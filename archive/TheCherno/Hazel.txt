Project Path: arc_TheCherno_Hazel_pph5soo9

Source Tree:

```txt
arc_TheCherno_Hazel_pph5soo9
├── Dependencies.lua
├── Hazel
│   ├── premake5.lua
│   ├── src
│   │   ├── Hazel
│   │   │   ├── Core
│   │   │   │   ├── Application.cpp
│   │   │   │   ├── Application.h
│   │   │   │   ├── Assert.h
│   │   │   │   ├── Base.h
│   │   │   │   ├── Buffer.h
│   │   │   │   ├── EntryPoint.h
│   │   │   │   ├── FileSystem.cpp
│   │   │   │   ├── FileSystem.h
│   │   │   │   ├── Input.h
│   │   │   │   ├── KeyCodes.h
│   │   │   │   ├── Layer.cpp
│   │   │   │   ├── Layer.h
│   │   │   │   ├── LayerStack.cpp
│   │   │   │   ├── LayerStack.h
│   │   │   │   ├── Log.cpp
│   │   │   │   ├── Log.h
│   │   │   │   ├── MouseCodes.h
│   │   │   │   ├── PlatformDetection.h
│   │   │   │   ├── Timer.h
│   │   │   │   ├── Timestep.h
│   │   │   │   ├── UUID.cpp
│   │   │   │   ├── UUID.h
│   │   │   │   ├── Window.cpp
│   │   │   │   └── Window.h
│   │   │   ├── Debug
│   │   │   │   └── Instrumentor.h
│   │   │   ├── Events
│   │   │   │   ├── ApplicationEvent.h
│   │   │   │   ├── Event.h
│   │   │   │   ├── KeyEvent.h
│   │   │   │   └── MouseEvent.h
│   │   │   ├── ImGui
│   │   │   │   ├── ImGuiBuild.cpp
│   │   │   │   ├── ImGuiLayer.cpp
│   │   │   │   └── ImGuiLayer.h
│   │   │   ├── Math
│   │   │   │   ├── Math.cpp
│   │   │   │   └── Math.h
│   │   │   ├── Physics
│   │   │   │   └── Physics2D.h
│   │   │   ├── Project
│   │   │   │   ├── Project.cpp
│   │   │   │   ├── Project.h
│   │   │   │   ├── ProjectSerializer.cpp
│   │   │   │   └── ProjectSerializer.h
│   │   │   ├── Renderer
│   │   │   │   ├── Buffer.cpp
│   │   │   │   ├── Buffer.h
│   │   │   │   ├── Camera.h
│   │   │   │   ├── EditorCamera.cpp
│   │   │   │   ├── EditorCamera.h
│   │   │   │   ├── Font.cpp
│   │   │   │   ├── Font.h
│   │   │   │   ├── Framebuffer.cpp
│   │   │   │   ├── Framebuffer.h
│   │   │   │   ├── GraphicsContext.cpp
│   │   │   │   ├── GraphicsContext.h
│   │   │   │   ├── MSDFData.h
│   │   │   │   ├── OrthographicCamera.cpp
│   │   │   │   ├── OrthographicCamera.h
│   │   │   │   ├── OrthographicCameraController.cpp
│   │   │   │   ├── OrthographicCameraController.h
│   │   │   │   ├── RenderCommand.cpp
│   │   │   │   ├── RenderCommand.h
│   │   │   │   ├── Renderer.cpp
│   │   │   │   ├── Renderer.h
│   │   │   │   ├── Renderer2D.cpp
│   │   │   │   ├── Renderer2D.h
│   │   │   │   ├── RendererAPI.cpp
│   │   │   │   ├── RendererAPI.h
│   │   │   │   ├── Shader.cpp
│   │   │   │   ├── Shader.h
│   │   │   │   ├── Texture.cpp
│   │   │   │   ├── Texture.h
│   │   │   │   ├── UniformBuffer.cpp
│   │   │   │   ├── UniformBuffer.h
│   │   │   │   ├── VertexArray.cpp
│   │   │   │   └── VertexArray.h
│   │   │   ├── Scene
│   │   │   │   ├── Components.h
│   │   │   │   ├── Entity.cpp
│   │   │   │   ├── Entity.h
│   │   │   │   ├── Scene.cpp
│   │   │   │   ├── Scene.h
│   │   │   │   ├── SceneCamera.cpp
│   │   │   │   ├── SceneCamera.h
│   │   │   │   ├── SceneSerializer.cpp
│   │   │   │   ├── SceneSerializer.h
│   │   │   │   └── ScriptableEntity.h
│   │   │   ├── Scripting
│   │   │   │   ├── ScriptEngine.cpp
│   │   │   │   ├── ScriptEngine.h
│   │   │   │   ├── ScriptGlue.cpp
│   │   │   │   └── ScriptGlue.h
│   │   │   ├── UI
│   │   │   │   └── UI.h
│   │   │   └── Utils
│   │   │       └── PlatformUtils.h
│   │   ├── Hazel.h
│   │   ├── Platform
│   │   │   ├── OpenGL
│   │   │   │   ├── OpenGLBuffer.cpp
│   │   │   │   ├── OpenGLBuffer.h
│   │   │   │   ├── OpenGLContext.cpp
│   │   │   │   ├── OpenGLContext.h
│   │   │   │   ├── OpenGLFramebuffer.cpp
│   │   │   │   ├── OpenGLFramebuffer.h
│   │   │   │   ├── OpenGLRendererAPI.cpp
│   │   │   │   ├── OpenGLRendererAPI.h
│   │   │   │   ├── OpenGLShader.cpp
│   │   │   │   ├── OpenGLShader.h
│   │   │   │   ├── OpenGLTexture.cpp
│   │   │   │   ├── OpenGLTexture.h
│   │   │   │   ├── OpenGLUniformBuffer.cpp
│   │   │   │   ├── OpenGLUniformBuffer.h
│   │   │   │   ├── OpenGLVertexArray.cpp
│   │   │   │   └── OpenGLVertexArray.h
│   │   │   └── Windows
│   │   │       ├── WindowsInput.cpp
│   │   │       ├── WindowsPlatformUtils.cpp
│   │   │       ├── WindowsWindow.cpp
│   │   │       └── WindowsWindow.h
│   │   ├── hzpch.cpp
│   │   └── hzpch.h
│   └── vendor
│       ├── Box2D
│       ├── GLFW
│       ├── Glad
│       │   ├── include
│       │   │   ├── KHR
│       │   │   │   └── khrplatform.h
│       │   │   └── glad
│       │   │       └── glad.h
│       │   ├── premake5.lua
│       │   └── src
│       │       └── glad.c
│       ├── ImGuizmo
│       ├── entt
│       │   ├── LICENSE.txt
│       │   └── include
│       │       └── entt.hpp
│       ├── filewatch
│       │   └── FileWatch.h
│       ├── glm
│       ├── imgui
│       ├── mono
│       │   ├── LICENSE
│       │   ├── README.md
│       │   ├── include
│       │   │   └── mono
│       │   │       ├── jit
│       │   │       │   └── jit.h
│       │   │       ├── metadata
│       │   │       │   ├── abi-details.h
│       │   │       │   ├── appdomain-icalls.h
│       │   │       │   ├── appdomain.h
│       │   │       │   ├── assembly-internals.h
│       │   │       │   ├── assembly.h
│       │   │       │   ├── attach.h
│       │   │       │   ├── attrdefs.h
│       │   │       │   ├── blob.h
│       │   │       │   ├── callspec.h
│       │   │       │   ├── cil-coff.h
│       │   │       │   ├── class-abi-details.h
│       │   │       │   ├── class-getters.h
│       │   │       │   ├── class-init.h
│       │   │       │   ├── class-inlines.h
│       │   │       │   ├── class-internals.h
│       │   │       │   ├── class-private-definition.h
│       │   │       │   ├── class.h
│       │   │       │   ├── cominterop-win32-internals.h
│       │   │       │   ├── cominterop.h
│       │   │       │   ├── console-io.h
│       │   │       │   ├── console-win32-internals.h
│       │   │       │   ├── coree-internals.h
│       │   │       │   ├── coree.h
│       │   │       │   ├── culture-info-tables.h
│       │   │       │   ├── culture-info.h
│       │   │       │   ├── custom-attrs-internals.h
│       │   │       │   ├── debug-helpers.h
│       │   │       │   ├── debug-internals.h
│       │   │       │   ├── debug-mono-ppdb.h
│       │   │       │   ├── debug-mono-symfile.h
│       │   │       │   ├── domain-internals.h
│       │   │       │   ├── dynamic-image-internals.h
│       │   │       │   ├── dynamic-stream-internals.h
│       │   │       │   ├── environment.h
│       │   │       │   ├── exception-internals.h
│       │   │       │   ├── exception.h
│       │   │       │   ├── external-only.h
│       │   │       │   ├── fdhandle.h
│       │   │       │   ├── file-mmap.h
│       │   │       │   ├── filewatcher.h
│       │   │       │   ├── gc-internals.h
│       │   │       │   ├── handle-decl.h
│       │   │       │   ├── handle.h
│       │   │       │   ├── icall-decl.h
│       │   │       │   ├── icall-def-netcore.h
│       │   │       │   ├── icall-def.h
│       │   │       │   ├── icall-internals.h
│       │   │       │   ├── icall-signatures.h
│       │   │       │   ├── icall-table.h
│       │   │       │   ├── icall-windows-internals.h
│       │   │       │   ├── icalls.h
│       │   │       │   ├── image-internals.h
│       │   │       │   ├── image.h
│       │   │       │   ├── jit-icall-reg.h
│       │   │       │   ├── loaded-images-internals.h
│       │   │       │   ├── loader-internals.h
│       │   │       │   ├── loader.h
│       │   │       │   ├── locales.h
│       │   │       │   ├── lock-tracer.h
│       │   │       │   ├── marshal-ilgen.h
│       │   │       │   ├── marshal-internals.h
│       │   │       │   ├── marshal-windows-internals.h
│       │   │       │   ├── marshal.h
│       │   │       │   ├── mempool-internals.h
│       │   │       │   ├── mempool.h
│       │   │       │   ├── metadata-internals.h
│       │   │       │   ├── metadata.h
│       │   │       │   ├── method-builder-ilgen-internals.h
│       │   │       │   ├── method-builder-ilgen.h
│       │   │       │   ├── method-builder-internals.h
│       │   │       │   ├── method-builder.h
│       │   │       │   ├── monitor.h
│       │   │       │   ├── mono-basic-block.h
│       │   │       │   ├── mono-conc-hash.h
│       │   │       │   ├── mono-config-dirs.h
│       │   │       │   ├── mono-config-internals.h
│       │   │       │   ├── mono-config.h
│       │   │       │   ├── mono-debug.h
│       │   │       │   ├── mono-endian.h
│       │   │       │   ├── mono-gc.h
│       │   │       │   ├── mono-hash-internals.h
│       │   │       │   ├── mono-hash.h
│       │   │       │   ├── mono-mlist.h
│       │   │       │   ├── mono-perfcounters-def.h
│       │   │       │   ├── mono-perfcounters.h
│       │   │       │   ├── mono-ptr-array.h
│       │   │       │   ├── mono-security-windows-internals.h
│       │   │       │   ├── normalization-tables.h
│       │   │       │   ├── null-gc-handles.h
│       │   │       │   ├── number-formatter.h
│       │   │       │   ├── number-ms.h
│       │   │       │   ├── object-forward.h
│       │   │       │   ├── object-internals.h
│       │   │       │   ├── object-offsets.h
│       │   │       │   ├── object.h
│       │   │       │   ├── opcodes.h
│       │   │       │   ├── pal-ios.h
│       │   │       │   ├── profiler-events.h
│       │   │       │   ├── profiler-legacy.h
│       │   │       │   ├── profiler-private.h
│       │   │       │   ├── profiler.h
│       │   │       │   ├── property-bag.h
│       │   │       │   ├── rand.h
│       │   │       │   ├── reflection-cache.h
│       │   │       │   ├── reflection-internals.h
│       │   │       │   ├── reflection.h
│       │   │       │   ├── remoting.h
│       │   │       │   ├── row-indexes.h
│       │   │       │   ├── runtime.h
│       │   │       │   ├── security-core-clr.h
│       │   │       │   ├── security-manager.h
│       │   │       │   ├── security.h
│       │   │       │   ├── seq-points-data.h
│       │   │       │   ├── sgen-bridge-internals.h
│       │   │       │   ├── sgen-bridge.h
│       │   │       │   ├── sgen-client-mono.h
│       │   │       │   ├── sgen-dynarray.h
│       │   │       │   ├── sgen-mono-ilgen.h
│       │   │       │   ├── sgen-mono.h
│       │   │       │   ├── sgen-toggleref.h
│       │   │       │   ├── sre-internals.h
│       │   │       │   ├── string-icalls.h
│       │   │       │   ├── tabledefs.h
│       │   │       │   ├── threadpool-io.h
│       │   │       │   ├── threadpool-worker.h
│       │   │       │   ├── threadpool.h
│       │   │       │   ├── threads-types.h
│       │   │       │   ├── threads.h
│       │   │       │   ├── tokentype.h
│       │   │       │   ├── verify-internals.h
│       │   │       │   ├── verify.h
│       │   │       │   ├── w32error.h
│       │   │       │   ├── w32event.h
│       │   │       │   ├── w32file-internals.h
│       │   │       │   ├── w32file-unix-glob.h
│       │   │       │   ├── w32file-win32-internals.h
│       │   │       │   ├── w32file.h
│       │   │       │   ├── w32handle-namespace.h
│       │   │       │   ├── w32handle.h
│       │   │       │   ├── w32mutex.h
│       │   │       │   ├── w32process-internals.h
│       │   │       │   ├── w32process-unix-internals.h
│       │   │       │   ├── w32process.h
│       │   │       │   ├── w32semaphore.h
│       │   │       │   ├── w32socket-internals.h
│       │   │       │   ├── w32socket.h
│       │   │       │   ├── w32subset.h
│       │   │       │   └── wrapper-types.h
│       │   │       └── utils
│       │   │           ├── mono-counters.h
│       │   │           ├── mono-dl-fallback.h
│       │   │           ├── mono-error.h
│       │   │           ├── mono-forward.h
│       │   │           ├── mono-logger.h
│       │   │           └── mono-publib.h
│       │   └── lib
│       │       ├── Debug
│       │       │   └── libmono-static-sgen.lib
│       │       └── Release
│       │           └── libmono-static-sgen.lib
│       ├── msdf-atlas-gen
│       ├── spdlog
│       ├── stb_image
│       │   ├── stb_image.cpp
│       │   └── stb_image.h
│       └── yaml-cpp
├── Hazel-ScriptCore
│   ├── Source
│   │   └── Hazel
│   │       ├── Input.cs
│   │       ├── InternalCalls.cs
│   │       ├── KeyCode.cs
│   │       ├── Scene
│   │       │   ├── Components.cs
│   │       │   └── Entity.cs
│   │       ├── Vector2.cs
│   │       ├── Vector3.cs
│   │       └── Vector4.cs
│   └── premake5.lua
├── Hazelnut
│   ├── Resources
│   │   └── Icons
│   │       ├── ContentBrowser
│   │       │   ├── DirectoryIcon.png
│   │       │   └── FileIcon.png
│   │       ├── PauseButton.png
│   │       ├── PlayButton.png
│   │       ├── SimulateButton.png
│   │       ├── StepButton.png
│   │       └── StopButton.png
│   ├── SandboxProject
│   │   ├── Assets
│   │   │   ├── Scenes
│   │   │   │   ├── 3DExample.hazel
│   │   │   │   ├── Example.hazel
│   │   │   │   ├── Physics2D.hazel
│   │   │   │   └── PinkCube.hazel
│   │   │   ├── Scripts
│   │   │   │   ├── Source
│   │   │   │   │   ├── Camera.cs
│   │   │   │   │   └── Player.cs
│   │   │   │   ├── Win-GenProjects.bat
│   │   │   │   └── premake5.lua
│   │   │   └── Textures
│   │   │       ├── Checkerboard.png
│   │   │       └── ChernoLogo.png
│   │   └── Sandbox.hproj
│   ├── assets
│   │   ├── fonts
│   │   │   └── opensans
│   │   │       ├── LICENSE.txt
│   │   │       ├── OpenSans-Bold.ttf
│   │   │       ├── OpenSans-BoldItalic.ttf
│   │   │       ├── OpenSans-ExtraBold.ttf
│   │   │       ├── OpenSans-ExtraBoldItalic.ttf
│   │   │       ├── OpenSans-Italic.ttf
│   │   │       ├── OpenSans-Light.ttf
│   │   │       ├── OpenSans-LightItalic.ttf
│   │   │       ├── OpenSans-Regular.ttf
│   │   │       ├── OpenSans-SemiBold.ttf
│   │   │       └── OpenSans-SemiBoldItalic.ttf
│   │   └── shaders
│   │       ├── FlatColor.glsl
│   │       ├── Renderer2D_Circle.glsl
│   │       ├── Renderer2D_Line.glsl
│   │       ├── Renderer2D_Quad.glsl
│   │       └── Renderer2D_Text.glsl
│   ├── imgui.ini
│   ├── mono
│   │   └── lib
│   │       └── mono
│   │           └── 4.5
│   │               ├── Accessibility.dll
│   │               ├── Commons.Xml.Relaxng.dll
│   │               ├── CustomMarshalers.dll
│   │               ├── Facades
│   │               │   ├── Microsoft.Win32.Primitives.dll
│   │               │   ├── Microsoft.Win32.Registry.AccessControl.dll
│   │               │   ├── Microsoft.Win32.Registry.AccessControl.pdb
│   │               │   ├── Microsoft.Win32.Registry.dll
│   │               │   ├── System.AppContext.dll
│   │               │   ├── System.Collections.Concurrent.dll
│   │               │   ├── System.Collections.NonGeneric.dll
│   │               │   ├── System.Collections.Specialized.dll
│   │               │   ├── System.Collections.dll
│   │               │   ├── System.ComponentModel.Annotations.dll
│   │               │   ├── System.ComponentModel.EventBasedAsync.dll
│   │               │   ├── System.ComponentModel.Primitives.dll
│   │               │   ├── System.ComponentModel.TypeConverter.dll
│   │               │   ├── System.ComponentModel.dll
│   │               │   ├── System.Console.dll
│   │               │   ├── System.Data.Common.dll
│   │               │   ├── System.Data.SqlClient.dll
│   │               │   ├── System.Diagnostics.Contracts.dll
│   │               │   ├── System.Diagnostics.Debug.dll
│   │               │   ├── System.Diagnostics.FileVersionInfo.dll
│   │               │   ├── System.Diagnostics.Process.dll
│   │               │   ├── System.Diagnostics.StackTrace.dll
│   │               │   ├── System.Diagnostics.TextWriterTraceListener.dll
│   │               │   ├── System.Diagnostics.Tools.dll
│   │               │   ├── System.Diagnostics.TraceEvent.dll
│   │               │   ├── System.Diagnostics.TraceSource.dll
│   │               │   ├── System.Diagnostics.Tracing.dll
│   │               │   ├── System.Drawing.Primitives.dll
│   │               │   ├── System.Dynamic.Runtime.dll
│   │               │   ├── System.Globalization.Calendars.dll
│   │               │   ├── System.Globalization.Extensions.dll
│   │               │   ├── System.Globalization.dll
│   │               │   ├── System.IO.Compression.ZipFile.dll
│   │               │   ├── System.IO.FileSystem.AccessControl.dll
│   │               │   ├── System.IO.FileSystem.AccessControl.pdb
│   │               │   ├── System.IO.FileSystem.DriveInfo.dll
│   │               │   ├── System.IO.FileSystem.Primitives.dll
│   │               │   ├── System.IO.FileSystem.Watcher.dll
│   │               │   ├── System.IO.FileSystem.dll
│   │               │   ├── System.IO.IsolatedStorage.dll
│   │               │   ├── System.IO.MemoryMappedFiles.dll
│   │               │   ├── System.IO.Pipes.dll
│   │               │   ├── System.IO.UnmanagedMemoryStream.dll
│   │               │   ├── System.IO.dll
│   │               │   ├── System.Linq.Expressions.dll
│   │               │   ├── System.Linq.Parallel.dll
│   │               │   ├── System.Linq.Queryable.dll
│   │               │   ├── System.Linq.dll
│   │               │   ├── System.Net.AuthenticationManager.dll
│   │               │   ├── System.Net.Cache.dll
│   │               │   ├── System.Net.Http.Rtc.dll
│   │               │   ├── System.Net.HttpListener.dll
│   │               │   ├── System.Net.Mail.dll
│   │               │   ├── System.Net.NameResolution.dll
│   │               │   ├── System.Net.NetworkInformation.dll
│   │               │   ├── System.Net.Ping.dll
│   │               │   ├── System.Net.Primitives.dll
│   │               │   ├── System.Net.Requests.dll
│   │               │   ├── System.Net.Security.dll
│   │               │   ├── System.Net.ServicePoint.dll
│   │               │   ├── System.Net.Sockets.dll
│   │               │   ├── System.Net.Utilities.dll
│   │               │   ├── System.Net.WebHeaderCollection.dll
│   │               │   ├── System.Net.WebSockets.Client.dll
│   │               │   ├── System.Net.WebSockets.dll
│   │               │   ├── System.ObjectModel.dll
│   │               │   ├── System.Reflection.Emit.ILGeneration.dll
│   │               │   ├── System.Reflection.Emit.Lightweight.dll
│   │               │   ├── System.Reflection.Emit.dll
│   │               │   ├── System.Reflection.Extensions.dll
│   │               │   ├── System.Reflection.Primitives.dll
│   │               │   ├── System.Reflection.TypeExtensions.dll
│   │               │   ├── System.Reflection.TypeExtensions.pdb
│   │               │   ├── System.Reflection.dll
│   │               │   ├── System.Resources.Reader.dll
│   │               │   ├── System.Resources.ReaderWriter.dll
│   │               │   ├── System.Resources.ResourceManager.dll
│   │               │   ├── System.Resources.Writer.dll
│   │               │   ├── System.Runtime.CompilerServices.VisualC.dll
│   │               │   ├── System.Runtime.Extensions.dll
│   │               │   ├── System.Runtime.Handles.dll
│   │               │   ├── System.Runtime.InteropServices.RuntimeInformation.dll
│   │               │   ├── System.Runtime.InteropServices.WindowsRuntime.dll
│   │               │   ├── System.Runtime.InteropServices.dll
│   │               │   ├── System.Runtime.Numerics.dll
│   │               │   ├── System.Runtime.Serialization.Formatters.dll
│   │               │   ├── System.Runtime.Serialization.Json.dll
│   │               │   ├── System.Runtime.Serialization.Primitives.dll
│   │               │   ├── System.Runtime.Serialization.Xml.dll
│   │               │   ├── System.Runtime.dll
│   │               │   ├── System.Security.AccessControl.dll
│   │               │   ├── System.Security.Claims.dll
│   │               │   ├── System.Security.Cryptography.Algorithms.dll
│   │               │   ├── System.Security.Cryptography.Csp.dll
│   │               │   ├── System.Security.Cryptography.DeriveBytes.dll
│   │               │   ├── System.Security.Cryptography.Encoding.dll
│   │               │   ├── System.Security.Cryptography.Encryption.Aes.dll
│   │               │   ├── System.Security.Cryptography.Encryption.ECDiffieHellman.dll
│   │               │   ├── System.Security.Cryptography.Encryption.ECDsa.dll
│   │               │   ├── System.Security.Cryptography.Encryption.dll
│   │               │   ├── System.Security.Cryptography.Hashing.Algorithms.dll
│   │               │   ├── System.Security.Cryptography.Hashing.dll
│   │               │   ├── System.Security.Cryptography.Primitives.dll
│   │               │   ├── System.Security.Cryptography.ProtectedData.dll
│   │               │   ├── System.Security.Cryptography.RSA.dll
│   │               │   ├── System.Security.Cryptography.RandomNumberGenerator.dll
│   │               │   ├── System.Security.Cryptography.X509Certificates.dll
│   │               │   ├── System.Security.Principal.Windows.dll
│   │               │   ├── System.Security.Principal.dll
│   │               │   ├── System.Security.SecureString.dll
│   │               │   ├── System.ServiceModel.Duplex.dll
│   │               │   ├── System.ServiceModel.Http.dll
│   │               │   ├── System.ServiceModel.NetTcp.dll
│   │               │   ├── System.ServiceModel.Primitives.dll
│   │               │   ├── System.ServiceModel.Security.dll
│   │               │   ├── System.ServiceProcess.ServiceController.dll
│   │               │   ├── System.ServiceProcess.ServiceController.pdb
│   │               │   ├── System.Text.Encoding.CodePages.dll
│   │               │   ├── System.Text.Encoding.CodePages.pdb
│   │               │   ├── System.Text.Encoding.Extensions.dll
│   │               │   ├── System.Text.Encoding.dll
│   │               │   ├── System.Text.RegularExpressions.dll
│   │               │   ├── System.Threading.AccessControl.dll
│   │               │   ├── System.Threading.AccessControl.pdb
│   │               │   ├── System.Threading.Overlapped.dll
│   │               │   ├── System.Threading.Tasks.Parallel.dll
│   │               │   ├── System.Threading.Tasks.dll
│   │               │   ├── System.Threading.Thread.dll
│   │               │   ├── System.Threading.ThreadPool.dll
│   │               │   ├── System.Threading.Timer.dll
│   │               │   ├── System.Threading.dll
│   │               │   ├── System.ValueTuple.dll
│   │               │   ├── System.Xml.ReaderWriter.dll
│   │               │   ├── System.Xml.XDocument.dll
│   │               │   ├── System.Xml.XPath.XDocument.dll
│   │               │   ├── System.Xml.XPath.dll
│   │               │   ├── System.Xml.XmlDocument.dll
│   │               │   ├── System.Xml.XmlSerializer.dll
│   │               │   ├── System.Xml.Xsl.Primitives.dll
│   │               │   └── netstandard.dll
│   │               ├── I18N.CJK.dll
│   │               ├── I18N.MidEast.dll
│   │               ├── I18N.Other.dll
│   │               ├── I18N.Rare.dll
│   │               ├── I18N.West.dll
│   │               ├── I18N.dll
│   │               ├── IBM.Data.DB2.dll
│   │               ├── ICSharpCode.SharpZipLib.dll
│   │               ├── MSBuild
│   │               │   ├── Microsoft.Build.CommonTypes.xsd
│   │               │   └── Microsoft.Build.Core.xsd
│   │               ├── Microsoft.Build.Engine.dll
│   │               ├── Microsoft.Build.Framework.dll
│   │               ├── Microsoft.Build.Tasks.v4.0.dll
│   │               ├── Microsoft.Build.Utilities.v4.0.dll
│   │               ├── Microsoft.Build.dll
│   │               ├── Microsoft.Build.xsd
│   │               ├── Microsoft.CSharp.dll
│   │               ├── Microsoft.CSharp.targets
│   │               ├── Microsoft.CodeAnalysis.CSharp.Scripting.dll
│   │               ├── Microsoft.CodeAnalysis.CSharp.dll
│   │               ├── Microsoft.CodeAnalysis.Scripting.dll
│   │               ├── Microsoft.CodeAnalysis.VisualBasic.dll
│   │               ├── Microsoft.CodeAnalysis.dll
│   │               ├── Microsoft.Common.targets
│   │               ├── Microsoft.Common.tasks
│   │               ├── Microsoft.VisualBasic.dll
│   │               ├── Microsoft.VisualBasic.targets
│   │               ├── Microsoft.VisualC.dll
│   │               ├── Microsoft.Web.Infrastructure.dll
│   │               ├── Mono.Btls.Interface.dll
│   │               ├── Mono.CSharp.dll
│   │               ├── Mono.Cairo.dll
│   │               ├── Mono.Cecil.VB.Mdb.dll
│   │               ├── Mono.Cecil.VB.Pdb.dll
│   │               ├── Mono.Cecil.VB.dll
│   │               ├── Mono.CodeContracts.dll
│   │               ├── Mono.CompilerServices.SymbolWriter.dll
│   │               ├── Mono.Data.Sqlite.dll
│   │               ├── Mono.Data.Tds.dll
│   │               ├── Mono.Debugger.Soft.dll
│   │               ├── Mono.Http.dll
│   │               ├── Mono.Management.dll
│   │               ├── Mono.Messaging.RabbitMQ.dll
│   │               ├── Mono.Messaging.dll
│   │               ├── Mono.Parallel.dll
│   │               ├── Mono.Posix.dll
│   │               ├── Mono.Profiler.Log.dll
│   │               ├── Mono.Security.Win32.dll
│   │               ├── Mono.Security.dll
│   │               ├── Mono.Simd.dll
│   │               ├── Mono.Tasklets.dll
│   │               ├── Mono.WebBrowser.dll
│   │               ├── Mono.WebServer2.dll
│   │               ├── Mono.XBuild.Tasks.dll
│   │               ├── Novell.Directory.Ldap.dll
│   │               ├── PEAPI.dll
│   │               ├── RabbitMQ.Client.Apigen.exe
│   │               ├── RabbitMQ.Client.Apigen.pdb
│   │               ├── RabbitMQ.Client.dll
│   │               ├── SMDiagnostics.dll
│   │               ├── System.Collections.Immutable.dll
│   │               ├── System.ComponentModel.Composition.dll
│   │               ├── System.ComponentModel.DataAnnotations.dll
│   │               ├── System.Configuration.Install.dll
│   │               ├── System.Configuration.dll
│   │               ├── System.Core.dll
│   │               ├── System.Data.DataSetExtensions.dll
│   │               ├── System.Data.Entity.dll
│   │               ├── System.Data.Linq.dll
│   │               ├── System.Data.OracleClient.dll
│   │               ├── System.Data.Services.Client.dll
│   │               ├── System.Data.Services.dll
│   │               ├── System.Data.dll
│   │               ├── System.Deployment.dll
│   │               ├── System.Design.dll
│   │               ├── System.DirectoryServices.Protocols.dll
│   │               ├── System.DirectoryServices.dll
│   │               ├── System.Drawing.Design.dll
│   │               ├── System.Drawing.dll
│   │               ├── System.Dynamic.dll
│   │               ├── System.EnterpriseServices.dll
│   │               ├── System.IO.Compression.FileSystem.dll
│   │               ├── System.IO.Compression.dll
│   │               ├── System.IdentityModel.Selectors.dll
│   │               ├── System.IdentityModel.dll
│   │               ├── System.Json.Microsoft.dll
│   │               ├── System.Json.dll
│   │               ├── System.Management.dll
│   │               ├── System.Memory.dll
│   │               ├── System.Messaging.dll
│   │               ├── System.Net.Http.Formatting.dll
│   │               ├── System.Net.Http.WebRequest.dll
│   │               ├── System.Net.Http.dll
│   │               ├── System.Net.dll
│   │               ├── System.Numerics.Vectors.dll
│   │               ├── System.Numerics.dll
│   │               ├── System.Reactive.Core.dll
│   │               ├── System.Reactive.Debugger.dll
│   │               ├── System.Reactive.Experimental.dll
│   │               ├── System.Reactive.Interfaces.dll
│   │               ├── System.Reactive.Linq.dll
│   │               ├── System.Reactive.Observable.Aliases.dll
│   │               ├── System.Reactive.PlatformServices.dll
│   │               ├── System.Reactive.Providers.dll
│   │               ├── System.Reactive.Runtime.Remoting.dll
│   │               ├── System.Reactive.Windows.Forms.dll
│   │               ├── System.Reactive.Windows.Threading.dll
│   │               ├── System.Reflection.Context.dll
│   │               ├── System.Reflection.Metadata.dll
│   │               ├── System.Runtime.Caching.dll
│   │               ├── System.Runtime.CompilerServices.Unsafe.dll
│   │               ├── System.Runtime.DurableInstancing.dll
│   │               ├── System.Runtime.Remoting.dll
│   │               ├── System.Runtime.Serialization.Formatters.Soap.dll
│   │               ├── System.Runtime.Serialization.dll
│   │               ├── System.Security.dll
│   │               ├── System.ServiceModel.Activation.dll
│   │               ├── System.ServiceModel.Discovery.dll
│   │               ├── System.ServiceModel.Internals.dll
│   │               ├── System.ServiceModel.Routing.dll
│   │               ├── System.ServiceModel.Web.dll
│   │               ├── System.ServiceModel.dll
│   │               ├── System.ServiceProcess.dll
│   │               ├── System.Threading.Tasks.Dataflow.dll
│   │               ├── System.Threading.Tasks.Extensions.dll
│   │               ├── System.Transactions.dll
│   │               ├── System.Web.Abstractions.dll
│   │               ├── System.Web.ApplicationServices.dll
│   │               ├── System.Web.DynamicData.dll
│   │               ├── System.Web.Extensions.Design.dll
│   │               ├── System.Web.Extensions.dll
│   │               ├── System.Web.Http.SelfHost.dll
│   │               ├── System.Web.Http.WebHost.dll
│   │               ├── System.Web.Http.dll
│   │               ├── System.Web.Mobile.dll
│   │               ├── System.Web.Mvc.dll
│   │               ├── System.Web.Razor.dll
│   │               ├── System.Web.RegularExpressions.dll
│   │               ├── System.Web.Routing.dll
│   │               ├── System.Web.Services.dll
│   │               ├── System.Web.WebPages.Deployment.dll
│   │               ├── System.Web.WebPages.Razor.dll
│   │               ├── System.Web.WebPages.dll
│   │               ├── System.Web.dll
│   │               ├── System.Windows.Forms.DataVisualization.dll
│   │               ├── System.Windows.Forms.dll
│   │               ├── System.Windows.dll
│   │               ├── System.Workflow.Activities.dll
│   │               ├── System.Workflow.ComponentModel.dll
│   │               ├── System.Workflow.Runtime.dll
│   │               ├── System.Xaml.dll
│   │               ├── System.Xml.Linq.dll
│   │               ├── System.Xml.Serialization.dll
│   │               ├── System.Xml.dll
│   │               ├── System.dll
│   │               ├── VBCSCompiler.exe
│   │               ├── VBCSCompiler.exe.config
│   │               ├── WebMatrix.Data.dll
│   │               ├── WindowsBase.dll
│   │               ├── al.exe
│   │               ├── al.pdb
│   │               ├── aprofutil.exe
│   │               ├── aprofutil.pdb
│   │               ├── browsercaps-updater.exe
│   │               ├── browsercaps-updater.pdb
│   │               ├── caspol.exe
│   │               ├── caspol.pdb
│   │               ├── cccheck.exe
│   │               ├── cccheck.pdb
│   │               ├── ccrewrite.exe
│   │               ├── ccrewrite.pdb
│   │               ├── cert-sync.exe
│   │               ├── cert-sync.pdb
│   │               ├── cert2spc.exe
│   │               ├── cert2spc.pdb
│   │               ├── certmgr.exe
│   │               ├── certmgr.pdb
│   │               ├── chktrust.exe
│   │               ├── chktrust.pdb
│   │               ├── crlupdate.exe
│   │               ├── crlupdate.pdb
│   │               ├── csc.exe
│   │               ├── csc.exe.config
│   │               ├── csc.rsp
│   │               ├── cscompmgd.dll
│   │               ├── csharp.exe
│   │               ├── csharp.pdb
│   │               ├── csi.exe
│   │               ├── csi.exe.config
│   │               ├── csi.rsp
│   │               ├── culevel.exe
│   │               ├── culevel.pdb
│   │               ├── disco.exe
│   │               ├── disco.pdb
│   │               ├── dtd2rng.exe
│   │               ├── dtd2rng.pdb
│   │               ├── dtd2xsd.exe
│   │               ├── dtd2xsd.pdb
│   │               ├── fastcgi-mono-server4.exe
│   │               ├── gacutil.exe
│   │               ├── gacutil.pdb
│   │               ├── genxs.exe
│   │               ├── genxs.pdb
│   │               ├── httpcfg.exe
│   │               ├── httpcfg.pdb
│   │               ├── ictool.exe
│   │               ├── ictool.pdb
│   │               ├── ikdasm.exe
│   │               ├── ikdasm.pdb
│   │               ├── ilasm.exe
│   │               ├── ilasm.pdb
│   │               ├── illinkanalyzer.exe
│   │               ├── illinkanalyzer.pdb
│   │               ├── installutil.exe
│   │               ├── installutil.pdb
│   │               ├── installvst.exe
│   │               ├── installvst.pdb
│   │               ├── lc.exe
│   │               ├── lc.pdb
│   │               ├── macpack.exe
│   │               ├── macpack.pdb
│   │               ├── makecert.exe
│   │               ├── makecert.pdb
│   │               ├── mconfig.exe
│   │               ├── mconfig.pdb
│   │               ├── mcs.exe
│   │               ├── mcs.pdb
│   │               ├── mdbrebase.exe
│   │               ├── mdbrebase.pdb
│   │               ├── mdoc.exe
│   │               ├── mdoc.pdb
│   │               ├── mkbundle.exe
│   │               ├── mkbundle.pdb
│   │               ├── mod-mono-server4.exe
│   │               ├── mod.exe
│   │               ├── mod.pdb
│   │               ├── mono-api-diff.exe
│   │               ├── mono-api-diff.pdb
│   │               ├── mono-api-html.exe
│   │               ├── mono-api-html.pdb
│   │               ├── mono-api-info.exe
│   │               ├── mono-api-info.pdb
│   │               ├── mono-cil-strip.exe
│   │               ├── mono-cil-strip.pdb
│   │               ├── mono-fpm.exe
│   │               ├── mono-service.exe
│   │               ├── mono-service.pdb
│   │               ├── mono-shlib-cop.exe
│   │               ├── mono-shlib-cop.exe.config
│   │               ├── mono-shlib-cop.pdb
│   │               ├── mono-symbolicate.exe
│   │               ├── mono-symbolicate.pdb
│   │               ├── mono-xmltool.exe
│   │               ├── mono-xmltool.pdb
│   │               ├── monolinker.exe
│   │               ├── monolinker.pdb
│   │               ├── monop.exe
│   │               ├── monop.pdb
│   │               ├── mozroots.exe
│   │               ├── mozroots.pdb
│   │               ├── mscorlib.dll
│   │               ├── mscorlib.pdb
│   │               ├── pdb2mdb.exe
│   │               ├── pdb2mdb.pdb
│   │               ├── permview.exe
│   │               ├── permview.pdb
│   │               ├── resgen.exe
│   │               ├── resgen.pdb
│   │               ├── secutil.exe
│   │               ├── secutil.pdb
│   │               ├── setreg.exe
│   │               ├── setreg.pdb
│   │               ├── sgen.exe
│   │               ├── sgen.pdb
│   │               ├── signcode.exe
│   │               ├── signcode.pdb
│   │               ├── sn.exe
│   │               ├── sn.pdb
│   │               ├── soapsuds.exe
│   │               ├── soapsuds.pdb
│   │               ├── sqlmetal.exe
│   │               ├── sqlmetal.exe.config
│   │               ├── sqlmetal.pdb
│   │               ├── sqlsharp.exe
│   │               ├── sqlsharp.pdb
│   │               ├── svcutil.exe
│   │               ├── svcutil.pdb
│   │               ├── vbc.exe
│   │               ├── vbc.exe.config
│   │               ├── vbc.rsp
│   │               ├── vbnc.exe
│   │               ├── vbnc.exe.mdb
│   │               ├── vbnc.rsp
│   │               ├── wsdl.exe
│   │               ├── wsdl.pdb
│   │               ├── xbuild.exe
│   │               ├── xbuild.exe.config
│   │               ├── xbuild.pdb
│   │               ├── xbuild.rsp
│   │               ├── xsd.exe
│   │               ├── xsd.pdb
│   │               └── xsp4.exe
│   ├── premake5.lua
│   └── src
│       ├── EditorLayer.cpp
│       ├── EditorLayer.h
│       ├── HazelnutApp.cpp
│       └── Panels
│           ├── ContentBrowserPanel.cpp
│           ├── ContentBrowserPanel.h
│           ├── SceneHierarchyPanel.cpp
│           └── SceneHierarchyPanel.h
├── LICENSE
├── README.md
├── Resources
│   └── Branding
│       └── Hazel_Logo_Text_Light_Square.png
├── Sandbox
│   ├── assets
│   │   ├── fonts
│   │   │   └── opensans
│   │   │       ├── LICENSE.txt
│   │   │       ├── OpenSans-Bold.ttf
│   │   │       ├── OpenSans-BoldItalic.ttf
│   │   │       ├── OpenSans-ExtraBold.ttf
│   │   │       ├── OpenSans-ExtraBoldItalic.ttf
│   │   │       ├── OpenSans-Italic.ttf
│   │   │       ├── OpenSans-Light.ttf
│   │   │       ├── OpenSans-LightItalic.ttf
│   │   │       ├── OpenSans-Regular.ttf
│   │   │       ├── OpenSans-SemiBold.ttf
│   │   │       └── OpenSans-SemiBoldItalic.ttf
│   │   ├── shaders
│   │   │   ├── FlatColor.glsl
│   │   │   └── Texture.glsl
│   │   └── textures
│   │       ├── Checkerboard.png
│   │       └── ChernoLogo.png
│   ├── imgui.ini
│   ├── premake5.lua
│   └── src
│       ├── ExampleLayer.cpp
│       ├── ExampleLayer.h
│       ├── Sandbox2D.cpp
│       ├── Sandbox2D.h
│       └── SandboxApp.cpp
├── premake5.lua
├── scripts
│   ├── Setup.bat
│   ├── Setup.py
│   ├── SetupPremake.py
│   ├── SetupPython.py
│   ├── SetupVulkan.py
│   ├── Utils.py
│   └── Win-GenProjects.bat
└── vendor
    └── premake
        ├── premake5.lua
        └── premake_customization
            └── solution_items.lua

```

`Dependencies.lua`:

```lua

-- Hazel Dependencies

VULKAN_SDK = os.getenv("VULKAN_SDK")

IncludeDir = {}
IncludeDir["stb_image"] = "%{wks.location}/Hazel/vendor/stb_image"
IncludeDir["yaml_cpp"] = "%{wks.location}/Hazel/vendor/yaml-cpp/include"
IncludeDir["Box2D"] = "%{wks.location}/Hazel/vendor/Box2D/include"
IncludeDir["filewatch"] = "%{wks.location}/Hazel/vendor/filewatch"
IncludeDir["GLFW"] = "%{wks.location}/Hazel/vendor/GLFW/include"
IncludeDir["Glad"] = "%{wks.location}/Hazel/vendor/Glad/include"
IncludeDir["ImGui"] = "%{wks.location}/Hazel/vendor/ImGui"
IncludeDir["ImGuizmo"] = "%{wks.location}/Hazel/vendor/ImGuizmo"
IncludeDir["glm"] = "%{wks.location}/Hazel/vendor/glm"
IncludeDir["entt"] = "%{wks.location}/Hazel/vendor/entt/include"
IncludeDir["mono"] = "%{wks.location}/Hazel/vendor/mono/include"
IncludeDir["shaderc"] = "%{wks.location}/Hazel/vendor/shaderc/include"
IncludeDir["SPIRV_Cross"] = "%{wks.location}/Hazel/vendor/SPIRV-Cross"
IncludeDir["VulkanSDK"] = "%{VULKAN_SDK}/Include"
IncludeDir["msdfgen"] = "%{wks.location}/Hazel/vendor/msdf-atlas-gen/msdfgen"
IncludeDir["msdf_atlas_gen"] = "%{wks.location}/Hazel/vendor/msdf-atlas-gen/msdf-atlas-gen"

LibraryDir = {}

LibraryDir["VulkanSDK"] = "%{VULKAN_SDK}/Lib"
LibraryDir["mono"] = "%{wks.location}/Hazel/vendor/mono/lib/%{cfg.buildcfg}"

Library = {}
Library["mono"] = "%{LibraryDir.mono}/libmono-static-sgen.lib"

Library["Vulkan"] = "%{LibraryDir.VulkanSDK}/vulkan-1.lib"
Library["VulkanUtils"] = "%{LibraryDir.VulkanSDK}/VkLayer_utils.lib"

Library["ShaderC_Debug"] = "%{LibraryDir.VulkanSDK}/shaderc_sharedd.lib"
Library["SPIRV_Cross_Debug"] = "%{LibraryDir.VulkanSDK}/spirv-cross-cored.lib"
Library["SPIRV_Cross_GLSL_Debug"] = "%{LibraryDir.VulkanSDK}/spirv-cross-glsld.lib"
Library["SPIRV_Tools_Debug"] = "%{LibraryDir.VulkanSDK}/SPIRV-Toolsd.lib"

Library["ShaderC_Release"] = "%{LibraryDir.VulkanSDK}/shaderc_shared.lib"
Library["SPIRV_Cross_Release"] = "%{LibraryDir.VulkanSDK}/spirv-cross-core.lib"
Library["SPIRV_Cross_GLSL_Release"] = "%{LibraryDir.VulkanSDK}/spirv-cross-glsl.lib"

-- Windows
Library["WinSock"] = "Ws2_32.lib"
Library["WinMM"] = "Winmm.lib"
Library["WinVersion"] = "Version.lib"
Library["BCrypt"] = "Bcrypt.lib"

```

`Hazel-ScriptCore/Source/Hazel/Input.cs`:

```cs
namespace Hazel
{
	public class Input
	{
		public static bool IsKeyDown(KeyCode keycode)
		{
			return InternalCalls.Input_IsKeyDown(keycode);
		}
	}
}

```

`Hazel-ScriptCore/Source/Hazel/InternalCalls.cs`:

```cs
using System;
using System.Runtime.CompilerServices;

namespace Hazel
{
	public static class InternalCalls
	{
		#region Entity
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static bool Entity_HasComponent(ulong entityID, Type componentType);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static ulong Entity_FindEntityByName(string name);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static object GetScriptInstance(ulong entityID);
		#endregion

		#region TransformComponent
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TransformComponent_GetTranslation(ulong entityID, out Vector3 translation);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TransformComponent_SetTranslation(ulong entityID, ref Vector3 translation);
		#endregion

		#region Rigidbody2DComponent
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void Rigidbody2DComponent_ApplyLinearImpulse(ulong entityID, ref Vector2 impulse, ref Vector2 point, bool wake);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void Rigidbody2DComponent_GetLinearVelocity(ulong entityID, out Vector2 linearVelocity);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static Rigidbody2DComponent.BodyType Rigidbody2DComponent_GetType(ulong entityID);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void Rigidbody2DComponent_SetType(ulong entityID, Rigidbody2DComponent.BodyType type);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void Rigidbody2DComponent_ApplyLinearImpulseToCenter(ulong entityID, ref Vector2 impulse, bool wake);
		#endregion

		#region TextComponent
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static string TextComponent_GetText(ulong entityID);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TextComponent_SetText(ulong entityID, string text);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TextComponent_GetColor(ulong entityID, out Vector4 color);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TextComponent_SetColor(ulong entityID, ref Vector4 color);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static float TextComponent_GetKerning(ulong entityID);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TextComponent_SetKerning(ulong entityID, float kerning);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static float TextComponent_GetLineSpacing(ulong entityID);
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static void TextComponent_SetLineSpacing(ulong entityID, float lineSpacing);
		#endregion

		#region Rigidbody2DComponent
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern static bool Input_IsKeyDown(KeyCode keycode);
		#endregion
	}
}

```

`Hazel-ScriptCore/Source/Hazel/KeyCode.cs`:

```cs
namespace Hazel
{
	public enum KeyCode
	{
		// From glfw3.h
		Space = 32,
		Apostrophe = 39, /* ' */
		Comma = 44, /* , */
		Minus = 45, /* - */
		Period = 46, /* . */
		Slash = 47, /* / */

		D0 = 48, /* 0 */
		D1 = 49, /* 1 */
		D2 = 50, /* 2 */
		D3 = 51, /* 3 */
		D4 = 52, /* 4 */
		D5 = 53, /* 5 */
		D6 = 54, /* 6 */
		D7 = 55, /* 7 */
		D8 = 56, /* 8 */
		D9 = 57, /* 9 */

		Semicolon = 59, /* ; */
		Equal = 61, /* = */

		A = 65,
		B = 66,
		C = 67,
		D = 68,
		E = 69,
		F = 70,
		G = 71,
		H = 72,
		I = 73,
		J = 74,
		K = 75,
		L = 76,
		M = 77,
		N = 78,
		O = 79,
		P = 80,
		Q = 81,
		R = 82,
		S = 83,
		T = 84,
		U = 85,
		V = 86,
		W = 87,
		X = 88,
		Y = 89,
		Z = 90,

		LeftBracket = 91,  /* [ */
		Backslash = 92,  /* \ */
		RightBracket = 93,  /* ] */
		GraveAccent = 96,  /* ` */

		World1 = 161, /* non-US #1 */
		World2 = 162, /* non-US #2 */

		/* Function keys */
		Escape = 256,
		Enter = 257,
		Tab = 258,
		Backspace = 259,
		Insert = 260,
		Delete = 261,
		Right = 262,
		Left = 263,
		Down = 264,
		Up = 265,
		PageUp = 266,
		PageDown = 267,
		Home = 268,
		End = 269,
		CapsLock = 280,
		ScrollLock = 281,
		NumLock = 282,
		PrintScreen = 283,
		Pause = 284,
		F1 = 290,
		F2 = 291,
		F3 = 292,
		F4 = 293,
		F5 = 294,
		F6 = 295,
		F7 = 296,
		F8 = 297,
		F9 = 298,
		F10 = 299,
		F11 = 300,
		F12 = 301,
		F13 = 302,
		F14 = 303,
		F15 = 304,
		F16 = 305,
		F17 = 306,
		F18 = 307,
		F19 = 308,
		F20 = 309,
		F21 = 310,
		F22 = 311,
		F23 = 312,
		F24 = 313,
		F25 = 314,

		/* Keypad */
		KP0 = 320,
		KP1 = 321,
		KP2 = 322,
		KP3 = 323,
		KP4 = 324,
		KP5 = 325,
		KP6 = 326,
		KP7 = 327,
		KP8 = 328,
		KP9 = 329,
		KPDecimal = 330,
		KPDivide = 331,
		KPMultiply = 332,
		KPSubtract = 333,
		KPAdd = 334,
		KPEnter = 335,
		KPEqual = 336,

		LeftShift = 340,
		LeftControl = 341,
		LeftAlt = 342,
		LeftSuper = 343,
		RightShift = 344,
		RightControl = 345,
		RightAlt = 346,
		RightSuper = 347,
		Menu = 348
	}

}

```

`Hazel-ScriptCore/Source/Hazel/Scene/Components.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Hazel
{
	public abstract class Component
	{
		public Entity Entity { get; internal set; }
	}

	public class TransformComponent : Component
	{
		public Vector3 Translation
		{
			get
			{
				InternalCalls.TransformComponent_GetTranslation(Entity.ID, out Vector3 translation);
				return translation;
			}
			set
			{
				InternalCalls.TransformComponent_SetTranslation(Entity.ID, ref value);
			}
		}
	}

	public class Rigidbody2DComponent : Component
	{
		public enum BodyType { Static = 0, Dynamic, Kinematic }

		public Vector2 LinearVelocity
		{
			get
			{
				InternalCalls.Rigidbody2DComponent_GetLinearVelocity(Entity.ID, out Vector2 velocity);
				return velocity;
			}
		}

		public BodyType Type
		{
			get => InternalCalls.Rigidbody2DComponent_GetType(Entity.ID);
			set => InternalCalls.Rigidbody2DComponent_SetType(Entity.ID, value);
		}

		public void ApplyLinearImpulse(Vector2 impulse, Vector2 worldPosition, bool wake)
		{
			InternalCalls.Rigidbody2DComponent_ApplyLinearImpulse(Entity.ID, ref impulse, ref worldPosition, wake);
		}

		public void ApplyLinearImpulse(Vector2 impulse, bool wake)
		{
			InternalCalls.Rigidbody2DComponent_ApplyLinearImpulseToCenter(Entity.ID, ref impulse, wake);
		}

	}

	public class TextComponent : Component
	{

		public string Text
		{
			get => InternalCalls.TextComponent_GetText(Entity.ID);
			set => InternalCalls.TextComponent_SetText(Entity.ID, value);
		}

		public Vector4 Color
		{
			get
			{
				InternalCalls.TextComponent_GetColor(Entity.ID, out Vector4 color);
				return color;
			}

			set
			{
				InternalCalls.TextComponent_SetColor(Entity.ID, ref value);
			}
		}

		public float Kerning
		{
			get => InternalCalls.TextComponent_GetKerning(Entity.ID);
			set => InternalCalls.TextComponent_SetKerning(Entity.ID, value);
		}

		public float LineSpacing
		{
			get => InternalCalls.TextComponent_GetLineSpacing(Entity.ID);
			set => InternalCalls.TextComponent_SetLineSpacing(Entity.ID, value);
		}

	}

}

```

`Hazel-ScriptCore/Source/Hazel/Scene/Entity.cs`:

```cs
using System;
using System.Runtime.CompilerServices;

namespace Hazel
{
	public class Entity
	{
		protected Entity() { ID = 0; } 

		internal Entity(ulong id)
		{
			ID = id;
		}

		public readonly ulong ID;

		public Vector3 Translation
		{
			get
			{
				InternalCalls.TransformComponent_GetTranslation(ID, out Vector3 result);
				return result;
			}
			set
			{
				InternalCalls.TransformComponent_SetTranslation(ID, ref value);
			}
		}

		public bool HasComponent<T>() where T : Component, new()
		{
			Type componentType = typeof(T);
			return InternalCalls.Entity_HasComponent(ID, componentType);
		}

		public T GetComponent<T>() where T : Component, new()
		{
			if (!HasComponent<T>())
				return null;

			T component = new T() { Entity = this };
			return component;
		}
		
		public Entity FindEntityByName(string name)
		{
			ulong entityID = InternalCalls.Entity_FindEntityByName(name);
			if (entityID == 0)
				return null;

			return new Entity(entityID);
		}

		public T As<T>() where T : Entity, new()
		{
			object instance = InternalCalls.GetScriptInstance(ID);
			return instance as T;
		}

	}

}

```

`Hazel-ScriptCore/Source/Hazel/Vector2.cs`:

```cs
using System;

namespace Hazel
{
	public struct Vector2
	{
		public float X, Y;

		public static Vector2 Zero => new Vector2(0.0f);

		public Vector2(float scalar)
		{
			X = scalar;
			Y = scalar;
		}

		public Vector2(float x, float y)
		{
			X = x;
			Y = y;
		}

		public static Vector2 operator +(Vector2 a, Vector2 b)
		{
			return new Vector2(a.X + b.X, a.Y + b.Y);
		}

		public static Vector2 operator *(Vector2 vector, float scalar)
		{
			return new Vector2(vector.X * scalar, vector.Y * scalar);
		}

		public float LengthSquared()
		{
			return X * X + Y * Y;
		}

		public float Length()
		{
			return (float)Math.Sqrt(LengthSquared());
		}


	}
}

```

`Hazel-ScriptCore/Source/Hazel/Vector3.cs`:

```cs
namespace Hazel
{
	public struct Vector3
	{
		public float X, Y, Z;

		public static Vector3 Zero => new Vector3(0.0f);

		public Vector3(float scalar)
		{
			X = scalar;
			Y = scalar;
			Z = scalar;
		}

		public Vector3(float x, float y, float z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		public Vector3(Vector2 xy, float z)
		{
			X = xy.X;
			Y = xy.Y;
			Z = z;
		}

		public Vector2 XY
		{
			get => new Vector2(X, Y);
			set
			{
				X = value.X;
				Y = value.Y;
			}
		}

		public static Vector3 operator +(Vector3 a, Vector3 b)
		{
			return new Vector3(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
		}

		public static Vector3 operator *(Vector3 vector, float scalar)
		{
			return new Vector3(vector.X * scalar, vector.Y * scalar, vector.Z * scalar);
		}

	}
}

```

`Hazel-ScriptCore/Source/Hazel/Vector4.cs`:

```cs
namespace Hazel
{
	public struct Vector4
	{
		public float X, Y, Z, W;

		public static Vector4 Zero => new Vector4(0.0f);

		public Vector4(float scalar)
		{
			X = scalar;
			Y = scalar;
			Z = scalar;
			W = scalar;
		}

		public Vector4(float x, float y, float z, float w)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}

		public Vector4(Vector3 xyz, float w)
		{
			X = xyz.X;
			Y = xyz.Y;
			Z = xyz.Z;
			W = w;
		}

		public Vector2 XY
		{
			get => new Vector2(X, Y);
			set
			{
				X = value.X;
				Y = value.Y;
			}
		}

		public Vector3 XYZ
		{
			get => new Vector3(X, Y, Z);
			set
			{
				X = value.X;
				Y = value.Y;
				Z = value.Z;
			}
		}

		public static Vector4 operator +(Vector4 a, Vector4 b)
		{
			return new Vector4(a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);
		}

		public static Vector4 operator *(Vector4 vector, float scalar)
		{
			return new Vector4(vector.X * scalar, vector.Y * scalar, vector.Z * scalar, vector.W * scalar);
		}

	}
}

```

`Hazel-ScriptCore/premake5.lua`:

```lua
project "Hazel-ScriptCore"
	kind "SharedLib"
	language "C#"
	dotnetframework "4.7.2"

	targetdir ("../Hazelnut/Resources/Scripts")
	objdir ("../Hazelnut/Resources/Scripts/Intermediates")

	files 
	{
		"Source/**.cs",
		"Properties/**.cs"
	}
	
	filter "configurations:Debug"
		optimize "Off"
		symbols "Default"

	filter "configurations:Release"
		optimize "On"
		symbols "Default"

	filter "configurations:Dist"
		optimize "Full"
		symbols "Off"

```

`Hazel/premake5.lua`:

```lua
project "Hazel"
	kind "StaticLib"
	language "C++"
	cppdialect "C++17"
	staticruntime "off"

	targetdir ("%{wks.location}/bin/" .. outputdir .. "/%{prj.name}")
	objdir ("%{wks.location}/bin-int/" .. outputdir .. "/%{prj.name}")

	pchheader "hzpch.h"
	pchsource "src/hzpch.cpp"

	files
	{
		"src/**.h",
		"src/**.cpp",
		"vendor/stb_image/**.h",
		"vendor/stb_image/**.cpp",
		"vendor/glm/glm/**.hpp",
		"vendor/glm/glm/**.inl",

		"vendor/ImGuizmo/ImGuizmo.h",
		"vendor/ImGuizmo/ImGuizmo.cpp"
	}

	defines
	{
		"_CRT_SECURE_NO_WARNINGS",
		"GLFW_INCLUDE_NONE"
	}

	includedirs
	{
		"src",
		"vendor/spdlog/include",
		"%{IncludeDir.Box2D}",
		"%{IncludeDir.filewatch}",
		"%{IncludeDir.GLFW}",
		"%{IncludeDir.Glad}",
		"%{IncludeDir.ImGui}",
		"%{IncludeDir.glm}",
		"%{IncludeDir.msdfgen}",
		"%{IncludeDir.msdf_atlas_gen}",
		"%{IncludeDir.stb_image}",
		"%{IncludeDir.entt}",
		"%{IncludeDir.mono}",
		"%{IncludeDir.yaml_cpp}",
		"%{IncludeDir.ImGuizmo}",
		"%{IncludeDir.VulkanSDK}"
	}

	links
	{
		"Box2D",
		"GLFW",
		"Glad",
		"ImGui",
		"msdf-atlas-gen",
		"yaml-cpp",
		"opengl32.lib",

		"%{Library.mono}",
	}

	filter "files:vendor/ImGuizmo/**.cpp"
	flags { "NoPCH" }

	filter "system:windows"
		systemversion "latest"

		defines
		{
		}

		links
		{
			"%{Library.WinSock}",
			"%{Library.WinMM}",
			"%{Library.WinVersion}",
			"%{Library.BCrypt}",
		}

	filter "configurations:Debug"
		defines "HZ_DEBUG"
		runtime "Debug"
		symbols "on"

		links
		{
			"%{Library.ShaderC_Debug}",
			"%{Library.SPIRV_Cross_Debug}",
			"%{Library.SPIRV_Cross_GLSL_Debug}"
		}

	filter "configurations:Release"
		defines "HZ_RELEASE"
		runtime "Release"
		optimize "on"

		links
		{
			"%{Library.ShaderC_Release}",
			"%{Library.SPIRV_Cross_Release}",
			"%{Library.SPIRV_Cross_GLSL_Release}"
		}

	filter "configurations:Dist"
		defines "HZ_DIST"
		runtime "Release"
		optimize "on"

		links
		{
			"%{Library.ShaderC_Release}",
			"%{Library.SPIRV_Cross_Release}",
			"%{Library.SPIRV_Cross_GLSL_Release}"
		}

```

`Hazel/src/Hazel.h`:

```h
#pragma once

// For use by Hazel applications

#include "Hazel/Core/Base.h"

#include "Hazel/Core/Application.h"
#include "Hazel/Core/Layer.h"
#include "Hazel/Core/Log.h"
#include "Hazel/Core/Assert.h"

#include "Hazel/Core/Timestep.h"

#include "Hazel/Core/Input.h"
#include "Hazel/Core/KeyCodes.h"
#include "Hazel/Core/MouseCodes.h"
#include "Hazel/Renderer/OrthographicCameraController.h"

#include "Hazel/ImGui/ImGuiLayer.h"

#include "Hazel/Scene/Scene.h"
#include "Hazel/Scene/Entity.h"
#include "Hazel/Scene/ScriptableEntity.h"
#include "Hazel/Scene/Components.h"

#include "Hazel/Project/Project.h"

// ---Renderer------------------------
#include "Hazel/Renderer/Renderer.h"
#include "Hazel/Renderer/Renderer2D.h"
#include "Hazel/Renderer/RenderCommand.h"

#include "Hazel/Renderer/Buffer.h"
#include "Hazel/Renderer/Shader.h"
#include "Hazel/Renderer/Framebuffer.h"
#include "Hazel/Renderer/Texture.h"
#include "Hazel/Renderer/VertexArray.h"

#include "Hazel/Renderer/OrthographicCamera.h"
// -----------------------------------

```

`Hazel/src/Hazel/Core/Application.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Core/Application.h"

#include "Hazel/Core/Log.h"

#include "Hazel/Renderer/Renderer.h"
#include "Hazel/Scripting/ScriptEngine.h"

#include "Hazel/Core/Input.h"
#include "Hazel/Utils/PlatformUtils.h"

namespace Hazel {

	Application* Application::s_Instance = nullptr;

	Application::Application(const ApplicationSpecification& specification)
		: m_Specification(specification)
	{
		HZ_PROFILE_FUNCTION();

		HZ_CORE_ASSERT(!s_Instance, "Application already exists!");
		s_Instance = this;

		// Set working directory here
		if (!m_Specification.WorkingDirectory.empty())
			std::filesystem::current_path(m_Specification.WorkingDirectory);

		m_Window = Window::Create(WindowProps(m_Specification.Name));
		m_Window->SetEventCallback(HZ_BIND_EVENT_FN(Application::OnEvent));

		Renderer::Init();

		m_ImGuiLayer = new ImGuiLayer();
		PushOverlay(m_ImGuiLayer);
	}

	Application::~Application()
	{
		HZ_PROFILE_FUNCTION();

		ScriptEngine::Shutdown();
		Renderer::Shutdown();
	}

	void Application::PushLayer(Layer* layer)
	{
		HZ_PROFILE_FUNCTION();

		m_LayerStack.PushLayer(layer);
		layer->OnAttach();
	}

	void Application::PushOverlay(Layer* layer)
	{
		HZ_PROFILE_FUNCTION();

		m_LayerStack.PushOverlay(layer);
		layer->OnAttach();
	}

	void Application::Close()
	{
		m_Running = false;
	}

	void Application::SubmitToMainThread(const std::function<void()>& function)
	{
		std::scoped_lock<std::mutex> lock(m_MainThreadQueueMutex);

		m_MainThreadQueue.emplace_back(function);
	}

	void Application::OnEvent(Event& e)
	{
		HZ_PROFILE_FUNCTION();

		EventDispatcher dispatcher(e);
		dispatcher.Dispatch<WindowCloseEvent>(HZ_BIND_EVENT_FN(Application::OnWindowClose));
		dispatcher.Dispatch<WindowResizeEvent>(HZ_BIND_EVENT_FN(Application::OnWindowResize));

		for (auto it = m_LayerStack.rbegin(); it != m_LayerStack.rend(); ++it)
		{
			if (e.Handled) 
				break;
			(*it)->OnEvent(e);
		}
	}

	void Application::Run()
	{
		HZ_PROFILE_FUNCTION();

		while (m_Running)
		{
			HZ_PROFILE_SCOPE("RunLoop");

			float time = Time::GetTime();
			Timestep timestep = time - m_LastFrameTime;
			m_LastFrameTime = time;

			ExecuteMainThreadQueue();

			if (!m_Minimized)
			{
				{
					HZ_PROFILE_SCOPE("LayerStack OnUpdate");

					for (Layer* layer : m_LayerStack)
						layer->OnUpdate(timestep);
				}

				m_ImGuiLayer->Begin();
				{
					HZ_PROFILE_SCOPE("LayerStack OnImGuiRender");

					for (Layer* layer : m_LayerStack)
						layer->OnImGuiRender();
				}
				m_ImGuiLayer->End();
			}

			m_Window->OnUpdate();
		}
	}

	bool Application::OnWindowClose(WindowCloseEvent& e)
	{
		m_Running = false;
		return true;
	}

	bool Application::OnWindowResize(WindowResizeEvent& e)
	{
		HZ_PROFILE_FUNCTION();

		if (e.GetWidth() == 0 || e.GetHeight() == 0)
		{
			m_Minimized = true;
			return false;
		}

		m_Minimized = false;
		Renderer::OnWindowResize(e.GetWidth(), e.GetHeight());

		return false;
	}

	void Application::ExecuteMainThreadQueue()
	{
		std::scoped_lock<std::mutex> lock(m_MainThreadQueueMutex);

		for (auto& func : m_MainThreadQueue)
			func();

		m_MainThreadQueue.clear();
	}

}

```

`Hazel/src/Hazel/Core/Application.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"

#include "Hazel/Core/Window.h"
#include "Hazel/Core/LayerStack.h"
#include "Hazel/Events/Event.h"
#include "Hazel/Events/ApplicationEvent.h"

#include "Hazel/Core/Timestep.h"

#include "Hazel/ImGui/ImGuiLayer.h"

int main(int argc, char** argv);

namespace Hazel {

	struct ApplicationCommandLineArgs
	{
		int Count = 0;
		char** Args = nullptr;

		const char* operator[](int index) const
		{
			HZ_CORE_ASSERT(index < Count);
			return Args[index];
		}
	};

	struct ApplicationSpecification
	{
		std::string Name = "Hazel Application";
		std::string WorkingDirectory;
		ApplicationCommandLineArgs CommandLineArgs;
	};

	class Application
	{
	public:
		Application(const ApplicationSpecification& specification);
		virtual ~Application();

		void OnEvent(Event& e);

		void PushLayer(Layer* layer);
		void PushOverlay(Layer* layer);

		Window& GetWindow() { return *m_Window; }

		void Close();

		ImGuiLayer* GetImGuiLayer() { return m_ImGuiLayer; }

		static Application& Get() { return *s_Instance; }

		const ApplicationSpecification& GetSpecification() const { return m_Specification; }

		void SubmitToMainThread(const std::function<void()>& function);
	private:
		void Run();
		bool OnWindowClose(WindowCloseEvent& e);
		bool OnWindowResize(WindowResizeEvent& e);

		void ExecuteMainThreadQueue();
	private:
		ApplicationSpecification m_Specification;
		Scope<Window> m_Window;
		ImGuiLayer* m_ImGuiLayer;
		bool m_Running = true;
		bool m_Minimized = false;
		LayerStack m_LayerStack;
		float m_LastFrameTime = 0.0f;

		std::vector<std::function<void()>> m_MainThreadQueue;
		std::mutex m_MainThreadQueueMutex;
	private:
		static Application* s_Instance;
		friend int ::main(int argc, char** argv);
	};

	// To be defined in CLIENT
	Application* CreateApplication(ApplicationCommandLineArgs args);

}

```

`Hazel/src/Hazel/Core/Assert.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"
#include "Hazel/Core/Log.h"
#include <filesystem>

#ifdef HZ_ENABLE_ASSERTS

	// Alteratively we could use the same "default" message for both "WITH_MSG" and "NO_MSG" and
	// provide support for custom formatting by concatenating the formatting string instead of having the format inside the default message
	#define HZ_INTERNAL_ASSERT_IMPL(type, check, msg, ...) { if(!(check)) { HZ##type##ERROR(msg, __VA_ARGS__); HZ_DEBUGBREAK(); } }
	#define HZ_INTERNAL_ASSERT_WITH_MSG(type, check, ...) HZ_INTERNAL_ASSERT_IMPL(type, check, "Assertion failed: {0}", __VA_ARGS__)
	#define HZ_INTERNAL_ASSERT_NO_MSG(type, check) HZ_INTERNAL_ASSERT_IMPL(type, check, "Assertion '{0}' failed at {1}:{2}", HZ_STRINGIFY_MACRO(check), std::filesystem::path(__FILE__).filename().string(), __LINE__)

	#define HZ_INTERNAL_ASSERT_GET_MACRO_NAME(arg1, arg2, macro, ...) macro
	#define HZ_INTERNAL_ASSERT_GET_MACRO(...) HZ_EXPAND_MACRO( HZ_INTERNAL_ASSERT_GET_MACRO_NAME(__VA_ARGS__, HZ_INTERNAL_ASSERT_WITH_MSG, HZ_INTERNAL_ASSERT_NO_MSG) )

	// Currently accepts at least the condition and one additional parameter (the message) being optional
	#define HZ_ASSERT(...) HZ_EXPAND_MACRO( HZ_INTERNAL_ASSERT_GET_MACRO(__VA_ARGS__)(_, __VA_ARGS__) )
	#define HZ_CORE_ASSERT(...) HZ_EXPAND_MACRO( HZ_INTERNAL_ASSERT_GET_MACRO(__VA_ARGS__)(_CORE_, __VA_ARGS__) )
#else
	#define HZ_ASSERT(...)
	#define HZ_CORE_ASSERT(...)
#endif

```

`Hazel/src/Hazel/Core/Base.h`:

```h
#pragma once

#include "Hazel/Core/PlatformDetection.h"

#include <memory>

#ifdef HZ_DEBUG
	#if defined(HZ_PLATFORM_WINDOWS)
		#define HZ_DEBUGBREAK() __debugbreak()
	#elif defined(HZ_PLATFORM_LINUX)
		#include <signal.h>
		#define HZ_DEBUGBREAK() raise(SIGTRAP)
	#else
		#error "Platform doesn't support debugbreak yet!"
	#endif
	#define HZ_ENABLE_ASSERTS
#else
	#define HZ_DEBUGBREAK()
#endif

#define HZ_EXPAND_MACRO(x) x
#define HZ_STRINGIFY_MACRO(x) #x

#define BIT(x) (1 << x)

#define HZ_BIND_EVENT_FN(fn) [this](auto&&... args) -> decltype(auto) { return this->fn(std::forward<decltype(args)>(args)...); }

namespace Hazel {

	template<typename T>
	using Scope = std::unique_ptr<T>;
	template<typename T, typename ... Args>
	constexpr Scope<T> CreateScope(Args&& ... args)
	{
		return std::make_unique<T>(std::forward<Args>(args)...);
	}

	template<typename T>
	using Ref = std::shared_ptr<T>;
	template<typename T, typename ... Args>
	constexpr Ref<T> CreateRef(Args&& ... args)
	{
		return std::make_shared<T>(std::forward<Args>(args)...);
	}

}

#include "Hazel/Core/Log.h"
#include "Hazel/Core/Assert.h"

```

`Hazel/src/Hazel/Core/Buffer.h`:

```h
#pragma once

#include <stdint.h>
#include <cstring>

namespace Hazel {

	// Non-owning raw buffer class
	struct Buffer
	{
		uint8_t* Data = nullptr;
		uint64_t Size = 0;

		Buffer() = default;

		Buffer(uint64_t size)
		{
			Allocate(size);
		}

		Buffer(const Buffer&) = default;

		static Buffer Copy(Buffer other)
		{
			Buffer result(other.Size);
			memcpy(result.Data, other.Data, other.Size);
			return result;
		}

		void Allocate(uint64_t size)
		{
			Release();

			Data = new uint8_t[size];
			Size = size;
		}

		void Release()
		{
			delete[] Data;
			Data = nullptr;
			Size = 0;
		}

		template<typename T>
		T* As()
		{
			return (T*)Data;
		}

		operator bool() const
		{
			return (bool)Data;
		}

	};

	struct ScopedBuffer
	{
		ScopedBuffer(Buffer buffer)
			: m_Buffer(buffer)
		{
		}

		ScopedBuffer(uint64_t size)
			: m_Buffer(size)
		{
		}

		~ScopedBuffer()
		{
			m_Buffer.Release();
		}

		uint8_t* Data() { return m_Buffer.Data; }
		uint64_t Size() { return m_Buffer.Size; }

		template<typename T>
		T* As()
		{
			return m_Buffer.As<T>();
		}

		operator bool() const { return m_Buffer; }
	private:
		Buffer m_Buffer;
	};


}

```

`Hazel/src/Hazel/Core/EntryPoint.h`:

```h
#pragma once
#include "Hazel/Core/Base.h"
#include "Hazel/Core/Application.h"

#ifdef HZ_PLATFORM_WINDOWS

extern Hazel::Application* Hazel::CreateApplication(ApplicationCommandLineArgs args);

int main(int argc, char** argv)
{
	Hazel::Log::Init();

	HZ_PROFILE_BEGIN_SESSION("Startup", "HazelProfile-Startup.json");
	auto app = Hazel::CreateApplication({ argc, argv });
	HZ_PROFILE_END_SESSION();

	HZ_PROFILE_BEGIN_SESSION("Runtime", "HazelProfile-Runtime.json");
	app->Run();
	HZ_PROFILE_END_SESSION();

	HZ_PROFILE_BEGIN_SESSION("Shutdown", "HazelProfile-Shutdown.json");
	delete app;
	HZ_PROFILE_END_SESSION();
}

#endif

```

`Hazel/src/Hazel/Core/FileSystem.cpp`:

```cpp
#include "hzpch.h"
#include "FileSystem.h"

namespace Hazel {

	Buffer FileSystem::ReadFileBinary(const std::filesystem::path& filepath)
	{
		std::ifstream stream(filepath, std::ios::binary | std::ios::ate);

		if (!stream)
		{
			// Failed to open the file
			return {};
		}


		std::streampos end = stream.tellg();
		stream.seekg(0, std::ios::beg);
		uint64_t size = end - stream.tellg();

		if (size == 0)
		{
			// File is empty
			return {};
		}

		Buffer buffer(size);
		stream.read(buffer.As<char>(), size);
		stream.close();
		return buffer;
	}

}

```

`Hazel/src/Hazel/Core/FileSystem.h`:

```h
#pragma once

#include "Hazel/Core/Buffer.h"

namespace Hazel {

	class FileSystem
	{
	public:
		// TODO: move to FileSystem class
		static Buffer ReadFileBinary(const std::filesystem::path& filepath);
	};

}

```

`Hazel/src/Hazel/Core/Input.h`:

```h
#pragma once

#include "Hazel/Core/KeyCodes.h"
#include "Hazel/Core/MouseCodes.h"

#include <glm/glm.hpp>

namespace Hazel {

	class Input
	{
	public:
		static bool IsKeyPressed(KeyCode key);

		static bool IsMouseButtonPressed(MouseCode button);
		static glm::vec2 GetMousePosition();
		static float GetMouseX();
		static float GetMouseY();
	};
}

```

`Hazel/src/Hazel/Core/KeyCodes.h`:

```h
#pragma once

namespace Hazel
{
	using KeyCode = uint16_t;
	
	namespace Key
	{
		enum : KeyCode
		{
			// From glfw3.h
			Space               = 32,
			Apostrophe          = 39, /* ' */
			Comma               = 44, /* , */
			Minus               = 45, /* - */
			Period              = 46, /* . */
			Slash               = 47, /* / */

			D0                  = 48, /* 0 */
			D1                  = 49, /* 1 */
			D2                  = 50, /* 2 */
			D3                  = 51, /* 3 */
			D4                  = 52, /* 4 */
			D5                  = 53, /* 5 */
			D6                  = 54, /* 6 */
			D7                  = 55, /* 7 */
			D8                  = 56, /* 8 */
			D9                  = 57, /* 9 */

			Semicolon           = 59, /* ; */
			Equal               = 61, /* = */

			A                   = 65,
			B                   = 66,
			C                   = 67,
			D                   = 68,
			E                   = 69,
			F                   = 70,
			G                   = 71,
			H                   = 72,
			I                   = 73,
			J                   = 74,
			K                   = 75,
			L                   = 76,
			M                   = 77,
			N                   = 78,
			O                   = 79,
			P                   = 80,
			Q                   = 81,
			R                   = 82,
			S                   = 83,
			T                   = 84,
			U                   = 85,
			V                   = 86,
			W                   = 87,
			X                   = 88,
			Y                   = 89,
			Z                   = 90,

			LeftBracket         = 91,  /* [ */
			Backslash           = 92,  /* \ */
			RightBracket        = 93,  /* ] */
			GraveAccent         = 96,  /* ` */

			World1              = 161, /* non-US #1 */
			World2              = 162, /* non-US #2 */

			/* Function keys */
			Escape              = 256,
			Enter               = 257,
			Tab                 = 258,
			Backspace           = 259,
			Insert              = 260,
			Delete              = 261,
			Right               = 262,
			Left                = 263,
			Down                = 264,
			Up                  = 265,
			PageUp              = 266,
			PageDown            = 267,
			Home                = 268,
			End                 = 269,
			CapsLock            = 280,
			ScrollLock          = 281,
			NumLock             = 282,
			PrintScreen         = 283,
			Pause               = 284,
			F1                  = 290,
			F2                  = 291,
			F3                  = 292,
			F4                  = 293,
			F5                  = 294,
			F6                  = 295,
			F7                  = 296,
			F8                  = 297,
			F9                  = 298,
			F10                 = 299,
			F11                 = 300,
			F12                 = 301,
			F13                 = 302,
			F14                 = 303,
			F15                 = 304,
			F16                 = 305,
			F17                 = 306,
			F18                 = 307,
			F19                 = 308,
			F20                 = 309,
			F21                 = 310,
			F22                 = 311,
			F23                 = 312,
			F24                 = 313,
			F25                 = 314,

			/* Keypad */
			KP0                 = 320,
			KP1                 = 321,
			KP2                 = 322,
			KP3                 = 323,
			KP4                 = 324,
			KP5                 = 325,
			KP6                 = 326,
			KP7                 = 327,
			KP8                 = 328,
			KP9                 = 329,
			KPDecimal           = 330,
			KPDivide            = 331,
			KPMultiply          = 332,
			KPSubtract          = 333,
			KPAdd               = 334,
			KPEnter             = 335,
			KPEqual             = 336,

			LeftShift           = 340,
			LeftControl         = 341,
			LeftAlt             = 342,
			LeftSuper           = 343,
			RightShift          = 344,
			RightControl        = 345,
			RightAlt            = 346,
			RightSuper          = 347,
			Menu                = 348
		};
	}
}
```

`Hazel/src/Hazel/Core/Layer.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Core/Layer.h"

namespace Hazel {

	Layer::Layer(const std::string& debugName)
		: m_DebugName(debugName)
	{
	}
	
}
```

`Hazel/src/Hazel/Core/Layer.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"
#include "Hazel/Core/Timestep.h"
#include "Hazel/Events/Event.h"

namespace Hazel {

	class Layer
	{
	public:
		Layer(const std::string& name = "Layer");
		virtual ~Layer() = default;

		virtual void OnAttach() {}
		virtual void OnDetach() {}
		virtual void OnUpdate(Timestep ts) {}
		virtual void OnImGuiRender() {}
		virtual void OnEvent(Event& event) {}

		const std::string& GetName() const { return m_DebugName; }
	protected:
		std::string m_DebugName;
	};

}
```

`Hazel/src/Hazel/Core/LayerStack.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Core/LayerStack.h"

namespace Hazel {

	LayerStack::~LayerStack()
	{
		for (Layer* layer : m_Layers)
		{
			layer->OnDetach();
			delete layer;
		}
	}

	void LayerStack::PushLayer(Layer* layer)
	{
		m_Layers.emplace(m_Layers.begin() + m_LayerInsertIndex, layer);
		m_LayerInsertIndex++;
	}

	void LayerStack::PushOverlay(Layer* overlay)
	{
		m_Layers.emplace_back(overlay);
	}

	void LayerStack::PopLayer(Layer* layer)
	{
		auto it = std::find(m_Layers.begin(), m_Layers.begin() + m_LayerInsertIndex, layer);
		if (it != m_Layers.begin() + m_LayerInsertIndex)
		{
			layer->OnDetach();
			m_Layers.erase(it);
			m_LayerInsertIndex--;
		}
	}

	void LayerStack::PopOverlay(Layer* overlay)
	{
		auto it = std::find(m_Layers.begin() + m_LayerInsertIndex, m_Layers.end(), overlay);
		if (it != m_Layers.end())
		{
			overlay->OnDetach();
			m_Layers.erase(it);
		}
	}

}

```

`Hazel/src/Hazel/Core/LayerStack.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"
#include "Hazel/Core/Layer.h"

#include <vector>

namespace Hazel {

	class LayerStack
	{
	public:
		LayerStack() = default;
		~LayerStack();

		void PushLayer(Layer* layer);
		void PushOverlay(Layer* overlay);
		void PopLayer(Layer* layer);
		void PopOverlay(Layer* overlay);

		std::vector<Layer*>::iterator begin() { return m_Layers.begin(); }
		std::vector<Layer*>::iterator end() { return m_Layers.end(); }
		std::vector<Layer*>::reverse_iterator rbegin() { return m_Layers.rbegin(); }
		std::vector<Layer*>::reverse_iterator rend() { return m_Layers.rend(); }

		std::vector<Layer*>::const_iterator begin() const { return m_Layers.begin(); }
		std::vector<Layer*>::const_iterator end()	const { return m_Layers.end(); }
		std::vector<Layer*>::const_reverse_iterator rbegin() const { return m_Layers.rbegin(); }
		std::vector<Layer*>::const_reverse_iterator rend() const { return m_Layers.rend(); }
	private:
		std::vector<Layer*> m_Layers;
		unsigned int m_LayerInsertIndex = 0;
	};

}
```

`Hazel/src/Hazel/Core/Log.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Core/Log.h"

#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/basic_file_sink.h>

namespace Hazel {

	Ref<spdlog::logger> Log::s_CoreLogger;
	Ref<spdlog::logger> Log::s_ClientLogger;

	void Log::Init()
	{
		std::vector<spdlog::sink_ptr> logSinks;
		logSinks.emplace_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());
		logSinks.emplace_back(std::make_shared<spdlog::sinks::basic_file_sink_mt>("Hazel.log", true));

		logSinks[0]->set_pattern("%^[%T] %n: %v%$");
		logSinks[1]->set_pattern("[%T] [%l] %n: %v");

		s_CoreLogger = std::make_shared<spdlog::logger>("HAZEL", begin(logSinks), end(logSinks));
		spdlog::register_logger(s_CoreLogger);
		s_CoreLogger->set_level(spdlog::level::trace);
		s_CoreLogger->flush_on(spdlog::level::trace);

		s_ClientLogger = std::make_shared<spdlog::logger>("APP", begin(logSinks), end(logSinks));
		spdlog::register_logger(s_ClientLogger);
		s_ClientLogger->set_level(spdlog::level::trace);
		s_ClientLogger->flush_on(spdlog::level::trace);
	}

}


```

`Hazel/src/Hazel/Core/Log.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"

#define GLM_ENABLE_EXPERIMENTAL
#include "glm/gtx/string_cast.hpp"

// This ignores all warnings raised inside External headers
#pragma warning(push, 0)
#include <spdlog/spdlog.h>
#include <spdlog/fmt/ostr.h>
#pragma warning(pop)

namespace Hazel {

	class Log
	{
	public:
		static void Init();

		static Ref<spdlog::logger>& GetCoreLogger() { return s_CoreLogger; }
		static Ref<spdlog::logger>& GetClientLogger() { return s_ClientLogger; }
	private:
		static Ref<spdlog::logger> s_CoreLogger;
		static Ref<spdlog::logger> s_ClientLogger;
	};

}

template<typename OStream, glm::length_t L, typename T, glm::qualifier Q>
inline OStream& operator<<(OStream& os, const glm::vec<L, T, Q>& vector)
{
	return os << glm::to_string(vector);
}

template<typename OStream, glm::length_t C, glm::length_t R, typename T, glm::qualifier Q>
inline OStream& operator<<(OStream& os, const glm::mat<C, R, T, Q>& matrix)
{
	return os << glm::to_string(matrix);
}

template<typename OStream, typename T, glm::qualifier Q>
inline OStream& operator<<(OStream& os, glm::qua<T, Q> quaternion)
{
	return os << glm::to_string(quaternion);
}

// Core log macros
#define HZ_CORE_TRACE(...)    ::Hazel::Log::GetCoreLogger()->trace(__VA_ARGS__)
#define HZ_CORE_INFO(...)     ::Hazel::Log::GetCoreLogger()->info(__VA_ARGS__)
#define HZ_CORE_WARN(...)     ::Hazel::Log::GetCoreLogger()->warn(__VA_ARGS__)
#define HZ_CORE_ERROR(...)    ::Hazel::Log::GetCoreLogger()->error(__VA_ARGS__)
#define HZ_CORE_CRITICAL(...) ::Hazel::Log::GetCoreLogger()->critical(__VA_ARGS__)

// Client log macros
#define HZ_TRACE(...)         ::Hazel::Log::GetClientLogger()->trace(__VA_ARGS__)
#define HZ_INFO(...)          ::Hazel::Log::GetClientLogger()->info(__VA_ARGS__)
#define HZ_WARN(...)          ::Hazel::Log::GetClientLogger()->warn(__VA_ARGS__)
#define HZ_ERROR(...)         ::Hazel::Log::GetClientLogger()->error(__VA_ARGS__)
#define HZ_CRITICAL(...)      ::Hazel::Log::GetClientLogger()->critical(__VA_ARGS__)

```

`Hazel/src/Hazel/Core/MouseCodes.h`:

```h
#pragma once

namespace Hazel
{
	using MouseCode = uint16_t;

	namespace Mouse
	{
		enum : MouseCode
		{
			// From glfw3.h
			Button0                = 0,
			Button1                = 1,
			Button2                = 2,
			Button3                = 3,
			Button4                = 4,
			Button5                = 5,
			Button6                = 6,
			Button7                = 7,

			ButtonLast             = Button7,
			ButtonLeft             = Button0,
			ButtonRight            = Button1,
			ButtonMiddle           = Button2
		};
	}
}
```

`Hazel/src/Hazel/Core/PlatformDetection.h`:

```h
// Platform detection using predefined macros
#ifdef _WIN32
	/* Windows x64/x86 */
	#ifdef _WIN64
		/* Windows x64  */
		#define HZ_PLATFORM_WINDOWS
	#else
		/* Windows x86 */
		#error "x86 Builds are not supported!"
	#endif
#elif defined(__APPLE__) || defined(__MACH__)
	#include <TargetConditionals.h>
	/* TARGET_OS_MAC exists on all the platforms
	 * so we must check all of them (in this order)
	 * to ensure that we're running on MAC
	 * and not some other Apple platform */
	#if TARGET_IPHONE_SIMULATOR == 1
		#error "IOS simulator is not supported!"
	#elif TARGET_OS_IPHONE == 1
		#define HZ_PLATFORM_IOS
		#error "IOS is not supported!"
	#elif TARGET_OS_MAC == 1
		#define HZ_PLATFORM_MACOS
		#error "MacOS is not supported!"
	#else
		#error "Unknown Apple platform!"
	#endif
/* We also have to check __ANDROID__ before __linux__
 * since android is based on the linux kernel
 * it has __linux__ defined */
#elif defined(__ANDROID__)
	#define HZ_PLATFORM_ANDROID
	#error "Android is not supported!"
#elif defined(__linux__)
	#define HZ_PLATFORM_LINUX
	#error "Linux is not supported!"
#else
	/* Unknown compiler/platform */
	#error "Unknown platform!"
#endif // End of platform detection

```

`Hazel/src/Hazel/Core/Timer.h`:

```h
#pragma once

#include <chrono>

namespace Hazel {

	class Timer
	{
	public:
		Timer()
		{
			Reset();
		}

		void Timer::Reset()
		{
			m_Start = std::chrono::high_resolution_clock::now();
		}

		float Timer::Elapsed()
		{
			return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - m_Start).count() * 0.001f * 0.001f * 0.001f;
		}

		float Timer::ElapsedMillis()
		{
			return Elapsed() * 1000.0f;
		}

	private:
		std::chrono::time_point<std::chrono::high_resolution_clock> m_Start;
	};

}

```

`Hazel/src/Hazel/Core/Timestep.h`:

```h
#pragma once

namespace Hazel {

	class Timestep
	{
	public:
		Timestep(float time = 0.0f)
			: m_Time(time)
		{
		}

		operator float() const { return m_Time; }

		float GetSeconds() const { return m_Time; }
		float GetMilliseconds() const { return m_Time * 1000.0f; }
	private:
		float m_Time;
	};

}
```

`Hazel/src/Hazel/Core/UUID.cpp`:

```cpp
#include "hzpch.h"
#include "UUID.h"

#include <random>

#include <unordered_map>

namespace Hazel {

	static std::random_device s_RandomDevice;
	static std::mt19937_64 s_Engine(s_RandomDevice());
	static std::uniform_int_distribution<uint64_t> s_UniformDistribution;

	UUID::UUID()
		: m_UUID(s_UniformDistribution(s_Engine))
	{
	}

	UUID::UUID(uint64_t uuid)
		: m_UUID(uuid)
	{
	}

}

```

`Hazel/src/Hazel/Core/UUID.h`:

```h
#pragma once

namespace Hazel {

	class UUID
	{
	public:
		UUID();
		UUID(uint64_t uuid);
		UUID(const UUID&) = default;

		operator uint64_t() const { return m_UUID; }
	private:
		uint64_t m_UUID;
	};

}

namespace std {
	template <typename T> struct hash;

	template<>
	struct hash<Hazel::UUID>
	{
		std::size_t operator()(const Hazel::UUID& uuid) const
		{
			return (uint64_t)uuid;
		}
	};

}

```

`Hazel/src/Hazel/Core/Window.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Core/Window.h"

#ifdef HZ_PLATFORM_WINDOWS
	#include "Platform/Windows/WindowsWindow.h"
#endif

namespace Hazel
{
	Scope<Window> Window::Create(const WindowProps& props)
	{
	#ifdef HZ_PLATFORM_WINDOWS
		return CreateScope<WindowsWindow>(props);
	#else
		HZ_CORE_ASSERT(false, "Unknown platform!");
		return nullptr;
	#endif
	}

}
```

`Hazel/src/Hazel/Core/Window.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"
#include "Hazel/Events/Event.h"

#include <sstream>

namespace Hazel {

	struct WindowProps
	{
		std::string Title;
		uint32_t Width;
		uint32_t Height;

		WindowProps(const std::string& title = "Hazel Engine",
			        uint32_t width = 1600,
			        uint32_t height = 900)
			: Title(title), Width(width), Height(height)
		{
		}
	};

	// Interface representing a desktop system based Window
	class Window
	{
	public:
		using EventCallbackFn = std::function<void(Event&)>;

		virtual ~Window() = default;

		virtual void OnUpdate() = 0;

		virtual uint32_t GetWidth() const = 0;
		virtual uint32_t GetHeight() const = 0;

		// Window attributes
		virtual void SetEventCallback(const EventCallbackFn& callback) = 0;
		virtual void SetVSync(bool enabled) = 0;
		virtual bool IsVSync() const = 0;

		virtual void* GetNativeWindow() const = 0;

		static Scope<Window> Create(const WindowProps& props = WindowProps());
	};

}

```

`Hazel/src/Hazel/Debug/Instrumentor.h`:

```h
#pragma once

#include "Hazel/Core/Log.h"

#include <algorithm>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <string>
#include <thread>
#include <mutex>
#include <sstream>

namespace Hazel {

	using FloatingPointMicroseconds = std::chrono::duration<double, std::micro>;

	struct ProfileResult
	{
		std::string Name;

		FloatingPointMicroseconds Start;
		std::chrono::microseconds ElapsedTime;
		std::thread::id ThreadID;
	};

	struct InstrumentationSession
	{
		std::string Name;
	};

	class Instrumentor
	{
	public:
		Instrumentor(const Instrumentor&) = delete;
		Instrumentor(Instrumentor&&) = delete;

		void BeginSession(const std::string& name, const std::string& filepath = "results.json")
		{
			std::lock_guard lock(m_Mutex);
			if (m_CurrentSession)
			{
				// If there is already a current session, then close it before beginning new one.
				// Subsequent profiling output meant for the original session will end up in the
				// newly opened session instead.  That's better than having badly formatted
				// profiling output.
				if (Log::GetCoreLogger()) // Edge case: BeginSession() might be before Log::Init()
				{
					HZ_CORE_ERROR("Instrumentor::BeginSession('{0}') when session '{1}' already open.", name, m_CurrentSession->Name);
				}
				InternalEndSession();
			}
			m_OutputStream.open(filepath);

			if (m_OutputStream.is_open())
			{
				m_CurrentSession = new InstrumentationSession({name});
				WriteHeader();
			}
			else
			{
				if (Log::GetCoreLogger()) // Edge case: BeginSession() might be before Log::Init()
				{
					HZ_CORE_ERROR("Instrumentor could not open results file '{0}'.", filepath);
				}
			}
		}

		void EndSession()
		{
			std::lock_guard lock(m_Mutex);
			InternalEndSession();
		}

		void WriteProfile(const ProfileResult& result)
		{
			std::stringstream json;

			json << std::setprecision(3) << std::fixed;
			json << ",{";
			json << "\"cat\":\"function\",";
			json << "\"dur\":" << (result.ElapsedTime.count()) << ',';
			json << "\"name\":\"" << result.Name << "\",";
			json << "\"ph\":\"X\",";
			json << "\"pid\":0,";
			json << "\"tid\":" << result.ThreadID << ",";
			json << "\"ts\":" << result.Start.count();
			json << "}";

			std::lock_guard lock(m_Mutex);
			if (m_CurrentSession)
			{
				m_OutputStream << json.str();
				m_OutputStream.flush();
			}
		}

		static Instrumentor& Get()
		{
			static Instrumentor instance;
			return instance;
		}
	private:
		Instrumentor()
			: m_CurrentSession(nullptr)
		{
		}

		~Instrumentor()
		{
			EndSession();
		}		

		void WriteHeader()
		{
			m_OutputStream << "{\"otherData\": {},\"traceEvents\":[{}";
			m_OutputStream.flush();
		}

		void WriteFooter()
		{
			m_OutputStream << "]}";
			m_OutputStream.flush();
		}

		// Note: you must already own lock on m_Mutex before
		// calling InternalEndSession()
		void InternalEndSession()
		{
			if (m_CurrentSession)
			{
				WriteFooter();
				m_OutputStream.close();
				delete m_CurrentSession;
				m_CurrentSession = nullptr;
			}
		}
	private:
		std::mutex m_Mutex;
		InstrumentationSession* m_CurrentSession;
		std::ofstream m_OutputStream;
	};

	class InstrumentationTimer
	{
	public:
		InstrumentationTimer(const char* name)
			: m_Name(name), m_Stopped(false)
		{
			m_StartTimepoint = std::chrono::steady_clock::now();
		}

		~InstrumentationTimer()
		{
			if (!m_Stopped)
				Stop();
		}

		void Stop()
		{
			auto endTimepoint = std::chrono::steady_clock::now();
			auto highResStart = FloatingPointMicroseconds{ m_StartTimepoint.time_since_epoch() };
			auto elapsedTime = std::chrono::time_point_cast<std::chrono::microseconds>(endTimepoint).time_since_epoch() - std::chrono::time_point_cast<std::chrono::microseconds>(m_StartTimepoint).time_since_epoch();

			Instrumentor::Get().WriteProfile({ m_Name, highResStart, elapsedTime, std::this_thread::get_id() });

			m_Stopped = true;
		}
	private:
		const char* m_Name;
		std::chrono::time_point<std::chrono::steady_clock> m_StartTimepoint;
		bool m_Stopped;
	};

	namespace InstrumentorUtils {

		template <size_t N>
		struct ChangeResult
		{
			char Data[N];
		};

		template <size_t N, size_t K>
		constexpr auto CleanupOutputString(const char(&expr)[N], const char(&remove)[K])
		{
			ChangeResult<N> result = {};

			size_t srcIndex = 0;
			size_t dstIndex = 0;
			while (srcIndex < N)
			{
				size_t matchIndex = 0;
				while (matchIndex < K - 1 && srcIndex + matchIndex < N - 1 && expr[srcIndex + matchIndex] == remove[matchIndex])
					matchIndex++;
				if (matchIndex == K - 1)
					srcIndex += matchIndex;
				result.Data[dstIndex++] = expr[srcIndex] == '"' ? '\'' : expr[srcIndex];
				srcIndex++;
			}
			return result;
		}
	}
}

#define HZ_PROFILE 0
#if HZ_PROFILE
	// Resolve which function signature macro will be used. Note that this only
	// is resolved when the (pre)compiler starts, so the syntax highlighting
	// could mark the wrong one in your editor!
	#if defined(__GNUC__) || (defined(__MWERKS__) && (__MWERKS__ >= 0x3000)) || (defined(__ICC) && (__ICC >= 600)) || defined(__ghs__)
		#define HZ_FUNC_SIG __PRETTY_FUNCTION__
	#elif defined(__DMC__) && (__DMC__ >= 0x810)
		#define HZ_FUNC_SIG __PRETTY_FUNCTION__
	#elif (defined(__FUNCSIG__) || (_MSC_VER))
		#define HZ_FUNC_SIG __FUNCSIG__
	#elif (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 600)) || (defined(__IBMCPP__) && (__IBMCPP__ >= 500))
		#define HZ_FUNC_SIG __FUNCTION__
	#elif defined(__BORLANDC__) && (__BORLANDC__ >= 0x550)
		#define HZ_FUNC_SIG __FUNC__
	#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)
		#define HZ_FUNC_SIG __func__
	#elif defined(__cplusplus) && (__cplusplus >= 201103)
		#define HZ_FUNC_SIG __func__
	#else
		#define HZ_FUNC_SIG "HZ_FUNC_SIG unknown!"
	#endif

	#define HZ_PROFILE_BEGIN_SESSION(name, filepath) ::Hazel::Instrumentor::Get().BeginSession(name, filepath)
	#define HZ_PROFILE_END_SESSION() ::Hazel::Instrumentor::Get().EndSession()
	#define HZ_PROFILE_SCOPE_LINE2(name, line) constexpr auto fixedName##line = ::Hazel::InstrumentorUtils::CleanupOutputString(name, "__cdecl ");\
											   ::Hazel::InstrumentationTimer timer##line(fixedName##line.Data)
	#define HZ_PROFILE_SCOPE_LINE(name, line) HZ_PROFILE_SCOPE_LINE2(name, line)
	#define HZ_PROFILE_SCOPE(name) HZ_PROFILE_SCOPE_LINE(name, __LINE__)
	#define HZ_PROFILE_FUNCTION() HZ_PROFILE_SCOPE(HZ_FUNC_SIG)
#else
	#define HZ_PROFILE_BEGIN_SESSION(name, filepath)
	#define HZ_PROFILE_END_SESSION()
	#define HZ_PROFILE_SCOPE(name)
	#define HZ_PROFILE_FUNCTION()
#endif
```

`Hazel/src/Hazel/Events/ApplicationEvent.h`:

```h
#pragma once

#include "Hazel/Events/Event.h"

namespace Hazel {

	class WindowResizeEvent : public Event
	{
	public:
		WindowResizeEvent(unsigned int width, unsigned int height)
			: m_Width(width), m_Height(height) {}

		unsigned int GetWidth() const { return m_Width; }
		unsigned int GetHeight() const { return m_Height; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "WindowResizeEvent: " << m_Width << ", " << m_Height;
			return ss.str();
		}

		EVENT_CLASS_TYPE(WindowResize)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	private:
		unsigned int m_Width, m_Height;
	};

	class WindowCloseEvent : public Event
	{
	public:
		WindowCloseEvent() = default;

		EVENT_CLASS_TYPE(WindowClose)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};

	class AppTickEvent : public Event
	{
	public:
		AppTickEvent() = default;

		EVENT_CLASS_TYPE(AppTick)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};

	class AppUpdateEvent : public Event
	{
	public:
		AppUpdateEvent() = default;

		EVENT_CLASS_TYPE(AppUpdate)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};

	class AppRenderEvent : public Event
	{
	public:
		AppRenderEvent() = default;

		EVENT_CLASS_TYPE(AppRender)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};
}
```

`Hazel/src/Hazel/Events/Event.h`:

```h
#pragma once

#include "Hazel/Debug/Instrumentor.h"
#include "Hazel/Core/Base.h"

#include <functional>

namespace Hazel {

	// Events in Hazel are currently blocking, meaning when an event occurs it
	// immediately gets dispatched and must be dealt with right then an there.
	// For the future, a better strategy might be to buffer events in an event
	// bus and process them during the "event" part of the update stage.

	enum class EventType
	{
		None = 0,
		WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,
		AppTick, AppUpdate, AppRender,
		KeyPressed, KeyReleased, KeyTyped,
		MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled
	};

	enum EventCategory
	{
		None = 0,
		EventCategoryApplication    = BIT(0),
		EventCategoryInput          = BIT(1),
		EventCategoryKeyboard       = BIT(2),
		EventCategoryMouse          = BIT(3),
		EventCategoryMouseButton    = BIT(4)
	};

#define EVENT_CLASS_TYPE(type) static EventType GetStaticType() { return EventType::type; }\
								virtual EventType GetEventType() const override { return GetStaticType(); }\
								virtual const char* GetName() const override { return #type; }

#define EVENT_CLASS_CATEGORY(category) virtual int GetCategoryFlags() const override { return category; }

	class Event
	{
	public:
		virtual ~Event() = default;

		bool Handled = false;

		virtual EventType GetEventType() const = 0;
		virtual const char* GetName() const = 0;
		virtual int GetCategoryFlags() const = 0;
		virtual std::string ToString() const { return GetName(); }

		bool IsInCategory(EventCategory category)
		{
			return GetCategoryFlags() & category;
		}
	};

	class EventDispatcher
	{
	public:
		EventDispatcher(Event& event)
			: m_Event(event)
		{
		}
		
		// F will be deduced by the compiler
		template<typename T, typename F>
		bool Dispatch(const F& func)
		{
			if (m_Event.GetEventType() == T::GetStaticType())
			{
				m_Event.Handled |= func(static_cast<T&>(m_Event));
				return true;
			}
			return false;
		}
	private:
		Event& m_Event;
	};

	inline std::ostream& operator<<(std::ostream& os, const Event& e)
	{
		return os << e.ToString();
	}

}


```

`Hazel/src/Hazel/Events/KeyEvent.h`:

```h
#pragma once

#include "Hazel/Events/Event.h"
#include "Hazel/Core/KeyCodes.h"

namespace Hazel {

	class KeyEvent : public Event
	{
	public:
		KeyCode GetKeyCode() const { return m_KeyCode; }

		EVENT_CLASS_CATEGORY(EventCategoryKeyboard | EventCategoryInput)
	protected:
		KeyEvent(const KeyCode keycode)
			: m_KeyCode(keycode) {}

		KeyCode m_KeyCode;
	};

	class KeyPressedEvent : public KeyEvent
	{
	public:
		KeyPressedEvent(const KeyCode keycode, bool isRepeat = false)
			: KeyEvent(keycode), m_IsRepeat(isRepeat) {}

		bool IsRepeat() const { return m_IsRepeat; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "KeyPressedEvent: " << m_KeyCode << " (repeat = " << m_IsRepeat << ")";
			return ss.str();
		}

		EVENT_CLASS_TYPE(KeyPressed)
	private:
		bool m_IsRepeat;
	};

	class KeyReleasedEvent : public KeyEvent
	{
	public:
		KeyReleasedEvent(const KeyCode keycode)
			: KeyEvent(keycode) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "KeyReleasedEvent: " << m_KeyCode;
			return ss.str();
		}

		EVENT_CLASS_TYPE(KeyReleased)
	};

	class KeyTypedEvent : public KeyEvent
	{
	public:
		KeyTypedEvent(const KeyCode keycode)
			: KeyEvent(keycode) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "KeyTypedEvent: " << m_KeyCode;
			return ss.str();
		}

		EVENT_CLASS_TYPE(KeyTyped)
	};
}

```

`Hazel/src/Hazel/Events/MouseEvent.h`:

```h
#pragma once

#include "Hazel/Events/Event.h"
#include "Hazel/Core/MouseCodes.h"

namespace Hazel {

	class MouseMovedEvent : public Event
	{
	public:
		MouseMovedEvent(const float x, const float y)
			: m_MouseX(x), m_MouseY(y) {}

		float GetX() const { return m_MouseX; }
		float GetY() const { return m_MouseY; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseMovedEvent: " << m_MouseX << ", " << m_MouseY;
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseMoved)
		EVENT_CLASS_CATEGORY(EventCategoryMouse | EventCategoryInput)
	private:
		float m_MouseX, m_MouseY;
	};

	class MouseScrolledEvent : public Event
	{
	public:
		MouseScrolledEvent(const float xOffset, const float yOffset)
			: m_XOffset(xOffset), m_YOffset(yOffset) {}

		float GetXOffset() const { return m_XOffset; }
		float GetYOffset() const { return m_YOffset; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseScrolledEvent: " << GetXOffset() << ", " << GetYOffset();
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseScrolled)
		EVENT_CLASS_CATEGORY(EventCategoryMouse | EventCategoryInput)
	private:
		float m_XOffset, m_YOffset;
	};

	class MouseButtonEvent : public Event
	{
	public:
		MouseCode GetMouseButton() const { return m_Button; }

		EVENT_CLASS_CATEGORY(EventCategoryMouse | EventCategoryInput | EventCategoryMouseButton)
	protected:
		MouseButtonEvent(const MouseCode button)
			: m_Button(button) {}

		MouseCode m_Button;
	};

	class MouseButtonPressedEvent : public MouseButtonEvent
	{
	public:
		MouseButtonPressedEvent(const MouseCode button)
			: MouseButtonEvent(button) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseButtonPressedEvent: " << m_Button;
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseButtonPressed)
	};

	class MouseButtonReleasedEvent : public MouseButtonEvent
	{
	public:
		MouseButtonReleasedEvent(const MouseCode button)
			: MouseButtonEvent(button) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseButtonReleasedEvent: " << m_Button;
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseButtonReleased)
	};

}

```

`Hazel/src/Hazel/ImGui/ImGuiBuild.cpp`:

```cpp
#include "hzpch.h"

#include <misc/cpp/imgui_stdlib.cpp>

#define IMGUI_IMPL_OPENGL_LOADER_GLAD
#include <examples/imgui_impl_opengl3.cpp>
#include <examples/imgui_impl_glfw.cpp>

```

`Hazel/src/Hazel/ImGui/ImGuiLayer.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/ImGui/ImGuiLayer.h"

#include <imgui.h>
#include <imgui_internal.h>

#include <examples/imgui_impl_glfw.h>
#include <examples/imgui_impl_opengl3.h>

#include "Hazel/Core/Application.h"

// TEMPORARY
#include <GLFW/glfw3.h>
#include <glad/glad.h>

#include "ImGuizmo.h"

namespace Hazel {

	ImGuiLayer::ImGuiLayer()
		: Layer("ImGuiLayer")
	{
	}

	void ImGuiLayer::OnAttach()
	{
		HZ_PROFILE_FUNCTION();

		// Setup Dear ImGui context
		IMGUI_CHECKVERSION();
		ImGui::CreateContext();
		ImGuiIO& io = ImGui::GetIO(); (void)io;
		io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;       // Enable Keyboard Controls
		//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
		io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;           // Enable Docking
		io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;         // Enable Multi-Viewport / Platform Windows
		//io.ConfigFlags |= ImGuiConfigFlags_ViewportsNoTaskBarIcons;
		//io.ConfigFlags |= ImGuiConfigFlags_ViewportsNoMerge;

		float fontSize = 18.0f;// *2.0f;
		io.Fonts->AddFontFromFileTTF("assets/fonts/opensans/OpenSans-Bold.ttf", fontSize);
		io.FontDefault = io.Fonts->AddFontFromFileTTF("assets/fonts/opensans/OpenSans-Regular.ttf", fontSize);

		// Setup Dear ImGui style
		ImGui::StyleColorsDark();
		//ImGui::StyleColorsClassic();

		// When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.
		ImGuiStyle& style = ImGui::GetStyle();
		if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
		{
			style.WindowRounding = 0.0f;
			style.Colors[ImGuiCol_WindowBg].w = 1.0f;
		}

		SetDarkThemeColors();

		Application& app = Application::Get();
		GLFWwindow* window = static_cast<GLFWwindow*>(app.GetWindow().GetNativeWindow());

		// Setup Platform/Renderer bindings
		ImGui_ImplGlfw_InitForOpenGL(window, true);
		ImGui_ImplOpenGL3_Init("#version 410");
	}

	void ImGuiLayer::OnDetach()
	{
		HZ_PROFILE_FUNCTION();

		ImGui_ImplOpenGL3_Shutdown();
		ImGui_ImplGlfw_Shutdown();
		ImGui::DestroyContext();
	}

	void ImGuiLayer::OnEvent(Event& e)
	{
		if (m_BlockEvents)
		{
			ImGuiIO& io = ImGui::GetIO();
			e.Handled |= e.IsInCategory(EventCategoryMouse) & io.WantCaptureMouse;
			e.Handled |= e.IsInCategory(EventCategoryKeyboard) & io.WantCaptureKeyboard;
		}
	}
	
	void ImGuiLayer::Begin()
	{
		HZ_PROFILE_FUNCTION();

		ImGui_ImplOpenGL3_NewFrame();
		ImGui_ImplGlfw_NewFrame();
		ImGui::NewFrame();
		ImGuizmo::BeginFrame();
	}

	void ImGuiLayer::End()
	{
		HZ_PROFILE_FUNCTION();

		ImGuiIO& io = ImGui::GetIO();
		Application& app = Application::Get();
		io.DisplaySize = ImVec2((float)app.GetWindow().GetWidth(), (float)app.GetWindow().GetHeight());

		// Rendering
		ImGui::Render();
		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

		if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
		{
			GLFWwindow* backup_current_context = glfwGetCurrentContext();
			ImGui::UpdatePlatformWindows();
			ImGui::RenderPlatformWindowsDefault();
			glfwMakeContextCurrent(backup_current_context);
		}
	}

	void ImGuiLayer::SetDarkThemeColors()
	{
		auto& colors = ImGui::GetStyle().Colors;
		colors[ImGuiCol_WindowBg] = ImVec4{ 0.1f, 0.105f, 0.11f, 1.0f };

		// Headers
		colors[ImGuiCol_Header] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };
		colors[ImGuiCol_HeaderHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };
		colors[ImGuiCol_HeaderActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
		
		// Buttons
		colors[ImGuiCol_Button] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };
		colors[ImGuiCol_ButtonHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };
		colors[ImGuiCol_ButtonActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };

		// Frame BG
		colors[ImGuiCol_FrameBg] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };
		colors[ImGuiCol_FrameBgHovered] = ImVec4{ 0.3f, 0.305f, 0.31f, 1.0f };
		colors[ImGuiCol_FrameBgActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };

		// Tabs
		colors[ImGuiCol_Tab] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
		colors[ImGuiCol_TabHovered] = ImVec4{ 0.38f, 0.3805f, 0.381f, 1.0f };
		colors[ImGuiCol_TabActive] = ImVec4{ 0.28f, 0.2805f, 0.281f, 1.0f };
		colors[ImGuiCol_TabUnfocused] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
		colors[ImGuiCol_TabUnfocusedActive] = ImVec4{ 0.2f, 0.205f, 0.21f, 1.0f };

		// Title
		colors[ImGuiCol_TitleBg] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
		colors[ImGuiCol_TitleBgActive] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
		colors[ImGuiCol_TitleBgCollapsed] = ImVec4{ 0.15f, 0.1505f, 0.151f, 1.0f };
	}

	uint32_t ImGuiLayer::GetActiveWidgetID() const
	{
		return GImGui->ActiveId;
	}

}

```

`Hazel/src/Hazel/ImGui/ImGuiLayer.h`:

```h
#pragma once

#include "Hazel/Core/Layer.h"

#include "Hazel/Events/ApplicationEvent.h"
#include "Hazel/Events/KeyEvent.h"
#include "Hazel/Events/MouseEvent.h"

namespace Hazel {

	class ImGuiLayer : public Layer
	{
	public:
		ImGuiLayer();
		~ImGuiLayer() = default;

		virtual void OnAttach() override;
		virtual void OnDetach() override;
		virtual void OnEvent(Event& e) override;

		void Begin();
		void End();

		void BlockEvents(bool block) { m_BlockEvents = block; }
		
		void SetDarkThemeColors();

		uint32_t GetActiveWidgetID() const;
	private:
		bool m_BlockEvents = true;
	};

}

```

`Hazel/src/Hazel/Math/Math.cpp`:

```cpp
#include "hzpch.h"
#include "Math.h"

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/matrix_decompose.hpp>

namespace Hazel::Math {

	bool DecomposeTransform(const glm::mat4& transform, glm::vec3& translation, glm::vec3& rotation, glm::vec3& scale)
	{
		// From glm::decompose in matrix_decompose.inl

		using namespace glm;
		using T = float;

		mat4 LocalMatrix(transform);

		// Normalize the matrix.
		if (epsilonEqual(LocalMatrix[3][3], static_cast<float>(0), epsilon<T>()))
			return false;

		// First, isolate perspective.  This is the messiest.
		if (
			epsilonNotEqual(LocalMatrix[0][3], static_cast<T>(0), epsilon<T>()) ||
			epsilonNotEqual(LocalMatrix[1][3], static_cast<T>(0), epsilon<T>()) ||
			epsilonNotEqual(LocalMatrix[2][3], static_cast<T>(0), epsilon<T>()))
		{
			// Clear the perspective partition
			LocalMatrix[0][3] = LocalMatrix[1][3] = LocalMatrix[2][3] = static_cast<T>(0);
			LocalMatrix[3][3] = static_cast<T>(1);
		}

		// Next take care of translation (easy).
		translation = vec3(LocalMatrix[3]);
		LocalMatrix[3] = vec4(0, 0, 0, LocalMatrix[3].w);

		vec3 Row[3], Pdum3;

		// Now get scale and shear.
		for (length_t i = 0; i < 3; ++i)
			for (length_t j = 0; j < 3; ++j)
				Row[i][j] = LocalMatrix[i][j];

		// Compute X scale factor and normalize first row.
		scale.x = length(Row[0]);
		Row[0] = detail::scale(Row[0], static_cast<T>(1));
		scale.y = length(Row[1]);
		Row[1] = detail::scale(Row[1], static_cast<T>(1));
		scale.z = length(Row[2]);
		Row[2] = detail::scale(Row[2], static_cast<T>(1));

		// At this point, the matrix (in rows[]) is orthonormal.
		// Check for a coordinate system flip.  If the determinant
		// is -1, then negate the matrix and the scaling factors.
#if 0
		Pdum3 = cross(Row[1], Row[2]); // v3Cross(row[1], row[2], Pdum3);
		if (dot(Row[0], Pdum3) < 0)
		{
			for (length_t i = 0; i < 3; i++)
			{
				scale[i] *= static_cast<T>(-1);
				Row[i] *= static_cast<T>(-1);
			}
		}
#endif

		rotation.y = asin(-Row[0][2]);
		if (cos(rotation.y) != 0) {
			rotation.x = atan2(Row[1][2], Row[2][2]);
			rotation.z = atan2(Row[0][1], Row[0][0]);
		}
		else {
			rotation.x = atan2(-Row[2][0], Row[1][1]);
			rotation.z = 0;
		}


		return true;
	}

}

```

`Hazel/src/Hazel/Math/Math.h`:

```h
#pragma once

#include <glm/glm.hpp>

namespace Hazel::Math {

	bool DecomposeTransform(const glm::mat4& transform, glm::vec3& translation, glm::vec3& rotation, glm::vec3& scale);

}

```

`Hazel/src/Hazel/Physics/Physics2D.h`:

```h
#pragma once

#include "Hazel/Scene/Components.h"

#include "box2d/b2_body.h"

namespace Hazel {

	namespace Utils {

		inline b2BodyType Rigidbody2DTypeToBox2DBody(Rigidbody2DComponent::BodyType bodyType)
		{
			switch (bodyType)
			{
				case Rigidbody2DComponent::BodyType::Static:    return b2_staticBody;
				case Rigidbody2DComponent::BodyType::Dynamic:   return b2_dynamicBody;
				case Rigidbody2DComponent::BodyType::Kinematic: return b2_kinematicBody;
			}

			HZ_CORE_ASSERT(false, "Unknown body type");
			return b2_staticBody;
		}

		inline Rigidbody2DComponent::BodyType Rigidbody2DTypeFromBox2DBody(b2BodyType bodyType)
		{
			switch (bodyType)
			{
				case b2_staticBody:    return Rigidbody2DComponent::BodyType::Static;   
				case b2_dynamicBody:   return Rigidbody2DComponent::BodyType::Dynamic;  
				case b2_kinematicBody: return Rigidbody2DComponent::BodyType::Kinematic;
			}

			HZ_CORE_ASSERT(false, "Unknown body type");
			return Rigidbody2DComponent::BodyType::Static;
		}

	}

}

```

`Hazel/src/Hazel/Project/Project.cpp`:

```cpp
#include "hzpch.h"
#include "Project.h"

#include "ProjectSerializer.h"

namespace Hazel {

	Ref<Project> Project::New()
	{
		s_ActiveProject = CreateRef<Project>();
		return s_ActiveProject;
	}

	Ref<Project> Project::Load(const std::filesystem::path& path)
	{
		Ref<Project> project = CreateRef<Project>();

		ProjectSerializer serializer(project);
		if (serializer.Deserialize(path))
		{
			project->m_ProjectDirectory = path.parent_path();
			s_ActiveProject = project;
			return s_ActiveProject;
		}

		return nullptr;
	}

	bool Project::SaveActive(const std::filesystem::path& path)
	{
		ProjectSerializer serializer(s_ActiveProject);
		if (serializer.Serialize(path))
		{
			s_ActiveProject->m_ProjectDirectory = path.parent_path();
			return true;
		}

		return false;
	}

}

```

`Hazel/src/Hazel/Project/Project.h`:

```h
#pragma once

#include <string>
#include <filesystem>

#include "Hazel/Core/Base.h"

namespace Hazel {

	struct ProjectConfig
	{
		std::string Name = "Untitled";

		std::filesystem::path StartScene;

		std::filesystem::path AssetDirectory;
		std::filesystem::path ScriptModulePath;
	};

	class Project
	{
	public:
		static const std::filesystem::path& GetProjectDirectory()
		{
			HZ_CORE_ASSERT(s_ActiveProject);
			return s_ActiveProject->m_ProjectDirectory;
		}

		static std::filesystem::path GetAssetDirectory()
		{
			HZ_CORE_ASSERT(s_ActiveProject);
			return GetProjectDirectory() / s_ActiveProject->m_Config.AssetDirectory;
		}

		// TODO(Yan): move to asset manager when we have one
		static std::filesystem::path GetAssetFileSystemPath(const std::filesystem::path& path)
		{
			HZ_CORE_ASSERT(s_ActiveProject);
			return GetAssetDirectory() / path;
		}

		ProjectConfig& GetConfig() { return m_Config; }

		static Ref<Project> GetActive() { return s_ActiveProject; }

		static Ref<Project> New();
		static Ref<Project> Load(const std::filesystem::path& path);
		static bool SaveActive(const std::filesystem::path& path);
	private:
		ProjectConfig m_Config;
		std::filesystem::path m_ProjectDirectory;

		inline static Ref<Project> s_ActiveProject;
	};

}

```

`Hazel/src/Hazel/Project/ProjectSerializer.cpp`:

```cpp
#include "hzpch.h"
#include "ProjectSerializer.h"

#include <fstream>
#include <yaml-cpp/yaml.h>

namespace Hazel {

	ProjectSerializer::ProjectSerializer(Ref<Project> project)
		: m_Project(project)
	{
	}

	bool ProjectSerializer::Serialize(const std::filesystem::path& filepath)
	{
		const auto& config = m_Project->GetConfig();

		YAML::Emitter out;
		{
			out << YAML::BeginMap; // Root
			out << YAML::Key << "Project" << YAML::Value;
			{
				out << YAML::BeginMap;// Project
				out << YAML::Key << "Name" << YAML::Value << config.Name;
				out << YAML::Key << "StartScene" << YAML::Value << config.StartScene.string();
				out << YAML::Key << "AssetDirectory" << YAML::Value << config.AssetDirectory.string();
				out << YAML::Key << "ScriptModulePath" << YAML::Value << config.ScriptModulePath.string();
				out << YAML::EndMap; // Project
			}
			out << YAML::EndMap; // Root
		}

		std::ofstream fout(filepath);
		fout << out.c_str();

		return true;
	}

	bool ProjectSerializer::Deserialize(const std::filesystem::path& filepath)
	{
		auto& config = m_Project->GetConfig();

		YAML::Node data;
		try
		{
			data = YAML::LoadFile(filepath.string());
		}
		catch (YAML::ParserException e)
		{
			HZ_CORE_ERROR("Failed to load project file '{0}'\n     {1}", filepath, e.what());
			return false;
		}

		auto projectNode = data["Project"];
		if (!projectNode)
			return false;

		config.Name = projectNode["Name"].as<std::string>();
		config.StartScene = projectNode["StartScene"].as<std::string>();
		config.AssetDirectory = projectNode["AssetDirectory"].as<std::string>();
		config.ScriptModulePath = projectNode["ScriptModulePath"].as<std::string>();
		return true;
	}

}

```

`Hazel/src/Hazel/Project/ProjectSerializer.h`:

```h
#pragma once

#include "Project.h"

namespace Hazel {

	class ProjectSerializer
	{
	public:
		ProjectSerializer(Ref<Project> project);

		bool Serialize(const std::filesystem::path& filepath);
		bool Deserialize(const std::filesystem::path& filepath);
	private:
		Ref<Project> m_Project;
	};

}

```

`Hazel/src/Hazel/Renderer/Buffer.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/Buffer.h"

#include "Hazel/Renderer/Renderer.h"

#include "Platform/OpenGL/OpenGLBuffer.h"

namespace Hazel {

	Ref<VertexBuffer> VertexBuffer::Create(uint32_t size)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLVertexBuffer>(size);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

	Ref<VertexBuffer> VertexBuffer::Create(float* vertices, uint32_t size)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLVertexBuffer>(vertices, size);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

	Ref<IndexBuffer> IndexBuffer::Create(uint32_t* indices, uint32_t size)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLIndexBuffer>(indices, size);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}
```

`Hazel/src/Hazel/Renderer/Buffer.h`:

```h
#pragma once

namespace Hazel {

	enum class ShaderDataType
	{
		None = 0, Float, Float2, Float3, Float4, Mat3, Mat4, Int, Int2, Int3, Int4, Bool
	};

	static uint32_t ShaderDataTypeSize(ShaderDataType type)
	{
		switch (type)
		{
			case ShaderDataType::Float:    return 4;
			case ShaderDataType::Float2:   return 4 * 2;
			case ShaderDataType::Float3:   return 4 * 3;
			case ShaderDataType::Float4:   return 4 * 4;
			case ShaderDataType::Mat3:     return 4 * 3 * 3;
			case ShaderDataType::Mat4:     return 4 * 4 * 4;
			case ShaderDataType::Int:      return 4;
			case ShaderDataType::Int2:     return 4 * 2;
			case ShaderDataType::Int3:     return 4 * 3;
			case ShaderDataType::Int4:     return 4 * 4;
			case ShaderDataType::Bool:     return 1;
		}

		HZ_CORE_ASSERT(false, "Unknown ShaderDataType!");
		return 0;
	}

	struct BufferElement
	{
		std::string Name;
		ShaderDataType Type;
		uint32_t Size;
		size_t Offset;
		bool Normalized;

		BufferElement() = default;

		BufferElement(ShaderDataType type, const std::string& name, bool normalized = false)
			: Name(name), Type(type), Size(ShaderDataTypeSize(type)), Offset(0), Normalized(normalized)
		{
		}

		uint32_t GetComponentCount() const
		{
			switch (Type)
			{
				case ShaderDataType::Float:   return 1;
				case ShaderDataType::Float2:  return 2;
				case ShaderDataType::Float3:  return 3;
				case ShaderDataType::Float4:  return 4;
				case ShaderDataType::Mat3:    return 3; // 3* float3
				case ShaderDataType::Mat4:    return 4; // 4* float4
				case ShaderDataType::Int:     return 1;
				case ShaderDataType::Int2:    return 2;
				case ShaderDataType::Int3:    return 3;
				case ShaderDataType::Int4:    return 4;
				case ShaderDataType::Bool:    return 1;
			}

			HZ_CORE_ASSERT(false, "Unknown ShaderDataType!");
			return 0;
		}
	};

	class BufferLayout
	{
	public:
		BufferLayout() {}

		BufferLayout(std::initializer_list<BufferElement> elements)
			: m_Elements(elements)
		{
			CalculateOffsetsAndStride();
		}

		uint32_t GetStride() const { return m_Stride; }
		const std::vector<BufferElement>& GetElements() const { return m_Elements; }

		std::vector<BufferElement>::iterator begin() { return m_Elements.begin(); }
		std::vector<BufferElement>::iterator end() { return m_Elements.end(); }
		std::vector<BufferElement>::const_iterator begin() const { return m_Elements.begin(); }
		std::vector<BufferElement>::const_iterator end() const { return m_Elements.end(); }
	private:
		void CalculateOffsetsAndStride()
		{
			size_t offset = 0;
			m_Stride = 0;
			for (auto& element : m_Elements)
			{
				element.Offset = offset;
				offset += element.Size;
				m_Stride += element.Size;
			}
		}
	private:
		std::vector<BufferElement> m_Elements;
		uint32_t m_Stride = 0;
	};

	class VertexBuffer
	{
	public:
		virtual ~VertexBuffer() = default;

		virtual void Bind() const = 0;
		virtual void Unbind() const = 0;

		virtual void SetData(const void* data, uint32_t size) = 0;

		virtual const BufferLayout& GetLayout() const = 0;
		virtual void SetLayout(const BufferLayout& layout) = 0;

		static Ref<VertexBuffer> Create(uint32_t size);
		static Ref<VertexBuffer> Create(float* vertices, uint32_t size);
	};

	// Currently Hazel only supports 32-bit index buffers
	class IndexBuffer
	{
	public:
		virtual ~IndexBuffer() = default;

		virtual void Bind() const = 0;
		virtual void Unbind() const = 0;

		virtual uint32_t GetCount() const = 0;

		static Ref<IndexBuffer> Create(uint32_t* indices, uint32_t count);
	};

}

```

`Hazel/src/Hazel/Renderer/Camera.h`:

```h
#pragma once

#include <glm/glm.hpp>

namespace Hazel {

	class Camera
	{
	public:
		Camera() = default;
		Camera(const glm::mat4& projection)
			: m_Projection(projection) {}

		virtual ~Camera() = default;

		const glm::mat4& GetProjection() const { return m_Projection; }
	protected:
		glm::mat4 m_Projection = glm::mat4(1.0f);
	};

}
```

`Hazel/src/Hazel/Renderer/EditorCamera.cpp`:

```cpp
#include "hzpch.h"
#include "EditorCamera.h"

#include "Hazel/Core/Input.h"
#include "Hazel/Core/KeyCodes.h"
#include "Hazel/Core/MouseCodes.h"

#include <glfw/glfw3.h>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/quaternion.hpp>

namespace Hazel {

	EditorCamera::EditorCamera(float fov, float aspectRatio, float nearClip, float farClip)
		: m_FOV(fov), m_AspectRatio(aspectRatio), m_NearClip(nearClip), m_FarClip(farClip), Camera(glm::perspective(glm::radians(fov), aspectRatio, nearClip, farClip))
	{
		UpdateView();
	}

	void EditorCamera::UpdateProjection()
	{
		m_AspectRatio = m_ViewportWidth / m_ViewportHeight;
		m_Projection = glm::perspective(glm::radians(m_FOV), m_AspectRatio, m_NearClip, m_FarClip);
	}

	void EditorCamera::UpdateView()
	{
		// m_Yaw = m_Pitch = 0.0f; // Lock the camera's rotation
		m_Position = CalculatePosition();

		glm::quat orientation = GetOrientation();
		m_ViewMatrix = glm::translate(glm::mat4(1.0f), m_Position) * glm::toMat4(orientation);
		m_ViewMatrix = glm::inverse(m_ViewMatrix);
	}

	std::pair<float, float> EditorCamera::PanSpeed() const
	{
		float x = std::min(m_ViewportWidth / 1000.0f, 2.4f); // max = 2.4f
		float xFactor = 0.0366f * (x * x) - 0.1778f * x + 0.3021f;

		float y = std::min(m_ViewportHeight / 1000.0f, 2.4f); // max = 2.4f
		float yFactor = 0.0366f * (y * y) - 0.1778f * y + 0.3021f;

		return { xFactor, yFactor };
	}

	float EditorCamera::RotationSpeed() const
	{
		return 0.8f;
	}

	float EditorCamera::ZoomSpeed() const
	{
		float distance = m_Distance * 0.2f;
		distance = std::max(distance, 0.0f);
		float speed = distance * distance;
		speed = std::min(speed, 100.0f); // max speed = 100
		return speed;
	}

	void EditorCamera::OnUpdate(Timestep ts)
	{
		if (Input::IsKeyPressed(Key::LeftAlt))
		{
			const glm::vec2& mouse{ Input::GetMouseX(), Input::GetMouseY() };
			glm::vec2 delta = (mouse - m_InitialMousePosition) * 0.003f;
			m_InitialMousePosition = mouse;

			if (Input::IsMouseButtonPressed(Mouse::ButtonMiddle))
				MousePan(delta);
			else if (Input::IsMouseButtonPressed(Mouse::ButtonLeft))
				MouseRotate(delta);
			else if (Input::IsMouseButtonPressed(Mouse::ButtonRight))
				MouseZoom(delta.y);
		}

		UpdateView();
	}

	void EditorCamera::OnEvent(Event& e)
	{
		EventDispatcher dispatcher(e);
		dispatcher.Dispatch<MouseScrolledEvent>(HZ_BIND_EVENT_FN(EditorCamera::OnMouseScroll));
	}

	bool EditorCamera::OnMouseScroll(MouseScrolledEvent& e)
	{
		float delta = e.GetYOffset() * 0.1f;
		MouseZoom(delta);
		UpdateView();
		return false;
	}

	void EditorCamera::MousePan(const glm::vec2& delta)
	{
		auto [xSpeed, ySpeed] = PanSpeed();
		m_FocalPoint += -GetRightDirection() * delta.x * xSpeed * m_Distance;
		m_FocalPoint += GetUpDirection() * delta.y * ySpeed * m_Distance;
	}

	void EditorCamera::MouseRotate(const glm::vec2& delta)
	{
		float yawSign = GetUpDirection().y < 0 ? -1.0f : 1.0f;
		m_Yaw += yawSign * delta.x * RotationSpeed();
		m_Pitch += delta.y * RotationSpeed();
	}

	void EditorCamera::MouseZoom(float delta)
	{
		m_Distance -= delta * ZoomSpeed();
		if (m_Distance < 1.0f)
		{
			m_FocalPoint += GetForwardDirection();
			m_Distance = 1.0f;
		}
	}

	glm::vec3 EditorCamera::GetUpDirection() const
	{
		return glm::rotate(GetOrientation(), glm::vec3(0.0f, 1.0f, 0.0f));
	}

	glm::vec3 EditorCamera::GetRightDirection() const
	{
		return glm::rotate(GetOrientation(), glm::vec3(1.0f, 0.0f, 0.0f));
	}

	glm::vec3 EditorCamera::GetForwardDirection() const
	{
		return glm::rotate(GetOrientation(), glm::vec3(0.0f, 0.0f, -1.0f));
	}

	glm::vec3 EditorCamera::CalculatePosition() const
	{
		return m_FocalPoint - GetForwardDirection() * m_Distance;
	}

	glm::quat EditorCamera::GetOrientation() const
	{
		return glm::quat(glm::vec3(-m_Pitch, -m_Yaw, 0.0f));
	}

}

```

`Hazel/src/Hazel/Renderer/EditorCamera.h`:

```h
#pragma once

#include "Camera.h"
#include "Hazel/Core/Timestep.h"
#include "Hazel/Events/Event.h"
#include "Hazel/Events/MouseEvent.h"

#include <glm/glm.hpp>

namespace Hazel {

	class EditorCamera : public Camera
	{
	public:
		EditorCamera() = default;
		EditorCamera(float fov, float aspectRatio, float nearClip, float farClip);

		void OnUpdate(Timestep ts);
		void OnEvent(Event& e);

		inline float GetDistance() const { return m_Distance; }
		inline void SetDistance(float distance) { m_Distance = distance; }

		inline void SetViewportSize(float width, float height) { m_ViewportWidth = width; m_ViewportHeight = height; UpdateProjection(); }

		const glm::mat4& GetViewMatrix() const { return m_ViewMatrix; }
		glm::mat4 GetViewProjection() const { return m_Projection * m_ViewMatrix; }

		glm::vec3 GetUpDirection() const;
		glm::vec3 GetRightDirection() const;
		glm::vec3 GetForwardDirection() const;
		const glm::vec3& GetPosition() const { return m_Position; }
		glm::quat GetOrientation() const;

		float GetPitch() const { return m_Pitch; }
		float GetYaw() const { return m_Yaw; }
	private:
		void UpdateProjection();
		void UpdateView();

		bool OnMouseScroll(MouseScrolledEvent& e);

		void MousePan(const glm::vec2& delta);
		void MouseRotate(const glm::vec2& delta);
		void MouseZoom(float delta);

		glm::vec3 CalculatePosition() const;

		std::pair<float, float> PanSpeed() const;
		float RotationSpeed() const;
		float ZoomSpeed() const;
	private:
		float m_FOV = 45.0f, m_AspectRatio = 1.778f, m_NearClip = 0.1f, m_FarClip = 1000.0f;

		glm::mat4 m_ViewMatrix;
		glm::vec3 m_Position = { 0.0f, 0.0f, 0.0f };
		glm::vec3 m_FocalPoint = { 0.0f, 0.0f, 0.0f };

		glm::vec2 m_InitialMousePosition = { 0.0f, 0.0f };

		float m_Distance = 10.0f;
		float m_Pitch = 0.0f, m_Yaw = 0.0f;

		float m_ViewportWidth = 1280, m_ViewportHeight = 720;
	};

}

```

`Hazel/src/Hazel/Renderer/Font.cpp`:

```cpp
#include "hzpch.h"
#include "Font.h"

#undef INFINITE
#include "msdf-atlas-gen.h"
#include "FontGeometry.h"
#include "GlyphGeometry.h"

#include "MSDFData.h"

namespace Hazel {

	template<typename T, typename S, int N, msdf_atlas::GeneratorFunction<S, N> GenFunc>
	static Ref<Texture2D> CreateAndCacheAtlas(const std::string& fontName, float fontSize, const std::vector<msdf_atlas::GlyphGeometry>& glyphs,
		const msdf_atlas::FontGeometry& fontGeometry, uint32_t width, uint32_t height)
	{
		msdf_atlas::GeneratorAttributes attributes;
		attributes.config.overlapSupport = true;
		attributes.scanlinePass = true;

		msdf_atlas::ImmediateAtlasGenerator<S, N, GenFunc, msdf_atlas::BitmapAtlasStorage<T, N>> generator(width, height);
		generator.setAttributes(attributes);
		generator.setThreadCount(8);
		generator.generate(glyphs.data(), (int)glyphs.size());

		msdfgen::BitmapConstRef<T, N> bitmap = (msdfgen::BitmapConstRef<T, N>)generator.atlasStorage();

		TextureSpecification spec;
		spec.Width = bitmap.width;
		spec.Height = bitmap.height;
		spec.Format = ImageFormat::RGB8;
		spec.GenerateMips = false;

		Ref<Texture2D> texture = Texture2D::Create(spec);
		texture->SetData((void*)bitmap.pixels, bitmap.width * bitmap.height * 3);
		return texture;
	}

	Font::Font(const std::filesystem::path& filepath)
		: m_Data(new MSDFData())
	{
		msdfgen::FreetypeHandle* ft = msdfgen::initializeFreetype();
		HZ_CORE_ASSERT(ft);
		
		std::string fileString = filepath.string();

		// TODO(Yan): msdfgen::loadFontData loads from memory buffer which we'll need 
		msdfgen::FontHandle* font = msdfgen::loadFont(ft, fileString.c_str());
		if (!font)
		{
			HZ_CORE_ERROR("Failed to load font: {}", fileString);
			return;
		}

		struct CharsetRange
		{
			uint32_t Begin, End;
		};

		// From imgui_draw.cpp
		static const CharsetRange charsetRanges[] =
		{
			{ 0x0020, 0x00FF }
		};

		msdf_atlas::Charset charset;
		for (CharsetRange range : charsetRanges)
		{
			for (uint32_t c = range.Begin; c <= range.End; c++)
				charset.add(c);
		}
		
		double fontScale = 1.0;
		m_Data->FontGeometry = msdf_atlas::FontGeometry(&m_Data->Glyphs);
		int glyphsLoaded = m_Data->FontGeometry.loadCharset(font, fontScale, charset);
		HZ_CORE_INFO("Loaded {} glyphs from font (out of {})", glyphsLoaded, charset.size());


		double emSize = 40.0;

		msdf_atlas::TightAtlasPacker atlasPacker;
		// atlasPacker.setDimensionsConstraint()
		atlasPacker.setPixelRange(2.0);
		atlasPacker.setMiterLimit(1.0);
		atlasPacker.setPadding(0);
		atlasPacker.setScale(emSize);
		int remaining = atlasPacker.pack(m_Data->Glyphs.data(), (int)m_Data->Glyphs.size());
		HZ_CORE_ASSERT(remaining == 0);

		int width, height;
		atlasPacker.getDimensions(width, height);
		emSize = atlasPacker.getScale();

#define DEFAULT_ANGLE_THRESHOLD 3.0
#define LCG_MULTIPLIER 6364136223846793005ull
#define LCG_INCREMENT 1442695040888963407ull
#define THREAD_COUNT 8
		// if MSDF || MTSDF

		uint64_t coloringSeed = 0;
		bool expensiveColoring = false;
		if (expensiveColoring)
		{
			msdf_atlas::Workload([&glyphs = m_Data->Glyphs, &coloringSeed](int i, int threadNo) -> bool {
				unsigned long long glyphSeed = (LCG_MULTIPLIER * (coloringSeed ^ i) + LCG_INCREMENT) * !!coloringSeed;
				glyphs[i].edgeColoring(msdfgen::edgeColoringInkTrap, DEFAULT_ANGLE_THRESHOLD, glyphSeed);
				return true;
				}, m_Data->Glyphs.size()).finish(THREAD_COUNT);
		}
		else {
			unsigned long long glyphSeed = coloringSeed;
			for (msdf_atlas::GlyphGeometry& glyph : m_Data->Glyphs)
			{
				glyphSeed *= LCG_MULTIPLIER;
				glyph.edgeColoring(msdfgen::edgeColoringInkTrap, DEFAULT_ANGLE_THRESHOLD, glyphSeed);
			}
		}


		m_AtlasTexture = CreateAndCacheAtlas<uint8_t, float, 3, msdf_atlas::msdfGenerator>("Test", (float)emSize, m_Data->Glyphs, m_Data->FontGeometry, width, height);


#if 0
		msdfgen::Shape shape;
		if (msdfgen::loadGlyph(shape, font, 'C'))
		{
			shape.normalize();
			//                      max. angle
			msdfgen::edgeColoringSimple(shape, 3.0);
			//           image width, height
			msdfgen::Bitmap<float, 3> msdf(32, 32);
			//                     range, scale, translation
			msdfgen::generateMSDF(msdf, shape, 4.0, 1.0, msdfgen::Vector2(4.0, 4.0));
			msdfgen::savePng(msdf, "output.png");
		}
#endif

		msdfgen::destroyFont(font);
		msdfgen::deinitializeFreetype(ft);
	}

	Font::~Font()
	{
		delete m_Data;
	}


	Ref<Font> Font::GetDefault()
	{
		static Ref<Font> DefaultFont;
		if (!DefaultFont)
			DefaultFont = CreateRef<Font>("assets/fonts/opensans/OpenSans-Regular.ttf");

		return DefaultFont;
	}

}

```

`Hazel/src/Hazel/Renderer/Font.h`:

```h
#pragma once

#include <filesystem>

#include "Hazel/Core/Base.h"
#include "Hazel/Renderer/Texture.h"

namespace Hazel {

	struct MSDFData;

	class Font
	{
	public:
		Font(const std::filesystem::path& font);
		~Font();

		const MSDFData* GetMSDFData() const { return m_Data; }
		Ref<Texture2D> GetAtlasTexture() const { return m_AtlasTexture; }

		static Ref<Font> GetDefault();
	private:
		MSDFData* m_Data;
		Ref<Texture2D> m_AtlasTexture;
	};

}

```

`Hazel/src/Hazel/Renderer/Framebuffer.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/Framebuffer.h"

#include "Hazel/Renderer/Renderer.h"

#include "Platform/OpenGL/OpenGLFramebuffer.h"

namespace Hazel {
	
	Ref<Framebuffer> Framebuffer::Create(const FramebufferSpecification& spec)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLFramebuffer>(spec);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}


```

`Hazel/src/Hazel/Renderer/Framebuffer.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"

namespace Hazel {

	enum class FramebufferTextureFormat
	{
		None = 0,

		// Color
		RGBA8,
		RED_INTEGER,

		// Depth/stencil
		DEPTH24STENCIL8,

		// Defaults
		Depth = DEPTH24STENCIL8
	};

	struct FramebufferTextureSpecification
	{
		FramebufferTextureSpecification() = default;
		FramebufferTextureSpecification(FramebufferTextureFormat format)
			: TextureFormat(format) {}

		FramebufferTextureFormat TextureFormat = FramebufferTextureFormat::None;
		// TODO: filtering/wrap
	};

	struct FramebufferAttachmentSpecification
	{
		FramebufferAttachmentSpecification() = default;
		FramebufferAttachmentSpecification(std::initializer_list<FramebufferTextureSpecification> attachments)
			: Attachments(attachments) {}

		std::vector<FramebufferTextureSpecification> Attachments;
	};

	struct FramebufferSpecification
	{
		uint32_t Width = 0, Height = 0;
		FramebufferAttachmentSpecification Attachments;
		uint32_t Samples = 1;

		bool SwapChainTarget = false;
	};

	class Framebuffer
	{
	public:
		virtual ~Framebuffer() = default;

		virtual void Bind() = 0;
		virtual void Unbind() = 0;

		virtual void Resize(uint32_t width, uint32_t height) = 0;
		virtual int ReadPixel(uint32_t attachmentIndex, int x, int y) = 0;

		virtual void ClearAttachment(uint32_t attachmentIndex, int value) = 0;

		virtual uint32_t GetColorAttachmentRendererID(uint32_t index = 0) const = 0;

		virtual const FramebufferSpecification& GetSpecification() const = 0;

		static Ref<Framebuffer> Create(const FramebufferSpecification& spec);
	};


}

```

`Hazel/src/Hazel/Renderer/GraphicsContext.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/GraphicsContext.h"

#include "Hazel/Renderer/Renderer.h"
#include "Platform/OpenGL/OpenGLContext.h"

namespace Hazel {

	Scope<GraphicsContext> GraphicsContext::Create(void* window)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateScope<OpenGLContext>(static_cast<GLFWwindow*>(window));
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}
```

`Hazel/src/Hazel/Renderer/GraphicsContext.h`:

```h
#pragma once

namespace Hazel {

	class GraphicsContext
	{
	public:
		virtual ~GraphicsContext() = default;

		virtual void Init() = 0;
		virtual void SwapBuffers() = 0;

		static Scope<GraphicsContext> Create(void* window);
	};

}
```

`Hazel/src/Hazel/Renderer/MSDFData.h`:

```h
#pragma once

#include <vector>

#undef INFINITE
#include "msdf-atlas-gen.h"

namespace Hazel {

	struct MSDFData
	{
		std::vector<msdf_atlas::GlyphGeometry> Glyphs;
		msdf_atlas::FontGeometry FontGeometry;
	};


}

```

`Hazel/src/Hazel/Renderer/OrthographicCamera.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/OrthographicCamera.h"

#include <glm/gtc/matrix_transform.hpp>

namespace Hazel {

	OrthographicCamera::OrthographicCamera(float left, float right, float bottom, float top)
		: m_ProjectionMatrix(glm::ortho(left, right, bottom, top, -1.0f, 1.0f)), m_ViewMatrix(1.0f)
	{
		HZ_PROFILE_FUNCTION();

		m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
	}

	void OrthographicCamera::SetProjection(float left, float right, float bottom, float top)
	{
		HZ_PROFILE_FUNCTION();

		m_ProjectionMatrix = glm::ortho(left, right, bottom, top, -1.0f, 1.0f);
		m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
	}

	void OrthographicCamera::RecalculateViewMatrix()
	{
		HZ_PROFILE_FUNCTION();

		glm::mat4 transform = glm::translate(glm::mat4(1.0f), m_Position) *
			glm::rotate(glm::mat4(1.0f), glm::radians(m_Rotation), glm::vec3(0, 0, 1));

		m_ViewMatrix = glm::inverse(transform);
		m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
	}

}
```

`Hazel/src/Hazel/Renderer/OrthographicCamera.h`:

```h
#pragma once

#include <glm/glm.hpp>

namespace Hazel {

	class OrthographicCamera
	{
	public:
		OrthographicCamera(float left, float right, float bottom, float top);

		void SetProjection(float left, float right, float bottom, float top);

		const glm::vec3& GetPosition() const { return m_Position; }
		void SetPosition(const glm::vec3& position) { m_Position = position; RecalculateViewMatrix(); }

		float GetRotation() const { return m_Rotation; }
		void SetRotation(float rotation) { m_Rotation = rotation; RecalculateViewMatrix(); }

		const glm::mat4& GetProjectionMatrix() const { return m_ProjectionMatrix; }
		const glm::mat4& GetViewMatrix() const { return m_ViewMatrix; }
		const glm::mat4& GetViewProjectionMatrix() const { return m_ViewProjectionMatrix; }
	private:
		void RecalculateViewMatrix();
	private:
		glm::mat4 m_ProjectionMatrix;
		glm::mat4 m_ViewMatrix;
		glm::mat4 m_ViewProjectionMatrix;

		glm::vec3 m_Position = { 0.0f, 0.0f, 0.0f };
		float m_Rotation = 0.0f;
	};

}

```

`Hazel/src/Hazel/Renderer/OrthographicCameraController.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/OrthographicCameraController.h"

#include "Hazel/Core/Input.h"
#include "Hazel/Core/KeyCodes.h"

namespace Hazel {

	OrthographicCameraController::OrthographicCameraController(float aspectRatio, bool rotation)
		: m_AspectRatio(aspectRatio), m_Camera(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel), m_Rotation(rotation)
	{
	}

	void OrthographicCameraController::OnUpdate(Timestep ts)
	{
		HZ_PROFILE_FUNCTION();

		if (Input::IsKeyPressed(Key::A))
		{
			m_CameraPosition.x -= cos(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
			m_CameraPosition.y -= sin(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
		}
		else if (Input::IsKeyPressed(Key::D))
		{
			m_CameraPosition.x += cos(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
			m_CameraPosition.y += sin(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
		}

		if (Input::IsKeyPressed(Key::W))
		{
			m_CameraPosition.x += -sin(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
			m_CameraPosition.y += cos(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
		}
		else if (Input::IsKeyPressed(Key::S))
		{
			m_CameraPosition.x -= -sin(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
			m_CameraPosition.y -= cos(glm::radians(m_CameraRotation)) * m_CameraTranslationSpeed * ts;
		}

		if (m_Rotation)
		{
			if (Input::IsKeyPressed(Key::Q))
				m_CameraRotation += m_CameraRotationSpeed * ts;
			if (Input::IsKeyPressed(Key::E))
				m_CameraRotation -= m_CameraRotationSpeed * ts;

			if (m_CameraRotation > 180.0f)
				m_CameraRotation -= 360.0f;
			else if (m_CameraRotation <= -180.0f)
				m_CameraRotation += 360.0f;

			m_Camera.SetRotation(m_CameraRotation);
		}

		m_Camera.SetPosition(m_CameraPosition);

		m_CameraTranslationSpeed = m_ZoomLevel;
	}

	void OrthographicCameraController::OnEvent(Event& e)
	{
		HZ_PROFILE_FUNCTION();

		EventDispatcher dispatcher(e);
		dispatcher.Dispatch<MouseScrolledEvent>(HZ_BIND_EVENT_FN(OrthographicCameraController::OnMouseScrolled));
		dispatcher.Dispatch<WindowResizeEvent>(HZ_BIND_EVENT_FN(OrthographicCameraController::OnWindowResized));
	}

	void OrthographicCameraController::OnResize(float width, float height)
	{
		m_AspectRatio = width / height;
		m_Camera.SetProjection(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel);
	}

	bool OrthographicCameraController::OnMouseScrolled(MouseScrolledEvent& e)
	{
		HZ_PROFILE_FUNCTION();

		m_ZoomLevel -= e.GetYOffset() * 0.25f;
		m_ZoomLevel = std::max(m_ZoomLevel, 0.25f);
		m_Camera.SetProjection(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel);
		return false;
	}

	bool OrthographicCameraController::OnWindowResized(WindowResizeEvent& e)
	{
		HZ_PROFILE_FUNCTION();

		OnResize((float)e.GetWidth(), (float)e.GetHeight());
		return false;
	}

}
```

`Hazel/src/Hazel/Renderer/OrthographicCameraController.h`:

```h
#pragma once

#include "Hazel/Renderer/OrthographicCamera.h"
#include "Hazel/Core/Timestep.h"

#include "Hazel/Events/ApplicationEvent.h"
#include "Hazel/Events/MouseEvent.h"

namespace Hazel {

	class OrthographicCameraController
	{
	public:
		OrthographicCameraController(float aspectRatio, bool rotation = false);

		void OnUpdate(Timestep ts);
		void OnEvent(Event& e);

		void OnResize(float width, float height);

		OrthographicCamera& GetCamera() { return m_Camera; }
		const OrthographicCamera& GetCamera() const { return m_Camera; }

		float GetZoomLevel() const { return m_ZoomLevel; }
		void SetZoomLevel(float level) { m_ZoomLevel = level; }
	private:
		bool OnMouseScrolled(MouseScrolledEvent& e);
		bool OnWindowResized(WindowResizeEvent& e);
	private:
		float m_AspectRatio;
		float m_ZoomLevel = 1.0f;
		OrthographicCamera m_Camera;

		bool m_Rotation;

		glm::vec3 m_CameraPosition = { 0.0f, 0.0f, 0.0f };
		float m_CameraRotation = 0.0f; //In degrees, in the anti-clockwise direction
		float m_CameraTranslationSpeed = 5.0f, m_CameraRotationSpeed = 180.0f;
	};

}
```

`Hazel/src/Hazel/Renderer/RenderCommand.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/RenderCommand.h"

namespace Hazel {

	Scope<RendererAPI> RenderCommand::s_RendererAPI = RendererAPI::Create();

}
```

`Hazel/src/Hazel/Renderer/RenderCommand.h`:

```h
#pragma once

#include "Hazel/Renderer/RendererAPI.h"

namespace Hazel {

	class RenderCommand
	{
	public:
		static void Init()
		{
			s_RendererAPI->Init();
		}

		static void SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
		{
			s_RendererAPI->SetViewport(x, y, width, height);
		}

		static void SetClearColor(const glm::vec4& color)
		{
			s_RendererAPI->SetClearColor(color);
		}

		static void Clear()
		{
			s_RendererAPI->Clear();
		}

		static void DrawIndexed(const Ref<VertexArray>& vertexArray, uint32_t indexCount = 0)
		{
			s_RendererAPI->DrawIndexed(vertexArray, indexCount);
		}

		static void DrawLines(const Ref<VertexArray>& vertexArray, uint32_t vertexCount)
		{
			s_RendererAPI->DrawLines(vertexArray, vertexCount);
		}

		static void SetLineWidth(float width)
		{
			s_RendererAPI->SetLineWidth(width);
		}
	private:
		static Scope<RendererAPI> s_RendererAPI;
	};

}

```

`Hazel/src/Hazel/Renderer/Renderer.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/Renderer.h"
#include "Hazel/Renderer/Renderer2D.h"

namespace Hazel {

	Scope<Renderer::SceneData> Renderer::s_SceneData = CreateScope<Renderer::SceneData>();

	void Renderer::Init()
	{
		HZ_PROFILE_FUNCTION();

		RenderCommand::Init();
		Renderer2D::Init();
	}

	void Renderer::Shutdown()
	{
		Renderer2D::Shutdown();
	}

	void Renderer::OnWindowResize(uint32_t width, uint32_t height)
	{
		RenderCommand::SetViewport(0, 0, width, height);
	}

	void Renderer::BeginScene(OrthographicCamera& camera)
	{
		s_SceneData->ViewProjectionMatrix = camera.GetViewProjectionMatrix();
	}

	void Renderer::EndScene()
	{
	}

	void Renderer::Submit(const Ref<Shader>& shader, const Ref<VertexArray>& vertexArray, const glm::mat4& transform)
	{
		shader->Bind();
		shader->SetMat4("u_ViewProjection", s_SceneData->ViewProjectionMatrix);
		shader->SetMat4("u_Transform", transform);

		vertexArray->Bind();
		RenderCommand::DrawIndexed(vertexArray);
	}

}

```

`Hazel/src/Hazel/Renderer/Renderer.h`:

```h
#pragma once

#include "Hazel/Renderer/RenderCommand.h"

#include "Hazel/Renderer/OrthographicCamera.h"
#include "Hazel/Renderer/Shader.h"

namespace Hazel {

	class Renderer
	{
	public:
		static void Init();
		static void Shutdown();
		
		static void OnWindowResize(uint32_t width, uint32_t height);

		static void BeginScene(OrthographicCamera& camera);
		static void EndScene();

		static void Submit(const Ref<Shader>& shader, const Ref<VertexArray>& vertexArray, const glm::mat4& transform = glm::mat4(1.0f));

		static RendererAPI::API GetAPI() { return RendererAPI::GetAPI(); }
	private:
		struct SceneData
		{
			glm::mat4 ViewProjectionMatrix;
		};

		static Scope<SceneData> s_SceneData;
	};
}

```

`Hazel/src/Hazel/Renderer/Renderer2D.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/Renderer2D.h"

#include "Hazel/Renderer/VertexArray.h"
#include "Hazel/Renderer/Shader.h"
#include "Hazel/Renderer/UniformBuffer.h"
#include "Hazel/Renderer/RenderCommand.h"

#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "MSDFData.h"

namespace Hazel {

	struct QuadVertex
	{
		glm::vec3 Position;
		glm::vec4 Color;
		glm::vec2 TexCoord;
		float TexIndex;
		float TilingFactor;
		
		// Editor-only
		int EntityID;
	};

	struct CircleVertex
	{
		glm::vec3 WorldPosition;
		glm::vec3 LocalPosition;
		glm::vec4 Color;
		float Thickness;
		float Fade;

		// Editor-only
		int EntityID;
	};

	struct LineVertex
	{
		glm::vec3 Position;
		glm::vec4 Color;

		// Editor-only
		int EntityID;
	};

	struct TextVertex
	{
		glm::vec3 Position;
		glm::vec4 Color;
		glm::vec2 TexCoord;

		// TODO: bg color for outline/bg

		// Editor-only
		int EntityID;
	};

	struct Renderer2DData
	{
		static const uint32_t MaxQuads = 20000;
		static const uint32_t MaxVertices = MaxQuads * 4;
		static const uint32_t MaxIndices = MaxQuads * 6;
		static const uint32_t MaxTextureSlots = 32; // TODO: RenderCaps

		Ref<VertexArray> QuadVertexArray;
		Ref<VertexBuffer> QuadVertexBuffer;
		Ref<Shader> QuadShader;
		Ref<Texture2D> WhiteTexture;

		Ref<VertexArray> CircleVertexArray;
		Ref<VertexBuffer> CircleVertexBuffer;
		Ref<Shader> CircleShader;

		Ref<VertexArray> LineVertexArray;
		Ref<VertexBuffer> LineVertexBuffer;
		Ref<Shader> LineShader;	
		
		Ref<VertexArray> TextVertexArray;
		Ref<VertexBuffer> TextVertexBuffer;
		Ref<Shader> TextShader;

		uint32_t QuadIndexCount = 0;
		QuadVertex* QuadVertexBufferBase = nullptr;
		QuadVertex* QuadVertexBufferPtr = nullptr;

		uint32_t CircleIndexCount = 0;
		CircleVertex* CircleVertexBufferBase = nullptr;
		CircleVertex* CircleVertexBufferPtr = nullptr;

		uint32_t LineVertexCount = 0;
		LineVertex* LineVertexBufferBase = nullptr;
		LineVertex* LineVertexBufferPtr = nullptr;

		uint32_t TextIndexCount = 0;
		TextVertex* TextVertexBufferBase = nullptr;
		TextVertex* TextVertexBufferPtr = nullptr;

		float LineWidth = 2.0f;

		std::array<Ref<Texture2D>, MaxTextureSlots> TextureSlots;
		uint32_t TextureSlotIndex = 1; // 0 = white texture
		
		Ref<Texture2D> FontAtlasTexture;

		glm::vec4 QuadVertexPositions[4];

		Renderer2D::Statistics Stats;

		struct CameraData
		{
			glm::mat4 ViewProjection;
		};
		CameraData CameraBuffer;
		Ref<UniformBuffer> CameraUniformBuffer;
	};

	static Renderer2DData s_Data;

	void Renderer2D::Init()
	{
		HZ_PROFILE_FUNCTION();

		s_Data.QuadVertexArray = VertexArray::Create();

		s_Data.QuadVertexBuffer = VertexBuffer::Create(s_Data.MaxVertices * sizeof(QuadVertex));
		s_Data.QuadVertexBuffer->SetLayout({
			{ ShaderDataType::Float3, "a_Position"     },
			{ ShaderDataType::Float4, "a_Color"        },
			{ ShaderDataType::Float2, "a_TexCoord"     },
			{ ShaderDataType::Float,  "a_TexIndex"     },
			{ ShaderDataType::Float,  "a_TilingFactor" },
			{ ShaderDataType::Int,    "a_EntityID"     }
		});
		s_Data.QuadVertexArray->AddVertexBuffer(s_Data.QuadVertexBuffer);

		s_Data.QuadVertexBufferBase = new QuadVertex[s_Data.MaxVertices];

		uint32_t* quadIndices = new uint32_t[s_Data.MaxIndices];

		uint32_t offset = 0;
		for (uint32_t i = 0; i < s_Data.MaxIndices; i += 6)
		{
			quadIndices[i + 0] = offset + 0;
			quadIndices[i + 1] = offset + 1;
			quadIndices[i + 2] = offset + 2;

			quadIndices[i + 3] = offset + 2;
			quadIndices[i + 4] = offset + 3;
			quadIndices[i + 5] = offset + 0;

			offset += 4;
		}

		Ref<IndexBuffer> quadIB = IndexBuffer::Create(quadIndices, s_Data.MaxIndices);
		s_Data.QuadVertexArray->SetIndexBuffer(quadIB);
		delete[] quadIndices;

		// Circles
		s_Data.CircleVertexArray = VertexArray::Create();

		s_Data.CircleVertexBuffer = VertexBuffer::Create(s_Data.MaxVertices * sizeof(CircleVertex));
		s_Data.CircleVertexBuffer->SetLayout({
			{ ShaderDataType::Float3, "a_WorldPosition" },
			{ ShaderDataType::Float3, "a_LocalPosition" },
			{ ShaderDataType::Float4, "a_Color"         },
			{ ShaderDataType::Float,  "a_Thickness"     },
			{ ShaderDataType::Float,  "a_Fade"          },
			{ ShaderDataType::Int,    "a_EntityID"      }
		});
		s_Data.CircleVertexArray->AddVertexBuffer(s_Data.CircleVertexBuffer);
		s_Data.CircleVertexArray->SetIndexBuffer(quadIB); // Use quad IB
		s_Data.CircleVertexBufferBase = new CircleVertex[s_Data.MaxVertices];

		// Lines
		s_Data.LineVertexArray = VertexArray::Create();

		s_Data.LineVertexBuffer = VertexBuffer::Create(s_Data.MaxVertices * sizeof(LineVertex));
		s_Data.LineVertexBuffer->SetLayout({
			{ ShaderDataType::Float3, "a_Position" },
			{ ShaderDataType::Float4, "a_Color"    },
			{ ShaderDataType::Int,    "a_EntityID" }
		});
		s_Data.LineVertexArray->AddVertexBuffer(s_Data.LineVertexBuffer);
		s_Data.LineVertexBufferBase = new LineVertex[s_Data.MaxVertices];

		// Text
		s_Data.TextVertexArray = VertexArray::Create();

		s_Data.TextVertexBuffer = VertexBuffer::Create(s_Data.MaxVertices * sizeof(TextVertex));
		s_Data.TextVertexBuffer->SetLayout({
			{ ShaderDataType::Float3, "a_Position"     },
			{ ShaderDataType::Float4, "a_Color"        },
			{ ShaderDataType::Float2, "a_TexCoord"     },
			{ ShaderDataType::Int,    "a_EntityID"     }
		});
		s_Data.TextVertexArray->AddVertexBuffer(s_Data.TextVertexBuffer);
		s_Data.TextVertexArray->SetIndexBuffer(quadIB);
		s_Data.TextVertexBufferBase = new TextVertex[s_Data.MaxVertices];

		s_Data.WhiteTexture = Texture2D::Create(TextureSpecification());
		uint32_t whiteTextureData = 0xffffffff;
		s_Data.WhiteTexture->SetData(&whiteTextureData, sizeof(uint32_t));

		int32_t samplers[s_Data.MaxTextureSlots];
		for (uint32_t i = 0; i < s_Data.MaxTextureSlots; i++)
			samplers[i] = i;

		s_Data.QuadShader = Shader::Create("assets/shaders/Renderer2D_Quad.glsl");
		s_Data.CircleShader = Shader::Create("assets/shaders/Renderer2D_Circle.glsl");
		s_Data.LineShader = Shader::Create("assets/shaders/Renderer2D_Line.glsl");
		s_Data.TextShader = Shader::Create("assets/shaders/Renderer2D_Text.glsl");

		// Set first texture slot to 0
		s_Data.TextureSlots[0] = s_Data.WhiteTexture;

		s_Data.QuadVertexPositions[0] = { -0.5f, -0.5f, 0.0f, 1.0f };
		s_Data.QuadVertexPositions[1] = {  0.5f, -0.5f, 0.0f, 1.0f };
		s_Data.QuadVertexPositions[2] = {  0.5f,  0.5f, 0.0f, 1.0f };
		s_Data.QuadVertexPositions[3] = { -0.5f,  0.5f, 0.0f, 1.0f };

		s_Data.CameraUniformBuffer = UniformBuffer::Create(sizeof(Renderer2DData::CameraData), 0);
	}

	void Renderer2D::Shutdown()
	{
		HZ_PROFILE_FUNCTION();

		delete[] s_Data.QuadVertexBufferBase;
	}

	void Renderer2D::BeginScene(const OrthographicCamera& camera)
	{
		HZ_PROFILE_FUNCTION();

		s_Data.CameraBuffer.ViewProjection = camera.GetViewProjectionMatrix();
		s_Data.CameraUniformBuffer->SetData(&s_Data.CameraBuffer, sizeof(Renderer2DData::CameraData));

		StartBatch();
	}

	void Renderer2D::BeginScene(const Camera& camera, const glm::mat4& transform)
	{
		HZ_PROFILE_FUNCTION();

		s_Data.CameraBuffer.ViewProjection = camera.GetProjection() * glm::inverse(transform);
		s_Data.CameraUniformBuffer->SetData(&s_Data.CameraBuffer, sizeof(Renderer2DData::CameraData));

		StartBatch();
	}

	void Renderer2D::BeginScene(const EditorCamera& camera)
	{
		HZ_PROFILE_FUNCTION();

		s_Data.CameraBuffer.ViewProjection = camera.GetViewProjection();
		s_Data.CameraUniformBuffer->SetData(&s_Data.CameraBuffer, sizeof(Renderer2DData::CameraData));

		StartBatch();
	}

	void Renderer2D::EndScene()
	{
		HZ_PROFILE_FUNCTION();

		Flush();
	}

	void Renderer2D::StartBatch()
	{
		s_Data.QuadIndexCount = 0;
		s_Data.QuadVertexBufferPtr = s_Data.QuadVertexBufferBase;

		s_Data.CircleIndexCount = 0;
		s_Data.CircleVertexBufferPtr = s_Data.CircleVertexBufferBase;

		s_Data.LineVertexCount = 0;
		s_Data.LineVertexBufferPtr = s_Data.LineVertexBufferBase;	
		
		s_Data.TextIndexCount = 0;
		s_Data.TextVertexBufferPtr = s_Data.TextVertexBufferBase;

		s_Data.TextureSlotIndex = 1;
	}

	void Renderer2D::Flush()
	{
		if (s_Data.QuadIndexCount)
		{
			uint32_t dataSize = (uint32_t)((uint8_t*)s_Data.QuadVertexBufferPtr - (uint8_t*)s_Data.QuadVertexBufferBase);
			s_Data.QuadVertexBuffer->SetData(s_Data.QuadVertexBufferBase, dataSize);

			// Bind textures
			for (uint32_t i = 0; i < s_Data.TextureSlotIndex; i++)
				s_Data.TextureSlots[i]->Bind(i);

			s_Data.QuadShader->Bind();
			RenderCommand::DrawIndexed(s_Data.QuadVertexArray, s_Data.QuadIndexCount);
			s_Data.Stats.DrawCalls++;
		}

		if (s_Data.CircleIndexCount)
		{
			uint32_t dataSize = (uint32_t)((uint8_t*)s_Data.CircleVertexBufferPtr - (uint8_t*)s_Data.CircleVertexBufferBase);
			s_Data.CircleVertexBuffer->SetData(s_Data.CircleVertexBufferBase, dataSize);

			s_Data.CircleShader->Bind();
			RenderCommand::DrawIndexed(s_Data.CircleVertexArray, s_Data.CircleIndexCount);
			s_Data.Stats.DrawCalls++;
		}

		if (s_Data.LineVertexCount)
		{
			uint32_t dataSize = (uint32_t)((uint8_t*)s_Data.LineVertexBufferPtr - (uint8_t*)s_Data.LineVertexBufferBase);
			s_Data.LineVertexBuffer->SetData(s_Data.LineVertexBufferBase, dataSize);

			s_Data.LineShader->Bind();
			RenderCommand::SetLineWidth(s_Data.LineWidth);
			RenderCommand::DrawLines(s_Data.LineVertexArray, s_Data.LineVertexCount);
			s_Data.Stats.DrawCalls++;
		}
		
		if (s_Data.TextIndexCount)
		{
			uint32_t dataSize = (uint32_t)((uint8_t*)s_Data.TextVertexBufferPtr - (uint8_t*)s_Data.TextVertexBufferBase);
			s_Data.TextVertexBuffer->SetData(s_Data.TextVertexBufferBase, dataSize);

			auto buf = s_Data.TextVertexBufferBase;
			s_Data.FontAtlasTexture->Bind(0);

			s_Data.TextShader->Bind();
			RenderCommand::DrawIndexed(s_Data.TextVertexArray, s_Data.TextIndexCount);
			s_Data.Stats.DrawCalls++;
		}
	}

	void Renderer2D::NextBatch()
	{
		Flush();
		StartBatch();
	}

	void Renderer2D::DrawQuad(const glm::vec2& position, const glm::vec2& size, const glm::vec4& color)
	{
		DrawQuad({ position.x, position.y, 0.0f }, size, color);
	}

	void Renderer2D::DrawQuad(const glm::vec3& position, const glm::vec2& size, const glm::vec4& color)
	{
		HZ_PROFILE_FUNCTION();

		glm::mat4 transform = glm::translate(glm::mat4(1.0f), position)
			* glm::scale(glm::mat4(1.0f), { size.x, size.y, 1.0f });
		
		DrawQuad(transform, color);
	}

	void Renderer2D::DrawQuad(const glm::vec2& position, const glm::vec2& size, const Ref<Texture2D>& texture, float tilingFactor, const glm::vec4& tintColor)
	{
		DrawQuad({ position.x, position.y, 0.0f }, size, texture, tilingFactor, tintColor);
	}

	void Renderer2D::DrawQuad(const glm::vec3& position, const glm::vec2& size, const Ref<Texture2D>& texture, float tilingFactor, const glm::vec4& tintColor)
	{
		HZ_PROFILE_FUNCTION();

		glm::mat4 transform = glm::translate(glm::mat4(1.0f), position)
			* glm::scale(glm::mat4(1.0f), { size.x, size.y, 1.0f });

		DrawQuad(transform, texture, tilingFactor, tintColor);
	}

	void Renderer2D::DrawQuad(const glm::mat4& transform, const glm::vec4& color, int entityID)
	{
		HZ_PROFILE_FUNCTION();

		constexpr size_t quadVertexCount = 4;
		const float textureIndex = 0.0f; // White Texture
		constexpr glm::vec2 textureCoords[] = { { 0.0f, 0.0f }, { 1.0f, 0.0f }, { 1.0f, 1.0f }, { 0.0f, 1.0f } };
		const float tilingFactor = 1.0f;

		if (s_Data.QuadIndexCount >= Renderer2DData::MaxIndices)
			NextBatch();

		for (size_t i = 0; i < quadVertexCount; i++)
		{
			s_Data.QuadVertexBufferPtr->Position = transform * s_Data.QuadVertexPositions[i];
			s_Data.QuadVertexBufferPtr->Color = color;
			s_Data.QuadVertexBufferPtr->TexCoord = textureCoords[i];
			s_Data.QuadVertexBufferPtr->TexIndex = textureIndex;
			s_Data.QuadVertexBufferPtr->TilingFactor = tilingFactor;
			s_Data.QuadVertexBufferPtr->EntityID = entityID;
			s_Data.QuadVertexBufferPtr++;
		}

		s_Data.QuadIndexCount += 6;

		s_Data.Stats.QuadCount++;
	}

	void Renderer2D::DrawQuad(const glm::mat4& transform, const Ref<Texture2D>& texture, float tilingFactor, const glm::vec4& tintColor, int entityID)
	{
		HZ_PROFILE_FUNCTION();

		constexpr size_t quadVertexCount = 4;
		constexpr glm::vec2 textureCoords[] = { { 0.0f, 0.0f }, { 1.0f, 0.0f }, { 1.0f, 1.0f }, { 0.0f, 1.0f } };

		if (s_Data.QuadIndexCount >= Renderer2DData::MaxIndices)
			NextBatch();

		float textureIndex = 0.0f;
		for (uint32_t i = 1; i < s_Data.TextureSlotIndex; i++)
		{
			if (*s_Data.TextureSlots[i] == *texture)
			{
				textureIndex = (float)i;
				break;
			}
		}

		if (textureIndex == 0.0f)
		{
			if (s_Data.TextureSlotIndex >= Renderer2DData::MaxTextureSlots)
				NextBatch();

			textureIndex = (float)s_Data.TextureSlotIndex;
			s_Data.TextureSlots[s_Data.TextureSlotIndex] = texture;
			s_Data.TextureSlotIndex++;
		}

		for (size_t i = 0; i < quadVertexCount; i++)
		{
			s_Data.QuadVertexBufferPtr->Position = transform * s_Data.QuadVertexPositions[i];
			s_Data.QuadVertexBufferPtr->Color = tintColor;
			s_Data.QuadVertexBufferPtr->TexCoord = textureCoords[i];
			s_Data.QuadVertexBufferPtr->TexIndex = textureIndex;
			s_Data.QuadVertexBufferPtr->TilingFactor = tilingFactor;
			s_Data.QuadVertexBufferPtr->EntityID = entityID;
			s_Data.QuadVertexBufferPtr++;
		}

		s_Data.QuadIndexCount += 6;

		s_Data.Stats.QuadCount++;
	}

	void Renderer2D::DrawRotatedQuad(const glm::vec2& position, const glm::vec2& size, float rotation, const glm::vec4& color)
	{
		DrawRotatedQuad({ position.x, position.y, 0.0f }, size, rotation, color);
	}

	void Renderer2D::DrawRotatedQuad(const glm::vec3& position, const glm::vec2& size, float rotation, const glm::vec4& color)
	{
		HZ_PROFILE_FUNCTION();

		glm::mat4 transform = glm::translate(glm::mat4(1.0f), position)
			* glm::rotate(glm::mat4(1.0f), glm::radians(rotation), { 0.0f, 0.0f, 1.0f })
			* glm::scale(glm::mat4(1.0f), { size.x, size.y, 1.0f });

		DrawQuad(transform, color);
	}

	void Renderer2D::DrawRotatedQuad(const glm::vec2& position, const glm::vec2& size, float rotation, const Ref<Texture2D>& texture, float tilingFactor, const glm::vec4& tintColor)
	{
		DrawRotatedQuad({ position.x, position.y, 0.0f }, size, rotation, texture, tilingFactor, tintColor);
	}

	void Renderer2D::DrawRotatedQuad(const glm::vec3& position, const glm::vec2& size, float rotation, const Ref<Texture2D>& texture, float tilingFactor, const glm::vec4& tintColor)
	{
		HZ_PROFILE_FUNCTION();

		glm::mat4 transform = glm::translate(glm::mat4(1.0f), position)
			* glm::rotate(glm::mat4(1.0f), glm::radians(rotation), { 0.0f, 0.0f, 1.0f })
			* glm::scale(glm::mat4(1.0f), { size.x, size.y, 1.0f });

		DrawQuad(transform, texture, tilingFactor, tintColor);
	}

	void Renderer2D::DrawCircle(const glm::mat4& transform, const glm::vec4& color, float thickness /*= 1.0f*/, float fade /*= 0.005f*/, int entityID /*= -1*/)
	{
		HZ_PROFILE_FUNCTION();

		// TODO: implement for circles
		// if (s_Data.QuadIndexCount >= Renderer2DData::MaxIndices)
		// 	NextBatch();

		for (size_t i = 0; i < 4; i++)
		{
			s_Data.CircleVertexBufferPtr->WorldPosition = transform * s_Data.QuadVertexPositions[i];
			s_Data.CircleVertexBufferPtr->LocalPosition = s_Data.QuadVertexPositions[i] * 2.0f;
			s_Data.CircleVertexBufferPtr->Color = color;
			s_Data.CircleVertexBufferPtr->Thickness = thickness;
			s_Data.CircleVertexBufferPtr->Fade = fade;
			s_Data.CircleVertexBufferPtr->EntityID = entityID;
			s_Data.CircleVertexBufferPtr++;
		}

		s_Data.CircleIndexCount += 6;

		s_Data.Stats.QuadCount++;
	}

	void Renderer2D::DrawLine(const glm::vec3& p0, glm::vec3& p1, const glm::vec4& color, int entityID)
	{
		s_Data.LineVertexBufferPtr->Position = p0;
		s_Data.LineVertexBufferPtr->Color = color;
		s_Data.LineVertexBufferPtr->EntityID = entityID;
		s_Data.LineVertexBufferPtr++;

		s_Data.LineVertexBufferPtr->Position = p1;
		s_Data.LineVertexBufferPtr->Color = color;
		s_Data.LineVertexBufferPtr->EntityID = entityID;
		s_Data.LineVertexBufferPtr++;

		s_Data.LineVertexCount += 2;
	}

	void Renderer2D::DrawRect(const glm::vec3& position, const glm::vec2& size, const glm::vec4& color, int entityID)
	{
		glm::vec3 p0 = glm::vec3(position.x - size.x * 0.5f, position.y - size.y * 0.5f, position.z);
		glm::vec3 p1 = glm::vec3(position.x + size.x * 0.5f, position.y - size.y * 0.5f, position.z);
		glm::vec3 p2 = glm::vec3(position.x + size.x * 0.5f, position.y + size.y * 0.5f, position.z);
		glm::vec3 p3 = glm::vec3(position.x - size.x * 0.5f, position.y + size.y * 0.5f, position.z);

		DrawLine(p0, p1, color, entityID);
		DrawLine(p1, p2, color, entityID);
		DrawLine(p2, p3, color, entityID);
		DrawLine(p3, p0, color, entityID);
	}

	void Renderer2D::DrawRect(const glm::mat4& transform, const glm::vec4& color, int entityID)
	{
		glm::vec3 lineVertices[4];
		for (size_t i = 0; i < 4; i++)
			lineVertices[i] = transform * s_Data.QuadVertexPositions[i];

		DrawLine(lineVertices[0], lineVertices[1], color, entityID);
		DrawLine(lineVertices[1], lineVertices[2], color, entityID);
		DrawLine(lineVertices[2], lineVertices[3], color, entityID);
		DrawLine(lineVertices[3], lineVertices[0], color, entityID);
	}

	void Renderer2D::DrawSprite(const glm::mat4& transform, SpriteRendererComponent& src, int entityID)
	{
		if (src.Texture)
			DrawQuad(transform, src.Texture, src.TilingFactor, src.Color, entityID);
		else
			DrawQuad(transform, src.Color, entityID);
	}

	void Renderer2D::DrawString(const std::string& string, Ref<Font> font, const glm::mat4& transform, const TextParams& textParams, int entityID)
	{
		const auto& fontGeometry = font->GetMSDFData()->FontGeometry;
		const auto& metrics = fontGeometry.getMetrics();
		Ref<Texture2D> fontAtlas = font->GetAtlasTexture();

		s_Data.FontAtlasTexture = fontAtlas;

		double x = 0.0;
		double fsScale = 1.0 / (metrics.ascenderY - metrics.descenderY);
		double y = 0.0;

		const float spaceGlyphAdvance = fontGeometry.getGlyph(' ')->getAdvance();
		
		for (size_t i = 0; i < string.size(); i++)
		{
			char character = string[i];
			if (character == '\r')
				continue;

			if (character == '\n')
			{
				x = 0;
				y -= fsScale * metrics.lineHeight + textParams.LineSpacing;
				continue;
			}

			if (character == ' ')
			{
				float advance = spaceGlyphAdvance;
				if (i < string.size() - 1)
				{
					char nextCharacter = string[i + 1];
					double dAdvance;
					fontGeometry.getAdvance(dAdvance, character, nextCharacter);
					advance = (float)dAdvance;
				}

				x += fsScale * advance + textParams.Kerning;
				continue;
			}

			if (character == '\t')
			{
				// NOTE(Yan): is this right?
				x += 4.0f * (fsScale * spaceGlyphAdvance + textParams.Kerning);
				continue;
			}

			auto glyph = fontGeometry.getGlyph(character);
			if (!glyph)
				glyph = fontGeometry.getGlyph('?');
			if (!glyph)
				return;

			double al, ab, ar, at;
			glyph->getQuadAtlasBounds(al, ab, ar, at);
			glm::vec2 texCoordMin((float)al, (float)ab);
			glm::vec2 texCoordMax((float)ar, (float)at);

			double pl, pb, pr, pt;
			glyph->getQuadPlaneBounds(pl, pb, pr, pt);
			glm::vec2 quadMin((float)pl, (float)pb);
			glm::vec2 quadMax((float)pr, (float)pt);

			quadMin *= fsScale, quadMax *= fsScale;
			quadMin += glm::vec2(x, y);
			quadMax += glm::vec2(x, y);

			float texelWidth = 1.0f / fontAtlas->GetWidth();
			float texelHeight = 1.0f / fontAtlas->GetHeight();
			texCoordMin *= glm::vec2(texelWidth, texelHeight);
			texCoordMax *= glm::vec2(texelWidth, texelHeight);

			// render here
			s_Data.TextVertexBufferPtr->Position = transform * glm::vec4(quadMin, 0.0f, 1.0f);
			s_Data.TextVertexBufferPtr->Color = textParams.Color;
			s_Data.TextVertexBufferPtr->TexCoord = texCoordMin;
			s_Data.TextVertexBufferPtr->EntityID = entityID;
			s_Data.TextVertexBufferPtr++;

			s_Data.TextVertexBufferPtr->Position = transform * glm::vec4(quadMin.x, quadMax.y, 0.0f, 1.0f);
			s_Data.TextVertexBufferPtr->Color = textParams.Color;
			s_Data.TextVertexBufferPtr->TexCoord = { texCoordMin.x, texCoordMax.y };
			s_Data.TextVertexBufferPtr->EntityID = entityID;
			s_Data.TextVertexBufferPtr++;

			s_Data.TextVertexBufferPtr->Position = transform * glm::vec4(quadMax, 0.0f, 1.0f);
			s_Data.TextVertexBufferPtr->Color = textParams.Color;
			s_Data.TextVertexBufferPtr->TexCoord = texCoordMax;
			s_Data.TextVertexBufferPtr->EntityID = entityID;
			s_Data.TextVertexBufferPtr++;

			s_Data.TextVertexBufferPtr->Position = transform * glm::vec4(quadMax.x, quadMin.y, 0.0f, 1.0f);
			s_Data.TextVertexBufferPtr->Color = textParams.Color;
			s_Data.TextVertexBufferPtr->TexCoord = { texCoordMax.x, texCoordMin.y };
			s_Data.TextVertexBufferPtr->EntityID = entityID;
			s_Data.TextVertexBufferPtr++;

			s_Data.TextIndexCount += 6;
			s_Data.Stats.QuadCount++;

			if (i < string.size() - 1)
			{
				double advance = glyph->getAdvance();
				char nextCharacter = string[i + 1];
				fontGeometry.getAdvance(advance, character, nextCharacter);

				x += fsScale * advance + textParams.Kerning;
			}
		}
	}

	void Renderer2D::DrawString(const std::string& string, const glm::mat4& transform, const TextComponent& component, int entityID)
	{
		DrawString(string, component.FontAsset, transform, { component.Color, component.Kerning, component.LineSpacing }, entityID);
	}

	float Renderer2D::GetLineWidth()
	{
		return s_Data.LineWidth;
	}

	void Renderer2D::SetLineWidth(float width)
	{
		s_Data.LineWidth = width;
	}

	void Renderer2D::ResetStats()
	{
		memset(&s_Data.Stats, 0, sizeof(Statistics));
	}

	Renderer2D::Statistics Renderer2D::GetStats()
	{
		return s_Data.Stats;
	}

}

```

`Hazel/src/Hazel/Renderer/Renderer2D.h`:

```h
#pragma once

#include "Hazel/Renderer/OrthographicCamera.h"

#include "Hazel/Renderer/Texture.h"

#include "Hazel/Renderer/Camera.h"
#include "Hazel/Renderer/EditorCamera.h"
#include "Hazel/Renderer/Font.h"

#include "Hazel/Scene/Components.h"

namespace Hazel {

	class Renderer2D
	{
	public:
		static void Init();
		static void Shutdown();

		static void BeginScene(const Camera& camera, const glm::mat4& transform);
		static void BeginScene(const EditorCamera& camera);
		static void BeginScene(const OrthographicCamera& camera); // TODO: Remove
		static void EndScene();
		static void Flush();

		// Primitives
		static void DrawQuad(const glm::vec2& position, const glm::vec2& size, const glm::vec4& color);
		static void DrawQuad(const glm::vec3& position, const glm::vec2& size, const glm::vec4& color);
		static void DrawQuad(const glm::vec2& position, const glm::vec2& size, const Ref<Texture2D>& texture, float tilingFactor = 1.0f, const glm::vec4& tintColor = glm::vec4(1.0f));
		static void DrawQuad(const glm::vec3& position, const glm::vec2& size, const Ref<Texture2D>& texture, float tilingFactor = 1.0f, const glm::vec4& tintColor = glm::vec4(1.0f));

		static void DrawQuad(const glm::mat4& transform, const glm::vec4& color, int entityID = -1);
		static void DrawQuad(const glm::mat4& transform, const Ref<Texture2D>& texture, float tilingFactor = 1.0f, const glm::vec4& tintColor = glm::vec4(1.0f), int entityID = -1);

		static void DrawRotatedQuad(const glm::vec2& position, const glm::vec2& size, float rotation, const glm::vec4& color);
		static void DrawRotatedQuad(const glm::vec3& position, const glm::vec2& size, float rotation, const glm::vec4& color);
		static void DrawRotatedQuad(const glm::vec2& position, const glm::vec2& size, float rotation, const Ref<Texture2D>& texture, float tilingFactor = 1.0f, const glm::vec4& tintColor = glm::vec4(1.0f));
		static void DrawRotatedQuad(const glm::vec3& position, const glm::vec2& size, float rotation, const Ref<Texture2D>& texture, float tilingFactor = 1.0f, const glm::vec4& tintColor = glm::vec4(1.0f));

		static void DrawCircle(const glm::mat4& transform, const glm::vec4& color, float thickness = 1.0f, float fade = 0.005f, int entityID = -1);
		
		static void DrawLine(const glm::vec3& p0, glm::vec3& p1, const glm::vec4& color, int entityID = -1);

		static void DrawRect(const glm::vec3& position, const glm::vec2& size, const glm::vec4& color, int entityID = -1);
		static void DrawRect(const glm::mat4& transform, const glm::vec4& color, int entityID = -1);

		static void DrawSprite(const glm::mat4& transform, SpriteRendererComponent& src, int entityID);

		struct TextParams
		{
			glm::vec4 Color{ 1.0f };
			float Kerning = 0.0f;
			float LineSpacing = 0.0f;
		};
		static void DrawString(const std::string& string, Ref<Font> font, const glm::mat4& transform, const TextParams& textParams, int entityID = -1);
		static void DrawString(const std::string& string, const glm::mat4& transform, const TextComponent& component, int entityID = -1);

		static float GetLineWidth();
		static void SetLineWidth(float width);

		// Stats
		struct Statistics
		{
			uint32_t DrawCalls = 0;
			uint32_t QuadCount = 0;

			uint32_t GetTotalVertexCount() const { return QuadCount * 4; }
			uint32_t GetTotalIndexCount() const { return QuadCount * 6; }
		};
		static void ResetStats();
		static Statistics GetStats();

	private:
		static void StartBatch();
		static void NextBatch();
	};

}

```

`Hazel/src/Hazel/Renderer/RendererAPI.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/RendererAPI.h"

#include "Platform/OpenGL/OpenGLRendererAPI.h"

namespace Hazel {

	RendererAPI::API RendererAPI::s_API = RendererAPI::API::OpenGL;

	Scope<RendererAPI> RendererAPI::Create()
	{
		switch (s_API)
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateScope<OpenGLRendererAPI>();
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}
```

`Hazel/src/Hazel/Renderer/RendererAPI.h`:

```h
#pragma once

#include "Hazel/Renderer/VertexArray.h"

#include <glm/glm.hpp>

namespace Hazel {

	class RendererAPI
	{
	public:
		enum class API
		{
			None = 0, OpenGL = 1
		};
	public:
		virtual ~RendererAPI() = default;

		virtual void Init() = 0;
		virtual void SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height) = 0;
		virtual void SetClearColor(const glm::vec4& color) = 0;
		virtual void Clear() = 0;

		virtual void DrawIndexed(const Ref<VertexArray>& vertexArray, uint32_t indexCount = 0) = 0;
		virtual void DrawLines(const Ref<VertexArray>& vertexArray, uint32_t vertexCount) = 0;
		
		virtual void SetLineWidth(float width) = 0;

		static API GetAPI() { return s_API; }
		static Scope<RendererAPI> Create();
	private:
		static API s_API;
	};

}

```

`Hazel/src/Hazel/Renderer/Shader.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/Shader.h"

#include "Hazel/Renderer/Renderer.h"
#include "Platform/OpenGL/OpenGLShader.h"

namespace Hazel {

	Ref<Shader> Shader::Create(const std::string& filepath)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLShader>(filepath);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

	Ref<Shader> Shader::Create(const std::string& name, const std::string& vertexSrc, const std::string& fragmentSrc)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLShader>(name, vertexSrc, fragmentSrc);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

	void ShaderLibrary::Add(const std::string& name, const Ref<Shader>& shader)
	{
		HZ_CORE_ASSERT(!Exists(name), "Shader already exists!");
		m_Shaders[name] = shader;
	}

	void ShaderLibrary::Add(const Ref<Shader>& shader)
	{
		auto& name = shader->GetName();
		Add(name, shader);
	}

	Ref<Shader> ShaderLibrary::Load(const std::string& filepath)
	{
		auto shader = Shader::Create(filepath);
		Add(shader);
		return shader;
	}

	Ref<Shader> ShaderLibrary::Load(const std::string& name, const std::string& filepath)
	{
		auto shader = Shader::Create(filepath);
		Add(name, shader);
		return shader;
	}

	Ref<Shader> ShaderLibrary::Get(const std::string& name)
	{
		HZ_CORE_ASSERT(Exists(name), "Shader not found!");
		return m_Shaders[name];
	}

	bool ShaderLibrary::Exists(const std::string& name) const
	{
		return m_Shaders.find(name) != m_Shaders.end();
	}

}
```

`Hazel/src/Hazel/Renderer/Shader.h`:

```h
#pragma once

#include <string>
#include <unordered_map>

#include <glm/glm.hpp>

namespace Hazel {

	class Shader
	{
	public:
		virtual ~Shader() = default;

		virtual void Bind() const = 0;
		virtual void Unbind() const = 0;

		virtual void SetInt(const std::string& name, int value) = 0;
		virtual void SetIntArray(const std::string& name, int* values, uint32_t count) = 0;
		virtual void SetFloat(const std::string& name, float value) = 0;
		virtual void SetFloat2(const std::string& name, const glm::vec2& value) = 0;
		virtual void SetFloat3(const std::string& name, const glm::vec3& value) = 0;
		virtual void SetFloat4(const std::string& name, const glm::vec4& value) = 0;
		virtual void SetMat4(const std::string& name, const glm::mat4& value) = 0;

		virtual const std::string& GetName() const = 0;

		static Ref<Shader> Create(const std::string& filepath);
		static Ref<Shader> Create(const std::string& name, const std::string& vertexSrc, const std::string& fragmentSrc);
	};

	class ShaderLibrary
	{
	public:
		void Add(const std::string& name, const Ref<Shader>& shader);
		void Add(const Ref<Shader>& shader);
		Ref<Shader> Load(const std::string& filepath);
		Ref<Shader> Load(const std::string& name, const std::string& filepath);

		Ref<Shader> Get(const std::string& name);

		bool Exists(const std::string& name) const;
	private:
		std::unordered_map<std::string, Ref<Shader>> m_Shaders;
	};

}

```

`Hazel/src/Hazel/Renderer/Texture.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/Texture.h"

#include "Hazel/Renderer/Renderer.h"
#include "Platform/OpenGL/OpenGLTexture.h"

namespace Hazel {

	Ref<Texture2D> Texture2D::Create(const TextureSpecification& specification)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLTexture2D>(specification);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

	Ref<Texture2D> Texture2D::Create(const std::string& path)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLTexture2D>(path);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}

```

`Hazel/src/Hazel/Renderer/Texture.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"

#include <string>

namespace Hazel {

	enum class ImageFormat
	{
		None = 0,
		R8,
		RGB8,
		RGBA8,
		RGBA32F
	};

	struct TextureSpecification
	{
		uint32_t Width = 1;
		uint32_t Height = 1;
		ImageFormat Format = ImageFormat::RGBA8;
		bool GenerateMips = true;
	};

	class Texture
	{
	public:
		virtual ~Texture() = default;

		virtual const TextureSpecification& GetSpecification() const = 0;

		virtual uint32_t GetWidth() const = 0;
		virtual uint32_t GetHeight() const = 0;
		virtual uint32_t GetRendererID() const = 0;

		virtual const std::string& GetPath() const = 0;

		virtual void SetData(void* data, uint32_t size) = 0;

		virtual void Bind(uint32_t slot = 0) const = 0;

		virtual bool IsLoaded() const = 0;

		virtual bool operator==(const Texture& other) const = 0;
	};

	class Texture2D : public Texture
	{
	public:
		static Ref<Texture2D> Create(const TextureSpecification& specification);
		static Ref<Texture2D> Create(const std::string& path);
	};

}

```

`Hazel/src/Hazel/Renderer/UniformBuffer.cpp`:

```cpp
#include "hzpch.h"
#include "UniformBuffer.h"

#include "Hazel/Renderer/Renderer.h"
#include "Platform/OpenGL/OpenGLUniformBuffer.h"

namespace Hazel {

	Ref<UniformBuffer> UniformBuffer::Create(uint32_t size, uint32_t binding)
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLUniformBuffer>(size, binding);
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}

```

`Hazel/src/Hazel/Renderer/UniformBuffer.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"

namespace Hazel {

	class UniformBuffer
	{
	public:
		virtual ~UniformBuffer() {}
		virtual void SetData(const void* data, uint32_t size, uint32_t offset = 0) = 0;
		
		static Ref<UniformBuffer> Create(uint32_t size, uint32_t binding);
	};

}

```

`Hazel/src/Hazel/Renderer/VertexArray.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Renderer/VertexArray.h"

#include "Hazel/Renderer/Renderer.h"
#include "Platform/OpenGL/OpenGLVertexArray.h"

namespace Hazel {

	Ref<VertexArray> VertexArray::Create()
	{
		switch (Renderer::GetAPI())
		{
			case RendererAPI::API::None:    HZ_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateRef<OpenGLVertexArray>();
		}

		HZ_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}
```

`Hazel/src/Hazel/Renderer/VertexArray.h`:

```h
#pragma once

#include "Hazel/Renderer/Buffer.h"

#include <memory>

namespace Hazel {

	class VertexArray
	{
	public:
		virtual ~VertexArray() = default;

		virtual void Bind() const = 0;
		virtual void Unbind() const = 0;

		virtual void AddVertexBuffer(const Ref<VertexBuffer>& vertexBuffer) = 0;
		virtual void SetIndexBuffer(const Ref<IndexBuffer>& indexBuffer) = 0;

		virtual const std::vector<Ref<VertexBuffer>>& GetVertexBuffers() const = 0;
		virtual const Ref<IndexBuffer>& GetIndexBuffer() const = 0;

		static Ref<VertexArray> Create();
	};

}

```

`Hazel/src/Hazel/Scene/Components.h`:

```h
#pragma once

#include "SceneCamera.h"
#include "Hazel/Core/UUID.h"
#include "Hazel/Renderer/Texture.h"
#include "Hazel/Renderer/Font.h"

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/quaternion.hpp>

namespace Hazel {

	struct IDComponent
	{
		UUID ID;

		IDComponent() = default;
		IDComponent(const IDComponent&) = default;
	};

	struct TagComponent
	{
		std::string Tag;

		TagComponent() = default;
		TagComponent(const TagComponent&) = default;
		TagComponent(const std::string& tag)
			: Tag(tag) {}
	};

	struct TransformComponent
	{
		glm::vec3 Translation = { 0.0f, 0.0f, 0.0f };
		glm::vec3 Rotation = { 0.0f, 0.0f, 0.0f };
		glm::vec3 Scale = { 1.0f, 1.0f, 1.0f };

		TransformComponent() = default;
		TransformComponent(const TransformComponent&) = default;
		TransformComponent(const glm::vec3& translation)
			: Translation(translation) {}

		glm::mat4 GetTransform() const
		{
			glm::mat4 rotation = glm::toMat4(glm::quat(Rotation));

			return glm::translate(glm::mat4(1.0f), Translation)
				* rotation
				* glm::scale(glm::mat4(1.0f), Scale);
		}
	};

	struct SpriteRendererComponent
	{
		glm::vec4 Color{ 1.0f, 1.0f, 1.0f, 1.0f };
		Ref<Texture2D> Texture;
		float TilingFactor = 1.0f;

		SpriteRendererComponent() = default;
		SpriteRendererComponent(const SpriteRendererComponent&) = default;
		SpriteRendererComponent(const glm::vec4& color)
			: Color(color) {}
	};

	struct CircleRendererComponent
	{
		glm::vec4 Color{ 1.0f, 1.0f, 1.0f, 1.0f };
		float Thickness = 1.0f;
		float Fade = 0.005f;

		CircleRendererComponent() = default;
		CircleRendererComponent(const CircleRendererComponent&) = default;
	};

	struct CameraComponent
	{
		SceneCamera Camera;
		bool Primary = true; // TODO: think about moving to Scene
		bool FixedAspectRatio = false;

		CameraComponent() = default;
		CameraComponent(const CameraComponent&) = default;
	};

	struct ScriptComponent
	{
		std::string ClassName;

		ScriptComponent() = default;
		ScriptComponent(const ScriptComponent&) = default;
	};

	// Forward declaration
	class ScriptableEntity;

	struct NativeScriptComponent
	{
		ScriptableEntity* Instance = nullptr;

		ScriptableEntity*(*InstantiateScript)();
		void (*DestroyScript)(NativeScriptComponent*);

		template<typename T>
		void Bind()
		{
			InstantiateScript = []() { return static_cast<ScriptableEntity*>(new T()); };
			DestroyScript = [](NativeScriptComponent* nsc) { delete nsc->Instance; nsc->Instance = nullptr; };
		}
	};

	// Physics

	struct Rigidbody2DComponent
	{
		enum class BodyType { Static = 0, Dynamic, Kinematic };
		BodyType Type = BodyType::Static;
		bool FixedRotation = false;

		// Storage for runtime
		void* RuntimeBody = nullptr;

		Rigidbody2DComponent() = default;
		Rigidbody2DComponent(const Rigidbody2DComponent&) = default;
	};

	struct BoxCollider2DComponent
	{
		glm::vec2 Offset = { 0.0f, 0.0f };
		glm::vec2 Size = { 0.5f, 0.5f };

		// TODO(Yan): move into physics material in the future maybe
		float Density = 1.0f;
		float Friction = 0.5f;
		float Restitution = 0.0f;
		float RestitutionThreshold = 0.5f;

		// Storage for runtime
		void* RuntimeFixture = nullptr;

		BoxCollider2DComponent() = default;
		BoxCollider2DComponent(const BoxCollider2DComponent&) = default;
	};

	struct CircleCollider2DComponent
	{
		glm::vec2 Offset = { 0.0f, 0.0f };
		float Radius = 0.5f;

		// TODO(Yan): move into physics material in the future maybe
		float Density = 1.0f;
		float Friction = 0.5f;
		float Restitution = 0.0f;
		float RestitutionThreshold = 0.5f;

		// Storage for runtime
		void* RuntimeFixture = nullptr;

		CircleCollider2DComponent() = default;
		CircleCollider2DComponent(const CircleCollider2DComponent&) = default;
	};

	struct TextComponent
	{
		std::string TextString;
		Ref<Font> FontAsset = Font::GetDefault();
		glm::vec4 Color{ 1.0f };
		float Kerning = 0.0f;
		float LineSpacing = 0.0f;
	};

	template<typename... Component>
	struct ComponentGroup
	{
	};

	using AllComponents = 
		ComponentGroup<TransformComponent, SpriteRendererComponent,
			CircleRendererComponent, CameraComponent, ScriptComponent,
			NativeScriptComponent, Rigidbody2DComponent, BoxCollider2DComponent,
			CircleCollider2DComponent, TextComponent>;

}

```

`Hazel/src/Hazel/Scene/Entity.cpp`:

```cpp
#include "hzpch.h"
#include "Entity.h"

namespace Hazel {

	Entity::Entity(entt::entity handle, Scene* scene)
		: m_EntityHandle(handle), m_Scene(scene)
	{
	}

}
```

`Hazel/src/Hazel/Scene/Entity.h`:

```h
#pragma once

#include "Hazel/Core/UUID.h"
#include "Scene.h"
#include "Components.h"

#include "entt.hpp"

namespace Hazel {

	class Entity
	{
	public:
		Entity() = default;
		Entity(entt::entity handle, Scene* scene);
		Entity(const Entity& other) = default;

		template<typename T, typename... Args>
		T& AddComponent(Args&&... args)
		{
			HZ_CORE_ASSERT(!HasComponent<T>(), "Entity already has component!");
			T& component = m_Scene->m_Registry.emplace<T>(m_EntityHandle, std::forward<Args>(args)...);
			m_Scene->OnComponentAdded<T>(*this, component);
			return component;
		}

		template<typename T, typename... Args>
		T& AddOrReplaceComponent(Args&&... args)
		{
			T& component = m_Scene->m_Registry.emplace_or_replace<T>(m_EntityHandle, std::forward<Args>(args)...);
			m_Scene->OnComponentAdded<T>(*this, component);
			return component;
		}

		template<typename T>
		T& GetComponent()
		{
			HZ_CORE_ASSERT(HasComponent<T>(), "Entity does not have component!");
			return m_Scene->m_Registry.get<T>(m_EntityHandle);
		}

		template<typename T>
		bool HasComponent()
		{
			return m_Scene->m_Registry.has<T>(m_EntityHandle);
		}

		template<typename T>
		void RemoveComponent()
		{
			HZ_CORE_ASSERT(HasComponent<T>(), "Entity does not have component!");
			m_Scene->m_Registry.remove<T>(m_EntityHandle);
		}

		operator bool() const { return m_EntityHandle != entt::null; }
		operator entt::entity() const { return m_EntityHandle; }
		operator uint32_t() const { return (uint32_t)m_EntityHandle; }

		UUID GetUUID() { return GetComponent<IDComponent>().ID; }
		const std::string& GetName() { return GetComponent<TagComponent>().Tag; }

		bool operator==(const Entity& other) const
		{
			return m_EntityHandle == other.m_EntityHandle && m_Scene == other.m_Scene;
		}

		bool operator!=(const Entity& other) const
		{
			return !(*this == other);
		}
	private:
		entt::entity m_EntityHandle{ entt::null };
		Scene* m_Scene = nullptr;
	};

}

```

`Hazel/src/Hazel/Scene/Scene.cpp`:

```cpp
#include "hzpch.h"
#include "Scene.h"
#include "Entity.h"

#include "Components.h"
#include "ScriptableEntity.h"
#include "Hazel/Scripting/ScriptEngine.h"
#include "Hazel/Renderer/Renderer2D.h"
#include "Hazel/Physics/Physics2D.h"

#include <glm/glm.hpp>

#include "Entity.h"

// Box2D
#include "box2d/b2_world.h"
#include "box2d/b2_body.h"
#include "box2d/b2_fixture.h"
#include "box2d/b2_polygon_shape.h"
#include "box2d/b2_circle_shape.h"

namespace Hazel {

	Scene::Scene()
	{
	}

	Scene::~Scene()
	{
		delete m_PhysicsWorld;
	}

	template<typename... Component>
	static void CopyComponent(entt::registry& dst, entt::registry& src, const std::unordered_map<UUID, entt::entity>& enttMap)
	{
		([&]()
		{
			auto view = src.view<Component>();
			for (auto srcEntity : view)
			{
				entt::entity dstEntity = enttMap.at(src.get<IDComponent>(srcEntity).ID);

				auto& srcComponent = src.get<Component>(srcEntity);
				dst.emplace_or_replace<Component>(dstEntity, srcComponent);
			}
		}(), ...);
	}

	template<typename... Component>
	static void CopyComponent(ComponentGroup<Component...>, entt::registry& dst, entt::registry& src, const std::unordered_map<UUID, entt::entity>& enttMap)
	{
		CopyComponent<Component...>(dst, src, enttMap);
	}

	template<typename... Component>
	static void CopyComponentIfExists(Entity dst, Entity src)
	{
		([&]()
		{
			if (src.HasComponent<Component>())
				dst.AddOrReplaceComponent<Component>(src.GetComponent<Component>());
		}(), ...);
	}

	template<typename... Component>
	static void CopyComponentIfExists(ComponentGroup<Component...>, Entity dst, Entity src)
	{
		CopyComponentIfExists<Component...>(dst, src);
	}

	Ref<Scene> Scene::Copy(Ref<Scene> other)
	{
		Ref<Scene> newScene = CreateRef<Scene>();

		newScene->m_ViewportWidth = other->m_ViewportWidth;
		newScene->m_ViewportHeight = other->m_ViewportHeight;

		auto& srcSceneRegistry = other->m_Registry;
		auto& dstSceneRegistry = newScene->m_Registry;
		std::unordered_map<UUID, entt::entity> enttMap;

		// Create entities in new scene
		auto idView = srcSceneRegistry.view<IDComponent>();
		for (auto e : idView)
		{
			UUID uuid = srcSceneRegistry.get<IDComponent>(e).ID;
			const auto& name = srcSceneRegistry.get<TagComponent>(e).Tag;
			Entity newEntity = newScene->CreateEntityWithUUID(uuid, name);
			enttMap[uuid] = (entt::entity)newEntity;
		}

		// Copy components (except IDComponent and TagComponent)
		CopyComponent(AllComponents{}, dstSceneRegistry, srcSceneRegistry, enttMap);

		return newScene;
	}

	Entity Scene::CreateEntity(const std::string& name)
	{
		return CreateEntityWithUUID(UUID(), name);
	}

	Entity Scene::CreateEntityWithUUID(UUID uuid, const std::string& name)
	{
		Entity entity = { m_Registry.create(), this };
		entity.AddComponent<IDComponent>(uuid);
		entity.AddComponent<TransformComponent>();
		auto& tag = entity.AddComponent<TagComponent>();
		tag.Tag = name.empty() ? "Entity" : name;

		m_EntityMap[uuid] = entity;

		return entity;
	}

	void Scene::DestroyEntity(Entity entity)
	{
		m_EntityMap.erase(entity.GetUUID());
		m_Registry.destroy(entity);
	}

	void Scene::OnRuntimeStart()
	{
		m_IsRunning = true;

		OnPhysics2DStart();

		// Scripting
		{
			ScriptEngine::OnRuntimeStart(this);
			// Instantiate all script entities

			auto view = m_Registry.view<ScriptComponent>();
			for (auto e : view)
			{
				Entity entity = { e, this };
				ScriptEngine::OnCreateEntity(entity);
			}
		}
	}

	void Scene::OnRuntimeStop()
	{
		m_IsRunning = false;

		OnPhysics2DStop();

		ScriptEngine::OnRuntimeStop();
	}

	void Scene::OnSimulationStart()
	{
		OnPhysics2DStart();
	}

	void Scene::OnSimulationStop()
	{
		OnPhysics2DStop();
	}

	void Scene::OnUpdateRuntime(Timestep ts)
	{
		if (!m_IsPaused || m_StepFrames-- > 0)
		{
			// Update scripts
			{
				// C# Entity OnUpdate
				auto view = m_Registry.view<ScriptComponent>();
				for (auto e : view)
				{
					Entity entity = { e, this };
					ScriptEngine::OnUpdateEntity(entity, ts);
				}

				m_Registry.view<NativeScriptComponent>().each([=](auto entity, auto& nsc)
					{
						// TODO: Move to Scene::OnScenePlay
						if (!nsc.Instance)
						{
							nsc.Instance = nsc.InstantiateScript();
							nsc.Instance->m_Entity = Entity{ entity, this };
							nsc.Instance->OnCreate();
						}

						nsc.Instance->OnUpdate(ts);
					});
			}

			// Physics
			{
				const int32_t velocityIterations = 6;
				const int32_t positionIterations = 2;
				m_PhysicsWorld->Step(ts, velocityIterations, positionIterations);

				// Retrieve transform from Box2D
				auto view = m_Registry.view<Rigidbody2DComponent>();
				for (auto e : view)
				{
					Entity entity = { e, this };
					auto& transform = entity.GetComponent<TransformComponent>();
					auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();

					b2Body* body = (b2Body*)rb2d.RuntimeBody;

					const auto& position = body->GetPosition();
					transform.Translation.x = position.x;
					transform.Translation.y = position.y;
					transform.Rotation.z = body->GetAngle();
				}
			}
		}

		// Render 2D
		Camera* mainCamera = nullptr;
		glm::mat4 cameraTransform;
		{
			auto view = m_Registry.view<TransformComponent, CameraComponent>();
			for (auto entity : view)
			{
				auto [transform, camera] = view.get<TransformComponent, CameraComponent>(entity);
				
				if (camera.Primary)
				{
					mainCamera = &camera.Camera;
					cameraTransform = transform.GetTransform();
					break;
				}
			}
		}

		if (mainCamera)
		{
			Renderer2D::BeginScene(*mainCamera, cameraTransform);

			// Draw sprites
			{
				auto group = m_Registry.group<TransformComponent>(entt::get<SpriteRendererComponent>);
				for (auto entity : group)
				{
					auto [transform, sprite] = group.get<TransformComponent, SpriteRendererComponent>(entity);

					Renderer2D::DrawSprite(transform.GetTransform(), sprite, (int)entity);
				}
			}

			// Draw circles
			{
				auto view = m_Registry.view<TransformComponent, CircleRendererComponent>();
				for (auto entity : view)
				{
					auto [transform, circle] = view.get<TransformComponent, CircleRendererComponent>(entity);

					Renderer2D::DrawCircle(transform.GetTransform(), circle.Color, circle.Thickness, circle.Fade, (int)entity);
				}
			}

			// Draw text
			{
				auto view = m_Registry.view<TransformComponent, TextComponent>();
				for (auto entity : view)
				{
					auto [transform, text] = view.get<TransformComponent, TextComponent>(entity);

					Renderer2D::DrawString(text.TextString, transform.GetTransform(), text, (int)entity);
				}
			}

			Renderer2D::EndScene();
		}

	}

	void Scene::OnUpdateSimulation(Timestep ts, EditorCamera& camera)
	{
		if (!m_IsPaused || m_StepFrames-- > 0)
		{
			// Physics
			{
				const int32_t velocityIterations = 6;
				const int32_t positionIterations = 2;
				m_PhysicsWorld->Step(ts, velocityIterations, positionIterations);

				// Retrieve transform from Box2D
				auto view = m_Registry.view<Rigidbody2DComponent>();
				for (auto e : view)
				{
					Entity entity = { e, this };
					auto& transform = entity.GetComponent<TransformComponent>();
					auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();

					b2Body* body = (b2Body*)rb2d.RuntimeBody;
					const auto& position = body->GetPosition();
					transform.Translation.x = position.x;
					transform.Translation.y = position.y;
					transform.Rotation.z = body->GetAngle();
				}
			}
		}

		// Render
		RenderScene(camera);
	}

	void Scene::OnUpdateEditor(Timestep ts, EditorCamera& camera)
	{
		// Render
		RenderScene(camera);
	}

	void Scene::OnViewportResize(uint32_t width, uint32_t height)
	{
		if (m_ViewportWidth == width && m_ViewportHeight == height)
			return;

		m_ViewportWidth = width;
		m_ViewportHeight = height;

		// Resize our non-FixedAspectRatio cameras
		auto view = m_Registry.view<CameraComponent>();
		for (auto entity : view)
		{
			auto& cameraComponent = view.get<CameraComponent>(entity);
			if (!cameraComponent.FixedAspectRatio)
				cameraComponent.Camera.SetViewportSize(width, height);
		}
	}

	Entity Scene::GetPrimaryCameraEntity()
	{
		auto view = m_Registry.view<CameraComponent>();
		for (auto entity : view)
		{
			const auto& camera = view.get<CameraComponent>(entity);
			if (camera.Primary)
				return Entity{entity, this};
		}
		return {};
	}

	void Scene::Step(int frames)
	{
		m_StepFrames = frames;
	}

	Entity Scene::DuplicateEntity(Entity entity)
	{
		// Copy name because we're going to modify component data structure
		std::string name = entity.GetName();
		Entity newEntity = CreateEntity(name);
		CopyComponentIfExists(AllComponents{}, newEntity, entity);
		return newEntity;
	}

	Entity Scene::FindEntityByName(std::string_view name)
	{
		auto view = m_Registry.view<TagComponent>();
		for (auto entity : view)
		{
			const TagComponent& tc = view.get<TagComponent>(entity);
			if (tc.Tag == name)
				return Entity{ entity, this };
		}
		return {};
	}

	Entity Scene::GetEntityByUUID(UUID uuid)
	{
		// TODO(Yan): Maybe should be assert
		if (m_EntityMap.find(uuid) != m_EntityMap.end())
			return { m_EntityMap.at(uuid), this };

		return {};
	}

	void Scene::OnPhysics2DStart()
	{
		m_PhysicsWorld = new b2World({ 0.0f, -9.8f });

		auto view = m_Registry.view<Rigidbody2DComponent>();
		for (auto e : view)
		{
			Entity entity = { e, this };
			auto& transform = entity.GetComponent<TransformComponent>();
			auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();

			b2BodyDef bodyDef;
			bodyDef.type = Utils::Rigidbody2DTypeToBox2DBody(rb2d.Type);
			bodyDef.position.Set(transform.Translation.x, transform.Translation.y);
			bodyDef.angle = transform.Rotation.z;

			b2Body* body = m_PhysicsWorld->CreateBody(&bodyDef);
			body->SetFixedRotation(rb2d.FixedRotation);
			rb2d.RuntimeBody = body;

			if (entity.HasComponent<BoxCollider2DComponent>())
			{
				auto& bc2d = entity.GetComponent<BoxCollider2DComponent>();

				b2PolygonShape boxShape;
				boxShape.SetAsBox(bc2d.Size.x * transform.Scale.x, bc2d.Size.y * transform.Scale.y, b2Vec2(bc2d.Offset.x, bc2d.Offset.y), 0.0f);

				b2FixtureDef fixtureDef;
				fixtureDef.shape = &boxShape;
				fixtureDef.density = bc2d.Density;
				fixtureDef.friction = bc2d.Friction;
				fixtureDef.restitution = bc2d.Restitution;
				fixtureDef.restitutionThreshold = bc2d.RestitutionThreshold;
				body->CreateFixture(&fixtureDef);
			}

			if (entity.HasComponent<CircleCollider2DComponent>())
			{
				auto& cc2d = entity.GetComponent<CircleCollider2DComponent>();

				b2CircleShape circleShape;
				circleShape.m_p.Set(cc2d.Offset.x, cc2d.Offset.y);
				circleShape.m_radius = transform.Scale.x * cc2d.Radius;

				b2FixtureDef fixtureDef;
				fixtureDef.shape = &circleShape;
				fixtureDef.density = cc2d.Density;
				fixtureDef.friction = cc2d.Friction;
				fixtureDef.restitution = cc2d.Restitution;
				fixtureDef.restitutionThreshold = cc2d.RestitutionThreshold;
				body->CreateFixture(&fixtureDef);
			}
		}
	}

	void Scene::OnPhysics2DStop()
	{
		delete m_PhysicsWorld;
		m_PhysicsWorld = nullptr;
	}

	void Scene::RenderScene(EditorCamera& camera)
	{
		Renderer2D::BeginScene(camera);

		// Draw sprites
		{
			auto group = m_Registry.group<TransformComponent>(entt::get<SpriteRendererComponent>);
			for (auto entity : group)
			{
				auto [transform, sprite] = group.get<TransformComponent, SpriteRendererComponent>(entity);

				Renderer2D::DrawSprite(transform.GetTransform(), sprite, (int)entity);
			}
		}

		// Draw circles
		{
			auto view = m_Registry.view<TransformComponent, CircleRendererComponent>();
			for (auto entity : view)
			{
				auto [transform, circle] = view.get<TransformComponent, CircleRendererComponent>(entity);

				Renderer2D::DrawCircle(transform.GetTransform(), circle.Color, circle.Thickness, circle.Fade, (int)entity);
			}
		}

		// Draw text
		{
			auto view = m_Registry.view<TransformComponent, TextComponent>();
			for (auto entity : view)
			{
				auto [transform, text] = view.get<TransformComponent, TextComponent>(entity);

				Renderer2D::DrawString(text.TextString, transform.GetTransform(), text, (int)entity);
			}
		}

		Renderer2D::EndScene();
	}
  
  template<typename T>
	void Scene::OnComponentAdded(Entity entity, T& component)
	{
		static_assert(sizeof(T) == 0);
	}

	template<>
	void Scene::OnComponentAdded<IDComponent>(Entity entity, IDComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<TransformComponent>(Entity entity, TransformComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<CameraComponent>(Entity entity, CameraComponent& component)
	{
		if (m_ViewportWidth > 0 && m_ViewportHeight > 0)
			component.Camera.SetViewportSize(m_ViewportWidth, m_ViewportHeight);
	}

	template<>
	void Scene::OnComponentAdded<ScriptComponent>(Entity entity, ScriptComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<SpriteRendererComponent>(Entity entity, SpriteRendererComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<CircleRendererComponent>(Entity entity, CircleRendererComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<TagComponent>(Entity entity, TagComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<NativeScriptComponent>(Entity entity, NativeScriptComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<Rigidbody2DComponent>(Entity entity, Rigidbody2DComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<BoxCollider2DComponent>(Entity entity, BoxCollider2DComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<CircleCollider2DComponent>(Entity entity, CircleCollider2DComponent& component)
	{
	}

	template<>
	void Scene::OnComponentAdded<TextComponent>(Entity entity, TextComponent& component)
	{
	}

}

```

`Hazel/src/Hazel/Scene/Scene.h`:

```h
#pragma once

#include "Hazel/Core/Timestep.h"
#include "Hazel/Core/UUID.h"
#include "Hazel/Renderer/EditorCamera.h"

#include "entt.hpp"

class b2World;

namespace Hazel {

	class Entity;

	class Scene
	{
	public:
		Scene();
		~Scene();

		static Ref<Scene> Copy(Ref<Scene> other);

		Entity CreateEntity(const std::string& name = std::string());
		Entity CreateEntityWithUUID(UUID uuid, const std::string& name = std::string());
		void DestroyEntity(Entity entity);

		void OnRuntimeStart();
		void OnRuntimeStop();

		void OnSimulationStart();
		void OnSimulationStop();

		void OnUpdateRuntime(Timestep ts);
		void OnUpdateSimulation(Timestep ts, EditorCamera& camera);
		void OnUpdateEditor(Timestep ts, EditorCamera& camera);
		void OnViewportResize(uint32_t width, uint32_t height);

		Entity DuplicateEntity(Entity entity);

		Entity FindEntityByName(std::string_view name);
		Entity GetEntityByUUID(UUID uuid);

		Entity GetPrimaryCameraEntity();

		bool IsRunning() const { return m_IsRunning; }
		bool IsPaused() const { return m_IsPaused; }

		void SetPaused(bool paused) { m_IsPaused = paused; }

		void Step(int frames = 1);

		template<typename... Components>
		auto GetAllEntitiesWith()
		{
			return m_Registry.view<Components...>();
		}
	private:
		template<typename T>
		void OnComponentAdded(Entity entity, T& component);

		void OnPhysics2DStart();
		void OnPhysics2DStop();

		void RenderScene(EditorCamera& camera);
	private:
		entt::registry m_Registry;
		uint32_t m_ViewportWidth = 0, m_ViewportHeight = 0;
		bool m_IsRunning = false;
		bool m_IsPaused = false;
		int m_StepFrames = 0;

		b2World* m_PhysicsWorld = nullptr;

		std::unordered_map<UUID, entt::entity> m_EntityMap;

		friend class Entity;
		friend class SceneSerializer;
		friend class SceneHierarchyPanel;
	};

}

```

`Hazel/src/Hazel/Scene/SceneCamera.cpp`:

```cpp
#include "hzpch.h"
#include "SceneCamera.h"

#include <glm/gtc/matrix_transform.hpp>

namespace Hazel {

	SceneCamera::SceneCamera()
	{
		RecalculateProjection();
	}

	void SceneCamera::SetPerspective(float verticalFOV, float nearClip, float farClip)
	{
		m_ProjectionType = ProjectionType::Perspective;
		m_PerspectiveFOV = verticalFOV;
		m_PerspectiveNear = nearClip;
		m_PerspectiveFar = farClip;
		RecalculateProjection();
	}

	void SceneCamera::SetOrthographic(float size, float nearClip, float farClip)
	{
		m_ProjectionType = ProjectionType::Orthographic;
		m_OrthographicSize = size;
		m_OrthographicNear = nearClip;
		m_OrthographicFar = farClip;
		RecalculateProjection();
	}

	void SceneCamera::SetViewportSize(uint32_t width, uint32_t height)
	{
		HZ_CORE_ASSERT(width > 0 && height > 0);
		m_AspectRatio = (float)width / (float)height;
		RecalculateProjection();
	}

	void SceneCamera::RecalculateProjection()
	{
		if (m_ProjectionType == ProjectionType::Perspective)
		{
			m_Projection = glm::perspective(m_PerspectiveFOV, m_AspectRatio, m_PerspectiveNear, m_PerspectiveFar);
		}
		else
		{
			float orthoLeft = -m_OrthographicSize * m_AspectRatio * 0.5f;
			float orthoRight = m_OrthographicSize * m_AspectRatio * 0.5f;
			float orthoBottom = -m_OrthographicSize * 0.5f;
			float orthoTop = m_OrthographicSize * 0.5f;

			m_Projection = glm::ortho(orthoLeft, orthoRight,
				orthoBottom, orthoTop, m_OrthographicNear, m_OrthographicFar);
		}
		
	}

}

```

`Hazel/src/Hazel/Scene/SceneCamera.h`:

```h
#pragma once

#include "Hazel/Renderer/Camera.h"

namespace Hazel {

	class SceneCamera : public Camera
	{
	public:
		enum class ProjectionType { Perspective = 0, Orthographic = 1 };
	public:
		SceneCamera();
		virtual ~SceneCamera() = default;

		void SetPerspective(float verticalFOV, float nearClip, float farClip);
		void SetOrthographic(float size, float nearClip, float farClip);

		void SetViewportSize(uint32_t width, uint32_t height);

		float GetPerspectiveVerticalFOV() const { return m_PerspectiveFOV; }
		void SetPerspectiveVerticalFOV(float verticalFov) { m_PerspectiveFOV = verticalFov; RecalculateProjection(); }
		float GetPerspectiveNearClip() const { return m_PerspectiveNear; }
		void SetPerspectiveNearClip(float nearClip) { m_PerspectiveNear = nearClip; RecalculateProjection(); }
		float GetPerspectiveFarClip() const { return m_PerspectiveFar; }
		void SetPerspectiveFarClip(float farClip) { m_PerspectiveFar = farClip; RecalculateProjection(); }

		float GetOrthographicSize() const { return m_OrthographicSize; }
		void SetOrthographicSize(float size) { m_OrthographicSize = size; RecalculateProjection(); }
		float GetOrthographicNearClip() const { return m_OrthographicNear; }
		void SetOrthographicNearClip(float nearClip) { m_OrthographicNear = nearClip; RecalculateProjection(); }
		float GetOrthographicFarClip() const { return m_OrthographicFar; }
		void SetOrthographicFarClip(float farClip) { m_OrthographicFar = farClip; RecalculateProjection(); }

		ProjectionType GetProjectionType() const { return m_ProjectionType; }
		void SetProjectionType(ProjectionType type) { m_ProjectionType = type; RecalculateProjection(); }
	private:
		void RecalculateProjection();
	private:
		ProjectionType m_ProjectionType = ProjectionType::Orthographic;

		float m_PerspectiveFOV = glm::radians(45.0f);
		float m_PerspectiveNear = 0.01f, m_PerspectiveFar = 1000.0f;

		float m_OrthographicSize = 10.0f;
		float m_OrthographicNear = -1.0f, m_OrthographicFar = 1.0f;

		float m_AspectRatio = 0.0f;
	};

}

```

`Hazel/src/Hazel/Scene/SceneSerializer.cpp`:

```cpp
#include "hzpch.h"
#include "SceneSerializer.h"

#include "Entity.h"
#include "Components.h"
#include "Hazel/Scripting/ScriptEngine.h"
#include "Hazel/Core/UUID.h"

#include "Hazel/Project/Project.h"

#include <fstream>

#include <yaml-cpp/yaml.h>

namespace YAML {

	template<>
	struct convert<glm::vec2>
	{
		static Node encode(const glm::vec2& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			node.SetStyle(EmitterStyle::Flow);
			return node;
		}

		static bool decode(const Node& node, glm::vec2& rhs)
		{
			if (!node.IsSequence() || node.size() != 2)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			return true;
		}
	};

	template<>
	struct convert<glm::vec3>
	{
		static Node encode(const glm::vec3& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			node.push_back(rhs.z);
			node.SetStyle(EmitterStyle::Flow);
			return node;
		}

		static bool decode(const Node& node, glm::vec3& rhs)
		{
			if (!node.IsSequence() || node.size() != 3)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			rhs.z = node[2].as<float>();
			return true;
		}
	};

	template<>
	struct convert<glm::vec4>
	{
		static Node encode(const glm::vec4& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			node.push_back(rhs.z);
			node.push_back(rhs.w);
			node.SetStyle(EmitterStyle::Flow);
			return node;
		}

		static bool decode(const Node& node, glm::vec4& rhs)
		{
			if (!node.IsSequence() || node.size() != 4)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			rhs.z = node[2].as<float>();
			rhs.w = node[3].as<float>();
			return true;
		}
	};

	template<>
	struct convert<Hazel::UUID>
	{
		static Node encode(const Hazel::UUID& uuid)
		{
			Node node;
			node.push_back((uint64_t)uuid);
			return node;
		}

		static bool decode(const Node& node, Hazel::UUID& uuid)
		{
			uuid = node.as<uint64_t>();
			return true;
		}
	};

}

namespace Hazel {

#define WRITE_SCRIPT_FIELD(FieldType, Type)           \
			case ScriptFieldType::FieldType:          \
				out << scriptField.GetValue<Type>();  \
				break

#define READ_SCRIPT_FIELD(FieldType, Type)             \
	case ScriptFieldType::FieldType:                   \
	{                                                  \
		Type data = scriptField["Data"].as<Type>();    \
		fieldInstance.SetValue(data);                  \
		break;                                         \
	}

	YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec2& v)
	{
		out << YAML::Flow;
		out << YAML::BeginSeq << v.x << v.y << YAML::EndSeq;
		return out;
	}

	YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec3& v)
	{
		out << YAML::Flow;
		out << YAML::BeginSeq << v.x << v.y << v.z << YAML::EndSeq;
		return out;
	}

	YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec4& v)
	{
		out << YAML::Flow;
		out << YAML::BeginSeq << v.x << v.y << v.z << v.w << YAML::EndSeq;
		return out;
	}

	static std::string RigidBody2DBodyTypeToString(Rigidbody2DComponent::BodyType bodyType)
	{
		switch (bodyType)
		{
			case Rigidbody2DComponent::BodyType::Static:    return "Static";
			case Rigidbody2DComponent::BodyType::Dynamic:   return "Dynamic";
			case Rigidbody2DComponent::BodyType::Kinematic: return "Kinematic";
		}

		HZ_CORE_ASSERT(false, "Unknown body type");
		return {};
	}

	static Rigidbody2DComponent::BodyType RigidBody2DBodyTypeFromString(const std::string& bodyTypeString)
	{
		if (bodyTypeString == "Static")    return Rigidbody2DComponent::BodyType::Static;
		if (bodyTypeString == "Dynamic")   return Rigidbody2DComponent::BodyType::Dynamic;
		if (bodyTypeString == "Kinematic") return Rigidbody2DComponent::BodyType::Kinematic;
	
		HZ_CORE_ASSERT(false, "Unknown body type");
		return Rigidbody2DComponent::BodyType::Static;
	}

	SceneSerializer::SceneSerializer(const Ref<Scene>& scene)
		: m_Scene(scene)
	{
	}

	static void SerializeEntity(YAML::Emitter& out, Entity entity)
	{
		HZ_CORE_ASSERT(entity.HasComponent<IDComponent>());

		out << YAML::BeginMap; // Entity
		out << YAML::Key << "Entity" << YAML::Value << entity.GetUUID();

		if (entity.HasComponent<TagComponent>())
		{
			out << YAML::Key << "TagComponent";
			out << YAML::BeginMap; // TagComponent

			auto& tag = entity.GetComponent<TagComponent>().Tag;
			out << YAML::Key << "Tag" << YAML::Value << tag;

			out << YAML::EndMap; // TagComponent
		}

		if (entity.HasComponent<TransformComponent>())
		{
			out << YAML::Key << "TransformComponent";
			out << YAML::BeginMap; // TransformComponent

			auto& tc = entity.GetComponent<TransformComponent>();
			out << YAML::Key << "Translation" << YAML::Value << tc.Translation;
			out << YAML::Key << "Rotation" << YAML::Value << tc.Rotation;
			out << YAML::Key << "Scale" << YAML::Value << tc.Scale;

			out << YAML::EndMap; // TransformComponent
		}

		if (entity.HasComponent<CameraComponent>())
		{
			out << YAML::Key << "CameraComponent";
			out << YAML::BeginMap; // CameraComponent

			auto& cameraComponent = entity.GetComponent<CameraComponent>();
			auto& camera = cameraComponent.Camera;

			out << YAML::Key << "Camera" << YAML::Value;
			out << YAML::BeginMap; // Camera
			out << YAML::Key << "ProjectionType" << YAML::Value << (int)camera.GetProjectionType();
			out << YAML::Key << "PerspectiveFOV" << YAML::Value << camera.GetPerspectiveVerticalFOV();
			out << YAML::Key << "PerspectiveNear" << YAML::Value << camera.GetPerspectiveNearClip();
			out << YAML::Key << "PerspectiveFar" << YAML::Value << camera.GetPerspectiveFarClip();
			out << YAML::Key << "OrthographicSize" << YAML::Value << camera.GetOrthographicSize();
			out << YAML::Key << "OrthographicNear" << YAML::Value << camera.GetOrthographicNearClip();
			out << YAML::Key << "OrthographicFar" << YAML::Value << camera.GetOrthographicFarClip();
			out << YAML::EndMap; // Camera

			out << YAML::Key << "Primary" << YAML::Value << cameraComponent.Primary;
			out << YAML::Key << "FixedAspectRatio" << YAML::Value << cameraComponent.FixedAspectRatio;

			out << YAML::EndMap; // CameraComponent
		}

		if (entity.HasComponent<ScriptComponent>())
		{
			auto& scriptComponent = entity.GetComponent<ScriptComponent>();

			out << YAML::Key << "ScriptComponent";
			out << YAML::BeginMap; // ScriptComponent
			out << YAML::Key << "ClassName" << YAML::Value << scriptComponent.ClassName;

			// Fields
			Ref<ScriptClass> entityClass = ScriptEngine::GetEntityClass(scriptComponent.ClassName);
			const auto& fields = entityClass->GetFields();
			if (fields.size() > 0)
			{
				out << YAML::Key << "ScriptFields" << YAML::Value;
				auto& entityFields = ScriptEngine::GetScriptFieldMap(entity);
				out << YAML::BeginSeq;
				for (const auto& [name, field] : fields)
				{
					if (entityFields.find(name) == entityFields.end())
						continue;

					out << YAML::BeginMap; // ScriptField
					out << YAML::Key << "Name" << YAML::Value << name;
					out << YAML::Key << "Type" << YAML::Value << Utils::ScriptFieldTypeToString(field.Type);

					out << YAML::Key << "Data" << YAML::Value;
					ScriptFieldInstance& scriptField = entityFields.at(name);

					switch (field.Type)
					{
						WRITE_SCRIPT_FIELD(Float,   float     );
						WRITE_SCRIPT_FIELD(Double,  double    );
						WRITE_SCRIPT_FIELD(Bool,    bool      );
						WRITE_SCRIPT_FIELD(Char,    char      );
						WRITE_SCRIPT_FIELD(Byte,    int8_t    );
						WRITE_SCRIPT_FIELD(Short,   int16_t   );
						WRITE_SCRIPT_FIELD(Int,     int32_t   );
						WRITE_SCRIPT_FIELD(Long,    int64_t   );
						WRITE_SCRIPT_FIELD(UByte,   uint8_t   );
						WRITE_SCRIPT_FIELD(UShort,  uint16_t  );
						WRITE_SCRIPT_FIELD(UInt,    uint32_t  );
						WRITE_SCRIPT_FIELD(ULong,   uint64_t  );
						WRITE_SCRIPT_FIELD(Vector2, glm::vec2 );
						WRITE_SCRIPT_FIELD(Vector3, glm::vec3 );
						WRITE_SCRIPT_FIELD(Vector4, glm::vec4 );
						WRITE_SCRIPT_FIELD(Entity,  UUID      );
					}
					out << YAML::EndMap; // ScriptFields
				}
				out << YAML::EndSeq;
			}

			out << YAML::EndMap; // ScriptComponent
		}

		if (entity.HasComponent<SpriteRendererComponent>())
		{
			out << YAML::Key << "SpriteRendererComponent";
			out << YAML::BeginMap; // SpriteRendererComponent

			auto& spriteRendererComponent = entity.GetComponent<SpriteRendererComponent>();
			out << YAML::Key << "Color" << YAML::Value << spriteRendererComponent.Color;
			if (spriteRendererComponent.Texture)
				out << YAML::Key << "TexturePath" << YAML::Value << spriteRendererComponent.Texture->GetPath();

			out << YAML::Key << "TilingFactor" << YAML::Value << spriteRendererComponent.TilingFactor;

			out << YAML::EndMap; // SpriteRendererComponent
		}

		if (entity.HasComponent<CircleRendererComponent>())
		{
			out << YAML::Key << "CircleRendererComponent";
			out << YAML::BeginMap; // CircleRendererComponent

			auto& circleRendererComponent = entity.GetComponent<CircleRendererComponent>();
			out << YAML::Key << "Color" << YAML::Value << circleRendererComponent.Color;
			out << YAML::Key << "Thickness" << YAML::Value << circleRendererComponent.Thickness;
			out << YAML::Key << "Fade" << YAML::Value << circleRendererComponent.Fade;

			out << YAML::EndMap; // CircleRendererComponent
		}

		if (entity.HasComponent<Rigidbody2DComponent>())
		{
			out << YAML::Key << "Rigidbody2DComponent";
			out << YAML::BeginMap; // Rigidbody2DComponent

			auto& rb2dComponent = entity.GetComponent<Rigidbody2DComponent>();
			out << YAML::Key << "BodyType" << YAML::Value << RigidBody2DBodyTypeToString(rb2dComponent.Type);
			out << YAML::Key << "FixedRotation" << YAML::Value << rb2dComponent.FixedRotation;

			out << YAML::EndMap; // Rigidbody2DComponent
		}

		if (entity.HasComponent<BoxCollider2DComponent>())
		{
			out << YAML::Key << "BoxCollider2DComponent";
			out << YAML::BeginMap; // BoxCollider2DComponent

			auto& bc2dComponent = entity.GetComponent<BoxCollider2DComponent>();
			out << YAML::Key << "Offset" << YAML::Value << bc2dComponent.Offset;
			out << YAML::Key << "Size" << YAML::Value << bc2dComponent.Size;
			out << YAML::Key << "Density" << YAML::Value << bc2dComponent.Density;
			out << YAML::Key << "Friction" << YAML::Value << bc2dComponent.Friction;
			out << YAML::Key << "Restitution" << YAML::Value << bc2dComponent.Restitution;
			out << YAML::Key << "RestitutionThreshold" << YAML::Value << bc2dComponent.RestitutionThreshold;

			out << YAML::EndMap; // BoxCollider2DComponent
		}

		if (entity.HasComponent<CircleCollider2DComponent>())
		{
			out << YAML::Key << "CircleCollider2DComponent";
			out << YAML::BeginMap; // CircleCollider2DComponent

			auto& cc2dComponent = entity.GetComponent<CircleCollider2DComponent>();
			out << YAML::Key << "Offset" << YAML::Value << cc2dComponent.Offset;
			out << YAML::Key << "Radius" << YAML::Value << cc2dComponent.Radius;
			out << YAML::Key << "Density" << YAML::Value << cc2dComponent.Density;
			out << YAML::Key << "Friction" << YAML::Value << cc2dComponent.Friction;
			out << YAML::Key << "Restitution" << YAML::Value << cc2dComponent.Restitution;
			out << YAML::Key << "RestitutionThreshold" << YAML::Value << cc2dComponent.RestitutionThreshold;

			out << YAML::EndMap; // CircleCollider2DComponent
		}

		if (entity.HasComponent<TextComponent>())
		{
			out << YAML::Key << "TextComponent";
			out << YAML::BeginMap; // TextComponent

			auto& textComponent = entity.GetComponent<TextComponent>();
			out << YAML::Key << "TextString" << YAML::Value << textComponent.TextString;
			// TODO: textComponent.FontAsset
			out << YAML::Key << "Color" << YAML::Value << textComponent.Color;
			out << YAML::Key << "Kerning" << YAML::Value << textComponent.Kerning;
			out << YAML::Key << "LineSpacing" << YAML::Value << textComponent.LineSpacing;

			out << YAML::EndMap; // TextComponent
		}

		out << YAML::EndMap; // Entity
	}

	void SceneSerializer::Serialize(const std::string& filepath)
	{
		YAML::Emitter out;
		out << YAML::BeginMap;
		out << YAML::Key << "Scene" << YAML::Value << "Untitled";
		out << YAML::Key << "Entities" << YAML::Value << YAML::BeginSeq;
		m_Scene->m_Registry.each([&](auto entityID)
		{
			Entity entity = { entityID, m_Scene.get() };
			if (!entity)
				return;

			SerializeEntity(out, entity);
		});
		out << YAML::EndSeq;
		out << YAML::EndMap;

		std::ofstream fout(filepath);
		fout << out.c_str();
	}

	void SceneSerializer::SerializeRuntime(const std::string& filepath)
	{
		// Not implemented
		HZ_CORE_ASSERT(false);
	}

	bool SceneSerializer::Deserialize(const std::string& filepath)
	{
		YAML::Node data;
		try
		{
			data = YAML::LoadFile(filepath);
		}
		catch (YAML::ParserException e)
		{
			HZ_CORE_ERROR("Failed to load .hazel file '{0}'\n     {1}", filepath, e.what());
			return false;
		}

		if (!data["Scene"])
			return false;

		std::string sceneName = data["Scene"].as<std::string>();
		HZ_CORE_TRACE("Deserializing scene '{0}'", sceneName);

		auto entities = data["Entities"];
		if (entities)
		{
			for (auto entity : entities)
			{
				uint64_t uuid = entity["Entity"].as<uint64_t>();

				std::string name;
				auto tagComponent = entity["TagComponent"];
				if (tagComponent)
					name = tagComponent["Tag"].as<std::string>();

				HZ_CORE_TRACE("Deserialized entity with ID = {0}, name = {1}", uuid, name);

				Entity deserializedEntity = m_Scene->CreateEntityWithUUID(uuid, name);

				auto transformComponent = entity["TransformComponent"];
				if (transformComponent)
				{
					// Entities always have transforms
					auto& tc = deserializedEntity.GetComponent<TransformComponent>();
					tc.Translation = transformComponent["Translation"].as<glm::vec3>();
					tc.Rotation = transformComponent["Rotation"].as<glm::vec3>();
					tc.Scale = transformComponent["Scale"].as<glm::vec3>();
				}

				auto cameraComponent = entity["CameraComponent"];
				if (cameraComponent)
				{
					auto& cc = deserializedEntity.AddComponent<CameraComponent>();

					auto& cameraProps = cameraComponent["Camera"];
					cc.Camera.SetProjectionType((SceneCamera::ProjectionType)cameraProps["ProjectionType"].as<int>());

					cc.Camera.SetPerspectiveVerticalFOV(cameraProps["PerspectiveFOV"].as<float>());
					cc.Camera.SetPerspectiveNearClip(cameraProps["PerspectiveNear"].as<float>());
					cc.Camera.SetPerspectiveFarClip(cameraProps["PerspectiveFar"].as<float>());

					cc.Camera.SetOrthographicSize(cameraProps["OrthographicSize"].as<float>());
					cc.Camera.SetOrthographicNearClip(cameraProps["OrthographicNear"].as<float>());
					cc.Camera.SetOrthographicFarClip(cameraProps["OrthographicFar"].as<float>());

					cc.Primary = cameraComponent["Primary"].as<bool>();
					cc.FixedAspectRatio = cameraComponent["FixedAspectRatio"].as<bool>();
				}

				auto scriptComponent = entity["ScriptComponent"];
				if (scriptComponent)
				{
					auto& sc = deserializedEntity.AddComponent<ScriptComponent>();
					sc.ClassName = scriptComponent["ClassName"].as<std::string>();

					auto scriptFields = scriptComponent["ScriptFields"];
					if (scriptFields)
					{
						Ref<ScriptClass> entityClass = ScriptEngine::GetEntityClass(sc.ClassName);
						if (entityClass)
						{
							const auto& fields = entityClass->GetFields();
							auto& entityFields = ScriptEngine::GetScriptFieldMap(deserializedEntity);

							for (auto scriptField : scriptFields)
							{
								std::string name = scriptField["Name"].as<std::string>();
								std::string typeString = scriptField["Type"].as<std::string>();
								ScriptFieldType type = Utils::ScriptFieldTypeFromString(typeString);

								ScriptFieldInstance& fieldInstance = entityFields[name];

								// TODO(Yan): turn this assert into Hazelnut log warning
								HZ_CORE_ASSERT(fields.find(name) != fields.end());

								if (fields.find(name) == fields.end())
									continue;

								fieldInstance.Field = fields.at(name);

								switch (type)
								{
									READ_SCRIPT_FIELD(Float, float);
									READ_SCRIPT_FIELD(Double, double);
									READ_SCRIPT_FIELD(Bool, bool);
									READ_SCRIPT_FIELD(Char, char);
									READ_SCRIPT_FIELD(Byte, int8_t);
									READ_SCRIPT_FIELD(Short, int16_t);
									READ_SCRIPT_FIELD(Int, int32_t);
									READ_SCRIPT_FIELD(Long, int64_t);
									READ_SCRIPT_FIELD(UByte, uint8_t);
									READ_SCRIPT_FIELD(UShort, uint16_t);
									READ_SCRIPT_FIELD(UInt, uint32_t);
									READ_SCRIPT_FIELD(ULong, uint64_t);
									READ_SCRIPT_FIELD(Vector2, glm::vec2);
									READ_SCRIPT_FIELD(Vector3, glm::vec3);
									READ_SCRIPT_FIELD(Vector4, glm::vec4);
									READ_SCRIPT_FIELD(Entity, UUID);
								}
							}
						}
					}

				}

				auto spriteRendererComponent = entity["SpriteRendererComponent"];
				if (spriteRendererComponent)
				{
					auto& src = deserializedEntity.AddComponent<SpriteRendererComponent>();
					src.Color = spriteRendererComponent["Color"].as<glm::vec4>();
					if (spriteRendererComponent["TexturePath"])
					{
						std::string texturePath = spriteRendererComponent["TexturePath"].as<std::string>();
						auto path = Project::GetAssetFileSystemPath(texturePath);
						src.Texture = Texture2D::Create(path.string());
					}

					if (spriteRendererComponent["TilingFactor"])
						src.TilingFactor = spriteRendererComponent["TilingFactor"].as<float>();
				}

				auto circleRendererComponent = entity["CircleRendererComponent"];
				if (circleRendererComponent)
				{
					auto& crc = deserializedEntity.AddComponent<CircleRendererComponent>();
					crc.Color = circleRendererComponent["Color"].as<glm::vec4>();
					crc.Thickness = circleRendererComponent["Thickness"].as<float>();
					crc.Fade = circleRendererComponent["Fade"].as<float>();
				}

				auto rigidbody2DComponent = entity["Rigidbody2DComponent"];
				if (rigidbody2DComponent)
				{
					auto& rb2d = deserializedEntity.AddComponent<Rigidbody2DComponent>();
					rb2d.Type = RigidBody2DBodyTypeFromString(rigidbody2DComponent["BodyType"].as<std::string>());
					rb2d.FixedRotation = rigidbody2DComponent["FixedRotation"].as<bool>();
				}

				auto boxCollider2DComponent = entity["BoxCollider2DComponent"];
				if (boxCollider2DComponent)
				{
					auto& bc2d = deserializedEntity.AddComponent<BoxCollider2DComponent>();
					bc2d.Offset = boxCollider2DComponent["Offset"].as<glm::vec2>();
					bc2d.Size = boxCollider2DComponent["Size"].as<glm::vec2>();
					bc2d.Density = boxCollider2DComponent["Density"].as<float>();
					bc2d.Friction = boxCollider2DComponent["Friction"].as<float>();
					bc2d.Restitution = boxCollider2DComponent["Restitution"].as<float>();
					bc2d.RestitutionThreshold = boxCollider2DComponent["RestitutionThreshold"].as<float>();
				}

				auto circleCollider2DComponent = entity["CircleCollider2DComponent"];
				if (circleCollider2DComponent)
				{
					auto& cc2d = deserializedEntity.AddComponent<CircleCollider2DComponent>();
					cc2d.Offset = circleCollider2DComponent["Offset"].as<glm::vec2>();
					cc2d.Radius = circleCollider2DComponent["Radius"].as<float>();
					cc2d.Density = circleCollider2DComponent["Density"].as<float>();
					cc2d.Friction = circleCollider2DComponent["Friction"].as<float>();
					cc2d.Restitution = circleCollider2DComponent["Restitution"].as<float>();
					cc2d.RestitutionThreshold = circleCollider2DComponent["RestitutionThreshold"].as<float>();
				}

				auto textComponent = entity["TextComponent"];
				if (textComponent)
				{
					auto& tc = deserializedEntity.AddComponent<TextComponent>();
					tc.TextString = textComponent["TextString"].as<std::string>();
					// tc.FontAsset // TODO
					tc.Color = textComponent["Color"].as<glm::vec4>();
					tc.Kerning = textComponent["Kerning"].as<float>();
					tc.LineSpacing = textComponent["LineSpacing"].as<float>();
				}
			}
		}

		return true;
	}

	bool SceneSerializer::DeserializeRuntime(const std::string& filepath)
	{
		// Not implemented
		HZ_CORE_ASSERT(false);
		return false;
	}

}

```

`Hazel/src/Hazel/Scene/SceneSerializer.h`:

```h
#pragma once

#include "Scene.h"

namespace Hazel {

	class SceneSerializer
	{
	public:
		SceneSerializer(const Ref<Scene>& scene);

		void Serialize(const std::string& filepath);
		void SerializeRuntime(const std::string& filepath);

		bool Deserialize(const std::string& filepath);
		bool DeserializeRuntime(const std::string& filepath);
	private:
		Ref<Scene> m_Scene;
	};

}

```

`Hazel/src/Hazel/Scene/ScriptableEntity.h`:

```h
#pragma once

#include "Entity.h"

namespace Hazel {

	class ScriptableEntity
	{
	public:
		virtual ~ScriptableEntity() {}

		template<typename T>
		T& GetComponent()
		{
			return m_Entity.GetComponent<T>();
		}
	protected:
		virtual void OnCreate() {}
		virtual void OnDestroy() {}
		virtual void OnUpdate(Timestep ts) {}
	private:
		Entity m_Entity;
		friend class Scene;
	};

}


```

`Hazel/src/Hazel/Scripting/ScriptEngine.cpp`:

```cpp
#include "hzpch.h"
#include "ScriptEngine.h"

#include "ScriptGlue.h"

#include "mono/jit/jit.h"
#include "mono/metadata/assembly.h"
#include "mono/metadata/object.h"
#include "mono/metadata/tabledefs.h"
#include "mono/metadata/mono-debug.h"
#include "mono/metadata/threads.h"

#include "FileWatch.h"

#include "Hazel/Core/Application.h"
#include "Hazel/Core/Timer.h"
#include "Hazel/Core/Buffer.h"
#include "Hazel/Core/FileSystem.h"

#include "Hazel/Project/Project.h"

namespace Hazel {

	static std::unordered_map<std::string, ScriptFieldType> s_ScriptFieldTypeMap =
	{
		{ "System.Single", ScriptFieldType::Float },
		{ "System.Double", ScriptFieldType::Double },
		{ "System.Boolean", ScriptFieldType::Bool },
		{ "System.Char", ScriptFieldType::Char },
		{ "System.Int16", ScriptFieldType::Short },
		{ "System.Int32", ScriptFieldType::Int },
		{ "System.Int64", ScriptFieldType::Long },
		{ "System.Byte", ScriptFieldType::Byte },
		{ "System.UInt16", ScriptFieldType::UShort },
		{ "System.UInt32", ScriptFieldType::UInt },
		{ "System.UInt64", ScriptFieldType::ULong },

		{ "Hazel.Vector2", ScriptFieldType::Vector2 },
		{ "Hazel.Vector3", ScriptFieldType::Vector3 },
		{ "Hazel.Vector4", ScriptFieldType::Vector4 },

		{ "Hazel.Entity", ScriptFieldType::Entity },
	};

	namespace Utils {

		static MonoAssembly* LoadMonoAssembly(const std::filesystem::path& assemblyPath, bool loadPDB = false)
		{
			ScopedBuffer fileData = FileSystem::ReadFileBinary(assemblyPath);

			// NOTE: We can't use this image for anything other than loading the assembly because this image doesn't have a reference to the assembly
			MonoImageOpenStatus status;
			MonoImage* image = mono_image_open_from_data_full(fileData.As<char>(), fileData.Size(), 1, &status, 0);

			if (status != MONO_IMAGE_OK)
			{
				const char* errorMessage = mono_image_strerror(status);
				// Log some error message using the errorMessage data
				return nullptr;
			}

			if (loadPDB)
			{
				std::filesystem::path pdbPath = assemblyPath;
				pdbPath.replace_extension(".pdb");

				if (std::filesystem::exists(pdbPath))
				{
					ScopedBuffer pdbFileData = FileSystem::ReadFileBinary(pdbPath);
					mono_debug_open_image_from_memory(image, pdbFileData.As<const mono_byte>(), pdbFileData.Size());
					HZ_CORE_INFO("Loaded PDB {}", pdbPath);
				}
			}

			std::string pathString = assemblyPath.string();
			MonoAssembly* assembly = mono_assembly_load_from_full(image, pathString.c_str(), &status, 0);
			mono_image_close(image);

			return assembly;
		}

		void PrintAssemblyTypes(MonoAssembly* assembly)
		{
			MonoImage* image = mono_assembly_get_image(assembly);
			const MonoTableInfo* typeDefinitionsTable = mono_image_get_table_info(image, MONO_TABLE_TYPEDEF);
			int32_t numTypes = mono_table_info_get_rows(typeDefinitionsTable);

			for (int32_t i = 0; i < numTypes; i++)
			{
				uint32_t cols[MONO_TYPEDEF_SIZE];
				mono_metadata_decode_row(typeDefinitionsTable, i, cols, MONO_TYPEDEF_SIZE);

				const char* nameSpace = mono_metadata_string_heap(image, cols[MONO_TYPEDEF_NAMESPACE]);
				const char* name = mono_metadata_string_heap(image, cols[MONO_TYPEDEF_NAME]);
				HZ_CORE_TRACE("{}.{}", nameSpace, name);
			}
		}

		ScriptFieldType MonoTypeToScriptFieldType(MonoType* monoType)
		{
			std::string typeName = mono_type_get_name(monoType);

			auto it = s_ScriptFieldTypeMap.find(typeName);
			if (it == s_ScriptFieldTypeMap.end())
			{
				HZ_CORE_ERROR("Unknown type: {}", typeName);
				return ScriptFieldType::None;
			}

			return it->second;
		}

	}

	struct ScriptEngineData
	{
		MonoDomain* RootDomain = nullptr;
		MonoDomain* AppDomain = nullptr;

		MonoAssembly* CoreAssembly = nullptr;
		MonoImage* CoreAssemblyImage = nullptr;

		MonoAssembly* AppAssembly = nullptr;
		MonoImage* AppAssemblyImage = nullptr;

		std::filesystem::path CoreAssemblyFilepath;
		std::filesystem::path AppAssemblyFilepath;

		ScriptClass EntityClass;

		std::unordered_map<std::string, Ref<ScriptClass>> EntityClasses;
		std::unordered_map<UUID, Ref<ScriptInstance>> EntityInstances;
		std::unordered_map<UUID, ScriptFieldMap> EntityScriptFields;

		Scope<filewatch::FileWatch<std::string>> AppAssemblyFileWatcher;
		bool AssemblyReloadPending = false;

#ifdef HZ_DEBUG
		bool EnableDebugging = true;
#else
		bool EnableDebugging = false;
#endif
		// Runtime

		Scene* SceneContext = nullptr;
	};

	static ScriptEngineData* s_Data = nullptr;

	static void OnAppAssemblyFileSystemEvent(const std::string& path, const filewatch::Event change_type)
	{
		if (!s_Data->AssemblyReloadPending && change_type == filewatch::Event::modified)
		{
			s_Data->AssemblyReloadPending = true;

			Application::Get().SubmitToMainThread([]()
			{
				s_Data->AppAssemblyFileWatcher.reset();
				ScriptEngine::ReloadAssembly();
			});
		}
	}

	void ScriptEngine::Init()
	{
		s_Data = new ScriptEngineData();

		InitMono();
		ScriptGlue::RegisterFunctions();

		bool status = LoadAssembly("Resources/Scripts/Hazel-ScriptCore.dll");
		if (!status)
		{
			HZ_CORE_ERROR("[ScriptEngine] Could not load Hazel-ScriptCore assembly.");
			return;
		}
		
		auto scriptModulePath = Project::GetAssetDirectory() / Project::GetActive()->GetConfig().ScriptModulePath;
		status = LoadAppAssembly(scriptModulePath);
		if (!status)
		{
			HZ_CORE_ERROR("[ScriptEngine] Could not load app assembly.");
			return;
		}

		LoadAssemblyClasses();

		ScriptGlue::RegisterComponents();

		// Retrieve and instantiate class
		s_Data->EntityClass = ScriptClass("Hazel", "Entity", true);
	}

	void ScriptEngine::Shutdown()
	{
		ShutdownMono();
		delete s_Data;
	}

	void ScriptEngine::InitMono()
	{
		mono_set_assemblies_path("mono/lib");

		if (s_Data->EnableDebugging)
		{
			const char* argv[2] = {
				"--debugger-agent=transport=dt_socket,address=127.0.0.1:2550,server=y,suspend=n,loglevel=3,logfile=MonoDebugger.log",
				"--soft-breakpoints"
			};

			mono_jit_parse_options(2, (char**)argv);
			mono_debug_init(MONO_DEBUG_FORMAT_MONO);
		}

		MonoDomain* rootDomain = mono_jit_init("HazelJITRuntime");
		HZ_CORE_ASSERT(rootDomain);

		// Store the root domain pointer
		s_Data->RootDomain = rootDomain;

		if (s_Data->EnableDebugging)
			mono_debug_domain_create(s_Data->RootDomain);

		mono_thread_set_main(mono_thread_current());
	}

	void ScriptEngine::ShutdownMono()
	{
		mono_domain_set(mono_get_root_domain(), false);

		mono_domain_unload(s_Data->AppDomain);
		s_Data->AppDomain = nullptr;
		
		mono_jit_cleanup(s_Data->RootDomain);
		s_Data->RootDomain = nullptr;
	}

	bool ScriptEngine::LoadAssembly(const std::filesystem::path& filepath)
	{
		// Create an App Domain
		s_Data->AppDomain = mono_domain_create_appdomain("HazelScriptRuntime", nullptr);
		mono_domain_set(s_Data->AppDomain, true);

		s_Data->CoreAssemblyFilepath = filepath;
		s_Data->CoreAssembly = Utils::LoadMonoAssembly(filepath, s_Data->EnableDebugging);
		if (s_Data->CoreAssembly == nullptr)
			return false;

		s_Data->CoreAssemblyImage = mono_assembly_get_image(s_Data->CoreAssembly);
		return true;
	}

	bool ScriptEngine::LoadAppAssembly(const std::filesystem::path& filepath)
	{
		s_Data->AppAssemblyFilepath = filepath;
		s_Data->AppAssembly = Utils::LoadMonoAssembly(filepath, s_Data->EnableDebugging);
		if (s_Data->AppAssembly == nullptr)
			return false;

		s_Data->AppAssemblyImage = mono_assembly_get_image(s_Data->AppAssembly);

		s_Data->AppAssemblyFileWatcher = CreateScope<filewatch::FileWatch<std::string>>(filepath.string(), OnAppAssemblyFileSystemEvent);
		s_Data->AssemblyReloadPending = false;
		return true;
	}

	void ScriptEngine::ReloadAssembly()
	{
		mono_domain_set(mono_get_root_domain(), false);

		mono_domain_unload(s_Data->AppDomain);

		LoadAssembly(s_Data->CoreAssemblyFilepath);
		LoadAppAssembly(s_Data->AppAssemblyFilepath);
		LoadAssemblyClasses();

		ScriptGlue::RegisterComponents();

		// Retrieve and instantiate class
		s_Data->EntityClass = ScriptClass("Hazel", "Entity", true);
	}

	void ScriptEngine::OnRuntimeStart(Scene* scene)
	{
		s_Data->SceneContext = scene;
	}

	bool ScriptEngine::EntityClassExists(const std::string& fullClassName)
	{
		return s_Data->EntityClasses.find(fullClassName) != s_Data->EntityClasses.end();
	}

	void ScriptEngine::OnCreateEntity(Entity entity)
	{
		const auto& sc = entity.GetComponent<ScriptComponent>();
		if (ScriptEngine::EntityClassExists(sc.ClassName))
		{
			UUID entityID = entity.GetUUID();

			Ref<ScriptInstance> instance = CreateRef<ScriptInstance>(s_Data->EntityClasses[sc.ClassName], entity);
			s_Data->EntityInstances[entityID] = instance;

			// Copy field values
			if (s_Data->EntityScriptFields.find(entityID) != s_Data->EntityScriptFields.end())
			{
				const ScriptFieldMap& fieldMap = s_Data->EntityScriptFields.at(entityID);
				for (const auto& [name, fieldInstance] : fieldMap)
					instance->SetFieldValueInternal(name, fieldInstance.m_Buffer);
			}

			instance->InvokeOnCreate();
		}
	}

	void ScriptEngine::OnUpdateEntity(Entity entity, Timestep ts)
	{
		UUID entityUUID = entity.GetUUID();
		if (s_Data->EntityInstances.find(entityUUID) != s_Data->EntityInstances.end())
		{
			Ref<ScriptInstance> instance = s_Data->EntityInstances[entityUUID];
			instance->InvokeOnUpdate((float)ts);
		}
		else
		{
			HZ_CORE_ERROR("Could not find ScriptInstance for entity {}",  entityUUID);
		}
	}

	Scene* ScriptEngine::GetSceneContext()
	{
		return s_Data->SceneContext;
	}

	Ref<ScriptInstance> ScriptEngine::GetEntityScriptInstance(UUID entityID)
	{
		auto it = s_Data->EntityInstances.find(entityID);
		if (it == s_Data->EntityInstances.end())
			return nullptr;

		return it->second;
	}


	Ref<ScriptClass> ScriptEngine::GetEntityClass(const std::string& name)
	{
		if (s_Data->EntityClasses.find(name) == s_Data->EntityClasses.end())
			return nullptr;

		return s_Data->EntityClasses.at(name);
	}

	void ScriptEngine::OnRuntimeStop()
	{
		s_Data->SceneContext = nullptr;

		s_Data->EntityInstances.clear();
	}

	std::unordered_map<std::string, Ref<ScriptClass>> ScriptEngine::GetEntityClasses()
	{
		return s_Data->EntityClasses;
	}

	ScriptFieldMap& ScriptEngine::GetScriptFieldMap(Entity entity)
	{
		HZ_CORE_ASSERT(entity);

		UUID entityID = entity.GetUUID();
		return s_Data->EntityScriptFields[entityID];
	}

	void ScriptEngine::LoadAssemblyClasses()
	{
		s_Data->EntityClasses.clear();

		const MonoTableInfo* typeDefinitionsTable = mono_image_get_table_info(s_Data->AppAssemblyImage, MONO_TABLE_TYPEDEF);
		int32_t numTypes = mono_table_info_get_rows(typeDefinitionsTable);
		MonoClass* entityClass = mono_class_from_name(s_Data->CoreAssemblyImage, "Hazel", "Entity");

		for (int32_t i = 0; i < numTypes; i++)
		{
			uint32_t cols[MONO_TYPEDEF_SIZE];
			mono_metadata_decode_row(typeDefinitionsTable, i, cols, MONO_TYPEDEF_SIZE);

			const char* nameSpace = mono_metadata_string_heap(s_Data->AppAssemblyImage, cols[MONO_TYPEDEF_NAMESPACE]);
			const char* className = mono_metadata_string_heap(s_Data->AppAssemblyImage, cols[MONO_TYPEDEF_NAME]);
			std::string fullName;
			if (strlen(nameSpace) != 0)
				fullName = fmt::format("{}.{}", nameSpace, className);
			else
				fullName = className;

			MonoClass* monoClass = mono_class_from_name(s_Data->AppAssemblyImage, nameSpace, className);

			if (monoClass == entityClass)
				continue;

			bool isEntity = mono_class_is_subclass_of(monoClass, entityClass, false);
			if (!isEntity)
				continue;

			Ref<ScriptClass> scriptClass = CreateRef<ScriptClass>(nameSpace, className);
			s_Data->EntityClasses[fullName] = scriptClass;


			// This routine is an iterator routine for retrieving the fields in a class.
			// You must pass a gpointer that points to zero and is treated as an opaque handle
			// to iterate over all of the elements. When no more values are available, the return value is NULL.

			int fieldCount = mono_class_num_fields(monoClass);
			HZ_CORE_WARN("{} has {} fields:", className, fieldCount);
			void* iterator = nullptr;
			while (MonoClassField* field = mono_class_get_fields(monoClass, &iterator))
			{
				const char* fieldName = mono_field_get_name(field);
				uint32_t flags = mono_field_get_flags(field);
				if (flags & FIELD_ATTRIBUTE_PUBLIC)
				{
					MonoType* type = mono_field_get_type(field);
					ScriptFieldType fieldType = Utils::MonoTypeToScriptFieldType(type);
					HZ_CORE_WARN("  {} ({})", fieldName, Utils::ScriptFieldTypeToString(fieldType));

					scriptClass->m_Fields[fieldName] = { fieldType, fieldName, field };
				}
			}

		}

		auto& entityClasses = s_Data->EntityClasses;

		//mono_field_get_value()

	}

	MonoImage* ScriptEngine::GetCoreAssemblyImage()
	{
		return s_Data->CoreAssemblyImage;
	}


	MonoObject* ScriptEngine::GetManagedInstance(UUID uuid)
	{
		HZ_CORE_ASSERT(s_Data->EntityInstances.find(uuid) != s_Data->EntityInstances.end());
		return s_Data->EntityInstances.at(uuid)->GetManagedObject();
	}

	MonoString* ScriptEngine::CreateString(const char* string)
	{
		return mono_string_new(s_Data->AppDomain, string);
	}

	MonoObject* ScriptEngine::InstantiateClass(MonoClass* monoClass)
	{
		MonoObject* instance = mono_object_new(s_Data->AppDomain, monoClass);
		mono_runtime_object_init(instance);
		return instance;
	}

	ScriptClass::ScriptClass(const std::string& classNamespace, const std::string& className, bool isCore)
		: m_ClassNamespace(classNamespace), m_ClassName(className)
	{
		m_MonoClass = mono_class_from_name(isCore ? s_Data->CoreAssemblyImage : s_Data->AppAssemblyImage, classNamespace.c_str(), className.c_str());
	}

	MonoObject* ScriptClass::Instantiate()
	{
		return ScriptEngine::InstantiateClass(m_MonoClass);
	}

	MonoMethod* ScriptClass::GetMethod(const std::string& name, int parameterCount)
	{
		return mono_class_get_method_from_name(m_MonoClass, name.c_str(), parameterCount);
	}

	MonoObject* ScriptClass::InvokeMethod(MonoObject* instance, MonoMethod* method, void** params)
	{
		MonoObject* exception = nullptr;
		return mono_runtime_invoke(method, instance, params, &exception);
	}

	ScriptInstance::ScriptInstance(Ref<ScriptClass> scriptClass, Entity entity)
		: m_ScriptClass(scriptClass)
	{
		m_Instance = scriptClass->Instantiate();

		m_Constructor = s_Data->EntityClass.GetMethod(".ctor", 1);
		m_OnCreateMethod = scriptClass->GetMethod("OnCreate", 0);
		m_OnUpdateMethod = scriptClass->GetMethod("OnUpdate", 1);

		// Call Entity constructor
		{
			UUID entityID = entity.GetUUID();
			void* param = &entityID;
			m_ScriptClass->InvokeMethod(m_Instance, m_Constructor, &param);
		}
	}

	void ScriptInstance::InvokeOnCreate()
	{
		if (m_OnCreateMethod)
			m_ScriptClass->InvokeMethod(m_Instance, m_OnCreateMethod);
	}

	void ScriptInstance::InvokeOnUpdate(float ts)
	{
		if (m_OnUpdateMethod)
		{
			void* param = &ts;
			m_ScriptClass->InvokeMethod(m_Instance, m_OnUpdateMethod, &param);
		}
	}

	bool ScriptInstance::GetFieldValueInternal(const std::string& name, void* buffer)
	{
		const auto& fields = m_ScriptClass->GetFields();
		auto it = fields.find(name);
		if (it == fields.end())
			return false;

		const ScriptField& field = it->second;
		mono_field_get_value(m_Instance, field.ClassField, buffer);
		return true;
	}

	bool ScriptInstance::SetFieldValueInternal(const std::string& name, const void* value)
	{
		const auto& fields = m_ScriptClass->GetFields();
		auto it = fields.find(name);
		if (it == fields.end())
			return false;

		const ScriptField& field = it->second;
		mono_field_set_value(m_Instance, field.ClassField, (void*)value);
		return true;
	}

}

```

`Hazel/src/Hazel/Scripting/ScriptEngine.h`:

```h
#pragma once

#include "Hazel/Scene/Scene.h"
#include "Hazel/Scene/Entity.h"

#include <filesystem>
#include <string>
#include <map>

extern "C" {
	typedef struct _MonoClass MonoClass;
	typedef struct _MonoObject MonoObject;
	typedef struct _MonoMethod MonoMethod;
	typedef struct _MonoAssembly MonoAssembly;
	typedef struct _MonoImage MonoImage;
	typedef struct _MonoClassField MonoClassField;
	typedef struct _MonoString MonoString;
}

namespace Hazel {

	enum class ScriptFieldType
	{
		None = 0,
		Float, Double,
		Bool, Char, Byte, Short, Int, Long,
		UByte, UShort, UInt, ULong,
		Vector2, Vector3, Vector4,
		Entity
	};

	struct ScriptField
	{
		ScriptFieldType Type;
		std::string Name;
		
		MonoClassField* ClassField;
	};

	// ScriptField + data storage
	struct ScriptFieldInstance
	{
		ScriptField Field;

		ScriptFieldInstance()
		{
			memset(m_Buffer, 0, sizeof(m_Buffer));
		}

		template<typename T>
		T GetValue()
		{
			static_assert(sizeof(T) <= 16, "Type too large!");
			return *(T*)m_Buffer;
		}

		template<typename T>
		void SetValue(T value)
		{
			static_assert(sizeof(T) <= 16, "Type too large!");
			memcpy(m_Buffer, &value, sizeof(T));
		}
	private:
		uint8_t m_Buffer[16];

		friend class ScriptEngine;
		friend class ScriptInstance;
	};

	using ScriptFieldMap = std::unordered_map<std::string, ScriptFieldInstance>;

	class ScriptClass
	{
	public:
		ScriptClass() = default;
		ScriptClass(const std::string& classNamespace, const std::string& className, bool isCore = false);

		MonoObject* Instantiate();
		MonoMethod* GetMethod(const std::string& name, int parameterCount);
		MonoObject* InvokeMethod(MonoObject* instance, MonoMethod* method, void** params = nullptr);

		const std::map<std::string, ScriptField>& GetFields() const { return m_Fields; }
	private:
		std::string m_ClassNamespace;
		std::string m_ClassName;

		std::map<std::string, ScriptField> m_Fields;

		MonoClass* m_MonoClass = nullptr;

		friend class ScriptEngine;
	};

	class ScriptInstance
	{
	public:
		ScriptInstance(Ref<ScriptClass> scriptClass, Entity entity);

		void InvokeOnCreate();
		void InvokeOnUpdate(float ts);

		Ref<ScriptClass> GetScriptClass() { return m_ScriptClass; }

		template<typename T>
		T GetFieldValue(const std::string& name)
		{
			static_assert(sizeof(T) <= 16, "Type too large!");

			bool success = GetFieldValueInternal(name, s_FieldValueBuffer);	
			if (!success)
				return T();

			return *(T*)s_FieldValueBuffer;
		}

		template<typename T>
		void SetFieldValue(const std::string& name, T value)
		{
			static_assert(sizeof(T) <= 16, "Type too large!");

			SetFieldValueInternal(name, &value);
		}

		MonoObject* GetManagedObject() { return m_Instance; }
	private:
		bool GetFieldValueInternal(const std::string& name, void* buffer);
		bool SetFieldValueInternal(const std::string& name, const void* value);
	private:
		Ref<ScriptClass> m_ScriptClass;

		MonoObject* m_Instance = nullptr;
		MonoMethod* m_Constructor = nullptr;
		MonoMethod* m_OnCreateMethod = nullptr;
		MonoMethod* m_OnUpdateMethod = nullptr;

		inline static char s_FieldValueBuffer[16];

		friend class ScriptEngine;
		friend struct ScriptFieldInstance;
	};

	class ScriptEngine
	{
	public:
		static void Init();
		static void Shutdown();

		static bool LoadAssembly(const std::filesystem::path& filepath);
		static bool LoadAppAssembly(const std::filesystem::path& filepath);
		
		static void ReloadAssembly();

		static void OnRuntimeStart(Scene* scene);
		static void OnRuntimeStop();

		static bool EntityClassExists(const std::string& fullClassName);
		static void OnCreateEntity(Entity entity);
		static void OnUpdateEntity(Entity entity, Timestep ts);

		static Scene* GetSceneContext();
		static Ref<ScriptInstance> GetEntityScriptInstance(UUID entityID);
		
		static Ref<ScriptClass> GetEntityClass(const std::string& name);
		static std::unordered_map<std::string, Ref<ScriptClass>> GetEntityClasses();
		static ScriptFieldMap& GetScriptFieldMap(Entity entity);
		
		static MonoImage* GetCoreAssemblyImage();

		static MonoObject* GetManagedInstance(UUID uuid);

		static MonoString* CreateString(const char* string);
	private:
		static void InitMono();
		static void ShutdownMono();

		static MonoObject* InstantiateClass(MonoClass* monoClass);
		static void LoadAssemblyClasses();

		friend class ScriptClass;
		friend class ScriptGlue;
	};

	namespace Utils {

		inline const char* ScriptFieldTypeToString(ScriptFieldType fieldType)
		{
			switch (fieldType)
			{
				case ScriptFieldType::None:    return "None";
				case ScriptFieldType::Float:   return "Float";
				case ScriptFieldType::Double:  return "Double";
				case ScriptFieldType::Bool:    return "Bool";
				case ScriptFieldType::Char:    return "Char";
				case ScriptFieldType::Byte:    return "Byte";
				case ScriptFieldType::Short:   return "Short";
				case ScriptFieldType::Int:     return "Int";
				case ScriptFieldType::Long:    return "Long";
				case ScriptFieldType::UByte:   return "UByte";
				case ScriptFieldType::UShort:  return "UShort";
				case ScriptFieldType::UInt:    return "UInt";
				case ScriptFieldType::ULong:   return "ULong";
				case ScriptFieldType::Vector2: return "Vector2";
				case ScriptFieldType::Vector3: return "Vector3";
				case ScriptFieldType::Vector4: return "Vector4";
				case ScriptFieldType::Entity:  return "Entity";
			}
			HZ_CORE_ASSERT(false, "Unknown ScriptFieldType");
			return "None";
		}

		inline ScriptFieldType ScriptFieldTypeFromString(std::string_view fieldType)
		{
			if (fieldType == "None")    return ScriptFieldType::None;
			if (fieldType == "Float")   return ScriptFieldType::Float;
			if (fieldType == "Double")  return ScriptFieldType::Double;
			if (fieldType == "Bool")    return ScriptFieldType::Bool;
			if (fieldType == "Char")    return ScriptFieldType::Char;
			if (fieldType == "Byte")    return ScriptFieldType::Byte;
			if (fieldType == "Short")   return ScriptFieldType::Short;
			if (fieldType == "Int")     return ScriptFieldType::Int;
			if (fieldType == "Long")    return ScriptFieldType::Long;
			if (fieldType == "UByte")   return ScriptFieldType::UByte;
			if (fieldType == "UShort")  return ScriptFieldType::UShort;
			if (fieldType == "UInt")    return ScriptFieldType::UInt;
			if (fieldType == "ULong")   return ScriptFieldType::ULong;
			if (fieldType == "Vector2") return ScriptFieldType::Vector2;
			if (fieldType == "Vector3") return ScriptFieldType::Vector3;
			if (fieldType == "Vector4") return ScriptFieldType::Vector4;
			if (fieldType == "Entity")  return ScriptFieldType::Entity;

			HZ_CORE_ASSERT(false, "Unknown ScriptFieldType");
			return ScriptFieldType::None;
		}

	}

}

```

`Hazel/src/Hazel/Scripting/ScriptGlue.cpp`:

```cpp
#include "hzpch.h"
#include "ScriptGlue.h"
#include "ScriptEngine.h"

#include "Hazel/Core/UUID.h"
#include "Hazel/Core/KeyCodes.h"
#include "Hazel/Core/Input.h"

#include "Hazel/Scene/Scene.h"
#include "Hazel/Scene/Entity.h"

#include "Hazel/Physics/Physics2D.h"

#include "mono/metadata/object.h"
#include "mono/metadata/reflection.h"

#include "box2d/b2_body.h"

namespace Hazel {

	namespace Utils {

		std::string MonoStringToString(MonoString* string)
		{
			char* cStr = mono_string_to_utf8(string);
			std::string str(cStr);
			mono_free(cStr);
			return str;
		}

	}

	static std::unordered_map<MonoType*, std::function<bool(Entity)>> s_EntityHasComponentFuncs;

#define HZ_ADD_INTERNAL_CALL(Name) mono_add_internal_call("Hazel.InternalCalls::" #Name, Name)

	static void NativeLog(MonoString* string, int parameter)
	{
		std::string str = Utils::MonoStringToString(string);
		std::cout << str << ", " << parameter << std::endl;
	}

	static void NativeLog_Vector(glm::vec3* parameter, glm::vec3* outResult)
	{
		HZ_CORE_WARN("Value: {0}", *parameter);
		*outResult = glm::normalize(*parameter);
	}

	static float NativeLog_VectorDot(glm::vec3* parameter)
	{
		HZ_CORE_WARN("Value: {0}", *parameter);
		return glm::dot(*parameter, *parameter);
	}

	static MonoObject* GetScriptInstance(UUID entityID)
	{
		return ScriptEngine::GetManagedInstance(entityID);
	}

	static bool Entity_HasComponent(UUID entityID, MonoReflectionType* componentType)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		MonoType* managedType = mono_reflection_type_get_type(componentType);
		HZ_CORE_ASSERT(s_EntityHasComponentFuncs.find(managedType) != s_EntityHasComponentFuncs.end());
		return s_EntityHasComponentFuncs.at(managedType)(entity);
	}

	static uint64_t Entity_FindEntityByName(MonoString* name)
	{
		char* nameCStr = mono_string_to_utf8(name);

		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->FindEntityByName(nameCStr);
		mono_free(nameCStr);

		if (!entity)
			return 0;
		
		return entity.GetUUID();
	}

	static void TransformComponent_GetTranslation(UUID entityID, glm::vec3* outTranslation)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		*outTranslation = entity.GetComponent<TransformComponent>().Translation;
	}

	static void TransformComponent_SetTranslation(UUID entityID, glm::vec3* translation)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		entity.GetComponent<TransformComponent>().Translation = *translation;
	}

	static void Rigidbody2DComponent_ApplyLinearImpulse(UUID entityID, glm::vec2* impulse, glm::vec2* point, bool wake)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();
		b2Body* body = (b2Body*)rb2d.RuntimeBody;
		body->ApplyLinearImpulse(b2Vec2(impulse->x, impulse->y), b2Vec2(point->x, point->y), wake);
	}

	static void Rigidbody2DComponent_ApplyLinearImpulseToCenter(UUID entityID, glm::vec2* impulse, bool wake)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();
		b2Body* body = (b2Body*)rb2d.RuntimeBody;
		body->ApplyLinearImpulseToCenter(b2Vec2(impulse->x, impulse->y), wake);
	}
	
	static void Rigidbody2DComponent_GetLinearVelocity(UUID entityID, glm::vec2* outLinearVelocity)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();
		b2Body* body = (b2Body*)rb2d.RuntimeBody;
		const b2Vec2& linearVelocity = body->GetLinearVelocity();
		*outLinearVelocity = glm::vec2(linearVelocity.x, linearVelocity.y);
	}

	static Rigidbody2DComponent::BodyType Rigidbody2DComponent_GetType(UUID entityID)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();
		b2Body* body = (b2Body*)rb2d.RuntimeBody;
		return Utils::Rigidbody2DTypeFromBox2DBody(body->GetType());
	}
	
	static void Rigidbody2DComponent_SetType(UUID entityID, Rigidbody2DComponent::BodyType bodyType)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);

		auto& rb2d = entity.GetComponent<Rigidbody2DComponent>();
		b2Body* body = (b2Body*)rb2d.RuntimeBody;
		body->SetType(Utils::Rigidbody2DTypeToBox2DBody(bodyType));
	}

	static MonoString* TextComponent_GetText(UUID entityID)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		return ScriptEngine::CreateString(tc.TextString.c_str());
	}

	static void TextComponent_SetText(UUID entityID, MonoString* textString)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		tc.TextString = Utils::MonoStringToString(textString);
	}

	static void TextComponent_GetColor(UUID entityID, glm::vec4* color)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		*color = tc.Color;
	}

	static void TextComponent_SetColor(UUID entityID, glm::vec4* color)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		tc.Color = *color;
	}

	static float TextComponent_GetKerning(UUID entityID)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		return tc.Kerning;
	}

	static void TextComponent_SetKerning(UUID entityID, float kerning)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		tc.Kerning = kerning;
	}

	static float TextComponent_GetLineSpacing(UUID entityID)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		return tc.LineSpacing;
	}

	static void TextComponent_SetLineSpacing(UUID entityID, float lineSpacing)
	{
		Scene* scene = ScriptEngine::GetSceneContext();
		HZ_CORE_ASSERT(scene);
		Entity entity = scene->GetEntityByUUID(entityID);
		HZ_CORE_ASSERT(entity);
		HZ_CORE_ASSERT(entity.HasComponent<TextComponent>());

		auto& tc = entity.GetComponent<TextComponent>();
		tc.LineSpacing = lineSpacing;
	}

	static bool Input_IsKeyDown(KeyCode keycode)
	{
		return Input::IsKeyPressed(keycode);
	}

	template<typename... Component>
	static void RegisterComponent()
	{
		([]()
		{
			std::string_view typeName = typeid(Component).name();
			size_t pos = typeName.find_last_of(':');
			std::string_view structName = typeName.substr(pos + 1);
			std::string managedTypename = fmt::format("Hazel.{}", structName);

			MonoType* managedType = mono_reflection_type_from_name(managedTypename.data(), ScriptEngine::GetCoreAssemblyImage());
			if (!managedType)
			{
				HZ_CORE_ERROR("Could not find component type {}", managedTypename);
				return;
			}
			s_EntityHasComponentFuncs[managedType] = [](Entity entity) { return entity.HasComponent<Component>(); };
		}(), ...);
	}

	template<typename... Component>
	static void RegisterComponent(ComponentGroup<Component...>)
	{
		RegisterComponent<Component...>();
	}

	void ScriptGlue::RegisterComponents()
	{
		s_EntityHasComponentFuncs.clear();
		RegisterComponent(AllComponents{});
	}

	void ScriptGlue::RegisterFunctions()
	{
		HZ_ADD_INTERNAL_CALL(NativeLog);
		HZ_ADD_INTERNAL_CALL(NativeLog_Vector);
		HZ_ADD_INTERNAL_CALL(NativeLog_VectorDot);

		HZ_ADD_INTERNAL_CALL(GetScriptInstance);

		HZ_ADD_INTERNAL_CALL(Entity_HasComponent);
		HZ_ADD_INTERNAL_CALL(Entity_FindEntityByName);

		HZ_ADD_INTERNAL_CALL(TransformComponent_GetTranslation);
		HZ_ADD_INTERNAL_CALL(TransformComponent_SetTranslation);
		
		HZ_ADD_INTERNAL_CALL(Rigidbody2DComponent_ApplyLinearImpulse);
		HZ_ADD_INTERNAL_CALL(Rigidbody2DComponent_ApplyLinearImpulseToCenter);
		HZ_ADD_INTERNAL_CALL(Rigidbody2DComponent_GetLinearVelocity);
		HZ_ADD_INTERNAL_CALL(Rigidbody2DComponent_GetType);
		HZ_ADD_INTERNAL_CALL(Rigidbody2DComponent_SetType);
		
		HZ_ADD_INTERNAL_CALL(TextComponent_GetText);
		HZ_ADD_INTERNAL_CALL(TextComponent_SetText);
		HZ_ADD_INTERNAL_CALL(TextComponent_GetColor);
		HZ_ADD_INTERNAL_CALL(TextComponent_SetColor);
		HZ_ADD_INTERNAL_CALL(TextComponent_GetKerning);
		HZ_ADD_INTERNAL_CALL(TextComponent_SetKerning);
		HZ_ADD_INTERNAL_CALL(TextComponent_GetLineSpacing);
		HZ_ADD_INTERNAL_CALL(TextComponent_SetLineSpacing);

		HZ_ADD_INTERNAL_CALL(Input_IsKeyDown);
	}

}

```

`Hazel/src/Hazel/Scripting/ScriptGlue.h`:

```h
#pragma once

namespace Hazel {

	class ScriptGlue
	{
	public:
		static void RegisterComponents();
		static void RegisterFunctions();
	};

}

```

`Hazel/src/Hazel/UI/UI.h`:

```h
#pragma once

#include <imgui/imgui.h>

namespace Hazel::UI {

	struct ScopedStyleColor
	{
		ScopedStyleColor() = default;

		ScopedStyleColor(ImGuiCol idx, ImVec4 color, bool predicate = true)
			: m_Set(predicate)
		{
			if (predicate)
				ImGui::PushStyleColor(idx, color);
		}

		ScopedStyleColor(ImGuiCol idx, ImU32 color, bool predicate = true)
			: m_Set(predicate)
		{
			if (predicate)
				ImGui::PushStyleColor(idx, color);
		}

		~ScopedStyleColor()
		{
			if (m_Set)
				ImGui::PopStyleColor();
		}
	private:
		bool m_Set = false;
	};


}

```

`Hazel/src/Hazel/Utils/PlatformUtils.h`:

```h
#pragma once

#include <string>

namespace Hazel {

	class FileDialogs
	{
	public:
		// These return empty strings if cancelled
		static std::string OpenFile(const char* filter);
		static std::string SaveFile(const char* filter);
	};

	class Time
	{
	public:
		static float GetTime();
	};

}

```

`Hazel/src/Platform/OpenGL/OpenGLBuffer.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLBuffer.h"

#include <glad/glad.h>

namespace Hazel {

	/////////////////////////////////////////////////////////////////////////////
	// VertexBuffer /////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	OpenGLVertexBuffer::OpenGLVertexBuffer(uint32_t size)
	{
		HZ_PROFILE_FUNCTION();

		glCreateBuffers(1, &m_RendererID);
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferData(GL_ARRAY_BUFFER, size, nullptr, GL_DYNAMIC_DRAW);
	}

	OpenGLVertexBuffer::OpenGLVertexBuffer(float* vertices, uint32_t size)
	{
		HZ_PROFILE_FUNCTION();

		glCreateBuffers(1, &m_RendererID);
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferData(GL_ARRAY_BUFFER, size, vertices, GL_STATIC_DRAW);
	}

	OpenGLVertexBuffer::~OpenGLVertexBuffer()
	{
		HZ_PROFILE_FUNCTION();

		glDeleteBuffers(1, &m_RendererID);
	}

	void OpenGLVertexBuffer::Bind() const
	{
		HZ_PROFILE_FUNCTION();

		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
	}

	void OpenGLVertexBuffer::Unbind() const
	{
		HZ_PROFILE_FUNCTION();

		glBindBuffer(GL_ARRAY_BUFFER, 0);
	}

	void OpenGLVertexBuffer::SetData(const void* data, uint32_t size)
	{
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferSubData(GL_ARRAY_BUFFER, 0, size, data);
	}

	/////////////////////////////////////////////////////////////////////////////
	// IndexBuffer //////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	OpenGLIndexBuffer::OpenGLIndexBuffer(uint32_t* indices, uint32_t count)
		: m_Count(count)
	{
		HZ_PROFILE_FUNCTION();

		glCreateBuffers(1, &m_RendererID);
		
		// GL_ELEMENT_ARRAY_BUFFER is not valid without an actively bound VAO
		// Binding with GL_ARRAY_BUFFER allows the data to be loaded regardless of VAO state. 
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferData(GL_ARRAY_BUFFER, count * sizeof(uint32_t), indices, GL_STATIC_DRAW);
	}

	OpenGLIndexBuffer::~OpenGLIndexBuffer()
	{
		HZ_PROFILE_FUNCTION();

		glDeleteBuffers(1, &m_RendererID);
	}

	void OpenGLIndexBuffer::Bind() const
	{
		HZ_PROFILE_FUNCTION();

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);
	}

	void OpenGLIndexBuffer::Unbind() const
	{
		HZ_PROFILE_FUNCTION();

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLBuffer.h`:

```h
#pragma once

#include "Hazel/Renderer/Buffer.h"

namespace Hazel {

	class OpenGLVertexBuffer : public VertexBuffer
	{
	public:
		OpenGLVertexBuffer(uint32_t size);
		OpenGLVertexBuffer(float* vertices, uint32_t size);
		virtual ~OpenGLVertexBuffer();

		virtual void Bind() const override;
		virtual void Unbind() const override;
		
		virtual void SetData(const void* data, uint32_t size) override;

		virtual const BufferLayout& GetLayout() const override { return m_Layout; }
		virtual void SetLayout(const BufferLayout& layout) override { m_Layout = layout; }
	private:
		uint32_t m_RendererID;
		BufferLayout m_Layout;
	};

	class OpenGLIndexBuffer : public IndexBuffer
	{
	public:
		OpenGLIndexBuffer(uint32_t* indices, uint32_t count);
		virtual ~OpenGLIndexBuffer();

		virtual void Bind() const;
		virtual void Unbind() const;

		virtual uint32_t GetCount() const { return m_Count; }
	private:
		uint32_t m_RendererID;
		uint32_t m_Count;
	};

}
```

`Hazel/src/Platform/OpenGL/OpenGLContext.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLContext.h"

#include <GLFW/glfw3.h>
#include <glad/glad.h>

namespace Hazel {

	OpenGLContext::OpenGLContext(GLFWwindow* windowHandle)
		: m_WindowHandle(windowHandle)
	{
		HZ_CORE_ASSERT(windowHandle, "Window handle is null!")
	}

	void OpenGLContext::Init()
	{
		HZ_PROFILE_FUNCTION();

		glfwMakeContextCurrent(m_WindowHandle);
		int status = gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
		HZ_CORE_ASSERT(status, "Failed to initialize Glad!");

		HZ_CORE_INFO("OpenGL Info:");
		HZ_CORE_INFO("  Vendor: {0}", glGetString(GL_VENDOR));
		HZ_CORE_INFO("  Renderer: {0}", glGetString(GL_RENDERER));
		HZ_CORE_INFO("  Version: {0}", glGetString(GL_VERSION));

		HZ_CORE_ASSERT(GLVersion.major > 4 || (GLVersion.major == 4 && GLVersion.minor >= 5), "Hazel requires at least OpenGL version 4.5!");
	}

	void OpenGLContext::SwapBuffers()
	{
		HZ_PROFILE_FUNCTION();

		glfwSwapBuffers(m_WindowHandle);
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLContext.h`:

```h
#pragma once

#include "Hazel/Renderer/GraphicsContext.h"

struct GLFWwindow;

namespace Hazel {

	class OpenGLContext : public GraphicsContext
	{
	public:
		OpenGLContext(GLFWwindow* windowHandle);

		virtual void Init() override;
		virtual void SwapBuffers() override;
	private:
		GLFWwindow* m_WindowHandle;
	};

}
```

`Hazel/src/Platform/OpenGL/OpenGLFramebuffer.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLFramebuffer.h"

#include <glad/glad.h>

namespace Hazel {

	static const uint32_t s_MaxFramebufferSize = 8192;

	namespace Utils {

		static GLenum TextureTarget(bool multisampled)
		{
			return multisampled ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D;
		}

		static void CreateTextures(bool multisampled, uint32_t* outID, uint32_t count)
		{
			glCreateTextures(TextureTarget(multisampled), count, outID);
		}

		static void BindTexture(bool multisampled, uint32_t id)
		{
			glBindTexture(TextureTarget(multisampled), id);
		}

		static void AttachColorTexture(uint32_t id, int samples, GLenum internalFormat, GLenum format, uint32_t width, uint32_t height, int index)
		{
			bool multisampled = samples > 1;
			if (multisampled)
			{
				glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, internalFormat, width, height, GL_FALSE);
			}
			else
			{
				glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, GL_UNSIGNED_BYTE, nullptr);

				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
			}

			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + index, TextureTarget(multisampled), id, 0);
		}

		static void AttachDepthTexture(uint32_t id, int samples, GLenum format, GLenum attachmentType, uint32_t width, uint32_t height)
		{
			bool multisampled = samples > 1;
			if (multisampled)
			{
				glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, format, width, height, GL_FALSE);
			}
			else
			{
				glTexStorage2D(GL_TEXTURE_2D, 1, format, width, height);

				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
			}

			glFramebufferTexture2D(GL_FRAMEBUFFER, attachmentType, TextureTarget(multisampled), id, 0);
		}

		static bool IsDepthFormat(FramebufferTextureFormat format)
		{
			switch (format)
			{
				case FramebufferTextureFormat::DEPTH24STENCIL8:  return true;
			}

			return false;
		}

		static GLenum HazelFBTextureFormatToGL(FramebufferTextureFormat format)
		{
			switch (format)
			{
				case FramebufferTextureFormat::RGBA8:       return GL_RGBA8;
				case FramebufferTextureFormat::RED_INTEGER: return GL_RED_INTEGER;
			}

			HZ_CORE_ASSERT(false);
			return 0;
		}

	}

	OpenGLFramebuffer::OpenGLFramebuffer(const FramebufferSpecification& spec)
		: m_Specification(spec)
	{
		for (auto spec : m_Specification.Attachments.Attachments)
		{
			if (!Utils::IsDepthFormat(spec.TextureFormat))
				m_ColorAttachmentSpecifications.emplace_back(spec);
			else
				m_DepthAttachmentSpecification = spec;
		}

		Invalidate();
	}

	OpenGLFramebuffer::~OpenGLFramebuffer()
	{
		glDeleteFramebuffers(1, &m_RendererID);
		glDeleteTextures(m_ColorAttachments.size(), m_ColorAttachments.data());
		glDeleteTextures(1, &m_DepthAttachment);
	}

	void OpenGLFramebuffer::Invalidate()
	{
		if (m_RendererID)
		{
			glDeleteFramebuffers(1, &m_RendererID);
			glDeleteTextures(m_ColorAttachments.size(), m_ColorAttachments.data());
			glDeleteTextures(1, &m_DepthAttachment);
			
			m_ColorAttachments.clear();
			m_DepthAttachment = 0;
		}

		glCreateFramebuffers(1, &m_RendererID);
		glBindFramebuffer(GL_FRAMEBUFFER, m_RendererID);

		bool multisample = m_Specification.Samples > 1;

		// Attachments
		if (m_ColorAttachmentSpecifications.size())
		{
			m_ColorAttachments.resize(m_ColorAttachmentSpecifications.size());
			Utils::CreateTextures(multisample, m_ColorAttachments.data(), m_ColorAttachments.size());

			for (size_t i = 0; i < m_ColorAttachments.size(); i++)
			{
				Utils::BindTexture(multisample, m_ColorAttachments[i]);
				switch (m_ColorAttachmentSpecifications[i].TextureFormat)
				{
					case FramebufferTextureFormat::RGBA8:
						Utils::AttachColorTexture(m_ColorAttachments[i], m_Specification.Samples, GL_RGBA8, GL_RGBA, m_Specification.Width, m_Specification.Height, i);
						break;
					case FramebufferTextureFormat::RED_INTEGER:
						Utils::AttachColorTexture(m_ColorAttachments[i], m_Specification.Samples, GL_R32I, GL_RED_INTEGER, m_Specification.Width, m_Specification.Height, i);
						break;
				}
			}
		}

		if (m_DepthAttachmentSpecification.TextureFormat != FramebufferTextureFormat::None)
		{
			Utils::CreateTextures(multisample, &m_DepthAttachment, 1);
			Utils::BindTexture(multisample, m_DepthAttachment);
			switch (m_DepthAttachmentSpecification.TextureFormat)
			{
				case FramebufferTextureFormat::DEPTH24STENCIL8:
					Utils::AttachDepthTexture(m_DepthAttachment, m_Specification.Samples, GL_DEPTH24_STENCIL8, GL_DEPTH_STENCIL_ATTACHMENT, m_Specification.Width, m_Specification.Height);
					break;
			}
		}

		if (m_ColorAttachments.size() > 1)
		{
			HZ_CORE_ASSERT(m_ColorAttachments.size() <= 4);
			GLenum buffers[4] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 };
			glDrawBuffers(m_ColorAttachments.size(), buffers);
		}
		else if (m_ColorAttachments.empty())
		{
			// Only depth-pass
			glDrawBuffer(GL_NONE);
		}

		HZ_CORE_ASSERT(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE, "Framebuffer is incomplete!");

		glBindFramebuffer(GL_FRAMEBUFFER, 0);
	}

	void OpenGLFramebuffer::Bind()
	{
		glBindFramebuffer(GL_FRAMEBUFFER, m_RendererID);
		glViewport(0, 0, m_Specification.Width, m_Specification.Height);
	}

	void OpenGLFramebuffer::Unbind()
	{
		glBindFramebuffer(GL_FRAMEBUFFER, 0);
	}

	void OpenGLFramebuffer::Resize(uint32_t width, uint32_t height)
	{
		if (width == 0 || height == 0 || width > s_MaxFramebufferSize || height > s_MaxFramebufferSize)
		{
			HZ_CORE_WARN("Attempted to rezize framebuffer to {0}, {1}", width, height);
			return;
		}
		m_Specification.Width = width;
		m_Specification.Height = height;
		
		Invalidate();
	}

	int OpenGLFramebuffer::ReadPixel(uint32_t attachmentIndex, int x, int y)
	{
		HZ_CORE_ASSERT(attachmentIndex < m_ColorAttachments.size());

		glReadBuffer(GL_COLOR_ATTACHMENT0 + attachmentIndex);
		int pixelData;
		glReadPixels(x, y, 1, 1, GL_RED_INTEGER, GL_INT, &pixelData);
		return pixelData;

	}

	void OpenGLFramebuffer::ClearAttachment(uint32_t attachmentIndex, int value)
	{
		HZ_CORE_ASSERT(attachmentIndex < m_ColorAttachments.size());

		auto& spec = m_ColorAttachmentSpecifications[attachmentIndex];
		glClearTexImage(m_ColorAttachments[attachmentIndex], 0,
			Utils::HazelFBTextureFormatToGL(spec.TextureFormat), GL_INT, &value);
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLFramebuffer.h`:

```h
#pragma once

#include "Hazel/Renderer/Framebuffer.h"

namespace Hazel {

	class OpenGLFramebuffer : public Framebuffer
	{
	public:
		OpenGLFramebuffer(const FramebufferSpecification& spec);
		virtual ~OpenGLFramebuffer();

		void Invalidate();

		virtual void Bind() override;
		virtual void Unbind() override;

		virtual void Resize(uint32_t width, uint32_t height) override;
		virtual int ReadPixel(uint32_t attachmentIndex, int x, int y) override;

		virtual void ClearAttachment(uint32_t attachmentIndex, int value) override;

		virtual uint32_t GetColorAttachmentRendererID(uint32_t index = 0) const override { HZ_CORE_ASSERT(index < m_ColorAttachments.size()); return m_ColorAttachments[index]; }

		virtual const FramebufferSpecification& GetSpecification() const override { return m_Specification; }
	private:
		uint32_t m_RendererID = 0;
		FramebufferSpecification m_Specification;

		std::vector<FramebufferTextureSpecification> m_ColorAttachmentSpecifications;
		FramebufferTextureSpecification m_DepthAttachmentSpecification = FramebufferTextureFormat::None;

		std::vector<uint32_t> m_ColorAttachments;
		uint32_t m_DepthAttachment = 0;
	};

}

```

`Hazel/src/Platform/OpenGL/OpenGLRendererAPI.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLRendererAPI.h"

#include <glad/glad.h>

namespace Hazel {
	
	void OpenGLMessageCallback(
		unsigned source,
		unsigned type,
		unsigned id,
		unsigned severity,
		int length,
		const char* message,
		const void* userParam)
	{
		switch (severity)
		{
			case GL_DEBUG_SEVERITY_HIGH:         HZ_CORE_CRITICAL(message); return;
			case GL_DEBUG_SEVERITY_MEDIUM:       HZ_CORE_ERROR(message); return;
			case GL_DEBUG_SEVERITY_LOW:          HZ_CORE_WARN(message); return;
			case GL_DEBUG_SEVERITY_NOTIFICATION: HZ_CORE_TRACE(message); return;
		}
		
		HZ_CORE_ASSERT(false, "Unknown severity level!");
	}

	void OpenGLRendererAPI::Init()
	{
		HZ_PROFILE_FUNCTION();

	#ifdef HZ_DEBUG
		glEnable(GL_DEBUG_OUTPUT);
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glDebugMessageCallback(OpenGLMessageCallback, nullptr);
		
		glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_NOTIFICATION, 0, NULL, GL_FALSE);
	#endif

		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

		glEnable(GL_DEPTH_TEST);
		glEnable(GL_LINE_SMOOTH);
	}

	void OpenGLRendererAPI::SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
	{
		glViewport(x, y, width, height);
	}

	void OpenGLRendererAPI::SetClearColor(const glm::vec4& color)
	{
		glClearColor(color.r, color.g, color.b, color.a);
	}

	void OpenGLRendererAPI::Clear()
	{
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	}

	void OpenGLRendererAPI::DrawIndexed(const Ref<VertexArray>& vertexArray, uint32_t indexCount)
	{
		vertexArray->Bind();
		uint32_t count = indexCount ? indexCount : vertexArray->GetIndexBuffer()->GetCount();
		glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_INT, nullptr);
	}

	void OpenGLRendererAPI::DrawLines(const Ref<VertexArray>& vertexArray, uint32_t vertexCount)
	{
		vertexArray->Bind();
		glDrawArrays(GL_LINES, 0, vertexCount);
	}

	void OpenGLRendererAPI::SetLineWidth(float width)
	{
		glLineWidth(width);
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLRendererAPI.h`:

```h
#pragma once

#include "Hazel/Renderer/RendererAPI.h"

namespace Hazel {

	class OpenGLRendererAPI : public RendererAPI
	{
	public:
		virtual void Init() override;
		virtual void SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height) override;

		virtual void SetClearColor(const glm::vec4& color) override;
		virtual void Clear() override;

		virtual void DrawIndexed(const Ref<VertexArray>& vertexArray, uint32_t indexCount = 0) override;
		virtual void DrawLines(const Ref<VertexArray>& vertexArray, uint32_t vertexCount) override;
		
		virtual void SetLineWidth(float width) override;
	};


}

```

`Hazel/src/Platform/OpenGL/OpenGLShader.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLShader.h"
#include "Hazel/Core/Timer.h"

#include <fstream>
#include <glad/glad.h>

#include <glm/gtc/type_ptr.hpp>

#include <shaderc/shaderc.hpp>
#include <spirv_cross/spirv_cross.hpp>
#include <spirv_cross/spirv_glsl.hpp>

namespace Hazel {

	namespace Utils {

		static GLenum ShaderTypeFromString(const std::string& type)
		{
			if (type == "vertex")
				return GL_VERTEX_SHADER;
			if (type == "fragment" || type == "pixel")
				return GL_FRAGMENT_SHADER;

			HZ_CORE_ASSERT(false, "Unknown shader type!");
			return 0;
		}

		static shaderc_shader_kind GLShaderStageToShaderC(GLenum stage)
		{
			switch (stage)
			{
				case GL_VERTEX_SHADER:   return shaderc_glsl_vertex_shader;
				case GL_FRAGMENT_SHADER: return shaderc_glsl_fragment_shader;
			}
			HZ_CORE_ASSERT(false);
			return (shaderc_shader_kind)0;
		}

		static const char* GLShaderStageToString(GLenum stage)
		{
			switch (stage)
			{
				case GL_VERTEX_SHADER:   return "GL_VERTEX_SHADER";
				case GL_FRAGMENT_SHADER: return "GL_FRAGMENT_SHADER";
			}
			HZ_CORE_ASSERT(false);
			return nullptr;
		}

		static const char* GetCacheDirectory()
		{
			// TODO: make sure the assets directory is valid
			return "assets/cache/shader/opengl";
		}

		static void CreateCacheDirectoryIfNeeded()
		{
			std::string cacheDirectory = GetCacheDirectory();
			if (!std::filesystem::exists(cacheDirectory))
				std::filesystem::create_directories(cacheDirectory);
		}

		static const char* GLShaderStageCachedOpenGLFileExtension(uint32_t stage)
		{
			switch (stage)
			{
				case GL_VERTEX_SHADER:    return ".cached_opengl.vert";
				case GL_FRAGMENT_SHADER:  return ".cached_opengl.frag";
			}
			HZ_CORE_ASSERT(false);
			return "";
		}

		static const char* GLShaderStageCachedVulkanFileExtension(uint32_t stage)
		{
			switch (stage)
			{
			case GL_VERTEX_SHADER:    return ".cached_vulkan.vert";
			case GL_FRAGMENT_SHADER:  return ".cached_vulkan.frag";
			}
			HZ_CORE_ASSERT(false);
			return "";
		}


	}

	OpenGLShader::OpenGLShader(const std::string& filepath)
		: m_FilePath(filepath)
	{
		HZ_PROFILE_FUNCTION();

		Utils::CreateCacheDirectoryIfNeeded();

		std::string source = ReadFile(filepath);
		auto shaderSources = PreProcess(source);

		{
			Timer timer;
			CompileOrGetVulkanBinaries(shaderSources);
			CompileOrGetOpenGLBinaries();
			CreateProgram();
			HZ_CORE_WARN("Shader creation took {0} ms", timer.ElapsedMillis());
		}

		// Extract name from filepath
		auto lastSlash = filepath.find_last_of("/\\");
		lastSlash = lastSlash == std::string::npos ? 0 : lastSlash + 1;
		auto lastDot = filepath.rfind('.');
		auto count = lastDot == std::string::npos ? filepath.size() - lastSlash : lastDot - lastSlash;
		m_Name = filepath.substr(lastSlash, count);
	}

	OpenGLShader::OpenGLShader(const std::string& name, const std::string& vertexSrc, const std::string& fragmentSrc)
		: m_Name(name)
	{
		HZ_PROFILE_FUNCTION();

		std::unordered_map<GLenum, std::string> sources;
		sources[GL_VERTEX_SHADER] = vertexSrc;
		sources[GL_FRAGMENT_SHADER] = fragmentSrc;

		CompileOrGetVulkanBinaries(sources);
		CompileOrGetOpenGLBinaries();
		CreateProgram();
	}

	OpenGLShader::~OpenGLShader()
	{
		HZ_PROFILE_FUNCTION();

		glDeleteProgram(m_RendererID);
	}

	std::string OpenGLShader::ReadFile(const std::string& filepath)
	{
		HZ_PROFILE_FUNCTION();

		std::string result;
		std::ifstream in(filepath, std::ios::in | std::ios::binary); // ifstream closes itself due to RAII
		if (in)
		{
			in.seekg(0, std::ios::end);
			size_t size = in.tellg();
			if (size != -1)
			{
				result.resize(size);
				in.seekg(0, std::ios::beg);
				in.read(&result[0], size);
			}
			else
			{
				HZ_CORE_ERROR("Could not read from file '{0}'", filepath);
			}
		}
		else
		{
			HZ_CORE_ERROR("Could not open file '{0}'", filepath);
		}

		return result;
	}

	std::unordered_map<GLenum, std::string> OpenGLShader::PreProcess(const std::string& source)
	{
		HZ_PROFILE_FUNCTION();

		std::unordered_map<GLenum, std::string> shaderSources;

		const char* typeToken = "#type";
		size_t typeTokenLength = strlen(typeToken);
		size_t pos = source.find(typeToken, 0); //Start of shader type declaration line
		while (pos != std::string::npos)
		{
			size_t eol = source.find_first_of("\r\n", pos); //End of shader type declaration line
			HZ_CORE_ASSERT(eol != std::string::npos, "Syntax error");
			size_t begin = pos + typeTokenLength + 1; //Start of shader type name (after "#type " keyword)
			std::string type = source.substr(begin, eol - begin);
			HZ_CORE_ASSERT(Utils::ShaderTypeFromString(type), "Invalid shader type specified");

			size_t nextLinePos = source.find_first_not_of("\r\n", eol); //Start of shader code after shader type declaration line
			HZ_CORE_ASSERT(nextLinePos != std::string::npos, "Syntax error");
			pos = source.find(typeToken, nextLinePos); //Start of next shader type declaration line

			shaderSources[Utils::ShaderTypeFromString(type)] = (pos == std::string::npos) ? source.substr(nextLinePos) : source.substr(nextLinePos, pos - nextLinePos);
		}

		return shaderSources;
	}

	void OpenGLShader::CompileOrGetVulkanBinaries(const std::unordered_map<GLenum, std::string>& shaderSources)
	{
		GLuint program = glCreateProgram();

		shaderc::Compiler compiler;
		shaderc::CompileOptions options;
		options.SetTargetEnvironment(shaderc_target_env_vulkan, shaderc_env_version_vulkan_1_2);
		const bool optimize = true;
		if (optimize)
			options.SetOptimizationLevel(shaderc_optimization_level_performance);

		std::filesystem::path cacheDirectory = Utils::GetCacheDirectory();

		auto& shaderData = m_VulkanSPIRV;
		shaderData.clear();
		for (auto&& [stage, source] : shaderSources)
		{
			std::filesystem::path shaderFilePath = m_FilePath;
			std::filesystem::path cachedPath = cacheDirectory / (shaderFilePath.filename().string() + Utils::GLShaderStageCachedVulkanFileExtension(stage));

			std::ifstream in(cachedPath, std::ios::in | std::ios::binary);
			if (in.is_open())
			{
				in.seekg(0, std::ios::end);
				auto size = in.tellg();
				in.seekg(0, std::ios::beg);

				auto& data = shaderData[stage];
				data.resize(size / sizeof(uint32_t));
				in.read((char*)data.data(), size);
			}
			else
			{
				shaderc::SpvCompilationResult module = compiler.CompileGlslToSpv(source, Utils::GLShaderStageToShaderC(stage), m_FilePath.c_str(), options);
				if (module.GetCompilationStatus() != shaderc_compilation_status_success)
				{
					HZ_CORE_ERROR(module.GetErrorMessage());
					HZ_CORE_ASSERT(false);
				}

				shaderData[stage] = std::vector<uint32_t>(module.cbegin(), module.cend());

				std::ofstream out(cachedPath, std::ios::out | std::ios::binary);
				if (out.is_open())
				{
					auto& data = shaderData[stage];
					out.write((char*)data.data(), data.size() * sizeof(uint32_t));
					out.flush();
					out.close();
				}
			}
		}

		for (auto&& [stage, data]: shaderData)
			Reflect(stage, data);
	}

	void OpenGLShader::CompileOrGetOpenGLBinaries()
	{
		auto& shaderData = m_OpenGLSPIRV;

		shaderc::Compiler compiler;
		shaderc::CompileOptions options;
		options.SetTargetEnvironment(shaderc_target_env_opengl, shaderc_env_version_opengl_4_5);
		const bool optimize = false;
		if (optimize)
			options.SetOptimizationLevel(shaderc_optimization_level_performance);

		std::filesystem::path cacheDirectory = Utils::GetCacheDirectory();

		shaderData.clear();
		m_OpenGLSourceCode.clear();
		for (auto&& [stage, spirv] : m_VulkanSPIRV)
		{
			std::filesystem::path shaderFilePath = m_FilePath;
			std::filesystem::path cachedPath = cacheDirectory / (shaderFilePath.filename().string() + Utils::GLShaderStageCachedOpenGLFileExtension(stage));

			std::ifstream in(cachedPath, std::ios::in | std::ios::binary);
			if (in.is_open())
			{
				in.seekg(0, std::ios::end);
				auto size = in.tellg();
				in.seekg(0, std::ios::beg);

				auto& data = shaderData[stage];
				data.resize(size / sizeof(uint32_t));
				in.read((char*)data.data(), size);
			}
			else
			{
				spirv_cross::CompilerGLSL glslCompiler(spirv);
				m_OpenGLSourceCode[stage] = glslCompiler.compile();
				auto& source = m_OpenGLSourceCode[stage];

				shaderc::SpvCompilationResult module = compiler.CompileGlslToSpv(source, Utils::GLShaderStageToShaderC(stage), m_FilePath.c_str());
				if (module.GetCompilationStatus() != shaderc_compilation_status_success)
				{
					HZ_CORE_ERROR(module.GetErrorMessage());
					HZ_CORE_ASSERT(false);
				}

				shaderData[stage] = std::vector<uint32_t>(module.cbegin(), module.cend());

				std::ofstream out(cachedPath, std::ios::out | std::ios::binary);
				if (out.is_open())
				{
					auto& data = shaderData[stage];
					out.write((char*)data.data(), data.size() * sizeof(uint32_t));
					out.flush();
					out.close();
				}
			}
		}
	}

	void OpenGLShader::CreateProgram()
	{
		GLuint program = glCreateProgram();

		std::vector<GLuint> shaderIDs;
		for (auto&& [stage, spirv] : m_OpenGLSPIRV)
		{
			GLuint shaderID = shaderIDs.emplace_back(glCreateShader(stage));
			glShaderBinary(1, &shaderID, GL_SHADER_BINARY_FORMAT_SPIR_V, spirv.data(), spirv.size() * sizeof(uint32_t));
			glSpecializeShader(shaderID, "main", 0, nullptr, nullptr);
			glAttachShader(program, shaderID);
		}

		glLinkProgram(program);

		GLint isLinked;
		glGetProgramiv(program, GL_LINK_STATUS, &isLinked);
		if (isLinked == GL_FALSE)
		{
			GLint maxLength;
			glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);

			std::vector<GLchar> infoLog(maxLength);
			glGetProgramInfoLog(program, maxLength, &maxLength, infoLog.data());
			HZ_CORE_ERROR("Shader linking failed ({0}):\n{1}", m_FilePath, infoLog.data());

			glDeleteProgram(program);

			for (auto id : shaderIDs)
				glDeleteShader(id);
		}

		for (auto id : shaderIDs)
		{
			glDetachShader(program, id);
			glDeleteShader(id);
		}

		m_RendererID = program;
	}

	void OpenGLShader::Reflect(GLenum stage, const std::vector<uint32_t>& shaderData)
	{
		spirv_cross::Compiler compiler(shaderData);
		spirv_cross::ShaderResources resources = compiler.get_shader_resources();

		HZ_CORE_TRACE("OpenGLShader::Reflect - {0} {1}", Utils::GLShaderStageToString(stage), m_FilePath);
		HZ_CORE_TRACE("    {0} uniform buffers", resources.uniform_buffers.size());
		HZ_CORE_TRACE("    {0} resources", resources.sampled_images.size());

		HZ_CORE_TRACE("Uniform buffers:");
		for (const auto& resource : resources.uniform_buffers)
		{
			const auto& bufferType = compiler.get_type(resource.base_type_id);
			uint32_t bufferSize = compiler.get_declared_struct_size(bufferType);
			uint32_t binding = compiler.get_decoration(resource.id, spv::DecorationBinding);
			int memberCount = bufferType.member_types.size();

			HZ_CORE_TRACE("  {0}", resource.name);
			HZ_CORE_TRACE("    Size = {0}", bufferSize);
			HZ_CORE_TRACE("    Binding = {0}", binding);
			HZ_CORE_TRACE("    Members = {0}", memberCount);
		}
	}

	void OpenGLShader::Bind() const
	{
		HZ_PROFILE_FUNCTION();

		glUseProgram(m_RendererID);
	}

	void OpenGLShader::Unbind() const
	{
		HZ_PROFILE_FUNCTION();

		glUseProgram(0);
	}

	void OpenGLShader::SetInt(const std::string& name, int value)
	{
		HZ_PROFILE_FUNCTION();

		UploadUniformInt(name, value);
	}

	void OpenGLShader::SetIntArray(const std::string& name, int* values, uint32_t count)
	{
		UploadUniformIntArray(name, values, count);
	}

	void OpenGLShader::SetFloat(const std::string& name, float value)
	{
		HZ_PROFILE_FUNCTION();

		UploadUniformFloat(name, value);
	}

	void OpenGLShader::SetFloat2(const std::string& name, const glm::vec2& value)
	{
		HZ_PROFILE_FUNCTION();

		UploadUniformFloat2(name, value);
	}

	void OpenGLShader::SetFloat3(const std::string& name, const glm::vec3& value)
	{
		HZ_PROFILE_FUNCTION();

		UploadUniformFloat3(name, value);
	}

	void OpenGLShader::SetFloat4(const std::string& name, const glm::vec4& value)
	{
		HZ_PROFILE_FUNCTION();

		UploadUniformFloat4(name, value);
	}

	void OpenGLShader::SetMat4(const std::string& name, const glm::mat4& value)
	{
		HZ_PROFILE_FUNCTION();

		UploadUniformMat4(name, value);
	}

	void OpenGLShader::UploadUniformInt(const std::string& name, int value)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniform1i(location, value);
	}

	void OpenGLShader::UploadUniformIntArray(const std::string& name, int* values, uint32_t count)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniform1iv(location, count, values);
	}

	void OpenGLShader::UploadUniformFloat(const std::string& name, float value)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniform1f(location, value);
	}

	void OpenGLShader::UploadUniformFloat2(const std::string& name, const glm::vec2& value)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniform2f(location, value.x, value.y);
	}

	void OpenGLShader::UploadUniformFloat3(const std::string& name, const glm::vec3& value)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniform3f(location, value.x, value.y, value.z);
	}

	void OpenGLShader::UploadUniformFloat4(const std::string& name, const glm::vec4& value)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniform4f(location, value.x, value.y, value.z, value.w);
	}

	void OpenGLShader::UploadUniformMat3(const std::string& name, const glm::mat3& matrix)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniformMatrix3fv(location, 1, GL_FALSE, glm::value_ptr(matrix));
	}

	void OpenGLShader::UploadUniformMat4(const std::string& name, const glm::mat4& matrix)
	{
		GLint location = glGetUniformLocation(m_RendererID, name.c_str());
		glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(matrix));
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLShader.h`:

```h
#pragma once

#include "Hazel/Renderer/Shader.h"
#include <glm/glm.hpp>

// TODO: REMOVE!
typedef unsigned int GLenum;

namespace Hazel {

	class OpenGLShader : public Shader
	{
	public:
		OpenGLShader(const std::string& filepath);
		OpenGLShader(const std::string& name, const std::string& vertexSrc, const std::string& fragmentSrc);
		virtual ~OpenGLShader();

		virtual void Bind() const override;
		virtual void Unbind() const override;

		virtual void SetInt(const std::string& name, int value) override;
		virtual void SetIntArray(const std::string& name, int* values, uint32_t count) override;
		virtual void SetFloat(const std::string& name, float value) override;
		virtual void SetFloat2(const std::string& name, const glm::vec2& value) override;
		virtual void SetFloat3(const std::string& name, const glm::vec3& value) override;
		virtual void SetFloat4(const std::string& name, const glm::vec4& value) override;
		virtual void SetMat4(const std::string& name, const glm::mat4& value) override;

		virtual const std::string& GetName() const override { return m_Name; }

		void UploadUniformInt(const std::string& name, int value);
		void UploadUniformIntArray(const std::string& name, int* values, uint32_t count);

		void UploadUniformFloat(const std::string& name, float value);
		void UploadUniformFloat2(const std::string& name, const glm::vec2& value);
		void UploadUniformFloat3(const std::string& name, const glm::vec3& value);
		void UploadUniformFloat4(const std::string& name, const glm::vec4& value);

		void UploadUniformMat3(const std::string& name, const glm::mat3& matrix);
		void UploadUniformMat4(const std::string& name, const glm::mat4& matrix);
	private:
		std::string ReadFile(const std::string& filepath);
		std::unordered_map<GLenum, std::string> PreProcess(const std::string& source);

		void CompileOrGetVulkanBinaries(const std::unordered_map<GLenum, std::string>& shaderSources);
		void CompileOrGetOpenGLBinaries();
		void CreateProgram();
		void Reflect(GLenum stage, const std::vector<uint32_t>& shaderData);
	private:
		uint32_t m_RendererID;
		std::string m_FilePath;
		std::string m_Name;

		std::unordered_map<GLenum, std::vector<uint32_t>> m_VulkanSPIRV;
		std::unordered_map<GLenum, std::vector<uint32_t>> m_OpenGLSPIRV;

		std::unordered_map<GLenum, std::string> m_OpenGLSourceCode;
	};

}

```

`Hazel/src/Platform/OpenGL/OpenGLTexture.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLTexture.h"

#include <stb_image.h>

namespace Hazel {

	namespace Utils {

		static GLenum HazelImageFormatToGLDataFormat(ImageFormat format)
		{
			switch (format)
			{
				case ImageFormat::RGB8:  return GL_RGB;
				case ImageFormat::RGBA8: return GL_RGBA;
			}

			HZ_CORE_ASSERT(false);
			return 0;
		}
		
		static GLenum HazelImageFormatToGLInternalFormat(ImageFormat format)
		{
			switch (format)
			{
			case ImageFormat::RGB8:  return GL_RGB8;
			case ImageFormat::RGBA8: return GL_RGBA8;
			}

			HZ_CORE_ASSERT(false);
			return 0;
		}

	}

	OpenGLTexture2D::OpenGLTexture2D(const TextureSpecification& specification)
		: m_Specification(specification), m_Width(m_Specification.Width), m_Height(m_Specification.Height)
	{
		HZ_PROFILE_FUNCTION();

		m_InternalFormat = Utils::HazelImageFormatToGLInternalFormat(m_Specification.Format);
		m_DataFormat = Utils::HazelImageFormatToGLDataFormat(m_Specification.Format);

		glCreateTextures(GL_TEXTURE_2D, 1, &m_RendererID);
		glTextureStorage2D(m_RendererID, 1, m_InternalFormat, m_Width, m_Height);

		glTextureParameteri(m_RendererID, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTextureParameteri(m_RendererID, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		glTextureParameteri(m_RendererID, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTextureParameteri(m_RendererID, GL_TEXTURE_WRAP_T, GL_REPEAT);
	}

	OpenGLTexture2D::OpenGLTexture2D(const std::string& path)
		: m_Path(path)
	{
		HZ_PROFILE_FUNCTION();

		int width, height, channels;
		stbi_set_flip_vertically_on_load(1);
		stbi_uc* data = nullptr;
		{
			HZ_PROFILE_SCOPE("stbi_load - OpenGLTexture2D::OpenGLTexture2D(const std::string&)");
			data = stbi_load(path.c_str(), &width, &height, &channels, 0);
		}
			
		if (data)
		{
			m_IsLoaded = true;

			m_Width = width;
			m_Height = height;

			GLenum internalFormat = 0, dataFormat = 0;
			if (channels == 4)
			{
				internalFormat = GL_RGBA8;
				dataFormat = GL_RGBA;
			}
			else if (channels == 3)
			{
				internalFormat = GL_RGB8;
				dataFormat = GL_RGB;
			}

			m_InternalFormat = internalFormat;
			m_DataFormat = dataFormat;

			HZ_CORE_ASSERT(internalFormat & dataFormat, "Format not supported!");

			glCreateTextures(GL_TEXTURE_2D, 1, &m_RendererID);
			glTextureStorage2D(m_RendererID, 1, internalFormat, m_Width, m_Height);

			glTextureParameteri(m_RendererID, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			glTextureParameteri(m_RendererID, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

			glTextureParameteri(m_RendererID, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTextureParameteri(m_RendererID, GL_TEXTURE_WRAP_T, GL_REPEAT);

			glTextureSubImage2D(m_RendererID, 0, 0, 0, m_Width, m_Height, dataFormat, GL_UNSIGNED_BYTE, data);

			stbi_image_free(data);
		}
	}

	OpenGLTexture2D::~OpenGLTexture2D()
	{
		HZ_PROFILE_FUNCTION();

		glDeleteTextures(1, &m_RendererID);
	}

	void OpenGLTexture2D::SetData(void* data, uint32_t size)
	{
		HZ_PROFILE_FUNCTION();

		uint32_t bpp = m_DataFormat == GL_RGBA ? 4 : 3;
		HZ_CORE_ASSERT(size == m_Width * m_Height * bpp, "Data must be entire texture!");
		glTextureSubImage2D(m_RendererID, 0, 0, 0, m_Width, m_Height, m_DataFormat, GL_UNSIGNED_BYTE, data);
	}

	void OpenGLTexture2D::Bind(uint32_t slot) const
	{
		HZ_PROFILE_FUNCTION();

		glBindTextureUnit(slot, m_RendererID);
	}
}

```

`Hazel/src/Platform/OpenGL/OpenGLTexture.h`:

```h
#pragma once

#include "Hazel/Renderer/Texture.h"

#include <glad/glad.h>

namespace Hazel {

	class OpenGLTexture2D : public Texture2D
	{
	public:
		OpenGLTexture2D(const TextureSpecification& specification);
		OpenGLTexture2D(const std::string& path);
		virtual ~OpenGLTexture2D();

		virtual const TextureSpecification& GetSpecification() const override { return m_Specification; }

		virtual uint32_t GetWidth() const override { return m_Width;  }
		virtual uint32_t GetHeight() const override { return m_Height; }
		virtual uint32_t GetRendererID() const override { return m_RendererID; }

		virtual const std::string& GetPath() const override { return m_Path; }
		
		virtual void SetData(void* data, uint32_t size) override;

		virtual void Bind(uint32_t slot = 0) const override;

		virtual bool IsLoaded() const override { return m_IsLoaded; }

		virtual bool operator==(const Texture& other) const override
		{
			return m_RendererID == other.GetRendererID();
		}
	private:
		TextureSpecification m_Specification;

		std::string m_Path;
		bool m_IsLoaded = false;
		uint32_t m_Width, m_Height;
		uint32_t m_RendererID;
		GLenum m_InternalFormat, m_DataFormat;
	};

}

```

`Hazel/src/Platform/OpenGL/OpenGLUniformBuffer.cpp`:

```cpp
#include "hzpch.h"
#include "OpenGLUniformBuffer.h"

#include <glad/glad.h>

namespace Hazel {

	OpenGLUniformBuffer::OpenGLUniformBuffer(uint32_t size, uint32_t binding)
	{
		glCreateBuffers(1, &m_RendererID);
		glNamedBufferData(m_RendererID, size, nullptr, GL_DYNAMIC_DRAW); // TODO: investigate usage hint
		glBindBufferBase(GL_UNIFORM_BUFFER, binding, m_RendererID);
	}

	OpenGLUniformBuffer::~OpenGLUniformBuffer()
	{
		glDeleteBuffers(1, &m_RendererID);
	}


	void OpenGLUniformBuffer::SetData(const void* data, uint32_t size, uint32_t offset)
	{
		glNamedBufferSubData(m_RendererID, offset, size, data);
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLUniformBuffer.h`:

```h
#pragma once

#include "Hazel/Renderer/UniformBuffer.h"

namespace Hazel {

	class OpenGLUniformBuffer : public UniformBuffer
	{
	public:
		OpenGLUniformBuffer(uint32_t size, uint32_t binding);
		virtual ~OpenGLUniformBuffer();

		virtual void SetData(const void* data, uint32_t size, uint32_t offset = 0) override;
	private:
		uint32_t m_RendererID = 0;
	};
}

```

`Hazel/src/Platform/OpenGL/OpenGLVertexArray.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/OpenGL/OpenGLVertexArray.h"

#include <glad/glad.h>

namespace Hazel {

	static GLenum ShaderDataTypeToOpenGLBaseType(ShaderDataType type)
	{
		switch (type)
		{
			case ShaderDataType::Float:    return GL_FLOAT;
			case ShaderDataType::Float2:   return GL_FLOAT;
			case ShaderDataType::Float3:   return GL_FLOAT;
			case ShaderDataType::Float4:   return GL_FLOAT;
			case ShaderDataType::Mat3:     return GL_FLOAT;
			case ShaderDataType::Mat4:     return GL_FLOAT;
			case ShaderDataType::Int:      return GL_INT;
			case ShaderDataType::Int2:     return GL_INT;
			case ShaderDataType::Int3:     return GL_INT;
			case ShaderDataType::Int4:     return GL_INT;
			case ShaderDataType::Bool:     return GL_BOOL;
		}

		HZ_CORE_ASSERT(false, "Unknown ShaderDataType!");
		return 0;
	}

	OpenGLVertexArray::OpenGLVertexArray()
	{
		HZ_PROFILE_FUNCTION();

		glCreateVertexArrays(1, &m_RendererID);
	}

	OpenGLVertexArray::~OpenGLVertexArray()
	{
		HZ_PROFILE_FUNCTION();

		glDeleteVertexArrays(1, &m_RendererID);
	}

	void OpenGLVertexArray::Bind() const
	{
		HZ_PROFILE_FUNCTION();

		glBindVertexArray(m_RendererID);
	}

	void OpenGLVertexArray::Unbind() const
	{
		HZ_PROFILE_FUNCTION();

		glBindVertexArray(0);
	}

	void OpenGLVertexArray::AddVertexBuffer(const Ref<VertexBuffer>& vertexBuffer)
	{
		HZ_PROFILE_FUNCTION();

		HZ_CORE_ASSERT(vertexBuffer->GetLayout().GetElements().size(), "Vertex Buffer has no layout!");

		glBindVertexArray(m_RendererID);
		vertexBuffer->Bind();

		const auto& layout = vertexBuffer->GetLayout();
		for (const auto& element : layout)
		{
			switch (element.Type)
			{
				case ShaderDataType::Float:
				case ShaderDataType::Float2:
				case ShaderDataType::Float3:
				case ShaderDataType::Float4:
				{
					glEnableVertexAttribArray(m_VertexBufferIndex);
					glVertexAttribPointer(m_VertexBufferIndex,
						element.GetComponentCount(),
						ShaderDataTypeToOpenGLBaseType(element.Type),
						element.Normalized ? GL_TRUE : GL_FALSE,
						layout.GetStride(),
						(const void*)element.Offset);
					m_VertexBufferIndex++;
					break;
				}
				case ShaderDataType::Int:
				case ShaderDataType::Int2:
				case ShaderDataType::Int3:
				case ShaderDataType::Int4:
				case ShaderDataType::Bool:
				{
					glEnableVertexAttribArray(m_VertexBufferIndex);
					glVertexAttribIPointer(m_VertexBufferIndex,
						element.GetComponentCount(),
						ShaderDataTypeToOpenGLBaseType(element.Type),
						layout.GetStride(),
						(const void*)element.Offset);
					m_VertexBufferIndex++;
					break;
				}
				case ShaderDataType::Mat3:
				case ShaderDataType::Mat4:
				{
					uint8_t count = element.GetComponentCount();
					for (uint8_t i = 0; i < count; i++)
					{
						glEnableVertexAttribArray(m_VertexBufferIndex);
						glVertexAttribPointer(m_VertexBufferIndex,
							count,
							ShaderDataTypeToOpenGLBaseType(element.Type),
							element.Normalized ? GL_TRUE : GL_FALSE,
							layout.GetStride(),
							(const void*)(element.Offset + sizeof(float) * count * i));
						glVertexAttribDivisor(m_VertexBufferIndex, 1);
						m_VertexBufferIndex++;
					}
					break;
				}
				default:
					HZ_CORE_ASSERT(false, "Unknown ShaderDataType!");
			}
		}

		m_VertexBuffers.push_back(vertexBuffer);
	}

	void OpenGLVertexArray::SetIndexBuffer(const Ref<IndexBuffer>& indexBuffer)
	{
		HZ_PROFILE_FUNCTION();

		glBindVertexArray(m_RendererID);
		indexBuffer->Bind();

		m_IndexBuffer = indexBuffer;
	}

}

```

`Hazel/src/Platform/OpenGL/OpenGLVertexArray.h`:

```h
#pragma once

#include "Hazel/Renderer/VertexArray.h"

namespace Hazel {

	class OpenGLVertexArray : public VertexArray
	{
	public:
		OpenGLVertexArray();
		virtual ~OpenGLVertexArray();

		virtual void Bind() const override;
		virtual void Unbind() const override;

		virtual void AddVertexBuffer(const Ref<VertexBuffer>& vertexBuffer) override;
		virtual void SetIndexBuffer(const Ref<IndexBuffer>& indexBuffer) override;

		virtual const std::vector<Ref<VertexBuffer>>& GetVertexBuffers() const { return m_VertexBuffers; }
		virtual const Ref<IndexBuffer>& GetIndexBuffer() const { return m_IndexBuffer; }
	private:
		uint32_t m_RendererID;
		uint32_t m_VertexBufferIndex = 0;
		std::vector<Ref<VertexBuffer>> m_VertexBuffers;
		Ref<IndexBuffer> m_IndexBuffer;
	};

}

```

`Hazel/src/Platform/Windows/WindowsInput.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Core/Input.h"

#include "Hazel/Core/Application.h"
#include <GLFW/glfw3.h>

namespace Hazel {

	bool Input::IsKeyPressed(const KeyCode key)
	{
		auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetNativeWindow());
		auto state = glfwGetKey(window, static_cast<int32_t>(key));
		return state == GLFW_PRESS;
	}

	bool Input::IsMouseButtonPressed(const MouseCode button)
	{
		auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetNativeWindow());
		auto state = glfwGetMouseButton(window, static_cast<int32_t>(button));
		return state == GLFW_PRESS;
	}

	glm::vec2 Input::GetMousePosition()
	{
		auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetNativeWindow());
		double xpos, ypos;
		glfwGetCursorPos(window, &xpos, &ypos);

		return { (float)xpos, (float)ypos };
	}

	float Input::GetMouseX()
	{
		return GetMousePosition().x;
	}

	float Input::GetMouseY()
	{
		return GetMousePosition().y;
	}

}
```

`Hazel/src/Platform/Windows/WindowsPlatformUtils.cpp`:

```cpp
#include "hzpch.h"
#include "Hazel/Utils/PlatformUtils.h"
#include "Hazel/Core/Application.h"

#include <commdlg.h>
#include <GLFW/glfw3.h>
#define GLFW_EXPOSE_NATIVE_WIN32
#include <GLFW/glfw3native.h>

namespace Hazel {

	float Time::GetTime()
	{
		return glfwGetTime();
	}


	std::string FileDialogs::OpenFile(const char* filter)
	{
		OPENFILENAMEA ofn;
		CHAR szFile[260] = { 0 };
		CHAR currentDir[256] = { 0 };
		ZeroMemory(&ofn, sizeof(OPENFILENAME));
		ofn.lStructSize = sizeof(OPENFILENAME);
		ofn.hwndOwner = glfwGetWin32Window((GLFWwindow*)Application::Get().GetWindow().GetNativeWindow());
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = sizeof(szFile);
		if (GetCurrentDirectoryA(256, currentDir))
			ofn.lpstrInitialDir = currentDir;
		ofn.lpstrFilter = filter;
		ofn.nFilterIndex = 1;
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

		if (GetOpenFileNameA(&ofn) == TRUE)
			return ofn.lpstrFile;

		return std::string();

	}

	std::string FileDialogs::SaveFile(const char* filter)
	{
		OPENFILENAMEA ofn;
		CHAR szFile[260] = { 0 };
		CHAR currentDir[256] = { 0 };
		ZeroMemory(&ofn, sizeof(OPENFILENAME));
		ofn.lStructSize = sizeof(OPENFILENAME);
		ofn.hwndOwner = glfwGetWin32Window((GLFWwindow*)Application::Get().GetWindow().GetNativeWindow());
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = sizeof(szFile);
		if (GetCurrentDirectoryA(256, currentDir))
			ofn.lpstrInitialDir = currentDir;
		ofn.lpstrFilter = filter;
		ofn.nFilterIndex = 1;
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;

		// Sets the default extension by extracting it from the filter
		ofn.lpstrDefExt = strchr(filter, '\0') + 1;

		if (GetSaveFileNameA(&ofn) == TRUE)
			return ofn.lpstrFile;
		
		return std::string();
	}

}

```

`Hazel/src/Platform/Windows/WindowsWindow.cpp`:

```cpp
#include "hzpch.h"
#include "Platform/Windows/WindowsWindow.h"

#include "Hazel/Core/Input.h"

#include "Hazel/Events/ApplicationEvent.h"
#include "Hazel/Events/MouseEvent.h"
#include "Hazel/Events/KeyEvent.h"

#include "Hazel/Renderer/Renderer.h"

#include "Platform/OpenGL/OpenGLContext.h"

namespace Hazel {
	
	static uint8_t s_GLFWWindowCount = 0;

	static void GLFWErrorCallback(int error, const char* description)
	{
		HZ_CORE_ERROR("GLFW Error ({0}): {1}", error, description);
	}

	WindowsWindow::WindowsWindow(const WindowProps& props)
	{
		HZ_PROFILE_FUNCTION();

		Init(props);
	}

	WindowsWindow::~WindowsWindow()
	{
		HZ_PROFILE_FUNCTION();

		Shutdown();
	}

	void WindowsWindow::Init(const WindowProps& props)
	{
		HZ_PROFILE_FUNCTION();

		m_Data.Title = props.Title;
		m_Data.Width = props.Width;
		m_Data.Height = props.Height;

		HZ_CORE_INFO("Creating window {0} ({1}, {2})", props.Title, props.Width, props.Height);

		if (s_GLFWWindowCount == 0)
		{
			HZ_PROFILE_SCOPE("glfwInit");
			int success = glfwInit();
			HZ_CORE_ASSERT(success, "Could not initialize GLFW!");
			glfwSetErrorCallback(GLFWErrorCallback);
		}

		{
			HZ_PROFILE_SCOPE("glfwCreateWindow");
		#if defined(HZ_DEBUG)
			if (Renderer::GetAPI() == RendererAPI::API::OpenGL)
				glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);
		#endif
			m_Window = glfwCreateWindow((int)props.Width, (int)props.Height, m_Data.Title.c_str(), nullptr, nullptr);
			++s_GLFWWindowCount;
		}

		m_Context = GraphicsContext::Create(m_Window);
		m_Context->Init();

		glfwSetWindowUserPointer(m_Window, &m_Data);
		SetVSync(true);

		// Set GLFW callbacks
		glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);
			data.Width = width;
			data.Height = height;

			WindowResizeEvent event(width, height);
			data.EventCallback(event);
		});

		glfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);
			WindowCloseEvent event;
			data.EventCallback(event);
		});

		glfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			switch (action)
			{
				case GLFW_PRESS:
				{
					KeyPressedEvent event(key, 0);
					data.EventCallback(event);
					break;
				}
				case GLFW_RELEASE:
				{
					KeyReleasedEvent event(key);
					data.EventCallback(event);
					break;
				}
				case GLFW_REPEAT:
				{
					KeyPressedEvent event(key, true);
					data.EventCallback(event);
					break;
				}
			}
		});

		glfwSetCharCallback(m_Window, [](GLFWwindow* window, unsigned int keycode)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			KeyTypedEvent event(keycode);
			data.EventCallback(event);
		});

		glfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			switch (action)
			{
				case GLFW_PRESS:
				{
					MouseButtonPressedEvent event(button);
					data.EventCallback(event);
					break;
				}
				case GLFW_RELEASE:
				{
					MouseButtonReleasedEvent event(button);
					data.EventCallback(event);
					break;
				}
			}
		});

		glfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			MouseScrolledEvent event((float)xOffset, (float)yOffset);
			data.EventCallback(event);
		});

		glfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			MouseMovedEvent event((float)xPos, (float)yPos);
			data.EventCallback(event);
		});
	}

	void WindowsWindow::Shutdown()
	{
		HZ_PROFILE_FUNCTION();

		glfwDestroyWindow(m_Window);
		--s_GLFWWindowCount;

		if (s_GLFWWindowCount == 0)
		{
			glfwTerminate();
		}
	}

	void WindowsWindow::OnUpdate()
	{
		HZ_PROFILE_FUNCTION();

		glfwPollEvents();
		m_Context->SwapBuffers();
	}

	void WindowsWindow::SetVSync(bool enabled)
	{
		HZ_PROFILE_FUNCTION();

		if (enabled)
			glfwSwapInterval(1);
		else
			glfwSwapInterval(0);

		m_Data.VSync = enabled;
	}

	bool WindowsWindow::IsVSync() const
	{
		return m_Data.VSync;
	}

}

```

`Hazel/src/Platform/Windows/WindowsWindow.h`:

```h
#pragma once

#include "Hazel/Core/Window.h"
#include "Hazel/Renderer/GraphicsContext.h"

#include <GLFW/glfw3.h>

namespace Hazel {

	class WindowsWindow : public Window
	{
	public:
		WindowsWindow(const WindowProps& props);
		virtual ~WindowsWindow();

		void OnUpdate() override;

		unsigned int GetWidth() const override { return m_Data.Width; }
		unsigned int GetHeight() const override { return m_Data.Height; }

		// Window attributes
		void SetEventCallback(const EventCallbackFn& callback) override { m_Data.EventCallback = callback; }
		void SetVSync(bool enabled) override;
		bool IsVSync() const override;

		virtual void* GetNativeWindow() const { return m_Window; }
	private:
		virtual void Init(const WindowProps& props);
		virtual void Shutdown();
	private:
		GLFWwindow* m_Window;
		Scope<GraphicsContext> m_Context;

		struct WindowData
		{
			std::string Title;
			unsigned int Width, Height;
			bool VSync;

			EventCallbackFn EventCallback;
		};

		WindowData m_Data;
	};

}
```

`Hazel/src/hzpch.cpp`:

```cpp
#include "hzpch.h"
```

`Hazel/src/hzpch.h`:

```h
#pragma once

#include "Hazel/Core/PlatformDetection.h"

#ifdef HZ_PLATFORM_WINDOWS
	#ifndef NOMINMAX
		// See github.com/skypjack/entt/wiki/Frequently-Asked-Questions#warning-c4003-the-min-the-max-and-the-macro
		#define NOMINMAX
	#endif
#endif

#include <iostream>
#include <memory>
#include <utility>
#include <algorithm>
#include <functional>

#include <string>
#include <sstream>
#include <array>
#include <vector>
#include <unordered_map>
#include <unordered_set>

#include "Hazel/Core/Base.h"

#include "Hazel/Core/Log.h"

#include "Hazel/Debug/Instrumentor.h"

#ifdef HZ_PLATFORM_WINDOWS
	#include <Windows.h>
#endif

```

`Hazel/vendor/Glad/include/KHR/khrplatform.h`:

```h
#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2018 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
 *
 * The master copy of khrplatform.h is maintained in the Khronos EGL
 * Registry repository at https://github.com/KhronosGroup/EGL-Registry
 * The last semantic modification to khrplatform.h was at commit ID:
 *      67a3e0864c2d75ea5287b9f3d2eb74a745936692
 *
 * Adopters may modify this file to suit their platform. Adopters are
 * encouraged to submit platform specific modifications to the Khronos
 * group so that they can be included in future versions of this file.
 * Please submit changes by filing pull requests or issues on
 * the EGL Registry repository linked above.
 *
 *
 * See the Implementer's Guidelines for information about where this file
 * should be located on your system and for more details of its use:
 *    http://www.khronos.org/registry/implementers_guide.pdf
 *
 * This file should be included as
 *        #include <KHR/khrplatform.h>
 * by Khronos client API header files that use its types and defines.
 *
 * The types in khrplatform.h should only be used to define API-specific types.
 *
 * Types defined in khrplatform.h:
 *    khronos_int8_t              signed   8  bit
 *    khronos_uint8_t             unsigned 8  bit
 *    khronos_int16_t             signed   16 bit
 *    khronos_uint16_t            unsigned 16 bit
 *    khronos_int32_t             signed   32 bit
 *    khronos_uint32_t            unsigned 32 bit
 *    khronos_int64_t             signed   64 bit
 *    khronos_uint64_t            unsigned 64 bit
 *    khronos_intptr_t            signed   same number of bits as a pointer
 *    khronos_uintptr_t           unsigned same number of bits as a pointer
 *    khronos_ssize_t             signed   size
 *    khronos_usize_t             unsigned size
 *    khronos_float_t             signed   32 bit floating point
 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
 *                                         nanoseconds
 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
 *    khronos_boolean_enum_t      enumerated boolean type. This should
 *      only be used as a base type when a client API's boolean type is
 *      an enum. Client APIs which use an integer or other type for
 *      booleans cannot use this as the base type for their boolean.
 *
 * Tokens defined in khrplatform.h:
 *
 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
 *
 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
 *
 * Calling convention macros defined in this file:
 *    KHRONOS_APICALL
 *    KHRONOS_APIENTRY
 *    KHRONOS_APIATTRIBUTES
 *
 * These may be used in function prototypes as:
 *
 *      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
 *                                  int arg1,
 *                                  int arg2) KHRONOS_APIATTRIBUTES;
 */

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APICALL
 *-------------------------------------------------------------------------
 * This precedes the return type of the function in the function prototype.
 */
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIENTRY
 *-------------------------------------------------------------------------
 * This follows the return type of the function  and precedes the function
 * name in the function prototype.
 */
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
    /* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIATTRIBUTES
 *-------------------------------------------------------------------------
 * This follows the closing parenthesis of the function prototype arguments.
 */
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
 * basic type definitions
 *-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
 * Using <stdint.h>
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
 * Using <inttypes.h>
 */
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
 * Win32
 */
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
 * Sun or Digital
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
 * Hypothetical platform with no float or int64 support
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
 * Generic fallback
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
 * Types that are (so far) the same on all platforms
 */
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
 * Types that differ between LLP64 and LP64 architectures - in LLP64,
 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
 * to be the only LLP64 architecture in current use.
 */
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
 * Float type
 */
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
 *
 * These types can be used to represent a time interval in nanoseconds or
 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
 * of nanoseconds since some arbitrary system event (e.g. since the last
 * time the system booted).  The Unadjusted System Time is an unsigned
 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
 * may be either signed or unsigned.
 */
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
 * Dummy value used to pad enum types to 32 bits.
 */
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
 * Enumerated boolean type
 *
 * Values other than zero should be considered to be true.  Therefore
 * comparisons should not be made against KHRONOS_TRUE.
 */
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */

```

`Hazel/vendor/Glad/include/glad/glad.h`:

```h
/*

    OpenGL loader generated by glad 0.1.28 on Sat Jan  5 02:36:41 2019.

    Language/Generator: C/C++
    Specification: gl
    APIs: gl=4.6
    Profile: core
    Extensions:
        
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gl=4.6" --generator="c" --spec="gl" --extensions=""
    Online:
        https://glad.dav1d.de/#profile=core&language=c&specification=gl&loader=on&api=gl%3D4.6
*/


#ifndef __glad_h_
#define __glad_h_

#ifdef __gl_h_
#error OpenGL header already included, remove this include, glad already provides it
#endif
#define __gl_h_

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#ifndef NOMINMAX
#define NOMINMAX 1
#endif
#include <windows.h>
#endif

#ifndef APIENTRY
#define APIENTRY
#endif
#ifndef APIENTRYP
#define APIENTRYP APIENTRY *
#endif

#ifndef GLAPIENTRY
#define GLAPIENTRY APIENTRY
#endif

#ifdef __cplusplus
extern "C" {
#endif

struct gladGLversionStruct {
    int major;
    int minor;
};

typedef void* (* GLADloadproc)(const char *name);

#ifndef GLAPI
# if defined(GLAD_GLAPI_EXPORT)
#  if defined(_WIN32) || defined(__CYGWIN__)
#   if defined(GLAD_GLAPI_EXPORT_BUILD)
#    if defined(__GNUC__)
#     define GLAPI __attribute__ ((dllexport)) extern
#    else
#     define GLAPI __declspec(dllexport) extern
#    endif
#   else
#    if defined(__GNUC__)
#     define GLAPI __attribute__ ((dllimport)) extern
#    else
#     define GLAPI __declspec(dllimport) extern
#    endif
#   endif
#  elif defined(__GNUC__) && defined(GLAD_GLAPI_EXPORT_BUILD)
#   define GLAPI __attribute__ ((visibility ("default"))) extern
#  else
#   define GLAPI extern
#  endif
# else
#  define GLAPI extern
# endif
#endif

GLAPI struct gladGLversionStruct GLVersion;

GLAPI int gladLoadGL(void);

GLAPI int gladLoadGLLoader(GLADloadproc);

#include <KHR/khrplatform.h>
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;
#ifdef __APPLE__
typedef void *GLhandleARB;
#else
typedef unsigned int GLhandleARB;
#endif
typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;
typedef khronos_intptr_t GLintptr;
typedef khronos_intptr_t GLintptrARB;
typedef khronos_ssize_t GLsizeiptr;
typedef khronos_ssize_t GLsizeiptrARB;
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (APIENTRY *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (APIENTRY *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (APIENTRY *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (APIENTRY *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void (APIENTRY *GLVULKANPROCNV)(void);
#define GL_DEPTH_BUFFER_BIT 0x00000100
#define GL_STENCIL_BUFFER_BIT 0x00000400
#define GL_COLOR_BUFFER_BIT 0x00004000
#define GL_FALSE 0
#define GL_TRUE 1
#define GL_POINTS 0x0000
#define GL_LINES 0x0001
#define GL_LINE_LOOP 0x0002
#define GL_LINE_STRIP 0x0003
#define GL_TRIANGLES 0x0004
#define GL_TRIANGLE_STRIP 0x0005
#define GL_TRIANGLE_FAN 0x0006
#define GL_NEVER 0x0200
#define GL_LESS 0x0201
#define GL_EQUAL 0x0202
#define GL_LEQUAL 0x0203
#define GL_GREATER 0x0204
#define GL_NOTEQUAL 0x0205
#define GL_GEQUAL 0x0206
#define GL_ALWAYS 0x0207
#define GL_ZERO 0
#define GL_ONE 1
#define GL_SRC_COLOR 0x0300
#define GL_ONE_MINUS_SRC_COLOR 0x0301
#define GL_SRC_ALPHA 0x0302
#define GL_ONE_MINUS_SRC_ALPHA 0x0303
#define GL_DST_ALPHA 0x0304
#define GL_ONE_MINUS_DST_ALPHA 0x0305
#define GL_DST_COLOR 0x0306
#define GL_ONE_MINUS_DST_COLOR 0x0307
#define GL_SRC_ALPHA_SATURATE 0x0308
#define GL_NONE 0
#define GL_FRONT_LEFT 0x0400
#define GL_FRONT_RIGHT 0x0401
#define GL_BACK_LEFT 0x0402
#define GL_BACK_RIGHT 0x0403
#define GL_FRONT 0x0404
#define GL_BACK 0x0405
#define GL_LEFT 0x0406
#define GL_RIGHT 0x0407
#define GL_FRONT_AND_BACK 0x0408
#define GL_NO_ERROR 0
#define GL_INVALID_ENUM 0x0500
#define GL_INVALID_VALUE 0x0501
#define GL_INVALID_OPERATION 0x0502
#define GL_OUT_OF_MEMORY 0x0505
#define GL_CW 0x0900
#define GL_CCW 0x0901
#define GL_POINT_SIZE 0x0B11
#define GL_POINT_SIZE_RANGE 0x0B12
#define GL_POINT_SIZE_GRANULARITY 0x0B13
#define GL_LINE_SMOOTH 0x0B20
#define GL_LINE_WIDTH 0x0B21
#define GL_LINE_WIDTH_RANGE 0x0B22
#define GL_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_POLYGON_MODE 0x0B40
#define GL_POLYGON_SMOOTH 0x0B41
#define GL_CULL_FACE 0x0B44
#define GL_CULL_FACE_MODE 0x0B45
#define GL_FRONT_FACE 0x0B46
#define GL_DEPTH_RANGE 0x0B70
#define GL_DEPTH_TEST 0x0B71
#define GL_DEPTH_WRITEMASK 0x0B72
#define GL_DEPTH_CLEAR_VALUE 0x0B73
#define GL_DEPTH_FUNC 0x0B74
#define GL_STENCIL_TEST 0x0B90
#define GL_STENCIL_CLEAR_VALUE 0x0B91
#define GL_STENCIL_FUNC 0x0B92
#define GL_STENCIL_VALUE_MASK 0x0B93
#define GL_STENCIL_FAIL 0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
#define GL_STENCIL_REF 0x0B97
#define GL_STENCIL_WRITEMASK 0x0B98
#define GL_VIEWPORT 0x0BA2
#define GL_DITHER 0x0BD0
#define GL_BLEND_DST 0x0BE0
#define GL_BLEND_SRC 0x0BE1
#define GL_BLEND 0x0BE2
#define GL_LOGIC_OP_MODE 0x0BF0
#define GL_DRAW_BUFFER 0x0C01
#define GL_READ_BUFFER 0x0C02
#define GL_SCISSOR_BOX 0x0C10
#define GL_SCISSOR_TEST 0x0C11
#define GL_COLOR_CLEAR_VALUE 0x0C22
#define GL_COLOR_WRITEMASK 0x0C23
#define GL_DOUBLEBUFFER 0x0C32
#define GL_STEREO 0x0C33
#define GL_LINE_SMOOTH_HINT 0x0C52
#define GL_POLYGON_SMOOTH_HINT 0x0C53
#define GL_UNPACK_SWAP_BYTES 0x0CF0
#define GL_UNPACK_LSB_FIRST 0x0CF1
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_ALIGNMENT 0x0CF5
#define GL_PACK_SWAP_BYTES 0x0D00
#define GL_PACK_LSB_FIRST 0x0D01
#define GL_PACK_ROW_LENGTH 0x0D02
#define GL_PACK_SKIP_ROWS 0x0D03
#define GL_PACK_SKIP_PIXELS 0x0D04
#define GL_PACK_ALIGNMENT 0x0D05
#define GL_MAX_TEXTURE_SIZE 0x0D33
#define GL_MAX_VIEWPORT_DIMS 0x0D3A
#define GL_SUBPIXEL_BITS 0x0D50
#define GL_TEXTURE_1D 0x0DE0
#define GL_TEXTURE_2D 0x0DE1
#define GL_TEXTURE_WIDTH 0x1000
#define GL_TEXTURE_HEIGHT 0x1001
#define GL_TEXTURE_BORDER_COLOR 0x1004
#define GL_DONT_CARE 0x1100
#define GL_FASTEST 0x1101
#define GL_NICEST 0x1102
#define GL_BYTE 0x1400
#define GL_UNSIGNED_BYTE 0x1401
#define GL_SHORT 0x1402
#define GL_UNSIGNED_SHORT 0x1403
#define GL_INT 0x1404
#define GL_UNSIGNED_INT 0x1405
#define GL_FLOAT 0x1406
#define GL_CLEAR 0x1500
#define GL_AND 0x1501
#define GL_AND_REVERSE 0x1502
#define GL_COPY 0x1503
#define GL_AND_INVERTED 0x1504
#define GL_NOOP 0x1505
#define GL_XOR 0x1506
#define GL_OR 0x1507
#define GL_NOR 0x1508
#define GL_EQUIV 0x1509
#define GL_INVERT 0x150A
#define GL_OR_REVERSE 0x150B
#define GL_COPY_INVERTED 0x150C
#define GL_OR_INVERTED 0x150D
#define GL_NAND 0x150E
#define GL_SET 0x150F
#define GL_TEXTURE 0x1702
#define GL_COLOR 0x1800
#define GL_DEPTH 0x1801
#define GL_STENCIL 0x1802
#define GL_STENCIL_INDEX 0x1901
#define GL_DEPTH_COMPONENT 0x1902
#define GL_RED 0x1903
#define GL_GREEN 0x1904
#define GL_BLUE 0x1905
#define GL_ALPHA 0x1906
#define GL_RGB 0x1907
#define GL_RGBA 0x1908
#define GL_POINT 0x1B00
#define GL_LINE 0x1B01
#define GL_FILL 0x1B02
#define GL_KEEP 0x1E00
#define GL_REPLACE 0x1E01
#define GL_INCR 0x1E02
#define GL_DECR 0x1E03
#define GL_VENDOR 0x1F00
#define GL_RENDERER 0x1F01
#define GL_VERSION 0x1F02
#define GL_EXTENSIONS 0x1F03
#define GL_NEAREST 0x2600
#define GL_LINEAR 0x2601
#define GL_NEAREST_MIPMAP_NEAREST 0x2700
#define GL_LINEAR_MIPMAP_NEAREST 0x2701
#define GL_NEAREST_MIPMAP_LINEAR 0x2702
#define GL_LINEAR_MIPMAP_LINEAR 0x2703
#define GL_TEXTURE_MAG_FILTER 0x2800
#define GL_TEXTURE_MIN_FILTER 0x2801
#define GL_TEXTURE_WRAP_S 0x2802
#define GL_TEXTURE_WRAP_T 0x2803
#define GL_REPEAT 0x2901
#define GL_COLOR_LOGIC_OP 0x0BF2
#define GL_POLYGON_OFFSET_UNITS 0x2A00
#define GL_POLYGON_OFFSET_POINT 0x2A01
#define GL_POLYGON_OFFSET_LINE 0x2A02
#define GL_POLYGON_OFFSET_FILL 0x8037
#define GL_POLYGON_OFFSET_FACTOR 0x8038
#define GL_TEXTURE_BINDING_1D 0x8068
#define GL_TEXTURE_BINDING_2D 0x8069
#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
#define GL_TEXTURE_RED_SIZE 0x805C
#define GL_TEXTURE_GREEN_SIZE 0x805D
#define GL_TEXTURE_BLUE_SIZE 0x805E
#define GL_TEXTURE_ALPHA_SIZE 0x805F
#define GL_DOUBLE 0x140A
#define GL_PROXY_TEXTURE_1D 0x8063
#define GL_PROXY_TEXTURE_2D 0x8064
#define GL_R3_G3_B2 0x2A10
#define GL_RGB4 0x804F
#define GL_RGB5 0x8050
#define GL_RGB8 0x8051
#define GL_RGB10 0x8052
#define GL_RGB12 0x8053
#define GL_RGB16 0x8054
#define GL_RGBA2 0x8055
#define GL_RGBA4 0x8056
#define GL_RGB5_A1 0x8057
#define GL_RGBA8 0x8058
#define GL_RGB10_A2 0x8059
#define GL_RGBA12 0x805A
#define GL_RGBA16 0x805B
#define GL_UNSIGNED_BYTE_3_3_2 0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
#define GL_UNSIGNED_INT_8_8_8_8 0x8035
#define GL_UNSIGNED_INT_10_10_10_2 0x8036
#define GL_TEXTURE_BINDING_3D 0x806A
#define GL_PACK_SKIP_IMAGES 0x806B
#define GL_PACK_IMAGE_HEIGHT 0x806C
#define GL_UNPACK_SKIP_IMAGES 0x806D
#define GL_UNPACK_IMAGE_HEIGHT 0x806E
#define GL_TEXTURE_3D 0x806F
#define GL_PROXY_TEXTURE_3D 0x8070
#define GL_TEXTURE_DEPTH 0x8071
#define GL_TEXTURE_WRAP_R 0x8072
#define GL_MAX_3D_TEXTURE_SIZE 0x8073
#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
#define GL_UNSIGNED_SHORT_5_6_5 0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
#define GL_BGR 0x80E0
#define GL_BGRA 0x80E1
#define GL_MAX_ELEMENTS_VERTICES 0x80E8
#define GL_MAX_ELEMENTS_INDICES 0x80E9
#define GL_CLAMP_TO_EDGE 0x812F
#define GL_TEXTURE_MIN_LOD 0x813A
#define GL_TEXTURE_MAX_LOD 0x813B
#define GL_TEXTURE_BASE_LEVEL 0x813C
#define GL_TEXTURE_MAX_LEVEL 0x813D
#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
#define GL_TEXTURE0 0x84C0
#define GL_TEXTURE1 0x84C1
#define GL_TEXTURE2 0x84C2
#define GL_TEXTURE3 0x84C3
#define GL_TEXTURE4 0x84C4
#define GL_TEXTURE5 0x84C5
#define GL_TEXTURE6 0x84C6
#define GL_TEXTURE7 0x84C7
#define GL_TEXTURE8 0x84C8
#define GL_TEXTURE9 0x84C9
#define GL_TEXTURE10 0x84CA
#define GL_TEXTURE11 0x84CB
#define GL_TEXTURE12 0x84CC
#define GL_TEXTURE13 0x84CD
#define GL_TEXTURE14 0x84CE
#define GL_TEXTURE15 0x84CF
#define GL_TEXTURE16 0x84D0
#define GL_TEXTURE17 0x84D1
#define GL_TEXTURE18 0x84D2
#define GL_TEXTURE19 0x84D3
#define GL_TEXTURE20 0x84D4
#define GL_TEXTURE21 0x84D5
#define GL_TEXTURE22 0x84D6
#define GL_TEXTURE23 0x84D7
#define GL_TEXTURE24 0x84D8
#define GL_TEXTURE25 0x84D9
#define GL_TEXTURE26 0x84DA
#define GL_TEXTURE27 0x84DB
#define GL_TEXTURE28 0x84DC
#define GL_TEXTURE29 0x84DD
#define GL_TEXTURE30 0x84DE
#define GL_TEXTURE31 0x84DF
#define GL_ACTIVE_TEXTURE 0x84E0
#define GL_MULTISAMPLE 0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
#define GL_SAMPLE_COVERAGE 0x80A0
#define GL_SAMPLE_BUFFERS 0x80A8
#define GL_SAMPLES 0x80A9
#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
#define GL_TEXTURE_CUBE_MAP 0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
#define GL_COMPRESSED_RGB 0x84ED
#define GL_COMPRESSED_RGBA 0x84EE
#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
#define GL_TEXTURE_COMPRESSED 0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
#define GL_CLAMP_TO_BORDER 0x812D
#define GL_BLEND_DST_RGB 0x80C8
#define GL_BLEND_SRC_RGB 0x80C9
#define GL_BLEND_DST_ALPHA 0x80CA
#define GL_BLEND_SRC_ALPHA 0x80CB
#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
#define GL_DEPTH_COMPONENT16 0x81A5
#define GL_DEPTH_COMPONENT24 0x81A6
#define GL_DEPTH_COMPONENT32 0x81A7
#define GL_MIRRORED_REPEAT 0x8370
#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
#define GL_TEXTURE_LOD_BIAS 0x8501
#define GL_INCR_WRAP 0x8507
#define GL_DECR_WRAP 0x8508
#define GL_TEXTURE_DEPTH_SIZE 0x884A
#define GL_TEXTURE_COMPARE_MODE 0x884C
#define GL_TEXTURE_COMPARE_FUNC 0x884D
#define GL_BLEND_COLOR 0x8005
#define GL_BLEND_EQUATION 0x8009
#define GL_CONSTANT_COLOR 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
#define GL_CONSTANT_ALPHA 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
#define GL_FUNC_ADD 0x8006
#define GL_FUNC_REVERSE_SUBTRACT 0x800B
#define GL_FUNC_SUBTRACT 0x800A
#define GL_MIN 0x8007
#define GL_MAX 0x8008
#define GL_BUFFER_SIZE 0x8764
#define GL_BUFFER_USAGE 0x8765
#define GL_QUERY_COUNTER_BITS 0x8864
#define GL_CURRENT_QUERY 0x8865
#define GL_QUERY_RESULT 0x8866
#define GL_QUERY_RESULT_AVAILABLE 0x8867
#define GL_ARRAY_BUFFER 0x8892
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#define GL_ARRAY_BUFFER_BINDING 0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_READ_ONLY 0x88B8
#define GL_WRITE_ONLY 0x88B9
#define GL_READ_WRITE 0x88BA
#define GL_BUFFER_ACCESS 0x88BB
#define GL_BUFFER_MAPPED 0x88BC
#define GL_BUFFER_MAP_POINTER 0x88BD
#define GL_STREAM_DRAW 0x88E0
#define GL_STREAM_READ 0x88E1
#define GL_STREAM_COPY 0x88E2
#define GL_STATIC_DRAW 0x88E4
#define GL_STATIC_READ 0x88E5
#define GL_STATIC_COPY 0x88E6
#define GL_DYNAMIC_DRAW 0x88E8
#define GL_DYNAMIC_READ 0x88E9
#define GL_DYNAMIC_COPY 0x88EA
#define GL_SAMPLES_PASSED 0x8914
#define GL_SRC1_ALPHA 0x8589
#define GL_BLEND_EQUATION_RGB 0x8009
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
#define GL_CURRENT_VERTEX_ATTRIB 0x8626
#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#define GL_STENCIL_BACK_FUNC 0x8800
#define GL_STENCIL_BACK_FAIL 0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
#define GL_MAX_DRAW_BUFFERS 0x8824
#define GL_DRAW_BUFFER0 0x8825
#define GL_DRAW_BUFFER1 0x8826
#define GL_DRAW_BUFFER2 0x8827
#define GL_DRAW_BUFFER3 0x8828
#define GL_DRAW_BUFFER4 0x8829
#define GL_DRAW_BUFFER5 0x882A
#define GL_DRAW_BUFFER6 0x882B
#define GL_DRAW_BUFFER7 0x882C
#define GL_DRAW_BUFFER8 0x882D
#define GL_DRAW_BUFFER9 0x882E
#define GL_DRAW_BUFFER10 0x882F
#define GL_DRAW_BUFFER11 0x8830
#define GL_DRAW_BUFFER12 0x8831
#define GL_DRAW_BUFFER13 0x8832
#define GL_DRAW_BUFFER14 0x8833
#define GL_DRAW_BUFFER15 0x8834
#define GL_BLEND_EQUATION_ALPHA 0x883D
#define GL_MAX_VERTEX_ATTRIBS 0x8869
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
#define GL_FRAGMENT_SHADER 0x8B30
#define GL_VERTEX_SHADER 0x8B31
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
#define GL_MAX_VARYING_FLOATS 0x8B4B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_SHADER_TYPE 0x8B4F
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_INT_VEC2 0x8B53
#define GL_INT_VEC3 0x8B54
#define GL_INT_VEC4 0x8B55
#define GL_BOOL 0x8B56
#define GL_BOOL_VEC2 0x8B57
#define GL_BOOL_VEC3 0x8B58
#define GL_BOOL_VEC4 0x8B59
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT4 0x8B5C
#define GL_SAMPLER_1D 0x8B5D
#define GL_SAMPLER_2D 0x8B5E
#define GL_SAMPLER_3D 0x8B5F
#define GL_SAMPLER_CUBE 0x8B60
#define GL_SAMPLER_1D_SHADOW 0x8B61
#define GL_SAMPLER_2D_SHADOW 0x8B62
#define GL_DELETE_STATUS 0x8B80
#define GL_COMPILE_STATUS 0x8B81
#define GL_LINK_STATUS 0x8B82
#define GL_VALIDATE_STATUS 0x8B83
#define GL_INFO_LOG_LENGTH 0x8B84
#define GL_ATTACHED_SHADERS 0x8B85
#define GL_ACTIVE_UNIFORMS 0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#define GL_ACTIVE_ATTRIBUTES 0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#define GL_CURRENT_PROGRAM 0x8B8D
#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
#define GL_LOWER_LEFT 0x8CA1
#define GL_UPPER_LEFT 0x8CA2
#define GL_STENCIL_BACK_REF 0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
#define GL_PIXEL_PACK_BUFFER 0x88EB
#define GL_PIXEL_UNPACK_BUFFER 0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
#define GL_FLOAT_MAT2x3 0x8B65
#define GL_FLOAT_MAT2x4 0x8B66
#define GL_FLOAT_MAT3x2 0x8B67
#define GL_FLOAT_MAT3x4 0x8B68
#define GL_FLOAT_MAT4x2 0x8B69
#define GL_FLOAT_MAT4x3 0x8B6A
#define GL_SRGB 0x8C40
#define GL_SRGB8 0x8C41
#define GL_SRGB_ALPHA 0x8C42
#define GL_SRGB8_ALPHA8 0x8C43
#define GL_COMPRESSED_SRGB 0x8C48
#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
#define GL_COMPARE_REF_TO_TEXTURE 0x884E
#define GL_CLIP_DISTANCE0 0x3000
#define GL_CLIP_DISTANCE1 0x3001
#define GL_CLIP_DISTANCE2 0x3002
#define GL_CLIP_DISTANCE3 0x3003
#define GL_CLIP_DISTANCE4 0x3004
#define GL_CLIP_DISTANCE5 0x3005
#define GL_CLIP_DISTANCE6 0x3006
#define GL_CLIP_DISTANCE7 0x3007
#define GL_MAX_CLIP_DISTANCES 0x0D32
#define GL_MAJOR_VERSION 0x821B
#define GL_MINOR_VERSION 0x821C
#define GL_NUM_EXTENSIONS 0x821D
#define GL_CONTEXT_FLAGS 0x821E
#define GL_COMPRESSED_RED 0x8225
#define GL_COMPRESSED_RG 0x8226
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
#define GL_RGBA32F 0x8814
#define GL_RGB32F 0x8815
#define GL_RGBA16F 0x881A
#define GL_RGB16F 0x881B
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
#define GL_CLAMP_READ_COLOR 0x891C
#define GL_FIXED_ONLY 0x891D
#define GL_MAX_VARYING_COMPONENTS 0x8B4B
#define GL_TEXTURE_1D_ARRAY 0x8C18
#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
#define GL_TEXTURE_2D_ARRAY 0x8C1A
#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
#define GL_R11F_G11F_B10F 0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
#define GL_RGB9_E5 0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
#define GL_TEXTURE_SHARED_SIZE 0x8C3F
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_PRIMITIVES_GENERATED 0x8C87
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_RASTERIZER_DISCARD 0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_INTERLEAVED_ATTRIBS 0x8C8C
#define GL_SEPARATE_ATTRIBS 0x8C8D
#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_RGBA32UI 0x8D70
#define GL_RGB32UI 0x8D71
#define GL_RGBA16UI 0x8D76
#define GL_RGB16UI 0x8D77
#define GL_RGBA8UI 0x8D7C
#define GL_RGB8UI 0x8D7D
#define GL_RGBA32I 0x8D82
#define GL_RGB32I 0x8D83
#define GL_RGBA16I 0x8D88
#define GL_RGB16I 0x8D89
#define GL_RGBA8I 0x8D8E
#define GL_RGB8I 0x8D8F
#define GL_RED_INTEGER 0x8D94
#define GL_GREEN_INTEGER 0x8D95
#define GL_BLUE_INTEGER 0x8D96
#define GL_RGB_INTEGER 0x8D98
#define GL_RGBA_INTEGER 0x8D99
#define GL_BGR_INTEGER 0x8D9A
#define GL_BGRA_INTEGER 0x8D9B
#define GL_SAMPLER_1D_ARRAY 0x8DC0
#define GL_SAMPLER_2D_ARRAY 0x8DC1
#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
#define GL_UNSIGNED_INT_VEC2 0x8DC6
#define GL_UNSIGNED_INT_VEC3 0x8DC7
#define GL_UNSIGNED_INT_VEC4 0x8DC8
#define GL_INT_SAMPLER_1D 0x8DC9
#define GL_INT_SAMPLER_2D 0x8DCA
#define GL_INT_SAMPLER_3D 0x8DCB
#define GL_INT_SAMPLER_CUBE 0x8DCC
#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
#define GL_QUERY_WAIT 0x8E13
#define GL_QUERY_NO_WAIT 0x8E14
#define GL_QUERY_BY_REGION_WAIT 0x8E15
#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
#define GL_BUFFER_ACCESS_FLAGS 0x911F
#define GL_BUFFER_MAP_LENGTH 0x9120
#define GL_BUFFER_MAP_OFFSET 0x9121
#define GL_DEPTH_COMPONENT32F 0x8CAC
#define GL_DEPTH32F_STENCIL8 0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_DEFAULT 0x8218
#define GL_FRAMEBUFFER_UNDEFINED 0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
#define GL_DEPTH_STENCIL 0x84F9
#define GL_UNSIGNED_INT_24_8 0x84FA
#define GL_DEPTH24_STENCIL8 0x88F0
#define GL_TEXTURE_STENCIL_SIZE 0x88F1
#define GL_TEXTURE_RED_TYPE 0x8C10
#define GL_TEXTURE_GREEN_TYPE 0x8C11
#define GL_TEXTURE_BLUE_TYPE 0x8C12
#define GL_TEXTURE_ALPHA_TYPE 0x8C13
#define GL_TEXTURE_DEPTH_TYPE 0x8C16
#define GL_UNSIGNED_NORMALIZED 0x8C17
#define GL_FRAMEBUFFER_BINDING 0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
#define GL_RENDERBUFFER_BINDING 0x8CA7
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_DRAW_FRAMEBUFFER 0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
#define GL_RENDERBUFFER_SAMPLES 0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
#define GL_COLOR_ATTACHMENT0 0x8CE0
#define GL_COLOR_ATTACHMENT1 0x8CE1
#define GL_COLOR_ATTACHMENT2 0x8CE2
#define GL_COLOR_ATTACHMENT3 0x8CE3
#define GL_COLOR_ATTACHMENT4 0x8CE4
#define GL_COLOR_ATTACHMENT5 0x8CE5
#define GL_COLOR_ATTACHMENT6 0x8CE6
#define GL_COLOR_ATTACHMENT7 0x8CE7
#define GL_COLOR_ATTACHMENT8 0x8CE8
#define GL_COLOR_ATTACHMENT9 0x8CE9
#define GL_COLOR_ATTACHMENT10 0x8CEA
#define GL_COLOR_ATTACHMENT11 0x8CEB
#define GL_COLOR_ATTACHMENT12 0x8CEC
#define GL_COLOR_ATTACHMENT13 0x8CED
#define GL_COLOR_ATTACHMENT14 0x8CEE
#define GL_COLOR_ATTACHMENT15 0x8CEF
#define GL_COLOR_ATTACHMENT16 0x8CF0
#define GL_COLOR_ATTACHMENT17 0x8CF1
#define GL_COLOR_ATTACHMENT18 0x8CF2
#define GL_COLOR_ATTACHMENT19 0x8CF3
#define GL_COLOR_ATTACHMENT20 0x8CF4
#define GL_COLOR_ATTACHMENT21 0x8CF5
#define GL_COLOR_ATTACHMENT22 0x8CF6
#define GL_COLOR_ATTACHMENT23 0x8CF7
#define GL_COLOR_ATTACHMENT24 0x8CF8
#define GL_COLOR_ATTACHMENT25 0x8CF9
#define GL_COLOR_ATTACHMENT26 0x8CFA
#define GL_COLOR_ATTACHMENT27 0x8CFB
#define GL_COLOR_ATTACHMENT28 0x8CFC
#define GL_COLOR_ATTACHMENT29 0x8CFD
#define GL_COLOR_ATTACHMENT30 0x8CFE
#define GL_COLOR_ATTACHMENT31 0x8CFF
#define GL_DEPTH_ATTACHMENT 0x8D00
#define GL_STENCIL_ATTACHMENT 0x8D20
#define GL_FRAMEBUFFER 0x8D40
#define GL_RENDERBUFFER 0x8D41
#define GL_RENDERBUFFER_WIDTH 0x8D42
#define GL_RENDERBUFFER_HEIGHT 0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
#define GL_STENCIL_INDEX1 0x8D46
#define GL_STENCIL_INDEX4 0x8D47
#define GL_STENCIL_INDEX8 0x8D48
#define GL_STENCIL_INDEX16 0x8D49
#define GL_RENDERBUFFER_RED_SIZE 0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_MAX_SAMPLES 0x8D57
#define GL_FRAMEBUFFER_SRGB 0x8DB9
#define GL_HALF_FLOAT 0x140B
#define GL_MAP_READ_BIT 0x0001
#define GL_MAP_WRITE_BIT 0x0002
#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
#define GL_COMPRESSED_RED_RGTC1 0x8DBB
#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
#define GL_COMPRESSED_RG_RGTC2 0x8DBD
#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
#define GL_RG 0x8227
#define GL_RG_INTEGER 0x8228
#define GL_R8 0x8229
#define GL_R16 0x822A
#define GL_RG8 0x822B
#define GL_RG16 0x822C
#define GL_R16F 0x822D
#define GL_R32F 0x822E
#define GL_RG16F 0x822F
#define GL_RG32F 0x8230
#define GL_R8I 0x8231
#define GL_R8UI 0x8232
#define GL_R16I 0x8233
#define GL_R16UI 0x8234
#define GL_R32I 0x8235
#define GL_R32UI 0x8236
#define GL_RG8I 0x8237
#define GL_RG8UI 0x8238
#define GL_RG16I 0x8239
#define GL_RG16UI 0x823A
#define GL_RG32I 0x823B
#define GL_RG32UI 0x823C
#define GL_VERTEX_ARRAY_BINDING 0x85B5
#define GL_SAMPLER_2D_RECT 0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
#define GL_SAMPLER_BUFFER 0x8DC2
#define GL_INT_SAMPLER_2D_RECT 0x8DCD
#define GL_INT_SAMPLER_BUFFER 0x8DD0
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8
#define GL_TEXTURE_BUFFER 0x8C2A
#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_RECTANGLE 0x84F5
#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
#define GL_R8_SNORM 0x8F94
#define GL_RG8_SNORM 0x8F95
#define GL_RGB8_SNORM 0x8F96
#define GL_RGBA8_SNORM 0x8F97
#define GL_R16_SNORM 0x8F98
#define GL_RG16_SNORM 0x8F99
#define GL_RGB16_SNORM 0x8F9A
#define GL_RGBA16_SNORM 0x8F9B
#define GL_SIGNED_NORMALIZED 0x8F9C
#define GL_PRIMITIVE_RESTART 0x8F9D
#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
#define GL_COPY_READ_BUFFER 0x8F36
#define GL_COPY_WRITE_BUFFER 0x8F37
#define GL_UNIFORM_BUFFER 0x8A11
#define GL_UNIFORM_BUFFER_BINDING 0x8A28
#define GL_UNIFORM_BUFFER_START 0x8A29
#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS 0x8A2C
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
#define GL_UNIFORM_TYPE 0x8A37
#define GL_UNIFORM_SIZE 0x8A38
#define GL_UNIFORM_NAME_LENGTH 0x8A39
#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
#define GL_UNIFORM_OFFSET 0x8A3B
#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_INVALID_INDEX 0xFFFFFFFF
#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_LINES_ADJACENCY 0x000A
#define GL_LINE_STRIP_ADJACENCY 0x000B
#define GL_TRIANGLES_ADJACENCY 0x000C
#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
#define GL_PROGRAM_POINT_SIZE 0x8642
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_GEOMETRY_SHADER 0x8DD9
#define GL_GEOMETRY_VERTICES_OUT 0x8916
#define GL_GEOMETRY_INPUT_TYPE 0x8917
#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
#define GL_CONTEXT_PROFILE_MASK 0x9126
#define GL_DEPTH_CLAMP 0x864F
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
#define GL_LAST_VERTEX_CONVENTION 0x8E4E
#define GL_PROVOKING_VERTEX 0x8E4F
#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
#define GL_OBJECT_TYPE 0x9112
#define GL_SYNC_CONDITION 0x9113
#define GL_SYNC_STATUS 0x9114
#define GL_SYNC_FLAGS 0x9115
#define GL_SYNC_FENCE 0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
#define GL_UNSIGNALED 0x9118
#define GL_SIGNALED 0x9119
#define GL_ALREADY_SIGNALED 0x911A
#define GL_TIMEOUT_EXPIRED 0x911B
#define GL_CONDITION_SATISFIED 0x911C
#define GL_WAIT_FAILED 0x911D
#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
#define GL_SAMPLE_POSITION 0x8E50
#define GL_SAMPLE_MASK 0x8E51
#define GL_SAMPLE_MASK_VALUE 0x8E52
#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_SAMPLES 0x9106
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
#define GL_MAX_INTEGER_SAMPLES 0x9110
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE
#define GL_SRC1_COLOR 0x88F9
#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
#define GL_ANY_SAMPLES_PASSED 0x8C2F
#define GL_SAMPLER_BINDING 0x8919
#define GL_RGB10_A2UI 0x906F
#define GL_TEXTURE_SWIZZLE_R 0x8E42
#define GL_TEXTURE_SWIZZLE_G 0x8E43
#define GL_TEXTURE_SWIZZLE_B 0x8E44
#define GL_TEXTURE_SWIZZLE_A 0x8E45
#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
#define GL_TIME_ELAPSED 0x88BF
#define GL_TIMESTAMP 0x8E28
#define GL_INT_2_10_10_10_REV 0x8D9F
#define GL_SAMPLE_SHADING 0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE 0x8C37
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_TEXTURE_CUBE_MAP_ARRAY 0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY 0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY 0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW 0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY 0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
#define GL_DRAW_INDIRECT_BUFFER 0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING 0x8F43
#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
#define GL_MAX_VERTEX_STREAMS 0x8E71
#define GL_DOUBLE_VEC2 0x8FFC
#define GL_DOUBLE_VEC3 0x8FFD
#define GL_DOUBLE_VEC4 0x8FFE
#define GL_DOUBLE_MAT2 0x8F46
#define GL_DOUBLE_MAT3 0x8F47
#define GL_DOUBLE_MAT4 0x8F48
#define GL_DOUBLE_MAT2x3 0x8F49
#define GL_DOUBLE_MAT2x4 0x8F4A
#define GL_DOUBLE_MAT3x2 0x8F4B
#define GL_DOUBLE_MAT3x4 0x8F4C
#define GL_DOUBLE_MAT4x2 0x8F4D
#define GL_DOUBLE_MAT4x3 0x8F4E
#define GL_ACTIVE_SUBROUTINES 0x8DE5
#define GL_ACTIVE_SUBROUTINE_UNIFORMS 0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH 0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_MAX_SUBROUTINES 0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_NUM_COMPATIBLE_SUBROUTINES 0x8E4A
#define GL_COMPATIBLE_SUBROUTINES 0x8E4B
#define GL_PATCHES 0x000E
#define GL_PATCH_VERTICES 0x8E72
#define GL_PATCH_DEFAULT_INNER_LEVEL 0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL 0x8E74
#define GL_TESS_CONTROL_OUTPUT_VERTICES 0x8E75
#define GL_TESS_GEN_MODE 0x8E76
#define GL_TESS_GEN_SPACING 0x8E77
#define GL_TESS_GEN_VERTEX_ORDER 0x8E78
#define GL_TESS_GEN_POINT_MODE 0x8E79
#define GL_ISOLINES 0x8E7A
#define GL_QUADS 0x0007
#define GL_FRACTIONAL_ODD 0x8E7B
#define GL_FRACTIONAL_EVEN 0x8E7C
#define GL_MAX_PATCH_VERTICES 0x8E7D
#define GL_MAX_TESS_GEN_LEVEL 0x8E7E
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_PATCH_COMPONENTS 0x8E84
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_TESS_EVALUATION_SHADER 0x8E87
#define GL_TESS_CONTROL_SHADER 0x8E88
#define GL_TRANSFORM_FEEDBACK 0x8E22
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BINDING 0x8E25
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
#define GL_FIXED 0x140C
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_LOW_FLOAT 0x8DF0
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_HIGH_FLOAT 0x8DF2
#define GL_LOW_INT 0x8DF3
#define GL_MEDIUM_INT 0x8DF4
#define GL_HIGH_INT 0x8DF5
#define GL_SHADER_COMPILER 0x8DFA
#define GL_SHADER_BINARY_FORMATS 0x8DF8
#define GL_NUM_SHADER_BINARY_FORMATS 0x8DF9
#define GL_MAX_VERTEX_UNIFORM_VECTORS 0x8DFB
#define GL_MAX_VARYING_VECTORS 0x8DFC
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS 0x8DFD
#define GL_RGB565 0x8D62
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINARY_LENGTH 0x8741
#define GL_NUM_PROGRAM_BINARY_FORMATS 0x87FE
#define GL_PROGRAM_BINARY_FORMATS 0x87FF
#define GL_VERTEX_SHADER_BIT 0x00000001
#define GL_FRAGMENT_SHADER_BIT 0x00000002
#define GL_GEOMETRY_SHADER_BIT 0x00000004
#define GL_TESS_CONTROL_SHADER_BIT 0x00000008
#define GL_TESS_EVALUATION_SHADER_BIT 0x00000010
#define GL_ALL_SHADER_BITS 0xFFFFFFFF
#define GL_PROGRAM_SEPARABLE 0x8258
#define GL_ACTIVE_PROGRAM 0x8259
#define GL_PROGRAM_PIPELINE_BINDING 0x825A
#define GL_MAX_VIEWPORTS 0x825B
#define GL_VIEWPORT_SUBPIXEL_BITS 0x825C
#define GL_VIEWPORT_BOUNDS_RANGE 0x825D
#define GL_LAYER_PROVOKING_VERTEX 0x825E
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_UNDEFINED_VERTEX 0x8260
#define GL_COPY_READ_BUFFER_BINDING 0x8F36
#define GL_COPY_WRITE_BUFFER_BINDING 0x8F37
#define GL_TRANSFORM_FEEDBACK_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_PAUSED 0x8E23
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH 0x9127
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT 0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH 0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE 0x912A
#define GL_PACK_COMPRESSED_BLOCK_WIDTH 0x912B
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT 0x912C
#define GL_PACK_COMPRESSED_BLOCK_DEPTH 0x912D
#define GL_PACK_COMPRESSED_BLOCK_SIZE 0x912E
#define GL_NUM_SAMPLE_COUNTS 0x9380
#define GL_MIN_MAP_BUFFER_ALIGNMENT 0x90BC
#define GL_ATOMIC_COUNTER_BUFFER 0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_BINDING 0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_START 0x92C2
#define GL_ATOMIC_COUNTER_BUFFER_SIZE 0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE 0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS 0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES 0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER 0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER 0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER 0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER 0x92CB
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0x92CC
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0x92CD
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0x92CE
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0x92CF
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 0x92D0
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 0x92D1
#define GL_MAX_VERTEX_ATOMIC_COUNTERS 0x92D2
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS 0x92D3
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0x92D4
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS 0x92D5
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS 0x92D6
#define GL_MAX_COMBINED_ATOMIC_COUNTERS 0x92D7
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE 0x92D8
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 0x92DC
#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS 0x92D9
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX 0x92DA
#define GL_UNSIGNED_INT_ATOMIC_COUNTER 0x92DB
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT 0x00000001
#define GL_ELEMENT_ARRAY_BARRIER_BIT 0x00000002
#define GL_UNIFORM_BARRIER_BIT 0x00000004
#define GL_TEXTURE_FETCH_BARRIER_BIT 0x00000008
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT 0x00000020
#define GL_COMMAND_BARRIER_BIT 0x00000040
#define GL_PIXEL_BUFFER_BARRIER_BIT 0x00000080
#define GL_TEXTURE_UPDATE_BARRIER_BIT 0x00000100
#define GL_BUFFER_UPDATE_BARRIER_BIT 0x00000200
#define GL_FRAMEBUFFER_BARRIER_BIT 0x00000400
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT 0x00000800
#define GL_ATOMIC_COUNTER_BARRIER_BIT 0x00001000
#define GL_ALL_BARRIER_BITS 0xFFFFFFFF
#define GL_MAX_IMAGE_UNITS 0x8F38
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS 0x8F39
#define GL_IMAGE_BINDING_NAME 0x8F3A
#define GL_IMAGE_BINDING_LEVEL 0x8F3B
#define GL_IMAGE_BINDING_LAYERED 0x8F3C
#define GL_IMAGE_BINDING_LAYER 0x8F3D
#define GL_IMAGE_BINDING_ACCESS 0x8F3E
#define GL_IMAGE_1D 0x904C
#define GL_IMAGE_2D 0x904D
#define GL_IMAGE_3D 0x904E
#define GL_IMAGE_2D_RECT 0x904F
#define GL_IMAGE_CUBE 0x9050
#define GL_IMAGE_BUFFER 0x9051
#define GL_IMAGE_1D_ARRAY 0x9052
#define GL_IMAGE_2D_ARRAY 0x9053
#define GL_IMAGE_CUBE_MAP_ARRAY 0x9054
#define GL_IMAGE_2D_MULTISAMPLE 0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY 0x9056
#define GL_INT_IMAGE_1D 0x9057
#define GL_INT_IMAGE_2D 0x9058
#define GL_INT_IMAGE_3D 0x9059
#define GL_INT_IMAGE_2D_RECT 0x905A
#define GL_INT_IMAGE_CUBE 0x905B
#define GL_INT_IMAGE_BUFFER 0x905C
#define GL_INT_IMAGE_1D_ARRAY 0x905D
#define GL_INT_IMAGE_2D_ARRAY 0x905E
#define GL_INT_IMAGE_CUBE_MAP_ARRAY 0x905F
#define GL_INT_IMAGE_2D_MULTISAMPLE 0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x9061
#define GL_UNSIGNED_INT_IMAGE_1D 0x9062
#define GL_UNSIGNED_INT_IMAGE_2D 0x9063
#define GL_UNSIGNED_INT_IMAGE_3D 0x9064
#define GL_UNSIGNED_INT_IMAGE_2D_RECT 0x9065
#define GL_UNSIGNED_INT_IMAGE_CUBE 0x9066
#define GL_UNSIGNED_INT_IMAGE_BUFFER 0x9067
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY 0x9068
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY 0x9069
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY 0x906A
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x906C
#define GL_MAX_IMAGE_SAMPLES 0x906D
#define GL_IMAGE_BINDING_FORMAT 0x906E
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE 0x90C7
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE 0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS 0x90C9
#define GL_MAX_VERTEX_IMAGE_UNIFORMS 0x90CA
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS 0x90CB
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0x90CC
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS 0x90CD
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS 0x90CE
#define GL_MAX_COMBINED_IMAGE_UNIFORMS 0x90CF
#define GL_COMPRESSED_RGBA_BPTC_UNORM 0x8E8C
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM 0x8E8D
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT 0x8E8F
#define GL_TEXTURE_IMMUTABLE_FORMAT 0x912F
#define GL_NUM_SHADING_LANGUAGE_VERSIONS 0x82E9
#define GL_VERTEX_ATTRIB_ARRAY_LONG 0x874E
#define GL_COMPRESSED_RGB8_ETC2 0x9274
#define GL_COMPRESSED_SRGB8_ETC2 0x9275
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_RGBA8_ETC2_EAC 0x9278
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_COMPRESSED_R11_EAC 0x9270
#define GL_COMPRESSED_SIGNED_R11_EAC 0x9271
#define GL_COMPRESSED_RG11_EAC 0x9272
#define GL_COMPRESSED_SIGNED_RG11_EAC 0x9273
#define GL_PRIMITIVE_RESTART_FIXED_INDEX 0x8D69
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_MAX_ELEMENT_INDEX 0x8D6B
#define GL_COMPUTE_SHADER 0x91B9
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS 0x91BB
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS 0x91BC
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS 0x91BD
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE 0x8262
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS 0x8263
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS 0x8265
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS 0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT 0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE 0x91BF
#define GL_COMPUTE_WORK_GROUP_SIZE 0x8267
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#define GL_DISPATCH_INDIRECT_BUFFER 0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING 0x90EF
#define GL_COMPUTE_SHADER_BIT 0x00000020
#define GL_DEBUG_OUTPUT_SYNCHRONOUS 0x8242
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH 0x8243
#define GL_DEBUG_CALLBACK_FUNCTION 0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM 0x8245
#define GL_DEBUG_SOURCE_API 0x8246
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM 0x8247
#define GL_DEBUG_SOURCE_SHADER_COMPILER 0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY 0x8249
#define GL_DEBUG_SOURCE_APPLICATION 0x824A
#define GL_DEBUG_SOURCE_OTHER 0x824B
#define GL_DEBUG_TYPE_ERROR 0x824C
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR 0x824D
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR 0x824E
#define GL_DEBUG_TYPE_PORTABILITY 0x824F
#define GL_DEBUG_TYPE_PERFORMANCE 0x8250
#define GL_DEBUG_TYPE_OTHER 0x8251
#define GL_MAX_DEBUG_MESSAGE_LENGTH 0x9143
#define GL_MAX_DEBUG_LOGGED_MESSAGES 0x9144
#define GL_DEBUG_LOGGED_MESSAGES 0x9145
#define GL_DEBUG_SEVERITY_HIGH 0x9146
#define GL_DEBUG_SEVERITY_MEDIUM 0x9147
#define GL_DEBUG_SEVERITY_LOW 0x9148
#define GL_DEBUG_TYPE_MARKER 0x8268
#define GL_DEBUG_TYPE_PUSH_GROUP 0x8269
#define GL_DEBUG_TYPE_POP_GROUP 0x826A
#define GL_DEBUG_SEVERITY_NOTIFICATION 0x826B
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH 0x826C
#define GL_DEBUG_GROUP_STACK_DEPTH 0x826D
#define GL_BUFFER 0x82E0
#define GL_SHADER 0x82E1
#define GL_PROGRAM 0x82E2
#define GL_VERTEX_ARRAY 0x8074
#define GL_QUERY 0x82E3
#define GL_PROGRAM_PIPELINE 0x82E4
#define GL_SAMPLER 0x82E6
#define GL_MAX_LABEL_LENGTH 0x82E8
#define GL_DEBUG_OUTPUT 0x92E0
#define GL_CONTEXT_FLAG_DEBUG_BIT 0x00000002
#define GL_MAX_UNIFORM_LOCATIONS 0x826E
#define GL_FRAMEBUFFER_DEFAULT_WIDTH 0x9310
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT 0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS 0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES 0x9313
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS 0x9314
#define GL_MAX_FRAMEBUFFER_WIDTH 0x9315
#define GL_MAX_FRAMEBUFFER_HEIGHT 0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS 0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES 0x9318
#define GL_INTERNALFORMAT_SUPPORTED 0x826F
#define GL_INTERNALFORMAT_PREFERRED 0x8270
#define GL_INTERNALFORMAT_RED_SIZE 0x8271
#define GL_INTERNALFORMAT_GREEN_SIZE 0x8272
#define GL_INTERNALFORMAT_BLUE_SIZE 0x8273
#define GL_INTERNALFORMAT_ALPHA_SIZE 0x8274
#define GL_INTERNALFORMAT_DEPTH_SIZE 0x8275
#define GL_INTERNALFORMAT_STENCIL_SIZE 0x8276
#define GL_INTERNALFORMAT_SHARED_SIZE 0x8277
#define GL_INTERNALFORMAT_RED_TYPE 0x8278
#define GL_INTERNALFORMAT_GREEN_TYPE 0x8279
#define GL_INTERNALFORMAT_BLUE_TYPE 0x827A
#define GL_INTERNALFORMAT_ALPHA_TYPE 0x827B
#define GL_INTERNALFORMAT_DEPTH_TYPE 0x827C
#define GL_INTERNALFORMAT_STENCIL_TYPE 0x827D
#define GL_MAX_WIDTH 0x827E
#define GL_MAX_HEIGHT 0x827F
#define GL_MAX_DEPTH 0x8280
#define GL_MAX_LAYERS 0x8281
#define GL_MAX_COMBINED_DIMENSIONS 0x8282
#define GL_COLOR_COMPONENTS 0x8283
#define GL_DEPTH_COMPONENTS 0x8284
#define GL_STENCIL_COMPONENTS 0x8285
#define GL_COLOR_RENDERABLE 0x8286
#define GL_DEPTH_RENDERABLE 0x8287
#define GL_STENCIL_RENDERABLE 0x8288
#define GL_FRAMEBUFFER_RENDERABLE 0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED 0x828A
#define GL_FRAMEBUFFER_BLEND 0x828B
#define GL_READ_PIXELS 0x828C
#define GL_READ_PIXELS_FORMAT 0x828D
#define GL_READ_PIXELS_TYPE 0x828E
#define GL_TEXTURE_IMAGE_FORMAT 0x828F
#define GL_TEXTURE_IMAGE_TYPE 0x8290
#define GL_GET_TEXTURE_IMAGE_FORMAT 0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE 0x8292
#define GL_MIPMAP 0x8293
#define GL_MANUAL_GENERATE_MIPMAP 0x8294
#define GL_AUTO_GENERATE_MIPMAP 0x8295
#define GL_COLOR_ENCODING 0x8296
#define GL_SRGB_READ 0x8297
#define GL_SRGB_WRITE 0x8298
#define GL_FILTER 0x829A
#define GL_VERTEX_TEXTURE 0x829B
#define GL_TESS_CONTROL_TEXTURE 0x829C
#define GL_TESS_EVALUATION_TEXTURE 0x829D
#define GL_GEOMETRY_TEXTURE 0x829E
#define GL_FRAGMENT_TEXTURE 0x829F
#define GL_COMPUTE_TEXTURE 0x82A0
#define GL_TEXTURE_SHADOW 0x82A1
#define GL_TEXTURE_GATHER 0x82A2
#define GL_TEXTURE_GATHER_SHADOW 0x82A3
#define GL_SHADER_IMAGE_LOAD 0x82A4
#define GL_SHADER_IMAGE_STORE 0x82A5
#define GL_SHADER_IMAGE_ATOMIC 0x82A6
#define GL_IMAGE_TEXEL_SIZE 0x82A7
#define GL_IMAGE_COMPATIBILITY_CLASS 0x82A8
#define GL_IMAGE_PIXEL_FORMAT 0x82A9
#define GL_IMAGE_PIXEL_TYPE 0x82AA
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST 0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST 0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE 0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE 0x82AF
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH 0x82B1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT 0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE 0x82B3
#define GL_CLEAR_BUFFER 0x82B4
#define GL_TEXTURE_VIEW 0x82B5
#define GL_VIEW_COMPATIBILITY_CLASS 0x82B6
#define GL_FULL_SUPPORT 0x82B7
#define GL_CAVEAT_SUPPORT 0x82B8
#define GL_IMAGE_CLASS_4_X_32 0x82B9
#define GL_IMAGE_CLASS_2_X_32 0x82BA
#define GL_IMAGE_CLASS_1_X_32 0x82BB
#define GL_IMAGE_CLASS_4_X_16 0x82BC
#define GL_IMAGE_CLASS_2_X_16 0x82BD
#define GL_IMAGE_CLASS_1_X_16 0x82BE
#define GL_IMAGE_CLASS_4_X_8 0x82BF
#define GL_IMAGE_CLASS_2_X_8 0x82C0
#define GL_IMAGE_CLASS_1_X_8 0x82C1
#define GL_IMAGE_CLASS_11_11_10 0x82C2
#define GL_IMAGE_CLASS_10_10_10_2 0x82C3
#define GL_VIEW_CLASS_128_BITS 0x82C4
#define GL_VIEW_CLASS_96_BITS 0x82C5
#define GL_VIEW_CLASS_64_BITS 0x82C6
#define GL_VIEW_CLASS_48_BITS 0x82C7
#define GL_VIEW_CLASS_32_BITS 0x82C8
#define GL_VIEW_CLASS_24_BITS 0x82C9
#define GL_VIEW_CLASS_16_BITS 0x82CA
#define GL_VIEW_CLASS_8_BITS 0x82CB
#define GL_VIEW_CLASS_S3TC_DXT1_RGB 0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA 0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA 0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA 0x82CF
#define GL_VIEW_CLASS_RGTC1_RED 0x82D0
#define GL_VIEW_CLASS_RGTC2_RG 0x82D1
#define GL_VIEW_CLASS_BPTC_UNORM 0x82D2
#define GL_VIEW_CLASS_BPTC_FLOAT 0x82D3
#define GL_UNIFORM 0x92E1
#define GL_UNIFORM_BLOCK 0x92E2
#define GL_PROGRAM_INPUT 0x92E3
#define GL_PROGRAM_OUTPUT 0x92E4
#define GL_BUFFER_VARIABLE 0x92E5
#define GL_SHADER_STORAGE_BLOCK 0x92E6
#define GL_VERTEX_SUBROUTINE 0x92E8
#define GL_TESS_CONTROL_SUBROUTINE 0x92E9
#define GL_TESS_EVALUATION_SUBROUTINE 0x92EA
#define GL_GEOMETRY_SUBROUTINE 0x92EB
#define GL_FRAGMENT_SUBROUTINE 0x92EC
#define GL_COMPUTE_SUBROUTINE 0x92ED
#define GL_VERTEX_SUBROUTINE_UNIFORM 0x92EE
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM 0x92EF
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM 0x92F0
#define GL_GEOMETRY_SUBROUTINE_UNIFORM 0x92F1
#define GL_FRAGMENT_SUBROUTINE_UNIFORM 0x92F2
#define GL_COMPUTE_SUBROUTINE_UNIFORM 0x92F3
#define GL_TRANSFORM_FEEDBACK_VARYING 0x92F4
#define GL_ACTIVE_RESOURCES 0x92F5
#define GL_MAX_NAME_LENGTH 0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES 0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES 0x92F8
#define GL_NAME_LENGTH 0x92F9
#define GL_TYPE 0x92FA
#define GL_ARRAY_SIZE 0x92FB
#define GL_OFFSET 0x92FC
#define GL_BLOCK_INDEX 0x92FD
#define GL_ARRAY_STRIDE 0x92FE
#define GL_MATRIX_STRIDE 0x92FF
#define GL_IS_ROW_MAJOR 0x9300
#define GL_ATOMIC_COUNTER_BUFFER_INDEX 0x9301
#define GL_BUFFER_BINDING 0x9302
#define GL_BUFFER_DATA_SIZE 0x9303
#define GL_NUM_ACTIVE_VARIABLES 0x9304
#define GL_ACTIVE_VARIABLES 0x9305
#define GL_REFERENCED_BY_VERTEX_SHADER 0x9306
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER 0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER 0x9308
#define GL_REFERENCED_BY_GEOMETRY_SHADER 0x9309
#define GL_REFERENCED_BY_FRAGMENT_SHADER 0x930A
#define GL_REFERENCED_BY_COMPUTE_SHADER 0x930B
#define GL_TOP_LEVEL_ARRAY_SIZE 0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE 0x930D
#define GL_LOCATION 0x930E
#define GL_LOCATION_INDEX 0x930F
#define GL_IS_PER_PATCH 0x92E7
#define GL_SHADER_STORAGE_BUFFER 0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING 0x90D3
#define GL_SHADER_STORAGE_BUFFER_START 0x90D4
#define GL_SHADER_STORAGE_BUFFER_SIZE 0x90D5
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS 0x90D6
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0x90D7
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0x90D8
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0x90D9
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 0x90DA
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS 0x90DB
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS 0x90DC
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS 0x90DD
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE 0x90DE
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 0x90DF
#define GL_SHADER_STORAGE_BARRIER_BIT 0x00002000
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES 0x8F39
#define GL_DEPTH_STENCIL_TEXTURE_MODE 0x90EA
#define GL_TEXTURE_BUFFER_OFFSET 0x919D
#define GL_TEXTURE_BUFFER_SIZE 0x919E
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT 0x919F
#define GL_TEXTURE_VIEW_MIN_LEVEL 0x82DB
#define GL_TEXTURE_VIEW_NUM_LEVELS 0x82DC
#define GL_TEXTURE_VIEW_MIN_LAYER 0x82DD
#define GL_TEXTURE_VIEW_NUM_LAYERS 0x82DE
#define GL_TEXTURE_IMMUTABLE_LEVELS 0x82DF
#define GL_VERTEX_ATTRIB_BINDING 0x82D4
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D5
#define GL_VERTEX_BINDING_DIVISOR 0x82D6
#define GL_VERTEX_BINDING_OFFSET 0x82D7
#define GL_VERTEX_BINDING_STRIDE 0x82D8
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D9
#define GL_MAX_VERTEX_ATTRIB_BINDINGS 0x82DA
#define GL_VERTEX_BINDING_BUFFER 0x8F4F
#define GL_DISPLAY_LIST 0x82E7
#define GL_STACK_UNDERFLOW 0x0504
#define GL_STACK_OVERFLOW 0x0503
#define GL_MAX_VERTEX_ATTRIB_STRIDE 0x82E5
#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
#define GL_TEXTURE_BUFFER_BINDING 0x8C2A
#define GL_MAP_PERSISTENT_BIT 0x0040
#define GL_MAP_COHERENT_BIT 0x0080
#define GL_DYNAMIC_STORAGE_BIT 0x0100
#define GL_CLIENT_STORAGE_BIT 0x0200
#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT 0x00004000
#define GL_BUFFER_IMMUTABLE_STORAGE 0x821F
#define GL_BUFFER_STORAGE_FLAGS 0x8220
#define GL_CLEAR_TEXTURE 0x9365
#define GL_LOCATION_COMPONENT 0x934A
#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX 0x934B
#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE 0x934C
#define GL_QUERY_BUFFER 0x9192
#define GL_QUERY_BUFFER_BARRIER_BIT 0x00008000
#define GL_QUERY_BUFFER_BINDING 0x9193
#define GL_QUERY_RESULT_NO_WAIT 0x9194
#define GL_MIRROR_CLAMP_TO_EDGE 0x8743
#define GL_CONTEXT_LOST 0x0507
#define GL_NEGATIVE_ONE_TO_ONE 0x935E
#define GL_ZERO_TO_ONE 0x935F
#define GL_CLIP_ORIGIN 0x935C
#define GL_CLIP_DEPTH_MODE 0x935D
#define GL_QUERY_WAIT_INVERTED 0x8E17
#define GL_QUERY_NO_WAIT_INVERTED 0x8E18
#define GL_QUERY_BY_REGION_WAIT_INVERTED 0x8E19
#define GL_QUERY_BY_REGION_NO_WAIT_INVERTED 0x8E1A
#define GL_MAX_CULL_DISTANCES 0x82F9
#define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES 0x82FA
#define GL_TEXTURE_TARGET 0x1006
#define GL_QUERY_TARGET 0x82EA
#define GL_GUILTY_CONTEXT_RESET 0x8253
#define GL_INNOCENT_CONTEXT_RESET 0x8254
#define GL_UNKNOWN_CONTEXT_RESET 0x8255
#define GL_RESET_NOTIFICATION_STRATEGY 0x8256
#define GL_LOSE_CONTEXT_ON_RESET 0x8252
#define GL_NO_RESET_NOTIFICATION 0x8261
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT 0x00000004
#define GL_CONTEXT_RELEASE_BEHAVIOR 0x82FB
#define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH 0x82FC
#define GL_SHADER_BINARY_FORMAT_SPIR_V 0x9551
#define GL_SPIR_V_BINARY 0x9552
#define GL_PARAMETER_BUFFER 0x80EE
#define GL_PARAMETER_BUFFER_BINDING 0x80EF
#define GL_CONTEXT_FLAG_NO_ERROR_BIT 0x00000008
#define GL_VERTICES_SUBMITTED 0x82EE
#define GL_PRIMITIVES_SUBMITTED 0x82EF
#define GL_VERTEX_SHADER_INVOCATIONS 0x82F0
#define GL_TESS_CONTROL_SHADER_PATCHES 0x82F1
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS 0x82F2
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED 0x82F3
#define GL_FRAGMENT_SHADER_INVOCATIONS 0x82F4
#define GL_COMPUTE_SHADER_INVOCATIONS 0x82F5
#define GL_CLIPPING_INPUT_PRIMITIVES 0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES 0x82F7
#define GL_POLYGON_OFFSET_CLAMP 0x8E1B
#define GL_SPIR_V_EXTENSIONS 0x9553
#define GL_NUM_SPIR_V_EXTENSIONS 0x9554
#define GL_TEXTURE_MAX_ANISOTROPY 0x84FE
#define GL_MAX_TEXTURE_MAX_ANISOTROPY 0x84FF
#define GL_TRANSFORM_FEEDBACK_OVERFLOW 0x82EC
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW 0x82ED
#ifndef GL_VERSION_1_0
#define GL_VERSION_1_0 1
GLAPI int GLAD_GL_VERSION_1_0;
typedef void (APIENTRYP PFNGLCULLFACEPROC)(GLenum mode);
GLAPI PFNGLCULLFACEPROC glad_glCullFace;
#define glCullFace glad_glCullFace
typedef void (APIENTRYP PFNGLFRONTFACEPROC)(GLenum mode);
GLAPI PFNGLFRONTFACEPROC glad_glFrontFace;
#define glFrontFace glad_glFrontFace
typedef void (APIENTRYP PFNGLHINTPROC)(GLenum target, GLenum mode);
GLAPI PFNGLHINTPROC glad_glHint;
#define glHint glad_glHint
typedef void (APIENTRYP PFNGLLINEWIDTHPROC)(GLfloat width);
GLAPI PFNGLLINEWIDTHPROC glad_glLineWidth;
#define glLineWidth glad_glLineWidth
typedef void (APIENTRYP PFNGLPOINTSIZEPROC)(GLfloat size);
GLAPI PFNGLPOINTSIZEPROC glad_glPointSize;
#define glPointSize glad_glPointSize
typedef void (APIENTRYP PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
GLAPI PFNGLPOLYGONMODEPROC glad_glPolygonMode;
#define glPolygonMode glad_glPolygonMode
typedef void (APIENTRYP PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLSCISSORPROC glad_glScissor;
#define glScissor glad_glScissor
typedef void (APIENTRYP PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
GLAPI PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
#define glTexParameterf glad_glTexParameterf
typedef void (APIENTRYP PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
GLAPI PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
#define glTexParameterfv glad_glTexParameterfv
typedef void (APIENTRYP PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
GLAPI PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
#define glTexParameteri glad_glTexParameteri
typedef void (APIENTRYP PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
GLAPI PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
#define glTexParameteriv glad_glTexParameteriv
typedef void (APIENTRYP PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
#define glTexImage1D glad_glTexImage1D
typedef void (APIENTRYP PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
#define glTexImage2D glad_glTexImage2D
typedef void (APIENTRYP PFNGLDRAWBUFFERPROC)(GLenum buf);
GLAPI PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
#define glDrawBuffer glad_glDrawBuffer
typedef void (APIENTRYP PFNGLCLEARPROC)(GLbitfield mask);
GLAPI PFNGLCLEARPROC glad_glClear;
#define glClear glad_glClear
typedef void (APIENTRYP PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GLAPI PFNGLCLEARCOLORPROC glad_glClearColor;
#define glClearColor glad_glClearColor
typedef void (APIENTRYP PFNGLCLEARSTENCILPROC)(GLint s);
GLAPI PFNGLCLEARSTENCILPROC glad_glClearStencil;
#define glClearStencil glad_glClearStencil
typedef void (APIENTRYP PFNGLCLEARDEPTHPROC)(GLdouble depth);
GLAPI PFNGLCLEARDEPTHPROC glad_glClearDepth;
#define glClearDepth glad_glClearDepth
typedef void (APIENTRYP PFNGLSTENCILMASKPROC)(GLuint mask);
GLAPI PFNGLSTENCILMASKPROC glad_glStencilMask;
#define glStencilMask glad_glStencilMask
typedef void (APIENTRYP PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
GLAPI PFNGLCOLORMASKPROC glad_glColorMask;
#define glColorMask glad_glColorMask
typedef void (APIENTRYP PFNGLDEPTHMASKPROC)(GLboolean flag);
GLAPI PFNGLDEPTHMASKPROC glad_glDepthMask;
#define glDepthMask glad_glDepthMask
typedef void (APIENTRYP PFNGLDISABLEPROC)(GLenum cap);
GLAPI PFNGLDISABLEPROC glad_glDisable;
#define glDisable glad_glDisable
typedef void (APIENTRYP PFNGLENABLEPROC)(GLenum cap);
GLAPI PFNGLENABLEPROC glad_glEnable;
#define glEnable glad_glEnable
typedef void (APIENTRYP PFNGLFINISHPROC)(void);
GLAPI PFNGLFINISHPROC glad_glFinish;
#define glFinish glad_glFinish
typedef void (APIENTRYP PFNGLFLUSHPROC)(void);
GLAPI PFNGLFLUSHPROC glad_glFlush;
#define glFlush glad_glFlush
typedef void (APIENTRYP PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
GLAPI PFNGLBLENDFUNCPROC glad_glBlendFunc;
#define glBlendFunc glad_glBlendFunc
typedef void (APIENTRYP PFNGLLOGICOPPROC)(GLenum opcode);
GLAPI PFNGLLOGICOPPROC glad_glLogicOp;
#define glLogicOp glad_glLogicOp
typedef void (APIENTRYP PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
GLAPI PFNGLSTENCILFUNCPROC glad_glStencilFunc;
#define glStencilFunc glad_glStencilFunc
typedef void (APIENTRYP PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
GLAPI PFNGLSTENCILOPPROC glad_glStencilOp;
#define glStencilOp glad_glStencilOp
typedef void (APIENTRYP PFNGLDEPTHFUNCPROC)(GLenum func);
GLAPI PFNGLDEPTHFUNCPROC glad_glDepthFunc;
#define glDepthFunc glad_glDepthFunc
typedef void (APIENTRYP PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
GLAPI PFNGLPIXELSTOREFPROC glad_glPixelStoref;
#define glPixelStoref glad_glPixelStoref
typedef void (APIENTRYP PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
GLAPI PFNGLPIXELSTOREIPROC glad_glPixelStorei;
#define glPixelStorei glad_glPixelStorei
typedef void (APIENTRYP PFNGLREADBUFFERPROC)(GLenum src);
GLAPI PFNGLREADBUFFERPROC glad_glReadBuffer;
#define glReadBuffer glad_glReadBuffer
typedef void (APIENTRYP PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
GLAPI PFNGLREADPIXELSPROC glad_glReadPixels;
#define glReadPixels glad_glReadPixels
typedef void (APIENTRYP PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean *data);
GLAPI PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
#define glGetBooleanv glad_glGetBooleanv
typedef void (APIENTRYP PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble *data);
GLAPI PFNGLGETDOUBLEVPROC glad_glGetDoublev;
#define glGetDoublev glad_glGetDoublev
typedef GLenum (APIENTRYP PFNGLGETERRORPROC)(void);
GLAPI PFNGLGETERRORPROC glad_glGetError;
#define glGetError glad_glGetError
typedef void (APIENTRYP PFNGLGETFLOATVPROC)(GLenum pname, GLfloat *data);
GLAPI PFNGLGETFLOATVPROC glad_glGetFloatv;
#define glGetFloatv glad_glGetFloatv
typedef void (APIENTRYP PFNGLGETINTEGERVPROC)(GLenum pname, GLint *data);
GLAPI PFNGLGETINTEGERVPROC glad_glGetIntegerv;
#define glGetIntegerv glad_glGetIntegerv
typedef const GLubyte * (APIENTRYP PFNGLGETSTRINGPROC)(GLenum name);
GLAPI PFNGLGETSTRINGPROC glad_glGetString;
#define glGetString glad_glGetString
typedef void (APIENTRYP PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
GLAPI PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
#define glGetTexImage glad_glGetTexImage
typedef void (APIENTRYP PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
GLAPI PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
#define glGetTexParameterfv glad_glGetTexParameterfv
typedef void (APIENTRYP PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
GLAPI PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
#define glGetTexParameteriv glad_glGetTexParameteriv
typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat *params);
GLAPI PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
#define glGetTexLevelParameterfv glad_glGetTexLevelParameterfv
typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint *params);
GLAPI PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
#define glGetTexLevelParameteriv glad_glGetTexLevelParameteriv
typedef GLboolean (APIENTRYP PFNGLISENABLEDPROC)(GLenum cap);
GLAPI PFNGLISENABLEDPROC glad_glIsEnabled;
#define glIsEnabled glad_glIsEnabled
typedef void (APIENTRYP PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
GLAPI PFNGLDEPTHRANGEPROC glad_glDepthRange;
#define glDepthRange glad_glDepthRange
typedef void (APIENTRYP PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLVIEWPORTPROC glad_glViewport;
#define glViewport glad_glViewport
#endif
#ifndef GL_VERSION_1_1
#define GL_VERSION_1_1 1
GLAPI int GLAD_GL_VERSION_1_1;
typedef void (APIENTRYP PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
GLAPI PFNGLDRAWARRAYSPROC glad_glDrawArrays;
#define glDrawArrays glad_glDrawArrays
typedef void (APIENTRYP PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices);
GLAPI PFNGLDRAWELEMENTSPROC glad_glDrawElements;
#define glDrawElements glad_glDrawElements
typedef void (APIENTRYP PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
GLAPI PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
#define glPolygonOffset glad_glPolygonOffset
typedef void (APIENTRYP PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
GLAPI PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
#define glCopyTexImage1D glad_glCopyTexImage1D
typedef void (APIENTRYP PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
GLAPI PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
#define glCopyTexImage2D glad_glCopyTexImage2D
typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
GLAPI PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
#define glCopyTexSubImage1D glad_glCopyTexSubImage1D
typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
#define glCopyTexSubImage2D glad_glCopyTexSubImage2D
typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
#define glTexSubImage1D glad_glTexSubImage1D
typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
#define glTexSubImage2D glad_glTexSubImage2D
typedef void (APIENTRYP PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
GLAPI PFNGLBINDTEXTUREPROC glad_glBindTexture;
#define glBindTexture glad_glBindTexture
typedef void (APIENTRYP PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint *textures);
GLAPI PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
#define glDeleteTextures glad_glDeleteTextures
typedef void (APIENTRYP PFNGLGENTEXTURESPROC)(GLsizei n, GLuint *textures);
GLAPI PFNGLGENTEXTURESPROC glad_glGenTextures;
#define glGenTextures glad_glGenTextures
typedef GLboolean (APIENTRYP PFNGLISTEXTUREPROC)(GLuint texture);
GLAPI PFNGLISTEXTUREPROC glad_glIsTexture;
#define glIsTexture glad_glIsTexture
#endif
#ifndef GL_VERSION_1_2
#define GL_VERSION_1_2 1
GLAPI int GLAD_GL_VERSION_1_2;
typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
GLAPI PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
#define glDrawRangeElements glad_glDrawRangeElements
typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
#define glTexImage3D glad_glTexImage3D
typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
#define glTexSubImage3D glad_glTexSubImage3D
typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
#define glCopyTexSubImage3D glad_glCopyTexSubImage3D
#endif
#ifndef GL_VERSION_1_3
#define GL_VERSION_1_3 1
GLAPI int GLAD_GL_VERSION_1_3;
typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC)(GLenum texture);
GLAPI PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
#define glActiveTexture glad_glActiveTexture
typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
GLAPI PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
#define glSampleCoverage glad_glSampleCoverage
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
#define glCompressedTexImage3D glad_glCompressedTexImage3D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
#define glCompressedTexImage2D glad_glCompressedTexImage2D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
#define glCompressedTexImage1D glad_glCompressedTexImage1D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
#define glCompressedTexSubImage3D glad_glCompressedTexSubImage3D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
#define glCompressedTexSubImage2D glad_glCompressedTexSubImage2D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
#define glCompressedTexSubImage1D glad_glCompressedTexSubImage1D
typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void *img);
GLAPI PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
#define glGetCompressedTexImage glad_glGetCompressedTexImage
#endif
#ifndef GL_VERSION_1_4
#define GL_VERSION_1_4 1
GLAPI int GLAD_GL_VERSION_1_4;
typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
GLAPI PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
#define glBlendFuncSeparate glad_glBlendFuncSeparate
typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
GLAPI PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
#define glMultiDrawArrays glad_glMultiDrawArrays
typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
GLAPI PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
#define glMultiDrawElements glad_glMultiDrawElements
typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
GLAPI PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
#define glPointParameterf glad_glPointParameterf
typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat *params);
GLAPI PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
#define glPointParameterfv glad_glPointParameterfv
typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
GLAPI PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
#define glPointParameteri glad_glPointParameteri
typedef void (APIENTRYP PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint *params);
GLAPI PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
#define glPointParameteriv glad_glPointParameteriv
typedef void (APIENTRYP PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GLAPI PFNGLBLENDCOLORPROC glad_glBlendColor;
#define glBlendColor glad_glBlendColor
typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC)(GLenum mode);
GLAPI PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
#define glBlendEquation glad_glBlendEquation
#endif
#ifndef GL_VERSION_1_5
#define GL_VERSION_1_5 1
GLAPI int GLAD_GL_VERSION_1_5;
typedef void (APIENTRYP PFNGLGENQUERIESPROC)(GLsizei n, GLuint *ids);
GLAPI PFNGLGENQUERIESPROC glad_glGenQueries;
#define glGenQueries glad_glGenQueries
typedef void (APIENTRYP PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint *ids);
GLAPI PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
#define glDeleteQueries glad_glDeleteQueries
typedef GLboolean (APIENTRYP PFNGLISQUERYPROC)(GLuint id);
GLAPI PFNGLISQUERYPROC glad_glIsQuery;
#define glIsQuery glad_glIsQuery
typedef void (APIENTRYP PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
GLAPI PFNGLBEGINQUERYPROC glad_glBeginQuery;
#define glBeginQuery glad_glBeginQuery
typedef void (APIENTRYP PFNGLENDQUERYPROC)(GLenum target);
GLAPI PFNGLENDQUERYPROC glad_glEndQuery;
#define glEndQuery glad_glEndQuery
typedef void (APIENTRYP PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint *params);
GLAPI PFNGLGETQUERYIVPROC glad_glGetQueryiv;
#define glGetQueryiv glad_glGetQueryiv
typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint *params);
GLAPI PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
#define glGetQueryObjectiv glad_glGetQueryObjectiv
typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint *params);
GLAPI PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
#define glGetQueryObjectuiv glad_glGetQueryObjectuiv
typedef void (APIENTRYP PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
GLAPI PFNGLBINDBUFFERPROC glad_glBindBuffer;
#define glBindBuffer glad_glBindBuffer
typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint *buffers);
GLAPI PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
#define glDeleteBuffers glad_glDeleteBuffers
typedef void (APIENTRYP PFNGLGENBUFFERSPROC)(GLsizei n, GLuint *buffers);
GLAPI PFNGLGENBUFFERSPROC glad_glGenBuffers;
#define glGenBuffers glad_glGenBuffers
typedef GLboolean (APIENTRYP PFNGLISBUFFERPROC)(GLuint buffer);
GLAPI PFNGLISBUFFERPROC glad_glIsBuffer;
#define glIsBuffer glad_glIsBuffer
typedef void (APIENTRYP PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void *data, GLenum usage);
GLAPI PFNGLBUFFERDATAPROC glad_glBufferData;
#define glBufferData glad_glBufferData
typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
GLAPI PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
#define glBufferSubData glad_glBufferSubData
typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void *data);
GLAPI PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
#define glGetBufferSubData glad_glGetBufferSubData
typedef void * (APIENTRYP PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
GLAPI PFNGLMAPBUFFERPROC glad_glMapBuffer;
#define glMapBuffer glad_glMapBuffer
typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERPROC)(GLenum target);
GLAPI PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
#define glUnmapBuffer glad_glUnmapBuffer
typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
GLAPI PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
#define glGetBufferParameteriv glad_glGetBufferParameteriv
typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void **params);
GLAPI PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
#define glGetBufferPointerv glad_glGetBufferPointerv
#endif
#ifndef GL_VERSION_2_0
#define GL_VERSION_2_0 1
GLAPI int GLAD_GL_VERSION_2_0;
typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
GLAPI PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
#define glBlendEquationSeparate glad_glBlendEquationSeparate
typedef void (APIENTRYP PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum *bufs);
GLAPI PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
#define glDrawBuffers glad_glDrawBuffers
typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
GLAPI PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
#define glStencilOpSeparate glad_glStencilOpSeparate
typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
GLAPI PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
#define glStencilFuncSeparate glad_glStencilFuncSeparate
typedef void (APIENTRYP PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
GLAPI PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
#define glStencilMaskSeparate glad_glStencilMaskSeparate
typedef void (APIENTRYP PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
GLAPI PFNGLATTACHSHADERPROC glad_glAttachShader;
#define glAttachShader glad_glAttachShader
typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar *name);
GLAPI PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
#define glBindAttribLocation glad_glBindAttribLocation
typedef void (APIENTRYP PFNGLCOMPILESHADERPROC)(GLuint shader);
GLAPI PFNGLCOMPILESHADERPROC glad_glCompileShader;
#define glCompileShader glad_glCompileShader
typedef GLuint (APIENTRYP PFNGLCREATEPROGRAMPROC)(void);
GLAPI PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
#define glCreateProgram glad_glCreateProgram
typedef GLuint (APIENTRYP PFNGLCREATESHADERPROC)(GLenum type);
GLAPI PFNGLCREATESHADERPROC glad_glCreateShader;
#define glCreateShader glad_glCreateShader
typedef void (APIENTRYP PFNGLDELETEPROGRAMPROC)(GLuint program);
GLAPI PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
#define glDeleteProgram glad_glDeleteProgram
typedef void (APIENTRYP PFNGLDELETESHADERPROC)(GLuint shader);
GLAPI PFNGLDELETESHADERPROC glad_glDeleteShader;
#define glDeleteShader glad_glDeleteShader
typedef void (APIENTRYP PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
GLAPI PFNGLDETACHSHADERPROC glad_glDetachShader;
#define glDetachShader glad_glDetachShader
typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
GLAPI PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
#define glDisableVertexAttribArray glad_glDisableVertexAttribArray
typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
GLAPI PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
#define glEnableVertexAttribArray glad_glEnableVertexAttribArray
typedef void (APIENTRYP PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GLAPI PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
#define glGetActiveAttrib glad_glGetActiveAttrib
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GLAPI PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
#define glGetActiveUniform glad_glGetActiveUniform
typedef void (APIENTRYP PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
GLAPI PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
#define glGetAttachedShaders glad_glGetAttachedShaders
typedef GLint (APIENTRYP PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar *name);
GLAPI PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
#define glGetAttribLocation glad_glGetAttribLocation
typedef void (APIENTRYP PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint *params);
GLAPI PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
#define glGetProgramiv glad_glGetProgramiv
typedef void (APIENTRYP PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GLAPI PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
#define glGetProgramInfoLog glad_glGetProgramInfoLog
typedef void (APIENTRYP PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint *params);
GLAPI PFNGLGETSHADERIVPROC glad_glGetShaderiv;
#define glGetShaderiv glad_glGetShaderiv
typedef void (APIENTRYP PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GLAPI PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
#define glGetShaderInfoLog glad_glGetShaderInfoLog
typedef void (APIENTRYP PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
GLAPI PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
#define glGetShaderSource glad_glGetShaderSource
typedef GLint (APIENTRYP PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar *name);
GLAPI PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
#define glGetUniformLocation glad_glGetUniformLocation
typedef void (APIENTRYP PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat *params);
GLAPI PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
#define glGetUniformfv glad_glGetUniformfv
typedef void (APIENTRYP PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint *params);
GLAPI PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
#define glGetUniformiv glad_glGetUniformiv
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble *params);
GLAPI PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
#define glGetVertexAttribdv glad_glGetVertexAttribdv
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat *params);
GLAPI PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
#define glGetVertexAttribfv glad_glGetVertexAttribfv
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint *params);
GLAPI PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
#define glGetVertexAttribiv glad_glGetVertexAttribiv
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void **pointer);
GLAPI PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
#define glGetVertexAttribPointerv glad_glGetVertexAttribPointerv
typedef GLboolean (APIENTRYP PFNGLISPROGRAMPROC)(GLuint program);
GLAPI PFNGLISPROGRAMPROC glad_glIsProgram;
#define glIsProgram glad_glIsProgram
typedef GLboolean (APIENTRYP PFNGLISSHADERPROC)(GLuint shader);
GLAPI PFNGLISSHADERPROC glad_glIsShader;
#define glIsShader glad_glIsShader
typedef void (APIENTRYP PFNGLLINKPROGRAMPROC)(GLuint program);
GLAPI PFNGLLINKPROGRAMPROC glad_glLinkProgram;
#define glLinkProgram glad_glLinkProgram
typedef void (APIENTRYP PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
GLAPI PFNGLSHADERSOURCEPROC glad_glShaderSource;
#define glShaderSource glad_glShaderSource
typedef void (APIENTRYP PFNGLUSEPROGRAMPROC)(GLuint program);
GLAPI PFNGLUSEPROGRAMPROC glad_glUseProgram;
#define glUseProgram glad_glUseProgram
typedef void (APIENTRYP PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
GLAPI PFNGLUNIFORM1FPROC glad_glUniform1f;
#define glUniform1f glad_glUniform1f
typedef void (APIENTRYP PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
GLAPI PFNGLUNIFORM2FPROC glad_glUniform2f;
#define glUniform2f glad_glUniform2f
typedef void (APIENTRYP PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GLAPI PFNGLUNIFORM3FPROC glad_glUniform3f;
#define glUniform3f glad_glUniform3f
typedef void (APIENTRYP PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GLAPI PFNGLUNIFORM4FPROC glad_glUniform4f;
#define glUniform4f glad_glUniform4f
typedef void (APIENTRYP PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
GLAPI PFNGLUNIFORM1IPROC glad_glUniform1i;
#define glUniform1i glad_glUniform1i
typedef void (APIENTRYP PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
GLAPI PFNGLUNIFORM2IPROC glad_glUniform2i;
#define glUniform2i glad_glUniform2i
typedef void (APIENTRYP PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
GLAPI PFNGLUNIFORM3IPROC glad_glUniform3i;
#define glUniform3i glad_glUniform3i
typedef void (APIENTRYP PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GLAPI PFNGLUNIFORM4IPROC glad_glUniform4i;
#define glUniform4i glad_glUniform4i
typedef void (APIENTRYP PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLUNIFORM1FVPROC glad_glUniform1fv;
#define glUniform1fv glad_glUniform1fv
typedef void (APIENTRYP PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLUNIFORM2FVPROC glad_glUniform2fv;
#define glUniform2fv glad_glUniform2fv
typedef void (APIENTRYP PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLUNIFORM3FVPROC glad_glUniform3fv;
#define glUniform3fv glad_glUniform3fv
typedef void (APIENTRYP PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLUNIFORM4FVPROC glad_glUniform4fv;
#define glUniform4fv glad_glUniform4fv
typedef void (APIENTRYP PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLUNIFORM1IVPROC glad_glUniform1iv;
#define glUniform1iv glad_glUniform1iv
typedef void (APIENTRYP PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLUNIFORM2IVPROC glad_glUniform2iv;
#define glUniform2iv glad_glUniform2iv
typedef void (APIENTRYP PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLUNIFORM3IVPROC glad_glUniform3iv;
#define glUniform3iv glad_glUniform3iv
typedef void (APIENTRYP PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLUNIFORM4IVPROC glad_glUniform4iv;
#define glUniform4iv glad_glUniform4iv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
#define glUniformMatrix2fv glad_glUniformMatrix2fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
#define glUniformMatrix3fv glad_glUniformMatrix3fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
#define glUniformMatrix4fv glad_glUniformMatrix4fv
typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPROC)(GLuint program);
GLAPI PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
#define glValidateProgram glad_glValidateProgram
typedef void (APIENTRYP PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
GLAPI PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
#define glVertexAttrib1d glad_glVertexAttrib1d
typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
#define glVertexAttrib1dv glad_glVertexAttrib1dv
typedef void (APIENTRYP PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
GLAPI PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
#define glVertexAttrib1f glad_glVertexAttrib1f
typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat *v);
GLAPI PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
#define glVertexAttrib1fv glad_glVertexAttrib1fv
typedef void (APIENTRYP PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
GLAPI PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
#define glVertexAttrib1s glad_glVertexAttrib1s
typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort *v);
GLAPI PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
#define glVertexAttrib1sv glad_glVertexAttrib1sv
typedef void (APIENTRYP PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
GLAPI PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
#define glVertexAttrib2d glad_glVertexAttrib2d
typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
#define glVertexAttrib2dv glad_glVertexAttrib2dv
typedef void (APIENTRYP PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
GLAPI PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
#define glVertexAttrib2f glad_glVertexAttrib2f
typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat *v);
GLAPI PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
#define glVertexAttrib2fv glad_glVertexAttrib2fv
typedef void (APIENTRYP PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
GLAPI PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
#define glVertexAttrib2s glad_glVertexAttrib2s
typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort *v);
GLAPI PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
#define glVertexAttrib2sv glad_glVertexAttrib2sv
typedef void (APIENTRYP PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
GLAPI PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
#define glVertexAttrib3d glad_glVertexAttrib3d
typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
#define glVertexAttrib3dv glad_glVertexAttrib3dv
typedef void (APIENTRYP PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
GLAPI PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
#define glVertexAttrib3f glad_glVertexAttrib3f
typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat *v);
GLAPI PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
#define glVertexAttrib3fv glad_glVertexAttrib3fv
typedef void (APIENTRYP PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
GLAPI PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
#define glVertexAttrib3s glad_glVertexAttrib3s
typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort *v);
GLAPI PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
#define glVertexAttrib3sv glad_glVertexAttrib3sv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte *v);
GLAPI PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
#define glVertexAttrib4Nbv glad_glVertexAttrib4Nbv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
#define glVertexAttrib4Niv glad_glVertexAttrib4Niv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort *v);
GLAPI PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
#define glVertexAttrib4Nsv glad_glVertexAttrib4Nsv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
GLAPI PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
#define glVertexAttrib4Nub glad_glVertexAttrib4Nub
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte *v);
GLAPI PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
#define glVertexAttrib4Nubv glad_glVertexAttrib4Nubv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint *v);
GLAPI PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
#define glVertexAttrib4Nuiv glad_glVertexAttrib4Nuiv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort *v);
GLAPI PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
#define glVertexAttrib4Nusv glad_glVertexAttrib4Nusv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte *v);
GLAPI PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
#define glVertexAttrib4bv glad_glVertexAttrib4bv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
GLAPI PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
#define glVertexAttrib4d glad_glVertexAttrib4d
typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
#define glVertexAttrib4dv glad_glVertexAttrib4dv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
GLAPI PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
#define glVertexAttrib4f glad_glVertexAttrib4f
typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat *v);
GLAPI PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
#define glVertexAttrib4fv glad_glVertexAttrib4fv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
#define glVertexAttrib4iv glad_glVertexAttrib4iv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
GLAPI PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
#define glVertexAttrib4s glad_glVertexAttrib4s
typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort *v);
GLAPI PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
#define glVertexAttrib4sv glad_glVertexAttrib4sv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte *v);
GLAPI PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
#define glVertexAttrib4ubv glad_glVertexAttrib4ubv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint *v);
GLAPI PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
#define glVertexAttrib4uiv glad_glVertexAttrib4uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort *v);
GLAPI PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
#define glVertexAttrib4usv glad_glVertexAttrib4usv
typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
GLAPI PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
#define glVertexAttribPointer glad_glVertexAttribPointer
#endif
#ifndef GL_VERSION_2_1
#define GL_VERSION_2_1 1
GLAPI int GLAD_GL_VERSION_2_1;
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
#define glUniformMatrix2x3fv glad_glUniformMatrix2x3fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
#define glUniformMatrix3x2fv glad_glUniformMatrix3x2fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
#define glUniformMatrix2x4fv glad_glUniformMatrix2x4fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
#define glUniformMatrix4x2fv glad_glUniformMatrix4x2fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
#define glUniformMatrix3x4fv glad_glUniformMatrix3x4fv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
#define glUniformMatrix4x3fv glad_glUniformMatrix4x3fv
#endif
#ifndef GL_VERSION_3_0
#define GL_VERSION_3_0 1
GLAPI int GLAD_GL_VERSION_3_0;
typedef void (APIENTRYP PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
GLAPI PFNGLCOLORMASKIPROC glad_glColorMaski;
#define glColorMaski glad_glColorMaski
typedef void (APIENTRYP PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean *data);
GLAPI PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
#define glGetBooleani_v glad_glGetBooleani_v
typedef void (APIENTRYP PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint *data);
GLAPI PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
#define glGetIntegeri_v glad_glGetIntegeri_v
typedef void (APIENTRYP PFNGLENABLEIPROC)(GLenum target, GLuint index);
GLAPI PFNGLENABLEIPROC glad_glEnablei;
#define glEnablei glad_glEnablei
typedef void (APIENTRYP PFNGLDISABLEIPROC)(GLenum target, GLuint index);
GLAPI PFNGLDISABLEIPROC glad_glDisablei;
#define glDisablei glad_glDisablei
typedef GLboolean (APIENTRYP PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
GLAPI PFNGLISENABLEDIPROC glad_glIsEnabledi;
#define glIsEnabledi glad_glIsEnabledi
typedef void (APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
GLAPI PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
#define glBeginTransformFeedback glad_glBeginTransformFeedback
typedef void (APIENTRYP PFNGLENDTRANSFORMFEEDBACKPROC)(void);
GLAPI PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
#define glEndTransformFeedback glad_glEndTransformFeedback
typedef void (APIENTRYP PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
GLAPI PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
#define glBindBufferRange glad_glBindBufferRange
typedef void (APIENTRYP PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
GLAPI PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
#define glBindBufferBase glad_glBindBufferBase
typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
GLAPI PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
#define glTransformFeedbackVaryings glad_glTransformFeedbackVaryings
typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
GLAPI PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
#define glGetTransformFeedbackVarying glad_glGetTransformFeedbackVarying
typedef void (APIENTRYP PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
GLAPI PFNGLCLAMPCOLORPROC glad_glClampColor;
#define glClampColor glad_glClampColor
typedef void (APIENTRYP PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
GLAPI PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
#define glBeginConditionalRender glad_glBeginConditionalRender
typedef void (APIENTRYP PFNGLENDCONDITIONALRENDERPROC)(void);
GLAPI PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
#define glEndConditionalRender glad_glEndConditionalRender
typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
GLAPI PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
#define glVertexAttribIPointer glad_glVertexAttribIPointer
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint *params);
GLAPI PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
#define glGetVertexAttribIiv glad_glGetVertexAttribIiv
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint *params);
GLAPI PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
#define glGetVertexAttribIuiv glad_glGetVertexAttribIuiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
GLAPI PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
#define glVertexAttribI1i glad_glVertexAttribI1i
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
GLAPI PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
#define glVertexAttribI2i glad_glVertexAttribI2i
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
GLAPI PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
#define glVertexAttribI3i glad_glVertexAttribI3i
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
GLAPI PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
#define glVertexAttribI4i glad_glVertexAttribI4i
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
GLAPI PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
#define glVertexAttribI1ui glad_glVertexAttribI1ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
GLAPI PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
#define glVertexAttribI2ui glad_glVertexAttribI2ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
GLAPI PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
#define glVertexAttribI3ui glad_glVertexAttribI3ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
GLAPI PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
#define glVertexAttribI4ui glad_glVertexAttribI4ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
#define glVertexAttribI1iv glad_glVertexAttribI1iv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
#define glVertexAttribI2iv glad_glVertexAttribI2iv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
#define glVertexAttribI3iv glad_glVertexAttribI3iv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
#define glVertexAttribI4iv glad_glVertexAttribI4iv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint *v);
GLAPI PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
#define glVertexAttribI1uiv glad_glVertexAttribI1uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint *v);
GLAPI PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
#define glVertexAttribI2uiv glad_glVertexAttribI2uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint *v);
GLAPI PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
#define glVertexAttribI3uiv glad_glVertexAttribI3uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint *v);
GLAPI PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
#define glVertexAttribI4uiv glad_glVertexAttribI4uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte *v);
GLAPI PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
#define glVertexAttribI4bv glad_glVertexAttribI4bv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort *v);
GLAPI PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
#define glVertexAttribI4sv glad_glVertexAttribI4sv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte *v);
GLAPI PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
#define glVertexAttribI4ubv glad_glVertexAttribI4ubv
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort *v);
GLAPI PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
#define glVertexAttribI4usv glad_glVertexAttribI4usv
typedef void (APIENTRYP PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint *params);
GLAPI PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
#define glGetUniformuiv glad_glGetUniformuiv
typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar *name);
GLAPI PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
#define glBindFragDataLocation glad_glBindFragDataLocation
typedef GLint (APIENTRYP PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar *name);
GLAPI PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
#define glGetFragDataLocation glad_glGetFragDataLocation
typedef void (APIENTRYP PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
GLAPI PFNGLUNIFORM1UIPROC glad_glUniform1ui;
#define glUniform1ui glad_glUniform1ui
typedef void (APIENTRYP PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
GLAPI PFNGLUNIFORM2UIPROC glad_glUniform2ui;
#define glUniform2ui glad_glUniform2ui
typedef void (APIENTRYP PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
GLAPI PFNGLUNIFORM3UIPROC glad_glUniform3ui;
#define glUniform3ui glad_glUniform3ui
typedef void (APIENTRYP PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GLAPI PFNGLUNIFORM4UIPROC glad_glUniform4ui;
#define glUniform4ui glad_glUniform4ui
typedef void (APIENTRYP PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
#define glUniform1uiv glad_glUniform1uiv
typedef void (APIENTRYP PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
#define glUniform2uiv glad_glUniform2uiv
typedef void (APIENTRYP PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
#define glUniform3uiv glad_glUniform3uiv
typedef void (APIENTRYP PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
#define glUniform4uiv glad_glUniform4uiv
typedef void (APIENTRYP PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint *params);
GLAPI PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
#define glTexParameterIiv glad_glTexParameterIiv
typedef void (APIENTRYP PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint *params);
GLAPI PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
#define glTexParameterIuiv glad_glTexParameterIuiv
typedef void (APIENTRYP PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint *params);
GLAPI PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
#define glGetTexParameterIiv glad_glGetTexParameterIiv
typedef void (APIENTRYP PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint *params);
GLAPI PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
#define glGetTexParameterIuiv glad_glGetTexParameterIuiv
typedef void (APIENTRYP PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint *value);
GLAPI PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
#define glClearBufferiv glad_glClearBufferiv
typedef void (APIENTRYP PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint *value);
GLAPI PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
#define glClearBufferuiv glad_glClearBufferuiv
typedef void (APIENTRYP PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat *value);
GLAPI PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
#define glClearBufferfv glad_glClearBufferfv
typedef void (APIENTRYP PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
GLAPI PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
#define glClearBufferfi glad_glClearBufferfi
typedef const GLubyte * (APIENTRYP PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
GLAPI PFNGLGETSTRINGIPROC glad_glGetStringi;
#define glGetStringi glad_glGetStringi
typedef GLboolean (APIENTRYP PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
GLAPI PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
#define glIsRenderbuffer glad_glIsRenderbuffer
typedef void (APIENTRYP PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
GLAPI PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
#define glBindRenderbuffer glad_glBindRenderbuffer
typedef void (APIENTRYP PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint *renderbuffers);
GLAPI PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
#define glDeleteRenderbuffers glad_glDeleteRenderbuffers
typedef void (APIENTRYP PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
GLAPI PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
#define glGenRenderbuffers glad_glGenRenderbuffers
typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
#define glRenderbufferStorage glad_glRenderbufferStorage
typedef void (APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
GLAPI PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
#define glGetRenderbufferParameteriv glad_glGetRenderbufferParameteriv
typedef GLboolean (APIENTRYP PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
GLAPI PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
#define glIsFramebuffer glad_glIsFramebuffer
typedef void (APIENTRYP PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
GLAPI PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
#define glBindFramebuffer glad_glBindFramebuffer
typedef void (APIENTRYP PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint *framebuffers);
GLAPI PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
#define glDeleteFramebuffers glad_glDeleteFramebuffers
typedef void (APIENTRYP PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
GLAPI PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
#define glGenFramebuffers glad_glGenFramebuffers
typedef GLenum (APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
GLAPI PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
#define glCheckFramebufferStatus glad_glCheckFramebufferStatus
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GLAPI PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
#define glFramebufferTexture1D glad_glFramebufferTexture1D
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GLAPI PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
#define glFramebufferTexture2D glad_glFramebufferTexture2D
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
GLAPI PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
#define glFramebufferTexture3D glad_glFramebufferTexture3D
typedef void (APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GLAPI PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
#define glFramebufferRenderbuffer glad_glFramebufferRenderbuffer
typedef void (APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
GLAPI PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;
#define glGetFramebufferAttachmentParameteriv glad_glGetFramebufferAttachmentParameteriv
typedef void (APIENTRYP PFNGLGENERATEMIPMAPPROC)(GLenum target);
GLAPI PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
#define glGenerateMipmap glad_glGenerateMipmap
typedef void (APIENTRYP PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GLAPI PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
#define glBlitFramebuffer glad_glBlitFramebuffer
typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
#define glRenderbufferStorageMultisample glad_glRenderbufferStorageMultisample
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
GLAPI PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
#define glFramebufferTextureLayer glad_glFramebufferTextureLayer
typedef void * (APIENTRYP PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
GLAPI PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
#define glMapBufferRange glad_glMapBufferRange
typedef void (APIENTRYP PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
GLAPI PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
#define glFlushMappedBufferRange glad_glFlushMappedBufferRange
typedef void (APIENTRYP PFNGLBINDVERTEXARRAYPROC)(GLuint array);
GLAPI PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
#define glBindVertexArray glad_glBindVertexArray
typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint *arrays);
GLAPI PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
#define glDeleteVertexArrays glad_glDeleteVertexArrays
typedef void (APIENTRYP PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
GLAPI PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
#define glGenVertexArrays glad_glGenVertexArrays
typedef GLboolean (APIENTRYP PFNGLISVERTEXARRAYPROC)(GLuint array);
GLAPI PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
#define glIsVertexArray glad_glIsVertexArray
#endif
#ifndef GL_VERSION_3_1
#define GL_VERSION_3_1 1
GLAPI int GLAD_GL_VERSION_3_1;
typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
GLAPI PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
#define glDrawArraysInstanced glad_glDrawArraysInstanced
typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
GLAPI PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
#define glDrawElementsInstanced glad_glDrawElementsInstanced
typedef void (APIENTRYP PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
GLAPI PFNGLTEXBUFFERPROC glad_glTexBuffer;
#define glTexBuffer glad_glTexBuffer
typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
GLAPI PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
#define glPrimitiveRestartIndex glad_glPrimitiveRestartIndex
typedef void (APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
GLAPI PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
#define glCopyBufferSubData glad_glCopyBufferSubData
typedef void (APIENTRYP PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
GLAPI PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
#define glGetUniformIndices glad_glGetUniformIndices
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
GLAPI PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
#define glGetActiveUniformsiv glad_glGetActiveUniformsiv
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
GLAPI PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
#define glGetActiveUniformName glad_glGetActiveUniformName
typedef GLuint (APIENTRYP PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar *uniformBlockName);
GLAPI PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
#define glGetUniformBlockIndex glad_glGetUniformBlockIndex
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
GLAPI PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
#define glGetActiveUniformBlockiv glad_glGetActiveUniformBlockiv
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
GLAPI PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
#define glGetActiveUniformBlockName glad_glGetActiveUniformBlockName
typedef void (APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
GLAPI PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
#define glUniformBlockBinding glad_glUniformBlockBinding
#endif
#ifndef GL_VERSION_3_2
#define GL_VERSION_3_2 1
GLAPI int GLAD_GL_VERSION_3_2;
typedef void (APIENTRYP PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
GLAPI PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
#define glDrawElementsBaseVertex glad_glDrawElementsBaseVertex
typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
GLAPI PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
#define glDrawRangeElementsBaseVertex glad_glDrawRangeElementsBaseVertex
typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
GLAPI PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
#define glDrawElementsInstancedBaseVertex glad_glDrawElementsInstancedBaseVertex
typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
GLAPI PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
#define glMultiDrawElementsBaseVertex glad_glMultiDrawElementsBaseVertex
typedef void (APIENTRYP PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
GLAPI PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
#define glProvokingVertex glad_glProvokingVertex
typedef GLsync (APIENTRYP PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
GLAPI PFNGLFENCESYNCPROC glad_glFenceSync;
#define glFenceSync glad_glFenceSync
typedef GLboolean (APIENTRYP PFNGLISSYNCPROC)(GLsync sync);
GLAPI PFNGLISSYNCPROC glad_glIsSync;
#define glIsSync glad_glIsSync
typedef void (APIENTRYP PFNGLDELETESYNCPROC)(GLsync sync);
GLAPI PFNGLDELETESYNCPROC glad_glDeleteSync;
#define glDeleteSync glad_glDeleteSync
typedef GLenum (APIENTRYP PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
GLAPI PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
#define glClientWaitSync glad_glClientWaitSync
typedef void (APIENTRYP PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
GLAPI PFNGLWAITSYNCPROC glad_glWaitSync;
#define glWaitSync glad_glWaitSync
typedef void (APIENTRYP PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 *data);
GLAPI PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
#define glGetInteger64v glad_glGetInteger64v
typedef void (APIENTRYP PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
GLAPI PFNGLGETSYNCIVPROC glad_glGetSynciv;
#define glGetSynciv glad_glGetSynciv
typedef void (APIENTRYP PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 *data);
GLAPI PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
#define glGetInteger64i_v glad_glGetInteger64i_v
typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 *params);
GLAPI PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
#define glGetBufferParameteri64v glad_glGetBufferParameteri64v
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
GLAPI PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
#define glFramebufferTexture glad_glFramebufferTexture
typedef void (APIENTRYP PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GLAPI PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
#define glTexImage2DMultisample glad_glTexImage2DMultisample
typedef void (APIENTRYP PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GLAPI PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
#define glTexImage3DMultisample glad_glTexImage3DMultisample
typedef void (APIENTRYP PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat *val);
GLAPI PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
#define glGetMultisamplefv glad_glGetMultisamplefv
typedef void (APIENTRYP PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
GLAPI PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
#define glSampleMaski glad_glSampleMaski
#endif
#ifndef GL_VERSION_3_3
#define GL_VERSION_3_3 1
GLAPI int GLAD_GL_VERSION_3_3;
typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
GLAPI PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
#define glBindFragDataLocationIndexed glad_glBindFragDataLocationIndexed
typedef GLint (APIENTRYP PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar *name);
GLAPI PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
#define glGetFragDataIndex glad_glGetFragDataIndex
typedef void (APIENTRYP PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint *samplers);
GLAPI PFNGLGENSAMPLERSPROC glad_glGenSamplers;
#define glGenSamplers glad_glGenSamplers
typedef void (APIENTRYP PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint *samplers);
GLAPI PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
#define glDeleteSamplers glad_glDeleteSamplers
typedef GLboolean (APIENTRYP PFNGLISSAMPLERPROC)(GLuint sampler);
GLAPI PFNGLISSAMPLERPROC glad_glIsSampler;
#define glIsSampler glad_glIsSampler
typedef void (APIENTRYP PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
GLAPI PFNGLBINDSAMPLERPROC glad_glBindSampler;
#define glBindSampler glad_glBindSampler
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
GLAPI PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
#define glSamplerParameteri glad_glSamplerParameteri
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
GLAPI PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
#define glSamplerParameteriv glad_glSamplerParameteriv
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
GLAPI PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
#define glSamplerParameterf glad_glSamplerParameterf
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat *param);
GLAPI PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
#define glSamplerParameterfv glad_glSamplerParameterfv
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
GLAPI PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
#define glSamplerParameterIiv glad_glSamplerParameterIiv
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint *param);
GLAPI PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
#define glSamplerParameterIuiv glad_glSamplerParameterIuiv
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint *params);
GLAPI PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
#define glGetSamplerParameteriv glad_glGetSamplerParameteriv
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint *params);
GLAPI PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
#define glGetSamplerParameterIiv glad_glGetSamplerParameterIiv
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat *params);
GLAPI PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
#define glGetSamplerParameterfv glad_glGetSamplerParameterfv
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint *params);
GLAPI PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
#define glGetSamplerParameterIuiv glad_glGetSamplerParameterIuiv
typedef void (APIENTRYP PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
GLAPI PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
#define glQueryCounter glad_glQueryCounter
typedef void (APIENTRYP PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 *params);
GLAPI PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
#define glGetQueryObjecti64v glad_glGetQueryObjecti64v
typedef void (APIENTRYP PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 *params);
GLAPI PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
#define glGetQueryObjectui64v glad_glGetQueryObjectui64v
typedef void (APIENTRYP PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
GLAPI PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
#define glVertexAttribDivisor glad_glVertexAttribDivisor
typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
#define glVertexAttribP1ui glad_glVertexAttribP1ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
#define glVertexAttribP1uiv glad_glVertexAttribP1uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
#define glVertexAttribP2ui glad_glVertexAttribP2ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
#define glVertexAttribP2uiv glad_glVertexAttribP2uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
#define glVertexAttribP3ui glad_glVertexAttribP3ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
#define glVertexAttribP3uiv glad_glVertexAttribP3uiv
typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
#define glVertexAttribP4ui glad_glVertexAttribP4ui
typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
#define glVertexAttribP4uiv glad_glVertexAttribP4uiv
typedef void (APIENTRYP PFNGLVERTEXP2UIPROC)(GLenum type, GLuint value);
GLAPI PFNGLVERTEXP2UIPROC glad_glVertexP2ui;
#define glVertexP2ui glad_glVertexP2ui
typedef void (APIENTRYP PFNGLVERTEXP2UIVPROC)(GLenum type, const GLuint *value);
GLAPI PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv;
#define glVertexP2uiv glad_glVertexP2uiv
typedef void (APIENTRYP PFNGLVERTEXP3UIPROC)(GLenum type, GLuint value);
GLAPI PFNGLVERTEXP3UIPROC glad_glVertexP3ui;
#define glVertexP3ui glad_glVertexP3ui
typedef void (APIENTRYP PFNGLVERTEXP3UIVPROC)(GLenum type, const GLuint *value);
GLAPI PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv;
#define glVertexP3uiv glad_glVertexP3uiv
typedef void (APIENTRYP PFNGLVERTEXP4UIPROC)(GLenum type, GLuint value);
GLAPI PFNGLVERTEXP4UIPROC glad_glVertexP4ui;
#define glVertexP4ui glad_glVertexP4ui
typedef void (APIENTRYP PFNGLVERTEXP4UIVPROC)(GLenum type, const GLuint *value);
GLAPI PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv;
#define glVertexP4uiv glad_glVertexP4uiv
typedef void (APIENTRYP PFNGLTEXCOORDP1UIPROC)(GLenum type, GLuint coords);
GLAPI PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui;
#define glTexCoordP1ui glad_glTexCoordP1ui
typedef void (APIENTRYP PFNGLTEXCOORDP1UIVPROC)(GLenum type, const GLuint *coords);
GLAPI PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv;
#define glTexCoordP1uiv glad_glTexCoordP1uiv
typedef void (APIENTRYP PFNGLTEXCOORDP2UIPROC)(GLenum type, GLuint coords);
GLAPI PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui;
#define glTexCoordP2ui glad_glTexCoordP2ui
typedef void (APIENTRYP PFNGLTEXCOORDP2UIVPROC)(GLenum type, const GLuint *coords);
GLAPI PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv;
#define glTexCoordP2uiv glad_glTexCoordP2uiv
typedef void (APIENTRYP PFNGLTEXCOORDP3UIPROC)(GLenum type, GLuint coords);
GLAPI PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui;
#define glTexCoordP3ui glad_glTexCoordP3ui
typedef void (APIENTRYP PFNGLTEXCOORDP3UIVPROC)(GLenum type, const GLuint *coords);
GLAPI PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv;
#define glTexCoordP3uiv glad_glTexCoordP3uiv
typedef void (APIENTRYP PFNGLTEXCOORDP4UIPROC)(GLenum type, GLuint coords);
GLAPI PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui;
#define glTexCoordP4ui glad_glTexCoordP4ui
typedef void (APIENTRYP PFNGLTEXCOORDP4UIVPROC)(GLenum type, const GLuint *coords);
GLAPI PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv;
#define glTexCoordP4uiv glad_glTexCoordP4uiv
typedef void (APIENTRYP PFNGLMULTITEXCOORDP1UIPROC)(GLenum texture, GLenum type, GLuint coords);
GLAPI PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui;
#define glMultiTexCoordP1ui glad_glMultiTexCoordP1ui
typedef void (APIENTRYP PFNGLMULTITEXCOORDP1UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
GLAPI PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv;
#define glMultiTexCoordP1uiv glad_glMultiTexCoordP1uiv
typedef void (APIENTRYP PFNGLMULTITEXCOORDP2UIPROC)(GLenum texture, GLenum type, GLuint coords);
GLAPI PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui;
#define glMultiTexCoordP2ui glad_glMultiTexCoordP2ui
typedef void (APIENTRYP PFNGLMULTITEXCOORDP2UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
GLAPI PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv;
#define glMultiTexCoordP2uiv glad_glMultiTexCoordP2uiv
typedef void (APIENTRYP PFNGLMULTITEXCOORDP3UIPROC)(GLenum texture, GLenum type, GLuint coords);
GLAPI PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui;
#define glMultiTexCoordP3ui glad_glMultiTexCoordP3ui
typedef void (APIENTRYP PFNGLMULTITEXCOORDP3UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
GLAPI PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv;
#define glMultiTexCoordP3uiv glad_glMultiTexCoordP3uiv
typedef void (APIENTRYP PFNGLMULTITEXCOORDP4UIPROC)(GLenum texture, GLenum type, GLuint coords);
GLAPI PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui;
#define glMultiTexCoordP4ui glad_glMultiTexCoordP4ui
typedef void (APIENTRYP PFNGLMULTITEXCOORDP4UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
GLAPI PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv;
#define glMultiTexCoordP4uiv glad_glMultiTexCoordP4uiv
typedef void (APIENTRYP PFNGLNORMALP3UIPROC)(GLenum type, GLuint coords);
GLAPI PFNGLNORMALP3UIPROC glad_glNormalP3ui;
#define glNormalP3ui glad_glNormalP3ui
typedef void (APIENTRYP PFNGLNORMALP3UIVPROC)(GLenum type, const GLuint *coords);
GLAPI PFNGLNORMALP3UIVPROC glad_glNormalP3uiv;
#define glNormalP3uiv glad_glNormalP3uiv
typedef void (APIENTRYP PFNGLCOLORP3UIPROC)(GLenum type, GLuint color);
GLAPI PFNGLCOLORP3UIPROC glad_glColorP3ui;
#define glColorP3ui glad_glColorP3ui
typedef void (APIENTRYP PFNGLCOLORP3UIVPROC)(GLenum type, const GLuint *color);
GLAPI PFNGLCOLORP3UIVPROC glad_glColorP3uiv;
#define glColorP3uiv glad_glColorP3uiv
typedef void (APIENTRYP PFNGLCOLORP4UIPROC)(GLenum type, GLuint color);
GLAPI PFNGLCOLORP4UIPROC glad_glColorP4ui;
#define glColorP4ui glad_glColorP4ui
typedef void (APIENTRYP PFNGLCOLORP4UIVPROC)(GLenum type, const GLuint *color);
GLAPI PFNGLCOLORP4UIVPROC glad_glColorP4uiv;
#define glColorP4uiv glad_glColorP4uiv
typedef void (APIENTRYP PFNGLSECONDARYCOLORP3UIPROC)(GLenum type, GLuint color);
GLAPI PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui;
#define glSecondaryColorP3ui glad_glSecondaryColorP3ui
typedef void (APIENTRYP PFNGLSECONDARYCOLORP3UIVPROC)(GLenum type, const GLuint *color);
GLAPI PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv;
#define glSecondaryColorP3uiv glad_glSecondaryColorP3uiv
#endif
#ifndef GL_VERSION_4_0
#define GL_VERSION_4_0 1
GLAPI int GLAD_GL_VERSION_4_0;
typedef void (APIENTRYP PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
GLAPI PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;
#define glMinSampleShading glad_glMinSampleShading
typedef void (APIENTRYP PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
GLAPI PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;
#define glBlendEquationi glad_glBlendEquationi
typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
GLAPI PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;
#define glBlendEquationSeparatei glad_glBlendEquationSeparatei
typedef void (APIENTRYP PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
GLAPI PFNGLBLENDFUNCIPROC glad_glBlendFunci;
#define glBlendFunci glad_glBlendFunci
typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
GLAPI PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;
#define glBlendFuncSeparatei glad_glBlendFuncSeparatei
typedef void (APIENTRYP PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect);
GLAPI PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;
#define glDrawArraysIndirect glad_glDrawArraysIndirect
typedef void (APIENTRYP PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect);
GLAPI PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;
#define glDrawElementsIndirect glad_glDrawElementsIndirect
typedef void (APIENTRYP PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
GLAPI PFNGLUNIFORM1DPROC glad_glUniform1d;
#define glUniform1d glad_glUniform1d
typedef void (APIENTRYP PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
GLAPI PFNGLUNIFORM2DPROC glad_glUniform2d;
#define glUniform2d glad_glUniform2d
typedef void (APIENTRYP PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
GLAPI PFNGLUNIFORM3DPROC glad_glUniform3d;
#define glUniform3d glad_glUniform3d
typedef void (APIENTRYP PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
GLAPI PFNGLUNIFORM4DPROC glad_glUniform4d;
#define glUniform4d glad_glUniform4d
typedef void (APIENTRYP PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLUNIFORM1DVPROC glad_glUniform1dv;
#define glUniform1dv glad_glUniform1dv
typedef void (APIENTRYP PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLUNIFORM2DVPROC glad_glUniform2dv;
#define glUniform2dv glad_glUniform2dv
typedef void (APIENTRYP PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLUNIFORM3DVPROC glad_glUniform3dv;
#define glUniform3dv glad_glUniform3dv
typedef void (APIENTRYP PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLUNIFORM4DVPROC glad_glUniform4dv;
#define glUniform4dv glad_glUniform4dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;
#define glUniformMatrix2dv glad_glUniformMatrix2dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;
#define glUniformMatrix3dv glad_glUniformMatrix3dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;
#define glUniformMatrix4dv glad_glUniformMatrix4dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;
#define glUniformMatrix2x3dv glad_glUniformMatrix2x3dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;
#define glUniformMatrix2x4dv glad_glUniformMatrix2x4dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;
#define glUniformMatrix3x2dv glad_glUniformMatrix3x2dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;
#define glUniformMatrix3x4dv glad_glUniformMatrix3x4dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;
#define glUniformMatrix4x2dv glad_glUniformMatrix4x2dv
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;
#define glUniformMatrix4x3dv glad_glUniformMatrix4x3dv
typedef void (APIENTRYP PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble *params);
GLAPI PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;
#define glGetUniformdv glad_glGetUniformdv
typedef GLint (APIENTRYP PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar *name);
GLAPI PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;
#define glGetSubroutineUniformLocation glad_glGetSubroutineUniformLocation
typedef GLuint (APIENTRYP PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar *name);
GLAPI PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;
#define glGetSubroutineIndex glad_glGetSubroutineIndex
typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
GLAPI PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;
#define glGetActiveSubroutineUniformiv glad_glGetActiveSubroutineUniformiv
typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GLAPI PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;
#define glGetActiveSubroutineUniformName glad_glGetActiveSubroutineUniformName
typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GLAPI PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;
#define glGetActiveSubroutineName glad_glGetActiveSubroutineName
typedef void (APIENTRYP PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint *indices);
GLAPI PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;
#define glUniformSubroutinesuiv glad_glUniformSubroutinesuiv
typedef void (APIENTRYP PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint *params);
GLAPI PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;
#define glGetUniformSubroutineuiv glad_glGetUniformSubroutineuiv
typedef void (APIENTRYP PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
GLAPI PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;
#define glGetProgramStageiv glad_glGetProgramStageiv
typedef void (APIENTRYP PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
GLAPI PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;
#define glPatchParameteri glad_glPatchParameteri
typedef void (APIENTRYP PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat *values);
GLAPI PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;
#define glPatchParameterfv glad_glPatchParameterfv
typedef void (APIENTRYP PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
GLAPI PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;
#define glBindTransformFeedback glad_glBindTransformFeedback
typedef void (APIENTRYP PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint *ids);
GLAPI PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;
#define glDeleteTransformFeedbacks glad_glDeleteTransformFeedbacks
typedef void (APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
GLAPI PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;
#define glGenTransformFeedbacks glad_glGenTransformFeedbacks
typedef GLboolean (APIENTRYP PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
GLAPI PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;
#define glIsTransformFeedback glad_glIsTransformFeedback
typedef void (APIENTRYP PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
GLAPI PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;
#define glPauseTransformFeedback glad_glPauseTransformFeedback
typedef void (APIENTRYP PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
GLAPI PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;
#define glResumeTransformFeedback glad_glResumeTransformFeedback
typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
GLAPI PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;
#define glDrawTransformFeedback glad_glDrawTransformFeedback
typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
GLAPI PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;
#define glDrawTransformFeedbackStream glad_glDrawTransformFeedbackStream
typedef void (APIENTRYP PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
GLAPI PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;
#define glBeginQueryIndexed glad_glBeginQueryIndexed
typedef void (APIENTRYP PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
GLAPI PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;
#define glEndQueryIndexed glad_glEndQueryIndexed
typedef void (APIENTRYP PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
GLAPI PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;
#define glGetQueryIndexediv glad_glGetQueryIndexediv
#endif
#ifndef GL_VERSION_4_1
#define GL_VERSION_4_1 1
GLAPI int GLAD_GL_VERSION_4_1;
typedef void (APIENTRYP PFNGLRELEASESHADERCOMPILERPROC)(void);
GLAPI PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;
#define glReleaseShaderCompiler glad_glReleaseShaderCompiler
typedef void (APIENTRYP PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
GLAPI PFNGLSHADERBINARYPROC glad_glShaderBinary;
#define glShaderBinary glad_glShaderBinary
typedef void (APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
GLAPI PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;
#define glGetShaderPrecisionFormat glad_glGetShaderPrecisionFormat
typedef void (APIENTRYP PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
GLAPI PFNGLDEPTHRANGEFPROC glad_glDepthRangef;
#define glDepthRangef glad_glDepthRangef
typedef void (APIENTRYP PFNGLCLEARDEPTHFPROC)(GLfloat d);
GLAPI PFNGLCLEARDEPTHFPROC glad_glClearDepthf;
#define glClearDepthf glad_glClearDepthf
typedef void (APIENTRYP PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
GLAPI PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;
#define glGetProgramBinary glad_glGetProgramBinary
typedef void (APIENTRYP PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
GLAPI PFNGLPROGRAMBINARYPROC glad_glProgramBinary;
#define glProgramBinary glad_glProgramBinary
typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
GLAPI PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;
#define glProgramParameteri glad_glProgramParameteri
typedef void (APIENTRYP PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
GLAPI PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;
#define glUseProgramStages glad_glUseProgramStages
typedef void (APIENTRYP PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
GLAPI PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;
#define glActiveShaderProgram glad_glActiveShaderProgram
typedef GLuint (APIENTRYP PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const*strings);
GLAPI PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;
#define glCreateShaderProgramv glad_glCreateShaderProgramv
typedef void (APIENTRYP PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
GLAPI PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;
#define glBindProgramPipeline glad_glBindProgramPipeline
typedef void (APIENTRYP PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint *pipelines);
GLAPI PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;
#define glDeleteProgramPipelines glad_glDeleteProgramPipelines
typedef void (APIENTRYP PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint *pipelines);
GLAPI PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;
#define glGenProgramPipelines glad_glGenProgramPipelines
typedef GLboolean (APIENTRYP PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
GLAPI PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;
#define glIsProgramPipeline glad_glIsProgramPipeline
typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint *params);
GLAPI PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;
#define glGetProgramPipelineiv glad_glGetProgramPipelineiv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
GLAPI PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;
#define glProgramUniform1i glad_glProgramUniform1i
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;
#define glProgramUniform1iv glad_glProgramUniform1iv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
GLAPI PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;
#define glProgramUniform1f glad_glProgramUniform1f
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;
#define glProgramUniform1fv glad_glProgramUniform1fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
GLAPI PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;
#define glProgramUniform1d glad_glProgramUniform1d
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;
#define glProgramUniform1dv glad_glProgramUniform1dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
GLAPI PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;
#define glProgramUniform1ui glad_glProgramUniform1ui
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;
#define glProgramUniform1uiv glad_glProgramUniform1uiv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
GLAPI PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;
#define glProgramUniform2i glad_glProgramUniform2i
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;
#define glProgramUniform2iv glad_glProgramUniform2iv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
GLAPI PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;
#define glProgramUniform2f glad_glProgramUniform2f
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;
#define glProgramUniform2fv glad_glProgramUniform2fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
GLAPI PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;
#define glProgramUniform2d glad_glProgramUniform2d
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;
#define glProgramUniform2dv glad_glProgramUniform2dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
GLAPI PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;
#define glProgramUniform2ui glad_glProgramUniform2ui
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;
#define glProgramUniform2uiv glad_glProgramUniform2uiv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
GLAPI PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;
#define glProgramUniform3i glad_glProgramUniform3i
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;
#define glProgramUniform3iv glad_glProgramUniform3iv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GLAPI PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;
#define glProgramUniform3f glad_glProgramUniform3f
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;
#define glProgramUniform3fv glad_glProgramUniform3fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
GLAPI PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;
#define glProgramUniform3d glad_glProgramUniform3d
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;
#define glProgramUniform3dv glad_glProgramUniform3dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
GLAPI PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;
#define glProgramUniform3ui glad_glProgramUniform3ui
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;
#define glProgramUniform3uiv glad_glProgramUniform3uiv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GLAPI PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;
#define glProgramUniform4i glad_glProgramUniform4i
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;
#define glProgramUniform4iv glad_glProgramUniform4iv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GLAPI PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;
#define glProgramUniform4f glad_glProgramUniform4f
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;
#define glProgramUniform4fv glad_glProgramUniform4fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
GLAPI PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;
#define glProgramUniform4d glad_glProgramUniform4d
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;
#define glProgramUniform4dv glad_glProgramUniform4dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GLAPI PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;
#define glProgramUniform4ui glad_glProgramUniform4ui
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;
#define glProgramUniform4uiv glad_glProgramUniform4uiv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;
#define glProgramUniformMatrix2fv glad_glProgramUniformMatrix2fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;
#define glProgramUniformMatrix3fv glad_glProgramUniformMatrix3fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;
#define glProgramUniformMatrix4fv glad_glProgramUniformMatrix4fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;
#define glProgramUniformMatrix2dv glad_glProgramUniformMatrix2dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;
#define glProgramUniformMatrix3dv glad_glProgramUniformMatrix3dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;
#define glProgramUniformMatrix4dv glad_glProgramUniformMatrix4dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;
#define glProgramUniformMatrix2x3fv glad_glProgramUniformMatrix2x3fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;
#define glProgramUniformMatrix3x2fv glad_glProgramUniformMatrix3x2fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;
#define glProgramUniformMatrix2x4fv glad_glProgramUniformMatrix2x4fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;
#define glProgramUniformMatrix4x2fv glad_glProgramUniformMatrix4x2fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;
#define glProgramUniformMatrix3x4fv glad_glProgramUniformMatrix3x4fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;
#define glProgramUniformMatrix4x3fv glad_glProgramUniformMatrix4x3fv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;
#define glProgramUniformMatrix2x3dv glad_glProgramUniformMatrix2x3dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;
#define glProgramUniformMatrix3x2dv glad_glProgramUniformMatrix3x2dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;
#define glProgramUniformMatrix2x4dv glad_glProgramUniformMatrix2x4dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;
#define glProgramUniformMatrix4x2dv glad_glProgramUniformMatrix4x2dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;
#define glProgramUniformMatrix3x4dv glad_glProgramUniformMatrix3x4dv
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;
#define glProgramUniformMatrix4x3dv glad_glProgramUniformMatrix4x3dv
typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
GLAPI PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;
#define glValidateProgramPipeline glad_glValidateProgramPipeline
typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GLAPI PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;
#define glGetProgramPipelineInfoLog glad_glGetProgramPipelineInfoLog
typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
GLAPI PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;
#define glVertexAttribL1d glad_glVertexAttribL1d
typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
GLAPI PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;
#define glVertexAttribL2d glad_glVertexAttribL2d
typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
GLAPI PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;
#define glVertexAttribL3d glad_glVertexAttribL3d
typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
GLAPI PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;
#define glVertexAttribL4d glad_glVertexAttribL4d
typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;
#define glVertexAttribL1dv glad_glVertexAttribL1dv
typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;
#define glVertexAttribL2dv glad_glVertexAttribL2dv
typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;
#define glVertexAttribL3dv glad_glVertexAttribL3dv
typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble *v);
GLAPI PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;
#define glVertexAttribL4dv glad_glVertexAttribL4dv
typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
GLAPI PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;
#define glVertexAttribLPointer glad_glVertexAttribLPointer
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble *params);
GLAPI PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;
#define glGetVertexAttribLdv glad_glGetVertexAttribLdv
typedef void (APIENTRYP PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat *v);
GLAPI PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;
#define glViewportArrayv glad_glViewportArrayv
typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
GLAPI PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;
#define glViewportIndexedf glad_glViewportIndexedf
typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat *v);
GLAPI PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;
#define glViewportIndexedfv glad_glViewportIndexedfv
typedef void (APIENTRYP PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint *v);
GLAPI PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;
#define glScissorArrayv glad_glScissorArrayv
typedef void (APIENTRYP PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
GLAPI PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;
#define glScissorIndexed glad_glScissorIndexed
typedef void (APIENTRYP PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint *v);
GLAPI PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;
#define glScissorIndexedv glad_glScissorIndexedv
typedef void (APIENTRYP PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble *v);
GLAPI PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;
#define glDepthRangeArrayv glad_glDepthRangeArrayv
typedef void (APIENTRYP PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
GLAPI PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;
#define glDepthRangeIndexed glad_glDepthRangeIndexed
typedef void (APIENTRYP PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat *data);
GLAPI PFNGLGETFLOATI_VPROC glad_glGetFloati_v;
#define glGetFloati_v glad_glGetFloati_v
typedef void (APIENTRYP PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble *data);
GLAPI PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;
#define glGetDoublei_v glad_glGetDoublei_v
#endif
#ifndef GL_VERSION_4_2
#define GL_VERSION_4_2 1
GLAPI int GLAD_GL_VERSION_4_2;
typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
GLAPI PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;
#define glDrawArraysInstancedBaseInstance glad_glDrawArraysInstancedBaseInstance
typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
GLAPI PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;
#define glDrawElementsInstancedBaseInstance glad_glDrawElementsInstancedBaseInstance
typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
GLAPI PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;
#define glDrawElementsInstancedBaseVertexBaseInstance glad_glDrawElementsInstancedBaseVertexBaseInstance
typedef void (APIENTRYP PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
GLAPI PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;
#define glGetInternalformativ glad_glGetInternalformativ
typedef void (APIENTRYP PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
GLAPI PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;
#define glGetActiveAtomicCounterBufferiv glad_glGetActiveAtomicCounterBufferiv
typedef void (APIENTRYP PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
GLAPI PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;
#define glBindImageTexture glad_glBindImageTexture
typedef void (APIENTRYP PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
GLAPI PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;
#define glMemoryBarrier glad_glMemoryBarrier
typedef void (APIENTRYP PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
GLAPI PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;
#define glTexStorage1D glad_glTexStorage1D
typedef void (APIENTRYP PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;
#define glTexStorage2D glad_glTexStorage2D
typedef void (APIENTRYP PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
GLAPI PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;
#define glTexStorage3D glad_glTexStorage3D
typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
GLAPI PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;
#define glDrawTransformFeedbackInstanced glad_glDrawTransformFeedbackInstanced
typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
GLAPI PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;
#define glDrawTransformFeedbackStreamInstanced glad_glDrawTransformFeedbackStreamInstanced
#endif
#ifndef GL_VERSION_4_3
#define GL_VERSION_4_3 1
GLAPI int GLAD_GL_VERSION_4_3;
typedef void (APIENTRYP PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
GLAPI PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;
#define glClearBufferData glad_glClearBufferData
typedef void (APIENTRYP PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
GLAPI PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;
#define glClearBufferSubData glad_glClearBufferSubData
typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
GLAPI PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;
#define glDispatchCompute glad_glDispatchCompute
typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
GLAPI PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;
#define glDispatchComputeIndirect glad_glDispatchComputeIndirect
typedef void (APIENTRYP PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
GLAPI PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;
#define glCopyImageSubData glad_glCopyImageSubData
typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
GLAPI PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;
#define glFramebufferParameteri glad_glFramebufferParameteri
typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
GLAPI PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;
#define glGetFramebufferParameteriv glad_glGetFramebufferParameteriv
typedef void (APIENTRYP PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
GLAPI PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;
#define glGetInternalformati64v glad_glGetInternalformati64v
typedef void (APIENTRYP PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
GLAPI PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;
#define glInvalidateTexSubImage glad_glInvalidateTexSubImage
typedef void (APIENTRYP PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
GLAPI PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;
#define glInvalidateTexImage glad_glInvalidateTexImage
typedef void (APIENTRYP PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
GLAPI PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;
#define glInvalidateBufferSubData glad_glInvalidateBufferSubData
typedef void (APIENTRYP PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
GLAPI PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;
#define glInvalidateBufferData glad_glInvalidateBufferData
typedef void (APIENTRYP PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum *attachments);
GLAPI PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;
#define glInvalidateFramebuffer glad_glInvalidateFramebuffer
typedef void (APIENTRYP PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;
#define glInvalidateSubFramebuffer glad_glInvalidateSubFramebuffer
typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
GLAPI PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;
#define glMultiDrawArraysIndirect glad_glMultiDrawArraysIndirect
typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
GLAPI PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;
#define glMultiDrawElementsIndirect glad_glMultiDrawElementsIndirect
typedef void (APIENTRYP PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
GLAPI PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;
#define glGetProgramInterfaceiv glad_glGetProgramInterfaceiv
typedef GLuint (APIENTRYP PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar *name);
GLAPI PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;
#define glGetProgramResourceIndex glad_glGetProgramResourceIndex
typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
GLAPI PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;
#define glGetProgramResourceName glad_glGetProgramResourceName
typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
GLAPI PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;
#define glGetProgramResourceiv glad_glGetProgramResourceiv
typedef GLint (APIENTRYP PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar *name);
GLAPI PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;
#define glGetProgramResourceLocation glad_glGetProgramResourceLocation
typedef GLint (APIENTRYP PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar *name);
GLAPI PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;
#define glGetProgramResourceLocationIndex glad_glGetProgramResourceLocationIndex
typedef void (APIENTRYP PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
GLAPI PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;
#define glShaderStorageBlockBinding glad_glShaderStorageBlockBinding
typedef void (APIENTRYP PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
GLAPI PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;
#define glTexBufferRange glad_glTexBufferRange
typedef void (APIENTRYP PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GLAPI PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;
#define glTexStorage2DMultisample glad_glTexStorage2DMultisample
typedef void (APIENTRYP PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GLAPI PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;
#define glTexStorage3DMultisample glad_glTexStorage3DMultisample
typedef void (APIENTRYP PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
GLAPI PFNGLTEXTUREVIEWPROC glad_glTextureView;
#define glTextureView glad_glTextureView
typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
GLAPI PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;
#define glBindVertexBuffer glad_glBindVertexBuffer
typedef void (APIENTRYP PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
GLAPI PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;
#define glVertexAttribFormat glad_glVertexAttribFormat
typedef void (APIENTRYP PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GLAPI PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;
#define glVertexAttribIFormat glad_glVertexAttribIFormat
typedef void (APIENTRYP PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GLAPI PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;
#define glVertexAttribLFormat glad_glVertexAttribLFormat
typedef void (APIENTRYP PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
GLAPI PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;
#define glVertexAttribBinding glad_glVertexAttribBinding
typedef void (APIENTRYP PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
GLAPI PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;
#define glVertexBindingDivisor glad_glVertexBindingDivisor
typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
GLAPI PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;
#define glDebugMessageControl glad_glDebugMessageControl
typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
GLAPI PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;
#define glDebugMessageInsert glad_glDebugMessageInsert
typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void *userParam);
GLAPI PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;
#define glDebugMessageCallback glad_glDebugMessageCallback
typedef GLuint (APIENTRYP PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
GLAPI PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;
#define glGetDebugMessageLog glad_glGetDebugMessageLog
typedef void (APIENTRYP PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar *message);
GLAPI PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;
#define glPushDebugGroup glad_glPushDebugGroup
typedef void (APIENTRYP PFNGLPOPDEBUGGROUPPROC)(void);
GLAPI PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;
#define glPopDebugGroup glad_glPopDebugGroup
typedef void (APIENTRYP PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
GLAPI PFNGLOBJECTLABELPROC glad_glObjectLabel;
#define glObjectLabel glad_glObjectLabel
typedef void (APIENTRYP PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
GLAPI PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;
#define glGetObjectLabel glad_glGetObjectLabel
typedef void (APIENTRYP PFNGLOBJECTPTRLABELPROC)(const void *ptr, GLsizei length, const GLchar *label);
GLAPI PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;
#define glObjectPtrLabel glad_glObjectPtrLabel
typedef void (APIENTRYP PFNGLGETOBJECTPTRLABELPROC)(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
GLAPI PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;
#define glGetObjectPtrLabel glad_glGetObjectPtrLabel
typedef void (APIENTRYP PFNGLGETPOINTERVPROC)(GLenum pname, void **params);
GLAPI PFNGLGETPOINTERVPROC glad_glGetPointerv;
#define glGetPointerv glad_glGetPointerv
#endif
#ifndef GL_VERSION_4_4
#define GL_VERSION_4_4 1
GLAPI int GLAD_GL_VERSION_4_4;
typedef void (APIENTRYP PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
GLAPI PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;
#define glBufferStorage glad_glBufferStorage
typedef void (APIENTRYP PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
GLAPI PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;
#define glClearTexImage glad_glClearTexImage
typedef void (APIENTRYP PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
GLAPI PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;
#define glClearTexSubImage glad_glClearTexSubImage
typedef void (APIENTRYP PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
GLAPI PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;
#define glBindBuffersBase glad_glBindBuffersBase
typedef void (APIENTRYP PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
GLAPI PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;
#define glBindBuffersRange glad_glBindBuffersRange
typedef void (APIENTRYP PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint *textures);
GLAPI PFNGLBINDTEXTURESPROC glad_glBindTextures;
#define glBindTextures glad_glBindTextures
typedef void (APIENTRYP PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint *samplers);
GLAPI PFNGLBINDSAMPLERSPROC glad_glBindSamplers;
#define glBindSamplers glad_glBindSamplers
typedef void (APIENTRYP PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint *textures);
GLAPI PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;
#define glBindImageTextures glad_glBindImageTextures
typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
GLAPI PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;
#define glBindVertexBuffers glad_glBindVertexBuffers
#endif
#ifndef GL_VERSION_4_5
#define GL_VERSION_4_5 1
GLAPI int GLAD_GL_VERSION_4_5;
typedef void (APIENTRYP PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
GLAPI PFNGLCLIPCONTROLPROC glad_glClipControl;
#define glClipControl glad_glClipControl
typedef void (APIENTRYP PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
GLAPI PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;
#define glCreateTransformFeedbacks glad_glCreateTransformFeedbacks
typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
GLAPI PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;
#define glTransformFeedbackBufferBase glad_glTransformFeedbackBufferBase
typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
GLAPI PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;
#define glTransformFeedbackBufferRange glad_glTransformFeedbackBufferRange
typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint *param);
GLAPI PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;
#define glGetTransformFeedbackiv glad_glGetTransformFeedbackiv
typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint *param);
GLAPI PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;
#define glGetTransformFeedbacki_v glad_glGetTransformFeedbacki_v
typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 *param);
GLAPI PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;
#define glGetTransformFeedbacki64_v glad_glGetTransformFeedbacki64_v
typedef void (APIENTRYP PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint *buffers);
GLAPI PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;
#define glCreateBuffers glad_glCreateBuffers
typedef void (APIENTRYP PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
GLAPI PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;
#define glNamedBufferStorage glad_glNamedBufferStorage
typedef void (APIENTRYP PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
GLAPI PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;
#define glNamedBufferData glad_glNamedBufferData
typedef void (APIENTRYP PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
GLAPI PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;
#define glNamedBufferSubData glad_glNamedBufferSubData
typedef void (APIENTRYP PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
GLAPI PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;
#define glCopyNamedBufferSubData glad_glCopyNamedBufferSubData
typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
GLAPI PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;
#define glClearNamedBufferData glad_glClearNamedBufferData
typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
GLAPI PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;
#define glClearNamedBufferSubData glad_glClearNamedBufferSubData
typedef void * (APIENTRYP PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
GLAPI PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;
#define glMapNamedBuffer glad_glMapNamedBuffer
typedef void * (APIENTRYP PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
GLAPI PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;
#define glMapNamedBufferRange glad_glMapNamedBufferRange
typedef GLboolean (APIENTRYP PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
GLAPI PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;
#define glUnmapNamedBuffer glad_glUnmapNamedBuffer
typedef void (APIENTRYP PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
GLAPI PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;
#define glFlushMappedNamedBufferRange glad_glFlushMappedNamedBufferRange
typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint *params);
GLAPI PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;
#define glGetNamedBufferParameteriv glad_glGetNamedBufferParameteriv
typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 *params);
GLAPI PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;
#define glGetNamedBufferParameteri64v glad_glGetNamedBufferParameteri64v
typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void **params);
GLAPI PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;
#define glGetNamedBufferPointerv glad_glGetNamedBufferPointerv
typedef void (APIENTRYP PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
GLAPI PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;
#define glGetNamedBufferSubData glad_glGetNamedBufferSubData
typedef void (APIENTRYP PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
GLAPI PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;
#define glCreateFramebuffers glad_glCreateFramebuffers
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GLAPI PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;
#define glNamedFramebufferRenderbuffer glad_glNamedFramebufferRenderbuffer
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
GLAPI PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;
#define glNamedFramebufferParameteri glad_glNamedFramebufferParameteri
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
GLAPI PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;
#define glNamedFramebufferTexture glad_glNamedFramebufferTexture
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
GLAPI PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;
#define glNamedFramebufferTextureLayer glad_glNamedFramebufferTextureLayer
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
GLAPI PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;
#define glNamedFramebufferDrawBuffer glad_glNamedFramebufferDrawBuffer
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum *bufs);
GLAPI PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;
#define glNamedFramebufferDrawBuffers glad_glNamedFramebufferDrawBuffers
typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
GLAPI PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;
#define glNamedFramebufferReadBuffer glad_glNamedFramebufferReadBuffer
typedef void (APIENTRYP PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments);
GLAPI PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;
#define glInvalidateNamedFramebufferData glad_glInvalidateNamedFramebufferData
typedef void (APIENTRYP PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;
#define glInvalidateNamedFramebufferSubData glad_glInvalidateNamedFramebufferSubData
typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value);
GLAPI PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;
#define glClearNamedFramebufferiv glad_glClearNamedFramebufferiv
typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value);
GLAPI PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;
#define glClearNamedFramebufferuiv glad_glClearNamedFramebufferuiv
typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value);
GLAPI PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;
#define glClearNamedFramebufferfv glad_glClearNamedFramebufferfv
typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
GLAPI PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;
#define glClearNamedFramebufferfi glad_glClearNamedFramebufferfi
typedef void (APIENTRYP PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GLAPI PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;
#define glBlitNamedFramebuffer glad_glBlitNamedFramebuffer
typedef GLenum (APIENTRYP PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
GLAPI PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;
#define glCheckNamedFramebufferStatus glad_glCheckNamedFramebufferStatus
typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint *param);
GLAPI PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;
#define glGetNamedFramebufferParameteriv glad_glGetNamedFramebufferParameteriv
typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
GLAPI PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;
#define glGetNamedFramebufferAttachmentParameteriv glad_glGetNamedFramebufferAttachmentParameteriv
typedef void (APIENTRYP PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
GLAPI PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;
#define glCreateRenderbuffers glad_glCreateRenderbuffers
typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;
#define glNamedRenderbufferStorage glad_glNamedRenderbufferStorage
typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;
#define glNamedRenderbufferStorageMultisample glad_glNamedRenderbufferStorageMultisample
typedef void (APIENTRYP PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint *params);
GLAPI PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;
#define glGetNamedRenderbufferParameteriv glad_glGetNamedRenderbufferParameteriv
typedef void (APIENTRYP PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint *textures);
GLAPI PFNGLCREATETEXTURESPROC glad_glCreateTextures;
#define glCreateTextures glad_glCreateTextures
typedef void (APIENTRYP PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
GLAPI PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;
#define glTextureBuffer glad_glTextureBuffer
typedef void (APIENTRYP PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
GLAPI PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;
#define glTextureBufferRange glad_glTextureBufferRange
typedef void (APIENTRYP PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
GLAPI PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;
#define glTextureStorage1D glad_glTextureStorage1D
typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;
#define glTextureStorage2D glad_glTextureStorage2D
typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
GLAPI PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;
#define glTextureStorage3D glad_glTextureStorage3D
typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GLAPI PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;
#define glTextureStorage2DMultisample glad_glTextureStorage2DMultisample
typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GLAPI PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;
#define glTextureStorage3DMultisample glad_glTextureStorage3DMultisample
typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;
#define glTextureSubImage1D glad_glTextureSubImage1D
typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;
#define glTextureSubImage2D glad_glTextureSubImage2D
typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
GLAPI PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;
#define glTextureSubImage3D glad_glTextureSubImage3D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;
#define glCompressedTextureSubImage1D glad_glCompressedTextureSubImage1D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;
#define glCompressedTextureSubImage2D glad_glCompressedTextureSubImage2D
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
GLAPI PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;
#define glCompressedTextureSubImage3D glad_glCompressedTextureSubImage3D
typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
GLAPI PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;
#define glCopyTextureSubImage1D glad_glCopyTextureSubImage1D
typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;
#define glCopyTextureSubImage2D glad_glCopyTextureSubImage2D
typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;
#define glCopyTextureSubImage3D glad_glCopyTextureSubImage3D
typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
GLAPI PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;
#define glTextureParameterf glad_glTextureParameterf
typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat *param);
GLAPI PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;
#define glTextureParameterfv glad_glTextureParameterfv
typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
GLAPI PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;
#define glTextureParameteri glad_glTextureParameteri
typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint *params);
GLAPI PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;
#define glTextureParameterIiv glad_glTextureParameterIiv
typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint *params);
GLAPI PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;
#define glTextureParameterIuiv glad_glTextureParameterIuiv
typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint *param);
GLAPI PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;
#define glTextureParameteriv glad_glTextureParameteriv
typedef void (APIENTRYP PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
GLAPI PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;
#define glGenerateTextureMipmap glad_glGenerateTextureMipmap
typedef void (APIENTRYP PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
GLAPI PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;
#define glBindTextureUnit glad_glBindTextureUnit
typedef void (APIENTRYP PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
GLAPI PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;
#define glGetTextureImage glad_glGetTextureImage
typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void *pixels);
GLAPI PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;
#define glGetCompressedTextureImage glad_glGetCompressedTextureImage
typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat *params);
GLAPI PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;
#define glGetTextureLevelParameterfv glad_glGetTextureLevelParameterfv
typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint *params);
GLAPI PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;
#define glGetTextureLevelParameteriv glad_glGetTextureLevelParameteriv
typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat *params);
GLAPI PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;
#define glGetTextureParameterfv glad_glGetTextureParameterfv
typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint *params);
GLAPI PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;
#define glGetTextureParameterIiv glad_glGetTextureParameterIiv
typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint *params);
GLAPI PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;
#define glGetTextureParameterIuiv glad_glGetTextureParameterIuiv
typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint *params);
GLAPI PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;
#define glGetTextureParameteriv glad_glGetTextureParameteriv
typedef void (APIENTRYP PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
GLAPI PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;
#define glCreateVertexArrays glad_glCreateVertexArrays
typedef void (APIENTRYP PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
GLAPI PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;
#define glDisableVertexArrayAttrib glad_glDisableVertexArrayAttrib
typedef void (APIENTRYP PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
GLAPI PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;
#define glEnableVertexArrayAttrib glad_glEnableVertexArrayAttrib
typedef void (APIENTRYP PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
GLAPI PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;
#define glVertexArrayElementBuffer glad_glVertexArrayElementBuffer
typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
GLAPI PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;
#define glVertexArrayVertexBuffer glad_glVertexArrayVertexBuffer
typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
GLAPI PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;
#define glVertexArrayVertexBuffers glad_glVertexArrayVertexBuffers
typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
GLAPI PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;
#define glVertexArrayAttribBinding glad_glVertexArrayAttribBinding
typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
GLAPI PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;
#define glVertexArrayAttribFormat glad_glVertexArrayAttribFormat
typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GLAPI PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;
#define glVertexArrayAttribIFormat glad_glVertexArrayAttribIFormat
typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GLAPI PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;
#define glVertexArrayAttribLFormat glad_glVertexArrayAttribLFormat
typedef void (APIENTRYP PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
GLAPI PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;
#define glVertexArrayBindingDivisor glad_glVertexArrayBindingDivisor
typedef void (APIENTRYP PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint *param);
GLAPI PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;
#define glGetVertexArrayiv glad_glGetVertexArrayiv
typedef void (APIENTRYP PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
GLAPI PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;
#define glGetVertexArrayIndexediv glad_glGetVertexArrayIndexediv
typedef void (APIENTRYP PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param);
GLAPI PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;
#define glGetVertexArrayIndexed64iv glad_glGetVertexArrayIndexed64iv
typedef void (APIENTRYP PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint *samplers);
GLAPI PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;
#define glCreateSamplers glad_glCreateSamplers
typedef void (APIENTRYP PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint *pipelines);
GLAPI PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;
#define glCreateProgramPipelines glad_glCreateProgramPipelines
typedef void (APIENTRYP PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint *ids);
GLAPI PFNGLCREATEQUERIESPROC glad_glCreateQueries;
#define glCreateQueries glad_glCreateQueries
typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
GLAPI PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;
#define glGetQueryBufferObjecti64v glad_glGetQueryBufferObjecti64v
typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
GLAPI PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;
#define glGetQueryBufferObjectiv glad_glGetQueryBufferObjectiv
typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
GLAPI PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;
#define glGetQueryBufferObjectui64v glad_glGetQueryBufferObjectui64v
typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
GLAPI PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;
#define glGetQueryBufferObjectuiv glad_glGetQueryBufferObjectuiv
typedef void (APIENTRYP PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
GLAPI PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;
#define glMemoryBarrierByRegion glad_glMemoryBarrierByRegion
typedef void (APIENTRYP PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
GLAPI PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;
#define glGetTextureSubImage glad_glGetTextureSubImage
typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
GLAPI PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;
#define glGetCompressedTextureSubImage glad_glGetCompressedTextureSubImage
typedef GLenum (APIENTRYP PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
GLAPI PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;
#define glGetGraphicsResetStatus glad_glGetGraphicsResetStatus
typedef void (APIENTRYP PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLsizei bufSize, void *pixels);
GLAPI PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;
#define glGetnCompressedTexImage glad_glGetnCompressedTexImage
typedef void (APIENTRYP PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
GLAPI PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;
#define glGetnTexImage glad_glGetnTexImage
typedef void (APIENTRYP PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
GLAPI PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;
#define glGetnUniformdv glad_glGetnUniformdv
typedef void (APIENTRYP PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
GLAPI PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;
#define glGetnUniformfv glad_glGetnUniformfv
typedef void (APIENTRYP PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
GLAPI PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;
#define glGetnUniformiv glad_glGetnUniformiv
typedef void (APIENTRYP PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
GLAPI PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;
#define glGetnUniformuiv glad_glGetnUniformuiv
typedef void (APIENTRYP PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
GLAPI PFNGLREADNPIXELSPROC glad_glReadnPixels;
#define glReadnPixels glad_glReadnPixels
typedef void (APIENTRYP PFNGLGETNMAPDVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
GLAPI PFNGLGETNMAPDVPROC glad_glGetnMapdv;
#define glGetnMapdv glad_glGetnMapdv
typedef void (APIENTRYP PFNGLGETNMAPFVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
GLAPI PFNGLGETNMAPFVPROC glad_glGetnMapfv;
#define glGetnMapfv glad_glGetnMapfv
typedef void (APIENTRYP PFNGLGETNMAPIVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLint *v);
GLAPI PFNGLGETNMAPIVPROC glad_glGetnMapiv;
#define glGetnMapiv glad_glGetnMapiv
typedef void (APIENTRYP PFNGLGETNPIXELMAPFVPROC)(GLenum map, GLsizei bufSize, GLfloat *values);
GLAPI PFNGLGETNPIXELMAPFVPROC glad_glGetnPixelMapfv;
#define glGetnPixelMapfv glad_glGetnPixelMapfv
typedef void (APIENTRYP PFNGLGETNPIXELMAPUIVPROC)(GLenum map, GLsizei bufSize, GLuint *values);
GLAPI PFNGLGETNPIXELMAPUIVPROC glad_glGetnPixelMapuiv;
#define glGetnPixelMapuiv glad_glGetnPixelMapuiv
typedef void (APIENTRYP PFNGLGETNPIXELMAPUSVPROC)(GLenum map, GLsizei bufSize, GLushort *values);
GLAPI PFNGLGETNPIXELMAPUSVPROC glad_glGetnPixelMapusv;
#define glGetnPixelMapusv glad_glGetnPixelMapusv
typedef void (APIENTRYP PFNGLGETNPOLYGONSTIPPLEPROC)(GLsizei bufSize, GLubyte *pattern);
GLAPI PFNGLGETNPOLYGONSTIPPLEPROC glad_glGetnPolygonStipple;
#define glGetnPolygonStipple glad_glGetnPolygonStipple
typedef void (APIENTRYP PFNGLGETNCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
GLAPI PFNGLGETNCOLORTABLEPROC glad_glGetnColorTable;
#define glGetnColorTable glad_glGetnColorTable
typedef void (APIENTRYP PFNGLGETNCONVOLUTIONFILTERPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
GLAPI PFNGLGETNCONVOLUTIONFILTERPROC glad_glGetnConvolutionFilter;
#define glGetnConvolutionFilter glad_glGetnConvolutionFilter
typedef void (APIENTRYP PFNGLGETNSEPARABLEFILTERPROC)(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
GLAPI PFNGLGETNSEPARABLEFILTERPROC glad_glGetnSeparableFilter;
#define glGetnSeparableFilter glad_glGetnSeparableFilter
typedef void (APIENTRYP PFNGLGETNHISTOGRAMPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
GLAPI PFNGLGETNHISTOGRAMPROC glad_glGetnHistogram;
#define glGetnHistogram glad_glGetnHistogram
typedef void (APIENTRYP PFNGLGETNMINMAXPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
GLAPI PFNGLGETNMINMAXPROC glad_glGetnMinmax;
#define glGetnMinmax glad_glGetnMinmax
typedef void (APIENTRYP PFNGLTEXTUREBARRIERPROC)(void);
GLAPI PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;
#define glTextureBarrier glad_glTextureBarrier
#endif
#ifndef GL_VERSION_4_6
#define GL_VERSION_4_6 1
GLAPI int GLAD_GL_VERSION_4_6;
typedef void (APIENTRYP PFNGLSPECIALIZESHADERPROC)(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);
GLAPI PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader;
#define glSpecializeShader glad_glSpecializeShader
typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
GLAPI PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount;
#define glMultiDrawArraysIndirectCount glad_glMultiDrawArraysIndirectCount
typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
GLAPI PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount;
#define glMultiDrawElementsIndirectCount glad_glMultiDrawElementsIndirectCount
typedef void (APIENTRYP PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
GLAPI PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;
#define glPolygonOffsetClamp glad_glPolygonOffsetClamp
#endif

#ifdef __cplusplus
}
#endif

#endif

```

`Hazel/vendor/Glad/premake5.lua`:

```lua
project "Glad"
    kind "StaticLib"
    language "C"
    staticruntime "off"
    
    targetdir ("bin/" .. outputdir .. "/%{prj.name}")
    objdir ("bin-int/" .. outputdir .. "/%{prj.name}")

    files
    {
        "include/glad/glad.h",
        "include/KHR/khrplatform.h",
        "src/glad.c"
    }

    includedirs
    {
        "include"
    }
    
    filter "system:windows"
        systemversion "latest"

    filter "configurations:Debug"
        runtime "Debug"
        symbols "on"

    filter "configurations:Release"
        runtime "Release"
        optimize "on"

```

`Hazel/vendor/Glad/src/glad.c`:

```c
/*

    OpenGL loader generated by glad 0.1.28 on Sat Jan  5 02:36:41 2019.

    Language/Generator: C/C++
    Specification: gl
    APIs: gl=4.6
    Profile: core
    Extensions:
        
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gl=4.6" --generator="c" --spec="gl" --extensions=""
    Online:
        https://glad.dav1d.de/#profile=core&language=c&specification=gl&loader=on&api=gl%3D4.6
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glad/glad.h>

static void* get_proc(const char *namez);

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
static HMODULE libGL;

typedef void* (APIENTRYP PFNWGLGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNWGLGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;

#ifdef _MSC_VER
#ifdef __has_include
  #if __has_include(<winapifamily.h>)
    #define HAVE_WINAPIFAMILY 1
  #endif
#elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
  #define HAVE_WINAPIFAMILY 1
#endif
#endif

#ifdef HAVE_WINAPIFAMILY
  #include <winapifamily.h>
  #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
    #define IS_UWP 1
  #endif
#endif

static
int open_gl(void) {
#ifndef IS_UWP
    libGL = LoadLibraryW(L"opengl32.dll");
    if(libGL != NULL) {
        void (* tmp)(void);
        tmp = (void(*)(void)) GetProcAddress(libGL, "wglGetProcAddress");
        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE) tmp;
        return gladGetProcAddressPtr != NULL;
    }
#endif

    return 0;
}

static
void close_gl(void) {
    if(libGL != NULL) {
        FreeLibrary((HMODULE) libGL);
        libGL = NULL;
    }
}
#else
#include <dlfcn.h>
static void* libGL;

#if !defined(__APPLE__) && !defined(__HAIKU__)
typedef void* (APIENTRYP PFNGLXGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNGLXGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;
#endif

static
int open_gl(void) {
#ifdef __APPLE__
    static const char *NAMES[] = {
        "../Frameworks/OpenGL.framework/OpenGL",
        "/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
    };
#else
    static const char *NAMES[] = {"libGL.so.1", "libGL.so"};
#endif

    unsigned int index = 0;
    for(index = 0; index < (sizeof(NAMES) / sizeof(NAMES[0])); index++) {
        libGL = dlopen(NAMES[index], RTLD_NOW | RTLD_GLOBAL);

        if(libGL != NULL) {
#if defined(__APPLE__) || defined(__HAIKU__)
            return 1;
#else
            gladGetProcAddressPtr = (PFNGLXGETPROCADDRESSPROC_PRIVATE)dlsym(libGL,
                "glXGetProcAddressARB");
            return gladGetProcAddressPtr != NULL;
#endif
        }
    }

    return 0;
}

static
void close_gl(void) {
    if(libGL != NULL) {
        dlclose(libGL);
        libGL = NULL;
    }
}
#endif

static
void* get_proc(const char *namez) {
    void* result = NULL;
    if(libGL == NULL) return NULL;

#if !defined(__APPLE__) && !defined(__HAIKU__)
    if(gladGetProcAddressPtr != NULL) {
        result = gladGetProcAddressPtr(namez);
    }
#endif
    if(result == NULL) {
#if defined(_WIN32) || defined(__CYGWIN__)
        result = (void*)GetProcAddress((HMODULE) libGL, namez);
#else
        result = dlsym(libGL, namez);
#endif
    }

    return result;
}

int gladLoadGL(void) {
    int status = 0;

    if(open_gl()) {
        status = gladLoadGLLoader(&get_proc);
        close_gl();
    }

    return status;
}

struct gladGLversionStruct GLVersion = { 0, 0 };

#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
#define _GLAD_IS_SOME_NEW_VERSION 1
#endif

static int max_loaded_major;
static int max_loaded_minor;

static const char *exts = NULL;
static int num_exts_i = 0;
static char **exts_i = NULL;

static int get_exts(void) {
#ifdef _GLAD_IS_SOME_NEW_VERSION
    if(max_loaded_major < 3) {
#endif
        exts = (const char *)glGetString(GL_EXTENSIONS);
#ifdef _GLAD_IS_SOME_NEW_VERSION
    } else {
        unsigned int index;

        num_exts_i = 0;
        glGetIntegerv(GL_NUM_EXTENSIONS, &num_exts_i);
        if (num_exts_i > 0) {
            char **tmp_exts_i = (char **)realloc((void *)exts_i, (size_t)num_exts_i * (sizeof *exts_i));
            if (tmp_exts_i == NULL) {
                return 0;
            }
            exts_i = tmp_exts_i;
        }

        if (exts_i == NULL) {
            return 0;
        }

        for(index = 0; index < (unsigned)num_exts_i; index++) {
            const char *gl_str_tmp = (const char*)glGetStringi(GL_EXTENSIONS, index);
            size_t len = strlen(gl_str_tmp);

            char *local_str = (char*)malloc((len+1) * sizeof(char));
            if(local_str != NULL) {
                memcpy(local_str, gl_str_tmp, (len+1) * sizeof(char));
            }
            exts_i[index] = local_str;
        }
    }
#endif
    return 1;
}

static void free_exts(void) {
    if (exts_i != NULL) {
        int index;
        for(index = 0; index < num_exts_i; index++) {
            free((char *)exts_i[index]);
        }
        free((void *)exts_i);
        exts_i = NULL;
    }
}

static int has_ext(const char *ext) {
#ifdef _GLAD_IS_SOME_NEW_VERSION
    if(max_loaded_major < 3) {
#endif
        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == NULL || ext == NULL) {
            return 0;
        }

        while(1) {
            loc = strstr(extensions, ext);
            if(loc == NULL) {
                return 0;
            }

            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }
#ifdef _GLAD_IS_SOME_NEW_VERSION
    } else {
        int index;
        if(exts_i == NULL) return 0;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];

            if(exts_i[index] != NULL && strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }
#endif

    return 0;
}
int GLAD_GL_VERSION_1_0 = 0;
int GLAD_GL_VERSION_1_1 = 0;
int GLAD_GL_VERSION_1_2 = 0;
int GLAD_GL_VERSION_1_3 = 0;
int GLAD_GL_VERSION_1_4 = 0;
int GLAD_GL_VERSION_1_5 = 0;
int GLAD_GL_VERSION_2_0 = 0;
int GLAD_GL_VERSION_2_1 = 0;
int GLAD_GL_VERSION_3_0 = 0;
int GLAD_GL_VERSION_3_1 = 0;
int GLAD_GL_VERSION_3_2 = 0;
int GLAD_GL_VERSION_3_3 = 0;
int GLAD_GL_VERSION_4_0 = 0;
int GLAD_GL_VERSION_4_1 = 0;
int GLAD_GL_VERSION_4_2 = 0;
int GLAD_GL_VERSION_4_3 = 0;
int GLAD_GL_VERSION_4_4 = 0;
int GLAD_GL_VERSION_4_5 = 0;
int GLAD_GL_VERSION_4_6 = 0;
PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram = NULL;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture = NULL;
PFNGLATTACHSHADERPROC glad_glAttachShader = NULL;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = NULL;
PFNGLBEGINQUERYPROC glad_glBeginQuery = NULL;
PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = NULL;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = NULL;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = NULL;
PFNGLBINDBUFFERPROC glad_glBindBuffer = NULL;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = NULL;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = NULL;
PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase = NULL;
PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange = NULL;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = NULL;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = NULL;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = NULL;
PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture = NULL;
PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures = NULL;
PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline = NULL;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = NULL;
PFNGLBINDSAMPLERPROC glad_glBindSampler = NULL;
PFNGLBINDSAMPLERSPROC glad_glBindSamplers = NULL;
PFNGLBINDTEXTUREPROC glad_glBindTexture = NULL;
PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit = NULL;
PFNGLBINDTEXTURESPROC glad_glBindTextures = NULL;
PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = NULL;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = NULL;
PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer = NULL;
PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers = NULL;
PFNGLBLENDCOLORPROC glad_glBlendColor = NULL;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation = NULL;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = NULL;
PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = NULL;
PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = NULL;
PFNGLBLENDFUNCPROC glad_glBlendFunc = NULL;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = NULL;
PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = NULL;
PFNGLBLENDFUNCIPROC glad_glBlendFunci = NULL;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = NULL;
PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer = NULL;
PFNGLBUFFERDATAPROC glad_glBufferData = NULL;
PFNGLBUFFERSTORAGEPROC glad_glBufferStorage = NULL;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = NULL;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus = NULL;
PFNGLCLAMPCOLORPROC glad_glClampColor = NULL;
PFNGLCLEARPROC glad_glClear = NULL;
PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData = NULL;
PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData = NULL;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = NULL;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = NULL;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = NULL;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = NULL;
PFNGLCLEARCOLORPROC glad_glClearColor = NULL;
PFNGLCLEARDEPTHPROC glad_glClearDepth = NULL;
PFNGLCLEARDEPTHFPROC glad_glClearDepthf = NULL;
PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData = NULL;
PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv = NULL;
PFNGLCLEARSTENCILPROC glad_glClearStencil = NULL;
PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage = NULL;
PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage = NULL;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = NULL;
PFNGLCLIPCONTROLPROC glad_glClipControl = NULL;
PFNGLCOLORMASKPROC glad_glColorMask = NULL;
PFNGLCOLORMASKIPROC glad_glColorMaski = NULL;
PFNGLCOLORP3UIPROC glad_glColorP3ui = NULL;
PFNGLCOLORP3UIVPROC glad_glColorP3uiv = NULL;
PFNGLCOLORP4UIPROC glad_glColorP4ui = NULL;
PFNGLCOLORP4UIVPROC glad_glColorP4uiv = NULL;
PFNGLCOMPILESHADERPROC glad_glCompileShader = NULL;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = NULL;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = NULL;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D = NULL;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = NULL;
PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData = NULL;
PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData = NULL;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = NULL;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = NULL;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = NULL;
PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D = NULL;
PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D = NULL;
PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D = NULL;
PFNGLCREATEBUFFERSPROC glad_glCreateBuffers = NULL;
PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers = NULL;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram = NULL;
PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines = NULL;
PFNGLCREATEQUERIESPROC glad_glCreateQueries = NULL;
PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers = NULL;
PFNGLCREATESAMPLERSPROC glad_glCreateSamplers = NULL;
PFNGLCREATESHADERPROC glad_glCreateShader = NULL;
PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv = NULL;
PFNGLCREATETEXTURESPROC glad_glCreateTextures = NULL;
PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks = NULL;
PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays = NULL;
PFNGLCULLFACEPROC glad_glCullFace = NULL;
PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback = NULL;
PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl = NULL;
PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert = NULL;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = NULL;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = NULL;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = NULL;
PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines = NULL;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries = NULL;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = NULL;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = NULL;
PFNGLDELETESHADERPROC glad_glDeleteShader = NULL;
PFNGLDELETESYNCPROC glad_glDeleteSync = NULL;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures = NULL;
PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = NULL;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = NULL;
PFNGLDEPTHFUNCPROC glad_glDepthFunc = NULL;
PFNGLDEPTHMASKPROC glad_glDepthMask = NULL;
PFNGLDEPTHRANGEPROC glad_glDepthRange = NULL;
PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv = NULL;
PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed = NULL;
PFNGLDEPTHRANGEFPROC glad_glDepthRangef = NULL;
PFNGLDETACHSHADERPROC glad_glDetachShader = NULL;
PFNGLDISABLEPROC glad_glDisable = NULL;
PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib = NULL;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = NULL;
PFNGLDISABLEIPROC glad_glDisablei = NULL;
PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute = NULL;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect = NULL;
PFNGLDRAWARRAYSPROC glad_glDrawArrays = NULL;
PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = NULL;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = NULL;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance = NULL;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer = NULL;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = NULL;
PFNGLDRAWELEMENTSPROC glad_glDrawElements = NULL;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = NULL;
PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = NULL;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance = NULL;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = NULL;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = NULL;
PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = NULL;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced = NULL;
PFNGLENABLEPROC glad_glEnable = NULL;
PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib = NULL;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = NULL;
PFNGLENABLEIPROC glad_glEnablei = NULL;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = NULL;
PFNGLENDQUERYPROC glad_glEndQuery = NULL;
PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = NULL;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = NULL;
PFNGLFENCESYNCPROC glad_glFenceSync = NULL;
PFNGLFINISHPROC glad_glFinish = NULL;
PFNGLFLUSHPROC glad_glFlush = NULL;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = NULL;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange = NULL;
PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri = NULL;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = NULL;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = NULL;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = NULL;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = NULL;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = NULL;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = NULL;
PFNGLFRONTFACEPROC glad_glFrontFace = NULL;
PFNGLGENBUFFERSPROC glad_glGenBuffers = NULL;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = NULL;
PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines = NULL;
PFNGLGENQUERIESPROC glad_glGenQueries = NULL;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = NULL;
PFNGLGENSAMPLERSPROC glad_glGenSamplers = NULL;
PFNGLGENTEXTURESPROC glad_glGenTextures = NULL;
PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = NULL;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = NULL;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = NULL;
PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = NULL;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = NULL;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = NULL;
PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = NULL;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = NULL;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = NULL;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = NULL;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = NULL;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = NULL;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = NULL;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = NULL;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = NULL;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv = NULL;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = NULL;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = NULL;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = NULL;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = NULL;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = NULL;
PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage = NULL;
PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage = NULL;
PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog = NULL;
PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v = NULL;
PFNGLGETDOUBLEVPROC glad_glGetDoublev = NULL;
PFNGLGETERRORPROC glad_glGetError = NULL;
PFNGLGETFLOATI_VPROC glad_glGetFloati_v = NULL;
PFNGLGETFLOATVPROC glad_glGetFloatv = NULL;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = NULL;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = NULL;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = NULL;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv = NULL;
PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus = NULL;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = NULL;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v = NULL;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = NULL;
PFNGLGETINTEGERVPROC glad_glGetIntegerv = NULL;
PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v = NULL;
PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ = NULL;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = NULL;
PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v = NULL;
PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv = NULL;
PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv = NULL;
PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData = NULL;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv = NULL;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv = NULL;
PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel = NULL;
PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel = NULL;
PFNGLGETPOINTERVPROC glad_glGetPointerv = NULL;
PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary = NULL;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = NULL;
PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv = NULL;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog = NULL;
PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv = NULL;
PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex = NULL;
PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName = NULL;
PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv = NULL;
PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = NULL;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = NULL;
PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v = NULL;
PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv = NULL;
PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v = NULL;
PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv = NULL;
PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = NULL;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = NULL;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = NULL;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = NULL;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = NULL;
PFNGLGETQUERYIVPROC glad_glGetQueryiv = NULL;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = NULL;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = NULL;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = NULL;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = NULL;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = NULL;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = NULL;
PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat = NULL;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = NULL;
PFNGLGETSHADERIVPROC glad_glGetShaderiv = NULL;
PFNGLGETSTRINGPROC glad_glGetString = NULL;
PFNGLGETSTRINGIPROC glad_glGetStringi = NULL;
PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = NULL;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = NULL;
PFNGLGETSYNCIVPROC glad_glGetSynciv = NULL;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage = NULL;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = NULL;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = NULL;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = NULL;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = NULL;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = NULL;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = NULL;
PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage = NULL;
PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv = NULL;
PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv = NULL;
PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv = NULL;
PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv = NULL;
PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv = NULL;
PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv = NULL;
PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = NULL;
PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v = NULL;
PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v = NULL;
PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv = NULL;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = NULL;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = NULL;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = NULL;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = NULL;
PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = NULL;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = NULL;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = NULL;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = NULL;
PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv = NULL;
PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv = NULL;
PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv = NULL;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = NULL;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = NULL;
PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv = NULL;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = NULL;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = NULL;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = NULL;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = NULL;
PFNGLGETNCOLORTABLEPROC glad_glGetnColorTable = NULL;
PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage = NULL;
PFNGLGETNCONVOLUTIONFILTERPROC glad_glGetnConvolutionFilter = NULL;
PFNGLGETNHISTOGRAMPROC glad_glGetnHistogram = NULL;
PFNGLGETNMAPDVPROC glad_glGetnMapdv = NULL;
PFNGLGETNMAPFVPROC glad_glGetnMapfv = NULL;
PFNGLGETNMAPIVPROC glad_glGetnMapiv = NULL;
PFNGLGETNMINMAXPROC glad_glGetnMinmax = NULL;
PFNGLGETNPIXELMAPFVPROC glad_glGetnPixelMapfv = NULL;
PFNGLGETNPIXELMAPUIVPROC glad_glGetnPixelMapuiv = NULL;
PFNGLGETNPIXELMAPUSVPROC glad_glGetnPixelMapusv = NULL;
PFNGLGETNPOLYGONSTIPPLEPROC glad_glGetnPolygonStipple = NULL;
PFNGLGETNSEPARABLEFILTERPROC glad_glGetnSeparableFilter = NULL;
PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage = NULL;
PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv = NULL;
PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv = NULL;
PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv = NULL;
PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv = NULL;
PFNGLHINTPROC glad_glHint = NULL;
PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData = NULL;
PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData = NULL;
PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData = NULL;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer = NULL;
PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage = NULL;
PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage = NULL;
PFNGLISBUFFERPROC glad_glIsBuffer = NULL;
PFNGLISENABLEDPROC glad_glIsEnabled = NULL;
PFNGLISENABLEDIPROC glad_glIsEnabledi = NULL;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = NULL;
PFNGLISPROGRAMPROC glad_glIsProgram = NULL;
PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline = NULL;
PFNGLISQUERYPROC glad_glIsQuery = NULL;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = NULL;
PFNGLISSAMPLERPROC glad_glIsSampler = NULL;
PFNGLISSHADERPROC glad_glIsShader = NULL;
PFNGLISSYNCPROC glad_glIsSync = NULL;
PFNGLISTEXTUREPROC glad_glIsTexture = NULL;
PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = NULL;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = NULL;
PFNGLLINEWIDTHPROC glad_glLineWidth = NULL;
PFNGLLINKPROGRAMPROC glad_glLinkProgram = NULL;
PFNGLLOGICOPPROC glad_glLogicOp = NULL;
PFNGLMAPBUFFERPROC glad_glMapBuffer = NULL;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = NULL;
PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer = NULL;
PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange = NULL;
PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier = NULL;
PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion = NULL;
PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = NULL;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount = NULL;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = NULL;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount = NULL;
PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui = NULL;
PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv = NULL;
PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui = NULL;
PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv = NULL;
PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui = NULL;
PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv = NULL;
PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui = NULL;
PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv = NULL;
PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData = NULL;
PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage = NULL;
PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers = NULL;
PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri = NULL;
PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample = NULL;
PFNGLNORMALP3UIPROC glad_glNormalP3ui = NULL;
PFNGLNORMALP3UIVPROC glad_glNormalP3uiv = NULL;
PFNGLOBJECTLABELPROC glad_glObjectLabel = NULL;
PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel = NULL;
PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = NULL;
PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = NULL;
PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = NULL;
PFNGLPIXELSTOREFPROC glad_glPixelStoref = NULL;
PFNGLPIXELSTOREIPROC glad_glPixelStorei = NULL;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = NULL;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = NULL;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = NULL;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = NULL;
PFNGLPOINTSIZEPROC glad_glPointSize = NULL;
PFNGLPOLYGONMODEPROC glad_glPolygonMode = NULL;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = NULL;
PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp = NULL;
PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup = NULL;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = NULL;
PFNGLPROGRAMBINARYPROC glad_glProgramBinary = NULL;
PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri = NULL;
PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d = NULL;
PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv = NULL;
PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f = NULL;
PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv = NULL;
PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i = NULL;
PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv = NULL;
PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui = NULL;
PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv = NULL;
PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d = NULL;
PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv = NULL;
PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f = NULL;
PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv = NULL;
PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i = NULL;
PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv = NULL;
PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui = NULL;
PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv = NULL;
PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d = NULL;
PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv = NULL;
PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f = NULL;
PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv = NULL;
PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i = NULL;
PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv = NULL;
PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui = NULL;
PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv = NULL;
PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d = NULL;
PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv = NULL;
PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f = NULL;
PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv = NULL;
PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i = NULL;
PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv = NULL;
PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui = NULL;
PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv = NULL;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = NULL;
PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup = NULL;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter = NULL;
PFNGLREADBUFFERPROC glad_glReadBuffer = NULL;
PFNGLREADPIXELSPROC glad_glReadPixels = NULL;
PFNGLREADNPIXELSPROC glad_glReadnPixels = NULL;
PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler = NULL;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = NULL;
PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = NULL;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = NULL;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski = NULL;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = NULL;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = NULL;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = NULL;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = NULL;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = NULL;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = NULL;
PFNGLSCISSORPROC glad_glScissor = NULL;
PFNGLSCISSORARRAYVPROC glad_glScissorArrayv = NULL;
PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed = NULL;
PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv = NULL;
PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui = NULL;
PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv = NULL;
PFNGLSHADERBINARYPROC glad_glShaderBinary = NULL;
PFNGLSHADERSOURCEPROC glad_glShaderSource = NULL;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding = NULL;
PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader = NULL;
PFNGLSTENCILFUNCPROC glad_glStencilFunc = NULL;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = NULL;
PFNGLSTENCILMASKPROC glad_glStencilMask = NULL;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = NULL;
PFNGLSTENCILOPPROC glad_glStencilOp = NULL;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = NULL;
PFNGLTEXBUFFERPROC glad_glTexBuffer = NULL;
PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange = NULL;
PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui = NULL;
PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv = NULL;
PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui = NULL;
PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv = NULL;
PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui = NULL;
PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv = NULL;
PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui = NULL;
PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv = NULL;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D = NULL;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D = NULL;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = NULL;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D = NULL;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = NULL;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = NULL;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = NULL;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf = NULL;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = NULL;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri = NULL;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = NULL;
PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D = NULL;
PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D = NULL;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample = NULL;
PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D = NULL;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample = NULL;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = NULL;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = NULL;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = NULL;
PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier = NULL;
PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer = NULL;
PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange = NULL;
PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv = NULL;
PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv = NULL;
PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf = NULL;
PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv = NULL;
PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri = NULL;
PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv = NULL;
PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D = NULL;
PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D = NULL;
PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample = NULL;
PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D = NULL;
PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample = NULL;
PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D = NULL;
PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D = NULL;
PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D = NULL;
PFNGLTEXTUREVIEWPROC glad_glTextureView = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = NULL;
PFNGLUNIFORM1DPROC glad_glUniform1d = NULL;
PFNGLUNIFORM1DVPROC glad_glUniform1dv = NULL;
PFNGLUNIFORM1FPROC glad_glUniform1f = NULL;
PFNGLUNIFORM1FVPROC glad_glUniform1fv = NULL;
PFNGLUNIFORM1IPROC glad_glUniform1i = NULL;
PFNGLUNIFORM1IVPROC glad_glUniform1iv = NULL;
PFNGLUNIFORM1UIPROC glad_glUniform1ui = NULL;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = NULL;
PFNGLUNIFORM2DPROC glad_glUniform2d = NULL;
PFNGLUNIFORM2DVPROC glad_glUniform2dv = NULL;
PFNGLUNIFORM2FPROC glad_glUniform2f = NULL;
PFNGLUNIFORM2FVPROC glad_glUniform2fv = NULL;
PFNGLUNIFORM2IPROC glad_glUniform2i = NULL;
PFNGLUNIFORM2IVPROC glad_glUniform2iv = NULL;
PFNGLUNIFORM2UIPROC glad_glUniform2ui = NULL;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = NULL;
PFNGLUNIFORM3DPROC glad_glUniform3d = NULL;
PFNGLUNIFORM3DVPROC glad_glUniform3dv = NULL;
PFNGLUNIFORM3FPROC glad_glUniform3f = NULL;
PFNGLUNIFORM3FVPROC glad_glUniform3fv = NULL;
PFNGLUNIFORM3IPROC glad_glUniform3i = NULL;
PFNGLUNIFORM3IVPROC glad_glUniform3iv = NULL;
PFNGLUNIFORM3UIPROC glad_glUniform3ui = NULL;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = NULL;
PFNGLUNIFORM4DPROC glad_glUniform4d = NULL;
PFNGLUNIFORM4DVPROC glad_glUniform4dv = NULL;
PFNGLUNIFORM4FPROC glad_glUniform4f = NULL;
PFNGLUNIFORM4FVPROC glad_glUniform4fv = NULL;
PFNGLUNIFORM4IPROC glad_glUniform4i = NULL;
PFNGLUNIFORM4IVPROC glad_glUniform4iv = NULL;
PFNGLUNIFORM4UIPROC glad_glUniform4ui = NULL;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = NULL;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = NULL;
PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = NULL;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = NULL;
PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = NULL;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = NULL;
PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = NULL;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = NULL;
PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = NULL;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = NULL;
PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = NULL;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = NULL;
PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = NULL;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = NULL;
PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = NULL;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = NULL;
PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = NULL;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = NULL;
PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = NULL;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = NULL;
PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = NULL;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = NULL;
PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer = NULL;
PFNGLUSEPROGRAMPROC glad_glUseProgram = NULL;
PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages = NULL;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = NULL;
PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline = NULL;
PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding = NULL;
PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat = NULL;
PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat = NULL;
PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat = NULL;
PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor = NULL;
PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers = NULL;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = NULL;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = NULL;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = NULL;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = NULL;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = NULL;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = NULL;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = NULL;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = NULL;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = NULL;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = NULL;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = NULL;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = NULL;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = NULL;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = NULL;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = NULL;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = NULL;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = NULL;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = NULL;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = NULL;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = NULL;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = NULL;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = NULL;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = NULL;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = NULL;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = NULL;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = NULL;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = NULL;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = NULL;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = NULL;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = NULL;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = NULL;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = NULL;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = NULL;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = NULL;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = NULL;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = NULL;
PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding = NULL;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = NULL;
PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat = NULL;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = NULL;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = NULL;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = NULL;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = NULL;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = NULL;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = NULL;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = NULL;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = NULL;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = NULL;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = NULL;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = NULL;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = NULL;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = NULL;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = NULL;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = NULL;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = NULL;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = NULL;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = NULL;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = NULL;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = NULL;
PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat = NULL;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = NULL;
PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d = NULL;
PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv = NULL;
PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d = NULL;
PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv = NULL;
PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d = NULL;
PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv = NULL;
PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d = NULL;
PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv = NULL;
PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat = NULL;
PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer = NULL;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = NULL;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = NULL;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = NULL;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = NULL;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = NULL;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = NULL;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = NULL;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = NULL;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = NULL;
PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor = NULL;
PFNGLVERTEXP2UIPROC glad_glVertexP2ui = NULL;
PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv = NULL;
PFNGLVERTEXP3UIPROC glad_glVertexP3ui = NULL;
PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv = NULL;
PFNGLVERTEXP4UIPROC glad_glVertexP4ui = NULL;
PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv = NULL;
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
PFNGLWAITSYNCPROC glad_glWaitSync = NULL;
static void load_GL_VERSION_1_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_0) return;
	glad_glCullFace = (PFNGLCULLFACEPROC)load("glCullFace");
	glad_glFrontFace = (PFNGLFRONTFACEPROC)load("glFrontFace");
	glad_glHint = (PFNGLHINTPROC)load("glHint");
	glad_glLineWidth = (PFNGLLINEWIDTHPROC)load("glLineWidth");
	glad_glPointSize = (PFNGLPOINTSIZEPROC)load("glPointSize");
	glad_glPolygonMode = (PFNGLPOLYGONMODEPROC)load("glPolygonMode");
	glad_glScissor = (PFNGLSCISSORPROC)load("glScissor");
	glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC)load("glTexParameterf");
	glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC)load("glTexParameterfv");
	glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC)load("glTexParameteri");
	glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC)load("glTexParameteriv");
	glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC)load("glTexImage1D");
	glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC)load("glTexImage2D");
	glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC)load("glDrawBuffer");
	glad_glClear = (PFNGLCLEARPROC)load("glClear");
	glad_glClearColor = (PFNGLCLEARCOLORPROC)load("glClearColor");
	glad_glClearStencil = (PFNGLCLEARSTENCILPROC)load("glClearStencil");
	glad_glClearDepth = (PFNGLCLEARDEPTHPROC)load("glClearDepth");
	glad_glStencilMask = (PFNGLSTENCILMASKPROC)load("glStencilMask");
	glad_glColorMask = (PFNGLCOLORMASKPROC)load("glColorMask");
	glad_glDepthMask = (PFNGLDEPTHMASKPROC)load("glDepthMask");
	glad_glDisable = (PFNGLDISABLEPROC)load("glDisable");
	glad_glEnable = (PFNGLENABLEPROC)load("glEnable");
	glad_glFinish = (PFNGLFINISHPROC)load("glFinish");
	glad_glFlush = (PFNGLFLUSHPROC)load("glFlush");
	glad_glBlendFunc = (PFNGLBLENDFUNCPROC)load("glBlendFunc");
	glad_glLogicOp = (PFNGLLOGICOPPROC)load("glLogicOp");
	glad_glStencilFunc = (PFNGLSTENCILFUNCPROC)load("glStencilFunc");
	glad_glStencilOp = (PFNGLSTENCILOPPROC)load("glStencilOp");
	glad_glDepthFunc = (PFNGLDEPTHFUNCPROC)load("glDepthFunc");
	glad_glPixelStoref = (PFNGLPIXELSTOREFPROC)load("glPixelStoref");
	glad_glPixelStorei = (PFNGLPIXELSTOREIPROC)load("glPixelStorei");
	glad_glReadBuffer = (PFNGLREADBUFFERPROC)load("glReadBuffer");
	glad_glReadPixels = (PFNGLREADPIXELSPROC)load("glReadPixels");
	glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC)load("glGetBooleanv");
	glad_glGetDoublev = (PFNGLGETDOUBLEVPROC)load("glGetDoublev");
	glad_glGetError = (PFNGLGETERRORPROC)load("glGetError");
	glad_glGetFloatv = (PFNGLGETFLOATVPROC)load("glGetFloatv");
	glad_glGetIntegerv = (PFNGLGETINTEGERVPROC)load("glGetIntegerv");
	glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
	glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC)load("glGetTexImage");
	glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC)load("glGetTexParameterfv");
	glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC)load("glGetTexParameteriv");
	glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC)load("glGetTexLevelParameterfv");
	glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC)load("glGetTexLevelParameteriv");
	glad_glIsEnabled = (PFNGLISENABLEDPROC)load("glIsEnabled");
	glad_glDepthRange = (PFNGLDEPTHRANGEPROC)load("glDepthRange");
	glad_glViewport = (PFNGLVIEWPORTPROC)load("glViewport");
}
static void load_GL_VERSION_1_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_1) return;
	glad_glDrawArrays = (PFNGLDRAWARRAYSPROC)load("glDrawArrays");
	glad_glDrawElements = (PFNGLDRAWELEMENTSPROC)load("glDrawElements");
	glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC)load("glPolygonOffset");
	glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC)load("glCopyTexImage1D");
	glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC)load("glCopyTexImage2D");
	glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC)load("glCopyTexSubImage1D");
	glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC)load("glCopyTexSubImage2D");
	glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC)load("glTexSubImage1D");
	glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC)load("glTexSubImage2D");
	glad_glBindTexture = (PFNGLBINDTEXTUREPROC)load("glBindTexture");
	glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC)load("glDeleteTextures");
	glad_glGenTextures = (PFNGLGENTEXTURESPROC)load("glGenTextures");
	glad_glIsTexture = (PFNGLISTEXTUREPROC)load("glIsTexture");
}
static void load_GL_VERSION_1_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_2) return;
	glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)load("glDrawRangeElements");
	glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC)load("glTexImage3D");
	glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)load("glTexSubImage3D");
	glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)load("glCopyTexSubImage3D");
}
static void load_GL_VERSION_1_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_3) return;
	glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC)load("glActiveTexture");
	glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)load("glSampleCoverage");
	glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)load("glCompressedTexImage3D");
	glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)load("glCompressedTexImage2D");
	glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)load("glCompressedTexImage1D");
	glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)load("glCompressedTexSubImage3D");
	glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)load("glCompressedTexSubImage2D");
	glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)load("glCompressedTexSubImage1D");
	glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)load("glGetCompressedTexImage");
}
static void load_GL_VERSION_1_4(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_4) return;
	glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)load("glBlendFuncSeparate");
	glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)load("glMultiDrawArrays");
	glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)load("glMultiDrawElements");
	glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC)load("glPointParameterf");
	glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)load("glPointParameterfv");
	glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC)load("glPointParameteri");
	glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)load("glPointParameteriv");
	glad_glBlendColor = (PFNGLBLENDCOLORPROC)load("glBlendColor");
	glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC)load("glBlendEquation");
}
static void load_GL_VERSION_1_5(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_5) return;
	glad_glGenQueries = (PFNGLGENQUERIESPROC)load("glGenQueries");
	glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC)load("glDeleteQueries");
	glad_glIsQuery = (PFNGLISQUERYPROC)load("glIsQuery");
	glad_glBeginQuery = (PFNGLBEGINQUERYPROC)load("glBeginQuery");
	glad_glEndQuery = (PFNGLENDQUERYPROC)load("glEndQuery");
	glad_glGetQueryiv = (PFNGLGETQUERYIVPROC)load("glGetQueryiv");
	glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)load("glGetQueryObjectiv");
	glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)load("glGetQueryObjectuiv");
	glad_glBindBuffer = (PFNGLBINDBUFFERPROC)load("glBindBuffer");
	glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)load("glDeleteBuffers");
	glad_glGenBuffers = (PFNGLGENBUFFERSPROC)load("glGenBuffers");
	glad_glIsBuffer = (PFNGLISBUFFERPROC)load("glIsBuffer");
	glad_glBufferData = (PFNGLBUFFERDATAPROC)load("glBufferData");
	glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC)load("glBufferSubData");
	glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)load("glGetBufferSubData");
	glad_glMapBuffer = (PFNGLMAPBUFFERPROC)load("glMapBuffer");
	glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)load("glUnmapBuffer");
	glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)load("glGetBufferParameteriv");
	glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)load("glGetBufferPointerv");
}
static void load_GL_VERSION_2_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_2_0) return;
	glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)load("glBlendEquationSeparate");
	glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC)load("glDrawBuffers");
	glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)load("glStencilOpSeparate");
	glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)load("glStencilFuncSeparate");
	glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)load("glStencilMaskSeparate");
	glad_glAttachShader = (PFNGLATTACHSHADERPROC)load("glAttachShader");
	glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)load("glBindAttribLocation");
	glad_glCompileShader = (PFNGLCOMPILESHADERPROC)load("glCompileShader");
	glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC)load("glCreateProgram");
	glad_glCreateShader = (PFNGLCREATESHADERPROC)load("glCreateShader");
	glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC)load("glDeleteProgram");
	glad_glDeleteShader = (PFNGLDELETESHADERPROC)load("glDeleteShader");
	glad_glDetachShader = (PFNGLDETACHSHADERPROC)load("glDetachShader");
	glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)load("glDisableVertexAttribArray");
	glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)load("glEnableVertexAttribArray");
	glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)load("glGetActiveAttrib");
	glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)load("glGetActiveUniform");
	glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)load("glGetAttachedShaders");
	glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)load("glGetAttribLocation");
	glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC)load("glGetProgramiv");
	glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)load("glGetProgramInfoLog");
	glad_glGetShaderiv = (PFNGLGETSHADERIVPROC)load("glGetShaderiv");
	glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)load("glGetShaderInfoLog");
	glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)load("glGetShaderSource");
	glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)load("glGetUniformLocation");
	glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC)load("glGetUniformfv");
	glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC)load("glGetUniformiv");
	glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)load("glGetVertexAttribdv");
	glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)load("glGetVertexAttribfv");
	glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)load("glGetVertexAttribiv");
	glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)load("glGetVertexAttribPointerv");
	glad_glIsProgram = (PFNGLISPROGRAMPROC)load("glIsProgram");
	glad_glIsShader = (PFNGLISSHADERPROC)load("glIsShader");
	glad_glLinkProgram = (PFNGLLINKPROGRAMPROC)load("glLinkProgram");
	glad_glShaderSource = (PFNGLSHADERSOURCEPROC)load("glShaderSource");
	glad_glUseProgram = (PFNGLUSEPROGRAMPROC)load("glUseProgram");
	glad_glUniform1f = (PFNGLUNIFORM1FPROC)load("glUniform1f");
	glad_glUniform2f = (PFNGLUNIFORM2FPROC)load("glUniform2f");
	glad_glUniform3f = (PFNGLUNIFORM3FPROC)load("glUniform3f");
	glad_glUniform4f = (PFNGLUNIFORM4FPROC)load("glUniform4f");
	glad_glUniform1i = (PFNGLUNIFORM1IPROC)load("glUniform1i");
	glad_glUniform2i = (PFNGLUNIFORM2IPROC)load("glUniform2i");
	glad_glUniform3i = (PFNGLUNIFORM3IPROC)load("glUniform3i");
	glad_glUniform4i = (PFNGLUNIFORM4IPROC)load("glUniform4i");
	glad_glUniform1fv = (PFNGLUNIFORM1FVPROC)load("glUniform1fv");
	glad_glUniform2fv = (PFNGLUNIFORM2FVPROC)load("glUniform2fv");
	glad_glUniform3fv = (PFNGLUNIFORM3FVPROC)load("glUniform3fv");
	glad_glUniform4fv = (PFNGLUNIFORM4FVPROC)load("glUniform4fv");
	glad_glUniform1iv = (PFNGLUNIFORM1IVPROC)load("glUniform1iv");
	glad_glUniform2iv = (PFNGLUNIFORM2IVPROC)load("glUniform2iv");
	glad_glUniform3iv = (PFNGLUNIFORM3IVPROC)load("glUniform3iv");
	glad_glUniform4iv = (PFNGLUNIFORM4IVPROC)load("glUniform4iv");
	glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)load("glUniformMatrix2fv");
	glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)load("glUniformMatrix3fv");
	glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)load("glUniformMatrix4fv");
	glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)load("glValidateProgram");
	glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)load("glVertexAttrib1d");
	glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)load("glVertexAttrib1dv");
	glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)load("glVertexAttrib1f");
	glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)load("glVertexAttrib1fv");
	glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)load("glVertexAttrib1s");
	glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)load("glVertexAttrib1sv");
	glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)load("glVertexAttrib2d");
	glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)load("glVertexAttrib2dv");
	glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)load("glVertexAttrib2f");
	glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)load("glVertexAttrib2fv");
	glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)load("glVertexAttrib2s");
	glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)load("glVertexAttrib2sv");
	glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)load("glVertexAttrib3d");
	glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)load("glVertexAttrib3dv");
	glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)load("glVertexAttrib3f");
	glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)load("glVertexAttrib3fv");
	glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)load("glVertexAttrib3s");
	glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)load("glVertexAttrib3sv");
	glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)load("glVertexAttrib4Nbv");
	glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)load("glVertexAttrib4Niv");
	glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)load("glVertexAttrib4Nsv");
	glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)load("glVertexAttrib4Nub");
	glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)load("glVertexAttrib4Nubv");
	glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)load("glVertexAttrib4Nuiv");
	glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)load("glVertexAttrib4Nusv");
	glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)load("glVertexAttrib4bv");
	glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)load("glVertexAttrib4d");
	glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)load("glVertexAttrib4dv");
	glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)load("glVertexAttrib4f");
	glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)load("glVertexAttrib4fv");
	glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)load("glVertexAttrib4iv");
	glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)load("glVertexAttrib4s");
	glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)load("glVertexAttrib4sv");
	glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)load("glVertexAttrib4ubv");
	glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)load("glVertexAttrib4uiv");
	glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)load("glVertexAttrib4usv");
	glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)load("glVertexAttribPointer");
}
static void load_GL_VERSION_2_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_2_1) return;
	glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)load("glUniformMatrix2x3fv");
	glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)load("glUniformMatrix3x2fv");
	glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)load("glUniformMatrix2x4fv");
	glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)load("glUniformMatrix4x2fv");
	glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)load("glUniformMatrix3x4fv");
	glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)load("glUniformMatrix4x3fv");
}
static void load_GL_VERSION_3_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_0) return;
	glad_glColorMaski = (PFNGLCOLORMASKIPROC)load("glColorMaski");
	glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)load("glGetBooleani_v");
	glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
	glad_glEnablei = (PFNGLENABLEIPROC)load("glEnablei");
	glad_glDisablei = (PFNGLDISABLEIPROC)load("glDisablei");
	glad_glIsEnabledi = (PFNGLISENABLEDIPROC)load("glIsEnabledi");
	glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)load("glBeginTransformFeedback");
	glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)load("glEndTransformFeedback");
	glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
	glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
	glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)load("glTransformFeedbackVaryings");
	glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)load("glGetTransformFeedbackVarying");
	glad_glClampColor = (PFNGLCLAMPCOLORPROC)load("glClampColor");
	glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)load("glBeginConditionalRender");
	glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)load("glEndConditionalRender");
	glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)load("glVertexAttribIPointer");
	glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)load("glGetVertexAttribIiv");
	glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)load("glGetVertexAttribIuiv");
	glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)load("glVertexAttribI1i");
	glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)load("glVertexAttribI2i");
	glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)load("glVertexAttribI3i");
	glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)load("glVertexAttribI4i");
	glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)load("glVertexAttribI1ui");
	glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)load("glVertexAttribI2ui");
	glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)load("glVertexAttribI3ui");
	glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)load("glVertexAttribI4ui");
	glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)load("glVertexAttribI1iv");
	glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)load("glVertexAttribI2iv");
	glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)load("glVertexAttribI3iv");
	glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)load("glVertexAttribI4iv");
	glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)load("glVertexAttribI1uiv");
	glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)load("glVertexAttribI2uiv");
	glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)load("glVertexAttribI3uiv");
	glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)load("glVertexAttribI4uiv");
	glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)load("glVertexAttribI4bv");
	glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)load("glVertexAttribI4sv");
	glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)load("glVertexAttribI4ubv");
	glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)load("glVertexAttribI4usv");
	glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)load("glGetUniformuiv");
	glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)load("glBindFragDataLocation");
	glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)load("glGetFragDataLocation");
	glad_glUniform1ui = (PFNGLUNIFORM1UIPROC)load("glUniform1ui");
	glad_glUniform2ui = (PFNGLUNIFORM2UIPROC)load("glUniform2ui");
	glad_glUniform3ui = (PFNGLUNIFORM3UIPROC)load("glUniform3ui");
	glad_glUniform4ui = (PFNGLUNIFORM4UIPROC)load("glUniform4ui");
	glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC)load("glUniform1uiv");
	glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC)load("glUniform2uiv");
	glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC)load("glUniform3uiv");
	glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC)load("glUniform4uiv");
	glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)load("glTexParameterIiv");
	glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)load("glTexParameterIuiv");
	glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)load("glGetTexParameterIiv");
	glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)load("glGetTexParameterIuiv");
	glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)load("glClearBufferiv");
	glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)load("glClearBufferuiv");
	glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)load("glClearBufferfv");
	glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)load("glClearBufferfi");
	glad_glGetStringi = (PFNGLGETSTRINGIPROC)load("glGetStringi");
	glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)load("glIsRenderbuffer");
	glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)load("glBindRenderbuffer");
	glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)load("glDeleteRenderbuffers");
	glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)load("glGenRenderbuffers");
	glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)load("glRenderbufferStorage");
	glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)load("glGetRenderbufferParameteriv");
	glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)load("glIsFramebuffer");
	glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)load("glBindFramebuffer");
	glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)load("glDeleteFramebuffers");
	glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)load("glGenFramebuffers");
	glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)load("glCheckFramebufferStatus");
	glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)load("glFramebufferTexture1D");
	glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)load("glFramebufferTexture2D");
	glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)load("glFramebufferTexture3D");
	glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)load("glFramebufferRenderbuffer");
	glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetFramebufferAttachmentParameteriv");
	glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)load("glGenerateMipmap");
	glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)load("glBlitFramebuffer");
	glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glRenderbufferStorageMultisample");
	glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)load("glFramebufferTextureLayer");
	glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)load("glMapBufferRange");
	glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)load("glFlushMappedBufferRange");
	glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)load("glBindVertexArray");
	glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)load("glDeleteVertexArrays");
	glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)load("glGenVertexArrays");
	glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC)load("glIsVertexArray");
}
static void load_GL_VERSION_3_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_1) return;
	glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)load("glDrawArraysInstanced");
	glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)load("glDrawElementsInstanced");
	glad_glTexBuffer = (PFNGLTEXBUFFERPROC)load("glTexBuffer");
	glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)load("glPrimitiveRestartIndex");
	glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)load("glCopyBufferSubData");
	glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)load("glGetUniformIndices");
	glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)load("glGetActiveUniformsiv");
	glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)load("glGetActiveUniformName");
	glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)load("glGetUniformBlockIndex");
	glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)load("glGetActiveUniformBlockiv");
	glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)load("glGetActiveUniformBlockName");
	glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)load("glUniformBlockBinding");
	glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
	glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
	glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
}
static void load_GL_VERSION_3_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_2) return;
	glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)load("glDrawElementsBaseVertex");
	glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)load("glDrawRangeElementsBaseVertex");
	glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)load("glDrawElementsInstancedBaseVertex");
	glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)load("glMultiDrawElementsBaseVertex");
	glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)load("glProvokingVertex");
	glad_glFenceSync = (PFNGLFENCESYNCPROC)load("glFenceSync");
	glad_glIsSync = (PFNGLISSYNCPROC)load("glIsSync");
	glad_glDeleteSync = (PFNGLDELETESYNCPROC)load("glDeleteSync");
	glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)load("glClientWaitSync");
	glad_glWaitSync = (PFNGLWAITSYNCPROC)load("glWaitSync");
	glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC)load("glGetInteger64v");
	glad_glGetSynciv = (PFNGLGETSYNCIVPROC)load("glGetSynciv");
	glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)load("glGetInteger64i_v");
	glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)load("glGetBufferParameteri64v");
	glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)load("glFramebufferTexture");
	glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)load("glTexImage2DMultisample");
	glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)load("glTexImage3DMultisample");
	glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)load("glGetMultisamplefv");
	glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC)load("glSampleMaski");
}
static void load_GL_VERSION_3_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_3) return;
	glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)load("glBindFragDataLocationIndexed");
	glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)load("glGetFragDataIndex");
	glad_glGenSamplers = (PFNGLGENSAMPLERSPROC)load("glGenSamplers");
	glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC)load("glDeleteSamplers");
	glad_glIsSampler = (PFNGLISSAMPLERPROC)load("glIsSampler");
	glad_glBindSampler = (PFNGLBINDSAMPLERPROC)load("glBindSampler");
	glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)load("glSamplerParameteri");
	glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)load("glSamplerParameteriv");
	glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)load("glSamplerParameterf");
	glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)load("glSamplerParameterfv");
	glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)load("glSamplerParameterIiv");
	glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)load("glSamplerParameterIuiv");
	glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)load("glGetSamplerParameteriv");
	glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)load("glGetSamplerParameterIiv");
	glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)load("glGetSamplerParameterfv");
	glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)load("glGetSamplerParameterIuiv");
	glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC)load("glQueryCounter");
	glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)load("glGetQueryObjecti64v");
	glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)load("glGetQueryObjectui64v");
	glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)load("glVertexAttribDivisor");
	glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)load("glVertexAttribP1ui");
	glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)load("glVertexAttribP1uiv");
	glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)load("glVertexAttribP2ui");
	glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)load("glVertexAttribP2uiv");
	glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)load("glVertexAttribP3ui");
	glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)load("glVertexAttribP3uiv");
	glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)load("glVertexAttribP4ui");
	glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)load("glVertexAttribP4uiv");
	glad_glVertexP2ui = (PFNGLVERTEXP2UIPROC)load("glVertexP2ui");
	glad_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC)load("glVertexP2uiv");
	glad_glVertexP3ui = (PFNGLVERTEXP3UIPROC)load("glVertexP3ui");
	glad_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC)load("glVertexP3uiv");
	glad_glVertexP4ui = (PFNGLVERTEXP4UIPROC)load("glVertexP4ui");
	glad_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC)load("glVertexP4uiv");
	glad_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)load("glTexCoordP1ui");
	glad_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)load("glTexCoordP1uiv");
	glad_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)load("glTexCoordP2ui");
	glad_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)load("glTexCoordP2uiv");
	glad_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)load("glTexCoordP3ui");
	glad_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)load("glTexCoordP3uiv");
	glad_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)load("glTexCoordP4ui");
	glad_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)load("glTexCoordP4uiv");
	glad_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)load("glMultiTexCoordP1ui");
	glad_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)load("glMultiTexCoordP1uiv");
	glad_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)load("glMultiTexCoordP2ui");
	glad_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)load("glMultiTexCoordP2uiv");
	glad_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)load("glMultiTexCoordP3ui");
	glad_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)load("glMultiTexCoordP3uiv");
	glad_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)load("glMultiTexCoordP4ui");
	glad_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)load("glMultiTexCoordP4uiv");
	glad_glNormalP3ui = (PFNGLNORMALP3UIPROC)load("glNormalP3ui");
	glad_glNormalP3uiv = (PFNGLNORMALP3UIVPROC)load("glNormalP3uiv");
	glad_glColorP3ui = (PFNGLCOLORP3UIPROC)load("glColorP3ui");
	glad_glColorP3uiv = (PFNGLCOLORP3UIVPROC)load("glColorP3uiv");
	glad_glColorP4ui = (PFNGLCOLORP4UIPROC)load("glColorP4ui");
	glad_glColorP4uiv = (PFNGLCOLORP4UIVPROC)load("glColorP4uiv");
	glad_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)load("glSecondaryColorP3ui");
	glad_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)load("glSecondaryColorP3uiv");
}
static void load_GL_VERSION_4_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_0) return;
	glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC)load("glMinSampleShading");
	glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC)load("glBlendEquationi");
	glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC)load("glBlendEquationSeparatei");
	glad_glBlendFunci = (PFNGLBLENDFUNCIPROC)load("glBlendFunci");
	glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC)load("glBlendFuncSeparatei");
	glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC)load("glDrawArraysIndirect");
	glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC)load("glDrawElementsIndirect");
	glad_glUniform1d = (PFNGLUNIFORM1DPROC)load("glUniform1d");
	glad_glUniform2d = (PFNGLUNIFORM2DPROC)load("glUniform2d");
	glad_glUniform3d = (PFNGLUNIFORM3DPROC)load("glUniform3d");
	glad_glUniform4d = (PFNGLUNIFORM4DPROC)load("glUniform4d");
	glad_glUniform1dv = (PFNGLUNIFORM1DVPROC)load("glUniform1dv");
	glad_glUniform2dv = (PFNGLUNIFORM2DVPROC)load("glUniform2dv");
	glad_glUniform3dv = (PFNGLUNIFORM3DVPROC)load("glUniform3dv");
	glad_glUniform4dv = (PFNGLUNIFORM4DVPROC)load("glUniform4dv");
	glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC)load("glUniformMatrix2dv");
	glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC)load("glUniformMatrix3dv");
	glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC)load("glUniformMatrix4dv");
	glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC)load("glUniformMatrix2x3dv");
	glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC)load("glUniformMatrix2x4dv");
	glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC)load("glUniformMatrix3x2dv");
	glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC)load("glUniformMatrix3x4dv");
	glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC)load("glUniformMatrix4x2dv");
	glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC)load("glUniformMatrix4x3dv");
	glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC)load("glGetUniformdv");
	glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)load("glGetSubroutineUniformLocation");
	glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC)load("glGetSubroutineIndex");
	glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)load("glGetActiveSubroutineUniformiv");
	glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)load("glGetActiveSubroutineUniformName");
	glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC)load("glGetActiveSubroutineName");
	glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC)load("glUniformSubroutinesuiv");
	glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC)load("glGetUniformSubroutineuiv");
	glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC)load("glGetProgramStageiv");
	glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC)load("glPatchParameteri");
	glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC)load("glPatchParameterfv");
	glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC)load("glBindTransformFeedback");
	glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC)load("glDeleteTransformFeedbacks");
	glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC)load("glGenTransformFeedbacks");
	glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC)load("glIsTransformFeedback");
	glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC)load("glPauseTransformFeedback");
	glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC)load("glResumeTransformFeedback");
	glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC)load("glDrawTransformFeedback");
	glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)load("glDrawTransformFeedbackStream");
	glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC)load("glBeginQueryIndexed");
	glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC)load("glEndQueryIndexed");
	glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC)load("glGetQueryIndexediv");
}
static void load_GL_VERSION_4_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_1) return;
	glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC)load("glReleaseShaderCompiler");
	glad_glShaderBinary = (PFNGLSHADERBINARYPROC)load("glShaderBinary");
	glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC)load("glGetShaderPrecisionFormat");
	glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC)load("glDepthRangef");
	glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC)load("glClearDepthf");
	glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC)load("glGetProgramBinary");
	glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC)load("glProgramBinary");
	glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)load("glProgramParameteri");
	glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC)load("glUseProgramStages");
	glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC)load("glActiveShaderProgram");
	glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC)load("glCreateShaderProgramv");
	glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC)load("glBindProgramPipeline");
	glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC)load("glDeleteProgramPipelines");
	glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC)load("glGenProgramPipelines");
	glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC)load("glIsProgramPipeline");
	glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC)load("glGetProgramPipelineiv");
	glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)load("glProgramParameteri");
	glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC)load("glProgramUniform1i");
	glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC)load("glProgramUniform1iv");
	glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC)load("glProgramUniform1f");
	glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC)load("glProgramUniform1fv");
	glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC)load("glProgramUniform1d");
	glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC)load("glProgramUniform1dv");
	glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC)load("glProgramUniform1ui");
	glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC)load("glProgramUniform1uiv");
	glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC)load("glProgramUniform2i");
	glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC)load("glProgramUniform2iv");
	glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC)load("glProgramUniform2f");
	glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC)load("glProgramUniform2fv");
	glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC)load("glProgramUniform2d");
	glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC)load("glProgramUniform2dv");
	glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC)load("glProgramUniform2ui");
	glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC)load("glProgramUniform2uiv");
	glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC)load("glProgramUniform3i");
	glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC)load("glProgramUniform3iv");
	glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC)load("glProgramUniform3f");
	glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC)load("glProgramUniform3fv");
	glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC)load("glProgramUniform3d");
	glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC)load("glProgramUniform3dv");
	glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC)load("glProgramUniform3ui");
	glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC)load("glProgramUniform3uiv");
	glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC)load("glProgramUniform4i");
	glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC)load("glProgramUniform4iv");
	glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC)load("glProgramUniform4f");
	glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC)load("glProgramUniform4fv");
	glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC)load("glProgramUniform4d");
	glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC)load("glProgramUniform4dv");
	glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC)load("glProgramUniform4ui");
	glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC)load("glProgramUniform4uiv");
	glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC)load("glProgramUniformMatrix2fv");
	glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC)load("glProgramUniformMatrix3fv");
	glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC)load("glProgramUniformMatrix4fv");
	glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC)load("glProgramUniformMatrix2dv");
	glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC)load("glProgramUniformMatrix3dv");
	glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC)load("glProgramUniformMatrix4dv");
	glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)load("glProgramUniformMatrix2x3fv");
	glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)load("glProgramUniformMatrix3x2fv");
	glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)load("glProgramUniformMatrix2x4fv");
	glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)load("glProgramUniformMatrix4x2fv");
	glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)load("glProgramUniformMatrix3x4fv");
	glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)load("glProgramUniformMatrix4x3fv");
	glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)load("glProgramUniformMatrix2x3dv");
	glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)load("glProgramUniformMatrix3x2dv");
	glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)load("glProgramUniformMatrix2x4dv");
	glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)load("glProgramUniformMatrix4x2dv");
	glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)load("glProgramUniformMatrix3x4dv");
	glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)load("glProgramUniformMatrix4x3dv");
	glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC)load("glValidateProgramPipeline");
	glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC)load("glGetProgramPipelineInfoLog");
	glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC)load("glVertexAttribL1d");
	glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC)load("glVertexAttribL2d");
	glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC)load("glVertexAttribL3d");
	glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC)load("glVertexAttribL4d");
	glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC)load("glVertexAttribL1dv");
	glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC)load("glVertexAttribL2dv");
	glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC)load("glVertexAttribL3dv");
	glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC)load("glVertexAttribL4dv");
	glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC)load("glVertexAttribLPointer");
	glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC)load("glGetVertexAttribLdv");
	glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC)load("glViewportArrayv");
	glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC)load("glViewportIndexedf");
	glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC)load("glViewportIndexedfv");
	glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC)load("glScissorArrayv");
	glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC)load("glScissorIndexed");
	glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC)load("glScissorIndexedv");
	glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC)load("glDepthRangeArrayv");
	glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC)load("glDepthRangeIndexed");
	glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC)load("glGetFloati_v");
	glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC)load("glGetDoublei_v");
}
static void load_GL_VERSION_4_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_2) return;
	glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)load("glDrawArraysInstancedBaseInstance");
	glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)load("glDrawElementsInstancedBaseInstance");
	glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)load("glDrawElementsInstancedBaseVertexBaseInstance");
	glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC)load("glGetInternalformativ");
	glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)load("glGetActiveAtomicCounterBufferiv");
	glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC)load("glBindImageTexture");
	glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC)load("glMemoryBarrier");
	glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC)load("glTexStorage1D");
	glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC)load("glTexStorage2D");
	glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC)load("glTexStorage3D");
	glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)load("glDrawTransformFeedbackInstanced");
	glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)load("glDrawTransformFeedbackStreamInstanced");
}
static void load_GL_VERSION_4_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_3) return;
	glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC)load("glClearBufferData");
	glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC)load("glClearBufferSubData");
	glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC)load("glDispatchCompute");
	glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC)load("glDispatchComputeIndirect");
	glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC)load("glCopyImageSubData");
	glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC)load("glFramebufferParameteri");
	glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC)load("glGetFramebufferParameteriv");
	glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC)load("glGetInternalformati64v");
	glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC)load("glInvalidateTexSubImage");
	glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC)load("glInvalidateTexImage");
	glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC)load("glInvalidateBufferSubData");
	glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC)load("glInvalidateBufferData");
	glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC)load("glInvalidateFramebuffer");
	glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC)load("glInvalidateSubFramebuffer");
	glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC)load("glMultiDrawArraysIndirect");
	glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC)load("glMultiDrawElementsIndirect");
	glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC)load("glGetProgramInterfaceiv");
	glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC)load("glGetProgramResourceIndex");
	glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC)load("glGetProgramResourceName");
	glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC)load("glGetProgramResourceiv");
	glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC)load("glGetProgramResourceLocation");
	glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)load("glGetProgramResourceLocationIndex");
	glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC)load("glShaderStorageBlockBinding");
	glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC)load("glTexBufferRange");
	glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC)load("glTexStorage2DMultisample");
	glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC)load("glTexStorage3DMultisample");
	glad_glTextureView = (PFNGLTEXTUREVIEWPROC)load("glTextureView");
	glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC)load("glBindVertexBuffer");
	glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC)load("glVertexAttribFormat");
	glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC)load("glVertexAttribIFormat");
	glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC)load("glVertexAttribLFormat");
	glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC)load("glVertexAttribBinding");
	glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC)load("glVertexBindingDivisor");
	glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC)load("glDebugMessageControl");
	glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC)load("glDebugMessageInsert");
	glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)load("glDebugMessageCallback");
	glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC)load("glGetDebugMessageLog");
	glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC)load("glPushDebugGroup");
	glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC)load("glPopDebugGroup");
	glad_glObjectLabel = (PFNGLOBJECTLABELPROC)load("glObjectLabel");
	glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC)load("glGetObjectLabel");
	glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC)load("glObjectPtrLabel");
	glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC)load("glGetObjectPtrLabel");
	glad_glGetPointerv = (PFNGLGETPOINTERVPROC)load("glGetPointerv");
}
static void load_GL_VERSION_4_4(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_4) return;
	glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC)load("glBufferStorage");
	glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC)load("glClearTexImage");
	glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC)load("glClearTexSubImage");
	glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC)load("glBindBuffersBase");
	glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC)load("glBindBuffersRange");
	glad_glBindTextures = (PFNGLBINDTEXTURESPROC)load("glBindTextures");
	glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC)load("glBindSamplers");
	glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC)load("glBindImageTextures");
	glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC)load("glBindVertexBuffers");
}
static void load_GL_VERSION_4_5(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_5) return;
	glad_glClipControl = (PFNGLCLIPCONTROLPROC)load("glClipControl");
	glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC)load("glCreateTransformFeedbacks");
	glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)load("glTransformFeedbackBufferBase");
	glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)load("glTransformFeedbackBufferRange");
	glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC)load("glGetTransformFeedbackiv");
	glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC)load("glGetTransformFeedbacki_v");
	glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC)load("glGetTransformFeedbacki64_v");
	glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC)load("glCreateBuffers");
	glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC)load("glNamedBufferStorage");
	glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC)load("glNamedBufferData");
	glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC)load("glNamedBufferSubData");
	glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC)load("glCopyNamedBufferSubData");
	glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC)load("glClearNamedBufferData");
	glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC)load("glClearNamedBufferSubData");
	glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC)load("glMapNamedBuffer");
	glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC)load("glMapNamedBufferRange");
	glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC)load("glUnmapNamedBuffer");
	glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)load("glFlushMappedNamedBufferRange");
	glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC)load("glGetNamedBufferParameteriv");
	glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)load("glGetNamedBufferParameteri64v");
	glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC)load("glGetNamedBufferPointerv");
	glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC)load("glGetNamedBufferSubData");
	glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC)load("glCreateFramebuffers");
	glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)load("glNamedFramebufferRenderbuffer");
	glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)load("glNamedFramebufferParameteri");
	glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)load("glNamedFramebufferTexture");
	glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)load("glNamedFramebufferTextureLayer");
	glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)load("glNamedFramebufferDrawBuffer");
	glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)load("glNamedFramebufferDrawBuffers");
	glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)load("glNamedFramebufferReadBuffer");
	glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)load("glInvalidateNamedFramebufferData");
	glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)load("glInvalidateNamedFramebufferSubData");
	glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)load("glClearNamedFramebufferiv");
	glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)load("glClearNamedFramebufferuiv");
	glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)load("glClearNamedFramebufferfv");
	glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)load("glClearNamedFramebufferfi");
	glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC)load("glBlitNamedFramebuffer");
	glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)load("glCheckNamedFramebufferStatus");
	glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)load("glGetNamedFramebufferParameteriv");
	glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetNamedFramebufferAttachmentParameteriv");
	glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC)load("glCreateRenderbuffers");
	glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC)load("glNamedRenderbufferStorage");
	glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glNamedRenderbufferStorageMultisample");
	glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)load("glGetNamedRenderbufferParameteriv");
	glad_glCreateTextures = (PFNGLCREATETEXTURESPROC)load("glCreateTextures");
	glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC)load("glTextureBuffer");
	glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC)load("glTextureBufferRange");
	glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC)load("glTextureStorage1D");
	glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC)load("glTextureStorage2D");
	glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC)load("glTextureStorage3D");
	glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)load("glTextureStorage2DMultisample");
	glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)load("glTextureStorage3DMultisample");
	glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC)load("glTextureSubImage1D");
	glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC)load("glTextureSubImage2D");
	glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC)load("glTextureSubImage3D");
	glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)load("glCompressedTextureSubImage1D");
	glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)load("glCompressedTextureSubImage2D");
	glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)load("glCompressedTextureSubImage3D");
	glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC)load("glCopyTextureSubImage1D");
	glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC)load("glCopyTextureSubImage2D");
	glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC)load("glCopyTextureSubImage3D");
	glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC)load("glTextureParameterf");
	glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC)load("glTextureParameterfv");
	glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC)load("glTextureParameteri");
	glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC)load("glTextureParameterIiv");
	glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC)load("glTextureParameterIuiv");
	glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC)load("glTextureParameteriv");
	glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC)load("glGenerateTextureMipmap");
	glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC)load("glBindTextureUnit");
	glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC)load("glGetTextureImage");
	glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)load("glGetCompressedTextureImage");
	glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC)load("glGetTextureLevelParameterfv");
	glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC)load("glGetTextureLevelParameteriv");
	glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC)load("glGetTextureParameterfv");
	glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC)load("glGetTextureParameterIiv");
	glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC)load("glGetTextureParameterIuiv");
	glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC)load("glGetTextureParameteriv");
	glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC)load("glCreateVertexArrays");
	glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC)load("glDisableVertexArrayAttrib");
	glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC)load("glEnableVertexArrayAttrib");
	glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC)load("glVertexArrayElementBuffer");
	glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC)load("glVertexArrayVertexBuffer");
	glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC)load("glVertexArrayVertexBuffers");
	glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC)load("glVertexArrayAttribBinding");
	glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC)load("glVertexArrayAttribFormat");
	glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC)load("glVertexArrayAttribIFormat");
	glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC)load("glVertexArrayAttribLFormat");
	glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC)load("glVertexArrayBindingDivisor");
	glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC)load("glGetVertexArrayiv");
	glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC)load("glGetVertexArrayIndexediv");
	glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC)load("glGetVertexArrayIndexed64iv");
	glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC)load("glCreateSamplers");
	glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC)load("glCreateProgramPipelines");
	glad_glCreateQueries = (PFNGLCREATEQUERIESPROC)load("glCreateQueries");
	glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC)load("glGetQueryBufferObjecti64v");
	glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC)load("glGetQueryBufferObjectiv");
	glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC)load("glGetQueryBufferObjectui64v");
	glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC)load("glGetQueryBufferObjectuiv");
	glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC)load("glMemoryBarrierByRegion");
	glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC)load("glGetTextureSubImage");
	glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)load("glGetCompressedTextureSubImage");
	glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC)load("glGetGraphicsResetStatus");
	glad_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC)load("glGetnCompressedTexImage");
	glad_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC)load("glGetnTexImage");
	glad_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC)load("glGetnUniformdv");
	glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC)load("glGetnUniformfv");
	glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC)load("glGetnUniformiv");
	glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC)load("glGetnUniformuiv");
	glad_glReadnPixels = (PFNGLREADNPIXELSPROC)load("glReadnPixels");
	glad_glGetnMapdv = (PFNGLGETNMAPDVPROC)load("glGetnMapdv");
	glad_glGetnMapfv = (PFNGLGETNMAPFVPROC)load("glGetnMapfv");
	glad_glGetnMapiv = (PFNGLGETNMAPIVPROC)load("glGetnMapiv");
	glad_glGetnPixelMapfv = (PFNGLGETNPIXELMAPFVPROC)load("glGetnPixelMapfv");
	glad_glGetnPixelMapuiv = (PFNGLGETNPIXELMAPUIVPROC)load("glGetnPixelMapuiv");
	glad_glGetnPixelMapusv = (PFNGLGETNPIXELMAPUSVPROC)load("glGetnPixelMapusv");
	glad_glGetnPolygonStipple = (PFNGLGETNPOLYGONSTIPPLEPROC)load("glGetnPolygonStipple");
	glad_glGetnColorTable = (PFNGLGETNCOLORTABLEPROC)load("glGetnColorTable");
	glad_glGetnConvolutionFilter = (PFNGLGETNCONVOLUTIONFILTERPROC)load("glGetnConvolutionFilter");
	glad_glGetnSeparableFilter = (PFNGLGETNSEPARABLEFILTERPROC)load("glGetnSeparableFilter");
	glad_glGetnHistogram = (PFNGLGETNHISTOGRAMPROC)load("glGetnHistogram");
	glad_glGetnMinmax = (PFNGLGETNMINMAXPROC)load("glGetnMinmax");
	glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC)load("glTextureBarrier");
}
static void load_GL_VERSION_4_6(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_6) return;
	glad_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC)load("glSpecializeShader");
	glad_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)load("glMultiDrawArraysIndirectCount");
	glad_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)load("glMultiDrawElementsIndirectCount");
	glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC)load("glPolygonOffsetClamp");
}
static int find_extensionsGL(void) {
	if (!get_exts()) return 0;
	(void)&has_ext;
	free_exts();
	return 1;
}

static void find_coreGL(void) {

    /* Thank you @elmindreda
     * https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176
     * https://github.com/glfw/glfw/blob/master/src/context.c#L36
     */
    int i, major, minor;

    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        NULL
    };

    version = (const char*) glGetString(GL_VERSION);
    if (!version) return;

    for (i = 0;  prefixes[i];  i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }

/* PR #18 */
#ifdef _MSC_VER
    sscanf_s(version, "%d.%d", &major, &minor);
#else
    sscanf(version, "%d.%d", &major, &minor);
#endif

    GLVersion.major = major; GLVersion.minor = minor;
    max_loaded_major = major; max_loaded_minor = minor;
	GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
	GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
	GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
	GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
	GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
	GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
	GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
	GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
	GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
	GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
	GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
	GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
	GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;
	GLAD_GL_VERSION_4_1 = (major == 4 && minor >= 1) || major > 4;
	GLAD_GL_VERSION_4_2 = (major == 4 && minor >= 2) || major > 4;
	GLAD_GL_VERSION_4_3 = (major == 4 && minor >= 3) || major > 4;
	GLAD_GL_VERSION_4_4 = (major == 4 && minor >= 4) || major > 4;
	GLAD_GL_VERSION_4_5 = (major == 4 && minor >= 5) || major > 4;
	GLAD_GL_VERSION_4_6 = (major == 4 && minor >= 6) || major > 4;
	if (GLVersion.major > 4 || (GLVersion.major >= 4 && GLVersion.minor >= 6)) {
		max_loaded_major = 4;
		max_loaded_minor = 6;
	}
}

int gladLoadGLLoader(GLADloadproc load) {
	GLVersion.major = 0; GLVersion.minor = 0;
	glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
	if(glGetString == NULL) return 0;
	if(glGetString(GL_VERSION) == NULL) return 0;
	find_coreGL();
	load_GL_VERSION_1_0(load);
	load_GL_VERSION_1_1(load);
	load_GL_VERSION_1_2(load);
	load_GL_VERSION_1_3(load);
	load_GL_VERSION_1_4(load);
	load_GL_VERSION_1_5(load);
	load_GL_VERSION_2_0(load);
	load_GL_VERSION_2_1(load);
	load_GL_VERSION_3_0(load);
	load_GL_VERSION_3_1(load);
	load_GL_VERSION_3_2(load);
	load_GL_VERSION_3_3(load);
	load_GL_VERSION_4_0(load);
	load_GL_VERSION_4_1(load);
	load_GL_VERSION_4_2(load);
	load_GL_VERSION_4_3(load);
	load_GL_VERSION_4_4(load);
	load_GL_VERSION_4_5(load);
	load_GL_VERSION_4_6(load);

	if (!find_extensionsGL()) return 0;
	return GLVersion.major != 0 || GLVersion.minor != 0;
}


```

`Hazel/vendor/entt/LICENSE.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2017-2020 Michele Caini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copy of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copy or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Hazel/vendor/entt/include/entt.hpp`:

```hpp
// #include "core/algorithm.hpp"
#ifndef ENTT_CORE_ALGORITHM_HPP
#define ENTT_CORE_ALGORITHM_HPP


#include <vector>
#include <utility>
#include <iterator>
#include <algorithm>
#include <functional>
// #include "utility.hpp"
#ifndef ENTT_CORE_UTILITY_HPP
#define ENTT_CORE_UTILITY_HPP


#include <utility>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/*! @brief Identity function object (waiting for C++20). */
struct identity {
    /**
     * @brief Returns its argument unchanged.
     * @tparam Type Type of the argument.
     * @param value The actual argument.
     * @return The submitted value as-is.
     */
    template<class Type>
    constexpr Type && operator()(Type &&value) const ENTT_NOEXCEPT {
        return std::forward<Type>(value);
    }
};


/**
 * @brief Constant utility to disambiguate overloaded members of a class.
 * @tparam Type Type of the desired overload.
 * @tparam Class Type of class to which the member belongs.
 * @param member A valid pointer to a member.
 * @return Pointer to the member.
 */
template<typename Type, typename Class>
constexpr auto overload(Type Class:: *member) ENTT_NOEXCEPT { return member; }


/**
 * @brief Constant utility to disambiguate overloaded functions.
 * @tparam Func Function type of the desired overload.
 * @param func A valid pointer to a function.
 * @return Pointer to the function.
 */
template<typename Func>
constexpr auto overload(Func *func) ENTT_NOEXCEPT { return func; }


/**
 * @brief Helper type for visitors.
 * @tparam Func Types of function objects.
 */
template<class... Func>
struct overloaded: Func... {
    using Func::operator()...;
};


/**
 * @brief Deduction guide.
 * @tparam Func Types of function objects.
 */
template<class... Func>
overloaded(Func...) -> overloaded<Func...>;


/**
 * @brief Basic implementation of a y-combinator.
 * @tparam Func Type of a potentially recursive function.
 */
template<class Func>
struct y_combinator {
    /**
     * @brief Constructs a y-combinator from a given function.
     * @param recursive A potentially recursive function.
     */
    y_combinator(Func recursive):
        func{std::move(recursive)}
    {}

    /**
     * @brief Invokes a y-combinator and therefore its underlying function.
     * @tparam Args Types of arguments to use to invoke the underlying function.
     * @param args Parameters to use to invoke the underlying function.
     * @return Return value of the underlying function, if any.
     */
    template <class... Args>
    decltype(auto) operator()(Args &&... args) const {
        return func(*this, std::forward<Args>(args)...);
    }

    /*! @copydoc operator()() */
    template <class... Args>
    decltype(auto) operator()(Args &&... args) {
        return func(*this, std::forward<Args>(args)...);
    }

private:
    Func func;
};


}


#endif



namespace entt {


/**
 * @brief Function object to wrap `std::sort` in a class type.
 *
 * Unfortunately, `std::sort` cannot be passed as template argument to a class
 * template or a function template.<br/>
 * This class fills the gap by wrapping some flavors of `std::sort` in a
 * function object.
 */
struct std_sort {
    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given binary comparison function.
     *
     * @tparam It Type of random access iterator.
     * @tparam Compare Type of comparison function object.
     * @tparam Args Types of arguments to forward to the sort function.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     * @param args Arguments to forward to the sort function, if any.
     */
    template<typename It, typename Compare = std::less<>, typename... Args>
    void operator()(It first, It last, Compare compare = Compare{}, Args &&... args) const {
        std::sort(std::forward<Args>(args)..., std::move(first), std::move(last), std::move(compare));
    }
};


/*! @brief Function object for performing insertion sort. */
struct insertion_sort {
    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given binary comparison function.
     *
     * @tparam It Type of random access iterator.
     * @tparam Compare Type of comparison function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     */
    template<typename It, typename Compare = std::less<>>
    void operator()(It first, It last, Compare compare = Compare{}) const {
        if(first < last) {
            for(auto it = first+1; it < last; ++it) {
                auto value = std::move(*it);
                auto pre = it;

                for(; pre > first && compare(value, *(pre-1)); --pre) {
                    *pre = std::move(*(pre-1));
                }

                *pre = std::move(value);
            }
        }
    }
};


/**
 * @brief Function object for performing LSD radix sort.
 * @tparam Bit Number of bits processed per pass.
 * @tparam N Maximum number of bits to sort.
 */
template<std::size_t Bit, std::size_t N>
struct radix_sort {
    static_assert((N % Bit) == 0);

    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given _getter_ to access the
     * actual data to be sorted.
     *
     * This implementation is inspired by the online book
     * [Physically Based Rendering](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#RadixSort).
     *
     * @tparam It Type of random access iterator.
     * @tparam Getter Type of _getter_ function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param getter A valid _getter_ function object.
     */
    template<typename It, typename Getter = identity>
    void operator()(It first, It last, Getter getter = Getter{}) const {
        if(first < last) {
            static constexpr auto mask = (1 << Bit) - 1;
            static constexpr auto buckets = 1 << Bit;
            static constexpr auto passes = N / Bit;

            using value_type = typename std::iterator_traits<It>::value_type;
            std::vector<value_type> aux(std::distance(first, last));

            auto part = [getter = std::move(getter)](auto from, auto to, auto out, auto start) {
                std::size_t index[buckets]{};
                std::size_t count[buckets]{};

                std::for_each(from, to, [&getter, &count, start](const value_type &item) {
                    ++count[(getter(item) >> start) & mask];
                });

                std::for_each(std::next(std::begin(index)), std::end(index), [index = std::begin(index), count = std::begin(count)](auto &item) mutable {
                    item = *(index++) + *(count++);
                });

                std::for_each(from, to, [&getter, &out, &index, start](value_type &item) {
                    out[index[(getter(item) >> start) & mask]++] = std::move(item);
                });
            };

            for(std::size_t pass = 0; pass < (passes & ~1); pass += 2) {
                part(first, last, aux.begin(), pass * Bit);
                part(aux.begin(), aux.end(), first, (pass + 1) * Bit);
            }

            if constexpr(passes & 1) {
                part(first, last, aux.begin(), (passes - 1) * Bit);
                std::move(aux.begin(), aux.end(), first);
            }
        }
    }
};


}


#endif

// #include "core/attribute.h"
#ifndef ENTT_CORE_ATTRIBUTE_H
#define ENTT_CORE_ATTRIBUTE_H


#ifndef ENTT_EXPORT
#   if defined _WIN32 || defined __CYGWIN__ || defined _MSC_VER
#       define ENTT_EXPORT __declspec(dllexport)
#       define ENTT_IMPORT __declspec(dllimport)
#       define ENTT_HIDDEN
#   elif defined __GNUC__ && __GNUC__ >= 4
#       define ENTT_EXPORT __attribute__((visibility("default")))
#       define ENTT_IMPORT __attribute__((visibility("default")))
#       define ENTT_HIDDEN __attribute__((visibility("hidden")))
#   else /* Unsupported compiler */
#       define ENTT_EXPORT
#       define ENTT_IMPORT
#       define ENTT_HIDDEN
#   endif
#endif


#ifndef ENTT_API
#   if defined ENTT_API_EXPORT
#       define ENTT_API ENTT_EXPORT
#   elif defined ENTT_API_IMPORT
#       define ENTT_API ENTT_IMPORT
#   else /* No API */
#       define ENTT_API
#   endif
#endif


#endif

// #include "core/family.hpp"
#ifndef ENTT_CORE_FAMILY_HPP
#define ENTT_CORE_FAMILY_HPP


// #include "../config/config.h"

// #include "fwd.hpp"
#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP


// #include "../config/config.h"



namespace entt {


/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;


}


#endif



namespace entt {


/**
 * @brief Dynamic identifier generator.
 *
 * Utility class template that can be used to assign unique identifiers to types
 * at runtime. Use different specializations to create separate sets of
 * identifiers.
 */
template<typename...>
class family {
    inline static ENTT_MAYBE_ATOMIC(id_type) identifier{};

public:
    /*! @brief Unsigned integer type. */
    using family_type = id_type;

    /*! @brief Statically generated unique identifier for the given type. */
    template<typename... Type>
    // at the time I'm writing, clang crashes during compilation if auto is used instead of family_type
    inline static const family_type type = identifier++;
};


}


#endif

// #include "core/hashed_string.hpp"
#ifndef ENTT_CORE_HASHED_STRING_HPP
#define ENTT_CORE_HASHED_STRING_HPP


#include <cstddef>
#include <cstdint>
// #include "../config/config.h"

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename>
struct fnv1a_traits;


template<>
struct fnv1a_traits<std::uint32_t> {
    using type = std::uint32_t;
    static constexpr std::uint32_t offset = 2166136261;
    static constexpr std::uint32_t prime = 16777619;
};


template<>
struct fnv1a_traits<std::uint64_t> {
    using type = std::uint64_t;
    static constexpr std::uint64_t offset = 14695981039346656037ull;
    static constexpr std::uint64_t prime = 1099511628211ull;
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Zero overhead unique identifier.
 *
 * A hashed string is a compile-time tool that allows users to use
 * human-readable identifers in the codebase while using their numeric
 * counterparts at runtime.<br/>
 * Because of that, a hashed string can also be used in constant expressions if
 * required.
 *
 * @tparam Char Character type.
 */
template<typename Char>
class basic_hashed_string {
    using traits_type = internal::fnv1a_traits<id_type>;

    struct const_wrapper {
        // non-explicit constructor on purpose
        constexpr const_wrapper(const Char *curr) ENTT_NOEXCEPT: str{curr} {}
        const Char *str;
    };

    // Fowler–Noll–Vo hash function v. 1a - the good
    static constexpr id_type helper(const Char *curr) ENTT_NOEXCEPT {
        auto value = traits_type::offset;

        while(*curr != 0) {
            value = (value ^ static_cast<traits_type::type>(*(curr++))) * traits_type::prime;
        }

        return value;
    }

public:
    /*! @brief Character type. */
    using value_type = Char;
    /*! @brief Unsigned integer type. */
    using hash_type = id_type;

    /**
     * @brief Returns directly the numeric representation of a string.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * const auto value = basic_hashed_string<char>::to_value("my.png");
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifer.
     * @return The numeric representation of the string.
     */
    template<std::size_t N>
    static constexpr hash_type value(const value_type (&str)[N]) ENTT_NOEXCEPT {
        return helper(str);
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     * @return The numeric representation of the string.
     */
    static hash_type value(const_wrapper wrapper) ENTT_NOEXCEPT {
        return helper(wrapper.str);
    }

    /**
     * @brief Returns directly the numeric representation of a string view.
     * @param str Human-readable identifer.
     * @param size Length of the string to hash.
     * @return The numeric representation of the string.
     */
    static hash_type value(const value_type *str, std::size_t size) ENTT_NOEXCEPT {
        id_type partial{traits_type::offset};
        while(size--) { partial = (partial^(str++)[0])*traits_type::prime; }
        return partial;
    }

    /*! @brief Constructs an empty hashed string. */
    constexpr basic_hashed_string() ENTT_NOEXCEPT
        : str{nullptr}, hash{}
    {}

    /**
     * @brief Constructs a hashed string from an array of const characters.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * basic_hashed_string<char> hs{"my.png"};
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param curr Human-readable identifer.
     */
    template<std::size_t N>
    constexpr basic_hashed_string(const value_type (&curr)[N]) ENTT_NOEXCEPT
        : str{curr}, hash{helper(curr)}
    {}

    /**
     * @brief Explicit constructor on purpose to avoid constructing a hashed
     * string directly from a `const value_type *`.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     */
    explicit constexpr basic_hashed_string(const_wrapper wrapper) ENTT_NOEXCEPT
        : str{wrapper.str}, hash{helper(wrapper.str)}
    {}

    /**
     * @brief Returns the human-readable representation of a hashed string.
     * @return The string used to initialize the instance.
     */
    constexpr const value_type * data() const ENTT_NOEXCEPT {
        return str;
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr hash_type value() const ENTT_NOEXCEPT {
        return hash;
    }

    /*! @copydoc data */
    constexpr operator const value_type *() const ENTT_NOEXCEPT { return data(); }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr operator hash_type() const ENTT_NOEXCEPT { return value(); }

    /**
     * @brief Compares two hashed strings.
     * @param other Hashed string with which to compare.
     * @return True if the two hashed strings are identical, false otherwise.
     */
    constexpr bool operator==(const basic_hashed_string &other) const ENTT_NOEXCEPT {
        return hash == other.hash;
    }

private:
    const value_type *str;
    hash_type hash;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the character type of the hashed string directly from a
 * human-readable identifer provided to the constructor.
 *
 * @tparam Char Character type.
 * @tparam N Number of characters of the identifier.
 * @param str Human-readable identifer.
 */
template<typename Char, std::size_t N>
basic_hashed_string(const Char (&str)[N]) ENTT_NOEXCEPT
-> basic_hashed_string<Char>;


/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings are identical, false otherwise.
 */
template<typename Char>
constexpr bool operator!=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/*! @brief Aliases for common character types. */
using hashed_string = basic_hashed_string<char>;


/*! @brief Aliases for common character types. */
using hashed_wstring = basic_hashed_string<wchar_t>;


}


/**
 * @brief User defined literal for hashed strings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed string.
 */
constexpr entt::hashed_string operator"" ENTT_HS_SUFFIX(const char *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_string{str};
}


/**
 * @brief User defined literal for hashed wstrings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed wstring.
 */
constexpr entt::hashed_wstring operator"" ENTT_HWS_SUFFIX(const wchar_t *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_wstring{str};
}


#endif

// #include "core/ident.hpp"
#ifndef ENTT_CORE_IDENT_HPP
#define ENTT_CORE_IDENT_HPP


#include <tuple>
#include <cstddef>
#include <utility>
#include <type_traits>
// #include "../config/config.h"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Types identifiers.
 *
 * Variable template used to generate identifiers at compile-time for the given
 * types. Use the `get` member function to know what's the identifier associated
 * to the specific type.
 *
 * @note
 * Identifiers are constant expression and can be used in any context where such
 * an expression is required. As an example:
 * @code{.cpp}
 * using id = entt::identifier<a_type, another_type>;
 *
 * switch(a_type_identifier) {
 * case id::type<a_type>:
 *     // ...
 *     break;
 * case id::type<another_type>:
 *     // ...
 *     break;
 * default:
 *     // ...
 * }
 * @endcode
 *
 * @tparam Types List of types for which to generate identifiers.
 */
template<typename... Types>
class identifier {
    using tuple_type = std::tuple<std::decay_t<Types>...>;

    template<typename Type, std::size_t... Indexes>
    static constexpr id_type get(std::index_sequence<Indexes...>) {
        static_assert(std::disjunction_v<std::is_same<Type, Types>...>);
        return (0 + ... + (std::is_same_v<Type, std::tuple_element_t<Indexes, tuple_type>> ? id_type(Indexes) : id_type{}));
    }

public:
    /*! @brief Unsigned integer type. */
    using identifier_type = id_type;

    /*! @brief Statically generated unique identifier for the given type. */
    template<typename Type>
    static constexpr identifier_type type = get<std::decay_t<Type>>(std::index_sequence_for<Types...>{});
};


}


#endif

// #include "core/monostate.hpp"
#ifndef ENTT_CORE_MONOSTATE_HPP
#define ENTT_CORE_MONOSTATE_HPP


// #include "../config/config.h"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Minimal implementation of the monostate pattern.
 *
 * A minimal, yet complete configuration system built on top of the monostate
 * pattern. Thread safe by design, it works only with basic types like `int`s or
 * `bool`s.<br/>
 * Multiple types and therefore more than one value can be associated with a
 * single key. Because of this, users must pay attention to use the same type
 * both during an assignment and when they try to read back their data.
 * Otherwise, they can incur in unexpected results.
 */
template<id_type>
struct monostate {
    /**
     * @brief Assigns a value of a specific type to a given key.
     * @tparam Type Type of the value to assign.
     * @param val User data to assign to the given key.
     */
    template<typename Type>
    void operator=(Type val) const ENTT_NOEXCEPT {
        value<Type> = val;
    }

    /**
     * @brief Gets a value of a specific type for a given key.
     * @tparam Type Type of the value to get.
     * @return Stored value, if any.
     */
    template<typename Type>
    operator Type() const ENTT_NOEXCEPT {
        return value<Type>;
    }

private:
    template<typename Type>
    inline static ENTT_MAYBE_ATOMIC(Type) value{};
};


/**
 * @brief Helper variable template.
 * @tparam Value Value used to differentiate between different variables.
 */
template<id_type Value>
inline monostate<Value> monostate_v = {};


}


#endif

// #include "core/type_info.hpp"
#ifndef ENTT_CORE_TYPE_INFO_HPP
#define ENTT_CORE_TYPE_INFO_HPP


// #include "../config/config.h"

// #include "../core/attribute.h"
#ifndef ENTT_CORE_ATTRIBUTE_H
#define ENTT_CORE_ATTRIBUTE_H


#ifndef ENTT_EXPORT
#   if defined _WIN32 || defined __CYGWIN__ || defined _MSC_VER
#       define ENTT_EXPORT __declspec(dllexport)
#       define ENTT_IMPORT __declspec(dllimport)
#       define ENTT_HIDDEN
#   elif defined __GNUC__ && __GNUC__ >= 4
#       define ENTT_EXPORT __attribute__((visibility("default")))
#       define ENTT_IMPORT __attribute__((visibility("default")))
#       define ENTT_HIDDEN __attribute__((visibility("hidden")))
#   else /* Unsupported compiler */
#       define ENTT_EXPORT
#       define ENTT_IMPORT
#       define ENTT_HIDDEN
#   endif
#endif


#ifndef ENTT_API
#   if defined ENTT_API_EXPORT
#       define ENTT_API ENTT_EXPORT
#   elif defined ENTT_API_IMPORT
#       define ENTT_API ENTT_IMPORT
#   else /* No API */
#       define ENTT_API
#   endif
#endif


#endif

// #include "hashed_string.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


struct ENTT_API type_index {
    static id_type next() ENTT_NOEXCEPT {
        static ENTT_MAYBE_ATOMIC(id_type) value{};
        return value++;
    }
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Type index.
 * @tparam Type Type for which to generate a sequential identifier.
 */
template<typename Type, typename = void>
struct ENTT_API type_index {
    /**
     * @brief Returns the sequential identifier of a given type.
     * @return The sequential identifier of a given type.
     */
    static id_type value() ENTT_NOEXCEPT {
        static const id_type value = internal::type_index::next();
        return value;
    }
};


/**
 * @brief Provides the member constant `value` to true if a given type is
 * indexable, false otherwise.
 * @tparam Type Potentially indexable type.
 */
template<typename, typename = void>
struct has_type_index: std::false_type {};


/*! @brief has_type_index */
template<typename Type>
struct has_type_index<Type, std::void_t<decltype(type_index<Type>::value())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially indexable type.
 */
template<typename Type>
inline constexpr bool has_type_index_v = has_type_index<Type>::value;


/**
 * @brief Type info.
 * @tparam Type Type for which to generate information.
 */
template<typename Type, typename = void>
struct ENTT_API type_info {
    /**
     * @brief Returns the numeric representation of a given type.
     * @return The numeric representation of the given type.
     */
#if defined ENTT_PRETTY_FUNCTION
    static ENTT_PRETTY_FUNCTION_CONSTEXPR() id_type id() ENTT_NOEXCEPT {
        ENTT_PRETTY_FUNCTION_CONSTEXPR(static const) auto value = entt::hashed_string::value(ENTT_PRETTY_FUNCTION);
        return value;
    }
#else
    static id_type id() ENTT_NOEXCEPT {
        return type_index<Type>::value();
    }
#endif
};


}


#endif

// #include "core/type_traits.hpp"
#ifndef ENTT_CORE_TYPE_TRAITS_HPP
#define ENTT_CORE_TYPE_TRAITS_HPP


#include <cstddef>
#include <utility>
#include <type_traits>
// #include "../config/config.h"

// #include "hashed_string.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Wraps a static constant.
 * @tparam Value A static constant.
 */
template<auto Value>
using integral_constant = std::integral_constant<decltype(Value), Value>;


/**
 * @brief Alias template to ease the creation of named values.
 * @tparam Value A constant value at least convertible to `id_type`.
 */
template<id_type Value>
using tag = integral_constant<Value>;


/**
 * @brief Utility class to disambiguate overloaded functions.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
struct choice_t
        // Unfortunately, doxygen cannot parse such a construct.
        /*! @cond TURN_OFF_DOXYGEN */
        : choice_t<N-1>
        /*! @endcond TURN_OFF_DOXYGEN */
{};


/*! @copybrief choice_t */
template<>
struct choice_t<0> {};


/**
 * @brief Variable template for the choice trick.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
inline constexpr choice_t<N> choice{};


/*! @brief A class to use to push around lists of types, nothing more. */
template<typename...>
struct type_list {};


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_size;


/**
 * @brief Compile-time number of elements in a type list.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_size<type_list<Type...>>
        : std::integral_constant<std::size_t, sizeof...(Type)>
{};


/**
 * @brief Helper variable template.
 * @tparam List Type list.
 */
template<class List>
inline constexpr auto type_list_size_v = type_list_size<List>::value;


/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct type_list_cat;


/*! @brief Concatenates multiple type lists. */
template<>
struct type_list_cat<> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<>;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 * @tparam List Other type lists, if any.
 */
template<typename... Type, typename... Other, typename... List>
struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_cat<type_list<Type...>> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<Type...>;
};


/**
 * @brief Helper type.
 * @tparam List Type lists to concatenate.
 */
template<typename... List>
using type_list_cat_t = typename type_list_cat<List...>::type;


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_unique;


/**
 * @brief Removes duplicates types from a type list.
 * @tparam Type One of the types provided by the given type list.
 * @tparam Other The other types provided by the given type list.
 */
template<typename Type, typename... Other>
struct type_list_unique<type_list<Type, Other...>> {
    /*! @brief A type list without duplicate types. */
    using type = std::conditional_t<
        std::disjunction_v<std::is_same<Type, Other>...>,
        typename type_list_unique<type_list<Other...>>::type,
        type_list_cat_t<type_list<Type>, typename type_list_unique<type_list<Other...>>::type>
    >;
};


/*! @brief Removes duplicates types from a type list. */
template<>
struct type_list_unique<type_list<>> {
    /*! @brief A type list without duplicate types. */
    using type = type_list<>;
};


/**
 * @brief Helper type.
 * @tparam Type A type list.
 */
template<typename Type>
using type_list_unique_t = typename type_list_unique<Type>::type;


/**
 * @brief Provides the member constant `value` to true if a given type is
 * equality comparable, false otherwise.
 * @tparam Type Potentially equality comparable type.
 */
template<typename Type, typename = std::void_t<>>
struct is_equality_comparable: std::false_type {};


/*! @copydoc is_equality_comparable */
template<typename Type>
struct is_equality_comparable<Type, std::void_t<decltype(std::declval<Type>() == std::declval<Type>())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially equality comparable type.
 */
template<class Type>
inline constexpr auto is_equality_comparable_v = is_equality_comparable<Type>::value;


/**
 * @brief Extracts the class of a non-static member object or function.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
class member_class {
    static_assert(std::is_member_pointer_v<Member>);

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...));

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...) const);

    template<typename Class, typename Type>
    static Class * clazz(Type Class:: *);

public:
    /*! @brief The class of the given non-static member object or function. */
    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
};


/**
 * @brief Helper type.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
using member_class_t = typename member_class<Member>::type;


}


/**
 * @brief Defines an enum class to use for opaque identifiers and a dedicate
 * `to_integer` function to convert the identifiers to their underlying type.
 * @param clazz The name to use for the enum class.
 * @param type The underlying type for the enum class.
 */
#define ENTT_OPAQUE_TYPE(clazz, type)\
    enum class clazz: type {};\
    constexpr auto to_integral(const clazz id) ENTT_NOEXCEPT {\
        return static_cast<std::underlying_type_t<clazz>>(id);\
    }\
    static_assert(true)


#endif

// #include "core/utility.hpp"

// #include "entity/actor.hpp"
#ifndef ENTT_ENTITY_ACTOR_HPP
#define ENTT_ENTITY_ACTOR_HPP


#include <utility>
#include <type_traits>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif

// #include "registry.hpp"
#ifndef ENTT_ENTITY_REGISTRY_HPP
#define ENTT_ENTITY_REGISTRY_HPP


#include <algorithm>
#include <cstddef>
#include <iterator>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>
// #include "../config/config.h"

// #include "../core/algorithm.hpp"
#ifndef ENTT_CORE_ALGORITHM_HPP
#define ENTT_CORE_ALGORITHM_HPP


#include <vector>
#include <utility>
#include <iterator>
#include <algorithm>
#include <functional>
// #include "utility.hpp"
#ifndef ENTT_CORE_UTILITY_HPP
#define ENTT_CORE_UTILITY_HPP


#include <utility>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/*! @brief Identity function object (waiting for C++20). */
struct identity {
    /**
     * @brief Returns its argument unchanged.
     * @tparam Type Type of the argument.
     * @param value The actual argument.
     * @return The submitted value as-is.
     */
    template<class Type>
    constexpr Type && operator()(Type &&value) const ENTT_NOEXCEPT {
        return std::forward<Type>(value);
    }
};


/**
 * @brief Constant utility to disambiguate overloaded members of a class.
 * @tparam Type Type of the desired overload.
 * @tparam Class Type of class to which the member belongs.
 * @param member A valid pointer to a member.
 * @return Pointer to the member.
 */
template<typename Type, typename Class>
constexpr auto overload(Type Class:: *member) ENTT_NOEXCEPT { return member; }


/**
 * @brief Constant utility to disambiguate overloaded functions.
 * @tparam Func Function type of the desired overload.
 * @param func A valid pointer to a function.
 * @return Pointer to the function.
 */
template<typename Func>
constexpr auto overload(Func *func) ENTT_NOEXCEPT { return func; }


/**
 * @brief Helper type for visitors.
 * @tparam Func Types of function objects.
 */
template<class... Func>
struct overloaded: Func... {
    using Func::operator()...;
};


/**
 * @brief Deduction guide.
 * @tparam Func Types of function objects.
 */
template<class... Func>
overloaded(Func...) -> overloaded<Func...>;


/**
 * @brief Basic implementation of a y-combinator.
 * @tparam Func Type of a potentially recursive function.
 */
template<class Func>
struct y_combinator {
    /**
     * @brief Constructs a y-combinator from a given function.
     * @param recursive A potentially recursive function.
     */
    y_combinator(Func recursive):
        func{std::move(recursive)}
    {}

    /**
     * @brief Invokes a y-combinator and therefore its underlying function.
     * @tparam Args Types of arguments to use to invoke the underlying function.
     * @param args Parameters to use to invoke the underlying function.
     * @return Return value of the underlying function, if any.
     */
    template <class... Args>
    decltype(auto) operator()(Args &&... args) const {
        return func(*this, std::forward<Args>(args)...);
    }

    /*! @copydoc operator()() */
    template <class... Args>
    decltype(auto) operator()(Args &&... args) {
        return func(*this, std::forward<Args>(args)...);
    }

private:
    Func func;
};


}


#endif



namespace entt {


/**
 * @brief Function object to wrap `std::sort` in a class type.
 *
 * Unfortunately, `std::sort` cannot be passed as template argument to a class
 * template or a function template.<br/>
 * This class fills the gap by wrapping some flavors of `std::sort` in a
 * function object.
 */
struct std_sort {
    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given binary comparison function.
     *
     * @tparam It Type of random access iterator.
     * @tparam Compare Type of comparison function object.
     * @tparam Args Types of arguments to forward to the sort function.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     * @param args Arguments to forward to the sort function, if any.
     */
    template<typename It, typename Compare = std::less<>, typename... Args>
    void operator()(It first, It last, Compare compare = Compare{}, Args &&... args) const {
        std::sort(std::forward<Args>(args)..., std::move(first), std::move(last), std::move(compare));
    }
};


/*! @brief Function object for performing insertion sort. */
struct insertion_sort {
    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given binary comparison function.
     *
     * @tparam It Type of random access iterator.
     * @tparam Compare Type of comparison function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     */
    template<typename It, typename Compare = std::less<>>
    void operator()(It first, It last, Compare compare = Compare{}) const {
        if(first < last) {
            for(auto it = first+1; it < last; ++it) {
                auto value = std::move(*it);
                auto pre = it;

                for(; pre > first && compare(value, *(pre-1)); --pre) {
                    *pre = std::move(*(pre-1));
                }

                *pre = std::move(value);
            }
        }
    }
};


/**
 * @brief Function object for performing LSD radix sort.
 * @tparam Bit Number of bits processed per pass.
 * @tparam N Maximum number of bits to sort.
 */
template<std::size_t Bit, std::size_t N>
struct radix_sort {
    static_assert((N % Bit) == 0);

    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given _getter_ to access the
     * actual data to be sorted.
     *
     * This implementation is inspired by the online book
     * [Physically Based Rendering](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#RadixSort).
     *
     * @tparam It Type of random access iterator.
     * @tparam Getter Type of _getter_ function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param getter A valid _getter_ function object.
     */
    template<typename It, typename Getter = identity>
    void operator()(It first, It last, Getter getter = Getter{}) const {
        if(first < last) {
            static constexpr auto mask = (1 << Bit) - 1;
            static constexpr auto buckets = 1 << Bit;
            static constexpr auto passes = N / Bit;

            using value_type = typename std::iterator_traits<It>::value_type;
            std::vector<value_type> aux(std::distance(first, last));

            auto part = [getter = std::move(getter)](auto from, auto to, auto out, auto start) {
                std::size_t index[buckets]{};
                std::size_t count[buckets]{};

                std::for_each(from, to, [&getter, &count, start](const value_type &item) {
                    ++count[(getter(item) >> start) & mask];
                });

                std::for_each(std::next(std::begin(index)), std::end(index), [index = std::begin(index), count = std::begin(count)](auto &item) mutable {
                    item = *(index++) + *(count++);
                });

                std::for_each(from, to, [&getter, &out, &index, start](value_type &item) {
                    out[index[(getter(item) >> start) & mask]++] = std::move(item);
                });
            };

            for(std::size_t pass = 0; pass < (passes & ~1); pass += 2) {
                part(first, last, aux.begin(), pass * Bit);
                part(aux.begin(), aux.end(), first, (pass + 1) * Bit);
            }

            if constexpr(passes & 1) {
                part(first, last, aux.begin(), (passes - 1) * Bit);
                std::move(aux.begin(), aux.end(), first);
            }
        }
    }
};


}


#endif

// #include "../core/fwd.hpp"
#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP


// #include "../config/config.h"



namespace entt {


/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;


}


#endif

// #include "../core/type_info.hpp"
#ifndef ENTT_CORE_TYPE_INFO_HPP
#define ENTT_CORE_TYPE_INFO_HPP


// #include "../config/config.h"

// #include "../core/attribute.h"
#ifndef ENTT_CORE_ATTRIBUTE_H
#define ENTT_CORE_ATTRIBUTE_H


#ifndef ENTT_EXPORT
#   if defined _WIN32 || defined __CYGWIN__ || defined _MSC_VER
#       define ENTT_EXPORT __declspec(dllexport)
#       define ENTT_IMPORT __declspec(dllimport)
#       define ENTT_HIDDEN
#   elif defined __GNUC__ && __GNUC__ >= 4
#       define ENTT_EXPORT __attribute__((visibility("default")))
#       define ENTT_IMPORT __attribute__((visibility("default")))
#       define ENTT_HIDDEN __attribute__((visibility("hidden")))
#   else /* Unsupported compiler */
#       define ENTT_EXPORT
#       define ENTT_IMPORT
#       define ENTT_HIDDEN
#   endif
#endif


#ifndef ENTT_API
#   if defined ENTT_API_EXPORT
#       define ENTT_API ENTT_EXPORT
#   elif defined ENTT_API_IMPORT
#       define ENTT_API ENTT_IMPORT
#   else /* No API */
#       define ENTT_API
#   endif
#endif


#endif

// #include "hashed_string.hpp"
#ifndef ENTT_CORE_HASHED_STRING_HPP
#define ENTT_CORE_HASHED_STRING_HPP


#include <cstddef>
#include <cstdint>
// #include "../config/config.h"

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename>
struct fnv1a_traits;


template<>
struct fnv1a_traits<std::uint32_t> {
    using type = std::uint32_t;
    static constexpr std::uint32_t offset = 2166136261;
    static constexpr std::uint32_t prime = 16777619;
};


template<>
struct fnv1a_traits<std::uint64_t> {
    using type = std::uint64_t;
    static constexpr std::uint64_t offset = 14695981039346656037ull;
    static constexpr std::uint64_t prime = 1099511628211ull;
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Zero overhead unique identifier.
 *
 * A hashed string is a compile-time tool that allows users to use
 * human-readable identifers in the codebase while using their numeric
 * counterparts at runtime.<br/>
 * Because of that, a hashed string can also be used in constant expressions if
 * required.
 *
 * @tparam Char Character type.
 */
template<typename Char>
class basic_hashed_string {
    using traits_type = internal::fnv1a_traits<id_type>;

    struct const_wrapper {
        // non-explicit constructor on purpose
        constexpr const_wrapper(const Char *curr) ENTT_NOEXCEPT: str{curr} {}
        const Char *str;
    };

    // Fowler–Noll–Vo hash function v. 1a - the good
    static constexpr id_type helper(const Char *curr) ENTT_NOEXCEPT {
        auto value = traits_type::offset;

        while(*curr != 0) {
            value = (value ^ static_cast<traits_type::type>(*(curr++))) * traits_type::prime;
        }

        return value;
    }

public:
    /*! @brief Character type. */
    using value_type = Char;
    /*! @brief Unsigned integer type. */
    using hash_type = id_type;

    /**
     * @brief Returns directly the numeric representation of a string.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * const auto value = basic_hashed_string<char>::to_value("my.png");
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifer.
     * @return The numeric representation of the string.
     */
    template<std::size_t N>
    static constexpr hash_type value(const value_type (&str)[N]) ENTT_NOEXCEPT {
        return helper(str);
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     * @return The numeric representation of the string.
     */
    static hash_type value(const_wrapper wrapper) ENTT_NOEXCEPT {
        return helper(wrapper.str);
    }

    /**
     * @brief Returns directly the numeric representation of a string view.
     * @param str Human-readable identifer.
     * @param size Length of the string to hash.
     * @return The numeric representation of the string.
     */
    static hash_type value(const value_type *str, std::size_t size) ENTT_NOEXCEPT {
        id_type partial{traits_type::offset};
        while(size--) { partial = (partial^(str++)[0])*traits_type::prime; }
        return partial;
    }

    /*! @brief Constructs an empty hashed string. */
    constexpr basic_hashed_string() ENTT_NOEXCEPT
        : str{nullptr}, hash{}
    {}

    /**
     * @brief Constructs a hashed string from an array of const characters.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * basic_hashed_string<char> hs{"my.png"};
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param curr Human-readable identifer.
     */
    template<std::size_t N>
    constexpr basic_hashed_string(const value_type (&curr)[N]) ENTT_NOEXCEPT
        : str{curr}, hash{helper(curr)}
    {}

    /**
     * @brief Explicit constructor on purpose to avoid constructing a hashed
     * string directly from a `const value_type *`.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     */
    explicit constexpr basic_hashed_string(const_wrapper wrapper) ENTT_NOEXCEPT
        : str{wrapper.str}, hash{helper(wrapper.str)}
    {}

    /**
     * @brief Returns the human-readable representation of a hashed string.
     * @return The string used to initialize the instance.
     */
    constexpr const value_type * data() const ENTT_NOEXCEPT {
        return str;
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr hash_type value() const ENTT_NOEXCEPT {
        return hash;
    }

    /*! @copydoc data */
    constexpr operator const value_type *() const ENTT_NOEXCEPT { return data(); }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr operator hash_type() const ENTT_NOEXCEPT { return value(); }

    /**
     * @brief Compares two hashed strings.
     * @param other Hashed string with which to compare.
     * @return True if the two hashed strings are identical, false otherwise.
     */
    constexpr bool operator==(const basic_hashed_string &other) const ENTT_NOEXCEPT {
        return hash == other.hash;
    }

private:
    const value_type *str;
    hash_type hash;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the character type of the hashed string directly from a
 * human-readable identifer provided to the constructor.
 *
 * @tparam Char Character type.
 * @tparam N Number of characters of the identifier.
 * @param str Human-readable identifer.
 */
template<typename Char, std::size_t N>
basic_hashed_string(const Char (&str)[N]) ENTT_NOEXCEPT
-> basic_hashed_string<Char>;


/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings are identical, false otherwise.
 */
template<typename Char>
constexpr bool operator!=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/*! @brief Aliases for common character types. */
using hashed_string = basic_hashed_string<char>;


/*! @brief Aliases for common character types. */
using hashed_wstring = basic_hashed_string<wchar_t>;


}


/**
 * @brief User defined literal for hashed strings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed string.
 */
constexpr entt::hashed_string operator"" ENTT_HS_SUFFIX(const char *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_string{str};
}


/**
 * @brief User defined literal for hashed wstrings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed wstring.
 */
constexpr entt::hashed_wstring operator"" ENTT_HWS_SUFFIX(const wchar_t *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_wstring{str};
}


#endif

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


struct ENTT_API type_index {
    static id_type next() ENTT_NOEXCEPT {
        static ENTT_MAYBE_ATOMIC(id_type) value{};
        return value++;
    }
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Type index.
 * @tparam Type Type for which to generate a sequential identifier.
 */
template<typename Type, typename = void>
struct ENTT_API type_index {
    /**
     * @brief Returns the sequential identifier of a given type.
     * @return The sequential identifier of a given type.
     */
    static id_type value() ENTT_NOEXCEPT {
        static const id_type value = internal::type_index::next();
        return value;
    }
};


/**
 * @brief Provides the member constant `value` to true if a given type is
 * indexable, false otherwise.
 * @tparam Type Potentially indexable type.
 */
template<typename, typename = void>
struct has_type_index: std::false_type {};


/*! @brief has_type_index */
template<typename Type>
struct has_type_index<Type, std::void_t<decltype(type_index<Type>::value())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially indexable type.
 */
template<typename Type>
inline constexpr bool has_type_index_v = has_type_index<Type>::value;


/**
 * @brief Type info.
 * @tparam Type Type for which to generate information.
 */
template<typename Type, typename = void>
struct ENTT_API type_info {
    /**
     * @brief Returns the numeric representation of a given type.
     * @return The numeric representation of the given type.
     */
#if defined ENTT_PRETTY_FUNCTION
    static ENTT_PRETTY_FUNCTION_CONSTEXPR() id_type id() ENTT_NOEXCEPT {
        ENTT_PRETTY_FUNCTION_CONSTEXPR(static const) auto value = entt::hashed_string::value(ENTT_PRETTY_FUNCTION);
        return value;
    }
#else
    static id_type id() ENTT_NOEXCEPT {
        return type_index<Type>::value();
    }
#endif
};


}


#endif

// #include "../core/type_traits.hpp"
#ifndef ENTT_CORE_TYPE_TRAITS_HPP
#define ENTT_CORE_TYPE_TRAITS_HPP


#include <cstddef>
#include <utility>
#include <type_traits>
// #include "../config/config.h"

// #include "hashed_string.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Wraps a static constant.
 * @tparam Value A static constant.
 */
template<auto Value>
using integral_constant = std::integral_constant<decltype(Value), Value>;


/**
 * @brief Alias template to ease the creation of named values.
 * @tparam Value A constant value at least convertible to `id_type`.
 */
template<id_type Value>
using tag = integral_constant<Value>;


/**
 * @brief Utility class to disambiguate overloaded functions.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
struct choice_t
        // Unfortunately, doxygen cannot parse such a construct.
        /*! @cond TURN_OFF_DOXYGEN */
        : choice_t<N-1>
        /*! @endcond TURN_OFF_DOXYGEN */
{};


/*! @copybrief choice_t */
template<>
struct choice_t<0> {};


/**
 * @brief Variable template for the choice trick.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
inline constexpr choice_t<N> choice{};


/*! @brief A class to use to push around lists of types, nothing more. */
template<typename...>
struct type_list {};


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_size;


/**
 * @brief Compile-time number of elements in a type list.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_size<type_list<Type...>>
        : std::integral_constant<std::size_t, sizeof...(Type)>
{};


/**
 * @brief Helper variable template.
 * @tparam List Type list.
 */
template<class List>
inline constexpr auto type_list_size_v = type_list_size<List>::value;


/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct type_list_cat;


/*! @brief Concatenates multiple type lists. */
template<>
struct type_list_cat<> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<>;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 * @tparam List Other type lists, if any.
 */
template<typename... Type, typename... Other, typename... List>
struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_cat<type_list<Type...>> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<Type...>;
};


/**
 * @brief Helper type.
 * @tparam List Type lists to concatenate.
 */
template<typename... List>
using type_list_cat_t = typename type_list_cat<List...>::type;


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_unique;


/**
 * @brief Removes duplicates types from a type list.
 * @tparam Type One of the types provided by the given type list.
 * @tparam Other The other types provided by the given type list.
 */
template<typename Type, typename... Other>
struct type_list_unique<type_list<Type, Other...>> {
    /*! @brief A type list without duplicate types. */
    using type = std::conditional_t<
        std::disjunction_v<std::is_same<Type, Other>...>,
        typename type_list_unique<type_list<Other...>>::type,
        type_list_cat_t<type_list<Type>, typename type_list_unique<type_list<Other...>>::type>
    >;
};


/*! @brief Removes duplicates types from a type list. */
template<>
struct type_list_unique<type_list<>> {
    /*! @brief A type list without duplicate types. */
    using type = type_list<>;
};


/**
 * @brief Helper type.
 * @tparam Type A type list.
 */
template<typename Type>
using type_list_unique_t = typename type_list_unique<Type>::type;


/**
 * @brief Provides the member constant `value` to true if a given type is
 * equality comparable, false otherwise.
 * @tparam Type Potentially equality comparable type.
 */
template<typename Type, typename = std::void_t<>>
struct is_equality_comparable: std::false_type {};


/*! @copydoc is_equality_comparable */
template<typename Type>
struct is_equality_comparable<Type, std::void_t<decltype(std::declval<Type>() == std::declval<Type>())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially equality comparable type.
 */
template<class Type>
inline constexpr auto is_equality_comparable_v = is_equality_comparable<Type>::value;


/**
 * @brief Extracts the class of a non-static member object or function.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
class member_class {
    static_assert(std::is_member_pointer_v<Member>);

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...));

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...) const);

    template<typename Class, typename Type>
    static Class * clazz(Type Class:: *);

public:
    /*! @brief The class of the given non-static member object or function. */
    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
};


/**
 * @brief Helper type.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
using member_class_t = typename member_class<Member>::type;


}


/**
 * @brief Defines an enum class to use for opaque identifiers and a dedicate
 * `to_integer` function to convert the identifiers to their underlying type.
 * @param clazz The name to use for the enum class.
 * @param type The underlying type for the enum class.
 */
#define ENTT_OPAQUE_TYPE(clazz, type)\
    enum class clazz: type {};\
    constexpr auto to_integral(const clazz id) ENTT_NOEXCEPT {\
        return static_cast<std::underlying_type_t<clazz>>(id);\
    }\
    static_assert(true)


#endif

// #include "../signal/sigh.hpp"
#ifndef ENTT_SIGNAL_SIGH_HPP
#define ENTT_SIGNAL_SIGH_HPP


#include <vector>
#include <utility>
#include <iterator>
#include <algorithm>
#include <functional>
#include <type_traits>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif

// #include "delegate.hpp"
#ifndef ENTT_SIGNAL_DELEGATE_HPP
#define ENTT_SIGNAL_DELEGATE_HPP


#include <tuple>
#include <cstddef>
#include <utility>
#include <functional>
#include <type_traits>
// #include "../config/config.h"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename Ret, typename... Args>
auto function_pointer(Ret(*)(Args...)) -> Ret(*)(Args...);


template<typename Ret, typename Type, typename... Args, typename Other>
auto function_pointer(Ret(*)(Type, Args...), Other &&) -> Ret(*)(Args...);


template<typename Class, typename Ret, typename... Args, typename... Other>
auto function_pointer(Ret(Class:: *)(Args...), Other &&...) -> Ret(*)(Args...);


template<typename Class, typename Ret, typename... Args, typename... Other>
auto function_pointer(Ret(Class:: *)(Args...) const, Other &&...) -> Ret(*)(Args...);


template<typename Class, typename Type, typename... Other>
auto function_pointer(Type Class:: *, Other &&...) -> Type(*)();


template<typename... Type>
using function_pointer_t = decltype(internal::function_pointer(std::declval<Type>()...));


template<typename... Class, typename Ret, typename... Args>
constexpr auto index_sequence_for(Ret(*)(Args...)) {
    return std::index_sequence_for<Class..., Args...>{};
}


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/*! @brief Used to wrap a function or a member of a specified type. */
template<auto>
struct connect_arg_t {};


/*! @brief Constant of type connect_arg_t used to disambiguate calls. */
template<auto Func>
inline constexpr connect_arg_t<Func> connect_arg{};


/**
 * @brief Basic delegate implementation.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 */
template<typename>
class delegate;


/**
 * @brief Utility class to use to send around functions and members.
 *
 * Unmanaged delegate for function pointers and members. Users of this class are
 * in charge of disconnecting instances before deleting them.
 *
 * A delegate can be used as a general purpose invoker without memory overhead
 * for free functions possibly with payloads and bound or unbound members.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class delegate<Ret(Args...)> {
    using proto_fn_type = Ret(const void *, Args...);

    template<auto Candidate, std::size_t... Index>
    auto wrap(std::index_sequence<Index...>) ENTT_NOEXCEPT {
        return [](const void *, Args... args) -> Ret {
            const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            return Ret(std::invoke(Candidate, std::forward<std::tuple_element_t<Index, std::tuple<Args...>>>(std::get<Index>(arguments))...));
        };
    }

    template<auto Candidate, typename Type, std::size_t... Index>
    auto wrap(Type &, std::index_sequence<Index...>) ENTT_NOEXCEPT {
        return [](const void *payload, Args... args) -> Ret {
            const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
            return Ret(std::invoke(Candidate, *curr, std::forward<std::tuple_element_t<Index, std::tuple<Args...>>>(std::get<Index>(arguments))...));
        };
    }

    template<auto Candidate, typename Type, std::size_t... Index>
    auto wrap(Type *, std::index_sequence<Index...>) ENTT_NOEXCEPT {
        return [](const void *payload, Args... args) -> Ret {
            const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
            return Ret(std::invoke(Candidate, curr, std::forward<std::tuple_element_t<Index, std::tuple<Args...>>>(std::get<Index>(arguments))...));
        };
    }

public:
    /*! @brief Function type of the delegate. */
    using function_type = Ret(Args...);

    /*! @brief Default constructor. */
    delegate() ENTT_NOEXCEPT
        : fn{nullptr}, data{nullptr}
    {}

    /**
     * @brief Constructs a delegate and connects a free function or an unbound
     * member.
     * @tparam Candidate Function or member to connect to the delegate.
     */
    template<auto Candidate>
    delegate(connect_arg_t<Candidate>) ENTT_NOEXCEPT
        : delegate{}
    {
        connect<Candidate>();
    }

    /**
     * @brief Constructs a delegate and connects a free function with payload or
     * a bound member.
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<auto Candidate, typename Type>
    delegate(connect_arg_t<Candidate>, Type &&value_or_instance) ENTT_NOEXCEPT
        : delegate{}
    {
        connect<Candidate>(std::forward<Type>(value_or_instance));
    }

    /**
     * @brief Connects a free function or an unbound member to a delegate.
     * @tparam Candidate Function or member to connect to the delegate.
     */
    template<auto Candidate>
    void connect() ENTT_NOEXCEPT {
        data = nullptr;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
            fn = [](const void *, Args... args) -> Ret {
                return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
            };
        } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
            fn = wrap<Candidate>(internal::index_sequence_for<std::tuple_element_t<0, std::tuple<Args...>>>(internal::function_pointer_t<decltype(Candidate)>{}));
        } else {
            fn = wrap<Candidate>(internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate)>{}));
        }
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * delegate.
     *
     * The delegate isn't responsible for the connected object or the payload.
     * Users must always guarantee that the lifetime of the instance overcomes
     * the one  of the delegate.<br/>
     * When used to connect a free function with payload, its signature must be
     * such that the instance is the first argument before the ones used to
     * define the delegate itself.
     *
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid reference that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void connect(Type &value_or_instance) ENTT_NOEXCEPT {
        data = &value_or_instance;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
            fn = [](const void *payload, Args... args) -> Ret {
                Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
                return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
            };
        } else {
            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
        }
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * delegate.
     *
     * @sa connect(Type &)
     *
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid pointer that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void connect(Type *value_or_instance) ENTT_NOEXCEPT {
        data = value_or_instance;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
            fn = [](const void *payload, Args... args) -> Ret {
                Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
                return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
            };
        } else {
            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
        }
    }

    /**
     * @brief Resets a delegate.
     *
     * After a reset, a delegate cannot be invoked anymore.
     */
    void reset() ENTT_NOEXCEPT {
        fn = nullptr;
        data = nullptr;
    }

    /**
     * @brief Returns the instance or the payload linked to a delegate, if any.
     * @return An opaque pointer to the underlying data.
     */
    const void * instance() const ENTT_NOEXCEPT {
        return data;
    }

    /**
     * @brief Triggers a delegate.
     *
     * The delegate invokes the underlying function and returns the result.
     *
     * @warning
     * Attempting to trigger an invalid delegate results in undefined
     * behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * delegate has not yet been set.
     *
     * @param args Arguments to use to invoke the underlying function.
     * @return The value returned by the underlying function.
     */
    Ret operator()(Args... args) const {
        ENTT_ASSERT(fn);
        return fn(data, std::forward<Args>(args)...);
    }

    /**
     * @brief Checks whether a delegate actually stores a listener.
     * @return False if the delegate is empty, true otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        // no need to test also data
        return !(fn == nullptr);
    }

    /**
     * @brief Compares the contents of two delegates.
     * @param other Delegate with which to compare.
     * @return False if the two contents differ, true otherwise.
     */
    bool operator==(const delegate<Ret(Args...)> &other) const ENTT_NOEXCEPT {
        return fn == other.fn && data == other.data;
    }

private:
    proto_fn_type *fn;
    const void *data;
};


/**
 * @brief Compares the contents of two delegates.
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 * @param lhs A valid delegate object.
 * @param rhs A valid delegate object.
 * @return True if the two contents differ, false otherwise.
 */
template<typename Ret, typename... Args>
bool operator!=(const delegate<Ret(Args...)> &lhs, const delegate<Ret(Args...)> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/**
 * @brief Deduction guide.
 * @tparam Candidate Function or member to connect to the delegate.
 */
template<auto Candidate>
delegate(connect_arg_t<Candidate>) ENTT_NOEXCEPT
-> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate)>>>;


/**
 * @brief Deduction guide.
 * @tparam Candidate Function or member to connect to the delegate.
 * @tparam Type Type of class or type of payload.
 */
template<auto Candidate, typename Type>
delegate(connect_arg_t<Candidate>, Type &&) ENTT_NOEXCEPT
-> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate), Type>>>;


}


#endif

// #include "fwd.hpp"
#ifndef ENTT_SIGNAL_FWD_HPP
#define ENTT_SIGNAL_FWD_HPP


namespace entt {


/*! @class delegate */
template<typename>
class delegate;

/*! @class dispatcher */
class dispatcher;

/*! @class emitter */
template<typename>
class emitter;

/*! @class connection */
class connection;

/*! @class scoped_connection */
struct scoped_connection;

/*! @class sink */
template<typename>
class sink;

/*! @class sigh */
template<typename>
class sigh;


}


#endif



namespace entt {


/**
 * @brief Sink class.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 *
 * @tparam Function A valid function type.
 */
template<typename Function>
class sink;


/**
 * @brief Unmanaged signal handler.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 *
 * @tparam Function A valid function type.
 */
template<typename Function>
class sigh;


/**
 * @brief Unmanaged signal handler.
 *
 * It works directly with references to classes and pointers to member functions
 * as well as pointers to free functions. Users of this class are in charge of
 * disconnecting instances before deleting them.
 *
 * This class serves mainly two purposes:
 *
 * * Creating signals to use later to notify a bunch of listeners.
 * * Collecting results from a set of functions like in a voting system.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class sigh<Ret(Args...)> {
    /*! @brief A sink is allowed to modify a signal. */
    friend class sink<Ret(Args...)>;

public:
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Sink type. */
    using sink_type = entt::sink<Ret(Args...)>;

    /**
     * @brief Instance type when it comes to connecting member functions.
     * @tparam Class Type of class to which the member function belongs.
     */
    template<typename Class>
    using instance_type = Class *;

    /**
     * @brief Number of listeners connected to the signal.
     * @return Number of listeners currently connected.
     */
    size_type size() const ENTT_NOEXCEPT {
        return calls.size();
    }

    /**
     * @brief Returns false if at least a listener is connected to the signal.
     * @return True if the signal has no listeners connected, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return calls.empty();
    }

    /**
     * @brief Triggers a signal.
     *
     * All the listeners are notified. Order isn't guaranteed.
     *
     * @param args Arguments to use to invoke listeners.
     */
    void publish(Args... args) const {
        for(auto &&call: std::as_const(calls)) {
            call(args...);
        }
    }

    /**
     * @brief Collects return values from the listeners.
     *
     * The collector must expose a call operator with the following properties:
     *
     * * The return type is either `void` or such that it's convertible to
     *   `bool`. In the second case, a true value will stop the iteration.
     * * The list of parameters is empty if `Ret` is `void`, otherwise it
     *   contains a single element such that `Ret` is convertible to it.
     *
     * @tparam Func Type of collector to use, if any.
     * @param func A valid function object.
     * @param args Arguments to use to invoke listeners.
     */
    template<typename Func>
    void collect(Func func, Args... args) const {
        for(auto &&call: calls) {
            if constexpr(std::is_void_v<Ret>) {
                if constexpr(std::is_invocable_r_v<bool, Func>) {
                    call(args...);
                    if(func()) { break; }
                } else {
                    call(args...);
                    func();
                }
            } else {
                if constexpr(std::is_invocable_r_v<bool, Func, Ret>) {
                    if(func(call(args...))) { break; }
                } else {
                    func(call(args...));
                }
            }
        }
    }

private:
    std::vector<delegate<Ret(Args...)>> calls;
};


/**
 * @brief Connection class.
 *
 * Opaque object the aim of which is to allow users to release an already
 * estabilished connection without having to keep a reference to the signal or
 * the sink that generated it.
 */
class connection {
    /*! @brief A sink is allowed to create connection objects. */
    template<typename>
    friend class sink;

    connection(delegate<void(void *)> fn, void *ref)
        : disconnect{fn}, signal{ref}
    {}

public:
    /*! @brief Default constructor. */
    connection() = default;

    /**
     * @brief Checks whether a connection is properly initialized.
     * @return True if the connection is properly initialized, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return static_cast<bool>(disconnect);
    }

    /*! @brief Breaks the connection. */
    void release() {
        if(disconnect) {
            disconnect(signal);
            disconnect.reset();
        }
    }

private:
    delegate<void(void *)> disconnect;
    void *signal{};
};


/**
 * @brief Scoped connection class.
 *
 * Opaque object the aim of which is to allow users to release an already
 * estabilished connection without having to keep a reference to the signal or
 * the sink that generated it.<br/>
 * A scoped connection automatically breaks the link between the two objects
 * when it goes out of scope.
 */
struct scoped_connection {
    /*! @brief Default constructor. */
    scoped_connection() = default;

    /**
     * @brief Constructs a scoped connection from a basic connection.
     * @param other A valid connection object.
     */
    scoped_connection(const connection &other)
        : conn{other}
    {}

    /*! @brief Default copy constructor, deleted on purpose. */
    scoped_connection(const scoped_connection &) = delete;

    /*! @brief Automatically breaks the link on destruction. */
    ~scoped_connection() {
        conn.release();
    }

    /**
     * @brief Default copy assignment operator, deleted on purpose.
     * @return This scoped connection.
     */
    scoped_connection & operator=(const scoped_connection &) = delete;

    /**
     * @brief Acquires a connection.
     * @param other The connection object to acquire.
     * @return This scoped connection.
     */
    scoped_connection & operator=(connection other) {
        conn = std::move(other);
        return *this;
    }

    /**
     * @brief Checks whether a scoped connection is properly initialized.
     * @return True if the connection is properly initialized, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return static_cast<bool>(conn);
    }

    /*! @brief Breaks the connection. */
    void release() {
        conn.release();
    }

private:
    connection conn;
};


/**
 * @brief Sink class.
 *
 * A sink is used to connect listeners to signals and to disconnect them.<br/>
 * The function type for a listener is the one of the signal to which it
 * belongs.
 *
 * The clear separation between a signal and a sink permits to store the former
 * as private data member without exposing the publish functionality to the
 * users of the class.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class sink<Ret(Args...)> {
    using signal_type = sigh<Ret(Args...)>;
    using difference_type = typename std::iterator_traits<typename decltype(signal_type::calls)::iterator>::difference_type;

    template<auto Candidate, typename Type>
    static void release(Type value_or_instance, void *signal) {
        sink{*static_cast<signal_type *>(signal)}.disconnect<Candidate>(value_or_instance);
    }

    template<auto Candidate>
    static void release(void *signal) {
        sink{*static_cast<signal_type *>(signal)}.disconnect<Candidate>();
    }

public:
    /**
     * @brief Constructs a sink that is allowed to modify a given signal.
     * @param ref A valid reference to a signal object.
     */
    sink(sigh<Ret(Args...)> &ref) ENTT_NOEXCEPT
        : offset{},
          signal{&ref}
    {}

    /**
     * @brief Returns false if at least a listener is connected to the sink.
     * @return True if the sink has no listeners connected, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return signal->calls.empty();
    }

    /**
     * @brief Returns a sink that connects before a given free function or an
     * unbound member.
     * @tparam Function A valid free function pointer.
     * @return A properly initialized sink object.
     */
    template<auto Function>
    sink before() {
        delegate<Ret(Args...)> call{};
        call.template connect<Function>();

        const auto &calls = signal->calls;
        const auto it = std::find(calls.cbegin(), calls.cend(), std::move(call));

        sink other{*this};
        other.offset = std::distance(it, calls.cend());
        return other;
    }

    /**
     * @brief Returns a sink that connects before a free function with payload
     * or a bound member.
     * @tparam Candidate Member or free function to look for.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     * @return A properly initialized sink object.
     */
    template<auto Candidate, typename Type>
    sink before(Type &&value_or_instance) {
        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>(std::forward<Type>(value_or_instance));

        const auto &calls = signal->calls;
        const auto it = std::find(calls.cbegin(), calls.cend(), std::move(call));

        sink other{*this};
        other.offset = std::distance(it, calls.cend());
        return other;
    }

    /**
     * @brief Returns a sink that connects before a given instance or specific
     * payload.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     * @return A properly initialized sink object.
     */
    template<typename Type>
    sink before(Type &value_or_instance) {
        return before(&value_or_instance);
    }

    /**
     * @brief Returns a sink that connects before a given instance or specific
     * payload.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid pointer that fits the purpose.
     * @return A properly initialized sink object.
     */
    template<typename Type>
    sink before(Type *value_or_instance) {
        sink other{*this};

        if(value_or_instance) {
            const auto &calls = signal->calls;
            const auto it = std::find_if(calls.cbegin(), calls.cend(), [value_or_instance](const auto &delegate) {
                return delegate.instance() == value_or_instance;
            });

            other.offset = std::distance(it, calls.cend());
        }

        return other;
    }

    /**
     * @brief Returns a sink that connects before anything else.
     * @return A properly initialized sink object.
     */
    sink before() {
        sink other{*this};
        other.offset = signal->calls.size();
        return other;
    }

    /**
     * @brief Connects a free function or an unbound member to a signal.
     *
     * The signal handler performs checks to avoid multiple connections for the
     * same function.
     *
     * @tparam Candidate Function or member to connect to the signal.
     * @return A properly initialized connection object.
     */
    template<auto Candidate>
    connection connect() {
        disconnect<Candidate>();

        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>();
        signal->calls.insert(signal->calls.end() - offset, std::move(call));

        delegate<void(void *)> conn{};
        conn.template connect<&release<Candidate>>();
        return { std::move(conn), signal };
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * signal.
     *
     * The signal isn't responsible for the connected object or the payload.
     * Users must always guarantee that the lifetime of the instance overcomes
     * the one of the signal. On the other side, the signal handler performs
     * checks to avoid multiple connections for the same function.<br/>
     * When used to connect a free function with payload, its signature must be
     * such that the instance is the first argument before the ones used to
     * define the signal itself.
     *
     * @tparam Candidate Function or member to connect to the signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     * @return A properly initialized connection object.
     */
    template<auto Candidate, typename Type>
    connection connect(Type &&value_or_instance) {
        disconnect<Candidate>(value_or_instance);

        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>(value_or_instance);
        signal->calls.insert(signal->calls.end() - offset, std::move(call));

        delegate<void(void *)> conn{};
        conn.template connect<&release<Candidate, Type>>(value_or_instance);
        return { std::move(conn), signal };
    }

    /**
     * @brief Disconnects a free function or an unbound member from a signal.
     * @tparam Candidate Function or member to disconnect from the signal.
     */
    template<auto Candidate>
    void disconnect() {
        auto &calls = signal->calls;
        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>();
        calls.erase(std::remove(calls.begin(), calls.end(), std::move(call)), calls.end());
    }

    /**
     * @brief Disconnects a free function with payload or a bound member from a
     * signal.
     * @tparam Candidate Function or member to disconnect from the signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void disconnect(Type &&value_or_instance) {
        auto &calls = signal->calls;
        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>(std::forward<Type>(value_or_instance));
        calls.erase(std::remove(calls.begin(), calls.end(), std::move(call)), calls.end());
    }

    /**
     * @brief Disconnects free functions with payload or bound members from a
     * signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<typename Type>
    void disconnect(Type &value_or_instance) {
        disconnect(&value_or_instance);
    }

    /**
     * @brief Disconnects free functions with payload or bound members from a
     * signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<typename Type>
    void disconnect(Type *value_or_instance) {
        if(value_or_instance) {
            auto &calls = signal->calls;
            calls.erase(std::remove_if(calls.begin(), calls.end(), [value_or_instance](const auto &delegate) {
                return delegate.instance() == value_or_instance;
            }), calls.end());
        }
    }

    /*! @brief Disconnects all the listeners from a signal. */
    void disconnect() {
        signal->calls.clear();
    }

private:
    difference_type offset;
    signal_type *signal;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the function type of a sink directly from the signal it
 * refers to.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
sink(sigh<Ret(Args...)> &) ENTT_NOEXCEPT -> sink<Ret(Args...)>;


}


#endif

// #include "entity.hpp"
#ifndef ENTT_ENTITY_ENTITY_HPP
#define ENTT_ENTITY_ENTITY_HPP


#include <cstdint>
#include <type_traits>
// #include "../config/config.h"

// #include "../core/type_traits.hpp"

// #include "../core/fwd.hpp"



namespace entt {


/**
 * @brief Entity traits.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is an accepted entity type.
 */
template<typename>
struct entt_traits;


/**
 * @brief Entity traits for a 16 bits entity identifier.
 *
 * A 16 bits entity identifier guarantees:
 *
 * * 12 bits for the entity number (up to 4k entities).
 * * 4 bit for the version (resets in [0-15]).
 */
template<>
struct entt_traits<std::uint16_t> {
    /*! @brief Underlying entity type. */
    using entity_type = std::uint16_t;
    /*! @brief Underlying version type. */
    using version_type = std::uint8_t;
    /*! @brief Difference type. */
    using difference_type = std::int32_t;

    /*! @brief Mask to use to get the entity number out of an identifier. */
    static constexpr std::uint16_t entity_mask = 0xFFF;
    /*! @brief Mask to use to get the version out of an identifier. */
    static constexpr std::uint16_t version_mask = 0xF;
    /*! @brief Extent of the entity number within an identifier. */
    static constexpr auto entity_shift = 12;
};


/**
 * @brief Entity traits for a 32 bits entity identifier.
 *
 * A 32 bits entity identifier guarantees:
 *
 * * 20 bits for the entity number (suitable for almost all the games).
 * * 12 bit for the version (resets in [0-4095]).
 */
template<>
struct entt_traits<std::uint32_t> {
    /*! @brief Underlying entity type. */
    using entity_type = std::uint32_t;
    /*! @brief Underlying version type. */
    using version_type = std::uint16_t;
    /*! @brief Difference type. */
    using difference_type = std::int64_t;

    /*! @brief Mask to use to get the entity number out of an identifier. */
    static constexpr std::uint32_t entity_mask = 0xFFFFF;
    /*! @brief Mask to use to get the version out of an identifier. */
    static constexpr std::uint32_t version_mask = 0xFFF;
    /*! @brief Extent of the entity number within an identifier. */
    static constexpr auto entity_shift = 20;
};


/**
 * @brief Entity traits for a 64 bits entity identifier.
 *
 * A 64 bits entity identifier guarantees:
 *
 * * 32 bits for the entity number (an indecently large number).
 * * 32 bit for the version (an indecently large number).
 */
template<>
struct entt_traits<std::uint64_t> {
    /*! @brief Underlying entity type. */
    using entity_type = std::uint64_t;
    /*! @brief Underlying version type. */
    using version_type = std::uint32_t;
    /*! @brief Difference type. */
    using difference_type = std::int64_t;

    /*! @brief Mask to use to get the entity number out of an identifier. */
    static constexpr std::uint64_t entity_mask = 0xFFFFFFFF;
    /*! @brief Mask to use to get the version out of an identifier. */
    static constexpr std::uint64_t version_mask = 0xFFFFFFFF;
    /*! @brief Extent of the entity number within an identifier. */
    static constexpr auto entity_shift = 32;
};


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


class null {
    template<typename Entity>
    using traits_type = entt_traits<std::underlying_type_t<Entity>>;

public:
    template<typename Entity>
    constexpr operator Entity() const ENTT_NOEXCEPT {
        return Entity{traits_type<Entity>::entity_mask};
    }

    constexpr bool operator==(null) const ENTT_NOEXCEPT {
        return true;
    }

    constexpr bool operator!=(null) const ENTT_NOEXCEPT {
        return false;
    }

    template<typename Entity>
    constexpr bool operator==(const Entity entity) const ENTT_NOEXCEPT {
        return (to_integral(entity) & traits_type<Entity>::entity_mask) == to_integral(static_cast<Entity>(*this));
    }

    template<typename Entity>
    constexpr bool operator!=(const Entity entity) const ENTT_NOEXCEPT {
        return !(entity == *this);
    }
};


template<typename Entity>
constexpr bool operator==(const Entity entity, null other) ENTT_NOEXCEPT {
    return other.operator==(entity);
}


template<typename Entity>
constexpr bool operator!=(const Entity entity, null other) ENTT_NOEXCEPT {
    return !(other == entity);
}


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/*! @brief Default entity identifier. */
ENTT_OPAQUE_TYPE(entity, id_type);


/**
 * @brief Compile-time constant for null entities.
 *
 * There exist implicit conversions from this variable to entity identifiers of
 * any allowed type. Similarly, there exist comparision operators between the
 * null entity and any other entity identifier.
 */
inline constexpr auto null = internal::null{};


}


#endif

// #include "fwd.hpp"
#ifndef ENTT_ENTITY_FWD_HPP
#define ENTT_ENTITY_FWD_HPP


// #include "../core/fwd.hpp"



namespace entt {


/*! @class basic_registry */
template <typename>
class basic_registry;

/*! @class basic_view */
template<typename...>
class basic_view;

/*! @class basic_runtime_view */
template<typename>
class basic_runtime_view;

/*! @class basic_group */
template<typename...>
class basic_group;

/*! @class basic_observer */
template<typename>
class basic_observer;

/*! @struct basic_actor */
template <typename>
struct basic_actor;

/*! @class basic_snapshot */
template<typename>
class basic_snapshot;

/*! @class basic_snapshot_loader */
template<typename>
class basic_snapshot_loader;

/*! @class basic_continuous_loader */
template<typename>
class basic_continuous_loader;

/*! @class entity */
enum class entity: id_type;

/*! @brief Alias declaration for the most common use case. */
using registry = basic_registry<entity>;

/*! @brief Alias declaration for the most common use case. */
using observer = basic_observer<entity>;

/*! @brief Alias declaration for the most common use case. */
using actor = basic_actor<entity>;

/*! @brief Alias declaration for the most common use case. */
using snapshot = basic_snapshot<entity>;

/*! @brief Alias declaration for the most common use case. */
using snapshot_loader = basic_snapshot_loader<entity>;

/*! @brief Alias declaration for the most common use case. */
using continuous_loader = basic_continuous_loader<entity>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Types Types of components iterated by the view.
 */
template<typename... Types>
using view = basic_view<entity, Types...>;

/*! @brief Alias declaration for the most common use case. */
using runtime_view = basic_runtime_view<entity>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Types Types of components iterated by the group.
 */
template<typename... Types>
using group = basic_group<entity, Types...>;


}


#endif

// #include "group.hpp"
#ifndef ENTT_ENTITY_GROUP_HPP
#define ENTT_ENTITY_GROUP_HPP


#include <tuple>
#include <utility>
#include <type_traits>
// #include "../config/config.h"

// #include "../core/type_traits.hpp"

// #include "sparse_set.hpp"
#ifndef ENTT_ENTITY_SPARSE_SET_HPP
#define ENTT_ENTITY_SPARSE_SET_HPP


#include <iterator>
#include <utility>
#include <vector>
#include <memory>
#include <cstddef>
#include <type_traits>
// #include "../config/config.h"

// #include "../core/algorithm.hpp"

// #include "entity.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Basic sparse set implementation.
 *
 * Sparse set or packed array or whatever is the name users give it.<br/>
 * Two arrays: an _external_ one and an _internal_ one; a _sparse_ one and a
 * _packed_ one; one used for direct access through contiguous memory, the other
 * one used to get the data through an extra level of indirection.<br/>
 * This is largely used by the registry to offer users the fastest access ever
 * to the components. Views and groups in general are almost entirely designed
 * around sparse sets.
 *
 * This type of data structure is widely documented in the literature and on the
 * web. This is nothing more than a customized implementation suitable for the
 * purpose of the framework.
 *
 * @note
 * There are no guarantees that entities are returned in the insertion order
 * when iterate a sparse set. Do not make assumption on the order in any case.
 *
 * @note
 * Internal data structures arrange elements to maximize performance. Because of
 * that, there are no guarantees that elements have the expected order when
 * iterate directly the internal packed array (see `data` and `size` member
 * functions for that). Use `begin` and `end` instead.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class sparse_set {
    static_assert(ENTT_PAGE_SIZE && ((ENTT_PAGE_SIZE & (ENTT_PAGE_SIZE - 1)) == 0));
    static constexpr auto entt_per_page = ENTT_PAGE_SIZE / sizeof(Entity);

    using traits_type = entt_traits<std::underlying_type_t<Entity>>;
    using page_type = std::unique_ptr<Entity[]>;

    class sparse_set_iterator final {
        friend class sparse_set<Entity>;

        using packed_type = std::vector<Entity>;
        using index_type = typename traits_type::difference_type;

        sparse_set_iterator(const packed_type &ref, const index_type idx) ENTT_NOEXCEPT
            : packed{&ref}, index{idx}
        {}

    public:
        using difference_type = index_type;
        using value_type = Entity;
        using pointer = const value_type *;
        using reference = const value_type &;
        using iterator_category = std::random_access_iterator_tag;

        sparse_set_iterator() ENTT_NOEXCEPT = default;

        sparse_set_iterator & operator++() ENTT_NOEXCEPT {
            return --index, *this;
        }

        sparse_set_iterator operator++(int) ENTT_NOEXCEPT {
            iterator orig = *this;
            return operator++(), orig;
        }

        sparse_set_iterator & operator--() ENTT_NOEXCEPT {
            return ++index, *this;
        }

        sparse_set_iterator operator--(int) ENTT_NOEXCEPT {
            sparse_set_iterator orig = *this;
            return operator--(), orig;
        }

        sparse_set_iterator & operator+=(const difference_type value) ENTT_NOEXCEPT {
            index -= value;
            return *this;
        }

        sparse_set_iterator operator+(const difference_type value) const ENTT_NOEXCEPT {
            sparse_set_iterator copy = *this;
            return (copy += value);
        }

        sparse_set_iterator & operator-=(const difference_type value) ENTT_NOEXCEPT {
            return (*this += -value);
        }

        sparse_set_iterator operator-(const difference_type value) const ENTT_NOEXCEPT {
            return (*this + -value);
        }

        difference_type operator-(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return other.index - index;
        }

        reference operator[](const difference_type value) const {
            const auto pos = size_type(index-value-1);
            return (*packed)[pos];
        }

        bool operator==(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return other.index == index;
        }

        bool operator!=(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return !(*this == other);
        }

        bool operator<(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return index > other.index;
        }

        bool operator>(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return index < other.index;
        }

        bool operator<=(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return !(*this > other);
        }

        bool operator>=(const sparse_set_iterator &other) const ENTT_NOEXCEPT {
            return !(*this < other);
        }

        pointer operator->() const {
            const auto pos = size_type(index-1);
            return &(*packed)[pos];
        }

        reference operator*() const {
            return *operator->();
        }

    private:
        const packed_type *packed;
        index_type index;
    };

    auto page(const Entity entt) const ENTT_NOEXCEPT {
        return std::size_t{(to_integral(entt) & traits_type::entity_mask) / entt_per_page};
    }

    auto offset(const Entity entt) const ENTT_NOEXCEPT {
        return std::size_t{to_integral(entt) & (entt_per_page - 1)};
    }

    page_type & assure(const std::size_t pos) {
        if(!(pos < sparse.size())) {
            sparse.resize(pos+1);
        }

        if(!sparse[pos]) {
            sparse[pos] = std::make_unique<entity_type[]>(entt_per_page);
            // null is safe in all cases for our purposes
            for(auto *first = sparse[pos].get(), *last = first + entt_per_page; first != last; ++first) {
                *first = null;
            }
        }

        return sparse[pos];
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Random access iterator type. */
    using iterator = sparse_set_iterator;

    /*! @brief Default constructor. */
    sparse_set() = default;

    /*! @brief Default move constructor. */
    sparse_set(sparse_set &&) = default;

    /*! @brief Default destructor. */
    virtual ~sparse_set() = default;

    /*! @brief Default move assignment operator. @return This sparse set. */
    sparse_set & operator=(sparse_set &&) = default;

    /**
     * @brief Increases the capacity of a sparse set.
     *
     * If the new capacity is greater than the current capacity, new storage is
     * allocated, otherwise the method does nothing.
     *
     * @param cap Desired capacity.
     */
    void reserve(const size_type cap) {
        packed.reserve(cap);
    }

    /**
     * @brief Returns the number of elements that a sparse set has currently
     * allocated space for.
     * @return Capacity of the sparse set.
     */
    size_type capacity() const ENTT_NOEXCEPT {
        return packed.capacity();
    }

    /*! @brief Requests the removal of unused capacity. */
    void shrink_to_fit() {
        // conservative approach
        if(packed.empty()) {
            sparse.clear();
        }

        sparse.shrink_to_fit();
        packed.shrink_to_fit();
    }

    /**
     * @brief Returns the extent of a sparse set.
     *
     * The extent of a sparse set is also the size of the internal sparse array.
     * There is no guarantee that the internal packed array has the same size.
     * Usually the size of the internal sparse array is equal or greater than
     * the one of the internal packed array.
     *
     * @return Extent of the sparse set.
     */
    size_type extent() const ENTT_NOEXCEPT {
        return sparse.size() * entt_per_page;
    }

    /**
     * @brief Returns the number of elements in a sparse set.
     *
     * The number of elements is also the size of the internal packed array.
     * There is no guarantee that the internal sparse array has the same size.
     * Usually the size of the internal sparse array is equal or greater than
     * the one of the internal packed array.
     *
     * @return Number of elements.
     */
    size_type size() const ENTT_NOEXCEPT {
        return packed.size();
    }

    /**
     * @brief Checks whether a sparse set is empty.
     * @return True if the sparse set is empty, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return packed.empty();
    }

    /**
     * @brief Direct access to the internal packed array.
     *
     * The returned pointer is such that range `[data(), data() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order, even though `respect` has been
     * previously invoked. Internal data structures arrange elements to maximize
     * performance. Accessing them directly gives a performance boost but less
     * guarantees. Use `begin` and `end` if you want to iterate the sparse set
     * in the expected order.
     *
     * @return A pointer to the internal packed array.
     */
    const entity_type * data() const ENTT_NOEXCEPT {
        return packed.data();
    }

    /**
     * @brief Returns an iterator to the beginning.
     *
     * The returned iterator points to the first entity of the internal packed
     * array. If the sparse set is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @note
     * Random access iterators stay true to the order imposed by a call to
     * `respect`.
     *
     * @return An iterator to the first entity of the internal packed array.
     */
    iterator begin() const ENTT_NOEXCEPT {
        const typename traits_type::difference_type pos = packed.size();
        return iterator{packed, pos};
    }

    /**
     * @brief Returns an iterator to the end.
     *
     * The returned iterator points to the element following the last entity in
     * the internal packed array. Attempting to dereference the returned
     * iterator results in undefined behavior.
     *
     * @note
     * Random access iterators stay true to the order imposed by a call to
     * `respect`.
     *
     * @return An iterator to the element following the last entity of the
     * internal packed array.
     */
    iterator end() const ENTT_NOEXCEPT {
        return iterator{packed, {}};
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid entity identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    iterator find(const entity_type entt) const {
        return contains(entt) ? --(end() - index(entt)) : end();
    }

    /**
     * @brief Checks if a sparse set contains an entity.
     * @param entt A valid entity identifier.
     * @return True if the sparse set contains the entity, false otherwise.
     */
    bool contains(const entity_type entt) const {
        const auto curr = page(entt);
        // testing against null permits to avoid accessing the packed array
        return (curr < sparse.size() && sparse[curr] && sparse[curr][offset(entt)] != null);
    }

    /*! @copydoc contains */
    [[deprecated("use ::contains instead")]]
    bool has(const entity_type entt) const {
        return contains(entt);
    }

    /**
     * @brief Returns the position of an entity in a sparse set.
     *
     * @warning
     * Attempting to get the position of an entity that doesn't belong to the
     * sparse set results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * sparse set doesn't contain the given entity.
     *
     * @param entt A valid entity identifier.
     * @return The position of the entity in the sparse set.
     */
    size_type index(const entity_type entt) const {
        ENTT_ASSERT(contains(entt));
        return size_type(sparse[page(entt)][offset(entt)]);
    }

    /**
     * @brief Assigns an entity to a sparse set.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the sparse set
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * sparse set already contains the given entity.
     *
     * @param entt A valid entity identifier.
     */
    void emplace(const entity_type entt) {
        ENTT_ASSERT(!contains(entt));
        assure(page(entt))[offset(entt)] = entity_type(packed.size());
        packed.push_back(entt);
    }

    /*! @copydoc emplace */
    [[deprecated("use ::emplace instead")]]
    void construct(const entity_type entt) {
        emplace(entt);
    }

    /**
     * @brief Assigns one or more entities to a sparse set.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the sparse set
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * sparse set already contains the given entity.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    void insert(It first, It last) {
        auto next = packed.size();
        packed.insert(packed.end(), first, last);

        while(first != last) {
            const auto entt = *(first++);
            ENTT_ASSERT(!contains(entt));
            assure(page(entt))[offset(entt)] = entity_type(next++);
        }
    }

    /*! @copydoc insert */
    template<typename It>
    [[deprecated("use ::insert instead")]]
    void construct(It first, It last) {
        insert(std::move(first), std::move(last));
    }

    /**
     * @brief Removes an entity from a sparse set.
     *
     * @warning
     * Attempting to remove an entity that doesn't belong to the sparse set
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * sparse set doesn't contain the given entity.
     *
     * @param entt A valid entity identifier.
     */
    void erase(const entity_type entt) {
        ENTT_ASSERT(contains(entt));
        const auto curr = page(entt);
        const auto pos = offset(entt);
        packed[size_type(sparse[curr][pos])] = entity_type(packed.back());
        sparse[page(packed.back())][offset(packed.back())] = sparse[curr][pos];
        sparse[curr][pos] = null;
        packed.pop_back();
    }

    /*! @copydoc erase */
    [[deprecated("use ::erase instead")]]
    void destroy(const entity_type entt) {
        erase(entt);
    }

    /**
     * @brief Swaps two entities in the internal packed array.
     *
     * For what it's worth, this function affects both the internal sparse array
     * and the internal packed array. Users should not care of that anyway.
     *
     * @warning
     * Attempting to swap entities that don't belong to the sparse set results
     * in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * sparse set doesn't contain the given entities.
     *
     * @param lhs A valid entity identifier.
     * @param rhs A valid entity identifier.
     */
    virtual void swap(const entity_type lhs, const entity_type rhs) {
        auto &from = sparse[page(lhs)][offset(lhs)];
        auto &to = sparse[page(rhs)][offset(rhs)];
        std::swap(packed[size_type(from)], packed[size_type(to)]);
        std::swap(from, to);
    }

    /**
     * @brief Sort elements according to the given comparison function.
     *
     * Sort the elements so that iterating the range with a couple of iterators
     * returns them in the expected order. See `begin` and `end` for more
     * details.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to the following:
     *
     * @code{.cpp}
     * bool(const Entity, const Entity);
     * @endcode
     *
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function oject must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @note
     * Attempting to iterate elements using a raw pointer returned by a call to
     * `data` gives no guarantees on the order, even though `sort` has been
     * invoked.
     *
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Compare, typename Sort = std_sort, typename... Args>
    void sort(iterator first, iterator last, Compare compare, Sort algo = Sort{}, Args &&... args) {
        ENTT_ASSERT(!(last < first));
        ENTT_ASSERT(!(last > end()));

        const auto length = std::distance(first, last);
        const auto skip = std::distance(last, end());
        const auto to = packed.rend() - skip;
        const auto from = to - length;

        algo(from, to, std::move(compare), std::forward<Args>(args)...);

        for(size_type pos = skip, end = skip+length; pos < end; ++pos) {
            sparse[page(packed[pos])][offset(packed[pos])] = entity_type(pos);
        }
    }

    /**
     * @brief Sort elements according to the given comparison function.
     *
     * @sa sort
     *
     * This function is a slightly slower version of `sort` that invokes the
     * caller to indicate which entities are swapped.<br/>
     * It's recommended when the caller wants to sort its own data structures to
     * align them with the order induced in the sparse set.
     *
     * The signature of the callback should be equivalent to the following:
     *
     * @code{.cpp}
     * bool(const Entity, const Entity);
     * @endcode
     *
     * @tparam Apply Type of function object to invoke to notify the caller.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param apply A valid function object to use as a callback.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Apply, typename Compare, typename Sort = std_sort, typename... Args>
    void arrange(iterator first, iterator last, Apply apply, Compare compare, Sort algo = Sort{}, Args &&... args) {
        ENTT_ASSERT(!(last < first));
        ENTT_ASSERT(!(last > end()));

        const auto length = std::distance(first, last);
        const auto skip = std::distance(last, end());
        const auto to = packed.rend() - skip;
        const auto from = to - length;

        algo(from, to, std::move(compare), std::forward<Args>(args)...);

        for(size_type pos = skip, end = skip+length; pos < end; ++pos) {
            auto curr = pos;
            auto next = index(packed[curr]);

            while(curr != next) {
                apply(packed[curr], packed[next]);
                sparse[page(packed[curr])][offset(packed[curr])] = entity_type(curr);

                curr = next;
                next = index(packed[curr]);
            }
        }
    }

    /**
     * @brief Sort entities according to their order in another sparse set.
     *
     * Entities that are part of both the sparse sets are ordered internally
     * according to the order they have in `other`. All the other entities goes
     * to the end of the list and there are no guarantees on their order.<br/>
     * In other terms, this function can be used to impose the same order on two
     * sets by using one of them as a master and the other one as a slave.
     *
     * Iterating the sparse set with a couple of iterators returns elements in
     * the expected order after a call to `respect`. See `begin` and `end` for
     * more details.
     *
     * @note
     * Attempting to iterate elements using a raw pointer returned by a call to
     * `data` gives no guarantees on the order, even though `respect` has been
     * invoked.
     *
     * @param other The sparse sets that imposes the order of the entities.
     */
    void respect(const sparse_set &other) {
        const auto to = other.end();
        auto from = other.begin();

        size_type pos = packed.size() - 1;

        while(pos && from != to) {
            if(contains(*from)) {
                if(*from != packed[pos]) {
                    swap(packed[pos], *from);
                }

                --pos;
            }

            ++from;
        }
    }

    /**
     * @brief Clears a sparse set.
     */
    void clear() ENTT_NOEXCEPT {
        sparse.clear();
        packed.clear();
    }

private:
    std::vector<page_type> sparse;
    std::vector<entity_type> packed;
};


}


#endif

// #include "storage.hpp"
#ifndef ENTT_ENTITY_STORAGE_HPP
#define ENTT_ENTITY_STORAGE_HPP


#include <algorithm>
#include <iterator>
#include <utility>
#include <vector>
#include <cstddef>
#include <type_traits>
// #include "../config/config.h"

// #include "../core/algorithm.hpp"

// #include "sparse_set.hpp"

// #include "entity.hpp"



namespace entt {


/**
 * @brief Basic storage implementation.
 *
 * This class is a refinement of a sparse set that associates an object to an
 * entity. The main purpose of this class is to extend sparse sets to store
 * components in a registry. It guarantees fast access both to the elements and
 * to the entities.
 *
 * @note
 * Entities and objects have the same order. It's guaranteed both in case of raw
 * access (either to entities or objects) and when using random or input access
 * iterators.
 *
 * @note
 * Internal data structures arrange elements to maximize performance. Because of
 * that, there are no guarantees that elements have the expected order when
 * iterate directly the internal packed array (see `raw` and `size` member
 * functions for that). Use `begin` and `end` instead.
 *
 * @warning
 * Empty types aren't explicitly instantiated. Therefore, many of the functions
 * normally available for non-empty types will not be available for empty ones.
 *
 * @sa sparse_set<Entity>
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 * @tparam Type Type of objects assigned to the entities.
 */
template<typename Entity, typename Type, typename = std::void_t<>>
class storage: public sparse_set<Entity> {
    static_assert(std::is_move_constructible_v<Type>);
    static_assert(std::is_move_assignable_v<Type>);

    using underlying_type = sparse_set<Entity>;
    using traits_type = entt_traits<std::underlying_type_t<Entity>>;

    template<bool Const>
    class storage_iterator final {
        friend class storage<Entity, Type>;

        using instance_type = std::conditional_t<Const, const std::vector<Type>, std::vector<Type>>;
        using index_type = typename traits_type::difference_type;

        storage_iterator(instance_type &ref, const index_type idx) ENTT_NOEXCEPT
            : instances{&ref}, index{idx}
        {}

    public:
        using difference_type = index_type;
        using value_type = Type;
        using pointer = std::conditional_t<Const, const value_type *, value_type *>;
        using reference = std::conditional_t<Const, const value_type &, value_type &>;
        using iterator_category = std::random_access_iterator_tag;

        storage_iterator() ENTT_NOEXCEPT = default;

        storage_iterator & operator++() ENTT_NOEXCEPT {
            return --index, *this;
        }

        storage_iterator operator++(int) ENTT_NOEXCEPT {
            storage_iterator orig = *this;
            return operator++(), orig;
        }

        storage_iterator & operator--() ENTT_NOEXCEPT {
            return ++index, *this;
        }

        storage_iterator operator--(int) ENTT_NOEXCEPT {
            storage_iterator orig = *this;
            return operator--(), orig;
        }

        storage_iterator & operator+=(const difference_type value) ENTT_NOEXCEPT {
            index -= value;
            return *this;
        }

        storage_iterator operator+(const difference_type value) const ENTT_NOEXCEPT {
            storage_iterator copy = *this;
            return (copy += value);
        }

        storage_iterator & operator-=(const difference_type value) ENTT_NOEXCEPT {
            return (*this += -value);
        }

        storage_iterator operator-(const difference_type value) const ENTT_NOEXCEPT {
            return (*this + -value);
        }

        difference_type operator-(const storage_iterator &other) const ENTT_NOEXCEPT {
            return other.index - index;
        }

        reference operator[](const difference_type value) const ENTT_NOEXCEPT {
            const auto pos = size_type(index-value-1);
            return (*instances)[pos];
        }

        bool operator==(const storage_iterator &other) const ENTT_NOEXCEPT {
            return other.index == index;
        }

        bool operator!=(const storage_iterator &other) const ENTT_NOEXCEPT {
            return !(*this == other);
        }

        bool operator<(const storage_iterator &other) const ENTT_NOEXCEPT {
            return index > other.index;
        }

        bool operator>(const storage_iterator &other) const ENTT_NOEXCEPT {
            return index < other.index;
        }

        bool operator<=(const storage_iterator &other) const ENTT_NOEXCEPT {
            return !(*this > other);
        }

        bool operator>=(const storage_iterator &other) const ENTT_NOEXCEPT {
            return !(*this < other);
        }

        pointer operator->() const ENTT_NOEXCEPT {
            const auto pos = size_type(index-1);
            return &(*instances)[pos];
        }

        reference operator*() const ENTT_NOEXCEPT {
            return *operator->();
        }

    private:
        instance_type *instances;
        index_type index;
    };

public:
    /*! @brief Type of the objects associated with the entities. */
    using object_type = Type;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Random access iterator type. */
    using iterator = storage_iterator<false>;
    /*! @brief Constant random access iterator type. */
    using const_iterator = storage_iterator<true>;

    /**
     * @brief Increases the capacity of a storage.
     *
     * If the new capacity is greater than the current capacity, new storage is
     * allocated, otherwise the method does nothing.
     *
     * @param cap Desired capacity.
     */
    void reserve(const size_type cap) {
        underlying_type::reserve(cap);
        instances.reserve(cap);
    }

    /*! @brief Requests the removal of unused capacity. */
    void shrink_to_fit() {
        underlying_type::shrink_to_fit();
        instances.shrink_to_fit();
    }

    /**
     * @brief Direct access to the array of objects.
     *
     * The returned pointer is such that range `[raw(), raw() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order, even though either `sort` or
     * `respect` has been previously invoked. Internal data structures arrange
     * elements to maximize performance. Accessing them directly gives a
     * performance boost but less guarantees. Use `begin` and `end` if you want
     * to iterate the storage in the expected order.
     *
     * @return A pointer to the array of objects.
     */
    const object_type * raw() const ENTT_NOEXCEPT {
        return instances.data();
    }

    /*! @copydoc raw */
    object_type * raw() ENTT_NOEXCEPT {
        return const_cast<object_type *>(std::as_const(*this).raw());
    }

    /**
     * @brief Returns an iterator to the beginning.
     *
     * The returned iterator points to the first instance of the given type. If
     * the storage is empty, the returned iterator will be equal to `end()`.
     *
     * @note
     * Random access iterators stay true to the order imposed by a call to
     * either `sort` or `respect`.
     *
     * @return An iterator to the first instance of the given type.
     */
    const_iterator cbegin() const ENTT_NOEXCEPT {
        const typename traits_type::difference_type pos = underlying_type::size();
        return const_iterator{instances, pos};
    }

    /*! @copydoc cbegin */
    const_iterator begin() const ENTT_NOEXCEPT {
        return cbegin();
    }

    /*! @copydoc begin */
    iterator begin() ENTT_NOEXCEPT {
        const typename traits_type::difference_type pos = underlying_type::size();
        return iterator{instances, pos};
    }

    /**
     * @brief Returns an iterator to the end.
     *
     * The returned iterator points to the element following the last instance
     * of the given type. Attempting to dereference the returned iterator
     * results in undefined behavior.
     *
     * @note
     * Random access iterators stay true to the order imposed by a call to
     * either `sort` or `respect`.
     *
     * @return An iterator to the element following the last instance of the
     * given type.
     */
    const_iterator cend() const ENTT_NOEXCEPT {
        return const_iterator{instances, {}};
    }

    /*! @copydoc cend */
    const_iterator end() const ENTT_NOEXCEPT {
        return cend();
    }

    /*! @copydoc end */
    iterator end() ENTT_NOEXCEPT {
        return iterator{instances, {}};
    }

    /**
     * @brief Returns the object associated with an entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * storage doesn't contain the given entity.
     *
     * @param entt A valid entity identifier.
     * @return The object associated with the entity.
     */
    const object_type & get(const entity_type entt) const {
        return instances[underlying_type::index(entt)];
    }

    /*! @copydoc get */
    object_type & get(const entity_type entt) {
        return const_cast<object_type &>(std::as_const(*this).get(entt));
    }

    /**
     * @brief Returns a pointer to the object associated with an entity, if any.
     * @param entt A valid entity identifier.
     * @return The object associated with the entity, if any.
     */
    const object_type * try_get(const entity_type entt) const {
        return underlying_type::contains(entt) ? (instances.data() + underlying_type::index(entt)) : nullptr;
    }

    /*! @copydoc try_get */
    object_type * try_get(const entity_type entt) {
        return const_cast<object_type *>(std::as_const(*this).try_get(entt));
    }

    /**
     * @brief Assigns an entity to a storage and constructs its object.
     *
     * This version accept both types that can be constructed in place directly
     * and types like aggregates that do not work well with a placement new as
     * performed usually under the hood during an _emplace back_.
     *
     * @warning
     * Attempting to use an entity that already belongs to the storage results
     * in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * storage already contains the given entity.
     *
     * @tparam Args Types of arguments to use to construct the object.
     * @param entt A valid entity identifier.
     * @param args Parameters to use to construct an object for the entity.
     */
    template<typename... Args>
    void emplace(const entity_type entt, Args &&... args) {
        if constexpr(std::is_aggregate_v<object_type>) {
            instances.push_back(Type{std::forward<Args>(args)...});
        } else {
            instances.emplace_back(std::forward<Args>(args)...);
        }

        // entity goes after component in case constructor throws
        underlying_type::emplace(entt);
    }

    /*! @copydoc emplace */
    template<typename... Args>
    [[deprecated("use ::emplace instead")]]
    void construct(const entity_type entt, Args &&... args) {
        emplace(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Assigns one or more entities to a storage and constructs their
     * objects from a given instance.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the storage
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * storage already contains the given entity.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param value An instance of the object to construct.
     */
    template<typename It>
    void insert(It first, It last, const object_type &value = {}) {
        instances.insert(instances.end(), std::distance(first, last), value);
        // entities go after components in case constructors throw
        underlying_type::insert(first, last);
    }

    /*! @copydoc insert */
    template<typename It>
    [[deprecated("use ::insert instead")]]
    std::enable_if_t<std::is_same_v<typename std::iterator_traits<It>::value_type, entity_type>, void>
    construct(It first, It last, const object_type &value = {}) {
        insert(std::move(first), std::move(last), value);
    }

    /**
     * @brief Assigns one or more entities to a storage and constructs their
     * objects from a given range.
     *
     * @sa construct
     *
     * @tparam EIt Type of input iterator.
     * @tparam CIt Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param from An iterator to the first element of the range of objects.
     * @param to An iterator past the last element of the range of objects.
     */
    template<typename EIt, typename CIt>
    void insert(EIt first, EIt last, CIt from, CIt to) {
        instances.insert(instances.end(), from, to);
        // entities go after components in case constructors throw
        underlying_type::insert(first, last);
    }

    /*! @copydoc insert */
    template<typename EIt, typename CIt>
    [[deprecated("use ::insert instead")]]
    std::enable_if_t<std::is_same_v<typename std::iterator_traits<EIt>::value_type, entity_type>, void>
    construct(EIt first, EIt last, CIt value) {
        insert(std::move(first), std::move(last), std::move(value));
    }

    /**
     * @brief Removes an entity from a storage and destroys its object.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * storage doesn't contain the given entity.
     *
     * @param entt A valid entity identifier.
     */
    void erase(const entity_type entt) {
        auto other = std::move(instances.back());
        instances[underlying_type::index(entt)] = std::move(other);
        instances.pop_back();
        underlying_type::erase(entt);
    }

    /*! @copydoc erase */
    [[deprecated("use ::erase instead")]]
    void destroy(const entity_type entt) {
        erase(entt);
    }

    /**
     * @brief Swaps entities and objects in the internal packed arrays.
     *
     * @warning
     * Attempting to swap entities that don't belong to the sparse set results
     * in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * sparse set doesn't contain the given entities.
     *
     * @param lhs A valid entity identifier.
     * @param rhs A valid entity identifier.
     */
    void swap(const entity_type lhs, const entity_type rhs) override {
        std::swap(instances[underlying_type::index(lhs)], instances[underlying_type::index(rhs)]);
        underlying_type::swap(lhs, rhs);
    }

    /**
     * @brief Sort elements according to the given comparison function.
     *
     * Sort the elements so that iterating the range with a couple of iterators
     * returns them in the expected order. See `begin` and `end` for more
     * details.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(const Entity, const Entity);
     * bool(const Type &, const Type &);
     * @endcode
     *
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function oject must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @note
     * Attempting to iterate elements using a raw pointer returned by a call to
     * either `data` or `raw` gives no guarantees on the order, even though
     * `sort` has been invoked.
     *
     * @warning
     * Empty types are never instantiated. Therefore, only comparison function
     * objects that require to return entities rather than components are
     * accepted.
     *
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Compare, typename Sort = std_sort, typename... Args>
    void sort(iterator first, iterator last, Compare compare, Sort algo = Sort{}, Args &&... args) {
        ENTT_ASSERT(!(last < first));
        ENTT_ASSERT(!(last > end()));

        const auto from = underlying_type::begin() + std::distance(begin(), first);
        const auto to = from + std::distance(first, last);

        const auto apply = [this](const auto lhs, const auto rhs) {
            std::swap(instances[underlying_type::index(lhs)], instances[underlying_type::index(rhs)]);
        };

        if constexpr(std::is_invocable_v<Compare, const object_type &, const object_type &>) {
            underlying_type::arrange(from, to, std::move(apply), [this, compare = std::move(compare)](const auto lhs, const auto rhs) {
                return compare(std::as_const(instances[underlying_type::index(lhs)]), std::as_const(instances[underlying_type::index(rhs)]));
            }, std::move(algo), std::forward<Args>(args)...);
        } else {
            underlying_type::arrange(from, to, std::move(apply), std::move(compare), std::move(algo), std::forward<Args>(args)...);
        }
    }

    /*! @brief Clears a storage. */
    void clear() {
        underlying_type::clear();
        instances.clear();
    }

private:
    std::vector<object_type> instances;
};


/*! @copydoc storage */
template<typename Entity, typename Type>
class storage<Entity, Type, std::enable_if_t<ENTT_IS_EMPTY(Type)>>: public sparse_set<Entity> {
    using traits_type = entt_traits<std::underlying_type_t<Entity>>;
    using underlying_type = sparse_set<Entity>;

public:
    /*! @brief Type of the objects associated with the entities. */
    using object_type = Type;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;

    /**
     * @brief Assigns an entity to a storage and constructs its object.
     *
     * @warning
     * Attempting to use an entity that already belongs to the storage results
     * in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * storage already contains the given entity.
     *
     * @tparam Args Types of arguments to use to construct the object.
     * @param entt A valid entity identifier.
     * @param args Parameters to use to construct an object for the entity.
     */
    template<typename... Args>
    void emplace(const entity_type entt, Args &&... args) {
        [[maybe_unused]] object_type instance{std::forward<Args>(args)...};
        underlying_type::emplace(entt);
    }

    /*! @copydoc emplace */
    template<typename... Args>
    [[deprecated("use ::emplace instead")]]
    void construct(const entity_type entt, Args &&... args) {
        emplace(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Assigns one or more entities to a storage.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the storage
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * storage already contains the given entity.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    void insert(It first, It last, const object_type & = {}) {
        underlying_type::insert(first, last);
    }

    /**
     * @copydoc insert
     * @param value An instance of the object to construct.
     */
    template<typename It>
    [[deprecated("use ::insert instead")]]
    std::enable_if_t<std::is_same_v<typename std::iterator_traits<It>::value_type, entity_type>, void>
    construct(It first, It last, const object_type &value = {}) {
        insert(std::move(first), std::move(last), value);
    }
};


}


#endif

// #include "utility.hpp"
#ifndef ENTT_ENTITY_UTILITY_HPP
#define ENTT_ENTITY_UTILITY_HPP


// #include "../core/type_traits.hpp"



namespace entt {


/**
 * @brief Alias for exclusion lists.
 * @tparam Type List of types.
 */
template<typename... Type>
struct exclude_t: type_list<Type...> {};


/**
 * @brief Variable template for exclusion lists.
 * @tparam Type List of types.
 */
template<typename... Type>
inline constexpr exclude_t<Type...> exclude{};


/**
 * @brief Alias for lists of observed components.
 * @tparam Type List of types.
 */
template<typename... Type>
struct get_t: type_list<Type...>{};


/**
 * @brief Variable template for lists of observed components.
 * @tparam Type List of types.
 */
template<typename... Type>
inline constexpr get_t<Type...> get{};


}


#endif

// #include "entity.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Group.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error, but for a few reasonable cases.
 */
template<typename...>
class basic_group;


/**
 * @brief Non-owning group.
 *
 * A non-owning group returns all entities and only the entities that have at
 * least the given components. Moreover, it's guaranteed that the entity list
 * is tightly packed in memory for fast iterations.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New instances of the given components are created and assigned to entities.
 * * The entity currently pointed is modified (as an example, if one of the
 *   given components is removed from the entity to which the iterator points).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the pools iterated by the group in any way
 * invalidates all the iterators and using them results in undefined behavior.
 *
 * @note
 * Groups share references to the underlying data structures of the registry
 * that generated them. Therefore any change to the entities and to the
 * components made by means of the registry are immediately reflected by all the
 * groups.<br/>
 * Moreover, sorting a non-owning group affects all the instances of the same
 * group (it means that users don't have to call `sort` on each instance to sort
 * all of them because they _share_ entities and components).
 *
 * @warning
 * Lifetime of a group must not overcome that of the registry that generated it.
 * In any other case, attempting to use a group results in undefined behavior.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 * @tparam Exclude Types of components used to filter the group.
 * @tparam Get Type of components observed by the group.
 */
template<typename Entity, typename... Exclude, typename... Get>
class basic_group<Entity, exclude_t<Exclude...>, get_t<Get...>> {
    /*! @brief A registry is allowed to create groups. */
    friend class basic_registry<Entity>;

    template<typename Component>
    using pool_type = std::conditional_t<std::is_const_v<Component>, const storage<Entity, std::remove_const_t<Component>>, storage<Entity, Component>>;

    // we could use pool_type<Type> &..., but vs complains about it and refuses to compile for unknown reasons (most likely a bug)
    basic_group(sparse_set<Entity> &ref, storage<Entity, std::remove_const_t<Get>> &... gpool) ENTT_NOEXCEPT
        : handler{&ref},
          pools{&gpool...}
    {}

    template<typename Func, typename... Weak>
    void traverse(Func func, type_list<Weak...>) const {
        for(const auto entt: *handler) {
            if constexpr(std::is_invocable_v<Func, decltype(get<Weak>({}))...>) {
                func(std::get<pool_type<Weak> *>(pools)->get(entt)...);
            } else {
                func(entt, std::get<pool_type<Weak> *>(pools)->get(entt)...);
            }
        }
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Input iterator type. */
    using iterator = typename sparse_set<Entity>::iterator;

    /**
     * @brief Returns the number of existing components of the given type.
     * @tparam Component Type of component of which to return the size.
     * @return Number of existing components of the given type.
     */
    template<typename Component>
    size_type size() const ENTT_NOEXCEPT {
        return std::get<pool_type<Component> *>(pools)->size();
    }

    /**
     * @brief Returns the number of entities that have the given components.
     * @return Number of entities that have the given components.
     */
    size_type size() const ENTT_NOEXCEPT {
        return handler->size();
    }

    /**
     * @brief Returns the number of elements that a group has currently
     * allocated space for.
     * @return Capacity of the group.
     */
    size_type capacity() const ENTT_NOEXCEPT {
        return handler->capacity();
    }

    /*! @brief Requests the removal of unused capacity. */
    void shrink_to_fit() {
        handler->shrink_to_fit();
    }

    /**
     * @brief Checks whether a group or some pools are empty.
     * @tparam Component Types of components in which one is interested.
     * @return True if the group or the pools are empty, false otherwise.
     */
    template<typename... Component>
    bool empty() const ENTT_NOEXCEPT {
        if constexpr(sizeof...(Component) == 0) {
            return handler->empty();
        } else {
            return (std::get<pool_type<Component> *>(pools)->empty() && ...);
        }
    }

    /**
     * @brief Direct access to the list of components of a given pool.
     *
     * The returned pointer is such that range
     * `[raw<Component>(), raw<Component>() + size<Component>()]` is always a
     * valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the components. Use `begin` and
     * `end` if you want to iterate the group in the expected order.
     *
     * @tparam Component Type of component in which one is interested.
     * @return A pointer to the array of components.
     */
    template<typename Component>
    Component * raw() const ENTT_NOEXCEPT {
        return std::get<pool_type<Component> *>(pools)->raw();
    }

    /**
     * @brief Direct access to the list of entities of a given pool.
     *
     * The returned pointer is such that range
     * `[data<Component>(), data<Component>() + size<Component>()]` is always a
     * valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the group in the expected order.
     *
     * @tparam Component Type of component in which one is interested.
     * @return A pointer to the array of entities.
     */
    template<typename Component>
    const entity_type * data() const ENTT_NOEXCEPT {
        return std::get<pool_type<Component> *>(pools)->data();
    }

    /**
     * @brief Direct access to the list of entities.
     *
     * The returned pointer is such that range `[data(), data() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the group in the expected order.
     *
     * @return A pointer to the array of entities.
     */
    const entity_type * data() const ENTT_NOEXCEPT {
        return handler->data();
    }

    /**
     * @brief Returns an iterator to the first entity that has the given
     * components.
     *
     * The returned iterator points to the first entity that has the given
     * components. If the group is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the first entity that has the given components.
     */
    iterator begin() const ENTT_NOEXCEPT {
        return handler->begin();
    }

    /**
     * @brief Returns an iterator that is past the last entity that has the
     * given components.
     *
     * The returned iterator points to the entity following the last entity that
     * has the given components. Attempting to dereference the returned iterator
     * results in undefined behavior.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the entity following the last entity that has the
     * given components.
     */
    iterator end() const ENTT_NOEXCEPT {
        return handler->end();
    }

    /**
     * @brief Returns the first entity that has the given components, if any.
     * @return The first entity that has the given components if one exists, the
     * null entity otherwise.
     */
    entity_type front() const {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity that has the given components, if any.
     * @return The last entity that has the given components if one exists, the
     * null entity otherwise.
     */
    entity_type back() const {
        const auto it = std::make_reverse_iterator(end());
        return it != std::make_reverse_iterator(begin()) ? *it : null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid entity identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    iterator find(const entity_type entt) const {
        const auto it = handler->find(entt);
        return it != end() && *it == entt ? it : end();
    }

    /**
     * @brief Returns the identifier that occupies the given position.
     * @param pos Position of the element to return.
     * @return The identifier that occupies the given position.
     */
    entity_type operator[](const size_type pos) const {
        return begin()[pos];
    }

    /**
     * @brief Checks if a group contains an entity.
     * @param entt A valid entity identifier.
     * @return True if the group contains the given entity, false otherwise.
     */
    bool contains(const entity_type entt) const {
        return handler->contains(entt);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * Prefer this function instead of `registry::get` during iterations. It has
     * far better performance than its counterpart.
     *
     * @warning
     * Attempting to use an invalid component type results in a compilation
     * error. Attempting to use an entity that doesn't belong to the group
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * group doesn't contain the given entity.
     *
     * @tparam Component Types of components to get.
     * @param entt A valid entity identifier.
     * @return The components assigned to the entity.
     */
    template<typename... Component>
    decltype(auto) get([[maybe_unused]] const entity_type entt) const {
        ENTT_ASSERT(contains(entt));

        if constexpr(sizeof...(Component) == 1) {
            return (std::get<pool_type<Component> *>(pools)->get(entt), ...);
        } else {
            return std::tuple<decltype(get<Component>({}))...>{get<Component>(entt)...};
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        using get_type_list = type_list_cat_t<std::conditional_t<ENTT_IS_EMPTY(Get), type_list<>, type_list<Get>>...>;
        traverse(std::move(func), get_type_list{});
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    [[deprecated("use ::each instead")]]
    void less(Func func) const {
        each(std::move(func));
    }

    /**
     * @brief Sort a group according to the given comparison function.
     *
     * Sort the group so that iterating it with a couple of iterators returns
     * entities and components in the expected order. See `begin` and `end` for
     * more details.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(std::tuple<Component &...>, std::tuple<Component &...>);
     * bool(const Component &..., const Component &...);
     * bool(const Entity, const Entity);
     * @endcode
     *
     * Where `Component` are such that they are iterated by the group.<br/>
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function oject must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @note
     * Attempting to iterate elements using a raw pointer returned by a call to
     * either `data` or `raw` gives no guarantees on the order, even though
     * `sort` has been invoked.
     *
     * @tparam Component Optional types of components to compare.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename... Component, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&... args) {
        if constexpr(sizeof...(Component) == 0) {
            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>);
            handler->sort(handler->begin(), handler->end(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
        }  else if constexpr(sizeof...(Component) == 1) {
            handler->sort(handler->begin(), handler->end(), [this, compare = std::move(compare)](const entity_type lhs, const entity_type rhs) {
                return compare((std::get<pool_type<Component> *>(pools)->get(lhs), ...), (std::get<pool_type<Component> *>(pools)->get(rhs), ...));
            }, std::move(algo), std::forward<Args>(args)...);
        } else {
            handler->sort(handler->begin(), handler->end(), [this, compare = std::move(compare)](const entity_type lhs, const entity_type rhs) {
                return compare(std::tuple<decltype(get<Component>({}))...>{std::get<pool_type<Component> *>(pools)->get(lhs)...}, std::tuple<decltype(get<Component>({}))...>{std::get<pool_type<Component> *>(pools)->get(rhs)...});
            }, std::move(algo), std::forward<Args>(args)...);
        }
    }

    /**
     * @brief Sort the shared pool of entities according to the given component.
     *
     * Non-owning groups of the same type share with the registry a pool of
     * entities with its own order that doesn't depend on the order of any pool
     * of components. Users can order the underlying data structure so that it
     * respects the order of the pool of the given component.
     *
     * @note
     * The shared pool of entities and thus its order is affected by the changes
     * to each and every pool that it tracks. Therefore changes to those pools
     * can quickly ruin the order imposed to the pool of entities shared between
     * the non-owning groups.
     *
     * @tparam Component Type of component to use to impose the order.
     */
    template<typename Component>
    void sort() const {
        handler->respect(*std::get<pool_type<Component> *>(pools));
    }

private:
    sparse_set<entity_type> *handler;
    const std::tuple<pool_type<Get> *...> pools;
};


/**
 * @brief Owning group.
 *
 * Owning groups return all entities and only the entities that have at least
 * the given components. Moreover:
 *
 * * It's guaranteed that the entity list is tightly packed in memory for fast
 *   iterations.
 * * It's guaranteed that the lists of owned components are tightly packed in
 *   memory for even faster iterations and to allow direct access.
 * * They stay true to the order of the owned components and all instances have
 *   the same order in memory.
 *
 * The more types of components are owned by a group, the faster it is to
 * iterate them.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New instances of the given components are created and assigned to entities.
 * * The entity currently pointed is modified (as an example, if one of the
 *   given components is removed from the entity to which the iterator points).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the pools iterated by the group in any way
 * invalidates all the iterators and using them results in undefined behavior.
 *
 * @note
 * Groups share references to the underlying data structures of the registry
 * that generated them. Therefore any change to the entities and to the
 * components made by means of the registry are immediately reflected by all the
 * groups.
 * Moreover, sorting an owning group affects all the instance of the same group
 * (it means that users don't have to call `sort` on each instance to sort all
 * of them because they share the underlying data structure).
 *
 * @warning
 * Lifetime of a group must not overcome that of the registry that generated it.
 * In any other case, attempting to use a group results in undefined behavior.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 * @tparam Exclude Types of components used to filter the group.
 * @tparam Get Types of components observed by the group.
 * @tparam Owned Types of components owned by the group.
 */
template<typename Entity, typename... Exclude, typename... Get, typename... Owned>
class basic_group<Entity, exclude_t<Exclude...>, get_t<Get...>, Owned...> {
    /*! @brief A registry is allowed to create groups. */
    friend class basic_registry<Entity>;

    template<typename Component>
    using pool_type = std::conditional_t<std::is_const_v<Component>, const storage<Entity, std::remove_const_t<Component>>, storage<Entity, Component>>;

    template<typename Component>
    using component_iterator = decltype(std::declval<pool_type<Component>>().begin());

    // we could use pool_type<Type> &..., but vs complains about it and refuses to compile for unknown reasons (most likely a bug)
    basic_group(const std::size_t &ref, const std::size_t &extent, storage<Entity, std::remove_const_t<Owned>> &... opool, storage<Entity, std::remove_const_t<Get>> &... gpool) ENTT_NOEXCEPT
        : pools{&opool..., &gpool...},
          length{&extent},
          super{&ref}
    {}

    template<typename Func, typename... Strong, typename... Weak>
    void traverse(Func func, type_list<Strong...>, type_list<Weak...>) const {
        [[maybe_unused]] auto it = std::make_tuple((std::get<pool_type<Strong> *>(pools)->end() - *length)...);
        [[maybe_unused]] auto data = std::get<0>(pools)->sparse_set<entity_type>::end() - *length;

        for(auto next = *length; next; --next) {
            if constexpr(std::is_invocable_v<Func, decltype(get<Strong>({}))..., decltype(get<Weak>({}))...>) {
                if constexpr(sizeof...(Weak) == 0) {
                    func(*(std::get<component_iterator<Strong>>(it)++)...);
                } else {
                    const auto entt = *(data++);
                    func(*(std::get<component_iterator<Strong>>(it)++)..., std::get<pool_type<Weak> *>(pools)->get(entt)...);
                }
            } else {
                const auto entt = *(data++);
                func(entt, *(std::get<component_iterator<Strong>>(it)++)..., std::get<pool_type<Weak> *>(pools)->get(entt)...);
            }
        }
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Input iterator type. */
    using iterator = typename sparse_set<Entity>::iterator;

    /**
     * @brief Returns the number of existing components of the given type.
     * @tparam Component Type of component of which to return the size.
     * @return Number of existing components of the given type.
     */
    template<typename Component>
    size_type size() const ENTT_NOEXCEPT {
        return std::get<pool_type<Component> *>(pools)->size();
    }

    /**
     * @brief Returns the number of entities that have the given components.
     * @return Number of entities that have the given components.
     */
    size_type size() const ENTT_NOEXCEPT {
        return *length;
    }

    /**
     * @brief Checks whether a group or some pools are empty.
     * @tparam Component Types of components in which one is interested.
     * @return True if the group or the pools are empty, false otherwise.
     */
    template<typename... Component>
    bool empty() const ENTT_NOEXCEPT {
        if constexpr(sizeof...(Component) == 0) {
            return !*length;
        } else {
            return (std::get<pool_type<Component> *>(pools)->empty() && ...);
        }
    }

    /**
     * @brief Direct access to the list of components of a given pool.
     *
     * The returned pointer is such that range
     * `[raw<Component>(), raw<Component>() + size<Component>()]` is always a
     * valid range, even if the container is empty.<br/>
     * Moreover, in case the group owns the given component, the range
     * `[raw<Component>(), raw<Component>() + size()]` is such that it contains
     * the instances that are part of the group itself.
     *
     * @note
     * There are no guarantees on the order of the components. Use `begin` and
     * `end` if you want to iterate the group in the expected order.
     *
     * @tparam Component Type of component in which one is interested.
     * @return A pointer to the array of components.
     */
    template<typename Component>
    Component * raw() const ENTT_NOEXCEPT {
        return std::get<pool_type<Component> *>(pools)->raw();
    }

    /**
     * @brief Direct access to the list of entities of a given pool.
     *
     * The returned pointer is such that range
     * `[data<Component>(), data<Component>() + size<Component>()]` is always a
     * valid range, even if the container is empty.<br/>
     * Moreover, in case the group owns the given component, the range
     * `[data<Component>(), data<Component>() + size()]` is such that it
     * contains the entities that are part of the group itself.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the group in the expected order.
     *
     * @tparam Component Type of component in which one is interested.
     * @return A pointer to the array of entities.
     */
    template<typename Component>
    const entity_type * data() const ENTT_NOEXCEPT {
        return std::get<pool_type<Component> *>(pools)->data();
    }

    /**
     * @brief Direct access to the list of entities.
     *
     * The returned pointer is such that range `[data(), data() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the group in the expected order.
     *
     * @return A pointer to the array of entities.
     */
    const entity_type * data() const ENTT_NOEXCEPT {
        return std::get<0>(pools)->data();
    }

    /**
     * @brief Returns an iterator to the first entity that has the given
     * components.
     *
     * The returned iterator points to the first entity that has the given
     * components. If the group is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the first entity that has the given components.
     */
    iterator begin() const ENTT_NOEXCEPT {
        return std::get<0>(pools)->sparse_set<entity_type>::end() - *length;
    }

    /**
     * @brief Returns an iterator that is past the last entity that has the
     * given components.
     *
     * The returned iterator points to the entity following the last entity that
     * has the given components. Attempting to dereference the returned iterator
     * results in undefined behavior.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the entity following the last entity that has the
     * given components.
     */
    iterator end() const ENTT_NOEXCEPT {
        return std::get<0>(pools)->sparse_set<entity_type>::end();
    }

    /**
     * @brief Returns the first entity that has the given components, if any.
     * @return The first entity that has the given components if one exists, the
     * null entity otherwise.
     */
    entity_type front() const {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity that has the given components, if any.
     * @return The last entity that has the given components if one exists, the
     * null entity otherwise.
     */
    entity_type back() const {
        const auto it = std::make_reverse_iterator(end());
        return it != std::make_reverse_iterator(begin()) ? *it : null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid entity identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    iterator find(const entity_type entt) const {
        const auto it = std::get<0>(pools)->find(entt);
        return it != end() && it >= begin() && *it == entt ? it : end();
    }

    /**
     * @brief Returns the identifier that occupies the given position.
     * @param pos Position of the element to return.
     * @return The identifier that occupies the given position.
     */
    entity_type operator[](const size_type pos) const {
        return begin()[pos];
    }

    /**
     * @brief Checks if a group contains an entity.
     * @param entt A valid entity identifier.
     * @return True if the group contains the given entity, false otherwise.
     */
    bool contains(const entity_type entt) const {
        return std::get<0>(pools)->contains(entt) && (std::get<0>(pools)->index(entt) < (*length));
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * Prefer this function instead of `registry::get` during iterations. It has
     * far better performance than its counterpart.
     *
     * @warning
     * Attempting to use an invalid component type results in a compilation
     * error. Attempting to use an entity that doesn't belong to the group
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * group doesn't contain the given entity.
     *
     * @tparam Component Types of components to get.
     * @param entt A valid entity identifier.
     * @return The components assigned to the entity.
     */
    template<typename... Component>
    decltype(auto) get([[maybe_unused]] const entity_type entt) const {
        ENTT_ASSERT(contains(entt));

        if constexpr(sizeof...(Component) == 1) {
            return (std::get<pool_type<Component> *>(pools)->get(entt), ...);
        } else {
            return std::tuple<decltype(get<Component>({}))...>{get<Component>(entt)...};
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        using owned_type_list = type_list_cat_t<std::conditional_t<ENTT_IS_EMPTY(Owned), type_list<>, type_list<Owned>>...>;
        using get_type_list = type_list_cat_t<std::conditional_t<ENTT_IS_EMPTY(Get), type_list<>, type_list<Get>>...>;
        traverse(std::move(func), owned_type_list{}, get_type_list{});
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    [[deprecated("use ::each instead")]]
    void less(Func func) const {
        each(std::move(func));
    }

    /**
     * @brief Checks whether the group can be sorted.
     * @return True if the group can be sorted, false otherwise.
     */
    bool sortable() const ENTT_NOEXCEPT {
        constexpr auto size = sizeof...(Owned) + sizeof...(Get) + sizeof...(Exclude);
        return *super == size;
    }

    /**
     * @brief Sort a group according to the given comparison function.
     *
     * Sort the group so that iterating it with a couple of iterators returns
     * entities and components in the expected order. See `begin` and `end` for
     * more details.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(std::tuple<Component &...>, std::tuple<Component &...>);
     * bool(const Component &, const Component &);
     * bool(const Entity, const Entity);
     * @endcode
     *
     * Where `Component` are either owned types or not but still such that they
     * are iterated by the group.<br/>
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function oject must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @note
     * Attempting to iterate elements using a raw pointer returned by a call to
     * either `data` or `raw` gives no guarantees on the order, even though
     * `sort` has been invoked.
     *
     * @tparam Component Optional types of components to compare.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename... Component, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&... args) {
        ENTT_ASSERT(sortable());
        auto *cpool = std::get<0>(pools);

        if constexpr(sizeof...(Component) == 0) {
            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>);
            cpool->sort(cpool->end()-*length, cpool->end(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
        } else if constexpr(sizeof...(Component) == 1) {
            cpool->sort(cpool->end()-*length, cpool->end(), [this, compare = std::move(compare)](const entity_type lhs, const entity_type rhs) {
                return compare((std::get<pool_type<Component> *>(pools)->get(lhs), ...), (std::get<pool_type<Component> *>(pools)->get(rhs), ...));
            }, std::move(algo), std::forward<Args>(args)...);
        } else {
            cpool->sort(cpool->end()-*length, cpool->end(), [this, compare = std::move(compare)](const entity_type lhs, const entity_type rhs) {
                return compare(std::tuple<decltype(get<Component>({}))...>{std::get<pool_type<Component> *>(pools)->get(lhs)...}, std::tuple<decltype(get<Component>({}))...>{std::get<pool_type<Component> *>(pools)->get(rhs)...});
            }, std::move(algo), std::forward<Args>(args)...);
        }

        [this](auto *head, auto *... other) {
            for(auto next = *length; next; --next) {
                const auto pos = next - 1;
                [[maybe_unused]] const auto entt = head->data()[pos];
                (other->swap(other->data()[pos], entt), ...);
            }
        }(std::get<pool_type<Owned> *>(pools)...);
    }

private:
    const std::tuple<pool_type<Owned> *..., pool_type<Get> *...> pools;
    const size_type *length;
    const size_type *super;
};


}


#endif

// #include "runtime_view.hpp"
#ifndef ENTT_ENTITY_RUNTIME_VIEW_HPP
#define ENTT_ENTITY_RUNTIME_VIEW_HPP


#include <iterator>
#include <vector>
#include <utility>
#include <algorithm>
#include <type_traits>
// #include "../config/config.h"

// #include "sparse_set.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Runtime view.
 *
 * Runtime views iterate over those entities that have at least all the given
 * components in their bags. During initialization, a runtime view looks at the
 * number of entities available for each component and picks up a reference to
 * the smallest set of candidate entities in order to get a performance boost
 * when iterate.<br/>
 * Order of elements during iterations are highly dependent on the order of the
 * underlying data structures. See sparse_set and its specializations for more
 * details.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New instances of the given components are created and assigned to entities.
 * * The entity currently pointed is modified (as an example, if one of the
 *   given components is removed from the entity to which the iterator points).
 * * The entity currently pointed is destroyed.
 *
 * In all the other cases, modifying the pools of the given components in any
 * way invalidates all the iterators and using them results in undefined
 * behavior.
 *
 * @note
 * Views share references to the underlying data structures of the registry that
 * generated them. Therefore any change to the entities and to the components
 * made by means of the registry are immediately reflected by the views, unless
 * a pool was missing when the view was built (in this case, the view won't
 * have a valid reference and won't be updated accordingly).
 *
 * @warning
 * Lifetime of a view must not overcome that of the registry that generated it.
 * In any other case, attempting to use a view results in undefined behavior.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class basic_runtime_view {
    /*! @brief A registry is allowed to create views. */
    friend class basic_registry<Entity>;

    using underlying_iterator = typename sparse_set<Entity>::iterator;

    class view_iterator final {
        friend class basic_runtime_view<Entity>;

        using direct_type = std::vector<const sparse_set<Entity> *>;

        view_iterator(const direct_type &all, underlying_iterator curr) ENTT_NOEXCEPT
            : pools{&all},
              it{curr}
        {
            if(it != (*pools)[0]->end() && !valid()) {
                ++(*this);
            }
        }

        bool valid() const {
            return std::all_of(pools->begin()++, pools->end(), [entt = *it](const auto *curr) {
                return curr->contains(entt);
            });
        }

    public:
        using difference_type = typename underlying_iterator::difference_type;
        using value_type = typename underlying_iterator::value_type;
        using pointer = typename underlying_iterator::pointer;
        using reference = typename underlying_iterator::reference;
        using iterator_category = std::bidirectional_iterator_tag;

        view_iterator() ENTT_NOEXCEPT = default;

        view_iterator & operator++() {
            while(++it != (*pools)[0]->end() && !valid());
            return *this;
        }

        view_iterator operator++(int) {
            view_iterator orig = *this;
            return operator++(), orig;
        }

        view_iterator & operator--() ENTT_NOEXCEPT {
            while(--it != (*pools)[0]->begin() && !valid());
            return *this;
        }

        view_iterator operator--(int) ENTT_NOEXCEPT {
            view_iterator orig = *this;
            return operator--(), orig;
        }

        bool operator==(const view_iterator &other) const ENTT_NOEXCEPT {
            return other.it == it;
        }

        bool operator!=(const view_iterator &other) const ENTT_NOEXCEPT {
            return !(*this == other);
        }

        pointer operator->() const {
            return it.operator->();
        }

        reference operator*() const {
            return *operator->();
        }

    private:
        const direct_type *pools;
        underlying_iterator it;
    };

    basic_runtime_view(std::vector<const sparse_set<Entity> *> others) ENTT_NOEXCEPT
        : pools{std::move(others)}
    {
        const auto it = std::min_element(pools.begin(), pools.end(), [](const auto *lhs, const auto *rhs) {
            return (!lhs && rhs) || (lhs && rhs && lhs->size() < rhs->size());
        });

        // brings the best candidate (if any) on front of the vector
        std::rotate(pools.begin(), it, pools.end());
    }

    bool valid() const {
        return !pools.empty() && pools.front();
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Input iterator type. */
    using iterator = view_iterator;

    /**
     * @brief Estimates the number of entities that have the given components.
     * @return Estimated number of entities that have the given components.
     */
    size_type size() const {
        return valid() ? pools.front()->size() : size_type{};
    }

    /**
     * @brief Checks if the view is definitely empty.
     * @return True if the view is definitely empty, false otherwise.
     */
    bool empty() const {
        return !valid() || pools.front()->empty();
    }

    /**
     * @brief Returns an iterator to the first entity that has the given
     * components.
     *
     * The returned iterator points to the first entity that has the given
     * components. If the view is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the first entity that has the given components.
     */
    iterator begin() const {
        iterator it{};

        if(valid()) {
            it = { pools, pools[0]->begin() };
        }

        return it;
    }

    /**
     * @brief Returns an iterator that is past the last entity that has the
     * given components.
     *
     * The returned iterator points to the entity following the last entity that
     * has the given components. Attempting to dereference the returned iterator
     * results in undefined behavior.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the entity following the last entity that has the
     * given components.
     */
    iterator end() const {
        iterator it{};

        if(valid()) {
            it = { pools, pools[0]->end() };
        }

        return it;
    }

    /**
     * @brief Checks if a view contains an entity.
     * @param entt A valid entity identifier.
     * @return True if the view contains the given entity, false otherwise.
     */
    bool contains(const entity_type entt) const {
        return valid() && std::all_of(pools.cbegin(), pools.cend(), [entt](const auto *view) {
            return view->find(entt) != view->end();
        });
    }

    /**
     * @brief Iterates entities and applies the given function object to them.
     *
     * The function object is invoked for each entity. It is provided only with
     * the entity itself. To get the components, users can use the registry with
     * which the view was built.<br/>
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const entity_type);
     * @endcode
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        for(const auto entity: *this) {
            func(entity);
        }
    }

private:
    std::vector<const sparse_set<Entity> *> pools;
};


}


#endif

// #include "snapshot.hpp"
#ifndef ENTT_ENTITY_SNAPSHOT_HPP
#define ENTT_ENTITY_SNAPSHOT_HPP


#include <array>
#include <vector>
#include <cstddef>
#include <utility>
#include <iterator>
#include <type_traits>
#include <unordered_map>
// #include "../config/config.h"

// #include "entity.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Utility class to create snapshots from a registry.
 *
 * A _snapshot_ can be either a dump of the entire registry or a narrower
 * selection of components of interest.<br/>
 * This type can be used in both cases if provided with a correctly configured
 * output archive.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class basic_snapshot {
    /*! @brief A registry is allowed to create snapshots. */
    friend class basic_registry<Entity>;

    using traits_type = entt_traits<std::underlying_type_t<Entity>>;

    template<typename Component, typename Archive, typename It>
    void get(Archive &archive, std::size_t sz, It first, It last) const {
        archive(typename traits_type::entity_type(sz));

        while(first != last) {
            const auto entt = *(first++);

            if(reg->template has<Component>(entt)) {
                if constexpr(std::is_empty_v<Component>) {
                    archive(entt);
                } else {
                    archive(entt, reg->template get<Component>(entt));
                }
            }
        }
    }

    template<typename... Component, typename Archive, typename It, std::size_t... Indexes>
    void component(Archive &archive, It first, It last, std::index_sequence<Indexes...>) const {
        std::array<std::size_t, sizeof...(Indexes)> size{};
        auto begin = first;

        while(begin != last) {
            const auto entt = *(begin++);
            ((reg->template has<Component>(entt) ? ++size[Indexes] : size[Indexes]), ...);
        }

        (get<Component>(archive, size[Indexes], first, last), ...);
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;

    /**
     * @brief Constructs an instance that is bound to a given registry.
     * @param source A valid reference to a registry.
     */
    basic_snapshot(const basic_registry<entity_type> &source) ENTT_NOEXCEPT
        : reg{&source}
    {}

    /*! @brief Default move constructor. */
    basic_snapshot(basic_snapshot &&) = default;

    /*! @brief Default move assignment operator. @return This snapshot. */
    basic_snapshot & operator=(basic_snapshot &&) = default;

    /**
     * @brief Puts aside all the entities from the underlying registry.
     *
     * Entities are serialized along with their versions. Destroyed entities are
     * taken in consideration as well by this function.
     *
     * @tparam Archive Type of output archive.
     * @param archive A valid reference to an output archive.
     * @return An object of this type to continue creating the snapshot.
     */
    template<typename Archive>
    const basic_snapshot & entities(Archive &archive) const {
        const auto sz = reg->size();
        auto first = reg->data();
        const auto last = first + sz;

        archive(typename traits_type::entity_type(sz));

        while(first != last) {
            archive(*(first++));
        }

        return *this;
    }

    /**
     * @brief Deprecated function. Currently, it does nothing.
     * @tparam Archive Type of output archive.
     * @return An object of this type to continue creating the snapshot.
     */
    template<typename Archive>
    [[deprecated("use ::entities instead, it exports now also destroyed entities")]]
    const basic_snapshot & destroyed(Archive &) const { return *this; }

    /**
     * @brief Puts aside the given components.
     *
     * Each instance is serialized together with the entity to which it belongs.
     * Entities are serialized along with their versions.
     *
     * @tparam Component Types of components to serialize.
     * @tparam Archive Type of output archive.
     * @param archive A valid reference to an output archive.
     * @return An object of this type to continue creating the snapshot.
     */
    template<typename... Component, typename Archive>
    const basic_snapshot & component(Archive &archive) const {
        (component<Component>(archive, reg->template data<Component>(), reg->template data<Component>() + reg->template size<Component>()), ...);
        return *this;
    }

    /**
     * @brief Puts aside the given components for the entities in a range.
     *
     * Each instance is serialized together with the entity to which it belongs.
     * Entities are serialized along with their versions.
     *
     * @tparam Component Types of components to serialize.
     * @tparam Archive Type of output archive.
     * @tparam It Type of input iterator.
     * @param archive A valid reference to an output archive.
     * @param first An iterator to the first element of the range to serialize.
     * @param last An iterator past the last element of the range to serialize.
     * @return An object of this type to continue creating the snapshot.
     */
    template<typename... Component, typename Archive, typename It>
    const basic_snapshot & component(Archive &archive, It first, It last) const {
        component<Component...>(archive, first, last, std::index_sequence_for<Component...>{});
        return *this;
    }

private:
    const basic_registry<entity_type> *reg;
};


/**
 * @brief Utility class to restore a snapshot as a whole.
 *
 * A snapshot loader requires that the destination registry be empty and loads
 * all the data at once while keeping intact the identifiers that the entities
 * originally had.<br/>
 * An example of use is the implementation of a save/restore utility.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class basic_snapshot_loader {
    /*! @brief A registry is allowed to create snapshot loaders. */
    friend class basic_registry<Entity>;

    using traits_type = entt_traits<std::underlying_type_t<Entity>>;

    template<typename Type, typename Archive, typename... Args>
    void assign(Archive &archive, Args... args) const {
        typename traits_type::entity_type length{};
        archive(length);

        while(length--) {
            entity_type entt{};

            if constexpr(std::is_empty_v<Type>) {
                archive(entt);
                const auto entity = reg->valid(entt) ? entt : reg->create(entt);
                ENTT_ASSERT(entity == entt);
                reg->template emplace<Type>(args..., entt);
            } else {
                Type instance{};
                archive(entt, instance);
                const auto entity = reg->valid(entt) ? entt : reg->create(entt);
                ENTT_ASSERT(entity == entt);
                reg->template emplace<Type>(args..., entt, std::as_const(instance));
            }
        }
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;

    /**
     * @brief Constructs an instance that is bound to a given registry.
     * @param source A valid reference to a registry.
     */
    basic_snapshot_loader(basic_registry<entity_type> &source) ENTT_NOEXCEPT
        : reg{&source}
    {
        // restoring a snapshot as a whole requires a clean registry
        ENTT_ASSERT(reg->empty());
    }

    /*! @brief Default move constructor. */
    basic_snapshot_loader(basic_snapshot_loader &&) = default;

    /*! @brief Default move assignment operator. @return This loader. */
    basic_snapshot_loader & operator=(basic_snapshot_loader &&) = default;

    /**
     * @brief Restores entities that were in use during serialization.
     *
     * This function restores the entities that were in use during serialization
     * and gives them the versions they originally had.
     *
     * @tparam Archive Type of input archive.
     * @param archive A valid reference to an input archive.
     * @return A valid loader to continue restoring data.
     */
    template<typename Archive>
    const basic_snapshot_loader & entities(Archive &archive) const {
        typename traits_type::entity_type length{};

        archive(length);
        std::vector<entity_type> all(length);

        for(decltype(length) pos{}; pos < length; ++pos) {
            archive(all[pos]);
        }

        reg->assign(all.cbegin(), all.cend());

        return *this;
    }

    /**
     * @brief Deprecated function. Currently, it does nothing.
     * @tparam Archive Type of input archive.
     * @return A valid loader to continue restoring data.
     */
    template<typename Archive>
    [[deprecated("use ::entities instead, it imports now also destroyed entities")]]
    const basic_snapshot_loader & destroyed(Archive &) const { return *this; }

    /**
     * @brief Restores components and assigns them to the right entities.
     *
     * The template parameter list must be exactly the same used during
     * serialization. In the event that the entity to which the component is
     * assigned doesn't exist yet, the loader will take care to create it with
     * the version it originally had.
     *
     * @tparam Component Types of components to restore.
     * @tparam Archive Type of input archive.
     * @param archive A valid reference to an input archive.
     * @return A valid loader to continue restoring data.
     */
    template<typename... Component, typename Archive>
    const basic_snapshot_loader & component(Archive &archive) const {
        (assign<Component>(archive), ...);
        return *this;
    }

    /**
     * @brief Destroys those entities that have no components.
     *
     * In case all the entities were serialized but only part of the components
     * was saved, it could happen that some of the entities have no components
     * once restored.<br/>
     * This functions helps to identify and destroy those entities.
     *
     * @return A valid loader to continue restoring data.
     */
    const basic_snapshot_loader & orphans() const {
        reg->orphans([this](const auto entt) {
            reg->destroy(entt);
        });

        return *this;
    }

private:
    basic_registry<entity_type> *reg;
};


/**
 * @brief Utility class for _continuous loading_.
 *
 * A _continuous loader_ is designed to load data from a source registry to a
 * (possibly) non-empty destination. The loader can accommodate in a registry
 * more than one snapshot in a sort of _continuous loading_ that updates the
 * destination one step at a time.<br/>
 * Identifiers that entities originally had are not transferred to the target.
 * Instead, the loader maps remote identifiers to local ones while restoring a
 * snapshot.<br/>
 * An example of use is the implementation of a client-server applications with
 * the requirement of transferring somehow parts of the representation side to
 * side.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class basic_continuous_loader {
    using traits_type = entt_traits<std::underlying_type_t<Entity>>;

    void destroy(Entity entt) {
        const auto it = remloc.find(entt);

        if(it == remloc.cend()) {
            const auto local = reg->create();
            remloc.emplace(entt, std::make_pair(local, true));
            reg->destroy(local);
        }
    }

    void restore(Entity entt) {
        const auto it = remloc.find(entt);

        if(it == remloc.cend()) {
            const auto local = reg->create();
            remloc.emplace(entt, std::make_pair(local, true));
        } else {
            remloc[entt].first = reg->valid(remloc[entt].first) ? remloc[entt].first : reg->create();
            // set the dirty flag
            remloc[entt].second = true;
        }
    }

    template<typename Container>
    auto update(int, Container &container)
    -> decltype(typename Container::mapped_type{}, void()) {
        // map like container
        Container other;

        for(auto &&pair: container) {
            using first_type = std::remove_const_t<typename std::decay_t<decltype(pair)>::first_type>;
            using second_type = typename std::decay_t<decltype(pair)>::second_type;

            if constexpr(std::is_same_v<first_type, entity_type> && std::is_same_v<second_type, entity_type>) {
                other.emplace(map(pair.first), map(pair.second));
            } else if constexpr(std::is_same_v<first_type, entity_type>) {
                other.emplace(map(pair.first), std::move(pair.second));
            } else {
                static_assert(std::is_same_v<second_type, entity_type>);
                other.emplace(std::move(pair.first), map(pair.second));
            }
        }

        std::swap(container, other);
    }

    template<typename Container>
    auto update(char, Container &container)
    -> decltype(typename Container::value_type{}, void()) {
        // vector like container
        static_assert(std::is_same_v<typename Container::value_type, entity_type>);

        for(auto &&entt: container) {
            entt = map(entt);
        }
    }

    template<typename Other, typename Type, typename Member>
    void update([[maybe_unused]] Other &instance, [[maybe_unused]] Member Type:: *member) {
        if constexpr(!std::is_same_v<Other, Type>) {
            return;
        } else if constexpr(std::is_same_v<Member, entity_type>) {
            instance.*member = map(instance.*member);
        } else {
            // maybe a container? let's try...
            update(0, instance.*member);
        }
    }

    template<typename Component>
    void remove_if_exists() {
        for(auto &&ref: remloc) {
            const auto local = ref.second.first;

            if(reg->valid(local)) {
                reg->template remove_if_exists<Component>(local);
            }
        }
    }

    template<typename Other, typename Archive, typename... Type, typename... Member>
    void assign(Archive &archive, [[maybe_unused]] Member Type:: *... member) {
        typename traits_type::entity_type length{};
        archive(length);

        while(length--) {
            entity_type entt{};

            if constexpr(std::is_empty_v<Other>) {
                archive(entt);
                restore(entt);
                reg->template emplace_or_replace<Other>(map(entt));
            } else {
                Other instance{};
                archive(entt, instance);
                (update(instance, member), ...);
                restore(entt);
                reg->template emplace_or_replace<Other>(map(entt), std::as_const(instance));
            }
        }
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;

    /**
     * @brief Constructs an instance that is bound to a given registry.
     * @param source A valid reference to a registry.
     */
    basic_continuous_loader(basic_registry<entity_type> &source) ENTT_NOEXCEPT
        : reg{&source}
    {}

    /*! @brief Default move constructor. */
    basic_continuous_loader(basic_continuous_loader &&) = default;

    /*! @brief Default move assignment operator. @return This loader. */
    basic_continuous_loader & operator=(basic_continuous_loader &&) = default;

    /**
     * @brief Restores entities that were in use during serialization.
     *
     * This function restores the entities that were in use during serialization
     * and creates local counterparts for them if required.
     *
     * @tparam Archive Type of input archive.
     * @param archive A valid reference to an input archive.
     * @return A non-const reference to this loader.
     */
    template<typename Archive>
    basic_continuous_loader & entities(Archive &archive) {
        typename traits_type::entity_type length{};
        entity_type entt{};

        archive(length);

        for(decltype(length) pos{}; pos < length; ++pos) {
            archive(entt);

            if(const auto entity = (to_integral(entt) & traits_type::entity_mask); entity == pos) {
                restore(entt);
            } else {
                destroy(entt);
            }
        }

        return *this;
    }

    /**
     * @brief Deprecated function. Currently, it does nothing.
     * @tparam Archive Type of input archive.
     * @return A non-const reference to this loader.
     */
    template<typename Archive>
    [[deprecated("use ::entities instead, it imports now also destroyed entities")]]
    basic_continuous_loader & destroyed(Archive &) { return *this; }

    /**
     * @brief Restores components and assigns them to the right entities.
     *
     * The template parameter list must be exactly the same used during
     * serialization. In the event that the entity to which the component is
     * assigned doesn't exist yet, the loader will take care to create a local
     * counterpart for it.<br/>
     * Members can be either data members of type entity_type or containers of
     * entities. In both cases, the loader will visit them and update the
     * entities by replacing each one with its local counterpart.
     *
     * @tparam Component Type of component to restore.
     * @tparam Archive Type of input archive.
     * @tparam Type Types of components to update with local counterparts.
     * @tparam Member Types of members to update with their local counterparts.
     * @param archive A valid reference to an input archive.
     * @param member Members to update with their local counterparts.
     * @return A non-const reference to this loader.
     */
    template<typename... Component, typename Archive, typename... Type, typename... Member>
    basic_continuous_loader & component(Archive &archive, Member Type:: *... member) {
        (remove_if_exists<Component>(), ...);
        (assign<Component>(archive, member...), ...);
        return *this;
    }

    /**
     * @brief Helps to purge entities that no longer have a conterpart.
     *
     * Users should invoke this member function after restoring each snapshot,
     * unless they know exactly what they are doing.
     *
     * @return A non-const reference to this loader.
     */
    basic_continuous_loader & shrink() {
        auto it = remloc.begin();

        while(it != remloc.cend()) {
            const auto local = it->second.first;
            bool &dirty = it->second.second;

            if(dirty) {
                dirty = false;
                ++it;
            } else {
                if(reg->valid(local)) {
                    reg->destroy(local);
                }

                it = remloc.erase(it);
            }
        }

        return *this;
    }

    /**
     * @brief Destroys those entities that have no components.
     *
     * In case all the entities were serialized but only part of the components
     * was saved, it could happen that some of the entities have no components
     * once restored.<br/>
     * This functions helps to identify and destroy those entities.
     *
     * @return A non-const reference to this loader.
     */
    basic_continuous_loader & orphans() {
        reg->orphans([this](const auto entt) {
            reg->destroy(entt);
        });

        return *this;
    }

    /**
     * @brief Tests if a loader knows about a given entity.
     * @param entt An entity identifier.
     * @return True if `entity` is managed by the loader, false otherwise.
     */
    bool contains(entity_type entt) const ENTT_NOEXCEPT {
        return (remloc.find(entt) != remloc.cend());
    }

    /*! @copydoc contains */
    [[deprecated("use ::contains instead")]]
    bool has(entity_type entt) const ENTT_NOEXCEPT {
        return contains(entt);
    }

    /**
     * @brief Returns the identifier to which an entity refers.
     * @param entt An entity identifier.
     * @return The local identifier if any, the null entity otherwise.
     */
    entity_type map(entity_type entt) const ENTT_NOEXCEPT {
        const auto it = remloc.find(entt);
        entity_type other = null;

        if(it != remloc.cend()) {
            other = it->second.first;
        }

        return other;
    }

private:
    std::unordered_map<entity_type, std::pair<entity_type, bool>> remloc;
    basic_registry<entity_type> *reg;
};


}


#endif

// #include "sparse_set.hpp"

// #include "storage.hpp"

// #include "utility.hpp"

// #include "view.hpp"
#ifndef ENTT_ENTITY_VIEW_HPP
#define ENTT_ENTITY_VIEW_HPP


#include <iterator>
#include <array>
#include <tuple>
#include <utility>
#include <algorithm>
#include <type_traits>
// #include "../config/config.h"

// #include "../core/type_traits.hpp"

// #include "sparse_set.hpp"

// #include "storage.hpp"

// #include "utility.hpp"

// #include "entity.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief View.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error, but for a few reasonable cases.
 */
template<typename...>
class basic_view;


/**
 * @brief Multi component view.
 *
 * Multi component views iterate over those entities that have at least all the
 * given components in their bags. During initialization, a multi component view
 * looks at the number of entities available for each component and uses the
 * smallest set in order to get a performance boost when iterate.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New instances of the given components are created and assigned to entities.
 * * The entity currently pointed is modified (as an example, if one of the
 *   given components is removed from the entity to which the iterator points).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the pools iterated by the view in any way
 * invalidates all the iterators and using them results in undefined behavior.
 *
 * @note
 * Views share references to the underlying data structures of the registry that
 * generated them. Therefore any change to the entities and to the components
 * made by means of the registry are immediately reflected by views.
 *
 * @warning
 * Lifetime of a view must not overcome that of the registry that generated it.
 * In any other case, attempting to use a view results in undefined behavior.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 * @tparam Exclude Types of components used to filter the view.
 * @tparam Component Types of components iterated by the view.
 */
template<typename Entity, typename... Exclude, typename... Component>
class basic_view<Entity, exclude_t<Exclude...>, Component...> {
    /*! @brief A registry is allowed to create views. */
    friend class basic_registry<Entity>;

    template<typename Comp>
    using pool_type = std::conditional_t<std::is_const_v<Comp>, const storage<Entity, std::remove_const_t<Comp>>, storage<Entity, Comp>>;

    template<typename Comp>
    using component_iterator = decltype(std::declval<pool_type<Comp>>().begin());

    using underlying_iterator = typename sparse_set<Entity>::iterator;
    using unchecked_type = std::array<const sparse_set<Entity> *, (sizeof...(Component) - 1)>;
    using filter_type = std::array<const sparse_set<Entity> *, sizeof...(Exclude)>;

    class view_iterator final {
        friend class basic_view<Entity, exclude_t<Exclude...>, Component...>;

        view_iterator(const sparse_set<Entity> &candidate, unchecked_type other, filter_type ignore, underlying_iterator curr) ENTT_NOEXCEPT
            : view{&candidate},
              unchecked{other},
              filter{ignore},
              it{curr}
        {
            if(it != view->end() && !valid()) {
                ++(*this);
            }
        }

        bool valid() const {
            return std::all_of(unchecked.cbegin(), unchecked.cend(), [entt = *it](const sparse_set<Entity> *curr) { return curr->contains(entt); })
                    && std::none_of(filter.cbegin(), filter.cend(), [entt = *it](const sparse_set<Entity> *curr) { return curr->contains(entt); });
        }

    public:
        using difference_type = typename underlying_iterator::difference_type;
        using value_type = typename underlying_iterator::value_type;
        using pointer = typename underlying_iterator::pointer;
        using reference = typename underlying_iterator::reference;
        using iterator_category = std::bidirectional_iterator_tag;

        view_iterator() ENTT_NOEXCEPT = default;

        view_iterator & operator++() {
            while(++it != view->end() && !valid());
            return *this;
        }

        view_iterator operator++(int) {
            view_iterator orig = *this;
            return operator++(), orig;
        }

        view_iterator & operator--() ENTT_NOEXCEPT {
            while(--it != view->begin() && !valid());
            return *this;
        }

        view_iterator operator--(int) ENTT_NOEXCEPT {
            view_iterator orig = *this;
            return operator--(), orig;
        }

        bool operator==(const view_iterator &other) const ENTT_NOEXCEPT {
            return other.it == it;
        }

        bool operator!=(const view_iterator &other) const ENTT_NOEXCEPT {
            return !(*this == other);
        }

        pointer operator->() const {
            return it.operator->();
        }

        reference operator*() const {
            return *operator->();
        }

    private:
        const sparse_set<Entity> *view;
        unchecked_type unchecked;
        filter_type filter;
        underlying_iterator it;
    };

    // we could use pool_type<Component> &..., but vs complains about it and refuses to compile for unknown reasons (likely a bug)
    basic_view(storage<Entity, std::remove_const_t<Component>> &... component, storage<Entity, std::remove_const_t<Exclude>> &... epool) ENTT_NOEXCEPT
        : pools{&component..., &epool...}
    {}

    const sparse_set<Entity> & candidate() const ENTT_NOEXCEPT {
        return *std::min({ static_cast<const sparse_set<Entity> *>(std::get<pool_type<Component> *>(pools))... }, [](const auto *lhs, const auto *rhs) {
            return lhs->size() < rhs->size();
        });
    }

    unchecked_type unchecked(const sparse_set<Entity> &view) const {
        std::size_t pos{};
        unchecked_type other{};
        ((std::get<pool_type<Component> *>(pools) == &view ? nullptr : (other[pos++] = std::get<pool_type<Component> *>(pools))), ...);
        return other;
    }

    template<typename Comp, typename Other>
    decltype(auto) get([[maybe_unused]] component_iterator<Comp> it, [[maybe_unused]] pool_type<Other> *cpool, [[maybe_unused]] const Entity entt) const {
        if constexpr(std::is_same_v<Comp, Other>) {
            return *it;
        } else {
            return cpool->get(entt);
        }
    }

    template<typename Comp, typename Func, typename... Type>
    void traverse(Func func, type_list<Type...>) const {
        if constexpr(std::disjunction_v<std::is_same<Comp, Type>...>) {
            auto it = std::get<pool_type<Comp> *>(pools)->begin();

            for(const auto entt: static_cast<const sparse_set<entity_type> &>(*std::get<pool_type<Comp> *>(pools))) {
                auto curr = it++;

                if(((std::is_same_v<Comp, Component> || std::get<pool_type<Component> *>(pools)->contains(entt)) && ...) && (!std::get<pool_type<Exclude> *>(pools)->contains(entt) && ...)) {
                    if constexpr(std::is_invocable_v<Func, decltype(get<Type>({}))...>) {
                        func(get<Comp, Type>(curr, std::get<pool_type<Type> *>(pools), entt)...);
                    } else {
                        func(entt, get<Comp, Type>(curr, std::get<pool_type<Type> *>(pools), entt)...);
                    }
                }
            }
        } else {
            for(const auto entt: static_cast<const sparse_set<entity_type> &>(*std::get<pool_type<Comp> *>(pools))) {
                if(((std::is_same_v<Comp, Component> || std::get<pool_type<Component> *>(pools)->contains(entt)) && ...) && (!std::get<pool_type<Exclude> *>(pools)->contains(entt) && ...)) {
                    if constexpr(std::is_invocable_v<Func, decltype(get<Type>({}))...>) {
                        func(std::get<pool_type<Type> *>(pools)->get(entt)...);
                    } else {
                        func(entt, std::get<pool_type<Type> *>(pools)->get(entt)...);
                    }
                }
            }
        }
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Input iterator type. */
    using iterator = view_iterator;

    /**
     * @brief Returns the number of existing components of the given type.
     *
     * This isn't the number of entities iterated by the view.
     *
     * @tparam Comp Type of component of which to return the size.
     * @return Number of existing components of the given type.
     */
    template<typename Comp>
    size_type size() const ENTT_NOEXCEPT {
        return std::get<pool_type<Comp> *>(pools)->size();
    }

    /**
     * @brief Estimates the number of entities iterated by the view.
     * @return Estimated number of entities iterated by the view.
     */
    size_type size() const ENTT_NOEXCEPT {
        return std::min({ std::get<pool_type<Component> *>(pools)->size()... });
    }

    /**
     * @brief Checks whether a view or some pools are empty.
     *
     * The view is definitely empty if one of the pools it uses is empty. In all
     * other cases, the view may be empty and not return entities even if this
     * function returns false.
     *
     * @tparam Comp Types of components in which one is interested.
     * @return True if the view or the pools are empty, false otherwise.
     */
    template<typename... Comp>
    bool empty() const ENTT_NOEXCEPT {
        if constexpr(sizeof...(Comp) == 0) {
            return (std::get<pool_type<Component> *>(pools)->empty() || ...);
        } else {
            return (std::get<pool_type<Comp> *>(pools)->empty() && ...);
        }
    }

    /**
     * @brief Direct access to the list of components of a given pool.
     *
     * The returned pointer is such that range
     * `[raw<Comp>(), raw<Comp>() + size<Comp>()]` is always a valid range, even
     * if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the components. Use `begin` and
     * `end` if you want to iterate the view in the expected order.
     *
     * @tparam Comp Type of component in which one is interested.
     * @return A pointer to the array of components.
     */
    template<typename Comp>
    Comp * raw() const ENTT_NOEXCEPT {
        return std::get<pool_type<Comp> *>(pools)->raw();
    }

    /**
     * @brief Direct access to the list of entities of a given pool.
     *
     * The returned pointer is such that range
     * `[data<Comp>(), data<Comp>() + size<Comp>()]` is always a valid range,
     * even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the view in the expected order.
     *
     * @tparam Comp Type of component in which one is interested.
     * @return A pointer to the array of entities.
     */
    template<typename Comp>
    const entity_type * data() const ENTT_NOEXCEPT {
        return std::get<pool_type<Comp> *>(pools)->data();
    }

    /**
     * @brief Returns an iterator to the first entity that has the given
     * components.
     *
     * The returned iterator points to the first entity that has the given
     * components. If the view is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the first entity that has the given components.
     */
    iterator begin() const {
        const auto &view = candidate();
        const filter_type ignore{std::get<pool_type<Exclude> *>(pools)...};
        return iterator{view, unchecked(view), ignore, view.begin()};
    }

    /**
     * @brief Returns an iterator that is past the last entity that has the
     * given components.
     *
     * The returned iterator points to the entity following the last entity that
     * has the given components. Attempting to dereference the returned iterator
     * results in undefined behavior.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the entity following the last entity that has the
     * given components.
     */
    iterator end() const {
        const auto &view = candidate();
        const filter_type ignore{std::get<pool_type<Exclude> *>(pools)...};
        return iterator{view, unchecked(view), ignore, view.end()};
    }

    /**
     * @brief Returns the first entity that has the given components, if any.
     * @return The first entity that has the given components if one exists, the
     * null entity otherwise.
     */
    entity_type front() const {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity that has the given components, if any.
     * @return The last entity that has the given components if one exists, the
     * null entity otherwise.
     */
    entity_type back() const {
        const auto it = std::make_reverse_iterator(end());
        return it != std::make_reverse_iterator(begin()) ? *it : null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid entity identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    iterator find(const entity_type entt) const {
        const auto &view = candidate();
        const filter_type ignore{std::get<pool_type<Exclude> *>(pools)...};
        iterator it{view, unchecked(view), ignore, view.find(entt)};
        return (it != end() && *it == entt) ? it : end();
    }

    /**
     * @brief Checks if a view contains an entity.
     * @param entt A valid entity identifier.
     * @return True if the view contains the given entity, false otherwise.
     */
    bool contains(const entity_type entt) const {
        return (std::get<pool_type<Component> *>(pools)->contains(entt) && ...)
                && (!std::get<pool_type<Exclude> *>(pools)->contains(entt) && ...);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * Prefer this function instead of `registry::get` during iterations. It has
     * far better performance than its counterpart.
     *
     * @warning
     * Attempting to use an invalid component type results in a compilation
     * error. Attempting to use an entity that doesn't belong to the view
     * results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * view doesn't contain the given entity.
     *
     * @tparam Comp Types of components to get.
     * @param entt A valid entity identifier.
     * @return The components assigned to the entity.
     */
    template<typename... Comp>
    decltype(auto) get([[maybe_unused]] const entity_type entt) const {
        ENTT_ASSERT(contains(entt));

        if constexpr(sizeof...(Comp) == 0) {
            static_assert(sizeof...(Component) == 1);
            return (std::get<pool_type<Component> *>(pools)->get(entt), ...);
        } else if constexpr(sizeof...(Comp) == 1) {
            return (std::get<pool_type<Comp> *>(pools)->get(entt), ...);
        } else {
            return std::tuple<decltype(get<Comp>({}))...>{get<Comp>(entt)...};
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        const auto &view = candidate();
        ((std::get<pool_type<Component> *>(pools) == &view ? each<Component>(std::move(func)) : void()), ...);
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The pool of the suggested component is used to lead the iterations. The
     * returned entities will therefore respect the order of the pool associated
     * with that type.<br/>
     * It is no longer guaranteed that the performance is the best possible, but
     * there will be greater control over the order of iteration.
     *
     * @sa each
     *
     * @tparam Comp Type of component to use to enforce the iteration order.
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Comp, typename Func>
    void each(Func func) const {
        using non_empty_type = type_list_cat_t<std::conditional_t<ENTT_IS_EMPTY(Component), type_list<>, type_list<Component>>...>;
        traverse<Comp>(std::move(func), non_empty_type{});
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    [[deprecated("use ::each instead")]]
    void less(Func func) const {
        each(std::move(func));
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The pool of the suggested component is used to lead the iterations. The
     * returned entities will therefore respect the order of the pool associated
     * with that type.<br/>
     * It is no longer guaranteed that the performance is the best possible, but
     * there will be greater control over the order of iteration.
     *
     * @sa less
     *
     * @tparam Comp Type of component to use to enforce the iteration order.
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Comp, typename Func>
    [[deprecated("use ::each instead")]]
    void less(Func func) const {
        each<Comp>(std::move(func));
    }

private:
    const std::tuple<pool_type<Component> *..., pool_type<Exclude> *...> pools;
};


/**
 * @brief Single component view specialization.
 *
 * Single component views are specialized in order to get a boost in terms of
 * performance. This kind of views can access the underlying data structure
 * directly and avoid superfluous checks.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New instances of the given component are created and assigned to entities.
 * * The entity currently pointed is modified (as an example, the given
 *   component is removed from the entity to which the iterator points).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the pool iterated by the view in any way
 * invalidates all the iterators and using them results in undefined behavior.
 *
 * @note
 * Views share a reference to the underlying data structure of the registry that
 * generated them. Therefore any change to the entities and to the components
 * made by means of the registry are immediately reflected by views.
 *
 * @warning
 * Lifetime of a view must not overcome that of the registry that generated it.
 * In any other case, attempting to use a view results in undefined behavior.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 * @tparam Component Type of component iterated by the view.
 */
template<typename Entity, typename Component>
class basic_view<Entity, exclude_t<>, Component> {
    /*! @brief A registry is allowed to create views. */
    friend class basic_registry<Entity>;

    using pool_type = std::conditional_t<std::is_const_v<Component>, const storage<Entity, std::remove_const_t<Component>>, storage<Entity, Component>>;

    basic_view(pool_type &ref) ENTT_NOEXCEPT
        : pool{&ref}
    {}

public:
    /*! @brief Type of component iterated by the view. */
    using raw_type = Component;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Input iterator type. */
    using iterator = typename sparse_set<Entity>::iterator;

    /**
     * @brief Returns the number of entities that have the given component.
     * @return Number of entities that have the given component.
     */
    size_type size() const ENTT_NOEXCEPT {
        return pool->size();
    }

    /**
     * @brief Checks whether a view is empty.
     * @return True if the view is empty, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return pool->empty();
    }

    /**
     * @brief Direct access to the list of components.
     *
     * The returned pointer is such that range `[raw(), raw() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the components. Use `begin` and
     * `end` if you want to iterate the view in the expected order.
     *
     * @return A pointer to the array of components.
     */
    raw_type * raw() const ENTT_NOEXCEPT {
        return pool->raw();
    }

    /**
     * @brief Direct access to the list of entities.
     *
     * The returned pointer is such that range `[data(), data() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the view in the expected order.
     *
     * @return A pointer to the array of entities.
     */
    const entity_type * data() const ENTT_NOEXCEPT {
        return pool->data();
    }

    /**
     * @brief Returns an iterator to the first entity that has the given
     * component.
     *
     * The returned iterator points to the first entity that has the given
     * component. If the view is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the first entity that has the given component.
     */
    iterator begin() const ENTT_NOEXCEPT {
        return pool->sparse_set<Entity>::begin();
    }

    /**
     * @brief Returns an iterator that is past the last entity that has the
     * given component.
     *
     * The returned iterator points to the entity following the last entity that
     * has the given component. Attempting to dereference the returned iterator
     * results in undefined behavior.
     *
     * @note
     * Input iterators stay true to the order imposed to the underlying data
     * structures.
     *
     * @return An iterator to the entity following the last entity that has the
     * given component.
     */
    iterator end() const ENTT_NOEXCEPT {
        return pool->sparse_set<Entity>::end();
    }

    /**
     * @brief Returns the first entity that has the given component, if any.
     * @return The first entity that has the given component if one exists, the
     * null entity otherwise.
     */
    entity_type front() const {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity that has the given component, if any.
     * @return The last entity that has the given component if one exists, the
     * null entity otherwise.
     */
    entity_type back() const {
        const auto it = std::make_reverse_iterator(end());
        return it != std::make_reverse_iterator(begin()) ? *it : null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid entity identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    iterator find(const entity_type entt) const {
        const auto it = pool->find(entt);
        return it != end() && *it == entt ? it : end();
    }

    /**
     * @brief Returns the identifier that occupies the given position.
     * @param pos Position of the element to return.
     * @return The identifier that occupies the given position.
     */
    entity_type operator[](const size_type pos) const {
        return begin()[pos];
    }

    /**
     * @brief Checks if a view contains an entity.
     * @param entt A valid entity identifier.
     * @return True if the view contains the given entity, false otherwise.
     */
    bool contains(const entity_type entt) const {
        return pool->contains(entt);
    }

    /**
     * @brief Returns the component assigned to the given entity.
     *
     * Prefer this function instead of `registry::get` during iterations. It has
     * far better performance than its counterpart.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the view results in
     * undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * view doesn't contain the given entity.
     *
     * @param entt A valid entity identifier.
     * @return The component assigned to the entity.
     */
    template<typename Comp = Component>
    decltype(auto) get(const entity_type entt) const {
        static_assert(std::is_same_v<Comp, Component>);
        ENTT_ASSERT(contains(entt));
        return pool->get(entt);
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a reference to the component if it's a non-empty one.
     * The _constness_ of the component is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Component &);
     * void(Component &);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        if constexpr(ENTT_IS_EMPTY(Component)) {
            if constexpr(std::is_invocable_v<Func>) {
                for(auto pos = pool->size(); pos; --pos) {
                    func();
                }
            } else {
                for(const auto entt: *this) {
                    func(entt);
                }
            }
        } else {
            if constexpr(std::is_invocable_v<Func, decltype(get({}))>) {
                for(auto &&component: *pool) {
                    func(component);
                }
            } else {
                auto raw = pool->begin();

                for(const auto entt: *this) {
                    func(entt, *(raw++));
                }
            }
        }
    }

    /*! @copydoc each */
    template<typename Func>
    [[deprecated("use ::each instead")]]
    void less(Func func) const {
        each(std::move(func));
    }

private:
    pool_type *pool;
};


}


#endif



namespace entt {


/**
 * @brief Fast and reliable entity-component system.
 *
 * The registry is the core class of the entity-component framework.<br/>
 * It stores entities and arranges pools of components on a per request basis.
 * By means of a registry, users can manage entities and components, then create
 * views or groups to iterate them.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class basic_registry {
    using traits_type = entt_traits<std::underlying_type_t<Entity>>;

    template<typename Component>
    struct pool_handler final: storage<Entity, Component> {
        static_assert(std::is_same_v<Component, std::decay_t<Component>>);
        std::size_t super{};

        auto on_construct() ENTT_NOEXCEPT {
            return sink{construction};
        }

        auto on_update() ENTT_NOEXCEPT {
            return sink{update};
        }

        auto on_destroy() ENTT_NOEXCEPT {
            return sink{destruction};
        }

        template<typename... Args>
        decltype(auto) emplace(basic_registry &owner, const Entity entt, Args &&... args) {
            storage<entity_type, Component>::emplace(entt, std::forward<Args>(args)...);
            construction.publish(owner, entt);

            if constexpr(!ENTT_IS_EMPTY(Component)) {
                return this->get(entt);
            }
        }

        template<typename It, typename... Args>
        void insert(basic_registry &owner, It first, It last, Args &&... args) {
            storage<entity_type, Component>::insert(first, last, std::forward<Args>(args)...);

            if(!construction.empty()) {
                while(first != last) { construction.publish(owner, *(first++)); }
            }
        }

        void remove(basic_registry &owner, const Entity entt) {
            destruction.publish(owner, entt);
            this->erase(entt);
        }

        template<typename It>
        void remove(basic_registry &owner, It first, It last) {
            if(std::distance(first, last) == std::distance(this->begin(), this->end())) {
                if(!destruction.empty()) {
                    while(first != last) { destruction.publish(owner, *(first++)); }
                }

                this->clear();
            } else {
                while(first != last) { this->remove(owner, *(first++)); }
            }
        }

        template<typename... Func>
        decltype(auto) patch(basic_registry &owner, const Entity entt, Func &&... func) {
            (std::forward<Func>(func)(this->get(entt)), ...);
            update.publish(owner, entt);

            if constexpr(!ENTT_IS_EMPTY(Component)) {
                return this->get(entt);
            }
        }

        decltype(auto) replace(basic_registry &owner, const Entity entt, [[maybe_unused]] Component component) {
            if constexpr(ENTT_IS_EMPTY(Component)) {
                return patch(owner, entt);
            } else {
                return patch(owner, entt, [&component](auto &&curr) { curr = std::move(component); });
            }
        }

    private:
        sigh<void(basic_registry &, const Entity)> construction{};
        sigh<void(basic_registry &, const Entity)> destruction{};
        sigh<void(basic_registry &, const Entity)> update{};
    };

    struct pool_data {
        id_type type_id{};
        std::unique_ptr<sparse_set<Entity>> pool{};
        void(* remove)(sparse_set<Entity> &, basic_registry &, const Entity){};
    };

    template<typename...>
    struct group_handler;

    template<typename... Exclude, typename... Get, typename... Owned>
    struct group_handler<exclude_t<Exclude...>, get_t<Get...>, Owned...> {
        static_assert(std::conjunction_v<std::is_same<Owned, std::decay_t<Owned>>..., std::is_same<Get, std::decay_t<Get>>..., std::is_same<Exclude, std::decay_t<Exclude>>...>);
        std::conditional_t<sizeof...(Owned) == 0, sparse_set<Entity>, std::size_t> current{};

        template<typename Component>
        void maybe_valid_if(basic_registry &owner, const Entity entt) {
            static_assert(std::disjunction_v<std::is_same<Owned, std::decay_t<Owned>>..., std::is_same<Get, std::decay_t<Get>>..., std::is_same<Exclude, std::decay_t<Exclude>>...>);
            [[maybe_unused]] const auto cpools = std::forward_as_tuple(owner.assure<Owned>()...);

            const auto is_valid = ((std::is_same_v<Component, Owned> || std::get<pool_handler<Owned> &>(cpools).contains(entt)) && ...)
                    && ((std::is_same_v<Component, Get> || owner.assure<Get>().contains(entt)) && ...)
                    && ((std::is_same_v<Component, Exclude> || !owner.assure<Exclude>().contains(entt)) && ...);

            if constexpr(sizeof...(Owned) == 0) {
                if(is_valid && !current.contains(entt)) {
                    current.emplace(entt);
                }
            } else {
                if(is_valid && !(std::get<0>(cpools).index(entt) < current)) {
                    const auto pos = current++;
                    (std::get<pool_handler<Owned> &>(cpools).swap(std::get<pool_handler<Owned> &>(cpools).data()[pos], entt), ...);
                }
            }
        }

        void discard_if([[maybe_unused]] basic_registry &owner, const Entity entt) {
            if constexpr(sizeof...(Owned) == 0) {
                if(current.contains(entt)) {
                    current.erase(entt);
                }
            } else {
                if(const auto cpools = std::forward_as_tuple(owner.assure<Owned>()...); std::get<0>(cpools).contains(entt) && (std::get<0>(cpools).index(entt) < current)) {
                    const auto pos = --current;
                    (std::get<pool_handler<Owned> &>(cpools).swap(std::get<pool_handler<Owned> &>(cpools).data()[pos], entt), ...);
                }
            }
        }
    };

    struct group_data {
        std::size_t size;
        std::unique_ptr<void, void(*)(void *)> group;
        bool (* owned)(const id_type) ENTT_NOEXCEPT;
        bool (* get)(const id_type) ENTT_NOEXCEPT;
        bool (* exclude)(const id_type) ENTT_NOEXCEPT;
    };

    struct variable_data {
        id_type type_id;
        std::unique_ptr<void, void(*)(void *)> value;
    };

    template<typename Component>
    const pool_handler<Component> & assure() const {
        static_assert(std::is_same_v<Component, std::decay_t<Component>>);

        if constexpr(has_type_index_v<Component>) {
            const auto index = type_index<Component>::value();

            if(!(index < pools.size())) {
                pools.resize(index+1);
            }

            if(auto &&pdata = pools[index]; !pdata.pool) {
                pdata.type_id = type_info<Component>::id();
                pdata.pool.reset(new pool_handler<Component>());
                pdata.remove = [](sparse_set<entity_type> &cpool, basic_registry &owner, const entity_type entt) {
                    static_cast<pool_handler<Component> &>(cpool).remove(owner, entt);
                };
            }

            return static_cast<pool_handler<Component> &>(*pools[index].pool);
        } else {
            sparse_set<entity_type> *candidate{nullptr};

            if(auto it = std::find_if(pools.begin(), pools.end(), [id = type_info<Component>::id()](const auto &pdata) { return id == pdata.type_id; }); it == pools.cend()) {
                candidate = pools.emplace_back(pool_data{
                    type_info<Component>::id(),
                    std::unique_ptr<sparse_set<entity_type>>{new pool_handler<Component>()},
                    [](sparse_set<entity_type> &cpool, basic_registry &owner, const entity_type entt) {
                        static_cast<pool_handler<Component> &>(cpool).remove(owner, entt);
                    }
                }).pool.get();
            } else {
                candidate = it->pool.get();
            }

            return static_cast<pool_handler<Component> &>(*candidate);
        }
    }

    template<typename Component>
    pool_handler<Component> & assure() {
        return const_cast<pool_handler<Component> &>(std::as_const(*this).template assure<Component>());
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Underlying version type. */
    using version_type = typename traits_type::version_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;

    /*! @brief Default constructor. */
    basic_registry() = default;

    /*! @brief Default move constructor. */
    basic_registry(basic_registry &&) = default;

    /*! @brief Default move assignment operator. @return This registry. */
    basic_registry & operator=(basic_registry &&) = default;

    /**
     * @brief Prepares a pool for the given type if required.
     * @tparam Component Type of component for which to prepare a pool.
     */
    template<typename Component>
    void prepare() {
        assure<Component>();
    }

    /**
     * @brief Returns the number of existing components of the given type.
     * @tparam Component Type of component of which to return the size.
     * @return Number of existing components of the given type.
     */
    template<typename Component>
    size_type size() const {
        return assure<Component>().size();
    }

    /**
     * @brief Returns the number of entities created so far.
     * @return Number of entities created so far.
     */
    size_type size() const ENTT_NOEXCEPT {
        return entities.size();
    }

    /**
     * @brief Returns the number of entities still in use.
     * @return Number of entities still in use.
     */
    size_type alive() const {
        auto sz = entities.size();
        auto curr = destroyed;

        for(; curr != null; --sz) {
            curr = entities[to_integral(curr) & traits_type::entity_mask];
        }

        return sz;
    }

    /**
     * @brief Increases the capacity of the registry or of the pools for the
     * given components.
     *
     * If no components are specified, the capacity of the registry is
     * increased, that is the number of entities it contains. Otherwise the
     * capacity of the pools for the given components is increased.<br/>
     * In both cases, if the new capacity is greater than the current capacity,
     * new storage is allocated, otherwise the method does nothing.
     *
     * @tparam Component Types of components for which to reserve storage.
     * @param cap Desired capacity.
     */
    template<typename... Component>
    void reserve(const size_type cap) {
        if constexpr(sizeof...(Component) == 0) {
            entities.reserve(cap);
        } else {
            (assure<Component>().reserve(cap), ...);
        }
    }

    /**
     * @brief Returns the capacity of the pool for the given component.
     * @tparam Component Type of component in which one is interested.
     * @return Capacity of the pool of the given component.
     */
    template<typename Component>
    size_type capacity() const {
        return assure<Component>().capacity();
    }

    /**
     * @brief Returns the number of entities that a registry has currently
     * allocated space for.
     * @return Capacity of the registry.
     */
    size_type capacity() const ENTT_NOEXCEPT {
        return entities.capacity();
    }

    /**
     * @brief Requests the removal of unused capacity for the given components.
     * @tparam Component Types of components for which to reclaim unused
     * capacity.
     */
    template<typename... Component>
    void shrink_to_fit() {
        (assure<Component>().shrink_to_fit(), ...);
    }

    /**
     * @brief Checks whether the registry or the pools of the given components
     * are empty.
     *
     * A registry is considered empty when it doesn't contain entities that are
     * still in use.
     *
     * @tparam Component Types of components in which one is interested.
     * @return True if the registry or the pools of the given components are
     * empty, false otherwise.
     */
    template<typename... Component>
    bool empty() const {
        if constexpr(sizeof...(Component) == 0) {
            return !alive();
        } else {
            return (assure<Component>().empty() && ...);
        }
    }

    /**
     * @brief Direct access to the list of components of a given pool.
     *
     * The returned pointer is such that range
     * `[raw<Component>(), raw<Component>() + size<Component>()]` is always a
     * valid range, even if the container is empty.
     *
     * There are no guarantees on the order of the components. Use a view if you
     * want to iterate entities and components in the expected order.
     *
     * @note
     * Empty components aren't explicitly instantiated. Therefore, this function
     * isn't available for them. A compilation error will occur if invoked.
     *
     * @tparam Component Type of component in which one is interested.
     * @return A pointer to the array of components of the given type.
     */
    template<typename Component>
    const Component * raw() const {
        return assure<Component>().raw();
    }

    /*! @copydoc raw */
    template<typename Component>
    Component * raw() {
        return const_cast<Component *>(std::as_const(*this).template raw<Component>());
    }

    /**
     * @brief Direct access to the list of entities of a given pool.
     *
     * The returned pointer is such that range
     * `[data<Component>(), data<Component>() + size<Component>()]` is always a
     * valid range, even if the container is empty.
     *
     * There are no guarantees on the order of the entities. Use a view if you
     * want to iterate entities and components in the expected order.
     *
     * @tparam Component Type of component in which one is interested.
     * @return A pointer to the array of entities.
     */
    template<typename Component>
    const entity_type * data() const {
        return assure<Component>().data();
    }

    /**
     * @brief Direct access to the list of entities of a registry.
     *
     * The returned pointer is such that range `[data(), data() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @warning
     * This list contains both valid and destroyed entities and isn't suitable
     * for direct use.
     *
     * @return A pointer to the array of entities.
     */
    const entity_type * data() const ENTT_NOEXCEPT {
        return entities.data();
    }

    /**
     * @brief Checks if an entity identifier refers to a valid entity.
     * @param entity An entity identifier, either valid or not.
     * @return True if the identifier is valid, false otherwise.
     */
    bool valid(const entity_type entity) const {
        const auto pos = size_type(to_integral(entity) & traits_type::entity_mask);
        return (pos < entities.size() && entities[pos] == entity);
    }

    /**
     * @brief Returns the entity identifier without the version.
     * @param entity An entity identifier, either valid or not.
     * @return The entity identifier without the version.
     */
    static entity_type entity(const entity_type entity) ENTT_NOEXCEPT {
        return entity_type{to_integral(entity) & traits_type::entity_mask};
    }

    /**
     * @brief Returns the version stored along with an entity identifier.
     * @param entity An entity identifier, either valid or not.
     * @return The version stored along with the given entity identifier.
     */
    static version_type version(const entity_type entity) ENTT_NOEXCEPT {
        return version_type(to_integral(entity) >> traits_type::entity_shift);
    }

    /**
     * @brief Returns the actual version for an entity identifier.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the registry results
     * in undefined behavior. An entity belongs to the registry even if it has
     * been previously destroyed and/or recycled.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * registry doesn't own the given entity.
     *
     * @param entity A valid entity identifier.
     * @return Actual version for the given entity identifier.
     */
    version_type current(const entity_type entity) const {
        const auto pos = size_type(to_integral(entity) & traits_type::entity_mask);
        ENTT_ASSERT(pos < entities.size());
        return version_type(to_integral(entities[pos]) >> traits_type::entity_shift);
    }

    /**
     * @brief Creates a new entity and returns it.
     *
     * There are two kinds of possible entity identifiers:
     *
     * * Newly created ones in case no entities have been previously destroyed.
     * * Recycled ones with updated versions.
     *
     * @return A valid entity identifier.
     */
    entity_type create() {
        entity_type entt;

        if(destroyed == null) {
            entt = entities.emplace_back(entity_type(entities.size()));
            // traits_type::entity_mask is reserved to allow for null identifiers
            ENTT_ASSERT(to_integral(entt) < traits_type::entity_mask);
        } else {
            const auto curr = to_integral(destroyed);
            const auto version = to_integral(entities[curr]) & (traits_type::version_mask << traits_type::entity_shift);
            destroyed = entity_type{to_integral(entities[curr]) & traits_type::entity_mask};
            entt = entities[curr] = entity_type{curr | version};
        }

        return entt;
    }

    /**
     * @brief Creates a new entity and returns it.
     *
     * @sa create
     *
     * If the requested entity isn't in use, the suggested identifier is created
     * and returned. Otherwise, a new one will be generated for this purpose.
     *
     * @param hint A desired entity identifier.
     * @return A valid entity identifier.
     */
    entity_type create(const entity_type hint) {
        ENTT_ASSERT(hint != null);
        entity_type entt;

        if(const auto req = (to_integral(hint) & traits_type::entity_mask); !(req < entities.size())) {
            entities.reserve(req + 1);

            for(auto pos = entities.size(); pos < req; ++pos) {
                entities.emplace_back(destroyed);
                destroyed = entity_type(pos);
            }

            entt = entities.emplace_back(hint);
        } else if(const auto curr = (to_integral(entities[req]) & traits_type::entity_mask); req == curr) {
            entt = create();
        } else {
            auto *it = &destroyed;
            for(; (to_integral(*it) & traits_type::entity_mask) != req; it = &entities[to_integral(*it) & traits_type::entity_mask]);
            *it = entity_type{curr | (to_integral(*it) & (traits_type::version_mask << traits_type::entity_shift))};
            entt = entities[req] = hint;
        }

        return entt;
    }

    /**
     * @brief Assigns each element in a range an entity.
     *
     * @sa create
     *
     * @tparam It Type of forward iterator.
     * @param first An iterator to the first element of the range to generate.
     * @param last An iterator past the last element of the range to generate.
     */
    template<typename It>
    void create(It first, It last) {
        std::generate(first, last, [this]() { return create(); });
    }

    /**
     * @brief Assigns entities to an empty registry.
     *
     * This function is intended for use in conjunction with `raw`.<br/>
     * Don't try to inject ranges of randomly generated entities. There is no
     * guarantee that a registry will continue to work properly in this case.
     *
     * @warning
     * An assertion will abort the execution at runtime in debug mode if all
     * pools aren't empty.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    void assign(It first, It last) {
        ENTT_ASSERT(std::all_of(pools.cbegin(), pools.cend(), [](auto &&pdata) { return !pdata.pool || pdata.pool->empty(); }));
        entities.assign(first, last);
        destroyed = null;

        for(std::size_t pos{}, end = entities.size(); pos < end; ++pos) {
            if((to_integral(entities[pos]) & traits_type::entity_mask) != pos) {
                const auto version = to_integral(entities[pos]) & (traits_type::version_mask << traits_type::entity_shift);
                entities[pos] = entity_type{to_integral(destroyed) | version};
                destroyed = entity_type(pos);
            }
        }
    }

    /**
     * @brief Destroys an entity.
     *
     * When an entity is destroyed, its version is updated and the identifier
     * can be recycled at any time.
     *
     * @sa remove_all
     *
     * @param entity A valid entity identifier.
     */
    void destroy(const entity_type entity) {
        destroy(entity, (to_integral(entity) >> traits_type::entity_shift) + 1);
    }

    /**
     * @brief Destroys an entity.
     *
     * If the entity isn't already destroyed, the suggested version is used
     * instead of the implicitly generated one.
     *
     * @sa remove_all
     *
     * @param entity A valid entity identifier.
     * @param version A desired version upon destruction.
     */
    void destroy(const entity_type entity, const version_type version) {
        remove_all(entity);
        // lengthens the implicit list of destroyed entities
        const auto entt = to_integral(entity) & traits_type::entity_mask;
        entities[entt] = entity_type{to_integral(destroyed) | (version << traits_type::entity_shift)};
        destroyed = entity_type{entt};
    }

    /**
     * @brief Destroys all the entities in a range.
     *
     * @sa destroy
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    void destroy(It first, It last) {
        while(first != last) { destroy(*(first++)); }
    }

    /**
     * @brief Assigns the given component to an entity.
     *
     * A new instance of the given component is created and initialized with the
     * arguments provided (the component must have a proper constructor or be of
     * aggregate type). Then the component is assigned to the given entity.
     *
     * @warning
     * Attempting to use an invalid entity or to assign a component to an entity
     * that already owns it results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity or if the entity already owns an instance of the given
     * component.
     *
     * @tparam Component Type of component to create.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entity A valid entity identifier.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Component, typename... Args>
    decltype(auto) emplace(const entity_type entity, Args &&... args) {
        ENTT_ASSERT(valid(entity));
        return assure<Component>().emplace(*this, entity, std::forward<Args>(args)...);
    }

    /*! @copydoc emplace */
    template<typename Component, typename... Args>
    [[deprecated("use ::emplace instead")]]
    decltype(auto) assign(const entity_type entity, Args &&... args) {
        return emplace<Component>(entity, std::forward<Args>(args)...);
    }

    /**
     * @brief Assigns each entity in a range the given component.
     *
     * @sa emplace
     *
     * @tparam Component Type of component to create.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param value An instance of the component to assign.
     */
    template<typename Component, typename It>
    void insert(It first, It last, const Component &value = {}) {
        ENTT_ASSERT(std::all_of(first, last, [this](const auto entity) { return valid(entity); }));
        assure<Component>().insert(*this, first, last, value);
    }

    /*! @copydoc insert */
    template<typename Component, typename It>
    [[deprecated("use ::insert instead")]]
    std::enable_if_t<std::is_same_v<typename std::iterator_traits<It>::value_type, entity_type>, void>
    assign(It first, It last, const Component &value = {}) {
        return insert(std::move(first), std::move(last), value);
    }

    /**
     * @brief Assigns each entity in a range the given components.
     *
     * @sa emplace
     *
     * @tparam Component Type of component to create.
     * @tparam EIt Type of input iterator.
     * @tparam CIt Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param from An iterator to the first element of the range of components.
     * @param to An iterator past the last element of the range of components.
     */
    template<typename Component, typename EIt, typename CIt>
    void insert(EIt first, EIt last, CIt from, CIt to) {
        static_assert(std::is_constructible_v<Component, typename std::iterator_traits<CIt>::value_type>);
        ENTT_ASSERT(std::all_of(first, last, [this](const auto entity) { return valid(entity); }));
        assure<Component>().insert(*this, first, last, from, to);
    }

    /*! @copydoc insert */
    template<typename Component, typename EIt, typename CIt>
    [[deprecated("use ::insert instead")]]
    std::enable_if_t<std::is_same_v<typename std::iterator_traits<EIt>::value_type, entity_type>, void>
    assign(EIt first, EIt last, CIt value) {
        return insert<Component>(std::move(first), std::move(last), value, value + std::distance(first, last));
    }

    /**
     * @brief Assigns or replaces the given component for an entity.
     *
     * Equivalent to the following snippet (pseudocode):
     *
     * @code{.cpp}
     * auto &component = registry.has<Component>(entity) ? registry.replace<Component>(entity, args...) : registry.emplace<Component>(entity, args...);
     * @endcode
     *
     * Prefer this function anyway because it has slightly better performance.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @tparam Component Type of component to assign or replace.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entity A valid entity identifier.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Component, typename... Args>
    decltype(auto) emplace_or_replace(const entity_type entity, Args &&... args) {
        ENTT_ASSERT(valid(entity));
        auto &cpool = assure<Component>();

        return cpool.contains(entity)
                ? cpool.replace(*this, entity, Component{std::forward<Args>(args)...})
                : cpool.emplace(*this, entity, std::forward<Args>(args)...);
    }

    /*! @copydoc emplace_or_replace */
    template<typename Component, typename... Args>
    [[deprecated("use ::emplace_or_replace instead")]]
    decltype(auto) assign_or_replace(const entity_type entity, Args &&... args) {
        return emplace_or_replace<Component>(entity, std::forward<Args>(args)...);
    }

    /**
     * @brief Patches the given component for an entity.
     *
     * The signature of the functions should be equivalent to the following:
     *
     * @code{.cpp}
     * void(Component &);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned. However, this function can be used to trigger an update signal
     * for them.
     *
     * @warning
     * Attempting to use an invalid entity or to patch a component of an entity
     * that doesn't own it results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity or if the entity doesn't own an instance of the given
     * component.
     *
     * @tparam Component Type of component to patch.
     * @tparam Func Types of the function objects to invoke.
     * @param entity A valid entity identifier.
     * @param func Valid function objects.
     * @return A reference to the patched component.
     */
    template<typename Component, typename... Func>
    decltype(auto) patch(const entity_type entity, Func &&... func) {
        ENTT_ASSERT(valid(entity));
        return assure<Component>().patch(*this, entity, std::forward<Func>(func)...);
    }

    /*! @copydoc patch */
    template<typename Component, typename... Func>
    [[deprecated("use registry::patch instead")]]
    auto replace(const entity_type entity, Func &&... func)
    -> decltype((func(std::declval<Component &>()), ...), assign<Component>(entity)) {
        return patch<Component>(entity, std::forward<Func>(func)...);
    }

    /**
     * @brief Replaces the given component for an entity.
     *
     * A new instance of the given component is created and initialized with the
     * arguments provided (the component must have a proper constructor or be of
     * aggregate type). Then the component is assigned to the given entity.
     *
     * @warning
     * Attempting to use an invalid entity or to replace a component of an
     * entity that doesn't own it results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity or if the entity doesn't own an instance of the given
     * component.
     *
     * @tparam Component Type of component to replace.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entity A valid entity identifier.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the component being replaced.
     */
    template<typename Component, typename... Args>
    auto replace(const entity_type entity, Args &&... args)
    -> decltype(std::enable_if_t<sizeof...(Args) != 0>(), Component{std::forward<Args>(args)...}, assure<Component>().get(entity)) {
        return assure<Component>().replace(*this, entity, Component{std::forward<Args>(args)...});
    }

    /**
     * @brief Removes the given components from an entity.
     *
     * @warning
     * Attempting to use an invalid entity or to remove a component from an
     * entity that doesn't own it results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity or if the entity doesn't own an instance of the given
     * component.
     *
     * @tparam Component Types of components to remove.
     * @param entity A valid entity identifier.
     */
    template<typename... Component>
    void remove(const entity_type entity) {
        ENTT_ASSERT(valid(entity));
        (assure<Component>().remove(*this, entity), ...);
    }

    /**
     * @brief Removes the given components from all the entities in a range.
     *
     * @see remove
     *
     * @tparam Component Types of components to remove.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename... Component, typename It>
    void remove(It first, It last) {
        ENTT_ASSERT(std::all_of(first, last, [this](const auto entity) { return valid(entity); }));
        (assure<Component>().remove(*this, first, last), ...);
    }

    /**
     * @brief Removes the given components from an entity.
     *
     * Equivalent to the following snippet (pseudocode):
     *
     * @code{.cpp}
     * if(registry.has<Component>(entity)) { registry.remove<Component>(entity) }
     * @endcode
     *
     * Prefer this function anyway because it has slightly better performance.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @tparam Component Types of components to remove.
     * @param entity A valid entity identifier.
     */
    template<typename... Component>
    void remove_if_exists(const entity_type entity) {
        ENTT_ASSERT(valid(entity));

        ([this, entity](auto &&cpool) {
            if(cpool.contains(entity)) {
                cpool.remove(*this, entity);
            }
        }(assure<Component>()), ...);
    }

    /**
     * @brief Removes all the components from an entity and makes it orphaned.
     *
     * @warning
     * In case there are listeners that observe the destruction of components
     * and assign other components to the entity in their bodies, the result of
     * invoking this function may not be as expected. In the worst case, it
     * could lead to undefined behavior. An assertion will abort the execution
     * at runtime in debug mode if a violation is detected.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @param entity A valid entity identifier.
     */
    void remove_all(const entity_type entity) {
        ENTT_ASSERT(valid(entity));

        for(auto pos = pools.size(); pos; --pos) {
            if(auto &pdata = pools[pos-1]; pdata.pool && pdata.pool->contains(entity)) {
                pdata.remove(*pdata.pool, *this, entity);
            }
        }
    }

    /**
     * @brief Checks if an entity has all the given components.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @tparam Component Components for which to perform the check.
     * @param entity A valid entity identifier.
     * @return True if the entity has all the components, false otherwise.
     */
    template<typename... Component>
    bool has(const entity_type entity) const {
        ENTT_ASSERT(valid(entity));
        return (assure<Component>().contains(entity) && ...);
    }

    /**
     * @brief Checks if an entity has at least one of the given components.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @tparam Component Components for which to perform the check.
     * @param entity A valid entity identifier.
     * @return True if the entity has at least one of the given components,
     * false otherwise.
     */
    template<typename... Component>
    bool any(const entity_type entity) const {
        ENTT_ASSERT(valid(entity));
        return (assure<Component>().contains(entity) || ...);
    }

    /**
     * @brief Returns references to the given components for an entity.
     *
     * @warning
     * Attempting to use an invalid entity or to get a component from an entity
     * that doesn't own it results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity or if the entity doesn't own an instance of the given
     * component.
     *
     * @tparam Component Types of components to get.
     * @param entity A valid entity identifier.
     * @return References to the components owned by the entity.
     */
    template<typename... Component>
    decltype(auto) get([[maybe_unused]] const entity_type entity) const {
        ENTT_ASSERT(valid(entity));

        if constexpr(sizeof...(Component) == 1) {
            return (assure<Component>().get(entity), ...);
        } else {
            return std::forward_as_tuple(get<Component>(entity)...);
        }
    }

    /*! @copydoc get */
    template<typename... Component>
    decltype(auto) get([[maybe_unused]] const entity_type entity) {
        ENTT_ASSERT(valid(entity));

        if constexpr(sizeof...(Component) == 1) {
            return (assure<Component>().get(entity), ...);
        } else {
            return std::forward_as_tuple(get<Component>(entity)...);
        }
    }

    /**
     * @brief Returns a reference to the given component for an entity.
     *
     * In case the entity doesn't own the component, the parameters provided are
     * used to construct it.<br/>
     * Equivalent to the following snippet (pseudocode):
     *
     * @code{.cpp}
     * auto &component = registry.has<Component>(entity) ? registry.get<Component>(entity) : registry.emplace<Component>(entity, args...);
     * @endcode
     *
     * Prefer this function anyway because it has slightly better performance.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @tparam Component Type of component to get.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entity A valid entity identifier.
     * @param args Parameters to use to initialize the component.
     * @return Reference to the component owned by the entity.
     */
    template<typename Component, typename... Args>
    decltype(auto) get_or_emplace(const entity_type entity, Args &&... args) {
        ENTT_ASSERT(valid(entity));
        auto &cpool = assure<Component>();
        return cpool.contains(entity) ? cpool.get(entity) : cpool.emplace(*this, entity, std::forward<Args>(args)...);
    }

    /*! @copydoc get_or_emplace */
    template<typename Component, typename... Args>
    [[deprecated("use ::get_or_emplace instead")]]
    decltype(auto) get_or_assign(const entity_type entity, Args &&... args) {
        return get_or_emplace<Component>(entity, std::forward<Args>(args)...);
    }

    /**
     * @brief Returns pointers to the given components for an entity.
     *
     * @warning
     * Attempting to use an invalid entity results in undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid entity.
     *
     * @tparam Component Types of components to get.
     * @param entity A valid entity identifier.
     * @return Pointers to the components owned by the entity.
     */
    template<typename... Component>
    auto try_get([[maybe_unused]] const entity_type entity) const {
        ENTT_ASSERT(valid(entity));

        if constexpr(sizeof...(Component) == 1) {
            return (assure<Component>().try_get(entity), ...);
        } else {
            return std::make_tuple(try_get<Component>(entity)...);
        }
    }

    /*! @copydoc try_get */
    template<typename... Component>
    auto try_get([[maybe_unused]] const entity_type entity) {
        ENTT_ASSERT(valid(entity));

        if constexpr(sizeof...(Component) == 1) {
            return (assure<Component>().try_get(entity), ...);
        } else {
            return std::make_tuple(try_get<Component>(entity)...);
        }
    }

    /**
     * @brief Clears a whole registry or the pools for the given components.
     * @tparam Component Types of components to remove from their entities.
     */
    template<typename... Component>
    void clear() {
        if constexpr(sizeof...(Component) == 0) {
            // useless this-> used to suppress a warning with clang
            each([this](const auto entity) { this->destroy(entity); });
        } else {
            ([this](auto &&cpool) {
                cpool.remove(*this, cpool.sparse_set<entity_type>::begin(), cpool.sparse_set<entity_type>::end());
            }(assure<Component>()), ...);
        }
    }

    /**
     * @brief Iterates all the entities that are still in use.
     *
     * The function object is invoked for each entity that is still in use.<br/>
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const Entity);
     * @endcode
     *
     * This function is fairly slow and should not be used frequently. However,
     * it's useful for iterating all the entities still in use, regardless of
     * their components.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        static_assert(std::is_invocable_v<Func, entity_type>);

        if(destroyed == null) {
            for(auto pos = entities.size(); pos; --pos) {
                func(entities[pos-1]);
            }
        } else {
            for(auto pos = entities.size(); pos; --pos) {
                if(const auto entt = entities[pos - 1]; (to_integral(entt) & traits_type::entity_mask) == (pos - 1)) {
                    func(entt);
                }
            }
        }
    }

    /**
     * @brief Checks if an entity has components assigned.
     * @param entity A valid entity identifier.
     * @return True if the entity has no components assigned, false otherwise.
     */
    bool orphan(const entity_type entity) const {
        ENTT_ASSERT(valid(entity));
        return std::none_of(pools.cbegin(), pools.cend(), [entity](auto &&pdata) { return pdata.pool && pdata.pool->contains(entity); });
    }

    /**
     * @brief Iterates orphans and applies them the given function object.
     *
     * The function object is invoked for each entity that is still in use and
     * has no components assigned.<br/>
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const Entity);
     * @endcode
     *
     * This function can be very slow and should not be used frequently.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void orphans(Func func) const {
        static_assert(std::is_invocable_v<Func, entity_type>);

        each([this, &func](const auto entity) {
            if(orphan(entity)) {
                func(entity);
            }
        });
    }

    /**
     * @brief Returns a sink object for the given component.
     *
     * A sink is an opaque object used to connect listeners to components.<br/>
     * The sink returned by this function can be used to receive notifications
     * whenever a new instance of the given component is created and assigned to
     * an entity.
     *
     * The function type for a listener is equivalent to:
     *
     * @code{.cpp}
     * void(registry<Entity> &, Entity);
     * @endcode
     *
     * Listeners are invoked **after** the component has been assigned to the
     * entity.
     *
     * @sa sink
     *
     * @tparam Component Type of component of which to get the sink.
     * @return A temporary sink object.
     */
    template<typename Component>
    auto on_construct() {
        return assure<Component>().on_construct();
    }

    /**
     * @brief Returns a sink object for the given component.
     *
     * A sink is an opaque object used to connect listeners to components.<br/>
     * The sink returned by this function can be used to receive notifications
     * whenever an instance of the given component is explicitly updated.
     *
     * The function type for a listener is equivalent to:
     *
     * @code{.cpp}
     * void(registry<Entity> &, Entity);
     * @endcode
     *
     * Listeners are invoked **after** the component has been updated.
     *
     * @sa sink
     *
     * @tparam Component Type of component of which to get the sink.
     * @return A temporary sink object.
     */
    template<typename Component>
    auto on_update() {
        return assure<Component>().on_update();
    }

    /*! @copydoc on_update */
    template<typename Component>
    [[deprecated("use registry::on_update instead")]]
    auto on_replace() {
        return on_update<Component>();
    }

    /**
     * @brief Returns a sink object for the given component.
     *
     * A sink is an opaque object used to connect listeners to components.<br/>
     * The sink returned by this function can be used to receive notifications
     * whenever an instance of the given component is removed from an entity and
     * thus destroyed.
     *
     * The function type for a listener is equivalent to:
     *
     * @code{.cpp}
     * void(registry<Entity> &, Entity);
     * @endcode
     *
     * Listeners are invoked **before** the component has been removed from the
     * entity.
     *
     * @sa sink
     *
     * @tparam Component Type of component of which to get the sink.
     * @return A temporary sink object.
     */
    template<typename Component>
    auto on_destroy() {
        return assure<Component>().on_destroy();
    }

    /**
     * @brief Sorts the pool of entities for the given component.
     *
     * The order of the elements in a pool is highly affected by assignments
     * of components to entities and deletions. Components are arranged to
     * maximize the performance during iterations and users should not make any
     * assumption on the order.<br/>
     * This function can be used to impose an order to the elements in the pool
     * of the given component. The order is kept valid until a component of the
     * given type is assigned or removed from an entity.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(const Entity, const Entity);
     * bool(const Component &, const Component &);
     * @endcode
     *
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function oject must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * The comparison funtion object received by the sort function object hasn't
     * necessarily the type of the one passed along with the other parameters to
     * this member function.
     *
     * @warning
     * Pools of components owned by a group cannot be sorted.<br/>
     * An assertion will abort the execution at runtime in debug mode in case
     * the pool is owned by a group.
     *
     * @tparam Component Type of components to sort.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Component, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&... args) {
        auto &cpool = assure<Component>();
        ENTT_ASSERT(!cpool.super);
        cpool.sort(cpool.begin(), cpool.end(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
    }

    /**
     * @brief Sorts two pools of components in the same way.
     *
     * The order of the elements in a pool is highly affected by assignments
     * of components to entities and deletions. Components are arranged to
     * maximize the performance during iterations and users should not make any
     * assumption on the order.
     *
     * It happens that different pools of components must be sorted the same way
     * because of runtime and/or performance constraints. This function can be
     * used to order a pool of components according to the order between the
     * entities in another pool of components.
     *
     * @b How @b it @b works
     *
     * Being `A` and `B` the two sets where `B` is the master (the one the order
     * of which rules) and `A` is the slave (the one to sort), after a call to
     * this function an iterator for `A` will return the entities according to
     * the following rules:
     *
     * * All the entities in `A` that are also in `B` are returned first
     *   according to the order they have in `B`.
     * * All the entities in `A` that are not in `B` are returned in no
     *   particular order after all the other entities.
     *
     * Any subsequent change to `B` won't affect the order in `A`.
     *
     * @warning
     * Pools of components owned by a group cannot be sorted.<br/>
     * An assertion will abort the execution at runtime in debug mode in case
     * the pool is owned by a group.
     *
     * @tparam To Type of components to sort.
     * @tparam From Type of components to use to sort.
     */
    template<typename To, typename From>
    void sort() {
        auto &cpool = assure<To>();
        ENTT_ASSERT(!cpool.super);
        cpool.respect(assure<From>());
    }

    /**
     * @brief Returns a view for the given components.
     *
     * This kind of objects are created on the fly and share with the registry
     * its internal data structures.<br/>
     * Feel free to discard a view after the use. Creating and destroying a view
     * is an incredibly cheap operation because they do not require any type of
     * initialization.<br/>
     * As a rule of thumb, storing a view should never be an option.
     *
     * Views do their best to iterate the smallest set of candidate entities.
     * In particular:
     *
     * * Single component views are incredibly fast and iterate a packed array
     *   of entities, all of which has the given component.
     * * Multi component views look at the number of entities available for each
     *   component and pick up a reference to the smallest set of candidates to
     *   test for the given components.
     *
     * Views in no way affect the functionalities of the registry nor those of
     * the underlying pools.
     *
     * @note
     * Multi component views are pretty fast. However their performance tend to
     * degenerate when the number of components to iterate grows up and the most
     * of the entities have all the given components.<br/>
     * To get a performance boost, consider using a group instead.
     *
     * @tparam Component Type of components used to construct the view.
     * @tparam Exclude Types of components used to filter the view.
     * @return A newly created view.
     */
    template<typename... Component, typename... Exclude>
    entt::basic_view<Entity, exclude_t<Exclude...>, Component...> view(exclude_t<Exclude...> = {}) {
        static_assert(sizeof...(Component) > 0);
        return { assure<std::decay_t<Component>>()..., assure<Exclude>()... };
    }

    /*! @copydoc view */
    template<typename... Component, typename... Exclude>
    entt::basic_view<Entity, exclude_t<Exclude...>, Component...> view(exclude_t<Exclude...> = {}) const {
        static_assert(std::conjunction_v<std::is_const<Component>...>);
        return const_cast<basic_registry *>(this)->view<Component...>(exclude<Exclude...>);
    }

    /**
     * @brief Checks whether the given components belong to any group.
     * @tparam Component Types of components in which one is interested.
     * @return True if the pools of the given components are sortable, false
     * otherwise.
     */
    template<typename... Component>
    bool sortable() const {
        return !(assure<Component>().super || ...);
    }

    /**
     * @brief Returns a group for the given components.
     *
     * This kind of objects are created on the fly and share with the registry
     * its internal data structures.<br/>
     * Feel free to discard a group after the use. Creating and destroying a
     * group is an incredibly cheap operation because they do not require any
     * type of initialization, but for the first time they are requested.<br/>
     * As a rule of thumb, storing a group should never be an option.
     *
     * Groups support exclusion lists and can own types of components. The more
     * types are owned by a group, the faster it is to iterate entities and
     * components.<br/>
     * However, groups also affect some features of the registry such as the
     * creation and destruction of components, which will consequently be
     * slightly slower (nothing that can be noticed in most cases).
     *
     * @note
     * Pools of components that are owned by a group cannot be sorted anymore.
     * The group takes the ownership of the pools and arrange components so as
     * to iterate them as fast as possible.
     *
     * @tparam Owned Types of components owned by the group.
     * @tparam Get Types of components observed by the group.
     * @tparam Exclude Types of components used to filter the group.
     * @return A newly created group.
     */
    template<typename... Owned, typename... Get, typename... Exclude>
    entt::basic_group<Entity, exclude_t<Exclude...>, get_t<Get...>, Owned...> group(get_t<Get...>, exclude_t<Exclude...> = {}) {
        static_assert(sizeof...(Owned) + sizeof...(Get) > 0);
        static_assert(sizeof...(Owned) + sizeof...(Get) + sizeof...(Exclude) > 1);

        using handler_type = group_handler<exclude_t<Exclude...>, get_t<std::decay_t<Get>...>, std::decay_t<Owned>...>;

        const auto cpools = std::forward_as_tuple(assure<std::decay_t<Owned>>()..., assure<std::decay_t<Get>>()...);
        constexpr auto size = sizeof...(Owned) + sizeof...(Get) + sizeof...(Exclude);
        handler_type *handler = nullptr;

        if(auto it = std::find_if(groups.cbegin(), groups.cend(), [size](const auto &gdata) {
            return gdata.size == size
                && (gdata.owned(type_info<std::decay_t<Owned>>::id()) && ...)
                && (gdata.get(type_info<std::decay_t<Get>>::id()) && ...)
                && (gdata.exclude(type_info<Exclude>::id()) && ...);
        }); it != groups.cend())
        {
            handler = static_cast<handler_type *>(it->group.get());
        }

        if(!handler) {
            group_data candidate = {
                size,
                { new handler_type{}, [](void *instance) { delete static_cast<handler_type *>(instance); } },
                []([[maybe_unused]] const id_type ctype) ENTT_NOEXCEPT { return ((ctype == type_info<std::decay_t<Owned>>::id()) || ...); },
                []([[maybe_unused]] const id_type ctype) ENTT_NOEXCEPT { return ((ctype == type_info<std::decay_t<Get>>::id()) || ...); },
                []([[maybe_unused]] const id_type ctype) ENTT_NOEXCEPT { return ((ctype == type_info<Exclude>::id()) || ...); },
            };

            handler = static_cast<handler_type *>(candidate.group.get());

            const void *maybe_valid_if = nullptr;
            const void *discard_if = nullptr;

            if constexpr(sizeof...(Owned) == 0) {
                groups.push_back(std::move(candidate));
            } else {
                ENTT_ASSERT(std::all_of(groups.cbegin(), groups.cend(), [size](const auto &gdata) {
                    const auto overlapping = (0u + ... + gdata.owned(type_info<std::decay_t<Owned>>::id()));
                    const auto sz = overlapping + (0u + ... + gdata.get(type_info<std::decay_t<Get>>::id())) + (0u + ... + gdata.exclude(type_info<Exclude>::id()));
                    return !overlapping || ((sz == size) || (sz == gdata.size));
                }));

                const auto next = std::find_if_not(groups.cbegin(), groups.cend(), [size](const auto &gdata) {
                    return !(0u + ... + gdata.owned(type_info<std::decay_t<Owned>>::id())) || (size > (gdata.size));
                });

                const auto prev = std::find_if(std::make_reverse_iterator(next), groups.crend(), [](const auto &gdata) {
                    return (0u + ... + gdata.owned(type_info<std::decay_t<Owned>>::id()));
                });

                maybe_valid_if = (next == groups.cend() ? maybe_valid_if : next->group.get());
                discard_if = (prev == groups.crend() ? discard_if : prev->group.get());
                groups.insert(next, std::move(candidate));
            }

            ((std::get<pool_handler<std::decay_t<Owned>> &>(cpools).super = std::max(std::get<pool_handler<std::decay_t<Owned>> &>(cpools).super, size)), ...);

            (on_construct<std::decay_t<Owned>>().before(maybe_valid_if).template connect<&handler_type::template maybe_valid_if<std::decay_t<Owned>>>(*handler), ...);
            (on_construct<std::decay_t<Get>>().before(maybe_valid_if).template connect<&handler_type::template maybe_valid_if<std::decay_t<Get>>>(*handler), ...);
            (on_destroy<Exclude>().before(maybe_valid_if).template connect<&handler_type::template maybe_valid_if<Exclude>>(*handler), ...);

            (on_destroy<std::decay_t<Owned>>().before(discard_if).template connect<&handler_type::discard_if>(*handler), ...);
            (on_destroy<std::decay_t<Get>>().before(discard_if).template connect<&handler_type::discard_if>(*handler), ...);
            (on_construct<Exclude>().before(discard_if).template connect<&handler_type::discard_if>(*handler), ...);

            if constexpr(sizeof...(Owned) == 0) {
                for(const auto entity: view<Owned..., Get...>(entt::exclude<Exclude...>)) {
                    handler->current.emplace(entity);
                }
            } else {
                // we cannot iterate backwards because we want to leave behind valid entities in case of owned types
                for(auto *first = std::get<0>(cpools).data(), *last = first + std::get<0>(cpools).size(); first != last; ++first) {
                    handler->template maybe_valid_if<std::tuple_element_t<0, std::tuple<std::decay_t<Owned>...>>>(*this, *first);
                }
            }
        }

        if constexpr(sizeof...(Owned) == 0) {
            return { handler->current, std::get<pool_handler<std::decay_t<Get>> &>(cpools)... };
        } else {
            return { std::get<0>(cpools).super, handler->current, std::get<pool_handler<std::decay_t<Owned>> &>(cpools)... , std::get<pool_handler<std::decay_t<Get>> &>(cpools)... };
        }
    }

    /**
     * @brief Returns a group for the given components.
     *
     * @sa group
     *
     * @tparam Owned Types of components owned by the group.
     * @tparam Get Types of components observed by the group.
     * @tparam Exclude Types of components used to filter the group.
     * @return A newly created group.
     */
    template<typename... Owned, typename... Get, typename... Exclude>
    entt::basic_group<Entity, exclude_t<Exclude...>, get_t<Get...>, Owned...> group(get_t<Get...>, exclude_t<Exclude...> = {}) const {
        static_assert(std::conjunction_v<std::is_const<Owned>..., std::is_const<Get>...>);
        return const_cast<basic_registry *>(this)->group<Owned...>(entt::get<Get...>, exclude<Exclude...>);
    }

    /**
     * @brief Returns a group for the given components.
     *
     * @sa group
     *
     * @tparam Owned Types of components owned by the group.
     * @tparam Exclude Types of components used to filter the group.
     * @return A newly created group.
     */
    template<typename... Owned, typename... Exclude>
    entt::basic_group<Entity, exclude_t<Exclude...>, get_t<>, Owned...> group(exclude_t<Exclude...> = {}) {
        return group<Owned...>(entt::get<>, exclude<Exclude...>);
    }

    /**
     * @brief Returns a group for the given components.
     *
     * @sa group
     *
     * @tparam Owned Types of components owned by the group.
     * @tparam Exclude Types of components used to filter the group.
     * @return A newly created group.
     */
    template<typename... Owned, typename... Exclude>
    entt::basic_group<Entity, exclude_t<Exclude...>, get_t<>, Owned...> group(exclude_t<Exclude...> = {}) const {
        static_assert(std::conjunction_v<std::is_const<Owned>...>);
        return const_cast<basic_registry *>(this)->group<Owned...>(exclude<Exclude...>);
    }

    /**
     * @brief Returns a runtime view for the given components.
     *
     * This kind of objects are created on the fly and share with the registry
     * its internal data structures.<br/>
     * Users should throw away the view after use. Fortunately, creating and
     * destroying a runtime view is an incredibly cheap operation because they
     * do not require any type of initialization.<br/>
     * As a rule of thumb, storing a view should never be an option.
     *
     * Runtime views are to be used when users want to construct a view from
     * some external inputs and don't know at compile-time what are the required
     * components.<br/>
     * This is particularly well suited to plugin systems and mods in general.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of components.
     * @param last An iterator past the last element of the range of components.
     * @return A newly created runtime view.
     */
    template<typename It>
    entt::basic_runtime_view<Entity> runtime_view(It first, It last) const {
        std::vector<const sparse_set<Entity> *> selected(std::distance(first, last));

        std::transform(first, last, selected.begin(), [this](const auto ctype) {
            const auto it = std::find_if(pools.cbegin(), pools.cend(), [ctype](auto &&pdata) { return pdata.pool && pdata.type_id == ctype; });
            return it == pools.cend() ? nullptr : it->pool.get();
        });

        return { std::move(selected) };
    }

    /**
     * @brief Returns a temporary object to use to create snapshots.
     *
     * A snapshot is either a full or a partial dump of a registry.<br/>
     * It can be used to save and restore its internal state or to keep two or
     * more instances of this class in sync, as an example in a client-server
     * architecture.
     *
     * @return A temporary object to use to take snasphosts.
     */
    [[deprecated("basic_snapshot has now a constructor that accepts a reference to a registry")]]
    entt::basic_snapshot<Entity> snapshot() const {
        return { *this };
    }

    /**
     * @brief Returns a temporary object to use to load snapshots.
     *
     * A snapshot is either a full or a partial dump of a registry.<br/>
     * It can be used to save and restore its internal state or to keep two or
     * more instances of this class in sync, as an example in a client-server
     * architecture.
     *
     * @note
     * The loader returned by this function requires that the registry be empty.
     * In case it isn't, all the data will be automatically deleted before to
     * return.
     *
     * @return A temporary object to use to load snasphosts.
     */
    [[deprecated("basic_snapshot_loader has now a constructor that accepts a reference to a registry")]]
    basic_snapshot_loader<Entity> loader() {
        return { *this };
    }

    /**
     * @brief Visits an entity and returns the types for its components.
     *
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const id_type);
     * @endcode
     *
     * Returned identifiers are those of the components owned by the entity.
     *
     * @sa type_info
     *
     * @warning
     * It's not specified whether a component attached to or removed from the
     * given entity during the visit is returned or not to the caller.
     *
     * @tparam Func Type of the function object to invoke.
     * @param entity A valid entity identifier.
     * @param func A valid function object.
     */
    template<typename Func>
    void visit(entity_type entity, Func func) const {
        for(auto pos = pools.size(); pos; --pos) {
            if(const auto &pdata = pools[pos-1]; pdata.pool && pdata.pool->contains(entity)) {
                func(pdata.type_id);
            }
        }
    }

    /**
     * @brief Visits a registry and returns the types for its components.
     *
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const id_type);
     * @endcode
     *
     * Returned identifiers are those of the components managed by the registry.
     *
     * @sa type_info
     *
     * @warning
     * It's not specified whether a component for which a pool is created during
     * the visit is returned or not to the caller.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void visit(Func func) const {
        for(auto pos = pools.size(); pos; --pos) {
            if(const auto &pdata = pools[pos-1]; pdata.pool) {
                func(pdata.type_id);
            }
        }
    }

    /**
     * @brief Binds an object to the context of the registry.
     *
     * If the value already exists it is overwritten, otherwise a new instance
     * of the given type is created and initialized with the arguments provided.
     *
     * @tparam Type Type of object to set.
     * @tparam Args Types of arguments to use to construct the object.
     * @param args Parameters to use to initialize the value.
     * @return A reference to the newly created object.
     */
    template<typename Type, typename... Args>
    Type & set(Args &&... args) {
        unset<Type>();
        vars.push_back(variable_data{type_info<Type>::id(), { new Type{std::forward<Args>(args)...}, [](void *instance) { delete static_cast<Type *>(instance); } }});
        return *static_cast<Type *>(vars.back().value.get());
    }

    /**
     * @brief Unsets a context variable if it exists.
     * @tparam Type Type of object to set.
     */
    template<typename Type>
    void unset() {
        vars.erase(std::remove_if(vars.begin(), vars.end(), [](auto &&var) {
            return var.type_id == type_info<Type>::id();
        }), vars.end());
    }

    /**
     * @brief Binds an object to the context of the registry.
     *
     * In case the context doesn't contain the given object, the parameters
     * provided are used to construct it.
     *
     * @tparam Type Type of object to set.
     * @tparam Args Types of arguments to use to construct the object.
     * @param args Parameters to use to initialize the object.
     * @return A reference to the object in the context of the registry.
     */
    template<typename Type, typename... Args>
    Type & ctx_or_set(Args &&... args) {
        auto *value = try_ctx<Type>();
        return value ? *value : set<Type>(std::forward<Args>(args)...);
    }

    /**
     * @brief Returns a pointer to an object in the context of the registry.
     * @tparam Type Type of object to get.
     * @return A pointer to the object if it exists in the context of the
     * registry, a null pointer otherwise.
     */
    template<typename Type>
    const Type * try_ctx() const {
        auto it = std::find_if(vars.cbegin(), vars.cend(), [](auto &&var) { return var.type_id == type_info<Type>::id(); });
        return it == vars.cend() ? nullptr : static_cast<const Type *>(it->value.get());
    }

    /*! @copydoc try_ctx */
    template<typename Type>
    Type * try_ctx() {
        return const_cast<Type *>(std::as_const(*this).template try_ctx<Type>());
    }

    /**
     * @brief Returns a reference to an object in the context of the registry.
     *
     * @warning
     * Attempting to get a context variable that doesn't exist results in
     * undefined behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case of
     * invalid requests.
     *
     * @tparam Type Type of object to get.
     * @return A valid reference to the object in the context of the registry.
     */
    template<typename Type>
    const Type & ctx() const {
        const auto *instance = try_ctx<Type>();
        ENTT_ASSERT(instance);
        return *instance;
    }

    /*! @copydoc ctx */
    template<typename Type>
    Type & ctx() {
        return const_cast<Type &>(std::as_const(*this).template ctx<Type>());
    }

    /**
     * @brief Visits a registry and returns the types for its context variables.
     *
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const id_type);
     * @endcode
     *
     * Returned identifiers are those of the context variables currently set.
     *
     * @sa type_info
     *
     * @warning
     * It's not specified whether a context variable created during the visit is
     * returned or not to the caller.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void ctx(Func func) const {
        for(auto pos = vars.size(); pos; --pos) {
            func(vars[pos-1].type_id);
        }
    }

private:
    std::vector<group_data> groups{};
    mutable std::vector<pool_data> pools{};
    std::vector<entity_type> entities{};
    std::vector<variable_data> vars{};
    entity_type destroyed{null};
};


}


#endif

// #include "entity.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Dedicated to those who aren't confident with the
 * entity-component-system architecture.
 *
 * Tiny wrapper around a registry, for all those users that aren't confident
 * with entity-component-system architecture and prefer to iterate objects
 * directly.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
struct basic_actor {
    /*! @brief Type of registry used internally. */
    using registry_type = basic_registry<Entity>;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;

    basic_actor() ENTT_NOEXCEPT
        : entt{entt::null}, reg{nullptr}
    {}

    /**
     * @brief Move constructor.
     *
     * After actor move construction, instances that have been moved from are
     * placed in a valid but unspecified state. It's highly discouraged to
     * continue using them.
     *
     * @param other The instance to move from.
     */
    basic_actor(basic_actor &&other) ENTT_NOEXCEPT
        : entt{other.entt}, reg{other.reg}
    {
        other.entt = null;
    }

    /**
     * @brief Constructs an actor from a given registry.
     * @param ref An instance of the registry class.
     */
    explicit basic_actor(registry_type &ref)
        : entt{ref.create()}, reg{&ref}
    {}

    /**
     * @brief Constructs an actor from a given entity.
     * @param entity A valid entity identifier.
     * @param ref An instance of the registry class.
     */
    explicit basic_actor(entity_type entity, registry_type &ref) ENTT_NOEXCEPT
        : entt{entity}, reg{&ref}
    {
        ENTT_ASSERT(ref.valid(entity));
    }

    /*! @brief Default destructor. */
    virtual ~basic_actor() {
        if(*this) {
            reg->destroy(entt);
        }
    }

    /**
     * @brief Move assignment operator.
     *
     * After actor move assignment, instances that have been moved from are
     * placed in a valid but unspecified state. It's highly discouraged to
     * continue using them.
     *
     * @param other The instance to move from.
     * @return This actor.
     */
    basic_actor & operator=(basic_actor &&other) ENTT_NOEXCEPT {
        if(this != &other) {
            auto tmp{std::move(other)};
            std::swap(reg, tmp.reg);
            std::swap(entt, tmp.entt);
        }

        return *this;
    }

    /**
     * @brief Assigns the given component to an actor.
     *
     * A new instance of the given component is created and initialized with the
     * arguments provided (the component must have a proper constructor or be of
     * aggregate type). Then the component is assigned to the actor.<br/>
     * In case the actor already has a component of the given type, it's
     * replaced with the new one.
     *
     * @tparam Component Type of the component to create.
     * @tparam Args Types of arguments to use to construct the component.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Component, typename... Args>
    decltype(auto) assign(Args &&... args) {
        return reg->template emplace_or_replace<Component>(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Removes the given component from an actor.
     * @tparam Component Type of the component to remove.
     */
    template<typename Component>
    void remove() {
        reg->template remove<Component>(entt);
    }

    /**
     * @brief Checks if an actor has the given components.
     * @tparam Component Components for which to perform the check.
     * @return True if the actor has all the components, false otherwise.
     */
    template<typename... Component>
    bool has() const {
        return reg->template has<Component...>(entt);
    }

    /**
     * @brief Returns references to the given components for an actor.
     * @tparam Component Types of components to get.
     * @return References to the components owned by the actor.
     */
    template<typename... Component>
    decltype(auto) get() const {
        return std::as_const(*reg).template get<Component...>(entt);
    }

    /*! @copydoc get */
    template<typename... Component>
    decltype(auto) get() {
        return reg->template get<Component...>(entt);
    }

    /**
     * @brief Returns pointers to the given components for an actor.
     * @tparam Component Types of components to get.
     * @return Pointers to the components owned by the actor.
     */
    template<typename... Component>
    auto try_get() const {
        return std::as_const(*reg).template try_get<Component...>(entt);
    }

    /*! @copydoc try_get */
    template<typename... Component>
    auto try_get() {
        return reg->template try_get<Component...>(entt);
    }

    /**
     * @brief Returns a reference to the underlying registry.
     * @return A reference to the underlying registry.
     */
    const registry_type & backend() const ENTT_NOEXCEPT {
        return *reg;
    }

    /*! @copydoc backend */
    registry_type & backend() ENTT_NOEXCEPT {
        return const_cast<registry_type &>(std::as_const(*this).backend());
    }

    /**
     * @brief Returns the entity associated with an actor.
     * @return The entity associated with the actor.
     */
    entity_type entity() const ENTT_NOEXCEPT {
        return entt;
    }

    /**
     * @brief Checks if an actor refers to a valid entity or not.
     * @return True if the actor refers to a valid entity, false otherwise.
     */
    explicit operator bool() const {
        return reg && reg->valid(entt);
    }

private:
    entity_type entt;
    registry_type *reg;
};


}


#endif

// #include "entity/entity.hpp"

// #include "entity/group.hpp"

// #include "entity/helper.hpp"
#ifndef ENTT_ENTITY_HELPER_HPP
#define ENTT_ENTITY_HELPER_HPP


#include <type_traits>
// #include "../config/config.h"

// #include "../core/type_traits.hpp"

// #include "../signal/delegate.hpp"

// #include "registry.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Converts a registry to a view.
 * @tparam Const Constness of the accepted registry.
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<bool Const, typename Entity>
struct as_view {
    /*! @brief Type of registry to convert. */
    using registry_type = std::conditional_t<Const, const entt::basic_registry<Entity>, entt::basic_registry<Entity>>;

    /**
     * @brief Constructs a converter for a given registry.
     * @param source A valid reference to a registry.
     */
    as_view(registry_type &source) ENTT_NOEXCEPT: reg{source} {}

    /**
     * @brief Conversion function from a registry to a view.
     * @tparam Exclude Types of components used to filter the view.
     * @tparam Component Type of components used to construct the view.
     * @return A newly created view.
     */
    template<typename Exclude, typename... Component>
    operator entt::basic_view<Entity, Exclude, Component...>() const {
        return reg.template view<Component...>(Exclude{});
    }

private:
    registry_type &reg;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the constness of a registry directly from the instance
 * provided to the constructor.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
as_view(basic_registry<Entity> &) ENTT_NOEXCEPT -> as_view<false, Entity>;


/*! @copydoc as_view */
template<typename Entity>
as_view(const basic_registry<Entity> &) ENTT_NOEXCEPT -> as_view<true, Entity>;


/**
 * @brief Converts a registry to a group.
 * @tparam Const Constness of the accepted registry.
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<bool Const, typename Entity>
struct as_group {
    /*! @brief Type of registry to convert. */
    using registry_type = std::conditional_t<Const, const entt::basic_registry<Entity>, entt::basic_registry<Entity>>;

    /**
     * @brief Constructs a converter for a given registry.
     * @param source A valid reference to a registry.
     */
    as_group(registry_type &source) ENTT_NOEXCEPT: reg{source} {}

    /**
     * @brief Conversion function from a registry to a group.
     * @tparam Exclude Types of components used to filter the group.
     * @tparam Get Types of components observed by the group.
     * @tparam Owned Types of components owned by the group.
     * @return A newly created group.
     */
    template<typename Exclude, typename Get, typename... Owned>
    operator entt::basic_group<Entity, Exclude, Get, Owned...>() const {
        return reg.template group<Owned...>(Get{}, Exclude{});
    }

private:
    registry_type &reg;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the constness of a registry directly from the instance
 * provided to the constructor.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
as_group(basic_registry<Entity> &) ENTT_NOEXCEPT -> as_group<false, Entity>;


/*! @copydoc as_group */
template<typename Entity>
as_group(const basic_registry<Entity> &) ENTT_NOEXCEPT -> as_group<true, Entity>;



/**
 * @brief Helper to create a listener that directly invokes a member function.
 * @tparam Member Member function to invoke on a component of the given type.
 * @tparam Entity A valid entity type (see entt_traits for more details).
 * @param reg A registry that contains the given entity and its components.
 * @param entt Entity from which to get the component.
 */
template<auto Member, typename Entity = entity>
void invoke(basic_registry<Entity> &reg, const Entity entt) {
    static_assert(std::is_member_function_pointer_v<decltype(Member)>);
    delegate<void(basic_registry<Entity> &, const Entity)> func;
    func.template connect<Member>(reg.template get<member_class_t<decltype(Member)>>(entt));
    func(reg, entt);
}


}


#endif

// #include "entity/observer.hpp"
#ifndef ENTT_ENTITY_OBSERVER_HPP
#define ENTT_ENTITY_OBSERVER_HPP


#include <limits>
#include <cstddef>
#include <cstdint>
#include <utility>
#include <type_traits>
// #include "../config/config.h"

// #include "../core/type_traits.hpp"

// #include "registry.hpp"

// #include "storage.hpp"

// #include "utility.hpp"

// #include "entity.hpp"

// #include "fwd.hpp"



namespace entt {


/*! @brief Grouping matcher. */
template<typename...>
struct matcher {};


/**
 * @brief Collector.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error, but for a few reasonable cases.
 */
template<typename...>
struct basic_collector;


/**
 * @brief Collector.
 *
 * A collector contains a set of rules (literally, matchers) to use to track
 * entities.<br/>
 * Its main purpose is to generate a descriptor that allows an observer to know
 * how to connect to a registry.
 */
template<>
struct basic_collector<> {
    /**
     * @brief Adds a grouping matcher to the collector.
     * @tparam AllOf Types of components tracked by the matcher.
     * @tparam NoneOf Types of components used to filter out entities.
     * @return The updated collector.
     */
    template<typename... AllOf, typename... NoneOf>
    static constexpr auto group(exclude_t<NoneOf...> = {}) ENTT_NOEXCEPT {
        return basic_collector<matcher<type_list<>, type_list<>, type_list<NoneOf...>, AllOf...>>{};
    }

    /**
     * @brief Adds an observing matcher to the collector.
     * @tparam AnyOf Type of component for which changes should be detected.
     * @return The updated collector.
     */
    template<typename AnyOf>
    static constexpr auto update() ENTT_NOEXCEPT {
        return basic_collector<matcher<type_list<>, type_list<>, AnyOf>>{};
    }

    /*! @copydoc update */
    template<typename AnyOf>
    [[deprecated("use ::update instead")]]
    static constexpr auto replace() ENTT_NOEXCEPT {
        return update<AnyOf>();
    }
};

/**
 * @brief Collector.
 * @copydetails basic_collector<>
 * @tparam Reject Untracked types used to filter out entities.
 * @tparam Require Untracked types required by the matcher.
 * @tparam Rule Specific details of the current matcher.
 * @tparam Other Other matchers.
 */
template<typename... Reject, typename... Require, typename... Rule, typename... Other>
struct basic_collector<matcher<type_list<Reject...>, type_list<Require...>, Rule...>, Other...> {
    /*! @brief Current matcher. */
    using current_type = matcher<type_list<Reject...>, type_list<Require...>, Rule...>;

    /**
     * @brief Adds a grouping matcher to the collector.
     * @tparam AllOf Types of components tracked by the matcher.
     * @tparam NoneOf Types of components used to filter out entities.
     * @return The updated collector.
     */
    template<typename... AllOf, typename... NoneOf>
    static constexpr auto group(exclude_t<NoneOf...> = {}) ENTT_NOEXCEPT {
        return basic_collector<matcher<type_list<>, type_list<>, type_list<NoneOf...>, AllOf...>, current_type, Other...>{};
    }

    /**
     * @brief Adds an observing matcher to the collector.
     * @tparam AnyOf Type of component for which changes should be detected.
     * @return The updated collector.
     */
    template<typename AnyOf>
    static constexpr auto update() ENTT_NOEXCEPT {
        return basic_collector<matcher<type_list<>, type_list<>, AnyOf>, current_type, Other...>{};
    }

    /*! @copydoc update */
    template<typename AnyOf>
    [[deprecated("use ::update instead")]]
    static constexpr auto replace() ENTT_NOEXCEPT {
        return update<AnyOf>();
    }


    /**
     * @brief Updates the filter of the last added matcher.
     * @tparam AllOf Types of components required by the matcher.
     * @tparam NoneOf Types of components used to filter out entities.
     * @return The updated collector.
     */
    template<typename... AllOf, typename... NoneOf>
    static constexpr auto where(exclude_t<NoneOf...> = {}) ENTT_NOEXCEPT {
        using extended_type = matcher<type_list<Reject..., NoneOf...>, type_list<Require..., AllOf...>, Rule...>;
        return basic_collector<extended_type, Other...>{};
    }
};


/*! @brief Variable template used to ease the definition of collectors. */
inline constexpr basic_collector<> collector{};


/**
 * @brief Observer.
 *
 * An observer returns all the entities and only the entities that fit the
 * requirements of at least one matcher. Moreover, it's guaranteed that the
 * entity list is tightly packed in memory for fast iterations.<br/>
 * In general, observers don't stay true to the order of any set of components.
 *
 * Observers work mainly with two types of matchers, provided through a
 * collector:
 *
 * * Observing matcher: an observer will return at least all the living entities
 *   for which one or more of the given components have been updated and not yet
 *   destroyed.
 * * Grouping matcher: an observer will return at least all the living entities
 *   that would have entered the given group if it existed and that would have
 *   not yet left it.
 *
 * If an entity respects the requirements of multiple matchers, it will be
 * returned once and only once by the observer in any case.
 *
 * Matchers support also filtering by means of a _where_ clause that accepts
 * both a list of types and an exclusion list.<br/>
 * Whenever a matcher finds that an entity matches its requirements, the
 * condition of the filter is verified before to register the entity itself.
 * Moreover, a registered entity isn't returned by the observer if the condition
 * set by the filter is broken in the meantime.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New instances of the given components are created and assigned to entities.
 * * The entity currently pointed is modified (as an example, if one of the
 *   given components is removed from the entity to which the iterator points).
 * * The entity currently pointed is destroyed.
 *
 * In all the other cases, modifying the pools of the given components in any
 * way invalidates all the iterators and using them results in undefined
 * behavior.
 *
 * @warning
 * Lifetime of an observer doesn't necessarily have to overcome that of the
 * registry to which it is connected. However, the observer must be disconnected
 * from the registry before being destroyed to avoid crashes due to dangling
 * pointers.
 *
 * @tparam Entity A valid entity type (see entt_traits for more details).
 */
template<typename Entity>
class basic_observer {
    using payload_type = std::uint32_t;

    template<typename>
    struct matcher_handler;

    template<typename... Reject, typename... Require, typename AnyOf>
    struct matcher_handler<matcher<type_list<Reject...>, type_list<Require...>, AnyOf>> {
        template<std::size_t Index>
        static void maybe_valid_if(basic_observer &obs, const basic_registry<Entity> &reg, const Entity entt) {
            if(reg.template has<Require...>(entt) && !reg.template any<Reject...>(entt)) {
                if(auto *comp = obs.view.try_get(entt); !comp) {
                    obs.view.emplace(entt);
                }

                obs.view.get(entt) |= (1 << Index);
            }
        }

        template<std::size_t Index>
        static void discard_if(basic_observer &obs, const basic_registry<Entity> &, const Entity entt) {
            if(auto *value = obs.view.try_get(entt); value && !(*value &= (~(1 << Index)))) {
                obs.view.erase(entt);
            }
        }

        template<std::size_t Index>
        static void connect(basic_observer &obs, basic_registry<Entity> &reg) {
            (reg.template on_destroy<Require>().template connect<&discard_if<Index>>(obs), ...);
            (reg.template on_construct<Reject>().template connect<&discard_if<Index>>(obs), ...);
            reg.template on_update<AnyOf>().template connect<&maybe_valid_if<Index>>(obs);
            reg.template on_destroy<AnyOf>().template connect<&discard_if<Index>>(obs);
        }

        static void disconnect(basic_observer &obs, basic_registry<Entity> &reg) {
            (reg.template on_destroy<Require>().disconnect(obs), ...);
            (reg.template on_construct<Reject>().disconnect(obs), ...);
            reg.template on_update<AnyOf>().disconnect(obs);
            reg.template on_destroy<AnyOf>().disconnect(obs);
        }
    };

    template<typename... Reject, typename... Require, typename... NoneOf, typename... AllOf>
    struct matcher_handler<matcher<type_list<Reject...>, type_list<Require...>, type_list<NoneOf...>, AllOf...>> {
        template<std::size_t Index>
        static void maybe_valid_if(basic_observer &obs, const basic_registry<Entity> &reg, const Entity entt) {
            if(reg.template has<AllOf..., Require...>(entt) && !reg.template any<NoneOf..., Reject...>(entt)) {
                if(auto *comp = obs.view.try_get(entt); !comp) {
                    obs.view.emplace(entt);
                }

                obs.view.get(entt) |= (1 << Index);
            }
        }

        template<std::size_t Index>
        static void discard_if(basic_observer &obs, const basic_registry<Entity> &, const Entity entt) {
            if(auto *value = obs.view.try_get(entt); value && !(*value &= (~(1 << Index)))) {
                obs.view.erase(entt);
            }
        }

        template<std::size_t Index>
        static void connect(basic_observer &obs, basic_registry<Entity> &reg) {
            (reg.template on_destroy<Require>().template connect<&discard_if<Index>>(obs), ...);
            (reg.template on_construct<Reject>().template connect<&discard_if<Index>>(obs), ...);
            (reg.template on_construct<AllOf>().template connect<&maybe_valid_if<Index>>(obs), ...);
            (reg.template on_destroy<NoneOf>().template connect<&maybe_valid_if<Index>>(obs), ...);
            (reg.template on_destroy<AllOf>().template connect<&discard_if<Index>>(obs), ...);
            (reg.template on_construct<NoneOf>().template connect<&discard_if<Index>>(obs), ...);
        }

        static void disconnect(basic_observer &obs, basic_registry<Entity> &reg) {
            (reg.template on_destroy<Require>().disconnect(obs), ...);
            (reg.template on_construct<Reject>().disconnect(obs), ...);
            (reg.template on_construct<AllOf>().disconnect(obs), ...);
            (reg.template on_destroy<NoneOf>().disconnect(obs), ...);
            (reg.template on_destroy<AllOf>().disconnect(obs), ...);
            (reg.template on_construct<NoneOf>().disconnect(obs), ...);
        }
    };

    template<typename... Matcher>
    static void disconnect(basic_observer &obs, basic_registry<Entity> &reg) {
        (matcher_handler<Matcher>::disconnect(obs, reg), ...);
    }

    template<typename... Matcher, std::size_t... Index>
    void connect(basic_registry<Entity> &reg, std::index_sequence<Index...>) {
        static_assert(sizeof...(Matcher) < std::numeric_limits<payload_type>::digits);
        (matcher_handler<Matcher>::template connect<Index>(*this, reg), ...);
        release = &basic_observer::disconnect<Matcher...>;
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Input iterator type. */
    using iterator = typename sparse_set<Entity>::iterator;

    /*! @brief Default constructor. */
    basic_observer()
        : target{}, release{}, view{}
    {}

    /*! @brief Default copy constructor, deleted on purpose. */
    basic_observer(const basic_observer &) = delete;
    /*! @brief Default move constructor, deleted on purpose. */
    basic_observer(basic_observer &&) = delete;

    /**
     * @brief Creates an observer and connects it to a given registry.
     * @tparam Matcher Types of matchers to use to initialize the observer.
     * @param reg A valid reference to a registry.
     */
    template<typename... Matcher>
    basic_observer(basic_registry<entity_type> &reg, basic_collector<Matcher...>)
        : target{&reg},
          release{},
          view{}
    {
        connect<Matcher...>(reg, std::index_sequence_for<Matcher...>{});
    }

    /*! @brief Default destructor. */
    ~basic_observer() = default;

    /**
     * @brief Default copy assignment operator, deleted on purpose.
     * @return This observer.
     */
    basic_observer & operator=(const basic_observer &) = delete;

    /**
     * @brief Default move assignment operator, deleted on purpose.
     * @return This observer.
     */
    basic_observer & operator=(basic_observer &&) = delete;

    /**
     * @brief Connects an observer to a given registry.
     * @tparam Matcher Types of matchers to use to initialize the observer.
     * @param reg A valid reference to a registry.
     */
    template<typename... Matcher>
    void connect(basic_registry<entity_type> &reg, basic_collector<Matcher...>) {
        disconnect();
        connect<Matcher...>(reg, std::index_sequence_for<Matcher...>{});
        target = &reg;
        view.clear();
    }

    /*! @brief Disconnects an observer from the registry it keeps track of. */
    void disconnect() {
        if(release) {
            release(*this, *target);
            release = nullptr;
        }
    }

    /**
     * @brief Returns the number of elements in an observer.
     * @return Number of elements.
     */
    size_type size() const ENTT_NOEXCEPT {
        return view.size();
    }

    /**
     * @brief Checks whether an observer is empty.
     * @return True if the observer is empty, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return view.empty();
    }

    /**
     * @brief Direct access to the list of entities of the observer.
     *
     * The returned pointer is such that range `[data(), data() + size()]` is
     * always a valid range, even if the container is empty.
     *
     * @note
     * There are no guarantees on the order of the entities. Use `begin` and
     * `end` if you want to iterate the observer in the expected order.
     *
     * @return A pointer to the array of entities.
     */
    const entity_type * data() const ENTT_NOEXCEPT {
        return view.data();
    }

    /**
     * @brief Returns an iterator to the first entity of the observer.
     *
     * The returned iterator points to the first entity of the observer. If the
     * container is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first entity of the observer.
     */
    iterator begin() const ENTT_NOEXCEPT {
        return view.sparse_set<entity_type>::begin();
    }

    /**
     * @brief Returns an iterator that is past the last entity of the observer.
     *
     * The returned iterator points to the entity following the last entity of
     * the observer. Attempting to dereference the returned iterator results in
     * undefined behavior.
     *
     * @return An iterator to the entity following the last entity of the
     * observer.
     */
    iterator end() const ENTT_NOEXCEPT {
        return view.sparse_set<entity_type>::end();
    }

    /*! @brief Clears the underlying container. */
    void clear() ENTT_NOEXCEPT {
        view.clear();
    }

    /**
     * @brief Iterates entities and applies the given function object to them.
     *
     * The function object is invoked for each entity.<br/>
     * The signature of the function must be equivalent to the following form:
     *
     * @code{.cpp}
     * void(const entity_type);
     * @endcode
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        static_assert(std::is_invocable_v<Func, entity_type>);

        for(const auto entity: *this) {
            func(entity);
        }
    }

    /**
     * @brief Iterates entities and applies the given function object to them,
     * then clears the observer.
     *
     * @sa each
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) {
        std::as_const(*this).each(std::move(func));
        clear();
    }

private:
    basic_registry<entity_type> *target;
    void(* release)(basic_observer &, basic_registry<entity_type> &);
    storage<entity_type, payload_type> view;
};


}


#endif

// #include "entity/registry.hpp"

// #include "entity/runtime_view.hpp"

// #include "entity/snapshot.hpp"

// #include "entity/sparse_set.hpp"

// #include "entity/storage.hpp"

// #include "entity/utility.hpp"

// #include "entity/view.hpp"

// #include "locator/locator.hpp"
#ifndef ENTT_LOCATOR_LOCATOR_HPP
#define ENTT_LOCATOR_LOCATOR_HPP


#include <memory>
#include <utility>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/**
 * @brief Service locator, nothing more.
 *
 * A service locator can be used to do what it promises: locate services.<br/>
 * Usually service locators are tightly bound to the services they expose and
 * thus it's hard to define a general purpose class to do that. This template
 * based implementation tries to fill the gap and to get rid of the burden of
 * defining a different specific locator for each application.
 *
 * @tparam Service Type of service managed by the locator.
 */
template<typename Service>
struct service_locator {
    /*! @brief Type of service offered. */
    using service_type = Service;

    /*! @brief Default constructor, deleted on purpose. */
    service_locator() = delete;
    /*! @brief Default destructor, deleted on purpose. */
    ~service_locator() = delete;

    /**
     * @brief Tests if a valid service implementation is set.
     * @return True if the service is set, false otherwise.
     */
    static bool empty() ENTT_NOEXCEPT {
        return !static_cast<bool>(service);
    }

    /**
     * @brief Returns a weak pointer to a service implementation, if any.
     *
     * Clients of a service shouldn't retain references to it. The recommended
     * way is to retrieve the service implementation currently set each and
     * every time the need of using it arises. Otherwise users can incur in
     * unexpected behaviors.
     *
     * @return A reference to the service implementation currently set, if any.
     */
    static std::weak_ptr<Service> get() ENTT_NOEXCEPT {
        return service;
    }

    /**
     * @brief Returns a weak reference to a service implementation, if any.
     *
     * Clients of a service shouldn't retain references to it. The recommended
     * way is to retrieve the service implementation currently set each and
     * every time the need of using it arises. Otherwise users can incur in
     * unexpected behaviors.
     *
     * @warning
     * In case no service implementation has been set, a call to this function
     * results in undefined behavior.
     *
     * @return A reference to the service implementation currently set, if any.
     */
    static Service & ref() ENTT_NOEXCEPT {
        return *service;
    }

    /**
     * @brief Sets or replaces a service.
     * @tparam Impl Type of the new service to use.
     * @tparam Args Types of arguments to use to construct the service.
     * @param args Parameters to use to construct the service.
     */
    template<typename Impl = Service, typename... Args>
    static void set(Args &&... args) {
        service = std::make_shared<Impl>(std::forward<Args>(args)...);
    }

    /**
     * @brief Sets or replaces a service.
     * @param ptr Service to use to replace the current one.
     */
    static void set(std::shared_ptr<Service> ptr) {
        ENTT_ASSERT(static_cast<bool>(ptr));
        service = std::move(ptr);
    }

    /**
     * @brief Resets a service.
     *
     * The service is no longer valid after a reset.
     */
    static void reset() {
        service.reset();
    }

private:
    inline static std::shared_ptr<Service> service = nullptr;
};


}


#endif

// #include "meta/factory.hpp"
#ifndef ENTT_META_FACTORY_HPP
#define ENTT_META_FACTORY_HPP


#include <array>
#include <cstddef>
#include <functional>
#include <tuple>
#include <type_traits>
#include <utility>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif

// #include "../core/fwd.hpp"
#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP


// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;


}


#endif

// #include "../core/type_info.hpp"
#ifndef ENTT_CORE_TYPE_INFO_HPP
#define ENTT_CORE_TYPE_INFO_HPP


// #include "../config/config.h"

// #include "../core/attribute.h"
#ifndef ENTT_CORE_ATTRIBUTE_H
#define ENTT_CORE_ATTRIBUTE_H


#ifndef ENTT_EXPORT
#   if defined _WIN32 || defined __CYGWIN__ || defined _MSC_VER
#       define ENTT_EXPORT __declspec(dllexport)
#       define ENTT_IMPORT __declspec(dllimport)
#       define ENTT_HIDDEN
#   elif defined __GNUC__ && __GNUC__ >= 4
#       define ENTT_EXPORT __attribute__((visibility("default")))
#       define ENTT_IMPORT __attribute__((visibility("default")))
#       define ENTT_HIDDEN __attribute__((visibility("hidden")))
#   else /* Unsupported compiler */
#       define ENTT_EXPORT
#       define ENTT_IMPORT
#       define ENTT_HIDDEN
#   endif
#endif


#ifndef ENTT_API
#   if defined ENTT_API_EXPORT
#       define ENTT_API ENTT_EXPORT
#   elif defined ENTT_API_IMPORT
#       define ENTT_API ENTT_IMPORT
#   else /* No API */
#       define ENTT_API
#   endif
#endif


#endif

// #include "hashed_string.hpp"
#ifndef ENTT_CORE_HASHED_STRING_HPP
#define ENTT_CORE_HASHED_STRING_HPP


#include <cstddef>
#include <cstdint>
// #include "../config/config.h"

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename>
struct fnv1a_traits;


template<>
struct fnv1a_traits<std::uint32_t> {
    using type = std::uint32_t;
    static constexpr std::uint32_t offset = 2166136261;
    static constexpr std::uint32_t prime = 16777619;
};


template<>
struct fnv1a_traits<std::uint64_t> {
    using type = std::uint64_t;
    static constexpr std::uint64_t offset = 14695981039346656037ull;
    static constexpr std::uint64_t prime = 1099511628211ull;
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Zero overhead unique identifier.
 *
 * A hashed string is a compile-time tool that allows users to use
 * human-readable identifers in the codebase while using their numeric
 * counterparts at runtime.<br/>
 * Because of that, a hashed string can also be used in constant expressions if
 * required.
 *
 * @tparam Char Character type.
 */
template<typename Char>
class basic_hashed_string {
    using traits_type = internal::fnv1a_traits<id_type>;

    struct const_wrapper {
        // non-explicit constructor on purpose
        constexpr const_wrapper(const Char *curr) ENTT_NOEXCEPT: str{curr} {}
        const Char *str;
    };

    // Fowler–Noll–Vo hash function v. 1a - the good
    static constexpr id_type helper(const Char *curr) ENTT_NOEXCEPT {
        auto value = traits_type::offset;

        while(*curr != 0) {
            value = (value ^ static_cast<traits_type::type>(*(curr++))) * traits_type::prime;
        }

        return value;
    }

public:
    /*! @brief Character type. */
    using value_type = Char;
    /*! @brief Unsigned integer type. */
    using hash_type = id_type;

    /**
     * @brief Returns directly the numeric representation of a string.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * const auto value = basic_hashed_string<char>::to_value("my.png");
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifer.
     * @return The numeric representation of the string.
     */
    template<std::size_t N>
    static constexpr hash_type value(const value_type (&str)[N]) ENTT_NOEXCEPT {
        return helper(str);
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     * @return The numeric representation of the string.
     */
    static hash_type value(const_wrapper wrapper) ENTT_NOEXCEPT {
        return helper(wrapper.str);
    }

    /**
     * @brief Returns directly the numeric representation of a string view.
     * @param str Human-readable identifer.
     * @param size Length of the string to hash.
     * @return The numeric representation of the string.
     */
    static hash_type value(const value_type *str, std::size_t size) ENTT_NOEXCEPT {
        id_type partial{traits_type::offset};
        while(size--) { partial = (partial^(str++)[0])*traits_type::prime; }
        return partial;
    }

    /*! @brief Constructs an empty hashed string. */
    constexpr basic_hashed_string() ENTT_NOEXCEPT
        : str{nullptr}, hash{}
    {}

    /**
     * @brief Constructs a hashed string from an array of const characters.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * basic_hashed_string<char> hs{"my.png"};
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param curr Human-readable identifer.
     */
    template<std::size_t N>
    constexpr basic_hashed_string(const value_type (&curr)[N]) ENTT_NOEXCEPT
        : str{curr}, hash{helper(curr)}
    {}

    /**
     * @brief Explicit constructor on purpose to avoid constructing a hashed
     * string directly from a `const value_type *`.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     */
    explicit constexpr basic_hashed_string(const_wrapper wrapper) ENTT_NOEXCEPT
        : str{wrapper.str}, hash{helper(wrapper.str)}
    {}

    /**
     * @brief Returns the human-readable representation of a hashed string.
     * @return The string used to initialize the instance.
     */
    constexpr const value_type * data() const ENTT_NOEXCEPT {
        return str;
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr hash_type value() const ENTT_NOEXCEPT {
        return hash;
    }

    /*! @copydoc data */
    constexpr operator const value_type *() const ENTT_NOEXCEPT { return data(); }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr operator hash_type() const ENTT_NOEXCEPT { return value(); }

    /**
     * @brief Compares two hashed strings.
     * @param other Hashed string with which to compare.
     * @return True if the two hashed strings are identical, false otherwise.
     */
    constexpr bool operator==(const basic_hashed_string &other) const ENTT_NOEXCEPT {
        return hash == other.hash;
    }

private:
    const value_type *str;
    hash_type hash;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the character type of the hashed string directly from a
 * human-readable identifer provided to the constructor.
 *
 * @tparam Char Character type.
 * @tparam N Number of characters of the identifier.
 * @param str Human-readable identifer.
 */
template<typename Char, std::size_t N>
basic_hashed_string(const Char (&str)[N]) ENTT_NOEXCEPT
-> basic_hashed_string<Char>;


/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings are identical, false otherwise.
 */
template<typename Char>
constexpr bool operator!=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/*! @brief Aliases for common character types. */
using hashed_string = basic_hashed_string<char>;


/*! @brief Aliases for common character types. */
using hashed_wstring = basic_hashed_string<wchar_t>;


}


/**
 * @brief User defined literal for hashed strings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed string.
 */
constexpr entt::hashed_string operator"" ENTT_HS_SUFFIX(const char *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_string{str};
}


/**
 * @brief User defined literal for hashed wstrings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed wstring.
 */
constexpr entt::hashed_wstring operator"" ENTT_HWS_SUFFIX(const wchar_t *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_wstring{str};
}


#endif

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


struct ENTT_API type_index {
    static id_type next() ENTT_NOEXCEPT {
        static ENTT_MAYBE_ATOMIC(id_type) value{};
        return value++;
    }
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Type index.
 * @tparam Type Type for which to generate a sequential identifier.
 */
template<typename Type, typename = void>
struct ENTT_API type_index {
    /**
     * @brief Returns the sequential identifier of a given type.
     * @return The sequential identifier of a given type.
     */
    static id_type value() ENTT_NOEXCEPT {
        static const id_type value = internal::type_index::next();
        return value;
    }
};


/**
 * @brief Provides the member constant `value` to true if a given type is
 * indexable, false otherwise.
 * @tparam Type Potentially indexable type.
 */
template<typename, typename = void>
struct has_type_index: std::false_type {};


/*! @brief has_type_index */
template<typename Type>
struct has_type_index<Type, std::void_t<decltype(type_index<Type>::value())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially indexable type.
 */
template<typename Type>
inline constexpr bool has_type_index_v = has_type_index<Type>::value;


/**
 * @brief Type info.
 * @tparam Type Type for which to generate information.
 */
template<typename Type, typename = void>
struct ENTT_API type_info {
    /**
     * @brief Returns the numeric representation of a given type.
     * @return The numeric representation of the given type.
     */
#if defined ENTT_PRETTY_FUNCTION
    static ENTT_PRETTY_FUNCTION_CONSTEXPR() id_type id() ENTT_NOEXCEPT {
        ENTT_PRETTY_FUNCTION_CONSTEXPR(static const) auto value = entt::hashed_string::value(ENTT_PRETTY_FUNCTION);
        return value;
    }
#else
    static id_type id() ENTT_NOEXCEPT {
        return type_index<Type>::value();
    }
#endif
};


}


#endif

// #include "../core/type_traits.hpp"
#ifndef ENTT_CORE_TYPE_TRAITS_HPP
#define ENTT_CORE_TYPE_TRAITS_HPP


#include <cstddef>
#include <utility>
#include <type_traits>
// #include "../config/config.h"

// #include "hashed_string.hpp"

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Wraps a static constant.
 * @tparam Value A static constant.
 */
template<auto Value>
using integral_constant = std::integral_constant<decltype(Value), Value>;


/**
 * @brief Alias template to ease the creation of named values.
 * @tparam Value A constant value at least convertible to `id_type`.
 */
template<id_type Value>
using tag = integral_constant<Value>;


/**
 * @brief Utility class to disambiguate overloaded functions.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
struct choice_t
        // Unfortunately, doxygen cannot parse such a construct.
        /*! @cond TURN_OFF_DOXYGEN */
        : choice_t<N-1>
        /*! @endcond TURN_OFF_DOXYGEN */
{};


/*! @copybrief choice_t */
template<>
struct choice_t<0> {};


/**
 * @brief Variable template for the choice trick.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
inline constexpr choice_t<N> choice{};


/*! @brief A class to use to push around lists of types, nothing more. */
template<typename...>
struct type_list {};


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_size;


/**
 * @brief Compile-time number of elements in a type list.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_size<type_list<Type...>>
        : std::integral_constant<std::size_t, sizeof...(Type)>
{};


/**
 * @brief Helper variable template.
 * @tparam List Type list.
 */
template<class List>
inline constexpr auto type_list_size_v = type_list_size<List>::value;


/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct type_list_cat;


/*! @brief Concatenates multiple type lists. */
template<>
struct type_list_cat<> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<>;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 * @tparam List Other type lists, if any.
 */
template<typename... Type, typename... Other, typename... List>
struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_cat<type_list<Type...>> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<Type...>;
};


/**
 * @brief Helper type.
 * @tparam List Type lists to concatenate.
 */
template<typename... List>
using type_list_cat_t = typename type_list_cat<List...>::type;


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_unique;


/**
 * @brief Removes duplicates types from a type list.
 * @tparam Type One of the types provided by the given type list.
 * @tparam Other The other types provided by the given type list.
 */
template<typename Type, typename... Other>
struct type_list_unique<type_list<Type, Other...>> {
    /*! @brief A type list without duplicate types. */
    using type = std::conditional_t<
        std::disjunction_v<std::is_same<Type, Other>...>,
        typename type_list_unique<type_list<Other...>>::type,
        type_list_cat_t<type_list<Type>, typename type_list_unique<type_list<Other...>>::type>
    >;
};


/*! @brief Removes duplicates types from a type list. */
template<>
struct type_list_unique<type_list<>> {
    /*! @brief A type list without duplicate types. */
    using type = type_list<>;
};


/**
 * @brief Helper type.
 * @tparam Type A type list.
 */
template<typename Type>
using type_list_unique_t = typename type_list_unique<Type>::type;


/**
 * @brief Provides the member constant `value` to true if a given type is
 * equality comparable, false otherwise.
 * @tparam Type Potentially equality comparable type.
 */
template<typename Type, typename = std::void_t<>>
struct is_equality_comparable: std::false_type {};


/*! @copydoc is_equality_comparable */
template<typename Type>
struct is_equality_comparable<Type, std::void_t<decltype(std::declval<Type>() == std::declval<Type>())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially equality comparable type.
 */
template<class Type>
inline constexpr auto is_equality_comparable_v = is_equality_comparable<Type>::value;


/**
 * @brief Extracts the class of a non-static member object or function.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
class member_class {
    static_assert(std::is_member_pointer_v<Member>);

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...));

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...) const);

    template<typename Class, typename Type>
    static Class * clazz(Type Class:: *);

public:
    /*! @brief The class of the given non-static member object or function. */
    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
};


/**
 * @brief Helper type.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
using member_class_t = typename member_class<Member>::type;


}


/**
 * @brief Defines an enum class to use for opaque identifiers and a dedicate
 * `to_integer` function to convert the identifiers to their underlying type.
 * @param clazz The name to use for the enum class.
 * @param type The underlying type for the enum class.
 */
#define ENTT_OPAQUE_TYPE(clazz, type)\
    enum class clazz: type {};\
    constexpr auto to_integral(const clazz id) ENTT_NOEXCEPT {\
        return static_cast<std::underlying_type_t<clazz>>(id);\
    }\
    static_assert(true)


#endif

// #include "../core/utility.hpp"
#ifndef ENTT_CORE_UTILITY_HPP
#define ENTT_CORE_UTILITY_HPP


#include <utility>
// #include "../config/config.h"



namespace entt {


/*! @brief Identity function object (waiting for C++20). */
struct identity {
    /**
     * @brief Returns its argument unchanged.
     * @tparam Type Type of the argument.
     * @param value The actual argument.
     * @return The submitted value as-is.
     */
    template<class Type>
    constexpr Type && operator()(Type &&value) const ENTT_NOEXCEPT {
        return std::forward<Type>(value);
    }
};


/**
 * @brief Constant utility to disambiguate overloaded members of a class.
 * @tparam Type Type of the desired overload.
 * @tparam Class Type of class to which the member belongs.
 * @param member A valid pointer to a member.
 * @return Pointer to the member.
 */
template<typename Type, typename Class>
constexpr auto overload(Type Class:: *member) ENTT_NOEXCEPT { return member; }


/**
 * @brief Constant utility to disambiguate overloaded functions.
 * @tparam Func Function type of the desired overload.
 * @param func A valid pointer to a function.
 * @return Pointer to the function.
 */
template<typename Func>
constexpr auto overload(Func *func) ENTT_NOEXCEPT { return func; }


/**
 * @brief Helper type for visitors.
 * @tparam Func Types of function objects.
 */
template<class... Func>
struct overloaded: Func... {
    using Func::operator()...;
};


/**
 * @brief Deduction guide.
 * @tparam Func Types of function objects.
 */
template<class... Func>
overloaded(Func...) -> overloaded<Func...>;


/**
 * @brief Basic implementation of a y-combinator.
 * @tparam Func Type of a potentially recursive function.
 */
template<class Func>
struct y_combinator {
    /**
     * @brief Constructs a y-combinator from a given function.
     * @param recursive A potentially recursive function.
     */
    y_combinator(Func recursive):
        func{std::move(recursive)}
    {}

    /**
     * @brief Invokes a y-combinator and therefore its underlying function.
     * @tparam Args Types of arguments to use to invoke the underlying function.
     * @param args Parameters to use to invoke the underlying function.
     * @return Return value of the underlying function, if any.
     */
    template <class... Args>
    decltype(auto) operator()(Args &&... args) const {
        return func(*this, std::forward<Args>(args)...);
    }

    /*! @copydoc operator()() */
    template <class... Args>
    decltype(auto) operator()(Args &&... args) {
        return func(*this, std::forward<Args>(args)...);
    }

private:
    Func func;
};


}


#endif

// #include "meta.hpp"
#ifndef ENTT_META_META_HPP
#define ENTT_META_META_HPP


#include <cstddef>
#include <functional>
#include <type_traits>
#include <utility>
// #include "../config/config.h"

// #include "../core/fwd.hpp"

// #include "../core/type_info.hpp"

// #include "../core/type_traits.hpp"



namespace entt {


class meta_any;
class meta_type;


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


struct meta_type_node;


struct meta_prop_node {
    meta_prop_node * next;
    meta_any(* const key)();
    meta_any(* const value)();
};


struct meta_base_node {
    meta_type_node * const parent;
    meta_base_node * next;
    meta_type_node *(* const type)() ENTT_NOEXCEPT;
    void *(* const cast)(void *) ENTT_NOEXCEPT;
};


struct meta_conv_node {
    meta_type_node * const parent;
    meta_conv_node * next;
    meta_type_node *(* const type)() ENTT_NOEXCEPT;
    meta_any(* const conv)(const void *);
};


struct meta_ctor_node {
    using size_type = std::size_t;
    meta_type_node * const parent;
    meta_ctor_node * next;
    meta_prop_node * prop;
    const size_type size;
    meta_type_node *(* const arg)(size_type) ENTT_NOEXCEPT;
    meta_any(* const invoke)(meta_any * const);
};


struct meta_dtor_node {
    meta_type_node * const parent;
    void(* const invoke)(void *);
};


struct meta_data_node {
    id_type id;
    meta_type_node * const parent;
    meta_data_node * next;
    meta_prop_node * prop;
    const bool is_const;
    const bool is_static;
    meta_type_node *(* const type)() ENTT_NOEXCEPT;
    bool(* const set)(meta_any, meta_any, meta_any);
    meta_any(* const get)(meta_any, meta_any);
};


struct meta_func_node {
    using size_type = std::size_t;
    id_type id;
    meta_type_node * const parent;
    meta_func_node * next;
    meta_prop_node * prop;
    const size_type size;
    const bool is_const;
    const bool is_static;
    meta_type_node *(* const ret)() ENTT_NOEXCEPT;
    meta_type_node *(* const arg)(size_type) ENTT_NOEXCEPT;
    meta_any(* const invoke)(meta_any, meta_any *);
};


struct meta_type_node {
    using size_type = std::size_t;
    const id_type type_id;
    id_type id;
    meta_type_node * next;
    meta_prop_node * prop;
    const bool is_void;
    const bool is_integral;
    const bool is_floating_point;
    const bool is_array;
    const bool is_enum;
    const bool is_union;
    const bool is_class;
    const bool is_pointer;
    const bool is_function_pointer;
    const bool is_member_object_pointer;
    const bool is_member_function_pointer;
    const size_type extent;
    bool(* const compare)(const void *, const void *);
    meta_type_node *(* const remove_pointer)() ENTT_NOEXCEPT;
    meta_type_node *(* const remove_extent)() ENTT_NOEXCEPT;
    meta_base_node *base{nullptr};
    meta_conv_node *conv{nullptr};
    meta_ctor_node *ctor{nullptr};
    meta_dtor_node *dtor{nullptr};
    meta_data_node *data{nullptr};
    meta_func_node *func{nullptr};
};


template<typename Type, typename Op, typename Node>
void visit(Op &op, Node *node) {
    while(node) {
        op(Type{node});
        node = node->next;
    }
}


template<auto Member, typename Type, typename Op>
void visit(Op &op, const internal::meta_type_node *node) {
    if(node) {
        internal::visit<Type>(op, node->*Member);
        auto *next = node->base;

        while(next) {
            visit<Member, Type>(op, next->type());
            next = next->next;
        }
    }
}


template<typename Op, typename Node>
auto find_if(const Op &op, Node *node) {
    while(node && !op(node)) {
        node = node->next;
    }

    return node;
}


template<auto Member, typename Op>
auto find_if(const Op &op, const meta_type_node *node)
-> decltype(find_if(op, node->*Member)) {
    decltype(find_if(op, node->*Member)) ret = nullptr;

    if(node) {
        ret = find_if(op, node->*Member);
        auto *next = node->base;

        while(next && !ret) {
            ret = find_if<Member>(op, next->type());
            next = next->next;
        }
    }

    return ret;
}


template<typename Type>
bool compare(const void *lhs, const void *rhs) {
    if constexpr(!std::is_function_v<Type> && is_equality_comparable_v<Type>) {
        return *static_cast<const Type *>(lhs) == *static_cast<const Type *>(rhs);
    } else {
        return lhs == rhs;
    }
}


struct ENTT_API meta_context {
    inline static meta_type_node *local = nullptr;
    inline static meta_type_node **global = &local;

    static void detach(const meta_type_node *node) ENTT_NOEXCEPT {
        auto **it = global;

        while(*it && *it != node) {
            it = &(*it)->next;
        }

        if(*it) {
            *it = (*it)->next;
        }
    }
};


template<typename Type>
struct ENTT_API meta_node {
    static_assert(std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<Type>>>);

    static meta_type_node * resolve() ENTT_NOEXCEPT {
        static meta_type_node node{
            type_info<Type>::id(),
            {},
            nullptr,
            nullptr,
            std::is_void_v<Type>,
            std::is_integral_v<Type>,
            std::is_floating_point_v<Type>,
            std::is_array_v<Type>,
            std::is_enum_v<Type>,
            std::is_union_v<Type>,
            std::is_class_v<Type>,
            std::is_pointer_v<Type>,
            std::is_pointer_v<Type> && std::is_function_v<std::remove_pointer_t<Type>>,
            std::is_member_object_pointer_v<Type>,
            std::is_member_function_pointer_v<Type>,
            std::extent_v<Type>,
            &compare<Type>, // workaround for an issue with VS2017
            &meta_node<std::remove_const_t<std::remove_pointer_t<Type>>>::resolve,
            &meta_node<std::remove_const_t<std::remove_extent_t<Type>>>::resolve
        };

        return &node;
    }
};


template<typename... Type>
struct meta_info: meta_node<std::remove_cv_t<std::remove_reference_t<Type>>...> {};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/*! @brief Opaque container for a meta context. */
struct meta_ctx {
    /**
     * @brief Binds the meta system to the given context.
     * @param other A valid context to which to bind.
     */
    static void bind(meta_ctx other) ENTT_NOEXCEPT {
        internal::meta_context::global = other.ctx;
    }

private:
    internal::meta_type_node **ctx{&internal::meta_context::local};
};


/**
 * @brief Opaque container for values of any type.
 *
 * This class uses a technique called small buffer optimization (SBO) to get rid
 * of memory allocations if possible. This should improve overall performance.
 */
class meta_any {
    using storage_type = std::aligned_storage_t<sizeof(void *), alignof(void *)>;
    using copy_fn_type = void(meta_any &, const meta_any &);
    using steal_fn_type = void(meta_any &, meta_any &);
    using destroy_fn_type = void(meta_any &);

    template<typename Type, typename = std::void_t<>>
    struct type_traits {
        template<typename... Args>
        static void instance(meta_any &any, Args &&... args) {
            any.instance = new Type{std::forward<Args>(args)...};
            new (&any.storage) Type *{static_cast<Type *>(any.instance)};
        }

        static void destroy(meta_any &any) {
            const auto * const node = internal::meta_info<Type>::resolve();
            if(node->dtor) { node->dtor->invoke(any.instance); }
            delete static_cast<Type *>(any.instance);
        }

        static void copy(meta_any &to, const meta_any &from) {
            auto *instance = new Type{*static_cast<const Type *>(from.instance)};
            new (&to.storage) Type *{instance};
            to.instance = instance;
        }

        static void steal(meta_any &to, meta_any &from) {
            new (&to.storage) Type *{static_cast<Type *>(from.instance)};
            to.instance = from.instance;
        }
    };

    template<typename Type>
    struct type_traits<Type, std::enable_if_t<sizeof(Type) <= sizeof(void *) && std::is_nothrow_move_constructible_v<Type>>> {
        template<typename... Args>
        static void instance(meta_any &any, Args &&... args) {
            any.instance = new (&any.storage) Type{std::forward<Args>(args)...};
        }

        static void destroy(meta_any &any) {
            const auto * const node = internal::meta_info<Type>::resolve();
            if(node->dtor) { node->dtor->invoke(any.instance); }
            static_cast<Type *>(any.instance)->~Type();
        }

        static void copy(meta_any &to, const meta_any &from) {
            to.instance = new (&to.storage) Type{*static_cast<const Type *>(from.instance)};
        }

        static void steal(meta_any &to, meta_any &from) {
            to.instance = new (&to.storage) Type{std::move(*static_cast<Type *>(from.instance))};
            destroy(from);
        }
    };

    meta_any(const internal::meta_type_node *curr, void *ref) ENTT_NOEXCEPT
        : meta_any{}
    {
        node = curr;
        instance = ref;
    }

public:
    /*! @brief Default constructor. */
    meta_any() ENTT_NOEXCEPT
        : storage{},
          instance{},
          node{},
          destroy_fn{},
          copy_fn{},
          steal_fn{}
    {}

    /**
     * @brief Constructs a meta any by directly initializing the new object.
     * @tparam Type Type of object to use to initialize the container.
     * @tparam Args Types of arguments to use to construct the new instance.
     * @param args Parameters to use to construct the instance.
     */
    template<typename Type, typename... Args>
    explicit meta_any(std::in_place_type_t<Type>, [[maybe_unused]] Args &&... args)
        : meta_any{}
    {
        node = internal::meta_info<Type>::resolve();

        if constexpr(!std::is_void_v<Type>) {
            using traits_type = type_traits<std::remove_cv_t<std::remove_reference_t<Type>>>;
            traits_type::instance(*this, std::forward<Args>(args)...);
            destroy_fn = &traits_type::destroy;
            copy_fn = &traits_type::copy;
            steal_fn = &traits_type::steal;
        }
    }

    /**
     * @brief Constructs a meta any that holds an unmanaged object.
     * @tparam Type Type of object to use to initialize the container.
     * @param value An instance of an object to use to initialize the container.
     */
    template<typename Type>
    meta_any(std::reference_wrapper<Type> value)
        : meta_any{internal::meta_info<Type>::resolve(), &value.get()}
    {}

    /**
     * @brief Constructs a meta any from a given value.
     * @tparam Type Type of object to use to initialize the container.
     * @param value An instance of an object to use to initialize the container.
     */
    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, meta_any>>>
    meta_any(Type &&value)
        : meta_any{std::in_place_type<std::remove_cv_t<std::remove_reference_t<Type>>>, std::forward<Type>(value)}
    {}

    /**
     * @brief Copy constructor.
     * @param other The instance to copy from.
     */
    meta_any(const meta_any &other)
        : meta_any{}
    {
        node = other.node;
        (other.copy_fn ? other.copy_fn : [](meta_any &to, const meta_any &from) { to.instance = from.instance; })(*this, other);
        destroy_fn = other.destroy_fn;
        copy_fn = other.copy_fn;
        steal_fn = other.steal_fn;
    }

    /**
     * @brief Move constructor.
     *
     * After move construction, instances that have been moved from are placed
     * in a valid but unspecified state.
     *
     * @param other The instance to move from.
     */
    meta_any(meta_any &&other)
        : meta_any{}
    {
        swap(*this, other);
    }

    /*! @brief Frees the internal storage, whatever it means. */
    ~meta_any() {
        if(destroy_fn) {
            destroy_fn(*this);
        }
    }

    /**
     * @brief Assignment operator.
     * @tparam Type Type of object to use to initialize the container.
     * @param value An instance of an object to use to initialize the container.
     * @return This meta any object.
     */
    template<typename Type>
    meta_any & operator=(Type &&value) {
        return (*this = meta_any{std::forward<Type>(value)});
    }

    /**
     * @brief Assignment operator.
     * @param other The instance to assign from.
     * @return This meta any object.
     */
    meta_any & operator=(meta_any other) {
        swap(other, *this);
        return *this;
    }

    /**
     * @brief Returns the meta type of the underlying object.
     * @return The meta type of the underlying object, if any.
     */
    inline meta_type type() const ENTT_NOEXCEPT;

    /**
     * @brief Returns an opaque pointer to the contained instance.
     * @return An opaque pointer the contained instance, if any.
     */
    const void * data() const ENTT_NOEXCEPT {
        return instance;
    }

    /*! @copydoc data */
    void * data() ENTT_NOEXCEPT {
        return const_cast<void *>(std::as_const(*this).data());
    }

    /**
     * @brief Tries to cast an instance to a given type.
     * @tparam Type Type to which to cast the instance.
     * @return A (possibly null) pointer to the contained instance.
     */
    template<typename Type>
    const Type * try_cast() const {
        void *ret = nullptr;

        if(const auto type_id = internal::meta_info<Type>::resolve()->type_id; node && node->type_id == type_id) {
            ret = instance;
        } else if(const auto *base = internal::find_if<&internal::meta_type_node::base>([type_id](const auto *curr) { return curr->type()->type_id == type_id; }, node); base) {
            ret = base->cast(instance);
        }

        return static_cast<const Type *>(ret);
    }

    /*! @copydoc try_cast */
    template<typename Type>
    Type * try_cast() {
        return const_cast<Type *>(std::as_const(*this).try_cast<Type>());
    }

    /**
     * @brief Tries to cast an instance to a given type.
     *
     * The type of the instance must be such that the cast is possible.
     *
     * @warning
     * Attempting to perform a cast that isn't viable results in undefined
     * behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode in case
     * the cast is not feasible.
     *
     * @tparam Type Type to which to cast the instance.
     * @return A reference to the contained instance.
     */
    template<typename Type>
    const Type & cast() const {
        auto * const actual = try_cast<Type>();
        ENTT_ASSERT(actual);
        return *actual;
    }

    /*! @copydoc cast */
    template<typename Type>
    Type & cast() {
        return const_cast<Type &>(std::as_const(*this).cast<Type>());
    }

    /**
     * @brief Tries to convert an instance to a given type and returns it.
     * @tparam Type Type to which to convert the instance.
     * @return A valid meta any object if the conversion is possible, an invalid
     * one otherwise.
     */
    template<typename Type>
    meta_any convert() const {
        meta_any any{};

        if(const auto type_id = internal::meta_info<Type>::resolve()->type_id; node && node->type_id == type_id) {
            any = *this;
        } else if(const auto * const conv = internal::find_if<&internal::meta_type_node::conv>([type_id](const auto *curr) { return curr->type()->type_id == type_id; }, node); conv) {
            any = conv->conv(instance);
        }

        return any;
    }

    /**
     * @brief Tries to convert an instance to a given type.
     * @tparam Type Type to which to convert the instance.
     * @return True if the conversion is possible, false otherwise.
     */
    template<typename Type>
    bool convert() {
        bool valid = (node && node->type_id == internal::meta_info<Type>::resolve()->type_id);

        if(!valid) {
            if(auto any = std::as_const(*this).convert<Type>(); any) {
                swap(any, *this);
                valid = true;
            }
        }

        return valid;
    }

    /**
     * @brief Replaces the contained object by initializing a new instance
     * directly.
     * @tparam Type Type of object to use to initialize the container.
     * @tparam Args Types of arguments to use to construct the new instance.
     * @param args Parameters to use to construct the instance.
     */
    template<typename Type, typename... Args>
    void emplace(Args &&... args) {
        *this = meta_any{std::in_place_type_t<Type>{}, std::forward<Args>(args)...};
    }

    /**
     * @brief Aliasing constructor.
     * @return A meta any that shares a reference to an unmanaged object.
     */
    meta_any ref() const ENTT_NOEXCEPT {
        return meta_any{node, instance};
    }

    /**
     * @brief Indirection operator for aliasing construction.
     * @return A meta any that shares a reference to an unmanaged object.
     */
    meta_any operator *() const ENTT_NOEXCEPT {
        return ref();
    }

    /**
     * @brief Returns false if a container is empty, true otherwise.
     * @return False if the container is empty, true otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

    /**
     * @brief Checks if two containers differ in their content.
     * @param other Container with which to compare.
     * @return False if the two containers differ in their content, true
     * otherwise.
     */
    bool operator==(const meta_any &other) const {
        return (!node && !other.node) || (node && other.node && node->type_id == other.node->type_id && node->compare(instance, other.instance));
    }

    /**
     * @brief Swaps two meta any objects.
     * @param lhs A valid meta any object.
     * @param rhs A valid meta any object.
     */
    friend void swap(meta_any &lhs, meta_any &rhs) {
        if(lhs.steal_fn && rhs.steal_fn) {
            meta_any buffer{};
            lhs.steal_fn(buffer, lhs);
            rhs.steal_fn(lhs, rhs);
            lhs.steal_fn(rhs, buffer);
        } else if(lhs.steal_fn) {
            lhs.steal_fn(rhs, lhs);
        } else if(rhs.steal_fn) {
            rhs.steal_fn(lhs, rhs);
        } else {
            std::swap(lhs.instance, rhs.instance);
        }

        std::swap(lhs.node, rhs.node);
        std::swap(lhs.destroy_fn, rhs.destroy_fn);
        std::swap(lhs.copy_fn, rhs.copy_fn);
        std::swap(lhs.steal_fn, rhs.steal_fn);
    }

private:
    storage_type storage;
    void *instance;
    const internal::meta_type_node *node;
    destroy_fn_type *destroy_fn;
    copy_fn_type *copy_fn;
    steal_fn_type *steal_fn;
};


/**
 * @brief Opaque pointers to instances of any type.
 *
 * A handle doesn't perform copies and isn't responsible for the contained
 * object. It doesn't prolong the lifetime of the pointed instance.<br/>
 * Handles are used to generate meta references to actual objects when needed.
 */
struct meta_handle {
    /*! @brief Default constructor. */
    meta_handle()
        : any{}
    {}

    /**
     * @brief Creates a handle that points to an unmanaged object.
     * @tparam Type Type of object to use to initialize the container.
     * @param value An instance of an object to use to initialize the container.
     */
    template<typename Type>
    meta_handle(Type &&value) ENTT_NOEXCEPT
        : meta_handle{}
    {
        if constexpr(std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, meta_any>) {
            any = *value;
        } else {
            static_assert(std::is_lvalue_reference_v<Type>);
            any = std::ref(value);
        }
    }

    /*! @copydoc meta_any::operator* */
    meta_any operator *() const {
        return any;
    }

private:
    meta_any any;
};


/**
 * @brief Checks if two containers differ in their content.
 * @param lhs A meta any object, either empty or not.
 * @param rhs A meta any object, either empty or not.
 * @return True if the two containers differ in their content, false otherwise.
 */
inline bool operator!=(const meta_any &lhs, const meta_any &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/*! @brief Opaque container for meta properties of any type. */
struct meta_prop {
    /**
     * @brief Constructs an instance from a given node.
     * @param curr The underlying node with which to construct the instance.
     */
    meta_prop(const internal::meta_prop_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /**
     * @brief Returns the stored key.
     * @return A meta any containing the key stored with the given property.
     */
    meta_any key() const {
        return node->key();
    }

    /**
     * @brief Returns the stored value.
     * @return A meta any containing the value stored with the given property.
     */
    meta_any value() const {
        return node->value();
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

private:
    const internal::meta_prop_node *node;
};


/*! @brief Opaque container for meta base classes. */
struct meta_base {
    /*! @copydoc meta_prop::meta_prop */
    meta_base(const internal::meta_base_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /**
     * @brief Returns the meta type to which a meta object belongs.
     * @return The meta type to which the meta object belongs.
     */
    inline meta_type parent() const ENTT_NOEXCEPT;

    /*! @copydoc meta_any::type */
    inline meta_type type() const ENTT_NOEXCEPT;

    /**
     * @brief Casts an instance from a parent type to a base type.
     * @param instance The instance to cast.
     * @return An opaque pointer to the base type.
     */
    void * cast(void *instance) const ENTT_NOEXCEPT {
        return node->cast(instance);
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

private:
    const internal::meta_base_node *node;
};


/*! @brief Opaque container for meta conversion functions. */
struct meta_conv {
    /*! @copydoc meta_prop::meta_prop */
    meta_conv(const internal::meta_conv_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /*! @copydoc meta_base::parent */
    inline meta_type parent() const ENTT_NOEXCEPT;

    /*! @copydoc meta_any::type */
    inline meta_type type() const ENTT_NOEXCEPT;

    /**
     * @brief Converts an instance to a given type.
     * @param instance The instance to convert.
     * @return An opaque pointer to the instance to convert.
     */
    meta_any convert(const void *instance) const {
        return node->conv(instance);
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

private:
    const internal::meta_conv_node *node;
};


/*! @brief Opaque container for meta constructors. */
struct meta_ctor {
    /*! @brief Unsigned integer type. */
    using size_type = typename internal::meta_ctor_node::size_type;

    /*! @copydoc meta_prop::meta_prop */
    meta_ctor(const internal::meta_ctor_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /*! @copydoc meta_base::parent */
    inline meta_type parent() const ENTT_NOEXCEPT;

    /**
     * @brief Returns the number of arguments accepted by a meta constructor.
     * @return The number of arguments accepted by the meta constructor.
     */
    size_type size() const ENTT_NOEXCEPT {
        return node->size;
    }

    /**
     * @brief Returns the meta type of the i-th argument of a meta constructor.
     * @param index The index of the argument of which to return the meta type.
     * @return The meta type of the i-th argument of a meta constructor, if any.
     */
    meta_type arg(size_type index) const ENTT_NOEXCEPT;

    /**
     * @brief Creates an instance of the underlying type, if possible.
     *
     * To create a valid instance, the parameters must be such that a cast or
     * conversion to the required types is possible. Otherwise, an empty and
     * thus invalid container is returned.
     *
     * @tparam Args Types of arguments to use to construct the instance.
     * @param args Parameters to use to construct the instance.
     * @return A meta any containing the new instance, if any.
     */
    template<typename... Args>
    meta_any invoke([[maybe_unused]] Args &&... args) const {
        if constexpr(sizeof...(Args) == 0) {
            return sizeof...(Args) == size() ? node->invoke(nullptr) : meta_any{};
        } else {
            meta_any arguments[]{std::forward<Args>(args)...};
            return sizeof...(Args) == size() ? node->invoke(arguments) : meta_any{};
        }
    }

    /**
     * @brief Iterates all the properties assigned to a meta constructor.
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_prop>, void>
    prop(Op op) const {
        internal::visit<meta_prop>(op, node->prop);
    }

    /**
     * @brief Returns the property associated with a given key.
     * @param key The key to use to search for a property.
     * @return The property associated with the given key, if any.
     */
    meta_prop prop(meta_any key) const {
        return internal::find_if([key = std::move(key)](const auto *curr) {
            return curr->key() == key;
        }, node->prop);
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

private:
    const internal::meta_ctor_node *node;
};


/*! @brief Opaque container for meta data. */
struct meta_data {
    /*! @copydoc meta_prop::meta_prop */
    meta_data(const internal::meta_data_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /*! @copydoc meta_type::id */
    id_type id() const ENTT_NOEXCEPT {
        return node->id;
    }

    /*! @copydoc id */
    [[deprecated("use ::id instead")]]
    id_type alias() const ENTT_NOEXCEPT {
        return id();
    }

    /*! @copydoc meta_base::parent */
    inline meta_type parent() const ENTT_NOEXCEPT;

    /**
     * @brief Indicates whether a given meta data is constant or not.
     * @return True if the meta data is constant, false otherwise.
     */
    bool is_const() const ENTT_NOEXCEPT {
        return node->is_const;
    }

    /**
     * @brief Indicates whether a given meta data is static or not.
     * @return True if the meta data is static, false otherwise.
     */
    bool is_static() const ENTT_NOEXCEPT {
        return node->is_static;
    }

    /*! @copydoc meta_any::type */
    inline meta_type type() const ENTT_NOEXCEPT;

    /**
     * @brief Sets the value of the variable enclosed by a given meta type.
     *
     * It must be possible to cast the instance to the parent type of the meta
     * data. Otherwise, invoking the setter results in an undefined
     * behavior.<br/>
     * The type of the value must be such that a cast or conversion to the type
     * of the variable is possible. Otherwise, invoking the setter does nothing.
     *
     * @tparam Type Type of value to assign.
     * @param instance An opaque instance of the underlying type.
     * @param value Parameter to use to set the underlying variable.
     * @return True in case of success, false otherwise.
     */
    template<typename Type>
    bool set(meta_handle instance, Type &&value) const {
        return node->set(*instance, {}, std::forward<Type>(value));
    }

    /**
     * @brief Sets the i-th element of an array enclosed by a given meta type.
     *
     * It must be possible to cast the instance to the parent type of the meta
     * data. Otherwise, invoking the setter results in an undefined
     * behavior.<br/>
     * The type of the value must be such that a cast or conversion to the array
     * type is possible. Otherwise, invoking the setter does nothing.
     *
     * @tparam Type Type of value to assign.
     * @param instance An opaque instance of the underlying type.
     * @param index Position of the underlying element to set.
     * @param value Parameter to use to set the underlying element.
     * @return True in case of success, false otherwise.
     */
    template<typename Type>
    bool set(meta_handle instance, std::size_t index, Type &&value) const {
        ENTT_ASSERT(index < node->type()->extent);
        return node->set(*instance, index, std::forward<Type>(value));
    }

    /**
     * @brief Gets the value of the variable enclosed by a given meta type.
     *
     * It must be possible to cast the instance to the parent type of the meta
     * data. Otherwise, invoking the getter results in an undefined behavior.
     *
     * @param instance An opaque instance of the underlying type.
     * @return A meta any containing the value of the underlying variable.
     */
    meta_any get(meta_handle instance) const {
        return node->get(*instance, {});
    }

    /**
     * @brief Gets the i-th element of an array enclosed by a given meta type.
     *
     * It must be possible to cast the instance to the parent type of the meta
     * data. Otherwise, invoking the getter results in an undefined behavior.
     *
     * @param instance An opaque instance of the underlying type.
     * @param index Position of the underlying element to get.
     * @return A meta any containing the value of the underlying element.
     */
    meta_any get(meta_handle instance, std::size_t index) const {
        ENTT_ASSERT(index < node->type()->extent);
        return node->get(*instance, index);
    }

    /**
     * @brief Iterates all the properties assigned to a meta data.
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_prop>, void>
    prop(Op op) const {
        internal::visit<meta_prop>(op, node->prop);
    }

    /**
     * @brief Returns the property associated with a given key.
     * @param key The key to use to search for a property.
     * @return The property associated with the given key, if any.
     */
    meta_prop prop(meta_any key) const {
        return internal::find_if([key = std::move(key)](const auto *curr) {
            return curr->key() == key;
        }, node->prop);
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

private:
    const internal::meta_data_node *node;
};


/*! @brief Opaque container for meta functions. */
struct meta_func {
    /*! @brief Unsigned integer type. */
    using size_type = typename internal::meta_func_node::size_type;

    /*! @copydoc meta_prop::meta_prop */
    meta_func(const internal::meta_func_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /*! @copydoc meta_type::id */
    id_type id() const ENTT_NOEXCEPT {
        return node->id;
    }

    /*! @copydoc id */
    [[deprecated("use ::id instead")]]
    id_type alias() const ENTT_NOEXCEPT {
        return id();
    }

    /*! @copydoc meta_base::parent */
    inline meta_type parent() const ENTT_NOEXCEPT;

    /**
     * @brief Returns the number of arguments accepted by a meta function.
     * @return The number of arguments accepted by the meta function.
     */
    size_type size() const ENTT_NOEXCEPT {
        return node->size;
    }

    /**
     * @brief Indicates whether a given meta function is constant or not.
     * @return True if the meta function is constant, false otherwise.
     */
    bool is_const() const ENTT_NOEXCEPT {
        return node->is_const;
    }

    /**
     * @brief Indicates whether a given meta function is static or not.
     * @return True if the meta function is static, false otherwise.
     */
    bool is_static() const ENTT_NOEXCEPT {
        return node->is_static;
    }

    /**
     * @brief Returns the meta type of the return type of a meta function.
     * @return The meta type of the return type of the meta function.
     */
    inline meta_type ret() const ENTT_NOEXCEPT;

    /**
     * @brief Returns the meta type of the i-th argument of a meta function.
     * @param index The index of the argument of which to return the meta type.
     * @return The meta type of the i-th argument of a meta function, if any.
     */
    inline meta_type arg(size_type index) const ENTT_NOEXCEPT;

    /**
     * @brief Invokes the underlying function, if possible.
     *
     * To invoke a meta function, the parameters must be such that a cast or
     * conversion to the required types is possible. Otherwise, an empty and
     * thus invalid container is returned.<br/>
     * It must be possible to cast the instance to the parent type of the meta
     * function. Otherwise, invoking the underlying function results in an
     * undefined behavior.
     *
     * @tparam Args Types of arguments to use to invoke the function.
     * @param instance An opaque instance of the underlying type.
     * @param args Parameters to use to invoke the function.
     * @return A meta any containing the returned value, if any.
     */
    template<typename... Args>
    meta_any invoke(meta_handle instance, Args &&... args) const {
        meta_any arguments[]{*instance, std::forward<Args>(args)...};
        return sizeof...(Args) == size() ? node->invoke(arguments[0], &arguments[sizeof...(Args) != 0]) : meta_any{};
    }

    /**
     * @brief Iterates all the properties assigned to a meta function.
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_prop>, void>
    prop(Op op) const {
        internal::visit<meta_prop>(op, node->prop);
    }

    /**
     * @brief Returns the property associated with a given key.
     * @param key The key to use to search for a property.
     * @return The property associated with the given key, if any.
     */
    meta_prop prop(meta_any key) const {
        return internal::find_if([key = std::move(key)](const auto *curr) {
            return curr->key() == key;
        }, node->prop);
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

private:
    const internal::meta_func_node *node;
};


/*! @brief Opaque container for meta types. */
class meta_type {
    template<typename... Args, std::size_t... Indexes>
    auto ctor(std::index_sequence<Indexes...>) const {
        return internal::find_if([](const auto *candidate) {
            return candidate->size == sizeof...(Args) && ([](auto *from, auto *to) {
                return (from->type_id == to->type_id)
                        || internal::find_if<&internal::meta_type_node::base>([to](const auto *curr) { return curr->type()->type_id == to->type_id; }, from)
                        || internal::find_if<&internal::meta_type_node::conv>([to](const auto *curr) { return curr->type()->type_id == to->type_id; }, from);
            }(internal::meta_info<Args>::resolve(), candidate->arg(Indexes)) && ...);
        }, node->ctor);
    }

public:
    /*! @brief Unsigned integer type. */
    using size_type = typename internal::meta_type_node::size_type;

    /*! @copydoc meta_prop::meta_prop */
    meta_type(const internal::meta_type_node *curr = nullptr) ENTT_NOEXCEPT
        : node{curr}
    {}

    /**
     * @brief Returns the type id of the underlying type.
     * @return The type id of the underlying type.
     */
    id_type type_id() const ENTT_NOEXCEPT {
        return node->type_id;
    }

    /**
     * @brief Returns the identifier assigned to a given meta object.
     * @return The identifier assigned to the meta object.
     */
    id_type id() const ENTT_NOEXCEPT {
        return node->id;
    }

    /*! @copydoc id */
    [[deprecated("use ::id instead")]]
    id_type alias() const ENTT_NOEXCEPT {
        return id();
    }

    /**
     * @brief Indicates whether a given meta type refers to void or not.
     * @return True if the underlying type is void, false otherwise.
     */
    bool is_void() const ENTT_NOEXCEPT {
        return node->is_void;
    }

    /**
     * @brief Indicates whether a given meta type refers to an integral type or
     * not.
     * @return True if the underlying type is an integral type, false otherwise.
     */
    bool is_integral() const ENTT_NOEXCEPT {
        return node->is_integral;
    }

    /**
     * @brief Indicates whether a given meta type refers to a floating-point
     * type or not.
     * @return True if the underlying type is a floating-point type, false
     * otherwise.
     */
    bool is_floating_point() const ENTT_NOEXCEPT {
        return node->is_floating_point;
    }

    /**
     * @brief Indicates whether a given meta type refers to an array type or
     * not.
     * @return True if the underlying type is an array type, false otherwise.
     */
    bool is_array() const ENTT_NOEXCEPT {
        return node->is_array;
    }

    /**
     * @brief Indicates whether a given meta type refers to an enum or not.
     * @return True if the underlying type is an enum, false otherwise.
     */
    bool is_enum() const ENTT_NOEXCEPT {
        return node->is_enum;
    }

    /**
     * @brief Indicates whether a given meta type refers to an union or not.
     * @return True if the underlying type is an union, false otherwise.
     */
    bool is_union() const ENTT_NOEXCEPT {
        return node->is_union;
    }

    /**
     * @brief Indicates whether a given meta type refers to a class or not.
     * @return True if the underlying type is a class, false otherwise.
     */
    bool is_class() const ENTT_NOEXCEPT {
        return node->is_class;
    }

    /**
     * @brief Indicates whether a given meta type refers to a pointer or not.
     * @return True if the underlying type is a pointer, false otherwise.
     */
    bool is_pointer() const ENTT_NOEXCEPT {
        return node->is_pointer;
    }

    /**
     * @brief Indicates whether a given meta type refers to a function pointer
     * or not.
     * @return True if the underlying type is a function pointer, false
     * otherwise.
     */
    bool is_function_pointer() const ENTT_NOEXCEPT {
        return node->is_function_pointer;
    }

    /**
     * @brief Indicates whether a given meta type refers to a pointer to data
     * member or not.
     * @return True if the underlying type is a pointer to data member, false
     * otherwise.
     */
    bool is_member_object_pointer() const ENTT_NOEXCEPT {
        return node->is_member_object_pointer;
    }

    /**
     * @brief Indicates whether a given meta type refers to a pointer to member
     * function or not.
     * @return True if the underlying type is a pointer to member function,
     * false otherwise.
     */
    bool is_member_function_pointer() const ENTT_NOEXCEPT {
        return node->is_member_function_pointer;
    }

    /**
     * @brief If a given meta type refers to an array type, provides the number
     * of elements of the array.
     * @return The number of elements of the array if the underlying type is an
     * array type, 0 otherwise.
     */
    size_type extent() const ENTT_NOEXCEPT {
        return node->extent;
    }

    /**
     * @brief Provides the meta type for which the pointer is defined.
     * @return The meta type for which the pointer is defined or this meta type
     * if it doesn't refer to a pointer type.
     */
    meta_type remove_pointer() const ENTT_NOEXCEPT {
        return node->remove_pointer();
    }

    /**
     * @brief Provides the meta type for which the array is defined.
     * @return The meta type for which the array is defined or this meta type
     * if it doesn't refer to an array type.
     */
    meta_type remove_extent() const ENTT_NOEXCEPT {
        return node->remove_extent();
    }

    /**
     * @brief Iterates all the meta bases of a meta type.
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_base>, void>
    base(Op op) const {
        internal::visit<&internal::meta_type_node::base, meta_base>(op, node);
    }

    /**
     * @brief Returns the meta base associated with a given identifier.
     * @param id Unique identifier.
     * @return The meta base associated with the given identifier, if any.
     */
    meta_base base(const id_type id) const {
        return internal::find_if<&internal::meta_type_node::base>([id](const auto *curr) {
            return curr->type()->id == id;
        }, node);
    }

    /**
     * @brief Iterates all the meta conversion functions of a meta type.
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    void conv(Op op) const {
        internal::visit<&internal::meta_type_node::conv, meta_conv>(op, node);
    }

    /**
     * @brief Returns the meta conversion function associated with a given type.
     * @tparam Type The type to use to search for a meta conversion function.
     * @return The meta conversion function associated with the given type, if
     * any.
     */
    template<typename Type>
    meta_conv conv() const {
        return internal::find_if<&internal::meta_type_node::conv>([type_id = internal::meta_info<Type>::resolve()->type_id](const auto *curr) {
            return curr->type()->type_id == type_id;
        }, node);
    }

    /**
     * @brief Iterates all the meta constructors of a meta type.
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    void ctor(Op op) const {
        internal::visit<meta_ctor>(op, node->ctor);
    }

    /**
     * @brief Returns the meta constructor that accepts a given list of types of
     * arguments.
     * @return The requested meta constructor, if any.
     */
    template<typename... Args>
    meta_ctor ctor() const {
        return ctor<Args...>(std::index_sequence_for<Args...>{});
    }

    /**
     * @brief Iterates all the meta data of a meta type.
     *
     * The meta data of the base classes will also be returned, if any.
     *
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_data>, void>
    data(Op op) const {
        internal::visit<&internal::meta_type_node::data, meta_data>(op, node);
    }

    /**
     * @brief Returns the meta data associated with a given identifier.
     *
     * The meta data of the base classes will also be visited, if any.
     *
     * @param id Unique identifier.
     * @return The meta data associated with the given identifier, if any.
     */
    meta_data data(const id_type id) const {
        return internal::find_if<&internal::meta_type_node::data>([id](const auto *curr) {
            return curr->id == id;
        }, node);
    }

    /**
     * @brief Iterates all the meta functions of a meta type.
     *
     * The meta functions of the base classes will also be returned, if any.
     *
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_func>, void>
    func(Op op) const {
        internal::visit<&internal::meta_type_node::func, meta_func>(op, node);
    }

    /**
     * @brief Returns the meta function associated with a given identifier.
     *
     * The meta functions of the base classes will also be visited, if any.
     *
     * @param id Unique identifier.
     * @return The meta function associated with the given identifier, if any.
     */
    meta_func func(const id_type id) const {
        return internal::find_if<&internal::meta_type_node::func>([id](const auto *curr) {
            return curr->id == id;
        }, node);
    }

    /**
     * @brief Creates an instance of the underlying type, if possible.
     *
     * To create a valid instance, the parameters must be such that a cast or
     * conversion to the required types is possible. Otherwise, an empty and
     * thus invalid container is returned.
     *
     * @tparam Args Types of arguments to use to construct the instance.
     * @param args Parameters to use to construct the instance.
     * @return A meta any containing the new instance, if any.
     */
    template<typename... Args>
    meta_any construct(Args &&... args) const {
        auto construct_if = [this](meta_any *params) {
            meta_any any{};

            internal::find_if<&internal::meta_type_node::ctor>([params, &any](const auto *curr) {
                return (curr->size == sizeof...(args)) && (any = curr->invoke(params));
            }, node);

            return any;
        };

        if constexpr(sizeof...(Args) == 0) {
            return construct_if(nullptr);
        } else {
            meta_any arguments[]{std::forward<Args>(args)...};
            return construct_if(arguments);
        }
    }

    /**
     * @brief Iterates all the properties assigned to a meta type.
     *
     * The properties of the base classes will also be returned, if any.
     *
     * @tparam Op Type of the function object to invoke.
     * @param op A valid function object.
     */
    template<typename Op>
    std::enable_if_t<std::is_invocable_v<Op, meta_prop>, void>
    prop(Op op) const {
        internal::visit<&internal::meta_type_node::prop, meta_prop>(op, node);
    }

    /**
     * @brief Returns the property associated with a given key.
     *
     * The properties of the base classes will also be visited, if any.
     *
     * @param key The key to use to search for a property.
     * @return The property associated with the given key, if any.
     */
    meta_prop prop(meta_any key) const {
        return internal::find_if<&internal::meta_type_node::prop>([key = std::move(key)](const auto *curr) {
            return curr->key() == key;
        }, node);
    }

    /**
     * @brief Returns true if a meta object is valid, false otherwise.
     * @return True if the meta object is valid, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return !(node == nullptr);
    }

    /**
     * @brief Checks if two meta objects refer to the same type.
     * @param other The meta object with which to compare.
     * @return True if the two meta objects refer to the same type, false
     * otherwise.
     */
    bool operator==(const meta_type &other) const ENTT_NOEXCEPT {
        return (!node && !other.node) || (node && other.node && node->type_id == other.node->type_id);
    }

    /*! @brief Removes a meta object from the list of searchable types. */
    void detach() ENTT_NOEXCEPT {
        internal::meta_context::detach(node);
    }

private:
    const internal::meta_type_node *node;
};


/**
 * @brief Checks if two meta objects refer to the same type.
 * @param lhs A meta object, either valid or not.
 * @param rhs A meta object, either valid or not.
 * @return False if the two meta objects refer to the same node, true otherwise.
 */
inline bool operator!=(const meta_type &lhs, const meta_type &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


inline meta_type meta_any::type() const ENTT_NOEXCEPT {
    return node;
}


inline meta_type meta_base::parent() const ENTT_NOEXCEPT {
    return node->parent;
}


inline meta_type meta_base::type() const ENTT_NOEXCEPT {
    return node->type();
}


inline meta_type meta_conv::parent() const ENTT_NOEXCEPT {
    return node->parent;
}


inline meta_type meta_conv::type() const ENTT_NOEXCEPT {
    return node->type();
}


inline meta_type meta_ctor::parent() const ENTT_NOEXCEPT {
    return node->parent;
}


inline meta_type meta_ctor::arg(size_type index) const ENTT_NOEXCEPT {
    return index < size() ? node->arg(index) : nullptr;
}


inline meta_type meta_data::parent() const ENTT_NOEXCEPT {
    return node->parent;
}


inline meta_type meta_data::type() const ENTT_NOEXCEPT {
    return node->type();
}


inline meta_type meta_func::parent() const ENTT_NOEXCEPT {
    return node->parent;
}


inline meta_type meta_func::ret() const ENTT_NOEXCEPT {
    return node->ret();
}


inline meta_type meta_func::arg(size_type index) const ENTT_NOEXCEPT {
    return index < size() ? node->arg(index) : nullptr;
}


}


#endif

// #include "policy.hpp"
#ifndef ENTT_META_POLICY_HPP
#define ENTT_META_POLICY_HPP


namespace entt {


/*! @brief Empty class type used to request the _as ref_ policy. */
struct as_ref_t {};


/*! @brief Disambiguation tag. */
inline constexpr as_ref_t as_ref;


/*! @copydoc as_ref_t */
using as_alias_t [[deprecated("use as_ref_t instead")]] = as_ref_t;


/*! @copydoc as_ref */
[[deprecated("use as_ref instead")]]
inline constexpr as_ref_t as_alias;


/*! @brief Empty class type used to request the _as-is_ policy. */
struct as_is_t {};


/*! @brief Empty class type used to request the _as void_ policy. */
struct as_void_t {};


}


#endif



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename>
struct meta_function_helper;


template<typename Ret, typename... Args>
struct meta_function_helper<Ret(Args...)> {
    using return_type = std::remove_cv_t<std::remove_reference_t<Ret>>;
    using args_type = std::tuple<std::remove_cv_t<std::remove_reference_t<Args>>...>;

    static constexpr std::index_sequence_for<Args...> index_sequence{};
    static constexpr auto is_const = false;

    static auto arg(typename internal::meta_func_node::size_type index) ENTT_NOEXCEPT {
        return std::array<meta_type_node *, sizeof...(Args)>{{meta_info<Args>::resolve()...}}[index];
    }
};


template<typename Ret, typename... Args>
struct meta_function_helper<Ret(Args...) const>: meta_function_helper<Ret(Args...)> {
    static constexpr auto is_const = true;
};


template<typename Ret, typename... Args, typename Class>
constexpr meta_function_helper<Ret(Args...)>
to_meta_function_helper(Ret(Class:: *)(Args...));


template<typename Ret, typename... Args, typename Class>
constexpr meta_function_helper<Ret(Args...) const>
to_meta_function_helper(Ret(Class:: *)(Args...) const);


template<typename Ret, typename... Args>
constexpr meta_function_helper<Ret(Args...)>
to_meta_function_helper(Ret(*)(Args...));


constexpr void to_meta_function_helper(...);


template<typename Candidate>
using meta_function_helper_t = decltype(to_meta_function_helper(std::declval<Candidate>()));


template<typename Type, typename... Args, std::size_t... Indexes>
meta_any construct(meta_any * const args, std::index_sequence<Indexes...>) {
    [[maybe_unused]] auto direct = std::make_tuple((args+Indexes)->try_cast<Args>()...);
    meta_any any{};

    if(((std::get<Indexes>(direct) || (args+Indexes)->convert<Args>()) && ...)) {
        any = Type{(std::get<Indexes>(direct) ? *std::get<Indexes>(direct) : (args+Indexes)->cast<Args>())...};
    }

    return any;
}


template<bool Const, typename Type, auto Data>
bool setter([[maybe_unused]] meta_any instance, [[maybe_unused]] meta_any index, [[maybe_unused]] meta_any value) {
    bool accepted = false;

    if constexpr(!Const) {
        if constexpr(std::is_function_v<std::remove_reference_t<std::remove_pointer_t<decltype(Data)>>> || std::is_member_function_pointer_v<decltype(Data)>) {
            using helper_type = meta_function_helper_t<decltype(Data)>;
            using data_type = std::tuple_element_t<!std::is_member_function_pointer_v<decltype(Data)>, typename helper_type::args_type>;
            static_assert(std::is_invocable_v<decltype(Data), Type &, data_type>);
            auto * const clazz = instance.try_cast<Type>();
            auto * const direct = value.try_cast<data_type>();

            if(clazz && (direct || value.convert<data_type>())) {
                std::invoke(Data, *clazz, direct ? *direct : value.cast<data_type>());
                accepted = true;
            }
        } else if constexpr(std::is_member_object_pointer_v<decltype(Data)>) {
            using data_type = std::remove_cv_t<std::remove_reference_t<decltype(std::declval<Type>().*Data)>>;
            static_assert(std::is_invocable_v<decltype(Data), Type *>);
            auto * const clazz = instance.try_cast<Type>();

            if constexpr(std::is_array_v<data_type>) {
                using underlying_type = std::remove_extent_t<data_type>;
                auto * const direct = value.try_cast<underlying_type>();
                auto * const idx = index.try_cast<std::size_t>();

                if(clazz && idx && (direct || value.convert<underlying_type>())) {
                    std::invoke(Data, clazz)[*idx] = direct ? *direct : value.cast<underlying_type>();
                    accepted = true;
                }
            } else {
                auto * const direct = value.try_cast<data_type>();

                if(clazz && (direct || value.convert<data_type>())) {
                    std::invoke(Data, clazz) = (direct ? *direct : value.cast<data_type>());
                    accepted = true;
                }
            }
        } else {
            static_assert(std::is_pointer_v<decltype(Data)>);
            using data_type = std::remove_cv_t<std::remove_reference_t<decltype(*Data)>>;

            if constexpr(std::is_array_v<data_type>) {
                using underlying_type = std::remove_extent_t<data_type>;
                auto * const direct = value.try_cast<underlying_type>();
                auto * const idx = index.try_cast<std::size_t>();

                if(idx && (direct || value.convert<underlying_type>())) {
                    (*Data)[*idx] = (direct ? *direct : value.cast<underlying_type>());
                    accepted = true;
                }
            } else {
                auto * const direct = value.try_cast<data_type>();

                if(direct || value.convert<data_type>()) {
                    *Data = (direct ? *direct : value.cast<data_type>());
                    accepted = true;
                }
            }
        }
    }

    return accepted;
}


template<typename Type, auto Data, typename Policy>
meta_any getter([[maybe_unused]] meta_any instance, [[maybe_unused]] meta_any index) {
    auto dispatch = [](auto &&value) {
        if constexpr(std::is_same_v<Policy, as_void_t>) {
            return meta_any{std::in_place_type<void>, std::forward<decltype(value)>(value)};
        } else if constexpr(std::is_same_v<Policy, as_ref_t>) {
            return meta_any{std::ref(std::forward<decltype(value)>(value))};
        } else {
            static_assert(std::is_same_v<Policy, as_is_t>);
            return meta_any{std::forward<decltype(value)>(value)};
        }
    };

    if constexpr(std::is_function_v<std::remove_reference_t<std::remove_pointer_t<decltype(Data)>>> || std::is_member_function_pointer_v<decltype(Data)>) {
        static_assert(std::is_invocable_v<decltype(Data), Type &>);
        auto * const clazz = instance.try_cast<Type>();
        return clazz ? dispatch(std::invoke(Data, *clazz)) : meta_any{};
    } else if constexpr(std::is_member_object_pointer_v<decltype(Data)>) {
        using data_type = std::remove_cv_t<std::remove_reference_t<decltype(std::declval<Type>().*Data)>>;
        static_assert(std::is_invocable_v<decltype(Data), Type *>);
        auto * const clazz = instance.try_cast<Type>();

        if constexpr(std::is_array_v<data_type>) {
            auto * const idx = index.try_cast<std::size_t>();
            return (clazz && idx) ? dispatch(std::invoke(Data, clazz)[*idx]) : meta_any{};
        } else {
            return clazz ? dispatch(std::invoke(Data, clazz)) : meta_any{};
        }
    } else {
        static_assert(std::is_pointer_v<std::decay_t<decltype(Data)>>);

        if constexpr(std::is_array_v<std::remove_pointer_t<decltype(Data)>>) {
            auto * const idx = index.try_cast<std::size_t>();
            return idx ? dispatch((*Data)[*idx]) : meta_any{};
        } else {
            return dispatch(*Data);
        }
    }
}


template<typename Type, auto Candidate, typename Policy, std::size_t... Indexes>
meta_any invoke([[maybe_unused]] meta_any instance, meta_any *args, std::index_sequence<Indexes...>) {
    using helper_type = meta_function_helper_t<decltype(Candidate)>;

    auto dispatch = [](auto *... params) {
        if constexpr(std::is_void_v<typename helper_type::return_type> || std::is_same_v<Policy, as_void_t>) {
            std::invoke(Candidate, *params...);
            return meta_any{std::in_place_type<void>};
        } else if constexpr(std::is_same_v<Policy, as_ref_t>) {
            return meta_any{std::ref(std::invoke(Candidate, *params...))};
        } else {
            static_assert(std::is_same_v<Policy, as_is_t>);
            return meta_any{std::invoke(Candidate, *params...)};
        }
    };

    [[maybe_unused]] const auto direct = std::make_tuple([](meta_any *any, auto *value) {
        using arg_type = std::remove_reference_t<decltype(*value)>;

        if(!value && any->convert<arg_type>()) {
            value = any->try_cast<arg_type>();
        }

        return value;
    }(args+Indexes, (args+Indexes)->try_cast<std::tuple_element_t<Indexes, typename helper_type::args_type>>())...);

    if constexpr(std::is_function_v<std::remove_reference_t<std::remove_pointer_t<decltype(Candidate)>>>) {
        return (std::get<Indexes>(direct) && ...) ? dispatch(std::get<Indexes>(direct)...) : meta_any{};
    } else {
        auto * const clazz = instance.try_cast<Type>();
        return (clazz && (std::get<Indexes>(direct) && ...)) ? dispatch(clazz, std::get<Indexes>(direct)...) : meta_any{};
    }
}


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Meta factory to be used for reflection purposes.
 *
 * The meta factory is an utility class used to reflect types, data members and
 * functions of all sorts. This class ensures that the underlying web of types
 * is built correctly and performs some checks in debug mode to ensure that
 * there are no subtle errors at runtime.
 */
template<typename...>
class meta_factory;


/**
 * @brief Extended meta factory to be used for reflection purposes.
 * @tparam Type Reflected type for which the factory was created.
 * @tparam Spec Property specialization pack used to disambiguate overloads.
 */
template<typename Type, typename... Spec>
class meta_factory<Type, Spec...>: public meta_factory<Type> {
    bool exists(const meta_any &key, const internal::meta_prop_node *node) ENTT_NOEXCEPT {
        return node && (node->key() == key || exists(key, node->next));
    }

    template<std::size_t Step = 0, std::size_t... Index, typename... Property, typename... Other>
    void unpack(std::index_sequence<Index...>, std::tuple<Property...> property, Other &&... other) {
        unroll<Step>(choice<3>, std::move(std::get<Index>(property))..., std::forward<Other>(other)...);
    }

    template<std::size_t Step = 0, typename... Property, typename... Other>
    void unroll(choice_t<3>, std::tuple<Property...> property, Other &&... other) {
        unpack<Step>(std::index_sequence_for<Property...>{}, std::move(property), std::forward<Other>(other)...);
    }

    template<std::size_t Step = 0, typename... Property, typename... Other>
    void unroll(choice_t<2>, std::pair<Property...> property, Other &&... other) {
        assign<Step>(std::move(property.first), std::move(property.second));
        unroll<Step+1>(choice<3>, std::forward<Other>(other)...);
    }

    template<std::size_t Step = 0, typename Property, typename... Other>
    std::enable_if_t<!std::is_invocable_v<Property>>
    unroll(choice_t<1>, Property &&property, Other &&... other) {
        assign<Step>(std::forward<Property>(property));
        unroll<Step+1>(choice<3>, std::forward<Other>(other)...);
    }

    template<std::size_t Step = 0, typename Func, typename... Other>
    void unroll(choice_t<0>, Func &&invocable, Other &&... other) {
        unroll<Step>(choice<3>, std::forward<Func>(invocable)(), std::forward<Other>(other)...);
    }

    template<std::size_t>
    void unroll(choice_t<0>) {}

    template<std::size_t = 0, typename Key, typename... Value>
    void assign(Key &&key, Value &&... value) {
        static const auto property{std::make_tuple(std::forward<Key>(key), std::forward<Value>(value)...)};

        static internal::meta_prop_node node{
            nullptr,
            []() -> meta_any {
                return std::get<0>(property);
            },
            []() -> meta_any {
                if constexpr(sizeof...(Value) == 0) {
                    return {};
                } else {
                    return std::get<1>(property);
                }
            }
        };

        ENTT_ASSERT(!exists(node.key(), *curr));
        node.next = *curr;
        *curr = &node;
    }

public:
    /**
     * @brief Constructs an extended factory from a given node.
     * @param target The underlying node to which to assign the properties.
     */
    meta_factory(entt::internal::meta_prop_node **target) ENTT_NOEXCEPT
        : curr{target}
    {}

    /**
     * @brief Assigns a property to the last meta object created.
     *
     * Both the key and the value (if any) must be at least copy constructible.
     *
     * @tparam PropertyOrKey Type of the property or property key.
     * @tparam Value Optional type of the property value.
     * @param property_or_key Property or property key.
     * @param value Optional property value.
     * @return A meta factory for the parent type.
     */
    template<typename PropertyOrKey, typename... Value>
    auto prop(PropertyOrKey &&property_or_key, Value &&... value) && {
        if constexpr(sizeof...(Value) == 0) {
            unroll(choice<3>, std::forward<PropertyOrKey>(property_or_key));
        } else {
            assign(std::forward<PropertyOrKey>(property_or_key), std::forward<Value>(value)...);
        }

        return meta_factory<Type, Spec..., PropertyOrKey, Value...>{curr};
    }

    /**
     * @brief Assigns properties to the last meta object created.
     *
     * Both the keys and the values (if any) must be at least copy
     * constructible.
     *
     * @tparam Property Types of the properties.
     * @param property Properties to assign to the last meta object created.
     * @return A meta factory for the parent type.
     */
    template <typename... Property>
    auto props(Property... property) && {
        unroll(choice<3>, std::forward<Property>(property)...);
        return meta_factory<Type, Spec..., Property...>{curr};
    }

private:
    entt::internal::meta_prop_node **curr;
};


/**
 * @brief Basic meta factory to be used for reflection purposes.
 * @tparam Type Reflected type for which the factory was created.
 */
template<typename Type>
class meta_factory<Type> {
    template<typename Node>
    bool exists(const Node *candidate, const Node *node) ENTT_NOEXCEPT {
        return node && (node == candidate || exists(candidate, node->next));
    }

    template<typename Node>
    bool exists(const id_type id, const Node *node) ENTT_NOEXCEPT {
        return node && (node->id == id || exists(id, node->next));
    }

public:
    /**
     * @brief Makes a meta type _searchable_.
     * @param id Optional unique identifier.
     * @return An extended meta factory for the given type.
     */
    auto type(const id_type id = type_info<Type>::id()) {
        auto * const node = internal::meta_info<Type>::resolve();

        ENTT_ASSERT(!exists(id, *internal::meta_context::global));
        ENTT_ASSERT(!exists(node, *internal::meta_context::global));
        node->id = id;
        node->next = *internal::meta_context::global;
        *internal::meta_context::global = node;

        return meta_factory<Type, Type>{&node->prop};
    }

    /*! @copydoc type */
    [[deprecated("use ::type instead")]]
    auto alias(const id_type id) ENTT_NOEXCEPT {
        return type(id);
    }

    /**
     * @brief Assigns a meta base to a meta type.
     *
     * A reflected base class must be a real base class of the reflected type.
     *
     * @tparam Base Type of the base class to assign to the meta type.
     * @return A meta factory for the parent type.
     */
    template<typename Base>
    auto base() ENTT_NOEXCEPT {
        static_assert(std::is_base_of_v<Base, Type>);
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_base_node node{
            type,
            nullptr,
            &internal::meta_info<Base>::resolve,
            [](void *instance) ENTT_NOEXCEPT -> void * {
                return static_cast<Base *>(static_cast<Type *>(instance));
            }
        };

        ENTT_ASSERT(!exists(&node, type->base));
        node.next = type->base;
        type->base = &node;

        return meta_factory<Type>{};
    }

    /**
     * @brief Assigns a meta conversion function to a meta type.
     *
     * The given type must be such that an instance of the reflected type can be
     * converted to it.
     *
     * @tparam To Type of the conversion function to assign to the meta type.
     * @return A meta factory for the parent type.
     */
    template<typename To>
    auto conv() ENTT_NOEXCEPT {
        static_assert(std::is_convertible_v<Type, To>);
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_conv_node node{
            type,
            nullptr,
            &internal::meta_info<To>::resolve,
            [](const void *instance) -> meta_any {
                return static_cast<To>(*static_cast<const Type *>(instance));
            }
        };

        ENTT_ASSERT(!exists(&node, type->conv));
        node.next = type->conv;
        type->conv = &node;

        return meta_factory<Type>{};
    }

    /**
     * @brief Assigns a meta conversion function to a meta type.
     *
     * Conversion functions can be either free functions or member
     * functions.<br/>
     * In case of free functions, they must accept a const reference to an
     * instance of the parent type as an argument. In case of member functions,
     * they should have no arguments at all.
     *
     * @tparam Candidate The actual function to use for the conversion.
     * @return A meta factory for the parent type.
     */
    template<auto Candidate>
    auto conv() ENTT_NOEXCEPT {
        using conv_type = std::invoke_result_t<decltype(Candidate), Type &>;
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_conv_node node{
            type,
            nullptr,
            &internal::meta_info<conv_type>::resolve,
            [](const void *instance) -> meta_any {
                return std::invoke(Candidate, *static_cast<const Type *>(instance));
            }
        };

        ENTT_ASSERT(!exists(&node, type->conv));
        node.next = type->conv;
        type->conv = &node;

        return meta_factory<Type>{};
    }

    /**
     * @brief Assigns a meta constructor to a meta type.
     *
     * Free functions can be assigned to meta types in the role of constructors.
     * All that is required is that they return an instance of the underlying
     * type.<br/>
     * From a client's point of view, nothing changes if a constructor of a meta
     * type is a built-in one or a free function.
     *
     * @tparam Func The actual function to use as a constructor.
     * @tparam Policy Optional policy (no policy set by default).
     * @return An extended meta factory for the parent type.
     */
    template<auto Func, typename Policy = as_is_t>
    auto ctor() ENTT_NOEXCEPT {
        using helper_type = internal::meta_function_helper_t<decltype(Func)>;
        static_assert(std::is_same_v<typename helper_type::return_type, Type>);
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_ctor_node node{
            type,
            nullptr,
            nullptr,
            helper_type::index_sequence.size(),
            &helper_type::arg,
            [](meta_any * const any) {
                return internal::invoke<Type, Func, Policy>({}, any, helper_type::index_sequence);
            }
        };

        ENTT_ASSERT(!exists(&node, type->ctor));
        node.next = type->ctor;
        type->ctor = &node;

        return meta_factory<Type, std::integral_constant<decltype(Func), Func>>{&node.prop};
    }

    /**
     * @brief Assigns a meta constructor to a meta type.
     *
     * A meta constructor is uniquely identified by the types of its arguments
     * and is such that there exists an actual constructor of the underlying
     * type that can be invoked with parameters whose types are those given.
     *
     * @tparam Args Types of arguments to use to construct an instance.
     * @return An extended meta factory for the parent type.
     */
    template<typename... Args>
    auto ctor() ENTT_NOEXCEPT {
        using helper_type = internal::meta_function_helper_t<Type(*)(Args...)>;
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_ctor_node node{
            type,
            nullptr,
            nullptr,
            helper_type::index_sequence.size(),
            &helper_type::arg,
            [](meta_any * const any) {
                return internal::construct<Type, std::remove_cv_t<std::remove_reference_t<Args>>...>(any, helper_type::index_sequence);
            }
        };

        ENTT_ASSERT(!exists(&node, type->ctor));
        node.next = type->ctor;
        type->ctor = &node;

        return meta_factory<Type, Type(Args...)>{&node.prop};
    }

    /**
     * @brief Assigns a meta destructor to a meta type.
     *
     * Free functions can be assigned to meta types in the role of destructors.
     * The signature of the function should identical to the following:
     *
     * @code{.cpp}
     * void(Type &);
     * @endcode
     *
     * The purpose is to give users the ability to free up resources that
     * require special treatment before an object is actually destroyed.
     *
     * @tparam Func The actual function to use as a destructor.
     * @return A meta factory for the parent type.
     */
    template<auto Func>
    auto dtor() ENTT_NOEXCEPT {
        static_assert(std::is_invocable_v<decltype(Func), Type &>);
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_dtor_node node{
            type,
            [](void *instance) {
                if(instance) {
                    std::invoke(Func, *static_cast<Type *>(instance));
                }
            }
        };

        ENTT_ASSERT(!type->dtor);
        type->dtor = &node;

        return meta_factory<Type>{};
    }

    /**
     * @brief Assigns a meta data to a meta type.
     *
     * Both data members and static and global variables, as well as constants
     * of any kind, can be assigned to a meta type.<br/>
     * From a client's point of view, all the variables associated with the
     * reflected object will appear as if they were part of the type itself.
     *
     * @tparam Data The actual variable to attach to the meta type.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<auto Data, typename Policy = as_is_t>
    auto data(const id_type id) ENTT_NOEXCEPT {
        auto * const type = internal::meta_info<Type>::resolve();
        internal::meta_data_node *curr = nullptr;

        if constexpr(std::is_same_v<Type, decltype(Data)>) {
            static_assert(std::is_same_v<Policy, as_is_t>);

            static internal::meta_data_node node{
                {},
                type,
                nullptr,
                nullptr,
                true,
                true,
                &internal::meta_info<Type>::resolve,
                [](meta_any, meta_any, meta_any) { return false; },
                [](meta_any, meta_any) -> meta_any { return Data; }
            };

            curr = &node;
        } else if constexpr(std::is_member_object_pointer_v<decltype(Data)>) {
            using data_type = std::remove_reference_t<decltype(std::declval<Type>().*Data)>;

            static internal::meta_data_node node{
                {},
                type,
                nullptr,
                nullptr,
                std::is_const_v<data_type>,
                !std::is_member_object_pointer_v<decltype(Data)>,
                &internal::meta_info<data_type>::resolve,
                &internal::setter<std::is_const_v<data_type>, Type, Data>,
                &internal::getter<Type, Data, Policy>
            };

            curr = &node;
        } else {
            static_assert(std::is_pointer_v<std::decay_t<decltype(Data)>>);
            using data_type = std::remove_pointer_t<std::decay_t<decltype(Data)>>;

            static internal::meta_data_node node{
                {},
                type,
                nullptr,
                nullptr,
                std::is_const_v<data_type>,
                !std::is_member_object_pointer_v<decltype(Data)>,
                &internal::meta_info<data_type>::resolve,
                &internal::setter<std::is_const_v<data_type>, Type, Data>,
                &internal::getter<Type, Data, Policy>
            };

            curr = &node;
        }

        ENTT_ASSERT(!exists(id, type->data));
        ENTT_ASSERT(!exists(curr, type->data));
        curr->id = id;
        curr->next = type->data;
        type->data = curr;

        return meta_factory<Type, std::integral_constant<decltype(Data), Data>>{&curr->prop};
    }

    /**
     * @brief Assigns a meta data to a meta type by means of its setter and
     * getter.
     *
     * Setters and getters can be either free functions, member functions or a
     * mix of them.<br/>
     * In case of free functions, setters and getters must accept a reference to
     * an instance of the parent type as their first argument. A setter has then
     * an extra argument of a type convertible to that of the parameter to
     * set.<br/>
     * In case of member functions, getters have no arguments at all, while
     * setters has an argument of a type convertible to that of the parameter to
     * set.
     *
     * @tparam Setter The actual function to use as a setter.
     * @tparam Getter The actual function to use as a getter.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<auto Setter, auto Getter, typename Policy = as_is_t>
    auto data(const id_type id) ENTT_NOEXCEPT {
        using underlying_type = std::invoke_result_t<decltype(Getter), Type &>;
        static_assert(std::is_invocable_v<decltype(Setter), Type &, underlying_type>);
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_data_node node{
            {},
            type,
            nullptr,
            nullptr,
            false,
            false,
            &internal::meta_info<underlying_type>::resolve,
            &internal::setter<false, Type, Setter>,
            &internal::getter<Type, Getter, Policy>
        };

        ENTT_ASSERT(!exists(id, type->data));
        ENTT_ASSERT(!exists(&node, type->data));
        node.id = id;
        node.next = type->data;
        type->data = &node;

        return meta_factory<Type, std::integral_constant<decltype(Setter), Setter>, std::integral_constant<decltype(Getter), Getter>>{&node.prop};
    }

    /**
     * @brief Assigns a meta funcion to a meta type.
     *
     * Both member functions and free functions can be assigned to a meta
     * type.<br/>
     * From a client's point of view, all the functions associated with the
     * reflected object will appear as if they were part of the type itself.
     *
     * @tparam Candidate The actual function to attach to the meta type.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<auto Candidate, typename Policy = as_is_t>
    auto func(const id_type id) ENTT_NOEXCEPT {
        using helper_type = internal::meta_function_helper_t<decltype(Candidate)>;
        auto * const type = internal::meta_info<Type>::resolve();

        static internal::meta_func_node node{
            {},
            type,
            nullptr,
            nullptr,
            helper_type::index_sequence.size(),
            helper_type::is_const,
            !std::is_member_function_pointer_v<decltype(Candidate)>,
            &internal::meta_info<std::conditional_t<std::is_same_v<Policy, as_void_t>, void, typename helper_type::return_type>>::resolve,
            &helper_type::arg,
            [](meta_any instance, meta_any *args) {
                return internal::invoke<Type, Candidate, Policy>(std::move(instance), args, helper_type::index_sequence);
            }
        };

        ENTT_ASSERT(!exists(id, type->func));
        ENTT_ASSERT(!exists(&node, type->func));
        node.id = id;
        node.next = type->func;
        type->func = &node;

        return meta_factory<Type, std::integral_constant<decltype(Candidate), Candidate>>{&node.prop};
    }

    /**
     * @brief Resets a meta type and all its parts.
     *
     * This function resets a meta type and all its data members, member
     * functions and properties, as well as its constructors, destructors and
     * conversion functions if any.<br/>
     * Base classes aren't reset but the link between the two types is removed.
     *
     * @return An extended meta factory for the given type.
     */
    auto reset() ENTT_NOEXCEPT {
        auto * const node = internal::meta_info<Type>::resolve();

        internal::meta_context::detach(node);

        const auto unregister_all = y_combinator{
            [](auto &&self, auto **curr, auto... member) {
                while(*curr) {
                    auto *prev = *curr;
                    (self(&(prev->*member)), ...);
                    *curr = prev->next;
                    prev->next = nullptr;
                }
            }
        };

        unregister_all(&node->prop);
        unregister_all(&node->base);
        unregister_all(&node->conv);
        unregister_all(&node->ctor, &internal::meta_ctor_node::prop);
        unregister_all(&node->data, &internal::meta_data_node::prop);
        unregister_all(&node->func, &internal::meta_func_node::prop);

        node->id = {};
        node->next = nullptr;
        node->dtor = nullptr;

        return meta_factory<Type, Type>{&node->prop};
    }
};


/**
 * @brief Utility function to use for reflection.
 *
 * This is the point from which everything starts.<br/>
 * By invoking this function with a type that is not yet reflected, a meta type
 * is created to which it will be possible to attach meta objects through a
 * dedicated factory.
 *
 * @tparam Type Type to reflect.
 * @return An meta factory for the given type.
 */
template<typename Type>
inline meta_factory<Type> meta() ENTT_NOEXCEPT {
    auto * const node = internal::meta_info<Type>::resolve();
    // extended meta factory to allow assigning properties to opaque meta types
    return meta_factory<Type, Type>{&node->prop};
}


}


#endif

// #include "meta/meta.hpp"

// #include "meta/resolve.hpp"
#ifndef ENTT_META_RESOLVE_HPP
#define ENTT_META_RESOLVE_HPP


#include <type_traits>
// #include "meta.hpp"



namespace entt {


/**
 * @brief Returns the meta type associated with a given type.
 * @tparam Type Type to use to search for a meta type.
 * @return The meta type associated with the given type, if any.
 */
template<typename Type>
inline meta_type resolve() ENTT_NOEXCEPT {
    return internal::meta_info<Type>::resolve();
}


/**
 * @brief Returns the first meta type that satisfies specific criteria, if any.
 * @tparam Func Type of the unary predicate to use to test the meta types.
 * @param func Unary predicate which returns ​true for the required element.
 * @return The first meta type satisfying the condition, if any.
 */
template<typename Func>
inline meta_type resolve_if(Func func) ENTT_NOEXCEPT {
    return internal::find_if([&func](const auto *curr) {
        return func(meta_type{curr});
    }, *internal::meta_context::global);
}


/**
 * @brief Returns the meta type associated with a given identifier, if any.
 * @param id Unique identifier.
 * @return The meta type associated with the given identifier, if any.
 */
inline meta_type resolve_id(const id_type id) ENTT_NOEXCEPT {
    return resolve_if([id](const auto type) { return type.id() == id; });
}


/**
 * @brief Returns the meta type associated with a given type id, if any.
 * @param id Unique identifier.
 * @return The meta type associated with the given type id, if any.
 */
inline meta_type resolve_type(const id_type id) ENTT_NOEXCEPT {
    return resolve_if([id](const auto type) { return type.type_id() == id; });
}


/*! @copydoc resolve_id */
[[deprecated("use entt::resolve_id instead")]]
inline meta_type resolve(const id_type id) ENTT_NOEXCEPT {
    return resolve_id(id);
}


/**
 * @brief Iterates all the reflected types.
 * @tparam Op Type of the function object to invoke.
 * @param op A valid function object.
 */
template<typename Op>
inline std::enable_if_t<std::is_invocable_v<Op, meta_type>, void>
resolve(Op op) {
    internal::visit<meta_type>(op, *internal::meta_context::global);
}


}


#endif

// #include "meta/policy.hpp"

// #include "process/process.hpp"
#ifndef ENTT_PROCESS_PROCESS_HPP
#define ENTT_PROCESS_PROCESS_HPP


#include <utility>
#include <type_traits>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif

// #include "../core/type_traits.hpp"
#ifndef ENTT_CORE_TYPE_TRAITS_HPP
#define ENTT_CORE_TYPE_TRAITS_HPP


#include <cstddef>
#include <utility>
#include <type_traits>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif

// #include "hashed_string.hpp"
#ifndef ENTT_CORE_HASHED_STRING_HPP
#define ENTT_CORE_HASHED_STRING_HPP


#include <cstddef>
#include <cstdint>
// #include "../config/config.h"

// #include "fwd.hpp"
#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP


// #include "../config/config.h"



namespace entt {


/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;


}


#endif



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename>
struct fnv1a_traits;


template<>
struct fnv1a_traits<std::uint32_t> {
    using type = std::uint32_t;
    static constexpr std::uint32_t offset = 2166136261;
    static constexpr std::uint32_t prime = 16777619;
};


template<>
struct fnv1a_traits<std::uint64_t> {
    using type = std::uint64_t;
    static constexpr std::uint64_t offset = 14695981039346656037ull;
    static constexpr std::uint64_t prime = 1099511628211ull;
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Zero overhead unique identifier.
 *
 * A hashed string is a compile-time tool that allows users to use
 * human-readable identifers in the codebase while using their numeric
 * counterparts at runtime.<br/>
 * Because of that, a hashed string can also be used in constant expressions if
 * required.
 *
 * @tparam Char Character type.
 */
template<typename Char>
class basic_hashed_string {
    using traits_type = internal::fnv1a_traits<id_type>;

    struct const_wrapper {
        // non-explicit constructor on purpose
        constexpr const_wrapper(const Char *curr) ENTT_NOEXCEPT: str{curr} {}
        const Char *str;
    };

    // Fowler–Noll–Vo hash function v. 1a - the good
    static constexpr id_type helper(const Char *curr) ENTT_NOEXCEPT {
        auto value = traits_type::offset;

        while(*curr != 0) {
            value = (value ^ static_cast<traits_type::type>(*(curr++))) * traits_type::prime;
        }

        return value;
    }

public:
    /*! @brief Character type. */
    using value_type = Char;
    /*! @brief Unsigned integer type. */
    using hash_type = id_type;

    /**
     * @brief Returns directly the numeric representation of a string.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * const auto value = basic_hashed_string<char>::to_value("my.png");
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifer.
     * @return The numeric representation of the string.
     */
    template<std::size_t N>
    static constexpr hash_type value(const value_type (&str)[N]) ENTT_NOEXCEPT {
        return helper(str);
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     * @return The numeric representation of the string.
     */
    static hash_type value(const_wrapper wrapper) ENTT_NOEXCEPT {
        return helper(wrapper.str);
    }

    /**
     * @brief Returns directly the numeric representation of a string view.
     * @param str Human-readable identifer.
     * @param size Length of the string to hash.
     * @return The numeric representation of the string.
     */
    static hash_type value(const value_type *str, std::size_t size) ENTT_NOEXCEPT {
        id_type partial{traits_type::offset};
        while(size--) { partial = (partial^(str++)[0])*traits_type::prime; }
        return partial;
    }

    /*! @brief Constructs an empty hashed string. */
    constexpr basic_hashed_string() ENTT_NOEXCEPT
        : str{nullptr}, hash{}
    {}

    /**
     * @brief Constructs a hashed string from an array of const characters.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * basic_hashed_string<char> hs{"my.png"};
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param curr Human-readable identifer.
     */
    template<std::size_t N>
    constexpr basic_hashed_string(const value_type (&curr)[N]) ENTT_NOEXCEPT
        : str{curr}, hash{helper(curr)}
    {}

    /**
     * @brief Explicit constructor on purpose to avoid constructing a hashed
     * string directly from a `const value_type *`.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     */
    explicit constexpr basic_hashed_string(const_wrapper wrapper) ENTT_NOEXCEPT
        : str{wrapper.str}, hash{helper(wrapper.str)}
    {}

    /**
     * @brief Returns the human-readable representation of a hashed string.
     * @return The string used to initialize the instance.
     */
    constexpr const value_type * data() const ENTT_NOEXCEPT {
        return str;
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr hash_type value() const ENTT_NOEXCEPT {
        return hash;
    }

    /*! @copydoc data */
    constexpr operator const value_type *() const ENTT_NOEXCEPT { return data(); }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr operator hash_type() const ENTT_NOEXCEPT { return value(); }

    /**
     * @brief Compares two hashed strings.
     * @param other Hashed string with which to compare.
     * @return True if the two hashed strings are identical, false otherwise.
     */
    constexpr bool operator==(const basic_hashed_string &other) const ENTT_NOEXCEPT {
        return hash == other.hash;
    }

private:
    const value_type *str;
    hash_type hash;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the character type of the hashed string directly from a
 * human-readable identifer provided to the constructor.
 *
 * @tparam Char Character type.
 * @tparam N Number of characters of the identifier.
 * @param str Human-readable identifer.
 */
template<typename Char, std::size_t N>
basic_hashed_string(const Char (&str)[N]) ENTT_NOEXCEPT
-> basic_hashed_string<Char>;


/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings are identical, false otherwise.
 */
template<typename Char>
constexpr bool operator!=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/*! @brief Aliases for common character types. */
using hashed_string = basic_hashed_string<char>;


/*! @brief Aliases for common character types. */
using hashed_wstring = basic_hashed_string<wchar_t>;


}


/**
 * @brief User defined literal for hashed strings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed string.
 */
constexpr entt::hashed_string operator"" ENTT_HS_SUFFIX(const char *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_string{str};
}


/**
 * @brief User defined literal for hashed wstrings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed wstring.
 */
constexpr entt::hashed_wstring operator"" ENTT_HWS_SUFFIX(const wchar_t *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_wstring{str};
}


#endif

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Wraps a static constant.
 * @tparam Value A static constant.
 */
template<auto Value>
using integral_constant = std::integral_constant<decltype(Value), Value>;


/**
 * @brief Alias template to ease the creation of named values.
 * @tparam Value A constant value at least convertible to `id_type`.
 */
template<id_type Value>
using tag = integral_constant<Value>;


/**
 * @brief Utility class to disambiguate overloaded functions.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
struct choice_t
        // Unfortunately, doxygen cannot parse such a construct.
        /*! @cond TURN_OFF_DOXYGEN */
        : choice_t<N-1>
        /*! @endcond TURN_OFF_DOXYGEN */
{};


/*! @copybrief choice_t */
template<>
struct choice_t<0> {};


/**
 * @brief Variable template for the choice trick.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
inline constexpr choice_t<N> choice{};


/*! @brief A class to use to push around lists of types, nothing more. */
template<typename...>
struct type_list {};


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_size;


/**
 * @brief Compile-time number of elements in a type list.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_size<type_list<Type...>>
        : std::integral_constant<std::size_t, sizeof...(Type)>
{};


/**
 * @brief Helper variable template.
 * @tparam List Type list.
 */
template<class List>
inline constexpr auto type_list_size_v = type_list_size<List>::value;


/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct type_list_cat;


/*! @brief Concatenates multiple type lists. */
template<>
struct type_list_cat<> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<>;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 * @tparam List Other type lists, if any.
 */
template<typename... Type, typename... Other, typename... List>
struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
};


/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_cat<type_list<Type...>> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<Type...>;
};


/**
 * @brief Helper type.
 * @tparam List Type lists to concatenate.
 */
template<typename... List>
using type_list_cat_t = typename type_list_cat<List...>::type;


/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_unique;


/**
 * @brief Removes duplicates types from a type list.
 * @tparam Type One of the types provided by the given type list.
 * @tparam Other The other types provided by the given type list.
 */
template<typename Type, typename... Other>
struct type_list_unique<type_list<Type, Other...>> {
    /*! @brief A type list without duplicate types. */
    using type = std::conditional_t<
        std::disjunction_v<std::is_same<Type, Other>...>,
        typename type_list_unique<type_list<Other...>>::type,
        type_list_cat_t<type_list<Type>, typename type_list_unique<type_list<Other...>>::type>
    >;
};


/*! @brief Removes duplicates types from a type list. */
template<>
struct type_list_unique<type_list<>> {
    /*! @brief A type list without duplicate types. */
    using type = type_list<>;
};


/**
 * @brief Helper type.
 * @tparam Type A type list.
 */
template<typename Type>
using type_list_unique_t = typename type_list_unique<Type>::type;


/**
 * @brief Provides the member constant `value` to true if a given type is
 * equality comparable, false otherwise.
 * @tparam Type Potentially equality comparable type.
 */
template<typename Type, typename = std::void_t<>>
struct is_equality_comparable: std::false_type {};


/*! @copydoc is_equality_comparable */
template<typename Type>
struct is_equality_comparable<Type, std::void_t<decltype(std::declval<Type>() == std::declval<Type>())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially equality comparable type.
 */
template<class Type>
inline constexpr auto is_equality_comparable_v = is_equality_comparable<Type>::value;


/**
 * @brief Extracts the class of a non-static member object or function.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
class member_class {
    static_assert(std::is_member_pointer_v<Member>);

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...));

    template<typename Class, typename Ret, typename... Args>
    static Class * clazz(Ret(Class:: *)(Args...) const);

    template<typename Class, typename Type>
    static Class * clazz(Type Class:: *);

public:
    /*! @brief The class of the given non-static member object or function. */
    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
};


/**
 * @brief Helper type.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
using member_class_t = typename member_class<Member>::type;


}


/**
 * @brief Defines an enum class to use for opaque identifiers and a dedicate
 * `to_integer` function to convert the identifiers to their underlying type.
 * @param clazz The name to use for the enum class.
 * @param type The underlying type for the enum class.
 */
#define ENTT_OPAQUE_TYPE(clazz, type)\
    enum class clazz: type {};\
    constexpr auto to_integral(const clazz id) ENTT_NOEXCEPT {\
        return static_cast<std::underlying_type_t<clazz>>(id);\
    }\
    static_assert(true)


#endif



namespace entt {


/**
 * @brief Base class for processes.
 *
 * This class stays true to the CRTP idiom. Derived classes must specify what's
 * the intended type for elapsed times.<br/>
 * A process should expose publicly the following member functions whether
 * required:
 *
 * * @code{.cpp}
 *   void update(Delta, void *);
 *   @endcode
 *
 *   It's invoked once per tick until a process is explicitly aborted or it
 *   terminates either with or without errors. Even though it's not mandatory to
 *   declare this member function, as a rule of thumb each process should at
 *   least define it to work properly. The `void *` parameter is an opaque
 *   pointer to user data (if any) forwarded directly to the process during an
 *   update.
 *
 * * @code{.cpp}
 *   void init();
 *   @endcode
 *
 *   It's invoked when the process joins the running queue of a scheduler. This
 *   happens as soon as it's attached to the scheduler if the process is a top
 *   level one, otherwise when it replaces its parent if the process is a
 *   continuation.
 *
 * * @code{.cpp}
 *   void succeeded();
 *   @endcode
 *
 *   It's invoked in case of success, immediately after an update and during the
 *   same tick.
 *
 * * @code{.cpp}
 *   void failed();
 *   @endcode
 *
 *   It's invoked in case of errors, immediately after an update and during the
 *   same tick.
 *
 * * @code{.cpp}
 *   void aborted();
 *   @endcode
 *
 *   It's invoked only if a process is explicitly aborted. There is no guarantee
 *   that it executes in the same tick, this depends solely on whether the
 *   process is aborted immediately or not.
 *
 * Derived classes can change the internal state of a process by invoking the
 * `succeed` and `fail` protected member functions and even pause or unpause the
 * process itself.
 *
 * @sa scheduler
 *
 * @tparam Derived Actual type of process that extends the class template.
 * @tparam Delta Type to use to provide elapsed time.
 */
template<typename Derived, typename Delta>
class process {
    enum class state: unsigned int {
        UNINITIALIZED = 0,
        RUNNING,
        PAUSED,
        SUCCEEDED,
        FAILED,
        ABORTED,
        FINISHED
    };

    template<typename Target = Derived>
    auto next(integral_constant<state::UNINITIALIZED>)
    -> decltype(std::declval<Target>().init()) {
        static_cast<Target *>(this)->init();
    }

    template<typename Target = Derived>
    auto next(integral_constant<state::RUNNING>, Delta delta, void *data)
    -> decltype(std::declval<Target>().update(delta, data)) {
        static_cast<Target *>(this)->update(delta, data);
    }

    template<typename Target = Derived>
    auto next(integral_constant<state::SUCCEEDED>)
    -> decltype(std::declval<Target>().succeeded()) {
        static_cast<Target *>(this)->succeeded();
    }

    template<typename Target = Derived>
    auto next(integral_constant<state::FAILED>)
    -> decltype(std::declval<Target>().failed()) {
        static_cast<Target *>(this)->failed();
    }

    template<typename Target = Derived>
    auto next(integral_constant<state::ABORTED>)
    -> decltype(std::declval<Target>().aborted()) {
        static_cast<Target *>(this)->aborted();
    }

    void next(...) const ENTT_NOEXCEPT {}

protected:
    /**
     * @brief Terminates a process with success if it's still alive.
     *
     * The function is idempotent and it does nothing if the process isn't
     * alive.
     */
    void succeed() ENTT_NOEXCEPT {
        if(alive()) {
            current = state::SUCCEEDED;
        }
    }

    /**
     * @brief Terminates a process with errors if it's still alive.
     *
     * The function is idempotent and it does nothing if the process isn't
     * alive.
     */
    void fail() ENTT_NOEXCEPT {
        if(alive()) {
            current = state::FAILED;
        }
    }

    /**
     * @brief Stops a process if it's in a running state.
     *
     * The function is idempotent and it does nothing if the process isn't
     * running.
     */
    void pause() ENTT_NOEXCEPT {
        if(current == state::RUNNING) {
            current = state::PAUSED;
        }
    }

    /**
     * @brief Restarts a process if it's paused.
     *
     * The function is idempotent and it does nothing if the process isn't
     * paused.
     */
    void unpause() ENTT_NOEXCEPT {
        if(current  == state::PAUSED) {
            current  = state::RUNNING;
        }
    }

public:
    /*! @brief Type used to provide elapsed time. */
    using delta_type = Delta;

    /*! @brief Default destructor. */
    virtual ~process() {
        static_assert(std::is_base_of_v<process, Derived>);
    }

    /**
     * @brief Aborts a process if it's still alive.
     *
     * The function is idempotent and it does nothing if the process isn't
     * alive.
     *
     * @param immediately Requests an immediate operation.
     */
    void abort(const bool immediately = false) {
        if(alive()) {
            current = state::ABORTED;

            if(immediately) {
                tick({});
            }
        }
    }

    /**
     * @brief Returns true if a process is either running or paused.
     * @return True if the process is still alive, false otherwise.
     */
    bool alive() const ENTT_NOEXCEPT {
        return current == state::RUNNING || current == state::PAUSED;
    }

    /**
     * @brief Returns true if a process is already terminated.
     * @return True if the process is terminated, false otherwise.
     */
    bool dead() const ENTT_NOEXCEPT {
        return current == state::FINISHED;
    }

    /**
     * @brief Returns true if a process is currently paused.
     * @return True if the process is paused, false otherwise.
     */
    bool paused() const ENTT_NOEXCEPT {
        return current == state::PAUSED;
    }

    /**
     * @brief Returns true if a process terminated with errors.
     * @return True if the process terminated with errors, false otherwise.
     */
    bool rejected() const ENTT_NOEXCEPT {
        return stopped;
    }

    /**
     * @brief Updates a process and its internal state if required.
     * @param delta Elapsed time.
     * @param data Optional data.
     */
    void tick(const Delta delta, void *data = nullptr) {
        switch (current) {
        case state::UNINITIALIZED:
            next(integral_constant<state::UNINITIALIZED>{});
            current = state::RUNNING;
            break;
        case state::RUNNING:
            next(integral_constant<state::RUNNING>{}, delta, data);
            break;
        default:
            // suppress warnings
            break;
        }

        // if it's dead, it must be notified and removed immediately
        switch(current) {
        case state::SUCCEEDED:
            next(integral_constant<state::SUCCEEDED>{});
            current = state::FINISHED;
            break;
        case state::FAILED:
            next(integral_constant<state::FAILED>{});
            current = state::FINISHED;
            stopped = true;
            break;
        case state::ABORTED:
            next(integral_constant<state::ABORTED>{});
            current = state::FINISHED;
            stopped = true;
            break;
        default:
            // suppress warnings
            break;
        }
    }

private:
    state current{state::UNINITIALIZED};
    bool stopped{false};
};


/**
 * @brief Adaptor for lambdas and functors to turn them into processes.
 *
 * Lambdas and functors can't be used directly with a scheduler for they are not
 * properly defined processes with managed life cycles.<br/>
 * This class helps in filling the gap and turning lambdas and functors into
 * full featured processes usable by a scheduler.
 *
 * The signature of the function call operator should be equivalent to the
 * following:
 *
 * @code{.cpp}
 * void(Delta delta, void *data, auto succeed, auto fail);
 * @endcode
 *
 * Where:
 *
 * * `delta` is the elapsed time.
 * * `data` is an opaque pointer to user data if any, `nullptr` otherwise.
 * * `succeed` is a function to call when a process terminates with success.
 * * `fail` is a function to call when a process terminates with errors.
 *
 * The signature of the function call operator of both `succeed` and `fail`
 * is equivalent to the following:
 *
 * @code{.cpp}
 * void();
 * @endcode
 *
 * Usually users shouldn't worry about creating adaptors. A scheduler will
 * create them internally each and avery time a lambda or a functor is used as
 * a process.
 *
 * @sa process
 * @sa scheduler
 *
 * @tparam Func Actual type of process.
 * @tparam Delta Type to use to provide elapsed time.
 */
template<typename Func, typename Delta>
struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Func {
    /**
     * @brief Constructs a process adaptor from a lambda or a functor.
     * @tparam Args Types of arguments to use to initialize the actual process.
     * @param args Parameters to use to initialize the actual process.
     */
    template<typename... Args>
    process_adaptor(Args &&... args)
        : Func{std::forward<Args>(args)...}
    {}

    /**
     * @brief Updates a process and its internal state if required.
     * @param delta Elapsed time.
     * @param data Optional data.
     */
    void update(const Delta delta, void *data) {
        Func::operator()(delta, data, [this]() { this->succeed(); }, [this]() { this->fail(); });
    }
};


}


#endif

// #include "process/scheduler.hpp"
#ifndef ENTT_PROCESS_SCHEDULER_HPP
#define ENTT_PROCESS_SCHEDULER_HPP


#include <vector>
#include <memory>
#include <utility>
#include <algorithm>
#include <type_traits>
// #include "../config/config.h"

// #include "process.hpp"



namespace entt {


/**
 * @brief Cooperative scheduler for processes.
 *
 * A cooperative scheduler runs processes and helps managing their life cycles.
 *
 * Each process is invoked once per tick. If a process terminates, it's
 * removed automatically from the scheduler and it's never invoked again.<br/>
 * A process can also have a child. In this case, the process is replaced with
 * its child when it terminates if it returns with success. In case of errors,
 * both the process and its child are discarded.
 *
 * Example of use (pseudocode):
 *
 * @code{.cpp}
 * scheduler.attach([](auto delta, void *, auto succeed, auto fail) {
 *     // code
 * }).then<my_process>(arguments...);
 * @endcode
 *
 * In order to invoke all scheduled processes, call the `update` member function
 * passing it the elapsed time to forward to the tasks.
 *
 * @sa process
 *
 * @tparam Delta Type to use to provide elapsed time.
 */
template<typename Delta>
class scheduler {
    struct process_handler {
        using instance_type = std::unique_ptr<void, void(*)(void *)>;
        using update_fn_type = bool(process_handler &, Delta, void *);
        using abort_fn_type = void(process_handler &, bool);
        using next_type = std::unique_ptr<process_handler>;

        instance_type instance;
        update_fn_type *update;
        abort_fn_type *abort;
        next_type next;
    };

    struct continuation {
        continuation(process_handler *ref)
            : handler{ref}
        {
            ENTT_ASSERT(handler);
        }

        template<typename Proc, typename... Args>
        continuation then(Args &&... args) {
            static_assert(std::is_base_of_v<process<Proc, Delta>, Proc>);
            auto proc = typename process_handler::instance_type{new Proc{std::forward<Args>(args)...}, &scheduler::deleter<Proc>};
            handler->next.reset(new process_handler{std::move(proc), &scheduler::update<Proc>, &scheduler::abort<Proc>, nullptr});
            handler = handler->next.get();
            return *this;
        }

        template<typename Func>
        continuation then(Func &&func) {
            return then<process_adaptor<std::decay_t<Func>, Delta>>(std::forward<Func>(func));
        }

    private:
        process_handler *handler;
    };

    template<typename Proc>
    static bool update(process_handler &handler, const Delta delta, void *data) {
        auto *process = static_cast<Proc *>(handler.instance.get());
        process->tick(delta, data);

        auto dead = process->dead();

        if(dead) {
            if(handler.next && !process->rejected()) {
                handler = std::move(*handler.next);
                // forces the process to exit the uninitialized state
                dead = handler.update(handler, {}, nullptr);
            } else {
                handler.instance.reset();
            }
        }

        return dead;
    }

    template<typename Proc>
    static void abort(process_handler &handler, const bool immediately) {
        static_cast<Proc *>(handler.instance.get())->abort(immediately);
    }

    template<typename Proc>
    static void deleter(void *proc) {
        delete static_cast<Proc *>(proc);
    }

public:
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;

    /*! @brief Default constructor. */
    scheduler() = default;

    /*! @brief Default move constructor. */
    scheduler(scheduler &&) = default;

    /*! @brief Default move assignment operator. @return This scheduler. */
    scheduler & operator=(scheduler &&) = default;

    /**
     * @brief Number of processes currently scheduled.
     * @return Number of processes currently scheduled.
     */
    size_type size() const ENTT_NOEXCEPT {
        return handlers.size();
    }

    /**
     * @brief Returns true if at least a process is currently scheduled.
     * @return True if there are scheduled processes, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return handlers.empty();
    }

    /**
     * @brief Discards all scheduled processes.
     *
     * Processes aren't aborted. They are discarded along with their children
     * and never executed again.
     */
    void clear() {
        handlers.clear();
    }

    /**
     * @brief Schedules a process for the next tick.
     *
     * Returned value is an opaque object that can be used to attach a child to
     * the given process. The child is automatically scheduled when the process
     * terminates and only if the process returns with success.
     *
     * Example of use (pseudocode):
     *
     * @code{.cpp}
     * // schedules a task in the form of a process class
     * scheduler.attach<my_process>(arguments...)
     * // appends a child in the form of a lambda function
     * .then([](auto delta, void *, auto succeed, auto fail) {
     *     // code
     * })
     * // appends a child in the form of another process class
     * .then<my_other_process>();
     * @endcode
     *
     * @tparam Proc Type of process to schedule.
     * @tparam Args Types of arguments to use to initialize the process.
     * @param args Parameters to use to initialize the process.
     * @return An opaque object to use to concatenate processes.
     */
    template<typename Proc, typename... Args>
    auto attach(Args &&... args) {
        static_assert(std::is_base_of_v<process<Proc, Delta>, Proc>);
        auto proc = typename process_handler::instance_type{new Proc{std::forward<Args>(args)...}, &scheduler::deleter<Proc>};
        process_handler handler{std::move(proc), &scheduler::update<Proc>, &scheduler::abort<Proc>, nullptr};
        // forces the process to exit the uninitialized state
        handler.update(handler, {}, nullptr);
        return continuation{&handlers.emplace_back(std::move(handler))};
    }

    /**
     * @brief Schedules a process for the next tick.
     *
     * A process can be either a lambda or a functor. The scheduler wraps both
     * of them in a process adaptor internally.<br/>
     * The signature of the function call operator should be equivalent to the
     * following:
     *
     * @code{.cpp}
     * void(Delta delta, void *data, auto succeed, auto fail);
     * @endcode
     *
     * Where:
     *
     * * `delta` is the elapsed time.
     * * `data` is an opaque pointer to user data if any, `nullptr` otherwise.
     * * `succeed` is a function to call when a process terminates with success.
     * * `fail` is a function to call when a process terminates with errors.
     *
     * The signature of the function call operator of both `succeed` and `fail`
     * is equivalent to the following:
     *
     * @code{.cpp}
     * void();
     * @endcode
     *
     * Returned value is an opaque object that can be used to attach a child to
     * the given process. The child is automatically scheduled when the process
     * terminates and only if the process returns with success.
     *
     * Example of use (pseudocode):
     *
     * @code{.cpp}
     * // schedules a task in the form of a lambda function
     * scheduler.attach([](auto delta, void *, auto succeed, auto fail) {
     *     // code
     * })
     * // appends a child in the form of another lambda function
     * .then([](auto delta, void *, auto succeed, auto fail) {
     *     // code
     * })
     * // appends a child in the form of a process class
     * .then<my_process>(arguments...);
     * @endcode
     *
     * @sa process_adaptor
     *
     * @tparam Func Type of process to schedule.
     * @param func Either a lambda or a functor to use as a process.
     * @return An opaque object to use to concatenate processes.
     */
    template<typename Func>
    auto attach(Func &&func) {
        using Proc = process_adaptor<std::decay_t<Func>, Delta>;
        return attach<Proc>(std::forward<Func>(func));
    }

    /**
     * @brief Updates all scheduled processes.
     *
     * All scheduled processes are executed in no specific order.<br/>
     * If a process terminates with success, it's replaced with its child, if
     * any. Otherwise, if a process terminates with an error, it's removed along
     * with its child.
     *
     * @param delta Elapsed time.
     * @param data Optional data.
     */
    void update(const Delta delta, void *data = nullptr) {
        bool clean = false;

        for(auto pos = handlers.size(); pos; --pos) {
            auto &handler = handlers[pos-1];
            const bool dead = handler.update(handler, delta, data);
            clean = clean || dead;
        }

        if(clean) {
            handlers.erase(std::remove_if(handlers.begin(), handlers.end(), [](auto &handler) {
                return !handler.instance;
            }), handlers.end());
        }
    }

    /**
     * @brief Aborts all scheduled processes.
     *
     * Unless an immediate operation is requested, the abort is scheduled for
     * the next tick. Processes won't be executed anymore in any case.<br/>
     * Once a process is fully aborted and thus finished, it's discarded along
     * with its child, if any.
     *
     * @param immediately Requests an immediate operation.
     */
    void abort(const bool immediately = false) {
        decltype(handlers) exec;
        exec.swap(handlers);

        for(auto &&handler: exec) {
            handler.abort(handler, immediately);
        }

        std::move(handlers.begin(), handlers.end(), std::back_inserter(exec));
        handlers.swap(exec);
    }

private:
    std::vector<process_handler> handlers{};
};


}


#endif

// #include "resource/cache.hpp"
#ifndef ENTT_RESOURCE_CACHE_HPP
#define ENTT_RESOURCE_CACHE_HPP


#include <memory>
#include <type_traits>
#include <unordered_map>
#include <utility>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif

// #include "../core/fwd.hpp"
#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP


// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;


}


#endif

// #include "handle.hpp"
#ifndef ENTT_RESOURCE_HANDLE_HPP
#define ENTT_RESOURCE_HANDLE_HPP


#include <memory>
#include <utility>
// #include "../config/config.h"

// #include "fwd.hpp"
#ifndef ENTT_RESOURCE_FWD_HPP
#define ENTT_RESOURCE_FWD_HPP


namespace entt {


/*! @struct cache */
template<typename>
struct cache;

/*! @class handle */
template<typename>
class handle;

/*! @class loader */
template<typename, typename>
class loader;


}


#endif



namespace entt {


/**
 * @brief Shared resource handle.
 *
 * A shared resource handle is a small class that wraps a resource and keeps it
 * alive even if it's deleted from the cache. It can be either copied or
 * moved. A handle shares a reference to the same resource with all the other
 * handles constructed for the same identifier.<br/>
 * As a rule of thumb, resources should never be copied nor moved. Handles are
 * the way to go to keep references to them.
 *
 * @tparam Resource Type of resource managed by a handle.
 */
template<typename Resource>
class handle {
    /*! @brief Resource handles are friends of their caches. */
    friend struct cache<Resource>;

    handle(std::shared_ptr<Resource> res) ENTT_NOEXCEPT
        : resource{std::move(res)}
    {}

public:
    /*! @brief Default constructor. */
    handle() ENTT_NOEXCEPT = default;

    /**
     * @brief Gets a reference to the managed resource.
     *
     * @warning
     * The behavior is undefined if the handle doesn't contain a resource.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * handle is empty.
     *
     * @return A reference to the managed resource.
     */
    const Resource & get() const ENTT_NOEXCEPT {
        ENTT_ASSERT(static_cast<bool>(resource));
        return *resource;
    }

    /*! @copydoc get */
    Resource & get() ENTT_NOEXCEPT {
        return const_cast<Resource &>(std::as_const(*this).get());
    }

    /*! @copydoc get */
    operator const Resource & () const ENTT_NOEXCEPT { return get(); }

    /*! @copydoc get */
    operator Resource & () ENTT_NOEXCEPT { return get(); }

    /*! @copydoc get */
    const Resource & operator *() const ENTT_NOEXCEPT { return get(); }

    /*! @copydoc get */
    Resource & operator *() ENTT_NOEXCEPT { return get(); }

    /**
     * @brief Gets a pointer to the managed resource.
     *
     * @warning
     * The behavior is undefined if the handle doesn't contain a resource.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * handle is empty.
     *
     * @return A pointer to the managed resource or `nullptr` if the handle
     * contains no resource at all.
     */
    const Resource * operator->() const ENTT_NOEXCEPT {
        ENTT_ASSERT(static_cast<bool>(resource));
        return resource.get();
    }

    /*! @copydoc operator-> */
    Resource * operator->() ENTT_NOEXCEPT {
        return const_cast<Resource *>(std::as_const(*this).operator->());
    }

    /**
     * @brief Returns true if a handle contains a resource, false otherwise.
     * @return True if the handle contains a resource, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return static_cast<bool>(resource);
    }

private:
    std::shared_ptr<Resource> resource;
};


}


#endif

// #include "loader.hpp"
#ifndef ENTT_RESOURCE_LOADER_HPP
#define ENTT_RESOURCE_LOADER_HPP


#include <memory>
// #include "fwd.hpp"



namespace entt {


/**
 * @brief Base class for resource loaders.
 *
 * Resource loaders must inherit from this class and stay true to the CRTP
 * idiom. Moreover, a resource loader must expose a public, const member
 * function named `load` that accepts a variable number of arguments and returns
 * a shared pointer to the resource just created.<br/>
 * As an example:
 *
 * @code{.cpp}
 * struct my_resource {};
 *
 * struct my_loader: entt::loader<my_loader, my_resource> {
 *     std::shared_ptr<my_resource> load(int) const {
 *         // use the integer value somehow
 *         return std::make_shared<my_resource>();
 *     }
 * };
 * @endcode
 *
 * In general, resource loaders should not have a state or retain data of any
 * type. They should let the cache manage their resources instead.
 *
 * @note
 * Base class and CRTP idiom aren't strictly required with the current
 * implementation. One could argue that a cache can easily work with loaders of
 * any type. However, future changes won't be breaking ones by forcing the use
 * of a base class today and that's why the model is already in its place.
 *
 * @tparam Loader Type of the derived class.
 * @tparam Resource Type of resource for which to use the loader.
 */
template<typename Loader, typename Resource>
class loader {
    /*! @brief Resource loaders are friends of their caches. */
    friend struct cache<Resource>;

    /**
     * @brief Loads the resource and returns it.
     * @tparam Args Types of arguments for the loader.
     * @param args Arguments for the loader.
     * @return The resource just loaded or an empty pointer in case of errors.
     */
    template<typename... Args>
    std::shared_ptr<Resource> get(Args &&... args) const {
        return static_cast<const Loader *>(this)->load(std::forward<Args>(args)...);
    }
};


}


#endif

// #include "fwd.hpp"



namespace entt {


/**
 * @brief Simple cache for resources of a given type.
 *
 * Minimal implementation of a cache for resources of a given type. It doesn't
 * offer much functionalities but it's suitable for small or medium sized
 * applications and can be freely inherited to add targeted functionalities for
 * large sized applications.
 *
 * @tparam Resource Type of resources managed by a cache.
 */
template<typename Resource>
struct cache {
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Type of resources managed by a cache. */
    using resource_type = Resource;

    /*! @brief Default constructor. */
    cache() = default;

    /*! @brief Default move constructor. */
    cache(cache &&) = default;

    /*! @brief Default move assignment operator. @return This cache. */
    cache & operator=(cache &&) = default;

    /**
     * @brief Number of resources managed by a cache.
     * @return Number of resources currently stored.
     */
    size_type size() const ENTT_NOEXCEPT {
        return resources.size();
    }

    /**
     * @brief Returns true if a cache contains no resources, false otherwise.
     * @return True if the cache contains no resources, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return resources.empty();
    }

    /**
     * @brief Clears a cache and discards all its resources.
     *
     * Handles are not invalidated and the memory used by a resource isn't
     * freed as long as at least a handle keeps the resource itself alive.
     */
    void clear() ENTT_NOEXCEPT {
        resources.clear();
    }

    /**
     * @brief Loads the resource that corresponds to a given identifier.
     *
     * In case an identifier isn't already present in the cache, it loads its
     * resource and stores it aside for future uses. Arguments are forwarded
     * directly to the loader in order to construct properly the requested
     * resource.
     *
     * @note
     * If the identifier is already present in the cache, this function does
     * nothing and the arguments are simply discarded.
     *
     * @warning
     * If the resource cannot be loaded correctly, the returned handle will be
     * invalid and any use of it will result in undefined behavior.
     *
     * @tparam Loader Type of loader to use to load the resource if required.
     * @tparam Args Types of arguments to use to load the resource if required.
     * @param id Unique resource identifier.
     * @param args Arguments to use to load the resource if required.
     * @return A handle for the given resource.
     */
    template<typename Loader, typename... Args>
    entt::handle<Resource> load(const id_type id, Args &&... args) {
        static_assert(std::is_base_of_v<loader<Loader, Resource>, Loader>);
        entt::handle<Resource> resource{};

        if(auto it = resources.find(id); it == resources.cend()) {
            if(auto instance = Loader{}.get(std::forward<Args>(args)...); instance) {
                resources[id] = instance;
                resource = std::move(instance);
            }
        } else {
            resource = it->second;
        }

        return resource;
    }

    /**
     * @brief Reloads a resource or loads it for the first time if not present.
     *
     * Equivalent to the following snippet (pseudocode):
     *
     * @code{.cpp}
     * cache.discard(id);
     * cache.load(id, args...);
     * @endcode
     *
     * Arguments are forwarded directly to the loader in order to construct
     * properly the requested resource.
     *
     * @warning
     * If the resource cannot be loaded correctly, the returned handle will be
     * invalid and any use of it will result in undefined behavior.
     *
     * @tparam Loader Type of loader to use to load the resource.
     * @tparam Args Types of arguments to use to load the resource.
     * @param id Unique resource identifier.
     * @param args Arguments to use to load the resource.
     * @return A handle for the given resource.
     */
    template<typename Loader, typename... Args>
    entt::handle<Resource> reload(const id_type id, Args &&... args) {
        return (discard(id), load<Loader>(id, std::forward<Args>(args)...));
    }

    /**
     * @brief Creates a temporary handle for a resource.
     *
     * Arguments are forwarded directly to the loader in order to construct
     * properly the requested resource. The handle isn't stored aside and the
     * cache isn't in charge of the lifetime of the resource itself.
     *
     * @tparam Loader Type of loader to use to load the resource.
     * @tparam Args Types of arguments to use to load the resource.
     * @param args Arguments to use to load the resource.
     * @return A handle for the given resource.
     */
    template<typename Loader, typename... Args>
    entt::handle<Resource> temp(Args &&... args) const {
        return { Loader{}.get(std::forward<Args>(args)...) };
    }

    /**
     * @brief Creates a handle for a given resource identifier.
     *
     * A resource handle can be in a either valid or invalid state. In other
     * terms, a resource handle is properly initialized with a resource if the
     * cache contains the resource itself. Otherwise the returned handle is
     * uninitialized and accessing it results in undefined behavior.
     *
     * @sa handle
     *
     * @param id Unique resource identifier.
     * @return A handle for the given resource.
     */
    entt::handle<Resource> handle(const id_type id) const {
        auto it = resources.find(id);
        return { it == resources.end() ? nullptr : it->second };
    }

    /**
     * @brief Checks if a cache contains a given identifier.
     * @param id Unique resource identifier.
     * @return True if the cache contains the resource, false otherwise.
     */
    bool contains(const id_type id) const {
        return (resources.find(id) != resources.cend());
    }

    /**
     * @brief Discards the resource that corresponds to a given identifier.
     *
     * Handles are not invalidated and the memory used by the resource isn't
     * freed as long as at least a handle keeps the resource itself alive.
     *
     * @param id Unique resource identifier.
     */
    void discard(const id_type id) {
        if(auto it = resources.find(id); it != resources.end()) {
            resources.erase(it);
        }
    }

    /**
     * @brief Iterates all resources.
     *
     * The function object is invoked for each element. It is provided with
     * either the resource identifier, the resource handle or both of them.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const id_type);
     * void(handle<Resource>);
     * void(const id_type, handle<Resource>);
     * @endcode
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template <typename Func>
    void each(Func func) const {
        auto begin = resources.begin();
        auto end = resources.end();

        while(begin != end) {
            auto curr = begin++;

            if constexpr(std::is_invocable_v<Func, id_type>) {
                func(curr->first);
            } else if constexpr(std::is_invocable_v<Func, entt::handle<Resource>>) {
                func(entt::handle{ curr->second });
            } else {
                func(curr->first, entt::handle{ curr->second });
            }
        }
    }

private:
    std::unordered_map<id_type, std::shared_ptr<Resource>> resources;
};


}


#endif

// #include "resource/handle.hpp"

// #include "resource/loader.hpp"

// #include "signal/delegate.hpp"
#ifndef ENTT_SIGNAL_DELEGATE_HPP
#define ENTT_SIGNAL_DELEGATE_HPP


#include <tuple>
#include <cstddef>
#include <utility>
#include <functional>
#include <type_traits>
// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename Ret, typename... Args>
auto function_pointer(Ret(*)(Args...)) -> Ret(*)(Args...);


template<typename Ret, typename Type, typename... Args, typename Other>
auto function_pointer(Ret(*)(Type, Args...), Other &&) -> Ret(*)(Args...);


template<typename Class, typename Ret, typename... Args, typename... Other>
auto function_pointer(Ret(Class:: *)(Args...), Other &&...) -> Ret(*)(Args...);


template<typename Class, typename Ret, typename... Args, typename... Other>
auto function_pointer(Ret(Class:: *)(Args...) const, Other &&...) -> Ret(*)(Args...);


template<typename Class, typename Type, typename... Other>
auto function_pointer(Type Class:: *, Other &&...) -> Type(*)();


template<typename... Type>
using function_pointer_t = decltype(internal::function_pointer(std::declval<Type>()...));


template<typename... Class, typename Ret, typename... Args>
constexpr auto index_sequence_for(Ret(*)(Args...)) {
    return std::index_sequence_for<Class..., Args...>{};
}


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/*! @brief Used to wrap a function or a member of a specified type. */
template<auto>
struct connect_arg_t {};


/*! @brief Constant of type connect_arg_t used to disambiguate calls. */
template<auto Func>
inline constexpr connect_arg_t<Func> connect_arg{};


/**
 * @brief Basic delegate implementation.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 */
template<typename>
class delegate;


/**
 * @brief Utility class to use to send around functions and members.
 *
 * Unmanaged delegate for function pointers and members. Users of this class are
 * in charge of disconnecting instances before deleting them.
 *
 * A delegate can be used as a general purpose invoker without memory overhead
 * for free functions possibly with payloads and bound or unbound members.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class delegate<Ret(Args...)> {
    using proto_fn_type = Ret(const void *, Args...);

    template<auto Candidate, std::size_t... Index>
    auto wrap(std::index_sequence<Index...>) ENTT_NOEXCEPT {
        return [](const void *, Args... args) -> Ret {
            const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            return Ret(std::invoke(Candidate, std::forward<std::tuple_element_t<Index, std::tuple<Args...>>>(std::get<Index>(arguments))...));
        };
    }

    template<auto Candidate, typename Type, std::size_t... Index>
    auto wrap(Type &, std::index_sequence<Index...>) ENTT_NOEXCEPT {
        return [](const void *payload, Args... args) -> Ret {
            const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
            return Ret(std::invoke(Candidate, *curr, std::forward<std::tuple_element_t<Index, std::tuple<Args...>>>(std::get<Index>(arguments))...));
        };
    }

    template<auto Candidate, typename Type, std::size_t... Index>
    auto wrap(Type *, std::index_sequence<Index...>) ENTT_NOEXCEPT {
        return [](const void *payload, Args... args) -> Ret {
            const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
            return Ret(std::invoke(Candidate, curr, std::forward<std::tuple_element_t<Index, std::tuple<Args...>>>(std::get<Index>(arguments))...));
        };
    }

public:
    /*! @brief Function type of the delegate. */
    using function_type = Ret(Args...);

    /*! @brief Default constructor. */
    delegate() ENTT_NOEXCEPT
        : fn{nullptr}, data{nullptr}
    {}

    /**
     * @brief Constructs a delegate and connects a free function or an unbound
     * member.
     * @tparam Candidate Function or member to connect to the delegate.
     */
    template<auto Candidate>
    delegate(connect_arg_t<Candidate>) ENTT_NOEXCEPT
        : delegate{}
    {
        connect<Candidate>();
    }

    /**
     * @brief Constructs a delegate and connects a free function with payload or
     * a bound member.
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<auto Candidate, typename Type>
    delegate(connect_arg_t<Candidate>, Type &&value_or_instance) ENTT_NOEXCEPT
        : delegate{}
    {
        connect<Candidate>(std::forward<Type>(value_or_instance));
    }

    /**
     * @brief Connects a free function or an unbound member to a delegate.
     * @tparam Candidate Function or member to connect to the delegate.
     */
    template<auto Candidate>
    void connect() ENTT_NOEXCEPT {
        data = nullptr;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
            fn = [](const void *, Args... args) -> Ret {
                return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
            };
        } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
            fn = wrap<Candidate>(internal::index_sequence_for<std::tuple_element_t<0, std::tuple<Args...>>>(internal::function_pointer_t<decltype(Candidate)>{}));
        } else {
            fn = wrap<Candidate>(internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate)>{}));
        }
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * delegate.
     *
     * The delegate isn't responsible for the connected object or the payload.
     * Users must always guarantee that the lifetime of the instance overcomes
     * the one  of the delegate.<br/>
     * When used to connect a free function with payload, its signature must be
     * such that the instance is the first argument before the ones used to
     * define the delegate itself.
     *
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid reference that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void connect(Type &value_or_instance) ENTT_NOEXCEPT {
        data = &value_or_instance;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
            fn = [](const void *payload, Args... args) -> Ret {
                Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
                return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
            };
        } else {
            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
        }
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * delegate.
     *
     * @sa connect(Type &)
     *
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid pointer that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void connect(Type *value_or_instance) ENTT_NOEXCEPT {
        data = value_or_instance;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
            fn = [](const void *payload, Args... args) -> Ret {
                Type *curr = static_cast<Type *>(const_cast<std::conditional_t<std::is_const_v<Type>, const void *, void *>>(payload));
                return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
            };
        } else {
            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
        }
    }

    /**
     * @brief Resets a delegate.
     *
     * After a reset, a delegate cannot be invoked anymore.
     */
    void reset() ENTT_NOEXCEPT {
        fn = nullptr;
        data = nullptr;
    }

    /**
     * @brief Returns the instance or the payload linked to a delegate, if any.
     * @return An opaque pointer to the underlying data.
     */
    const void * instance() const ENTT_NOEXCEPT {
        return data;
    }

    /**
     * @brief Triggers a delegate.
     *
     * The delegate invokes the underlying function and returns the result.
     *
     * @warning
     * Attempting to trigger an invalid delegate results in undefined
     * behavior.<br/>
     * An assertion will abort the execution at runtime in debug mode if the
     * delegate has not yet been set.
     *
     * @param args Arguments to use to invoke the underlying function.
     * @return The value returned by the underlying function.
     */
    Ret operator()(Args... args) const {
        ENTT_ASSERT(fn);
        return fn(data, std::forward<Args>(args)...);
    }

    /**
     * @brief Checks whether a delegate actually stores a listener.
     * @return False if the delegate is empty, true otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        // no need to test also data
        return !(fn == nullptr);
    }

    /**
     * @brief Compares the contents of two delegates.
     * @param other Delegate with which to compare.
     * @return False if the two contents differ, true otherwise.
     */
    bool operator==(const delegate<Ret(Args...)> &other) const ENTT_NOEXCEPT {
        return fn == other.fn && data == other.data;
    }

private:
    proto_fn_type *fn;
    const void *data;
};


/**
 * @brief Compares the contents of two delegates.
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 * @param lhs A valid delegate object.
 * @param rhs A valid delegate object.
 * @return True if the two contents differ, false otherwise.
 */
template<typename Ret, typename... Args>
bool operator!=(const delegate<Ret(Args...)> &lhs, const delegate<Ret(Args...)> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/**
 * @brief Deduction guide.
 * @tparam Candidate Function or member to connect to the delegate.
 */
template<auto Candidate>
delegate(connect_arg_t<Candidate>) ENTT_NOEXCEPT
-> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate)>>>;


/**
 * @brief Deduction guide.
 * @tparam Candidate Function or member to connect to the delegate.
 * @tparam Type Type of class or type of payload.
 */
template<auto Candidate, typename Type>
delegate(connect_arg_t<Candidate>, Type &&) ENTT_NOEXCEPT
-> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate), Type>>>;


}


#endif

// #include "signal/dispatcher.hpp"
#ifndef ENTT_SIGNAL_DISPATCHER_HPP
#define ENTT_SIGNAL_DISPATCHER_HPP


#include <cstddef>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>
// #include "../config/config.h"

// #include "../core/fwd.hpp"
#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP


// #include "../config/config.h"
#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#ifndef ENTT_NOEXCEPT
#   define ENTT_NOEXCEPT noexcept
#endif


#ifndef ENTT_HS_SUFFIX
#   define ENTT_HS_SUFFIX _hs
#endif


#ifndef ENTT_HWS_SUFFIX
#   define ENTT_HWS_SUFFIX _hws
#endif


#ifndef ENTT_USE_ATOMIC
#   define ENTT_MAYBE_ATOMIC(Type) Type
#else
#   include <atomic>
#   define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#endif


#ifndef ENTT_ID_TYPE
#   include <cstdint>
#   define ENTT_ID_TYPE std::uint32_t
#endif


#ifndef ENTT_PAGE_SIZE
#   define ENTT_PAGE_SIZE 32768
#endif


#ifndef ENTT_ASSERT
#   include <cassert>
#   define ENTT_ASSERT(condition) assert(condition)
#endif


#ifndef ENTT_NO_ETO
#   include <type_traits>
#   define ENTT_IS_EMPTY(Type) std::is_empty_v<Type>
#else
#   include <type_traits>
#   // sfinae-friendly definition
#   define ENTT_IS_EMPTY(Type) (false && std::is_empty_v<Type>)
#endif


#ifndef ENTT_STANDARD_CPP
#   if defined _MSC_VER
#      define ENTT_PRETTY_FUNCTION __FUNCSIG__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __clang__ || (defined __GNUC__ && __GNUC__ > 8)
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) constexpr
#   elif defined __GNUC__
#      define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#      define ENTT_PRETTY_FUNCTION_CONSTEXPR(...) __VA_ARGS__
#   endif
#endif


#endif



namespace entt {


/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;


}


#endif

// #include "../core/type_info.hpp"
#ifndef ENTT_CORE_TYPE_INFO_HPP
#define ENTT_CORE_TYPE_INFO_HPP


// #include "../config/config.h"

// #include "../core/attribute.h"
#ifndef ENTT_CORE_ATTRIBUTE_H
#define ENTT_CORE_ATTRIBUTE_H


#ifndef ENTT_EXPORT
#   if defined _WIN32 || defined __CYGWIN__ || defined _MSC_VER
#       define ENTT_EXPORT __declspec(dllexport)
#       define ENTT_IMPORT __declspec(dllimport)
#       define ENTT_HIDDEN
#   elif defined __GNUC__ && __GNUC__ >= 4
#       define ENTT_EXPORT __attribute__((visibility("default")))
#       define ENTT_IMPORT __attribute__((visibility("default")))
#       define ENTT_HIDDEN __attribute__((visibility("hidden")))
#   else /* Unsupported compiler */
#       define ENTT_EXPORT
#       define ENTT_IMPORT
#       define ENTT_HIDDEN
#   endif
#endif


#ifndef ENTT_API
#   if defined ENTT_API_EXPORT
#       define ENTT_API ENTT_EXPORT
#   elif defined ENTT_API_IMPORT
#       define ENTT_API ENTT_IMPORT
#   else /* No API */
#       define ENTT_API
#   endif
#endif


#endif

// #include "hashed_string.hpp"
#ifndef ENTT_CORE_HASHED_STRING_HPP
#define ENTT_CORE_HASHED_STRING_HPP


#include <cstddef>
#include <cstdint>
// #include "../config/config.h"

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


template<typename>
struct fnv1a_traits;


template<>
struct fnv1a_traits<std::uint32_t> {
    using type = std::uint32_t;
    static constexpr std::uint32_t offset = 2166136261;
    static constexpr std::uint32_t prime = 16777619;
};


template<>
struct fnv1a_traits<std::uint64_t> {
    using type = std::uint64_t;
    static constexpr std::uint64_t offset = 14695981039346656037ull;
    static constexpr std::uint64_t prime = 1099511628211ull;
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Zero overhead unique identifier.
 *
 * A hashed string is a compile-time tool that allows users to use
 * human-readable identifers in the codebase while using their numeric
 * counterparts at runtime.<br/>
 * Because of that, a hashed string can also be used in constant expressions if
 * required.
 *
 * @tparam Char Character type.
 */
template<typename Char>
class basic_hashed_string {
    using traits_type = internal::fnv1a_traits<id_type>;

    struct const_wrapper {
        // non-explicit constructor on purpose
        constexpr const_wrapper(const Char *curr) ENTT_NOEXCEPT: str{curr} {}
        const Char *str;
    };

    // Fowler–Noll–Vo hash function v. 1a - the good
    static constexpr id_type helper(const Char *curr) ENTT_NOEXCEPT {
        auto value = traits_type::offset;

        while(*curr != 0) {
            value = (value ^ static_cast<traits_type::type>(*(curr++))) * traits_type::prime;
        }

        return value;
    }

public:
    /*! @brief Character type. */
    using value_type = Char;
    /*! @brief Unsigned integer type. */
    using hash_type = id_type;

    /**
     * @brief Returns directly the numeric representation of a string.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * const auto value = basic_hashed_string<char>::to_value("my.png");
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifer.
     * @return The numeric representation of the string.
     */
    template<std::size_t N>
    static constexpr hash_type value(const value_type (&str)[N]) ENTT_NOEXCEPT {
        return helper(str);
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     * @return The numeric representation of the string.
     */
    static hash_type value(const_wrapper wrapper) ENTT_NOEXCEPT {
        return helper(wrapper.str);
    }

    /**
     * @brief Returns directly the numeric representation of a string view.
     * @param str Human-readable identifer.
     * @param size Length of the string to hash.
     * @return The numeric representation of the string.
     */
    static hash_type value(const value_type *str, std::size_t size) ENTT_NOEXCEPT {
        id_type partial{traits_type::offset};
        while(size--) { partial = (partial^(str++)[0])*traits_type::prime; }
        return partial;
    }

    /*! @brief Constructs an empty hashed string. */
    constexpr basic_hashed_string() ENTT_NOEXCEPT
        : str{nullptr}, hash{}
    {}

    /**
     * @brief Constructs a hashed string from an array of const characters.
     *
     * Forcing template resolution avoids implicit conversions. An
     * human-readable identifier can be anything but a plain, old bunch of
     * characters.<br/>
     * Example of use:
     * @code{.cpp}
     * basic_hashed_string<char> hs{"my.png"};
     * @endcode
     *
     * @tparam N Number of characters of the identifier.
     * @param curr Human-readable identifer.
     */
    template<std::size_t N>
    constexpr basic_hashed_string(const value_type (&curr)[N]) ENTT_NOEXCEPT
        : str{curr}, hash{helper(curr)}
    {}

    /**
     * @brief Explicit constructor on purpose to avoid constructing a hashed
     * string directly from a `const value_type *`.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     */
    explicit constexpr basic_hashed_string(const_wrapper wrapper) ENTT_NOEXCEPT
        : str{wrapper.str}, hash{helper(wrapper.str)}
    {}

    /**
     * @brief Returns the human-readable representation of a hashed string.
     * @return The string used to initialize the instance.
     */
    constexpr const value_type * data() const ENTT_NOEXCEPT {
        return str;
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr hash_type value() const ENTT_NOEXCEPT {
        return hash;
    }

    /*! @copydoc data */
    constexpr operator const value_type *() const ENTT_NOEXCEPT { return data(); }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the instance.
     */
    constexpr operator hash_type() const ENTT_NOEXCEPT { return value(); }

    /**
     * @brief Compares two hashed strings.
     * @param other Hashed string with which to compare.
     * @return True if the two hashed strings are identical, false otherwise.
     */
    constexpr bool operator==(const basic_hashed_string &other) const ENTT_NOEXCEPT {
        return hash == other.hash;
    }

private:
    const value_type *str;
    hash_type hash;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the character type of the hashed string directly from a
 * human-readable identifer provided to the constructor.
 *
 * @tparam Char Character type.
 * @tparam N Number of characters of the identifier.
 * @param str Human-readable identifer.
 */
template<typename Char, std::size_t N>
basic_hashed_string(const Char (&str)[N]) ENTT_NOEXCEPT
-> basic_hashed_string<Char>;


/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings are identical, false otherwise.
 */
template<typename Char>
constexpr bool operator!=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) ENTT_NOEXCEPT {
    return !(lhs == rhs);
}


/*! @brief Aliases for common character types. */
using hashed_string = basic_hashed_string<char>;


/*! @brief Aliases for common character types. */
using hashed_wstring = basic_hashed_string<wchar_t>;


}


/**
 * @brief User defined literal for hashed strings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed string.
 */
constexpr entt::hashed_string operator"" ENTT_HS_SUFFIX(const char *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_string{str};
}


/**
 * @brief User defined literal for hashed wstrings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed wstring.
 */
constexpr entt::hashed_wstring operator"" ENTT_HWS_SUFFIX(const wchar_t *str, std::size_t) ENTT_NOEXCEPT {
    return entt::hashed_wstring{str};
}


#endif

// #include "fwd.hpp"



namespace entt {


/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */


namespace internal {


struct ENTT_API type_index {
    static id_type next() ENTT_NOEXCEPT {
        static ENTT_MAYBE_ATOMIC(id_type) value{};
        return value++;
    }
};


}


/**
 * Internal details not to be documented.
 * @endcond TURN_OFF_DOXYGEN
 */


/**
 * @brief Type index.
 * @tparam Type Type for which to generate a sequential identifier.
 */
template<typename Type, typename = void>
struct ENTT_API type_index {
    /**
     * @brief Returns the sequential identifier of a given type.
     * @return The sequential identifier of a given type.
     */
    static id_type value() ENTT_NOEXCEPT {
        static const id_type value = internal::type_index::next();
        return value;
    }
};


/**
 * @brief Provides the member constant `value` to true if a given type is
 * indexable, false otherwise.
 * @tparam Type Potentially indexable type.
 */
template<typename, typename = void>
struct has_type_index: std::false_type {};


/*! @brief has_type_index */
template<typename Type>
struct has_type_index<Type, std::void_t<decltype(type_index<Type>::value())>>: std::true_type {};


/**
 * @brief Helper variable template.
 * @tparam Type Potentially indexable type.
 */
template<typename Type>
inline constexpr bool has_type_index_v = has_type_index<Type>::value;


/**
 * @brief Type info.
 * @tparam Type Type for which to generate information.
 */
template<typename Type, typename = void>
struct ENTT_API type_info {
    /**
     * @brief Returns the numeric representation of a given type.
     * @return The numeric representation of the given type.
     */
#if defined ENTT_PRETTY_FUNCTION
    static ENTT_PRETTY_FUNCTION_CONSTEXPR() id_type id() ENTT_NOEXCEPT {
        ENTT_PRETTY_FUNCTION_CONSTEXPR(static const) auto value = entt::hashed_string::value(ENTT_PRETTY_FUNCTION);
        return value;
    }
#else
    static id_type id() ENTT_NOEXCEPT {
        return type_index<Type>::value();
    }
#endif
};


}


#endif

// #include "sigh.hpp"
#ifndef ENTT_SIGNAL_SIGH_HPP
#define ENTT_SIGNAL_SIGH_HPP


#include <vector>
#include <utility>
#include <iterator>
#include <algorithm>
#include <functional>
#include <type_traits>
// #include "../config/config.h"

// #include "delegate.hpp"

// #include "fwd.hpp"
#ifndef ENTT_SIGNAL_FWD_HPP
#define ENTT_SIGNAL_FWD_HPP


namespace entt {


/*! @class delegate */
template<typename>
class delegate;

/*! @class dispatcher */
class dispatcher;

/*! @class emitter */
template<typename>
class emitter;

/*! @class connection */
class connection;

/*! @class scoped_connection */
struct scoped_connection;

/*! @class sink */
template<typename>
class sink;

/*! @class sigh */
template<typename>
class sigh;


}


#endif



namespace entt {


/**
 * @brief Sink class.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 *
 * @tparam Function A valid function type.
 */
template<typename Function>
class sink;


/**
 * @brief Unmanaged signal handler.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 *
 * @tparam Function A valid function type.
 */
template<typename Function>
class sigh;


/**
 * @brief Unmanaged signal handler.
 *
 * It works directly with references to classes and pointers to member functions
 * as well as pointers to free functions. Users of this class are in charge of
 * disconnecting instances before deleting them.
 *
 * This class serves mainly two purposes:
 *
 * * Creating signals to use later to notify a bunch of listeners.
 * * Collecting results from a set of functions like in a voting system.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class sigh<Ret(Args...)> {
    /*! @brief A sink is allowed to modify a signal. */
    friend class sink<Ret(Args...)>;

public:
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Sink type. */
    using sink_type = entt::sink<Ret(Args...)>;

    /**
     * @brief Instance type when it comes to connecting member functions.
     * @tparam Class Type of class to which the member function belongs.
     */
    template<typename Class>
    using instance_type = Class *;

    /**
     * @brief Number of listeners connected to the signal.
     * @return Number of listeners currently connected.
     */
    size_type size() const ENTT_NOEXCEPT {
        return calls.size();
    }

    /**
     * @brief Returns false if at least a listener is connected to the signal.
     * @return True if the signal has no listeners connected, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return calls.empty();
    }

    /**
     * @brief Triggers a signal.
     *
     * All the listeners are notified. Order isn't guaranteed.
     *
     * @param args Arguments to use to invoke listeners.
     */
    void publish(Args... args) const {
        for(auto &&call: std::as_const(calls)) {
            call(args...);
        }
    }

    /**
     * @brief Collects return values from the listeners.
     *
     * The collector must expose a call operator with the following properties:
     *
     * * The return type is either `void` or such that it's convertible to
     *   `bool`. In the second case, a true value will stop the iteration.
     * * The list of parameters is empty if `Ret` is `void`, otherwise it
     *   contains a single element such that `Ret` is convertible to it.
     *
     * @tparam Func Type of collector to use, if any.
     * @param func A valid function object.
     * @param args Arguments to use to invoke listeners.
     */
    template<typename Func>
    void collect(Func func, Args... args) const {
        for(auto &&call: calls) {
            if constexpr(std::is_void_v<Ret>) {
                if constexpr(std::is_invocable_r_v<bool, Func>) {
                    call(args...);
                    if(func()) { break; }
                } else {
                    call(args...);
                    func();
                }
            } else {
                if constexpr(std::is_invocable_r_v<bool, Func, Ret>) {
                    if(func(call(args...))) { break; }
                } else {
                    func(call(args...));
                }
            }
        }
    }

private:
    std::vector<delegate<Ret(Args...)>> calls;
};


/**
 * @brief Connection class.
 *
 * Opaque object the aim of which is to allow users to release an already
 * estabilished connection without having to keep a reference to the signal or
 * the sink that generated it.
 */
class connection {
    /*! @brief A sink is allowed to create connection objects. */
    template<typename>
    friend class sink;

    connection(delegate<void(void *)> fn, void *ref)
        : disconnect{fn}, signal{ref}
    {}

public:
    /*! @brief Default constructor. */
    connection() = default;

    /**
     * @brief Checks whether a connection is properly initialized.
     * @return True if the connection is properly initialized, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return static_cast<bool>(disconnect);
    }

    /*! @brief Breaks the connection. */
    void release() {
        if(disconnect) {
            disconnect(signal);
            disconnect.reset();
        }
    }

private:
    delegate<void(void *)> disconnect;
    void *signal{};
};


/**
 * @brief Scoped connection class.
 *
 * Opaque object the aim of which is to allow users to release an already
 * estabilished connection without having to keep a reference to the signal or
 * the sink that generated it.<br/>
 * A scoped connection automatically breaks the link between the two objects
 * when it goes out of scope.
 */
struct scoped_connection {
    /*! @brief Default constructor. */
    scoped_connection() = default;

    /**
     * @brief Constructs a scoped connection from a basic connection.
     * @param other A valid connection object.
     */
    scoped_connection(const connection &other)
        : conn{other}
    {}

    /*! @brief Default copy constructor, deleted on purpose. */
    scoped_connection(const scoped_connection &) = delete;

    /*! @brief Automatically breaks the link on destruction. */
    ~scoped_connection() {
        conn.release();
    }

    /**
     * @brief Default copy assignment operator, deleted on purpose.
     * @return This scoped connection.
     */
    scoped_connection & operator=(const scoped_connection &) = delete;

    /**
     * @brief Acquires a connection.
     * @param other The connection object to acquire.
     * @return This scoped connection.
     */
    scoped_connection & operator=(connection other) {
        conn = std::move(other);
        return *this;
    }

    /**
     * @brief Checks whether a scoped connection is properly initialized.
     * @return True if the connection is properly initialized, false otherwise.
     */
    explicit operator bool() const ENTT_NOEXCEPT {
        return static_cast<bool>(conn);
    }

    /*! @brief Breaks the connection. */
    void release() {
        conn.release();
    }

private:
    connection conn;
};


/**
 * @brief Sink class.
 *
 * A sink is used to connect listeners to signals and to disconnect them.<br/>
 * The function type for a listener is the one of the signal to which it
 * belongs.
 *
 * The clear separation between a signal and a sink permits to store the former
 * as private data member without exposing the publish functionality to the
 * users of the class.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class sink<Ret(Args...)> {
    using signal_type = sigh<Ret(Args...)>;
    using difference_type = typename std::iterator_traits<typename decltype(signal_type::calls)::iterator>::difference_type;

    template<auto Candidate, typename Type>
    static void release(Type value_or_instance, void *signal) {
        sink{*static_cast<signal_type *>(signal)}.disconnect<Candidate>(value_or_instance);
    }

    template<auto Candidate>
    static void release(void *signal) {
        sink{*static_cast<signal_type *>(signal)}.disconnect<Candidate>();
    }

public:
    /**
     * @brief Constructs a sink that is allowed to modify a given signal.
     * @param ref A valid reference to a signal object.
     */
    sink(sigh<Ret(Args...)> &ref) ENTT_NOEXCEPT
        : offset{},
          signal{&ref}
    {}

    /**
     * @brief Returns false if at least a listener is connected to the sink.
     * @return True if the sink has no listeners connected, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return signal->calls.empty();
    }

    /**
     * @brief Returns a sink that connects before a given free function or an
     * unbound member.
     * @tparam Function A valid free function pointer.
     * @return A properly initialized sink object.
     */
    template<auto Function>
    sink before() {
        delegate<Ret(Args...)> call{};
        call.template connect<Function>();

        const auto &calls = signal->calls;
        const auto it = std::find(calls.cbegin(), calls.cend(), std::move(call));

        sink other{*this};
        other.offset = std::distance(it, calls.cend());
        return other;
    }

    /**
     * @brief Returns a sink that connects before a free function with payload
     * or a bound member.
     * @tparam Candidate Member or free function to look for.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     * @return A properly initialized sink object.
     */
    template<auto Candidate, typename Type>
    sink before(Type &&value_or_instance) {
        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>(std::forward<Type>(value_or_instance));

        const auto &calls = signal->calls;
        const auto it = std::find(calls.cbegin(), calls.cend(), std::move(call));

        sink other{*this};
        other.offset = std::distance(it, calls.cend());
        return other;
    }

    /**
     * @brief Returns a sink that connects before a given instance or specific
     * payload.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     * @return A properly initialized sink object.
     */
    template<typename Type>
    sink before(Type &value_or_instance) {
        return before(&value_or_instance);
    }

    /**
     * @brief Returns a sink that connects before a given instance or specific
     * payload.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid pointer that fits the purpose.
     * @return A properly initialized sink object.
     */
    template<typename Type>
    sink before(Type *value_or_instance) {
        sink other{*this};

        if(value_or_instance) {
            const auto &calls = signal->calls;
            const auto it = std::find_if(calls.cbegin(), calls.cend(), [value_or_instance](const auto &delegate) {
                return delegate.instance() == value_or_instance;
            });

            other.offset = std::distance(it, calls.cend());
        }

        return other;
    }

    /**
     * @brief Returns a sink that connects before anything else.
     * @return A properly initialized sink object.
     */
    sink before() {
        sink other{*this};
        other.offset = signal->calls.size();
        return other;
    }

    /**
     * @brief Connects a free function or an unbound member to a signal.
     *
     * The signal handler performs checks to avoid multiple connections for the
     * same function.
     *
     * @tparam Candidate Function or member to connect to the signal.
     * @return A properly initialized connection object.
     */
    template<auto Candidate>
    connection connect() {
        disconnect<Candidate>();

        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>();
        signal->calls.insert(signal->calls.end() - offset, std::move(call));

        delegate<void(void *)> conn{};
        conn.template connect<&release<Candidate>>();
        return { std::move(conn), signal };
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * signal.
     *
     * The signal isn't responsible for the connected object or the payload.
     * Users must always guarantee that the lifetime of the instance overcomes
     * the one of the signal. On the other side, the signal handler performs
     * checks to avoid multiple connections for the same function.<br/>
     * When used to connect a free function with payload, its signature must be
     * such that the instance is the first argument before the ones used to
     * define the signal itself.
     *
     * @tparam Candidate Function or member to connect to the signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     * @return A properly initialized connection object.
     */
    template<auto Candidate, typename Type>
    connection connect(Type &&value_or_instance) {
        disconnect<Candidate>(value_or_instance);

        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>(value_or_instance);
        signal->calls.insert(signal->calls.end() - offset, std::move(call));

        delegate<void(void *)> conn{};
        conn.template connect<&release<Candidate, Type>>(value_or_instance);
        return { std::move(conn), signal };
    }

    /**
     * @brief Disconnects a free function or an unbound member from a signal.
     * @tparam Candidate Function or member to disconnect from the signal.
     */
    template<auto Candidate>
    void disconnect() {
        auto &calls = signal->calls;
        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>();
        calls.erase(std::remove(calls.begin(), calls.end(), std::move(call)), calls.end());
    }

    /**
     * @brief Disconnects a free function with payload or a bound member from a
     * signal.
     * @tparam Candidate Function or member to disconnect from the signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void disconnect(Type &&value_or_instance) {
        auto &calls = signal->calls;
        delegate<Ret(Args...)> call{};
        call.template connect<Candidate>(std::forward<Type>(value_or_instance));
        calls.erase(std::remove(calls.begin(), calls.end(), std::move(call)), calls.end());
    }

    /**
     * @brief Disconnects free functions with payload or bound members from a
     * signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<typename Type>
    void disconnect(Type &value_or_instance) {
        disconnect(&value_or_instance);
    }

    /**
     * @brief Disconnects free functions with payload or bound members from a
     * signal.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid object that fits the purpose.
     */
    template<typename Type>
    void disconnect(Type *value_or_instance) {
        if(value_or_instance) {
            auto &calls = signal->calls;
            calls.erase(std::remove_if(calls.begin(), calls.end(), [value_or_instance](const auto &delegate) {
                return delegate.instance() == value_or_instance;
            }), calls.end());
        }
    }

    /*! @brief Disconnects all the listeners from a signal. */
    void disconnect() {
        signal->calls.clear();
    }

private:
    difference_type offset;
    signal_type *signal;
};


/**
 * @brief Deduction guide.
 *
 * It allows to deduce the function type of a sink directly from the signal it
 * refers to.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
sink(sigh<Ret(Args...)> &) ENTT_NOEXCEPT -> sink<Ret(Args...)>;


}


#endif



namespace entt {


/**
 * @brief Basic dispatcher implementation.
 *
 * A dispatcher can be used either to trigger an immediate event or to enqueue
 * events to be published all together once per tick.<br/>
 * Listeners are provided in the form of member functions. For each event of
 * type `Event`, listeners are such that they can be invoked with an argument of
 * type `const Event &`, no matter what the return type is.
 *
 * The dispatcher creates instances of the `sigh` class internally. Refer to the
 * documentation of the latter for more details.
 */
class dispatcher {
    struct basic_pool {
        virtual ~basic_pool() = default;
        virtual void publish() = 0;
        virtual void clear() ENTT_NOEXCEPT = 0;
        virtual id_type type_id() const ENTT_NOEXCEPT = 0;
    };

    template<typename Event>
    struct pool_handler final: basic_pool {
        using signal_type = sigh<void(const Event &)>;
        using sink_type = typename signal_type::sink_type;

        void publish() override {
            const auto length = events.size();

            for(std::size_t pos{}; pos < length; ++pos) {
                signal.publish(events[pos]);
            }

            events.erase(events.cbegin(), events.cbegin()+length);
        }

        void clear() ENTT_NOEXCEPT override {
            events.clear();
        }

        sink_type sink() ENTT_NOEXCEPT {
            return entt::sink{signal};
        }

        template<typename... Args>
        void trigger(Args &&... args) {
            signal.publish(Event{std::forward<Args>(args)...});
        }

        template<typename... Args>
        void enqueue(Args &&... args) {
            events.emplace_back(std::forward<Args>(args)...);
        }

        id_type type_id() const ENTT_NOEXCEPT override {
            return type_info<Event>::id();
        }

    private:
        signal_type signal{};
        std::vector<Event> events;
    };

    template<typename Event>
    pool_handler<Event> & assure() {
        static_assert(std::is_same_v<Event, std::decay_t<Event>>);

        if constexpr(has_type_index_v<Event>) {
            const auto index = type_index<Event>::value();

            if(!(index < pools.size())) {
                pools.resize(index+1);
            }

            if(!pools[index]) {
                pools[index].reset(new pool_handler<Event>{});
            }

            return static_cast<pool_handler<Event> &>(*pools[index]);
        } else {
            auto it = std::find_if(pools.begin(), pools.end(), [id = type_info<Event>::id()](const auto &cpool) { return id == cpool->type_id(); });
            return static_cast<pool_handler<Event> &>(it == pools.cend() ? *pools.emplace_back(new pool_handler<Event>{}) : **it);
        }
    }

public:
    /**
     * @brief Returns a sink object for the given event.
     *
     * A sink is an opaque object used to connect listeners to events.
     *
     * The function type for a listener is:
     * @code{.cpp}
     * void(const Event &);
     * @endcode
     *
     * The order of invocation of the listeners isn't guaranteed.
     *
     * @sa sink
     *
     * @tparam Event Type of event of which to get the sink.
     * @return A temporary sink object.
     */
    template<typename Event>
    auto sink() {
        return assure<Event>().sink();
    }

    /**
     * @brief Triggers an immediate event of the given type.
     *
     * All the listeners registered for the given type are immediately notified.
     * The event is discarded after the execution.
     *
     * @tparam Event Type of event to trigger.
     * @tparam Args Types of arguments to use to construct the event.
     * @param args Arguments to use to construct the event.
     */
    template<typename Event, typename... Args>
    void trigger(Args &&... args) {
        assure<Event>().trigger(std::forward<Args>(args)...);
    }

    /**
     * @brief Triggers an immediate event of the given type.
     *
     * All the listeners registered for the given type are immediately notified.
     * The event is discarded after the execution.
     *
     * @tparam Event Type of event to trigger.
     * @param event An instance of the given type of event.
     */
    template<typename Event>
    void trigger(Event &&event) {
        assure<std::decay_t<Event>>().trigger(std::forward<Event>(event));
    }

    /**
     * @brief Enqueues an event of the given type.
     *
     * An event of the given type is queued. No listener is invoked. Use the
     * `update` member function to notify listeners when ready.
     *
     * @tparam Event Type of event to enqueue.
     * @tparam Args Types of arguments to use to construct the event.
     * @param args Arguments to use to construct the event.
     */
    template<typename Event, typename... Args>
    void enqueue(Args &&... args) {
        assure<Event>().enqueue(std::forward<Args>(args)...);
    }

    /**
     * @brief Enqueues an event of the given type.
     *
     * An event of the given type is queued. No listener is invoked. Use the
     * `update` member function to notify listeners when ready.
     *
     * @tparam Event Type of event to enqueue.
     * @param event An instance of the given type of event.
     */
    template<typename Event>
    void enqueue(Event &&event) {
        assure<std::decay_t<Event>>().enqueue(std::forward<Event>(event));
    }

    /**
     * @brief Discards all the events queued so far.
     *
     * If no types are provided, the dispatcher will clear all the existing
     * pools.
     *
     * @tparam Event Type of events to discard.
     */
    template<typename... Event>
    void clear() {
        if constexpr(sizeof...(Event) == 0) {
            for(auto &&cpool: pools) {
                if(cpool) {
                    cpool->clear();
                }
            }
        } else {
            (assure<Event>().clear(), ...);
        }
    }

    /**
     * @brief Delivers all the pending events of the given type.
     *
     * This method is blocking and it doesn't return until all the events are
     * delivered to the registered listeners. It's responsibility of the users
     * to reduce at a minimum the time spent in the bodies of the listeners.
     *
     * @tparam Event Type of events to send.
     */
    template<typename Event>
    void update() {
        assure<Event>().publish();
    }

    /**
     * @brief Delivers all the pending events.
     *
     * This method is blocking and it doesn't return until all the events are
     * delivered to the registered listeners. It's responsibility of the users
     * to reduce at a minimum the time spent in the bodies of the listeners.
     */
    void update() const {
        for(auto pos = pools.size(); pos; --pos) {
            if(auto &&cpool = pools[pos-1]; cpool) {
                cpool->publish();
            }
        }
    }

private:
    std::vector<std::unique_ptr<basic_pool>> pools;
};


}


#endif

// #include "signal/emitter.hpp"
#ifndef ENTT_SIGNAL_EMITTER_HPP
#define ENTT_SIGNAL_EMITTER_HPP


#include <algorithm>
#include <functional>
#include <iterator>
#include <list>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>
// #include "../config/config.h"

// #include "../core/fwd.hpp"

// #include "../core/type_info.hpp"



namespace entt {


/**
 * @brief General purpose event emitter.
 *
 * The emitter class template follows the CRTP idiom. To create a custom emitter
 * type, derived classes must inherit directly from the base class as:
 *
 * @code{.cpp}
 * struct my_emitter: emitter<my_emitter> {
 *     // ...
 * }
 * @endcode
 *
 * Pools for the type of events are created internally on the fly. It's not
 * required to specify in advance the full list of accepted types.<br/>
 * Moreover, whenever an event is published, an emitter provides the listeners
 * with a reference to itself along with a const reference to the event.
 * Therefore listeners have an handy way to work with it without incurring in
 * the need of capturing a reference to the emitter.
 *
 * @tparam Derived Actual type of emitter that extends the class template.
 */
template<typename Derived>
class emitter {
    struct basic_pool {
        virtual ~basic_pool() = default;
        virtual bool empty() const ENTT_NOEXCEPT = 0;
        virtual void clear() ENTT_NOEXCEPT = 0;
        virtual id_type type_id() const ENTT_NOEXCEPT = 0;
    };

    template<typename Event>
    struct pool_handler final: basic_pool {
        using listener_type = std::function<void(const Event &, Derived &)>;
        using element_type = std::pair<bool, listener_type>;
        using container_type = std::list<element_type>;
        using connection_type = typename container_type::iterator;

        bool empty() const ENTT_NOEXCEPT override {
            auto pred = [](auto &&element) { return element.first; };

            return std::all_of(once_list.cbegin(), once_list.cend(), pred) &&
                    std::all_of(on_list.cbegin(), on_list.cend(), pred);
        }

        void clear() ENTT_NOEXCEPT override {
            if(publishing) {
                for(auto &&element: once_list) {
                    element.first = true;
                }

                for(auto &&element: on_list) {
                    element.first = true;
                }
            } else {
                once_list.clear();
                on_list.clear();
            }
        }

        connection_type once(listener_type listener) {
            return once_list.emplace(once_list.cend(), false, std::move(listener));
        }

        connection_type on(listener_type listener) {
            return on_list.emplace(on_list.cend(), false, std::move(listener));
        }

        void erase(connection_type conn) {
            conn->first = true;

            if(!publishing) {
                auto pred = [](auto &&element) { return element.first; };
                once_list.remove_if(pred);
                on_list.remove_if(pred);
            }
        }

        void publish(const Event &event, Derived &ref) {
            container_type swap_list;
            once_list.swap(swap_list);

            publishing = true;

            for(auto &&element: on_list) {
                element.first ? void() : element.second(event, ref);
            }

            for(auto &&element: swap_list) {
                element.first ? void() : element.second(event, ref);
            }

            publishing = false;

            on_list.remove_if([](auto &&element) { return element.first; });
        }

        id_type type_id() const ENTT_NOEXCEPT override {
            return type_info<Event>::id();
        }

    private:
        bool publishing{false};
        container_type once_list{};
        container_type on_list{};
    };

    template<typename Event>
    const pool_handler<Event> & assure() const {
        static_assert(std::is_same_v<Event, std::decay_t<Event>>);

        if constexpr(has_type_index_v<Event>) {
            const auto index = type_index<Event>::value();

            if(!(index < pools.size())) {
                pools.resize(index+1);
            }

            if(!pools[index]) {
                pools[index].reset(new pool_handler<Event>{});
            }

            return static_cast<pool_handler<Event> &>(*pools[index]);
        } else {
            auto it = std::find_if(pools.begin(), pools.end(), [id = type_info<Event>::id()](const auto &cpool) { return id == cpool->type_id(); });
            return static_cast<pool_handler<Event> &>(it == pools.cend() ? *pools.emplace_back(new pool_handler<Event>{}) : **it);
        }
    }

    template<typename Event>
    pool_handler<Event> & assure() {
        return const_cast<pool_handler<Event> &>(std::as_const(*this).template assure<Event>());
    }

public:
    /** @brief Type of listeners accepted for the given event. */
    template<typename Event>
    using listener = typename pool_handler<Event>::listener_type;

    /**
     * @brief Generic connection type for events.
     *
     * Type of the connection object returned by the event emitter whenever a
     * listener for the given type is registered.<br/>
     * It can be used to break connections still in use.
     *
     * @tparam Event Type of event for which the connection is created.
     */
    template<typename Event>
    struct connection: private pool_handler<Event>::connection_type {
        /** @brief Event emitters are friend classes of connections. */
        friend class emitter;

        /*! @brief Default constructor. */
        connection() = default;

        /**
         * @brief Creates a connection that wraps its underlying instance.
         * @param conn A connection object to wrap.
         */
        connection(typename pool_handler<Event>::connection_type conn)
            : pool_handler<Event>::connection_type{std::move(conn)}
        {}
    };

    /*! @brief Default constructor. */
    emitter() = default;

    /*! @brief Default destructor. */
    virtual ~emitter() {
        static_assert(std::is_base_of_v<emitter<Derived>, Derived>);
    }

    /*! @brief Default move constructor. */
    emitter(emitter &&) = default;

    /*! @brief Default move assignment operator. @return This emitter. */
    emitter & operator=(emitter &&) = default;

    /**
     * @brief Emits the given event.
     *
     * All the listeners registered for the specific event type are invoked with
     * the given event. The event type must either have a proper constructor for
     * the arguments provided or be an aggregate type.
     *
     * @tparam Event Type of event to publish.
     * @tparam Args Types of arguments to use to construct the event.
     * @param args Parameters to use to initialize the event.
     */
    template<typename Event, typename... Args>
    void publish(Args &&... args) {
        assure<Event>().publish(Event{std::forward<Args>(args)...}, *static_cast<Derived *>(this));
    }

    /**
     * @brief Registers a long-lived listener with the event emitter.
     *
     * This method can be used to register a listener designed to be invoked
     * more than once for the given event type.<br/>
     * The connection returned by the method can be freely discarded. It's meant
     * to be used later to disconnect the listener if required.
     *
     * The listener is as a callable object that can be moved and the type of
     * which is `void(const Event &, Derived &)`.
     *
     * @note
     * Whenever an event is emitted, the emitter provides the listener with a
     * reference to the derived class. Listeners don't have to capture those
     * instances for later uses.
     *
     * @tparam Event Type of event to which to connect the listener.
     * @param instance The listener to register.
     * @return Connection object that can be used to disconnect the listener.
     */
    template<typename Event>
    connection<Event> on(listener<Event> instance) {
        return assure<Event>().on(std::move(instance));
    }

    /**
     * @brief Registers a short-lived listener with the event emitter.
     *
     * This method can be used to register a listener designed to be invoked
     * only once for the given event type.<br/>
     * The connection returned by the method can be freely discarded. It's meant
     * to be used later to disconnect the listener if required.
     *
     * The listener is as a callable object that can be moved and the type of
     * which is `void(const Event &, Derived &)`.
     *
     * @note
     * Whenever an event is emitted, the emitter provides the listener with a
     * reference to the derived class. Listeners don't have to capture those
     * instances for later uses.
     *
     * @tparam Event Type of event to which to connect the listener.
     * @param instance The listener to register.
     * @return Connection object that can be used to disconnect the listener.
     */
    template<typename Event>
    connection<Event> once(listener<Event> instance) {
        return assure<Event>().once(std::move(instance));
    }

    /**
     * @brief Disconnects a listener from the event emitter.
     *
     * Do not use twice the same connection to disconnect a listener, it results
     * in undefined behavior. Once used, discard the connection object.
     *
     * @tparam Event Type of event of the connection.
     * @param conn A valid connection.
     */
    template<typename Event>
    void erase(connection<Event> conn) {
        assure<Event>().erase(std::move(conn));
    }

    /**
     * @brief Disconnects all the listeners for the given event type.
     *
     * All the connections previously returned for the given event are
     * invalidated. Using them results in undefined behavior.
     *
     * @tparam Event Type of event to reset.
     */
    template<typename Event>
    void clear() {
        assure<Event>().clear();
    }

    /**
     * @brief Disconnects all the listeners.
     *
     * All the connections previously returned are invalidated. Using them
     * results in undefined behavior.
     */
    void clear() ENTT_NOEXCEPT {
        for(auto &&cpool: pools) {
            if(cpool) {
                cpool->clear();
            }
        }
    }

    /**
     * @brief Checks if there are listeners registered for the specific event.
     * @tparam Event Type of event to test.
     * @return True if there are no listeners registered, false otherwise.
     */
    template<typename Event>
    bool empty() const {
        return assure<Event>().empty();
    }

    /**
     * @brief Checks if there are listeners registered with the event emitter.
     * @return True if there are no listeners registered, false otherwise.
     */
    bool empty() const ENTT_NOEXCEPT {
        return std::all_of(pools.cbegin(), pools.cend(), [](auto &&cpool) {
            return !cpool || cpool->empty();
        });
    }

private:
    mutable std::vector<std::unique_ptr<basic_pool>> pools{};
};


}


#endif

// #include "signal/sigh.hpp"


```

`Hazel/vendor/filewatch/FileWatch.h`:

```h
//	MIT License
//	
//	Copyright(c) 2017 Thomas Monkman
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files(the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions :
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.

#ifndef FILEWATCHER_H
#define FILEWATCHER_H

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <Pathcch.h>
#include <shlwapi.h>
#endif // WIN32

#if __unix__
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/inotify.h>
#include <sys/stat.h>
#include <unistd.h>
#endif // __unix__

#include <functional>
#include <atomic>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <utility>
#include <vector>
#include <array>
#include <map>
#include <system_error>
#include <string>
#include <algorithm>
#include <type_traits>
#include <future>
#include <regex>
#include <iostream>

namespace filewatch {
	enum class Event {
		added,
		removed,
		modified,
		renamed_old,
		renamed_new
	};

	/**
	* \class FileWatch
	*
	* \brief Watches a folder or file, and will notify of changes via function callback.
	*
	* \author Thomas Monkman
	*
	*/
	template<class T>
	class FileWatch
	{
		typedef typename T::value_type C;
		typedef std::basic_string<C, std::char_traits<C>> UnderpinningString;
		typedef std::basic_regex<C, std::regex_traits<C>> UnderpinningRegex;

	public:

		FileWatch(T path, UnderpinningRegex pattern, std::function<void(const T& file, const Event event_type)> callback) :
			_path(path),
			_pattern(pattern),
			_callback(callback),
			_directory(get_directory(path))
		{
			init();
		}

		FileWatch(T path, std::function<void(const T& file, const Event event_type)> callback) :
			FileWatch<T>(path, UnderpinningRegex(_regex_all), callback) {}

		~FileWatch() {
			destroy();
		}

		FileWatch(const FileWatch<T>& other) : FileWatch<T>(other._path, other._callback) {}

		FileWatch<T>& operator=(const FileWatch<T>& other) 
		{
			if (this == &other) { return *this; }

			destroy();
			_path = other._path;
			_callback = other._callback;
			_directory = get_directory(other._path);
			init();
			return *this;
		}

		// Const memeber varibles don't let me implent moves nicely, if moves are really wanted std::unique_ptr should be used and move that.
		FileWatch<T>(FileWatch<T>&&) = delete;
		FileWatch<T>& operator=(FileWatch<T>&&) & = delete;

	private:
		static constexpr C _regex_all[] = { '.', '*', '\0' };
		static constexpr C _this_directory[] = { '.', '/', '\0' };

		struct PathParts
		{
			PathParts(T directory, T filename) : directory(directory), filename(filename) {}
			T directory;
			T filename;
		};
		const T _path;

		UnderpinningRegex _pattern;

		static constexpr std::size_t _buffer_size = { 1024 * 256 };

		// only used if watch a single file
		bool _watching_single_file = { false };
		T _filename;

		std::atomic<bool> _destory = { false };
		std::function<void(const T& file, const Event event_type)> _callback;

		std::thread _watch_thread;

		std::condition_variable _cv;
		std::mutex _callback_mutex;
		std::vector<std::pair<T, Event>> _callback_information;
		std::thread _callback_thread;

		std::promise<void> _running;
#ifdef _WIN32
		HANDLE _directory = { nullptr };
		HANDLE _close_event = { nullptr };

		const DWORD _listen_filters =
			FILE_NOTIFY_CHANGE_SECURITY |
			FILE_NOTIFY_CHANGE_CREATION |
			FILE_NOTIFY_CHANGE_LAST_ACCESS |
			FILE_NOTIFY_CHANGE_LAST_WRITE |
			FILE_NOTIFY_CHANGE_SIZE |
			FILE_NOTIFY_CHANGE_ATTRIBUTES |
			FILE_NOTIFY_CHANGE_DIR_NAME |
			FILE_NOTIFY_CHANGE_FILE_NAME;

		const std::map<DWORD, Event> _event_type_mapping = {
			{ FILE_ACTION_ADDED, Event::added },
			{ FILE_ACTION_REMOVED, Event::removed },
			{ FILE_ACTION_MODIFIED, Event::modified },
			{ FILE_ACTION_RENAMED_OLD_NAME, Event::renamed_old },
			{ FILE_ACTION_RENAMED_NEW_NAME, Event::renamed_new }
		};
#endif // WIN32

#if __unix__
		struct FolderInfo {
			int folder;
			int watch;
		};

		FolderInfo  _directory;

		const std::uint32_t _listen_filters = IN_MODIFY | IN_CREATE | IN_DELETE;

		const static std::size_t event_size = (sizeof(struct inotify_event));
#endif // __unix__

		void init() 
		{
#ifdef _WIN32
			_close_event = CreateEvent(NULL, TRUE, FALSE, NULL);
			if (!_close_event) {
				throw std::system_error(GetLastError(), std::system_category());
			}
#endif // WIN32
			_callback_thread = std::move(std::thread([this]() {
				try {
					callback_thread();
				} catch (...) {
					try {
						_running.set_exception(std::current_exception());
					}
					catch (...) {} // set_exception() may throw too
				}
			}));
			_watch_thread = std::move(std::thread([this]() { 
				try {
					monitor_directory();
				} catch (...) {
					try {
						_running.set_exception(std::current_exception());
					}
					catch (...) {} // set_exception() may throw too
				}
			}));

			std::future<void> future = _running.get_future();
			future.get(); //block until the monitor_directory is up and running
		}

		void destroy()
		{
			_destory = true;
			_running = std::promise<void>();
#ifdef _WIN32
			SetEvent(_close_event);
#elif __unix__
			inotify_rm_watch(_directory.folder, _directory.watch);
#endif // __unix__
			_cv.notify_all();
			_watch_thread.join();
			_callback_thread.join();
#ifdef _WIN32
			CloseHandle(_directory);
#elif __unix__
			close(_directory.folder);
#endif // __unix__
		}

		const PathParts split_directory_and_file(const T& path) const 
		{
			const auto predict = [](C character) {
#ifdef _WIN32
				return character == C('\\') || character == C('/');
#elif __unix__
				return character == C('/');
#endif // __unix__
			};

			UnderpinningString path_string = path;
			const auto pivot = std::find_if(path_string.rbegin(), path_string.rend(), predict).base();
			//if the path is something like "test.txt" there will be no directory part, however we still need one, so insert './'
			const T directory = [&]() {
				const auto extracted_directory = UnderpinningString(path_string.begin(), pivot);
				return (extracted_directory.size() > 0) ? extracted_directory : UnderpinningString(_this_directory);
			}();
			const T filename = UnderpinningString(pivot, path_string.end());
			return PathParts(directory, filename);
		}

		bool pass_filter(const UnderpinningString& file_path)
		{ 
			if (_watching_single_file) {
				const UnderpinningString extracted_filename = { split_directory_and_file(file_path).filename };
				//if we are watching a single file, only that file should trigger action
				return extracted_filename == _filename;
			}
			return std::regex_match(file_path, _pattern);
		}

#ifdef _WIN32
		template<typename... Args> DWORD GetFileAttributesX(const char* lpFileName, Args... args) {
			return GetFileAttributesA(lpFileName, args...);
		}
		template<typename... Args> DWORD GetFileAttributesX(const wchar_t* lpFileName, Args... args) {
			return GetFileAttributesW(lpFileName, args...);
		}

		template<typename... Args> HANDLE CreateFileX(const char* lpFileName, Args... args) {
			return CreateFileA(lpFileName, args...);
		}
		template<typename... Args> HANDLE CreateFileX(const wchar_t* lpFileName, Args... args) {
			return CreateFileW(lpFileName, args...);
		}

		HANDLE get_directory(const T& path) 
		{
			auto file_info = GetFileAttributesX(path.c_str());

			if (file_info == INVALID_FILE_ATTRIBUTES)
			{
				throw std::system_error(GetLastError(), std::system_category());
			}
			_watching_single_file = (file_info & FILE_ATTRIBUTE_DIRECTORY) == false;

			const T watch_path = [this, &path]() {
				if (_watching_single_file)
				{
					const auto parsed_path = split_directory_and_file(path);
					_filename = parsed_path.filename;
					return parsed_path.directory;
				}
				else 
				{
					return path;
				}
			}();

			HANDLE directory = CreateFileX(
				watch_path.c_str(),           // pointer to the file name
				FILE_LIST_DIRECTORY,    // access (read/write) mode
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, // share mode
				nullptr, // security descriptor
				OPEN_EXISTING,         // how to create
				FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED, // file attributes
				HANDLE(0));                 // file with attributes to copy

			if (directory == INVALID_HANDLE_VALUE)
			{
				throw std::system_error(GetLastError(), std::system_category());
			}
			return directory;
		}

		void convert_wstring(const std::wstring& wstr, std::string& out)
		{
			int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
			out.resize(size_needed, '\0');
			WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &out[0], size_needed, NULL, NULL);
		}

		void convert_wstring(const std::wstring& wstr, std::wstring& out)
		{
			out = wstr;
		}

		void monitor_directory() 
		{
			std::vector<BYTE> buffer(_buffer_size);
			DWORD bytes_returned = 0;
			OVERLAPPED overlapped_buffer{ 0 };

			overlapped_buffer.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
			if (!overlapped_buffer.hEvent) {
				std::cerr << "Error creating monitor event" << std::endl;
			}

			std::array<HANDLE, 2> handles{ overlapped_buffer.hEvent, _close_event };

			auto async_pending = false;
			_running.set_value();
			do {
				std::vector<std::pair<T, Event>> parsed_information;
				ReadDirectoryChangesW(
					_directory,
					buffer.data(), static_cast<DWORD>(buffer.size()),
					TRUE,
					_listen_filters,
					&bytes_returned,
					&overlapped_buffer, NULL);
			
				async_pending = true;
			
				switch (WaitForMultipleObjects(2, handles.data(), FALSE, INFINITE))
				{
				case WAIT_OBJECT_0:
				{
					if (!GetOverlappedResult(_directory, &overlapped_buffer, &bytes_returned, TRUE)) {
						throw std::system_error(GetLastError(), std::system_category());
					}
					async_pending = false;

					if (bytes_returned == 0) {
						break;
					}

					FILE_NOTIFY_INFORMATION *file_information = reinterpret_cast<FILE_NOTIFY_INFORMATION*>(&buffer[0]);
					do
					{
						std::wstring changed_file_w{ file_information->FileName, file_information->FileNameLength / sizeof(file_information->FileName[0]) };
						UnderpinningString changed_file;
						convert_wstring(changed_file_w, changed_file);
						if (pass_filter(changed_file))
						{
							parsed_information.emplace_back(T{ changed_file }, _event_type_mapping.at(file_information->Action));
						}

						if (file_information->NextEntryOffset == 0) {
							break;
						}

						file_information = reinterpret_cast<FILE_NOTIFY_INFORMATION*>(reinterpret_cast<BYTE*>(file_information) + file_information->NextEntryOffset);
					} while (true);
					break;
				}
				case WAIT_OBJECT_0 + 1:
					// quit
					break;
				case WAIT_FAILED:
					break;
				}
				//dispatch callbacks
				{
					std::lock_guard<std::mutex> lock(_callback_mutex);
					_callback_information.insert(_callback_information.end(), parsed_information.begin(), parsed_information.end());
				}
				_cv.notify_all();
			} while (_destory == false);

			if (async_pending)
			{
				//clean up running async io
				CancelIo(_directory);
				GetOverlappedResult(_directory, &overlapped_buffer, &bytes_returned, TRUE);
			}
		}
#endif // WIN32

#if __unix__

		bool is_file(const T& path) const
		{
			struct stat statbuf = {};
			if (stat(path.c_str(), &statbuf) != 0)
			{
				throw std::system_error(errno, std::system_category());
			}
			return S_ISREG(statbuf.st_mode);
		}

		FolderInfo get_directory(const T& path) 
		{
			const auto folder = inotify_init();
			if (folder < 0) 
			{
				throw std::system_error(errno, std::system_category());
			}
			const auto listen_filters = _listen_filters;

			_watching_single_file = is_file(path);

			const T watch_path = [this, &path]() {
				if (_watching_single_file)
				{
					const auto parsed_path = split_directory_and_file(path);
					_filename = parsed_path.filename;
					return parsed_path.directory;
				}
				else
				{
					return path;
				}
			}();

			const auto watch = inotify_add_watch(folder, watch_path.c_str(), IN_MODIFY | IN_CREATE | IN_DELETE);
			if (watch < 0) 
			{
				throw std::system_error(errno, std::system_category());
			}
			return { folder, watch };
		}

		void monitor_directory() 
		{
			std::vector<char> buffer(_buffer_size);

			_running.set_value();
			while (_destory == false) 
			{
				const auto length = read(_directory.folder, static_cast<void*>(buffer.data()), buffer.size());
				if (length > 0) 
				{
					int i = 0;
					std::vector<std::pair<T, Event>> parsed_information;
					while (i < length) 
					{
						struct inotify_event *event = reinterpret_cast<struct inotify_event *>(&buffer[i]); // NOLINT
						if (event->len) 
						{
							const UnderpinningString changed_file{ event->name };
							if (pass_filter(changed_file))
							{
								if (event->mask & IN_CREATE) 
								{
									parsed_information.emplace_back(T{ changed_file }, Event::added);
								}
								else if (event->mask & IN_DELETE) 
								{
									parsed_information.emplace_back(T{ changed_file }, Event::removed);
								}
								else if (event->mask & IN_MODIFY) 
								{
									parsed_information.emplace_back(T{ changed_file }, Event::modified);
								}
							}
						}
						i += event_size + event->len;
					}
					//dispatch callbacks
					{
						std::lock_guard<std::mutex> lock(_callback_mutex);
						_callback_information.insert(_callback_information.end(), parsed_information.begin(), parsed_information.end());
					}
					_cv.notify_all();
				}
			}
		}
#endif // __unix__

		void callback_thread()
		{
			while (_destory == false) {
				std::unique_lock<std::mutex> lock(_callback_mutex);
				if (_callback_information.empty() && _destory == false) {
					_cv.wait(lock, [this] { return _callback_information.size() > 0 || _destory; });
				}
				decltype(_callback_information) callback_information = {};
				std::swap(callback_information, _callback_information);
				lock.unlock();

				for (const auto& file : callback_information) {
					if (_callback) {
						try
						{
							_callback(file.first, file.second);
						}
						catch (const std::exception&)
						{
						}
					}
				}
			}
		}
	};

	template<class T> constexpr typename FileWatch<T>::C FileWatch<T>::_regex_all[];
	template<class T> constexpr typename FileWatch<T>::C FileWatch<T>::_this_directory[];
}
#endif
```

`Hazel/vendor/mono/LICENSE`:

```

In general, the runtime and its class libraries are licensed under the
terms of the MIT license, and some third party code is licensed under
the 3-clause BSD license.  See the file "PATENTS.TXT" for Microsoft's
patent grant on the Mono codebase.

The Mono distribution does include a handful of pieces of code that
are used during the build system and are covered under different
licenses, those include:

Build Time Code
===============

This is code that is used at build time, or during the maintenance of
Mono itself, and does not end up in the redistributable part of Mono:

* gettext

  m4 source files used to probe features at build time: GPL

* Benchmark Source Files

  Logic.cs and zipmark.cs are GPL source files.

* mono/docs/HtmlAgilityPack

  MS-PL licensed

* mcs/jay: 4-clause BSD licensed

* mcs/class/I18N/mklist.sh, tools/cvt.sh: GNU GPLv2

Runtime Code
============

The following code is linked with the final Mono runtime, the libmono
embeddable runtime:

* support/minizip: BSD license.

* mono/utils/memcheck.h: BSD license, used on debug builds that use Valgrind.

* mono/utils/freebsd-dwarf.h, freebsd-elf_common.h, freebsd-elf64.h freebsd-elf32.h: BSD license.

* mono/utils/bsearch.c: BSD license.

* mono/metadata/w32file-unix-glob.c, w32file-unix-glob.h: BSD license

Class Library code
==================

These are class libraries that can be loaded by your process:

* mcs/class/RabbitMQ.Client: dual licensed in Apache v2, and Mozilla Public License 1.1

* mcs/class/Compat.ICSharpCode.SharpZipLib and
  mcs/class/ICSharpCode.SharpZipLib are GPL with class-path exception.
  Originates with the SharpDevelop project.

* mcs/class/System.Core/System/TimeZoneInfo.Android.cs

  This is a port of Apache 2.0-licensed Android code, and thus is
  licensed under the Apache 2.0 license

	    http://www.apache.org/licenses/LICENSE-2.0

API Documentation
=================

The API documentation is licensed under the terms of the Creative
Commons Attribution 4.0 International Public License


The Licenses
============

	These are the licenses used in Mono, the files are located:

### MIT X11 License

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


### Mozilla.MPL

                          MOZILLA PUBLIC LICENSE
                                Version 1.1

                              ---------------

1. Definitions.

     1.0.1. "Commercial Use" means distribution or otherwise making the
     Covered Code available to a third party.

     1.1. "Contributor" means each entity that creates or contributes to
     the creation of Modifications.

     1.2. "Contributor Version" means the combination of the Original
     Code, prior Modifications used by a Contributor, and the Modifications
     made by that particular Contributor.

     1.3. "Covered Code" means the Original Code or Modifications or the
     combination of the Original Code and Modifications, in each case
     including portions thereof.

     1.4. "Electronic Distribution Mechanism" means a mechanism generally
     accepted in the software development community for the electronic
     transfer of data.

     1.5. "Executable" means Covered Code in any form other than Source
     Code.

     1.6. "Initial Developer" means the individual or entity identified
     as the Initial Developer in the Source Code notice required by Exhibit
     A.

     1.7. "Larger Work" means a work which combines Covered Code or
     portions thereof with code not governed by the terms of this License.

     1.8. "License" means this document.

     1.8.1. "Licensable" means having the right to grant, to the maximum
     extent possible, whether at the time of the initial grant or
     subsequently acquired, any and all of the rights conveyed herein.

     1.9. "Modifications" means any addition to or deletion from the
     substance or structure of either the Original Code or any previous
     Modifications. When Covered Code is released as a series of files, a
     Modification is:
          A. Any addition to or deletion from the contents of a file
          containing Original Code or previous Modifications.

          B. Any new file that contains any part of the Original Code or
          previous Modifications.

     1.10. "Original Code" means Source Code of computer software code
     which is described in the Source Code notice required by Exhibit A as
     Original Code, and which, at the time of its release under this
     License is not already Covered Code governed by this License.

     1.10.1. "Patent Claims" means any patent claim(s), now owned or
     hereafter acquired, including without limitation,  method, process,
     and apparatus claims, in any patent Licensable by grantor.

     1.11. "Source Code" means the preferred form of the Covered Code for
     making modifications to it, including all modules it contains, plus
     any associated interface definition files, scripts used to control
     compilation and installation of an Executable, or source code
     differential comparisons against either the Original Code or another
     well known, available Covered Code of the Contributor's choice. The
     Source Code can be in a compressed or archival form, provided the
     appropriate decompression or de-archiving software is widely available
     for no charge.

     1.12. "You" (or "Your")  means an individual or a legal entity
     exercising rights under, and complying with all of the terms of, this
     License or a future version of this License issued under Section 6.1.
     For legal entities, "You" includes any entity which controls, is
     controlled by, or is under common control with You. For purposes of
     this definition, "control" means (a) the power, direct or indirect,
     to cause the direction or management of such entity, whether by
     contract or otherwise, or (b) ownership of more than fifty percent
     (50%) of the outstanding shares or beneficial ownership of such
     entity.

2. Source Code License.

     2.1. The Initial Developer Grant.
     The Initial Developer hereby grants You a world-wide, royalty-free,
     non-exclusive license, subject to third party intellectual property
     claims:
          (a)  under intellectual property rights (other than patent or
          trademark) Licensable by Initial Developer to use, reproduce,
          modify, display, perform, sublicense and distribute the Original
          Code (or portions thereof) with or without Modifications, and/or
          as part of a Larger Work; and

          (b) under Patents Claims infringed by the making, using or
          selling of Original Code, to make, have made, use, practice,
          sell, and offer for sale, and/or otherwise dispose of the
          Original Code (or portions thereof).

          (c) the licenses granted in this Section 2.1(a) and (b) are
          effective on the date Initial Developer first distributes
          Original Code under the terms of this License.

          (d) Notwithstanding Section 2.1(b) above, no patent license is
          granted: 1) for code that You delete from the Original Code; 2)
          separate from the Original Code;  or 3) for infringements caused
          by: i) the modification of the Original Code or ii) the
          combination of the Original Code with other software or devices.

     2.2. Contributor Grant.
     Subject to third party intellectual property claims, each Contributor
     hereby grants You a world-wide, royalty-free, non-exclusive license

          (a)  under intellectual property rights (other than patent or
          trademark) Licensable by Contributor, to use, reproduce, modify,
          display, perform, sublicense and distribute the Modifications
          created by such Contributor (or portions thereof) either on an
          unmodified basis, with other Modifications, as Covered Code
          and/or as part of a Larger Work; and

          (b) under Patent Claims infringed by the making, using, or
          selling of  Modifications made by that Contributor either alone
          and/or in combination with its Contributor Version (or portions
          of such combination), to make, use, sell, offer for sale, have
          made, and/or otherwise dispose of: 1) Modifications made by that
          Contributor (or portions thereof); and 2) the combination of
          Modifications made by that Contributor with its Contributor
          Version (or portions of such combination).

          (c) the licenses granted in Sections 2.2(a) and 2.2(b) are
          effective on the date Contributor first makes Commercial Use of
          the Covered Code.

          (d)    Notwithstanding Section 2.2(b) above, no patent license is
          granted: 1) for any code that Contributor has deleted from the
          Contributor Version; 2)  separate from the Contributor Version;
          3)  for infringements caused by: i) third party modifications of
          Contributor Version or ii)  the combination of Modifications made
          by that Contributor with other software  (except as part of the
          Contributor Version) or other devices; or 4) under Patent Claims
          infringed by Covered Code in the absence of Modifications made by
          that Contributor.

3. Distribution Obligations.

     3.1. Application of License.
     The Modifications which You create or to which You contribute are
     governed by the terms of this License, including without limitation
     Section 2.2. The Source Code version of Covered Code may be
     distributed only under the terms of this License or a future version
     of this License released under Section 6.1, and You must include a
     copy of this License with every copy of the Source Code You
     distribute. You may not offer or impose any terms on any Source Code
     version that alters or restricts the applicable version of this
     License or the recipients' rights hereunder. However, You may include
     an additional document offering the additional rights described in
     Section 3.5.

     3.2. Availability of Source Code.
     Any Modification which You create or to which You contribute must be
     made available in Source Code form under the terms of this License
     either on the same media as an Executable version or via an accepted
     Electronic Distribution Mechanism to anyone to whom you made an
     Executable version available; and if made available via Electronic
     Distribution Mechanism, must remain available for at least twelve (12)
     months after the date it initially became available, or at least six
     (6) months after a subsequent version of that particular Modification
     has been made available to such recipients. You are responsible for
     ensuring that the Source Code version remains available even if the
     Electronic Distribution Mechanism is maintained by a third party.

     3.3. Description of Modifications.
     You must cause all Covered Code to which You contribute to contain a
     file documenting the changes You made to create that Covered Code and
     the date of any change. You must include a prominent statement that
     the Modification is derived, directly or indirectly, from Original
     Code provided by the Initial Developer and including the name of the
     Initial Developer in (a) the Source Code, and (b) in any notice in an
     Executable version or related documentation in which You describe the
     origin or ownership of the Covered Code.

     3.4. Intellectual Property Matters
          (a) Third Party Claims.
          If Contributor has knowledge that a license under a third party's
          intellectual property rights is required to exercise the rights
          granted by such Contributor under Sections 2.1 or 2.2,
          Contributor must include a text file with the Source Code
          distribution titled "LEGAL" which describes the claim and the
          party making the claim in sufficient detail that a recipient will
          know whom to contact. If Contributor obtains such knowledge after
          the Modification is made available as described in Section 3.2,
          Contributor shall promptly modify the LEGAL file in all copies
          Contributor makes available thereafter and shall take other steps
          (such as notifying appropriate mailing lists or newsgroups)
          reasonably calculated to inform those who received the Covered
          Code that new knowledge has been obtained.

          (b) Contributor APIs.
          If Contributor's Modifications include an application programming
          interface and Contributor has knowledge of patent licenses which
          are reasonably necessary to implement that API, Contributor must
          also include this information in the LEGAL file.

               (c)    Representations.
          Contributor represents that, except as disclosed pursuant to
          Section 3.4(a) above, Contributor believes that Contributor's
          Modifications are Contributor's original creation(s) and/or
          Contributor has sufficient rights to grant the rights conveyed by
          this License.

     3.5. Required Notices.
     You must duplicate the notice in Exhibit A in each file of the Source
     Code.  If it is not possible to put such notice in a particular Source
     Code file due to its structure, then You must include such notice in a
     location (such as a relevant directory) where a user would be likely
     to look for such a notice.  If You created one or more Modification(s)
     You may add your name as a Contributor to the notice described in
     Exhibit A.  You must also duplicate this License in any documentation
     for the Source Code where You describe recipients' rights or ownership
     rights relating to Covered Code.  You may choose to offer, and to
     charge a fee for, warranty, support, indemnity or liability
     obligations to one or more recipients of Covered Code. However, You
     may do so only on Your own behalf, and not on behalf of the Initial
     Developer or any Contributor. You must make it absolutely clear than
     any such warranty, support, indemnity or liability obligation is
     offered by You alone, and You hereby agree to indemnify the Initial
     Developer and every Contributor for any liability incurred by the
     Initial Developer or such Contributor as a result of warranty,
     support, indemnity or liability terms You offer.

     3.6. Distribution of Executable Versions.
     You may distribute Covered Code in Executable form only if the
     requirements of Section 3.1-3.5 have been met for that Covered Code,
     and if You include a notice stating that the Source Code version of
     the Covered Code is available under the terms of this License,
     including a description of how and where You have fulfilled the
     obligations of Section 3.2. The notice must be conspicuously included
     in any notice in an Executable version, related documentation or
     collateral in which You describe recipients' rights relating to the
     Covered Code. You may distribute the Executable version of Covered
     Code or ownership rights under a license of Your choice, which may
     contain terms different from this License, provided that You are in
     compliance with the terms of this License and that the license for the
     Executable version does not attempt to limit or alter the recipient's
     rights in the Source Code version from the rights set forth in this
     License. If You distribute the Executable version under a different
     license You must make it absolutely clear that any terms which differ
     from this License are offered by You alone, not by the Initial
     Developer or any Contributor. You hereby agree to indemnify the
     Initial Developer and every Contributor for any liability incurred by
     the Initial Developer or such Contributor as a result of any such
     terms You offer.

     3.7. Larger Works.
     You may create a Larger Work by combining Covered Code with other code
     not governed by the terms of this License and distribute the Larger
     Work as a single product. In such a case, You must make sure the
     requirements of this License are fulfilled for the Covered Code.

4. Inability to Comply Due to Statute or Regulation.

     If it is impossible for You to comply with any of the terms of this
     License with respect to some or all of the Covered Code due to
     statute, judicial order, or regulation then You must: (a) comply with
     the terms of this License to the maximum extent possible; and (b)
     describe the limitations and the code they affect. Such description
     must be included in the LEGAL file described in Section 3.4 and must
     be included with all distributions of the Source Code. Except to the
     extent prohibited by statute or regulation, such description must be
     sufficiently detailed for a recipient of ordinary skill to be able to
     understand it.

5. Application of this License.

     This License applies to code to which the Initial Developer has
     attached the notice in Exhibit A and to related Covered Code.

6. Versions of the License.

     6.1. New Versions.
     Netscape Communications Corporation ("Netscape") may publish revised
     and/or new versions of the License from time to time. Each version
     will be given a distinguishing version number.

     6.2. Effect of New Versions.
     Once Covered Code has been published under a particular version of the
     License, You may always continue to use it under the terms of that
     version. You may also choose to use such Covered Code under the terms
     of any subsequent version of the License published by Netscape. No one
     other than Netscape has the right to modify the terms applicable to
     Covered Code created under this License.

     6.3. Derivative Works.
     If You create or use a modified version of this License (which you may
     only do in order to apply it to code which is not already Covered Code
     governed by this License), You must (a) rename Your license so that
     the phrases "Mozilla", "MOZILLAPL", "MOZPL", "Netscape",
     "MPL", "NPL" or any confusingly similar phrase do not appear in your
     license (except to note that your license differs from this License)
     and (b) otherwise make it clear that Your version of the license
     contains terms which differ from the Mozilla Public License and
     Netscape Public License. (Filling in the name of the Initial
     Developer, Original Code or Contributor in the notice described in
     Exhibit A shall not of themselves be deemed to be modifications of
     this License.)

7. DISCLAIMER OF WARRANTY.

     COVERED CODE IS PROVIDED UNDER THIS LICENSE ON AN "AS IS" BASIS,
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
     WITHOUT LIMITATION, WARRANTIES THAT THE COVERED CODE IS FREE OF
     DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING.
     THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE COVERED CODE
     IS WITH YOU. SHOULD ANY COVERED CODE PROVE DEFECTIVE IN ANY RESPECT,
     YOU (NOT THE INITIAL DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE
     COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER
     OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF
     ANY COVERED CODE IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER.

8. TERMINATION.

     8.1.  This License and the rights granted hereunder will terminate
     automatically if You fail to comply with terms herein and fail to cure
     such breach within 30 days of becoming aware of the breach. All
     sublicenses to the Covered Code which are properly granted shall
     survive any termination of this License. Provisions which, by their
     nature, must remain in effect beyond the termination of this License
     shall survive.

     8.2.  If You initiate litigation by asserting a patent infringement
     claim (excluding declatory judgment actions) against Initial Developer
     or a Contributor (the Initial Developer or Contributor against whom
     You file such action is referred to as "Participant")  alleging that:

     (a)  such Participant's Contributor Version directly or indirectly
     infringes any patent, then any and all rights granted by such
     Participant to You under Sections 2.1 and/or 2.2 of this License
     shall, upon 60 days notice from Participant terminate prospectively,
     unless if within 60 days after receipt of notice You either: (i)
     agree in writing to pay Participant a mutually agreeable reasonable
     royalty for Your past and future use of Modifications made by such
     Participant, or (ii) withdraw Your litigation claim with respect to
     the Contributor Version against such Participant.  If within 60 days
     of notice, a reasonable royalty and payment arrangement are not
     mutually agreed upon in writing by the parties or the litigation claim
     is not withdrawn, the rights granted by Participant to You under
     Sections 2.1 and/or 2.2 automatically terminate at the expiration of
     the 60 day notice period specified above.

     (b)  any software, hardware, or device, other than such Participant's
     Contributor Version, directly or indirectly infringes any patent, then
     any rights granted to You by such Participant under Sections 2.1(b)
     and 2.2(b) are revoked effective as of the date You first made, used,
     sold, distributed, or had made, Modifications made by that
     Participant.

     8.3.  If You assert a patent infringement claim against Participant
     alleging that such Participant's Contributor Version directly or
     indirectly infringes any patent where such claim is resolved (such as
     by license or settlement) prior to the initiation of patent
     infringement litigation, then the reasonable value of the licenses
     granted by such Participant under Sections 2.1 or 2.2 shall be taken
     into account in determining the amount or value of any payment or
     license.

     8.4.  In the event of termination under Sections 8.1 or 8.2 above,
     all end user license agreements (excluding distributors and resellers)
     which have been validly granted by You or any distributor hereunder
     prior to termination shall survive termination.

9. LIMITATION OF LIABILITY.

     UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER TORT
     (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL YOU, THE INITIAL
     DEVELOPER, ANY OTHER CONTRIBUTOR, OR ANY DISTRIBUTOR OF COVERED CODE,
     OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR
     ANY INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY
     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL,
     WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER
     COMMERCIAL DAMAGES OR LOSSES, EVEN IF SUCH PARTY SHALL HAVE BEEN
     INFORMED OF THE POSSIBILITY OF SUCH DAMAGES. THIS LIMITATION OF
     LIABILITY SHALL NOT APPLY TO LIABILITY FOR DEATH OR PERSONAL INJURY
     RESULTING FROM SUCH PARTY'S NEGLIGENCE TO THE EXTENT APPLICABLE LAW
     PROHIBITS SUCH LIMITATION. SOME JURISDICTIONS DO NOT ALLOW THE
     EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO
     THIS EXCLUSION AND LIMITATION MAY NOT APPLY TO YOU.

10. U.S. GOVERNMENT END USERS.

     The Covered Code is a "commercial item," as that term is defined in
     48 C.F.R. 2.101 (Oct. 1995), consisting of "commercial computer
     software" and "commercial computer software documentation," as such
     terms are used in 48 C.F.R. 12.212 (Sept. 1995). Consistent with 48
     C.F.R. 12.212 and 48 C.F.R. 227.7202-1 through 227.7202-4 (June 1995),
     all U.S. Government End Users acquire Covered Code with only those
     rights set forth herein.

11. MISCELLANEOUS.

     This License represents the complete agreement concerning subject
     matter hereof. If any provision of this License is held to be
     unenforceable, such provision shall be reformed only to the extent
     necessary to make it enforceable. This License shall be governed by
     California law provisions (except to the extent applicable law, if
     any, provides otherwise), excluding its conflict-of-law provisions.
     With respect to disputes in which at least one party is a citizen of,
     or an entity chartered or registered to do business in the United
     States of America, any litigation relating to this License shall be
     subject to the jurisdiction of the Federal Courts of the Northern
     District of California, with venue lying in Santa Clara County,
     California, with the losing party responsible for costs, including
     without limitation, court costs and reasonable attorneys' fees and
     expenses. The application of the United Nations Convention on
     Contracts for the International Sale of Goods is expressly excluded.
     Any law or regulation which provides that the language of a contract
     shall be construed against the drafter shall not apply to this
     License.

12. RESPONSIBILITY FOR CLAIMS.

     As between Initial Developer and the Contributors, each party is
     responsible for claims and damages arising, directly or indirectly,
     out of its utilization of rights under this License and You agree to
     work with Initial Developer and Contributors to distribute such
     responsibility on an equitable basis. Nothing herein is intended or
     shall be deemed to constitute any admission of liability.

13. MULTIPLE-LICENSED CODE.

     Initial Developer may designate portions of the Covered Code as
     "Multiple-Licensed".  "Multiple-Licensed" means that the Initial
     Developer permits you to utilize portions of the Covered Code under
     Your choice of the NPL or the alternative licenses, if any, specified
     by the Initial Developer in the file described in Exhibit A.

EXHIBIT A -Mozilla Public License.

     ``The contents of this file are subject to the Mozilla Public License
     Version 1.1 (the "License"); you may not use this file except in
     compliance with the License. You may obtain a copy of the License at
     http://www.mozilla.org/MPL/

     Software distributed under the License is distributed on an "AS IS"
     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
     License for the specific language governing rights and limitations
     under the License.

     The Original Code is ______________________________________.

     The Initial Developer of the Original Code is ________________________.
     Portions created by ______________________ are Copyright (C) ______
     _______________________. All Rights Reserved.

     Contributor(s): ______________________________________.

     Alternatively, the contents of this file may be used under the terms
     of the _____ license (the  "[___] License"), in which case the
     provisions of [______] License are applicable instead of those
     above.  If you wish to allow use of your version of this file only
     under the terms of the [____] License and not to allow others to use
     your version of this file under the MPL, indicate your decision by
     deleting  the provisions above and replace  them with the notice and
     other provisions required by the [___] License.  If you do not delete
     the provisions above, a recipient may use your version of this file
     under either the MPL or the [___] License."

     [NOTE: The text of this Exhibit A may differ slightly from the text of
     the notices in the Source Code files of the Original Code. You should
     use the text of this Exhibit A rather than the text found in the
     Original Code Source Code for Your Modifications.]

### Microsoft Public License

Microsoft Permissive License (Ms-PL)
 
	This license governs use of the accompanying software. If you use the software, you accept this license. If you do not accept the license, do not use the software.
 
1. Definitions

	The terms reproduce, reproduction, derivative works, and distribution have the same meaning here as under U.S. copyright law.
	A contribution is the original software, or any additions or changes to the software.
	A contributor is any person that distributes its contribution under this license.
	 Licensed patents are a contributors patent claims that read directly on its contribution.
 
2. Grant of Rights

	(A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.
	(B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.
 
3. Conditions and Limitations

	(A) No Trademark License- This license does not grant you rights to use any contributors name, logo, or trademarks.
	(B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically.
	(C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software.
	(D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under a license that complies with this license.
	(E) The software is licensed as-is. You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.
	(F) If you distribute the software or derivative works with programs you develop, you agree to indemnify, defend, and hold harmless all contributors from any claims, including attorneys fees, related to the distribution or use of your programs.  For clarity, you have no such obligations to a contributor for any claims based solely on the unmodified contributions of that contributor.
	(G) If you make any additions or changes to the original software, you may only distribute them under a new namespace.  In addition, you will clearly identify your changes or additions as your own.

### Infozip BSD

This is version 2009-Jan-02 of the Info-ZIP license. The definitive
version of this document should be available at
ftp://ftp.info-zip.org/pub/infozip/license.html indefinitely and a
copy at http://www.info-zip.org/pub/infozip/license.html.

Copyright (c) 1990-2009 Info-ZIP. All rights reserved.

For the purposes of this copyright and license, "Info-ZIP" is defined
as the following set of individuals: Mark Adler, John Bush, Karl
Davis, Harald Denker, Jean-Michel Dubois, Jean-loup Gailly, Hunter
Goatley, Ed Gordon, Ian Gorman, Chris Herborth, Dirk Haase, Greg
Hartwig, Robert Heath, Jonathan Hudson, Paul Kienitz, David
Kirschbaum, Johnny Lee, Onno van der Linden, Igor Mandrichenko, Steve
P. Miller, Sergio Monesi, Keith Owens, George Petrov, Greg Roelofs,
Kai Uwe Rommel, Steve Salisbury, Dave Smith, Steven M. Schweda,
Christian Spieler, Cosmin Truta, Antoine Verheijen, Paul von Behren,
Rich Wales, Mike White.

This software is provided "as is," without warranty of any kind,
express or implied. In no event shall Info-ZIP or its contributors be
held liable for any direct, indirect, incidental, special or
consequential damages arising out of the use of or inability to use
this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the above disclaimer and the following
restrictions:

Redistributions of source code (in whole or in part) must retain the
above copyright notice, definition, disclaimer, and this list of
conditions.

Redistributions in binary form (compiled executables and libraries)
must reproduce the above copyright notice, definition, disclaimer, and
this list of conditions in documentation and/or other materials
provided with the distribution. Additional documentation is not needed
for executables where a command line license option provides these and
a note regarding this option is in the executable's startup
banner. The sole exception to this condition is redistribution of a
standard UnZipSFX binary (including SFXWiz) as part of a
self-extracting archive; that is permitted without inclusion of this
license, as long as the normal SFX banner has not been removed from
the binary or disabled.

Altered versions--including, but not limited to, ports to new
operating systems, existing ports with new graphical interfaces,
versions with modified or added functionality, and dynamic, shared, or
static library versions not from Info-ZIP--must be plainly marked as
such and must not be misrepresented as being the original source or,
if binaries, compiled from the original source. Such altered versions
also must not be misrepresented as being Info-ZIP releases--including,
but not limited to, labeling of the altered versions with the names
"Info-ZIP" (or any variation thereof, including, but not limited to,
different capitalizations), "Pocket UnZip," "WiZ" or "MacZip" without
the explicit permission of Info-ZIP. Such altered versions are further
prohibited from misrepresentative use of the Zip-Bugs or Info-ZIP
e-mail addresses or the Info-ZIP URL(s), such as to imply Info-ZIP
will provide support for the altered versions.

Info-ZIP retains the right to use the names "Info-ZIP," "Zip,"
"UnZip," "UnZipSFX," "WiZ," "Pocket UnZip," "Pocket Zip," and "MacZip"
for its own source and binary releases.

### License Creative Commons 2.5

// Copyright 2006 James Newton-King
// http://www.newtonsoft.com
//
// This work is licensed under the Creative Commons Attribution 2.5 License
// http://creativecommons.org/licenses/by/2.5/
//
// You are free:
//    * to copy, distribute, display, and perform the work
//    * to make derivative works
//    * to make commercial use of the work
//
// Under the following conditions:
//    * For any reuse or distribution, you must make clear to others the license terms of this work.
//    * Any of these conditions can be waived if you get permission from the copyright holder.

From: james.newtonking@gmail.com [mailto:james.newtonking@gmail.com] On Behalf Of James Newton-King
Sent: Tuesday, June 05, 2007 6:36 AM
To: Konstantin Triger
Subject: Re: Support request by Konstantin Triger for Json.NET

Hey Kosta

I think it would be awesome to use Json.NET in Mono for System.Web.Extensions.

The CC license has the following clause: Any of the above conditions can be waived if you get permission from the copyright holder.

I can waive that statement for you and Mono. Would that be acceptable?


Regards,
James

### Creative Commons Attribution 4.0 International Public License

Attribution 4.0 International

=======================================================================

Creative Commons Corporation ("Creative Commons") is not a law firm and
does not provide legal services or legal advice. Distribution of
Creative Commons public licenses does not create a lawyer-client or
other relationship. Creative Commons makes its licenses and related
information available on an "as-is" basis. Creative Commons gives no
warranties regarding its licenses, any material licensed under their
terms and conditions, or any related information. Creative Commons
disclaims all liability for damages resulting from their use to the
fullest extent possible.

Using Creative Commons Public Licenses

Creative Commons public licenses provide a standard set of terms and
conditions that creators and other rights holders may use to share
original works of authorship and other material subject to copyright
and certain other rights specified in the public license below. The
following considerations are for informational purposes only, are not
exhaustive, and do not form part of our licenses.

     Considerations for licensors: Our public licenses are
     intended for use by those authorized to give the public
     permission to use material in ways otherwise restricted by
     copyright and certain other rights. Our licenses are
     irrevocable. Licensors should read and understand the terms
     and conditions of the license they choose before applying it.
     Licensors should also secure all rights necessary before
     applying our licenses so that the public can reuse the
     material as expected. Licensors should clearly mark any
     material not subject to the license. This includes other CC-
     licensed material, or material used under an exception or
     limitation to copyright. More considerations for licensors:
	wiki.creativecommons.org/Considerations_for_licensors

     Considerations for the public: By using one of our public
     licenses, a licensor grants the public permission to use the
     licensed material under specified terms and conditions. If
     the licensor's permission is not necessary for any reason--for
     example, because of any applicable exception or limitation to
     copyright--then that use is not regulated by the license. Our
     licenses grant only permissions under copyright and certain
     other rights that a licensor has authority to grant. Use of
     the licensed material may still be restricted for other
     reasons, including because others have copyright or other
     rights in the material. A licensor may make special requests,
     such as asking that all changes be marked or described.
     Although not required by our licenses, you are encouraged to
     respect those requests where reasonable. More_considerations
     for the public: 
	wiki.creativecommons.org/Considerations_for_licensees

=======================================================================

Creative Commons Attribution 4.0 International Public License

By exercising the Licensed Rights (defined below), You accept and agree
to be bound by the terms and conditions of this Creative Commons
Attribution 4.0 International Public License ("Public License"). To the
extent this Public License may be interpreted as a contract, You are
granted the Licensed Rights in consideration of Your acceptance of
these terms and conditions, and the Licensor grants You such rights in
consideration of benefits the Licensor receives from making the
Licensed Material available under these terms and conditions.


Section 1 -- Definitions.

  a. Adapted Material means material subject to Copyright and Similar
     Rights that is derived from or based upon the Licensed Material
     and in which the Licensed Material is translated, altered,
     arranged, transformed, or otherwise modified in a manner requiring
     permission under the Copyright and Similar Rights held by the
     Licensor. For purposes of this Public License, where the Licensed
     Material is a musical work, performance, or sound recording,
     Adapted Material is always produced where the Licensed Material is
     synched in timed relation with a moving image.

  b. Adapter's License means the license You apply to Your Copyright
     and Similar Rights in Your contributions to Adapted Material in
     accordance with the terms and conditions of this Public License.

  c. Copyright and Similar Rights means copyright and/or similar rights
     closely related to copyright including, without limitation,
     performance, broadcast, sound recording, and Sui Generis Database
     Rights, without regard to how the rights are labeled or
     categorized. For purposes of this Public License, the rights
     specified in Section 2(b)(1)-(2) are not Copyright and Similar
     Rights.

  d. Effective Technological Measures means those measures that, in the
     absence of proper authority, may not be circumvented under laws
     fulfilling obligations under Article 11 of the WIPO Copyright
     Treaty adopted on December 20, 1996, and/or similar international
     agreements.

  e. Exceptions and Limitations means fair use, fair dealing, and/or
     any other exception or limitation to Copyright and Similar Rights
     that applies to Your use of the Licensed Material.

  f. Licensed Material means the artistic or literary work, database,
     or other material to which the Licensor applied this Public
     License.

  g. Licensed Rights means the rights granted to You subject to the
     terms and conditions of this Public License, which are limited to
     all Copyright and Similar Rights that apply to Your use of the
     Licensed Material and that the Licensor has authority to license.

  h. Licensor means the individual(s) or entity(ies) granting rights
     under this Public License.

  i. Share means to provide material to the public by any means or
     process that requires permission under the Licensed Rights, such
     as reproduction, public display, public performance, distribution,
     dissemination, communication, or importation, and to make material
     available to the public including in ways that members of the
     public may access the material from a place and at a time
     individually chosen by them.

  j. Sui Generis Database Rights means rights other than copyright
     resulting from Directive 96/9/EC of the European Parliament and of
     the Council of 11 March 1996 on the legal protection of databases,
     as amended and/or succeeded, as well as other essentially
     equivalent rights anywhere in the world.

  k. You means the individual or entity exercising the Licensed Rights
     under this Public License. Your has a corresponding meaning.


Section 2 -- Scope.

  a. License grant.

       1. Subject to the terms and conditions of this Public License,
          the Licensor hereby grants You a worldwide, royalty-free,
          non-sublicensable, non-exclusive, irrevocable license to
          exercise the Licensed Rights in the Licensed Material to:

            a. reproduce and Share the Licensed Material, in whole or
               in part; and

            b. produce, reproduce, and Share Adapted Material.

       2. Exceptions and Limitations. For the avoidance of doubt, where
          Exceptions and Limitations apply to Your use, this Public
          License does not apply, and You do not need to comply with
          its terms and conditions.

       3. Term. The term of this Public License is specified in Section
          6(a).

       4. Media and formats; technical modifications allowed. The
          Licensor authorizes You to exercise the Licensed Rights in
          all media and formats whether now known or hereafter created,
          and to make technical modifications necessary to do so. The
          Licensor waives and/or agrees not to assert any right or
          authority to forbid You from making technical modifications
          necessary to exercise the Licensed Rights, including
          technical modifications necessary to circumvent Effective
          Technological Measures. For purposes of this Public License,
          simply making modifications authorized by this Section 2(a)
          (4) never produces Adapted Material.

       5. Downstream recipients.

            a. Offer from the Licensor -- Licensed Material. Every
               recipient of the Licensed Material automatically
               receives an offer from the Licensor to exercise the
               Licensed Rights under the terms and conditions of this
               Public License.

            b. No downstream restrictions. You may not offer or impose
               any additional or different terms or conditions on, or
               apply any Effective Technological Measures to, the
               Licensed Material if doing so restricts exercise of the
               Licensed Rights by any recipient of the Licensed
               Material.

       6. No endorsement. Nothing in this Public License constitutes or
          may be construed as permission to assert or imply that You
          are, or that Your use of the Licensed Material is, connected
          with, or sponsored, endorsed, or granted official status by,
          the Licensor or others designated to receive attribution as
          provided in Section 3(a)(1)(A)(i).

  b. Other rights.

       1. Moral rights, such as the right of integrity, are not
          licensed under this Public License, nor are publicity,
          privacy, and/or other similar personality rights; however, to
          the extent possible, the Licensor waives and/or agrees not to
          assert any such rights held by the Licensor to the limited
          extent necessary to allow You to exercise the Licensed
          Rights, but not otherwise.

       2. Patent and trademark rights are not licensed under this
          Public License.

       3. To the extent possible, the Licensor waives any right to
          collect royalties from You for the exercise of the Licensed
          Rights, whether directly or through a collecting society
          under any voluntary or waivable statutory or compulsory
          licensing scheme. In all other cases the Licensor expressly
          reserves any right to collect such royalties.


Section 3 -- License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the
following conditions.

  a. Attribution.

       1. If You Share the Licensed Material (including in modified
          form), You must:

            a. retain the following if it is supplied by the Licensor
               with the Licensed Material:

                 i. identification of the creator(s) of the Licensed
                    Material and any others designated to receive
                    attribution, in any reasonable manner requested by
                    the Licensor (including by pseudonym if
                    designated);

                ii. a copyright notice;

               iii. a notice that refers to this Public License;

                iv. a notice that refers to the disclaimer of
                    warranties;

                 v. a URI or hyperlink to the Licensed Material to the
                    extent reasonably practicable;

            b. indicate if You modified the Licensed Material and
               retain an indication of any previous modifications; and

            c. indicate the Licensed Material is licensed under this
               Public License, and include the text of, or the URI or
               hyperlink to, this Public License.

       2. You may satisfy the conditions in Section 3(a)(1) in any
          reasonable manner based on the medium, means, and context in
          which You Share the Licensed Material. For example, it may be
          reasonable to satisfy the conditions by providing a URI or
          hyperlink to a resource that includes the required
          information.

       3. If requested by the Licensor, You must remove any of the
          information required by Section 3(a)(1)(A) to the extent
          reasonably practicable.

       4. If You Share Adapted Material You produce, the Adapter's
          License You apply must not prevent recipients of the Adapted
          Material from complying with this Public License.


Section 4 -- Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that
apply to Your use of the Licensed Material:

  a. for the avoidance of doubt, Section 2(a)(1) grants You the right
     to extract, reuse, reproduce, and Share all or a substantial
     portion of the contents of the database;

  b. if You include all or a substantial portion of the database
     contents in a database in which You have Sui Generis Database
     Rights, then the database in which You have Sui Generis Database
     Rights (but not its individual contents) is Adapted Material; and

  c. You must comply with the conditions in Section 3(a) if You Share
     all or a substantial portion of the contents of the database.

For the avoidance of doubt, this Section 4 supplements and does not
replace Your obligations under this Public License where the Licensed
Rights include other Copyright and Similar Rights.


Section 5 -- Disclaimer of Warranties and Limitation of Liability.

  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE
     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS
     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,
     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,
     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR
     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,
     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT
     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT
     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.

  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE
     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,
     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,
     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR
     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR
     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR
     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.

  c. The disclaimer of warranties and limitation of liability provided
     above shall be interpreted in a manner that, to the extent
     possible, most closely approximates an absolute disclaimer and
     waiver of all liability.


Section 6 -- Term and Termination.

  a. This Public License applies for the term of the Copyright and
     Similar Rights licensed here. However, if You fail to comply with
     this Public License, then Your rights under this Public License
     terminate automatically.

  b. Where Your right to use the Licensed Material has terminated under
     Section 6(a), it reinstates:

       1. automatically as of the date the violation is cured, provided
          it is cured within 30 days of Your discovery of the
          violation; or

       2. upon express reinstatement by the Licensor.

     For the avoidance of doubt, this Section 6(b) does not affect any
     right the Licensor may have to seek remedies for Your violations
     of this Public License.

  c. For the avoidance of doubt, the Licensor may also offer the
     Licensed Material under separate terms or conditions or stop
     distributing the Licensed Material at any time; however, doing so
     will not terminate this Public License.

  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public
     License.


Section 7 -- Other Terms and Conditions.

  a. The Licensor shall not be bound by any additional or different
     terms or conditions communicated by You unless expressly agreed.

  b. Any arrangements, understandings, or agreements regarding the
     Licensed Material not stated herein are separate from and
     independent of the terms and conditions of this Public License.


Section 8 -- Interpretation.

  a. For the avoidance of doubt, this Public License does not, and
     shall not be interpreted to, reduce, limit, restrict, or impose
     conditions on any use of the Licensed Material that could lawfully
     be made without permission under this Public License.

  b. To the extent possible, if any provision of this Public License is
     deemed unenforceable, it shall be automatically reformed to the
     minimum extent necessary to make it enforceable. If the provision
     cannot be reformed, it shall be severed from this Public License
     without affecting the enforceability of the remaining terms and
     conditions.

  c. No term or condition of this Public License will be waived and no
     failure to comply consented to unless expressly agreed to by the
     Licensor.

  d. Nothing in this Public License constitutes or may be interpreted
     as a limitation upon, or waiver of, any privileges and immunities
     that apply to the Licensor or You, including from the legal
     processes of any jurisdiction or authority.


=======================================================================

Creative Commons is not a party to its public
licenses. Notwithstanding, Creative Commons may elect to apply one of
its public licenses to material it publishes and in those instances
will be considered the “Licensor.” The text of the Creative Commons
public licenses is dedicated to the public domain under the CC0 Public
Domain Dedication. Except for the limited purpose of indicating that
material is shared under a Creative Commons public license or as
otherwise permitted by the Creative Commons policies published at
creativecommons.org/policies, Creative Commons does not authorize the
use of the trademark "Creative Commons" or any other trademark or logo
of Creative Commons without its prior written consent including,
without limitation, in connection with any unauthorized modifications
to any of its public licenses or any other arrangements,
understandings, or agreements concerning use of licensed material. For
the avoidance of doubt, this paragraph does not form part of the
public licenses.

Creative Commons may be contacted at creativecommons.org.

### GPL version 2

		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

```

`Hazel/vendor/mono/README.md`:

```md
Mono is a software platform designed to allow developers to easily
create cross platform applications.  It is an open source
implementation of Microsoft's .NET Framework based on the ECMA
standards for C# and the Common Language Runtime.

The Mono project is part of the [.NET Foundation](https://www.dotnetfoundation.org/)

[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/mono/mono?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

1. [Compilation and Installation](#compilation-and-installation)
2. [Using Mono](#using-mono)
3. [Directory Roadmap](#directory-roadmap)
4. [Contributing to Mono](#contributing-to-mono)
5. [Reporting bugs](#reporting-bugs)
6. [Configuration Options](#configuration-options)
7. [Working with Submodules](#working-with-submodules)

### Build Status

| OS           | Architecture       | Status                       |
|--------------|--------------------|------------------------------|
| Debian 9     | amd64              | [![debian-9-amd64][1]][2]    |
| Debian 9     | i386               | [![debian-9-i386][3]][4]     |
| Debian 9     | armel              | [![debian-9-armel][5]][6]    |
| Debian 9     | armhf              | [![debian-9-armhf][7]][8]    |
| Debian 9     | arm64              | [![debian-9-arm64][9]][10]   |
| OS X         | amd64              | [![osx-amd64][11]][12]       |
| OS X         | i386               | [![osx-i386][13]][14]        |
| Windows      | amd64              | [![windows-amd64][15]][16]   |
| Windows      | i386               | [![windows-i386][17]][18]    |
| CentOS       | s390x (cs)         | [![centos-s390x][19]][20]    |
| Debian 9     | ppc64el (cs)       | [![debian-9-ppc64el][21]][22]|
| AIX 6.1      | ppc64 (cs)         | [![aix-ppc64][23]][24]       |
| FreeBSD 12   | amd64 (cs)         | [![freebsd-amd64][25]][26]   |

_(cs) = community supported architecture_

[1]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-amd64/badge/icon
[2]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-amd64
[3]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-i386/badge/icon
[4]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-i386/
[5]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-armel/badge/icon
[6]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-armel/
[7]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-armhf/badge/icon
[8]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-armhf/
[9]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-arm64/badge/icon
[10]: https://jenkins.mono-project.com/job/test-mono-mainline-linux/label=debian-9-arm64/
[11]: https://jenkins.mono-project.com/job/test-mono-mainline/label=osx-amd64/badge/icon
[12]: https://jenkins.mono-project.com/job/test-mono-mainline/label=osx-amd64/
[13]: https://jenkins.mono-project.com/job/test-mono-mainline/label=osx-i386/badge/icon
[14]: https://jenkins.mono-project.com/job/test-mono-mainline/label=osx-i386/
[15]: https://jenkins.mono-project.com/job/z/label=w64/badge/icon
[16]: https://jenkins.mono-project.com/job/z/label=w64/
[17]: https://jenkins.mono-project.com/job/z/label=w32/badge/icon
[18]: https://jenkins.mono-project.com/job/z/label=w32/
[19]: https://jenkins.mono-project.com/job/test-mono-mainline-community/label=centos-s390x/badge/icon
[20]: https://jenkins.mono-project.com/job/test-mono-mainline-community/label=centos-s390x
[21]: https://jenkins.mono-project.com/job/test-mono-mainline-community-chroot/label=debian-9-ppc64el/badge/icon
[22]: https://jenkins.mono-project.com/job/test-mono-mainline-community-chroot/label=debian-9-ppc64el
[23]: https://jenkins.mono-project.com/job/test-mono-mainline-community/label=aix-ppc64/badge/icon
[24]: https://jenkins.mono-project.com/job/test-mono-mainline-community/label=aix-ppc64
[25]: https://jenkins.mono-project.com/job/test-mono-mainline-community/label=freebsd-12-amd64/badge/icon
[26]: https://jenkins.mono-project.com/job/test-mono-mainline-community/label=freebsd-12-amd64

Compilation and Installation
============================

Building the Software
---------------------

Please see our guides for building Mono on
[Mac OS X](https://www.mono-project.com/docs/compiling-mono/mac/),
[Linux](https://www.mono-project.com/docs/compiling-mono/linux/) and 
[Windows](https://www.mono-project.com/docs/compiling-mono/windows/).

Note that building from Git assumes that you already have Mono installed,
so please download and [install the latest Mono release](https://www.mono-project.com/download/)
before trying to build from Git. This is required because the Mono build
relies on a working Mono C# compiler to compile itself
(also known as [bootstrapping](https://en.wikipedia.org/wiki/Bootstrapping_(compilers))).

If you don't have a working Mono installation
---------------------------------------------

If you don't have a working Mono installation, you can try a slightly
more risky approach: getting the latest version of the 'monolite' distribution,
which contains just enough to run the 'mcs' compiler. You do this with:

    # Run the following line after ./autogen.sh
    make get-monolite-latest

This will download and place the files appropriately so that you can then
just run:

    make

The build will then use the files downloaded by `make get-monolite-latest`.

Testing and Installation
------------------------

You can run the mono and mcs test suites with the command: `make check`.

Expect to find a few test suite failures. As a sanity check, you
can compare the failures you got with [https://jenkins.mono-project.com/](https://jenkins.mono-project.com/).

You can now install mono with: `make install`

You can verify your installation by using the mono-test-install
script, it can diagnose some common problems with Mono's install.
Failure to follow these steps may result in a broken installation. 

Using Mono
==========

Once you have installed the software, you can run a few programs:

* `mono program.exe` runtime engine

* `mcs program.cs` C# compiler

* `monodis program.exe` CIL Disassembler

See the man pages for mono(1), mcs(1) and monodis(1) for further details.

Directory Roadmap
=================

* `acceptance-tests/` - Optional third party test suites used to validate Mono against a wider range of test cases.

* `data/` - Configuration files installed as part of the Mono runtime.

* `docs/` - Technical documents about the Mono runtime.

* `external/` - Git submodules for external libraries (Newtonsoft.Json, ikvm, etc).

* `ikvm-native/` - Glue code for ikvm.

* `libgc/` - The (deprecated) Boehm GC implementation.

* `llvm/` - Utility Makefiles for integrating the Mono LLVM fork.

* `m4/` - General utility Makefiles.

* `man/` - Manual pages for the various Mono commands and programs.

* `mcs/` - The class libraries, compiler and tools

  * `class/` - The class libraries (like System.*, Microsoft.Build, etc.)

  * `mcs/` - The Mono C# compiler written in C#

  * `tools/` - Tools like gacutil, ikdasm, mdoc, etc.

* `mono/` - The core of the Mono Runtime.

  * `arch/` - Architecture specific portions.

  * `benchmark/` - A collection of benchmarks.

  * `btls/` - Build files for the BTLS library which incorporates BoringSSL.

  * `cil/` - Common Intermediate Representation, XML
definition of the CIL bytecodes.

  * `dis/` - CIL executable Disassembler.

  * `eglib/` - Independent implementation of the glib API.

  * `metadata/` - The object system and metadata reader.

  * `mini/` - The Just in Time Compiler.

  * `profiler/` - The profiler implementation.

  * `sgen/` - The SGen Garbage Collector implementation.

  * `tests/` - The main runtime tests.

  * `unit-tests/` - Additional runtime unit tests.

  * `utils/` - Utility functions used across the runtime codebase.

* `msvc/` - Logic for the MSVC / Visual Studio based runtime and BCL build system.
The latter is experimental at the moment.

* `packaging/` - Packaging logic for the OS X and Windows Mono packages.

* `po/` - Translation files.

* `runtime/` - A directory that contains the Makefiles that link the
mono/ and mcs/ build systems.

* `samples/` - Some simple sample programs on uses of the Mono
runtime as an embedded library.

* `scripts/` - Scripts used to invoke Mono and the corresponding program.

* `sdks/` - A new way of embedding Mono into Xamarin.iOS, Xamarin.Android and other products.

* `support/` - Various support libraries.

* `tools/` - A collection of tools, mostly used during Mono development.

Contributing to Mono
====================

Before submitting changes to Mono, please review the [contribution
guidelines](https://www.mono-project.com/community/contributing/).
Please pay particular attention to the [Important
Rules](https://www.mono-project.com/community/contributing/#important-rules)
section.

Reporting bugs
==============

To submit bug reports, please [open an issue on the mono GitHub repo](https://github.com/mono/mono/issues/new).

Please use the search facility to ensure the same bug hasn't already
been submitted and follow our
[guidelines](https://www.mono-project.com/community/bugs/make-a-good-bug-report/)
on how to make a good bug report.

Configuration Options
=====================

The following are the configuration options that someone building Mono
might want to use:

* `--with-sgen=yes,no` - Generational GC support: Used to enable or
disable the compilation of a Mono runtime with the SGen garbage
collector.

  * On platforms that support it, after building Mono, you will have
both a `mono-boehm` binary and a `mono-sgen` binary. `mono-boehm` uses Boehm,
while `mono-sgen` uses the Simple Generational GC.

* `--with-libgc=[included, none]` - Selects the default Boehm
garbage collector engine to use.

  * *included*: (*slightly modified Boehm GC*) This is the default
value for the Boehm GC, and it's the most feature complete, it will
allow Mono to use typed allocations and support the debugger.

  * *none*:
Disables the inclusion of a Boehm garbage collector.

  * This defaults to `included`.

* `--enable-cooperative-suspend`

  * If you pass this flag the Mono runtime is configured to only use
  the cooperative mode of the garbage collector.  If you do not pass
  this flag, then you can control at runtime the use of the
  cooperative GC mode by setting the `MONO_ENABLE_COOP_SUSPEND` flag.
  
* `--with-tls=__thread,pthread`

  * Controls how Mono should access thread local storage,
pthread forces Mono to use the pthread APIs, while
__thread uses compiler-optimized access to it.

  * Although __thread is faster, it requires support from
the compiler, kernel and libc. Old Linux systems do
not support with __thread.

  * This value is typically pre-configured and there is no
need to set it, unless you are trying to debug a problem.

* `--with-sigaltstack=yes,no`

  * **Experimental**: Use at your own risk, it is known to
cause problems with garbage collection and is hard to
reproduce those bugs.

  * This controls whether Mono will install a special
signal handler to handle stack overflows. If set to
`yes`, it will turn stack overflows into the
StackOverflowException. Otherwise when a stack
overflow happens, your program will receive a
segmentation fault.

  * The configure script will try to detect if your
operating system supports this. Some older Linux
systems do not support this feature, or you might want
to override the auto-detection.

* `--with-static_mono=yes,no`

  * This controls whether `mono` should link against a
static library (libmono.a) or a shared library
(libmono.so). 

  * This defaults to `yes`, and will improve the performance
of the `mono` program. 

  * This only affects the `mono' binary, the shared
library libmono.so will always be produced for
developers that want to embed the runtime in their
application.

* `--with-xen-opt=yes,no` - Optimize code for Xen virtualization.

  * It makes Mono generate code which might be slightly
slower on average systems, but the resulting executable will run
faster under the Xen virtualization system.

  * This defaults to `yes`.

* `--with-large-heap=yes,no` - Enable support for GC heaps larger than 3GB.

  * This only applies only to the Boehm garbage collector, the SGen garbage
collector does not use this configuration option.

  * This defaults to `no`.

* `--enable-small-config=yes,no` - Enable some tweaks to reduce memory usage
and disk footprint at the expense of some capabilities.

  * Typically this means that the number of threads that can be created
is limited (256), that the maximum heap size is also reduced (256 MB)
and other such limitations that still make mono useful, but more suitable
to embedded devices (like mobile phones).

  * This defaults to `no`.

* `--with-ikvm-native=yes,no` - Controls whether the IKVM JNI interface library is
built or not.

  * This is used if you are planning on
using the IKVM Java Virtual machine with Mono.

  * This defaults to `yes`.

* `--with-profile4=yes,no` - Whether you want to build the 4.x profile libraries
and runtime.

  * This defaults to `yes`.

* `--with-libgdiplus=installed,sibling,<path>` - Configure where Mono
searches for libgdiplus when running System.Drawing tests.

  * It defaults to `installed`, which means that the
library is available to Mono through the regular
system setup.

  * `sibling` can be used to specify that a libgdiplus
that resides as a sibling of this directory (mono)
should be used.

 * Or you can specify a path to a libgdiplus.

* `--enable-minimal=LIST`

  * Use this feature to specify optional runtime
components that you might not want to include.  This
is only useful for developers embedding Mono that
require a subset of Mono functionality.
  * The list is a comma-separated list of components that
should be removed, these are:

    * `aot`:
Disables support for the Ahead of Time compilation.

    * `attach`:
Support for the Mono.Management assembly and the
VMAttach API (allowing code to be injected into
a target VM)

    * `com`:
Disables COM support.

    * `debug`:
Drop debugging support.

    * `decimal`:
Disables support for System.Decimal.

    * `full_messages`:
By default Mono comes with a full table
of messages for error codes. This feature
turns off uncommon error messages and reduces
the runtime size.

    * `generics`:
Generics support.  Disabling this will not
allow Mono to run any 2.0 libraries or
code that contains generics.

    * `jit`:
Removes the JIT engine from the build, this reduces
the executable size, and requires that all code
executed by the virtual machine be compiled with
Full AOT before execution.

    * `large_code`:
Disables support for large assemblies.

    * `logging`:
Disables support for debug logging.

    * `pinvoke`:
Support for Platform Invocation services,
disabling this will drop support for any
libraries using DllImport.

    * `portability`:
Removes support for MONO_IOMAP, the environment
variables for simplifying porting applications that 
are case-insensitive and that mix the Unix and Windows path separators.

    * `profiler`:
Disables support for the default profiler.

    * `reflection_emit`:
Drop System.Reflection.Emit support

    * `reflection_emit_save`:
Drop support for saving dynamically created
assemblies (AssemblyBuilderAccess.Save) in
System.Reflection.Emit.

    * `shadow_copy`:
Disables support for AppDomain's shadow copies
(you can disable this if you do not plan on 
using appdomains).

    * `simd`:
Disables support for the Mono.SIMD intrinsics
library.

    * `ssa`:
Disables compilation for the SSA optimization
framework, and the various SSA-based optimizations.

* `--enable-llvm`
* `--enable-loadedllvm`

  * This enables the use of LLVM as a code generation engine
for Mono.  The LLVM code generator and optimizer will be 
used instead of Mono's built-in code generator for both
Just in Time and Ahead of Time compilations.

  * See https://www.mono-project.com/docs/advanced/mono-llvm/ for the 
full details and up-to-date information on this feature.

  * You will need to have an LLVM built that Mono can link
against.

  * The `--enable-loadedllvm` variant will make the LLVM backend
into a runtime-loadable module instead of linking it directly
into the main mono binary.

* `--enable-big-arrays` - Enable use of arrays with indexes larger
than Int32.MaxValue.

  * By default Mono has the same limitation as .NET on
Win32 and Win64 and limits array indexes to 32-bit
values (even on 64-bit systems).

  * In certain scenarios where large arrays are required,
you can pass this flag and Mono will be built to
support 64-bit arrays.

  * This is not the default as it breaks the C embedding
ABI that we have exposed through the Mono development
cycle.

* `--enable-parallel-mark`

  * Use this option to enable the garbage collector to use
multiple CPUs to do its work.  This helps performance
on multi-CPU machines as the work is divided across CPUS.

  * This option is not currently the default on OSX
as it runs into issues there.

  * This option only applies to the Boehm GC.

* `--enable-dtrace`

  * On Solaris and MacOS X builds a version of the Mono
runtime that contains DTrace probes and can
participate in the system profiling using DTrace.

* `--disable-dev-random`

  * Mono uses /dev/random to obtain good random data for
any source that requires random numbers.   If your
system does not support this, you might want to
disable it.

  * There are a number of runtime options to control this
also, see the man page.

* `--with-csc=roslyn,mcs,default`

  * Use this option to configure which C# compiler to use.  By default
    the configure script will pick Roslyn, except on platforms where
    Roslyn does not work (Big Endian systems) where it will pick mcs.

    If you specify "mcs", then Mono's C# compiler will be used.  This
    also allows for a complete bootstrap of Mono's core compiler and
    core libraries from source.

    If you specify "roslyn", then Roslyn's C# compiler will be used.
    This currently uses Roslyn binaries.
  
* `--enable-nacl`

  * This configures the Mono compiler to generate code
suitable to be used by Google's Native Client:
https://code.google.com/p/nativeclient/

  * Currently this is used with Mono's AOT engine as
Native Client does not support JIT engines yet.

* `--enable-wasm`

  * Use this option to configure mono to run on WebAssembly. It will
    set both host and target to the WebAssembly triplet. This overrides
    the values passed to `--host` or `--target` and ignored what config.sub guesses.

    This is a workaround to enable usage of old automake versions that don't
    recognize the wasm triplet.


Working With Submodules
=======================

Mono references several external git submodules, for example
a fork of Microsoft's reference source code that has been altered
to be suitable for use with the Mono runtime.

This section describes how to use it.

An initial clone should be done recursively so all submodules will also be
cloned in a single pass:

	$ git clone --recursive git@github.com:mono/mono

Once cloned, submodules can be updated to pull down the latest changes.
This can also be done after an initial non-recursive clone:

	$ git submodule update --init --recursive

To pull external changes into a submodule:

	$ cd <submodule>
	$ git pull origin <branch>
	$ cd <top-level>
	$ git add <submodule>
	$ git commit

By default, submodules are detached because they point to a specific commit.
Use `git checkout` to move back to a branch before making changes:

	$ cd <submodule>
	$ git checkout <branch>
	# work as normal; the submodule is a normal repo
	$ git commit/push new changes to the repo (submodule)

	$ cd <top-level>
	$ git add <submodule> # this will record the new commits to the submodule
	$ git commit

To switch the repo of a submodule (this should not be a common or normal thing
to do at all), first edit `.gitmodules` to point to the new location, then:

	$ git submodule sync -- <path of the submodule>
	$ git submodule update --recursive
	$ git checkout <desired new hash or branch>

The desired output diff is a change in `.gitmodules` to reflect the
change in the remote URL, and a change in /<submodule> where you see
the desired change in the commit hash.

License
=======

See the LICENSE file for licensing information, and the PATENTS.TXT
file for information about Microsoft's patent grant.

Mono Trademark Use Policy
=========================

The use of trademarks and logos for Mono can be found [here](https://www.dotnetfoundation.org/legal/mono-tm). 

Maintaining the Class Library Solution Files
============================================

Mono now ships with a solution file that can be used to build the
assemblies from an IDE.  Either by opening the topmost `net_4_x.sln`
file, or to by loading one of the individual `csproj` files located in
each directory.

These are maintained by extracting the configuration information from
our Makefiles, which as of May 2016 remain the canonical location for
configuration information.

When changes are made to the Makefiles, a user would need to run the
following command to re-generate the solution files at the top level:

	$ make update-solution-files


```

`Hazel/vendor/mono/include/mono/jit/jit.h`:

```h
/**
 * \file
 * Author:
 *   Dietmar Maurer (dietmar@ximian.com)
 *
 * (C) 2001, 2002, 2003 Ximian, Inc.
 */

#ifndef _MONO_JIT_JIT_H_
#define _MONO_JIT_JIT_H_

#include <mono/metadata/appdomain.h>

MONO_BEGIN_DECLS

MONO_API MONO_RT_EXTERNAL_ONLY MonoDomain * 
mono_jit_init              (const char *file);

MONO_API MONO_RT_EXTERNAL_ONLY MonoDomain * 
mono_jit_init_version      (const char *root_domain_name, const char *runtime_version);

MONO_API MonoDomain * 
mono_jit_init_version_for_test_only      (const char *root_domain_name, const char *runtime_version);

MONO_API int
mono_jit_exec              (MonoDomain *domain, MonoAssembly *assembly, 
			    int argc, char *argv[]);
MONO_API void        
mono_jit_cleanup           (MonoDomain *domain);

MONO_API mono_bool
mono_jit_set_trace_options (const char* options);

MONO_API void
mono_set_signal_chaining   (mono_bool chain_signals);

MONO_API void
mono_set_crash_chaining   (mono_bool chain_signals);

/**
 * This function is deprecated, use mono_jit_set_aot_mode instead.
 */
MONO_API void
mono_jit_set_aot_only      (mono_bool aot_only);

/**
 * Allows control over our AOT (Ahead-of-time) compilation mode.
 */
typedef enum {
	/* Disables AOT mode */
	MONO_AOT_MODE_NONE,
	/* Enables normal AOT mode, equivalent to mono_jit_set_aot_only (false) */
	MONO_AOT_MODE_NORMAL,
	/* Enables hybrid AOT mode, JIT can still be used for wrappers */
	MONO_AOT_MODE_HYBRID,
	/* Enables full AOT mode, JIT is disabled and not allowed,
	 * equivalent to mono_jit_set_aot_only (true) */
	MONO_AOT_MODE_FULL,
	/* Same as full, but use only llvm compiled code */
	MONO_AOT_MODE_LLVMONLY,
	/* Uses Interpreter, JIT is disabled and not allowed,
	 * equivalent to "--full-aot --interpreter" */
	MONO_AOT_MODE_INTERP,
	/* Same as INTERP, but use only llvm compiled code */
	MONO_AOT_MODE_INTERP_LLVMONLY,
	/* Use only llvm compiled code, fall back to the interpeter */
	MONO_AOT_MODE_LLVMONLY_INTERP,
	/* Sentinel value used internally by the runtime. We use a large number to avoid clashing with some internal values. */
	MONO_AOT_MODE_LAST = 1000,
} MonoAotMode;

MONO_API void
mono_jit_set_aot_mode      (MonoAotMode mode);

/*
 * Returns whether the runtime was invoked for the purpose of AOT-compiling an
 * assembly, i.e. no managed code will run.
 */
MONO_API mono_bool
mono_jit_aot_compiling (void);

/* Allow embedders to decide wherther to actually obey breakpoint instructions
 * in specific methods (works for both break IL instructions and Debugger.Break ()
 * method calls).
 */
typedef enum {
	/* the default is to always obey the breakpoint */
	MONO_BREAK_POLICY_ALWAYS,
	/* a nop is inserted instead of a breakpoint */
	MONO_BREAK_POLICY_NEVER,
	/* the breakpoint is executed only if the program has ben started under
	 * the debugger (that is if a debugger was attached at the time the method
	 * was compiled).
	 */
	MONO_BREAK_POLICY_ON_DBG
} MonoBreakPolicy;

typedef MonoBreakPolicy (*MonoBreakPolicyFunc) (MonoMethod *method);
MONO_API void mono_set_break_policy (MonoBreakPolicyFunc policy_callback);

MONO_API void
mono_jit_parse_options     (int argc, char * argv[]);

MONO_API char*       mono_get_runtime_build_info    (void);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_set_use_llvm (mono_bool use_llvm);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_aot_register_module (void **aot_info);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoDomain* mono_jit_thread_attach (MonoDomain *domain);


MONO_END_DECLS

#endif


```

`Hazel/vendor/mono/include/mono/metadata/abi-details.h`:

```h
/**
 * \file
 * Copyright 2014 Xamarin Inc
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_ABI_DETAILS_H__
#define __MONO_METADATA_ABI_DETAILS_H__

#include <config.h>
#include <glib.h>

/*
 * This file defines macros to compute sizes/alignments/field offsets which depend on
 * the ABI. It is needed during cross compiling since the generated code needs to
 * contain offsets which correspond to the ABI of the target, not the host.
 * It defines the following macros:
 * - MONO_ABI_SIZEOF(type) for every basic type
 * - MONO_ABI_ALIGNOF(type) for every basic type
 * - MONO_STRUCT_OFFSET(struct, field) for various runtime structures
 * When not cross compiling, these correspond to the host ABI (i.e. sizeof/offsetof).
 * When cross compiling, these are defined in a generated header file which is
 * generated by the offsets tool in tools/offsets-tool. The name of the file
 * is given by the --with-cross-offsets= configure argument.
 */

typedef enum {
	MONO_ALIGN_gint8,
	MONO_ALIGN_gint16,
	MONO_ALIGN_gint32,
	MONO_ALIGN_gint64,
	MONO_ALIGN_float,
	MONO_ALIGN_double,
	MONO_ALIGN_gpointer,
	MONO_ALIGN_COUNT
} CoreTypeAlign;

int mono_abi_alignment (CoreTypeAlign type);

#define MONO_ABI_ALIGNOF(type) mono_abi_alignment (MONO_ALIGN_ ## type)
#define MONO_ABI_SIZEOF(type) (MONO_STRUCT_SIZE (type))
#define MONO_CURRENT_ABI_SIZEOF(type) ((int)sizeof(type))

#undef DECL_OFFSET2
#define DECL_OFFSET(struct,field) MONO_OFFSET_ ## struct ## _ ## field = -1,
#define DECL_OFFSET2(struct,field,offset) MONO_OFFSET_ ## struct ## _ ## field = offset,
#define DECL_ALIGN2(type,size)
#define DECL_SIZE(type) MONO_SIZEOF_ ##type = -1,
#define DECL_SIZE2(type,size) MONO_SIZEOF_ ##type = size,


enum {
#include "object-offsets.h"
};

#ifdef USED_CROSS_COMPILER_OFFSETS
#define MONO_STRUCT_OFFSET(struct,field) MONO_OFFSET_ ## struct ## _ ## field
#define MONO_STRUCT_SIZE(struct) MONO_SIZEOF_ ## struct
#else
#if defined(HAS_CROSS_COMPILER_OFFSETS) || defined(MONO_CROSS_COMPILE)
#define MONO_STRUCT_OFFSET(struct,field) (MONO_OFFSET_ ## struct ## _ ## field == -1, G_STRUCT_OFFSET (struct,field))
#define MONO_STRUCT_SIZE(struct) (MONO_SIZEOF_ ## struct == -1, (int)sizeof(struct))
#else
#define MONO_STRUCT_OFFSET(struct,field) G_STRUCT_OFFSET (struct,field)
#define MONO_STRUCT_SIZE(struct) ((int)sizeof(struct))
#endif
#endif

// #define MONO_SIZEOF_MonoObject (2 * MONO_ABI_SIZEOF(gpointer))
#define MONO_SIZEOF_MonoObject (2 * MONO_SIZEOF_gpointer)
#endif

```

`Hazel/vendor/mono/include/mono/metadata/appdomain-icalls.h`:

```h
/**
 * \file
 * Appdomain-related icalls.
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_METADATA_APPDOMAIN_ICALLS_H__
#define __MONO_METADATA_APPDOMAIN_ICALLS_H__

#include <mono/metadata/appdomain.h>
#include <mono/metadata/handle.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/icalls.h>
#include "reflection-internals.h"

#endif /*__MONO_METADATA_APPDOMAIN_ICALLS_H__*/

```

`Hazel/vendor/mono/include/mono/metadata/appdomain.h`:

```h
/**
 * \file
 * AppDomain functions
 *
 * Author:
 *	Dietmar Maurer (dietmar@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 */

#ifndef _MONO_METADATA_APPDOMAIN_H_
#define _MONO_METADATA_APPDOMAIN_H_

#include <mono/utils/mono-publib.h>

#include <mono/utils/mono-forward.h>
#include <mono/metadata/object.h>
#include <mono/metadata/reflection.h>

MONO_BEGIN_DECLS

typedef void (*MonoThreadStartCB) (intptr_t tid, void* stack_start,
				   void* func);
typedef void (*MonoThreadAttachCB) (intptr_t tid, void* stack_start);

typedef struct _MonoAppDomain MonoAppDomain;

typedef void (*MonoDomainFunc) (MonoDomain *domain, void* user_data);

MONO_API MonoDomain*
mono_init                  (const char *filename);

MONO_API MonoDomain *
mono_init_from_assembly    (const char *domain_name, const char *filename);

MONO_API MonoDomain *
mono_init_version          (const char *domain_name, const char *version);

MONO_API MonoDomain*
mono_get_root_domain       (void);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_runtime_init          (MonoDomain *domain, MonoThreadStartCB start_cb,
			    MonoThreadAttachCB attach_cb);

MONO_API void
mono_runtime_cleanup       (MonoDomain *domain);

MONO_API void
mono_install_runtime_cleanup (MonoDomainFunc func);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_runtime_quit (void);

MONO_API void
mono_runtime_set_shutting_down (void);

MONO_API mono_bool
mono_runtime_is_shutting_down (void);

MONO_API const char*
mono_check_corlib_version (void);

MONO_API MonoDomain *
mono_domain_create         (void);

MONO_API MONO_RT_EXTERNAL_ONLY MonoDomain *
mono_domain_create_appdomain (char *friendly_name, char *configuration_file);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_domain_set_config (MonoDomain *domain, const char *base_dir, const char *config_file_name);

MONO_API MonoDomain *
mono_domain_get            (void);

MONO_API MonoDomain *
mono_domain_get_by_id      (int32_t domainid);

MONO_API int32_t
mono_domain_get_id         (MonoDomain *domain);

MONO_API const char *
mono_domain_get_friendly_name (MonoDomain *domain);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_domain_set            (MonoDomain *domain, mono_bool force);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_domain_set_internal   (MonoDomain *domain);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_domain_unload (MonoDomain *domain);

MONO_API void
mono_domain_try_unload (MonoDomain *domain, MonoObject **exc);

MONO_API mono_bool
mono_domain_is_unloading   (MonoDomain *domain);

MONO_API MONO_RT_EXTERNAL_ONLY MonoDomain *
mono_domain_from_appdomain (MonoAppDomain *appdomain);

MONO_API void
mono_domain_foreach        (MonoDomainFunc func, void* user_data);

MONO_API MONO_RT_EXTERNAL_ONLY MonoAssembly *
mono_domain_assembly_open  (MonoDomain *domain, const char *name);

MONO_API mono_bool
mono_domain_finalize       (MonoDomain *domain, uint32_t timeout);

MONO_API void
mono_domain_free           (MonoDomain *domain, mono_bool force);

MONO_API mono_bool
mono_domain_has_type_resolve (MonoDomain *domain);

MONO_API MONO_RT_EXTERNAL_ONLY MonoReflectionAssembly *
mono_domain_try_type_resolve (MonoDomain *domain, char *name, MonoObject *tb);

MONO_API mono_bool
mono_domain_owns_vtable_slot (MonoDomain *domain, void* vtable_slot);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_context_init 				   (MonoDomain *domain);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_context_set				   (MonoAppContext *new_context);

MONO_API MonoAppContext * 
mono_context_get				   (void);

MONO_API int32_t
mono_context_get_id         (MonoAppContext *context);

MONO_API int32_t
mono_context_get_domain_id  (MonoAppContext *context);

MONO_API MonoJitInfo *
mono_jit_info_table_find   (MonoDomain *domain, void* addr);

/* MonoJitInfo accessors */

MONO_API void*
mono_jit_info_get_code_start (MonoJitInfo* ji);

MONO_API int
mono_jit_info_get_code_size (MonoJitInfo* ji);

MONO_API MonoMethod*
mono_jit_info_get_method (MonoJitInfo* ji);


MONO_API MonoImage*
mono_get_corlib            (void);

MONO_API MonoClass*
mono_get_object_class      (void);

MONO_API MonoClass*
mono_get_byte_class        (void);

MONO_API MonoClass*
mono_get_void_class        (void);

MONO_API MonoClass*
mono_get_boolean_class     (void);

MONO_API MonoClass*
mono_get_sbyte_class       (void);

MONO_API MonoClass*
mono_get_int16_class       (void);

MONO_API MonoClass*
mono_get_uint16_class      (void);

MONO_API MonoClass*
mono_get_int32_class       (void);

MONO_API MonoClass*
mono_get_uint32_class      (void);

MONO_API MonoClass*
mono_get_intptr_class         (void);

MONO_API MonoClass*
mono_get_uintptr_class        (void);

MONO_API MonoClass*
mono_get_int64_class       (void);

MONO_API MonoClass*
mono_get_uint64_class      (void);

MONO_API MonoClass*
mono_get_single_class      (void);

MONO_API MonoClass*
mono_get_double_class      (void);

MONO_API MonoClass*
mono_get_char_class        (void);

MONO_API MonoClass*
mono_get_string_class      (void);

MONO_API MonoClass*
mono_get_enum_class        (void);

MONO_API MonoClass*
mono_get_array_class       (void);

MONO_API MonoClass*
mono_get_thread_class       (void);

MONO_API MonoClass*
mono_get_exception_class    (void);

MONO_API void
mono_security_enable_core_clr (void);

typedef mono_bool (*MonoCoreClrPlatformCB) (const char *image_name);

MONO_API void
mono_security_set_core_clr_platform_callback (MonoCoreClrPlatformCB callback);

MONO_END_DECLS

#endif /* _MONO_METADATA_APPDOMAIN_H_ */


```

`Hazel/vendor/mono/include/mono/metadata/assembly-internals.h`:

```h
/**
 * \file
 * Copyright 2015 Xamarin Inc
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_ASSEMBLY_INTERNALS_H__
#define __MONO_METADATA_ASSEMBLY_INTERNALS_H__

#include <glib.h>

#include <mono/metadata/assembly.h>
#include <mono/metadata/metadata-internals.h>

#ifndef ENABLE_NETCORE
#define MONO_ASSEMBLY_CORLIB_NAME "mscorlib"
#else
#define MONO_ASSEMBLY_CORLIB_NAME "System.Private.CoreLib"
#endif

/* Flag bits for mono_assembly_names_equal_flags (). */
typedef enum {
	/* Default comparison: all fields must match */
	MONO_ANAME_EQ_NONE = 0x0,
	/* Don't compare public key token */
	MONO_ANAME_EQ_IGNORE_PUBKEY = 0x1,
	/* Don't compare the versions */
	MONO_ANAME_EQ_IGNORE_VERSION = 0x2,
	/* When comparing simple names, ignore case differences */
	MONO_ANAME_EQ_IGNORE_CASE = 0x4,

	MONO_ANAME_EQ_MASK = 0x7
} MonoAssemblyNameEqFlags;

G_ENUM_FUNCTIONS (MonoAssemblyNameEqFlags)

void
mono_assembly_name_free_internal (MonoAssemblyName *aname);

gboolean
mono_assembly_name_culture_is_neutral (const MonoAssemblyName *aname);

gboolean
mono_assembly_names_equal_flags (MonoAssemblyName *l, MonoAssemblyName *r, MonoAssemblyNameEqFlags flags);

gboolean
mono_assembly_get_assemblyref_checked (MonoImage *image, int index, MonoAssemblyName *aname, MonoError *error);

MONO_API MonoImage*    mono_assembly_load_module_checked (MonoAssembly *assembly, uint32_t idx, MonoError *error);

MonoAssembly* mono_assembly_load_with_partial_name_internal (const char *name, MonoAssemblyLoadContext *alc, MonoImageOpenStatus *status);


typedef gboolean (*MonoAssemblyAsmCtxFromPathFunc) (const char *absfname, MonoAssembly *requesting_assembly, gpointer user_data, MonoAssemblyContextKind *out_asmctx);

void mono_install_assembly_asmctx_from_path_hook (MonoAssemblyAsmCtxFromPathFunc func, gpointer user_data);

typedef MonoAssembly * (*MonoAssemblyPreLoadFuncV2) (MonoAssemblyLoadContext *alc, MonoAssemblyName *aname, char **assemblies_path, gboolean refonly, gpointer user_data, MonoError *error);

void mono_install_assembly_preload_hook_v2 (MonoAssemblyPreLoadFuncV2 func, gpointer user_data, gboolean refonly);

typedef MonoAssembly * (*MonoAssemblySearchFuncV2) (MonoAssemblyLoadContext *alc, MonoAssembly *requesting, MonoAssemblyName *aname, gboolean refonly, gboolean postload, gpointer user_data, MonoError *error);

void
mono_install_assembly_search_hook_v2 (MonoAssemblySearchFuncV2 func, gpointer user_data, gboolean refonly, gboolean postload);

typedef void (*MonoAssemblyLoadFuncV2) (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, gpointer user_data, MonoError *error);

void
mono_install_assembly_load_hook_v2 (MonoAssemblyLoadFuncV2 func, gpointer user_data);

void
mono_assembly_invoke_load_hook_internal (MonoAssemblyLoadContext *alc, MonoAssembly *ass);

/* If predicate returns true assembly should be loaded, if false ignore it. */
typedef gboolean (*MonoAssemblyCandidatePredicate)(MonoAssembly *, gpointer);

typedef struct MonoAssemblyLoadRequest {
	/* Assembly Load context that is requesting an assembly. */
	MonoAssemblyContextKind asmctx;
	MonoAssemblyLoadContext *alc;
	/* Predicate to apply to candidate assemblies. Optional. */
	MonoAssemblyCandidatePredicate predicate;
	/* user_data for predicate. Optional. */
	gpointer predicate_ud;
} MonoAssemblyLoadRequest;

typedef struct MonoAssemblyOpenRequest {
	MonoAssemblyLoadRequest request;
	/* Assembly that is requesting the wanted assembly. Optional. */
	MonoAssembly *requesting_assembly;
} MonoAssemblyOpenRequest;

typedef struct MonoAssemblyByNameRequest {
	MonoAssemblyLoadRequest request;
	/* Assembly that is requesting the wanted assembly name. Optional.
	 * If no_postload_search is TRUE, requesting_assembly is not used.
	 */
	MonoAssembly *requesting_assembly;
	/* basedir to probe for the wanted assembly name.  Optional. */
	const char *basedir;
	gboolean no_postload_search; /* FALSE is usual */
	/* FIXME: predicate unused? */
} MonoAssemblyByNameRequest;

void                   mono_assembly_request_prepare_load (MonoAssemblyLoadRequest *req,
							   MonoAssemblyContextKind asmctx,
							   MonoAssemblyLoadContext *alc);

void                   mono_assembly_request_prepare_open (MonoAssemblyOpenRequest *req,
							   MonoAssemblyContextKind asmctx,
							   MonoAssemblyLoadContext *alc);

void                   mono_assembly_request_prepare_byname (MonoAssemblyByNameRequest *req,
							     MonoAssemblyContextKind asmctx,
							     MonoAssemblyLoadContext *alc);

MonoAssembly*          mono_assembly_request_open (const char *filename,
						     const MonoAssemblyOpenRequest *req,
						     MonoImageOpenStatus *status);

MonoAssembly*          mono_assembly_request_load_from (MonoImage *image, const char *fname,
							const MonoAssemblyLoadRequest *req,
							MonoImageOpenStatus *status);

MonoAssembly*          mono_assembly_request_byname (MonoAssemblyName *aname,
						     const MonoAssemblyByNameRequest *req,
						     MonoImageOpenStatus *status);

/* MonoAssemblyCandidatePredicate that compares the assembly name (name, version,
 * culture, public key token) of the candidate with the wanted name, if the
 * wanted name has a public key token (if not present, always return true).
 * Pass the wanted MonoAssemblyName* as the user_data.
 */
gboolean
mono_assembly_candidate_predicate_sn_same_name (MonoAssembly *candidate, gpointer wanted_name);

gboolean
mono_assembly_check_name_match (MonoAssemblyName *wanted_name, MonoAssemblyName *candidate_name);

MonoAssembly*
mono_assembly_binding_applies_to_image (MonoAssemblyLoadContext *alc, MonoImage* image, MonoImageOpenStatus *status);

MonoAssembly*
mono_assembly_load_from_assemblies_path (gchar **assemblies_path, MonoAssemblyName *aname, MonoAssemblyContextKind asmctx);

MonoAssembly *
mono_assembly_loaded_internal (MonoAssemblyLoadContext *alc, MonoAssemblyName *aname, gboolean refonly);

MONO_PROFILER_API MonoAssemblyName*
mono_assembly_get_name_internal (MonoAssembly *assembly);

MONO_PROFILER_API MonoImage*
mono_assembly_get_image_internal (MonoAssembly *assembly);

#endif /* __MONO_METADATA_ASSEMBLY_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/assembly.h`:

```h
/**
 * \file
 */

#ifndef _MONONET_METADATA_ASSEMBLY_H_ 
#define _MONONET_METADATA_ASSEMBLY_H_

#include <mono/utils/mono-error.h>
#include <mono/metadata/image.h>

MONO_BEGIN_DECLS

MONO_API void          mono_assemblies_init     (void);
MONO_API void          mono_assemblies_cleanup  (void);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly *mono_assembly_open       (const char *filename,
				       	MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly *mono_assembly_open_full (const char *filename,
				       	MonoImageOpenStatus *status,
					mono_bool refonly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_load       (MonoAssemblyName *aname, 
                                       	const char       *basedir, 
				     	MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_load_full (MonoAssemblyName *aname,
                                       	const char       *basedir, 
				     	MonoImageOpenStatus *status,
					mono_bool refonly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_load_from  (MonoImage *image, const char *fname,
					MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_load_from_full  (MonoImage *image, const char *fname,
					MonoImageOpenStatus *status,
					mono_bool refonly);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_load_with_partial_name (const char *name, MonoImageOpenStatus *status);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_loaded     (MonoAssemblyName *aname);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_loaded_full (MonoAssemblyName *aname, mono_bool refonly);
MONO_API void          mono_assembly_get_assemblyref (MonoImage *image, int index, MonoAssemblyName *aname);
MONO_API void          mono_assembly_load_reference (MonoImage *image, int index);
MONO_API void          mono_assembly_load_references (MonoImage *image, MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY MonoImage*    mono_assembly_load_module (MonoAssembly *assembly, uint32_t idx);
MONO_API void          mono_assembly_close      (MonoAssembly *assembly);
MONO_API void          mono_assembly_setrootdir (const char *root_dir);
MONO_API MONO_CONST_RETURN char *mono_assembly_getrootdir (void);
MONO_API char         *mono_native_getrootdir (void);
MONO_API void	       mono_assembly_foreach    (MonoFunc func, void* user_data);
MONO_API void          mono_assembly_set_main   (MonoAssembly *assembly);
MONO_API MonoAssembly *mono_assembly_get_main   (void);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage    *mono_assembly_get_image  (MonoAssembly *assembly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssemblyName *mono_assembly_get_name (MonoAssembly *assembly);
MONO_API mono_bool      mono_assembly_fill_assembly_name (MonoImage *image, MonoAssemblyName *aname);
MONO_API mono_bool      mono_assembly_names_equal (MonoAssemblyName *l, MonoAssemblyName *r);
MONO_API char*         mono_stringify_assembly_name (MonoAssemblyName *aname);

/* Installs a function which is called each time a new assembly is loaded. */
typedef void  (*MonoAssemblyLoadFunc)         (MonoAssembly *assembly, void* user_data);
MONO_API MONO_RT_EXTERNAL_ONLY void
mono_install_assembly_load_hook (MonoAssemblyLoadFunc func, void* user_data);

/* 
 * Installs a new function which is used to search the list of loaded 
 * assemblies for a given assembly name.
 */
typedef MonoAssembly *(*MonoAssemblySearchFunc)         (MonoAssemblyName *aname, void* user_data);
MONO_API MONO_RT_EXTERNAL_ONLY
void          mono_install_assembly_search_hook (MonoAssemblySearchFunc func, void* user_data);
MONO_API MONO_RT_EXTERNAL_ONLY
void 	      mono_install_assembly_refonly_search_hook (MonoAssemblySearchFunc func, void* user_data);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoAssembly* mono_assembly_invoke_search_hook (MonoAssemblyName *aname);

/*
 * Installs a new search function which is used as a last resort when loading 
 * an assembly fails. This could invoke AssemblyResolve events.
 */
MONO_API MONO_RT_EXTERNAL_ONLY
void
mono_install_assembly_postload_search_hook (MonoAssemblySearchFunc func, void* user_data);

MONO_API MONO_RT_EXTERNAL_ONLY
void
mono_install_assembly_postload_refonly_search_hook (MonoAssemblySearchFunc func, void* user_data);


/* Installs a function which is called before a new assembly is loaded
 * The hook are invoked from last hooked to first. If any of them returns
 * a non-null value, that will be the value returned in mono_assembly_load */
typedef MonoAssembly * (*MonoAssemblyPreLoadFunc) (MonoAssemblyName *aname,
						   char **assemblies_path,
						   void* user_data);

MONO_API MONO_RT_EXTERNAL_ONLY
void          mono_install_assembly_preload_hook (MonoAssemblyPreLoadFunc func, void* user_data);
MONO_API MONO_RT_EXTERNAL_ONLY
void          mono_install_assembly_refonly_preload_hook (MonoAssemblyPreLoadFunc func, void* user_data);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_assembly_invoke_load_hook (MonoAssembly *ass);

MONO_API MonoAssemblyName* mono_assembly_name_new             (const char *name);
MONO_API const char*       mono_assembly_name_get_name        (MonoAssemblyName *aname);
MONO_API const char*       mono_assembly_name_get_culture     (MonoAssemblyName *aname);
MONO_API uint16_t          mono_assembly_name_get_version     (MonoAssemblyName *aname,
						      uint16_t *minor, uint16_t *build, uint16_t *revision);
MONO_API mono_byte*        mono_assembly_name_get_pubkeytoken (MonoAssemblyName *aname);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_assembly_name_free   (MonoAssemblyName *aname);

typedef struct {
	const char *name;
	const unsigned char *data;
	unsigned int size;
} MonoBundledAssembly;

MONO_API void          mono_register_bundled_assemblies (const MonoBundledAssembly **assemblies);
MONO_API void          mono_register_config_for_assembly (const char* assembly_name, const char* config_xml);
MONO_API void          mono_register_symfile_for_assembly (const char* assembly_name, const mono_byte *raw_contents, int size);
MONO_API void	      mono_register_machine_config (const char *config_xml);

MONO_API void          mono_set_rootdir (void);
MONO_API void          mono_set_dirs (const char *assembly_dir, const char *config_dir);
MONO_API void          mono_set_assemblies_path (const char* path);
MONO_END_DECLS

#endif


```

`Hazel/vendor/mono/include/mono/metadata/attach.h`:

```h
/**
 * \file
 */

#ifndef __MONO_ATTACH_H__
#define __MONO_ATTACH_H__

#include <glib.h>
#include <mono/utils/mono-compiler.h>

void
mono_attach_parse_options (char *options);

void
mono_attach_init (void);

gboolean
mono_attach_start (void);

void
mono_attach_maybe_start (void);

void
mono_attach_cleanup (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/attrdefs.h`:

```h
/**
 * \file
 * This file contains the various definitions for constants
 * found on the metadata tables
 *
 * Author:
 *   Miguel de Icaza (miguel@ximian.com)
 *   Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 * (C) 2006 Novell, Inc.
 *
 * From the ECMA documentation
 */
 
#ifndef _MONO_METADATA_ATTRDEFS_H_
#define	_MONO_METADATA_ATTRDEFS_H_

/*
 * 23.1.1  Values for AssemblyHashAlgorithm 
 */
enum {
	MONO_ASSEMBLY_HASH_NONE,
	MONO_ASSEMBLY_HASH_MD5  = 0x8003,
	MONO_ASSEMBLY_HASH_SHA1 = 0x8004
};

/*
 * 23.1.2 AssemblyRefs
 */
enum {
	MONO_ASSEMBLYREF_FULL_PUBLIC_KEY = 0x0001,
	MONO_ASSEMBLYREF_RETARGETABLE    = 0x0100,
	MONO_ASSEMBLYREF_JIT_TRACKING    = 0x8000,
	MONO_ASSEMBLYREF_NO_JIT_OPT      = 0x4000
};

/*
 * 23.1.4 Flags for Event.EventAttributes
 */
enum {
	MONO_EVENT_SPECIALNAME   = 0x0200,
	MONO_EVENT_RTSPECIALNAME = 0x0400
};

/*
 * Field Attributes (23.1.5).
 */
enum {
	MONO_FIELD_ATTR_FIELD_ACCESS_MASK     = 0x0007,
	MONO_FIELD_ATTR_COMPILER_CONTROLLED   = 0x0000,
	MONO_FIELD_ATTR_PRIVATE               = 0x0001,
	MONO_FIELD_ATTR_FAM_AND_ASSEM         = 0x0002,
	MONO_FIELD_ATTR_ASSEMBLY              = 0x0003,
	MONO_FIELD_ATTR_FAMILY                = 0x0004,
	MONO_FIELD_ATTR_FAM_OR_ASSEM          = 0x0005,
	MONO_FIELD_ATTR_PUBLIC                = 0x0006,

	MONO_FIELD_ATTR_STATIC                = 0x0010,
	MONO_FIELD_ATTR_INIT_ONLY             = 0x0020,
	MONO_FIELD_ATTR_LITERAL               = 0x0040,
	MONO_FIELD_ATTR_NOT_SERIALIZED        = 0x0080,
	MONO_FIELD_ATTR_SPECIAL_NAME          = 0x0200,
	MONO_FIELD_ATTR_PINVOKE_IMPL          = 0x2000,

/* For runtime use only */
	MONO_FIELD_ATTR_RESERVED_MASK         = 0x9500,
	MONO_FIELD_ATTR_RT_SPECIAL_NAME       = 0x0400,
	MONO_FIELD_ATTR_HAS_MARSHAL           = 0x1000,
	MONO_FIELD_ATTR_HAS_DEFAULT           = 0x8000,
	MONO_FIELD_ATTR_HAS_RVA               = 0x0100
};

/*
 * 23.1.6 Flags for FileAttributes
 */
enum {
	MONO_FILE_HAS_METADATA      = 0,
	MONO_FILE_HAS_NO_METADATA   = 1
};

/*
 * 23.1.7 Flags for generic parameters
 */
enum {
	MONO_GEN_PARAM_VARIANCE_MASK    = 0x0003,
	MONO_GEN_PARAM_NON_VARIANT      = 0x0000,
	MONO_GEN_PARAM_VARIANT          = 0x0001,
	MONO_GEN_PARAM_COVARIANT        = 0x0002,
	MONO_GEN_PARAM_CONSTRAINT_MASK  = 0x001c,
	MONO_GEN_PARAM_CONSTRAINT_CLASS = 0x0004,
	MONO_GEN_PARAM_CONSTRAINT_VTYPE = 0x0008,
	MONO_GEN_PARAM_CONSTRAINT_DCTOR = 0x0010
};

/*
 * 23.1.8 Flags for ImplMap [PInvokeAttributes]
 */
enum {
	MONO_PINVOKE_NO_MANGLE           = 0x0001,
	MONO_PINVOKE_CHAR_SET_MASK       = 0x0006,
	MONO_PINVOKE_CHAR_SET_NOT_SPEC   = 0x0000,
	MONO_PINVOKE_CHAR_SET_ANSI       = 0x0002,
	MONO_PINVOKE_CHAR_SET_UNICODE    = 0x0004,
	MONO_PINVOKE_CHAR_SET_AUTO       = 0x0006,
	MONO_PINVOKE_BEST_FIT_ENABLED    = 0x0010,
	MONO_PINVOKE_BEST_FIT_DISABLED   = 0x0020,
	MONO_PINVOKE_BEST_FIT_MASK       = 0x0030,
	MONO_PINVOKE_SUPPORTS_LAST_ERROR = 0x0040,
	MONO_PINVOKE_CALL_CONV_MASK      = 0x0700,
	MONO_PINVOKE_CALL_CONV_WINAPI    = 0x0100,
	MONO_PINVOKE_CALL_CONV_CDECL     = 0x0200,
	MONO_PINVOKE_CALL_CONV_STDCALL   = 0x0300,
	MONO_PINVOKE_CALL_CONV_THISCALL  = 0x0400,
	MONO_PINVOKE_CALL_CONV_FASTCALL  = 0x0500,
	MONO_PINVOKE_THROW_ON_UNMAPPABLE_ENABLED    = 0x1000,
	MONO_PINVOKE_THROW_ON_UNMAPPABLE_DISABLED   = 0x2000,
	MONO_PINVOKE_THROW_ON_UNMAPPABLE_MASK       = 0x3000,
	MONO_PINVOKE_CALL_CONV_GENERIC     = 0x0010,
	MONO_PINVOKE_CALL_CONV_GENERICINST = 0x000a
};

/*
 * 23.1.9 Flags for ManifestResource
 */
enum {
	MONO_MANIFEST_RESOURCE_VISIBILITY_MASK    = 0x00000007,
	MONO_MANIFEST_RESOURCE_PUBLIC             = 0x00000001,
	MONO_MANIFEST_RESOURCE_PRIVATE            = 0x00000002
};

/*
 * Method Attributes (23.1.10)
 */
enum {
	MONO_METHOD_ATTR_ACCESS_MASK               = 0x0007,
	MONO_METHOD_ATTR_COMPILER_CONTROLLED       = 0x0000,
	MONO_METHOD_ATTR_PRIVATE                   = 0x0001,
	MONO_METHOD_ATTR_FAM_AND_ASSEM             = 0x0002,
	MONO_METHOD_ATTR_ASSEM                     = 0x0003,
	MONO_METHOD_ATTR_FAMILY                    = 0x0004,
	MONO_METHOD_ATTR_FAM_OR_ASSEM              = 0x0005,
	MONO_METHOD_ATTR_PUBLIC                    = 0x0006,

	MONO_METHOD_ATTR_STATIC                    = 0x0010,
	MONO_METHOD_ATTR_FINAL                     = 0x0020,
	MONO_METHOD_ATTR_VIRTUAL                   = 0x0040,
	MONO_METHOD_ATTR_HIDE_BY_SIG               = 0x0080,

	MONO_METHOD_ATTR_VTABLE_LAYOUT_MASK        = 0x0100,
	MONO_METHOD_ATTR_REUSE_SLOT                = 0x0000,
	MONO_METHOD_ATTR_NEW_SLOT                  = 0x0100,
	MONO_METHOD_ATTR_STRICT                    = 0x0200,
	MONO_METHOD_ATTR_ABSTRACT                  = 0x0400,

	MONO_METHOD_ATTR_SPECIAL_NAME              = 0x0800,

	MONO_METHOD_ATTR_PINVOKE_IMPL              = 0x2000,
	MONO_METHOD_ATTR_UNMANAGED_EXPORT          = 0x0008,

/*
 * For runtime use only
 */
	MONO_METHOD_ATTR_RESERVED_MASK             = 0xd000,
	MONO_METHOD_ATTR_RT_SPECIAL_NAME           = 0x1000,
	MONO_METHOD_ATTR_HAS_SECURITY              = 0x4000,
	MONO_METHOD_ATTR_REQUIRE_SEC_OBJECT        = 0x8000
};

/*
 * Method Impl Attributes (23.1.11)
 */
enum {
	MONO_METHOD_IMPL_ATTR_CODE_TYPE_MASK       = 0x0003,
	MONO_METHOD_IMPL_ATTR_IL                   = 0x0000,
	MONO_METHOD_IMPL_ATTR_NATIVE               = 0x0001,
	MONO_METHOD_IMPL_ATTR_OPTIL                = 0x0002,
	MONO_METHOD_IMPL_ATTR_RUNTIME              = 0x0003,

	MONO_METHOD_IMPL_ATTR_MANAGED_MASK         = 0x0004,
	MONO_METHOD_IMPL_ATTR_UNMANAGED            = 0x0004,
	MONO_METHOD_IMPL_ATTR_MANAGED              = 0x0000,

	MONO_METHOD_IMPL_ATTR_FORWARD_REF          = 0x0010,
	MONO_METHOD_IMPL_ATTR_PRESERVE_SIG         = 0x0080,
	MONO_METHOD_IMPL_ATTR_INTERNAL_CALL        = 0x1000,
	MONO_METHOD_IMPL_ATTR_SYNCHRONIZED         = 0x0020,
	MONO_METHOD_IMPL_ATTR_NOINLINING           = 0x0008,
	MONO_METHOD_IMPL_ATTR_NOOPTIMIZATION       = 0x0040,	
	MONO_METHOD_IMPL_ATTR_MAX_METHOD_IMPL_VAL  = 0xffff
};

/*
 * Method Semantics ([MethodSemanticAttributes]) 23.1.12,
 */
enum {
	MONO_METHOD_SEMANTIC_SETTER    = 0x0001,
	MONO_METHOD_SEMANTIC_GETTER    = 0x0002,
	MONO_METHOD_SEMANTIC_OTHER     = 0x0004,
	MONO_METHOD_SEMANTIC_ADD_ON    = 0x0008,
	MONO_METHOD_SEMANTIC_REMOVE_ON = 0x0010,
	MONO_METHOD_SEMANTIC_FIRE      = 0x0020
};

/*
 * Flags for Params (23.1.13)
 */
enum {
	MONO_PARAM_ATTR_IN                 = 0x0001,
	MONO_PARAM_ATTR_OUT                = 0x0002,
	MONO_PARAM_ATTR_OPTIONAL           = 0x0010,
	MONO_PARAM_ATTR_RESERVED_MASK      = 0xf000,
	MONO_PARAM_ATTR_HAS_DEFAULT        = 0x1000,
	MONO_PARAM_ATTR_HAS_MARSHAL        = 0x2000,
	MONO_PARAM_ATTR_UNUSED             = 0xcfe0
};

/*
 * 23.1.14 PropertyAttributes
 */
enum {
	MONO_PROPERTY_ATTR_SPECIAL_NAME    = 0x0200,
	MONO_PROPERTY_ATTR_RESERVED_MASK   = 0xf400,
	MONO_PROPERTY_ATTR_RT_SPECIAL_NAME = 0x0400,
	MONO_PROPERTY_ATTR_HAS_DEFAULT     = 0x1000,
	MONO_PROPERTY_ATTR_UNUSED          = 0xe9ff
};

/*
 * Type Attributes (23.1.15).
 */
enum {
	MONO_TYPE_ATTR_VISIBILITY_MASK       = 0x00000007,
	MONO_TYPE_ATTR_NOT_PUBLIC            = 0x00000000,
	MONO_TYPE_ATTR_PUBLIC                = 0x00000001,
	MONO_TYPE_ATTR_NESTED_PUBLIC         = 0x00000002,
	MONO_TYPE_ATTR_NESTED_PRIVATE        = 0x00000003,
	MONO_TYPE_ATTR_NESTED_FAMILY         = 0x00000004,
	MONO_TYPE_ATTR_NESTED_ASSEMBLY       = 0x00000005,
	MONO_TYPE_ATTR_NESTED_FAM_AND_ASSEM  = 0x00000006,
	MONO_TYPE_ATTR_NESTED_FAM_OR_ASSEM   = 0x00000007,

	MONO_TYPE_ATTR_LAYOUT_MASK           = 0x00000018,
	MONO_TYPE_ATTR_AUTO_LAYOUT           = 0x00000000,
	MONO_TYPE_ATTR_SEQUENTIAL_LAYOUT     = 0x00000008,
	MONO_TYPE_ATTR_EXPLICIT_LAYOUT       = 0x00000010,

	MONO_TYPE_ATTR_CLASS_SEMANTIC_MASK   = 0x00000020,
	MONO_TYPE_ATTR_CLASS                 = 0x00000000,
	MONO_TYPE_ATTR_INTERFACE             = 0x00000020,

	MONO_TYPE_ATTR_ABSTRACT              = 0x00000080,
	MONO_TYPE_ATTR_SEALED                = 0x00000100,
	MONO_TYPE_ATTR_SPECIAL_NAME          = 0x00000400,

	MONO_TYPE_ATTR_IMPORT                = 0x00001000,
	MONO_TYPE_ATTR_SERIALIZABLE          = 0x00002000,

	MONO_TYPE_ATTR_STRING_FORMAT_MASK    = 0x00030000,
	MONO_TYPE_ATTR_ANSI_CLASS            = 0x00000000,
	MONO_TYPE_ATTR_UNICODE_CLASS         = 0x00010000,
	MONO_TYPE_ATTR_AUTO_CLASS            = 0x00020000,
	MONO_TYPE_ATTR_CUSTOM_CLASS          = 0x00030000,
	MONO_TYPE_ATTR_CUSTOM_MASK           = 0x00c00000,

	MONO_TYPE_ATTR_BEFORE_FIELD_INIT     = 0x00100000,
	MONO_TYPE_ATTR_FORWARDER             = 0x00200000,

	MONO_TYPE_ATTR_RESERVED_MASK         = 0x00040800,
	MONO_TYPE_ATTR_RT_SPECIAL_NAME       = 0x00000800,
	MONO_TYPE_ATTR_HAS_SECURITY          = 0x00040000
};

#endif

```

`Hazel/vendor/mono/include/mono/metadata/blob.h`:

```h
/**
 * \file
 * Definitions used to pull information out of the Blob
 *
 */
#ifndef _MONO_METADATA_BLOB_H_
#define _MONO_METADATA_BLOB_H_

/*
 * Encoding for type signatures used in the Metadata
 */
typedef enum {
	MONO_TYPE_END        = 0x00,       /* End of List */
	MONO_TYPE_VOID       = 0x01,
	MONO_TYPE_BOOLEAN    = 0x02,
	MONO_TYPE_CHAR       = 0x03,
	MONO_TYPE_I1         = 0x04,
	MONO_TYPE_U1         = 0x05,
	MONO_TYPE_I2         = 0x06,
	MONO_TYPE_U2         = 0x07,
	MONO_TYPE_I4         = 0x08,
	MONO_TYPE_U4         = 0x09,
	MONO_TYPE_I8         = 0x0a,
	MONO_TYPE_U8         = 0x0b,
	MONO_TYPE_R4         = 0x0c,
	MONO_TYPE_R8         = 0x0d,
	MONO_TYPE_STRING     = 0x0e,
	MONO_TYPE_PTR        = 0x0f,       /* arg: <type> token */
	MONO_TYPE_BYREF      = 0x10,       /* arg: <type> token */
	MONO_TYPE_VALUETYPE  = 0x11,       /* arg: <type> token */
	MONO_TYPE_CLASS      = 0x12,       /* arg: <type> token */
	MONO_TYPE_VAR	     = 0x13,	   /* number */
	MONO_TYPE_ARRAY      = 0x14,       /* type, rank, boundsCount, bound1, loCount, lo1 */
	MONO_TYPE_GENERICINST= 0x15,	   /* <type> <type-arg-count> <type-1> \x{2026} <type-n> */
	MONO_TYPE_TYPEDBYREF = 0x16,
	MONO_TYPE_I          = 0x18,
	MONO_TYPE_U          = 0x19,
	MONO_TYPE_FNPTR      = 0x1b,	      /* arg: full method signature */
	MONO_TYPE_OBJECT     = 0x1c,
	MONO_TYPE_SZARRAY    = 0x1d,       /* 0-based one-dim-array */
	MONO_TYPE_MVAR	     = 0x1e,       /* number */
	MONO_TYPE_CMOD_REQD  = 0x1f,       /* arg: typedef or typeref token */
	MONO_TYPE_CMOD_OPT   = 0x20,       /* optional arg: typedef or typref token */
	MONO_TYPE_INTERNAL   = 0x21,       /* CLR internal type */

	MONO_TYPE_MODIFIER   = 0x40,       /* Or with the following types */
	MONO_TYPE_SENTINEL   = 0x41,       /* Sentinel for varargs method signature */
	MONO_TYPE_PINNED     = 0x45,       /* Local var that points to pinned object */

	MONO_TYPE_ENUM       = 0x55        /* an enumeration */
} MonoTypeEnum;

typedef enum {
	MONO_TABLE_MODULE,
	MONO_TABLE_TYPEREF,
	MONO_TABLE_TYPEDEF,
	MONO_TABLE_FIELD_POINTER,
	MONO_TABLE_FIELD,
	MONO_TABLE_METHOD_POINTER,
	MONO_TABLE_METHOD,
	MONO_TABLE_PARAM_POINTER,
	MONO_TABLE_PARAM,
	MONO_TABLE_INTERFACEIMPL,
	MONO_TABLE_MEMBERREF, /* 0xa */
	MONO_TABLE_CONSTANT,
	MONO_TABLE_CUSTOMATTRIBUTE,
	MONO_TABLE_FIELDMARSHAL,
	MONO_TABLE_DECLSECURITY,
	MONO_TABLE_CLASSLAYOUT,
	MONO_TABLE_FIELDLAYOUT, /* 0x10 */
	MONO_TABLE_STANDALONESIG,
	MONO_TABLE_EVENTMAP,
	MONO_TABLE_EVENT_POINTER,
	MONO_TABLE_EVENT,
	MONO_TABLE_PROPERTYMAP,
	MONO_TABLE_PROPERTY_POINTER,
	MONO_TABLE_PROPERTY,
	MONO_TABLE_METHODSEMANTICS,
	MONO_TABLE_METHODIMPL,
	MONO_TABLE_MODULEREF, /* 0x1a */
	MONO_TABLE_TYPESPEC,
	MONO_TABLE_IMPLMAP,
	MONO_TABLE_FIELDRVA,
	MONO_TABLE_UNUSED6,
	MONO_TABLE_UNUSED7,
	MONO_TABLE_ASSEMBLY, /* 0x20 */
	MONO_TABLE_ASSEMBLYPROCESSOR,
	MONO_TABLE_ASSEMBLYOS,
	MONO_TABLE_ASSEMBLYREF,
	MONO_TABLE_ASSEMBLYREFPROCESSOR,
	MONO_TABLE_ASSEMBLYREFOS,
	MONO_TABLE_FILE,
	MONO_TABLE_EXPORTEDTYPE,
	MONO_TABLE_MANIFESTRESOURCE,
	MONO_TABLE_NESTEDCLASS,
	MONO_TABLE_GENERICPARAM, /* 0x2a */
	MONO_TABLE_METHODSPEC,
	MONO_TABLE_GENERICPARAMCONSTRAINT,
	MONO_TABLE_UNUSED8,
	MONO_TABLE_UNUSED9,
	MONO_TABLE_UNUSED10,
	/* Portable PDB tables */
	MONO_TABLE_DOCUMENT, /* 0x30 */
	MONO_TABLE_METHODBODY,
	MONO_TABLE_LOCALSCOPE,
	MONO_TABLE_LOCALVARIABLE,
	MONO_TABLE_LOCALCONSTANT,
	MONO_TABLE_IMPORTSCOPE,
	MONO_TABLE_STATEMACHINEMETHOD,
	MONO_TABLE_CUSTOMDEBUGINFORMATION

#define MONO_TABLE_LAST MONO_TABLE_CUSTOMDEBUGINFORMATION
#define MONO_TABLE_NUM (MONO_TABLE_LAST + 1)

} MonoMetaTableEnum;

#endif


```

`Hazel/vendor/mono/include/mono/metadata/callspec.h`:

```h
/**
 * \file
 */

#ifndef __MONO_CALLSPEC_H__
#define __MONO_CALLSPEC_H__
#include <glib.h>
#include <mono/utils/mono-compiler.h>

typedef enum {
	MONO_TRACEOP_ALL,
	MONO_TRACEOP_PROGRAM,
	MONO_TRACEOP_METHOD,
	MONO_TRACEOP_ASSEMBLY,
	MONO_TRACEOP_CLASS,
	MONO_TRACEOP_NAMESPACE,
	MONO_TRACEOP_EXCEPTION,
	MONO_TRACEOP_WRAPPER,
} MonoTraceOpcode;

typedef struct {
	MonoTraceOpcode op;
	int exclude;
	void *data, *data2;
} MonoTraceOperation;

typedef struct {
	int len;
	gboolean enabled;
	MonoTraceOperation *ops;
} MonoCallSpec;

MONO_PROFILER_API gboolean mono_callspec_parse		(const char *options,
							 MonoCallSpec *spec,
							 char **errstr);
MONO_PROFILER_API void     mono_callspec_cleanup	(MonoCallSpec *spec);
MONO_PROFILER_API gboolean mono_callspec_eval_exception	(MonoClass *klass,
							 MonoCallSpec *spec);
MONO_PROFILER_API gboolean mono_callspec_eval		(MonoMethod *method,
							 const MonoCallSpec *spec);
void			   mono_callspec_set_assembly	(MonoAssembly *assembly);

#endif /* __MONO_CALLSPEC_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/cil-coff.h`:

```h
/**
 * \file
 */

#ifndef __MONO_CIL_COFF_H__
#define __MONO_CIL_COFF_H__

#include <mono/metadata/metadata.h>
#include <glib.h>

/*
 * 25.2.1: Method header type values
 */
#define METHOD_HEADER_FORMAT_MASK   3
#define METHOD_HEADER_TINY_FORMAT   2
#define METHOD_HEADER_FAT_FORMAT    3

/*
 * 25.2.3.1: Flags for method headers
 */
#define METHOD_HEADER_INIT_LOCALS   0x10
#define METHOD_HEADER_MORE_SECTS    0x08

/*
 * For section data (25.3)
 */
#define METHOD_HEADER_SECTION_RESERVED    0
#define METHOD_HEADER_SECTION_EHTABLE     1
#define METHOD_HEADER_SECTION_OPTIL_TABLE 2
#define METHOD_HEADER_SECTION_FAT_FORMAT  0x40
#define METHOD_HEADER_SECTION_MORE_SECTS  0x80

/* 128 bytes */
typedef struct {
	char    msdos_sig [2];
	guint16 nlast_page;
	guint16 npages;
	char    msdos_header [54];
	guint32 pe_offset;
	char    msdos_header2 [64];
} MonoMSDOSHeader;

/* Possible values for coff_machine */
#define COFF_MACHINE_I386 332
#define COFF_MACHINE_IA64 512
#define COFF_MACHINE_AMD64 34404
#define COFF_MACHINE_ARM 452

/* 20 bytes */
typedef struct {
	guint16  coff_machine;
	guint16  coff_sections;
	guint32  coff_time;
	guint32  coff_symptr;
	guint32  coff_symcount;
	guint16  coff_opt_header_size;
	guint16  coff_attributes;
} MonoCOFFHeader;

#define COFF_ATTRIBUTE_EXECUTABLE_IMAGE 0x0002
#define COFF_ATTRIBUTE_LIBRARY_IMAGE    0x2000

/* 28 bytes */
typedef struct {
	guint16 pe_magic;
	guchar  pe_major;
	guchar  pe_minor;
	guint32 pe_code_size;
	guint32 pe_data_size;
	guint32 pe_uninit_data_size;
	guint32 pe_rva_entry_point;
	guint32 pe_rva_code_base;
	guint32 pe_rva_data_base;
} MonoPEHeader;

/* 24 bytes */
typedef struct {
	guint16 pe_magic;
	guchar  pe_major;
	guchar  pe_minor;
	guint32 pe_code_size;
	guint32 pe_data_size;
	guint32 pe_uninit_data_size;
	guint32 pe_rva_entry_point;
	guint32 pe_rva_code_base;
} MonoPEHeader64;

/* 68 bytes */
typedef struct {
	guint32 pe_image_base;		/* must be 0x400000 */
	guint32 pe_section_align;       /* must be 8192 */
	guint32 pe_file_alignment;      /* must be 512 or 4096 */
	guint16 pe_os_major;            /* must be 4 */
	guint16 pe_os_minor;            /* must be 0 */
	guint16 pe_user_major;
	guint16 pe_user_minor;
	guint16 pe_subsys_major;
	guint16 pe_subsys_minor;
	guint32 pe_reserved_1;
	guint32 pe_image_size;
	guint32 pe_header_size;
	guint32 pe_checksum;
	guint16 pe_subsys_required;
	guint16 pe_dll_flags;
	guint32 pe_stack_reserve;
	guint32 pe_stack_commit;
	guint32 pe_heap_reserve;
	guint32 pe_heap_commit;
	guint32 pe_loader_flags;
	guint32 pe_data_dir_count;
} MonoPEHeaderNT;

/* 88 bytes */
typedef struct {
	guint64 pe_image_base;
	guint32 pe_section_align;       /* must be 8192 */
	guint32 pe_file_alignment;      /* must be 512 or 4096 */
	guint16 pe_os_major;            /* must be 4 */
	guint16 pe_os_minor;            /* must be 0 */
	guint16 pe_user_major;
	guint16 pe_user_minor;
	guint16 pe_subsys_major;
	guint16 pe_subsys_minor;
	guint32 pe_reserved_1;
	guint32 pe_image_size;
	guint32 pe_header_size;
	guint32 pe_checksum;
	guint16 pe_subsys_required;
	guint16 pe_dll_flags;
	guint64 pe_stack_reserve;
	guint64 pe_stack_commit;
	guint64 pe_heap_reserve;
	guint64 pe_heap_commit;
	guint32 pe_loader_flags;
	guint32 pe_data_dir_count;
} MonoPEHeaderNT64;

typedef struct {
	guint32 rde_data_offset;
	guint32 rde_size;
	guint32 rde_codepage;
	guint32 rde_reserved;
} MonoPEResourceDataEntry;

#define MONO_PE_RESOURCE_ID_CURSOR	0x01
#define MONO_PE_RESOURCE_ID_BITMAP	0x02
#define MONO_PE_RESOURCE_ID_ICON	0x03
#define MONO_PE_RESOURCE_ID_MENU	0x04
#define MONO_PE_RESOURCE_ID_DIALOG	0x05
#define MONO_PE_RESOURCE_ID_STRING	0x06
#define MONO_PE_RESOURCE_ID_FONTDIR	0x07
#define MONO_PE_RESOURCE_ID_FONT	0x08
#define MONO_PE_RESOURCE_ID_ACCEL	0x09
#define MONO_PE_RESOURCE_ID_RCDATA	0x0a
#define MONO_PE_RESOURCE_ID_MESSAGETABLE	0x0b
#define MONO_PE_RESOURCE_ID_GROUP_CURSOR	0x0c
#define MONO_PE_RESOURCE_ID_GROUP_ICON	0x0d
#define MONO_PE_RESOURCE_ID_VERSION	0x10
#define MONO_PE_RESOURCE_ID_DLGINCLUDE	0x11
#define MONO_PE_RESOURCE_ID_PLUGPLAY	0x13
#define MONO_PE_RESOURCE_ID_VXD		0x14
#define MONO_PE_RESOURCE_ID_ANICURSOR	0x15
#define MONO_PE_RESOURCE_ID_ANIICON	0x16
#define MONO_PE_RESOURCE_ID_HTML	0x17
#define MONO_PE_RESOURCE_ID_ASPNET_STRING	0x65

typedef struct {
	/* If the MSB is set, then the other 31 bits store the RVA of
	 * the unicode string containing the name.  Otherwise, the
	 * other 31 bits contain the ID of this entry.
	 */
	guint32 name;

	/* If the MSB is set, then the other 31 bits store the RVA of
	 * another subdirectory.  Otherwise, the other 31 bits store
	 * the RVA of the resource data entry leaf node.
	 */
	guint32 dir;
} MonoPEResourceDirEntry;

#define MONO_PE_RES_DIR_ENTRY_NAME_IS_STRING(d)	(GUINT32_FROM_LE((d).name) >> 31)
#define MONO_PE_RES_DIR_ENTRY_NAME_OFFSET(d)	(GUINT32_FROM_LE((d).name) & 0x7fffffff)
#define MONO_PE_RES_DIR_ENTRY_SET_NAME(d,i,o)	((d).name = GUINT32_TO_LE(((guint32)((i)?1:0) << 31) | ((o) & 0x7fffffff)))

#define MONO_PE_RES_DIR_ENTRY_IS_DIR(d)		(GUINT32_FROM_LE((d).dir) >> 31)
#define MONO_PE_RES_DIR_ENTRY_DIR_OFFSET(d)	(GUINT32_FROM_LE((d).dir) & 0x7fffffff)
#define MONO_PE_RES_DIR_ENTRY_SET_DIR(d,i,o)	((d).dir = GUINT32_TO_LE(((guint32)((i)?1:0) << 31) | ((o) & 0x7fffffff)))

typedef struct 
{
	guint32 res_characteristics;
	guint32 res_date_stamp;
	guint16 res_major;
	guint16 res_minor;
	guint16 res_named_entries;
	guint16 res_id_entries;
	/* Directory entries follow on here.  The array is
	 * res_named_entries + res_id_entries long, containing all
	 * named entries first.
	 */
} MonoPEResourceDir;

typedef struct {
	guint32 rva;
	guint32 size;
} MonoPEDirEntry;

/* 128 bytes */
typedef struct {
	MonoPEDirEntry pe_export_table;
	MonoPEDirEntry pe_import_table;
	MonoPEDirEntry pe_resource_table;
	MonoPEDirEntry pe_exception_table;
	MonoPEDirEntry pe_certificate_table;
	MonoPEDirEntry pe_reloc_table;
	MonoPEDirEntry pe_debug;
	MonoPEDirEntry pe_copyright;
	MonoPEDirEntry pe_global_ptr;
	MonoPEDirEntry pe_tls_table;
	MonoPEDirEntry pe_load_config_table;
	MonoPEDirEntry pe_bound_import;
	MonoPEDirEntry pe_iat;
	MonoPEDirEntry pe_delay_import_desc;
	MonoPEDirEntry pe_cli_header;
	MonoPEDirEntry pe_reserved;
} MonoPEDatadir;

/* 248 bytes */
typedef struct {
	char            pesig [4];
	MonoCOFFHeader  coff;
	MonoPEHeader    pe;
	MonoPEHeaderNT  nt;
	MonoPEDatadir   datadir;
} MonoDotNetHeader32;

/* 248 bytes */
typedef struct {
	char            pesig [4];
	MonoCOFFHeader  coff;
	MonoPEHeader    pe;
	MonoPEHeaderNT  nt;
	MonoPEDatadir   datadir;
} MonoDotNetHeader;

/* XX248 bytes */
typedef struct {
	char              pesig [4];
	MonoCOFFHeader    coff;
	MonoPEHeader64    pe;
	MonoPEHeaderNT64  nt;
	MonoPEDatadir     datadir;
} MonoDotNetHeader64;

#define VTFIXUP_TYPE_32BIT                            0x01
#define VTFIXUP_TYPE_64BIT                            0x02
#define VTFIXUP_TYPE_FROM_UNMANAGED                   0x04
#define VTFIXUP_TYPE_FROM_UNMANAGED_RETAIN_APPDOMAIN  0x08
#define VTFIXUP_TYPE_CALL_MOST_DERIVED                0x10

typedef struct {
	guint32 rva;
	guint16 count;
	guint16 type;
} MonoVTableFixup;

typedef struct {
	char    st_name [8];
	guint32 st_virtual_size;
	guint32 st_virtual_address;
	guint32 st_raw_data_size;
	guint32 st_raw_data_ptr;
	guint32 st_reloc_ptr;
	guint32 st_lineno_ptr;
	guint16 st_reloc_count;
	guint16 st_line_count;

#define SECT_FLAGS_HAS_CODE               0x20
#define SECT_FLAGS_HAS_INITIALIZED_DATA   0x40
#define SECT_FLAGS_HAS_UNINITIALIZED_DATA 0x80
#define SECT_FLAGS_MEM_DISCARDABLE        0x02000000
#define SECT_FLAGS_MEM_NOT_CACHED         0x04000000
#define SECT_FLAGS_MEM_NOT_PAGED          0x08000000
#define SECT_FLAGS_MEM_SHARED             0x10000000
#define SECT_FLAGS_MEM_EXECUTE            0x20000000
#define SECT_FLAGS_MEM_READ               0x40000000
#define SECT_FLAGS_MEM_WRITE              0x80000000
	guint32 st_flags;

} MonoSectionTable;

typedef struct {
	guint32        ch_size;
	guint16        ch_runtime_major;
	guint16        ch_runtime_minor;
	MonoPEDirEntry ch_metadata;

#define CLI_FLAGS_ILONLY         0x01
#define CLI_FLAGS_32BITREQUIRED  0x02
#define CLI_FLAGS_STRONGNAMESIGNED 0x8
#define CLI_FLAGS_TRACKDEBUGDATA 0x00010000
#define CLI_FLAGS_PREFERRED32BIT 0x00020000
	guint32        ch_flags;

	guint32        ch_entry_point;
	MonoPEDirEntry ch_resources;
	MonoPEDirEntry ch_strong_name;
	MonoPEDirEntry ch_code_manager_table;
	MonoPEDirEntry ch_vtable_fixups;
	MonoPEDirEntry ch_export_address_table_jumps;

	/* The following are zero in the current docs */
	MonoPEDirEntry ch_eeinfo_table;
	MonoPEDirEntry ch_helper_table;
	MonoPEDirEntry ch_dynamic_info;
	MonoPEDirEntry ch_delay_load_info;
	MonoPEDirEntry ch_module_image;
	MonoPEDirEntry ch_external_fixups;
	MonoPEDirEntry ch_ridmap;
	MonoPEDirEntry ch_debug_map;
	MonoPEDirEntry ch_ip_map;
} MonoCLIHeader;

/* This is not an on-disk structure */
typedef struct {
	MonoDotNetHeader  cli_header;
	int               cli_section_count;
	MonoSectionTable  *cli_section_tables;
	void            **cli_sections;
	MonoCLIHeader     cli_cli_header;
} MonoCLIImageInfo;

MONO_API guint32       mono_cli_rva_image_map (MonoImage *image, guint32 rva);

#endif /* __MONO_CIL_COFF_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/class-abi-details.h`:

```h
/**
 * \file Declarations of MonoClass field offset functions
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_CLASS_ABI_DETAILS_H__
#define __MONO_METADATA_CLASS_ABI_DETAILS_H__

#include <mono/metadata/class-internals.h>
#include <mono/metadata/abi-details.h>

#define MONO_CLASS_GETTER(funcname, rettype, optref, argtype, fieldname) /*nothing*/
#ifdef MONO_CLASS_DEF_PRIVATE
#define MONO_CLASS_OFFSET(funcname, argtype, fieldname) intptr_t funcname (void);
#else
#define MONO_CLASS_OFFSET(funcname, argtype, fieldname) static inline intptr_t funcname (void) { return MONO_STRUCT_OFFSET (argtype, fieldname); }
#endif
#include "class-getters.h"
#undef MONO_CLASS_GETTER
#undef MONO_CLASS_OFFSET

#endif /* __MONO_METADATA_CLASS_ABI_DETAILS_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/class-getters.h`:

```h
/* 
 * \file Definitions of getters for the fields of struct _MonoClass
 *
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

/* No include guards - this file is meant to be included multiple times.
 * Before including the file define the following macros:
 * MONO_CLASS_GETTER(funcname, rettype, optref, argtype, fieldname)
 * 
 * MONO_CLASS_OFFSET(funcname, argtype, fieldname)
 */

/* Accessors for _MonoClass fields. */
MONO_CLASS_GETTER(m_class_get_element_class, MonoClass *,  , MonoClass, element_class)
MONO_CLASS_GETTER(m_class_get_cast_class, MonoClass *,  , MonoClass, cast_class)
MONO_CLASS_GETTER(m_class_get_supertypes, MonoClass **, , MonoClass, supertypes)
MONO_CLASS_GETTER(m_class_get_idepth, guint16,  , MonoClass, idepth)
MONO_CLASS_GETTER(m_class_get_rank, guint8,  , MonoClass, rank)
MONO_CLASS_GETTER(m_class_get_instance_size, int, , MonoClass, instance_size)
MONO_CLASS_GETTER(m_class_is_inited, gboolean, , MonoClass, inited)
MONO_CLASS_GETTER(m_class_is_size_inited, gboolean, , MonoClass, size_inited)
MONO_CLASS_GETTER(m_class_is_valuetype, gboolean, , MonoClass, valuetype)
MONO_CLASS_GETTER(m_class_is_enumtype, gboolean, , MonoClass, enumtype)
MONO_CLASS_GETTER(m_class_is_blittable, gboolean, , MonoClass, blittable)
MONO_CLASS_GETTER(m_class_is_unicode, gboolean, , MonoClass, unicode)
MONO_CLASS_GETTER(m_class_was_typebuilder, gboolean, , MonoClass, wastypebuilder)
MONO_CLASS_GETTER(m_class_is_array_special_interface, gboolean, , MonoClass, is_array_special_interface)
MONO_CLASS_GETTER(m_class_is_byreflike, gboolean, , MonoClass, is_byreflike)
MONO_CLASS_GETTER(m_class_get_min_align, guint8, , MonoClass, min_align)
MONO_CLASS_GETTER(m_class_get_packing_size, guint, , MonoClass, packing_size)
MONO_CLASS_GETTER(m_class_is_ghcimpl, gboolean, , MonoClass, ghcimpl)
MONO_CLASS_GETTER(m_class_has_finalize, gboolean, , MonoClass, has_finalize)
#ifndef DISABLE_REMOTING
MONO_CLASS_GETTER(m_class_get_marshalbyref, guint, , MonoClass, marshalbyref)
MONO_CLASS_GETTER(m_class_get_contextbound, guint, , MonoClass, contextbound)
#endif
MONO_CLASS_GETTER(m_class_is_delegate, gboolean, , MonoClass, delegate)
MONO_CLASS_GETTER(m_class_is_gc_descr_inited, gboolean, , MonoClass, gc_descr_inited)
MONO_CLASS_GETTER(m_class_has_cctor, gboolean,  , MonoClass, has_cctor)
MONO_CLASS_GETTER(m_class_has_references, gboolean, , MonoClass, has_references)
MONO_CLASS_GETTER(m_class_has_static_refs, gboolean, , MonoClass, has_static_refs)
MONO_CLASS_GETTER(m_class_has_no_special_static_fields, gboolean, , MonoClass, no_special_static_fields)
MONO_CLASS_GETTER(m_class_is_com_object, gboolean, , MonoClass, is_com_object)
MONO_CLASS_GETTER(m_class_is_nested_classes_inited, gboolean, , MonoClass, nested_classes_inited)
MONO_CLASS_GETTER(m_class_get_class_kind, guint8, , MonoClass, class_kind)
MONO_CLASS_GETTER(m_class_is_interfaces_inited, gboolean, , MonoClass, interfaces_inited)
MONO_CLASS_GETTER(m_class_is_simd_type, gboolean, , MonoClass, simd_type)
MONO_CLASS_GETTER(m_class_is_has_finalize_inited, gboolean, , MonoClass, has_finalize_inited)
MONO_CLASS_GETTER(m_class_is_fields_inited, gboolean, , MonoClass, fields_inited)
MONO_CLASS_GETTER(m_class_has_failure, gboolean, , MonoClass, has_failure)
MONO_CLASS_GETTER(m_class_has_weak_fields, gboolean, , MonoClass, has_weak_fields)
MONO_CLASS_GETTER(m_class_has_dim_conflicts, gboolean, , MonoClass, has_dim_conflicts)
MONO_CLASS_GETTER(m_class_get_parent, MonoClass *, , MonoClass, parent)
MONO_CLASS_GETTER(m_class_get_nested_in, MonoClass *, ,  MonoClass, nested_in)
MONO_CLASS_GETTER(m_class_get_image, MonoImage *, , MonoClass, image)
MONO_CLASS_GETTER(m_class_get_name, const char *, , MonoClass, name)
MONO_CLASS_GETTER(m_class_get_name_space, const char *, , MonoClass, name_space)
MONO_CLASS_GETTER(m_class_get_type_token, guint32, , MonoClass, type_token)
MONO_CLASS_GETTER(m_class_get_vtable_size, int, , MonoClass, vtable_size)
MONO_CLASS_GETTER(m_class_get_interface_count, guint16, , MonoClass, interface_count)
MONO_CLASS_GETTER(m_class_get_interface_id, guint32, , MonoClass, interface_id)
MONO_CLASS_GETTER(m_class_get_max_interface_id, guint32, , MonoClass, max_interface_id)
MONO_CLASS_GETTER(m_class_get_interface_offsets_count, guint16, , MonoClass, interface_offsets_count)
MONO_CLASS_GETTER(m_class_get_interfaces_packed, MonoClass **, , MonoClass, interfaces_packed)
MONO_CLASS_GETTER(m_class_get_interface_offsets_packed, guint16 *, , MonoClass, interface_offsets_packed)
MONO_CLASS_GETTER(m_class_get_interface_bitmap, guint8 *, , MonoClass, interface_bitmap)
MONO_CLASS_GETTER(m_class_get_interfaces, MonoClass **, , MonoClass, interfaces)
MONO_CLASS_GETTER(m_class_get_sizes, union _MonoClassSizes, , MonoClass, sizes)
MONO_CLASS_GETTER(m_class_get_fields, MonoClassField *, , MonoClass, fields)
MONO_CLASS_GETTER(m_class_get_methods, MonoMethod **, ,  MonoClass, methods)
MONO_CLASS_GETTER(m_class_get_this_arg, MonoType*, &, MonoClass, this_arg)
MONO_CLASS_GETTER(m_class_get_byval_arg, MonoType*, &, MonoClass, _byval_arg)
MONO_CLASS_GETTER(m_class_get_gc_descr, MonoGCDescriptor, , MonoClass, gc_descr)
MONO_CLASS_GETTER(m_class_get_runtime_info, MonoClassRuntimeInfo *, , MonoClass, runtime_info)
MONO_CLASS_GETTER(m_class_get_vtable, MonoMethod **, , MonoClass, vtable)
MONO_CLASS_GETTER(m_class_get_infrequent_data, MonoPropertyBag*, &, MonoClass, infrequent_data)

/* Accessors for _MonoClassDef fields. */
MONO_CLASS_GETTER(m_classdef_get_klass, MonoClass*, &, MonoClassDef, klass)
MONO_CLASS_GETTER(m_classdef_get_flags, guint32, , MonoClassDef, flags)
MONO_CLASS_GETTER(m_classdef_get_first_method_idx, guint32, ,  MonoClassDef, first_method_idx)
MONO_CLASS_GETTER(m_classdef_get_first_field_idx, guint32, , MonoClassDef, first_field_idx)
MONO_CLASS_GETTER(m_classdef_get_method_count, guint32, ,  MonoClassDef, method_count)
MONO_CLASS_GETTER(m_classdef_get_field_count, guint32, ,  MonoClassDef, field_count)
MONO_CLASS_GETTER(m_classdef_get_next_class_cache, MonoClass **, &, MonoClassDef, next_class_cache)

/* Accessors for _MonoClassGtd fields. */
MONO_CLASS_GETTER(m_classgtd_get_klass, MonoClassDef*, &, MonoClassGtd, klass)
MONO_CLASS_GETTER(m_classgtd_get_generic_container, MonoGenericContainer*, , MonoClassGtd, generic_container)
MONO_CLASS_GETTER(m_classgtd_get_canonical_inst, MonoType*, &, MonoClassGtd, canonical_inst)

/* Accessors for _MonoClassGenericInst fields. */
MONO_CLASS_GETTER(m_classgenericinst_get_klass, MonoClass*, &, MonoClassGenericInst, klass)
MONO_CLASS_GETTER(m_classgenericinst_get_generic_class, MonoGenericClass*, , MonoClassGenericInst, generic_class)

/* Accessors for _MonoClassGenericParam fields. */
MONO_CLASS_GETTER(m_classgenericparam_get_klass, MonoClass*, &, MonoClassGenericParam, klass)

/* Accessors for _MonoClassArray fields. */
MONO_CLASS_GETTER(m_classarray_get_klass, MonoClass*, &, MonoClassArray, klass)
MONO_CLASS_GETTER(m_classarray_get_method_count, guint32, , MonoClassArray, method_count)

/* Accessors for _MonoClassPointer fields. */
MONO_CLASS_GETTER(m_classpointer_get_klass, MonoClass*, &, MonoClassPointer, klass)

MONO_CLASS_OFFSET(m_class_offsetof_interface_bitmap, MonoClass, interface_bitmap)
MONO_CLASS_OFFSET(m_class_offsetof_byval_arg, MonoClass, _byval_arg)
MONO_CLASS_OFFSET(m_class_offsetof_cast_class, MonoClass, cast_class)
MONO_CLASS_OFFSET(m_class_offsetof_element_class, MonoClass, element_class)
MONO_CLASS_OFFSET(m_class_offsetof_idepth, MonoClass, idepth)
MONO_CLASS_OFFSET(m_class_offsetof_instance_size, MonoClass, instance_size)
MONO_CLASS_OFFSET(m_class_offsetof_interface_id, MonoClass, interface_id)
MONO_CLASS_OFFSET(m_class_offsetof_max_interface_id, MonoClass, max_interface_id)
MONO_CLASS_OFFSET(m_class_offsetof_parent, MonoClass, parent)
MONO_CLASS_OFFSET(m_class_offsetof_rank, MonoClass, rank)
MONO_CLASS_OFFSET(m_class_offsetof_sizes, MonoClass, sizes)
MONO_CLASS_OFFSET(m_class_offsetof_supertypes, MonoClass, supertypes)
MONO_CLASS_OFFSET(m_class_offsetof_class_kind, MonoClass, class_kind)

```

`Hazel/vendor/mono/include/mono/metadata/class-init.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_CLASS_INIT_H__
#define __MONO_METADATA_CLASS_INIT_H__

#include <glib.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/class-internals.h>

gboolean
mono_class_init_internal (MonoClass *klass);

void
mono_classes_init (void);

void
mono_classes_cleanup (void);

MonoClass *
mono_class_create_from_typedef (MonoImage *image, guint32 type_token, MonoError *error);

MonoClass*
mono_class_create_generic_inst (MonoGenericClass *gclass);

MonoClass *
mono_class_create_bounded_array (MonoClass *element_class, uint32_t rank, mono_bool bounded);

MonoClass *
mono_class_create_array (MonoClass *element_class, uint32_t rank);

MonoClass *
mono_class_create_generic_parameter (MonoGenericParam *param);

MonoClass *
mono_class_create_ptr (MonoType *type);

MonoClass *
mono_class_create_fnptr (MonoMethodSignature *sig);

void
mono_class_setup_vtable_general (MonoClass *klass, MonoMethod **overrides, int onum, GList *in_setup);

void
mono_class_init_sizes (MonoClass *klass);

void
mono_class_setup_basic_field_info (MonoClass *klass);

void
mono_class_setup_fields (MonoClass *klass);

void
mono_class_setup_methods (MonoClass *klass);

void
mono_class_setup_properties (MonoClass *klass);

void
mono_class_setup_events (MonoClass *klass);

void
mono_class_layout_fields (MonoClass *klass, int base_instance_size, int packing_size, int real_size, gboolean sre);

void
mono_class_setup_interface_offsets (MonoClass *klass);

void
mono_class_setup_vtable (MonoClass *klass);

void
mono_class_setup_parent    (MonoClass *klass, MonoClass *parent);

void
mono_class_setup_mono_type (MonoClass *klass);

void
mono_class_setup_has_finalizer (MonoClass *klass);

void
mono_class_setup_nested_types (MonoClass *klass);

void
mono_class_setup_runtime_info (MonoClass *klass, MonoDomain *domain, MonoVTable *vtable);

MonoClass *
mono_class_create_array_fill_type (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/class-inlines.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_CLASS_INLINES_H__
#define __MONO_METADATA_CLASS_INLINES_H__

#include <mono/metadata/class-internals.h>
#include <mono/metadata/tabledefs.h>

static inline MonoType*
mono_get_void_type (void)
{
	return m_class_get_byval_arg (mono_defaults.void_class);
}

static inline MonoType*
mono_get_int32_type (void)
{
	return m_class_get_byval_arg (mono_defaults.int32_class);
}

static inline MonoType*
mono_get_int_type (void)
{
	return m_class_get_byval_arg (mono_defaults.int_class);
}

static inline MonoType*
mono_get_object_type (void)
{
	return m_class_get_byval_arg (mono_defaults.object_class);
}


static inline gboolean
mono_class_is_def (MonoClass *klass)
{
	return m_class_get_class_kind (klass) == MONO_CLASS_DEF;
}

static inline gboolean
mono_class_is_gtd (MonoClass *klass)
{
	return m_class_get_class_kind (klass) == MONO_CLASS_GTD;
}

static inline gboolean
mono_class_is_ginst (MonoClass *klass)
{
	return m_class_get_class_kind (klass) == MONO_CLASS_GINST;
}

static inline gboolean
mono_class_is_gparam (MonoClass *klass)
{
	return m_class_get_class_kind (klass) == MONO_CLASS_GPARAM;
}

static inline gboolean
mono_class_is_array (MonoClass *klass)
{
	return m_class_get_class_kind (klass) == MONO_CLASS_ARRAY;
}

static inline gboolean
mono_class_is_pointer (MonoClass *klass)
{
	return m_class_get_class_kind (klass) == MONO_CLASS_POINTER;
}

static inline gboolean
mono_class_is_abstract (MonoClass *klass)
{
	return mono_class_get_flags (klass) & TYPE_ATTRIBUTE_ABSTRACT;
}

static inline gboolean
mono_class_is_interface (MonoClass *klass)
{
	return mono_class_get_flags (klass) & TYPE_ATTRIBUTE_INTERFACE;
}

static inline gboolean
mono_class_is_sealed (MonoClass *klass)
{
	return mono_class_get_flags (klass) & TYPE_ATTRIBUTE_SEALED;
}

static inline gboolean
mono_class_is_before_field_init (MonoClass *klass)
{
	return mono_class_get_flags (klass) & TYPE_ATTRIBUTE_BEFORE_FIELD_INIT;
}

static inline gboolean
mono_class_is_auto_layout (MonoClass *klass)
{
	return (mono_class_get_flags (klass) & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_AUTO_LAYOUT;
}

static inline gboolean
mono_class_is_explicit_layout (MonoClass *klass)
{
	return (mono_class_get_flags (klass) & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT;
}

static inline gboolean
mono_class_is_public (MonoClass *klass)
{
	return mono_class_get_flags (klass) & TYPE_ATTRIBUTE_PUBLIC;
}

static inline gboolean
mono_class_has_static_metadata (MonoClass *klass)
{
	return m_class_get_type_token (klass) && !m_class_get_image (klass)->dynamic && !mono_class_is_ginst (klass);
}

static inline gboolean
m_class_is_abstract (MonoClass *klass)
{
	return (mono_class_get_flags (klass) & TYPE_ATTRIBUTE_ABSTRACT) != 0;
}

static inline gboolean
m_class_is_interface (MonoClass *klass)
{
	return MONO_CLASS_IS_INTERFACE_INTERNAL (klass);
}

static inline gboolean
m_class_is_gtd (MonoClass *klass)
{
	return mono_class_is_gtd (klass);
}

static inline gboolean
m_class_is_string (MonoClass *klass)
{
	return klass == mono_defaults.string_class;
}

static inline gboolean
m_class_is_primitive (MonoClass *klass)
{
	return mono_type_is_primitive (m_class_get_byval_arg (klass));
}

static inline gboolean
m_class_is_native_pointer (MonoClass *klass)
{
	MonoType *t = m_class_get_byval_arg (klass);

	return t->type == MONO_TYPE_PTR || t->type == MONO_TYPE_FNPTR;
}

static inline gboolean
m_class_is_nullable (MonoClass *klass)
{
	return mono_class_is_nullable (klass);
}

static inline MonoClass*
m_class_get_nullable_elem_class (MonoClass *klass)
{
	return m_class_get_cast_class (klass);
}

static inline gboolean
m_class_is_runtime_type (MonoClass *klass)
{
	return klass == mono_defaults.runtimetype_class;
}

static inline gboolean
m_class_is_auto_layout (MonoClass *klass)
{
	guint32 layout = (mono_class_get_flags (klass) & TYPE_ATTRIBUTE_LAYOUT_MASK);

	return layout == TYPE_ATTRIBUTE_AUTO_LAYOUT;
}

static inline gboolean
m_class_is_ginst (MonoClass *klass)
{
	return mono_class_is_ginst (klass);
}

#endif

```

`Hazel/vendor/mono/include/mono/metadata/class-internals.h`:

```h
/**
 * \file
 * Copyright 2012 Xamarin Inc
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_CLASS_INTERNALS_H__
#define __MONO_METADATA_CLASS_INTERNALS_H__

#include <mono/metadata/class.h>
#include <mono/metadata/object.h>
#include <mono/metadata/mempool.h>
#include <mono/metadata/metadata-internals.h>
#include <mono/metadata/property-bag.h>
#include "mono/utils/mono-compiler.h"
#include "mono/utils/mono-error.h"
#include "mono/sgen/gc-internal-agnostic.h"
#include "mono/utils/mono-error-internals.h"
#include "mono/utils/mono-memory-model.h"

#define MONO_CLASS_IS_ARRAY(c) (m_class_get_rank (c))

#define MONO_CLASS_HAS_STATIC_METADATA(klass) (m_class_get_type_token (klass) && !m_class_get_image (klass)->dynamic && !mono_class_is_ginst (klass))

#define MONO_DEFAULT_SUPERTABLE_SIZE 6

extern gboolean mono_print_vtable;
extern gboolean mono_align_small_structs;
extern gint32 mono_simd_register_size;

typedef struct _MonoMethodWrapper MonoMethodWrapper;
typedef struct _MonoMethodInflated MonoMethodInflated;
typedef struct _MonoMethodPInvoke MonoMethodPInvoke;
typedef struct _MonoDynamicMethod MonoDynamicMethod;

/* Properties that applies to a group of structs should better use a higher number
 * to avoid colision with type specific properties.
 * 
 * This prop applies to class, method, property, event, assembly and image.
 */
#define MONO_PROP_DYNAMIC_CATTR 0x1000

typedef enum {
#define WRAPPER(e,n) MONO_WRAPPER_ ## e,
#include "wrapper-types.h"
#undef WRAPPER
	MONO_WRAPPER_NUM
} MonoWrapperType;

typedef enum {
	MONO_REMOTING_TARGET_UNKNOWN,
	MONO_REMOTING_TARGET_APPDOMAIN,
	MONO_REMOTING_TARGET_COMINTEROP
} MonoRemotingTarget;

#define MONO_METHOD_PROP_GENERIC_CONTAINER 0

struct _MonoMethod {
	guint16 flags;  /* method flags */
	guint16 iflags; /* method implementation flags */
	guint32 token;
	MonoClass *klass; /* To what class does this method belong */
	MonoMethodSignature *signature;
	/* name is useful mostly for debugging */
	const char *name;
	/* this is used by the inlining algorithm */
	unsigned int inline_info:1;
	unsigned int inline_failure:1;
	unsigned int wrapper_type:5;
	unsigned int string_ctor:1;
	unsigned int save_lmf:1;
	unsigned int dynamic:1; /* created & destroyed during runtime */
	unsigned int sre_method:1; /* created at runtime using Reflection.Emit */
	unsigned int is_generic:1; /* whenever this is a generic method definition */
	unsigned int is_inflated:1; /* whether we're a MonoMethodInflated */
	unsigned int skip_visibility:1; /* whenever to skip JIT visibility checks */
	unsigned int verification_success:1; /* whether this method has been verified successfully.*/
	unsigned int is_reabstracted:1; /* whenever this is a reabstraction of another interface */
	signed int slot : 16;

	/*
	 * If is_generic is TRUE, the generic_container is stored in image->property_hash, 
	 * using the key MONO_METHOD_PROP_GENERIC_CONTAINER.
	 */
};

struct _MonoMethodWrapper {
	MonoMethod method;
	MonoMethodHeader *header;
	void *method_data;
};

struct _MonoDynamicMethod {
	MonoMethodWrapper method;
	MonoAssembly *assembly;
};

struct _MonoMethodPInvoke {
	MonoMethod method;
	gpointer addr;
	/* add marshal info */
	guint16 piflags;  /* pinvoke flags */
	guint32 implmap_idx;  /* index into IMPLMAP */
};

/* 
 * Stores the default value / RVA of fields.
 * This information is rarely needed, so it is stored separately from 
 * MonoClassField.
 */
typedef struct MonoFieldDefaultValue {
	/*
	 * If the field is constant, pointer to the metadata constant
	 * value.
	 * If the field has an RVA flag, pointer to the data.
	 * Else, invalid.
	 */
	const char      *data;

	/* If the field is constant, the type of the constant. */
	MonoTypeEnum     def_type;
} MonoFieldDefaultValue;

/*
 * MonoClassField is just a runtime representation of the metadata for
 * field, it doesn't contain the data directly.  Static fields are
 * stored in MonoVTable->data.  Instance fields are allocated in the
 * objects after the object header.
 */
struct _MonoClassField {
	/* Type of the field */
	MonoType        *type;

	const char      *name;

	/* Type where the field was defined */
	MonoClass       *parent;

	/*
	 * Offset where this field is stored; if it is an instance
	 * field, it's the offset from the start of the object, if
	 * it's static, it's from the start of the memory chunk
	 * allocated for statics for the class.
	 * For special static fields, this is set to -1 during vtable construction.
	 */
	int              offset;
};

/* a field is ignored if it's named "_Deleted" and it has the specialname and rtspecialname flags set */
#define mono_field_is_deleted(field) (((field)->type->attrs & (FIELD_ATTRIBUTE_SPECIAL_NAME | FIELD_ATTRIBUTE_RT_SPECIAL_NAME)) \
				      && (strcmp (mono_field_get_name (field), "_Deleted") == 0))

/* a field is ignored if it's named "_Deleted" and it has the specialname and rtspecialname flags set */
/* Try to avoid loading the field's type */
#define mono_field_is_deleted_with_flags(field, flags) (((flags) & (FIELD_ATTRIBUTE_SPECIAL_NAME | FIELD_ATTRIBUTE_RT_SPECIAL_NAME)) \
				      && (strcmp (mono_field_get_name (field), "_Deleted") == 0))

typedef struct {
	MonoClassField *field;
	guint32 offset;
	MonoMarshalSpec *mspec;
} MonoMarshalField;

typedef struct {
	MonoPropertyBagItem head;

	guint32 native_size, min_align;
	guint32 num_fields;
	MonoMethod *ptr_to_str;
	MonoMethod *str_to_ptr;
	MonoMarshalField fields [MONO_ZERO_LEN_ARRAY];
} MonoMarshalType;

#define MONO_SIZEOF_MARSHAL_TYPE (offsetof (MonoMarshalType, fields))

struct _MonoProperty {
	MonoClass *parent;
	const char *name;
	MonoMethod *get;
	MonoMethod *set;
	guint32 attrs;
};

struct _MonoEvent {
	MonoClass *parent;
	const char *name;
	MonoMethod *add;
	MonoMethod *remove;
	MonoMethod *raise;
#ifndef MONO_SMALL_CONFIG
	MonoMethod **other;
#endif
	guint32 attrs;
};

/* type of exception being "on hold" for later processing (see exception_type) */
typedef enum {
	MONO_EXCEPTION_NONE = 0,
	MONO_EXCEPTION_INVALID_PROGRAM = 3,
	MONO_EXCEPTION_UNVERIFIABLE_IL = 4,
	MONO_EXCEPTION_MISSING_METHOD = 5,
	MONO_EXCEPTION_MISSING_FIELD = 6,
	MONO_EXCEPTION_TYPE_LOAD = 7,
	MONO_EXCEPTION_FILE_NOT_FOUND = 8,
	MONO_EXCEPTION_METHOD_ACCESS = 9,
	MONO_EXCEPTION_FIELD_ACCESS = 10,
	MONO_EXCEPTION_GENERIC_SHARING_FAILED = 11,
	MONO_EXCEPTION_BAD_IMAGE = 12,
	MONO_EXCEPTION_OBJECT_SUPPLIED = 13, /*The exception object is already created.*/
	MONO_EXCEPTION_OUT_OF_MEMORY = 14,
	MONO_EXCEPTION_INLINE_FAILED = 15,
	MONO_EXCEPTION_MONO_ERROR = 16,
	/* add other exception type */
} MonoExceptionType;

/* This struct collects the info needed for the runtime use of a class,
 * like the vtables for a domain, the GC descriptor, etc.
 */
typedef struct {
	guint16 max_domain;
	/* domain_vtables is indexed by the domain id and the size is max_domain + 1 */
	MonoVTable *domain_vtables [MONO_ZERO_LEN_ARRAY];
} MonoClassRuntimeInfo;

#define MONO_SIZEOF_CLASS_RUNTIME_INFO (sizeof (MonoClassRuntimeInfo) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)

typedef struct {
	MonoPropertyBagItem head;

	MonoProperty *properties;
	guint32 first, count;
	MonoFieldDefaultValue *def_values;
} MonoClassPropertyInfo;

typedef struct {
	MonoPropertyBagItem head;

	/* Initialized by a call to mono_class_setup_events () */
	MonoEvent *events;
	guint32 first, count;
} MonoClassEventInfo;

typedef enum {
	MONO_CLASS_DEF = 1, /* non-generic type */
	MONO_CLASS_GTD, /* generic type definition */
	MONO_CLASS_GINST, /* generic instantiation */
	MONO_CLASS_GPARAM, /* generic parameter */
	MONO_CLASS_ARRAY, /* vector or array, bounded or not */
	MONO_CLASS_POINTER, /* pointer or function pointer*/
} MonoTypeKind;

typedef struct _MonoClassDef MonoClassDef;
typedef struct _MonoClassGtd MonoClassGtd;
typedef struct _MonoClassGenericInst MonoClassGenericInst;
typedef struct _MonoClassGenericParam MonoClassGenericParam;
typedef struct _MonoClassArray MonoClassArray;
typedef struct _MonoClassPointer MonoClassPointer;

union _MonoClassSizes {
		int class_size; /* size of area for static fields */
		int element_size; /* for array types */
		int generic_param_token; /* for generic param types, both var and mvar */
};

/* enabled only with small config for now: we might want to do it unconditionally */
#ifdef MONO_SMALL_CONFIG
#define COMPRESSED_INTERFACE_BITMAP 1
#endif


#ifdef ENABLE_CHECKED_BUILD_PRIVATE_TYPES
#define MONO_CLASS_DEF_PRIVATE 1
#endif

/* Hide _MonoClass definition in checked build mode to ensure that
 * it is only accessed via getter and setter methods.
 */
#ifndef MONO_CLASS_DEF_PRIVATE
#include "class-private-definition.h"
#endif

/* If MonoClass definition is hidden, just declare the getters.
 * Otherwise, define them as static inline functions.
 */
#ifdef MONO_CLASS_DEF_PRIVATE
#define MONO_CLASS_GETTER(funcname, rettype, optref, argtype, fieldname) rettype funcname (argtype *klass);
#else
#define MONO_CLASS_GETTER(funcname, rettype, optref, argtype, fieldname) static inline rettype funcname (argtype *klass) { return optref klass-> fieldname ; }
#endif
#define MONO_CLASS_OFFSET(funcname, argtype, fieldname) /*nothing*/
#include "class-getters.h"
#undef MONO_CLASS_GETTER
#undef MONO_CLASS_OFFSET

#ifdef COMPRESSED_INTERFACE_BITMAP
int mono_compress_bitmap (uint8_t *dest, const uint8_t *bitmap, int size);
int mono_class_interface_match (const uint8_t *bitmap, int id);
#else
#define mono_class_interface_match(bmap,uiid) ((bmap) [(uiid) >> 3] & (1 << ((uiid)&7)))
#endif

#define MONO_CLASS_IMPLEMENTS_INTERFACE(k,uiid) (((uiid) <= m_class_get_max_interface_id (k)) && mono_class_interface_match (m_class_get_interface_bitmap (k), (uiid)))

#define MONO_VTABLE_AVAILABLE_GC_BITS 4

#ifdef DISABLE_REMOTING
#define mono_class_is_marshalbyref(klass) (FALSE)
#define mono_class_is_contextbound(klass) (FALSE)
#define mono_vtable_is_remote(vtable) (FALSE)
#define mono_vtable_set_is_remote(vtable,enable) do {} while (0)
#else
#define mono_class_is_marshalbyref(klass) (m_class_get_marshalbyref (klass))
#define mono_class_is_contextbound(klass) (m_class_get_contextbound (klass))
#define mono_vtable_is_remote(vtable) ((vtable)->remote)
#define mono_vtable_set_is_remote(vtable,enable) do { (vtable)->remote = enable ? 1 : 0; } while (0)
#endif

#ifdef DISABLE_COM
#define mono_class_is_com_object(klass) (FALSE)
#else
#define mono_class_is_com_object(klass) (m_class_is_com_object (klass))
#endif


MONO_API int mono_class_interface_offset (MonoClass *klass, MonoClass *itf);
int mono_class_interface_offset_with_variance (MonoClass *klass, MonoClass *itf, gboolean *non_exact_match);

typedef gpointer MonoRuntimeGenericContext;

typedef enum {
	/* array or string */
	MONO_VT_FLAG_ARRAY_OR_STRING = (1 << 0),
	MONO_VT_FLAG_HAS_REFERENCES = (1 << 1),
	MONO_VT_FLAG_ARRAY_IS_PRIMITIVE = (1 << 2),
} MonoVTableFlags;

/* the interface_offsets array is stored in memory before this struct */
struct MonoVTable {
	MonoClass  *klass;
	 /*
	 * According to comments in gc_gcj.h, this should be the second word in
	 * the vtable.
	 */
	MonoGCDescriptor gc_descr;
	MonoDomain *domain;  /* each object/vtable belongs to exactly one domain */
	gpointer    type; /* System.Type type for klass */
	guint8     *interface_bitmap;
	guint32     max_interface_id;
	guint8      rank;
	/* Keep this a guint8, the jit depends on it */
	guint8      initialized; /* cctor has been run */
	/* Keep this a guint8, the jit depends on it */
	guint8      flags; /* MonoVTableFlags */
	guint remote          : 1; /* class is remotely activated */
	guint init_failed     : 1; /* cctor execution failed */
	guint has_static_fields : 1; /* pointer to the data stored at the end of the vtable array */
	guint gc_bits         : MONO_VTABLE_AVAILABLE_GC_BITS; /* Those bits are reserved for the usaged of the GC */

	guint32     imt_collisions_bitmap;
	MonoRuntimeGenericContext *runtime_generic_context;
	/* interp virtual method table */
	gpointer *interp_vtable;
	/* do not add any fields after vtable, the structure is dynamically extended */
	/* vtable contains function pointers to methods or their trampolines, at the
	 end there may be a slot containing the pointer to the static fields */
	gpointer    vtable [MONO_ZERO_LEN_ARRAY];	
};

#define MONO_SIZEOF_VTABLE (sizeof (MonoVTable) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)

#define MONO_VTABLE_IMPLEMENTS_INTERFACE(vt,uiid) (((uiid) <= (vt)->max_interface_id) && mono_class_interface_match ((vt)->interface_bitmap, (uiid)))

/*
 * Generic instantiation data type encoding.
 */

/*
 * A particular generic instantiation:
 *
 * All instantiations are cached and we don't distinguish between class and method
 * instantiations here.
 */
struct _MonoGenericInst {
#ifndef MONO_SMALL_CONFIG
	gint32 id;			/* unique ID for debugging */
#endif
	guint type_argc    : 22;	/* number of type arguments */
	guint is_open      :  1;	/* if this is an open type */
	MonoType *type_argv [MONO_ZERO_LEN_ARRAY];
};

#define MONO_SIZEOF_GENERIC_INST (sizeof (MonoGenericInst) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)
/*
 * The generic context: an instantiation of a set of class and method generic parameters.
 *
 * NOTE: Never allocate this directly on the heap.  It have to be either allocated on the stack,
 *	 or embedded within other objects.  Don't store pointers to this, because it may be on the stack.
 *	 If you really have to, ensure you store a pointer to the embedding object along with it.
 */
struct _MonoGenericContext {
	/* The instantiation corresponding to the class generic parameters */
	MonoGenericInst *class_inst;
	/* The instantiation corresponding to the method generic parameters */
	MonoGenericInst *method_inst;
};

/*
 * Inflated generic method.
 */
struct _MonoMethodInflated {
	union {
		MonoMethod method;
		MonoMethodPInvoke pinvoke;
	} method;
	MonoMethod *declaring;		/* the generic method definition. */
	MonoGenericContext context;	/* The current instantiation */
	MonoImageSet *owner; /* The image set that the inflated method belongs to. */
};

/*
 * A particular instantiation of a generic type.
 */
struct _MonoGenericClass {
	MonoClass *container_class;	/* the generic type definition */
	MonoGenericContext context;	/* a context that contains the type instantiation doesn't contain any method instantiation */ /* FIXME: Only the class_inst member of "context" is ever used, so this field could be replaced with just a monogenericinst */
	guint is_dynamic  : 1;		/* Contains dynamic types */
	guint is_tb_open  : 1;		/* This is the fully open instantiation for a type_builder. Quite ugly, but it's temporary.*/
	guint need_sync   : 1;      /* Only if dynamic. Need to be synchronized with its container class after its finished. */
	MonoClass *cached_class;	/* if present, the MonoClass corresponding to the instantiation.  */

	/* 
	 * The image set which owns this generic class. Memory owned by the generic class
	 * including cached_class should be allocated from the mempool of the image set,
	 * so it is easy to free.
	 */
	MonoImageSet *owner;
};

/* Additional details about a MonoGenericParam */
/* Keep in sync with managed Mono.RuntimeStructs.GenericParamInfo */
typedef struct {
	MonoClass *pklass;		/* The corresponding `MonoClass'. */
	const char *name;

	// See GenericParameterAttributes
	guint16 flags;

	guint32 token;

	// Constraints on type parameters
	MonoClass** constraints; /* NULL means end of list */
} MonoGenericParamInfo;

/*
 * A type parameter.
 */
struct _MonoGenericParam {
	/*
	 * Type or method this parameter was defined in.
	 */
	MonoGenericContainer *owner;
	guint16 num;
	/*
	 * If != NULL, this is a generated generic param used by the JIT to implement generic
	 * sharing.
	 */
	MonoType *gshared_constraint;

	MonoGenericParamInfo info;
};

typedef MonoGenericParam MonoGenericParamFull;

/*
 * The generic container.
 *
 * Stores the type parameters of a generic type definition or a generic method definition.
 */
struct _MonoGenericContainer {
	MonoGenericContext context;
	/* If we're a generic method definition in a generic type definition,
	   the generic container of the containing class. */
	MonoGenericContainer *parent;
	/* the generic type definition or the generic method definition corresponding to this container */
	/* Union rules: If is_anonymous, image field is valid; else if is_method, method field is valid; else klass is valid. */
	union {
		MonoClass *klass;
		MonoMethod *method;
		MonoImage *image;
	} owner;
	int type_argc    : 29; // Per the ECMA spec, this value is capped at 16 bits
	/* If true, we're a generic method, otherwise a generic type definition. */
	/* Invariant: parent != NULL => is_method */
	int is_method     : 1;
	/* If true, this container has no associated class/method and only the image is known. This can happen:
	   1. For the special anonymous containers kept by MonoImage.
	   2. When user code creates a generic parameter via SRE, but has not yet set an owner. */
	int is_anonymous : 1;
	/* Our type parameters. If this is a special anonymous container (case 1, above), this field is not valid, use mono_metadata_create_anon_gparam ()  */
	MonoGenericParamFull *type_params;
};

static inline MonoGenericParam *
mono_generic_container_get_param (MonoGenericContainer *gc, int i)
{
	return (MonoGenericParam *) &gc->type_params [i];
}

static inline MonoGenericParamInfo *
mono_generic_container_get_param_info (MonoGenericContainer *gc, int i)
{
	return &gc->type_params [i].info;
}

static inline MonoGenericContainer *
mono_generic_param_owner (MonoGenericParam *p)
{
	return p->owner;
}

static inline int
mono_generic_param_num (MonoGenericParam *p)
{
	return p->num;
}

static inline MonoGenericParamInfo *
mono_generic_param_info (MonoGenericParam *p)
{
	return &((MonoGenericParamFull *) p)->info;
}

static inline const char *
mono_generic_param_name (MonoGenericParam *p)
{
	return ((MonoGenericParamFull *) p)->info.name;
}

static inline MonoGenericContainer *
mono_type_get_generic_param_owner (MonoType *t)
{
	return mono_generic_param_owner (t->data.generic_param);
}

static inline int
mono_type_get_generic_param_num (MonoType *t)
{
	return mono_generic_param_num (t->data.generic_param);
}

/*
 * Class information which might be cached by the runtime in the AOT file for
 * example. Caching this allows us to avoid computing a generic vtable
 * (class->vtable) in most cases, saving time and avoiding creation of lots of
 * MonoMethod structures.
 */
typedef struct MonoCachedClassInfo {
	guint32 vtable_size;
	guint has_finalize : 1;
	guint ghcimpl : 1;
	guint has_cctor : 1;
	guint has_nested_classes : 1;
	guint blittable : 1;
	guint has_references : 1;
	guint has_static_refs : 1;
	guint no_special_static_fields : 1;
	guint is_generic_container : 1;
	guint has_weak_fields : 1;
	guint32 cctor_token;
	MonoImage *finalize_image;
	guint32 finalize_token;
	guint32 instance_size;
	guint32 class_size;
	guint32 packing_size;
	guint32 min_align;
} MonoCachedClassInfo;

typedef struct {
	// Name and func fields double as "inited".
	// That is, any initialized MonoJitICallInfo must
	// have both of them to be non-NULL.
	const char *name;
	gconstpointer func;
	gconstpointer wrapper;
	gconstpointer trampoline;
	MonoMethodSignature *sig;
	const char *c_symbol;
	MonoMethod *wrapper_method;
} MonoJitICallInfo;

void
mono_class_setup_supertypes (MonoClass *klass);

/* WARNING
 * Only call this function if you can ensure both @klass and @parent
 * have supertype information initialized.
 * This can be accomplished by mono_class_setup_supertypes or mono_class_init.
 * If unsure, use mono_class_has_parent.
 */
static inline gboolean
mono_class_has_parent_fast (MonoClass *klass, MonoClass *parent)
{
	return (m_class_get_idepth (klass) >= m_class_get_idepth (parent)) && (m_class_get_supertypes (klass) [m_class_get_idepth (parent) - 1] == parent);
}

static inline gboolean
mono_class_has_parent (MonoClass *klass, MonoClass *parent)
{
	if (G_UNLIKELY (!m_class_get_supertypes (klass)))
		mono_class_setup_supertypes (klass);

	if (G_UNLIKELY (!m_class_get_supertypes (parent)))
		mono_class_setup_supertypes (parent);

	return mono_class_has_parent_fast (klass, parent);
}

typedef struct {
	MonoVTable *default_vtable;
	MonoVTable *xdomain_vtable;
	MonoClass *proxy_class;
	char* proxy_class_name;
	uint32_t interface_count;
	MonoClass *interfaces [MONO_ZERO_LEN_ARRAY];
} MonoRemoteClass;

#define MONO_SIZEOF_REMOTE_CLASS (sizeof (MonoRemoteClass) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)

typedef struct {
	gint32 initialized_class_count;
	gint32 generic_vtable_count;
	gint32 used_class_count;
	gint32 method_count;
	gint32 class_vtable_size;
	gint32 class_static_data_size;
	gint32 generic_class_count;
	gint32 inflated_method_count;
	gint32 inflated_type_count;
	gint32 delegate_creations;
	gint32 imt_tables_size;
	gint32 imt_number_of_tables;
	gint32 imt_number_of_methods;
	gint32 imt_used_slots;
	gint32 imt_slots_with_collisions;
	gint32 imt_max_collisions_in_slot;
	gint32 imt_method_count_when_max_collisions;
	gint32 imt_trampolines_size;
	gint32 jit_info_table_insert_count;
	gint32 jit_info_table_remove_count;
	gint32 jit_info_table_lookup_count;
	gint32 generics_sharable_methods;
	gint32 generics_unsharable_methods;
	gint32 generics_shared_methods;
	gint32 gsharedvt_methods;
	gboolean enabled;
} MonoStats;

/* 
 * new structure to hold performace counters values that are exported
 * to managed code.
 * Note: never remove fields from this structure and only add them to the end.
 * Size of fields and type should not be changed as well.
 */
typedef struct {
	/* JIT category */
	gint32 jit_methods;
	gint32 jit_bytes;
	gint32 jit_time;
	gint32 jit_failures;
	/* Exceptions category */
	gint32 exceptions_thrown;
	gint32 exceptions_filters;
	gint32 exceptions_finallys;
	gint32 exceptions_depth;
	gint32 aspnet_requests_queued;
	gint32 aspnet_requests;
	/* Memory category */
	gint32 gc_collections0;
	gint32 gc_collections1;
	gint32 gc_collections2;
	gint32 gc_promotions0;
	gint32 gc_promotions1;
	gint32 gc_promotion_finalizers;
	gint64 gc_gen0size;
	gint64 gc_gen1size;
	gint64 gc_gen2size;
	gint32 gc_lossize;
	gint32 gc_fin_survivors;
	gint32 gc_num_handles;
	gint32 gc_allocated;
	gint32 gc_induced;
	gint32 gc_time;
	gint64 gc_total_bytes;
	gint64 gc_committed_bytes;
	gint64 gc_reserved_bytes;
	gint32 gc_num_pinned;
	gint32 gc_sync_blocks;
	/* Remoting category */
	gint32 remoting_calls;
	gint32 remoting_channels;
	gint32 remoting_proxies;
	gint32 remoting_classes;
	gint32 remoting_objects;
	gint32 remoting_contexts;
	/* Loader category */
	gint32 loader_classes;
	gint32 loader_total_classes;
	gint32 loader_appdomains;
	gint32 loader_total_appdomains;
	gint32 loader_assemblies;
	gint32 loader_total_assemblies;
	gint32 loader_failures;
	gint32 loader_bytes;
	gint32 loader_appdomains_uloaded;
	/* Threads and Locks category  */
	gint32 thread_contentions;
	gint32 thread_queue_len;
	gint32 thread_queue_max;
	gint32 thread_num_logical;
	gint32 thread_num_physical;
	gint32 thread_cur_recognized;
	gint32 thread_num_recognized;
	/* Interop category */
	gint32 interop_num_ccw;
	gint32 interop_num_stubs;
	gint32 interop_num_marshals;
	/* Security category */
	gint32 security_num_checks;
	gint32 security_num_link_checks;
	gint32 security_time;
	gint32 security_depth;
	gint32 unused;
	/* Threadpool */
	gint32 threadpool_threads;
	gint64 threadpool_workitems;
	gint64 threadpool_ioworkitems;
	gint32 threadpool_iothreads;
} MonoPerfCounters;

extern MonoPerfCounters *mono_perfcounters;

MONO_API void mono_perfcounters_init (void);

/*
 * The definition of the first field in SafeHandle,
 * Keep in sync with SafeHandle.cs, this is only used
 * to access the `handle' parameter.
 */
typedef struct {
	MonoObject  base;
	void       *handle;
} MonoSafeHandle;

/*
 * Keep in sync with HandleRef.cs
 */
typedef struct {
	MonoObject *wrapper;
	void       *handle;
} MonoHandleRef;

extern MonoStats mono_stats;

typedef gboolean (*MonoGetCachedClassInfo) (MonoClass *klass, MonoCachedClassInfo *res);

typedef gboolean (*MonoGetClassFromName) (MonoImage *image, const char *name_space, const char *name, MonoClass **res);

static inline gboolean
method_is_dynamic (MonoMethod *method)
{
#ifdef DISABLE_REFLECTION_EMIT
	return FALSE;
#else
	return method->dynamic;
#endif
}

MonoMethod*
mono_class_get_method_by_index (MonoClass *klass, int index);

MonoMethod*
mono_class_get_inflated_method (MonoClass *klass, MonoMethod *method, MonoError *error);

MonoMethod*
mono_class_get_vtable_entry (MonoClass *klass, int offset);

GPtrArray*
mono_class_get_implemented_interfaces (MonoClass *klass, MonoError *error);

int
mono_class_get_vtable_size (MonoClass *klass);

gboolean
mono_class_is_open_constructed_type (MonoType *t);

void
mono_class_get_overrides_full (MonoImage *image, guint32 type_token, MonoMethod ***overrides, gint32 *num_overrides, MonoGenericContext *generic_context, MonoError *error);

MONO_LLVM_INTERNAL MonoMethod*
mono_class_get_cctor (MonoClass *klass);

MonoMethod*
mono_class_get_finalizer (MonoClass *klass);

gboolean
mono_class_needs_cctor_run (MonoClass *klass, MonoMethod *caller);

gboolean
mono_class_field_is_special_static (MonoClassField *field);

guint32
mono_class_field_get_special_static_type (MonoClassField *field);

gboolean
mono_class_has_special_static_fields (MonoClass *klass);

const char*
mono_class_get_field_default_value (MonoClassField *field, MonoTypeEnum *def_type);

MonoProperty* 
mono_class_get_property_from_name_internal (MonoClass *klass, const char *name);

const char*
mono_class_get_property_default_value (MonoProperty *property, MonoTypeEnum *def_type);

gpointer
mono_lookup_dynamic_token (MonoImage *image, guint32 token, MonoGenericContext *context, MonoError *error);

gpointer
mono_lookup_dynamic_token_class (MonoImage *image, guint32 token, gboolean check_token, MonoClass **handle_class, MonoGenericContext *context, MonoError *error);

gpointer
mono_runtime_create_jump_trampoline (MonoDomain *domain, MonoMethod *method, gboolean add_sync_wrapper, MonoError *error);

gpointer
mono_runtime_create_delegate_trampoline (MonoClass *klass);

void
mono_install_get_cached_class_info (MonoGetCachedClassInfo func);

void
mono_install_get_class_from_name (MonoGetClassFromName func);

MONO_PROFILER_API MonoGenericContext*
mono_class_get_context (MonoClass *klass);

MONO_PROFILER_API MonoMethodSignature*
mono_method_signature_checked_slow (MonoMethod *m, MonoError *err);

MONO_PROFILER_API MonoMethodSignature*
mono_method_signature_internal_slow (MonoMethod *m);

/**
 * mono_method_signature_checked:
 *
 * Return the signature of the method M. On failure, returns NULL, and ERR is set.
 */
static inline MonoMethodSignature*
mono_method_signature_checked (MonoMethod *m, MonoError *error)
{
	error_init (error);
	MonoMethodSignature* sig = m->signature;
	return sig ? sig : mono_method_signature_checked_slow (m, error);
}

/**
 * mono_method_signature_internal:
 * \returns the signature of the method \p m. On failure, returns NULL.
 */
static inline MonoMethodSignature*
mono_method_signature_internal (MonoMethod *m)
{
	MonoMethodSignature* sig = m->signature;
	return sig ? sig : mono_method_signature_internal_slow (m);
}

MonoGenericContext*
mono_method_get_context_general (MonoMethod *method, gboolean uninflated);

MONO_PROFILER_API MonoGenericContext*
mono_method_get_context (MonoMethod *method);

/* Used by monodis, thus cannot be MONO_INTERNAL */
MONO_API MonoGenericContainer*
mono_method_get_generic_container (MonoMethod *method);

MonoGenericContext*
mono_generic_class_get_context (MonoGenericClass *gclass);

void
mono_method_set_generic_container (MonoMethod *method, MonoGenericContainer* container);

MonoMethod*
mono_class_inflate_generic_method_full_checked (MonoMethod *method, MonoClass *klass_hint, MonoGenericContext *context, MonoError *error);

MonoMethod *
mono_class_inflate_generic_method_checked (MonoMethod *method, MonoGenericContext *context, MonoError *error);

MonoImageSet *
mono_metadata_get_image_set_for_class (MonoClass *klass);

MonoImageSet *
mono_metadata_get_image_set_for_method (MonoMethodInflated *method);

MONO_API MonoMethodSignature *
mono_metadata_get_inflated_signature (MonoMethodSignature *sig, MonoGenericContext *context);

MonoType*
mono_class_inflate_generic_type_with_mempool (MonoImage *image, MonoType *type, MonoGenericContext *context, MonoError *error);

MonoType*
mono_class_inflate_generic_type_checked (MonoType *type, MonoGenericContext *context, MonoError *error);

MONO_API void
mono_metadata_free_inflated_signature (MonoMethodSignature *sig);

MonoMethodSignature*
mono_inflate_generic_signature (MonoMethodSignature *sig, MonoGenericContext *context, MonoError *error);

MonoClass*
mono_generic_param_get_base_type (MonoClass *klass);

typedef struct {
	MonoImage *corlib;
	MonoClass *object_class;
	MonoClass *object_class_array; // used via token pasting in mono_array_class_get_cached
	MonoClass *byte_class;
	MonoClass *void_class;
	MonoClass *boolean_class;
	MonoClass *sbyte_class;
	MonoClass *int16_class;
	MonoClass *uint16_class;
	MonoClass *int32_class;
	MonoClass *uint32_class;
	MonoClass *int_class;
	MonoClass *uint_class;
	MonoClass *int64_class;
	MonoClass *uint64_class;
	MonoClass *single_class;
	MonoClass *double_class;
	MonoClass *char_class;
	MonoClass *string_class;
	MonoClass *enum_class;
	MonoClass *array_class;
	MonoClass *delegate_class;
	MonoClass *multicastdelegate_class;
	MonoClass *manualresetevent_class;
	MonoClass *typehandle_class;
	MonoClass *fieldhandle_class;
	MonoClass *methodhandle_class;
	MonoClass *systemtype_class;
	MonoClass *runtimetype_class;
	MonoClass *runtimetype_class_array; // used via token pasting in mono_array_class_get_cached
	MonoClass *exception_class;
	MonoClass *threadabortexception_class;
	MonoClass *thread_class;
	MonoClass *internal_thread_class;
#ifndef DISABLE_REMOTING
	MonoClass *transparent_proxy_class;
	MonoClass *real_proxy_class;
	MonoClass *marshalbyrefobject_class;
	MonoClass *iremotingtypeinfo_class;
#endif
	MonoClass *mono_method_message_class;
	MonoClass *appdomain_class;
	MonoClass *field_info_class;
	MonoClass *method_info_class;
	MonoClass *stack_frame_class;
	MonoClass *marshal_class;
	MonoClass *typed_reference_class;
	MonoClass *argumenthandle_class;
	MonoClass *monitor_class;
	MonoClass *generic_ilist_class;
	MonoClass *generic_nullable_class;
	MonoClass *attribute_class;
	MonoClass *attribute_class_array; // used via token pasting in mono_array_class_get_cached
	MonoClass *critical_finalizer_object; /* MAYBE NULL */
	MonoClass *generic_ireadonlylist_class;
	MonoClass *generic_ienumerator_class;
#ifndef ENABLE_NETCORE
	MonoMethod *threadpool_perform_wait_callback_method;
#endif
} MonoDefaults;

#ifdef DISABLE_REMOTING
#define mono_class_is_transparent_proxy(klass) (FALSE)
#define mono_class_is_real_proxy(klass) (FALSE)
#else
#define mono_class_is_transparent_proxy(klass) ((klass) == mono_defaults.transparent_proxy_class)
#define mono_class_is_real_proxy(klass) ((klass) == mono_defaults.real_proxy_class)
#endif

#define mono_object_is_transparent_proxy(object) (mono_class_is_transparent_proxy (mono_object_class (object)))


#define GENERATE_GET_CLASS_WITH_CACHE_DECL(shortname) \
MonoClass* mono_class_get_##shortname##_class (void);

#define GENERATE_TRY_GET_CLASS_WITH_CACHE_DECL(shortname) \
MonoClass* mono_class_try_get_##shortname##_class (void);

// GENERATE_GET_CLASS_WITH_CACHE attempts mono_class_load_from_name whenever
// its cache is null. i.e. potentially repeatedly, though it is expected to succeed
// the first time.
//
#define GENERATE_GET_CLASS_WITH_CACHE(shortname,name_space,name) \
MonoClass*	\
mono_class_get_##shortname##_class (void)	\
{	\
	static MonoClass *tmp_class;	\
	MonoClass *klass = tmp_class;	\
	if (!klass) {	\
		klass = mono_class_load_from_name (mono_defaults.corlib, name_space, name);	\
		mono_memory_barrier ();	/* FIXME excessive? */ \
		tmp_class = klass;	\
	}	\
	return klass;	\
}

// GENERATE_TRY_GET_CLASS_WITH_CACHE attempts mono_class_load_from_name approximately
// only once. i.e. if it fails, it will return null and not retry.
// In a race it might try a few times, but not indefinitely.
//
// FIXME This maybe has excessive volatile/barriers.
//
#define GENERATE_TRY_GET_CLASS_WITH_CACHE(shortname,name_space,name) \
MonoClass*	\
mono_class_try_get_##shortname##_class (void)	\
{	\
	static volatile MonoClass *tmp_class;	\
	static volatile gboolean inited;	\
	MonoClass *klass = (MonoClass *)tmp_class;	\
	mono_memory_barrier ();	\
	if (!inited) {	\
		klass = mono_class_try_load_from_name (mono_defaults.corlib, name_space, name);	\
		tmp_class = klass;	\
		mono_memory_barrier ();	\
		inited = TRUE;	\
	}	\
	return klass;	\
}

GENERATE_TRY_GET_CLASS_WITH_CACHE_DECL (safehandle)

#ifndef DISABLE_COM

GENERATE_GET_CLASS_WITH_CACHE_DECL (interop_proxy)
GENERATE_GET_CLASS_WITH_CACHE_DECL (idispatch)
GENERATE_GET_CLASS_WITH_CACHE_DECL (iunknown)
GENERATE_GET_CLASS_WITH_CACHE_DECL (com_object)
GENERATE_GET_CLASS_WITH_CACHE_DECL (variant)

#endif

GENERATE_GET_CLASS_WITH_CACHE_DECL (appdomain)
GENERATE_GET_CLASS_WITH_CACHE_DECL (appdomain_setup)

GENERATE_GET_CLASS_WITH_CACHE_DECL (appdomain_unloaded_exception)
GENERATE_TRY_GET_CLASS_WITH_CACHE_DECL (appdomain_unloaded_exception)

GENERATE_GET_CLASS_WITH_CACHE_DECL (valuetype)

GENERATE_TRY_GET_CLASS_WITH_CACHE_DECL(handleref)

#ifdef ENABLE_NETCORE
GENERATE_GET_CLASS_WITH_CACHE_DECL (assembly_load_context)
GENERATE_GET_CLASS_WITH_CACHE_DECL (native_library)
#endif

/* If you need a MonoType, use one of the mono_get_*_type () functions in class-inlines.h */
extern MonoDefaults mono_defaults;

void
mono_loader_init           (void);

void
mono_loader_cleanup        (void);

MONO_LLVM_INTERNAL void
mono_loader_lock           (void);

MONO_LLVM_INTERNAL void
mono_loader_unlock         (void);

void
mono_loader_lock_track_ownership (gboolean track);

gboolean
mono_loader_lock_is_owned_by_self (void);

void
mono_loader_lock_if_inited (void);

void
mono_loader_unlock_if_inited (void);

void
mono_reflection_init       (void);

void
mono_icall_init            (void);

void
mono_icall_cleanup         (void);

gpointer
mono_method_get_wrapper_data (MonoMethod *method, guint32 id);

gboolean
mono_metadata_has_generic_params (MonoImage *image, guint32 token);

MONO_API MonoGenericContainer *
mono_metadata_load_generic_params (MonoImage *image, guint32 token,
				   MonoGenericContainer *parent_container,
				   gpointer real_owner);

MONO_API gboolean
mono_metadata_load_generic_param_constraints_checked (MonoImage *image, guint32 token,
					      MonoGenericContainer *container, MonoError *error);

// This is the "real" function for registering JIT icalls. All others are one line wrappers that call it,
// i.e. filling in info or c_symbol.
void
mono_register_jit_icall_info (MonoJitICallInfo *info, gconstpointer func, const char *name,
			      MonoMethodSignature *sig, gboolean no_wrapper, const char *c_symbol);

#ifdef __cplusplus
template <typename T>
inline void
mono_register_jit_icall_info (MonoJitICallInfo *info, T func, const char *name, MonoMethodSignature *sig, gboolean no_wrapper, const char *c_symbol)
{
	mono_register_jit_icall_info (info, (gconstpointer)func, name, sig, no_wrapper, c_symbol);
}
#endif // __cplusplus

#define mono_register_jit_icall(func, sig, no_wrapper) (mono_register_jit_icall_info (&mono_get_jit_icall_info ()->func, func, #func, (sig), (no_wrapper), NULL))

gboolean
mono_class_set_type_load_failure (MonoClass *klass, const char * fmt, ...) MONO_ATTR_FORMAT_PRINTF(2,3);

MonoException*
mono_class_get_exception_for_failure (MonoClass *klass);

char*
mono_identifier_escape_type_name_chars (const char* identifier);

char*
mono_type_get_full_name (MonoClass *klass);

char *
mono_method_get_name_full (MonoMethod *method, gboolean signature, gboolean ret, MonoTypeNameFormat format);

MONO_PROFILER_API char *
mono_method_get_full_name (MonoMethod *method);

const char*
mono_wrapper_type_to_str (guint32 wrapper_type);

MonoArrayType *mono_dup_array_type (MonoImage *image, MonoArrayType *a);
MonoMethodSignature *mono_metadata_signature_deep_dup (MonoImage *image, MonoMethodSignature *sig);

MONO_API void
mono_image_init_name_cache (MonoImage *image);

MonoClass*
mono_class_get_nullable_param_internal (MonoClass *klass);

/* object debugging functions, for use inside gdb */
MONO_API void mono_object_describe        (MonoObject *obj);
MONO_API void mono_object_describe_fields (MonoObject *obj);
MONO_API void mono_value_describe_fields  (MonoClass* klass, const char* addr);
MONO_API void mono_class_describe_statics (MonoClass* klass);

/* method debugging functions, for use inside gdb */
MONO_API void mono_method_print_code (MonoMethod *method);

MONO_PROFILER_API char *mono_signature_full_name (MonoMethodSignature *sig);

/*Enum validation related functions*/
MONO_API gboolean
mono_type_is_valid_enum_basetype (MonoType * type);

MONO_API gboolean
mono_class_is_valid_enum (MonoClass *klass);

MONO_PROFILER_API gboolean
mono_type_is_primitive (MonoType *type);

MonoType *
mono_type_get_checked        (MonoImage *image, guint32 type_token, MonoGenericContext *context, MonoError *error);

gboolean
mono_generic_class_is_generic_type_definition (MonoGenericClass *gklass);

MonoType*
mono_type_get_basic_type_from_generic (MonoType *type);

gboolean
mono_method_can_access_method_full (MonoMethod *method, MonoMethod *called, MonoClass *context_klass);

gboolean
mono_method_can_access_field_full (MonoMethod *method, MonoClassField *field, MonoClass *context_klass);

gboolean
mono_class_can_access_class (MonoClass *access_class, MonoClass *target_class);

MonoClass *
mono_class_get_generic_type_definition (MonoClass *klass);

gboolean
mono_class_has_parent_and_ignore_generics (MonoClass *klass, MonoClass *parent);

int
mono_method_get_vtable_slot (MonoMethod *method);

int
mono_method_get_vtable_index (MonoMethod *method);

MonoMethod*
mono_method_get_base_method (MonoMethod *method, gboolean definition, MonoError *error);

MonoMethod*
mono_method_search_in_array_class (MonoClass *klass, const char *name, MonoMethodSignature *sig);

void
mono_class_setup_interface_id (MonoClass *klass);

MonoGenericContainer*
mono_class_get_generic_container (MonoClass *klass);

gpointer
mono_class_alloc (MonoClass *klass, int size);

gpointer
mono_class_alloc0 (MonoClass *klass, int size);

#define mono_class_alloc0(klass, size) (g_cast (mono_class_alloc0 ((klass), (size))))

void
mono_class_setup_interfaces (MonoClass *klass, MonoError *error);

MonoClassField*
mono_class_get_field_from_name_full (MonoClass *klass, const char *name, MonoType *type);

MonoVTable*
mono_class_vtable_checked (MonoDomain *domain, MonoClass *klass, MonoError *error);

void
mono_class_is_assignable_from_checked (MonoClass *klass, MonoClass *oklass, gboolean *result, MonoError *error);

gboolean
mono_class_is_assignable_from_slow (MonoClass *target, MonoClass *candidate);

gboolean
mono_class_has_variant_generic_params (MonoClass *klass);

gboolean
mono_class_is_variant_compatible (MonoClass *klass, MonoClass *oklass, gboolean check_for_reference_conv);

gboolean 
mono_class_is_subclass_of_internal (MonoClass *klass, MonoClass *klassc, gboolean check_interfaces);

mono_bool
mono_class_is_assignable_from_internal (MonoClass *klass, MonoClass *oklass);

gboolean mono_is_corlib_image (MonoImage *image);

MonoType*
mono_field_get_type_checked (MonoClassField *field, MonoError *error);

MonoType*
mono_field_get_type_internal (MonoClassField *field);

MonoClassField*
mono_class_get_fields_internal (MonoClass* klass, gpointer *iter);

MonoClassField*
mono_class_get_fields_lazy (MonoClass* klass, gpointer *iter);

gboolean
mono_class_check_vtable_constraints (MonoClass *klass, GList *in_setup);

gboolean
mono_class_has_finalizer (MonoClass *klass);

void
mono_unload_interface_id (MonoClass *klass);

GPtrArray*
mono_class_get_methods_by_name (MonoClass *klass, const char *name, guint32 bflags, guint32 mlisttype, gboolean allow_ctors, MonoError *error);

char*
mono_class_full_name (MonoClass *klass);

MonoClass*
mono_class_inflate_generic_class_checked (MonoClass *gklass, MonoGenericContext *context, MonoError *error);

MONO_PROFILER_API MonoClass *
mono_class_get_checked (MonoImage *image, guint32 type_token, MonoError *error);

MonoClass *
mono_class_get_and_inflate_typespec_checked (MonoImage *image, guint32 type_token, MonoGenericContext *context, MonoError *error);

MonoClass *
mono_class_from_name_checked (MonoImage *image, const char* name_space, const char *name, MonoError *error);

MonoClass *
mono_class_from_name_case_checked (MonoImage *image, const char* name_space, const char *name, MonoError *error);

MONO_PROFILER_API MonoClass *
mono_class_from_mono_type_internal (MonoType *type);

MonoClassField*
mono_field_from_token_checked (MonoImage *image, uint32_t token, MonoClass **retklass, MonoGenericContext *context, MonoError *error);

gpointer
mono_ldtoken_checked (MonoImage *image, guint32 token, MonoClass **handle_class, MonoGenericContext *context, MonoError *error);

MonoImage *
mono_get_image_for_generic_param (MonoGenericParam *param);

char *
mono_make_generic_name_string (MonoImage *image, int num);

MONO_LLVM_INTERNAL MonoClass *
mono_class_load_from_name (MonoImage *image, const char* name_space, const char *name);

MonoClass*
mono_class_try_load_from_name (MonoImage *image, const char* name_space, const char *name);

void
mono_error_set_for_class_failure (MonoError *orerror, const MonoClass *klass);

gboolean
mono_class_has_failure (const MonoClass *klass);

/* Kind specific accessors */
MONO_LLVM_INTERNAL MonoGenericClass*
mono_class_get_generic_class (MonoClass *klass);

MonoGenericClass*
mono_class_try_get_generic_class (MonoClass *klass);

void
mono_class_set_flags (MonoClass *klass, guint32 flags);

MonoGenericContainer*
mono_class_try_get_generic_container (MonoClass *klass);

void
mono_class_set_generic_container (MonoClass *klass, MonoGenericContainer *container);

MonoType*
mono_class_gtd_get_canonical_inst (MonoClass *klass);

guint32
mono_class_get_first_method_idx (MonoClass *klass);

void
mono_class_set_first_method_idx (MonoClass *klass, guint32 idx);

guint32
mono_class_get_first_field_idx (MonoClass *klass);

void
mono_class_set_first_field_idx (MonoClass *klass, guint32 idx);

guint32
mono_class_get_method_count (MonoClass *klass);

void
mono_class_set_method_count (MonoClass *klass, guint32 count);

guint32
mono_class_get_field_count (MonoClass *klass);

void
mono_class_set_field_count (MonoClass *klass, guint32 count);

MonoMarshalType*
mono_class_get_marshal_info (MonoClass *klass);

void
mono_class_set_marshal_info (MonoClass *klass, MonoMarshalType *marshal_info);

guint32
mono_class_get_ref_info_handle (MonoClass *klass);

guint32
mono_class_set_ref_info_handle (MonoClass *klass, guint32 value);

MonoErrorBoxed*
mono_class_get_exception_data (MonoClass *klass);

void
mono_class_set_exception_data (MonoClass *klass, MonoErrorBoxed *value);

GList*
mono_class_get_nested_classes_property (MonoClass *klass);

void
mono_class_set_nested_classes_property (MonoClass *klass, GList *value);

MonoClassPropertyInfo*
mono_class_get_property_info (MonoClass *klass);

void
mono_class_set_property_info (MonoClass *klass, MonoClassPropertyInfo *info);

MonoClassEventInfo*
mono_class_get_event_info (MonoClass *klass);

void
mono_class_set_event_info (MonoClass *klass, MonoClassEventInfo *info);

MonoFieldDefaultValue*
mono_class_get_field_def_values (MonoClass *klass);

void
mono_class_set_field_def_values (MonoClass *klass, MonoFieldDefaultValue *values);

guint32
mono_class_get_declsec_flags (MonoClass *klass);

void
mono_class_set_declsec_flags (MonoClass *klass, guint32 value);

void
mono_class_set_is_com_object (MonoClass *klass);

void
mono_class_set_weak_bitmap (MonoClass *klass, int nbits, gsize *bits);

gsize*
mono_class_get_weak_bitmap (MonoClass *klass, int *nbits);

gboolean
mono_class_has_dim_conflicts (MonoClass *klass);

void
mono_class_set_dim_conflicts (MonoClass *klass, GSList *conflicts);

GSList*
mono_class_get_dim_conflicts (MonoClass *klass);

MonoMethod *
mono_class_get_method_from_name_checked (MonoClass *klass, const char *name, int param_count, int flags, MonoError *error);

gboolean
mono_method_has_no_body (MonoMethod *method);

// FIXME Replace all internal callers of mono_method_get_header_checked with
// mono_method_get_header_internal; the difference is in error initialization.
//
// And then mark mono_method_get_header_checked as MONO_RT_EXTERNAL_ONLY MONO_API.
//
// Internal callers expected to use ERROR_DECL. External callers are not.
MonoMethodHeader*
mono_method_get_header_internal (MonoMethod *method, MonoError *error);

MonoType*
mono_class_find_enum_basetype (MonoClass *klass, MonoError *error);

gboolean
mono_class_set_failure (MonoClass *klass, MonoErrorBoxed *boxed_error);

gboolean
mono_class_set_type_load_failure_causedby_class (MonoClass *klass, const MonoClass *caused_by, const gchar* msg);

gboolean mono_class_get_cached_class_info (MonoClass *klass, MonoCachedClassInfo *res);

MonoMethod* mono_find_method_in_metadata (MonoClass *klass, const char *name, int param_count, int flags);

int
mono_class_get_object_finalize_slot (void);

MonoMethod *
mono_class_get_default_finalize_method (void);

void
mono_field_resolve_type (MonoClassField *field, MonoError *error);

gboolean
mono_type_has_exceptions (MonoType *type);

void
mono_class_set_nonblittable (MonoClass *klass);

gboolean
mono_class_publish_gc_descriptor (MonoClass *klass, MonoGCDescriptor gc_descr);

void
mono_class_compute_gc_descriptor (MonoClass *klass);

#ifndef DISABLE_REMOTING
void
mono_class_contextbound_bit_offset (int* byte_offset_out, guint8* mask_out);
#endif

gboolean
mono_class_init_checked (MonoClass *klass, MonoError *error);

MONO_LLVM_INTERNAL MonoType*
mono_class_enum_basetype_internal (MonoClass *klass);

gboolean
mono_method_is_constructor (MonoMethod *method);

gboolean
mono_class_has_default_constructor (MonoClass *klass, gboolean public_only);

// There are many ways to do on-demand initialization.
//   Some allow multiple concurrent initializations. Some do not.
//   Some allow multiple concurrent writes to the global. Some do not.
//
// Booleans or names capturing these factors would be desirable.
//	RacyInit?
//
// This form allows both such races, on the understanding that,
// even if the initialization occurs multiple times, every result is equivalent,
// and the goal is not to initialize no more than once, but for the steady state
// to stop rerunning the initialization.
//
// It may be desirable to replace this with mono_lazy_initialize, etc.
//
// These macros cannot be wrapped in do/while as they inject "name" into invoking scope.
//
#define MONO_STATIC_POINTER_INIT(type, name)					\
	static type *static_ ## name;						\
	type *name; 								\
	name = static_ ## name;							\
	if (!name) {								\
		/* Custom code here to initialize name */
#define MONO_STATIC_POINTER_INIT_END(type, name)				\
		if (name) {							\
			/* Success, commit to static. */			\
			mono_atomic_store_seq (&static_ ## name, name);		\
		}								\
	}									\

static inline gboolean
m_field_get_offset (MonoClassField *field)
{
	g_assert (m_class_is_fields_inited (field->parent));
	return field->offset;
}

// Enum and static storage for JIT icalls.
#include "jit-icall-reg.h"

/*Now that everything has been defined, let's include the inline functions */
#include <mono/metadata/class-inlines.h>

#endif /* __MONO_METADATA_CLASS_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/class-private-definition.h`:

```h
/**
 * \file Definitions of struct _MonoClass members
 *
 * NOTE: This file should NOT be included directly.
 */

#if defined(MONO_CLASS_DEF_PRIVATE) && !defined(REALLY_INCLUDE_CLASS_DEF)
#error struct _MonoClass definition should not be accessed directly
#endif

#ifndef __MONO_METADATA_CLASS_PRIVATE_DEFINITION_H__
#define __MONO_METADATA_CLASS_PRIVATE_DEFINITION_H__

struct _MonoClass {
	/* element class for arrays and enum basetype for enums */
	MonoClass *element_class; 
	/* used for subtype checks */
	MonoClass *cast_class; 

	/* for fast subtype checks */
	MonoClass **supertypes;
	guint16     idepth;

	/* array dimension */
	guint8     rank;

	/* One of the values from MonoTypeKind */
	guint8     class_kind;

	int        instance_size; /* object instance size */

	guint inited          : 1;

	/* A class contains static and non static data. Static data can be
	 * of the same type as the class itselfs, but it does not influence
	 * the instance size of the class. To avoid cyclic calls to 
	 * mono_class_init_internal (from mono_class_instance_size ()) we first
	 * initialise all non static fields. After that we set size_inited 
	 * to 1, because we know the instance size now. After that we 
	 * initialise all static fields.
	 */

	/* ALL BITFIELDS SHOULD BE WRITTEN WHILE HOLDING THE LOADER LOCK */
	guint size_inited     : 1;
	guint valuetype       : 1; /* derives from System.ValueType */
	guint enumtype        : 1; /* derives from System.Enum */
	guint blittable       : 1; /* class is blittable */
	guint unicode         : 1; /* class uses unicode char when marshalled */
	guint wastypebuilder  : 1; /* class was created at runtime from a TypeBuilder */
	guint is_array_special_interface : 1; /* gtd or ginst of once of the magic interfaces that arrays implement */
	guint is_byreflike    : 1; /* class is a valuetype and has System.Runtime.CompilerServices.IsByRefLikeAttribute */

	/* next byte */
	guint8 min_align;

	/* next byte */
	guint packing_size    : 4;
	guint ghcimpl         : 1; /* class has its own GetHashCode impl */ 
	guint has_finalize    : 1; /* class has its own Finalize impl */ 
#ifndef DISABLE_REMOTING
	guint marshalbyref    : 1; /* class is a MarshalByRefObject */
	guint contextbound    : 1; /* class is a ContextBoundObject */
#endif
	/* next byte */
	guint delegate        : 1; /* class is a Delegate */
	guint gc_descr_inited : 1; /* gc_descr is initialized */
	guint has_cctor       : 1; /* class has a cctor */
	guint has_references  : 1; /* it has GC-tracked references in the instance */
	guint has_static_refs : 1; /* it has static fields that are GC-tracked */
	guint no_special_static_fields : 1; /* has no thread/context static fields */
	/* directly or indirectly derives from ComImport attributed class.
	 * this means we need to create a proxy for instances of this class
	 * for COM Interop. set this flag on loading so all we need is a quick check
	 * during object creation rather than having to traverse supertypes
	 */
	guint is_com_object : 1; 
	guint nested_classes_inited : 1; /* Whenever nested_class is initialized */

	/* next byte*/
	guint interfaces_inited : 1; /* interfaces is initialized */
	guint simd_type : 1; /* class is a simd intrinsic type */
	guint has_finalize_inited    : 1; /* has_finalize is initialized */
	guint fields_inited : 1; /* setup_fields () has finished */
	guint has_failure : 1; /* See mono_class_get_exception_data () for a MonoErrorBoxed with the details */
	guint has_weak_fields : 1; /* class has weak reference fields */
	guint has_dim_conflicts : 1; /* Class has conflicting default interface methods */

	MonoClass  *parent;
	MonoClass  *nested_in;

	MonoImage *image;
	const char *name;
	const char *name_space;

	guint32    type_token;
	int        vtable_size; /* number of slots */

	guint16     interface_count;
	guint32     interface_id;        /* unique inderface id (for interfaces) */
	guint32     max_interface_id;
	
	guint16     interface_offsets_count;
	MonoClass **interfaces_packed;
	guint16    *interface_offsets_packed;
	guint8     *interface_bitmap;

	MonoClass **interfaces;

	union _MonoClassSizes sizes;

	/*
	 * Field information: Type and location from object base
	 */
	MonoClassField *fields;

	MonoMethod **methods;

	/* used as the type of the this argument and when passing the arg by value */
	MonoType this_arg;
	MonoType _byval_arg;

	MonoGCDescriptor gc_descr;

	MonoClassRuntimeInfo *runtime_info;

	/* Generic vtable. Initialized by a call to mono_class_setup_vtable () */
	MonoMethod **vtable;

	/* Infrequently used items. See class-accessors.c: InfrequentDataKind for what goes into here. */
	MonoPropertyBag infrequent_data;
};

struct _MonoClassDef {
	MonoClass klass;
	guint32	flags;
	/*
	 * From the TypeDef table
	 */
	guint32 first_method_idx;
	guint32 first_field_idx;
	guint32 method_count, field_count;
	/* next element in the class_cache hash list (in MonoImage) */
	MonoClass *next_class_cache;
};

struct _MonoClassGtd {
	MonoClassDef klass;
	MonoGenericContainer *generic_container;
	/* The canonical GENERICINST where we instantiate a generic type definition with its own generic parameters.*/
	/* Suppose we have class T`2<A,B> {...}.  canonical_inst is the GTD T`2 applied to A and B. */
	MonoType canonical_inst;
};

struct _MonoClassGenericInst {
	MonoClass klass;
	MonoGenericClass *generic_class;
};

struct _MonoClassGenericParam {
	MonoClass klass;
};

struct _MonoClassArray {
	MonoClass klass;
	guint32 method_count;
};

struct _MonoClassPointer {
	MonoClass klass;
};


#endif

```

`Hazel/vendor/mono/include/mono/metadata/class.h`:

```h
/**
 * \file
 */

#ifndef _MONO_CLI_CLASS_H_
#define _MONO_CLI_CLASS_H_

#include <mono/metadata/metadata.h>
#include <mono/metadata/image.h>
#include <mono/metadata/loader.h>
#include <mono/utils/mono-error.h>

MONO_BEGIN_DECLS

typedef struct MonoVTable MonoVTable;

typedef struct _MonoClassField MonoClassField;
typedef struct _MonoProperty MonoProperty;
typedef struct _MonoEvent MonoEvent;

typedef enum {
	MONO_TYPE_NAME_FORMAT_IL,
	MONO_TYPE_NAME_FORMAT_REFLECTION,
	MONO_TYPE_NAME_FORMAT_FULL_NAME,
	MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED
} MonoTypeNameFormat;

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass *
mono_class_get             (MonoImage *image, uint32_t type_token);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass *
mono_class_get_full        (MonoImage *image, uint32_t type_token, MonoGenericContext *context);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_class_init            (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoVTable *
mono_class_vtable          (MonoDomain *domain, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass *
mono_class_from_name       (MonoImage *image, const char* name_space, const char *name);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass *
mono_class_from_name_case  (MonoImage *image, const char* name_space, const char *name);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod *
mono_class_get_method_from_name_flags (MonoClass *klass, const char *name, int param_count, int flags);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass *
mono_class_from_typeref    (MonoImage *image, uint32_t type_token);

MONO_API MonoClass *
mono_class_from_typeref_checked (MonoImage *image, uint32_t type_token, MonoError *error);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass *
mono_class_from_generic_parameter (MonoGenericParam *param, MonoImage *image, mono_bool is_mvar);

MONO_API MONO_RT_EXTERNAL_ONLY MonoType*
mono_class_inflate_generic_type (MonoType *type, MonoGenericContext *context) /* MONO_DEPRECATED */;

MONO_API MONO_RT_EXTERNAL_ONLY
MonoMethod*
mono_class_inflate_generic_method (MonoMethod *method, MonoGenericContext *context);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoMethod *
mono_get_inflated_method (MonoMethod *method);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClassField*
mono_field_from_token      (MonoImage *image, uint32_t token, MonoClass **retklass, MonoGenericContext *context);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass *
mono_bounded_array_class_get (MonoClass *element_class, uint32_t rank, mono_bool bounded);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass *
mono_array_class_get       (MonoClass *element_class, uint32_t rank);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass *
mono_ptr_class_get         (MonoType *type);

MONO_API MonoClassField *
mono_class_get_field       (MonoClass *klass, uint32_t field_token);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClassField *
mono_class_get_field_from_name (MonoClass *klass, const char *name);

MONO_API uint32_t
mono_class_get_field_token (MonoClassField *field);

MONO_API uint32_t
mono_class_get_event_token (MonoEvent *event);

MONO_API MONO_RT_EXTERNAL_ONLY MonoProperty *
mono_class_get_property_from_name (MonoClass *klass, const char *name);

MONO_API uint32_t
mono_class_get_property_token (MonoProperty *prop);

MONO_API int32_t
mono_array_element_size    (MonoClass *ac);

MONO_API int32_t
mono_class_instance_size   (MonoClass *klass);

MONO_API int32_t
mono_class_array_element_size (MonoClass *klass);

MONO_API int32_t
mono_class_data_size       (MonoClass *klass);

MONO_API int32_t
mono_class_value_size      (MonoClass *klass, uint32_t *align);

MONO_API int32_t
mono_class_min_align       (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass *
mono_class_from_mono_type  (MonoType *type);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_class_is_subclass_of (MonoClass *klass, MonoClass *klassc, 
						   mono_bool check_interfaces);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_class_is_assignable_from (MonoClass *klass, MonoClass *oklass);

MONO_API MONO_RT_EXTERNAL_ONLY
void*
mono_ldtoken               (MonoImage *image, uint32_t token, MonoClass **retclass, MonoGenericContext *context);

MONO_API char *
mono_type_get_name_full (MonoType *type, MonoTypeNameFormat format);

MONO_API char*         
mono_type_get_name         (MonoType *type);

MONO_API MonoType*
mono_type_get_underlying_type (MonoType *type);

/* MonoClass accessors */
MONO_API MonoImage*
mono_class_get_image         (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass*
mono_class_get_element_class (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
mono_bool
mono_class_is_valuetype      (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
mono_bool
mono_class_is_enum          (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoType*
mono_class_enum_basetype    (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass*
mono_class_get_parent        (MonoClass *klass);

MONO_API MonoClass*
mono_class_get_nesting_type  (MonoClass *klass);

MONO_API int
mono_class_get_rank          (MonoClass *klass);

MONO_API uint32_t
mono_class_get_flags         (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
const char*
mono_class_get_name          (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
const char*
mono_class_get_namespace     (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoType*
mono_class_get_type          (MonoClass *klass);

MONO_API uint32_t
mono_class_get_type_token    (MonoClass *klass);

MONO_API MonoType*
mono_class_get_byref_type    (MonoClass *klass);

MONO_API int
mono_class_num_fields        (MonoClass *klass);

MONO_API int
mono_class_num_methods       (MonoClass *klass);

MONO_API int
mono_class_num_properties    (MonoClass *klass);

MONO_API int
mono_class_num_events        (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClassField*
mono_class_get_fields        (MonoClass* klass, void **iter);

MONO_API MonoMethod*
mono_class_get_methods       (MonoClass* klass, void **iter);

MONO_API MonoProperty*
mono_class_get_properties    (MonoClass* klass, void **iter);

MONO_API MonoEvent*
mono_class_get_events        (MonoClass* klass, void **iter);

MONO_API MonoClass*
mono_class_get_interfaces    (MonoClass* klass, void **iter);

MONO_API MonoClass*
mono_class_get_nested_types  (MonoClass* klass, void **iter);

MONO_API MONO_RT_EXTERNAL_ONLY
mono_bool
mono_class_is_delegate       (MonoClass* klass);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_class_implements_interface (MonoClass* klass, MonoClass* iface);

/* MonoClassField accessors */
MONO_API const char*
mono_field_get_name   (MonoClassField *field);

MONO_API MonoType*
mono_field_get_type   (MonoClassField *field);

MONO_API MonoClass*
mono_field_get_parent (MonoClassField *field);

MONO_API uint32_t
mono_field_get_flags  (MonoClassField *field);

MONO_API uint32_t
mono_field_get_offset  (MonoClassField *field);

MONO_API const char *
mono_field_get_data  (MonoClassField *field);

/* MonoProperty acessors */
MONO_API const char*
mono_property_get_name       (MonoProperty *prop);

MONO_API MonoMethod*
mono_property_get_set_method (MonoProperty *prop);

MONO_API MonoMethod*
mono_property_get_get_method (MonoProperty *prop);

MONO_API MonoClass*
mono_property_get_parent     (MonoProperty *prop);

MONO_API uint32_t
mono_property_get_flags      (MonoProperty *prop);

/* MonoEvent accessors */
MONO_API const char*
mono_event_get_name          (MonoEvent *event);

MONO_API MonoMethod*
mono_event_get_add_method    (MonoEvent *event);

MONO_API MonoMethod*
mono_event_get_remove_method (MonoEvent *event);

MONO_API MonoMethod*
mono_event_get_remove_method (MonoEvent *event);

MONO_API MonoMethod*
mono_event_get_raise_method  (MonoEvent *event);

MONO_API MonoClass*
mono_event_get_parent        (MonoEvent *event);

MONO_API uint32_t
mono_event_get_flags         (MonoEvent *event);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod *
mono_class_get_method_from_name (MonoClass *klass, const char *name, int param_count);

MONO_API char *
mono_class_name_from_token (MonoImage *image, uint32_t type_token);

MONO_API mono_bool
mono_method_can_access_field (MonoMethod *method, MonoClassField *field);

MONO_API mono_bool
mono_method_can_access_method (MonoMethod *method, MonoMethod *called);

MONO_API mono_bool
mono_class_is_nullable (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass*
mono_class_get_nullable_param (MonoClass *klass);

MONO_END_DECLS

#endif /* _MONO_CLI_CLASS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/cominterop-win32-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_COMINTEROP_WIN32_INTERNALS_H__
#define __MONO_METADATA_COMINTEROP_WIN32_INTERNALS_H__

#include <config.h>
#include <glib.h>

// On some Windows platforms the implementation of below methods are hosted
// in separate source files like cominterop-win32-*.c. On other platforms,
// the implementation is kept in cominterop.c and declared as static and in some
// cases even inline.
#if defined(HOST_WIN32) && !G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT | HAVE_UWP_WINAPI_SUPPORT)

guint32
mono_marshal_win_safearray_get_dim (gpointer safearray);

int
mono_marshal_win_safe_array_get_lbound (gpointer psa, guint nDim, glong* plLbound);

int
mono_marshal_win_safe_array_get_ubound (gpointer psa, guint nDim, glong* plUbound);

int
mono_marshal_win_safearray_get_value (gpointer safearray, gpointer indices, gpointer *result);

void
mono_marshal_win_safearray_end (gpointer safearray, gpointer indices);

gboolean
mono_marshal_win_safearray_create_internal (UINT cDims, SAFEARRAYBOUND *rgsabound, gpointer *newsafearray);

int
mono_marshal_win_safearray_set_value (gpointer safearray, gpointer indices, gpointer value);

#endif /* HOST_WIN32 && !G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT | HAVE_UWP_WINAPI_SUPPORT) */

#endif /* __MONO_METADATA_COMINTEROP_WIN32_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/cominterop.h`:

```h
/**
 * \file
 * COM Interop Support
 * 
 *
 * (C) 2002 Ximian, Inc.  http://www.ximian.com
 *
 */

#ifndef __MONO_COMINTEROP_H__
#define __MONO_COMINTEROP_H__

#include <mono/metadata/method-builder.h>
#include <mono/metadata/method-builder-ilgen.h>
#include <mono/metadata/marshal.h>

void
mono_cominterop_init (void);

void
mono_cominterop_cleanup (void);

void
mono_mb_emit_cominterop_get_function_pointer (MonoMethodBuilder *mb, MonoMethod* method);

void
mono_mb_emit_cominterop_call_function_pointer (MonoMethodBuilder *mb, MonoMethodSignature *sig);

void
mono_mb_emit_cominterop_call (MonoMethodBuilder *mb, MonoMethodSignature *sig, MonoMethod* method);

void
mono_cominterop_emit_ptr_to_object_conv (MonoMethodBuilder *mb, MonoType *type, MonoMarshalConv conv, MonoMarshalSpec *mspec);

void
mono_cominterop_emit_object_to_ptr_conv (MonoMethodBuilder *mb, MonoType *type, MonoMarshalConv conv, MonoMarshalSpec *mspec);

MonoMethod *
mono_cominterop_get_native_wrapper (MonoMethod *method);

MonoMethod *
mono_cominterop_get_invoke (MonoMethod *method);

int
mono_cominterop_emit_marshal_com_interface (EmitMarshalContext *m, int argnum, 
											MonoType *t,
											MonoMarshalSpec *spec, 
											int conv_arg, MonoType **conv_arg_type, 
											MarshalAction action);

int
mono_cominterop_emit_marshal_safearray (EmitMarshalContext *m, int argnum,
										MonoType *t,
										MonoMarshalSpec *spec, 
										int conv_arg, MonoType **conv_arg_type,
										MarshalAction action);

MONO_API MONO_RT_EXTERNAL_ONLY MonoString *
mono_string_from_bstr (/*mono_bstr*/gpointer bstr);

MONO_API void 
mono_free_bstr (/*mono_bstr_const*/gpointer bstr);

MonoClass*
mono_class_try_get_com_object_class (void);

void*
mono_cominterop_get_com_interface (MonoObject* object, MonoClass* ic, MonoError *error);

gboolean
mono_cominterop_is_interface (MonoClass* klass);

#endif /* __MONO_COMINTEROP_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/console-io.h`:

```h
/**
 * \file
 * Console IO internal calls
 *
 * Author:
 *	Gonzalo Paniagua Javier (gonzalo@ximian.com)
 *
 * Copyright (c) 2005 Novell, Inc. (http://www.novell.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_METADATA_CONSOLEIO_H
#define _MONO_METADATA_CONSOLEIO_H

#include <config.h>
#include <glib.h>

#include <mono/metadata/object.h>
#include <mono/utils/mono-compiler.h>
#include <mono/metadata/icalls.h>

void mono_console_init (void);
void mono_console_handle_async_ops (void);

#endif /* _MONO_METADATA_CONSOLEIO_H */

```

`Hazel/vendor/mono/include/mono/metadata/console-win32-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_CONSOLE_WIN32_INTERNALS_H__
#define __MONO_CONSOLE_WIN32_INTERNALS_H__

#include <config.h>
#include <glib.h>

#include "mono/metadata/object.h"
#include "mono/metadata/object-internals.h"
#include "mono/utils/mono-error.h"
#include "mono/utils/mono-error-internals.h"
#include <mono/metadata/console-io.h>

#endif /* __MONO_CONSOLE_WIN32_INTERNALS_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/coree-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_COREE_INTERNALS_H__
#define __MONO_COREE_INTERNALS_H__

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32
#include <windows.h>

BOOL STDMETHODCALLTYPE
_CorDllMain (HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);

__int32 STDMETHODCALLTYPE
_CorExeMain (void);

void STDMETHODCALLTYPE
CorExitProcess (int exitCode);

STDAPI
_CorValidateImage (PVOID *ImageBase, LPCWSTR FileName);

STDAPI_(VOID)
_CorImageUnloading (PVOID ImageBase);

STDAPI
CorBindToRuntimeEx (LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor,
		    DWORD startupFlags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);

STDAPI
CorBindToRuntime (LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor,
		  REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);

HMODULE WINAPI
MonoLoadImage (LPCWSTR FileName);

void mono_coree_set_act_ctx (const char *file_name);
#endif /* HOST_WIN32 */

#endif /* __MONO_COREE_INTERNALS_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/coree.h`:

```h
/**
 * \file
 * mscoree.dll functions
 *
 * Author:
 *   Kornel Pal <http://www.kornelpal.hu/>
 *
 * Copyright (C) 2008 Kornel Pal
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_COREE_H__
#define __MONO_COREE_H__

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32

#include <mono/utils/mono-compiler.h>
#include <mono/utils/w32api.h>
#include "image.h"
#include "image-internals.h"

#define STATUS_SUCCESS 0x00000000L
#define STATUS_INVALID_IMAGE_FORMAT 0xC000007BL

MONO_API HRESULT STDAPICALLTYPE MonoFixupCorEE(HMODULE ModuleHandle);

/* Defined by the linker. */
#ifndef _MSC_VER
#ifdef __MINGW64_VERSION_MAJOR
#define __ImageBase __MINGW_LSYMBOL(_image_base__)
#else
#define __ImageBase _image_base__
#endif
#endif
G_BEGIN_DECLS extern IMAGE_DOS_HEADER __ImageBase; G_END_DECLS
extern HMODULE coree_module_handle;

HMODULE WINAPI MonoLoadImage(LPCWSTR FileName);
STDAPI MonoFixupExe(HMODULE ModuleHandle);

gchar* mono_get_module_file_name (HMODULE module_handle);
void mono_load_coree (const char* file_name);
void mono_fixup_exe_image (MonoImage* image);

/* Declared in image.c. */
MonoImage* mono_image_open_from_module_handle (MonoAssemblyLoadContext *alc, HMODULE module_handle, char* fname, gboolean has_entry_point, MonoImageOpenStatus* status);

#endif /* HOST_WIN32 */

#endif /* __MONO_COREE_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/culture-info-tables.h`:

```h

/* This is a generated file. Do not edit. See tools/locale-builder. */
#ifndef MONO_METADATA_CULTURE_INFO_TABLES
#define MONO_METADATA_CULTURE_INFO_TABLES 1


#define NUM_CULTURE_ENTRIES 341
#define NUM_REGION_ENTRIES 136


static const DateTimeFormatEntry datetime_format_entries [] = {
	{1, 0, 0, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, 0, 6, 1, 3, {9,18,0,0,0,0,0,0,0,0,0,0,0,0},{29,42,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 5, 8, {177, 190, 211, 226, 237, 256, 267}, {280, 285, 290, 295, 300, 305, 310}, {315, 318, 321, 324, 327, 318, 324}, {330, 343, 360, 369, 380, 387, 394, 401, 414, 433, 450, 465, 0}, {330, 343, 360, 369, 380, 387, 394, 401, 414, 433, 450, 465, 0}, {482, 489, 360, 496, 380, 387, 394, 503, 510, 517, 524, 531, 0}, {482, 489, 360, 496, 380, 387, 394, 503, 510, 517, 524, 531, 0}, 2, 1, 11, 3, {116,131,147,163,0,0,0,0,0,0,0,0,0,0},{180,199,217,242,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{279,0,0,0,0,0,0,0}},
	{109, 13, 19, {538, 547, 555, 563, 572, 579, 589}, {598, 602, 606, 610, 614, 618, 622}, {626, 629, 632, 635, 638, 641, 644}, {647, 653, 660, 666, 672, 677, 682, 689, 695, 704, 712, 721, 0}, {730, 739, 749, 758, 768, 776, 784, 794, 804, 816, 828, 840, 0}, {852, 857, 660, 863, 672, 677, 868, 873, 877, 882, 887, 892, 0}, {852, 857, 660, 863, 672, 677, 868, 873, 877, 882, 887, 892, 0}, 2, 1, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{315,338,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {967, 974, 981, 988, 995, 1002, 1009}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {379,388,397,406,417,428,439,446,453,460,0,0,0,0},{469,491,519,547,562,0,0,0,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {967, 974, 981, 988, 995, 1002, 1009}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {379,388,397,406,417,428,439,446,453,460,0,0,0,0},{469,491,519,547,562,0,0,0,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{673, 39, 44, {1197, 1205, 1215, 1223, 1231, 1240, 1247}, {1254, 1257, 1260, 1264, 1267, 1271, 1275}, {1278, 1280, 1282, 1285, 1287, 1280, 1285}, {1290, 1296, 1302, 1310, 1316, 1324, 1332, 1342, 1348, 1356, 1364, 1373, 0}, {1382, 1388, 1395, 1403, 1409, 1417, 1425, 1435, 1348, 1441, 1449, 1459, 0}, {1468, 1472, 1477, 1482, 1486, 1491, 1496, 1501, 1505, 1511, 1517, 1521, 0}, {1468, 1472, 1477, 1482, 1486, 1491, 1496, 1501, 1505, 1511, 1517, 1521, 0}, 2, 1, 11, 3, {681,692,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 49, 52, {1525, 1533, 1540, 1548, 1555, 1563, 1570}, {1578, 1583, 1587, 1591, 1595, 1599, 1603}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 1633, 1639, 1645, 1649, 1654, 1659, 1666, 1676, 1684, 1693, 0}, {1618, 1625, 1633, 1639, 1645, 1649, 1654, 1659, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {744,755,417,764,0,0,0,0,0,0,0,0,0,0},{721,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 57, 63, {1747, 1755, 1762, 1771, 1780, 1791, 1799}, {1807, 1810, 1813, 1816, 1819, 1822, 1825}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {681,775,417,784,0,0,0,0,0,0,0,0,0,0},{798,721,817,0,0,0,0,0,0,0},{71,830,0,0,0,0,0,0,0,0,0,0},{89,842,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 70, 77, {1959, 1974, 1989, 2000, 2015, 2028, 2047}, {2062, 2069, 2076, 2083, 2090, 2097, 2104}, {2111, 2114, 2117, 2117, 2120, 2120, 2123}, {2126, 2147, 2170, 2185, 2202, 2213, 2228, 2243, 2262, 2285, 2304, 2323, 0}, {2344, 2365, 2388, 2403, 2420, 2431, 2446, 2461, 2480, 2503, 2522, 2541, 0}, {2562, 2569, 2576, 2583, 2590, 2597, 2606, 2615, 2622, 2629, 2636, 2643, 0}, {2562, 2569, 2576, 2583, 2590, 2597, 2606, 2615, 2622, 2629, 2636, 2643, 0}, 2, 1, 1, 3, {295,18,857,9,864,417,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {932,941,948,957,460,417,968,0,0,0,0,0,0,0},{978,997,1010,1029,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1042, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 2890, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, 0, 1, 1, 3, {18,9,1054,857,1062,755,775,417,0,0,0,0,0,0},{1069,1097,1124,0,0,0,0,0,0,0},{266,71,1146,1151,1157,0,0,0,0,0,0,0},{271,89,1165,1173,1182,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{673, 84, 88, {2997, 3009, 3021, 3031, 3045, 3055, 3067}, {3078, 3081, 3084, 3087, 3090, 3093, 3096}, {1285, 1608, 1610, 3099, 1610, 1280, 1616}, {3101, 3110, 3119, 3129, 3138, 3147, 3156, 3166, 3173, 3181, 3189, 3199, 0}, {3208, 3219, 3230, 3242, 3253, 3264, 3275, 3287, 3296, 3306, 3316, 3328, 0}, {3339, 3345, 3351, 3358, 3364, 3370, 3376, 3383, 3387, 3392, 3397, 3404, 0}, {3339, 3345, 3351, 3358, 3364, 3370, 3376, 3383, 3387, 3392, 3397, 3404, 0}, 2, 1, 11, 11, {1208,0,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{1146,0,0,0,0,0,0,0,0,0,0,0},{1165,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 1, 1, 3, {18,9,775,755,417,0,0,0,0,0,0,0,0,0},{1217,894,1234,0,0,0,0,0,0,0},{71,266,1151,1243,1253,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 92, 105, {3596, 3614, 3628, 3646, 3664, 3682, 3698}, {3712, 3724, 3736, 3748, 3760, 3772, 3784}, {3791, 3796, 3801, 3806, 3811, 3816, 3821}, {3826, 3837, 3850, 3857, 3868, 3875, 3884, 3893, 3906, 3919, 3934, 3947, 0}, {3826, 3837, 3850, 3857, 3868, 3875, 3884, 3893, 3906, 3919, 3934, 3947, 0}, {3958, 3967, 3850, 3976, 3868, 3875, 3884, 3985, 3994, 4003, 4012, 4021, 0}, {3958, 3967, 3850, 3976, 3868, 3875, 3884, 3985, 3994, 4003, 4012, 4021, 0}, 0, 0, 1, 3, {18,1261,9,29,755,744,1274,417,1287,1304,0,0,0,0},{1314,1261,1332,1354,1287,0,0,0,0,0},{71,62,0,0,0,0,0,0,0,0,0,0},{89,77,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1375, 116, 120, {4030, 4040, 4048, 4053, 4060, 4073, 4081}, {2894, 4089, 3099, 4091, 4095, 1280, 4098}, {2894, 4089, 3099, 4102, 4095, 1280, 4102}, {4105, 4113, 4122, 4131, 4140, 4147, 4155, 4163, 4173, 4184, 1684, 1693, 0}, {4105, 4113, 4122, 4131, 4140, 4147, 4155, 4163, 4173, 4184, 1684, 1693, 0}, {1702, 857, 4193, 4200, 4206, 4212, 4218, 1727, 4224, 1737, 887, 1742, 0}, {1702, 857, 4193, 4200, 4206, 4212, 4218, 1727, 4224, 1737, 887, 1742, 0}, 2, 1, 124, 3, {1383,1397,0,0,0,0,0,0,0,0,0,0,0,0},{1410,1430,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{1444,0,0,0,0,0,0,0}},
	{673, 127, 132, {4231, 4242, 4253, 4267, 4281, 4293, 4305}, {4317, 4322, 4328, 4334, 4340, 4345, 4351}, {1285, 1608, 4356, 1608, 1614, 1614, 1616}, {4359, 4367, 3504, 4376, 4383, 4388, 4395, 4402, 1666, 4184, 4410, 4420, 0}, {4359, 4367, 3504, 4376, 4383, 4388, 4395, 4402, 1666, 4184, 4410, 4420, 0}, {1702, 1707, 1712, 1717, 4383, 4212, 4218, 4429, 1732, 1737, 4436, 892, 0}, {1702, 1707, 1712, 1717, 4383, 4212, 4218, 4429, 1732, 1737, 4436, 892, 0}, 2, 1, 11, 3, {1208,1455,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {4442, 4451, 4459, 4468, 4479, 4488, 4497}, {4504, 4508, 4512, 4516, 4520, 4524, 4528}, {1828, 1616, 1608, 1608, 4532, 2894, 1285}, {4534, 4542, 2910, 4551, 4558, 4565, 4572, 2933, 4579, 4589, 712, 4597, 0}, {4534, 4542, 2910, 4551, 4558, 4565, 4572, 2933, 4579, 4589, 712, 4597, 0}, {4606, 4610, 4512, 4614, 4618, 4622, 4626, 4630, 4634, 4638, 4642, 4646, 0}, {4606, 4610, 4512, 4614, 4618, 4622, 4626, 4630, 4634, 4638, 4642, 4646, 0}, 2, 1, 1, 3, {18,864,9,1467,857,0,0,0,0,0,0,0,0,0},{1217,1475,894,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{370, 137, 144, {4650, 4660, 4670, 4680, 4690, 4700, 4710}, {1016, 4720, 4724, 4728, 4732, 4736, 4740}, {1016, 4720, 4724, 4728, 4732, 4736, 4740}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, 0, 0, 1, 3, {406,460,439,379,417,0,0,0,0,0,0,0,0,0},{469,1484,1508,1535,1564,1588,1617,1637,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{623,1662,652,0,0,0,0,0}},
	{1680, 151, 158, {4771, 4781, 4791, 4801, 4811, 4821, 4831}, {4841, 4845, 4849, 4853, 4857, 4861, 4865}, {4841, 4845, 4849, 4853, 4857, 4861, 4865}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, 0, 0, 55, 3, {417,1690,446,388,0,0,0,0,0,0,0,0,0,0},{1699,1728,1752,1779,1801,1832,1858,1889,1915,1942},{583,591,266,71,0,0,0,0,0,0,0,0},{600,611,271,89,0,0,0,0,0},{1964,1981,2000,0,0,0,0,0}},
	{109, 165, 170, {4932, 4939, 4947, 4955, 4964, 4974, 4982}, {4991, 3081, 4994, 4997, 5000, 5003, 5006}, {5009, 1608, 1828, 2735, 1828, 2894, 5009}, {5011, 5019, 5028, 1639, 5034, 1649, 1654, 5038, 1666, 1676, 1684, 1693, 0}, {5011, 5019, 5028, 1639, 5034, 1649, 1654, 5038, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 5047, 1717, 5034, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 5047, 1717, 5034, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {2015,1062,755,9,775,2024,417,0,0,0,0,0,0,0},{1217,1475,894,1234,0,0,0,0,0,0},{71,266,1146,2036,2048,0,0,0,0,0,0,0},{89,271,2060,2075,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{2090, 165, 170, {1525, 1533, 1540, 1548, 1555, 1563, 1570}, {5052, 5058, 5063, 5068, 5073, 5078, 5083}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 0, 0, 11, 11, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {5117, 5127, 5141, 5148, 5155, 5164, 1247}, {5172, 5179, 5184, 5188, 5193, 5198, 5202}, {1278, 1280, 2735, 5207, 5210, 1280, 1285}, {5212, 5221, 5226, 5233, 1645, 5243, 5252, 5259, 5269, 5279, 1364, 5292, 0}, {5302, 5311, 5318, 5324, 5333, 5338, 5346, 5352, 5361, 5371, 5385, 5395, 0}, {5403, 5407, 4512, 5411, 1645, 5415, 5419, 5423, 5427, 5431, 1517, 5436, 0}, {5403, 5407, 4512, 5411, 1645, 5415, 5419, 5423, 5427, 5431, 1517, 5436, 0}, 2, 1, 11, 3, {681,0,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1042, 49, 52, {2803, 5440, 5454, 5467, 5480, 5493, 2850}, {4504, 5505, 5509, 5513, 5517, 5521, 5525}, {1828, 1285, 1610, 5530, 5530, 1285, 1285}, {5532, 5540, 5550, 666, 5557, 5562, 5568, 2933, 5574, 5583, 5591, 5600, 0}, {5532, 5540, 5550, 666, 5557, 5562, 5568, 2933, 5574, 5583, 5591, 5600, 0}, {5089, 5609, 4512, 5613, 3515, 5093, 5097, 4630, 4634, 5617, 4642, 5621, 0}, {5089, 5609, 4512, 5613, 3515, 5093, 5097, 4630, 4634, 5617, 4642, 5621, 0}, 0, 0, 1, 3, {18,9,295,857,755,744,1062,2015,775,681,2024,2098,1208,417},{1069,1124,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{673, 49, 52, {5625, 5634, 3425, 5644, 5652, 5660, 5669}, {5675, 5678, 3081, 5682, 5685, 5689, 1275}, {1828, 4532, 1608, 1608, 4532, 2894, 1285}, {5692, 5700, 3504, 5707, 5714, 5719, 5729, 5737, 5743, 5753, 1684, 1693, 0}, {5692, 5700, 3504, 5707, 5714, 5719, 5729, 5737, 5743, 5753, 1684, 1693, 0}, {5761, 5768, 3504, 3579, 5714, 5774, 5781, 5737, 5786, 882, 887, 1742, 0}, {5761, 5768, 3504, 3579, 5714, 5774, 5781, 5737, 5786, 882, 887, 1742, 0}, 2, 1, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{2105,2134,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 165, 170, {5792, 5802, 5807, 5814, 5823, 5827, 5834}, {5845, 2863, 1712, 5850, 5823, 5855, 5860}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {5866, 5875, 5885, 5892, 3515, 5900, 5906, 1659, 5912, 5923, 5933, 5943, 0}, {5866, 5875, 5885, 5892, 3515, 5900, 5906, 1659, 5912, 5923, 5933, 5943, 0}, {5953, 1707, 1712, 1717, 3515, 5958, 5963, 1727, 2986, 882, 887, 1742, 0}, {5953, 1707, 1712, 1717, 3515, 5958, 5963, 1727, 2986, 882, 887, 1742, 0}, 0, 1, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 175, 180, {5968, 5991, 211, 6014, 6025, 6040, 6055}, {6070, 285, 290, 295, 300, 305, 310}, {6075, 6078, 6075, 6081, 6084, 6078, 6081}, {6087, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {6206, 6219, 6234, 6245, 6258, 6265, 6274, 6283, 6298, 6315, 6330, 6343, 0}, {6358, 6366, 360, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, {6358, 6366, 360, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, 0, 1, 11, 3, {681,775,2098,744,9,0,0,0,0,0,0,0,0,0},{199,180,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 49, 52, {6428, 6437, 6449, 6456, 6464, 6474, 6480}, {6487, 6491, 6495, 6499, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {6527, 6537, 6546, 6554, 6562, 6570, 6577, 6584, 6592, 1364, 6598, 6606, 0}, {6615, 6625, 6634, 6642, 6650, 6658, 6665, 6672, 6681, 5385, 6687, 6697, 0}, {6706, 6710, 6715, 6720, 6724, 5419, 1501, 6728, 6732, 1517, 6736, 1521, 0}, {6706, 6710, 6715, 6720, 6724, 5419, 1501, 6728, 6732, 1517, 6736, 1521, 0}, 0, 1, 11, 3, {2151,2161,2169,2181,2193,2203,2213,417,0,0,0,0,0,0},{2225,2239,2254,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{673, 49, 52, {6740, 6748, 6757, 6764, 6771, 6780, 1247}, {1254, 1257, 6787, 1264, 6790, 6794, 1275}, {6516, 6518, 6520, 6522, 6797, 6518, 6522}, {4105, 4113, 6800, 4376, 6806, 6811, 6816, 1659, 1666, 4184, 1684, 1693, 0}, {6821, 6830, 5318, 6840, 6848, 6854, 6860, 6866, 6874, 6884, 6893, 6902, 0}, {5089, 4610, 4512, 4614, 6806, 6811, 6816, 5101, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 6806, 6811, 6816, 5101, 5105, 5109, 4642, 6911, 0}, 2, 1, 11, 3, {681,692,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 185, 197, {6915, 6922, 6931, 6940, 6952, 6960, 6969}, {6979, 6983, 2791, 6988, 6993, 6997, 7001}, {1828, 4089, 1608, 1608, 7005, 1280, 1285}, {7007, 7013, 7020, 7025, 7031, 7035, 7043, 7050, 7056, 7064, 7070, 7078, 0}, {7086, 7092, 3504, 7099, 1645, 7105, 7113, 7120, 7126, 7134, 7140, 7148, 0}, {1914, 7156, 2791, 7160, 7031, 7164, 7168, 7172, 7001, 7176, 7180, 7185, 0}, {1914, 7156, 2791, 7160, 7031, 7164, 7168, 7172, 7001, 7176, 7180, 7185, 0}, 0, 1, 11, 3, {1208,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{2274, 208, 211, {7189, 7197, 7205, 1548, 1555, 1563, 7212}, {7220, 7225, 7230, 1591, 7234, 1599, 7239}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {5011, 5019, 3504, 1639, 1645, 1649, 1654, 7244, 1666, 1676, 1684, 1693, 0}, {5011, 5019, 3504, 1639, 1645, 1649, 1654, 7244, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 3504, 1717, 1645, 1649, 1654, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 3504, 1717, 1645, 1649, 1654, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {417,1690,0,0,0,0,0,0,0,0,0,0,0,0},{2287,2305,0,0,0,0,0,0,0,0},{71,266,2328,0,0,0,0,0,0,0,0,0},{89,271,2338,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 0, 0, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, 0, 0, 1, 3, {295,857,9,18,304,2351,417,0,0,0,0,0,0,0},{894,2363,2379,0,0,0,0,0,0,0},{266,71,906,62,0,0,0,0,0,0,0,0},{271,89,914,77,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 214, 219, {7252, 7258, 7268, 7274, 7285, 7295, 7300}, {7310, 7314, 7318, 7322, 7327, 7331, 7335}, {1280, 1280, 1285, 7339, 1280, 5210, 5210}, {7342, 7347, 7354, 7359, 7365, 7372, 7380, 7387, 7396, 7403, 7408, 7415, 0}, {7342, 7347, 7354, 7359, 7365, 7372, 7380, 7387, 7396, 7403, 7408, 7415, 0}, {7423, 7427, 2791, 7432, 2760, 7436, 7440, 7444, 7449, 7453, 7457, 7461, 0}, {7423, 7427, 2791, 7432, 2760, 7436, 7440, 7444, 7449, 7453, 7457, 7461, 0}, 0, 1, 11, 3, {2421,304,0,0,0,0,0,0,0,0,0,0,0,0},{2431,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 49, 52, {7465, 7476, 7489, 7498, 7505, 7518, 7527}, {7465, 7476, 7489, 7498, 7505, 7518, 7527}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, 0, 0, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {7660, 7667, 7673, 7680, 7685, 7691, 7697}, {7703, 7707, 7711, 7715, 7719, 7723, 7727}, {1608, 1285, 1285, 7731, 3099, 2892, 1285}, {7733, 7741, 7750, 1851, 7756, 1861, 1866, 7760, 1878, 1888, 1896, 7768, 0}, {7733, 7741, 7750, 1851, 7756, 1861, 1866, 7760, 1878, 1888, 1896, 7768, 0}, {1914, 1918, 2791, 1927, 7756, 1931, 1935, 7777, 1943, 1947, 1951, 7781, 0}, {1914, 1918, 2791, 1927, 7756, 1931, 1935, 7777, 1943, 1947, 1951, 7781, 0}, 0, 0, 1, 11, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{2462,894,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 223, 228, {7785, 7798, 7817, 7834, 7847, 7860, 7877}, {280, 285, 290, 295, 300, 305, 310}, {7890, 6078, 6075, 6081, 6084, 6078, 6081}, {7893, 7906, 7917, 7934, 7949, 7964, 7979, 7992, 8007, 8024, 8039, 8056, 0}, {8071, 8082, 8095, 8110, 8123, 8136, 8149, 8160, 8173, 8188, 8201, 8220, 0}, {8233, 8240, 8247, 8254, 8261, 8268, 8275, 8282, 8289, 8296, 8303, 8310, 0}, {8233, 8240, 8247, 8254, 8261, 8268, 8275, 8282, 8289, 8296, 8303, 8310, 0}, 0, 1, 11, 3, {681,775,417,0,0,0,0,0,0,0,0,0,0,0},{2481,0,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{2499,0,0,0,0,0,0,0}},
	{109, 49, 52, {8317, 8332, 8353, 8368, 8381, 8394, 7877}, {280, 285, 8409, 295, 8414, 305, 310}, {315, 318, 8419, 324, 327, 318, 324}, {8422, 8439, 8448, 8463, 380, 8480, 8495, 8508, 8523, 8540, 8561, 8578, 0}, {8593, 8610, 8623, 8640, 6258, 8659, 8674, 8687, 8700, 8715, 8738, 8757, 0}, {8770, 8240, 8777, 8784, 380, 8791, 8798, 8805, 8289, 8812, 8819, 8826, 0}, {8770, 8240, 8777, 8784, 380, 8791, 8798, 8805, 8289, 8812, 8819, 8826, 0}, 0, 1, 11, 3, {775,0,0,0,0,0,0,0,0,0,0,0,0,0},{894,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{2515,0,0,0,0,0,0,0}},
	{673, 39, 233, {8833, 8841, 8852, 8858, 8864, 8873, 1247}, {8879, 5179, 5073, 8884, 8889, 8895, 5202}, {6516, 6518, 8900, 6522, 6524, 6518, 6522}, {1618, 1625, 6800, 1639, 1645, 8902, 8908, 8914, 1666, 1676, 1684, 1693, 0}, {1618, 1625, 6800, 1639, 1645, 8902, 8908, 8914, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 8921, 1732, 1737, 887, 1742, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 8921, 1732, 1737, 887, 1742, 0}, 0, 1, 124, 3, {2529,1455,0,0,0,0,0,0,0,0,0,0,0,0},{2541,2561,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 49, 52, {8926, 8937, 8948, 8959, 8970, 8981, 8987}, {1280, 7005, 1610, 3099, 1278, 7731, 1616}, {1280, 7005, 1610, 3099, 1278, 7731, 1616}, {8996, 9004, 9013, 9020, 3515, 9027, 9033, 1659, 1666, 9039, 1684, 9048, 0}, {8996, 9004, 9013, 9020, 3515, 9027, 9033, 1659, 1666, 9039, 1684, 9048, 0}, {9058, 9063, 9013, 4614, 3515, 9027, 9033, 5101, 9069, 5109, 4642, 9074, 0}, {9058, 9063, 9013, 4614, 3515, 9027, 9033, 5101, 9069, 5109, 4642, 9074, 0}, 2, 1, 11, 3, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{2575,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 238, 248, {9079, 9090, 9100, 9109, 9120, 9132, 9143}, {9153, 9161, 9168, 9174, 9182, 9191, 9199}, {1285, 1280, 1612, 1610, 5210, 1280, 1285}, {9206, 9216, 1633, 9227, 9236, 9242, 9250, 9258, 9266, 9277, 9286, 9296, 0}, {9206, 9216, 1633, 9227, 9236, 9242, 9250, 9258, 9266, 9277, 9286, 9296, 0}, {3566, 857, 1633, 1717, 9236, 9306, 9312, 1727, 2986, 1737, 887, 1742, 0}, {3566, 857, 1633, 1717, 9236, 9306, 9312, 1727, 2986, 1737, 887, 1742, 0}, 0, 1, 11, 3, {681,2583,0,0,0,0,0,0,0,0,0,0,0,0},{2603,2630,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2651,0,0,0,0,0,0,0}},
	{925, 255, 266, {9318, 9330, 9342, 9354, 9368, 9383, 9396}, {9410, 9413, 9416, 9419, 9422, 9425, 6790}, {1285, 1280, 9428, 1610, 3099, 1280, 9430}, {9433, 9440, 9448, 9454, 9463, 9472, 9482, 9488, 9499, 9509, 9516, 9526, 0}, {9534, 9541, 9549, 9554, 9565, 9575, 9585, 9592, 9604, 9613, 9620, 9631, 0}, {9641, 9647, 9652, 9657, 9662, 9667, 9674, 9680, 9686, 9692, 9698, 9705, 0}, {9641, 9647, 9652, 9657, 9662, 9667, 9674, 9680, 9686, 9692, 9698, 9705, 0}, 2, 1, 55, 3, {417,0,0,0,0,0,0,0,0,0,0,0,0,0},{2667,2695,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 273, 285, {9712, 9727, 9742, 9757, 9774, 9793, 9804}, {9815, 9822, 9829, 9836, 9843, 9850, 9857}, {0, 0, 0, 0, 0, 0, 0}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 0, 11, 3, {681,775,2098,744,9,0,0,0,0,0,0,0,0,0},{2727,2745,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 297, 304, {10057, 10070, 10083, 10099, 10116, 10131, 10140}, {10057, 10070, 10083, 10099, 10116, 10131, 10140}, {10149, 10152, 10155, 10158, 10161, 10164, 10167}, {10170, 10183, 10194, 10203, 10214, 10219, 10228, 10239, 10246, 10261, 10272, 10285, 0}, {10298, 10313, 10194, 10203, 10326, 10219, 10333, 10239, 10246, 10261, 10272, 10285, 0}, {10170, 10183, 10194, 10203, 10214, 10219, 10228, 10239, 10246, 10261, 10272, 10285, 0}, {10170, 10183, 10194, 10203, 10214, 10219, 10228, 10239, 10246, 10261, 10272, 10285, 0}, 0, 6, 1, 3, {18,9,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 311, 314, {10346, 10359, 10369, 10378, 10388, 10399, 10410}, {10422, 10425, 10430, 10435, 10440, 10445, 10450}, {10422, 10455, 10458, 10461, 10464, 10467, 10470}, {10473, 10482, 10491, 10500, 10509, 10518, 10527, 10536, 10545, 10554, 10564, 10574, 0}, {10584, 10593, 10602, 10611, 10620, 10629, 10638, 10647, 10656, 10665, 10675, 10685, 0}, {10695, 10701, 10707, 10713, 10719, 10725, 10731, 10737, 10743, 10749, 10756, 10763, 0}, {10695, 10701, 10707, 10713, 10719, 10725, 10731, 10737, 10743, 10749, 10756, 10763, 0}, 0, 1, 1, 3, {18,9,755,744,417,0,0,0,0,0,0,0,0,0},{1261,0,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 317, 322, {10770, 10783, 10804, 10823, 10844, 10863, 10876}, {10887, 10894, 10901, 10908, 10915, 10922, 10929}, {10936, 10939, 10939, 10942, 10945, 10948, 10951}, {10954, 10969, 10984, 10993, 11004, 11015, 11028, 11041, 11056, 11075, 11094, 11111, 0}, {11130, 11147, 11164, 11175, 11188, 11201, 11216, 11231, 11248, 11269, 11290, 11309, 0}, {11330, 11337, 11344, 11351, 11358, 11365, 11372, 11379, 11386, 11393, 11400, 11407, 0}, {11330, 11337, 11344, 11351, 11358, 11365, 11372, 11379, 11386, 11393, 11400, 11407, 0}, 0, 1, 11, 3, {681,775,2764,18,2774,864,417,0,0,0,0,0,0,0},{1029,876,2462,1261,2785,2796,2808,2825,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {11414, 11420, 11434, 11457, 11471, 11487, 11494}, {11503, 11506, 11511, 11517, 11521, 11526, 11529}, {4756, 4744, 4746, 4748, 4750, 4752, 4754}, {11533, 11540, 7354, 11547, 2760, 11553, 11559, 11565, 11572, 11581, 11589, 11596, 0}, {11603, 11610, 11617, 11622, 11628, 11632, 11637, 11642, 11649, 11658, 11666, 11673, 0}, {11680, 5609, 4512, 4614, 11628, 11684, 11688, 11692, 11696, 5109, 11700, 11704, 0}, {11680, 5609, 4512, 4614, 11628, 11684, 11688, 11692, 11696, 5109, 11700, 11704, 0}, 0, 0, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{2843,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {11708, 11716, 11727, 11737, 11748, 11757, 11766}, {11776, 11780, 11784, 11788, 11792, 11796, 11800}, {11804, 9428, 9428, 9428, 1612, 1612, 1616}, {11806, 11816, 11824, 11832, 11840, 11848, 11855, 11863, 11871, 11878, 11884, 11891, 0}, {11806, 11899, 11907, 11915, 11923, 11931, 11938, 11946, 11954, 11961, 11967, 11974, 0}, {11982, 11987, 1712, 11992, 11997, 12002, 12007, 12012, 12017, 12022, 12027, 12032, 0}, {11982, 11987, 1712, 11992, 11997, 12002, 12007, 12012, 12017, 12022, 12027, 12032, 0}, 2, 1, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2872,2899,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2920,0,0,0,0,0,0,0}},
	{673, 327, 338, {12037, 12047, 12058, 12065, 12072, 12082, 1247}, {12088, 12092, 12097, 12101, 12105, 12110, 12114}, {6516, 6518, 12118, 6522, 6797, 6518, 6522}, {1618, 1625, 12120, 12126, 12132, 8902, 8908, 12137, 1666, 1676, 12144, 1693, 0}, {12153, 12161, 12170, 12177, 12184, 12189, 12196, 12203, 6874, 12211, 12219, 6902, 0}, {5089, 4610, 12228, 4614, 12233, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, {5089, 4610, 12228, 4614, 12233, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, 2, 1, 11, 3, {1208,0,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{2939,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 349, 363, {12245, 190, 211, 6014, 12258, 12275, 12286}, {12299, 12307, 12315, 12323, 12331, 12339, 12347}, {315, 318, 321, 324, 327, 318, 324}, {12355, 343, 360, 369, 12370, 12377, 12386, 401, 414, 433, 450, 465, 0}, {12355, 343, 360, 369, 12370, 12377, 12386, 401, 414, 433, 450, 465, 0}, {12395, 12403, 12411, 6376, 12370, 12419, 12427, 6384, 12435, 6402, 12445, 6420, 0}, {12395, 12403, 12411, 6376, 12370, 12419, 12427, 6384, 12435, 6402, 12445, 6420, 0}, 0, 1, 11, 3, {2953,0,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2963,0,0,0,0,0,0,0}},
	{925, 0, 0, {12455, 12463, 12472, 12481, 12490, 12497, 12507}, {12516, 12520, 12524, 12528, 12532, 12535, 12539}, {0, 0, 0, 0, 0, 0, 0}, {12543, 12554, 12562, 12572, 12578, 12590, 12599, 12605, 12611, 12619, 12628, 12640, 0}, {12543, 12554, 12562, 12572, 12578, 12590, 12599, 12605, 12611, 12619, 12628, 12640, 0}, {12648, 12652, 12656, 12660, 12664, 1914, 12668, 12672, 12676, 12680, 12684, 12688, 0}, {12648, 12652, 12656, 12660, 12664, 1914, 12668, 12672, 12676, 12680, 12684, 12688, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 0, 0, {12692, 12698, 12711, 12722, 12733, 12742, 12754}, {12516, 12764, 12768, 12772, 12532, 12776, 12780}, {0, 0, 0, 0, 0, 0, 0}, {12784, 12792, 12804, 12816, 12828, 12838, 12850, 12859, 12867, 12875, 12885, 12892, 0}, {12784, 12792, 12804, 12816, 12828, 12838, 12850, 12859, 12867, 12875, 12885, 12892, 0}, {2707, 12906, 12910, 12914, 12918, 12922, 12926, 12930, 12934, 12938, 12942, 12946, 0}, {2707, 12906, 12910, 12914, 12918, 12922, 12926, 12930, 12934, 12938, 12942, 12946, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 0, 0, {12950, 12957, 12472, 12968, 12490, 12977, 12988}, {12688, 12998, 12524, 12528, 12532, 13002, 13006}, {0, 0, 0, 0, 0, 0, 0}, {13010, 13020, 13029, 13037, 13046, 13059, 13071, 13078, 13085, 13092, 13102, 13114, 0}, {13010, 13020, 13029, 13037, 13046, 13059, 13071, 13078, 13085, 13092, 13102, 13114, 0}, {13127, 12776, 13131, 13135, 12664, 13139, 13143, 12672, 13147, 13151, 13155, 13159, 0}, {13127, 12776, 13131, 13135, 12664, 13139, 13143, 12672, 13147, 13151, 13155, 13159, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 0, 0, {13163, 13168, 13174, 13184, 13196, 13204, 13215}, {13224, 13228, 13232, 13236, 13240, 12535, 13244}, {0, 0, 0, 0, 0, 0, 0}, {13248, 13258, 13268, 13275, 13282, 1861, 13287, 13294, 13301, 13310, 13318, 13326, 0}, {13248, 13258, 13268, 13275, 13282, 1861, 13287, 13294, 13301, 13310, 13318, 13326, 0}, {1914, 1918, 13006, 13334, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 13006, 13334, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 49, 52, {13350, 13357, 13369, 13380, 13393, 13402, 13414}, {12516, 13424, 13428, 13236, 13240, 12535, 13244}, {1285, 1608, 13432, 1610, 1285, 4089, 1608}, {13434, 13258, 13443, 13449, 13282, 1861, 13287, 13294, 13457, 13310, 13318, 13326, 0}, {13467, 13258, 13443, 13449, 13282, 1861, 13287, 13294, 13457, 13310, 13318, 13326, 0}, {1914, 1918, 13478, 13482, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 13478, 13482, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, 0, 0, 1, 3, {932,3009,0,0,0,0,0,0,0,0,0,0,0,0},{978,997,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 373, 377, {13486, 13493, 13501, 13509, 13518, 13528, 13535}, {13544, 13548, 13552, 13556, 13560, 13564, 13568}, {1285, 1608, 1828, 2735, 1828, 2894, 1285}, {13572, 13581, 13591, 1851, 7756, 13597, 13603, 13609, 1878, 1888, 1896, 7768, 0}, {13572, 13581, 13591, 1851, 7756, 13597, 13603, 13609, 1878, 1888, 1896, 7768, 0}, {13618, 13623, 13628, 13633, 7756, 13638, 13643, 13648, 13653, 13658, 13663, 13668, 0}, {13618, 13623, 13628, 13633, 7756, 13638, 13643, 13648, 13653, 13658, 13663, 13668, 0}, 0, 0, 55, 3, {417,2351,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {13673, 13689, 13714, 13742, 13770, 13798, 13826}, {13845, 13855, 13865, 13875, 13885, 13895, 13905}, {13915, 13919, 13923, 13919, 13927, 13931, 13935}, {13939, 13961, 13989, 14005, 14024, 14040, 14059, 14078, 14100, 14131, 14159, 14184, 0}, {13939, 13961, 13989, 14005, 14024, 14040, 14059, 14078, 14100, 14131, 14159, 14184, 0}, {14212, 14222, 14232, 14242, 14252, 14262, 14272, 14282, 14292, 14302, 14312, 14322, 0}, {14212, 14222, 14232, 14242, 14252, 14262, 14272, 14282, 14292, 14302, 14312, 14322, 0}, 0, 1, 11, 3, {681,3021,0,0,0,0,0,0,0,0,0,0,0,0},{42,1029,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 49, 52, {4231, 14332, 14343, 14353, 14363, 14373, 14387}, {14399, 14403, 14408, 14413, 14417, 14422, 14427}, {1285, 1608, 1610, 1608, 4089, 1614, 1616}, {1618, 1625, 3504, 4376, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 4376, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 2, 1, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{1314,1455,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 381, 409, {14431, 14450, 14469, 14491, 14510, 14532, 14557}, {14576, 14586, 14596, 14609, 14619, 14632, 14648}, {14658, 14662, 14669, 14676, 14683, 14690, 14697}, {14701, 14717, 14736, 14752, 14771, 14778, 14788, 14804, 14820, 14839, 14861, 14877, 0}, {14701, 14717, 14736, 14752, 14771, 14778, 14788, 14804, 14820, 14839, 14861, 14877, 0}, {14896, 14906, 14736, 14752, 14771, 14778, 14919, 14932, 14942, 14955, 14974, 14984, 0}, {14896, 14906, 14736, 14752, 14771, 14778, 14919, 14932, 14942, 14955, 14974, 14984, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{3033, 49, 52, {14997, 15006, 15015, 15025, 15035, 15045, 15057}, {15065, 15070, 15074, 15078, 15082, 15087, 15092}, {15096, 15100, 15103, 15106, 15109, 15113, 15117}, {15120, 15127, 15132, 1851, 15138, 15144, 15151, 15157, 15165, 15175, 15183, 15192, 0}, {15120, 15127, 15132, 1851, 15138, 15144, 15151, 15157, 15165, 15175, 15183, 15192, 0}, {1914, 15202, 2791, 1927, 15206, 15210, 15215, 15219, 15223, 15227, 1951, 15231, 0}, {1914, 15202, 2791, 1927, 15206, 15210, 15215, 15219, 15223, 15227, 1951, 15231, 0}, 0, 0, 1, 3, {18,2351,0,0,0,0,0,0,0,0,0,0,0,0},{3048,3074,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{3094,0,0,0,0,0,0,0}},
	{925, 431, 436, {15236, 15248, 15259, 15273, 15285, 15295, 15305}, {15316, 15321, 15326, 15331, 15336, 15341, 15346}, {1285, 2894, 1608, 4532, 1828, 13432, 1616}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, 2, 1, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{109, 165, 170, {15579, 15593, 15603, 15614, 15628, 15639, 15650}, {15663, 15668, 15673, 15680, 15686, 15692, 15698}, {1828, 1616, 1608, 5210, 1828, 9428, 1285}, {15703, 15711, 15719, 15726, 15735, 15745, 15755, 15761, 15769, 15784, 15802, 15810, 0}, {15703, 15711, 15719, 15726, 15735, 15745, 15755, 15761, 15769, 15784, 15802, 15810, 0}, {15818, 15822, 15719, 15828, 15832, 15837, 15755, 15843, 15848, 15855, 15862, 15867, 0}, {15818, 15822, 15719, 15828, 15832, 15837, 15755, 15843, 15848, 15855, 15862, 15867, 0}, 2, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 441, 444, {15872, 15877, 7673, 7680, 15883, 15890, 7697}, {15897, 15901, 7711, 7715, 15905, 7723, 7727}, {9428, 11804, 1285, 7731, 3099, 2892, 1285}, {7733, 7741, 15909, 1851, 7756, 1931, 15913, 15919, 1878, 1888, 1896, 15924, 0}, {7733, 7741, 15909, 1851, 7756, 1931, 15913, 15919, 1878, 1888, 1896, 15924, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 15933, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 15933, 1943, 1947, 1951, 13346, 0}, 0, 1, 1, 3, {2764,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {15937, 15954, 15971, 15988, 16005, 16022, 16031}, {16042, 16047, 16052, 16057, 16062, 16067, 16072}, {16077, 16080, 6081, 6081, 16083, 16077, 6081}, {16086, 16099, 16110, 16123, 16134, 16145, 16158, 16169, 16180, 16197, 16208, 16221, 0}, {16240, 16253, 16264, 16277, 16288, 16299, 16312, 16323, 16334, 16351, 16362, 16375, 0}, {16394, 16402, 16410, 16418, 16426, 16434, 16442, 16450, 16458, 16466, 16474, 16482, 0}, {16394, 16402, 16410, 16418, 16426, 16434, 16442, 16450, 16458, 16466, 16474, 16482, 0}, 0, 1, 1, 3, {18,3112,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3125, 448, 453, {16490, 16507, 16524, 16541, 16558, 16575, 16584}, {16597, 16605, 16613, 16623, 16633, 16575, 16643}, {16077, 16080, 16651, 16651, 16083, 16077, 16654}, {16657, 16670, 9888, 16685, 9908, 16698, 16707, 9929, 16716, 16733, 16748, 16761, 0}, {6087, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 1, 55, 3, {3132,0,0,0,0,0,0,0,0,0,0,0,0,0},{3141,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{3160,0,0,0,0,0,0,0}},
	{109, 49, 52, {16776, 16785, 16794, 16802, 16811, 16820, 16827}, {16776, 16785, 16794, 16802, 16811, 16820, 16827}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {7733, 7741, 16836, 16842, 7756, 1861, 15913, 16849, 13301, 16856, 13318, 16863, 0}, {7733, 7741, 16836, 16842, 7756, 1861, 15913, 16849, 13301, 16856, 13318, 16863, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 16871, 1943, 1947, 1951, 7781, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 16871, 1943, 1947, 1951, 7781, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 0, 0, {16875, 16886, 16895, 16904, 16915, 16925, 16930}, {16937, 16941, 16944, 16947, 16951, 9416, 16954}, {16958, 1828, 1285, 7339, 1280, 9428, 16961}, {16964, 16972, 11617, 11622, 16979, 16984, 16990, 12137, 16996, 17006, 17015, 11673, 0}, {16964, 16972, 11617, 11622, 16979, 16984, 16990, 12137, 16996, 17006, 17015, 11673, 0}, {17023, 17028, 11617, 4614, 16979, 16984, 16990, 12237, 11696, 5109, 17032, 11704, 0}, {17023, 17028, 11617, 4614, 16979, 16984, 16990, 12237, 11696, 5109, 17032, 11704, 0}, 0, 1, 11, 3, {3176,681,0,0,0,0,0,0,0,0,0,0,0,0},{3191,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{3223,0,0,0,0,0,0,0}},
	{925, 458, 461, {17037, 17047, 17056, 17065, 17076, 17086, 17091}, {17098, 17102, 17107, 17112, 17117, 7723, 17121}, {17126, 1828, 1285, 5210, 1280, 2892, 1285}, {11533, 11540, 7354, 11547, 2760, 17128, 17133, 17138, 17145, 17153, 11589, 11596, 0}, {11603, 11610, 11617, 11622, 11628, 11632, 11637, 8914, 17160, 17168, 11666, 11673, 0}, {12906, 17175, 2791, 1927, 2760, 17179, 17183, 17187, 7707, 1947, 17191, 17195, 0}, {12906, 17175, 2791, 1927, 2760, 17179, 17183, 17187, 7707, 1947, 17191, 17195, 0}, 0, 0, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{109, 49, 52, {17199, 17214, 17229, 17244, 17261, 17282, 17293}, {17304, 17312, 17320, 17328, 17336, 17346, 17354}, {17362, 16080, 6081, 6084, 6078, 17365, 16651}, {17368, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {17368, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {17383, 12403, 12411, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, {17383, 12403, 12411, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, 0, 1, 11, 3, {681,775,2098,9,417,3258,0,0,0,0,0,0,0,0},{3258,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,3278,0,0,0,0,0,0}},
	{109, 49, 52, {17393, 17412, 17431, 17456, 17475, 17509, 17534}, {17553, 17563, 17573, 17589, 17599, 17624, 17640}, {17650, 17654, 17661, 17665, 17672, 17679, 17686}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, 0, 1, 55, 11, {755,1062,744,755,744,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{1151,1146,3295,3304,0,0,0,0,0,0,0,0},{1173,1165,3312,3324,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 464, 479, {17936, 17952, 17971, 17993, 18015, 18034, 18062}, {18093, 18100, 18110, 18123, 18136, 18146, 18165}, {18187, 18191, 18198, 18205, 18215, 18222, 18235}, {18242, 18258, 18277, 18290, 18309, 18316, 18326, 18342, 18355, 18371, 18390, 18406, 0}, {18242, 18258, 18277, 18290, 18309, 18316, 18326, 18342, 18355, 18371, 18390, 18406, 0}, {18422, 18429, 18277, 18439, 18309, 18316, 18455, 18468, 18475, 18485, 18498, 18508, 0}, {18422, 18429, 18277, 18439, 18309, 18316, 18455, 18468, 18475, 18485, 18498, 18508, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{3335,894,0,0,0,0,0,0,0,0},{591,583,266,71,0,0,0,0,0,0,0,0},{611,600,271,89,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 49, 52, {18518, 18537, 18556, 18578, 18597, 18619, 18644}, {18663, 18673, 18683, 18696, 18706, 18719, 18735}, {18745, 18749, 18756, 18763, 18770, 18777, 18784}, {18788, 18816, 18844, 18860, 18879, 18886, 18896, 18912, 18928, 18956, 18978, 19000, 0}, {18788, 18816, 18844, 18860, 18879, 18886, 18896, 18912, 18928, 18956, 18978, 19000, 0}, {19025, 19044, 18844, 18860, 18879, 18886, 18896, 18912, 19063, 19079, 19095, 19105, 0}, {19025, 19044, 18844, 18860, 18879, 18886, 18896, 18912, 19063, 19079, 19095, 19105, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 5, 8, {19118, 19137, 19156, 19181, 19200, 19222, 19247}, {19266, 19276, 19286, 19302, 19312, 19325, 19341}, {19351, 19355, 19362, 19366, 19373, 19380, 19387}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 494, 519, {19625, 19644, 19666, 19691, 19707, 19729, 19748}, {19758, 19772, 19786, 19800, 19811, 19825, 19748}, {19839, 19846, 19853, 19860, 19867, 19874, 19881}, {19885, 19901, 19926, 19945, 19964, 19971, 19984, 19997, 20016, 20047, 20072, 20094, 0}, {19885, 19901, 19926, 19945, 19964, 19971, 19984, 19997, 20016, 20047, 20072, 20094, 0}, {20119, 20127, 20141, 20155, 19964, 19971, 19984, 20166, 20174, 20188, 20199, 20207, 0}, {20119, 20127, 20141, 20155, 19964, 19971, 19984, 20166, 20174, 20188, 20199, 20207, 0}, 0, 1, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {20218, 20240, 20262, 20287, 20309, 20334, 20362}, {20384, 20394, 20404, 20417, 20427, 20440, 20456}, {20466, 20470, 20477, 20481, 20488, 20495, 20502}, {20506, 20522, 20547, 20566, 20588, 20595, 20608, 20621, 20640, 20671, 20696, 20715, 0}, {20506, 20522, 20547, 20566, 20588, 20595, 20608, 20621, 20640, 20671, 20696, 20715, 0}, {20740, 20747, 20547, 20763, 20588, 20595, 20608, 20621, 20779, 20801, 20817, 20827, 0}, {20740, 20747, 20547, 20763, 20588, 20595, 20608, 20621, 20779, 20801, 20817, 20827, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 544, 572, {20843, 20865, 20884, 20906, 20925, 20947, 20972}, {20991, 21004, 21014, 21027, 21037, 21050, 21066}, {21076, 21083, 21090, 21097, 21104, 21111, 21118}, {21122, 21138, 21163, 21182, 21204, 21211, 21224, 21237, 21256, 21287, 21312, 21334, 0}, {21122, 21138, 21163, 21182, 21204, 21211, 21224, 21237, 21256, 21287, 21312, 21334, 0}, {21359, 21366, 21163, 21382, 21204, 21211, 21224, 21398, 21405, 21427, 21443, 21456, 0}, {21359, 21366, 21163, 21382, 21204, 21211, 21224, 21398, 21405, 21427, 21443, 21456, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{3353, 49, 52, {21472, 21500, 21534, 21562, 21590, 21621, 21658}, {21686, 21699, 21718, 21734, 21747, 21766, 21785}, {21795, 21802, 21809, 21816, 21823, 21836, 21843}, {21847, 21866, 21894, 21916, 21935, 21948, 21958, 21971, 21996, 22027, 22052, 22068, 0}, {21847, 21866, 21894, 21916, 21935, 21948, 21958, 21971, 21996, 22027, 22052, 22068, 0}, {22087, 22097, 22116, 22126, 21935, 21948, 21958, 22142, 22149, 22174, 22190, 22200, 0}, {22087, 22097, 22116, 22126, 21935, 21948, 21958, 22142, 22149, 22174, 22190, 22200, 0}, 0, 0, 55, 11, {755,1062,775,2098,0,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{1151,1146,3295,3304,0,0,0,0,0,0,0,0},{1173,1165,3312,3324,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 594, 622, {22213, 22232, 22251, 22276, 22295, 22329, 22354}, {22373, 17563, 17573, 17589, 22383, 22408, 17640}, {0, 0, 0, 0, 0, 0, 0}, {22424, 22449, 22480, 22496, 17787, 17794, 17804, 22515, 22531, 22562, 22584, 22606, 0}, {22424, 22449, 22480, 22496, 17787, 17794, 17804, 22515, 22531, 22562, 22584, 22606, 0}, {22631, 22644, 22480, 22496, 17787, 17794, 17804, 22663, 22670, 22686, 22702, 22712, 0}, {22631, 22644, 22480, 22496, 17787, 17794, 17804, 22663, 22670, 22686, 22702, 22712, 0}, 0, 0, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{3361,0,0,0,0,0,0,0,0,0},{583,591,266,0,0,0,0,0,0,0,0,0},{600,611,271,0,0,0,0,0,0},{3380,3388,0,0,0,0,0,0}},
	{1, 644, 656, {14431, 14450, 22725, 14491, 14510, 14532, 14557}, {14576, 14586, 22747, 14609, 14619, 14632, 14648}, {14658, 14662, 14669, 14676, 14683, 14690, 14697}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 22855, 22871, 22896, 22918, 22946, 0}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 22855, 22871, 22896, 22918, 22946, 0}, {22968, 22981, 14736, 23000, 22835, 14778, 22842, 23016, 23023, 23042, 23058, 23080, 0}, {22968, 22981, 14736, 23000, 22835, 14778, 22842, 23016, 23023, 23042, 23058, 23080, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 665, 670, {23096, 23103, 23114, 23127, 23140, 23151, 23164}, {23175, 23180, 23185, 23190, 23195, 23200, 23205}, {23175, 23180, 23185, 23190, 23195, 23200, 23205}, {23210, 23236, 23264, 23294, 23324, 23350, 23380, 23406, 23434, 23458, 23486, 23523, 0}, {23210, 23236, 23264, 23294, 23324, 23350, 23380, 23406, 23434, 23458, 23486, 23523, 0}, {23562, 23574, 23586, 23598, 23610, 23622, 23634, 23646, 23658, 23670, 23683, 23696, 0}, {23562, 23574, 23586, 23598, 23610, 23622, 23634, 23646, 23658, 23670, 23683, 23696, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3398,3436,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{3468, 675, 697, {23709, 23737, 23765, 23802, 23833, 23867, 23898}, {23932, 23948, 23964, 23989, 24008, 24030, 24049}, {24071, 24078, 24085, 24095, 24105, 24115, 24125}, {24138, 24172, 24209, 24246, 24280, 24311, 24348, 24385, 24425, 24459, 24493, 24542, 0}, {24591, 24622, 24656, 24690, 24721, 24749, 24783, 24817, 24854, 24885, 24916, 24962, 0}, {25008, 25021, 25034, 25047, 25060, 25073, 25086, 25099, 25112, 25125, 25141, 25157, 0}, {25008, 25021, 25034, 25047, 25060, 25073, 25086, 25099, 25112, 25125, 25141, 25157, 0}, 0, 0, 1, 3, {379,388,397,428,417,406,446,439,453,0,0,0,0,0},{3492,3535,3583,3615,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{3652,666,0,0,0,0,0,0}},
	{109, 722, 725, {25173, 25182, 25192, 25204, 25217, 25226, 25238}, {25250, 25254, 12926, 25259, 25263, 25267, 25271}, {1285, 25275, 1608, 1608, 11804, 4532, 1285}, {25278, 25285, 25294, 25301, 1857, 25308, 25316, 25327, 25332, 25337, 25344, 25353, 0}, {25278, 25285, 25294, 25301, 1857, 25308, 25316, 25327, 25332, 25337, 25344, 25353, 0}, {25361, 25365, 12926, 25369, 1857, 25373, 25377, 25327, 25332, 25381, 25385, 25390, 0}, {25361, 25365, 12926, 25369, 1857, 25373, 25377, 25327, 25332, 25381, 25385, 25390, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {25395, 25417, 25433, 25452, 25462, 25493, 25509}, {25395, 25417, 25433, 25452, 25462, 25493, 25509}, {25522, 25526, 25522, 25530, 25530, 25534, 25534}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, 0, 0, 1, 3, {9,417,0,0,0,0,0,0,0,0,0,0,0,0},{894,2363,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{3685,0,0,0,0,0,0,0}},
	{109, 728, 753, {25727, 25752, 25771, 25799, 25818, 25843, 25862}, {25884, 25900, 25910, 25929, 25939, 25955, 25965}, {25978, 25985, 25989, 25993, 25997, 26004, 26011}, {26015, 26034, 26050, 26063, 26076, 26098, 26117, 26139, 26155, 26171, 26184, 26200, 0}, {26015, 26034, 26050, 26063, 26076, 26098, 26117, 26139, 26155, 26171, 26184, 26200, 0}, {26216, 26225, 26234, 26243, 26252, 26261, 26273, 26282, 26291, 26300, 26309, 26318, 0}, {26216, 26225, 26234, 26243, 26252, 26261, 26273, 26282, 26291, 26300, 26309, 26318, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{3720,894,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 778, 794, {26327, 26355, 26377, 26396, 26421, 26446, 26465}, {26327, 26355, 26377, 26396, 26421, 26446, 26465}, {26475, 26475, 26479, 26483, 26487, 26491, 26495}, {26499, 26524, 26555, 26565, 26578, 26585, 26598, 26620, 26636, 26661, 26692, 26717, 0}, {26499, 26524, 26555, 26565, 26578, 26585, 26598, 26620, 26636, 26661, 26692, 26717, 0}, {26739, 26749, 26555, 26756, 26578, 26585, 26760, 26767, 26771, 26781, 26797, 26807, 0}, {26739, 26749, 26555, 26756, 26578, 26585, 26760, 26767, 26771, 26781, 26797, 26807, 0}, 0, 0, 55, 3, {744,304,0,0,0,0,0,0,0,0,0,0,0,0},{3747,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 165, 170, {2803, 26814, 2817, 26819, 26829, 26835, 2850}, {26842, 26847, 26852, 26857, 26863, 26868, 26873}, {1828, 1616, 1608, 1608, 2890, 2894, 1285}, {26879, 26887, 26896, 26902, 26908, 26913, 26919, 26925, 26932, 26941, 26949, 26958, 0}, {26967, 26975, 2910, 666, 5557, 26984, 26990, 2933, 5574, 5583, 5591, 26996, 0}, {27005, 13623, 26852, 27010, 26908, 26913, 27015, 27020, 27025, 27030, 13663, 27035, 0}, {27005, 13623, 26852, 27010, 26908, 26913, 27015, 27020, 27025, 27030, 13663, 27035, 0}, 2, 1, 1, 3, {18,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1314,1261,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 644, 804, {27040, 14450, 27068, 14491, 14510, 14532, 14557}, {14576, 14586, 22747, 14609, 14619, 14632, 14648}, {0, 0, 0, 0, 0, 0, 0}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 27087, 27103, 27131, 22918, 22946, 0}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 27087, 27103, 27131, 22918, 22946, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 816, 828, {27153, 27169, 27185, 27213, 27229, 27272, 27297}, {27153, 27169, 27325, 27213, 27335, 27357, 27370}, {27380, 27384, 27388, 27392, 27396, 27409, 27416}, {27423, 27442, 27467, 27486, 27511, 27524, 27537, 27550, 27572, 27606, 27631, 27659, 0}, {27423, 27442, 27467, 27486, 27511, 27524, 27537, 27550, 27572, 27606, 27631, 27659, 0}, {27687, 27694, 27704, 27486, 27511, 27524, 27537, 27717, 27727, 27740, 27750, 27763, 0}, {27687, 27694, 27704, 27486, 27511, 27524, 27537, 27717, 27727, 27740, 27750, 27763, 0}, 0, 1, 55, 11, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{3304,71,0,0,0,0,0,0,0,0,0,0},{3324,89,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 837, 847, {27776, 27798, 27820, 27836, 27852, 27868, 27887}, {27909, 27919, 27929, 27939, 27949, 27959, 27969}, {27979, 27983, 27987, 27991, 27995, 27999, 28003}, {28007, 28023, 28033, 28043, 28053, 28069, 28082, 28095, 28105, 28118, 28131, 28144, 0}, {28007, 28023, 28033, 28043, 28053, 28069, 28082, 28095, 28105, 28118, 28131, 28144, 0}, {28157, 28164, 28171, 28178, 28185, 28192, 28199, 28206, 28213, 28220, 28227, 28234, 0}, {28157, 28164, 28171, 28178, 28185, 28192, 28199, 28206, 28213, 28220, 28227, 28234, 0}, 0, 0, 1, 3, {932,941,948,957,460,417,968,0,0,0,0,0,0,0},{3768,3787,42,2448,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 866, 876, {28241, 28251, 28258, 28271, 28281, 28291, 28301}, {28241, 28251, 28311, 28271, 28281, 28291, 28301}, {28321, 28325, 28329, 28333, 28337, 28341, 28345}, {28349, 28365, 28381, 28391, 28404, 28411, 28418, 28428, 28441, 28460, 28476, 28492, 0}, {28349, 28365, 28381, 28391, 28404, 28411, 28418, 28428, 28441, 28460, 28476, 28492, 0}, {28508, 28518, 28381, 28528, 28404, 28411, 28418, 28538, 28548, 28558, 28568, 28578, 0}, {28508, 28518, 28381, 28528, 28404, 28411, 28418, 28538, 28548, 28558, 28568, 28578, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 889, 899, {28588, 28595, 28601, 28608, 28614, 28620, 28628}, {28638, 28642, 28646, 28650, 28654, 28658, 28662}, {9428, 9428, 9428, 9428, 9428, 9428, 9428}, {28668, 28677, 7020, 28686, 28692, 28698, 28704, 28711, 28717, 28726, 28735, 28743, 0}, {28668, 28677, 7020, 28686, 28692, 28698, 28704, 28711, 28717, 28726, 28735, 28743, 0}, {28752, 28756, 2791, 28760, 2760, 28764, 28768, 28772, 28777, 28781, 28787, 28791, 0}, {28752, 28756, 2791, 28760, 2760, 28764, 28768, 28772, 28777, 28781, 28787, 28791, 0}, 0, 0, 55, 3, {744,755,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 381, 409, {28795, 28814, 28833, 28858, 28877, 28899, 28924}, {28943, 14586, 28953, 14609, 28969, 14632, 14648}, {28982, 14662, 28986, 14676, 28990, 14690, 14697}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 14771, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, 0, 0, 1, 3, {932,941,948,957,460,417,968,0,0,0,0,0,0,0},{3800,3820,42,2448,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{3388,0,0,0,0,0,0,0}},
	{109, 49, 52, {29173, 29179, 29187, 29195, 29204, 29215, 29221}, {29227, 29230, 3084, 4997, 3090, 29233, 1275}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {29236, 29247, 13591, 1851, 29258, 29264, 2769, 13609, 29269, 1888, 29279, 29288, 0}, {29236, 29247, 13591, 1851, 29258, 29264, 2769, 13609, 29269, 1888, 29279, 29288, 0}, {1914, 1918, 29297, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 7781, 0}, {1914, 1918, 29297, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 7781, 0}, 2, 1, 55, 3, {744,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 0, 0, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, 0, 6, 1, 3, {379,417,0,0,0,0,0,0,0,0,0,0,0,0},{894,1217,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {29415, 29422, 29428, 29435, 29446, 29454, 29463}, {29470, 29474, 2791, 29478, 29482, 29486, 7727}, {29470, 29474, 2791, 29478, 29482, 29486, 7727}, {29490, 29496, 29504, 26902, 29510, 29515, 29521, 26925, 29527, 29537, 29545, 29555, 0}, {29490, 29496, 29504, 26902, 29510, 29515, 29521, 26925, 29527, 29537, 29545, 29555, 0}, {29565, 29569, 2791, 29573, 2760, 29577, 29581, 16871, 15223, 1947, 29585, 13346, 0}, {29565, 29569, 2791, 29573, 2760, 29577, 29581, 16871, 15223, 1947, 29585, 13346, 0}, 0, 0, 1, 3, {932,3009,0,0,0,0,0,0,0,0,0,0,0,0},{978,997,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 912, 919, {29589, 29594, 29602, 29611, 29621, 29631, 29638}, {29649, 29653, 29658, 12088, 29662, 29666, 29670}, {29674, 29676, 29678, 6516, 6516, 29678, 29680}, {29682, 29688, 29694, 29700, 29708, 29715, 29721, 29727, 29732, 29739, 29748, 29754, 0}, {29682, 29688, 29694, 29700, 29708, 29715, 29721, 29727, 29732, 29739, 29748, 29754, 0}, {29760, 29764, 29768, 29772, 29776, 29780, 29784, 29788, 29792, 29796, 29800, 29804, 0}, {29760, 29764, 29768, 29772, 29776, 29780, 29784, 29788, 29792, 29796, 29800, 29804, 0}, 0, 0, 1, 3, {18,9,775,755,417,0,0,0,0,0,0,0,0,0},{1217,1234,894,0,0,0,0,0,0,0},{71,266,1151,1243,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {29808, 29815, 29823, 29830, 29837, 29845, 29854}, {29861, 29865, 29869, 29873, 29877, 7723, 28638}, {1616, 1616, 1610, 1616, 9428, 2892, 9428}, {29881, 29889, 29899, 29905, 29913, 29918, 29923, 29928, 29935, 16856, 29943, 29951, 0}, {29881, 29889, 29899, 29905, 29913, 29918, 29923, 29928, 29935, 16856, 29943, 29951, 0}, {1914, 29959, 2791, 29963, 2760, 28764, 28768, 29967, 2731, 1947, 29971, 13346, 0}, {1914, 29959, 2791, 29963, 2760, 28764, 28768, 29967, 2731, 1947, 29971, 13346, 0}, 0, 0, 1, 3, {295,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1010,1029,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 928, 939, {29975, 29993, 30008, 30030, 30043, 30057, 30074}, {30098, 30106, 30111, 30030, 30043, 30123, 30130}, {0, 0, 0, 0, 0, 0, 0}, {30144, 30166, 30182, 30202, 30216, 30233, 30248, 30265, 30279, 30292, 30311, 30325, 0}, {30144, 30166, 30182, 30202, 30216, 30233, 30248, 30265, 30279, 30292, 30311, 30325, 0}, {30344, 30359, 30368, 30381, 30388, 30398, 30406, 30416, 30423, 30429, 30441, 30448, 0}, {30344, 30359, 30368, 30381, 30388, 30398, 30406, 30416, 30423, 30429, 30441, 30448, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 0, 0, {30460, 30468, 12472, 12968, 12490, 30479, 30489}, {12516, 12998, 12524, 12528, 12532, 12535, 30498}, {0, 0, 0, 0, 0, 0, 0}, {30502, 30511, 30521, 30529, 7756, 2764, 30537, 30543, 30552, 30561, 30570, 30579, 0}, {30502, 30511, 30521, 30529, 7756, 2764, 30537, 30543, 30552, 30561, 30570, 30579, 0}, {1914, 1918, 13006, 30588, 7756, 1931, 1935, 16871, 15223, 1947, 30592, 13346, 0}, {1914, 1918, 13006, 30588, 7756, 1931, 1935, 16871, 15223, 1947, 30592, 13346, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{3834, 949, 955, {30596, 30604, 30613, 30624, 30634, 30646, 30654}, {12516, 30664, 30669, 30674, 30679, 30683, 30687}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 30691, 30698, 30706, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 30691, 30698, 30706, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 30710, 29573, 30706, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 30710, 29573, 30706, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {775,9,755,0,0,0,0,0,0,0,0,0,0,0},{721,3843,798,2541,3856,3881,0,0,0,0},{71,266,1146,3907,0,0,0,0,0,0,0,0},{89,3919,3934,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3950, 965, 970, {30715, 30722, 30737, 30751, 30767, 30782, 30798}, {4528, 30813, 4512, 30817, 30821, 30825, 30829}, {1285, 9428, 1608, 1280, 1285, 1610, 9428}, {5011, 5019, 30833, 30840, 30847, 1649, 1654, 30852, 30862, 30873, 30882, 30892, 0}, {5011, 5019, 30833, 30840, 30847, 1649, 1654, 30852, 30862, 30873, 30882, 30892, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 5101, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 5101, 5105, 5109, 4642, 6911, 0}, 0, 0, 55, 3, {744,755,417,764,0,0,0,0,0,0,0,0,0,0},{3963,721,2561,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 975, 980, {30902, 30918, 30926, 30934, 30943, 30955, 30965}, {30975, 30981, 30987, 30991, 30995, 31003, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {31010, 31023, 31037, 31046, 30706, 31052, 31057, 31065, 13301, 31078, 13318, 13326, 0}, {31010, 31023, 31037, 31046, 30706, 31052, 31057, 31065, 13301, 31078, 13318, 13326, 0}, {31087, 1918, 31091, 13334, 30706, 31095, 1935, 31099, 1943, 31107, 1951, 13346, 0}, {31087, 1918, 31091, 13334, 30706, 31095, 1935, 31099, 1943, 31107, 1951, 13346, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 985, 988, {31113, 31121, 31129, 31137, 31144, 31152, 31160}, {31168, 31172, 31176, 31180, 7719, 31184, 31188}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {31192, 31200, 31212, 31224, 31229, 31236, 31247, 31258, 31266, 31275, 31288, 31296, 0}, {31192, 31200, 31212, 31224, 31229, 31236, 31247, 31258, 31266, 31275, 31288, 31296, 0}, {31303, 31307, 31311, 31315, 31319, 31323, 31327, 31331, 31335, 31339, 25271, 12918, 0}, {31303, 31307, 31311, 31315, 31319, 31323, 31327, 31331, 31335, 31339, 25271, 12918, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{978,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 991, 1011, {31343, 31356, 31366, 28271, 31376, 31386, 31396}, {31406, 31413, 31420, 31427, 31434, 31441, 31448}, {28325, 28325, 31455, 28333, 31459, 28341, 31463}, {31467, 31474, 31487, 31500, 31513, 31526, 31533, 31543, 31553, 31569, 31582, 31592, 0}, {31467, 31474, 31487, 31500, 31513, 31526, 31533, 31543, 31553, 31569, 31582, 31592, 0}, {31467, 31605, 31612, 31619, 31626, 31526, 31633, 31640, 31647, 31654, 31661, 31668, 0}, {31467, 31605, 31612, 31619, 31626, 31526, 31633, 31640, 31647, 31654, 31661, 31668, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{3982,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {31675, 31683, 31693, 31702, 31712, 31721, 31731}, {31740, 31743, 31746, 31749, 31752, 31755, 31758}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {31761, 31769, 31779, 31786, 7756, 31796, 31801, 31807, 31816, 31827, 31837, 31846, 0}, {31761, 31769, 31779, 31786, 7756, 31796, 31801, 31807, 31816, 31827, 31837, 31846, 0}, {31855, 31860, 31865, 31870, 7756, 31876, 31881, 31886, 31892, 31897, 31903, 31908, 0}, {31855, 31860, 31865, 31870, 7756, 31876, 31881, 31886, 31892, 31897, 31903, 31908, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 1031, 1035, {31913, 31918, 31925, 31933, 31940, 31948, 31954}, {31960, 15901, 29869, 31964, 15905, 31184, 7727}, {9428, 11804, 1610, 9428, 31968, 2892, 1285}, {31971, 31985, 31998, 32014, 32027, 32041, 32054, 32069, 32085, 32101, 32115, 32137, 0}, {31971, 31985, 31998, 32014, 32027, 32041, 32054, 32069, 32085, 32101, 32115, 32137, 0}, {32160, 32164, 25271, 32168, 32172, 32176, 32180, 32184, 32188, 32192, 32196, 32200, 0}, {32160, 32164, 25271, 32168, 32172, 32176, 32180, 32184, 32188, 32192, 32196, 32200, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{3800,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{4019, 1039, 1046, {32204, 32214, 32224, 32234, 32244, 32254, 32264}, {32274, 32281, 32288, 32295, 32302, 32309, 32316}, {32323, 32327, 32331, 32335, 32339, 32343, 32347}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, 0, 0, 1, 3, {379,388,397,428,417,406,0,0,0,0,0,0,0,0},{4042,4066,4096,4126,4143,0,0,0,0,0},{583,266,71,0,0,0,0,0,0,0,0,0},{600,271,89,0,0,0,0,0,0},{4166,666,0,0,0,0,0,0}},
	{109, 975, 1053, {25250, 29474, 32441, 32448, 32458, 32463, 32470}, {25250, 29474, 32477, 32482, 32458, 32487, 32492}, {32497, 1616, 32500, 32503, 17126, 4532, 1825}, {32506, 32513, 32441, 32524, 32530, 32534, 32543, 32550, 32555, 32564, 32569, 32572, 0}, {32506, 32513, 32441, 32524, 32530, 32534, 32543, 32550, 32555, 32564, 32569, 32572, 0}, {32578, 32583, 32591, 32597, 32530, 32602, 32608, 32550, 32614, 32564, 32569, 32620, 0}, {32578, 32583, 32591, 32597, 32530, 32602, 32608, 32550, 32614, 32564, 32569, 32620, 0}, 2, 1, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3125, 1058, 1064, {32625, 32642, 32657, 32674, 32691, 32708, 32717}, {32728, 32733, 32738, 32743, 32748, 32753, 32758}, {32763, 10152, 10155, 10158, 10161, 10164, 10167}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, 0, 0, 55, 3, {388,397,417,428,0,0,0,0,0,0,0,0,0,0},{4183,4204,4230,4271,4317,0,0,0,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{4331,2717,666,0,0,0,0,0}},
	{673, 1070, 1075, {32922, 32930, 32940, 32950, 32959, 32969, 32977}, {32987, 32991, 32996, 33000, 33004, 33008, 13568}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 33012, 33021, 33032, 33041, 33051, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 33012, 33021, 33032, 33041, 33051, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 1, 3, {18,9,775,755,417,0,0,0,0,0,0,0,0,0},{1217,1234,894,0,0,0,0,0,0,0},{71,266,1151,1243,1253,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{4352, 1080, 1085, {33061, 33086, 33111, 33136, 33149, 33164, 33181}, {33196, 33201, 33206, 33211, 33216, 33221, 310}, {16083, 16083, 33226, 6081, 6084, 16083, 6081}, {33229, 33248, 33263, 33285, 33305, 33319, 33333, 33345, 33369, 33391, 33408, 33425, 0}, {33442, 33461, 33476, 33498, 33518, 33534, 33550, 33564, 33590, 33614, 33631, 33425, 0}, {33648, 33657, 33666, 33673, 33680, 33687, 33694, 33701, 33708, 33715, 33722, 33729, 0}, {33648, 33657, 33666, 33673, 33680, 33687, 33694, 33701, 33708, 33715, 33722, 33729, 0}, 0, 1, 11, 3, {681,1208,417,4368,4378,0,0,0,0,0,0,0,0,0},{4391,4426,4455,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{4490,0,0,0,0,0,0,0}},
	{925, 49, 52, {33736, 33748, 33759, 33771, 33783, 33793, 33805}, {33820, 33825, 33830, 33835, 33840, 33845, 33850}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {33855, 33864, 33876, 33884, 33889, 33899, 33906, 33915, 33922, 33928, 33937, 33948, 0}, {33855, 33864, 33876, 33884, 33889, 33899, 33906, 33915, 33922, 33928, 33937, 33948, 0}, {33956, 33961, 33966, 33971, 33976, 33981, 33986, 33840, 33991, 33996, 34001, 34006, 0}, {33956, 33961, 33966, 33971, 33976, 33981, 33986, 33840, 33991, 33996, 34001, 34006, 0}, 0, 0, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{4506, 1090, 1092, {34011, 34024, 34032, 34041, 34051, 34061, 34070}, {34082, 34086, 34090, 34094, 34098, 34102, 34106}, {1828, 1616, 1608, 5210, 9428, 4089, 1285}, {34110, 34124, 34135, 34144, 34155, 34167, 34181, 34193, 34206, 34219, 34231, 34244, 0}, {34258, 34275, 34289, 34301, 34315, 34330, 34344, 34356, 34371, 34386, 34400, 34415, 0}, {34431, 34436, 34442, 34448, 34453, 34459, 34465, 34470, 34476, 34481, 15862, 34487, 0}, {34431, 34436, 34442, 34448, 34453, 34459, 34465, 34470, 34476, 34481, 15862, 34487, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{4517,4539,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 0, 0, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, {1, 10, 17, 37, 57, 81, 105, 112, 123, 134, 143, 161, 0}, 0, 0, 1, 3, {9,18,0,0,0,0,0,0,0,0,0,0,0,0},{29,42,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 5, 8, {177, 190, 211, 226, 237, 256, 267}, {280, 285, 290, 295, 300, 305, 310}, {315, 318, 321, 324, 327, 318, 324}, {330, 343, 360, 369, 380, 387, 394, 401, 414, 433, 450, 465, 0}, {330, 343, 360, 369, 380, 387, 394, 401, 414, 433, 450, 465, 0}, {482, 489, 360, 496, 380, 387, 394, 503, 510, 517, 524, 531, 0}, {482, 489, 360, 496, 380, 387, 394, 503, 510, 517, 524, 531, 0}, 2, 1, 11, 3, {116,131,147,163,0,0,0,0,0,0,0,0,0,0},{180,199,217,242,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{279,0,0,0,0,0,0,0}},
	{109, 13, 19, {538, 547, 555, 563, 572, 579, 589}, {598, 602, 606, 610, 614, 618, 622}, {626, 629, 632, 635, 638, 641, 644}, {647, 653, 660, 666, 672, 677, 682, 689, 695, 704, 712, 721, 0}, {730, 739, 749, 758, 768, 776, 784, 794, 804, 816, 828, 840, 0}, {852, 857, 660, 863, 672, 677, 868, 873, 877, 882, 887, 892, 0}, {852, 857, 660, 863, 672, 677, 868, 873, 877, 882, 887, 892, 0}, 2, 1, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{315,338,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {34493, 34500, 34507, 34514, 34521, 34528, 34535}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {379,406,417,0,0,0,0,0,0,0,0,0,0,0},{469,1484,547,4555,0,0,0,0,0,0},{591,583,71,266,0,0,0,0,0,0,0,0},{611,600,89,271,0,0,0,0,0},{623,639,652,0,0,0,0,0}},
	{673, 39, 44, {1197, 1205, 1215, 1223, 1231, 1240, 1247}, {1254, 1257, 1260, 1264, 1267, 1271, 1275}, {1278, 1280, 1282, 1285, 1287, 1280, 1285}, {1290, 1296, 1302, 1310, 1316, 1324, 1332, 1342, 1348, 1356, 1364, 1373, 0}, {1382, 1388, 1395, 1403, 1409, 1417, 1425, 1435, 1348, 1441, 1449, 1459, 0}, {1468, 1472, 1477, 1482, 1486, 1491, 1496, 1501, 1505, 1511, 1517, 1521, 0}, {1468, 1472, 1477, 1482, 1486, 1491, 1496, 1501, 1505, 1511, 1517, 1521, 0}, 2, 1, 11, 3, {681,692,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 49, 52, {1525, 1533, 1540, 1548, 1555, 1563, 1570}, {1578, 1583, 1587, 1591, 1595, 1599, 1603}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 1633, 1639, 1645, 1649, 1654, 1659, 1666, 1676, 1684, 1693, 0}, {1618, 1625, 1633, 1639, 1645, 1649, 1654, 1659, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {744,755,417,764,0,0,0,0,0,0,0,0,0,0},{721,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 57, 63, {1747, 1755, 1762, 1771, 1780, 1791, 1799}, {1807, 1810, 1813, 1816, 1819, 1822, 1825}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {681,775,417,784,0,0,0,0,0,0,0,0,0,0},{798,721,817,0,0,0,0,0,0,0},{71,830,0,0,0,0,0,0,0,0,0,0},{89,842,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 70, 77, {1959, 1974, 1989, 2000, 2015, 2028, 2047}, {2062, 2069, 2076, 2083, 2090, 2097, 2104}, {2111, 2114, 2117, 2117, 2120, 2120, 2123}, {2126, 2147, 2170, 2185, 2202, 2213, 2228, 2243, 2262, 2285, 2304, 2323, 0}, {2344, 2365, 2388, 2403, 2420, 2431, 2446, 2461, 2480, 2503, 2522, 2541, 0}, {2562, 2569, 2576, 2583, 2590, 2597, 2606, 2615, 2622, 2629, 2636, 2643, 0}, {2562, 2569, 2576, 2583, 2590, 2597, 2606, 2615, 2622, 2629, 2636, 2643, 0}, 2, 1, 1, 3, {295,18,857,9,864,417,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {932,941,948,957,460,417,968,0,0,0,0,0,0,0},{978,997,1010,1029,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 84, 88, {2997, 3009, 3021, 3031, 3045, 3055, 3067}, {3078, 3081, 3084, 3087, 3090, 3093, 3096}, {1285, 1608, 1610, 3099, 1610, 1280, 1616}, {3101, 3110, 3119, 3129, 3138, 3147, 3156, 3166, 3173, 3181, 3189, 3199, 0}, {3208, 3219, 3230, 3242, 3253, 3264, 3275, 3287, 3296, 3306, 3316, 3328, 0}, {3339, 3345, 3351, 3358, 3364, 3370, 3376, 3383, 3387, 3392, 3397, 3404, 0}, {3339, 3345, 3351, 3358, 3364, 3370, 3376, 3383, 3387, 3392, 3397, 3404, 0}, 2, 1, 11, 11, {1208,0,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{1146,0,0,0,0,0,0,0,0,0,0,0},{1165,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 2, 1, 1, 3, {18,9,775,755,417,0,0,0,0,0,0,0,0,0},{1217,894,1234,0,0,0,0,0,0,0},{71,266,1151,1243,1253,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 92, 105, {3596, 3614, 3628, 3646, 3664, 3682, 3698}, {3712, 3724, 3736, 3748, 3760, 3772, 3784}, {3791, 3796, 3801, 3806, 3811, 3816, 3821}, {3826, 3837, 3850, 3857, 3868, 3875, 3884, 3893, 3906, 3919, 3934, 3947, 0}, {3826, 3837, 3850, 3857, 3868, 3875, 3884, 3893, 3906, 3919, 3934, 3947, 0}, {3958, 3967, 3850, 3976, 3868, 3875, 3884, 3985, 3994, 4003, 4012, 4021, 0}, {3958, 3967, 3850, 3976, 3868, 3875, 3884, 3985, 3994, 4003, 4012, 4021, 0}, 0, 0, 1, 3, {18,1261,9,29,755,744,1274,417,1287,1304,0,0,0,0},{1314,1261,1332,1354,1287,0,0,0,0,0},{71,62,0,0,0,0,0,0,0,0,0,0},{89,77,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1375, 116, 120, {4030, 4040, 4048, 4053, 4060, 4073, 4081}, {2894, 4089, 3099, 4091, 4095, 1280, 4098}, {2894, 4089, 3099, 4102, 4095, 1280, 4102}, {4105, 4113, 4122, 4131, 4140, 4147, 4155, 4163, 4173, 4184, 1684, 1693, 0}, {4105, 4113, 4122, 4131, 4140, 4147, 4155, 4163, 4173, 4184, 1684, 1693, 0}, {1702, 857, 4193, 4200, 4206, 4212, 4218, 1727, 4224, 1737, 887, 1742, 0}, {1702, 857, 4193, 4200, 4206, 4212, 4218, 1727, 4224, 1737, 887, 1742, 0}, 2, 1, 124, 3, {1383,1397,0,0,0,0,0,0,0,0,0,0,0,0},{1410,1430,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{1444,0,0,0,0,0,0,0}},
	{673, 127, 132, {4231, 4242, 4253, 4267, 4281, 4293, 4305}, {4317, 4322, 4328, 4334, 4340, 4345, 4351}, {1285, 1608, 4356, 1608, 1614, 1614, 1616}, {4359, 4367, 3504, 4376, 4383, 4388, 4395, 4402, 1666, 4184, 4410, 4420, 0}, {4359, 4367, 3504, 4376, 4383, 4388, 4395, 4402, 1666, 4184, 4410, 4420, 0}, {1702, 1707, 1712, 1717, 4383, 4212, 4218, 4429, 1732, 1737, 4436, 892, 0}, {1702, 1707, 1712, 1717, 4383, 4212, 4218, 4429, 1732, 1737, 4436, 892, 0}, 2, 1, 11, 3, {1208,1455,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {4442, 4451, 4459, 4468, 4479, 4488, 4497}, {4504, 4508, 4512, 4516, 4520, 4524, 4528}, {1828, 1616, 1608, 1608, 4532, 2894, 1285}, {4534, 4542, 2910, 4551, 4558, 4565, 4572, 2933, 4579, 4589, 712, 4597, 0}, {4534, 4542, 2910, 4551, 4558, 4565, 4572, 2933, 4579, 4589, 712, 4597, 0}, {4606, 4610, 4512, 4614, 4618, 4622, 4626, 4630, 4634, 4638, 4642, 4646, 0}, {4606, 4610, 4512, 4614, 4618, 4622, 4626, 4630, 4634, 4638, 4642, 4646, 0}, 2, 1, 1, 3, {18,864,9,1467,857,0,0,0,0,0,0,0,0,0},{1217,1475,894,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{370, 137, 144, {4650, 4660, 4670, 4680, 4690, 4700, 4710}, {1016, 4720, 4724, 4728, 4732, 4736, 4740}, {1016, 4720, 4724, 4728, 4732, 4736, 4740}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, 0, 0, 1, 3, {406,460,439,379,417,0,0,0,0,0,0,0,0,0},{469,1484,1508,1535,1564,1588,1617,1637,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{623,1662,652,0,0,0,0,0}},
	{1680, 151, 158, {4771, 4781, 4791, 4801, 4811, 4821, 4831}, {4841, 4845, 4849, 4853, 4857, 4861, 4865}, {4841, 4845, 4849, 4853, 4857, 4861, 4865}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, {4869, 4874, 4879, 4884, 4889, 4894, 4899, 4904, 4909, 4914, 4920, 4926, 0}, 0, 0, 55, 3, {417,1690,446,388,0,0,0,0,0,0,0,0,0,0},{1699,1728,1752,1779,1801,1832,1858,1889,1915,1942},{583,591,266,71,0,0,0,0,0,0,0,0},{600,611,271,89,0,0,0,0,0},{1964,1981,2000,0,0,0,0,0}},
	{109, 165, 170, {4932, 4939, 4947, 4955, 4964, 4974, 4982}, {4991, 3081, 4994, 4997, 5000, 5003, 5006}, {5009, 1608, 1828, 2735, 1828, 2894, 5009}, {5011, 5019, 5028, 1639, 5034, 1649, 1654, 5038, 1666, 1676, 1684, 1693, 0}, {5011, 5019, 5028, 1639, 5034, 1649, 1654, 5038, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 5047, 1717, 5034, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 5047, 1717, 5034, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {2015,1062,755,9,775,2024,417,0,0,0,0,0,0,0},{1217,1475,894,1234,0,0,0,0,0,0},{71,266,1146,2036,2048,0,0,0,0,0,0,0},{89,271,2060,2075,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{2090, 165, 170, {1525, 1533, 1540, 1548, 1555, 1563, 1570}, {5052, 5058, 5063, 5068, 5073, 5078, 5083}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 2, 1, 11, 11, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {5117, 5127, 5141, 5148, 5155, 5164, 1247}, {5172, 5179, 5184, 5188, 5193, 5198, 5202}, {1278, 1280, 2735, 5207, 5210, 1280, 1285}, {5212, 5221, 5226, 5233, 1645, 5243, 5252, 5259, 5269, 5279, 1364, 5292, 0}, {5302, 5311, 5318, 5324, 5333, 5338, 5346, 5352, 5361, 5371, 5385, 5395, 0}, {5403, 5407, 4512, 5411, 1645, 5415, 5419, 5423, 5427, 5431, 1517, 5436, 0}, {5403, 5407, 4512, 5411, 1645, 5415, 5419, 5423, 5427, 5431, 1517, 5436, 0}, 2, 1, 11, 3, {681,0,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1042, 49, 52, {2803, 5440, 5454, 5467, 5480, 5493, 2850}, {4504, 5505, 5509, 5513, 5517, 5521, 5525}, {1828, 1285, 1610, 5530, 5530, 1285, 1285}, {5532, 5540, 5550, 666, 5557, 5562, 5568, 2933, 5574, 5583, 5591, 5600, 0}, {5532, 5540, 5550, 666, 5557, 5562, 5568, 2933, 5574, 5583, 5591, 5600, 0}, {5089, 5609, 4512, 5613, 3515, 5093, 5097, 4630, 4634, 5617, 4642, 5621, 0}, {5089, 5609, 4512, 5613, 3515, 5093, 5097, 4630, 4634, 5617, 4642, 5621, 0}, 0, 0, 1, 3, {18,9,295,857,755,744,1062,2015,775,681,2024,2098,1208,417},{1069,1124,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{673, 49, 52, {5625, 5634, 3425, 5644, 5652, 5660, 5669}, {5675, 5678, 3081, 5682, 5685, 5689, 1275}, {1828, 4532, 1608, 1608, 4532, 2894, 1285}, {5692, 5700, 3504, 5707, 5714, 5719, 5729, 5737, 5743, 5753, 1684, 1693, 0}, {5692, 5700, 3504, 5707, 5714, 5719, 5729, 5737, 5743, 5753, 1684, 1693, 0}, {5761, 5768, 3504, 3579, 5714, 5774, 5781, 5737, 5786, 882, 887, 1742, 0}, {5761, 5768, 3504, 3579, 5714, 5774, 5781, 5737, 5786, 882, 887, 1742, 0}, 2, 1, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{2105,2134,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 165, 170, {5792, 5802, 5807, 5814, 5823, 5827, 5834}, {5845, 2863, 1712, 5850, 5823, 5855, 5860}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {5866, 5875, 5885, 5892, 3515, 5900, 5906, 1659, 5912, 5923, 5933, 5943, 0}, {5866, 5875, 5885, 5892, 3515, 5900, 5906, 1659, 5912, 5923, 5933, 5943, 0}, {5953, 1707, 1712, 1717, 3515, 5958, 5963, 1727, 2986, 882, 887, 1742, 0}, {5953, 1707, 1712, 1717, 3515, 5958, 5963, 1727, 2986, 882, 887, 1742, 0}, 0, 1, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 175, 180, {5968, 5991, 211, 6014, 6025, 6040, 6055}, {6070, 285, 290, 295, 300, 305, 310}, {6075, 6078, 6075, 6081, 6084, 6078, 6081}, {6087, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {6206, 6219, 6234, 6245, 6258, 6265, 6274, 6283, 6298, 6315, 6330, 6343, 0}, {6358, 6366, 360, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, {6358, 6366, 360, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, 0, 1, 11, 3, {681,775,2098,744,9,0,0,0,0,0,0,0,0,0},{199,180,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 49, 52, {6428, 6437, 6449, 6456, 6464, 6474, 6480}, {6487, 6491, 6495, 6499, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {6527, 6537, 6546, 6554, 6562, 6570, 6577, 6584, 6592, 1364, 6598, 6606, 0}, {6615, 6625, 6634, 6642, 6650, 6658, 6665, 6672, 6681, 5385, 6687, 6697, 0}, {6706, 6710, 6715, 6720, 6724, 5419, 1501, 6728, 6732, 1517, 6736, 1521, 0}, {6706, 6710, 6715, 6720, 6724, 5419, 1501, 6728, 6732, 1517, 6736, 1521, 0}, 0, 1, 11, 3, {2151,2161,2169,2181,2193,2203,2213,417,0,0,0,0,0,0},{2225,2239,2254,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{673, 49, 52, {6740, 6748, 6757, 6764, 6771, 6780, 1247}, {1254, 1257, 6787, 1264, 6790, 6794, 1275}, {6516, 6518, 6520, 6522, 6797, 6518, 6522}, {4105, 4113, 6800, 4376, 6806, 6811, 6816, 1659, 1666, 4184, 1684, 1693, 0}, {6821, 6830, 5318, 6840, 6848, 6854, 6860, 6866, 6874, 6884, 6893, 6902, 0}, {5089, 4610, 4512, 4614, 6806, 6811, 6816, 5101, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 6806, 6811, 6816, 5101, 5105, 5109, 4642, 6911, 0}, 2, 1, 11, 3, {681,692,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 185, 197, {6915, 6922, 6931, 6940, 6952, 6960, 6969}, {6979, 6983, 2791, 6988, 6993, 6997, 7001}, {1828, 4089, 1608, 1608, 7005, 1280, 1285}, {7007, 7013, 7020, 7025, 7031, 7035, 7043, 7050, 7056, 7064, 7070, 7078, 0}, {7086, 7092, 3504, 7099, 1645, 7105, 7113, 7120, 7126, 7134, 7140, 7148, 0}, {1914, 7156, 2791, 7160, 7031, 7164, 7168, 7172, 7001, 7176, 7180, 7185, 0}, {1914, 7156, 2791, 7160, 7031, 7164, 7168, 7172, 7001, 7176, 7180, 7185, 0}, 0, 1, 11, 3, {1208,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{2274, 208, 211, {7189, 7197, 7205, 1548, 1555, 1563, 7212}, {7220, 7225, 7230, 1591, 7234, 1599, 7239}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {5011, 5019, 3504, 1639, 1645, 1649, 1654, 7244, 1666, 1676, 1684, 1693, 0}, {5011, 5019, 3504, 1639, 1645, 1649, 1654, 7244, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 3504, 1717, 1645, 1649, 1654, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 3504, 1717, 1645, 1649, 1654, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {417,1690,0,0,0,0,0,0,0,0,0,0,0,0},{2287,2305,0,0,0,0,0,0,0,0},{71,266,2328,0,0,0,0,0,0,0,0,0},{89,271,2338,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 0, 0, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, 0, 0, 1, 3, {295,857,9,18,304,2351,417,0,0,0,0,0,0,0},{894,2363,2379,0,0,0,0,0,0,0},{266,71,906,62,0,0,0,0,0,0,0,0},{271,89,914,77,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 214, 219, {7252, 7258, 7268, 7274, 7285, 7295, 7300}, {7310, 7314, 7318, 7322, 7327, 7331, 7335}, {1280, 1280, 1285, 7339, 1280, 5210, 5210}, {7342, 7347, 7354, 7359, 7365, 7372, 7380, 7387, 7396, 7403, 7408, 7415, 0}, {7342, 7347, 7354, 7359, 7365, 7372, 7380, 7387, 7396, 7403, 7408, 7415, 0}, {7423, 7427, 2791, 7432, 2760, 7436, 7440, 7444, 7449, 7453, 7457, 7461, 0}, {7423, 7427, 2791, 7432, 2760, 7436, 7440, 7444, 7449, 7453, 7457, 7461, 0}, 0, 1, 11, 3, {2421,304,0,0,0,0,0,0,0,0,0,0,0,0},{2431,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 49, 52, {7465, 7476, 7489, 7498, 7505, 7518, 7527}, {7465, 7476, 7489, 7498, 7505, 7518, 7527}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, 0, 0, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {7660, 7667, 7673, 7680, 7685, 7691, 7697}, {7703, 7707, 7711, 7715, 7719, 7723, 7727}, {1608, 1285, 1285, 7731, 3099, 2892, 1285}, {7733, 7741, 7750, 1851, 7756, 1861, 1866, 7760, 1878, 1888, 1896, 7768, 0}, {7733, 7741, 7750, 1851, 7756, 1861, 1866, 7760, 1878, 1888, 1896, 7768, 0}, {1914, 1918, 2791, 1927, 7756, 1931, 1935, 7777, 1943, 1947, 1951, 7781, 0}, {1914, 1918, 2791, 1927, 7756, 1931, 1935, 7777, 1943, 1947, 1951, 7781, 0}, 0, 0, 1, 11, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{2462,894,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 223, 228, {7785, 7798, 7817, 7834, 7847, 7860, 7877}, {280, 285, 290, 295, 300, 305, 310}, {7890, 6078, 6075, 6081, 6084, 6078, 6081}, {7893, 7906, 7917, 7934, 7949, 7964, 7979, 7992, 8007, 8024, 8039, 8056, 0}, {8071, 8082, 8095, 8110, 8123, 8136, 8149, 8160, 8173, 8188, 8201, 8220, 0}, {8233, 8240, 8247, 8254, 8261, 8268, 8275, 8282, 8289, 8296, 8303, 8310, 0}, {8233, 8240, 8247, 8254, 8261, 8268, 8275, 8282, 8289, 8296, 8303, 8310, 0}, 0, 1, 11, 3, {681,775,417,0,0,0,0,0,0,0,0,0,0,0},{2481,0,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{2499,0,0,0,0,0,0,0}},
	{109, 49, 52, {8317, 8332, 8353, 8368, 8381, 8394, 7877}, {280, 285, 8409, 295, 8414, 305, 310}, {315, 318, 8419, 324, 327, 318, 324}, {8422, 8439, 8448, 8463, 380, 8480, 8495, 8508, 8523, 8540, 8561, 8578, 0}, {8593, 8610, 8623, 8640, 6258, 8659, 8674, 8687, 8700, 8715, 8738, 8757, 0}, {8770, 8240, 8777, 8784, 380, 8791, 8798, 8805, 8289, 8812, 8819, 8826, 0}, {8770, 8240, 8777, 8784, 380, 8791, 8798, 8805, 8289, 8812, 8819, 8826, 0}, 0, 1, 11, 3, {775,0,0,0,0,0,0,0,0,0,0,0,0,0},{894,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{2515,0,0,0,0,0,0,0}},
	{673, 39, 233, {8833, 8841, 8852, 8858, 8864, 8873, 1247}, {8879, 5179, 5073, 8884, 8889, 8895, 5202}, {6516, 6518, 8900, 6522, 6524, 6518, 6522}, {1618, 1625, 6800, 1639, 1645, 8902, 8908, 8914, 1666, 1676, 1684, 1693, 0}, {1618, 1625, 6800, 1639, 1645, 8902, 8908, 8914, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 8921, 1732, 1737, 887, 1742, 0}, {1702, 1707, 1712, 1717, 1645, 1722, 868, 8921, 1732, 1737, 887, 1742, 0}, 0, 1, 124, 3, {2529,1455,0,0,0,0,0,0,0,0,0,0,0,0},{2541,2561,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 49, 52, {8926, 8937, 8948, 8959, 8970, 8981, 8987}, {1280, 7005, 1610, 3099, 1278, 7731, 1616}, {1280, 7005, 1610, 3099, 1278, 7731, 1616}, {8996, 9004, 9013, 9020, 3515, 9027, 9033, 1659, 1666, 9039, 1684, 9048, 0}, {8996, 9004, 9013, 9020, 3515, 9027, 9033, 1659, 1666, 9039, 1684, 9048, 0}, {9058, 9063, 9013, 4614, 3515, 9027, 9033, 5101, 9069, 5109, 4642, 9074, 0}, {9058, 9063, 9013, 4614, 3515, 9027, 9033, 5101, 9069, 5109, 4642, 9074, 0}, 2, 1, 11, 3, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{2575,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 238, 248, {9079, 9090, 9100, 9109, 9120, 9132, 9143}, {9153, 9161, 9168, 9174, 9182, 9191, 9199}, {1285, 1280, 1612, 1610, 5210, 1280, 1285}, {9206, 9216, 1633, 9227, 9236, 9242, 9250, 9258, 9266, 9277, 9286, 9296, 0}, {9206, 9216, 1633, 9227, 9236, 9242, 9250, 9258, 9266, 9277, 9286, 9296, 0}, {3566, 857, 1633, 1717, 9236, 9306, 9312, 1727, 2986, 1737, 887, 1742, 0}, {3566, 857, 1633, 1717, 9236, 9306, 9312, 1727, 2986, 1737, 887, 1742, 0}, 0, 1, 11, 3, {681,2583,0,0,0,0,0,0,0,0,0,0,0,0},{2603,2630,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2651,0,0,0,0,0,0,0}},
	{925, 255, 266, {9318, 9330, 9342, 9354, 9368, 9383, 9396}, {9410, 9413, 9416, 9419, 9422, 9425, 6790}, {1285, 1280, 9428, 1610, 3099, 1280, 9430}, {9433, 9440, 9448, 9454, 9463, 9472, 9482, 9488, 9499, 9509, 9516, 9526, 0}, {9534, 9541, 9549, 9554, 9565, 9575, 9585, 9592, 9604, 9613, 9620, 9631, 0}, {9641, 9647, 9652, 9657, 9662, 9667, 9674, 9680, 9686, 9692, 9698, 9705, 0}, {9641, 9647, 9652, 9657, 9662, 9667, 9674, 9680, 9686, 9692, 9698, 9705, 0}, 2, 1, 55, 3, {417,0,0,0,0,0,0,0,0,0,0,0,0,0},{2667,2695,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 273, 285, {9712, 9727, 9742, 9757, 9774, 9793, 9804}, {9815, 9822, 9829, 9836, 9843, 9850, 9857}, {0, 0, 0, 0, 0, 0, 0}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 1, 11, 3, {681,775,2098,744,9,0,0,0,0,0,0,0,0,0},{2727,2745,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 297, 304, {10057, 10070, 10083, 10099, 10116, 10131, 10140}, {10057, 10070, 10083, 10099, 10116, 10131, 10140}, {10149, 10152, 10155, 10158, 10161, 10164, 10167}, {10170, 10183, 10194, 10203, 10214, 10219, 10228, 10239, 10246, 10261, 10272, 10285, 0}, {10298, 10313, 10194, 10203, 10326, 10219, 10333, 10239, 10246, 10261, 10272, 10285, 0}, {10170, 10183, 10194, 10203, 10214, 10219, 10228, 10239, 10246, 10261, 10272, 10285, 0}, {10170, 10183, 10194, 10203, 10214, 10219, 10228, 10239, 10246, 10261, 10272, 10285, 0}, 0, 6, 1, 3, {18,9,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 311, 314, {10346, 10359, 10369, 10378, 10388, 10399, 10410}, {10422, 10425, 10430, 10435, 10440, 10445, 10450}, {10422, 10455, 10458, 10461, 10464, 10467, 10470}, {10473, 10482, 10491, 10500, 10509, 10518, 10527, 10536, 10545, 10554, 10564, 10574, 0}, {10584, 10593, 10602, 10611, 10620, 10629, 10638, 10647, 10656, 10665, 10675, 10685, 0}, {10695, 10701, 10707, 10713, 10719, 10725, 10731, 10737, 10743, 10749, 10756, 10763, 0}, {10695, 10701, 10707, 10713, 10719, 10725, 10731, 10737, 10743, 10749, 10756, 10763, 0}, 0, 1, 1, 3, {18,9,755,744,417,0,0,0,0,0,0,0,0,0},{1261,0,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 317, 322, {10770, 10783, 10804, 10823, 10844, 10863, 10876}, {10887, 10894, 10901, 10908, 10915, 10922, 10929}, {10936, 10939, 10939, 10942, 10945, 10948, 10951}, {10954, 10969, 10984, 10993, 11004, 11015, 11028, 11041, 11056, 11075, 11094, 11111, 0}, {11130, 11147, 11164, 11175, 11188, 11201, 11216, 11231, 11248, 11269, 11290, 11309, 0}, {11330, 11337, 11344, 11351, 11358, 11365, 11372, 11379, 11386, 11393, 11400, 11407, 0}, {11330, 11337, 11344, 11351, 11358, 11365, 11372, 11379, 11386, 11393, 11400, 11407, 0}, 0, 1, 11, 3, {681,775,2764,18,2774,864,417,0,0,0,0,0,0,0},{1029,876,2462,1261,2785,2796,2808,2825,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {11414, 11420, 11434, 11457, 11471, 11487, 11494}, {11503, 11506, 11511, 11517, 11521, 11526, 11529}, {4756, 4744, 4746, 4748, 4750, 4752, 4754}, {11533, 11540, 7354, 11547, 2760, 11553, 11559, 11565, 11572, 11581, 11589, 11596, 0}, {11603, 11610, 11617, 11622, 11628, 11632, 11637, 11642, 11649, 11658, 11666, 11673, 0}, {11680, 5609, 4512, 4614, 11628, 11684, 11688, 11692, 11696, 5109, 11700, 11704, 0}, {11680, 5609, 4512, 4614, 11628, 11684, 11688, 11692, 11696, 5109, 11700, 11704, 0}, 0, 1, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{2843,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {11708, 11716, 11727, 11737, 11748, 11757, 11766}, {11776, 11780, 11784, 11788, 11792, 11796, 11800}, {11804, 9428, 9428, 9428, 1612, 1612, 1616}, {11806, 11816, 11824, 11832, 11840, 11848, 11855, 11863, 11871, 11878, 11884, 11891, 0}, {11806, 11899, 11907, 11915, 11923, 11931, 11938, 11946, 11954, 11961, 11967, 11974, 0}, {11982, 11987, 1712, 11992, 11997, 12002, 12007, 12012, 12017, 12022, 12027, 12032, 0}, {11982, 11987, 1712, 11992, 11997, 12002, 12007, 12012, 12017, 12022, 12027, 12032, 0}, 2, 1, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2872,2899,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2920,0,0,0,0,0,0,0}},
	{673, 327, 338, {12037, 12047, 12058, 12065, 12072, 12082, 1247}, {12088, 12092, 12097, 12101, 12105, 12110, 12114}, {6516, 6518, 12118, 6522, 6797, 6518, 6522}, {1618, 1625, 12120, 12126, 12132, 8902, 8908, 12137, 1666, 1676, 12144, 1693, 0}, {12153, 12161, 12170, 12177, 12184, 12189, 12196, 12203, 6874, 12211, 12219, 6902, 0}, {5089, 4610, 12228, 4614, 12233, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, {5089, 4610, 12228, 4614, 12233, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, 2, 1, 11, 3, {1208,0,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{2939,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 349, 363, {12245, 190, 211, 6014, 12258, 12275, 12286}, {12299, 12307, 12315, 12323, 12331, 12339, 12347}, {315, 318, 321, 324, 327, 318, 324}, {12355, 343, 360, 369, 12370, 12377, 12386, 401, 414, 433, 450, 465, 0}, {12355, 343, 360, 369, 12370, 12377, 12386, 401, 414, 433, 450, 465, 0}, {12395, 12403, 12411, 6376, 12370, 12419, 12427, 6384, 12435, 6402, 12445, 6420, 0}, {12395, 12403, 12411, 6376, 12370, 12419, 12427, 6384, 12435, 6402, 12445, 6420, 0}, 0, 1, 11, 3, {2953,0,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2963,0,0,0,0,0,0,0}},
	{925, 0, 0, {12455, 12463, 12472, 12481, 12490, 12497, 12507}, {12516, 12520, 12524, 12528, 12532, 12535, 12539}, {0, 0, 0, 0, 0, 0, 0}, {12543, 12554, 12562, 12572, 12578, 12590, 12599, 12605, 12611, 12619, 12628, 12640, 0}, {12543, 12554, 12562, 12572, 12578, 12590, 12599, 12605, 12611, 12619, 12628, 12640, 0}, {12648, 12652, 12656, 12660, 12664, 1914, 12668, 12672, 12676, 12680, 12684, 12688, 0}, {12648, 12652, 12656, 12660, 12664, 1914, 12668, 12672, 12676, 12680, 12684, 12688, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 0, 0, {12692, 12698, 12711, 12722, 12733, 12742, 12754}, {12516, 12764, 12768, 12772, 12532, 12776, 12780}, {0, 0, 0, 0, 0, 0, 0}, {12784, 12792, 12804, 12816, 12828, 12838, 12850, 12859, 12867, 12875, 12885, 12892, 0}, {12784, 12792, 12804, 12816, 12828, 12838, 12850, 12859, 12867, 12875, 12885, 12892, 0}, {2707, 12906, 12910, 12914, 12918, 12922, 12926, 12930, 12934, 12938, 12942, 12946, 0}, {2707, 12906, 12910, 12914, 12918, 12922, 12926, 12930, 12934, 12938, 12942, 12946, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 0, 0, {12950, 12957, 12472, 12968, 12490, 12977, 12988}, {12688, 12998, 12524, 12528, 12532, 13002, 13006}, {0, 0, 0, 0, 0, 0, 0}, {13010, 13020, 13029, 13037, 13046, 13059, 13071, 13078, 13085, 13092, 13102, 13114, 0}, {13010, 13020, 13029, 13037, 13046, 13059, 13071, 13078, 13085, 13092, 13102, 13114, 0}, {13127, 12776, 13131, 13135, 12664, 13139, 13143, 12672, 13147, 13151, 13155, 13159, 0}, {13127, 12776, 13131, 13135, 12664, 13139, 13143, 12672, 13147, 13151, 13155, 13159, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 0, 0, {13163, 13168, 13174, 13184, 13196, 13204, 13215}, {13224, 13228, 13232, 13236, 13240, 12535, 13244}, {0, 0, 0, 0, 0, 0, 0}, {13248, 13258, 13268, 13275, 13282, 1861, 13287, 13294, 13301, 13310, 13318, 13326, 0}, {13248, 13258, 13268, 13275, 13282, 1861, 13287, 13294, 13301, 13310, 13318, 13326, 0}, {1914, 1918, 13006, 13334, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 13006, 13334, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 49, 52, {13350, 13357, 13369, 13380, 13393, 13402, 13414}, {12516, 13424, 13428, 13236, 13240, 12535, 13244}, {1285, 1608, 13432, 1610, 1285, 4089, 1608}, {13434, 13258, 13443, 13449, 13282, 1861, 13287, 13294, 13457, 13310, 13318, 13326, 0}, {13467, 13258, 13443, 13449, 13282, 1861, 13287, 13294, 13457, 13310, 13318, 13326, 0}, {1914, 1918, 13478, 13482, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 13478, 13482, 13338, 1931, 1935, 13342, 1943, 1947, 1951, 13346, 0}, 0, 0, 1, 3, {932,3009,0,0,0,0,0,0,0,0,0,0,0,0},{978,997,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 373, 377, {13486, 13493, 13501, 13509, 13518, 13528, 13535}, {13544, 13548, 13552, 13556, 13560, 13564, 13568}, {1285, 1608, 1828, 2735, 1828, 2894, 1285}, {13572, 13581, 13591, 1851, 7756, 13597, 13603, 13609, 1878, 1888, 1896, 7768, 0}, {13572, 13581, 13591, 1851, 7756, 13597, 13603, 13609, 1878, 1888, 1896, 7768, 0}, {13618, 13623, 13628, 13633, 7756, 13638, 13643, 13648, 13653, 13658, 13663, 13668, 0}, {13618, 13623, 13628, 13633, 7756, 13638, 13643, 13648, 13653, 13658, 13663, 13668, 0}, 0, 0, 55, 3, {417,2351,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {13673, 13689, 13714, 13742, 13770, 13798, 13826}, {13845, 13855, 13865, 13875, 13885, 13895, 13905}, {13915, 13919, 13923, 13919, 13927, 13931, 13935}, {13939, 13961, 13989, 14005, 14024, 14040, 14059, 14078, 14100, 14131, 14159, 14184, 0}, {13939, 13961, 13989, 14005, 14024, 14040, 14059, 14078, 14100, 14131, 14159, 14184, 0}, {14212, 14222, 14232, 14242, 14252, 14262, 14272, 14282, 14292, 14302, 14312, 14322, 0}, {14212, 14222, 14232, 14242, 14252, 14262, 14272, 14282, 14292, 14302, 14312, 14322, 0}, 0, 1, 11, 3, {681,3021,0,0,0,0,0,0,0,0,0,0,0,0},{42,1029,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 49, 52, {4231, 14332, 14343, 14353, 14363, 14373, 14387}, {14399, 14403, 14408, 14413, 14417, 14422, 14427}, {1285, 1608, 1610, 1608, 4089, 1614, 1616}, {1618, 1625, 3504, 4376, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 4376, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 2, 1, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{1314,1455,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 381, 409, {14431, 14450, 14469, 14491, 14510, 14532, 14557}, {14576, 14586, 14596, 14609, 14619, 14632, 14648}, {14658, 14662, 14669, 14676, 14683, 14690, 14697}, {14701, 14717, 14736, 14752, 14771, 14778, 14788, 14804, 14820, 14839, 14861, 14877, 0}, {14701, 14717, 14736, 14752, 14771, 14778, 14788, 14804, 14820, 14839, 14861, 14877, 0}, {14896, 14906, 14736, 14752, 14771, 14778, 14919, 14932, 14942, 14955, 14974, 14984, 0}, {14896, 14906, 14736, 14752, 14771, 14778, 14919, 14932, 14942, 14955, 14974, 14984, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{3033, 49, 52, {14997, 15006, 15015, 15025, 15035, 15045, 15057}, {15065, 15070, 15074, 15078, 15082, 15087, 15092}, {15096, 15100, 15103, 15106, 15109, 15113, 15117}, {15120, 15127, 15132, 1851, 15138, 15144, 15151, 15157, 15165, 15175, 15183, 15192, 0}, {15120, 15127, 15132, 1851, 15138, 15144, 15151, 15157, 15165, 15175, 15183, 15192, 0}, {1914, 15202, 2791, 1927, 15206, 15210, 15215, 15219, 15223, 15227, 1951, 15231, 0}, {1914, 15202, 2791, 1927, 15206, 15210, 15215, 15219, 15223, 15227, 1951, 15231, 0}, 0, 0, 1, 3, {18,2351,0,0,0,0,0,0,0,0,0,0,0,0},{3048,3074,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{3094,0,0,0,0,0,0,0}},
	{925, 431, 436, {15236, 15248, 15259, 15273, 15285, 15295, 15305}, {15316, 15321, 15326, 15331, 15336, 15341, 15346}, {1285, 2894, 1608, 4532, 1828, 13432, 1616}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, 2, 1, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{109, 441, 444, {15872, 15877, 7673, 7680, 15883, 15890, 7697}, {15897, 15901, 7711, 7715, 15905, 7723, 7727}, {9428, 11804, 1285, 7731, 3099, 2892, 1285}, {7733, 7741, 15909, 1851, 7756, 1931, 15913, 15919, 1878, 1888, 1896, 15924, 0}, {7733, 7741, 15909, 1851, 7756, 1931, 15913, 15919, 1878, 1888, 1896, 15924, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 15933, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 15933, 1943, 1947, 1951, 13346, 0}, 0, 1, 1, 3, {2764,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {15937, 15954, 15971, 15988, 16005, 16022, 16031}, {16042, 16047, 16052, 16057, 16062, 16067, 16072}, {16077, 16080, 6081, 6081, 16083, 16077, 6081}, {16086, 16099, 16110, 16123, 16134, 16145, 16158, 16169, 16180, 16197, 16208, 16221, 0}, {16240, 16253, 16264, 16277, 16288, 16299, 16312, 16323, 16334, 16351, 16362, 16375, 0}, {16394, 16402, 16410, 16418, 16426, 16434, 16442, 16450, 16458, 16466, 16474, 16482, 0}, {16394, 16402, 16410, 16418, 16426, 16434, 16442, 16450, 16458, 16466, 16474, 16482, 0}, 0, 1, 1, 3, {18,3112,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3125, 448, 453, {16490, 16507, 16524, 16541, 16558, 16575, 16584}, {16597, 16605, 16613, 16623, 16633, 16575, 16643}, {16077, 16080, 16651, 16651, 16083, 16077, 16654}, {16657, 16670, 9888, 16685, 9908, 16698, 16707, 9929, 16716, 16733, 16748, 16761, 0}, {6087, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 1, 55, 3, {3132,0,0,0,0,0,0,0,0,0,0,0,0,0},{3141,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{3160,0,0,0,0,0,0,0}},
	{109, 49, 52, {16776, 16785, 16794, 16802, 16811, 16820, 16827}, {16776, 16785, 16794, 16802, 16811, 16820, 16827}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {7733, 7741, 16836, 16842, 7756, 1861, 15913, 16849, 13301, 16856, 13318, 16863, 0}, {7733, 7741, 16836, 16842, 7756, 1861, 15913, 16849, 13301, 16856, 13318, 16863, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 16871, 1943, 1947, 1951, 7781, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 16871, 1943, 1947, 1951, 7781, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 0, 0, {16875, 16886, 16895, 16904, 16915, 16925, 16930}, {16937, 16941, 16944, 16947, 16951, 9416, 16954}, {16958, 1828, 1285, 7339, 1280, 9428, 16961}, {16964, 16972, 11617, 11622, 16979, 16984, 16990, 12137, 16996, 17006, 17015, 11673, 0}, {16964, 16972, 11617, 11622, 16979, 16984, 16990, 12137, 16996, 17006, 17015, 11673, 0}, {17023, 17028, 11617, 4614, 16979, 16984, 16990, 12237, 11696, 5109, 17032, 11704, 0}, {17023, 17028, 11617, 4614, 16979, 16984, 16990, 12237, 11696, 5109, 17032, 11704, 0}, 0, 1, 11, 3, {3176,681,0,0,0,0,0,0,0,0,0,0,0,0},{3191,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{3223,0,0,0,0,0,0,0}},
	{925, 458, 461, {17037, 17047, 17056, 17065, 17076, 17086, 17091}, {17098, 17102, 17107, 17112, 17117, 7723, 17121}, {17126, 1828, 1285, 5210, 1280, 2892, 1285}, {11533, 11540, 7354, 11547, 2760, 17128, 17133, 17138, 17145, 17153, 11589, 11596, 0}, {11603, 11610, 11617, 11622, 11628, 11632, 11637, 8914, 17160, 17168, 11666, 11673, 0}, {12906, 17175, 2791, 1927, 2760, 17179, 17183, 17187, 7707, 1947, 17191, 17195, 0}, {12906, 17175, 2791, 1927, 2760, 17179, 17183, 17187, 7707, 1947, 17191, 17195, 0}, 0, 1, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{109, 49, 52, {17199, 17214, 17229, 17244, 17261, 17282, 17293}, {17304, 17312, 17320, 17328, 17336, 17346, 17354}, {17362, 16080, 6081, 6084, 6078, 17365, 16651}, {17368, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {17368, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {17383, 12403, 12411, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, {17383, 12403, 12411, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, 0, 1, 11, 3, {681,775,2098,9,417,3258,0,0,0,0,0,0,0,0},{3258,0,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,3278,0,0,0,0,0,0}},
	{109, 49, 52, {17393, 17412, 17431, 17456, 17475, 17509, 17534}, {17553, 17563, 17573, 17589, 17599, 17624, 17640}, {17650, 17654, 17661, 17665, 17672, 17679, 17686}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, 0, 0, 55, 11, {755,1062,744,755,744,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{1151,1146,3295,3304,0,0,0,0,0,0,0,0},{1173,1165,3312,3324,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 49, 52, {18518, 18537, 18556, 18578, 18597, 18619, 18644}, {18663, 18673, 18683, 18696, 18706, 18719, 18735}, {18745, 18749, 18756, 18763, 18770, 18777, 18784}, {18788, 18816, 18844, 18860, 18879, 18886, 18896, 18912, 18928, 18956, 18978, 19000, 0}, {18788, 18816, 18844, 18860, 18879, 18886, 18896, 18912, 18928, 18956, 18978, 19000, 0}, {19025, 19044, 18844, 18860, 18879, 18886, 18896, 18912, 19063, 19079, 19095, 19105, 0}, {19025, 19044, 18844, 18860, 18879, 18886, 18896, 18912, 19063, 19079, 19095, 19105, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 5, 8, {19118, 19137, 19156, 19181, 19200, 19222, 19247}, {19266, 19276, 19286, 19302, 19312, 19325, 19341}, {19351, 19355, 19362, 19366, 19373, 19380, 19387}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, {19391, 19413, 19435, 19457, 19476, 19483, 19493, 19509, 19525, 19556, 19578, 19600, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 494, 519, {19625, 19644, 19666, 19691, 19707, 19729, 19748}, {19758, 19772, 19786, 19800, 19811, 19825, 19748}, {19839, 19846, 19853, 19860, 19867, 19874, 19881}, {19885, 19901, 19926, 19945, 19964, 19971, 19984, 19997, 20016, 20047, 20072, 20094, 0}, {19885, 19901, 19926, 19945, 19964, 19971, 19984, 19997, 20016, 20047, 20072, 20094, 0}, {20119, 20127, 20141, 20155, 19964, 19971, 19984, 20166, 20174, 20188, 20199, 20207, 0}, {20119, 20127, 20141, 20155, 19964, 19971, 19984, 20166, 20174, 20188, 20199, 20207, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {20218, 20240, 20262, 20287, 20309, 20334, 20362}, {20384, 20394, 20404, 20417, 20427, 20440, 20456}, {20466, 20470, 20477, 20481, 20488, 20495, 20502}, {20506, 20522, 20547, 20566, 20588, 20595, 20608, 20621, 20640, 20671, 20696, 20715, 0}, {20506, 20522, 20547, 20566, 20588, 20595, 20608, 20621, 20640, 20671, 20696, 20715, 0}, {20740, 20747, 20547, 20763, 20588, 20595, 20608, 20621, 20779, 20801, 20817, 20827, 0}, {20740, 20747, 20547, 20763, 20588, 20595, 20608, 20621, 20779, 20801, 20817, 20827, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 544, 572, {20843, 20865, 20884, 20906, 20925, 20947, 20972}, {20991, 21004, 21014, 21027, 21037, 21050, 21066}, {21076, 21083, 21090, 21097, 21104, 21111, 21118}, {21122, 21138, 21163, 21182, 21204, 21211, 21224, 21237, 21256, 21287, 21312, 21334, 0}, {21122, 21138, 21163, 21182, 21204, 21211, 21224, 21237, 21256, 21287, 21312, 21334, 0}, {21359, 21366, 21163, 21382, 21204, 21211, 21224, 21398, 21405, 21427, 21443, 21456, 0}, {21359, 21366, 21163, 21382, 21204, 21211, 21224, 21398, 21405, 21427, 21443, 21456, 0}, 0, 0, 55, 3, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{3353, 49, 52, {21472, 21500, 21534, 21562, 21590, 21621, 21658}, {21686, 21699, 21718, 21734, 21747, 21766, 21785}, {21795, 21802, 21809, 21816, 21823, 21836, 21843}, {21847, 21866, 21894, 21916, 21935, 21948, 21958, 21971, 21996, 22027, 22052, 22068, 0}, {21847, 21866, 21894, 21916, 21935, 21948, 21958, 21971, 21996, 22027, 22052, 22068, 0}, {22087, 22097, 22116, 22126, 21935, 21948, 21958, 22142, 22149, 22174, 22190, 22200, 0}, {22087, 22097, 22116, 22126, 21935, 21948, 21958, 22142, 22149, 22174, 22190, 22200, 0}, 0, 0, 55, 11, {755,1062,775,2098,0,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{1151,1146,3295,3304,0,0,0,0,0,0,0,0},{1173,1165,3312,3324,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 594, 622, {22213, 22232, 22251, 22276, 22295, 22329, 22354}, {22373, 17563, 17573, 17589, 22383, 22408, 17640}, {0, 0, 0, 0, 0, 0, 0}, {22424, 22449, 22480, 22496, 17787, 17794, 17804, 22515, 22531, 22562, 22584, 22606, 0}, {22424, 22449, 22480, 22496, 17787, 17794, 17804, 22515, 22531, 22562, 22584, 22606, 0}, {22631, 22644, 22480, 22496, 17787, 17794, 17804, 22663, 22670, 22686, 22702, 22712, 0}, {22631, 22644, 22480, 22496, 17787, 17794, 17804, 22663, 22670, 22686, 22702, 22712, 0}, 0, 0, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{3361,0,0,0,0,0,0,0,0,0},{583,591,266,0,0,0,0,0,0,0,0,0},{600,611,271,0,0,0,0,0,0},{3380,3388,0,0,0,0,0,0}},
	{1, 644, 656, {14431, 14450, 22725, 14491, 14510, 14532, 14557}, {14576, 14586, 22747, 14609, 14619, 14632, 14648}, {14658, 14662, 14669, 14676, 14683, 14690, 14697}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 22855, 22871, 22896, 22918, 22946, 0}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 22855, 22871, 22896, 22918, 22946, 0}, {22968, 22981, 14736, 23000, 22835, 14778, 22842, 23016, 23023, 23042, 23058, 23080, 0}, {22968, 22981, 14736, 23000, 22835, 14778, 22842, 23016, 23023, 23042, 23058, 23080, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 665, 670, {23096, 23103, 23114, 23127, 23140, 23151, 23164}, {23175, 23180, 23185, 23190, 23195, 23200, 23205}, {23175, 23180, 23185, 23190, 23195, 23200, 23205}, {23210, 23236, 23264, 23294, 23324, 23350, 23380, 23406, 23434, 23458, 23486, 23523, 0}, {23210, 23236, 23264, 23294, 23324, 23350, 23380, 23406, 23434, 23458, 23486, 23523, 0}, {23562, 23574, 23586, 23598, 23610, 23622, 23634, 23646, 23658, 23670, 23683, 23696, 0}, {23562, 23574, 23586, 23598, 23610, 23622, 23634, 23646, 23658, 23670, 23683, 23696, 0}, 0, 1, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3398,3436,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{3468, 675, 697, {23709, 23737, 23765, 23802, 23833, 23867, 23898}, {23932, 23948, 23964, 23989, 24008, 24030, 24049}, {24071, 24078, 24085, 24095, 24105, 24115, 24125}, {24138, 24172, 24209, 24246, 24280, 24311, 24348, 24385, 24425, 24459, 24493, 24542, 0}, {24591, 24622, 24656, 24690, 24721, 24749, 24783, 24817, 24854, 24885, 24916, 24962, 0}, {25008, 25021, 25034, 25047, 25060, 25073, 25086, 25099, 25112, 25125, 25141, 25157, 0}, {25008, 25021, 25034, 25047, 25060, 25073, 25086, 25099, 25112, 25125, 25141, 25157, 0}, 0, 0, 1, 3, {379,388,397,428,417,406,446,439,453,0,0,0,0,0},{3492,3535,3583,3615,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{3652,666,0,0,0,0,0,0}},
	{109, 722, 725, {25173, 25182, 25192, 25204, 25217, 25226, 25238}, {25250, 25254, 12926, 25259, 25263, 25267, 25271}, {1285, 25275, 1608, 1608, 11804, 4532, 1285}, {25278, 25285, 25294, 25301, 1857, 25308, 25316, 25327, 25332, 25337, 25344, 25353, 0}, {25278, 25285, 25294, 25301, 1857, 25308, 25316, 25327, 25332, 25337, 25344, 25353, 0}, {25361, 25365, 12926, 25369, 1857, 25373, 25377, 25327, 25332, 25381, 25385, 25390, 0}, {25361, 25365, 12926, 25369, 1857, 25373, 25377, 25327, 25332, 25381, 25385, 25390, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {25395, 25417, 25433, 25452, 25462, 25493, 25509}, {25395, 25417, 25433, 25452, 25462, 25493, 25509}, {25522, 25526, 25522, 25530, 25530, 25534, 25534}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, {25538, 25551, 25570, 25583, 25596, 25609, 25628, 25647, 25660, 25676, 25689, 25714, 0}, 0, 0, 1, 3, {9,417,0,0,0,0,0,0,0,0,0,0,0,0},{894,2363,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{3685,0,0,0,0,0,0,0}},
	{109, 728, 753, {25727, 25752, 25771, 25799, 25818, 25843, 25862}, {25884, 25900, 25910, 25929, 25939, 25955, 25965}, {25978, 25985, 25989, 25993, 25997, 26004, 26011}, {26015, 26034, 26050, 26063, 26076, 26098, 26117, 26139, 26155, 26171, 26184, 26200, 0}, {26015, 26034, 26050, 26063, 26076, 26098, 26117, 26139, 26155, 26171, 26184, 26200, 0}, {26216, 26225, 26234, 26243, 26252, 26261, 26273, 26282, 26291, 26300, 26309, 26318, 0}, {26216, 26225, 26234, 26243, 26252, 26261, 26273, 26282, 26291, 26300, 26309, 26318, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{3720,894,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 778, 794, {26327, 26355, 26377, 26396, 26421, 26446, 26465}, {26327, 26355, 26377, 26396, 26421, 26446, 26465}, {26475, 26475, 26479, 26483, 26487, 26491, 26495}, {26499, 26524, 26555, 26565, 26578, 26585, 26598, 26620, 26636, 26661, 26692, 26717, 0}, {26499, 26524, 26555, 26565, 26578, 26585, 26598, 26620, 26636, 26661, 26692, 26717, 0}, {26739, 26749, 26555, 26756, 26578, 26585, 26760, 26767, 26771, 26781, 26797, 26807, 0}, {26739, 26749, 26555, 26756, 26578, 26585, 26760, 26767, 26771, 26781, 26797, 26807, 0}, 0, 0, 55, 3, {744,304,0,0,0,0,0,0,0,0,0,0,0,0},{3747,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 165, 170, {2803, 26814, 2817, 26819, 26829, 26835, 2850}, {26842, 26847, 26852, 26857, 26863, 26868, 26873}, {1828, 1616, 1608, 1608, 2890, 2894, 1285}, {26879, 26887, 26896, 26902, 26908, 26913, 26919, 26925, 26932, 26941, 26949, 26958, 0}, {26967, 26975, 2910, 666, 5557, 26984, 26990, 2933, 5574, 5583, 5591, 26996, 0}, {27005, 13623, 26852, 27010, 26908, 26913, 27015, 27020, 27025, 27030, 13663, 27035, 0}, {27005, 13623, 26852, 27010, 26908, 26913, 27015, 27020, 27025, 27030, 13663, 27035, 0}, 2, 1, 1, 3, {18,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1314,1261,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 644, 804, {27040, 14450, 27068, 14491, 14510, 14532, 14557}, {14576, 14586, 22747, 14609, 14619, 14632, 14648}, {0, 0, 0, 0, 0, 0, 0}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 27087, 27103, 27131, 22918, 22946, 0}, {22760, 22785, 14736, 22816, 22835, 14778, 22842, 27087, 27103, 27131, 22918, 22946, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, {4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4765, 4768, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,591,583,0,0,0,0,0,0,0,0},{89,271,611,600,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 816, 828, {27153, 27169, 27185, 27213, 27229, 27272, 27297}, {27153, 27169, 27325, 27213, 27335, 27357, 27370}, {27380, 27384, 27388, 27392, 27396, 27409, 27416}, {27423, 27442, 27467, 27486, 27511, 27524, 27537, 27550, 27572, 27606, 27631, 27659, 0}, {27423, 27442, 27467, 27486, 27511, 27524, 27537, 27550, 27572, 27606, 27631, 27659, 0}, {27687, 27694, 27704, 27486, 27511, 27524, 27537, 27717, 27727, 27740, 27750, 27763, 0}, {27687, 27694, 27704, 27486, 27511, 27524, 27537, 27717, 27727, 27740, 27750, 27763, 0}, 0, 1, 55, 11, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{3304,71,0,0,0,0,0,0,0,0,0,0},{3324,89,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 866, 876, {28241, 28251, 28258, 28271, 28281, 28291, 28301}, {28241, 28251, 28311, 28271, 28281, 28291, 28301}, {28321, 28325, 28329, 28333, 28337, 28341, 28345}, {28349, 28365, 28381, 28391, 28404, 28411, 28418, 28428, 28441, 28460, 28476, 28492, 0}, {28349, 28365, 28381, 28391, 28404, 28411, 28418, 28428, 28441, 28460, 28476, 28492, 0}, {28508, 28518, 28381, 28528, 28404, 28411, 28418, 28538, 28548, 28558, 28568, 28578, 0}, {28508, 28518, 28381, 28528, 28404, 28411, 28418, 28538, 28548, 28558, 28568, 28578, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 381, 409, {28795, 28814, 28833, 28858, 28877, 28899, 28924}, {28943, 14586, 28953, 14609, 28969, 14632, 14648}, {28982, 14662, 28986, 14676, 28990, 14690, 14697}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 14771, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, 0, 0, 1, 3, {932,941,948,957,460,417,968,0,0,0,0,0,0,0},{3800,3820,42,2448,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{3388,0,0,0,0,0,0,0}},
	{109, 49, 52, {29173, 29179, 29187, 29195, 29204, 29215, 29221}, {29227, 29230, 3084, 4997, 3090, 29233, 1275}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {29236, 29247, 13591, 1851, 29258, 29264, 2769, 13609, 29269, 1888, 29279, 29288, 0}, {29236, 29247, 13591, 1851, 29258, 29264, 2769, 13609, 29269, 1888, 29279, 29288, 0}, {1914, 1918, 29297, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 7781, 0}, {1914, 1918, 29297, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 7781, 0}, 2, 1, 55, 3, {744,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 0, 0, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, {29301, 29308, 29317, 29332, 29343, 29352, 29359, 29366, 29373, 29384, 29397, 29410, 0}, 0, 6, 1, 3, {379,417,0,0,0,0,0,0,0,0,0,0,0,0},{894,1217,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {29415, 29422, 29428, 29435, 29446, 29454, 29463}, {29470, 29474, 2791, 29478, 29482, 29486, 7727}, {29470, 29474, 2791, 29478, 29482, 29486, 7727}, {29490, 29496, 29504, 26902, 29510, 29515, 29521, 26925, 29527, 29537, 29545, 29555, 0}, {29490, 29496, 29504, 26902, 29510, 29515, 29521, 26925, 29527, 29537, 29545, 29555, 0}, {29565, 29569, 2791, 29573, 2760, 29577, 29581, 16871, 15223, 1947, 29585, 13346, 0}, {29565, 29569, 2791, 29573, 2760, 29577, 29581, 16871, 15223, 1947, 29585, 13346, 0}, 0, 0, 1, 3, {932,3009,0,0,0,0,0,0,0,0,0,0,0,0},{978,997,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 49, 52, {29808, 29815, 29823, 29830, 29837, 29845, 29854}, {29861, 29865, 29869, 29873, 29877, 7723, 28638}, {1616, 1616, 1610, 1616, 9428, 2892, 9428}, {29881, 29889, 29899, 29905, 29913, 29918, 29923, 29928, 29935, 16856, 29943, 29951, 0}, {29881, 29889, 29899, 29905, 29913, 29918, 29923, 29928, 29935, 16856, 29943, 29951, 0}, {1914, 29959, 2791, 29963, 2760, 28764, 28768, 29967, 2731, 1947, 29971, 13346, 0}, {1914, 29959, 2791, 29963, 2760, 28764, 28768, 29967, 2731, 1947, 29971, 13346, 0}, 0, 0, 1, 3, {295,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1010,1029,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 928, 939, {29975, 29993, 30008, 30030, 30043, 30057, 30074}, {30098, 30106, 30111, 30030, 30043, 30123, 30130}, {0, 0, 0, 0, 0, 0, 0}, {30144, 30166, 30182, 30202, 30216, 30233, 30248, 30265, 30279, 30292, 30311, 30325, 0}, {30144, 30166, 30182, 30202, 30216, 30233, 30248, 30265, 30279, 30292, 30311, 30325, 0}, {30344, 30359, 30368, 30381, 30388, 30398, 30406, 30416, 30423, 30429, 30441, 30448, 0}, {30344, 30359, 30368, 30381, 30388, 30398, 30406, 30416, 30423, 30429, 30441, 30448, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 0, 0, {30460, 30468, 12472, 12968, 12490, 30479, 30489}, {12516, 12998, 12524, 12528, 12532, 12535, 30498}, {0, 0, 0, 0, 0, 0, 0}, {30502, 30511, 30521, 30529, 7756, 2764, 30537, 30543, 30552, 30561, 30570, 30579, 0}, {30502, 30511, 30521, 30529, 7756, 2764, 30537, 30543, 30552, 30561, 30570, 30579, 0}, {1914, 1918, 13006, 30588, 7756, 1931, 1935, 16871, 15223, 1947, 30592, 13346, 0}, {1914, 1918, 13006, 30588, 7756, 1931, 1935, 16871, 15223, 1947, 30592, 13346, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{3834, 949, 955, {30596, 30604, 30613, 30624, 30634, 30646, 30654}, {12516, 30664, 30669, 30674, 30679, 30683, 30687}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 30691, 30698, 30706, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 30691, 30698, 30706, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 30710, 29573, 30706, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 30710, 29573, 30706, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {775,9,755,0,0,0,0,0,0,0,0,0,0,0},{721,3843,798,2541,3856,3881,0,0,0,0},{71,266,1146,3907,0,0,0,0,0,0,0,0},{89,3919,3934,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3950, 965, 970, {30715, 30722, 30737, 30751, 30767, 30782, 30798}, {4528, 30813, 4512, 30817, 30821, 30825, 30829}, {1285, 9428, 1608, 1280, 1285, 1610, 9428}, {5011, 5019, 30833, 30840, 30847, 1649, 1654, 30852, 30862, 30873, 30882, 30892, 0}, {5011, 5019, 30833, 30840, 30847, 1649, 1654, 30852, 30862, 30873, 30882, 30892, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 5101, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 5101, 5105, 5109, 4642, 6911, 0}, 0, 0, 55, 3, {744,755,417,764,0,0,0,0,0,0,0,0,0,0},{3963,721,2561,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 975, 980, {30902, 30918, 30926, 30934, 30943, 30955, 30965}, {30975, 30981, 30987, 30991, 30995, 31003, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {31010, 31023, 31037, 31046, 30706, 31052, 31057, 31065, 13301, 31078, 13318, 13326, 0}, {31010, 31023, 31037, 31046, 30706, 31052, 31057, 31065, 13301, 31078, 13318, 13326, 0}, {31087, 1918, 31091, 13334, 30706, 31095, 1935, 31099, 1943, 31107, 1951, 13346, 0}, {31087, 1918, 31091, 13334, 30706, 31095, 1935, 31099, 1943, 31107, 1951, 13346, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 985, 988, {31113, 31121, 31129, 31137, 31144, 31152, 31160}, {31168, 31172, 31176, 31180, 7719, 31184, 31188}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {31192, 31200, 31212, 31224, 31229, 31236, 31247, 31258, 31266, 31275, 31288, 31296, 0}, {31192, 31200, 31212, 31224, 31229, 31236, 31247, 31258, 31266, 31275, 31288, 31296, 0}, {31303, 31307, 31311, 31315, 31319, 31323, 31327, 31331, 31335, 31339, 25271, 12918, 0}, {31303, 31307, 31311, 31315, 31319, 31323, 31327, 31331, 31335, 31339, 25271, 12918, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{978,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 991, 1011, {31343, 31356, 31366, 28271, 31376, 31386, 31396}, {31406, 31413, 31420, 31427, 31434, 31441, 31448}, {28325, 28325, 31455, 28333, 31459, 28341, 31463}, {31467, 31474, 31487, 31500, 31513, 31526, 31533, 31543, 31553, 31569, 31582, 31592, 0}, {31467, 31474, 31487, 31500, 31513, 31526, 31533, 31543, 31553, 31569, 31582, 31592, 0}, {31467, 31605, 31612, 31619, 31626, 31526, 31633, 31640, 31647, 31654, 31661, 31668, 0}, {31467, 31605, 31612, 31619, 31626, 31526, 31633, 31640, 31647, 31654, 31661, 31668, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{4575,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {31675, 31683, 31693, 31702, 31712, 31721, 31731}, {31740, 31743, 31746, 31749, 31752, 31755, 31758}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {31761, 31769, 31779, 31786, 7756, 31796, 31801, 31807, 31816, 31827, 31837, 31846, 0}, {31761, 31769, 31779, 31786, 7756, 31796, 31801, 31807, 31816, 31827, 31837, 31846, 0}, {31855, 31860, 31865, 31870, 7756, 31876, 31881, 31886, 31892, 31897, 31903, 31908, 0}, {31855, 31860, 31865, 31870, 7756, 31876, 31881, 31886, 31892, 31897, 31903, 31908, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 1031, 1035, {31913, 31918, 31925, 31933, 31940, 31948, 31954}, {31960, 15901, 29869, 31964, 15905, 31184, 7727}, {9428, 11804, 1610, 9428, 31968, 2892, 1285}, {31971, 31985, 31998, 32014, 32027, 32041, 32054, 32069, 32085, 32101, 32115, 32137, 0}, {31971, 31985, 31998, 32014, 32027, 32041, 32054, 32069, 32085, 32101, 32115, 32137, 0}, {32160, 32164, 25271, 32168, 32172, 32176, 32180, 32184, 32188, 32192, 32196, 32200, 0}, {32160, 32164, 25271, 32168, 32172, 32176, 32180, 32184, 32188, 32192, 32196, 32200, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{3800,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{4019, 1039, 1046, {32204, 32214, 32224, 32234, 32244, 32254, 32264}, {32274, 32281, 32288, 32295, 32302, 32309, 32316}, {32323, 32327, 32331, 32335, 32339, 32343, 32347}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, {32351, 32358, 32365, 32372, 32379, 32386, 32393, 32400, 32407, 32414, 32421, 32431, 0}, 0, 0, 1, 3, {379,388,397,428,417,406,0,0,0,0,0,0,0,0},{4042,4066,4096,4126,4143,0,0,0,0,0},{583,266,71,0,0,0,0,0,0,0,0,0},{600,271,89,0,0,0,0,0,0},{4166,666,0,0,0,0,0,0}},
	{109, 975, 1053, {25250, 29474, 32441, 32448, 32458, 32463, 32470}, {25250, 29474, 32477, 32482, 32458, 32487, 32492}, {32497, 1616, 32500, 32503, 17126, 4532, 1825}, {32506, 32513, 32441, 32524, 32530, 32534, 32543, 32550, 32555, 32564, 32569, 32572, 0}, {32506, 32513, 32441, 32524, 32530, 32534, 32543, 32550, 32555, 32564, 32569, 32572, 0}, {32578, 32583, 32591, 32597, 32530, 32602, 32608, 32550, 32614, 32564, 32569, 32620, 0}, {32578, 32583, 32591, 32597, 32530, 32602, 32608, 32550, 32614, 32564, 32569, 32620, 0}, 2, 1, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3125, 1058, 1064, {32625, 32642, 32657, 32674, 32691, 32708, 32717}, {32728, 32733, 32738, 32743, 32748, 32753, 32758}, {32763, 10152, 10155, 10158, 10161, 10164, 10167}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, {32766, 32779, 32792, 32801, 32814, 32821, 32832, 32843, 32858, 32875, 32892, 32907, 0}, 0, 0, 55, 3, {388,397,417,428,0,0,0,0,0,0,0,0,0,0},{4183,4204,4230,4271,4317,0,0,0,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{4331,2717,666,0,0,0,0,0}},
	{673, 1070, 1075, {32922, 32930, 32940, 32950, 32959, 32969, 32977}, {32987, 32991, 32996, 33000, 33004, 33008, 13568}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 33012, 33021, 33032, 33041, 33051, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 33012, 33021, 33032, 33041, 33051, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 1, 3, {18,9,775,755,417,0,0,0,0,0,0,0,0,0},{1217,1234,894,0,0,0,0,0,0,0},{71,266,1151,1243,1253,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{4352, 1080, 1085, {33061, 33086, 33111, 33136, 33149, 33164, 33181}, {33196, 33201, 33206, 33211, 33216, 33221, 310}, {16083, 16083, 33226, 6081, 6084, 16083, 6081}, {33229, 33248, 33263, 33285, 33305, 33319, 33333, 33345, 33369, 33391, 33408, 33425, 0}, {33442, 33461, 33476, 33498, 33518, 33534, 33550, 33564, 33590, 33614, 33631, 33425, 0}, {33648, 33657, 33666, 33673, 33680, 33687, 33694, 33701, 33708, 33715, 33722, 33729, 0}, {33648, 33657, 33666, 33673, 33680, 33687, 33694, 33701, 33708, 33715, 33722, 33729, 0}, 0, 1, 11, 3, {681,1208,417,4368,4378,0,0,0,0,0,0,0,0,0},{4391,4426,4455,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{4490,0,0,0,0,0,0,0}},
	{925, 49, 52, {33736, 33748, 33759, 33771, 33783, 33793, 33805}, {33820, 33825, 33830, 33835, 33840, 33845, 33850}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {33855, 33864, 33876, 33884, 33889, 33899, 33906, 33915, 33922, 33928, 33937, 33948, 0}, {33855, 33864, 33876, 33884, 33889, 33899, 33906, 33915, 33922, 33928, 33937, 33948, 0}, {33956, 33961, 33966, 33971, 33976, 33981, 33986, 33840, 33991, 33996, 34001, 34006, 0}, {33956, 33961, 33966, 33971, 33976, 33981, 33986, 33840, 33991, 33996, 34001, 34006, 0}, 0, 0, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{4506, 1090, 1092, {34011, 34024, 34032, 34041, 34051, 34061, 34070}, {34082, 34086, 34090, 34094, 34098, 34102, 34106}, {1828, 1616, 1608, 5210, 9428, 4089, 1285}, {34110, 34124, 34135, 34144, 34155, 34167, 34181, 34193, 34206, 34219, 34231, 34244, 0}, {34258, 34275, 34289, 34301, 34315, 34330, 34344, 34356, 34371, 34386, 34400, 34415, 0}, {34431, 34436, 34442, 34448, 34453, 34459, 34465, 34470, 34476, 34481, 15862, 34487, 0}, {34431, 34436, 34442, 34448, 34453, 34459, 34465, 34470, 34476, 34481, 15862, 34487, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{4517,4539,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 13, 19, {538, 547, 555, 563, 572, 579, 589}, {598, 602, 606, 610, 614, 618, 622}, {626, 629, 632, 635, 638, 641, 644}, {647, 653, 660, 666, 672, 677, 682, 689, 695, 704, 712, 721, 0}, {730, 739, 749, 758, 768, 776, 784, 794, 804, 816, 828, 840, 0}, {852, 857, 660, 863, 672, 677, 868, 873, 877, 882, 887, 892, 0}, {852, 857, 660, 863, 672, 677, 868, 873, 877, 882, 887, 892, 0}, 2, 1, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{315,338,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {967, 974, 981, 988, 995, 1002, 1009}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {379,388,397,406,417,428,439,446,453,460,0,0,0,0},{469,491,519,547,562,0,0,0,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{4612, 57, 63, {1747, 1755, 1762, 1771, 1780, 1791, 1799}, {1807, 1810, 1813, 1816, 1819, 1822, 1825}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {681,0,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 5, 8, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 2, 1, 1, 3, {18,9,857,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,876,2462,0,0,0,0,0,0},{71,266,62,906,0,0,0,0,0,0,0,0},{89,271,77,914,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1042, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {34822, 4610, 4512, 5613, 11628, 5093, 5097, 4630, 5105, 34826, 4642, 4646, 0}, {34822, 4610, 4512, 5613, 11628, 5093, 5097, 4630, 5105, 34826, 4642, 4646, 0}, 0, 0, 1, 3, {18,864,9,1054,857,755,417,0,0,0,0,0,0,0},{1069,1124,0,0,0,0,0,0,0,0},{62,906,266,71,0,0,0,0,0,0,0,0},{77,914,271,89,0,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 2, 1, 55, 3, {755,18,9,744,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,266,1151,1243,1253,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{4621, 49, 52, {4442, 4451, 4459, 4468, 4479, 4488, 4497}, {4504, 4508, 4512, 4516, 4520, 4524, 4528}, {1828, 1616, 1608, 1608, 4532, 2894, 1285}, {4534, 4542, 2910, 4551, 4558, 4565, 4572, 2933, 4579, 4589, 712, 4597, 0}, {4534, 4542, 2910, 4551, 4558, 4565, 4572, 2933, 4579, 4589, 712, 4597, 0}, {4606, 4610, 4512, 4614, 4618, 4622, 4626, 4630, 4634, 4638, 4642, 4646, 0}, {4606, 4610, 4512, 4614, 4618, 4622, 4626, 4630, 4634, 4638, 4642, 4646, 0}, 2, 1, 11, 3, {681,2785,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{4629,0,0,0,0,0,0,0}},
	{109, 165, 170, {4932, 4939, 4947, 4955, 4964, 4974, 4982}, {4991, 3081, 4994, 4997, 5000, 5003, 5006}, {5009, 1608, 1828, 2735, 1828, 2894, 5009}, {5011, 5019, 5028, 1639, 5034, 1649, 1654, 5038, 1666, 1676, 1684, 1693, 0}, {5011, 5019, 5028, 1639, 5034, 1649, 1654, 5038, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 5047, 1717, 5034, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 5047, 1717, 5034, 1722, 868, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 1, 3, {2764,1054,755,775,2024,417,0,0,0,0,0,0,0,0},{1217,968,894,1304,0,0,0,0,0,0},{266,71,4639,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1100, 1105, {1525, 7197, 34830, 1548, 1555, 1563, 34837}, {1578, 7225, 34845, 1591, 1595, 1599, 34849}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 2, 1, 11, 3, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1042, 165, 170, {2803, 5440, 5454, 5467, 5480, 5493, 2850}, {2803, 34853, 34861, 34868, 34875, 34882, 2850}, {1828, 1285, 1610, 5530, 5530, 1285, 1285}, {5532, 5540, 5550, 666, 5557, 5562, 5568, 2933, 5574, 5583, 5591, 5600, 0}, {5532, 5540, 5550, 666, 5557, 5562, 5568, 2933, 5574, 5583, 5591, 5600, 0}, {5089, 5609, 4512, 5613, 3515, 5093, 5097, 4630, 4634, 5617, 4642, 5621, 0}, {5089, 5609, 4512, 5613, 3515, 5093, 5097, 4630, 4634, 5617, 4642, 5621, 0}, 2, 1, 1, 3, {18,681,744,9,775,755,406,428,417,460,4649,1690,0,0},{1124,1069,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{109, 165, 170, {5792, 5802, 5807, 5814, 5823, 5827, 5834}, {34888, 29474, 2791, 34892, 34896, 34900, 34904}, {1828, 1616, 34909, 1816, 2892, 2894, 1285}, {5866, 5875, 5885, 5892, 3515, 5900, 5906, 1659, 5912, 5923, 5933, 5943, 0}, {5866, 5875, 5885, 5892, 3515, 5900, 5906, 1659, 5912, 5923, 5933, 5943, 0}, {5953, 1707, 1712, 1717, 3515, 5958, 5963, 1727, 2986, 882, 887, 1742, 0}, {5953, 1707, 1712, 1717, 3515, 5958, 5963, 1727, 2986, 882, 887, 1742, 0}, 0, 1, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{4621, 175, 180, {5968, 5991, 211, 6014, 6025, 6040, 6055}, {6070, 285, 290, 295, 300, 305, 310}, {6075, 6078, 6075, 6081, 6084, 6078, 6081}, {6087, 6100, 360, 6115, 380, 6128, 6137, 401, 6146, 6163, 6178, 6191, 0}, {6206, 6219, 6234, 6245, 6258, 6265, 6274, 6283, 6298, 6315, 6330, 6343, 0}, {6358, 6366, 360, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, {6358, 6366, 360, 6376, 380, 6128, 6137, 6384, 6392, 6402, 6410, 6420, 0}, 0, 1, 11, 3, {681,4658,0,0,0,0,0,0,0,0,0,0,0,0},{4675,4699,0,0,0,0,0,0,0,0},{266,0,0,0,0,0,0,0,0,0,0,0},{271,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 208, 211, {7189, 7197, 7205, 1548, 1555, 1563, 7212}, {7220, 7225, 7230, 1591, 7234, 1599, 7239}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {5011, 5019, 3504, 1639, 1645, 1649, 1654, 7244, 1666, 1676, 1684, 1693, 0}, {5011, 5019, 3504, 1639, 1645, 1649, 1654, 7244, 1666, 1676, 1684, 1693, 0}, {1702, 1707, 3504, 1717, 1645, 1649, 1654, 1727, 1732, 1737, 887, 1742, 0}, {1702, 1707, 3504, 1717, 1645, 1649, 1654, 1727, 1732, 1737, 887, 1742, 0}, 2, 1, 55, 3, {744,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {7465, 34912, 7489, 7498, 7505, 7518, 7527}, {7465, 34912, 7489, 7498, 7505, 7518, 7527}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 7578, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, 0, 0, 1, 3, {857,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1010,1029,0,0,0,0,0,0,0,0},{906,266,0,0,0,0,0,0,0,0,0,0},{914,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 1110, 1115, {34919, 34930, 34954, 34984, 35001, 35023, 35032}, {35043, 35047, 35054, 35061, 35065, 35072, 35076}, {4756, 4744, 4746, 4748, 4750, 4752, 4754}, {35080, 9875, 9888, 9897, 9908, 35093, 35102, 9929, 35111, 35128, 35143, 9981, 0}, {35156, 35169, 360, 35182, 380, 35193, 35202, 401, 35211, 35228, 35243, 35256, 0}, {35269, 489, 35276, 496, 380, 35283, 35290, 503, 35297, 517, 35304, 531, 0}, {35269, 489, 35276, 496, 380, 35283, 35290, 503, 35297, 517, 35304, 531, 0}, 0, 1, 11, 3, {681,775,2098,9,417,0,0,0,0,0,0,0,0,0},{894,1261,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 327, 1120, {35311, 35320, 35332, 35341, 35348, 35357, 1247}, {12088, 12092, 35363, 12101, 35368, 35372, 12114}, {6516, 6518, 12118, 6522, 6522, 6518, 6522}, {1618, 1625, 12120, 12126, 1645, 8902, 8908, 12137, 1666, 1676, 12144, 1693, 0}, {12153, 12161, 12170, 12177, 5333, 12189, 12196, 12203, 6874, 12211, 12219, 6902, 0}, {5089, 4610, 12228, 4614, 1645, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, {5089, 4610, 12228, 4614, 1645, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, 2, 1, 124, 3, {692,4717,681,775,417,0,0,0,0,0,0,0,0,0},{798,721,692,0,0,0,0,0,0,0},{71,266,4726,4740,0,0,0,0,0,0,0,0},{89,4753,4770,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 0, 0, {12950, 12957, 12472, 12968, 12490, 12977, 12988}, {12688, 12998, 12524, 12528, 12532, 13002, 13006}, {0, 0, 0, 0, 0, 0, 0}, {13010, 13020, 13029, 13037, 13046, 13059, 13071, 13078, 13085, 13092, 13102, 13114, 0}, {13010, 13020, 13029, 13037, 13046, 13059, 13071, 13078, 13085, 13092, 13102, 13114, 0}, {13127, 12776, 13131, 13135, 12664, 13139, 13143, 12672, 13147, 13151, 13155, 13159, 0}, {13127, 12776, 13131, 13135, 12664, 13139, 13143, 12672, 13147, 13151, 13155, 13159, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{4786, 431, 436, {15236, 15248, 15259, 15273, 15285, 15295, 15305}, {15316, 15321, 15326, 15331, 15336, 15341, 15346}, {1285, 2894, 1608, 4532, 1828, 13432, 1616}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, 2, 1, 55, 3, {417,1690,0,0,0,0,0,0,0,0,0,0,0,0},{4799,4823,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 165, 170, {15579, 15593, 15603, 15614, 15628, 15639, 15650}, {15663, 15668, 15673, 15680, 15686, 15692, 15698}, {1828, 1616, 1608, 5210, 1828, 9428, 1285}, {15703, 15711, 15719, 15726, 15735, 15745, 15755, 15761, 15769, 15784, 15802, 15810, 0}, {15703, 15711, 15719, 15726, 15735, 15745, 15755, 15761, 15769, 15784, 15802, 15810, 0}, {15818, 15822, 15719, 15828, 15832, 15837, 15755, 15843, 15848, 15855, 15862, 15867, 0}, {15818, 15822, 15719, 15828, 15832, 15837, 15755, 15843, 15848, 15855, 15862, 15867, 0}, 2, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 441, 444, {15872, 15877, 7673, 7680, 15883, 15890, 7697}, {15897, 15901, 7711, 7715, 15905, 7723, 7727}, {9428, 11804, 1285, 7731, 3099, 2892, 1285}, {7733, 7741, 15909, 1851, 7756, 1931, 15913, 15919, 1878, 1888, 1896, 15924, 0}, {7733, 7741, 15909, 1851, 7756, 1931, 15913, 15919, 1878, 1888, 1896, 15924, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 15933, 1943, 1947, 1951, 13346, 0}, {1914, 1918, 15909, 1927, 7756, 1931, 1935, 15933, 1943, 1947, 1951, 13346, 0}, 0, 1, 1, 3, {2764,304,0,0,0,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 1133, 1138, {35377, 35392, 35407, 35422, 35439, 16575, 35456}, {35467, 35474, 35481, 35488, 35495, 35502, 35509}, {17362, 16080, 6081, 6084, 6078, 16077, 16651}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {35516, 35169, 360, 35182, 380, 35527, 35534, 401, 35541, 35556, 35569, 35256, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 1, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 49, 52, {17393, 17412, 17431, 17456, 17475, 17509, 17534}, {17553, 17563, 17573, 17589, 17599, 17624, 17640}, {17650, 17654, 17661, 17665, 17672, 17679, 17686}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, {17690, 17718, 17752, 17768, 17787, 17794, 17804, 17820, 17836, 17867, 17889, 17911, 0}, 0, 5, 55, 11, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{1151,1146,3295,3304,0,0,0,0,0,0,0,0},{1173,1165,3312,3324,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 464, 479, {7465, 34912, 7489, 35580, 7505, 7518, 7527}, {18093, 18100, 18110, 18123, 18136, 18146, 18165}, {18187, 18191, 18198, 18205, 18215, 18222, 18235}, {7536, 7547, 7558, 7567, 35589, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 35589, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {18422, 18429, 18277, 18439, 18309, 18316, 18455, 18468, 18475, 18485, 18498, 18508, 0}, {18422, 18429, 18277, 18439, 18309, 18316, 18455, 18468, 18475, 18485, 18498, 18508, 0}, 0, 0, 55, 11, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{3335,894,0,0,0,0,0,0,0,0},{4841,62,266,71,0,0,0,0,0,0,0,0},{4849,77,271,89,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 494, 519, {19625, 19644, 19666, 19691, 19707, 19729, 19748}, {19758, 19772, 19786, 19800, 19811, 19825, 19748}, {19839, 19846, 19853, 19860, 19867, 19874, 19881}, {19885, 19901, 19926, 19945, 19964, 19971, 19984, 19997, 20016, 20047, 20072, 20094, 0}, {19885, 19901, 19926, 19945, 19964, 19971, 19984, 19997, 20016, 20047, 20072, 20094, 0}, {20119, 20127, 20141, 20155, 19964, 19971, 19984, 20166, 20174, 20188, 20199, 20207, 0}, {20119, 20127, 20141, 20155, 19964, 19971, 19984, 20166, 20174, 20188, 20199, 20207, 0}, 0, 1, 55, 3, {2015,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1010,1029,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 381, 409, {28795, 28814, 28833, 28858, 28877, 28899, 28924}, {28943, 14586, 28953, 14609, 28969, 14632, 14648}, {28982, 14662, 28986, 14676, 28990, 14690, 14697}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 14771, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, {14701, 28997, 14736, 29025, 22835, 29044, 14788, 29054, 29070, 29101, 29123, 29148, 0}, 0, 0, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{2979,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 991, 1011, {31343, 31356, 31366, 28271, 31376, 31386, 31396}, {31406, 31413, 31420, 31427, 31434, 31441, 31448}, {28325, 28325, 28325, 28333, 31459, 28341, 31463}, {31467, 31474, 31487, 31500, 31513, 31526, 31533, 31543, 31553, 31569, 31582, 31592, 0}, {31467, 31474, 31487, 31500, 31513, 31526, 31533, 31543, 31553, 31569, 31582, 31592, 0}, {31467, 31605, 31612, 31619, 31626, 31526, 31633, 31640, 31647, 31654, 31661, 31668, 0}, {31467, 31605, 31612, 31619, 31626, 31526, 31633, 31640, 31647, 31654, 31661, 31668, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{3982,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {34493, 34500, 34507, 34514, 34521, 34528, 34535}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {295,857,9,439,460,379,406,417,0,0,0,0,0,0},{469,1484,547,562,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{4612, 57, 63, {1747, 1755, 1762, 1771, 1780, 1791, 1799}, {1807, 1810, 1813, 1816, 1819, 1822, 1825}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {35723, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {35723, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {35731, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {35731, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {681,0,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {35736, 35741, 35746, 35751, 35756, 35761, 35766}, {32987, 35771, 35774, 35778, 35781, 35785, 13568}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {13618, 13623, 26852, 13633, 2760, 13638, 13643, 13648, 13653, 35788, 13663, 27035, 0}, {13618, 13623, 26852, 13633, 2760, 13638, 13643, 13648, 13653, 35788, 13663, 27035, 0}, 0, 0, 1, 3, {2764,1054,857,295,9,18,968,1274,417,460,406,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,266,71,0,0,0,0,0,0,0,0,0},{914,271,89,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1042, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 2890, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, 2, 1, 1, 3, {18,9,1054,857,1062,755,775,417,0,0,0,0,0,0},{1069,1097,1124,0,0,0,0,0,0,0},{266,71,1146,1151,1157,0,0,0,0,0,0,0},{271,89,1165,1173,1182,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{109, 165, 170, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 35793, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 35793, 3532, 2986, 882, 887, 3590, 0}, 0, 0, 55, 3, {417,1690,755,4860,9,864,0,0,0,0,0,0,0,0},{894,304,0,0,0,0,0,0,0,0},{71,266,1151,1243,1253,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{4786, 431, 436, {15236, 35800, 35812, 35827, 35838, 35849, 35860}, {15316, 15321, 15326, 15331, 15336, 15341, 15346}, {1285, 1608, 1828, 4532, 1828, 13432, 1616}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15351, 15368, 15381, 15395, 15408, 15421, 15434, 15448, 15460, 15474, 15488, 15502, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, {15515, 15522, 15527, 15532, 15536, 15541, 15546, 15551, 15556, 15563, 15568, 15574, 0}, 2, 1, 11, 3, {1208,681,2098,417,0,0,0,0,0,0,0,0,0,0},{4869,4823,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,0,0,0,0,0,0,0,0,0,0},{77,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {967, 974, 981, 988, 995, 1002, 1009}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {295,857,9,439,460,379,406,417,0,0,0,0,0,0},{469,1484,547,4555,0,0,0,0,0,0},{583,591,266,71,0,0,0,0,0,0,0,0},{600,611,271,89,0,0,0,0,0},{623,639,652,0,0,0,0,0}},
	{4612, 57, 63, {1747, 1755, 1762, 1771, 1780, 1791, 1799}, {1807, 1810, 1813, 1816, 1819, 1822, 1825}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {681,0,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 55, 3, {417,18,9,857,1690,4895,968,2796,417,0,0,0,0,0},{997,3800,4903,1475,0,0,0,0,0,0},{906,62,71,266,0,0,0,0,0,0,0,0},{914,77,89,271,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {2764,0,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{4621, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 2, 1, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{4629,0,0,0,0,0,0,0}},
	{673, 49, 52, {6428, 6437, 6449, 6456, 6464, 6474, 6480}, {6487, 6491, 6495, 6499, 6503, 6508, 6512}, {1278, 1280, 35872, 1285, 1287, 1280, 1285}, {6527, 6537, 6546, 6554, 6562, 6570, 6577, 6584, 6592, 1364, 6598, 6606, 0}, {6615, 6625, 6634, 6642, 6650, 6658, 6665, 6672, 6681, 5385, 6687, 6697, 0}, {6706, 6710, 6715, 6720, 6724, 5419, 1501, 6728, 6732, 1517, 6736, 1521, 0}, {6706, 6710, 6715, 6720, 6724, 5419, 1501, 6728, 6732, 1517, 6736, 1521, 0}, 0, 1, 11, 3, {2181,4972,0,0,0,0,0,0,0,0,0,0,0,0},{2254,2225,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, 0, 6, 55, 3, {744,755,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{266,71,62,0,0,0,0,0,0,0,0,0},{271,89,77,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {34493, 34500, 34507, 34514, 34521, 34528, 34535}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {295,857,9,439,460,379,406,417,0,0,0,0,0,0},{469,4996,5023,764,547,4555,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{4612, 57, 63, {1747, 1755, 1762, 1771, 1780, 1791, 1799}, {1807, 1810, 1813, 1816, 1819, 1822, 1825}, {1285, 1608, 1828, 1608, 1828, 1614, 1285}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1830, 1837, 1845, 1851, 1857, 1861, 1866, 1871, 1878, 1888, 1896, 1905, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, {1914, 1918, 1922, 1927, 1857, 1931, 1935, 1939, 1943, 1947, 1951, 1955, 0}, 2, 1, 11, 3, {681,0,0,0,0,0,0,0,0,0,0,0,0,0},{798,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{5039, 165, 170, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {2764,0,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 1, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1143, 1154, {6428, 6437, 6449, 6456, 6464, 6474, 6480}, {6487, 6491, 6495, 6499, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 1649, 1654, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 1649, 1654, 8914, 35936, 35946, 35954, 35963, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, 0, 1, 11, 3, {2181,5056,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 32814, 35638, 35976, 35989, 35996, 35684, 36007, 36018, 0}, {35594, 35605, 10194, 35618, 32814, 35638, 35976, 35989, 35996, 35684, 36007, 36018, 0}, {35594, 35605, 10194, 35618, 32814, 35638, 35976, 35989, 35996, 35684, 36007, 36018, 0}, {35594, 35605, 10194, 35618, 32814, 35638, 35976, 35989, 35996, 35684, 36007, 36018, 0}, 0, 6, 55, 3, {744,755,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{266,71,62,0,0,0,0,0,0,0,0,0},{271,89,77,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{5039, 165, 170, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 2, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,906,0,0,0,0,0,0,0,0,0,0},{89,914,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{5092, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {957,0,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1162, 1174, {6428, 36029, 6449, 6456, 6464, 6474, 6480}, {8879, 5179, 36040, 36044, 8889, 8895, 36048}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {1702, 1707, 11617, 1717, 1645, 5093, 5097, 8921, 2986, 1737, 887, 1742, 0}, {1702, 1707, 11617, 1717, 1645, 5093, 5097, 8921, 2986, 1737, 887, 1742, 0}, 0, 1, 11, 3, {2151,2181,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{71,1151,0,0,0,0,0,0,0,0,0,0},{89,1173,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, {35874, 35885, 10194, 35896, 32814, 35907, 35916, 35929, 35671, 35684, 35697, 35710, 0}, 0, 0, 55, 3, {744,755,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{266,71,62,0,0,0,0,0,0,0,0,0},{271,89,77,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {406,2351,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{673, 1183, 1205, {36053, 36068, 36087, 36100, 36115, 36132, 7877}, {12299, 12307, 36143, 36149, 12331, 12339, 36155}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {12395, 36276, 360, 6376, 12370, 36194, 36201, 6384, 12435, 6402, 36284, 36292, 0}, {12395, 36276, 360, 6376, 12370, 36194, 36201, 6384, 12435, 6402, 36284, 36292, 0}, 0, 1, 11, 3, {2151,2181,0,0,0,0,0,0,0,0,0,0,0,0},{721,2561,798,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{5039, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 2, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{3353, 1221, 1239, {36300, 36068, 36087, 36100, 36115, 36132, 7877}, {36313, 36320, 36327, 36334, 36341, 36348, 36355}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 12377, 12386, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 12377, 12386, 401, 36208, 36227, 36242, 36259, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, 0, 1, 11, 3, {1208,2098,692,681,4717,775,5100,417,0,0,0,0,0,0},{721,2561,798,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 0, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {29674, 36383, 29678, 29678, 36385, 36387, 6522}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, 0, 0, 1, 3, {2764,0,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1254, 1174, {8833, 36029, 6449, 8858, 6464, 6474, 6480}, {6487, 6491, 6495, 36389, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, 0, 1, 11, 11, {2151,2181,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{5111, 88, 1264, {36393, 36404, 36416, 36428, 36436, 36447, 36461}, {36471, 36475, 1645, 36479, 36483, 36487, 15346}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {36492, 36510, 36524, 36540, 36556, 36569, 36581, 36595, 36608, 36624, 36640, 36655, 0}, {36492, 36510, 36524, 36540, 36556, 36569, 36581, 36595, 36608, 36624, 36640, 36655, 0}, {36670, 36676, 36683, 36692, 36701, 36707, 36712, 36719, 36725, 36734, 36743, 36751, 0}, {36670, 36676, 36683, 36692, 36701, 36707, 36712, 36719, 36725, 36734, 36743, 36751, 0}, 2, 1, 11, 3, {1208,681,2098,417,0,0,0,0,0,0,0,0,0,0},{5125,0,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {18,2796,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {29490, 36759, 26896, 26902, 29510, 36767, 36773, 26925, 36779, 36789, 36797, 36807, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 36817, 704, 2951, 2961, 0}, {36827, 13623, 26852, 27010, 36832, 13638, 13643, 27020, 27025, 35788, 13663, 36837, 0}, {36827, 13623, 26852, 27010, 36832, 13638, 13643, 27020, 27025, 35788, 13663, 36837, 0}, 0, 0, 1, 3, {2764,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1221, 1205, {36300, 36068, 36087, 6014, 36115, 36132, 7877}, {36313, 36320, 36327, 36842, 36341, 36348, 36355}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, 0, 1, 11, 3, {2181,0,0,0,0,0,0,0,0,0,0,0,0,0},{2225,2239,2254,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5143,0,0,0,0,0,0,0}},
	{109, 1268, 1273, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 1, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1162, 1174, {6428, 36029, 6449, 6456, 6464, 6474, 6480}, {8879, 5179, 36040, 36044, 8889, 8895, 36048}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {1702, 1707, 11617, 1717, 1645, 5093, 5097, 8921, 2986, 1737, 887, 1742, 0}, {1702, 1707, 11617, 1717, 1645, 5093, 5097, 8921, 2986, 1737, 887, 1742, 0}, 0, 1, 11, 11, {2151,2181,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, {34654, 34678, 34687, 34696, 34707, 34716, 34729, 34738, 34743, 34754, 34776, 34800, 0}, 0, 1, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{1, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {295,5153,0,0,0,0,0,0,0,0,0,0,0,0},{2462,1261,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 1, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1183, 1205, {36053, 36068, 36087, 36100, 36115, 36132, 7877}, {12299, 12307, 36143, 36149, 12331, 12339, 36155}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {12395, 36276, 360, 6376, 12370, 36194, 36201, 6384, 12435, 6402, 36284, 36292, 0}, {12395, 36276, 360, 6376, 12370, 36194, 36201, 6384, 12435, 6402, 36284, 36292, 0}, 0, 1, 11, 3, {2151,2161,2169,2181,2193,2203,2213,5165,0,0,0,0,0,0},{2225,2239,2254,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, 0, 1, 55, 3, {744,0,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{5143,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {29490, 36759, 26896, 26902, 29510, 36767, 36773, 26925, 36779, 36789, 36797, 36807, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 36817, 704, 2951, 2961, 0}, {36827, 13623, 26852, 27010, 36832, 13638, 13643, 27020, 27025, 35788, 13663, 36837, 0}, {36827, 13623, 26852, 27010, 36832, 13638, 13643, 27020, 27025, 35788, 13663, 36837, 0}, 0, 1, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{266,71,62,906,0,0,0,0,0,0,0,0},{271,89,77,914,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 165, 170, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {1702, 36849, 1712, 3579, 3515, 36855, 3584, 3532, 2986, 882, 887, 3590, 0}, {1702, 36849, 1712, 3579, 3515, 36855, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 6, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{5039, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 2986, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {3410, 3419, 3425, 3431, 3440, 3446, 3455}, {3462, 2863, 1712, 3467, 3472, 3477, 3482}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3487, 3495, 3504, 3509, 3515, 3519, 3524, 3532, 3538, 3548, 712, 3556, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, {3566, 3572, 3504, 3579, 3515, 3519, 3584, 3532, 2986, 882, 887, 3590, 0}, 0, 0, 1, 3, {18,304,0,0,0,0,0,0,0,0,0,0,0,0},{1217,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{1, 1094, 1097, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34542, 34553, 34568, 34585, 34602, 34615, 34628}, {34639, 34642, 34645, 34648, 34651, 10164, 10155}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, {35594, 35605, 10194, 35618, 35629, 35638, 35649, 35660, 35671, 35684, 35697, 35710, 0}, 0, 6, 1, 3, {18,9,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{62,71,266,0,0,0,0,0,0,0,0,0},{77,89,271,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 55, 3, {744,755,1062,2098,417,0,0,0,0,0,0,0,0,0},{1261,894,0,0,0,0,0,0,0,0},{71,266,62,0,0,0,0,0,0,0,0,0},{89,271,4849,77,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 1, 1, 3, {295,857,18,9,417,0,0,0,0,0,0,0,0,0},{1010,1029,0,0,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{98,734,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{109, 49, 52, {2650, 2657, 2664, 2672, 2682, 2691, 2698}, {2707, 2711, 2715, 2719, 2723, 2727, 2731}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {2737, 2745, 2754, 1851, 2760, 2764, 2769, 1871, 1878, 2774, 1896, 2782, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, {1914, 1918, 2791, 1927, 2760, 1931, 1935, 1939, 1943, 2795, 1951, 2799, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{876,894,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{5177,5205,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{4914, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{5092, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {957,0,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{5046,0,0,0,0,0,0,0}},
	{925, 13, 19, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {932,941,948,957,460,417,968,0,0,0,0,0,0,0},{3800,3820,42,2448,0,0,0,0,0,0},{906,62,266,71,0,0,0,0,0,0,0,0},{914,77,271,89,0,0,0,0,0},{1193,0,0,0,0,0,0,0}},
	{4914, 165, 170, {2803, 2811, 2817, 2824, 2835, 2842, 2850}, {2858, 2863, 1712, 2868, 2874, 2879, 2884}, {1828, 1616, 1608, 1608, 2892, 2894, 1285}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2896, 2902, 2910, 666, 2916, 2921, 2927, 2933, 2940, 704, 2951, 2961, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, {2971, 1707, 1712, 863, 2976, 1722, 868, 2981, 1732, 882, 887, 2992, 0}, 0, 0, 1, 3, {295,304,0,0,0,0,0,0,0,0,0,0,0,0},{4922,4950,0,0,0,0,0,0,0,0},{906,71,0,0,0,0,0,0,0,0,0,0},{914,89,0,0,0,0,0,0,0},{355,0,0,0,0,0,0,0}},
	{3353, 1221, 1239, {36300, 36068, 36087, 36100, 36115, 36132, 7877}, {36313, 36320, 36327, 36334, 36341, 36348, 36355}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 12377, 12386, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 12377, 12386, 401, 36208, 36227, 36242, 36259, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, 0, 1, 11, 3, {1208,2098,692,681,4717,775,5100,417,0,0,0,0,0,0},{721,2561,798,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{673, 1143, 1154, {6428, 6437, 6449, 6456, 6464, 6474, 6480}, {6487, 6491, 6495, 6499, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 1649, 1654, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 1649, 1654, 8914, 35936, 35946, 35954, 35963, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, 0, 1, 11, 3, {2181,5056,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{673, 1221, 1205, {36300, 36068, 36087, 6014, 36115, 36132, 7877}, {36313, 36320, 36327, 36842, 36341, 36348, 36355}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, 0, 1, 11, 3, {2181,0,0,0,0,0,0,0,0,0,0,0,0,0},{2225,2239,2254,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{673, 1254, 1174, {8833, 36029, 6449, 8858, 6464, 6474, 6480}, {6487, 6491, 6495, 36389, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 5093, 5097, 8914, 35936, 35946, 35954, 35963, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, 0, 1, 11, 11, {2151,2181,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{5111, 88, 1264, {36393, 36404, 36416, 36428, 36436, 36447, 36461}, {36471, 36475, 1645, 36479, 36483, 36487, 15346}, {1285, 1608, 1610, 2735, 1610, 1614, 1285}, {36492, 36510, 36524, 36540, 36556, 36569, 36581, 36595, 36608, 36624, 36640, 36655, 0}, {36492, 36510, 36524, 36540, 36556, 36569, 36581, 36595, 36608, 36624, 36640, 36655, 0}, {36670, 36676, 36683, 36692, 36701, 36707, 36712, 36719, 36725, 36734, 36743, 36751, 0}, {36670, 36676, 36683, 36692, 36701, 36707, 36712, 36719, 36725, 36734, 36743, 36751, 0}, 2, 1, 11, 3, {1208,681,2098,417,0,0,0,0,0,0,0,0,0,0},{5125,0,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{109, 1110, 1115, {34919, 34930, 34954, 34984, 35001, 35023, 35032}, {35043, 35047, 35054, 35061, 35065, 35072, 35076}, {4756, 4744, 4746, 4748, 4750, 4752, 4754}, {35080, 9875, 9888, 9897, 9908, 35093, 35102, 9929, 35111, 35128, 35143, 9981, 0}, {35156, 35169, 360, 35182, 380, 35193, 35202, 401, 35211, 35228, 35243, 35256, 0}, {35269, 489, 35276, 496, 380, 35283, 35290, 503, 35297, 517, 35304, 531, 0}, {35269, 489, 35276, 496, 380, 35283, 35290, 503, 35297, 517, 35304, 531, 0}, 0, 1, 11, 3, {681,775,2098,9,417,0,0,0,0,0,0,0,0,0},{894,1261,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {967, 974, 981, 988, 995, 1002, 1009}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1044, 1051, 1058, 1065, 1072, 1079, 1086, 1093, 1100, 1107, 1114, 1124, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {379,388,397,406,417,428,439,446,453,460,0,0,0,0},{469,491,519,547,562,0,0,0,0,0},{266,71,583,591,0,0,0,0,0,0,0,0},{271,89,600,611,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{673, 1100, 1105, {1525, 7197, 34830, 1548, 1555, 1563, 34837}, {1578, 7225, 34845, 1591, 1595, 1599, 34849}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 2, 1, 11, 3, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1143, 1154, {6428, 6437, 6449, 6456, 6464, 6474, 6480}, {6487, 6491, 6495, 6499, 6503, 6508, 6512}, {6516, 6518, 6520, 6522, 6524, 6518, 6522}, {1618, 1625, 11617, 1639, 1645, 1649, 1654, 8914, 35936, 35946, 35954, 35963, 0}, {1618, 1625, 11617, 1639, 1645, 1649, 1654, 8914, 35936, 35946, 35954, 35963, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, {5089, 4610, 4512, 4614, 1645, 5093, 5097, 35972, 5105, 5109, 4642, 6911, 0}, 0, 1, 11, 3, {2181,5056,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{109, 49, 52, {11414, 11420, 11434, 11457, 11471, 11487, 11494}, {11503, 11506, 11511, 11517, 11521, 11526, 11529}, {4756, 4744, 4746, 4748, 4750, 4752, 4754}, {11533, 11540, 7354, 11547, 2760, 11553, 11559, 11565, 11572, 11581, 11589, 11596, 0}, {11603, 11610, 11617, 11622, 11628, 11632, 11637, 11642, 11649, 11658, 11666, 11673, 0}, {11680, 5609, 4512, 4614, 11628, 11684, 11688, 11692, 11696, 5109, 11700, 11704, 0}, {11680, 5609, 4512, 4614, 11628, 11684, 11688, 11692, 11696, 5109, 11700, 11704, 0}, 0, 1, 11, 3, {681,304,0,0,0,0,0,0,0,0,0,0,0,0},{2843,894,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 1133, 1138, {35377, 35392, 35407, 35422, 35439, 16575, 35456}, {35467, 35474, 35481, 35488, 35495, 35502, 35509}, {17362, 16080, 6081, 6084, 6078, 16077, 16651}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {35516, 35169, 360, 35182, 380, 35527, 35534, 401, 35541, 35556, 35569, 35256, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 1, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{925, 665, 670, {23096, 23103, 23114, 23127, 23140, 23151, 23164}, {23175, 23180, 23185, 23190, 23195, 23200, 23205}, {23175, 23180, 23185, 23190, 23195, 23200, 23205}, {23210, 23236, 23264, 23294, 23324, 23350, 23380, 23406, 23434, 23458, 23486, 23523, 0}, {23210, 23236, 23264, 23294, 23324, 23350, 23380, 23406, 23434, 23458, 23486, 23523, 0}, {23562, 23574, 23586, 23598, 23610, 23622, 23634, 23646, 23658, 23670, 23683, 23696, 0}, {23562, 23574, 23586, 23598, 23610, 23622, 23634, 23646, 23658, 23670, 23683, 23696, 0}, 0, 1, 55, 3, {417,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3398,3436,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {34493, 34500, 34507, 34514, 34521, 34528, 34535}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {295,857,9,439,460,379,406,417,0,0,0,0,0,0},{469,1484,547,562,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{370, 25, 32, {897, 907, 917, 927, 937, 947, 957}, {34493, 34500, 34507, 34514, 34521, 34528, 34535}, {1016, 1020, 1024, 1028, 1032, 1036, 1040}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, {1134, 1139, 1144, 1149, 1154, 1159, 1164, 1169, 1174, 1179, 1185, 1191, 0}, 0, 0, 1, 3, {295,857,9,439,460,379,406,417,0,0,0,0,0,0},{469,1484,547,562,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{623,639,652,666,0,0,0,0}},
	{2090, 165, 170, {1525, 1533, 1540, 1548, 1555, 1563, 1570}, {5052, 5058, 5063, 5068, 5073, 5078, 5083}, {1285, 1608, 1610, 1612, 1610, 1614, 1616}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {1618, 1625, 3504, 1639, 3515, 1649, 1654, 1659, 1666, 1676, 1684, 4420, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, {5089, 4610, 4512, 4614, 3515, 5093, 5097, 5101, 5105, 5109, 4642, 5113, 0}, 2, 1, 11, 11, {681,1455,0,0,0,0,0,0,0,0,0,0,0,0},{703,721,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 1221, 1205, {36300, 36068, 36087, 6014, 36115, 36132, 7877}, {36313, 36320, 36327, 36842, 36341, 36348, 36355}, {315, 318, 36163, 324, 327, 318, 324}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {36166, 36179, 360, 369, 12370, 36194, 36201, 401, 36208, 36227, 36242, 36259, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, {35269, 36362, 35276, 496, 12370, 36194, 36201, 503, 510, 517, 36369, 36376, 0}, 0, 1, 11, 11, {2151,2181,0,0,0,0,0,0,0,0,0,0,0,0},{5071,2239,0,0,0,0,0,0,0,0},{1151,0,0,0,0,0,0,0,0,0,0,0},{1173,0,0,0,0,0,0,0,0},{4985,0,0,0,0,0,0,0}},
	{1, 273, 285, {9712, 9727, 9742, 9757, 9774, 9793, 9804}, {9815, 9822, 9829, 9836, 9843, 9850, 9857}, {0, 0, 0, 0, 0, 0, 0}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {9864, 9875, 9888, 9897, 9908, 9915, 9922, 9929, 9942, 9957, 9970, 9981, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, {9994, 10001, 10008, 10015, 9908, 9915, 9922, 10022, 10029, 10036, 10043, 10050, 0}, 0, 1, 11, 3, {681,775,2098,744,9,0,0,0,0,0,0,0,0,0},{2727,2745,0,0,0,0,0,0,0,0},{71,266,0,0,0,0,0,0,0,0,0,0},{89,271,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{673, 327, 1120, {35311, 35320, 35332, 35341, 35348, 35357, 1247}, {12088, 12092, 35363, 12101, 35368, 35372, 12114}, {6516, 6518, 12118, 6522, 6522, 6518, 6522}, {1618, 1625, 12120, 12126, 1645, 8902, 8908, 12137, 1666, 1676, 12144, 1693, 0}, {12153, 12161, 12170, 12177, 5333, 12189, 12196, 12203, 6874, 12211, 12219, 6902, 0}, {5089, 4610, 12228, 4614, 1645, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, {5089, 4610, 12228, 4614, 1645, 5093, 5097, 12237, 5105, 5109, 12241, 6911, 0}, 2, 1, 124, 3, {692,4717,681,775,417,0,0,0,0,0,0,0,0,0},{798,721,692,0,0,0,0,0,0,0},{71,266,4726,4740,0,0,0,0,0,0,0,0},{89,4753,4770,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}},
	{925, 458, 461, {17037, 17047, 17056, 17065, 17076, 17086, 17091}, {17098, 17102, 17107, 17112, 17117, 7723, 17121}, {17126, 1828, 1285, 5210, 1280, 2892, 1285}, {11533, 11540, 7354, 11547, 2760, 17128, 17133, 17138, 17145, 17153, 11589, 11596, 0}, {11603, 11610, 11617, 11622, 11628, 11632, 11637, 8914, 17160, 17168, 11666, 11673, 0}, {12906, 17175, 2791, 1927, 2760, 17179, 17183, 17187, 7707, 1947, 17191, 17195, 0}, {12906, 17175, 2791, 1927, 2760, 17179, 17183, 17187, 7707, 1947, 17191, 17195, 0}, 0, 1, 1, 3, {406,2861,0,0,0,0,0,0,0,0,0,0,0,0},{3239,2997,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{2717,0,0,0,0,0,0,0}},
	{1, 464, 479, {7465, 34912, 7489, 35580, 7505, 7518, 7527}, {18093, 18100, 18110, 18123, 18136, 18146, 18165}, {18187, 18191, 18198, 18205, 18215, 18222, 18235}, {7536, 7547, 7558, 7567, 35589, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {7536, 7547, 7558, 7567, 35589, 7585, 7592, 7605, 7614, 7625, 7638, 7649, 0}, {18422, 18429, 18277, 18439, 18309, 18316, 18455, 18468, 18475, 18485, 18498, 18508, 0}, {18422, 18429, 18277, 18439, 18309, 18316, 18455, 18468, 18475, 18485, 18498, 18508, 0}, 0, 0, 55, 11, {755,1062,2098,744,417,0,0,0,0,0,0,0,0,0},{3335,894,0,0,0,0,0,0,0,0},{4841,62,266,71,0,0,0,0,0,0,0,0},{4849,77,271,89,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{109, 889, 899, {28588, 28595, 28601, 28608, 28614, 28620, 28628}, {28638, 28642, 28646, 28650, 28654, 28658, 28662}, {9428, 9428, 9428, 9428, 9428, 9428, 9428}, {28668, 28677, 7020, 28686, 28692, 28698, 28704, 28711, 28717, 28726, 28735, 28743, 0}, {28668, 28677, 7020, 28686, 28692, 28698, 28704, 28711, 28717, 28726, 28735, 28743, 0}, {28752, 28756, 2791, 28760, 2760, 28764, 28768, 28772, 28777, 28781, 28787, 28791, 0}, {28752, 28756, 2791, 28760, 2760, 28764, 28768, 28772, 28777, 28781, 28787, 28791, 0}, 0, 0, 55, 3, {744,755,417,0,0,0,0,0,0,0,0,0,0,0},{2448,42,0,0,0,0,0,0,0,0},{266,71,0,0,0,0,0,0,0,0,0,0},{271,89,0,0,0,0,0,0,0},{98,0,0,0,0,0,0,0}},
	{925, 49, 52, {29808, 29815, 29823, 29830, 29837, 29845, 29854}, {29861, 29865, 29869, 29873, 29877, 7723, 28638}, {1616, 1616, 1610, 1616, 9428, 2892, 9428}, {29881, 29889, 29899, 29905, 29913, 29918, 29923, 29928, 29935, 16856, 29943, 29951, 0}, {29881, 29889, 29899, 29905, 29913, 29918, 29923, 29928, 29935, 16856, 29943, 29951, 0}, {1914, 29959, 2791, 29963, 2760, 28764, 28768, 29967, 2731, 1947, 29971, 13346, 0}, {1914, 29959, 2791, 29963, 2760, 28764, 28768, 29967, 2731, 1947, 29971, 13346, 0}, 0, 0, 1, 3, {295,3021,0,0,0,0,0,0,0,0,0,0,0,0},{1010,1029,0,0,0,0,0,0,0,0},{71,0,0,0,0,0,0,0,0,0,0,0},{89,0,0,0,0,0,0,0,0},{734,0,0,0,0,0,0,0}}
};


static const NumberFormatEntry number_format_entries [] = {
	{11, 1278, 11, 1278, 1280, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1339, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1361, 1370, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 1347, 1310, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 1347, 1310, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1381, 1345, 0, 1351, 1385, 1397, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1409, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1413, 1424, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1435, 1449, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 0, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1464, 1474, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1483, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1511, 1345, 1347, 1351, 1313, 1323, 55, 1515, 2, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1520, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1523, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1464, 1527, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1537, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1541, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1310, 1545, 1555, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 0, 1290, 1347, 1310, 1313, 1323, 55, 1332, 9, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1564, 1345, 1347, 1351, 1568, 1587, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1606, 1345, 1347, 1351, 1464, 1527, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1609, 11, 1609, 1613, 1345, 1347, 1351, 1617, 1626, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1635, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1639, 1345, 1643, 1351, 1660, 1688, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1715, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 2, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1385, 1397, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1718, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 1336, 1724, 1345, 1727, 1734, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1740, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1744, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 2, 2, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1748, 1345, 1347, 1351, 1313, 1323, 55, 1751, 3, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1759, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1762, 1345, 1347, 1351, 1313, 1323, 55, 1355, 5, 1, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1766, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1769, 1783, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1796, 1351, 1799, 1811, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {2, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1822, 1833, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 0, 1345, 0, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1, 1278, 1, 1278, 1843, 1492, 0, 1310, 1313, 1323, 55, 1355, 3, 0, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1852, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1856, 1345, 1859, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 0, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1866, 1876, 55, 1355, 8, 3, 7, 3, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1885, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1336, 11, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1892, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1894, 1345, 1898, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1724, 1345, 1347, 1351, 1313, 1323, 55, 1355, 2, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1727, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1943, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1946, 1345, 1950, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1967, 1345, 1974, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1991, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1995, 1345, 1999, 1351, 1313, 1323, 55, 1355, 5, 1, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 0, 1492, 2009, 1310, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1639, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2028, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 1, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 0, 1492, 1347, 1310, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 2, 2, 1, 2, 2, {3, -1}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 1, 1, 1, 2, 2, {3, 2}, {3, 2}},
	{2035, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 0, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 1347, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, 0}, {3, -1}},
	{11, 1278, 11, 1278, 2037, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2040, 1345, 1347, 1351, 1313, 1323, 55, 1355, 5, 1, 1, 1, 2, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2044, 1345, 2048, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2094, 1345, 2096, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 2136, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 0, 1345, 1347, 1351, 1313, 1323, 55, 1355, 0, 0, 1, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2144, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 1, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 0, 1345, 0, 1351, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2151, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, 2}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 11, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2158, 1492, 1347, 1310, 1313, 1323, 55, 1751, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2161, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 0, 1345, 0, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 0, 1345, 0, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2165, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1336, 11, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1409, 1345, 1727, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 0}, {3, -1}},
	{11, 1278, 11, 1278, 2165, 1345, 1347, 1310, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1766, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2169, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2173, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 0, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 0, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1537, 1345, 1347, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1639, 1345, 2175, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2204, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2037, 1492, 1347, 1310, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1280, 1492, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1339, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1361, 1370, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 2207, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1381, 1345, 0, 1351, 1385, 1397, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1409, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1413, 1424, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1435, 1449, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 0, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1483, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1511, 1345, 1347, 1351, 1313, 1323, 55, 1515, 2, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1520, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1523, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1464, 1527, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1537, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1541, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1310, 1545, 1555, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1724, 1290, 1347, 1310, 1313, 1323, 55, 1332, 9, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1564, 1345, 1347, 1351, 1568, 1587, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1606, 1345, 1347, 1351, 1464, 1527, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1609, 11, 1609, 1613, 1345, 1347, 1351, 1617, 1626, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1635, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1639, 1345, 1643, 1351, 1660, 1688, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2217, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 2, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1385, 1397, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1718, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 1336, 1724, 1345, 1727, 1734, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1740, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1744, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 2, 2, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1748, 1345, 1347, 1351, 1313, 1323, 55, 1751, 3, 0, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1759, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1762, 1345, 1347, 1351, 1313, 1323, 55, 1355, 5, 1, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1766, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1769, 1783, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1796, 1351, 1799, 1811, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {2, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1822, 1833, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1967, 1345, 0, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1, 1278, 1, 1278, 1843, 1492, 0, 1310, 1313, 1323, 55, 1355, 3, 0, 0, 0, 3, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1852, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1856, 1345, 1859, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2221, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1866, 1876, 55, 1355, 8, 3, 7, 3, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1885, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1336, 11, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1892, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1894, 1345, 1898, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1724, 1345, 1347, 1351, 1313, 1323, 55, 1355, 2, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1724, 1345, 1727, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1943, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1946, 1345, 1950, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1967, 1345, 1974, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1991, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1995, 1345, 1999, 1351, 1313, 1323, 55, 1355, 5, 1, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2225, 1492, 2009, 1310, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1639, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 1, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 2, 2, 1, 2, 2, {3, -1}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 1, 1, 1, 2, 2, {3, 2}, {3, 2}},
	{2035, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 2231, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 1347, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, 0}, {3, -1}},
	{11, 1278, 11, 1278, 2037, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2040, 1345, 1347, 1351, 1313, 1323, 55, 1355, 5, 1, 1, 1, 2, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2044, 1345, 2048, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2094, 1345, 2096, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 0, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 2136, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2144, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 1, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2235, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, 2}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 11, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2158, 1492, 1347, 1310, 1313, 1323, 55, 1751, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2161, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2165, 1345, 0, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2165, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1336, 11, 1336, 1892, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1409, 1345, 1727, 1351, 1313, 1323, 55, 1355, 12, 2, 0, 0, 1, 2, 2, {3, 0}, {3, -1}},
	{11, 1278, 11, 1278, 2165, 1345, 1347, 1310, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1766, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1766, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2173, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 0, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 0, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1537, 1345, 1347, 1351, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1639, 1345, 2175, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2204, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2037, 1492, 1347, 1310, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2248, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1361, 1370, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1537, 1345, 1347, 1310, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 2258, 11, 2258, 1613, 1345, 1347, 1351, 1413, 1424, 55, 1355, 2, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2037, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 2258, 11, 2258, 1613, 1345, 1347, 1351, 1464, 1527, 55, 1355, 2, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 1336, 1357, 1345, 1347, 1310, 1545, 1555, 55, 1355, 12, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1724, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1347, 1351, 1464, 1527, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2260, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2260, 1345, 1643, 1351, 1660, 1688, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1727, 1734, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1751, 1, 0, 1, 2, 1, 2, 2, {3, 2}, {3, -1}},
	{1278, 1336, 1278, 1336, 2221, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1336, 11, 1336, 2262, 1345, 0, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 1336, 1724, 1345, 1727, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2264, 1492, 2271, 1310, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2304, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 1, 0, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 2308, 1492, 1347, 1310, 1313, 1323, 55, 1515, 9, 2, 9, 3, 2, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2311, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, 2}, {3, 2}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2169, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2315, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2325, 1345, 2207, 1351, 1313, 1323, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1413, 1424, 55, 1355, 9, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1464, 1474, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1462, 1492, 1347, 1310, 1495, 1503, 55, 1355, 15, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 1727, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2329, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 0, 0, 0, 3, 3, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1310, 1313, 1323, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1413, 1424, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2339, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1336, 11, 1336, 1613, 1492, 1347, 1310, 1495, 1503, 55, 1355, 2, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2341, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2344, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2354, 1345, 2207, 1351, 1313, 1323, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 2258, 11, 2258, 1613, 1345, 1347, 1351, 1413, 1424, 55, 1355, 9, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2359, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2341, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2363, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2373, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2341, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2377, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 3, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1892, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2387, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2391, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2396, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 3, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2406, 1345, 1347, 1351, 1464, 1474, 55, 1355, 2, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2391, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2410, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2420, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2423, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 2427, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2435, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2445, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2448, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2423, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2452, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 3, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2462, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2467, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 2, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2448, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2477, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 3, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2161, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 2, 0, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2448, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2487, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 9, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2497, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2501, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 3, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2325, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2511, 1345, 1347, 1351, 1464, 1474, 55, 1355, 12, 2, 0, 0, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2515, 1492, 1347, 1310, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2517, 1290, 1295, 1310, 1313, 1323, 55, 1332, 3, 2, 0, 0, 3, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1939, 1345, 1347, 1351, 1313, 1323, 55, 1355, 12, 2, 1, 1, 1, 2, 2, {3, 2}, {3, 2}},
	{1278, 11, 1278, 11, 2527, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1943, 1345, 1347, 1351, 1313, 1323, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1313, 1323, 55, 1355, 1, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2260, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2530, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1462, 1345, 1347, 1351, 1464, 1474, 55, 1355, 1, 0, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2391, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2341, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2533, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2541, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1357, 1345, 2427, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2221, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 1378, 1345, 1347, 1310, 1313, 1323, 55, 1355, 2, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1724, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2341, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2221, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2264, 1492, 2271, 1310, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2231, 1345, 1347, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2325, 1345, 2207, 1351, 1313, 1323, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2325, 1345, 2207, 1351, 1313, 1323, 55, 1355, 0, 0, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1724, 1290, 1347, 1310, 1313, 1323, 55, 1332, 9, 2, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 2541, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 1967, 1345, 0, 1351, 1313, 1323, 55, 1355, 8, 3, 1, 1, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 11, 1278, 11, 1357, 1345, 1347, 1351, 1313, 1323, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 2225, 1492, 2009, 1310, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 0, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2308, 1492, 1347, 1310, 1313, 1323, 55, 1515, 9, 2, 9, 3, 2, 2, 2, {3, -1}, {3, -1}},
	{1278, 1336, 1278, 1336, 0, 1345, 0, 1351, 1495, 1503, 55, 1355, 8, 3, 0, 0, 1, 2, 2, {3, -1}, {3, -1}},
	{11, 1278, 11, 1278, 2165, 1345, 0, 1351, 1313, 1323, 55, 1355, 9, 2, 1, 1, 1, 2, 2, {3, -1}, {3, -1}}
};


static const CultureInfoEntry culture_entries [] = {
	{0x0001, 0x007F, 768, -1, 2546, 2549, 2556, 2571, 2575, 2546, 0, {0, 0, 36860, 0}, 0, 0, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0002, 0x007F, 257, -1, 2579, 2582, 2592, 2611, 2615, 2579, 0, {36888, 0, 0, 0}, 1, 1, { 1251, 21025, 10007, 866, 0, ';' }},
	{0x0003, 0x007F, 257, -1, 2619, 2622, 2630, 2638, 2642, 2619, 0, {36930, 0, 0, 0}, 2, 2, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0004, 0x7804, 257, -1, 2646, 2654, 2675, 2682, 2686, 2690, 0, {36950, 0, 0, 0}, 3, 3, { 936, 500, 10008, 936, 0, ',' }},
	{0x0004, 0x0004, 257, -1, 2693, 2700, 2675, 2682, 2686, 2690, 0, {36950, 0, 0, 0}, 4, 4, { 936, 500, 10008, 936, 0, ',' }},
	{0x0005, 0x007F, 257, -1, 2728, 2731, 2737, 2747, 2751, 2728, 0, {36957, 0, 0, 0}, 5, 5, { 1250, 500, 10029, 852, 0, ';' }},
	{0x0006, 0x007F, 257, -1, 2755, 2758, 2765, 2771, 2775, 2755, 0, {36983, 0, 0, 0}, 6, 6, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0007, 0x007F, 257, -1, 2779, 2782, 2789, 2797, 2801, 2779, 0, {37004, 0, 0, 0}, 7, 7, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x0008, 0x007F, 257, -1, 2805, 2808, 2814, 2831, 2835, 2805, 0, {37029, 0, 0, 0}, 8, 8, { 1253, 20273, 10006, 737, 0, ';' }},
	{0x0009, 0x007F, 257, -1, 2839, 2842, 2842, 2850, 2854, 2839, 0, {37071, 0, 0, 0}, 9, 9, { 1252, 37, 10000, 437, 0, ',' }},
	{0x000A, 0x007F, 257, -1, 2858, 2861, 2869, 2878, 2882, 2858, 0, {37090, 0, 0, 0}, 10, 10, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x000B, 0x007F, 257, -1, 2886, 2889, 2897, 2903, 2907, 2886, 0, {37112, 0, 0, 0}, 11, 11, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x000C, 0x007F, 257, -1, 2911, 2914, 2921, 2931, 2935, 2911, 0, {37137, 0, 0, 0}, 12, 12, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x000D, 0x007F, 257, -1, 2939, 2942, 2949, 2960, 2964, 2939, 0, {37159, 0, 0, 0}, 13, 13, { 1255, 500, 10005, 862, 1, ',' }},
	{0x000E, 0x007F, 257, -1, 2968, 2971, 2981, 2988, 2992, 2968, 0, {37196, 0, 0, 0}, 14, 14, { 1250, 500, 10029, 852, 0, ';' }},
	{0x000F, 0x007F, 257, -1, 2996, 2999, 3009, 3019, 3023, 2996, 0, {37212, 0, 0, 0}, 15, 15, { 1252, 20871, 10079, 850, 0, ';' }},
	{0x0010, 0x007F, 257, -1, 3027, 3030, 3038, 3047, 3051, 3027, 0, {37232, 0, 0, 0}, 16, 16, { 1252, 20280, 10000, 850, 0, ';' }},
	{0x0011, 0x007F, 257, -1, 3055, 3058, 3067, 3077, 3081, 3055, 0, {37254, 0, 0, 0}, 17, 17, { 932, 20290, 10001, 932, 0, ',' }},
	{0x0012, 0x007F, 257, -1, 3085, 3088, 3095, 3105, 3109, 3085, 0, {37281, 0, 0, 0}, 18, 18, { 949, 20833, 10003, 949, 0, ',' }},
	{0x0013, 0x007F, 257, -1, 3113, 3116, 3122, 3133, 3137, 3113, 0, {37288, 0, 0, 0}, 19, 19, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0014, 0x007F, 257, -1, 3141, 3144, 3154, 3160, 3164, 3168, 0, {36983, 0, 0, 0}, 20, 20, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0015, 0x007F, 257, -1, 3171, 3174, 3181, 3188, 3192, 3171, 0, {37310, 0, 0, 0}, 21, 21, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0016, 0x007F, 257, -1, 3196, 3199, 3210, 3221, 3225, 3196, 0, {37334, 0, 0, 0}, 22, 22, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0017, 0x007F, 257, -1, 3229, 3232, 3240, 3250, 3254, 3229, 0, {37357, 0, 0, 0}, 23, 23, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x0018, 0x007F, 257, -1, 3258, 3261, 3270, 3279, 3283, 3258, 0, {37377, 0, 0, 0}, 24, 24, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0019, 0x007F, 257, -1, 3287, 3290, 3298, 3313, 3317, 3287, 0, {37396, 0, 0, 0}, 25, 25, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x001A, 0x007F, 257, -1, 3321, 3324, 3333, 3342, 3346, 3321, 0, {37442, 0, 0, 0}, 26, 26, { 1250, 500, 10082, 852, 0, ';' }},
	{0x001B, 0x007F, 257, -1, 3350, 3353, 3360, 3372, 3376, 3350, 0, {37465, 0, 0, 0}, 27, 27, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x001C, 0x007F, 257, -1, 3380, 3383, 3392, 3398, 3402, 3380, 0, {37489, 0, 0, 0}, 28, 28, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x001D, 0x007F, 257, -1, 3406, 3409, 3417, 3425, 3429, 3406, 0, {36983, 0, 0, 0}, 29, 29, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x001E, 0x007F, 512, -1, 3433, 3436, 3441, 3451, 3455, 3433, 0, {0, 37508, 0, 0}, 30, 30, { 874, 20838, 10021, 874, 0, ',' }},
	{0x001F, 0x007F, 257, -1, 3459, 3462, 3470, 3479, 3483, 3459, 0, {37539, 0, 0, 0}, 31, 31, { 1254, 20905, 10081, 857, 0, ';' }},
	{0x0020, 0x007F, 257, -1, 3487, 3490, 3495, 3504, 3508, 3487, 0, {37553, 0, 0, 0}, 32, 32, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0021, 0x007F, 257, -1, 3512, 3515, 3526, 3536, 3540, 3512, 0, {37583, 0, 0, 0}, 33, 33, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0022, 0x007F, 257, -1, 3544, 3547, 3557, 3578, 3582, 3544, 0, {37602, 0, 0, 0}, 34, 34, { 1251, 500, 10017, 866, 0, ';' }},
	{0x0023, 0x007F, 257, -1, 3586, 3589, 3600, 3621, 3625, 3586, 0, {37648, 0, 0, 0}, 35, 35, { 1251, 500, 10007, 866, 0, ';' }},
	{0x0024, 0x007F, 257, -1, 3629, 3632, 3642, 3656, 3660, 3629, 0, {37690, 0, 0, 0}, 36, 36, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0025, 0x007F, 257, -1, 3664, 3667, 3676, 3682, 3686, 3664, 0, {37712, 0, 0, 0}, 37, 37, { 1257, 500, 10029, 775, 0, ';' }},
	{0x0026, 0x007F, 257, -1, 3690, 3693, 3701, 3711, 3715, 3690, 0, {37732, 0, 0, 0}, 38, 38, { 1257, 500, 10029, 775, 0, ';' }},
	{0x0027, 0x007F, 257, -1, 3719, 3722, 3733, 3743, 3747, 3719, 0, {37751, 0, 0, 0}, 39, 39, { 1257, 500, 10029, 775, 0, ';' }},
	{0x0028, 0x007F, 257, -1, 3751, 3754, 3760, 3773, 3777, 3751, 0, {0, 0, 0, 0}, 40, 40, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0029, 0x007F, 257, -1, 3781, 3784, 3792, 3803, 3807, 3781, 0, {37774, 0, 0, 0}, 41, 41, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x002A, 0x007F, 257, -1, 3811, 3814, 3825, 3840, 3844, 3811, 0, {37798, 0, 0, 0}, 42, 42, { 1258, 500, 10000, 1258, 0, ',' }},
	{0x002B, 0x007F, 257, -1, 3848, 3851, 3860, 3875, 3879, 3848, 0, {37813, 0, 0, 0}, 43, 43, { 0, 500, 2, 1, 0, ',' }},
	{0x002C, 0x007F, 257, -1, 3883, 3886, 3898, 3910, 3914, 3883, 0, {37843, 0, 0, 0}, 44, 44, { 1254, 20905, 10081, 857, 0, ';' }},
	{0x002D, 0x007F, 257, -1, 3918, 3921, 3928, 3936, 3940, 3918, 0, {37862, 0, 0, 0}, 45, 45, { 1252, 500, 2, 850, 0, ';' }},
	{0x002E, 0x007F, 257, -1, 3944, 3948, 3962, 3980, 3944, 3944, 0, {37882, 0, 0, 0}, 46, 46, { 1252, 870, 10000, 850, 0, ';' }},
	{0x002F, 0x007F, 257, -1, 3984, 3987, 3998, 4019, 4023, 3984, 0, {37903, 0, 0, 0}, 47, 47, { 1251, 500, 10007, 866, 0, ';' }},
	{0x0030, 0x007F, 257, -1, 4027, 4030, 4045, 4053, 4057, 4027, 0, {0, 0, 0, 0}, 48, 48, { 0, 500, 2, 1, 0, ';' }},
	{0x0031, 0x007F, 257, -1, 4061, 4064, 4071, 4080, 4084, 4061, 0, {0, 0, 0, 0}, 49, 49, { 0, 500, 2, 1, 0, ';' }},
	{0x0032, 0x007F, 257, -1, 4088, 4091, 4098, 4107, 4111, 4088, 0, {0, 0, 0, 0}, 50, 50, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0034, 0x007F, 257, -1, 4115, 4118, 4124, 4133, 4137, 4115, 0, {0, 0, 0, 0}, 51, 51, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0035, 0x007F, 257, -1, 4141, 4144, 4149, 4157, 4161, 4141, 0, {37947, 0, 0, 0}, 52, 52, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0036, 0x007F, 257, -1, 4165, 4168, 4168, 4178, 4182, 4165, 0, {37972, 0, 0, 0}, 53, 53, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0037, 0x007F, 257, -1, 4186, 4189, 4198, 4220, 4224, 4186, 0, {37992, 0, 0, 0}, 54, 54, { 0, 500, 2, 1, 0, ';' }},
	{0x0038, 0x007F, 257, -1, 4228, 4231, 4239, 4249, 4253, 4228, 0, {38057, 0, 0, 0}, 55, 55, { 1252, 20277, 10079, 850, 0, ';' }},
	{0x0039, 0x007F, 257, -1, 4257, 4260, 4266, 4285, 4289, 4257, 0, {38081, 0, 0, 0}, 56, 56, { 0, 500, 2, 1, 0, ',' }},
	{0x003A, 0x007F, 257, -1, 4293, 4296, 4304, 4310, 4314, 4293, 0, {38134, 0, 0, 0}, 57, 57, { 0, 500, 2, 1, 0, ';' }},
	{0x003B, 0x007F, 257, -1, 4318, 4321, 4335, 4352, 4356, 4318, 0, {38155, 0, 0, 0}, 58, 58, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x003C, 0x007F, 257, -1, 4360, 4363, 4369, 4377, 4381, 4360, 0, {38174, 0, 0, 0}, 59, 59, { 1252, 500, 10000, 850, 0, ';' }},
	{0x003E, 0x007F, 257, -1, 4385, 4388, 4394, 4408, 4412, 4385, 0, {38195, 0, 0, 0}, 60, 60, { 1252, 500, 10000, 850, 0, ';' }},
	{0x003F, 0x007F, 257, -1, 4416, 4419, 4426, 4446, 4450, 4416, 0, {38212, 0, 0, 0}, 61, 61, { 0, 500, 2, 1, 0, ';' }},
	{0x0040, 0x007F, 257, -1, 4454, 4457, 4464, 4481, 4485, 4454, 0, {38254, 0, 0, 0}, 62, 62, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0041, 0x007F, 257, -1, 4489, 4492, 4500, 4510, 4514, 4489, 0, {38294, 0, 0, 0}, 63, 63, { 1252, 500, 10000, 437, 0, ';' }},
	{0x0042, 0x007F, 257, -1, 4518, 4521, 4529, 4541, 4545, 4518, 0, {38315, 0, 0, 0}, 64, 64, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0043, 0x007F, 257, -1, 4549, 4552, 4558, 4567, 4571, 4549, 0, {38337, 0, 0, 0}, 65, 65, { 1254, 500, 10029, 857, 0, ';' }},
	{0x0044, 0x007F, 257, -1, 4575, 4578, 4584, 4595, 4599, 4575, 0, {38355, 0, 0, 0}, 66, 66, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0045, 0x007F, 257, -1, 4603, 4606, 4613, 4629, 4633, 4603, 0, {38390, 0, 0, 0}, 67, 67, { 0, 500, 2, 1, 0, ',' }},
	{0x0046, 0x007F, 257, -1, 4637, 4640, 4648, 4667, 4671, 4637, 0, {38461, 0, 0, 0}, 68, 68, { 0, 500, 2, 1, 0, ',' }},
	{0x0047, 0x007F, 257, -1, 4675, 4678, 4687, 4709, 4713, 4675, 0, {38508, 0, 0, 0}, 69, 69, { 0, 500, 2, 1, 0, ',' }},
	{0x0048, 0x007F, 257, -1, 4717, 4720, 4725, 4741, 4745, 4717, 0, {0, 0, 0, 0}, 70, 70, { 0, 500, 2, 1, 0, ',' }},
	{0x0049, 0x007F, 257, -1, 4749, 4752, 4758, 4774, 4778, 4749, 0, {38564, 0, 0, 0}, 71, 71, { 0, 500, 2, 1, 0, ',' }},
	{0x004A, 0x007F, 257, -1, 4782, 4785, 4792, 4811, 4815, 4782, 0, {38629, 0, 0, 0}, 72, 72, { 0, 500, 2, 1, 0, ',' }},
	{0x004B, 0x007F, 257, -1, 1715, 4819, 4827, 4843, 4847, 1715, 0, {38694, 0, 0, 0}, 73, 73, { 0, 500, 2, 1, 0, ',' }},
	{0x004C, 0x007F, 257, -1, 4851, 4854, 4864, 4883, 4887, 4851, 0, {38759, 0, 0, 0}, 74, 74, { 0, 500, 2, 1, 0, ',' }},
	{0x004D, 0x007F, 257, -1, 4891, 4894, 4903, 4925, 4929, 4891, 0, {38803, 0, 0, 0}, 75, 75, { 0, 500, 2, 1, 0, ',' }},
	{0x004E, 0x007F, 257, -1, 4933, 4936, 4944, 4960, 4964, 4933, 0, {38856, 0, 0, 0}, 76, 76, { 0, 500, 2, 1, 0, ',' }},
	{0x0050, 0x007F, 257, -1, 4968, 4971, 4981, 4994, 4998, 4968, 0, {38918, 0, 0, 0}, 77, 77, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0051, 0x007F, 257, -1, 5002, 5005, 5013, 5038, 5042, 5002, 0, {0, 0, 0, 0}, 78, 78, { 0, 500, 2, 1, 0, ',' }},
	{0x0052, 0x007F, 257, -1, 5046, 5049, 5055, 5063, 5067, 5046, 0, {38950, 0, 0, 0}, 79, 79, { 1252, 20285, 10000, 850, 0, ';' }},
	{0x0053, 0x007F, 257, -1, 5071, 5074, 5080, 5096, 5100, 5071, 0, {38966, 0, 0, 0}, 80, 80, { 0, 500, 2, 1, 0, ',' }},
	{0x0054, 0x007F, 257, -1, 5104, 5107, 5111, 5121, 5125, 5104, 0, {39021, 0, 0, 0}, 81, 81, { 0, 500, 2, 1, 0, ';' }},
	{0x0055, 0x007F, 257, -1, 5129, 5132, 5140, 5159, 5163, 5129, 0, {39067, 0, 0, 0}, 82, 82, { 0, 500, 2, 1, 0, ';' }},
	{0x0056, 0x007F, 257, -1, 5167, 5170, 5179, 5186, 5190, 5167, 0, {37090, 0, 0, 0}, 83, 83, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0057, 0x007F, 257, -1, 5194, 5198, 5206, 5225, 5194, 5194, 0, {0, 0, 0, 0}, 84, 84, { 0, 500, 2, 1, 0, ',' }},
	{0x005B, 0x007F, 257, -1, 5229, 5232, 5240, 5256, 5260, 5229, 0, {39138, 0, 0, 0}, 85, 85, { 0, 500, 2, 1, 0, ';' }},
	{0x005C, 0x007F, 257, -1, 5264, 5268, 5277, 5287, 5264, 5264, 0, {39204, 0, 0, 0}, 86, 86, { 0, 500, 2, 1, 0, ',' }},
	{0x005E, 0x007F, 257, -1, 5, 5291, 5299, 5312, 5316, 5, 0, {39243, 0, 0, 0}, 87, 87, { 0, 500, 2, 1, 0, ';' }},
	{0x005F, 0x007F, 257, -1, 5320, 5324, 5348, 5371, 5320, 5320, 0, {0, 0, 0, 0}, 88, 88, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0061, 0x007F, 257, -1, 5375, 5378, 5385, 5404, 5408, 5375, 0, {39291, 0, 0, 0}, 89, 89, { 0, 500, 2, 1, 0, ',' }},
	{0x0062, 0x007F, 257, -1, 5412, 5415, 5431, 5442, 5446, 5412, 0, {39341, 0, 0, 0}, 90, 90, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0063, 0x007F, 1024, -1, 5450, 5453, 5460, 5469, 5473, 5450, 0, {0, 0, 0, 0}, 91, 91, { 0, 500, 2, 1, 1, ';' }},
	{0x0064, 0x007F, 257, -1, 5477, 5481, 5481, 5490, 5477, 5477, 0, {39364, 0, 0, 0}, 92, 92, { 1252, 500, 10000, 437, 0, ';' }},
	{0x0067, 0x007F, 257, -1, 5494, 5497, 5503, 5510, 5514, 5494, 0, {0, 0, 0, 0}, 93, 93, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0068, 0x007F, 257, -1, 5518, 5521, 5521, 5527, 5531, 5518, 0, {0, 0, 0, 0}, 94, 94, { 1252, 37, 10000, 437, 0, ';' }},
	{0x006A, 0x007F, 257, -1, 5535, 5538, 5545, 5560, 5564, 5535, 0, {0, 0, 0, 0}, 95, 95, { 1252, 37, 10000, 437, 0, ';' }},
	{0x006C, 0x007F, 257, -1, 5568, 5572, 5587, 5604, 5568, 5568, 0, {0, 0, 0, 0}, 96, 96, { 1252, 500, 10000, 850, 0, ';' }},
	{0x006E, 0x007F, 257, -1, 5608, 5611, 5625, 5641, 5645, 5608, 0, {39388, 0, 0, 0}, 97, 97, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x006F, 0x007F, 257, -1, 5649, 5652, 5664, 5676, 5680, 5649, 0, {39412, 0, 0, 0}, 98, 98, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0070, 0x007F, 257, -1, 5684, 5687, 5687, 5692, 5696, 5684, 0, {0, 0, 0, 0}, 99, 99, { 1252, 37, 10000, 437, 0, ';' }},
	{0x0072, 0x007F, 257, -1, 5700, 5703, 5709, 5716, 5720, 5700, 0, {0, 0, 0, 0}, 100, 100, { 0, 500, 2, 1, 0, ';' }},
	{0x0073, 0x007F, 257, -1, 5724, 5727, 5736, 5749, 5753, 5724, 0, {0, 0, 0, 0}, 101, 101, { 0, 500, 2, 1, 0, ';' }},
	{0x0075, 0x007F, 257, -1, 5757, 5761, 5770, 5788, 5757, 5757, 0, {0, 0, 0, 0}, 102, 102, { 1252, 37, 10000, 437, 0, ';' }},
	{0x0077, 0x007F, 257, -1, 5792, 5795, 5802, 5811, 5815, 5792, 0, {0, 0, 0, 0}, 103, 103, { 0, 500, 2, 1, 0, ';' }},
	{0x0078, 0x007F, 257, -1, 5819, 5822, 5833, 5843, 5847, 5819, 0, {39439, 0, 0, 0}, 104, 104, { 0, 500, 2, 1, 0, ';' }},
	{0x007E, 0x007F, 257, -1, 5851, 5854, 5861, 5871, 5875, 5851, 0, {39452, 0, 0, 0}, 105, 105, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0080, 0x007F, 257, -1, 5879, 5882, 5889, 5906, 5910, 5879, 0, {39472, 0, 0, 0}, 106, 106, { 1256, 20420, 10004, 720, 1, ',' }},
	{0x0084, 0x007F, 257, -1, 5914, 5918, 5931, 5950, 5914, 5914, 0, {39508, 0, 0, 0}, 107, 107, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0085, 0x007F, 257, -1, 5954, 5958, 5964, 5982, 5954, 5954, 0, {0, 0, 0, 0}, 108, 108, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0087, 0x007F, 257, -1, 5986, 5989, 5989, 6001, 6005, 5986, 0, {0, 0, 0, 0}, 109, 109, { 1252, 37, 10000, 437, 0, ';' }},
	{0x0091, 0x007F, 257, -1, 6009, 6012, 6028, 6038, 6042, 6009, 0, {39533, 0, 0, 0}, 110, 110, { 1252, 20285, 10000, 850, 0, ';' }},
	{0x0401, 0x0001, 768, 111, 6046, 6052, 6074, 2571, 2575, 2546, 311, {0, 0, 36860, 0}, 111, 111, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0402, 0x0002, 257, 11, 6138, 6144, 6165, 2611, 2615, 2579, 6203, {36888, 0, 0, 0}, 112, 112, { 1251, 21025, 10007, 866, 0, ';' }},
	{0x0403, 0x0003, 257, 38, 6206, 6212, 6228, 2638, 2642, 2619, 6246, {36930, 0, 0, 0}, 113, 113, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0404, 0x7C04, 257, 126, 6249, 6255, 6277, 6293, 2686, 2690, 6297, {39558, 0, 0, 0}, 114, 114, { 950, 500, 10002, 950, 0, ',' }},
	{0x0405, 0x0005, 257, 29, 6300, 6306, 6329, 2747, 2751, 2728, 6359, {36957, 0, 0, 0}, 115, 115, { 1250, 500, 10029, 852, 0, ';' }},
	{0x0406, 0x0006, 257, 31, 6362, 6368, 6385, 2771, 2775, 2755, 6401, {36983, 0, 0, 0}, 116, 116, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0407, 0x0007, 257, 30, 6404, 6410, 6427, 2797, 2801, 2779, 6449, {37004, 0, 0, 0}, 117, 117, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x0408, 0x0008, 257, 46, 6452, 6458, 6473, 2831, 2835, 2805, 6505, {37029, 0, 0, 0}, 118, 118, { 1253, 20273, 10006, 737, 0, ';' }},
	{0x0409, 0x0009, 257, 128, 6508, 6514, 6514, 2850, 2854, 2839, 6538, {37071, 0, 0, 0}, 119, 119, { 1252, 37, 10000, 437, 0, ',' }},
	{0x040B, 0x000B, 257, 40, 6541, 6547, 6565, 2903, 2907, 2886, 6579, {37112, 0, 0, 0}, 120, 120, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x040C, 0x000C, 257, 42, 6582, 6588, 6604, 2931, 2935, 2911, 6623, {37137, 0, 0, 0}, 121, 121, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x040D, 0x000D, 257, 55, 6626, 6632, 6648, 2960, 2964, 2939, 6672, {37159, 0, 0, 0}, 122, 122, { 1255, 500, 10005, 862, 1, ',' }},
	{0x040E, 0x000E, 257, 52, 6675, 6681, 6701, 2988, 2992, 2968, 6724, {37196, 0, 0, 0}, 123, 123, { 1250, 500, 10029, 852, 0, ';' }},
	{0x040F, 0x000F, 257, 59, 6727, 6733, 6753, 3019, 3023, 2996, 6773, {37212, 0, 0, 0}, 124, 124, { 1252, 20871, 10079, 850, 0, ';' }},
	{0x0410, 0x0010, 257, 60, 6776, 6782, 6798, 3047, 3051, 3027, 6816, {37232, 0, 0, 0}, 125, 125, { 1252, 20280, 10000, 850, 0, ';' }},
	{0x0411, 0x0011, 257, 63, 6819, 6825, 6842, 3077, 3081, 3055, 6861, {37254, 0, 0, 0}, 126, 126, { 932, 20290, 10001, 932, 0, ',' }},
	{0x0412, 0x0012, 257, 67, 6864, 6870, 6891, 3105, 3109, 3085, 6916, {37281, 0, 0, 0}, 127, 127, { 949, 20833, 10003, 949, 0, ',' }},
	{0x0413, 0x0013, 257, 92, 6919, 6925, 6945, 3133, 3137, 3113, 6968, {37288, 0, 0, 0}, 128, 128, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0414, 0x7C14, 257, 93, 6971, 6977, 7004, 3160, 3164, 3168, 7026, {36983, 0, 0, 0}, 129, 129, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0415, 0x0015, 257, 101, 7029, 7035, 7051, 3188, 3192, 3171, 7067, {37310, 0, 0, 0}, 130, 130, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0416, 0x0016, 257, 15, 7070, 7076, 7096, 3221, 3225, 3196, 7116, {37334, 0, 0, 0}, 131, 131, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0417, 0x0017, 257, 21, 7119, 7125, 7147, 3250, 3254, 3229, 314, {37357, 0, 0, 0}, 132, 132, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x0418, 0x0018, 257, 107, 7166, 7172, 7191, 3279, 3283, 3258, 7211, {37377, 0, 0, 0}, 133, 133, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0419, 0x0019, 257, 109, 7214, 7220, 7237, 3313, 3317, 3287, 7267, {37396, 0, 0, 0}, 134, 134, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x041A, 0x001A, 257, 50, 7270, 7276, 7295, 3342, 3346, 3321, 7315, {37442, 0, 0, 0}, 135, 135, { 1250, 500, 10082, 852, 0, ';' }},
	{0x041B, 0x001B, 257, 115, 7318, 7324, 7342, 3372, 3376, 3350, 7366, {37465, 0, 0, 0}, 136, 136, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x041C, 0x001C, 257, 2, 7369, 7375, 7394, 3398, 3402, 3380, 7412, {37489, 0, 0, 0}, 137, 137, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x041D, 0x001D, 257, 112, 7415, 7421, 7438, 3425, 3429, 3406, 7456, {36983, 0, 0, 0}, 138, 138, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x041E, 0x001E, 512, 120, 7459, 7465, 7481, 3451, 3455, 3433, 7503, {0, 37508, 0, 0}, 139, 139, { 874, 20838, 10021, 874, 0, ',' }},
	{0x041F, 0x001F, 257, 124, 7506, 7512, 7529, 3479, 3483, 3459, 7549, {37539, 0, 0, 0}, 140, 140, { 1254, 20905, 10081, 857, 0, ';' }},
	{0x0420, 0x0020, 257, 100, 7552, 7558, 7574, 3504, 3508, 3487, 7600, {37553, 0, 0, 0}, 141, 141, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0421, 0x0021, 257, 53, 7603, 7609, 7632, 3536, 3540, 3512, 7654, {37583, 0, 0, 0}, 142, 142, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0422, 0x0022, 257, 127, 7657, 7663, 7683, 3578, 3582, 3544, 7721, {37602, 0, 0, 0}, 143, 143, { 1251, 500, 10017, 866, 0, ';' }},
	{0x0423, 0x0023, 257, 17, 7724, 7730, 7751, 3621, 3625, 3586, 7791, {37648, 0, 0, 0}, 144, 144, { 1251, 500, 10007, 866, 0, ';' }},
	{0x0424, 0x0024, 257, 114, 7794, 7800, 7821, 3656, 3660, 3629, 7847, {37690, 0, 0, 0}, 145, 145, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0425, 0x0025, 257, 35, 7850, 7856, 7875, 3682, 3686, 3664, 7889, {37712, 0, 0, 0}, 146, 146, { 1257, 500, 10029, 775, 0, ';' }},
	{0x0426, 0x0026, 257, 76, 7892, 7898, 7915, 3711, 3715, 3690, 7935, {37732, 0, 0, 0}, 147, 147, { 1257, 500, 10029, 775, 0, ';' }},
	{0x0427, 0x0027, 257, 74, 7938, 7944, 7967, 3743, 3747, 3719, 7987, {37751, 0, 0, 0}, 148, 148, { 1257, 500, 10029, 775, 0, ';' }},
	{0x0428, 0x7C28, 257, 121, 7990, 8001, 8030, 3773, 3777, 3751, 8066, {0, 0, 0, 0}, 149, 149, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0429, 0x0029, 257, 58, 8069, 8075, 8090, 3803, 3807, 3781, 8114, {37774, 0, 0, 0}, 150, 150, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x042A, 0x002A, 257, 132, 8117, 8123, 8144, 3840, 3844, 3811, 8172, {37798, 0, 0, 0}, 151, 151, { 1258, 500, 10000, 1258, 0, ',' }},
	{0x042B, 0x002B, 257, 3, 8175, 8181, 8200, 3875, 3879, 3848, 49, {37813, 0, 0, 0}, 152, 152, { 0, 500, 2, 1, 0, ',' }},
	{0x042C, 0x782C, 257, 7, 8234, 8245, 8277, 3910, 3914, 3883, 8303, {37843, 0, 0, 0}, 153, 153, { 1254, 20905, 10081, 857, 0, ';' }},
	{0x042D, 0x002D, 257, 38, 8306, 8312, 8327, 3936, 3940, 3918, 6246, {37862, 0, 0, 0}, 154, 154, { 1252, 500, 2, 850, 0, ';' }},
	{0x042E, 0x002E, 257, 30, 8346, 8353, 8377, 3980, 3944, 3944, 6449, {37882, 0, 0, 0}, 155, 155, { 1252, 870, 10000, 850, 0, ';' }},
	{0x042F, 0x002F, 257, 82, 8405, 8411, 8434, 4019, 4023, 3984, 8478, {37903, 0, 0, 0}, 156, 156, { 1251, 500, 10007, 866, 0, ';' }},
	{0x0430, 0x0030, 257, 134, 8481, 8487, 4045, 4053, 4057, 4027, 8517, {0, 0, 0, 0}, 157, 157, { 0, 500, 2, 1, 0, ';' }},
	{0x0431, 0x0031, 257, 134, 8520, 8526, 4071, 4080, 4084, 4061, 8517, {0, 0, 0, 0}, 158, 158, { 0, 500, 2, 1, 0, ';' }},
	{0x0432, 0x0032, 257, 134, 8548, 8554, 4098, 4107, 4111, 4088, 8517, {0, 0, 0, 0}, 159, 159, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0434, 0x0034, 257, 134, 8576, 8582, 4124, 4133, 4137, 4115, 8517, {0, 0, 0, 0}, 160, 160, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0435, 0x0035, 257, 134, 8603, 8609, 8629, 4157, 4161, 4141, 8517, {37947, 0, 0, 0}, 161, 161, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0436, 0x0036, 257, 134, 8654, 8660, 8685, 4178, 4182, 4165, 8517, {37972, 0, 0, 0}, 162, 162, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0437, 0x0037, 257, 44, 8709, 8715, 8734, 4220, 4224, 4186, 8789, {37992, 0, 0, 0}, 163, 163, { 0, 500, 2, 1, 0, ';' }},
	{0x0438, 0x0038, 257, 41, 8792, 8798, 8822, 4249, 4253, 4228, 8843, {38057, 0, 0, 0}, 164, 164, { 1252, 20277, 10079, 850, 0, ';' }},
	{0x0439, 0x0039, 257, 56, 8846, 8852, 8866, 4285, 4289, 4257, 8900, {38081, 0, 0, 0}, 165, 165, { 0, 500, 2, 1, 0, ',' }},
	{0x043A, 0x003A, 257, 87, 8903, 8909, 8925, 4310, 4314, 4293, 8939, {38134, 0, 0, 0}, 166, 166, { 0, 500, 2, 1, 0, ';' }},
	{0x043B, 0x003B, 257, 93, 8942, 8948, 8971, 4352, 4356, 4318, 7026, {38155, 0, 0, 0}, 167, 167, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x043E, 0x003E, 257, 89, 8996, 9002, 9019, 4408, 4412, 4385, 9044, {38195, 0, 0, 0}, 168, 168, { 1252, 500, 10000, 850, 0, ';' }},
	{0x043F, 0x003F, 257, 69, 9047, 9053, 9073, 4446, 4450, 4416, 9114, {38212, 0, 0, 0}, 169, 169, { 0, 500, 2, 1, 0, ';' }},
	{0x0440, 0x0040, 257, 65, 9117, 9123, 9143, 4481, 4485, 4454, 9183, {38254, 0, 0, 0}, 170, 170, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0441, 0x0041, 257, 64, 9186, 9192, 9208, 4510, 4514, 4489, 9226, {38294, 0, 0, 0}, 171, 171, { 1252, 500, 10000, 437, 0, ';' }},
	{0x0442, 0x0042, 257, 122, 9229, 9235, 9258, 4541, 4545, 4518, 9286, {38315, 0, 0, 0}, 172, 172, { 1250, 20880, 10029, 852, 0, ';' }},
	{0x0443, 0x7C43, 257, 130, 9289, 9300, 9326, 4567, 4571, 4549, 9350, {38337, 0, 0, 0}, 173, 173, { 1254, 500, 10029, 857, 0, ';' }},
	{0x0444, 0x0044, 257, 109, 9353, 9359, 9374, 4595, 4599, 4575, 7267, {38355, 0, 0, 0}, 174, 174, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0445, 0x0045, 257, 56, 9400, 9406, 9421, 4629, 4633, 4603, 8900, {38390, 0, 0, 0}, 175, 175, { 0, 500, 2, 1, 0, ',' }},
	{0x0447, 0x0047, 257, 56, 9452, 9458, 9475, 4709, 4713, 4675, 8900, {38508, 0, 0, 0}, 176, 176, { 0, 500, 2, 1, 0, ',' }},
	{0x0448, 0x0048, 257, 56, 9512, 9518, 9531, 4741, 4745, 4717, 8900, {0, 0, 0, 0}, 177, 177, { 0, 500, 2, 1, 0, ',' }},
	{0x0449, 0x0049, 257, 56, 9562, 9568, 9582, 4774, 4778, 4749, 8900, {38564, 0, 0, 0}, 178, 178, { 0, 500, 2, 1, 0, ',' }},
	{0x044A, 0x004A, 257, 56, 9622, 9628, 9643, 4811, 4815, 4782, 8900, {38629, 0, 0, 0}, 179, 179, { 0, 500, 2, 1, 0, ',' }},
	{0x044B, 0x004B, 257, 56, 9690, 9696, 9712, 4843, 4847, 1715, 8900, {38694, 0, 0, 0}, 180, 180, { 0, 500, 2, 1, 0, ',' }},
	{0x044C, 0x004C, 257, 56, 9743, 9749, 9767, 4883, 4887, 4851, 8900, {38759, 0, 0, 0}, 181, 181, { 0, 500, 2, 1, 0, ',' }},
	{0x044D, 0x004D, 257, 56, 9807, 9813, 9830, 4925, 4929, 4891, 8900, {38803, 0, 0, 0}, 182, 182, { 0, 500, 2, 1, 0, ',' }},
	{0x044E, 0x004E, 257, 56, 9867, 9873, 9889, 4960, 4964, 4933, 8900, {38856, 0, 0, 0}, 183, 183, { 0, 500, 2, 1, 0, ',' }},
	{0x0450, 0x7850, 257, 85, 9920, 9926, 9947, 9975, 4998, 4968, 9979, {38918, 0, 0, 0}, 184, 184, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0451, 0x0051, 257, 25, 9982, 9988, 10004, 5038, 5042, 5002, 10050, {0, 0, 0, 0}, 185, 185, { 0, 500, 2, 1, 0, ',' }},
	{0x0452, 0x0052, 257, 43, 10053, 10059, 10082, 5063, 5067, 5046, 10109, {38950, 0, 0, 0}, 186, 186, { 1252, 20285, 10000, 850, 0, ';' }},
	{0x0453, 0x0053, 257, 66, 10112, 10118, 10135, 5096, 5100, 5071, 10175, {38966, 0, 0, 0}, 187, 187, { 0, 500, 2, 1, 0, ',' }},
	{0x0454, 0x0054, 257, 70, 10178, 10184, 10195, 5121, 5125, 5104, 10217, {39021, 0, 0, 0}, 188, 188, { 0, 500, 2, 1, 0, ';' }},
	{0x0455, 0x0055, 257, 84, 10220, 10226, 10252, 5159, 5163, 5129, 10292, {39067, 0, 0, 0}, 189, 189, { 0, 500, 2, 1, 0, ';' }},
	{0x0456, 0x0056, 257, 38, 10295, 10301, 10318, 5186, 5190, 5167, 6246, {37090, 0, 0, 0}, 190, 190, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0457, 0x0057, 257, 56, 10335, 10342, 10358, 5225, 5194, 5194, 8900, {0, 0, 0, 0}, 191, 191, { 0, 500, 2, 1, 0, ',' }},
	{0x045B, 0x005B, 257, 73, 10392, 10398, 10418, 5256, 5260, 5229, 10468, {39138, 0, 0, 0}, 192, 192, { 0, 500, 2, 1, 0, ';' }},
	{0x045E, 0x005E, 257, 39, 10471, 10477, 10496, 5312, 5316, 5, 10527, {39243, 0, 0, 0}, 193, 193, { 0, 500, 2, 1, 0, ';' }},
	{0x0461, 0x0061, 257, 94, 10530, 10536, 10551, 5404, 5408, 5375, 10588, {39291, 0, 0, 0}, 194, 194, { 0, 500, 2, 1, 0, ',' }},
	{0x0462, 0x0062, 257, 92, 10591, 10597, 10627, 5442, 5446, 5412, 6968, {39341, 0, 0, 0}, 195, 195, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0463, 0x0063, 1024, 1, 10650, 10656, 10677, 5469, 5473, 5450, 10707, {0, 0, 0, 0}, 196, 196, { 0, 500, 2, 1, 1, ';' }},
	{0x0464, 0x0064, 257, 99, 10710, 10717, 10740, 5490, 5477, 5477, 10761, {39364, 0, 0, 0}, 197, 197, { 1252, 500, 10000, 437, 0, ';' }},
	{0x0468, 0x7C68, 257, 90, 10764, 10775, 10798, 5527, 5531, 5518, 10815, {0, 0, 0, 0}, 198, 198, { 1252, 37, 10000, 437, 0, ';' }},
	{0x046A, 0x006A, 257, 90, 10818, 10824, 10841, 5560, 5564, 5535, 10815, {0, 0, 0, 0}, 199, 199, { 1252, 37, 10000, 437, 0, ';' }},
	{0x046C, 0x006C, 257, 134, 10887, 10894, 5587, 5604, 5568, 5568, 8517, {0, 0, 0, 0}, 200, 200, { 1252, 500, 10000, 850, 0, ';' }},
	{0x046E, 0x006E, 257, 75, 10924, 10930, 10957, 5641, 5645, 5608, 10987, {39388, 0, 0, 0}, 201, 201, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x046F, 0x006F, 257, 45, 10990, 10996, 11020, 5676, 5680, 5649, 11051, {39412, 0, 0, 0}, 202, 202, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0470, 0x0070, 257, 90, 11054, 11060, 11060, 5692, 5696, 5684, 10815, {0, 0, 0, 0}, 203, 203, { 1252, 37, 10000, 437, 0, ';' }},
	{0x0472, 0x0072, 257, 39, 11075, 11081, 11098, 5716, 5720, 5700, 10527, {0, 0, 0, 0}, 204, 204, { 0, 500, 2, 1, 0, ';' }},
	{0x0473, 0x0073, 257, 39, 11118, 11124, 11144, 11175, 5753, 5724, 10527, {0, 0, 0, 0}, 205, 205, { 0, 500, 2, 1, 0, ';' }},
	{0x0475, 0x0075, 257, 128, 11179, 11186, 11211, 5788, 5757, 5757, 6538, {0, 0, 0, 0}, 206, 206, { 1252, 37, 10000, 437, 0, ';' }},
	{0x0477, 0x0077, 257, 117, 11254, 11260, 11277, 5811, 5815, 5792, 11299, {0, 0, 0, 0}, 207, 207, { 0, 500, 2, 1, 0, ';' }},
	{0x0478, 0x0078, 257, 25, 11302, 11308, 11327, 5843, 5847, 5819, 10050, {39439, 0, 0, 0}, 208, 208, { 0, 500, 2, 1, 0, ';' }},
	{0x047E, 0x007E, 257, 42, 11346, 11352, 11368, 5871, 5875, 5851, 6623, {39452, 0, 0, 0}, 209, 209, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0480, 0x0080, 257, 25, 11387, 11393, 11408, 5906, 5910, 5879, 10050, {39472, 0, 0, 0}, 210, 210, { 1256, 20420, 10004, 720, 1, ',' }},
	{0x0484, 0x0084, 257, 42, 11438, 11445, 11467, 5950, 5914, 5914, 6623, {39508, 0, 0, 0}, 211, 211, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0485, 0x0085, 257, 109, 11499, 11506, 11521, 5982, 5954, 5954, 7267, {0, 0, 0, 0}, 212, 212, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0487, 0x0087, 257, 110, 11560, 11566, 11566, 6001, 6005, 5986, 11587, {0, 0, 0, 0}, 213, 213, { 1252, 37, 10000, 437, 0, ';' }},
	{0x0491, 0x0091, 257, 43, 11590, 11596, 11629, 6038, 6042, 6009, 10109, {39533, 0, 0, 0}, 214, 214, { 1252, 20285, 10000, 850, 0, ';' }},
	{0x0801, 0x0001, 257, 57, 11665, 11671, 11685, 11715, 2575, 2546, 11719, {39565, 0, 0, 0}, 215, 215, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0803, 0x0403, 257, 38, 11722, 6212, 6228, 11737, 2642, 2619, 6246, {36930, 0, 0, 0}, 216, 216, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0804, 0x0004, 257, 25, 11741, 2654, 11747, 2682, 2686, 2690, 10050, {36950, 0, 0, 0}, 217, 217, { 936, 500, 10008, 936, 0, ',' }},
	{0x0807, 0x0007, 257, 21, 11763, 11769, 11790, 11808, 2801, 2779, 314, {37004, 0, 0, 0}, 218, 218, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x0809, 0x0009, 257, 43, 11812, 11818, 11818, 11843, 2854, 2839, 10109, {37071, 0, 0, 0}, 219, 219, { 1252, 20285, 10000, 850, 0, ',' }},
	{0x080A, 0x000A, 257, 88, 11847, 11853, 11870, 11889, 2882, 2858, 11893, {37232, 0, 0, 0}, 220, 220, { 1252, 20284, 10000, 850, 0, ',' }},
	{0x080C, 0x000C, 257, 10, 11896, 11902, 11919, 11940, 2935, 2911, 11944, {37137, 0, 0, 0}, 221, 221, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0810, 0x0010, 257, 21, 11947, 11953, 11975, 11995, 3051, 3027, 314, {37232, 0, 0, 0}, 222, 222, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0813, 0x0013, 257, 10, 11999, 12005, 12021, 12042, 3137, 3113, 11944, {37288, 0, 0, 0}, 223, 223, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0814, 0x7814, 257, 93, 12046, 12052, 12079, 12095, 12099, 12103, 7026, {36983, 0, 0, 0}, 224, 224, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x0816, 0x0016, 257, 103, 12106, 12112, 12134, 444, 3225, 3196, 12156, {39597, 0, 0, 0}, 225, 225, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0818, 0x0018, 257, 80, 12159, 12165, 12184, 12213, 3283, 3258, 12217, {37377, 0, 0, 0}, 226, 226, { 1250, 500, 2, 852, 0, ';' }},
	{0x0819, 0x0019, 257, 80, 12220, 12226, 12244, 12276, 3317, 3287, 12217, {37396, 0, 0, 0}, 227, 227, { 1251, 500, 2, 866, 0, ';' }},
	{0x081D, 0x001D, 257, 40, 12280, 12286, 12304, 12322, 3429, 3406, 6579, {36983, 0, 0, 0}, 228, 228, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x0820, 0x0020, 257, 56, 12326, 12332, 12345, 12367, 3508, 3487, 8900, {37553, 0, 0, 0}, 229, 229, { 1256, 500, 2, 720, 1, ';' }},
	{0x082C, 0x742C, 257, 7, 12371, 12382, 8277, 12417, 3914, 3883, 8303, {37843, 0, 0, 0}, 230, 230, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x082E, 0x7C2E, 257, 30, 12421, 12428, 12452, 12478, 12482, 12482, 6449, {39620, 0, 0, 0}, 231, 231, { 1252, 870, 10000, 850, 0, ';' }},
	{0x0832, 0x0032, 257, 16, 12486, 12492, 4098, 12510, 4111, 4088, 12514, {0, 0, 0, 0}, 232, 232, { 1252, 500, 10000, 850, 0, ';' }},
	{0x083B, 0x003B, 257, 112, 12517, 12523, 12546, 12574, 4356, 4318, 7456, {38155, 0, 0, 0}, 233, 233, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x083C, 0x003C, 257, 54, 12578, 12584, 12600, 4377, 4381, 4360, 12616, {38174, 0, 0, 0}, 234, 234, { 1252, 500, 10000, 850, 0, ';' }},
	{0x083E, 0x003E, 257, 13, 12619, 12625, 12640, 12663, 4412, 4385, 12667, {38195, 0, 0, 0}, 235, 235, { 1252, 500, 10000, 850, 0, ';' }},
	{0x0843, 0x7843, 257, 130, 12670, 12681, 9326, 12710, 4571, 4549, 9350, {39643, 0, 0, 0}, 236, 236, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x0845, 0x0045, 257, 9, 12714, 12720, 12740, 12783, 4633, 4603, 12787, {38390, 0, 0, 0}, 237, 237, { 0, 500, 2, 1, 0, ',' }},
	{0x0846, 0x7C46, 257, 100, 12790, 12801, 12828, 12874, 4671, 4637, 7600, {38461, 0, 0, 0}, 238, 238, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0849, 0x0049, 257, 73, 12878, 12884, 12902, 12939, 4778, 4749, 10468, {38564, 0, 0, 0}, 239, 239, { 0, 500, 2, 1, 0, ';' }},
	{0x0861, 0x0061, 257, 56, 12943, 12949, 12964, 12998, 5408, 5375, 8900, {39291, 0, 0, 0}, 240, 240, { 0, 500, 2, 1, 0, ';' }},
	{0x0873, 0x0073, 257, 37, 13002, 13008, 13027, 5749, 5753, 5724, 13055, {0, 0, 0, 0}, 241, 241, { 0, 500, 2, 1, 0, ';' }},
	{0x0C01, 0x0001, 257, 36, 13058, 13064, 13079, 13103, 2575, 2546, 13107, {39565, 0, 0, 0}, 242, 242, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x0C04, 0x7C04, 257, 48, 13110, 13116, 13159, 13196, 2686, 2690, 13200, {39558, 0, 0, 0}, 243, 243, { 950, 500, 10002, 950, 0, ',' }},
	{0x0C07, 0x0007, 257, 5, 13203, 13209, 13226, 13248, 2801, 2779, 13252, {37004, 0, 0, 0}, 244, 244, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x0C09, 0x0009, 257, 6, 13255, 13261, 13261, 13281, 2854, 2839, 13285, {37071, 0, 0, 0}, 245, 245, { 1252, 500, 10000, 850, 0, ',' }},
	{0x0C0A, 0x000A, 257, 38, 13288, 13294, 13310, 13329, 2882, 2858, 6246, {37090, 0, 0, 0}, 246, 246, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x0C0C, 0x000C, 257, 19, 13333, 13339, 13355, 13374, 2935, 2911, 13378, {37137, 0, 0, 0}, 247, 247, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x0C3B, 0x003B, 257, 40, 13381, 13387, 13411, 13437, 4356, 4318, 6579, {39681, 0, 0, 0}, 248, 248, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x1001, 0x0001, 257, 77, 13441, 13447, 13462, 13490, 2575, 2546, 13494, {39565, 0, 0, 0}, 249, 249, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x1004, 0x0004, 257, 113, 13497, 13503, 13535, 13554, 2686, 2690, 13558, {36950, 0, 0, 0}, 250, 250, { 936, 500, 10008, 936, 0, ',' }},
	{0x1007, 0x0007, 257, 75, 13561, 13567, 13587, 13607, 2801, 2779, 10987, {37004, 0, 0, 0}, 251, 251, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x1009, 0x0009, 257, 19, 13611, 13617, 13617, 13634, 2854, 2839, 13378, {37071, 0, 0, 0}, 252, 252, { 1252, 37, 10000, 850, 0, ',' }},
	{0x100A, 0x000A, 257, 47, 13638, 13644, 13664, 13685, 2882, 2858, 13689, {37090, 0, 0, 0}, 253, 253, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x100C, 0x000C, 257, 21, 13692, 13698, 13719, 13738, 2935, 2911, 314, {37137, 0, 0, 0}, 254, 254, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x101A, 0x001A, 257, 8, 13742, 13748, 13780, 13811, 3346, 3321, 13815, {37442, 0, 0, 0}, 255, 255, { 1250, 870, 10082, 852, 0, ';' }},
	{0x1401, 0x0001, 257, 33, 13818, 13824, 13841, 13873, 2575, 2546, 13877, {39565, 0, 0, 0}, 256, 256, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x1404, 0x7C04, 257, 86, 13880, 13886, 13925, 13962, 2686, 2690, 13966, {39558, 0, 0, 0}, 257, 257, { 950, 500, 10002, 950, 0, ',' }},
	{0x1407, 0x0007, 257, 72, 13969, 13975, 13998, 14022, 2801, 2779, 14026, {37004, 0, 0, 0}, 258, 258, { 1252, 20273, 10000, 850, 0, ';' }},
	{0x1409, 0x0009, 257, 95, 14029, 14035, 14035, 14057, 2854, 2839, 14061, {37071, 0, 0, 0}, 259, 259, { 1252, 500, 10000, 850, 0, ',' }},
	{0x140A, 0x000A, 257, 27, 14064, 14070, 14091, 14113, 2882, 2858, 14117, {37090, 0, 0, 0}, 260, 260, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x140C, 0x000C, 257, 75, 14120, 14126, 14146, 14169, 2935, 2911, 10987, {37137, 0, 0, 0}, 261, 261, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x141A, 0x681A, 257, 8, 14173, 14184, 14222, 14253, 14257, 14261, 13815, {37442, 0, 0, 0}, 262, 262, { 1250, 870, 10082, 852, 0, ';' }},
	{0x1801, 0x0001, 257, 78, 14264, 14270, 14287, 14317, 2575, 2546, 14321, {39565, 0, 0, 0}, 263, 263, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x1809, 0x0009, 257, 54, 14324, 14330, 14330, 14348, 2854, 2839, 12616, {37071, 0, 0, 0}, 264, 264, { 1252, 500, 10000, 850, 0, ',' }},
	{0x180A, 0x000A, 257, 97, 14352, 14358, 14375, 14394, 2882, 2858, 14398, {37090, 0, 0, 0}, 265, 265, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x180C, 0x000C, 257, 79, 14401, 14407, 14423, 14442, 2935, 2911, 14446, {37137, 0, 0, 0}, 266, 266, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x181A, 0x701A, 257, 8, 14449, 14460, 14498, 14550, 14554, 14558, 13815, {37442, 0, 0, 0}, 267, 267, { 1250, 870, 10082, 852, 0, ';' }},
	{0x1C01, 0x0001, 257, 123, 14561, 14567, 14584, 14610, 2575, 2546, 14614, {39565, 0, 0, 0}, 268, 268, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x1C09, 0x0009, 257, 134, 14617, 14623, 14623, 14646, 2854, 2839, 8517, {37071, 0, 0, 0}, 269, 269, { 1252, 500, 10000, 437, 0, ',' }},
	{0x1C0A, 0x000A, 257, 32, 14650, 14656, 14685, 14718, 2882, 2858, 14722, {37090, 0, 0, 0}, 270, 270, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x1C1A, 0x6C1A, 257, 8, 14725, 14736, 14498, 14777, 14554, 14558, 13815, {39703, 0, 0, 0}, 271, 271, { 1251, 21025, 10007, 855, 0, ';' }},
	{0x2001, 0x0001, 257, 96, 14781, 14787, 14801, 14829, 2575, 2546, 14833, {39565, 0, 0, 0}, 272, 272, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x2009, 0x0009, 257, 61, 14836, 14842, 14842, 14860, 2854, 2839, 14864, {37071, 0, 0, 0}, 273, 273, { 1252, 500, 10000, 850, 0, ',' }},
	{0x200A, 0x000A, 257, 131, 14867, 14873, 14893, 14914, 2882, 2858, 14918, {37090, 0, 0, 0}, 274, 274, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x200C, 0x000C, 257, 106, 14921, 14927, 14945, 14969, 2935, 2911, 14973, {37137, 0, 0, 0}, 275, 275, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x201A, 0x641A, 257, 8, 14976, 14987, 14222, 15028, 14257, 14261, 13815, {37903, 0, 0, 0}, 276, 276, { 1251, 870, 10082, 855, 0, ';' }},
	{0x2401, 0x0001, 257, 133, 15032, 15038, 15053, 15081, 2575, 2546, 15085, {39565, 0, 0, 0}, 277, 277, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x240A, 0x000A, 257, 26, 15088, 15094, 15113, 15133, 2882, 2858, 15137, {37090, 0, 0, 0}, 278, 278, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x240C, 0x000C, 257, 20, 15140, 15146, 15172, 15199, 2935, 2911, 15203, {37137, 0, 0, 0}, 279, 279, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x241A, 0x701A, 257, 108, 15206, 15217, 15241, 15269, 14554, 14558, 15273, {37442, 0, 0, 0}, 280, 280, { 1250, 500, 10029, 852, 0, ';' }},
	{0x243B, 0x703B, 257, 40, 15276, 15283, 15304, 15328, 15332, 15332, 6579, {0, 0, 0, 0}, 281, 281, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x2801, 0x0001, 257, 119, 15336, 15342, 15357, 15385, 2575, 2546, 15389, {39565, 0, 0, 0}, 282, 282, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x2809, 0x0009, 257, 18, 15392, 15398, 15398, 15415, 2854, 2839, 15419, {37071, 0, 0, 0}, 283, 283, { 1252, 500, 10000, 850, 0, ',' }},
	{0x280A, 0x000A, 257, 98, 15422, 15428, 15443, 15460, 2882, 2858, 15464, {37090, 0, 0, 0}, 284, 284, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x280C, 0x000C, 257, 116, 15467, 15473, 15490, 15512, 2935, 2911, 15516, {37137, 0, 0, 0}, 285, 285, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x281A, 0x6C1A, 257, 108, 15519, 15530, 15241, 15557, 14554, 14558, 15273, {39703, 0, 0, 0}, 286, 286, { 1251, 21025, 10007, 855, 0, ';' }},
	{0x2C01, 0x0001, 257, 62, 15561, 15567, 15583, 15613, 2575, 2546, 15617, {39565, 0, 0, 0}, 287, 287, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x2C09, 0x0009, 257, 125, 15620, 15626, 15626, 15654, 2854, 2839, 15658, {37071, 0, 0, 0}, 288, 288, { 1252, 500, 10000, 850, 0, ',' }},
	{0x2C0A, 0x000A, 257, 4, 15661, 15667, 15687, 15708, 2882, 2858, 15712, {37090, 0, 0, 0}, 289, 289, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x2C0C, 0x000C, 257, 24, 15715, 15721, 15739, 15760, 2935, 2911, 15764, {37137, 0, 0, 0}, 290, 290, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x2C1A, 0x701A, 257, 81, 15767, 15778, 15806, 15839, 14554, 14558, 15843, {37442, 0, 0, 0}, 291, 291, { 1250, 500, 10029, 852, 0, ';' }},
	{0x3001, 0x0001, 257, 71, 15846, 15852, 15869, 15897, 2575, 2546, 15901, {39565, 0, 0, 0}, 292, 292, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x3009, 0x0009, 257, 135, 15904, 15910, 15910, 15929, 2854, 2839, 15933, {37071, 0, 0, 0}, 293, 293, { 1252, 500, 10000, 437, 0, ',' }},
	{0x300A, 0x000A, 257, 34, 15936, 15942, 15960, 15979, 2882, 2858, 15983, {37090, 0, 0, 0}, 294, 294, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x300C, 0x000C, 257, 22, 15986, 15992, 16018, 16047, 2935, 2911, 16051, {37137, 0, 0, 0}, 295, 295, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x301A, 0x6C1A, 257, 81, 16054, 16065, 15806, 16096, 14554, 14558, 15843, {39703, 0, 0, 0}, 296, 296, { 1251, 21025, 10007, 855, 0, ';' }},
	{0x3401, 0x0001, 257, 68, 16100, 16106, 16122, 16152, 2575, 2546, 16156, {39565, 0, 0, 0}, 297, 297, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x3409, 0x0009, 257, 99, 16159, 16165, 16165, 16187, 2854, 2839, 10761, {37071, 0, 0, 0}, 298, 298, { 1252, 500, 10000, 437, 0, ',' }},
	{0x340A, 0x000A, 257, 23, 16191, 16197, 16213, 16230, 2882, 2858, 16234, {37090, 0, 0, 0}, 299, 299, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x340C, 0x000C, 257, 83, 16237, 16243, 16257, 16274, 2935, 2911, 16278, {37137, 0, 0, 0}, 300, 300, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x3801, 0x0001, 257, 0, 16281, 16287, 16317, 16381, 2575, 2546, 16385, {39565, 0, 0, 0}, 301, 301, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x380A, 0x000A, 257, 129, 16388, 16394, 16412, 16431, 2882, 2858, 16435, {37090, 0, 0, 0}, 302, 302, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x380C, 0x000C, 257, 78, 16438, 16444, 16461, 16479, 2935, 2911, 14321, {37137, 0, 0, 0}, 303, 303, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x3C01, 0x0001, 257, 12, 16483, 16489, 16506, 16538, 2575, 2546, 16542, {39565, 0, 0, 0}, 304, 304, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x3C09, 0x0009, 257, 48, 16545, 16551, 16551, 16581, 2854, 2839, 13200, {37071, 0, 0, 0}, 305, 305, { 1252, 500, 10000, 850, 0, ',' }},
	{0x3C0A, 0x000A, 257, 104, 16585, 16591, 16610, 16630, 2882, 2858, 16634, {37090, 0, 0, 0}, 306, 306, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x3C0C, 0x000C, 257, 51, 16637, 16643, 16658, 16677, 2935, 2911, 16681, {37137, 0, 0, 0}, 307, 307, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x4001, 0x0001, 257, 105, 16684, 16690, 16705, 16729, 2575, 2546, 16733, {39565, 0, 0, 0}, 308, 308, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x4009, 0x0009, 257, 56, 16736, 16742, 16742, 16758, 2854, 2839, 8900, {37071, 0, 0, 0}, 309, 309, { 1252, 37, 10000, 437, 0, ',' }},
	{0x400A, 0x000A, 257, 14, 16762, 16768, 16786, 16805, 2882, 2858, 16809, {37090, 0, 0, 0}, 310, 310, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x4409, 0x0009, 257, 89, 16812, 16818, 16818, 16837, 2854, 2839, 9044, {37071, 0, 0, 0}, 311, 311, { 1252, 37, 10000, 437, 0, ',' }},
	{0x440A, 0x000A, 257, 118, 16841, 16847, 16869, 16892, 2882, 2858, 16896, {37090, 0, 0, 0}, 312, 312, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x4809, 0x0009, 257, 113, 16899, 16905, 16905, 16925, 2854, 2839, 13558, {37071, 0, 0, 0}, 313, 313, { 1252, 37, 10000, 437, 0, ',' }},
	{0x480A, 0x000A, 257, 49, 16929, 16935, 16954, 16974, 2882, 2858, 16978, {37090, 0, 0, 0}, 314, 314, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x4C0A, 0x000A, 257, 91, 16981, 16987, 17007, 17028, 2882, 2858, 17032, {37090, 0, 0, 0}, 315, 315, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x500A, 0x000A, 257, 102, 17035, 17041, 17063, 17086, 2882, 2858, 17090, {37090, 0, 0, 0}, 316, 316, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x540A, 0x000A, 257, 128, 17093, 17099, 17123, 17149, 2882, 2858, 6538, {37090, 0, 0, 0}, 317, 317, { 1252, 20284, 10000, 850, 0, ',' }},
	{0x5C0A, 0x000A, 257, 28, 17153, 17159, 17174, 17190, 2882, 2858, 17194, {37090, 0, 0, 0}, 318, 318, { 1252, 20284, 10000, 850, 0, ';' }},
	{0x641A, 0x781A, 257, -1, 17197, 17205, 17224, 15028, 14257, 14261, 0, {37903, 0, 0, 0}, 319, 319, { 1251, 870, 10082, 855, 0, ';' }},
	{0x681A, 0x781A, 257, -1, 17233, 17241, 17224, 14253, 14257, 14261, 0, {37442, 0, 0, 0}, 320, 320, { 1250, 870, 10082, 852, 0, ';' }},
	{0x6C1A, 0x7C1A, 257, -1, 17257, 17265, 17284, 15557, 14554, 14558, 0, {39703, 0, 0, 0}, 321, 321, { 1251, 21025, 10007, 855, 0, ';' }},
	{0x701A, 0x7C1A, 257, -1, 17297, 17305, 17284, 15269, 14554, 14558, 0, {37442, 0, 0, 0}, 322, 322, { 1250, 500, 10029, 852, 0, ';' }},
	{0x703B, 0x003B, 257, -1, 15332, 17321, 17332, 15328, 15332, 15332, 0, {0, 0, 0, 0}, 323, 323, { 1252, 20278, 10000, 850, 0, ';' }},
	{0x742C, 0x002C, 257, -1, 17347, 17355, 3898, 12417, 3914, 3883, 0, {37843, 0, 0, 0}, 324, 324, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x7804, 0x007F, 257, -1, 2690, 2654, 2675, 2682, 2686, 2690, 0, {36950, 0, 0, 0}, 325, 325, { 936, 500, 10008, 936, 0, ',' }},
	{0x7814, 0x0014, 257, -1, 12103, 17378, 17396, 12095, 12099, 12103, 0, {36983, 0, 0, 0}, 326, 326, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x781A, 0x007F, 257, -1, 14261, 17404, 17224, 14253, 14257, 14261, 0, {37442, 0, 0, 0}, 327, 327, { 1250, 870, 10082, 852, 0, ';' }},
	{0x782C, 0x002C, 257, -1, 17412, 17420, 3898, 3910, 3914, 3883, 0, {37843, 0, 0, 0}, 328, 328, { 1254, 20905, 10081, 857, 0, ';' }},
	{0x7843, 0x0043, 257, -1, 17440, 17448, 4558, 12710, 4571, 4549, 0, {39643, 0, 0, 0}, 329, 329, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x7850, 0x0050, 257, -1, 17465, 17473, 4981, 9975, 4998, 4968, 0, {38918, 0, 0, 0}, 330, 330, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x7C04, 0x7804, 257, -1, 17494, 6255, 2675, 6293, 2686, 2690, 0, {39558, 0, 0, 0}, 331, 331, { 950, 500, 10002, 950, 0, ',' }},
	{0x7C04, 0x7C04, 257, -1, 17502, 17509, 2675, 6293, 2686, 2690, 0, {39558, 0, 0, 0}, 332, 332, { 950, 500, 10002, 950, 0, ',' }},
	{0x7C14, 0x0014, 257, -1, 3168, 17538, 17556, 3160, 3164, 3168, 0, {36983, 0, 0, 0}, 333, 333, { 1252, 20277, 10000, 850, 0, ';' }},
	{0x7C1A, 0x007F, 257, -1, 14558, 17570, 17284, 17578, 14554, 14558, 0, {39703, 0, 0, 0}, 334, 334, { 1250, 500, 10029, 852, 0, ';' }},
	{0x7C28, 0x0028, 257, -1, 17582, 17590, 3760, 3773, 3777, 3751, 0, {0, 0, 0, 0}, 335, 335, { 1251, 20880, 10007, 866, 0, ';' }},
	{0x7C2E, 0x002E, 257, -1, 12482, 17607, 17621, 12478, 12482, 12482, 0, {39620, 0, 0, 0}, 336, 336, { 1252, 870, 10000, 850, 0, ';' }},
	{0x7C43, 0x0043, 257, -1, 17638, 17646, 4558, 4567, 4571, 4549, 0, {38337, 0, 0, 0}, 337, 337, { 1254, 500, 10029, 857, 0, ';' }},
	{0x7C46, 0x0046, 257, -1, 17660, 17668, 4648, 12874, 4671, 4637, 0, {38461, 0, 0, 0}, 338, 338, { 1256, 20420, 10004, 720, 1, ';' }},
	{0x7C5F, 0x005F, 257, -1, 17685, 17694, 5348, 5371, 5320, 5320, 0, {0, 0, 0, 0}, 339, 339, { 1252, 20297, 10000, 850, 0, ';' }},
	{0x7C68, 0x0068, 257, -1, 17726, 17734, 5521, 5527, 5531, 5518, 0, {0, 0, 0, 0}, 340, 340, { 1252, 37, 10000, 437, 0, ';' }}
};


static const CultureInfoNameEntry culture_name_entries [] = {
	{4165, 53},	 /* af */
	{17748, 162},	 /* af-za */
	{5, 87},	 /* am */
	{17754, 193},	 /* am-et */
	{2546, 0},	 /* ar */
	{17760, 301},	 /* ar-ae */
	{17766, 304},	 /* ar-bh */
	{17772, 256},	 /* ar-dz */
	{17778, 242},	 /* ar-eg */
	{17784, 215},	 /* ar-iq */
	{17790, 287},	 /* ar-jo */
	{17796, 297},	 /* ar-kw */
	{17802, 292},	 /* ar-lb */
	{17808, 249},	 /* ar-ly */
	{17814, 263},	 /* ar-ma */
	{17820, 272},	 /* ar-om */
	{17826, 308},	 /* ar-qa */
	{17832, 111},	 /* ar-sa */
	{17838, 282},	 /* ar-sy */
	{17844, 268},	 /* ar-tn */
	{17850, 277},	 /* ar-ye */
	{4891, 75},	 /* as */
	{17856, 182},	 /* as-in */
	{3883, 44},	 /* az */
	{17862, 324},	 /* az-cyrl */
	{17870, 230},	 /* az-cyrl-az */
	{17881, 328},	 /* az-latn */
	{17889, 153},	 /* az-latn-az */
	{3586, 35},	 /* be */
	{17900, 144},	 /* be-by */
	{2579, 1},	 /* bg */
	{17906, 112},	 /* bg-bg */
	{4603, 67},	 /* bn */
	{17912, 237},	 /* bn-bd */
	{17918, 175},	 /* bn-in */
	{5002, 78},	 /* bo */
	{17924, 185},	 /* bo-cn */
	{5851, 105},	 /* br */
	{17930, 209},	 /* br-fr */
	{14261, 327},	 /* bs */
	{17936, 319},	 /* bs-cyrl */
	{17944, 276},	 /* bs-cyrl-ba */
	{17955, 320},	 /* bs-latn */
	{17963, 262},	 /* bs-latn-ba */
	{2619, 2},	 /* ca */
	{17974, 113},	 /* ca-es */
	{17980, 216},	 /* ca-es-valencia */
	{5264, 86},	 /* chr */
	{2728, 5},	 /* cs */
	{17995, 115},	 /* cs-cz */
	{5046, 79},	 /* cy */
	{18001, 186},	 /* cy-gb */
	{2755, 6},	 /* da */
	{18007, 116},	 /* da-dk */
	{2779, 7},	 /* de */
	{18013, 244},	 /* de-at */
	{18019, 218},	 /* de-ch */
	{18025, 117},	 /* de-de */
	{18031, 258},	 /* de-li */
	{18037, 251},	 /* de-lu */
	{12482, 336},	 /* dsb */
	{18043, 231},	 /* dsb-de */
	{2805, 8},	 /* el */
	{18050, 118},	 /* el-gr */
	{2839, 9},	 /* en */
	{18056, 245},	 /* en-au */
	{18062, 283},	 /* en-bz */
	{18068, 252},	 /* en-ca */
	{18074, 219},	 /* en-gb */
	{18080, 305},	 /* en-hk */
	{18086, 264},	 /* en-ie */
	{18092, 309},	 /* en-in */
	{18098, 273},	 /* en-jm */
	{18104, 311},	 /* en-my */
	{18110, 259},	 /* en-nz */
	{18116, 298},	 /* en-ph */
	{18122, 313},	 /* en-sg */
	{18128, 288},	 /* en-tt */
	{18134, 119},	 /* en-us */
	{18140, 269},	 /* en-za */
	{18146, 293},	 /* en-zw */
	{2858, 10},	 /* es */
	{18152, 289},	 /* es-ar */
	{18158, 310},	 /* es-bo */
	{18164, 299},	 /* es-cl */
	{18170, 278},	 /* es-co */
	{18176, 260},	 /* es-cr */
	{18182, 318},	 /* es-cu */
	{18188, 270},	 /* es-do */
	{18194, 294},	 /* es-ec */
	{18200, 246},	 /* es-es */
	{18206, 253},	 /* es-gt */
	{18212, 314},	 /* es-hn */
	{18218, 220},	 /* es-mx */
	{18224, 315},	 /* es-ni */
	{18230, 265},	 /* es-pa */
	{18236, 284},	 /* es-pe */
	{18242, 316},	 /* es-pr */
	{18248, 306},	 /* es-py */
	{18254, 312},	 /* es-sv */
	{18260, 317},	 /* es-us */
	{18266, 302},	 /* es-uy */
	{18272, 274},	 /* es-ve */
	{3664, 37},	 /* et */
	{18278, 146},	 /* et-ee */
	{3918, 45},	 /* eu */
	{18284, 154},	 /* eu-es */
	{3781, 41},	 /* fa */
	{18290, 150},	 /* fa-ir */
	{5494, 93},	 /* ff */
	{2886, 11},	 /* fi */
	{18296, 120},	 /* fi-fi */
	{5477, 92},	 /* fil */
	{18302, 197},	 /* fil-ph */
	{4228, 55},	 /* fo */
	{18309, 164},	 /* fo-fo */
	{2911, 12},	 /* fr */
	{18315, 221},	 /* fr-be */
	{18321, 247},	 /* fr-ca */
	{18327, 279},	 /* fr-cd */
	{18333, 254},	 /* fr-ch */
	{18339, 295},	 /* fr-ci */
	{18345, 290},	 /* fr-cm */
	{18351, 121},	 /* fr-fr */
	{18357, 307},	 /* fr-ht */
	{18363, 261},	 /* fr-lu */
	{18369, 303},	 /* fr-ma */
	{18375, 266},	 /* fr-mc */
	{18381, 300},	 /* fr-ml */
	{18387, 275},	 /* fr-re */
	{18393, 285},	 /* fr-sn */
	{5412, 90},	 /* fy */
	{18399, 195},	 /* fy-nl */
	{4360, 59},	 /* ga */
	{18405, 234},	 /* ga-ie */
	{6009, 110},	 /* gd */
	{18411, 214},	 /* gd-gb */
	{5167, 83},	 /* gl */
	{18417, 190},	 /* gl-es */
	{5914, 107},	 /* gsw */
	{18423, 211},	 /* gsw-fr */
	{4675, 69},	 /* gu */
	{18430, 176},	 /* gu-in */
	{5518, 94},	 /* ha */
	{18436, 340},	 /* ha-latn */
	{18444, 198},	 /* ha-latn-ng */
	{5757, 102},	 /* haw */
	{18455, 206},	 /* haw-us */
	{2939, 13},	 /* he */
	{18462, 122},	 /* he-il */
	{4257, 56},	 /* hi */
	{18468, 165},	 /* hi-in */
	{3321, 26},	 /* hr */
	{18474, 255},	 /* hr-ba */
	{18480, 135},	 /* hr-hr */
	{3944, 46},	 /* hsb */
	{18486, 155},	 /* hsb-de */
	{2968, 14},	 /* hu */
	{18493, 123},	 /* hu-hu */
	{3848, 43},	 /* hy */
	{18499, 152},	 /* hy-am */
	{3512, 33},	 /* id */
	{18505, 142},	 /* id-id */
	{5684, 99},	 /* ig */
	{18511, 203},	 /* ig-ng */
	{5819, 104},	 /* ii */
	{18517, 208},	 /* ii-cn */
	{2996, 15},	 /* is */
	{18523, 124},	 /* is-is */
	{3027, 16},	 /* it */
	{18529, 222},	 /* it-ch */
	{18535, 125},	 /* it-it */
	{3055, 17},	 /* ja */
	{18541, 126},	 /* ja-jp */
	{4186, 54},	 /* ka */
	{18547, 163},	 /* ka-ge */
	{4416, 61},	 /* kk */
	{18553, 169},	 /* kk-kz */
	{5649, 98},	 /* kl */
	{18559, 202},	 /* kl-gl */
	{5071, 80},	 /* km */
	{18565, 187},	 /* km-kh */
	{1715, 73},	 /* kn */
	{18571, 180},	 /* kn-in */
	{3085, 18},	 /* ko */
	{18577, 127},	 /* ko-kr */
	{5194, 84},	 /* kok */
	{18583, 191},	 /* kok-in */
	{4454, 62},	 /* ky */
	{18590, 170},	 /* ky-kg */
	{5608, 97},	 /* lb */
	{18596, 201},	 /* lb-lu */
	{5104, 81},	 /* lo */
	{18602, 188},	 /* lo-la */
	{3719, 39},	 /* lt */
	{18608, 148},	 /* lt-lt */
	{3690, 38},	 /* lv */
	{18614, 147},	 /* lv-lv */
	{3984, 47},	 /* mk */
	{18620, 156},	 /* mk-mk */
	{4851, 74},	 /* ml */
	{18626, 181},	 /* ml-in */
	{4968, 77},	 /* mn */
	{18632, 330},	 /* mn-cyrl */
	{18640, 184},	 /* mn-mn */
	{4933, 76},	 /* mr */
	{18646, 183},	 /* mr-in */
	{4385, 60},	 /* ms */
	{18652, 235},	 /* ms-bn */
	{18658, 168},	 /* ms-my */
	{4293, 57},	 /* mt */
	{18664, 166},	 /* mt-mt */
	{5129, 82},	 /* my */
	{18670, 189},	 /* my-mm */
	{3168, 333},	 /* nb */
	{18676, 129},	 /* nb-no */
	{5375, 89},	 /* ne */
	{18682, 240},	 /* ne-in */
	{18688, 194},	 /* ne-np */
	{3113, 19},	 /* nl */
	{18694, 223},	 /* nl-be */
	{18700, 128},	 /* nl-nl */
	{12103, 326},	 /* nn */
	{18706, 224},	 /* nn-no */
	{3141, 20},	 /* no */
	{5568, 96},	 /* nso */
	{18712, 200},	 /* nso-za */
	{5700, 100},	 /* om */
	{18719, 204},	 /* om-et */
	{4717, 70},	 /* or */
	{18725, 177},	 /* or-in */
	{4637, 68},	 /* pa */
	{18731, 338},	 /* pa-arab */
	{18739, 238},	 /* pa-arab-pk */
	{3171, 21},	 /* pl */
	{18750, 130},	 /* pl-pl */
	{5450, 91},	 /* ps */
	{18756, 196},	 /* ps-af */
	{3196, 22},	 /* pt */
	{18762, 131},	 /* pt-br */
	{18768, 225},	 /* pt-pt */
	{3229, 23},	 /* rm */
	{18774, 132},	 /* rm-ch */
	{3258, 24},	 /* ro */
	{18780, 226},	 /* ro-md */
	{18786, 133},	 /* ro-ro */
	{3287, 25},	 /* ru */
	{18792, 227},	 /* ru-md */
	{18798, 134},	 /* ru-ru */
	{5986, 109},	 /* rw */
	{18804, 213},	 /* rw-rw */
	{5954, 108},	 /* sah */
	{18810, 212},	 /* sah-ru */
	{4318, 58},	 /* se */
	{18817, 248},	 /* se-fi */
	{18823, 167},	 /* se-no */
	{18829, 233},	 /* se-se */
	{5229, 85},	 /* si */
	{18835, 192},	 /* si-lk */
	{3350, 27},	 /* sk */
	{18841, 136},	 /* sk-sk */
	{3629, 36},	 /* sl */
	{18847, 145},	 /* sl-si */
	{15332, 323},	 /* smn */
	{18853, 281},	 /* smn-fi */
	{5792, 103},	 /* so */
	{18860, 207},	 /* so-so */
	{3380, 28},	 /* sq */
	{18866, 137},	 /* sq-al */
	{14558, 334},	 /* sr */
	{18872, 321},	 /* sr-cyrl */
	{18880, 271},	 /* sr-cyrl-ba */
	{18891, 296},	 /* sr-cyrl-me */
	{18902, 286},	 /* sr-cyrl-rs */
	{18913, 322},	 /* sr-latn */
	{18921, 267},	 /* sr-latn-ba */
	{18932, 291},	 /* sr-latn-me */
	{18943, 280},	 /* sr-latn-rs */
	{4027, 48},	 /* st */
	{18954, 157},	 /* st-za */
	{3406, 29},	 /* sv */
	{18960, 228},	 /* sv-fi */
	{18966, 138},	 /* sv-se */
	{4489, 63},	 /* sw */
	{18972, 171},	 /* sw-ke */
	{4749, 71},	 /* ta */
	{18978, 178},	 /* ta-in */
	{18984, 239},	 /* ta-lk */
	{4782, 72},	 /* te */
	{18990, 179},	 /* te-in */
	{3751, 40},	 /* tg */
	{18996, 335},	 /* tg-cyrl */
	{19004, 149},	 /* tg-cyrl-tj */
	{3433, 30},	 /* th */
	{19015, 139},	 /* th-th */
	{5724, 101},	 /* ti */
	{19021, 241},	 /* ti-er */
	{19027, 205},	 /* ti-et */
	{4518, 64},	 /* tk */
	{19033, 172},	 /* tk-tm */
	{4088, 50},	 /* tn */
	{19039, 232},	 /* tn-bw */
	{19045, 159},	 /* tn-za */
	{3459, 31},	 /* tr */
	{19051, 140},	 /* tr-tr */
	{4061, 49},	 /* ts */
	{19057, 158},	 /* ts-za */
	{4575, 66},	 /* tt */
	{19063, 174},	 /* tt-ru */
	{5320, 88},	 /* tzm */
	{19069, 339},	 /* tzm-latn */
	{5879, 106},	 /* ug */
	{19078, 210},	 /* ug-cn */
	{3544, 34},	 /* uk */
	{19084, 143},	 /* uk-ua */
	{3487, 32},	 /* ur */
	{19090, 229},	 /* ur-in */
	{19096, 141},	 /* ur-pk */
	{4549, 65},	 /* uz */
	{19102, 329},	 /* uz-cyrl */
	{19110, 236},	 /* uz-cyrl-uz */
	{19121, 337},	 /* uz-latn */
	{19129, 173},	 /* uz-latn-uz */
	{3811, 42},	 /* vi */
	{19140, 151},	 /* vi-vn */
	{4115, 51},	 /* xh */
	{19146, 160},	 /* xh-za */
	{5535, 95},	 /* yo */
	{19152, 199},	 /* yo-ng */
	{2690, 325},	 /* zh */
	{19158, 4},	 /* zh-chs */
	{19165, 332},	 /* zh-cht */
	{19172, 217},	 /* zh-cn */
	{19178, 3},	 /* zh-hans */
	{19186, 331},	 /* zh-hant */
	{19194, 243},	 /* zh-hk */
	{19200, 257},	 /* zh-mo */
	{19206, 250},	 /* zh-sg */
	{19212, 114},	 /* zh-tw */
	{4141, 52},	 /* zu */
	{19218, 161}	 /* zu-za */
};


static const RegionInfoEntry region_entries [] = {
	{ 224,16385,13103,13103,19224,19245,2487,19292,19296,19324},
	{ 3,10707,19348,19348,19352,19364,2158,19383,19387,19402},
	{ 6,7412,19415,19415,19419,19427,1718,19437,19441,19454},
	{ 7,49,14317,14317,19468,19476,1856,19493,19497,19511},
	{ 11,15712,13873,13873,19537,19537,1462,15385,19547,19562},
	{ 14,13252,19577,19577,19581,19589,1357,19601,19605,19605},
	{ 12,13285,19610,19610,19614,19614,1462,19624,19628,19628},
	{ 5,8303,3910,3910,19646,19657,2221,19669,19673,19691},
	{ 25,13815,19711,19711,19715,19736,2341,19756,19760,19796},
	{ 23,12787,19816,19816,19820,19831,2304,19856,19860,19877},
	{ 21,11944,3621,3621,19918,19926,1357,19601,19605,19935},
	{ 35,6203,2611,2611,19940,19949,1339,19966,19970,19984},
	{ 17,16542,20010,20010,20014,20022,2501,20037,20041,20056},
	{ 37,12667,20080,20080,20084,20084,1462,20091,20095,20109},
	{ 26,16809,20122,20122,20126,20126,2527,5038,20134,20153},
	{ 32,7116,20163,20163,20167,20174,1606,20181,20185,20200},
	{ 19,12514,20216,20216,20220,0,2262,20229,20233,0},
	{ 29,7791,20248,20248,20252,20260,1766,20277,20281,20298},
	{ 24,15419,20330,20330,20334,20334,1462,20341,20345,20345},
	{ 39,13378,20359,20359,20363,20363,1462,20370,20374,20390},
	{ 44,15203,20406,20406,20410,20427,2420,20442,20446,20462},
	{ 223,314,20478,20478,20482,20494,1613,1613,20501,20513},
	{ 119,16051,20527,20527,20531,20531,2448,20548,20552,20575},
	{ 46,16234,20593,20593,20597,20597,1462,20603,20607,20620},
	{ 49,15764,20633,20633,20637,20646,2462,20655,20659,20685},
	{ 45,10050,20702,20702,20706,20712,1378,20731,20735,20748},
	{ 51,15137,20767,20767,20771,20771,1462,20780,20784,20799},
	{ 54,14117,20815,20815,20819,20819,2359,20830,20834,20853},
	{ 56,17194,20874,20874,20878,20878,1462,20883,20887,20898},
	{ 75,6359,20910,20910,20914,20929,1381,20947,20951,20973},
	{ 94,6449,2797,2797,20988,20996,1357,19601,19605,19605},
	{ 61,6401,21008,21008,21012,21020,1409,21028,21032,21045},
	{ 65,14722,21057,21057,21061,21080,2387,21102,21106,21121},
	{ 4,13877,21137,21137,21141,21149,2344,21164,21168,21183},
	{ 66,15983,21207,21207,21211,21211,1462,21219,21223,21233},
	{ 70,7889,17149,17149,21255,21263,1357,19601,19605,19935},
	{ 67,13107,21269,21269,21273,21279,2315,21286,21290,21305},
	{ 71,13055,21323,21323,21327,21335,2169,21348,21352,0},
	{ 217,6246,2878,2878,21367,21373,1357,19601,19605,19935},
	{ 73,10527,21381,21381,21385,21394,2144,21410,21414,21429},
	{ 77,6579,2903,2903,21455,21463,1357,19601,19605,19935},
	{ 81,8843,16479,16479,21469,21483,1724,21028,21032,21492},
	{ 84,6623,2931,2931,21505,21505,1357,19601,19605,19935},
	{ 242,10109,21512,21512,21516,21531,2037,21548,21552,21566},
	{ 88,8789,21579,21579,21583,21591,1894,21622,21626,21640},
	{ 93,11051,21675,21675,21679,21689,1409,21028,21032,21706},
	{ 98,6505,21726,21726,21730,21737,1357,19601,19605,21750},
	{ 99,13689,21759,21759,21763,21763,2339,21773,21777,21796},
	{ 104,13200,21804,21804,21808,21828,2325,21856,21860,21877},
	{ 106,16978,21884,21884,21888,21888,2260,21897,21901,21918},
	{ 108,7315,3342,3342,21937,21945,2217,2217,21954,21968},
	{ 103,16681,21982,21982,21986,21992,2515,21999,22003,22018},
	{ 109,6724,2988,2988,22036,22044,1520,22058,22062,22079},
	{ 111,7654,22093,22093,3526,3526,1759,22097,22101,22119},
	{ 68,12616,22136,22136,22140,22148,1357,19601,19605,19605},
	{ 117,6672,22154,22154,22158,22165,1511,22176,22180,22199},
	{ 113,8900,3536,3536,22213,22219,1939,22232,22236,22249},
	{ 121,11719,22284,22284,22288,22293,2248,22306,22310,22322},
	{ 116,8114,22344,22344,22348,22353,1843,22364,22368,22381},
	{ 110,6773,3019,3019,22401,22409,1523,1523,22417,22434},
	{ 118,6816,3047,3047,22450,22456,1357,19601,19605,19935},
	{ 124,14864,22463,22463,22467,22467,1462,22475,22479,22479},
	{ 126,15617,22495,22495,22499,22506,2452,22519,22523,22539},
	{ 122,6861,3077,3077,22561,22567,1537,22574,22578,22591},
	{ 129,9226,22601,22601,22605,22605,1991,22611,22615,22631},
	{ 130,9183,22649,22649,22653,22664,1967,22685,22689,22704},
	{ 40,10175,5096,5096,22734,22743,2040,22765,22769,22784},
	{ 134,6916,3105,3105,22818,22830,1541,22843,22847,22864},
	{ 136,16156,22881,22881,22885,22892,2477,22905,22909,22923},
	{ 137,9114,22945,22945,22949,22960,1946,22979,22983,23001},
	{ 138,10217,5121,5121,23035,5111,2044,23040,23044,23056},
	{ 139,15901,23076,23076,23080,23088,2467,23099,23103,23118},
	{ 145,14026,23140,23140,23144,23144,1613,1613,20501,23158},
	{ 42,10468,23176,23176,23180,23190,2136,23222,23226,23243},
	{ 141,7987,23291,23291,23295,23305,1357,19601,19605,23313},
	{ 147,10987,23319,23319,23323,23334,1357,19601,19605,19605},
	{ 140,7935,23346,23346,23350,23357,1357,19601,19605,23365},
	{ 148,13494,23370,23370,23374,23380,2329,23391,23395,23408},
	{ 159,14321,4960,4960,23428,23436,2363,2497,23449,23465},
	{ 158,14446,23485,23485,23489,23489,1357,19601,19605,19935},
	{ 152,12217,23496,23496,23500,23508,2260,23526,23530,23543},
	{ 270,15843,23559,23559,23563,23574,1357,19601,19605,23592},
	{ 19618,8478,23597,23597,23601,23611,1885,23597,23632,23649},
	{ 157,16278,23681,23681,23685,23685,2448,20548,20552,20575},
	{ 27,10292,23690,23690,23694,5140,2094,23710,23714,23727},
	{ 154,9979,23758,23758,23762,23771,2231,23784,23788,23805},
	{ 151,13966,23818,23818,23822,23838,2354,23866,23870,23886},
	{ 163,8939,4310,4310,23896,23896,1357,19601,19605,23902},
	{ 166,11893,23907,23907,23911,23918,1462,23926,23930,23943},
	{ 167,9044,23957,23957,23961,23961,1943,23970,23974,23992},
	{ 175,10815,24009,24009,24013,24021,2165,24030,24034,24049},
	{ 182,17032,24055,24055,24059,24059,2530,24069,24073,24093},
	{ 176,6968,3133,3133,24116,24128,1357,19601,19605,19605},
	{ 177,7026,3160,3160,24138,24145,1724,24151,24155,24171},
	{ 178,10588,24185,24185,24189,24195,2235,24211,24215,24230},
	{ 183,14061,24271,24271,24275,24275,1462,24287,24291,24291},
	{ 164,14833,24310,24310,24314,24319,2396,24330,24334,24345},
	{ 192,14398,4667,4667,24365,24372,2373,24380,24384,24402},
	{ 187,15464,24419,24419,24423,24428,2445,24434,24438,24451},
	{ 201,10761,24469,24469,24473,24485,2161,24495,24499,24515},
	{ 190,7600,24533,24533,24537,24546,1748,24561,24565,24581},
	{ 191,7067,24609,24609,24613,24620,1564,24627,24631,24644},
	{ 202,17090,24658,24658,24662,24662,1462,21219,21223,21233},
	{ 193,12156,24674,24674,24678,24678,1357,19601,19605,19605},
	{ 185,16634,24687,24687,24691,24691,2511,24700,24704,24723},
	{ 197,16733,24742,24742,24746,24752,2517,24759,24763,24775},
	{ 198,14973,24793,24793,24797,24806,1357,19601,19605,19935},
	{ 200,7211,24818,24818,24822,24830,1635,1635,24839,24852},
	{ 271,15273,17578,17578,24866,24873,2423,2423,24886,24900},
	{ 203,7267,3313,3313,24913,24920,1639,24933,24937,24951},
	{ 204,11587,24983,24983,24987,24987,2204,24994,24998,0},
	{ 205,311,25012,25012,25016,25029,1280,25076,25080,25092},
	{ 221,7456,25112,25112,25116,25123,1724,25131,25135,25149},
	{ 215,13558,25162,25162,25166,25176,1462,25186,25190,25207},
	{ 212,7847,25220,25220,25224,25233,1357,19601,19605,25243},
	{ 143,7366,25248,25248,25252,25261,1357,19601,19605,19935},
	{ 210,15516,25271,25271,25275,25283,2448,20548,20552,20575},
	{ 216,11299,5811,5811,25293,25301,2173,25312,25316,25332},
	{ 72,16896,3656,3656,25348,25348,1462,21219,21223,21233},
	{ 222,15389,25360,25360,25364,25370,2435,25381,25385,25398},
	{ 227,7503,3451,3451,25418,3441,1740,1740,25427,25437},
	{ 228,8066,25456,25456,25460,25471,1967,25492,25496,25515},
	{ 238,9286,25528,25528,25532,25545,1995,1995,25559,25579},
	{ 234,14614,25595,25595,25599,25607,2377,25616,25620,25635},
	{ 235,7549,25657,25657,25661,25668,1744,25677,25681,25694},
	{ 225,15658,25708,25708,25712,25712,1462,25730,25734,25734},
	{ 237,6297,25759,25759,25763,25770,1462,25777,25781,25799},
	{ 241,7721,3578,3578,25809,25817,1762,25832,25836,25854},
	{ 244,6538,25888,25888,25892,25892,1462,21219,21223,21223},
	{ 246,16435,25906,25906,25910,25910,1462,25918,25922,25937},
	{ 247,9350,4567,4567,25951,25962,2225,25975,25979,25995},
	{ 249,14918,26017,26017,26021,26021,2406,26031,26035,26055},
	{ 251,8172,26075,26075,26079,26087,1852,26098,26102,26118},
	{ 261,15085,26137,26137,26141,26147,2410,26158,26162,26174},
	{ 209,8517,26192,26192,26196,0,1892,26209,26213,0},
	{ 264,15933,26232,26232,26236,26236,1462,21219,21223,21223}
};


static const RegionInfoNameEntry region_name_entries [] = {
	{16385, 0},	 /* AE */
	{10707, 1},	 /* AF */
	{7412, 2},	 /* AL */
	{49, 3},	 /* AM */
	{15712, 4},	 /* AR */
	{13252, 5},	 /* AT */
	{13285, 6},	 /* AU */
	{8303, 7},	 /* AZ */
	{13815, 8},	 /* BA */
	{12787, 9},	 /* BD */
	{11944, 10},	 /* BE */
	{6203, 11},	 /* BG */
	{16542, 12},	 /* BH */
	{12667, 13},	 /* BN */
	{16809, 14},	 /* BO */
	{7116, 15},	 /* BR */
	{12514, 16},	 /* BW */
	{7791, 17},	 /* BY */
	{15419, 18},	 /* BZ */
	{13378, 19},	 /* CA */
	{15203, 20},	 /* CD */
	{314, 21},	 /* CH */
	{16051, 22},	 /* CI */
	{16234, 23},	 /* CL */
	{15764, 24},	 /* CM */
	{10050, 25},	 /* CN */
	{15137, 26},	 /* CO */
	{14117, 27},	 /* CR */
	{17194, 28},	 /* CU */
	{6359, 29},	 /* CZ */
	{6449, 30},	 /* DE */
	{6401, 31},	 /* DK */
	{14722, 32},	 /* DO */
	{13877, 33},	 /* DZ */
	{15983, 34},	 /* EC */
	{7889, 35},	 /* EE */
	{13107, 36},	 /* EG */
	{13055, 37},	 /* ER */
	{6246, 38},	 /* ES */
	{10527, 39},	 /* ET */
	{6579, 40},	 /* FI */
	{8843, 41},	 /* FO */
	{6623, 42},	 /* FR */
	{10109, 43},	 /* GB */
	{8789, 44},	 /* GE */
	{11051, 45},	 /* GL */
	{6505, 46},	 /* GR */
	{13689, 47},	 /* GT */
	{13200, 48},	 /* HK */
	{16978, 49},	 /* HN */
	{7315, 50},	 /* HR */
	{16681, 51},	 /* HT */
	{6724, 52},	 /* HU */
	{7654, 53},	 /* ID */
	{12616, 54},	 /* IE */
	{6672, 55},	 /* IL */
	{8900, 56},	 /* IN */
	{11719, 57},	 /* IQ */
	{8114, 58},	 /* IR */
	{6773, 59},	 /* IS */
	{6816, 60},	 /* IT */
	{14864, 61},	 /* JM */
	{15617, 62},	 /* JO */
	{6861, 63},	 /* JP */
	{9226, 64},	 /* KE */
	{9183, 65},	 /* KG */
	{10175, 66},	 /* KH */
	{6916, 67},	 /* KR */
	{16156, 68},	 /* KW */
	{9114, 69},	 /* KZ */
	{10217, 70},	 /* LA */
	{15901, 71},	 /* LB */
	{14026, 72},	 /* LI */
	{10468, 73},	 /* LK */
	{7987, 74},	 /* LT */
	{10987, 75},	 /* LU */
	{7935, 76},	 /* LV */
	{13494, 77},	 /* LY */
	{14321, 78},	 /* MA */
	{14446, 79},	 /* MC */
	{12217, 80},	 /* MD */
	{15843, 81},	 /* ME */
	{8478, 82},	 /* MK */
	{16278, 83},	 /* ML */
	{10292, 84},	 /* MM */
	{9979, 85},	 /* MN */
	{13966, 86},	 /* MO */
	{8939, 87},	 /* MT */
	{11893, 88},	 /* MX */
	{9044, 89},	 /* MY */
	{10815, 90},	 /* NG */
	{17032, 91},	 /* NI */
	{6968, 92},	 /* NL */
	{7026, 93},	 /* NO */
	{10588, 94},	 /* NP */
	{14061, 95},	 /* NZ */
	{14833, 96},	 /* OM */
	{14398, 97},	 /* PA */
	{15464, 98},	 /* PE */
	{10761, 99},	 /* PH */
	{7600, 100},	 /* PK */
	{7067, 101},	 /* PL */
	{17090, 102},	 /* PR */
	{12156, 103},	 /* PT */
	{16634, 104},	 /* PY */
	{16733, 105},	 /* QA */
	{14973, 106},	 /* RE */
	{7211, 107},	 /* RO */
	{15273, 108},	 /* RS */
	{7267, 109},	 /* RU */
	{11587, 110},	 /* RW */
	{311, 111},	 /* SA */
	{7456, 112},	 /* SE */
	{13558, 113},	 /* SG */
	{7847, 114},	 /* SI */
	{7366, 115},	 /* SK */
	{15516, 116},	 /* SN */
	{11299, 117},	 /* SO */
	{16896, 118},	 /* SV */
	{15389, 119},	 /* SY */
	{7503, 120},	 /* TH */
	{8066, 121},	 /* TJ */
	{9286, 122},	 /* TM */
	{14614, 123},	 /* TN */
	{7549, 124},	 /* TR */
	{15658, 125},	 /* TT */
	{6297, 126},	 /* TW */
	{7721, 127},	 /* UA */
	{6538, 128},	 /* US */
	{16435, 129},	 /* UY */
	{9350, 130},	 /* UZ */
	{14918, 131},	 /* VE */
	{8172, 132},	 /* VN */
	{15085, 133},	 /* YE */
	{8517, 134},	 /* ZA */
	{15933, 135}	 /* ZW */
};


static const char locale_strings [] = {
	"\0"
	"/\0"
	":\0"
	"am\0"
	"pm\0"
	".\0"
	"a. m.\0"
	"p. m.\0"
	"\xe4\xb8\x8a\xe5\x8d\x88\0"
	"\xe4\xb8\x8b\xe5\x8d\x88\0"
	"dop.\0"
	"odp.\0"
	"AM\0"
	"PM\0"
	"-\0"
	"vorm.\0"
	"nachm.\0"
	"\xcf\x80.\xce\xbc.\0"
	"\xce\xbc.\xce\xbc.\0"
	"ap.\0"
	"ip.\0"
	"\xd7\x9c\xd7\xa4\xd7\xa0\xd7\x94\xd7\xb4\xd7\xa6\0"
	"\xd7\x90\xd7\x97\xd7\x94\xd7\xb4\xd7\xa6\0"
	"de.\0"
	"du.\0"
	". \0"
	"f.h.\0"
	"e.h.\0"
	"\xe5\x8d\x88\xe5\x89\x8d\0"
	"\xe5\x8d\x88\xe5\xbe\x8c\0"
	"\xec\x98\xa4\xec\xa0\x84\0"
	"\xec\x98\xa4\xed\x9b\x84\0"
	"a.m.\0"
	"p.m.\0"
	"\xd0\x94\xd0\x9f\0"
	"\xd0\x9f\xd0\x9f\0"
	"e paradites\0"
	"e pasdites\0"
	"fm\0"
	"em\0"
	"\xc3\x96\xc3\x96\0"
	"\xc3\x96S\0"
	"\xd0\xb4\xd0\xbf\0"
	"\xd0\xbf\xd0\xbf\0"
	"pop.\0"
	"priek\xc5\xa1p.\0"
	"p\xc4\x93\x63p.\0"
	"prie\xc5\xa1piet\0"
	"popiet\0"
	"\xd0\xbf\xd0\xb5. \xd1\x87\xd0\xbe.\0"
	"\xd0\xbf\xd0\xb0. \xd1\x87\xd0\xbe.\0"
	"\xd9\x82.\xd8\xb8.\0"
	"\xd8\xa8.\xd8\xb8.\0"
	"SA\0"
	"CH\0"
	"\xd4\xbf\xd4\xb1\0"
	"\xd4\xbf\xd5\x80\0"
	"dopo\xc5\x82\x64nja\0"
	"popo\xc5\x82\x64nju\0"
	"\xd0\xbf\xd1\x80\xd0\xb5\xd1\x82\xd0\xbf\xd0\xbb.\0"
	"\xd0\xbf\xd0\xbe\xd0\xbf\xd0\xbb.\0"
	"vm.\0"
	"nm.\0"
	"\xe0\xa4\xaa\xe0\xa5\x82\xe0\xa4\xb0\xe0\xa5\x8d\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb9\xe0\xa5\x8d\xe0\xa4\xa8\0"
	"\xe0\xa4\x85\xe0\xa4\xaa\xe0\xa4\xb0\xe0\xa4\xbe\xe0\xa4\xb9\xe0\xa5\x8d\xe0\xa4\xa8\0"
	"i.b.\0"
	"e.b.\0"
	"PG\0"
	"PTG\0"
	"\xd1\x82\xd2\xa3\0"
	"\xd1\x82\xd0\xba\0"
	"TO\0"
	"TK\0"
	"\xe0\xa8\xaa\xe0\xa9\x82.\xe0\xa8\xa6\xe0\xa9\x81.\0"
	"\xe0\xa8\xac\xe0\xa8\xbe.\xe0\xa8\xa6\xe0\xa9\x81.\0"
	"\xe0\xae\xae\xe0\xaf\x81\xe0\xae\xb1\xe0\xaf\x8d\xe0\xae\xaa\xe0\xae\x95\xe0\xae\xb2\xe0\xaf\x8d\0"
	"\xe0\xae\xaa\xe0\xae\xbf\xe0\xae\xb1\xe0\xaf\x8d\xe0\xae\xaa\xe0\xae\x95\xe0\xae\xb2\xe0\xaf\x8d\0"
	"\xe0\xb2\xaa\xe0\xb3\x82\xe0\xb2\xb0\xe0\xb3\x8d\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb9\xe0\xb3\x8d\xe0\xb2\xa8\0"
	"\xe0\xb2\x85\xe0\xb2\xaa\xe0\xb2\xb0\xe0\xb2\xbe\xe0\xb2\xb9\xe0\xb3\x8d\xe0\xb2\xa8\0"
	"\xe0\xa6\xaa\xe0\xa7\x82\xe0\xa7\xb0\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb9\xe0\xa7\x8d\xe0\xa6\xa3\0"
	"\xe0\xa6\x85\xe0\xa6\xaa\xe0\xa7\xb0\xe0\xa6\xbe\xe0\xa6\xb9\xe0\xa7\x8d\xe0\xa6\xa3\0"
	"\xe0\xa4\xae.\xe0\xa4\xaa\xe0\xa5\x82.\0"
	"\xe0\xa4\xae.\xe0\xa4\x89.\0"
	"\xd2\xae\xd3\xa8\0"
	"\xd2\xae\xd0\xa5\0"
	"\xe0\xbd\xa6\xe0\xbe\x94\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbe\xb2\xe0\xbd\xbc\xe0\xbc\x8b\0"
	"\xe0\xbd\x95\xe0\xbe\xb1\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbe\xb2\xe0\xbd\xbc\xe0\xbc\x8b\0"
	"yb\0"
	"yh\0"
	"\xe0\xba\x81\xe0\xbb\x88\xe0\xba\xad\xe0\xba\x99\xe0\xba\x97\xe0\xbb\x88\xe0\xba\xbd\xe0\xba\x87\0"
	"\xe0\xba\xab\xe0\xba\xbc\xe0\xba\xb1\xe0\xba\x87\xe0\xba\x97\xe0\xbb\x88\xe0\xba\xbd\xe0\xba\x87\0"
	"\xe1\x80\x94\xe1\x80\xb6\xe1\x80\x94\xe1\x80\x80\xe1\x80\xba\0"
	"\xe1\x80\x8a\xe1\x80\x94\xe1\x80\xb1\0"
	"\xe0\xa4\xae.\xe0\xa4\xa8\xe0\xa4\x82.\0"
	"\xe0\xb6\xb4\xe0\xb7\x99.\xe0\xb7\x80.\0"
	"\xe0\xb6\xb4.\xe0\xb7\x80.\0"
	"\xe1\x8f\x8c\xe1\x8e\xbe\xe1\x8e\xb4\0"
	"\xe1\x8f\x92\xe1\x8e\xaf\xe1\x8f\xb1\xe1\x8e\xa2\xe1\x8f\x97\xe1\x8f\xa2\0"
	"\xe1\x8c\xa5\xe1\x8b\x8b\xe1\x89\xb5\0"
	"\xe1\x8a\xa8\xe1\x88\xb0\xe1\x8b\x93\xe1\x89\xb5\0"
	"Zdat azal\0"
	"\xe1\xb8\x8c\x65\x66\x66ir aza\0"
	"subaka\0"
	"kikii\xc9\x97\x65\0"
	"\xc3\x80\xc3\xa1r\xe1\xbb\x8d\xcc\x80\0"
	"\xe1\xbb\x8c\xcc\x80s\xc3\xa1n\0"
	"moies\0"
	"nom\xc3\xabttes\0"
	"u.t.\0"
	"u.k.\0"
	"A.M.\0"
	"P.M.\0"
	"WD\0"
	"WB\0"
	"\xe1\x8a\x95\xe1\x8c\x89\xe1\x88\x86 \xe1\x88\xb0\xe1\x8b\x93\xe1\x89\xb0\0"
	"\xe1\x8b\xb5\xe1\x88\x95\xe1\x88\xad \xe1\x88\xb0\xe1\x8b\x93\xe1\x89\xb5\0"
	"sn.\0"
	"gn.\0"
	"\xea\x8e\xb8\xea\x84\x91\0"
	"\xea\x81\xaf\xea\x8b\x92\0"
	"G.M.\0"
	"\xda\x86.\xd8\xa8\0"
	"\xda\x86.\xd9\x83\0"
	"v.m.\0"
	"n.m.\0"
	"\xd0\xad\xd0\x98\0"
	"\xd0\xad\xd0\x9a\0"
	"m\0"
	"f\0"
	"\xd8\xb5\0"
	"\xd9\x85\0"
	"f.m.\0"
	"e.m.\0"
	"\xd0\x90\xd0\x9c\0"
	"\xd0\x9f\xd0\x9c\0"
	"w\xc3\xb3tpo\xc5\x82\x64nja\0"
	"\xd0\xa2\xd0\x9e\0"
	"\xd0\xa2\xd0\x9a\0"
	"prijepodne\0"
	"popodne\0"
	"prije podne\0"
	"po podne\0"
	"\xd0\xbf\xd1\x80\xd0\xb8\xd1\x98\xd0\xb5 \xd0\xbf\xd0\xbe\xd0\xb4\xd0\xbd\xd0\xb5\0"
	"\xd0\xbf\xd0\xbe \xd0\xbf\xd0\xbe\xd0\xb4\xd0\xbd\xd0\xb5\0"
	"\xd0\xbf\xd1\x80\xd0\xb5 \xd0\xbf\xd0\xbe\xd0\xb4\xd0\xbd\xd0\xb5\0"
	"\xd0\xbf\xd0\xbe\xd0\xbf\xd0\xbe\xd0\xb4\xd0\xbd\xd0\xb5\0"
	"pre podne\0"
	"ep.\0"
	"mat.\0"
	"soir\0"
	",\0"
	"\xd8\xb1.\xd8\xb3.\xe2\x80\x8f\0"
	"\xd9\xaa\xd8\x9c\0"
	"\xd9\x84\xd9\x8a\xd8\xb3\xc2\xa0\xd8\xb1\xd9\x82\xd9\x85\0"
	"\xd8\x89\0"
	"-Infinity\0"
	"Infinity\0"
	"\xd8\x9c+\0"
	"\xc2\xa0\0"
	"\xd0\xbb\xd0\xb2.\0"
	"%\0"
	"NaN\0"
	"\xe2\x80\xb0\0"
	"+\0"
	"\xe2\x82\xac\0"
	"-Infinit\0"
	"Infinit\0"
	"\xc2\xa5\0"
	"K\xc4\x8d\0"
	"-nekone\xc4\x8dno\0"
	"+nekone\xc4\x8dno\0"
	"kr.\0"
	"-unendlich\0"
	"+unendlich\0"
	"-\xce\x86\xcf\x80\xce\xb5\xce\xb9\xcf\x81\xce\xbf\0"
	"\xce\x86\xcf\x80\xce\xb5\xce\xb9\xcf\x81\xce\xbf\0"
	"$\0"
	"-Infinito\0"
	"Infinito\0"
	"ep\xc3\xa4luku\0"
	"\xd9\xaa\0"
	"-Infini\0"
	"+Infini\0"
	"\xe2\x82\xaa\0"
	"\xe2\x80\x8e+\0"
	"Ft\0"
	"ISK\0"
	"+Infinito\0"
	"\xef\xbf\xa5\0"
	"\xe2\x82\xa9\0"
	"-oneindig\0"
	"oneindig\0"
	"z\xc5\x82\0"
	"-niesko\xc5\x84\x63zono\xc5\x9b\xc4\x87\0"
	"+niesko\xc5\x84\x63zono\xc5\x9b\xc4\x87\0"
	"R$\0"
	"\xe2\x80\x99\0"
	"CHF\0"
	"-infinit\0"
	"+infinit\0"
	"RON\0"
	"\xe2\x82\xbd\0"
	"\xd0\xbd\xd0\xb5\xc2\xa0\xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xbe\0"
	"-\xd0\xb1\xd0\xb5\xd1\x81\xd0\xba\xd0\xbe\xd0\xbd\xd0\xb5\xd1\x87\xd0\xbd\xd0\xbe\xd1\x81\xd1\x82\xd1\x8c\0"
	"\xd0\xb1\xd0\xb5\xd1\x81\xd0\xba\xd0\xbe\xd0\xbd\xd0\xb5\xd1\x87\xd0\xbd\xd0\xbe\xd1\x81\xd1\x82\xd1\x8c\0"
	"kn\0"
	"Lek\xc3\xab\0"
	"kr\0"
	"\xc2\xa4\xc2\xa4\xc2\xa4\0"
	"\xd8\x89\xe2\x80\x8f\0"
	"THB\0"
	"\xe2\x82\xba\0"
	"Rs\0"
	"\xe2\x80\x8e+\xe2\x80\x8e\0"
	"Rp\0"
	"\xe2\x82\xb4\0"
	"Br\0"
	"-neskon\xc4\x8dnost\0"
	"neskon\xc4\x8dnost\0"
	"NS\0"
	"-bezgal\xc4\xab\x62\x61\0"
	"bezgal\xc4\xab\x62\x61\0"
	"-begalyb\xc4\x97\0"
	"begalyb\xc4\x97\0"
	"\xd8\xb1\xdb\x8c\xd8\xa7\xd9\x84\0"
	"\xe2\x82\xab\0"
	"\xd6\x8f\0"
	"\xd5\x88\xd5\xb9\xd4\xb9\0"
	"-Infinitu\0"
	"Infinitu\0"
	"\xd0\xb4\xd0\xb5\xd0\xbd\0"
	"R\0"
	"\xe2\x82\xbe\0"
	"\xe1\x83\x90\xe1\x83\xa0\xc2\xa0\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x98\xe1\x83\xa1\xc2\xa0\xe1\x83\xa0\xe1\x83\x98\xe1\x83\xaa\xe1\x83\xae\xe1\x83\x95\xe1\x83\x98\0"
	"\xe2\x82\xb9\0"
	"RM\0"
	"\xe2\x82\xb8\0"
	"\xd1\x81\xd0\xb0\xd0\xbd\xc2\xa0\xd0\xb5\xd0\xbc\xd0\xb5\xd1\x81\0"
	"\xd1\x81\xd0\xbe\xd0\xbc\0"
	"\xd1\x81\xd0\xb0\xd0\xbd\xc2\xa0\xd1\x8d\xd0\xbc\xd0\xb5\xd1\x81\0"
	"Ksh\0"
	"TMT\0"
	"san\xc2\xa0\x64\xc3\xa4l\0"
	"haqiqiy\xc2\xa0son\xc2\xa0\x65mas\0"
	"\xe0\xa6\x9f\xe0\xa6\xbe\0"
	"`\0"
	"\xc2\xa3\0"
	"\xe1\x9f\x9b\0"
	"\xe2\x82\xad\0"
	"\xe0\xba\x9a\xe0\xbb\x8d\xe0\xbb\x88\xe2\x80\x8b\xe0\xbb\x81\xe0\xba\xa1\xe0\xbb\x88\xe0\xba\x99\xe2\x80\x8b\xe0\xbb\x82\xe0\xba\x95\xe2\x80\x8b\xe0\xbb\x80\xe0\xba\xa5\xe0\xba\x81\0"
	"K\0"
	"\xe1\x80\x82\xe1\x80\x8f\xe1\x80\x94\xe1\x80\xba\xe1\x80\xb8\xe1\x80\x99\xe1\x80\x9f\xe1\x80\xaf\xe1\x80\x90\xe1\x80\xba\xe1\x80\x9e\xe1\x80\xb1\xe1\x80\xac\0"
	"\xe0\xb6\xbb\xe0\xb7\x94.\0"
	"\xe1\x89\xa5\xe1\x88\xad\0"
	"\xe0\xa4\xb0\xe0\xa5\x81\0"
	"\xd8\x8b\0"
	"\xe2\x82\xb1\0"
	"\xe2\x82\xa6\0"
	"Nfk\0"
	"S\0"
	"\xd1\x87\xd1\x8b\xd1\x8b\xd2\xbb\xd1\x8b\xd0\xbb\xd0\xb0\xc2\xa0\xd0\xb1\xd1\x83\xd0\xbe\xd1\x82\xd0\xb0\xd1\x85\0"
	"RF\0"
	"\xe9\x9d\x9e\xe6\x95\xb8\xe5\x80\xbc\0"
	"HRK\0"
	"\xe2\x82\xbc\0"
	"so\xca\xbbm\0"
	"\xe2\x82\xae\0"
	"\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xb0\xe0\xa5\x82\0"
	"\xd8\xaf.\xd8\xb9.\xe2\x80\x8f\0"
	"'\0"
	"L\0"
	"P\0"
	"\xd1\x81\xd1\x9e\xd0\xbc\0"
	"\xd2\xb3\xd0\xb0\xd2\x9b\xd0\xb8\xd2\x9b\xd0\xb8\xd0\xb9\xc2\xa0\xd1\x81\xd0\xbe\xd0\xbd\xc2\xa0\xd1\x8d\xd0\xbc\xd0\xb0\xd1\x81\0"
	"\xe0\xa7\xb3\0"
	"\xd8\xb1\0"
	"Rs.\0"
	"\xd8\xac.\xd9\x85.\xe2\x80\x8f\0"
	"HK$\0"
	"\xd8\xaf.\xd9\x84.\xe2\x80\x8f\0"
	"Q\0"
	"KM\0"
	"\xd8\xaf.\xd8\xac.\xe2\x80\x8f\0"
	"MOP$\0"
	"\xe2\x82\xa1\0"
	"\xd8\xaf.\xd9\x85.\xe2\x80\x8f\0"
	"B/.\0"
	"\xd8\xaf.\xd8\xaa.\xe2\x80\x8f\0"
	"RD$\0"
	"\xd0\x9a\xd0\x9c\0"
	"\xd8\xb1.\xd8\xb9.\xe2\x80\x8f\0"
	"Bs.\0"
	"\xd8\xb1.\xd9\x8a.\xe2\x80\x8f\0"
	"FC\0"
	"RSD\0"
	"epiloho\0"
	"\xd9\x84.\xd8\xb3.\xe2\x80\x8f\0"
	"S/\0"
	"CFA\0"
	"\xd8\xaf.\xd8\xa3.\xe2\x80\x8f\0"
	"FCFA\0"
	"\xd9\x84.\xd9\x84.\xe2\x80\x8f\0"
	"\xd8\xaf.\xd9\x83.\xe2\x80\x8f\0"
	"\xd8\xaf.\xd8\xa5.\xe2\x80\x8f\0"
	"MAD\0"
	"\xd8\xaf.\xd8\xa8.\xe2\x80\x8f\0"
	"Gs.\0"
	"G\0"
	"\xd8\xb1.\xd9\x82.\xe2\x80\x8f\0"
	"Bs\0"
	"C$\0"
	"\xd0\x94\xd0\xb8\xd0\xbd.\0"
	"Din.\0"
	"ar\0"
	"Arabic\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9\0"
	"ARA\0"
	"ara\0"
	"bg\0"
	"Bulgarian\0"
	"\xd0\xb1\xd1\x8a\xd0\xbb\xd0\xb3\xd0\xb0\xd1\x80\xd1\x81\xd0\xba\xd0\xb8\0"
	"BGR\0"
	"bul\0"
	"ca\0"
	"Catalan\0"
	"catal\xc3\xa0\0"
	"CAT\0"
	"cat\0"
	"zh-Hans\0"
	"Chinese (Simplified)\0"
	"\xe4\xb8\xad\xe6\x96\x87\0"
	"CHS\0"
	"zho\0"
	"zh\0"
	"zh-CHS\0"
	"Chinese (Simplified) Legacy\0"
	"cs\0"
	"Czech\0"
	"\xc4\x8d\x65\xc5\xa1tina\0"
	"CSY\0"
	"ces\0"
	"da\0"
	"Danish\0"
	"dansk\0"
	"DAN\0"
	"dan\0"
	"de\0"
	"German\0"
	"Deutsch\0"
	"DEU\0"
	"deu\0"
	"el\0"
	"Greek\0"
	"\xce\x95\xce\xbb\xce\xbb\xce\xb7\xce\xbd\xce\xb9\xce\xba\xce\xac\0"
	"ELL\0"
	"ell\0"
	"en\0"
	"English\0"
	"ENU\0"
	"eng\0"
	"es\0"
	"Spanish\0"
	"espa\xc3\xb1ol\0"
	"ESP\0"
	"spa\0"
	"fi\0"
	"Finnish\0"
	"suomi\0"
	"FIN\0"
	"fin\0"
	"fr\0"
	"French\0"
	"fran\xc3\xa7\x61is\0"
	"FRA\0"
	"fra\0"
	"he\0"
	"Hebrew\0"
	"\xd7\xa2\xd7\x91\xd7\xa8\xd7\x99\xd7\xaa\0"
	"HEB\0"
	"heb\0"
	"hu\0"
	"Hungarian\0"
	"magyar\0"
	"HUN\0"
	"hun\0"
	"is\0"
	"Icelandic\0"
	"\xc3\xadslenska\0"
	"ISL\0"
	"isl\0"
	"it\0"
	"Italian\0"
	"italiano\0"
	"ITA\0"
	"ita\0"
	"ja\0"
	"Japanese\0"
	"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e\0"
	"JPN\0"
	"jpn\0"
	"ko\0"
	"Korean\0"
	"\xed\x95\x9c\xea\xb5\xad\xec\x96\xb4\0"
	"KOR\0"
	"kor\0"
	"nl\0"
	"Dutch\0"
	"Nederlands\0"
	"NLD\0"
	"nld\0"
	"no\0"
	"Norwegian\0"
	"norsk\0"
	"NOR\0"
	"nob\0"
	"nb\0"
	"pl\0"
	"Polish\0"
	"polski\0"
	"PLK\0"
	"pol\0"
	"pt\0"
	"Portuguese\0"
	"portugu\xc3\xaas\0"
	"PTB\0"
	"por\0"
	"rm\0"
	"Romansh\0"
	"rumantsch\0"
	"RMC\0"
	"roh\0"
	"ro\0"
	"Romanian\0"
	"rom\xc3\xa2n\xc4\x83\0"
	"ROM\0"
	"ron\0"
	"ru\0"
	"Russian\0"
	"\xd1\x80\xd1\x83\xd1\x81\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9\0"
	"RUS\0"
	"rus\0"
	"hr\0"
	"Croatian\0"
	"hrvatski\0"
	"HRV\0"
	"hrv\0"
	"sk\0"
	"Slovak\0"
	"sloven\xc4\x8dina\0"
	"SKY\0"
	"slk\0"
	"sq\0"
	"Albanian\0"
	"shqip\0"
	"SQI\0"
	"sqi\0"
	"sv\0"
	"Swedish\0"
	"svenska\0"
	"SVE\0"
	"swe\0"
	"th\0"
	"Thai\0"
	"\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2\0"
	"THA\0"
	"tha\0"
	"tr\0"
	"Turkish\0"
	"T\xc3\xbcrk\xc3\xa7\x65\0"
	"TRK\0"
	"tur\0"
	"ur\0"
	"Urdu\0"
	"\xd8\xa7\xd8\xb1\xd8\xaf\xd9\x88\0"
	"URD\0"
	"urd\0"
	"id\0"
	"Indonesian\0"
	"Indonesia\0"
	"IND\0"
	"ind\0"
	"uk\0"
	"Ukrainian\0"
	"\xd1\x83\xd0\xba\xd1\x80\xd0\xb0\xd1\x97\xd0\xbd\xd1\x81\xd1\x8c\xd0\xba\xd0\xb0\0"
	"UKR\0"
	"ukr\0"
	"be\0"
	"Belarusian\0"
	"\xd0\xb1\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x80\xd1\x83\xd1\x81\xd0\xba\xd0\xb0\xd1\x8f\0"
	"BEL\0"
	"bel\0"
	"sl\0"
	"Slovenian\0"
	"sloven\xc5\xa1\xc4\x8dina\0"
	"SLV\0"
	"slv\0"
	"et\0"
	"Estonian\0"
	"eesti\0"
	"ETI\0"
	"est\0"
	"lv\0"
	"Latvian\0"
	"latvie\xc5\xa1u\0"
	"LVI\0"
	"lav\0"
	"lt\0"
	"Lithuanian\0"
	"lietuvi\xc5\xb3\0"
	"LTH\0"
	"lit\0"
	"tg\0"
	"Tajik\0"
	"\xd0\xa2\xd0\xbe\xd2\xb7\xd0\xb8\xd0\xba\xd3\xa3\0"
	"TAJ\0"
	"tgk\0"
	"fa\0"
	"Persian\0"
	"\xd9\x81\xd8\xa7\xd8\xb1\xd8\xb3\xdb\x8c\0"
	"FAR\0"
	"fas\0"
	"vi\0"
	"Vietnamese\0"
	"Ti\xe1\xba\xbfng Vi\xe1\xbb\x87t\0"
	"VIT\0"
	"vie\0"
	"hy\0"
	"Armenian\0"
	"\xd5\xb0\xd5\xa1\xd5\xb5\xd5\xa5\xd6\x80\xd5\xa5\xd5\xb6\0"
	"HYE\0"
	"hye\0"
	"az\0"
	"Azerbaijani\0"
	"az\xc9\x99rbaycan\0"
	"AZE\0"
	"aze\0"
	"eu\0"
	"Basque\0"
	"euskara\0"
	"EUQ\0"
	"eus\0"
	"hsb\0"
	"Upper Sorbian\0"
	"hornjoserb\xc5\xa1\xc4\x87ina\0"
	"HSB\0"
	"mk\0"
	"Macedonian\0"
	"\xd0\xbc\xd0\xb0\xd0\xba\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8\0"
	"MKI\0"
	"mkd\0"
	"st\0"
	"Southern Sotho\0"
	"Sesotho\0"
	"SOT\0"
	"sot\0"
	"ts\0"
	"Tsonga\0"
	"Xitsonga\0"
	"TSO\0"
	"tso\0"
	"tn\0"
	"Tswana\0"
	"Setswana\0"
	"TSN\0"
	"tsn\0"
	"xh\0"
	"Xhosa\0"
	"isiXhosa\0"
	"XHO\0"
	"xho\0"
	"zu\0"
	"Zulu\0"
	"isiZulu\0"
	"ZUL\0"
	"zul\0"
	"af\0"
	"Afrikaans\0"
	"AFK\0"
	"afr\0"
	"ka\0"
	"Georgian\0"
	"\xe1\x83\xa5\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x97\xe1\x83\xa3\xe1\x83\x9a\xe1\x83\x98\0"
	"KAT\0"
	"kat\0"
	"fo\0"
	"Faroese\0"
	"f\xc3\xb8royskt\0"
	"FOS\0"
	"fao\0"
	"hi\0"
	"Hindi\0"
	"\xe0\xa4\xb9\xe0\xa4\xbf\xe0\xa4\xa8\xe0\xa5\x8d\xe0\xa4\xa6\xe0\xa5\x80\0"
	"HIN\0"
	"hin\0"
	"mt\0"
	"Maltese\0"
	"Malti\0"
	"MLT\0"
	"mlt\0"
	"se\0"
	"Northern Sami\0"
	"davvis\xc3\xa1megiella\0"
	"SME\0"
	"sme\0"
	"ga\0"
	"Irish\0"
	"Gaeilge\0"
	"IRE\0"
	"gle\0"
	"ms\0"
	"Malay\0"
	"Bahasa Melayu\0"
	"MSL\0"
	"msa\0"
	"kk\0"
	"Kazakh\0"
	"\xd2\x9b\xd0\xb0\xd0\xb7\xd0\xb0\xd2\x9b \xd1\x82\xd1\x96\xd0\xbb\xd1\x96\0"
	"KKZ\0"
	"kaz\0"
	"ky\0"
	"Kyrgyz\0"
	"\xd0\xba\xd1\x8b\xd1\x80\xd0\xb3\xd1\x8b\xd0\xb7\xd1\x87\xd0\xb0\0"
	"KYR\0"
	"kir\0"
	"sw\0"
	"Swahili\0"
	"Kiswahili\0"
	"SWK\0"
	"swa\0"
	"tk\0"
	"Turkmen\0"
	"t\xc3\xbcrkmen\xc3\xa7\x65\0"
	"TUK\0"
	"tuk\0"
	"uz\0"
	"Uzbek\0"
	"o\xe2\x80\x98zbek\0"
	"UZB\0"
	"uzb\0"
	"tt\0"
	"Tatar\0"
	"\xd1\x82\xd0\xb0\xd1\x82\xd0\xb0\xd1\x80\0"
	"TTT\0"
	"tat\0"
	"bn\0"
	"Bangla\0"
	"\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe\0"
	"BNG\0"
	"ben\0"
	"pa\0"
	"Punjabi\0"
	"\xe0\xa8\xaa\xe0\xa9\xb0\xe0\xa8\x9c\xe0\xa8\xbe\xe0\xa8\xac\xe0\xa9\x80\0"
	"PAN\0"
	"pan\0"
	"gu\0"
	"Gujarati\0"
	"\xe0\xaa\x97\xe0\xab\x81\xe0\xaa\x9c\xe0\xaa\xb0\xe0\xaa\xbe\xe0\xaa\xa4\xe0\xab\x80\0"
	"GUJ\0"
	"guj\0"
	"or\0"
	"Odia\0"
	"\xe0\xac\x93\xe0\xac\xa1\xe0\xac\xbc\xe0\xac\xbf\xe0\xac\x86\0"
	"ORI\0"
	"ori\0"
	"ta\0"
	"Tamil\0"
	"\xe0\xae\xa4\xe0\xae\xae\xe0\xae\xbf\xe0\xae\xb4\xe0\xaf\x8d\0"
	"TAI\0"
	"tam\0"
	"te\0"
	"Telugu\0"
	"\xe0\xb0\xa4\xe0\xb1\x86\xe0\xb0\xb2\xe0\xb1\x81\xe0\xb0\x97\xe0\xb1\x81\0"
	"TEL\0"
	"tel\0"
	"Kannada\0"
	"\xe0\xb2\x95\xe0\xb2\xa8\xe0\xb3\x8d\xe0\xb2\xa8\xe0\xb2\xa1\0"
	"KDI\0"
	"kan\0"
	"ml\0"
	"Malayalam\0"
	"\xe0\xb4\xae\xe0\xb4\xb2\xe0\xb4\xaf\xe0\xb4\xbe\xe0\xb4\xb3\xe0\xb4\x82\0"
	"MYM\0"
	"mal\0"
	"as\0"
	"Assamese\0"
	"\xe0\xa6\x85\xe0\xa6\xb8\xe0\xa6\xae\xe0\xa7\x80\xe0\xa6\xaf\xe0\xa6\xbc\xe0\xa6\xbe\0"
	"ASM\0"
	"asm\0"
	"mr\0"
	"Marathi\0"
	"\xe0\xa4\xae\xe0\xa4\xb0\xe0\xa4\xbe\xe0\xa4\xa0\xe0\xa5\x80\0"
	"MAR\0"
	"mar\0"
	"mn\0"
	"Mongolian\0"
	"\xd0\xbc\xd0\xbe\xd0\xbd\xd0\xb3\xd0\xbe\xd0\xbb\0"
	"MON\0"
	"mon\0"
	"bo\0"
	"Tibetan\0"
	"\xe0\xbd\x96\xe0\xbd\xbc\xe0\xbd\x91\xe0\xbc\x8b\xe0\xbd\xa6\xe0\xbe\x90\xe0\xbd\x91\xe0\xbc\x8b\0"
	"BOB\0"
	"bod\0"
	"cy\0"
	"Welsh\0"
	"Cymraeg\0"
	"CYM\0"
	"cym\0"
	"km\0"
	"Khmer\0"
	"\xe1\x9e\x81\xe1\x9f\x92\xe1\x9e\x98\xe1\x9f\x82\xe1\x9e\x9a\0"
	"KHM\0"
	"khm\0"
	"lo\0"
	"Lao\0"
	"\xe0\xba\xa5\xe0\xba\xb2\xe0\xba\xa7\0"
	"LAO\0"
	"lao\0"
	"my\0"
	"Burmese\0"
	"\xe1\x80\x99\xe1\x80\xbc\xe1\x80\x94\xe1\x80\xba\xe1\x80\x99\xe1\x80\xac\0"
	"MYA\0"
	"mya\0"
	"gl\0"
	"Galician\0"
	"galego\0"
	"GLC\0"
	"glg\0"
	"kok\0"
	"Konkani\0"
	"\xe0\xa4\x95\xe0\xa5\x8b\xe0\xa4\x82\xe0\xa4\x95\xe0\xa4\xa3\xe0\xa5\x80\0"
	"KNK\0"
	"si\0"
	"Sinhala\0"
	"\xe0\xb7\x83\xe0\xb7\x92\xe0\xb6\x82\xe0\xb7\x84\xe0\xb6\xbd\0"
	"SIN\0"
	"sin\0"
	"chr\0"
	"Cherokee\0"
	"\xe1\x8f\xa3\xe1\x8e\xb3\xe1\x8e\xa9\0"
	"CRE\0"
	"Amharic\0"
	"\xe1\x8a\xa0\xe1\x88\x9b\xe1\x88\xad\xe1\x8a\x9b\0"
	"AMH\0"
	"amh\0"
	"tzm\0"
	"Central Atlas Tamazight\0"
	"Tamazi\xc9\xa3t n la\xe1\xb9\xadla\xe1\xb9\xa3\0"
	"TZA\0"
	"ne\0"
	"Nepali\0"
	"\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xb2\xe0\xa5\x80\0"
	"NEP\0"
	"nep\0"
	"fy\0"
	"Western Frisian\0"
	"West-Frysk\0"
	"FYN\0"
	"fry\0"
	"ps\0"
	"Pashto\0"
	"\xd9\xbe\xda\x9a\xd8\xaa\xd9\x88\0"
	"PAS\0"
	"pus\0"
	"fil\0"
	"Filipino\0"
	"FPO\0"
	"ff\0"
	"Fulah\0"
	"Pulaar\0"
	"FUL\0"
	"ful\0"
	"ha\0"
	"Hausa\0"
	"HAU\0"
	"hau\0"
	"yo\0"
	"Yoruba\0"
	"\xc3\x88\x64\xc3\xa8 Yor\xc3\xb9\x62\xc3\xa1\0"
	"YOR\0"
	"yor\0"
	"nso\0"
	"Northern Sotho\0"
	"Sesotho sa Leboa\0"
	"NSO\0"
	"lb\0"
	"Luxembourgish\0"
	"L\xc3\xabtzebuergesch\0"
	"LBX\0"
	"ltz\0"
	"kl\0"
	"Kalaallisut\0"
	"kalaallisut\0"
	"KAL\0"
	"kal\0"
	"ig\0"
	"Igbo\0"
	"IBO\0"
	"ibo\0"
	"om\0"
	"Oromo\0"
	"Oromoo\0"
	"ORM\0"
	"orm\0"
	"ti\0"
	"Tigrinya\0"
	"\xe1\x89\xb5\xe1\x8c\x8d\xe1\x88\xad\xe1\x8a\x9b\0"
	"TIR\0"
	"tir\0"
	"haw\0"
	"Hawaiian\0"
	"\xca\xbb\xc5\x8clelo Hawai\xca\xbbi\0"
	"HAW\0"
	"so\0"
	"Somali\0"
	"Soomaali\0"
	"SOM\0"
	"som\0"
	"ii\0"
	"Sichuan Yi\0"
	"\xea\x86\x88\xea\x8c\xa0\xea\x89\x99\0"
	"III\0"
	"iii\0"
	"br\0"
	"Breton\0"
	"brezhoneg\0"
	"BRE\0"
	"bre\0"
	"ug\0"
	"Uyghur\0"
	"\xd8\xa6\xdb\x87\xd9\x8a\xd8\xba\xdb\x87\xd8\xb1\xda\x86\xdb\x95\0"
	"UIG\0"
	"uig\0"
	"gsw\0"
	"Swiss German\0"
	"Schwiizert\xc3\xbc\xc3\xbctsch\0"
	"GSW\0"
	"sah\0"
	"Sakha\0"
	"\xd1\x81\xd0\xb0\xd1\x85\xd0\xb0 \xd1\x82\xd1\x8b\xd0\xbb\xd0\xb0\0"
	"SAH\0"
	"rw\0"
	"Kinyarwanda\0"
	"KIN\0"
	"kin\0"
	"gd\0"
	"Scottish Gaelic\0"
	"G\xc3\xa0idhlig\0"
	"GLA\0"
	"gla\0"
	"ar-SA\0"
	"Arabic (Saudi Arabia)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd9\x85\xd9\x85\xd9\x84\xd9\x83\xd8\xa9 \xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 \xd8\xa7\xd9\x84\xd8\xb3\xd8\xb9\xd9\x88\xd8\xaf\xd9\x8a\xd8\xa9)\0"
	"bg-BG\0"
	"Bulgarian (Bulgaria)\0"
	"\xd0\xb1\xd1\x8a\xd0\xbb\xd0\xb3\xd0\xb0\xd1\x80\xd1\x81\xd0\xba\xd0\xb8 (\xd0\x91\xd1\x8a\xd0\xbb\xd0\xb3\xd0\xb0\xd1\x80\xd0\xb8\xd1\x8f)\0"
	"BG\0"
	"ca-ES\0"
	"Catalan (Spain)\0"
	"catal\xc3\xa0 (Espanya)\0"
	"ES\0"
	"zh-TW\0"
	"Chinese (Traditional)\0"
	"\xe4\xb8\xad\xe6\x96\x87 (\xe5\x8f\xb0\xe6\xb9\xbe)\0"
	"CHT\0"
	"TW\0"
	"cs-CZ\0"
	"Czech (Czech Republic)\0"
	"\xc4\x8d\x65\xc5\xa1tina (\xc4\x8c\x65sk\xc3\xa1 republika)\0"
	"CZ\0"
	"da-DK\0"
	"Danish (Denmark)\0"
	"dansk (Danmark)\0"
	"DK\0"
	"de-DE\0"
	"German (Germany)\0"
	"Deutsch (Deutschland)\0"
	"DE\0"
	"el-GR\0"
	"Greek (Greece)\0"
	"\xce\x95\xce\xbb\xce\xbb\xce\xb7\xce\xbd\xce\xb9\xce\xba\xce\xac (\xce\x95\xce\xbb\xce\xbb\xce\xac\xce\xb4\xce\xb1)\0"
	"GR\0"
	"en-US\0"
	"English (United States)\0"
	"US\0"
	"fi-FI\0"
	"Finnish (Finland)\0"
	"suomi (Suomi)\0"
	"FI\0"
	"fr-FR\0"
	"French (France)\0"
	"fran\xc3\xa7\x61is (France)\0"
	"FR\0"
	"he-IL\0"
	"Hebrew (Israel)\0"
	"\xd7\xa2\xd7\x91\xd7\xa8\xd7\x99\xd7\xaa (\xd7\x99\xd7\xa9\xd7\xa8\xd7\x90\xd7\x9c)\0"
	"IL\0"
	"hu-HU\0"
	"Hungarian (Hungary)\0"
	"magyar (Magyarorsz\xc3\xa1g)\0"
	"HU\0"
	"is-IS\0"
	"Icelandic (Iceland)\0"
	"\xc3\xadslenska (\xc3\x8dsland)\0"
	"IS\0"
	"it-IT\0"
	"Italian (Italy)\0"
	"italiano (Italia)\0"
	"IT\0"
	"ja-JP\0"
	"Japanese (Japan)\0"
	"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e (\xe6\x97\xa5\xe6\x9c\xac)\0"
	"JP\0"
	"ko-KR\0"
	"Korean (South Korea)\0"
	"\xed\x95\x9c\xea\xb5\xad\xec\x96\xb4 (\xeb\x8c\x80\xed\x95\x9c\xeb\xaf\xbc\xea\xb5\xad)\0"
	"KR\0"
	"nl-NL\0"
	"Dutch (Netherlands)\0"
	"Nederlands (Nederland)\0"
	"NL\0"
	"nb-NO\0"
	"Norwegian Bokm\xc3\xa5l (Norway)\0"
	"norsk bokm\xc3\xa5l (Norge)\0"
	"NO\0"
	"pl-PL\0"
	"Polish (Poland)\0"
	"polski (Polska)\0"
	"PL\0"
	"pt-BR\0"
	"Portuguese (Brazil)\0"
	"portugu\xc3\xaas (Brasil)\0"
	"BR\0"
	"rm-CH\0"
	"Romansh (Switzerland)\0"
	"rumantsch (Svizra)\0"
	"ro-RO\0"
	"Romanian (Romania)\0"
	"rom\xc3\xa2n\xc4\x83 (Rom\xc3\xa2nia)\0"
	"RO\0"
	"ru-RU\0"
	"Russian (Russia)\0"
	"\xd1\x80\xd1\x83\xd1\x81\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9 (\xd0\xa0\xd0\xbe\xd1\x81\xd1\x81\xd0\xb8\xd1\x8f)\0"
	"RU\0"
	"hr-HR\0"
	"Croatian (Croatia)\0"
	"hrvatski (Hrvatska)\0"
	"HR\0"
	"sk-SK\0"
	"Slovak (Slovakia)\0"
	"sloven\xc4\x8dina (Slovensko)\0"
	"SK\0"
	"sq-AL\0"
	"Albanian (Albania)\0"
	"shqip (Shqip\xc3\xabri)\0"
	"AL\0"
	"sv-SE\0"
	"Swedish (Sweden)\0"
	"svenska (Sverige)\0"
	"SE\0"
	"th-TH\0"
	"Thai (Thailand)\0"
	"\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2 (\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2)\0"
	"TH\0"
	"tr-TR\0"
	"Turkish (Turkey)\0"
	"T\xc3\xbcrk\xc3\xa7\x65 (T\xc3\xbcrkiye)\0"
	"TR\0"
	"ur-PK\0"
	"Urdu (Pakistan)\0"
	"\xd8\xa7\xd8\xb1\xd8\xaf\xd9\x88 (\xd9\xbe\xd8\xa7\xda\xa9\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86)\0"
	"PK\0"
	"id-ID\0"
	"Indonesian (Indonesia)\0"
	"Indonesia (Indonesia)\0"
	"ID\0"
	"uk-UA\0"
	"Ukrainian (Ukraine)\0"
	"\xd1\x83\xd0\xba\xd1\x80\xd0\xb0\xd1\x97\xd0\xbd\xd1\x81\xd1\x8c\xd0\xba\xd0\xb0 (\xd0\xa3\xd0\xba\xd1\x80\xd0\xb0\xd1\x97\xd0\xbd\xd0\xb0)\0"
	"UA\0"
	"be-BY\0"
	"Belarusian (Belarus)\0"
	"\xd0\xb1\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x80\xd1\x83\xd1\x81\xd0\xba\xd0\xb0\xd1\x8f (\xd0\x91\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x80\xd1\x83\xd1\x81\xd1\x8c)\0"
	"BY\0"
	"sl-SI\0"
	"Slovenian (Slovenia)\0"
	"sloven\xc5\xa1\xc4\x8dina (Slovenija)\0"
	"SI\0"
	"et-EE\0"
	"Estonian (Estonia)\0"
	"eesti (Eesti)\0"
	"EE\0"
	"lv-LV\0"
	"Latvian (Latvia)\0"
	"latvie\xc5\xa1u (Latvija)\0"
	"LV\0"
	"lt-LT\0"
	"Lithuanian (Lithuania)\0"
	"lietuvi\xc5\xb3 (Lietuva)\0"
	"LT\0"
	"tg-Cyrl-TJ\0"
	"Tajik (Cyrillic, Tajikistan)\0"
	"\xd0\xa2\xd0\xbe\xd2\xb7\xd0\xb8\xd0\xba\xd3\xa3 (\xd0\xa2\xd0\xbe\xd2\xb7\xd0\xb8\xd0\xba\xd0\xb8\xd1\x81\xd1\x82\xd0\xbe\xd0\xbd)\0"
	"TJ\0"
	"fa-IR\0"
	"Persian (Iran)\0"
	"\xd9\x81\xd8\xa7\xd8\xb1\xd8\xb3\xdb\x8c (\xd8\xa7\xdb\x8c\xd8\xb1\xd8\xa7\xd9\x86)\0"
	"IR\0"
	"vi-VN\0"
	"Vietnamese (Vietnam)\0"
	"Ti\xe1\xba\xbfng Vi\xe1\xbb\x87t (Vi\xe1\xbb\x87t Nam)\0"
	"VN\0"
	"hy-AM\0"
	"Armenian (Armenia)\0"
	"\xd5\xb0\xd5\xa1\xd5\xb5\xd5\xa5\xd6\x80\xd5\xa5\xd5\xb6 (\xd5\x80\xd5\xa1\xd5\xb5\xd5\xa1\xd5\xbd\xd5\xbf\xd5\xa1\xd5\xb6)\0"
	"az-Latn-AZ\0"
	"Azerbaijani (Latin, Azerbaijan)\0"
	"az\xc9\x99rbaycan (Az\xc9\x99rbaycan)\0"
	"AZ\0"
	"eu-ES\0"
	"Basque (Spain)\0"
	"euskara (Espainia)\0"
	"hsb-DE\0"
	"Upper Sorbian (Germany)\0"
	"hornjoserb\xc5\xa1\xc4\x87ina (N\xc4\x9bmska)\0"
	"mk-MK\0"
	"Macedonian (Macedonia)\0"
	"\xd0\xbc\xd0\xb0\xd0\xba\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8 (\xd0\x9c\xd0\xb0\xd0\xba\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbd\xd0\xb8\xd1\x98\xd0\xb0)\0"
	"MK\0"
	"st-ZA\0"
	"Southern Sotho (South Africa)\0"
	"ZA\0"
	"ts-ZA\0"
	"Tsonga (South Africa)\0"
	"tn-ZA\0"
	"Tswana (South Africa)\0"
	"xh-ZA\0"
	"Xhosa (South Africa)\0"
	"zu-ZA\0"
	"Zulu (South Africa)\0"
	"isiZulu (i-South Africa)\0"
	"af-ZA\0"
	"Afrikaans (South Africa)\0"
	"Afrikaans (Suid-Afrika)\0"
	"ka-GE\0"
	"Georgian (Georgia)\0"
	"\xe1\x83\xa5\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x97\xe1\x83\xa3\xe1\x83\x9a\xe1\x83\x98 (\xe1\x83\xa1\xe1\x83\x90\xe1\x83\xa5\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x97\xe1\x83\x95\xe1\x83\x94\xe1\x83\x9a\xe1\x83\x9d)\0"
	"GE\0"
	"fo-FO\0"
	"Faroese (Faroe Islands)\0"
	"f\xc3\xb8royskt (F\xc3\xb8royar)\0"
	"FO\0"
	"hi-IN\0"
	"Hindi (India)\0"
	"\xe0\xa4\xb9\xe0\xa4\xbf\xe0\xa4\xa8\xe0\xa5\x8d\xe0\xa4\xa6\xe0\xa5\x80 (\xe0\xa4\xad\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa4\xa4)\0"
	"IN\0"
	"mt-MT\0"
	"Maltese (Malta)\0"
	"Malti (Malta)\0"
	"MT\0"
	"se-NO\0"
	"Northern Sami (Norway)\0"
	"davvis\xc3\xa1megiella (Norga)\0"
	"ms-MY\0"
	"Malay (Malaysia)\0"
	"Bahasa Melayu (Malaysia)\0"
	"MY\0"
	"kk-KZ\0"
	"Kazakh (Kazakhstan)\0"
	"\xd2\x9b\xd0\xb0\xd0\xb7\xd0\xb0\xd2\x9b \xd1\x82\xd1\x96\xd0\xbb\xd1\x96 (\xd2\x9a\xd0\xb0\xd0\xb7\xd0\xb0\xd2\x9b\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd)\0"
	"KZ\0"
	"ky-KG\0"
	"Kyrgyz (Kyrgyzstan)\0"
	"\xd0\xba\xd1\x8b\xd1\x80\xd0\xb3\xd1\x8b\xd0\xb7\xd1\x87\xd0\xb0 (\xd0\x9a\xd1\x8b\xd1\x80\xd0\xb3\xd1\x8b\xd0\xb7\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd)\0"
	"KG\0"
	"sw-KE\0"
	"Swahili (Kenya)\0"
	"Kiswahili (Kenya)\0"
	"KE\0"
	"tk-TM\0"
	"Turkmen (Turkmenistan)\0"
	"t\xc3\xbcrkmen\xc3\xa7\x65 (T\xc3\xbcrkmenistan)\0"
	"TM\0"
	"uz-Latn-UZ\0"
	"Uzbek (Latin, Uzbekistan)\0"
	"o\xe2\x80\x98zbek (O\xca\xbbzbekiston)\0"
	"UZ\0"
	"tt-RU\0"
	"Tatar (Russia)\0"
	"\xd1\x82\xd0\xb0\xd1\x82\xd0\xb0\xd1\x80 (\xd0\xa0\xd0\xbe\xd1\x81\xd1\x81\xd0\xb8\xd1\x8f)\0"
	"bn-IN\0"
	"Bangla (India)\0"
	"\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe (\xe0\xa6\xad\xe0\xa6\xbe\xe0\xa6\xb0\xe0\xa6\xa4)\0"
	"gu-IN\0"
	"Gujarati (India)\0"
	"\xe0\xaa\x97\xe0\xab\x81\xe0\xaa\x9c\xe0\xaa\xb0\xe0\xaa\xbe\xe0\xaa\xa4\xe0\xab\x80 (\xe0\xaa\xad\xe0\xaa\xbe\xe0\xaa\xb0\xe0\xaa\xa4)\0"
	"or-IN\0"
	"Odia (India)\0"
	"\xe0\xac\x93\xe0\xac\xa1\xe0\xac\xbc\xe0\xac\xbf\xe0\xac\x86 (\xe0\xac\xad\xe0\xac\xbe\xe0\xac\xb0\xe0\xac\xa4)\0"
	"ta-IN\0"
	"Tamil (India)\0"
	"\xe0\xae\xa4\xe0\xae\xae\xe0\xae\xbf\xe0\xae\xb4\xe0\xaf\x8d (\xe0\xae\x87\xe0\xae\xa8\xe0\xaf\x8d\xe0\xae\xa4\xe0\xae\xbf\xe0\xae\xaf\xe0\xae\xbe)\0"
	"te-IN\0"
	"Telugu (India)\0"
	"\xe0\xb0\xa4\xe0\xb1\x86\xe0\xb0\xb2\xe0\xb1\x81\xe0\xb0\x97\xe0\xb1\x81 (\xe0\xb0\xad\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\xa4 \xe0\xb0\xa6\xe0\xb1\x87\xe0\xb0\xb6\xe0\xb0\x82)\0"
	"kn-IN\0"
	"Kannada (India)\0"
	"\xe0\xb2\x95\xe0\xb2\xa8\xe0\xb3\x8d\xe0\xb2\xa8\xe0\xb2\xa1 (\xe0\xb2\xad\xe0\xb2\xbe\xe0\xb2\xb0\xe0\xb2\xa4)\0"
	"ml-IN\0"
	"Malayalam (India)\0"
	"\xe0\xb4\xae\xe0\xb4\xb2\xe0\xb4\xaf\xe0\xb4\xbe\xe0\xb4\xb3\xe0\xb4\x82 (\xe0\xb4\x87\xe0\xb4\xa8\xe0\xb5\x8d\xe0\xb4\xa4\xe0\xb5\x8d\xe0\xb4\xaf)\0"
	"as-IN\0"
	"Assamese (India)\0"
	"\xe0\xa6\x85\xe0\xa6\xb8\xe0\xa6\xae\xe0\xa7\x80\xe0\xa6\xaf\xe0\xa6\xbc\xe0\xa6\xbe (\xe0\xa6\xad\xe0\xa6\xbe\xe0\xa7\xb0\xe0\xa6\xa4)\0"
	"mr-IN\0"
	"Marathi (India)\0"
	"\xe0\xa4\xae\xe0\xa4\xb0\xe0\xa4\xbe\xe0\xa4\xa0\xe0\xa5\x80 (\xe0\xa4\xad\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa4\xa4)\0"
	"mn-MN\0"
	"Mongolian (Mongolia)\0"
	"\xd0\xbc\xd0\xbe\xd0\xbd\xd0\xb3\xd0\xbe\xd0\xbb (\xd0\x9c\xd0\xbe\xd0\xbd\xd0\xb3\xd0\xbe\xd0\xbb)\0"
	"MNN\0"
	"MN\0"
	"bo-CN\0"
	"Tibetan (China)\0"
	"\xe0\xbd\x96\xe0\xbd\xbc\xe0\xbd\x91\xe0\xbc\x8b\xe0\xbd\xa6\xe0\xbe\x90\xe0\xbd\x91\xe0\xbc\x8b (\xe0\xbd\xa2\xe0\xbe\x92\xe0\xbe\xb1\xe0\xbc\x8b\xe0\xbd\x93\xe0\xbd\x82)\0"
	"CN\0"
	"cy-GB\0"
	"Welsh (United Kingdom)\0"
	"Cymraeg (Y Deyrnas Unedig)\0"
	"GB\0"
	"km-KH\0"
	"Khmer (Cambodia)\0"
	"\xe1\x9e\x81\xe1\x9f\x92\xe1\x9e\x98\xe1\x9f\x82\xe1\x9e\x9a (\xe1\x9e\x80\xe1\x9e\x98\xe1\x9f\x92\xe1\x9e\x96\xe1\x9e\xbb\xe1\x9e\x87\xe1\x9e\xb6)\0"
	"KH\0"
	"lo-LA\0"
	"Lao (Laos)\0"
	"\xe0\xba\xa5\xe0\xba\xb2\xe0\xba\xa7 (\xe0\xba\xa5\xe0\xba\xb2\xe0\xba\xa7)\0"
	"LA\0"
	"my-MM\0"
	"Burmese (Myanmar (Burma))\0"
	"\xe1\x80\x99\xe1\x80\xbc\xe1\x80\x94\xe1\x80\xba\xe1\x80\x99\xe1\x80\xac (\xe1\x80\x99\xe1\x80\xbc\xe1\x80\x94\xe1\x80\xba\xe1\x80\x99\xe1\x80\xac)\0"
	"MM\0"
	"gl-ES\0"
	"Galician (Spain)\0"
	"galego (Espa\xc3\xb1\x61)\0"
	"kok-IN\0"
	"Konkani (India)\0"
	"\xe0\xa4\x95\xe0\xa5\x8b\xe0\xa4\x82\xe0\xa4\x95\xe0\xa4\xa3\xe0\xa5\x80 (\xe0\xa4\xad\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa4\xa4)\0"
	"si-LK\0"
	"Sinhala (Sri Lanka)\0"
	"\xe0\xb7\x83\xe0\xb7\x92\xe0\xb6\x82\xe0\xb7\x84\xe0\xb6\xbd (\xe0\xb7\x81\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x93 \xe0\xb6\xbd\xe0\xb6\x82\xe0\xb6\x9a\xe0\xb7\x8f\xe0\xb7\x80)\0"
	"LK\0"
	"am-ET\0"
	"Amharic (Ethiopia)\0"
	"\xe1\x8a\xa0\xe1\x88\x9b\xe1\x88\xad\xe1\x8a\x9b (\xe1\x8a\xa2\xe1\x89\xb5\xe1\x8b\xae\xe1\x8c\xb5\xe1\x8b\xab)\0"
	"ET\0"
	"ne-NP\0"
	"Nepali (Nepal)\0"
	"\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xb2\xe0\xa5\x80 (\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xb2)\0"
	"NP\0"
	"fy-NL\0"
	"Western Frisian (Netherlands)\0"
	"West-Frysk (Nederl\xc3\xa2n)\0"
	"ps-AF\0"
	"Pashto (Afghanistan)\0"
	"\xd9\xbe\xda\x9a\xd8\xaa\xd9\x88 (\xd8\xa7\xd9\x81\xd8\xba\xd8\xa7\xd9\x86\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86)\0"
	"AF\0"
	"fil-PH\0"
	"Filipino (Philippines)\0"
	"Filipino (Pilipinas)\0"
	"PH\0"
	"ha-Latn-NG\0"
	"Hausa (Latin, Nigeria)\0"
	"Hausa (Najeriya)\0"
	"NG\0"
	"yo-NG\0"
	"Yoruba (Nigeria)\0"
	"\xc3\x88\x64\xc3\xa8 Yor\xc3\xb9\x62\xc3\xa1 (Or\xc3\xadl\xe1\xba\xb9\xcc\x81\xc3\xa8\x64\x65 N\xc3\xa0\xc3\xacj\xc3\xadr\xc3\xad\xc3\xa0)\0"
	"nso-ZA\0"
	"Northern Sotho (South Africa)\0"
	"lb-LU\0"
	"Luxembourgish (Luxembourg)\0"
	"L\xc3\xabtzebuergesch (L\xc3\xabtzebuerg)\0"
	"LU\0"
	"kl-GL\0"
	"Kalaallisut (Greenland)\0"
	"kalaallisut (Kalaallit Nunaat)\0"
	"GL\0"
	"ig-NG\0"
	"Igbo (Nigeria)\0"
	"om-ET\0"
	"Oromo (Ethiopia)\0"
	"Oromoo (Itoophiyaa)\0"
	"ti-ET\0"
	"Tigrinya (Ethiopia)\0"
	"\xe1\x89\xb5\xe1\x8c\x8d\xe1\x88\xad\xe1\x8a\x9b (\xe1\x8a\xa2\xe1\x89\xb5\xe1\x8b\xae\xe1\x8c\xb5\xe1\x8b\xab)\0"
	"TIE\0"
	"haw-US\0"
	"Hawaiian (United States)\0"
	"\xca\xbb\xc5\x8clelo Hawai\xca\xbbi (\xca\xbb\x41melika Hui P\xc5\xab \xca\xbbIa)\0"
	"so-SO\0"
	"Somali (Somalia)\0"
	"Soomaali (Soomaaliya)\0"
	"SO\0"
	"ii-CN\0"
	"Sichuan Yi (China)\0"
	"\xea\x86\x88\xea\x8c\xa0\xea\x89\x99 (\xea\x8d\x8f\xea\x87\xa9)\0"
	"br-FR\0"
	"Breton (France)\0"
	"brezhoneg (Fra\xc3\xb1s)\0"
	"ug-CN\0"
	"Uyghur (China)\0"
	"\xd8\xa6\xdb\x87\xd9\x8a\xd8\xba\xdb\x87\xd8\xb1\xda\x86\xdb\x95 (\xd8\xac\xdb\x87\xda\xad\xda\xaf\xd9\x88)\0"
	"gsw-FR\0"
	"Swiss German (France)\0"
	"Schwiizert\xc3\xbc\xc3\xbctsch (Frankriich)\0"
	"sah-RU\0"
	"Sakha (Russia)\0"
	"\xd1\x81\xd0\xb0\xd1\x85\xd0\xb0 \xd1\x82\xd1\x8b\xd0\xbb\xd0\xb0 (\xd0\x90\xd1\x80\xd0\xb0\xd1\x81\xd1\x81\xd1\x8b\xd1\x8b\xd0\xb9\xd0\xb0)\0"
	"rw-RW\0"
	"Kinyarwanda (Rwanda)\0"
	"RW\0"
	"gd-GB\0"
	"Scottish Gaelic (United Kingdom)\0"
	"G\xc3\xa0idhlig (An R\xc3\xacoghachd Aonaichte)\0"
	"ar-IQ\0"
	"Arabic (Iraq)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa7\xd9\x82)\0"
	"ARI\0"
	"IQ\0"
	"ca-ES-valencia\0"
	"VAL\0"
	"zh-CN\0"
	"\xe4\xb8\xad\xe6\x96\x87 (\xe4\xb8\xad\xe5\x9b\xbd)\0"
	"de-CH\0"
	"German (Switzerland)\0"
	"Deutsch (Schweiz)\0"
	"DES\0"
	"en-GB\0"
	"English (United Kingdom)\0"
	"ENG\0"
	"es-MX\0"
	"Spanish (Mexico)\0"
	"espa\xc3\xb1ol (M\xc3\xa9xico)\0"
	"ESM\0"
	"MX\0"
	"fr-BE\0"
	"French (Belgium)\0"
	"fran\xc3\xa7\x61is (Belgique)\0"
	"FRB\0"
	"BE\0"
	"it-CH\0"
	"Italian (Switzerland)\0"
	"italiano (Svizzera)\0"
	"ITS\0"
	"nl-BE\0"
	"Dutch (Belgium)\0"
	"Nederlands (Belgi\xc3\xab)\0"
	"NLB\0"
	"nn-NO\0"
	"Norwegian Nynorsk (Norway)\0"
	"nynorsk (Noreg)\0"
	"NON\0"
	"nno\0"
	"nn\0"
	"pt-PT\0"
	"Portuguese (Portugal)\0"
	"portugu\xc3\xaas (Portugal)\0"
	"PT\0"
	"ro-MD\0"
	"Romanian (Moldova)\0"
	"rom\xc3\xa2n\xc4\x83 (Republica Moldova)\0"
	"ROD\0"
	"MD\0"
	"ru-MD\0"
	"Russian (Moldova)\0"
	"\xd1\x80\xd1\x83\xd1\x81\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9 (\xd0\x9c\xd0\xbe\xd0\xbb\xd0\xb4\xd0\xbe\xd0\xb2\xd0\xb0)\0"
	"RUM\0"
	"sv-FI\0"
	"Swedish (Finland)\0"
	"svenska (Finland)\0"
	"SVF\0"
	"ur-IN\0"
	"Urdu (India)\0"
	"\xd8\xa7\xd8\xb1\xd8\xaf\xd9\x88 (\xd8\xa8\xda\xbe\xd8\xa7\xd8\xb1\xd8\xaa)\0"
	"URI\0"
	"az-Cyrl-AZ\0"
	"Azerbaijani (Cyrillic, Azerbaijan)\0"
	"AZC\0"
	"dsb-DE\0"
	"Lower Sorbian (Germany)\0"
	"dolnoserb\xc5\xa1\xc4\x87ina (Nimska)\0"
	"DSB\0"
	"dsb\0"
	"tn-BW\0"
	"Tswana (Botswana)\0"
	"TSB\0"
	"BW\0"
	"se-SE\0"
	"Northern Sami (Sweden)\0"
	"davvis\xc3\xa1megiella (Ruo\xc5\xa7\xc5\xa7\x61)\0"
	"SMF\0"
	"ga-IE\0"
	"Irish (Ireland)\0"
	"Gaeilge (\xc3\x89ire)\0"
	"IE\0"
	"ms-BN\0"
	"Malay (Brunei)\0"
	"Bahasa Melayu (Brunei)\0"
	"MSB\0"
	"BN\0"
	"uz-Cyrl-UZ\0"
	"Uzbek (Cyrillic, Uzbekistan)\0"
	"UZC\0"
	"bn-BD\0"
	"Bangla (Bangladesh)\0"
	"\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe (\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe\xe0\xa6\xa6\xe0\xa7\x87\xe0\xa6\xb6)\0"
	"BNB\0"
	"BD\0"
	"pa-Arab-PK\0"
	"Punjabi (Arabic, Pakistan)\0"
	"\xe0\xa8\xaa\xe0\xa9\xb0\xe0\xa8\x9c\xe0\xa8\xbe\xe0\xa8\xac\xe0\xa9\x80 (\xe0\xa8\xaa\xe0\xa8\xbe\xe0\xa8\x95\xe0\xa8\xbf\xe0\xa8\xb8\xe0\xa8\xa4\xe0\xa8\xbe\xe0\xa8\xa8)\0"
	"PAP\0"
	"ta-LK\0"
	"Tamil (Sri Lanka)\0"
	"\xe0\xae\xa4\xe0\xae\xae\xe0\xae\xbf\xe0\xae\xb4\xe0\xaf\x8d (\xe0\xae\x87\xe0\xae\xb2\xe0\xae\x99\xe0\xaf\x8d\xe0\xae\x95\xe0\xaf\x88)\0"
	"TAM\0"
	"ne-IN\0"
	"Nepali (India)\0"
	"\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xb2\xe0\xa5\x80 (\xe0\xa4\xad\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa4\xa4)\0"
	"NEI\0"
	"ti-ER\0"
	"Tigrinya (Eritrea)\0"
	"\xe1\x89\xb5\xe1\x8c\x8d\xe1\x88\xad\xe1\x8a\x9b (\xe1\x8a\xa4\xe1\x88\xad\xe1\x89\xb5\xe1\x88\xab)\0"
	"ER\0"
	"ar-EG\0"
	"Arabic (Egypt)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd9\x85\xd8\xb5\xd8\xb1)\0"
	"ARE\0"
	"EG\0"
	"zh-HK\0"
	"Chinese (Traditional, Hong Kong SAR China)\0"
	"\xe4\xb8\xad\xe6\x96\x87 (\xe4\xb8\xad\xe5\x9b\xbd\xe9\xa6\x99\xe6\xb8\xaf\xe7\x89\xb9\xe5\x88\xab\xe8\xa1\x8c\xe6\x94\xbf\xe5\x8c\xba)\0"
	"ZHH\0"
	"HK\0"
	"de-AT\0"
	"German (Austria)\0"
	"Deutsch (\xc3\x96sterreich)\0"
	"DEA\0"
	"AT\0"
	"en-AU\0"
	"English (Australia)\0"
	"ENA\0"
	"AU\0"
	"es-ES\0"
	"Spanish (Spain)\0"
	"espa\xc3\xb1ol (Espa\xc3\xb1\x61)\0"
	"ESN\0"
	"fr-CA\0"
	"French (Canada)\0"
	"fran\xc3\xa7\x61is (Canada)\0"
	"FRC\0"
	"CA\0"
	"se-FI\0"
	"Northern Sami (Finland)\0"
	"davvis\xc3\xa1megiella (Suopma)\0"
	"SMG\0"
	"ar-LY\0"
	"Arabic (Libya)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd9\x84\xd9\x8a\xd8\xa8\xd9\x8a\xd8\xa7)\0"
	"ARL\0"
	"LY\0"
	"zh-SG\0"
	"Chinese (Simplified, Singapore)\0"
	"\xe4\xb8\xad\xe6\x96\x87 (\xe6\x96\xb0\xe5\x8a\xa0\xe5\x9d\xa1)\0"
	"ZHI\0"
	"SG\0"
	"de-LU\0"
	"German (Luxembourg)\0"
	"Deutsch (Luxemburg)\0"
	"DEL\0"
	"en-CA\0"
	"English (Canada)\0"
	"ENC\0"
	"es-GT\0"
	"Spanish (Guatemala)\0"
	"espa\xc3\xb1ol (Guatemala)\0"
	"ESG\0"
	"GT\0"
	"fr-CH\0"
	"French (Switzerland)\0"
	"fran\xc3\xa7\x61is (Suisse)\0"
	"FRS\0"
	"hr-BA\0"
	"Croatian (Bosnia & Herzegovina)\0"
	"hrvatski (Bosna i Hercegovina)\0"
	"HRB\0"
	"BA\0"
	"ar-DZ\0"
	"Arabic (Algeria)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd8\xac\xd8\xb2\xd8\xa7\xd8\xa6\xd8\xb1)\0"
	"ARG\0"
	"DZ\0"
	"zh-MO\0"
	"Chinese (Traditional, Macau SAR China)\0"
	"\xe4\xb8\xad\xe6\x96\x87 (\xe4\xb8\xad\xe5\x9b\xbd\xe6\xbe\xb3\xe9\x97\xa8\xe7\x89\xb9\xe5\x88\xab\xe8\xa1\x8c\xe6\x94\xbf\xe5\x8c\xba)\0"
	"ZHM\0"
	"MO\0"
	"de-LI\0"
	"German (Liechtenstein)\0"
	"Deutsch (Liechtenstein)\0"
	"DEC\0"
	"LI\0"
	"en-NZ\0"
	"English (New Zealand)\0"
	"ENZ\0"
	"NZ\0"
	"es-CR\0"
	"Spanish (Costa Rica)\0"
	"espa\xc3\xb1ol (Costa Rica)\0"
	"ESC\0"
	"CR\0"
	"fr-LU\0"
	"French (Luxembourg)\0"
	"fran\xc3\xa7\x61is (Luxembourg)\0"
	"FRL\0"
	"bs-Latn-BA\0"
	"Bosnian (Latin, Bosnia & Herzegovina)\0"
	"bosanski (Bosna i Hercegovina)\0"
	"BSB\0"
	"bos\0"
	"bs\0"
	"ar-MA\0"
	"Arabic (Morocco)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd9\x85\xd8\xba\xd8\xb1\xd8\xa8)\0"
	"ARM\0"
	"MA\0"
	"en-IE\0"
	"English (Ireland)\0"
	"ENI\0"
	"es-PA\0"
	"Spanish (Panama)\0"
	"espa\xc3\xb1ol (Panam\xc3\xa1)\0"
	"ESA\0"
	"PA\0"
	"fr-MC\0"
	"French (Monaco)\0"
	"fran\xc3\xa7\x61is (Monaco)\0"
	"FRM\0"
	"MC\0"
	"sr-Latn-BA\0"
	"Serbian (Latin, Bosnia & Herzegovina)\0"
	"\xd1\x81\xd1\x80\xd0\xbf\xd1\x81\xd0\xba\xd0\xb8 (\xd0\x91\xd0\xbe\xd1\x81\xd0\xbd\xd0\xb0 \xd0\xb8 \xd0\xa5\xd0\xb5\xd1\x80\xd1\x86\xd0\xb5\xd0\xb3\xd0\xbe\xd0\xb2\xd0\xb8\xd0\xbd\xd0\xb0)\0"
	"SRS\0"
	"srp\0"
	"sr\0"
	"ar-TN\0"
	"Arabic (Tunisia)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xaa\xd9\x88\xd9\x86\xd8\xb3)\0"
	"ART\0"
	"TN\0"
	"en-ZA\0"
	"English (South Africa)\0"
	"ENS\0"
	"es-DO\0"
	"Spanish (Dominican Republic)\0"
	"espa\xc3\xb1ol (Rep\xc3\xba\x62lica Dominicana)\0"
	"ESD\0"
	"DO\0"
	"sr-Cyrl-BA\0"
	"Serbian (Cyrillic, Bosnia & Herzegovina)\0"
	"SRN\0"
	"ar-OM\0"
	"Arabic (Oman)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xb9\xd9\x8f\xd9\x85\xd8\xa7\xd9\x86)\0"
	"ARO\0"
	"OM\0"
	"en-JM\0"
	"English (Jamaica)\0"
	"ENJ\0"
	"JM\0"
	"es-VE\0"
	"Spanish (Venezuela)\0"
	"espa\xc3\xb1ol (Venezuela)\0"
	"ESV\0"
	"VE\0"
	"fr-RE\0"
	"French (R\xc3\xa9union)\0"
	"fran\xc3\xa7\x61is (La R\xc3\xa9union)\0"
	"FRR\0"
	"RE\0"
	"bs-Cyrl-BA\0"
	"Bosnian (Cyrillic, Bosnia & Herzegovina)\0"
	"BSC\0"
	"ar-YE\0"
	"Arabic (Yemen)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x86)\0"
	"ARY\0"
	"YE\0"
	"es-CO\0"
	"Spanish (Colombia)\0"
	"espa\xc3\xb1ol (Colombia)\0"
	"ESO\0"
	"CO\0"
	"fr-CD\0"
	"French (Congo - Kinshasa)\0"
	"fran\xc3\xa7\x61is (Congo-Kinshasa)\0"
	"FRD\0"
	"CD\0"
	"sr-Latn-RS\0"
	"Serbian (Latin, Serbia)\0"
	"\xd1\x81\xd1\x80\xd0\xbf\xd1\x81\xd0\xba\xd0\xb8 (\xd0\xa1\xd1\x80\xd0\xb1\xd0\xb8\xd1\x98\xd0\xb0)\0"
	"SRM\0"
	"RS\0"
	"smn-FI\0"
	"Inari Sami (Finland)\0"
	"anar\xc3\xa2\xc5\xa1kiel\xc3\xa2 (Suom\xc3\xa2)\0"
	"SMN\0"
	"smn\0"
	"ar-SY\0"
	"Arabic (Syria)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xb3\xd9\x88\xd8\xb1\xd9\x8a\xd8\xa7)\0"
	"ARS\0"
	"SY\0"
	"en-BZ\0"
	"English (Belize)\0"
	"ENL\0"
	"BZ\0"
	"es-PE\0"
	"Spanish (Peru)\0"
	"espa\xc3\xb1ol (Per\xc3\xba)\0"
	"ESR\0"
	"PE\0"
	"fr-SN\0"
	"French (Senegal)\0"
	"fran\xc3\xa7\x61is (S\xc3\xa9n\xc3\xa9gal)\0"
	"FRN\0"
	"SN\0"
	"sr-Cyrl-RS\0"
	"Serbian (Cyrillic, Serbia)\0"
	"SRO\0"
	"ar-JO\0"
	"Arabic (Jordan)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd8\xa3\xd8\xb1\xd8\xaf\xd9\x86)\0"
	"ARJ\0"
	"JO\0"
	"en-TT\0"
	"English (Trinidad & Tobago)\0"
	"ENT\0"
	"TT\0"
	"es-AR\0"
	"Spanish (Argentina)\0"
	"espa\xc3\xb1ol (Argentina)\0"
	"ESS\0"
	"AR\0"
	"fr-CM\0"
	"French (Cameroon)\0"
	"fran\xc3\xa7\x61is (Cameroun)\0"
	"FRE\0"
	"CM\0"
	"sr-Latn-ME\0"
	"Serbian (Latin, Montenegro)\0"
	"\xd1\x81\xd1\x80\xd0\xbf\xd1\x81\xd0\xba\xd0\xb8 (\xd0\xa6\xd1\x80\xd0\xbd\xd0\xb0 \xd0\x93\xd0\xbe\xd1\x80\xd0\xb0)\0"
	"SRP\0"
	"ME\0"
	"ar-LB\0"
	"Arabic (Lebanon)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd9\x84\xd8\xa8\xd9\x86\xd8\xa7\xd9\x86)\0"
	"ARB\0"
	"LB\0"
	"en-ZW\0"
	"English (Zimbabwe)\0"
	"ENW\0"
	"ZW\0"
	"es-EC\0"
	"Spanish (Ecuador)\0"
	"espa\xc3\xb1ol (Ecuador)\0"
	"ESF\0"
	"EC\0"
	"fr-CI\0"
	"French (C\xc3\xb4te d\xe2\x80\x99Ivoire)\0"
	"fran\xc3\xa7\x61is (C\xc3\xb4te d\xe2\x80\x99Ivoire)\0"
	"FRI\0"
	"CI\0"
	"sr-Cyrl-ME\0"
	"Serbian (Cyrillic, Montenegro)\0"
	"SRQ\0"
	"ar-KW\0"
	"Arabic (Kuwait)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd9\x83\xd9\x88\xd9\x8a\xd8\xaa)\0"
	"ARK\0"
	"KW\0"
	"en-PH\0"
	"English (Philippines)\0"
	"ENP\0"
	"es-CL\0"
	"Spanish (Chile)\0"
	"espa\xc3\xb1ol (Chile)\0"
	"ESL\0"
	"CL\0"
	"fr-ML\0"
	"French (Mali)\0"
	"fran\xc3\xa7\x61is (Mali)\0"
	"FRF\0"
	"ML\0"
	"ar-AE\0"
	"Arabic (United Arab Emirates)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd8\xa5\xd9\x85\xd8\xa7\xd8\xb1\xd8\xa7\xd8\xaa \xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 \xd8\xa7\xd9\x84\xd9\x85\xd8\xaa\xd8\xad\xd8\xaf\xd8\xa9)\0"
	"ARU\0"
	"AE\0"
	"es-UY\0"
	"Spanish (Uruguay)\0"
	"espa\xc3\xb1ol (Uruguay)\0"
	"ESY\0"
	"UY\0"
	"fr-MA\0"
	"French (Morocco)\0"
	"fran\xc3\xa7\x61is (Maroc)\0"
	"FRO\0"
	"ar-BH\0"
	"Arabic (Bahrain)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd8\xa7\xd9\x84\xd8\xa8\xd8\xad\xd8\xb1\xd9\x8a\xd9\x86)\0"
	"ARH\0"
	"BH\0"
	"en-HK\0"
	"English (Hong Kong SAR China)\0"
	"ENH\0"
	"es-PY\0"
	"Spanish (Paraguay)\0"
	"espa\xc3\xb1ol (Paraguay)\0"
	"ESZ\0"
	"PY\0"
	"fr-HT\0"
	"French (Haiti)\0"
	"fran\xc3\xa7\x61is (Ha\xc3\xafti)\0"
	"FRH\0"
	"HT\0"
	"ar-QA\0"
	"Arabic (Qatar)\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 (\xd9\x82\xd8\xb7\xd8\xb1)\0"
	"ARQ\0"
	"QA\0"
	"en-IN\0"
	"English (India)\0"
	"ENN\0"
	"es-BO\0"
	"Spanish (Bolivia)\0"
	"espa\xc3\xb1ol (Bolivia)\0"
	"ESB\0"
	"BO\0"
	"en-MY\0"
	"English (Malaysia)\0"
	"ENM\0"
	"es-SV\0"
	"Spanish (El Salvador)\0"
	"espa\xc3\xb1ol (El Salvador)\0"
	"ESE\0"
	"SV\0"
	"en-SG\0"
	"English (Singapore)\0"
	"ENE\0"
	"es-HN\0"
	"Spanish (Honduras)\0"
	"espa\xc3\xb1ol (Honduras)\0"
	"ESH\0"
	"HN\0"
	"es-NI\0"
	"Spanish (Nicaragua)\0"
	"espa\xc3\xb1ol (Nicaragua)\0"
	"ESI\0"
	"NI\0"
	"es-PR\0"
	"Spanish (Puerto Rico)\0"
	"espa\xc3\xb1ol (Puerto Rico)\0"
	"ESU\0"
	"PR\0"
	"es-US\0"
	"Spanish (United States)\0"
	"espa\xc3\xb1ol (Estados Unidos)\0"
	"EST\0"
	"es-CU\0"
	"Spanish (Cuba)\0"
	"espa\xc3\xb1ol (Cuba)\0"
	"ESK\0"
	"CU\0"
	"bs-Cyrl\0"
	"Bosnian (Cyrillic)\0"
	"bosanski\0"
	"bs-Latn\0"
	"Bosnian (Latin)\0"
	"sr-Cyrl\0"
	"Serbian (Cyrillic)\0"
	"\xd1\x81\xd1\x80\xd0\xbf\xd1\x81\xd0\xba\xd0\xb8\0"
	"sr-Latn\0"
	"Serbian (Latin)\0"
	"Inari Sami\0"
	"anar\xc3\xa2\xc5\xa1kiel\xc3\xa2\0"
	"az-Cyrl\0"
	"Azerbaijani (Cyrillic)\0"
	"Norwegian Nynorsk\0"
	"nynorsk\0"
	"Bosnian\0"
	"az-Latn\0"
	"Azerbaijani (Latin)\0"
	"uz-Cyrl\0"
	"Uzbek (Cyrillic)\0"
	"mn-Cyrl\0"
	"Mongolian (Cyrillic)\0"
	"zh-Hant\0"
	"zh-CHT\0"
	"Chinese (Traditional) Legacy\0"
	"Norwegian Bokm\xc3\xa5l\0"
	"norsk bokm\xc3\xa5l\0"
	"Serbian\0"
	"SRB\0"
	"tg-Cyrl\0"
	"Tajik (Cyrillic)\0"
	"Lower Sorbian\0"
	"dolnoserb\xc5\xa1\xc4\x87ina\0"
	"uz-Latn\0"
	"Uzbek (Latin)\0"
	"pa-Arab\0"
	"Punjabi (Arabic)\0"
	"tzm-Latn\0"
	"Central Atlas Tamazight (Latin)\0"
	"ha-Latn\0"
	"Hausa (Latin)\0"
	"af-za\0"
	"am-et\0"
	"ar-ae\0"
	"ar-bh\0"
	"ar-dz\0"
	"ar-eg\0"
	"ar-iq\0"
	"ar-jo\0"
	"ar-kw\0"
	"ar-lb\0"
	"ar-ly\0"
	"ar-ma\0"
	"ar-om\0"
	"ar-qa\0"
	"ar-sa\0"
	"ar-sy\0"
	"ar-tn\0"
	"ar-ye\0"
	"as-in\0"
	"az-cyrl\0"
	"az-cyrl-az\0"
	"az-latn\0"
	"az-latn-az\0"
	"be-by\0"
	"bg-bg\0"
	"bn-bd\0"
	"bn-in\0"
	"bo-cn\0"
	"br-fr\0"
	"bs-cyrl\0"
	"bs-cyrl-ba\0"
	"bs-latn\0"
	"bs-latn-ba\0"
	"ca-es\0"
	"ca-es-valencia\0"
	"cs-cz\0"
	"cy-gb\0"
	"da-dk\0"
	"de-at\0"
	"de-ch\0"
	"de-de\0"
	"de-li\0"
	"de-lu\0"
	"dsb-de\0"
	"el-gr\0"
	"en-au\0"
	"en-bz\0"
	"en-ca\0"
	"en-gb\0"
	"en-hk\0"
	"en-ie\0"
	"en-in\0"
	"en-jm\0"
	"en-my\0"
	"en-nz\0"
	"en-ph\0"
	"en-sg\0"
	"en-tt\0"
	"en-us\0"
	"en-za\0"
	"en-zw\0"
	"es-ar\0"
	"es-bo\0"
	"es-cl\0"
	"es-co\0"
	"es-cr\0"
	"es-cu\0"
	"es-do\0"
	"es-ec\0"
	"es-es\0"
	"es-gt\0"
	"es-hn\0"
	"es-mx\0"
	"es-ni\0"
	"es-pa\0"
	"es-pe\0"
	"es-pr\0"
	"es-py\0"
	"es-sv\0"
	"es-us\0"
	"es-uy\0"
	"es-ve\0"
	"et-ee\0"
	"eu-es\0"
	"fa-ir\0"
	"fi-fi\0"
	"fil-ph\0"
	"fo-fo\0"
	"fr-be\0"
	"fr-ca\0"
	"fr-cd\0"
	"fr-ch\0"
	"fr-ci\0"
	"fr-cm\0"
	"fr-fr\0"
	"fr-ht\0"
	"fr-lu\0"
	"fr-ma\0"
	"fr-mc\0"
	"fr-ml\0"
	"fr-re\0"
	"fr-sn\0"
	"fy-nl\0"
	"ga-ie\0"
	"gd-gb\0"
	"gl-es\0"
	"gsw-fr\0"
	"gu-in\0"
	"ha-latn\0"
	"ha-latn-ng\0"
	"haw-us\0"
	"he-il\0"
	"hi-in\0"
	"hr-ba\0"
	"hr-hr\0"
	"hsb-de\0"
	"hu-hu\0"
	"hy-am\0"
	"id-id\0"
	"ig-ng\0"
	"ii-cn\0"
	"is-is\0"
	"it-ch\0"
	"it-it\0"
	"ja-jp\0"
	"ka-ge\0"
	"kk-kz\0"
	"kl-gl\0"
	"km-kh\0"
	"kn-in\0"
	"ko-kr\0"
	"kok-in\0"
	"ky-kg\0"
	"lb-lu\0"
	"lo-la\0"
	"lt-lt\0"
	"lv-lv\0"
	"mk-mk\0"
	"ml-in\0"
	"mn-cyrl\0"
	"mn-mn\0"
	"mr-in\0"
	"ms-bn\0"
	"ms-my\0"
	"mt-mt\0"
	"my-mm\0"
	"nb-no\0"
	"ne-in\0"
	"ne-np\0"
	"nl-be\0"
	"nl-nl\0"
	"nn-no\0"
	"nso-za\0"
	"om-et\0"
	"or-in\0"
	"pa-arab\0"
	"pa-arab-pk\0"
	"pl-pl\0"
	"ps-af\0"
	"pt-br\0"
	"pt-pt\0"
	"rm-ch\0"
	"ro-md\0"
	"ro-ro\0"
	"ru-md\0"
	"ru-ru\0"
	"rw-rw\0"
	"sah-ru\0"
	"se-fi\0"
	"se-no\0"
	"se-se\0"
	"si-lk\0"
	"sk-sk\0"
	"sl-si\0"
	"smn-fi\0"
	"so-so\0"
	"sq-al\0"
	"sr-cyrl\0"
	"sr-cyrl-ba\0"
	"sr-cyrl-me\0"
	"sr-cyrl-rs\0"
	"sr-latn\0"
	"sr-latn-ba\0"
	"sr-latn-me\0"
	"sr-latn-rs\0"
	"st-za\0"
	"sv-fi\0"
	"sv-se\0"
	"sw-ke\0"
	"ta-in\0"
	"ta-lk\0"
	"te-in\0"
	"tg-cyrl\0"
	"tg-cyrl-tj\0"
	"th-th\0"
	"ti-er\0"
	"ti-et\0"
	"tk-tm\0"
	"tn-bw\0"
	"tn-za\0"
	"tr-tr\0"
	"ts-za\0"
	"tt-ru\0"
	"tzm-latn\0"
	"ug-cn\0"
	"uk-ua\0"
	"ur-in\0"
	"ur-pk\0"
	"uz-cyrl\0"
	"uz-cyrl-uz\0"
	"uz-latn\0"
	"uz-latn-uz\0"
	"vi-vn\0"
	"xh-za\0"
	"yo-ng\0"
	"zh-chs\0"
	"zh-cht\0"
	"zh-cn\0"
	"zh-hans\0"
	"zh-hant\0"
	"zh-hk\0"
	"zh-mo\0"
	"zh-sg\0"
	"zh-tw\0"
	"zu-za\0"
	"United Arab Emirates\0"
	"\xd8\xa7\xd9\x84\xd8\xa5\xd9\x85\xd8\xa7\xd8\xb1\xd8\xa7\xd8\xaa \xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 \xd8\xa7\xd9\x84\xd9\x85\xd8\xaa\xd8\xad\xd8\xaf\xd8\xa9\0"
	"AED\0"
	"United Arab Emirates Dirham\0"
	"\xd8\xaf\xd8\xb1\xd9\x87\xd9\x85 \xd8\xa5\xd9\x85\xd8\xa7\xd8\xb1\xd8\xa7\xd8\xaa\xd9\x8a\0"
	"AFG\0"
	"Afghanistan\0"
	"\xd8\xa7\xd9\x81\xd8\xba\xd8\xa7\xd9\x86\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86\0"
	"AFN\0"
	"Afghan Afghani\0"
	"\xd8\xa7\xd9\x81\xd8\xba\xd8\xa7\xd9\x86\xdb\x8d\0"
	"ALB\0"
	"Albania\0"
	"Shqip\xc3\xabri\0"
	"ALL\0"
	"Albanian Lek\0"
	"Leku shqiptar\0"
	"Armenia\0"
	"\xd5\x80\xd5\xa1\xd5\xb5\xd5\xa1\xd5\xbd\xd5\xbf\xd5\xa1\xd5\xb6\0"
	"AMD\0"
	"Armenian Dram\0"
	"\xd5\x80\xd5\xa1\xd5\xb5\xd5\xaf\xd5\xa1\xd5\xaf\xd5\xa1\xd5\xb6 \xd5\xa4\xd6\x80\xd5\xa1\xd5\xb4\0"
	"Argentina\0"
	"Argentine Peso\0"
	"peso argentino\0"
	"AUT\0"
	"Austria\0"
	"\xc3\x96sterreich\0"
	"EUR\0"
	"Euro\0"
	"AUS\0"
	"Australia\0"
	"AUD\0"
	"Australian Dollar\0"
	"Azerbaijan\0"
	"Az\xc9\x99rbaycan\0"
	"AZN\0"
	"Azerbaijani Manat\0"
	"Az\xc9\x99rbaycan Manat\xc4\xb1\0"
	"BIH\0"
	"Bosnia & Herzegovina\0"
	"Bosna i Hercegovina\0"
	"BAM\0"
	"Bosnia-Herzegovina Convertible Mark\0"
	"konvertibilna marka\0"
	"BGD\0"
	"Bangladesh\0"
	"\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe\xe0\xa6\xa6\xe0\xa7\x87\xe0\xa6\xb6\0"
	"BDT\0"
	"Bangladeshi Taka\0"
	"\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe\xe0\xa6\xa6\xe0\xa7\x87\xe0\xa6\xb6\xe0\xa7\x80 \xe0\xa6\x9f\xe0\xa6\xbe\xe0\xa6\x95\xe0\xa6\xbe\0"
	"Belgium\0"
	"Belgique\0"
	"euro\0"
	"Bulgaria\0"
	"\xd0\x91\xd1\x8a\xd0\xbb\xd0\xb3\xd0\xb0\xd1\x80\xd0\xb8\xd1\x8f\0"
	"BGN\0"
	"Bulgarian Lev\0"
	"\xd0\x91\xd1\x8a\xd0\xbb\xd0\xb3\xd0\xb0\xd1\x80\xd1\x81\xd0\xba\xd0\xb8 \xd0\xbb\xd0\xb5\xd0\xb2\0"
	"BHR\0"
	"Bahrain\0"
	"\xd8\xa7\xd9\x84\xd8\xa8\xd8\xad\xd8\xb1\xd9\x8a\xd9\x86\0"
	"BHD\0"
	"Bahraini Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd8\xa8\xd8\xad\xd8\xb1\xd9\x8a\xd9\x86\xd9\x8a\0"
	"BRN\0"
	"Brunei\0"
	"BND\0"
	"Brunei Dollar\0"
	"Dolar Brunei\0"
	"BOL\0"
	"Bolivia\0"
	"Bolivian Boliviano\0"
	"boliviano\0"
	"BRA\0"
	"Brazil\0"
	"Brasil\0"
	"BRL\0"
	"Brazilian Real\0"
	"Real brasileiro\0"
	"BWA\0"
	"Botswana\0"
	"BWP\0"
	"Botswanan Pula\0"
	"BLR\0"
	"Belarus\0"
	"\xd0\x91\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x80\xd1\x83\xd1\x81\xd1\x8c\0"
	"BYN\0"
	"Belarusian Ruble\0"
	"\xd0\xb1\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x80\xd1\x83\xd1\x81\xd0\xba\xd1\x96 \xd1\x80\xd1\x83\xd0\xb1\xd0\xb5\xd0\xbb\xd1\x8c\0"
	"BLZ\0"
	"Belize\0"
	"BZD\0"
	"Belize Dollar\0"
	"CAN\0"
	"Canada\0"
	"CAD\0"
	"Canadian Dollar\0"
	"dollar canadien\0"
	"COD\0"
	"Congo - Kinshasa\0"
	"Congo-Kinshasa\0"
	"CDF\0"
	"Congolese Franc\0"
	"franc congolais\0"
	"CHE\0"
	"Switzerland\0"
	"Svizra\0"
	"Swiss Franc\0"
	"franc svizzer\0"
	"CIV\0"
	"C\xc3\xb4te d\xe2\x80\x99Ivoire\0"
	"XOF\0"
	"West African CFA Franc\0"
	"franc CFA (BCEAO)\0"
	"CHL\0"
	"Chile\0"
	"CLP\0"
	"Chilean Peso\0"
	"Peso chileno\0"
	"CMR\0"
	"Cameroon\0"
	"Cameroun\0"
	"XAF\0"
	"Central African CFA Franc\0"
	"franc CFA (BEAC)\0"
	"CHN\0"
	"China\0"
	"\xe0\xbd\xa2\xe0\xbe\x92\xe0\xbe\xb1\xe0\xbc\x8b\xe0\xbd\x93\xe0\xbd\x82\0"
	"CNY\0"
	"Chinese Yuan\0"
	"\xe0\xbd\xa1\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\xa8\xe0\xbd\x93\xe0\xbc\x8b\0"
	"COL\0"
	"Colombia\0"
	"COP\0"
	"Colombian Peso\0"
	"peso colombiano\0"
	"CRI\0"
	"Costa Rica\0"
	"CRC\0"
	"Costa Rican Col\xc3\xb3n\0"
	"col\xc3\xb3n costarricense\0"
	"CUB\0"
	"Cuba\0"
	"CUP\0"
	"Cuban Peso\0"
	"peso cubano\0"
	"CZE\0"
	"Czech Republic\0"
	"\xc4\x8c\x65sk\xc3\xa1 republika\0"
	"CZK\0"
	"Czech Republic Koruna\0"
	"\xc4\x8d\x65sk\xc3\xa1 koruna\0"
	"Germany\0"
	"Deutschland\0"
	"DNK\0"
	"Denmark\0"
	"Danmark\0"
	"DKK\0"
	"Danish Krone\0"
	"dansk krone\0"
	"DOM\0"
	"Dominican Republic\0"
	"Rep\xc3\xba\x62lica Dominicana\0"
	"DOP\0"
	"Dominican Peso\0"
	"peso dominicano\0"
	"DZA\0"
	"Algeria\0"
	"\xd8\xa7\xd9\x84\xd8\xac\xd8\xb2\xd8\xa7\xd8\xa6\xd8\xb1\0"
	"DZD\0"
	"Algerian Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd8\xac\xd8\xb2\xd8\xa7\xd8\xa6\xd8\xb1\xd9\x8a\0"
	"ECU\0"
	"Ecuador\0"
	"USD\0"
	"US Dollar\0"
	"d\xc3\xb3lar estadounidense\0"
	"Estonia\0"
	"Eesti\0"
	"EGY\0"
	"Egypt\0"
	"\xd9\x85\xd8\xb5\xd8\xb1\0"
	"EGP\0"
	"Egyptian Pound\0"
	"\xd8\xac\xd9\x86\xd9\x8a\xd9\x87 \xd9\x85\xd8\xb5\xd8\xb1\xd9\x8a\0"
	"ERI\0"
	"Eritrea\0"
	"\xe1\x8a\xa4\xe1\x88\xad\xe1\x89\xb5\xe1\x88\xab\0"
	"ERN\0"
	"Eritrean Nakfa\0"
	"Spain\0"
	"Espanya\0"
	"ETH\0"
	"Ethiopia\0"
	"\xe1\x8a\xa2\xe1\x89\xb5\xe1\x8b\xae\xe1\x8c\xb5\xe1\x8b\xab\0"
	"ETB\0"
	"Ethiopian Birr\0"
	"\xe1\x8b\xa8\xe1\x8a\xa2\xe1\x89\xb5\xe1\x8b\xae\xe1\x8c\xb5\xe1\x8b\xab \xe1\x89\xa5\xe1\x88\xad\0"
	"Finland\0"
	"Suomi\0"
	"Faroe Islands\0"
	"F\xc3\xb8royar\0"
	"donsk kr\xc3\xb3na\0"
	"France\0"
	"GBR\0"
	"United Kingdom\0"
	"Y Deyrnas Unedig\0"
	"GBP\0"
	"British Pound\0"
	"Punt Prydain\0"
	"GEO\0"
	"Georgia\0"
	"\xe1\x83\xa1\xe1\x83\x90\xe1\x83\xa5\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x97\xe1\x83\x95\xe1\x83\x94\xe1\x83\x9a\xe1\x83\x9d\0"
	"GEL\0"
	"Georgian Lari\0"
	"\xe1\x83\xa5\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x97\xe1\x83\xa3\xe1\x83\x9a\xe1\x83\x98 \xe1\x83\x9a\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x98\0"
	"GRL\0"
	"Greenland\0"
	"Kalaallit Nunaat\0"
	"danmarkimut koruuni\0"
	"GRC\0"
	"Greece\0"
	"\xce\x95\xce\xbb\xce\xbb\xce\xac\xce\xb4\xce\xb1\0"
	"\xce\x95\xcf\x85\xcf\x81\xcf\x8e\0"
	"GTM\0"
	"Guatemala\0"
	"GTQ\0"
	"Guatemalan Quetzal\0"
	"quetzal\0"
	"HKG\0"
	"Hong Kong SAR China\0"
	"\xe4\xb8\xad\xe5\x9b\xbd\xe9\xa6\x99\xe6\xb8\xaf\xe7\x89\xb9\xe5\x88\xab\xe8\xa1\x8c\xe6\x94\xbf\xe5\x8c\xba\0"
	"HKD\0"
	"Hong Kong Dollar\0"
	"\xe6\xb8\xaf\xe5\x85\x83\0"
	"HND\0"
	"Honduras\0"
	"HNL\0"
	"Honduran Lempira\0"
	"lempira hondure\xc3\xb1o\0"
	"Croatia\0"
	"Hrvatska\0"
	"Croatian Kuna\0"
	"hrvatska kuna\0"
	"HTI\0"
	"Haiti\0"
	"Ha\xc3\xafti\0"
	"HTG\0"
	"Haitian Gourde\0"
	"gourde ha\xc3\xaftienne\0"
	"Hungary\0"
	"Magyarorsz\xc3\xa1g\0"
	"HUF\0"
	"Hungarian Forint\0"
	"magyar forint\0"
	"IDN\0"
	"IDR\0"
	"Indonesian Rupiah\0"
	"Rupiah Indonesia\0"
	"IRL\0"
	"Ireland\0"
	"\xc3\x89ire\0"
	"ISR\0"
	"Israel\0"
	"\xd7\x99\xd7\xa9\xd7\xa8\xd7\x90\xd7\x9c\0"
	"ILS\0"
	"Israeli New Shekel\0"
	"\xd7\xa9\xd7\xa7\xd7\x9c \xd7\x97\xd7\x93\xd7\xa9\0"
	"India\0"
	"\xe0\xa4\xad\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa4\xa4\0"
	"INR\0"
	"Indian Rupee\0"
	"\xe0\xa4\xad\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa4\xa4\xe0\xa5\x80\xe0\xa4\xaf \xe0\xa4\xb0\xe0\xa5\x81\xe0\xa4\xaa\xe0\xa4\xaf\xe0\xa4\xbe\0"
	"IRQ\0"
	"Iraq\0"
	"\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa7\xd9\x82\0"
	"IQD\0"
	"Iraqi Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd8\xb9\xd8\xb1\xd8\xa7\xd9\x82\xd9\x8a\0"
	"IRN\0"
	"Iran\0"
	"\xd8\xa7\xdb\x8c\xd8\xb1\xd8\xa7\xd9\x86\0"
	"IRR\0"
	"Iranian Rial\0"
	"\xd8\xb1\xdb\x8c\xd8\xa7\xd9\x84 \xd8\xa7\xdb\x8c\xd8\xb1\xd8\xa7\xd9\x86\0"
	"Iceland\0"
	"\xc3\x8dsland\0"
	"Icelandic Kr\xc3\xb3na\0"
	"\xc3\xadslensk kr\xc3\xb3na\0"
	"Italy\0"
	"Italia\0"
	"JAM\0"
	"Jamaica\0"
	"JMD\0"
	"Jamaican Dollar\0"
	"JOR\0"
	"Jordan\0"
	"\xd8\xa7\xd9\x84\xd8\xa3\xd8\xb1\xd8\xaf\xd9\x86\0"
	"JOD\0"
	"Jordanian Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd8\xa3\xd8\xb1\xd8\xaf\xd9\x86\xd9\x8a\0"
	"Japan\0"
	"\xe6\x97\xa5\xe6\x9c\xac\0"
	"JPY\0"
	"Japanese Yen\0"
	"\xe6\x97\xa5\xe6\x9c\xac\xe5\x86\x86\0"
	"KEN\0"
	"Kenya\0"
	"KES\0"
	"Kenyan Shilling\0"
	"Shilingi ya Kenya\0"
	"KGZ\0"
	"Kyrgyzstan\0"
	"\xd0\x9a\xd1\x8b\xd1\x80\xd0\xb3\xd1\x8b\xd0\xb7\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd\0"
	"KGS\0"
	"Kyrgystani Som\0"
	"\xd0\x9a\xd1\x8b\xd1\x80\xd0\xb3\xd1\x8b\xd0\xb7\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd \xd1\x81\xd0\xbe\xd0\xbc\xd1\x83\0"
	"Cambodia\0"
	"\xe1\x9e\x80\xe1\x9e\x98\xe1\x9f\x92\xe1\x9e\x96\xe1\x9e\xbb\xe1\x9e\x87\xe1\x9e\xb6\0"
	"KHR\0"
	"Cambodian Riel\0"
	"\xe1\x9e\x9a\xe1\x9f\x80\xe1\x9e\x9b\xe2\x80\x8b\xe1\x9e\x80\xe1\x9e\x98\xe1\x9f\x92\xe1\x9e\x96\xe1\x9e\xbb\xe1\x9e\x87\xe1\x9e\xb6\0"
	"South Korea\0"
	"\xeb\x8c\x80\xed\x95\x9c\xeb\xaf\xbc\xea\xb5\xad\0"
	"KRW\0"
	"South Korean Won\0"
	"\xeb\x8c\x80\xed\x95\x9c\xeb\xaf\xbc\xea\xb5\xad \xec\x9b\x90\0"
	"KWT\0"
	"Kuwait\0"
	"\xd8\xa7\xd9\x84\xd9\x83\xd9\x88\xd9\x8a\xd8\xaa\0"
	"KWD\0"
	"Kuwaiti Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd9\x83\xd9\x88\xd9\x8a\xd8\xaa\xd9\x8a\0"
	"KAZ\0"
	"Kazakhstan\0"
	"\xd2\x9a\xd0\xb0\xd0\xb7\xd0\xb0\xd2\x9b\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd\0"
	"KZT\0"
	"Kazakhstani Tenge\0"
	"\xd2\x9a\xd0\xb0\xd0\xb7\xd0\xb0\xd2\x9b\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd \xd1\x82\xd0\xb5\xd2\xa3\xd0\xb3\xd0\xb5\xd1\x81\xd1\x96\0"
	"Laos\0"
	"LAK\0"
	"Laotian Kip\0"
	"\xe0\xba\xa5\xe0\xba\xb2\xe0\xba\xa7 \xe0\xba\x81\xe0\xba\xb5\xe0\xba\x9a\0"
	"LBN\0"
	"Lebanon\0"
	"\xd9\x84\xd8\xa8\xd9\x86\xd8\xa7\xd9\x86\0"
	"LBP\0"
	"Lebanese Pound\0"
	"\xd8\xac\xd9\x86\xd9\x8a\xd9\x87 \xd9\x84\xd8\xa8\xd9\x86\xd8\xa7\xd9\x86\xd9\x8a\0"
	"LIE\0"
	"Liechtenstein\0"
	"Schweizer Franken\0"
	"LKA\0"
	"Sri Lanka\0"
	"\xe0\xb7\x81\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x93 \xe0\xb6\xbd\xe0\xb6\x82\xe0\xb6\x9a\xe0\xb7\x8f\xe0\xb7\x80\0"
	"LKR\0"
	"Sri Lankan Rupee\0"
	"\xe0\xb7\x81\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x93 \xe0\xb6\xbd\xe0\xb6\x82\xe0\xb6\x9a\xe0\xb7\x8f \xe0\xb6\xbb\xe0\xb7\x94\xe0\xb6\xb4\xe0\xb7\x92\xe0\xb6\xba\xe0\xb6\xbd\0"
	"LTU\0"
	"Lithuania\0"
	"Lietuva\0"
	"Euras\0"
	"LUX\0"
	"Luxembourg\0"
	"L\xc3\xabtzebuerg\0"
	"LVA\0"
	"Latvia\0"
	"Latvija\0"
	"eiro\0"
	"LBY\0"
	"Libya\0"
	"\xd9\x84\xd9\x8a\xd8\xa8\xd9\x8a\xd8\xa7\0"
	"LYD\0"
	"Libyan Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd9\x84\xd9\x8a\xd8\xa8\xd9\x8a\0"
	"Morocco\0"
	"\xd8\xa7\xd9\x84\xd9\x85\xd8\xba\xd8\xb1\xd8\xa8\0"
	"Moroccan Dirham\0"
	"\xd8\xaf\xd8\xb1\xd9\x87\xd9\x85 \xd9\x85\xd8\xba\xd8\xb1\xd8\xa8\xd9\x8a\0"
	"MCO\0"
	"Monaco\0"
	"MDA\0"
	"Moldova\0"
	"Republica Moldova\0"
	"MDL\0"
	"Moldovan Leu\0"
	"leu moldovenesc\0"
	"MNE\0"
	"Montenegro\0"
	"\xd0\xa6\xd1\x80\xd0\xbd\xd0\xb0 \xd0\x93\xd0\xbe\xd1\x80\xd0\xb0\0"
	"Evro\0"
	"MKD\0"
	"Macedonia\0"
	"\xd0\x9c\xd0\xb0\xd0\xba\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbd\xd0\xb8\xd1\x98\xd0\xb0\0"
	"Macedonian Denar\0"
	"\xd0\x9c\xd0\xb0\xd0\xba\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8 \xd0\xb4\xd0\xb5\xd0\xbd\xd0\xb0\xd1\x80\0"
	"MLI\0"
	"Mali\0"
	"MMR\0"
	"Myanmar (Burma)\0"
	"MMK\0"
	"Myanmar Kyat\0"
	"\xe1\x80\x99\xe1\x80\xbc\xe1\x80\x94\xe1\x80\xba\xe1\x80\x99\xe1\x80\xac\xe1\x80\x80\xe1\x80\xbb\xe1\x80\x95\xe1\x80\xba\0"
	"MNG\0"
	"Mongolia\0"
	"\xd0\x9c\xd0\xbe\xd0\xbd\xd0\xb3\xd0\xbe\xd0\xbb\0"
	"MNT\0"
	"Mongolian Tugrik\0"
	"\xd1\x82\xd3\xa9\xd0\xb3\xd1\x80\xd3\xa9\xd0\xb3\0"
	"MAC\0"
	"Macau SAR China\0"
	"\xe4\xb8\xad\xe5\x9b\xbd\xe6\xbe\xb3\xe9\x97\xa8\xe7\x89\xb9\xe5\x88\xab\xe8\xa1\x8c\xe6\x94\xbf\xe5\x8c\xba\0"
	"MOP\0"
	"Macanese Pataca\0"
	"\xe6\xbe\xb3\xe9\x96\x80\xe5\x85\x83\0"
	"Malta\0"
	"ewro\0"
	"MEX\0"
	"Mexico\0"
	"M\xc3\xa9xico\0"
	"MXN\0"
	"Mexican Peso\0"
	"peso mexicano\0"
	"MYS\0"
	"Malaysia\0"
	"MYR\0"
	"Malaysian Ringgit\0"
	"Ringgit Malaysia\0"
	"NGA\0"
	"Nigeria\0"
	"Najeriya\0"
	"NGN\0"
	"Nigerian Naira\0"
	"Naira\0"
	"NIC\0"
	"Nicaragua\0"
	"NIO\0"
	"Nicaraguan C\xc3\xb3rdoba\0"
	"c\xc3\xb3rdoba nicarag\xc3\xbc\x65nse\0"
	"Netherlands\0"
	"Nederland\0"
	"Norway\0"
	"Norge\0"
	"NOK\0"
	"Norwegian Krone\0"
	"norske kroner\0"
	"NPL\0"
	"Nepal\0"
	"\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xb2\0"
	"NPR\0"
	"Nepalese Rupee\0"
	"\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xb2\xe0\xa5\x80 \xe0\xa4\xb0\xe0\xa5\x82\xe0\xa4\xaa\xe0\xa5\x88\xe0\xa4\xaf\xe0\xa4\xbe\xe0\xa4\x81\0"
	"NZL\0"
	"New Zealand\0"
	"NZD\0"
	"New Zealand Dollar\0"
	"OMN\0"
	"Oman\0"
	"\xd8\xb9\xd9\x8f\xd9\x85\xd8\xa7\xd9\x86\0"
	"OMR\0"
	"Omani Rial\0"
	"\xd8\xb1\xd9\x8a\xd8\xa7\xd9\x84 \xd8\xb9\xd9\x85\xd8\xa7\xd9\x86\xd9\x8a\0"
	"Panama\0"
	"Panam\xc3\xa1\0"
	"PAB\0"
	"Panamanian Balboa\0"
	"balboa paname\xc3\xb1o\0"
	"PER\0"
	"Peru\0"
	"Per\xc3\xba\0"
	"PEN\0"
	"Peruvian Sol\0"
	"nuevo sol peruano\0"
	"PHL\0"
	"Philippines\0"
	"Pilipinas\0"
	"PHP\0"
	"Philippine Peso\0"
	"Piso ng Pilipinas\0"
	"PAK\0"
	"Pakistan\0"
	"\xd9\xbe\xd8\xa7\xda\xa9\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86\0"
	"PKR\0"
	"Pakistani Rupee\0"
	"\xd9\xbe\xd8\xa7\xda\xa9\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86\xdb\x8c \xd8\xb1\xd9\x88\xd9\xbe\xdb\x8c\xdb\x81\0"
	"POL\0"
	"Poland\0"
	"Polska\0"
	"PLN\0"
	"Polish Zloty\0"
	"z\xc5\x82oty polski\0"
	"PRI\0"
	"Puerto Rico\0"
	"PRT\0"
	"Portugal\0"
	"PRY\0"
	"Paraguay\0"
	"PYG\0"
	"Paraguayan Guarani\0"
	"guaran\xc3\xad paraguayo\0"
	"QAT\0"
	"Qatar\0"
	"\xd9\x82\xd8\xb7\xd8\xb1\0"
	"QAR\0"
	"Qatari Rial\0"
	"\xd8\xb1\xd9\x8a\xd8\xa7\xd9\x84 \xd9\x82\xd8\xb7\xd8\xb1\xd9\x8a\0"
	"REU\0"
	"R\xc3\xa9union\0"
	"La R\xc3\xa9union\0"
	"ROU\0"
	"Romania\0"
	"Rom\xc3\xa2nia\0"
	"Romanian Leu\0"
	"leu rom\xc3\xa2nesc\0"
	"Serbia\0"
	"\xd0\xa1\xd1\x80\xd0\xb1\xd0\xb8\xd1\x98\xd0\xb0\0"
	"Serbian Dinar\0"
	"Srpski dinar\0"
	"Russia\0"
	"\xd0\xa0\xd0\xbe\xd1\x81\xd1\x81\xd0\xb8\xd1\x8f\0"
	"RUB\0"
	"Russian Ruble\0"
	"\xd0\xa0\xd0\xbe\xd1\x81\xd1\x81\xd0\xb8\xd0\xb9\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9 \xd1\x80\xd1\x83\xd0\xb1\xd0\xbb\xd1\x8c\0"
	"RWA\0"
	"Rwanda\0"
	"RWF\0"
	"Rwandan Franc\0"
	"SAU\0"
	"Saudi Arabia\0"
	"\xd8\xa7\xd9\x84\xd9\x85\xd9\x85\xd9\x84\xd9\x83\xd8\xa9 \xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9 \xd8\xa7\xd9\x84\xd8\xb3\xd8\xb9\xd9\x88\xd8\xaf\xd9\x8a\xd8\xa9\0"
	"SAR\0"
	"Saudi Riyal\0"
	"\xd8\xb1\xd9\x8a\xd8\xa7\xd9\x84 \xd8\xb3\xd8\xb9\xd9\x88\xd8\xaf\xd9\x8a\0"
	"SWE\0"
	"Sweden\0"
	"Sverige\0"
	"SEK\0"
	"Swedish Krona\0"
	"svensk krona\0"
	"SGP\0"
	"Singapore\0"
	"\xe6\x96\xb0\xe5\x8a\xa0\xe5\x9d\xa1\0"
	"SGD\0"
	"Singapore Dollar\0"
	"\xe6\x96\xb0\xe5\x8a\xa0\xe5\x9d\xa1\xe5\x85\x83\0"
	"SVN\0"
	"Slovenia\0"
	"Slovenija\0"
	"evro\0"
	"SVK\0"
	"Slovakia\0"
	"Slovensko\0"
	"SEN\0"
	"Senegal\0"
	"S\xc3\xa9n\xc3\xa9gal\0"
	"Somalia\0"
	"Soomaaliya\0"
	"SOS\0"
	"Somali Shilling\0"
	"Shilin soomaali\0"
	"El Salvador\0"
	"SYR\0"
	"Syria\0"
	"\xd8\xb3\xd9\x88\xd8\xb1\xd9\x8a\xd8\xa7\0"
	"SYP\0"
	"Syrian Pound\0"
	"\xd9\x84\xd9\x8a\xd8\xb1\xd8\xa9 \xd8\xb3\xd9\x88\xd8\xb1\xd9\x8a\xd8\xa9\0"
	"Thailand\0"
	"Thai Baht\0"
	"\xe0\xb8\x9a\xe0\xb8\xb2\xe0\xb8\x97\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2\0"
	"TJK\0"
	"Tajikistan\0"
	"\xd0\xa2\xd0\xbe\xd2\xb7\xd0\xb8\xd0\xba\xd0\xb8\xd1\x81\xd1\x82\xd0\xbe\xd0\xbd\0"
	"TJS\0"
	"Tajikistani Somoni\0"
	"\xd0\xa1\xd0\xbe\xd0\xbc\xd0\xbe\xd0\xbd\xd3\xa3\0"
	"TKM\0"
	"Turkmenistan\0"
	"T\xc3\xbcrkmenistan\0"
	"Turkmenistani Manat\0"
	"T\xc3\xbcrkmen manaty\0"
	"TUN\0"
	"Tunisia\0"
	"\xd8\xaa\xd9\x88\xd9\x86\xd8\xb3\0"
	"TND\0"
	"Tunisian Dinar\0"
	"\xd8\xaf\xd9\x8a\xd9\x86\xd8\xa7\xd8\xb1 \xd8\xaa\xd9\x88\xd9\x86\xd8\xb3\xd9\x8a\0"
	"TUR\0"
	"Turkey\0"
	"T\xc3\xbcrkiye\0"
	"TRY\0"
	"Turkish Lira\0"
	"T\xc3\xbcrk Liras\xc4\xb1\0"
	"TTO\0"
	"Trinidad & Tobago\0"
	"TTD\0"
	"Trinidad & Tobago Dollar\0"
	"TWN\0"
	"Taiwan\0"
	"\xe5\x8f\xb0\xe6\xb9\xbe\0"
	"TWD\0"
	"New Taiwan Dollar\0"
	"\xe6\x96\xb0\xe5\x8f\xb0\xe5\xb9\xa3\0"
	"Ukraine\0"
	"\xd0\xa3\xd0\xba\xd1\x80\xd0\xb0\xd1\x97\xd0\xbd\xd0\xb0\0"
	"UAH\0"
	"Ukrainian Hryvnia\0"
	"\xd1\x83\xd0\xba\xd1\x80\xd0\xb0\xd1\x97\xd0\xbd\xd1\x81\xd1\x8c\xd0\xba\xd0\xb0 \xd0\xb3\xd1\x80\xd0\xb8\xd0\xb2\xd0\xbd\xd1\x8f\0"
	"USA\0"
	"United States\0"
	"URY\0"
	"Uruguay\0"
	"UYU\0"
	"Uruguayan Peso\0"
	"peso uruguayo\0"
	"Uzbekistan\0"
	"O\xca\xbbzbekiston\0"
	"UZS\0"
	"Uzbekistani Som\0"
	"O\xe2\x80\x98zbekiston so\xe2\x80\x98mi\0"
	"VEN\0"
	"Venezuela\0"
	"VEF\0"
	"Venezuelan Bol\xc3\xadvar\0"
	"bol\xc3\xadvar venezolano\0"
	"VNM\0"
	"Vietnam\0"
	"Vi\xe1\xbb\x87t Nam\0"
	"VND\0"
	"Vietnamese Dong\0"
	"\xc4\x90\xe1\xbb\x93ng Vi\xe1\xbb\x87t Nam\0"
	"YEM\0"
	"Yemen\0"
	"\xd8\xa7\xd9\x84\xd9\x8a\xd9\x85\xd9\x86\0"
	"YER\0"
	"Yemeni Rial\0"
	"\xd8\xb1\xd9\x8a\xd8\xa7\xd9\x84 \xd9\x8a\xd9\x85\xd9\x86\xd9\x8a\0"
	"ZAF\0"
	"South Africa\0"
	"ZAR\0"
	"South African Rand\0"
	"ZWE\0"
	"Zimbabwe\0"
};


static const char patterns [] = {
	"\0"
	"dd MMMM\0"
	"dd/MM/yy\0"
	"dd/MM/yyyy\0"
	"dd/MMMM/yyyy\0"
	"dddd, dd MMMM, yyyy\0"
	"hh:mm tt\0"
	"HH:mm\0"
	"hh:mm:ss tt\0"
	"HH:mm:ss\0"
	"MMMM, yyyy\0"
	"d MMMM\0"
	"d.M.yyyy '\xd0\xb3.'\0"
	"dd.M.yyyy '\xd0\xb3.'\0"
	"d.MM.yyyy '\xd0\xb3.'\0"
	"dd.MM.yyyy '\xd0\xb3.'\0"
	"dd MMMM yyyy '\xd0\xb3.'\0"
	"d MMMM yyyy '\xd0\xb3.'\0"
	"dddd, dd MMMM yyyy '\xd0\xb3.'\0"
	"dddd, d MMMM yyyy '\xd0\xb3.'\0"
	"H:mm\0"
	"H:mm:ss\0"
	"MMMM yyyy '\xd0\xb3.'\0"
	"d/M/yyyy\0"
	"d MMM yyyy\0"
	"dddd, d MMMM 'de' yyyy\0"
	"d MMMM 'de' yyyy\0"
	"MMMM 'de' yyyy\0"
	"M\xe6\x9c\x88\x64\xe6\x97\xa5\0"
	"yyyy/M/d\0"
	"yyyy-M-d\0"
	"yyyy.M.d\0"
	"yyyy/MM/dd\0"
	"yyyy-MM-dd\0"
	"yyyy.MM.dd\0"
	"yy/M/d\0"
	"yy-M-d\0"
	"yy.M.d\0"
	"yy/MM/dd\0"
	"yyyy'\xe5\xb9\xb4'M'\xe6\x9c\x88'd'\xe6\x97\xa5'\0"
	"yyyy'\xe5\xb9\xb4'M'\xe6\x9c\x88'd'\xe6\x97\xa5', dddd\0"
	"dddd, yyyy'\xe5\xb9\xb4'M'\xe6\x9c\x88'd'\xe6\x97\xa5'\0"
	"yyyy\xe5\xb9\xb4MMMd\xe6\x97\xa5\0"
	"yyyy\xe5\xb9\xb4MMMd\xe6\x97\xa5, dddd\0"
	"tt h:mm\0"
	"tt hh:mm\0"
	"tt h:mm:ss\0"
	"tt hh:mm:ss\0"
	"yyyy'\xe5\xb9\xb4'M'\xe6\x9c\x88'\0"
	"yyyy'\xe5\xb9\xb4'MMM\0"
	"yyyy'\xe5\xb9\xb4'MMMM\0"
	"yyyy.M\0"
	"d. MMMM\0"
	"dd.MM.yyyy\0"
	"d. M. yyyy\0"
	"dddd d. MMMM yyyy\0"
	"d. MMMM yyyy\0"
	"MMMM yyyy\0"
	"dd-MM-yyyy\0"
	"dd-MM-yy\0"
	"yyyy MM dd\0"
	"dd.MM.yy\0"
	"dd. MMM. yyyy\0"
	"dddd, d. MMMM yyyy\0"
	"d. MMM. yyyy\0"
	"HH:mm' Uhr'\0"
	"HH:mm:ss' Uhr'\0"
	"d/M/yy\0"
	"dd/MMM/yyyy\0"
	"dddd, d MMMM yyyy\0"
	"d MMMM yyyy\0"
	"h:mm tt\0"
	"h:mm:ss tt\0"
	"MMMM d\0"
	"M/d/yyyy\0"
	"M/d/yy\0"
	"MM/dd/yy\0"
	"MM/dd/yyyy\0"
	"dd-MMM-yy\0"
	"dddd, MMMM d, yyyy\0"
	"MMMM d, yyyy\0"
	"dddd, d MMMM, yyyy\0"
	"d MMMM, yyyy\0"
	"d 'de' MMMM\0"
	"d/MM/yy\0"
	"d-M-yy\0"
	"dddd, d' de 'MMMM' de 'yyyy\0"
	"dddd d' de 'MMMM' de 'yyyy\0"
	"d' de 'MMMM' de 'yyyy\0"
	"H.mm\0"
	"HH.mm\0"
	"HH'H'mm\0"
	"H.mm.ss\0"
	"HH.mm.ss\0"
	"HH'H'mm.ss\0"
	"MMMM' de 'yyyy\0"
	"d.M.yyyy\0"
	"dddd d MMMM yyyy\0"
	"d MMM yy\0"
	"HH' h 'mm\0"
	"HH'h'mm\0"
	"dd MMMM yyyy\0"
	"dd-MMMM-yyyy\0"
	"dd '\xd7\x91'MMMM yyyy\0"
	"dd MMM yy\0"
	"dddd dd MMMM yyyy\0"
	"dddd dd '\xd7\x91'MMMM yyyy\0"
	"ddd dd '\xd7\x91'MMMM yyyy\0"
	"MMMM d.\0"
	"yyyy. MM. dd.\0"
	"yyyy. MMM d.\0"
	"yyyy. MMMM d., dddd\0"
	"yyyy. MMMM d.\0"
	"yyyy. MMMM\0"
	"d. MMM yyyy\0"
	"dd.M.yy\0"
	"d-MMM-yy\0"
	"yyyy'\xe5\xb9\xb4'MM'\xe6\x9c\x88'dd'\xe6\x97\xa5'\0"
	"yyyy'\xe5\xb9\xb4'M'\xe6\x9c\x88'd'\xe6\x97\xa5 'dddd\0"
	"yyyy'\xe5\xb9\xb4'MM'\xe6\x9c\x88'dd'\xe6\x97\xa5 'dddd\0"
	"yyyy'\xe5\xb9\xb4'MMM'\xe6\x9c\x88'd'\xe6\x97\xa5'\0"
	"yyyy'\xe5\xb9\xb4'MMM'\xe6\x9c\x88'd'\xe6\x97\xa5 'dddd\0"
	"yyyy'\xe5\xb9\xb4'MMMMd'\xe6\x97\xa5'\0"
	"yyyy'\xe5\xb9\xb4'MMMMd'\xe6\x97\xa5 'dddd\0"
	"yyyy'\xe5\xb9\xb4'MMM'\xe6\x9c\x88'\0"
	"M\xec\x9b\x94 d\xec\x9d\xbc\0"
	"yy-MM-dd\0"
	"yyyy'\xeb\x85\x84' M'\xec\x9b\x94' d'\xec\x9d\xbc' dddd\0"
	"yyyy'\xeb\x85\x84' M'\xec\x9b\x94' d'\xec\x9d\xbc'\0"
	"yy'\xeb\x85\x84' M'\xec\x9b\x94' d'\xec\x9d\xbc' dddd\0"
	"yy'\xeb\x85\x84' M'\xec\x9b\x94' d'\xec\x9d\xbc'\0"
	"yyyy'\xeb\x85\x84' MM'\xec\x9b\x94' dd'\xec\x9d\xbc' dddd\0"
	"yyyy'\xeb\x85\x84' MM'\xec\x9b\x94' dd'\xec\x9d\xbc'\0"
	"yyyy'\xeb\x85\x84 'MMM'\xec\x9b\x94 'd'\xec\x9d\xbc 'dddd\0"
	"yyyy'\xeb\x85\x84 'MMM'\xec\x9b\x94 'd'\xec\x9d\xbc'\0"
	"yyyy'\xeb\x85\x84 'MMMM d'\xec\x9d\xbc 'dddd\0"
	"yyyy'\xeb\x85\x84 'MMMM d'\xec\x9d\xbc'\0"
	"yyyy'\xeb\x85\x84' M'\xec\x9b\x94'\0"
	"yyyy'\xeb\x85\x84' MMM'\xec\x9b\x94'\0"
	"yyyy'\xeb\x85\x84' MMMM\0"
	"d-M-yyyy\0"
	"dd.MMM.yyyy\0"
	"HH.mm' uur'\0"
	"HH:mm' uur'\0"
	"HH.mm.ss' uur'\0"
	"HH:mm:ss' uur'\0"
	"d.MMMM.\0"
	"d.M.yy\0"
	"dddd, 'ils' d 'da' MMMM yyyy\0"
	"d 'da' MMMM yyyy\0"
	"d.M.yyyy.\0"
	"d.M.yy.\0"
	"d. M. yyyy.\0"
	"dd.MM.yyyy.\0"
	"d. M. yy.\0"
	"dd.MM.yy.\0"
	"dd. MM. yy.\0"
	"d. MMMM yyyy.\0"
	"dd. MMMM yyyy.\0"
	"dddd, d. MMMM yyyy.\0"
	"'den 'd MMMM\0"
	"'den 'd MMMM yyyy\0"
	"dddd' den 'd MMMM yyyy\0"
	"'kl 'H:mm\0"
	"'kl 'H:mm:ss\0"
	"dd MMM yyyy\0"
	"ddd d MMMM yyyy\0"
	"'\xe0\xb8\xa7\xe0\xb8\xb1\xe0\xb8\x99'dddd'\xe0\xb8\x97\xe0\xb8\xb5\xe0\xb9\x88' d MMMM gg yyyy\0"
	"d.MM.yyyy\0"
	"d MMMM yyyy dddd\0"
	"dd MMMM, yyyy\0"
	"dddd, dd MMMM yyyy\0"
	"d MMMM yyyy' \xd1\x80.'\0"
	"MMMM yyyy' \xd1\x80.'\0"
	"MMMM yyyy \xd0\xb3.\0"
	"d. MM. yyyy\0"
	"dddd, dd. MMMM yyyy\0"
	"dd. MMMM yyyy\0"
	"H:mm.ss\0"
	"yyyy. 'gada' d. MMM\0"
	"dddd, yyyy. 'gada' d. MMMM\0"
	"yyyy. 'gada' d. MMMM\0"
	"yyyy. 'g'. MMMM\0"
	"yyyy 'm'. MMMM d 'd'., dddd\0"
	"yyyy 'm'. MMMM d 'd'.\0"
	"yyyy MMMM\0"
	"d MMMM yyyy' \xd1\x81.'\0"
	"dd MMMM yyyy' \xd1\x81.'\0"
	"d/MM/yyyy\0"
	"d/MMM/yyyy\0"
	"d-MMM-yyyy\0"
	"dd-MMM-yyyy\0"
	"ddd, d-MMMM-yyyy\0"
	"ddd, dd-MMMM-yyyy\0"
	"d MMMM yyyy, dddd\0"
	"yyyy MMM d\0"
	"yyyy('e')'ko' MMMM d, dddd\0"
	"yyyy('e')'ko' MMMM d\0"
	"yyyy('e')'ko' MMMM\0"
	"H:mm 'hod\xc5\xba'.\0"
	"dd.M.yyyy\0"
	"MMMM yyyy '\xd0\xb3'.\0"
	"yyyy MMMM d, dddd\0"
	"yyyy MMMM d\0"
	"MMM d, yyyy\0"
	"d MMM, yyyy\0"
	"d 'ta'\xe2\x80\x99 MMMM\0"
	"dddd, d 'ta'\xe2\x80\x99 MMMM yyyy\0"
	"d 'ta'\xe2\x80\x99 MMMM yyyy\0"
	"MMMM 'ta'\xe2\x80\x99 yyyy\0"
	"yyyy, dd-MMM\0"
	"d-MMMM\0"
	"d-MMM yy\0"
	"dd-MMMM yyyy'-\xd0\xb6.'\0"
	"MMMM yyyy'-\xd0\xb6.'\0"
	"dd.MM.yy '\xc3\xbd.'\0"
	"yyyy'-nji \xc3\xbdyly\xc5\x88 'd'-nji 'MMMM\0"
	"yyyy '\xc3\xbd.' MMMM\0"
	"dddd, yyyy MMMM dd\0"
	"dd MMMM yyyy' \xd0\xb5\xd0\xbb'\0"
	"MMMM yyyy' \xd0\xb5\xd0\xbb'\0"
	"tt hh.mm\0"
	"tt h.mm\0"
	"tt hh.mm.ss\0"
	"tt h.mm.ss\0"
	"dd MMMM yyyy dddd\0"
	"MMMM dd\0"
	"yyyy,MMMM dd, dddd\0"
	"MMMM,yy\0"
	"MMMM,yyyy\0"
	"dddd, yyyy '\xd0\xbe\xd0\xbd\xd1\x8b' MM '\xd1\x81\xd0\xb0\xd1\x80\xd1\x8b\xd0\xbd' d\0"
	"yyyy '\xd0\xbe\xd0\xbd\xd1\x8b' MM '\xd1\x81\xd0\xb0\xd1\x80\xd1\x8b\xd0\xbd' d\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8bM\xe0\xbd\x9a\xe0\xbd\xba\xe0\xbd\xa6\xe0\xbc\x8b\x64\0"
	"yyyy'\xe0\xbd\xa3\xe0\xbd\xbc\xe0\xbd\xa0\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x9f\xe0\xbe\xb3' M'\xe0\xbd\x9a\xe0\xbd\xba\xe0\xbd\xa6' d\0"
	"yyyy'\xe0\xbd\xa3\xe0\xbd\xbc\xe0\xbd\xa0\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x9f\xe0\xbe\xb3' M'\xe0\xbd\x9a\xe0\xbd\xba\xe0\xbd\xa6' d dddd\0"
	"yyyy\xe0\xbd\xa3\xe0\xbd\xbc\xe0\xbd\xa0\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x9f\xe0\xbe\xb3 MMM d\0"
	"yyyy\xe0\xbd\xa3\xe0\xbd\xbc\xe0\xbd\xa0\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x9f\xe0\xbe\xb3 MMM d dddd\0"
	"yyyy'\xe0\xbd\xa3\xe0\xbd\xbc\xe0\xbd\xa0\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b' M\0"
	"'\xe1\x9e\x81\xe1\x9f\x82' MM '\xe1\x9e\x86\xe1\x9f\x92\xe1\x9e\x93\xe1\x9e\xb6\xe1\x9f\x86' yyyy\0"
	"dddd \xe0\xba\x97\xe0\xba\xb5 d MMMM gg yyyy\0"
	"dddd\xe1\x81\x8a dd MMMM yyyy\0"
	"dddd, MMMM dd,yyyy\0"
	"MMMM dd,yyyy\0"
	"dddd, MMMM dd, yyyy\0"
	"MMMM dd, yyyy\0"
	"dd. MMMM\0"
	"dd. MMMMyyyy\0"
	"dddd,' den 'd. MMMM yyyy\0"
	"dddd,' den 'dd. MMMM yyyy\0"
	"H.mm' Auer'\0"
	"H:mm:ss' Auer'\0"
	"HH:mm:ss' Auer'\0"
	"MMMM d'.-at'\0"
	"MMMM d'.-at, 'yyyy\0"
	"dddd\xe1\x8d\xa1 dd MMMM \xe1\x88\x98\xe1\x8b\x93\xe1\x88\x8d\xe1\x89\xb2 yyyy gg\0"
	"M\xe2\x80\x99 \xea\x86\xaa\xe2\x80\x99\x64\xe2\x80\x99 \xea\x91\x8d\xe2\x80\x99\0"
	"yyyy'\xea\x88\x8e' M'\xea\x86\xaa' d'\xea\x91\x8d'\0"
	"dddd, yyyy'\xea\x88\x8e' M'\xea\x86\xaa' d'\xea\x91\x8d'\0"
	"yyyy'\xea\x88\x8e' M'\xea\x86\xaa' d'\xea\x91\x8d', dddd\0"
	"yyyy\xea\x88\x8e MMM d\xea\x91\x8d\0"
	"dddd, yyyy\xea\x88\x8e MMM d\xea\x91\x8d\0"
	"yyyy'\xea\x88\x8e' M'\xea\x86\xaa'\0"
	"yyyy-'\xd9\x8a\xd9\x89\xd9\x84' d-MMMM\0"
	"yyyy-'\xd9\x8a\xd9\x89\xd9\x84' d-MMMM dddd\0"
	"yyyy-'\xd9\x8a\xd9\x89\xd9\x84\xd9\x89' MMM'\xd9\x86\xd9\x89\xda\xad' d'-\xd9\x83\xdb\x88\xd9\x86\xd9\x89'\0"
	"yyyy-'\xd9\x8a\xd9\x89\xd9\x84\xd9\x89' MMM'\xd9\x86\xd9\x89\xda\xad' d'-\xd9\x83\xdb\x88\xd9\x86\xd9\x89' dddd\0"
	"yyyy-M-d dddd\0"
	"yyyy-'\xd9\x8a\xd9\x89\xd9\x84\xd9\x89' MMMM\0"
	"MMMM d \xd0\xba\xd2\xaf\xd0\xbd\xd1\x8d\0"
	"yyyy MM d\0"
	"dd yyyy MM d\0"
	"dddd, yyyy '\xd1\x81.' MMMM d '\xd0\xba\xd2\xaf\xd0\xbd\xd1\x8d'\0"
	"yyyy '\xd1\x81.' MMMM d '\xd0\xba\xd2\xaf\xd0\xbd\xd1\x8d'\0"
	"dddd, MMMM d '\xd0\xba\xd2\xaf\xd0\xbd\xd1\x8d' yyyy '\xd1\x81.'\0"
	"yyyy '\xd1\x81.' MMMM\0"
	"d'mh' MMMM\0"
	"dddd, d'mh' MMMM yyyy\0"
	"d'mh' MMMM yyyy\0"
	"dddd yyyy\xe5\xb9\xb4MMMd\xe6\x97\xa5\0"
	"dddd\xe1\x8d\xa3 dd MMMM \xe1\x88\x98\xe1\x8b\x93\xe1\x88\x8d\xe1\x89\xb2 yyyy gg\0"
	"dd.MMMM.\0"
	"dd.MMMM\0"
	"MMMM.yyyy\0"
	"H.mm' u.'\0"
	"yy.MM.dd\0"
	"d MMM yyyy '\xd0\xb3'.\0"
	"dddd, d MMMM yyyy '\xd0\xb3'.\0"
	"d MMMM yyyy '\xd0\xb3'.\0"
	"d. M. yy\0"
	"H:mm' g\xc3\xb3\xc5\xba.'\0"
	"'zeger 'H:mm\0"
	"H:mm:ss' g\xc3\xb3\xc5\xba.'\0"
	"'zeger 'H:mm:ss\0"
	"MMMM d'. b.'\0"
	"dddd, MMMM d'. b. 'yyyy\0"
	"MMMM d'. b. 'yyyy\0"
	"h.mm tt\0"
	"h.mm.ss tt\0"
	"yy MM dd\0"
	"dddd', 'MMMM d'. b. 'yyyy\0"
	"M/dd/yy\0"
	"MMMM-dd-yy\0"
	"dd-MMMM\0"
	"dddd, d 'de' MMMM 'de' yyyy\0"
	"d 'de' MMMM 'de' yyyy\0"
	"d. MMM yyyy.\0"
	"MMMM yyyy.\0"
	"dddd yyyy'\xe5\xb9\xb4'M'\xe6\x9c\x88'd'\xe6\x97\xa5'\0"
	"dddd yyyy MM dd\0"
	"d/MMMM\0"
	"MMMM/yyyy\0"
	"dd. MMM. yyyy.\0"
	"dddd, dd. MMMM yyyy.\0"
	"MMMM/dd\0"
	"dd. MM. yy\0"
	"MMMM d'. p. '\0"
	"MMMM d'. p. 'yyyy\0"
	"MMMM-yyyy\0"
	"dd MMM,yyyy\0"
	"yyyy-MM-dd.\0"
	"dddd dd 'de' MMMM 'de' yyyy\0"
	"dd 'de' MMMM 'de' yyyy\0"
};


static const char datetime_strings [] = {
	"\0"
	"\xd9\x85\xd8\xad\xd8\xb1\xd9\x85\0"
	"\xd8\xb5\xd9\x81\xd8\xb1\0"
	"\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xb9 \xd8\xa7\xd9\x84\xd8\xa3\xd9\x88\xd9\x84\0"
	"\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xb9 \xd8\xa7\xd9\x84\xd8\xa2\xd8\xae\xd8\xb1\0"
	"\xd8\xac\xd9\x85\xd8\xa7\xd8\xaf\xd9\x89 \xd8\xa7\xd9\x84\xd8\xa3\xd9\x88\xd9\x84\xd9\x89\0"
	"\xd8\xac\xd9\x85\xd8\xa7\xd8\xaf\xd9\x89 \xd8\xa7\xd9\x84\xd8\xa2\xd8\xae\xd8\xb1\xd8\xa9\0"
	"\xd8\xb1\xd8\xac\xd8\xa8\0"
	"\xd8\xb4\xd8\xb9\xd8\xa8\xd8\xa7\xd9\x86\0"
	"\xd8\xb1\xd9\x85\xd8\xb6\xd8\xa7\xd9\x86\0"
	"\xd8\xb4\xd9\x88\xd8\xa7\xd9\x84\0"
	"\xd8\xb0\xd9\x88 \xd8\xa7\xd9\x84\xd9\x82\xd8\xb9\xd8\xaf\xd8\xa9\0"
	"\xd8\xb0\xd9\x88 \xd8\xa7\xd9\x84\xd8\xad\xd8\xac\xd8\xa9\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd1\x8f\0"
	"\xd0\xbf\xd0\xbe\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xbd\xd0\xb8\xd0\xba\0"
	"\xd0\xb2\xd1\x82\xd0\xbe\xd1\x80\xd0\xbd\xd0\xb8\xd0\xba\0"
	"\xd1\x81\xd1\x80\xd1\x8f\xd0\xb4\xd0\xb0\0"
	"\xd1\x87\xd0\xb5\xd1\x82\xd0\xb2\xd1\x8a\xd1\x80\xd1\x82\xd1\x8a\xd0\xba\0"
	"\xd0\xbf\xd0\xb5\xd1\x82\xd1\x8a\xd0\xba\0"
	"\xd1\x81\xd1\x8a\xd0\xb1\xd0\xbe\xd1\x82\xd0\xb0\0"
	"\xd0\xbd\xd0\xb4\0"
	"\xd0\xbf\xd0\xbd\0"
	"\xd0\xb2\xd1\x82\0"
	"\xd1\x81\xd1\x80\0"
	"\xd1\x87\xd1\x82\0"
	"\xd0\xbf\xd1\x82\0"
	"\xd1\x81\xd0\xb1\0"
	"\xd0\xbd\0"
	"\xd0\xbf\0"
	"\xd0\xb2\0"
	"\xd1\x81\0"
	"\xd1\x87\0"
	"\xd1\x8f\xd0\xbd\xd1\x83\xd0\xb0\xd1\x80\xd0\xb8\0"
	"\xd1\x84\xd0\xb5\xd0\xb2\xd1\x80\xd1\x83\xd0\xb0\xd1\x80\xd0\xb8\0"
	"\xd0\xbc\xd0\xb0\xd1\x80\xd1\x82\0"
	"\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbb\0"
	"\xd0\xbc\xd0\xb0\xd0\xb9\0"
	"\xd1\x8e\xd0\xbd\xd0\xb8\0"
	"\xd1\x8e\xd0\xbb\xd0\xb8\0"
	"\xd0\xb0\xd0\xb2\xd0\xb3\xd1\x83\xd1\x81\xd1\x82\0"
	"\xd1\x81\xd0\xb5\xd0\xbf\xd1\x82\xd0\xb5\xd0\xbc\xd0\xb2\xd1\x80\xd0\xb8\0"
	"\xd0\xbe\xd0\xba\xd1\x82\xd0\xbe\xd0\xbc\xd0\xb2\xd1\x80\xd0\xb8\0"
	"\xd0\xbd\xd0\xbe\xd0\xb5\xd0\xbc\xd0\xb2\xd1\x80\xd0\xb8\0"
	"\xd0\xb4\xd0\xb5\xd0\xba\xd0\xb5\xd0\xbc\xd0\xb2\xd1\x80\xd0\xb8\0"
	"\xd1\x8f\xd0\xbd\xd1\x83\0"
	"\xd1\x84\xd0\xb5\xd0\xb2\0"
	"\xd0\xb0\xd0\xbf\xd1\x80\0"
	"\xd0\xb0\xd0\xb2\xd0\xb3\0"
	"\xd1\x81\xd0\xb5\xd0\xbf\0"
	"\xd0\xbe\xd0\xba\xd1\x82\0"
	"\xd0\xbd\xd0\xbe\xd0\xb5\0"
	"\xd0\xb4\xd0\xb5\xd0\xba\0"
	"diumenge\0"
	"dilluns\0"
	"dimarts\0"
	"dimecres\0"
	"dijous\0"
	"divendres\0"
	"dissabte\0"
	"dg.\0"
	"dl.\0"
	"dt.\0"
	"dc.\0"
	"dj.\0"
	"dv.\0"
	"ds.\0"
	"dg\0"
	"dl\0"
	"dt\0"
	"dc\0"
	"dj\0"
	"dv\0"
	"ds\0"
	"gener\0"
	"febrer\0"
	"mar\xc3\xa7\0"
	"abril\0"
	"maig\0"
	"juny\0"
	"juliol\0"
	"agost\0"
	"setembre\0"
	"octubre\0"
	"novembre\0"
	"desembre\0"
	"de gener\0"
	"de febrer\0"
	"de mar\xc3\xa7\0"
	"d\xe2\x80\x99\x61\x62ril\0"
	"de maig\0"
	"de juny\0"
	"de juliol\0"
	"d\xe2\x80\x99\x61gost\0"
	"de setembre\0"
	"d\xe2\x80\x99octubre\0"
	"de novembre\0"
	"de desembre\0"
	"gen.\0"
	"febr.\0"
	"abr.\0"
	"jul.\0"
	"ag.\0"
	"set.\0"
	"oct.\0"
	"nov.\0"
	"des.\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe6\x97\xa5\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe4\xb8\x80\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe4\xba\x8c\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe4\xb8\x89\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe5\x9b\x9b\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe4\xba\x94\0"
	"\xe6\x98\x9f\xe6\x9c\x9f\xe5\x85\xad\0"
	"\xe5\x91\xa8\xe6\x97\xa5\0"
	"\xe5\x91\xa8\xe4\xb8\x80\0"
	"\xe5\x91\xa8\xe4\xba\x8c\0"
	"\xe5\x91\xa8\xe4\xb8\x89\0"
	"\xe5\x91\xa8\xe5\x9b\x9b\0"
	"\xe5\x91\xa8\xe4\xba\x94\0"
	"\xe5\x91\xa8\xe5\x85\xad\0"
	"\xe6\x97\xa5\0"
	"\xe4\xb8\x80\0"
	"\xe4\xba\x8c\0"
	"\xe4\xb8\x89\0"
	"\xe5\x9b\x9b\0"
	"\xe4\xba\x94\0"
	"\xe5\x85\xad\0"
	"\xe4\xb8\x80\xe6\x9c\x88\0"
	"\xe4\xba\x8c\xe6\x9c\x88\0"
	"\xe4\xb8\x89\xe6\x9c\x88\0"
	"\xe5\x9b\x9b\xe6\x9c\x88\0"
	"\xe4\xba\x94\xe6\x9c\x88\0"
	"\xe5\x85\xad\xe6\x9c\x88\0"
	"\xe4\xb8\x83\xe6\x9c\x88\0"
	"\xe5\x85\xab\xe6\x9c\x88\0"
	"\xe4\xb9\x9d\xe6\x9c\x88\0"
	"\xe5\x8d\x81\xe6\x9c\x88\0"
	"\xe5\x8d\x81\xe4\xb8\x80\xe6\x9c\x88\0"
	"\xe5\x8d\x81\xe4\xba\x8c\xe6\x9c\x88\0"
	"1\xe6\x9c\x88\0"
	"2\xe6\x9c\x88\0"
	"3\xe6\x9c\x88\0"
	"4\xe6\x9c\x88\0"
	"5\xe6\x9c\x88\0"
	"6\xe6\x9c\x88\0"
	"7\xe6\x9c\x88\0"
	"8\xe6\x9c\x88\0"
	"9\xe6\x9c\x88\0"
	"10\xe6\x9c\x88\0"
	"11\xe6\x9c\x88\0"
	"12\xe6\x9c\x88\0"
	"ned\xc4\x9ble\0"
	"pond\xc4\x9bl\xc3\xad\0"
	"\xc3\xbater\xc3\xbd\0"
	"st\xc5\x99\x65\x64\x61\0"
	"\xc4\x8dtvrtek\0"
	"p\xc3\xa1tek\0"
	"sobota\0"
	"ne\0"
	"po\0"
	"\xc3\xbat\0"
	"st\0"
	"\xc4\x8dt\0"
	"p\xc3\xa1\0"
	"so\0"
	"N\0"
	"P\0"
	"\xc3\x9a\0"
	"S\0"
	"\xc4\x8c\0"
	"leden\0"
	"\xc3\xbanor\0"
	"b\xc5\x99\x65zen\0"
	"duben\0"
	"kv\xc4\x9bten\0"
	"\xc4\x8d\x65rven\0"
	"\xc4\x8d\x65rvenec\0"
	"srpen\0"
	"z\xc3\xa1\xc5\x99\xc3\xad\0"
	"\xc5\x99\xc3\xadjen\0"
	"listopad\0"
	"prosinec\0"
	"ledna\0"
	"\xc3\xbanora\0"
	"b\xc5\x99\x65zna\0"
	"dubna\0"
	"kv\xc4\x9btna\0"
	"\xc4\x8d\x65rvna\0"
	"\xc4\x8d\x65rvence\0"
	"srpna\0"
	"\xc5\x99\xc3\xadjna\0"
	"listopadu\0"
	"prosince\0"
	"led\0"
	"\xc3\xbano\0"
	"b\xc5\x99\x65\0"
	"dub\0"
	"kv\xc4\x9b\0"
	"\xc4\x8dvn\0"
	"\xc4\x8dvc\0"
	"srp\0"
	"z\xc3\xa1\xc5\x99\0"
	"\xc5\x99\xc3\xadj\0"
	"lis\0"
	"pro\0"
	"s\xc3\xb8ndag\0"
	"mandag\0"
	"tirsdag\0"
	"onsdag\0"
	"torsdag\0"
	"fredag\0"
	"l\xc3\xb8rdag\0"
	"s\xc3\xb8n\0"
	"man\0"
	"tir\0"
	"ons\0"
	"tor\0"
	"fre\0"
	"l\xc3\xb8r\0"
	"M\0"
	"T\0"
	"O\0"
	"F\0"
	"L\0"
	"januar\0"
	"februar\0"
	"marts\0"
	"april\0"
	"maj\0"
	"juni\0"
	"juli\0"
	"august\0"
	"september\0"
	"oktober\0"
	"november\0"
	"december\0"
	"jan.\0"
	"feb.\0"
	"mar.\0"
	"apr.\0"
	"jun.\0"
	"aug.\0"
	"sep.\0"
	"okt.\0"
	"dec.\0"
	"Sonntag\0"
	"Montag\0"
	"Dienstag\0"
	"Mittwoch\0"
	"Donnerstag\0"
	"Freitag\0"
	"Samstag\0"
	"So\0"
	"Mo\0"
	"Di\0"
	"Mi\0"
	"Do\0"
	"Fr\0"
	"Sa\0"
	"D\0"
	"Januar\0"
	"Februar\0"
	"M\xc3\xa4rz\0"
	"April\0"
	"Mai\0"
	"Juni\0"
	"Juli\0"
	"August\0"
	"September\0"
	"Oktober\0"
	"November\0"
	"Dezember\0"
	"Jan\0"
	"Feb\0"
	"M\xc3\xa4r\0"
	"Apr\0"
	"Jun\0"
	"Jul\0"
	"Aug\0"
	"Sep\0"
	"Okt\0"
	"Nov\0"
	"Dez\0"
	"\xce\x9a\xcf\x85\xcf\x81\xce\xb9\xce\xb1\xce\xba\xce\xae\0"
	"\xce\x94\xce\xb5\xcf\x85\xcf\x84\xce\xad\xcf\x81\xce\xb1\0"
	"\xce\xa4\xcf\x81\xce\xaf\xcf\x84\xce\xb7\0"
	"\xce\xa4\xce\xb5\xcf\x84\xce\xac\xcf\x81\xcf\x84\xce\xb7\0"
	"\xce\xa0\xce\xad\xce\xbc\xcf\x80\xcf\x84\xce\xb7\0"
	"\xce\xa0\xce\xb1\xcf\x81\xce\xb1\xcf\x83\xce\xba\xce\xb5\xcf\x85\xce\xae\0"
	"\xce\xa3\xce\xac\xce\xb2\xce\xb2\xce\xb1\xcf\x84\xce\xbf\0"
	"\xce\x9a\xcf\x85\xcf\x81\0"
	"\xce\x94\xce\xb5\xcf\x85\0"
	"\xce\xa4\xcf\x81\xce\xaf\0"
	"\xce\xa4\xce\xb5\xcf\x84\0"
	"\xce\xa0\xce\xad\xce\xbc\0"
	"\xce\xa0\xce\xb1\xcf\x81\0"
	"\xce\xa3\xce\xac\xce\xb2\0"
	"\xce\x9a\0"
	"\xce\x94\0"
	"\xce\xa4\0"
	"\xce\xa0\0"
	"\xce\xa3\0"
	"\xce\x99\xce\xb1\xce\xbd\xce\xbf\xcf\x85\xce\xac\xcf\x81\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\xa6\xce\xb5\xce\xb2\xcf\x81\xce\xbf\xcf\x85\xce\xac\xcf\x81\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x9c\xce\xac\xcf\x81\xcf\x84\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x91\xcf\x80\xcf\x81\xce\xaf\xce\xbb\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x9c\xce\xac\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x99\xce\xbf\xcf\x8d\xce\xbd\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x99\xce\xbf\xcf\x8d\xce\xbb\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x91\xcf\x8d\xce\xb3\xce\xbf\xcf\x85\xcf\x83\xcf\x84\xce\xbf\xcf\x82\0"
	"\xce\xa3\xce\xb5\xcf\x80\xcf\x84\xce\xad\xce\xbc\xce\xb2\xcf\x81\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x9f\xce\xba\xcf\x84\xcf\x8e\xce\xb2\xcf\x81\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x9d\xce\xbf\xce\xad\xce\xbc\xce\xb2\xcf\x81\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x94\xce\xb5\xce\xba\xce\xad\xce\xbc\xce\xb2\xcf\x81\xce\xb9\xce\xbf\xcf\x82\0"
	"\xce\x99\xce\xb1\xce\xbd\xce\xbf\xcf\x85\xce\xb1\xcf\x81\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\xa6\xce\xb5\xce\xb2\xcf\x81\xce\xbf\xcf\x85\xce\xb1\xcf\x81\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x9c\xce\xb1\xcf\x81\xcf\x84\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x91\xcf\x80\xcf\x81\xce\xb9\xce\xbb\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x9c\xce\xb1\xce\x90\xce\xbf\xcf\x85\0"
	"\xce\x99\xce\xbf\xcf\x85\xce\xbd\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x99\xce\xbf\xcf\x85\xce\xbb\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x91\xcf\x85\xce\xb3\xce\xbf\xcf\x8d\xcf\x83\xcf\x84\xce\xbf\xcf\x85\0"
	"\xce\xa3\xce\xb5\xcf\x80\xcf\x84\xce\xb5\xce\xbc\xce\xb2\xcf\x81\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x9f\xce\xba\xcf\x84\xcf\x89\xce\xb2\xcf\x81\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x9d\xce\xbf\xce\xb5\xce\xbc\xce\xb2\xcf\x81\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x94\xce\xb5\xce\xba\xce\xb5\xce\xbc\xce\xb2\xcf\x81\xce\xaf\xce\xbf\xcf\x85\0"
	"\xce\x99\xce\xb1\xce\xbd\0"
	"\xce\xa6\xce\xb5\xce\xb2\0"
	"\xce\x9c\xce\xac\xcf\x81\0"
	"\xce\x91\xcf\x80\xcf\x81\0"
	"\xce\x9c\xce\xac\xce\xb9\0"
	"\xce\x99\xce\xbf\xcf\x8d\xce\xbd\0"
	"\xce\x99\xce\xbf\xcf\x8d\xce\xbb\0"
	"\xce\x91\xcf\x8d\xce\xb3\0"
	"\xce\xa3\xce\xb5\xcf\x80\0"
	"\xce\x9f\xce\xba\xcf\x84\0"
	"\xce\x9d\xce\xbf\xce\xad\0"
	"\xce\x94\xce\xb5\xce\xba\0"
	"Sunday\0"
	"Monday\0"
	"Tuesday\0"
	"Wednesday\0"
	"Thursday\0"
	"Friday\0"
	"Saturday\0"
	"Sun\0"
	"Mon\0"
	"Tue\0"
	"Wed\0"
	"Thu\0"
	"Fri\0"
	"Sat\0"
	"W\0"
	"January\0"
	"February\0"
	"March\0"
	"May\0"
	"June\0"
	"July\0"
	"October\0"
	"December\0"
	"Mar\0"
	"Oct\0"
	"Dec\0"
	"domingo\0"
	"lunes\0"
	"martes\0"
	"mi\xc3\xa9rcoles\0"
	"jueves\0"
	"viernes\0"
	"s\xc3\xa1\x62\x61\x64o\0"
	"dom.\0"
	"lun.\0"
	"mi\xc3\xa9.\0"
	"jue.\0"
	"vie.\0"
	"s\xc3\xa1\x62.\0"
	"X\0"
	"J\0"
	"V\0"
	"enero\0"
	"febrero\0"
	"marzo\0"
	"mayo\0"
	"junio\0"
	"julio\0"
	"agosto\0"
	"septiembre\0"
	"noviembre\0"
	"diciembre\0"
	"ene.\0"
	"may.\0"
	"ago.\0"
	"sept.\0"
	"dic.\0"
	"sunnuntaina\0"
	"maanantaina\0"
	"tiistaina\0"
	"keskiviikkona\0"
	"torstaina\0"
	"perjantaina\0"
	"lauantaina\0"
	"su\0"
	"ma\0"
	"ti\0"
	"ke\0"
	"to\0"
	"pe\0"
	"la\0"
	"K\0"
	"tammikuu\0"
	"helmikuu\0"
	"maaliskuu\0"
	"huhtikuu\0"
	"toukokuu\0"
	"kes\xc3\xa4kuu\0"
	"hein\xc3\xa4kuu\0"
	"elokuu\0"
	"syyskuu\0"
	"lokakuu\0"
	"marraskuu\0"
	"joulukuu\0"
	"tammikuuta\0"
	"helmikuuta\0"
	"maaliskuuta\0"
	"huhtikuuta\0"
	"toukokuuta\0"
	"kes\xc3\xa4kuuta\0"
	"hein\xc3\xa4kuuta\0"
	"elokuuta\0"
	"syyskuuta\0"
	"lokakuuta\0"
	"marraskuuta\0"
	"joulukuuta\0"
	"tammi\0"
	"helmi\0"
	"maalis\0"
	"huhti\0"
	"touko\0"
	"kes\xc3\xa4\0"
	"hein\xc3\xa4\0"
	"elo\0"
	"syys\0"
	"loka\0"
	"marras\0"
	"joulu\0"
	"dimanche\0"
	"lundi\0"
	"mardi\0"
	"mercredi\0"
	"jeudi\0"
	"vendredi\0"
	"samedi\0"
	"dim.\0"
	"mer.\0"
	"jeu.\0"
	"ven.\0"
	"sam.\0"
	"janvier\0"
	"f\xc3\xa9vrier\0"
	"mars\0"
	"avril\0"
	"mai\0"
	"juin\0"
	"juillet\0"
	"ao\xc3\xbbt\0"
	"septembre\0"
	"octobre\0"
	"d\xc3\xa9\x63\x65mbre\0"
	"janv.\0"
	"f\xc3\xa9vr.\0"
	"avr.\0"
	"juil.\0"
	"d\xc3\xa9\x63.\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\xa8\xd7\x90\xd7\xa9\xd7\x95\xd7\x9f\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\xa9\xd7\xa0\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\xa9\xd7\x9c\xd7\x99\xd7\xa9\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\xa8\xd7\x91\xd7\x99\xd7\xa2\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x97\xd7\x9e\xd7\x99\xd7\xa9\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\xa9\xd7\x99\xd7\xa9\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\xa9\xd7\x91\xd7\xaa\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x90\xd7\xb3\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x91\xd7\xb3\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x92\xd7\xb3\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x93\xd7\xb3\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x94\xd7\xb3\0"
	"\xd7\x99\xd7\x95\xd7\x9d \xd7\x95\xd7\xb3\0"
	"\xd7\xa9\xd7\x91\xd7\xaa\0"
	"\xd7\x90\xd7\xb3\0"
	"\xd7\x91\xd7\xb3\0"
	"\xd7\x92\xd7\xb3\0"
	"\xd7\x93\xd7\xb3\0"
	"\xd7\x94\xd7\xb3\0"
	"\xd7\x95\xd7\xb3\0"
	"\xd7\xa9\xd7\xb3\0"
	"\xd7\x99\xd7\xa0\xd7\x95\xd7\x90\xd7\xa8\0"
	"\xd7\xa4\xd7\x91\xd7\xa8\xd7\x95\xd7\x90\xd7\xa8\0"
	"\xd7\x9e\xd7\xa8\xd7\xa5\0"
	"\xd7\x90\xd7\xa4\xd7\xa8\xd7\x99\xd7\x9c\0"
	"\xd7\x9e\xd7\x90\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\xa0\xd7\x99\0"
	"\xd7\x99\xd7\x95\xd7\x9c\xd7\x99\0"
	"\xd7\x90\xd7\x95\xd7\x92\xd7\x95\xd7\xa1\xd7\x98\0"
	"\xd7\xa1\xd7\xa4\xd7\x98\xd7\x9e\xd7\x91\xd7\xa8\0"
	"\xd7\x90\xd7\x95\xd7\xa7\xd7\x98\xd7\x95\xd7\x91\xd7\xa8\0"
	"\xd7\xa0\xd7\x95\xd7\x91\xd7\x9e\xd7\x91\xd7\xa8\0"
	"\xd7\x93\xd7\xa6\xd7\x9e\xd7\x91\xd7\xa8\0"
	"\xd7\x99\xd7\xa0\xd7\x95\xd7\xb3\0"
	"\xd7\xa4\xd7\x91\xd7\xa8\xd7\xb3\0"
	"\xd7\x90\xd7\xa4\xd7\xa8\xd7\xb3\0"
	"\xd7\x90\xd7\x95\xd7\x92\xd7\xb3\0"
	"\xd7\xa1\xd7\xa4\xd7\x98\xd7\xb3\0"
	"\xd7\x90\xd7\x95\xd7\xa7\xd7\xb3\0"
	"\xd7\xa0\xd7\x95\xd7\x91\xd7\xb3\0"
	"\xd7\x93\xd7\xa6\xd7\x9e\xd7\xb3\0"
	"vas\xc3\xa1rnap\0"
	"h\xc3\xa9tf\xc5\x91\0"
	"kedd\0"
	"szerda\0"
	"cs\xc3\xbct\xc3\xb6rt\xc3\xb6k\0"
	"p\xc3\xa9ntek\0"
	"szombat\0"
	"H\0"
	"Sze\0"
	"Cs\0"
	"Szo\0"
	"Sz\0"
	"janu\xc3\xa1r\0"
	"febru\xc3\xa1r\0"
	"m\xc3\xa1rcius\0"
	"\xc3\xa1prilis\0"
	"m\xc3\xa1jus\0"
	"j\xc3\xbanius\0"
	"j\xc3\xbalius\0"
	"augusztus\0"
	"szeptember\0"
	"okt\xc3\xb3\x62\x65r\0"
	"m\xc3\xa1rc.\0"
	"\xc3\xa1pr.\0"
	"m\xc3\xa1j.\0"
	"j\xc3\xban.\0"
	"j\xc3\xbal.\0"
	"szept.\0"
	"sunnudagur\0"
	"m\xc3\xa1nudagur\0"
	"\xc3\xberi\xc3\xb0judagur\0"
	"mi\xc3\xb0vikudagur\0"
	"fimmtudagur\0"
	"f\xc3\xb6studagur\0"
	"laugardagur\0"
	"sun.\0"
	"m\xc3\xa1n.\0"
	"\xc3\xberi.\0"
	"mi\xc3\xb0.\0"
	"fim.\0"
	"f\xc3\xb6s.\0"
	"lau.\0"
	"\xc3\x9e\0"
	"jan\xc3\xba\x61r\0"
	"febr\xc3\xba\x61r\0"
	"apr\xc3\xadl\0"
	"ma\xc3\xad\0"
	"j\xc3\xban\xc3\xad\0"
	"j\xc3\xbal\xc3\xad\0"
	"\xc3\xa1g\xc3\xbast\0"
	"n\xc3\xb3vember\0"
	"desember\0"
	"\xc3\xa1g\xc3\xba.\0"
	"n\xc3\xb3v.\0"
	"domenica\0"
	"luned\xc3\xac\0"
	"marted\xc3\xac\0"
	"mercoled\xc3\xac\0"
	"gioved\xc3\xac\0"
	"venerd\xc3\xac\0"
	"sabato\0"
	"dom\0"
	"lun\0"
	"mar\0"
	"mer\0"
	"gio\0"
	"ven\0"
	"sab\0"
	"G\0"
	"gennaio\0"
	"febbraio\0"
	"aprile\0"
	"maggio\0"
	"giugno\0"
	"luglio\0"
	"settembre\0"
	"ottobre\0"
	"dicembre\0"
	"gen\0"
	"feb\0"
	"apr\0"
	"mag\0"
	"giu\0"
	"lug\0"
	"ago\0"
	"set\0"
	"ott\0"
	"nov\0"
	"dic\0"
	"\xe6\x97\xa5\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe6\x9c\x88\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe7\x81\xab\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe6\xb0\xb4\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe6\x9c\xa8\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe9\x87\x91\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe5\x9c\x9f\xe6\x9b\x9c\xe6\x97\xa5\0"
	"\xe6\x9c\x88\0"
	"\xe7\x81\xab\0"
	"\xe6\xb0\xb4\0"
	"\xe6\x9c\xa8\0"
	"\xe9\x87\x91\0"
	"\xe5\x9c\x9f\0"
	"1\0"
	"2\0"
	"3\0"
	"4\0"
	"5\0"
	"6\0"
	"7\0"
	"8\0"
	"9\0"
	"10\0"
	"11\0"
	"12\0"
	"\xec\x9d\xbc\xec\x9a\x94\xec\x9d\xbc\0"
	"\xec\x9b\x94\xec\x9a\x94\xec\x9d\xbc\0"
	"\xed\x99\x94\xec\x9a\x94\xec\x9d\xbc\0"
	"\xec\x88\x98\xec\x9a\x94\xec\x9d\xbc\0"
	"\xeb\xaa\xa9\xec\x9a\x94\xec\x9d\xbc\0"
	"\xea\xb8\x88\xec\x9a\x94\xec\x9d\xbc\0"
	"\xed\x86\xa0\xec\x9a\x94\xec\x9d\xbc\0"
	"\xec\x9d\xbc\0"
	"\xec\x9b\x94\0"
	"\xed\x99\x94\0"
	"\xec\x88\x98\0"
	"\xeb\xaa\xa9\0"
	"\xea\xb8\x88\0"
	"\xed\x86\xa0\0"
	"1\xec\x9b\x94\0"
	"2\xec\x9b\x94\0"
	"3\xec\x9b\x94\0"
	"4\xec\x9b\x94\0"
	"5\xec\x9b\x94\0"
	"6\xec\x9b\x94\0"
	"7\xec\x9b\x94\0"
	"8\xec\x9b\x94\0"
	"9\xec\x9b\x94\0"
	"10\xec\x9b\x94\0"
	"11\xec\x9b\x94\0"
	"12\xec\x9b\x94\0"
	"zondag\0"
	"maandag\0"
	"dinsdag\0"
	"woensdag\0"
	"donderdag\0"
	"vrijdag\0"
	"zaterdag\0"
	"zo\0"
	"di\0"
	"wo\0"
	"do\0"
	"vr\0"
	"za\0"
	"Z\0"
	"januari\0"
	"februari\0"
	"maart\0"
	"mei\0"
	"augustus\0"
	"mrt.\0"
	"s\xc3\xb8n.\0"
	"man.\0"
	"tir.\0"
	"ons.\0"
	"tor.\0"
	"fre.\0"
	"l\xc3\xb8r.\0"
	"jan\0"
	"jun\0"
	"jul\0"
	"aug\0"
	"sep\0"
	"okt\0"
	"des\0"
	"niedziela\0"
	"poniedzia\xc5\x82\x65k\0"
	"wtorek\0"
	"\xc5\x9broda\0"
	"czwartek\0"
	"pi\xc4\x85tek\0"
	"niedz.\0"
	"pon.\0"
	"wt.\0"
	"\xc5\x9br.\0"
	"czw.\0"
	"pt.\0"
	"sob.\0"
	"\xc5\x9a\0"
	"C\0"
	"stycze\xc5\x84\0"
	"luty\0"
	"marzec\0"
	"kwiecie\xc5\x84\0"
	"czerwiec\0"
	"lipiec\0"
	"sierpie\xc5\x84\0"
	"wrzesie\xc5\x84\0"
	"pa\xc5\xba\x64ziernik\0"
	"grudzie\xc5\x84\0"
	"stycznia\0"
	"lutego\0"
	"marca\0"
	"kwietnia\0"
	"maja\0"
	"czerwca\0"
	"lipca\0"
	"sierpnia\0"
	"wrze\xc5\x9bnia\0"
	"pa\xc5\xba\x64ziernika\0"
	"listopada\0"
	"grudnia\0"
	"sty\0"
	"lut\0"
	"kwi\0"
	"cze\0"
	"lip\0"
	"sie\0"
	"wrz\0"
	"pa\xc5\xba\0"
	"gru\0"
	"segunda-feira\0"
	"ter\xc3\xa7\x61-feira\0"
	"quarta-feira\0"
	"quinta-feira\0"
	"sexta-feira\0"
	"seg\0"
	"ter\0"
	"qua\0"
	"qui\0"
	"sex\0"
	"s\xc3\xa1\x62\0"
	"Q\0"
	"janeiro\0"
	"fevereiro\0"
	"mar\xc3\xa7o\0"
	"maio\0"
	"junho\0"
	"julho\0"
	"setembro\0"
	"outubro\0"
	"novembro\0"
	"dezembro\0"
	"fev\0"
	"abr\0"
	"out\0"
	"dez\0"
	"dumengia\0"
	"glindesdi\0"
	"mesemna\0"
	"gievgia\0"
	"venderdi\0"
	"sonda\0"
	"du\0"
	"gli\0"
	"me\0"
	"gie\0"
	"ve\0"
	"schaner\0"
	"favrer\0"
	"avrigl\0"
	"matg\0"
	"zercladur\0"
	"fanadur\0"
	"avust\0"
	"settember\0"
	"october\0"
	"schan.\0"
	"favr.\0"
	"zercl.\0"
	"fan.\0"
	"sett.\0"
	"duminic\xc4\x83\0"
	"luni\0"
	"mar\xc8\x9bi\0"
	"miercuri\0"
	"joi\0"
	"vineri\0"
	"s\xc3\xa2mb\xc4\x83t\xc4\x83\0"
	"dum.\0"
	"mie.\0"
	"vin.\0"
	"s\xc3\xa2m.\0"
	"ianuarie\0"
	"februarie\0"
	"martie\0"
	"aprilie\0"
	"iunie\0"
	"iulie\0"
	"septembrie\0"
	"octombrie\0"
	"noiembrie\0"
	"decembrie\0"
	"ian.\0"
	"iun.\0"
	"iul.\0"
	"\xd0\xb2\xd0\xbe\xd1\x81\xd0\xba\xd1\x80\xd0\xb5\xd1\x81\xd0\xb5\xd0\xbd\xd1\x8c\xd0\xb5\0"
	"\xd0\xbf\xd0\xbe\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xb8\xd0\xba\0"
	"\xd1\x81\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb0\0"
	"\xd1\x87\xd0\xb5\xd1\x82\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb3\0"
	"\xd0\xbf\xd1\x8f\xd1\x82\xd0\xbd\xd0\xb8\xd1\x86\xd0\xb0\0"
	"\xd1\x81\xd1\x83\xd0\xb1\xd0\xb1\xd0\xbe\xd1\x82\xd0\xb0\0"
	"\xd0\xb2\xd1\x81\0"
	"\xd0\x92\0"
	"\xd0\x9f\0"
	"\xd0\xa1\0"
	"\xd0\xa7\0"
	"\xd1\x8f\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\xd1\x8c\0"
	"\xd1\x84\xd0\xb5\xd0\xb2\xd1\x80\xd0\xb0\xd0\xbb\xd1\x8c\0"
	"\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb5\xd0\xbb\xd1\x8c\0"
	"\xd0\xb8\xd1\x8e\xd0\xbd\xd1\x8c\0"
	"\xd0\xb8\xd1\x8e\xd0\xbb\xd1\x8c\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd0\xbe\xd0\xba\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd0\xbd\xd0\xbe\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd0\xb4\xd0\xb5\xd0\xba\xd0\xb0\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd1\x8f\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\xd1\x8f\0"
	"\xd1\x84\xd0\xb5\xd0\xb2\xd1\x80\xd0\xb0\xd0\xbb\xd1\x8f\0"
	"\xd0\xbc\xd0\xb0\xd1\x80\xd1\x82\xd0\xb0\0"
	"\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb5\xd0\xbb\xd1\x8f\0"
	"\xd0\xbc\xd0\xb0\xd1\x8f\0"
	"\xd0\xb8\xd1\x8e\xd0\xbd\xd1\x8f\0"
	"\xd0\xb8\xd1\x8e\xd0\xbb\xd1\x8f\0"
	"\xd0\xb0\xd0\xb2\xd0\xb3\xd1\x83\xd1\x81\xd1\x82\xd0\xb0\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8f\0"
	"\xd0\xbe\xd0\xba\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8f\0"
	"\xd0\xbd\xd0\xbe\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8f\0"
	"\xd0\xb4\xd0\xb5\xd0\xba\xd0\xb0\xd0\xb1\xd1\x80\xd1\x8f\0"
	"\xd1\x8f\xd0\xbd\xd0\xb2.\0"
	"\xd1\x84\xd0\xb5\xd0\xb2\xd1\x80.\0"
	"\xd0\xb0\xd0\xbf\xd1\x80.\0"
	"\xd0\xb0\xd0\xb2\xd0\xb3.\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\xd1\x82.\0"
	"\xd0\xbe\xd0\xba\xd1\x82.\0"
	"\xd0\xbd\xd0\xbe\xd1\x8f\xd0\xb1.\0"
	"\xd0\xb4\xd0\xb5\xd0\xba.\0"
	"nedjelja\0"
	"ponedjeljak\0"
	"utorak\0"
	"srijeda\0"
	"\xc4\x8d\x65tvrtak\0"
	"petak\0"
	"subota\0"
	"ned\0"
	"pon\0"
	"uto\0"
	"sri\0"
	"\xc4\x8d\x65t\0"
	"pet\0"
	"sub\0"
	"n\0"
	"p\0"
	"u\0"
	"s\0"
	"\xc4\x8d\0"
	"sije\xc4\x8d\x61nj\0"
	"velja\xc4\x8d\x61\0"
	"o\xc5\xbeujak\0"
	"travanj\0"
	"svibanj\0"
	"lipanj\0"
	"srpanj\0"
	"kolovoz\0"
	"rujan\0"
	"studeni\0"
	"prosinac\0"
	"sije\xc4\x8dnja\0"
	"velja\xc4\x8d\x65\0"
	"o\xc5\xbeujka\0"
	"travnja\0"
	"svibnja\0"
	"lipnja\0"
	"srpnja\0"
	"kolovoza\0"
	"rujna\0"
	"studenoga\0"
	"prosinca\0"
	"sij\0"
	"velj\0"
	"o\xc5\xbeu\0"
	"tra\0"
	"svi\0"
	"kol\0"
	"ruj\0"
	"stu\0"
	"nede\xc4\xbe\x61\0"
	"pondelok\0"
	"utorok\0"
	"streda\0"
	"\xc5\xa1tvrtok\0"
	"piatok\0"
	"ut\0"
	"\xc5\xa1t\0"
	"pi\0"
	"\xc5\xa1\0"
	"marec\0"
	"m\xc3\xa1j\0"
	"j\xc3\xban\0"
	"j\xc3\xbal\0"
	"janu\xc3\xa1ra\0"
	"febru\xc3\xa1ra\0"
	"apr\xc3\xadla\0"
	"m\xc3\xa1ja\0"
	"j\xc3\xbana\0"
	"j\xc3\xbala\0"
	"augusta\0"
	"septembra\0"
	"okt\xc3\xb3\x62ra\0"
	"novembra\0"
	"decembra\0"
	"dec\0"
	"e diel\0"
	"e h\xc3\xabn\xc3\xab\0"
	"e mart\xc3\xab\0"
	"e m\xc3\xabrkur\xc3\xab\0"
	"e enjte\0"
	"e premte\0"
	"e shtun\xc3\xab\0"
	"Die\0"
	"H\xc3\xabn\0"
	"M\xc3\xabr\0"
	"Enj\0"
	"Pre\0"
	"Sht\0"
	"E\0"
	"Janar\0"
	"Shkurt\0"
	"Mars\0"
	"Prill\0"
	"Maj\0"
	"Qershor\0"
	"Korrik\0"
	"Gusht\0"
	"Shtator\0"
	"Tetor\0"
	"N\xc3\xabntor\0"
	"Dhjetor\0"
	"janar\0"
	"shkurt\0"
	"prill\0"
	"qershor\0"
	"korrik\0"
	"gusht\0"
	"shtator\0"
	"tetor\0"
	"n\xc3\xabntor\0"
	"dhjetor\0"
	"Shk\0"
	"Pri\0"
	"Qer\0"
	"Kor\0"
	"Gsh\0"
	"Tet\0"
	"N\xc3\xabn\0"
	"Dhj\0"
	"s\xc3\xb6ndag\0"
	"m\xc3\xa5ndag\0"
	"tisdag\0"
	"l\xc3\xb6rdag\0"
	"s\xc3\xb6n\0"
	"m\xc3\xa5n\0"
	"tis\0"
	"tors\0"
	"l\xc3\xb6r\0"
	"augusti\0"
	"Pazar\0"
	"Pazartesi\0"
	"Sal\xc4\xb1\0"
	"\xc3\x87\x61r\xc5\x9f\x61mba\0"
	"Per\xc5\x9f\x65mbe\0"
	"Cuma\0"
	"Cumartesi\0"
	"Paz\0"
	"Pzt\0"
	"Sal\0"
	"\xc3\x87\x61r\0"
	"Per\0"
	"Cum\0"
	"Cmt\0"
	"\xc3\x87\0"
	"Ocak\0"
	"\xc5\x9eubat\0"
	"Mart\0"
	"Nisan\0"
	"May\xc4\xb1s\0"
	"Haziran\0"
	"Temmuz\0"
	"A\xc4\x9fustos\0"
	"Eyl\xc3\xbcl\0"
	"Ekim\0"
	"Kas\xc4\xb1m\0"
	"Aral\xc4\xb1k\0"
	"Oca\0"
	"\xc5\x9eub\0"
	"Nis\0"
	"Haz\0"
	"Tem\0"
	"A\xc4\x9fu\0"
	"Eyl\0"
	"Eki\0"
	"Kas\0"
	"Ara\0"
	"\xd8\xa7\xd8\xaa\xd9\x88\xd8\xa7\xd8\xb1\0"
	"\xd8\xb3\xd9\x88\xd9\x85\xd9\x88\xd8\xa7\xd8\xb1\0"
	"\xd9\x85\xd9\x86\xda\xaf\xd9\x84\0"
	"\xd8\xa8\xd8\xaf\xda\xbe\0"
	"\xd8\xac\xd9\x85\xd8\xb9\xd8\xb1\xd8\xa7\xd8\xaa\0"
	"\xd8\xac\xd9\x85\xd8\xb9\xdb\x81\0"
	"\xdb\x81\xd9\x81\xd8\xaa\xdb\x81\0"
	"\xd8\xac\xd9\x86\xd9\x88\xd8\xb1\xdb\x8c\0"
	"\xd9\x81\xd8\xb1\xd9\x88\xd8\xb1\xdb\x8c\0"
	"\xd9\x85\xd8\xa7\xd8\xb1\xda\x86\0"
	"\xd8\xa7\xd9\xbe\xd8\xb1\xdb\x8c\xd9\x84\0"
	"\xd9\x85\xd8\xa6\xdb\x8c\0"
	"\xd8\xac\xd9\x88\xd9\x86\0"
	"\xd8\xac\xd9\x88\xd9\x84\xd8\xa7\xd8\xa6\xdb\x8c\0"
	"\xd8\xa7\xda\xaf\xd8\xb3\xd8\xaa\0"
	"\xd8\xb3\xd8\xaa\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xd8\xa7\xda\xa9\xd8\xaa\xd9\x88\xd8\xa8\xd8\xb1\0"
	"\xd9\x86\xd9\x88\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xd8\xaf\xd8\xb3\xd9\x85\xd8\xa8\xd8\xb1\0"
	"Minggu\0"
	"Senin\0"
	"Selasa\0"
	"Rabu\0"
	"Kamis\0"
	"Jumat\0"
	"Sabtu\0"
	"Min\0"
	"Sen\0"
	"Sel\0"
	"Rab\0"
	"Kam\0"
	"Jum\0"
	"Sab\0"
	"R\0"
	"Januari\0"
	"Februari\0"
	"Maret\0"
	"Mei\0"
	"Agustus\0"
	"Desember\0"
	"Agt\0"
	"Des\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4\xd1\x96\xd0\xbb\xd1\x8f\0"
	"\xd0\xbf\xd0\xbe\xd0\xbd\xd0\xb5\xd0\xb4\xd1\x96\xd0\xbb\xd0\xbe\xd0\xba\0"
	"\xd0\xb2\xd1\x96\xd0\xb2\xd1\x82\xd0\xbe\xd1\x80\xd0\xbe\xd0\xba\0"
	"\xd1\x81\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb0\0"
	"\xd1\x87\xd0\xb5\xd1\x82\xd0\xb2\xd0\xb5\xd1\x80\0"
	"\xd0\xbf\xca\xbc\xd1\x8f\xd1\x82\xd0\xbd\xd0\xb8\xd1\x86\xd1\x8f\0"
	"\xd1\x81\xd1\x83\xd0\xb1\xd0\xbe\xd1\x82\xd0\xb0\0"
	"\xd0\x9d\0"
	"\xd1\x81\xd1\x96\xd1\x87\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xbb\xd1\x8e\xd1\x82\xd0\xb8\xd0\xb9\0"
	"\xd0\xb1\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb7\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xba\xd0\xb2\xd1\x96\xd1\x82\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd1\x82\xd1\x80\xd0\xb0\xd0\xb2\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd1\x87\xd0\xb5\xd1\x80\xd0\xb2\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xbb\xd0\xb8\xd0\xbf\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd1\x81\xd0\xb5\xd1\x80\xd0\xbf\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb5\xd1\x81\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xb6\xd0\xbe\xd0\xb2\xd1\x82\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xbb\xd0\xb8\xd1\x81\xd1\x82\xd0\xbe\xd0\xbf\xd0\xb0\xd0\xb4\0"
	"\xd0\xb3\xd1\x80\xd1\x83\xd0\xb4\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd1\x81\xd1\x96\xd1\x87\xd0\xbd\xd1\x8f\0"
	"\xd0\xbb\xd1\x8e\xd1\x82\xd0\xbe\xd0\xb3\xd0\xbe\0"
	"\xd0\xb1\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb7\xd0\xbd\xd1\x8f\0"
	"\xd0\xba\xd0\xb2\xd1\x96\xd1\x82\xd0\xbd\xd1\x8f\0"
	"\xd1\x82\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbd\xd1\x8f\0"
	"\xd1\x87\xd0\xb5\xd1\x80\xd0\xb2\xd0\xbd\xd1\x8f\0"
	"\xd0\xbb\xd0\xb8\xd0\xbf\xd0\xbd\xd1\x8f\0"
	"\xd1\x81\xd0\xb5\xd1\x80\xd0\xbf\xd0\xbd\xd1\x8f\0"
	"\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb5\xd1\x81\xd0\xbd\xd1\x8f\0"
	"\xd0\xb6\xd0\xbe\xd0\xb2\xd1\x82\xd0\xbd\xd1\x8f\0"
	"\xd0\xbb\xd0\xb8\xd1\x81\xd1\x82\xd0\xbe\xd0\xbf\xd0\xb0\xd0\xb4\xd0\xb0\0"
	"\xd0\xb3\xd1\x80\xd1\x83\xd0\xb4\xd0\xbd\xd1\x8f\0"
	"\xd1\x81\xd1\x96\xd1\x87\0"
	"\xd0\xbb\xd1\x8e\xd1\x82\0"
	"\xd0\xb1\xd0\xb5\xd1\x80\0"
	"\xd0\xba\xd0\xb2\xd1\x96\0"
	"\xd1\x82\xd1\x80\xd0\xb0\0"
	"\xd1\x87\xd0\xb5\xd1\x80\0"
	"\xd0\xbb\xd0\xb8\xd0\xbf\0"
	"\xd1\x81\xd0\xb5\xd1\x80\0"
	"\xd0\xb2\xd0\xb5\xd1\x80\0"
	"\xd0\xb6\xd0\xbe\xd0\xb2\0"
	"\xd0\xbb\xd0\xb8\xd1\x81\0"
	"\xd0\xb3\xd1\x80\xd1\x83\0"
	"\xd0\xbd\xd1\x8f\xd0\xb4\xd0\xb7\xd0\xb5\xd0\xbb\xd1\x8f\0"
	"\xd0\xbf\xd0\xb0\xd0\xbd\xd1\x8f\xd0\xb4\xd0\xb7\xd0\xb5\xd0\xbb\xd0\xb0\xd0\xba\0"
	"\xd0\xb0\xd1\x9e\xd1\x82\xd0\xbe\xd1\x80\xd0\xb0\xd0\xba\0"
	"\xd1\x81\xd0\xb5\xd1\x80\xd0\xb0\xd0\xb4\xd0\xb0\0"
	"\xd1\x87\xd0\xb0\xd1\x86\xd0\xb2\xd0\xb5\xd1\x80\0"
	"\xd0\xbf\xd1\x8f\xd1\x82\xd0\xbd\xd1\x96\xd1\x86\xd0\xb0\0"
	"\xd0\xb0\xd1\x9e\0"
	"\xd1\x87\xd1\x86\0"
	"\xd0\xb0\0"
	"\xd1\x81\xd1\x82\xd1\x83\xd0\xb4\xd0\xb7\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xbb\xd1\x8e\xd1\x82\xd1\x8b\0"
	"\xd1\x81\xd0\xb0\xd0\xba\xd0\xb0\xd0\xb2\xd1\x96\xd0\xba\0"
	"\xd0\xba\xd1\x80\xd0\xb0\xd1\x81\xd0\xb0\xd0\xb2\xd1\x96\xd0\xba\0"
	"\xd1\x87\xd1\x8d\xd1\x80\xd0\xb2\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xbb\xd1\x96\xd0\xbf\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xb6\xd0\xbd\xd1\x96\xd0\xb2\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb0\xd1\x81\xd0\xb5\xd0\xbd\xd1\x8c\0"
	"\xd0\xba\xd0\xb0\xd1\x81\xd1\x82\xd1\x80\xd1\x8b\xd1\x87\xd0\xbd\xd1\x96\xd0\xba\0"
	"\xd0\xbb\xd1\x96\xd1\x81\xd1\x82\xd0\xb0\xd0\xbf\xd0\xb0\xd0\xb4\0"
	"\xd1\x81\xd0\xbd\xd0\xb5\xd0\xb6\xd0\xb0\xd0\xbd\xd1\x8c\0"
	"\xd1\x81\xd1\x82\xd1\x83\xd0\xb4\xd0\xb7\xd0\xb5\xd0\xbd\xd1\x8f\0"
	"\xd0\xbb\xd1\x8e\xd1\x82\xd0\xb0\xd0\xb3\xd0\xb0\0"
	"\xd1\x81\xd0\xb0\xd0\xba\xd0\xb0\xd0\xb2\xd1\x96\xd0\xba\xd0\xb0\0"
	"\xd0\xba\xd1\x80\xd0\xb0\xd1\x81\xd0\xb0\xd0\xb2\xd1\x96\xd0\xba\xd0\xb0\0"
	"\xd1\x87\xd1\x8d\xd1\x80\xd0\xb2\xd0\xb5\xd0\xbd\xd1\x8f\0"
	"\xd0\xbb\xd1\x96\xd0\xbf\xd0\xb5\xd0\xbd\xd1\x8f\0"
	"\xd0\xb6\xd0\xbd\xd1\x96\xd1\x9e\xd0\xbd\xd1\x8f\0"
	"\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb0\xd1\x81\xd0\xbd\xd1\x8f\0"
	"\xd0\xba\xd0\xb0\xd1\x81\xd1\x82\xd1\x80\xd1\x8b\xd1\x87\xd0\xbd\xd1\x96\xd0\xba\xd0\xb0\0"
	"\xd0\xbb\xd1\x96\xd1\x81\xd1\x82\xd0\xb0\xd0\xbf\xd0\xb0\xd0\xb4\xd0\xb0\0"
	"\xd1\x81\xd0\xbd\xd0\xb5\xd0\xb6\xd0\xbd\xd1\x8f\0"
	"\xd1\x81\xd1\x82\xd1\x83\0"
	"\xd1\x81\xd0\xb0\xd0\xba\0"
	"\xd0\xba\xd1\x80\xd0\xb0\0"
	"\xd1\x87\xd1\x8d\xd1\x80\0"
	"\xd0\xbb\xd1\x96\xd0\xbf\0"
	"\xd0\xb6\xd0\xbd\xd1\x96\0"
	"\xd0\xba\xd0\xb0\xd1\x81\0"
	"\xd0\xbb\xd1\x96\xd1\x81\0"
	"\xd1\x81\xd0\xbd\xd0\xb5\0"
	"nedelja\0"
	"ponedeljek\0"
	"torek\0"
	"sreda\0"
	"\xc4\x8d\x65trtek\0"
	"petek\0"
	"ned.\0"
	"sre.\0"
	"\xc4\x8d\x65t.\0"
	"pet.\0"
	"t\0"
	"junij\0"
	"julij\0"
	"avgust\0"
	"avg.\0"
	"p\xc3\xbchap\xc3\xa4\x65v\0"
	"esmasp\xc3\xa4\x65v\0"
	"teisip\xc3\xa4\x65v\0"
	"kolmap\xc3\xa4\x65v\0"
	"neljap\xc3\xa4\x65v\0"
	"reede\0"
	"laup\xc3\xa4\x65v\0"
	"jaanuar\0"
	"veebruar\0"
	"m\xc3\xa4rts\0"
	"aprill\0"
	"juuni\0"
	"juuli\0"
	"oktoober\0"
	"detsember\0"
	"jaan\0"
	"veebr\0"
	"sept\0"
	"dets\0"
	"sv\xc4\x93tdiena\0"
	"pirmdiena\0"
	"otrdiena\0"
	"tre\xc5\xa1\x64iena\0"
	"ceturtdiena\0"
	"piektdiena\0"
	"sestdiena\0"
	"Sv\xc4\x93td.\0"
	"Pirmd.\0"
	"Otrd.\0"
	"Tre\xc5\xa1\x64.\0"
	"Ceturtd.\0"
	"Piektd.\0"
	"Sestd.\0"
	"janv\xc4\x81ris\0"
	"febru\xc4\x81ris\0"
	"apr\xc4\xablis\0"
	"maijs\0"
	"j\xc5\xabnijs\0"
	"j\xc5\xablijs\0"
	"augusts\0"
	"septembris\0"
	"oktobris\0"
	"novembris\0"
	"decembris\0"
	"j\xc5\xabn.\0"
	"j\xc5\xabl.\0"
	"sekmadienis\0"
	"pirmadienis\0"
	"antradienis\0"
	"tre\xc4\x8diadienis\0"
	"ketvirtadienis\0"
	"penktadienis\0"
	"\xc5\xa1\x65\xc5\xa1tadienis\0"
	"sk\0"
	"pr\0"
	"an\0"
	"tr\0"
	"kt\0"
	"pn\0"
	"A\0"
	"\xc5\xa0\0"
	"sausis\0"
	"vasaris\0"
	"kovas\0"
	"balandis\0"
	"gegu\xc5\xbe\xc4\x97\0"
	"bir\xc5\xbe\x65lis\0"
	"liepa\0"
	"rugpj\xc5\xabtis\0"
	"rugs\xc4\x97jis\0"
	"spalis\0"
	"lapkritis\0"
	"gruodis\0"
	"sausio\0"
	"vasario\0"
	"kovo\0"
	"baland\xc5\xbeio\0"
	"gegu\xc5\xbe\xc4\x97s\0"
	"bir\xc5\xbe\x65lio\0"
	"liepos\0"
	"rugpj\xc5\xab\xc4\x8dio\0"
	"rugs\xc4\x97jo\0"
	"spalio\0"
	"lapkri\xc4\x8dio\0"
	"gruod\xc5\xbeio\0"
	"saus.\0"
	"vas.\0"
	"kov.\0"
	"bal.\0"
	"geg.\0"
	"bir\xc5\xbe.\0"
	"liep.\0"
	"rugp.\0"
	"rugs.\0"
	"spal.\0"
	"lapkr.\0"
	"gruod.\0"
	"\xd0\xaf\xd0\xba\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb5\0"
	"\xd0\x94\xd1\x83\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb5\0"
	"\xd0\xa1\xd0\xb5\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb5\0"
	"\xd0\xa7\xd0\xbe\xd1\x80\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb5\0"
	"\xd0\x9f\xd0\xb0\xd0\xbd\xd2\xb7\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb5\0"
	"\xd2\xb6\xd1\x83\xd0\xbc\xd1\x8a\xd0\xb0\0"
	"\xd0\xa8\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb5\0"
	"\xd0\xaf\xd1\x88\xd0\xb1\0"
	"\xd0\x94\xd1\x88\xd0\xb1\0"
	"\xd0\xa1\xd1\x88\xd0\xb1\0"
	"\xd0\xa7\xd1\x88\xd0\xb1\0"
	"\xd0\x9f\xd1\x88\xd0\xb1\0"
	"\xd2\xb6\xd0\xbc\xd1\x8a\0"
	"\xd0\xa8\xd0\xbd\xd0\xb1\0"
	"\xd0\xaf\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\0"
	"\xd0\xa4\xd0\xb5\xd0\xb2\xd1\x80\xd0\xb0\xd0\xbb\0"
	"\xd0\x9c\xd0\xb0\xd1\x80\xd1\x82\0"
	"\xd0\x90\xd0\xbf\xd1\x80\xd0\xb5\xd0\xbb\0"
	"\xd0\x9c\xd0\xb0\xd0\xb9\0"
	"\xd0\x98\xd1\x8e\xd0\xbd\0"
	"\xd0\x98\xd1\x8e\xd0\xbb\0"
	"\xd0\x90\xd0\xb2\xd0\xb3\xd1\x83\xd1\x81\xd1\x82\0"
	"\xd0\xa1\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\0"
	"\xd0\x9e\xd0\xba\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\0"
	"\xd0\x9d\xd0\xbe\xd1\x8f\xd0\xb1\xd1\x80\0"
	"\xd0\x94\xd0\xb5\xd0\xba\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd0\xaf\xd0\xbd\xd0\xb2\0"
	"\xd0\xa4\xd0\xb5\xd0\xb2\0"
	"\xd0\x9c\xd0\xb0\xd1\x80\0"
	"\xd0\x90\xd0\xbf\xd1\x80\0"
	"\xd0\x90\xd0\xb2\xd0\xb3\0"
	"\xd0\xa1\xd0\xb5\xd0\xbd\0"
	"\xd0\x9e\xd0\xba\xd1\x82\0"
	"\xd0\x9d\xd0\xbe\xd1\x8f\0"
	"\xd0\x94\xd0\xb5\xd0\xba\0"
	"\xdb\x8c\xda\xa9\xd8\xb4\xd9\x86\xd8\xa8\xd9\x87\0"
	"\xd8\xaf\xd9\x88\xd8\xb4\xd9\x86\xd8\xa8\xd9\x87\0"
	"\xd8\xb3\xd9\x87\xe2\x80\x8c\xd8\xb4\xd9\x86\xd8\xa8\xd9\x87\0"
	"\xda\x86\xd9\x87\xd8\xa7\xd8\xb1\xd8\xb4\xd9\x86\xd8\xa8\xd9\x87\0"
	"\xd9\xbe\xd9\x86\xd8\xac\xd8\xb4\xd9\x86\xd8\xa8\xd9\x87\0"
	"\xd8\xac\xd9\x85\xd8\xb9\xd9\x87\0"
	"\xd8\xb4\xd9\x86\xd8\xa8\xd9\x87\0"
	"\xdb\x8c\0"
	"\xd8\xaf\0"
	"\xd8\xb3\0"
	"\xda\x86\0"
	"\xd9\xbe\0"
	"\xd8\xac\0"
	"\xd8\xb4\0"
	"\xda\x98\xd8\xa7\xd9\x86\xd9\x88\xdb\x8c\xd9\x87\0"
	"\xd9\x81\xd9\x88\xd8\xb1\xdb\x8c\xd9\x87\0"
	"\xd9\x85\xd8\xa7\xd8\xb1\xd8\xb3\0"
	"\xd8\xa2\xd9\x88\xd8\xb1\xdb\x8c\xd9\x84\0"
	"\xd9\x85\xd9\x87\0"
	"\xda\x98\xd9\x88\xd8\xa6\xd9\x86\0"
	"\xda\x98\xd9\x88\xd8\xa6\xdb\x8c\xd9\x87\0"
	"\xd8\xa7\xd9\x88\xd8\xaa\0"
	"\xd8\xb3\xd9\xbe\xd8\xaa\xd8\xa7\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xd8\xa7\xda\xa9\xd8\xaa\xd8\xa8\xd8\xb1\0"
	"\xd9\x86\xd9\x88\xd8\xa7\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xd8\xaf\xd8\xb3\xd8\xa7\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xda\x98\xd8\xa7\xd9\x86\xd9\x88\xdb\x8c\xd9\x87\xd9\x94\0"
	"\xd9\x81\xd9\x88\xd8\xb1\xdb\x8c\xd9\x87\xd9\x94\0"
	"\xd9\x85\xd9\x87\xd9\x94\0"
	"\xda\x98\xd9\x88\xd8\xa6\xdb\x8c\xd9\x87\xd9\x94\0"
	"Ch\xe1\xbb\xa7 Nh\xe1\xba\xadt\0"
	"Th\xe1\xbb\xa9 Hai\0"
	"Th\xe1\xbb\xa9 Ba\0"
	"Th\xe1\xbb\xa9 T\xc6\xb0\0"
	"Th\xe1\xbb\xa9 N\xc4\x83m\0"
	"Th\xe1\xbb\xa9 S\xc3\xa1u\0"
	"Th\xe1\xbb\xa9 B\xe1\xba\xa3y\0"
	"CN\0"
	"Th 2\0"
	"Th 3\0"
	"Th 4\0"
	"Th 5\0"
	"Th 6\0"
	"Th 7\0"
	"T2\0"
	"T3\0"
	"T4\0"
	"T5\0"
	"T6\0"
	"T7\0"
	"Th\xc3\xa1ng 1\0"
	"Th\xc3\xa1ng 2\0"
	"Th\xc3\xa1ng 3\0"
	"Th\xc3\xa1ng 4\0"
	"Th\xc3\xa1ng 5\0"
	"Th\xc3\xa1ng 6\0"
	"Th\xc3\xa1ng 7\0"
	"Th\xc3\xa1ng 8\0"
	"Th\xc3\xa1ng 9\0"
	"Th\xc3\xa1ng 10\0"
	"Th\xc3\xa1ng 11\0"
	"Th\xc3\xa1ng 12\0"
	"th\xc3\xa1ng 1\0"
	"th\xc3\xa1ng 2\0"
	"th\xc3\xa1ng 3\0"
	"th\xc3\xa1ng 4\0"
	"th\xc3\xa1ng 5\0"
	"th\xc3\xa1ng 6\0"
	"th\xc3\xa1ng 7\0"
	"th\xc3\xa1ng 8\0"
	"th\xc3\xa1ng 9\0"
	"th\xc3\xa1ng 10\0"
	"th\xc3\xa1ng 11\0"
	"th\xc3\xa1ng 12\0"
	"Thg 1\0"
	"Thg 2\0"
	"Thg 3\0"
	"Thg 4\0"
	"Thg 5\0"
	"Thg 6\0"
	"Thg 7\0"
	"Thg 8\0"
	"Thg 9\0"
	"Thg 10\0"
	"Thg 11\0"
	"Thg 12\0"
	"\xd5\xaf\xd5\xab\xd6\x80\xd5\xa1\xd5\xaf\xd5\xab\0"
	"\xd5\xa5\xd6\x80\xd5\xaf\xd5\xb8\xd6\x82\xd5\xb7\xd5\xa1\xd5\xa2\xd5\xa9\xd5\xab\0"
	"\xd5\xa5\xd6\x80\xd5\xa5\xd6\x84\xd5\xb7\xd5\xa1\xd5\xa2\xd5\xa9\xd5\xab\0"
	"\xd5\xb9\xd5\xb8\xd6\x80\xd5\xa5\xd6\x84\xd5\xb7\xd5\xa1\xd5\xa2\xd5\xa9\xd5\xab\0"
	"\xd5\xb0\xd5\xab\xd5\xb6\xd5\xa3\xd5\xb7\xd5\xa1\xd5\xa2\xd5\xa9\xd5\xab\0"
	"\xd5\xb8\xd6\x82\xd6\x80\xd5\xa2\xd5\xa1\xd5\xa9\0"
	"\xd5\xb7\xd5\xa1\xd5\xa2\xd5\xa1\xd5\xa9\0"
	"\xd5\xaf\xd5\xab\xd6\x80\0"
	"\xd5\xa5\xd6\x80\xd5\xaf\0"
	"\xd5\xa5\xd6\x80\xd6\x84\0"
	"\xd5\xb9\xd6\x80\xd6\x84\0"
	"\xd5\xb0\xd5\xb6\xd5\xa3\0"
	"\xd5\xb8\xd6\x82\xd6\x80\0"
	"\xd5\xb7\xd5\xa2\xd5\xa9\0"
	"\xd4\xbf\0"
	"\xd4\xb5\0"
	"\xd5\x89\0"
	"\xd5\x80\0"
	"\xd5\x88\0"
	"\xd5\x87\0"
	"\xd5\xb0\xd5\xb8\xd6\x82\xd5\xb6\xd5\xbe\xd5\xa1\xd6\x80\0"
	"\xd6\x83\xd5\xa5\xd5\xbf\xd6\x80\xd5\xbe\xd5\xa1\xd6\x80\0"
	"\xd5\xb4\xd5\xa1\xd6\x80\xd5\xbf\0"
	"\xd5\xa1\xd5\xba\xd6\x80\xd5\xab\xd5\xac\0"
	"\xd5\xb4\xd5\xa1\xd5\xb5\xd5\xab\xd5\xbd\0"
	"\xd5\xb0\xd5\xb8\xd6\x82\xd5\xb6\xd5\xab\xd5\xbd\0"
	"\xd5\xb0\xd5\xb8\xd6\x82\xd5\xac\xd5\xab\xd5\xbd\0"
	"\xd6\x85\xd5\xa3\xd5\xb8\xd5\xbd\xd5\xbf\xd5\xb8\xd5\xbd\0"
	"\xd5\xbd\xd5\xa5\xd5\xba\xd5\xbf\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\0"
	"\xd5\xb0\xd5\xb8\xd5\xaf\xd5\xbf\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\0"
	"\xd5\xb6\xd5\xb8\xd5\xb5\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\0"
	"\xd5\xa4\xd5\xa5\xd5\xaf\xd5\xbf\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\0"
	"\xd5\xb0\xd5\xb8\xd6\x82\xd5\xb6\xd5\xbe\xd5\xa1\xd6\x80\xd5\xab\0"
	"\xd6\x83\xd5\xa5\xd5\xbf\xd6\x80\xd5\xbe\xd5\xa1\xd6\x80\xd5\xab\0"
	"\xd5\xb4\xd5\xa1\xd6\x80\xd5\xbf\xd5\xab\0"
	"\xd5\xa1\xd5\xba\xd6\x80\xd5\xab\xd5\xac\xd5\xab\0"
	"\xd5\xb4\xd5\xa1\xd5\xb5\xd5\xab\xd5\xbd\xd5\xab\0"
	"\xd5\xb0\xd5\xb8\xd6\x82\xd5\xb6\xd5\xab\xd5\xbd\xd5\xab\0"
	"\xd5\xb0\xd5\xb8\xd6\x82\xd5\xac\xd5\xab\xd5\xbd\xd5\xab\0"
	"\xd6\x85\xd5\xa3\xd5\xb8\xd5\xbd\xd5\xbf\xd5\xb8\xd5\xbd\xd5\xab\0"
	"\xd5\xbd\xd5\xa5\xd5\xba\xd5\xbf\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\xd5\xab\0"
	"\xd5\xb0\xd5\xb8\xd5\xaf\xd5\xbf\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\xd5\xab\0"
	"\xd5\xb6\xd5\xb8\xd5\xb5\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\xd5\xab\0"
	"\xd5\xa4\xd5\xa5\xd5\xaf\xd5\xbf\xd5\xa5\xd5\xb4\xd5\xa2\xd5\xa5\xd6\x80\xd5\xab\0"
	"\xd5\xb0\xd5\xb6\xd5\xbe\0"
	"\xd6\x83\xd5\xbf\xd5\xbe\0"
	"\xd5\xb4\xd6\x80\xd5\xbf\0"
	"\xd5\xa1\xd5\xba\xd6\x80\0"
	"\xd5\xb4\xd5\xb5\xd5\xbd\0"
	"\xd5\xb0\xd5\xb6\xd5\xbd\0"
	"\xd5\xb0\xd5\xac\xd5\xbd\0"
	"\xd6\x85\xd5\xa3\xd5\xbd\0"
	"\xd5\xbd\xd5\xa5\xd5\xba\0"
	"\xd5\xb0\xd5\xb8\xd5\xaf\0"
	"\xd5\xb6\xd5\xb8\xd5\xb5\0"
	"\xd5\xa4\xd5\xa5\xd5\xaf\0"
	"bazar\0"
	"bazar ert\xc9\x99si\0"
	"\xc3\xa7\xc9\x99r\xc5\x9f\xc9\x99nb\xc9\x99 ax\xc5\x9f\x61m\xc4\xb1\0"
	"\xc3\xa7\xc9\x99r\xc5\x9f\xc9\x99nb\xc9\x99\0"
	"c\xc3\xbcm\xc9\x99 ax\xc5\x9f\x61m\xc4\xb1\0"
	"c\xc3\xbcm\xc9\x99\0"
	"\xc5\x9f\xc9\x99nb\xc9\x99\0"
	"B.\0"
	"B.E.\0"
	"\xc3\x87.A.\0"
	"\xc3\x87.\0"
	"C.A.\0"
	"C.\0"
	"\xc5\x9e.\0"
	"Yanvar\0"
	"Fevral\0"
	"Aprel\0"
	"\xc4\xb0yun\0"
	"\xc4\xb0yul\0"
	"Avqust\0"
	"Sentyabr\0"
	"Oktyabr\0"
	"Noyabr\0"
	"Dekabr\0"
	"yanvar\0"
	"fevral\0"
	"mart\0"
	"aprel\0"
	"may\0"
	"iyun\0"
	"iyul\0"
	"avqust\0"
	"sentyabr\0"
	"oktyabr\0"
	"noyabr\0"
	"dekabr\0"
	"yan\0"
	"iyn\0"
	"iyl\0"
	"avq\0"
	"sen\0"
	"noy\0"
	"dek\0"
	"igandea\0"
	"astelehena\0"
	"asteartea\0"
	"asteazkena\0"
	"osteguna\0"
	"ostirala\0"
	"larunbata\0"
	"ig.\0"
	"al.\0"
	"ar.\0"
	"az.\0"
	"og.\0"
	"or.\0"
	"lr.\0"
	"I\0"
	"urtarrila\0"
	"Otsaila\0"
	"Martxoa\0"
	"Apirila\0"
	"Maiatza\0"
	"Ekaina\0"
	"Uztaila\0"
	"Abuztua\0"
	"Iraila\0"
	"Urria\0"
	"Azaroa\0"
	"Abendua\0"
	"otsaila\0"
	"martxoa\0"
	"apirila\0"
	"maiatza\0"
	"ekaina\0"
	"uztaila\0"
	"abuztua\0"
	"iraila\0"
	"urria\0"
	"azaroa\0"
	"abendua\0"
	"urt.\0"
	"ots.\0"
	"api.\0"
	"mai.\0"
	"eka.\0"
	"uzt.\0"
	"abu.\0"
	"ira.\0"
	"urr.\0"
	"aza.\0"
	"abe.\0"
	"njed\xc5\xba\x65la\0"
	"p\xc3\xb3nd\xc5\xba\x65la\0"
	"wutora\0"
	"srjeda\0"
	"\xc5\xa1tw\xc3\xb3rtk\0"
	"pjatk\0"
	"nje\0"
	"p\xc3\xb3n\0"
	"wut\0"
	"srj\0"
	"\xc5\xa1tw\0"
	"pja\0"
	"sob\0"
	"w\0"
	"m\xc4\x9brc\0"
	"apryl\0"
	"meja\0"
	"awgust\0"
	"nowember\0"
	"januara\0"
	"februara\0"
	"m\xc4\x9brca\0"
	"apryla\0"
	"meje\0"
	"junija\0"
	"julija\0"
	"awgusta\0"
	"oktobra\0"
	"nowembra\0"
	"m\xc4\x9br\0"
	"mej\0"
	"awg\0"
	"now\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\0"
	"\xd1\x87\xd0\xb5\xd1\x82\xd0\xb2\xd1\x80\xd1\x82\xd0\xbe\xd0\xba\0"
	"\xd0\xbf\xd0\xb5\xd1\x82\xd0\xbe\xd0\xba\0"
	"\xd1\x81\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd0\xb0\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4.\0"
	"\xd0\xbf\xd0\xbe\xd0\xbd.\0"
	"\xd0\xb2\xd1\x82\xd0\xbe.\0"
	"\xd1\x81\xd1\x80\xd0\xb5.\0"
	"\xd1\x87\xd0\xb5\xd1\x82.\0"
	"\xd0\xbf\xd0\xb5\xd1\x82.\0"
	"\xd1\x81\xd0\xb0\xd0\xb1.\0"
	"\xd1\x98\xd0\xb0\xd0\xbd\xd1\x83\xd0\xb0\xd1\x80\xd0\xb8\0"
	"\xd0\xbc\xd0\xb0\xd1\x98\0"
	"\xd1\x98\xd1\x83\xd0\xbd\xd0\xb8\0"
	"\xd1\x98\xd1\x83\xd0\xbb\xd0\xb8\0"
	"\xd1\x98\xd0\xb0\xd0\xbd.\0"
	"\xd1\x84\xd0\xb5\xd0\xb2.\0"
	"\xd0\xbc\xd0\xb0\xd1\x80.\0"
	"\xd1\x98\xd1\x83\xd0\xbd.\0"
	"\xd1\x98\xd1\x83\xd0\xbb.\0"
	"\xd1\x81\xd0\xb5\xd0\xbf\xd1\x82.\0"
	"\xd0\xbd\xd0\xbe\xd0\xb5\xd0\xbc.\0"
	"Sontaha\0"
	"Mmantaha\0"
	"Labobedi\0"
	"Laboraru\0"
	"Labone\0"
	"Labohlane\0"
	"Moqebelo\0"
	"Son\0"
	"Mma\0"
	"Bed\0"
	"Rar\0"
	"Ne\0"
	"Hla\0"
	"Moq\0"
	"Phesekgong\0"
	"Hlakola\0"
	"Hlakubele\0"
	"Mmese\0"
	"Motsheanong\0"
	"Phupjane\0"
	"Phupu\0"
	"Phata\0"
	"Leotshe\0"
	"Mphalane\0"
	"Pundungwane\0"
	"Tshitwe\0"
	"Phe\0"
	"Kol\0"
	"Ube\0"
	"Mme\0"
	"Mot\0"
	"Upu\0"
	"Pha\0"
	"Leo\0"
	"Mph\0"
	"Pun\0"
	"Tsh\0"
	"Sonto\0"
	"Musumbhunuku\0"
	"Ravumbirhi\0"
	"Ravunharhu\0"
	"Ravumune\0"
	"Ravuntlhanu\0"
	"Mugqivela\0"
	"Mus\0"
	"Bir\0"
	"Har\0"
	"Tlh\0"
	"Mug\0"
	"Sunguti\0"
	"Nyenyenyani\0"
	"Nyenyankulu\0"
	"Dzivamisoko\0"
	"Mudyaxihi\0"
	"Khotavuxika\0"
	"Mawuwani\0"
	"Mhawuri\0"
	"Ndzhati\0"
	"Nhlangula\0"
	"Hukuri\0"
	"N'wendzamhala\0"
	"Yan\0"
	"Kul\0"
	"Dzi\0"
	"Mud\0"
	"Kho\0"
	"Maw\0"
	"Mha\0"
	"Ndz\0"
	"Nhl\0"
	"Huk\0"
	"N'w\0"
	"Tshipi\0"
	"Mosopulogo\0"
	"Laboraro\0"
	"Labotlhano\0"
	"Matlhatso\0"
	"Mos\0"
	"Tla\0"
	"Mat\0"
	"Ferikgong\0"
	"Tlhakole\0"
	"Mopitlo\0"
	"Moranang\0"
	"Motsheganang\0"
	"Seetebosigo\0"
	"Phukwi\0"
	"Phatwe\0"
	"Lwetse\0"
	"Diphalane\0"
	"Ngwanatsele\0"
	"Sedimonthole\0"
	"Fer\0"
	"Mop\0"
	"Mor\0"
	"See\0"
	"Phu\0"
	"Lwe\0"
	"Dip\0"
	"Ngw\0"
	"Sed\0"
	"Cawe\0"
	"Mvulo\0"
	"Lwesibini\0"
	"Lwesithathu\0"
	"Lwesine\0"
	"Lwesihlanu\0"
	"Mgqibelo\0"
	"Caw\0"
	"Mvu\0"
	"Bin\0"
	"Tha\0"
	"Sin\0"
	"Mgq\0"
	"Janyuwari\0"
	"Februwari\0"
	"Matshi\0"
	"Epreli\0"
	"Meyi\0"
	"Julayi\0"
	"Agasti\0"
	"Septemba\0"
	"Okthoba\0"
	"Novemba\0"
	"Disemba\0"
	"Epr\0"
	"Mey\0"
	"Aga\0"
	"Dis\0"
	"ISonto\0"
	"UMsombuluko\0"
	"ULwesibili\0"
	"ULwesithathu\0"
	"ULwesine\0"
	"ULwesihlanu\0"
	"UMgqibelo\0"
	"Mso\0"
	"Bil\0"
	"B\0"
	"Januwari\0"
	"Mashi\0"
	"Ephreli\0"
	"Septhemba\0"
	"UMasingana\0"
	"Mas\0"
	"Eph\0"
	"Sondag\0"
	"Maandag\0"
	"Dinsdag\0"
	"Woensdag\0"
	"Donderdag\0"
	"Vrydag\0"
	"Saterdag\0"
	"So.\0"
	"Ma.\0"
	"Di.\0"
	"Wo.\0"
	"Do.\0"
	"Vr.\0"
	"Sa.\0"
	"Januarie\0"
	"Februarie\0"
	"Maart\0"
	"Junie\0"
	"Julie\0"
	"Augustus\0"
	"Jan.\0"
	"Feb.\0"
	"Mrt.\0"
	"Apr.\0"
	"Jun.\0"
	"Jul.\0"
	"Aug.\0"
	"Sep.\0"
	"Okt.\0"
	"Nov.\0"
	"Des.\0"
	"\xe1\x83\x99\xe1\x83\x95\xe1\x83\x98\xe1\x83\xa0\xe1\x83\x90\0"
	"\xe1\x83\x9d\xe1\x83\xa0\xe1\x83\xa8\xe1\x83\x90\xe1\x83\x91\xe1\x83\x90\xe1\x83\x97\xe1\x83\x98\0"
	"\xe1\x83\xa1\xe1\x83\x90\xe1\x83\x9b\xe1\x83\xa8\xe1\x83\x90\xe1\x83\x91\xe1\x83\x90\xe1\x83\x97\xe1\x83\x98\0"
	"\xe1\x83\x9d\xe1\x83\x97\xe1\x83\xae\xe1\x83\xa8\xe1\x83\x90\xe1\x83\x91\xe1\x83\x90\xe1\x83\x97\xe1\x83\x98\0"
	"\xe1\x83\xae\xe1\x83\xa3\xe1\x83\x97\xe1\x83\xa8\xe1\x83\x90\xe1\x83\x91\xe1\x83\x90\xe1\x83\x97\xe1\x83\x98\0"
	"\xe1\x83\x9e\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x90\xe1\x83\xa1\xe1\x83\x99\xe1\x83\x94\xe1\x83\x95\xe1\x83\x98\0"
	"\xe1\x83\xa8\xe1\x83\x90\xe1\x83\x91\xe1\x83\x90\xe1\x83\x97\xe1\x83\x98\0"
	"\xe1\x83\x99\xe1\x83\x95\xe1\x83\x98\0"
	"\xe1\x83\x9d\xe1\x83\xa0\xe1\x83\xa8\0"
	"\xe1\x83\xa1\xe1\x83\x90\xe1\x83\x9b\0"
	"\xe1\x83\x9d\xe1\x83\x97\xe1\x83\xae\0"
	"\xe1\x83\xae\xe1\x83\xa3\xe1\x83\x97\0"
	"\xe1\x83\x9e\xe1\x83\x90\xe1\x83\xa0\0"
	"\xe1\x83\xa8\xe1\x83\x90\xe1\x83\x91\0"
	"\xe1\x83\x99\0"
	"\xe1\x83\x9d\0"
	"\xe1\x83\xa1\0"
	"\xe1\x83\xae\0"
	"\xe1\x83\x9e\0"
	"\xe1\x83\xa8\0"
	"\xe1\x83\x98\xe1\x83\x90\xe1\x83\x9c\xe1\x83\x95\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x98\0"
	"\xe1\x83\x97\xe1\x83\x94\xe1\x83\x91\xe1\x83\x94\xe1\x83\xa0\xe1\x83\x95\xe1\x83\x90\xe1\x83\x9a\xe1\x83\x98\0"
	"\xe1\x83\x9b\xe1\x83\x90\xe1\x83\xa0\xe1\x83\xa2\xe1\x83\x98\0"
	"\xe1\x83\x90\xe1\x83\x9e\xe1\x83\xa0\xe1\x83\x98\xe1\x83\x9a\xe1\x83\x98\0"
	"\xe1\x83\x9b\xe1\x83\x90\xe1\x83\x98\xe1\x83\xa1\xe1\x83\x98\0"
	"\xe1\x83\x98\xe1\x83\x95\xe1\x83\x9c\xe1\x83\x98\xe1\x83\xa1\xe1\x83\x98\0"
	"\xe1\x83\x98\xe1\x83\x95\xe1\x83\x9a\xe1\x83\x98\xe1\x83\xa1\xe1\x83\x98\0"
	"\xe1\x83\x90\xe1\x83\x92\xe1\x83\x95\xe1\x83\x98\xe1\x83\xa1\xe1\x83\xa2\xe1\x83\x9d\0"
	"\xe1\x83\xa1\xe1\x83\x94\xe1\x83\xa5\xe1\x83\xa2\xe1\x83\x94\xe1\x83\x9b\xe1\x83\x91\xe1\x83\x94\xe1\x83\xa0\xe1\x83\x98\0"
	"\xe1\x83\x9d\xe1\x83\xa5\xe1\x83\xa2\xe1\x83\x9d\xe1\x83\x9b\xe1\x83\x91\xe1\x83\x94\xe1\x83\xa0\xe1\x83\x98\0"
	"\xe1\x83\x9c\xe1\x83\x9d\xe1\x83\x94\xe1\x83\x9b\xe1\x83\x91\xe1\x83\x94\xe1\x83\xa0\xe1\x83\x98\0"
	"\xe1\x83\x93\xe1\x83\x94\xe1\x83\x99\xe1\x83\x94\xe1\x83\x9b\xe1\x83\x91\xe1\x83\x94\xe1\x83\xa0\xe1\x83\x98\0"
	"\xe1\x83\x98\xe1\x83\x90\xe1\x83\x9c\0"
	"\xe1\x83\x97\xe1\x83\x94\xe1\x83\x91\0"
	"\xe1\x83\x9b\xe1\x83\x90\xe1\x83\xa0\0"
	"\xe1\x83\x90\xe1\x83\x9e\xe1\x83\xa0\0"
	"\xe1\x83\x9b\xe1\x83\x90\xe1\x83\x98\0"
	"\xe1\x83\x98\xe1\x83\x95\xe1\x83\x9c\0"
	"\xe1\x83\x98\xe1\x83\x95\xe1\x83\x9a\0"
	"\xe1\x83\x90\xe1\x83\x92\xe1\x83\x95\0"
	"\xe1\x83\xa1\xe1\x83\x94\xe1\x83\xa5\0"
	"\xe1\x83\x9d\xe1\x83\xa5\xe1\x83\xa2\0"
	"\xe1\x83\x9c\xe1\x83\x9d\xe1\x83\x94\0"
	"\xe1\x83\x93\xe1\x83\x94\xe1\x83\x99\0"
	"m\xc3\xa1nadagur\0"
	"t\xc3\xbdsdagur\0"
	"mikudagur\0"
	"h\xc3\xb3sdagur\0"
	"fr\xc3\xadggjadagur\0"
	"leygardagur\0"
	"sun\0"
	"m\xc3\xa1n\0"
	"t\xc3\xbds\0"
	"mik\0"
	"h\xc3\xb3s\0"
	"fr\xc3\xad\0"
	"ley\0"
	"\xe0\xa4\xb0\xe0\xa4\xb5\xe0\xa4\xbf\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb8\xe0\xa5\x8b\xe0\xa4\xae\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xae\xe0\xa4\x82\xe0\xa4\x97\xe0\xa4\xb2\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xac\xe0\xa5\x81\xe0\xa4\xa7\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\x97\xe0\xa5\x81\xe0\xa4\xb0\xe0\xa5\x81\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb6\xe0\xa5\x81\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb6\xe0\xa4\xa8\xe0\xa4\xbf\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb0\xe0\xa4\xb5\xe0\xa4\xbf\0"
	"\xe0\xa4\xb8\xe0\xa5\x8b\xe0\xa4\xae\0"
	"\xe0\xa4\xae\xe0\xa4\x82\xe0\xa4\x97\xe0\xa4\xb2\0"
	"\xe0\xa4\xac\xe0\xa5\x81\xe0\xa4\xa7\0"
	"\xe0\xa4\x97\xe0\xa5\x81\xe0\xa4\xb0\xe0\xa5\x81\0"
	"\xe0\xa4\xb6\xe0\xa5\x81\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xb0\0"
	"\xe0\xa4\xb6\xe0\xa4\xa8\xe0\xa4\xbf\0"
	"\xe0\xa4\xb0\0"
	"\xe0\xa4\xb8\xe0\xa5\x8b\0"
	"\xe0\xa4\xae\xe0\xa4\x82\0"
	"\xe0\xa4\xac\xe0\xa5\x81\0"
	"\xe0\xa4\x97\xe0\xa5\x81\0"
	"\xe0\xa4\xb6\xe0\xa5\x81\0"
	"\xe0\xa4\xb6\0"
	"\xe0\xa4\x9c\xe0\xa4\xa8\xe0\xa4\xb5\xe0\xa4\xb0\xe0\xa5\x80\0"
	"\xe0\xa4\xab\xe0\xa4\xbc\xe0\xa4\xb0\xe0\xa4\xb5\xe0\xa4\xb0\xe0\xa5\x80\0"
	"\xe0\xa4\xae\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa5\x8d\xe0\xa4\x9a\0"
	"\xe0\xa4\x85\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x88\xe0\xa4\xb2\0"
	"\xe0\xa4\xae\xe0\xa4\x88\0"
	"\xe0\xa4\x9c\xe0\xa5\x82\xe0\xa4\xa8\0"
	"\xe0\xa4\x9c\xe0\xa5\x81\xe0\xa4\xb2\xe0\xa4\xbe\xe0\xa4\x88\0"
	"\xe0\xa4\x85\xe0\xa4\x97\xe0\xa4\xb8\xe0\xa5\x8d\xe0\xa4\xa4\0"
	"\xe0\xa4\xb8\xe0\xa4\xbf\xe0\xa4\xa4\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\x85\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xa4\xe0\xa5\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\xa8\xe0\xa4\xb5\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\xa6\xe0\xa4\xbf\xe0\xa4\xb8\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\x9c\xe0\xa4\xa8\xe0\xa5\xb0\0"
	"\xe0\xa4\xab\xe0\xa4\xbc\xe0\xa4\xb0\xe0\xa5\xb0\0"
	"\xe0\xa4\x9c\xe0\xa5\x81\xe0\xa4\xb2\xe0\xa5\xb0\0"
	"\xe0\xa4\x85\xe0\xa4\x97\xe0\xa5\xb0\0"
	"\xe0\xa4\xb8\xe0\xa4\xbf\xe0\xa4\xa4\xe0\xa5\xb0\0"
	"\xe0\xa4\x85\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xa4\xe0\xa5\x82\xe0\xa5\xb0\0"
	"\xe0\xa4\xa8\xe0\xa4\xb5\xe0\xa5\xb0\0"
	"\xe0\xa4\xa6\xe0\xa4\xbf\xe0\xa4\xb8\xe0\xa5\xb0\0"
	"Il-\xc4\xa6\x61\x64\x64\0"
	"It-Tnejn\0"
	"It-Tlieta\0"
	"L-Erbg\xc4\xa7\x61\0"
	"Il-\xc4\xa6\x61mis\0"
	"Il-\xc4\xa0img\xc4\xa7\x61\0"
	"Is-Sibt\0"
	"\xc4\xa6\x61\x64\0"
	"Tne\0"
	"Tli\0"
	"Erb\0"
	"\xc4\xa6\x61m\0"
	"\xc4\xa0im\0"
	"Sib\0"
	"\xc4\xa6\x64\0"
	"Tn\0"
	"Tl\0"
	"Er\0"
	"\xc4\xa6m\0"
	"\xc4\xa0m\0"
	"Sb\0"
	"Jannar\0"
	"Frar\0"
	"Marzu\0"
	"Mejju\0"
	"\xc4\xa0unju\0"
	"Lulju\0"
	"Awwissu\0"
	"Settembru\0"
	"Ottubru\0"
	"Novembru\0"
	"Di\xc4\x8b\x65mbru\0"
	"Fra\0"
	"Mej\0"
	"\xc4\xa0un\0"
	"Lul\0"
	"Aww\0"
	"Set\0"
	"Ott\0"
	"Di\xc4\x8b\0"
	"sotnabeaivi\0"
	"vuoss\xc3\xa1rga\0"
	"ma\xc5\x8b\xc5\x8b\x65\x62\xc3\xa1rga\0"
	"gaskavahkku\0"
	"duorasdat\0"
	"bearjadat\0"
	"l\xc3\xa1vvardat\0"
	"sotn\0"
	"vuos\0"
	"ma\xc5\x8b\0"
	"gask\0"
	"duor\0"
	"bear\0"
	"l\xc3\xa1v\0"
	"o\xc4\x91\xc4\x91\x61jagem\xc3\xa1nnu\0"
	"guovvam\xc3\xa1nnu\0"
	"njuk\xc4\x8d\x61m\xc3\xa1nnu\0"
	"cuo\xc5\x8bom\xc3\xa1nnu\0"
	"miessem\xc3\xa1nnu\0"
	"geassem\xc3\xa1nnu\0"
	"suoidnem\xc3\xa1nnu\0"
	"borgem\xc3\xa1nnu\0"
	"\xc4\x8d\x61k\xc4\x8d\x61m\xc3\xa1nnu\0"
	"golggotm\xc3\xa1nnu\0"
	"sk\xc3\xa1\x62mam\xc3\xa1nnu\0"
	"juovlam\xc3\xa1nnu\0"
	"o\xc4\x91\xc4\x91j\0"
	"guov\0"
	"njuk\0"
	"cuo\0"
	"mies\0"
	"geas\0"
	"suoi\0"
	"borg\0"
	"\xc4\x8d\x61k\xc4\x8d\0"
	"golg\0"
	"sk\xc3\xa1\x62\0"
	"juov\0"
	"D\xc3\xa9 Domhnaigh\0"
	"D\xc3\xa9 Luain\0"
	"D\xc3\xa9 M\xc3\xa1irt\0"
	"D\xc3\xa9 C\xc3\xa9\x61\x64\x61oin\0"
	"D\xc3\xa9\x61rdaoin\0"
	"D\xc3\xa9 hAoine\0"
	"D\xc3\xa9 Sathairn\0"
	"Domh\0"
	"Luan\0"
	"M\xc3\xa1irt\0"
	"C\xc3\xa9\x61\x64\0"
	"D\xc3\xa9\x61r\0"
	"Aoine\0"
	"Sath\0"
	"Ean\xc3\xa1ir\0"
	"Feabhra\0"
	"M\xc3\xa1rta\0"
	"Aibre\xc3\xa1n\0"
	"Bealtaine\0"
	"Meitheamh\0"
	"I\xc3\xbail\0"
	"L\xc3\xbanasa\0"
	"Me\xc3\xa1n F\xc3\xb3mhair\0"
	"Deireadh F\xc3\xb3mhair\0"
	"Samhain\0"
	"Nollaig\0"
	"Ean\0"
	"Feabh\0"
	"Aib\0"
	"Beal\0"
	"Meith\0"
	"L\xc3\xban\0"
	"MF\xc3\xb3mh\0"
	"DF\xc3\xb3mh\0"
	"Samh\0"
	"Noll\0"
	"Ahad\0"
	"Isnin\0"
	"Khamis\0"
	"Jumaat\0"
	"Ahd\0"
	"Isn\0"
	"Kha\0"
	"Mac\0"
	"Julai\0"
	"Ogos\0"
	"Disember\0"
	"Ogo\0"
	"\xd0\xb6\xd0\xb5\xd0\xba\xd1\x81\xd0\xb5\xd0\xbd\xd0\xb1\xd1\x96\0"
	"\xd0\xb4\xd2\xaf\xd0\xb9\xd1\x81\xd0\xb5\xd0\xbd\xd0\xb1\xd1\x96\0"
	"\xd1\x81\xd0\xb5\xd0\xb9\xd1\x81\xd0\xb5\xd0\xbd\xd0\xb1\xd1\x96\0"
	"\xd1\x81\xd3\x99\xd1\x80\xd1\x81\xd0\xb5\xd0\xbd\xd0\xb1\xd1\x96\0"
	"\xd0\xb1\xd0\xb5\xd0\xb9\xd1\x81\xd0\xb5\xd0\xbd\xd0\xb1\xd1\x96\0"
	"\xd0\xb6\xd2\xb1\xd0\xbc\xd0\xb0\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\xd0\xb1\xd1\x96\0"
	"\xd0\x96\xd1\x81\0"
	"\xd0\x94\xd1\x81\0"
	"\xd0\xa1\xd1\x81\0"
	"\xd0\xa1\xd1\x80\0"
	"\xd0\x91\xd1\x81\0"
	"\xd0\x96\xd0\xbc\0"
	"\xd0\xa1\xd0\xb1\0"
	"\xd0\x96\0"
	"\xd0\x94\0"
	"\xd0\x91\0"
	"\xd2\x9a\xd0\xb0\xd2\xa3\xd1\x82\xd0\xb0\xd1\x80\0"
	"\xd0\x90\xd2\x9b\xd0\xbf\xd0\xb0\xd0\xbd\0"
	"\xd0\x9d\xd0\xb0\xd1\x83\xd1\x80\xd1\x8b\xd0\xb7\0"
	"\xd0\xa1\xd3\x99\xd1\x83\xd1\x96\xd1\x80\0"
	"\xd0\x9c\xd0\xb0\xd0\xbc\xd1\x8b\xd1\x80\0"
	"\xd0\x9c\xd0\xb0\xd1\x83\xd1\x81\xd1\x8b\xd0\xbc\0"
	"\xd0\xa8\xd1\x96\xd0\xbb\xd0\xb4\xd0\xb5\0"
	"\xd0\xa2\xd0\xb0\xd0\xbc\xd1\x8b\xd0\xb7\0"
	"\xd2\x9a\xd1\x8b\xd1\x80\xd0\xba\xd2\xaf\xd0\xb9\xd0\xb5\xd0\xba\0"
	"\xd2\x9a\xd0\xb0\xd0\xb7\xd0\xb0\xd0\xbd\0"
	"\xd2\x9a\xd0\xb0\xd1\x80\xd0\xb0\xd1\x88\xd0\xb0\0"
	"\xd0\x96\xd0\xb5\xd0\xbb\xd1\x82\xd0\xbe\xd2\x9b\xd1\x81\xd0\xb0\xd0\xbd\0"
	"\xd2\x9b\xd0\xb0\xd2\xa3\xd1\x82\xd0\xb0\xd1\x80\0"
	"\xd0\xb0\xd2\x9b\xd0\xbf\xd0\xb0\xd0\xbd\0"
	"\xd0\xbd\xd0\xb0\xd1\x83\xd1\x80\xd1\x8b\xd0\xb7\0"
	"\xd1\x81\xd3\x99\xd1\x83\xd1\x96\xd1\x80\0"
	"\xd0\xbc\xd0\xb0\xd0\xbc\xd1\x8b\xd1\x80\0"
	"\xd0\xbc\xd0\xb0\xd1\x83\xd1\x81\xd1\x8b\xd0\xbc\0"
	"\xd1\x88\xd1\x96\xd0\xbb\xd0\xb4\xd0\xb5\0"
	"\xd1\x82\xd0\xb0\xd0\xbc\xd1\x8b\xd0\xb7\0"
	"\xd2\x9b\xd1\x8b\xd1\x80\xd0\xba\xd2\xaf\xd0\xb9\xd0\xb5\xd0\xba\0"
	"\xd2\x9b\xd0\xb0\xd0\xb7\xd0\xb0\xd0\xbd\0"
	"\xd2\x9b\xd0\xb0\xd1\x80\xd0\xb0\xd1\x88\xd0\xb0\0"
	"\xd0\xb6\xd0\xb5\xd0\xbb\xd1\x82\xd0\xbe\xd2\x9b\xd1\x81\xd0\xb0\xd0\xbd\0"
	"\xd2\x9a\xd0\xb0\xd2\xa3.\0"
	"\xd0\x90\xd2\x9b\xd0\xbf.\0"
	"\xd0\x9d\xd0\xb0\xd1\x83.\0"
	"\xd0\xa1\xd3\x99\xd1\x83.\0"
	"\xd0\x9c\xd0\xb0\xd0\xbc.\0"
	"\xd0\x9c\xd0\xb0\xd1\x83.\0"
	"\xd0\xa8\xd1\x96\xd0\xbb.\0"
	"\xd0\xa2\xd0\xb0\xd0\xbc.\0"
	"\xd2\x9a\xd1\x8b\xd1\x80.\0"
	"\xd2\x9a\xd0\xb0\xd0\xb7.\0"
	"\xd2\x9a\xd0\xb0\xd1\x80.\0"
	"\xd0\x96\xd0\xb5\xd0\xbb.\0"
	"\xd0\xb6\xd0\xb5\xd0\xba\xd1\x88\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb8\0"
	"\xd0\xb4\xd2\xaf\xd0\xb9\xd1\x88\xd3\xa9\xd0\xbc\xd0\xb1\xd2\xaf\0"
	"\xd1\x88\xd0\xb5\xd0\xb9\xd1\x88\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb8\0"
	"\xd1\x88\xd0\xb0\xd1\x80\xd1\x88\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb8\0"
	"\xd0\xb1\xd0\xb5\xd0\xb9\xd1\x88\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb8\0"
	"\xd0\xb6\xd1\x83\xd0\xbc\xd0\xb0\0"
	"\xd0\xb8\xd1\x88\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb8\0"
	"\xd0\xb6\xd0\xb5\xd0\xba.\0"
	"\xd0\xb4\xd2\xaf\xd0\xb9.\0"
	"\xd1\x88\xd0\xb5\xd0\xb9\xd1\x88.\0"
	"\xd1\x88\xd0\xb0\xd1\x80\xd1\x88.\0"
	"\xd0\xb1\xd0\xb5\xd0\xb9\xd1\x88.\0"
	"\xd0\xb8\xd1\x88\xd0\xbc.\0"
	"\xd0\xa8\0"
	"\xd0\x98\0"
	"\xd0\xaf\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\xd1\x8c\0"
	"\xd0\xa4\xd0\xb5\xd0\xb2\xd1\x80\xd0\xb0\xd0\xbb\xd1\x8c\0"
	"\xd0\x90\xd0\xbf\xd1\x80\xd0\xb5\xd0\xbb\xd1\x8c\0"
	"\xd0\x98\xd1\x8e\xd0\xbd\xd1\x8c\0"
	"\xd0\x98\xd1\x8e\xd0\xbb\xd1\x8c\0"
	"\xd0\xa1\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd0\x9e\xd0\xba\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd0\x9d\xd0\xbe\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c\0"
	"\xd0\x94\xd0\xb5\xd0\xba\xd0\xb0\xd0\xb1\xd1\x80\xd1\x8c\0"
	"Jumapili\0"
	"Jumatatu\0"
	"Jumanne\0"
	"Jumatano\0"
	"Alhamisi\0"
	"Ijumaa\0"
	"Jumamosi\0"
	"Machi\0"
	"Aprili\0"
	"Agosti\0"
	"Oktoba\0"
	"Desemba\0"
	"Ago\0"
	"\xc3\xbd\x65k\xc5\x9f\x65nbe\0"
	"du\xc5\x9f\x65nbe\0"
	"si\xc5\x9f\x65nbe\0"
	"\xc3\xa7\x61r\xc5\x9f\x65nbe\0"
	"pen\xc5\x9f\x65nbe\0"
	"anna\0"
	"\xc5\x9f\x65nbe\0"
	"\xc3\xbd\x62\0"
	"db\0"
	"sb\0"
	"\xc3\xa7\x62\0"
	"pb\0"
	"\xc5\x9f\x62\0"
	"\xc3\x9d\0"
	"\xc5\x9e\0"
	"\xc3\xbd\x61nwar\0"
	"fewral\0"
	"ma\xc3\xbd\0"
	"i\xc3\xbdun\0"
	"i\xc3\xbdul\0"
	"sent\xc3\xbd\x61\x62r\0"
	"okt\xc3\xbd\x61\x62r\0"
	"no\xc3\xbd\x61\x62r\0"
	"\xc3\xbd\x61n\0"
	"few\0"
	"no\xc3\xbd\0"
	"yakshanba\0"
	"dushanba\0"
	"seshanba\0"
	"chorshanba\0"
	"payshanba\0"
	"juma\0"
	"shanba\0"
	"Yak\0"
	"Dush\0"
	"Sesh\0"
	"Chor\0"
	"Pay\0"
	"Shan\0"
	"Y\0"
	"Iyun\0"
	"Iyul\0"
	"Avgust\0"
	"Sentabr\0"
	"Oktabr\0"
	"sentabr\0"
	"oktabr\0"
	"Fev\0"
	"Iyn\0"
	"Iyl\0"
	"Avg\0"
	"Noy\0"
	"Dek\0"
	"\xd1\x8f\xd0\xba\xd1\x88\xd3\x99\xd0\xbc\xd0\xb1\xd0\xb5\0"
	"\xd0\xb4\xd2\xaf\xd1\x88\xd3\x99\xd0\xbc\xd0\xb1\xd0\xb5\0"
	"\xd1\x81\xd0\xb8\xd1\x88\xd3\x99\xd0\xbc\xd0\xb1\xd0\xb5\0"
	"\xd1\x87\xd3\x99\xd1\x80\xd1\x88\xd3\x99\xd0\xbc\xd0\xb1\xd0\xb5\0"
	"\xd0\xbf\xd3\x99\xd0\xbd\xd2\x97\xd0\xb5\xd1\x88\xd3\x99\xd0\xbc\xd0\xb1\xd0\xb5\0"
	"\xd2\x97\xd0\xbe\xd0\xbc\xd0\xb3\xd0\xb0\0"
	"\xd1\x88\xd0\xb8\xd0\xbc\xd0\xb1\xd3\x99\0"
	"\xd1\x8f\xd0\xba\xd1\x88.\0"
	"\xd0\xb4\xd2\xaf\xd1\x88.\0"
	"\xd1\x81\xd0\xb8\xd1\x88.\0"
	"\xd1\x87\xd3\x99\xd1\x80.\0"
	"\xd0\xbf\xd3\x99\xd0\xbd\xd2\x97.\0"
	"\xd2\x97\xd0\xbe\xd0\xbc.\0"
	"\xd1\x88\xd0\xb8\xd0\xbc.\0"
	"\xd0\xaf\0"
	"\xd2\x96\0"
	"\xd0\xb3\xd1\x8b\xd0\xb9\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\0"
	"\xd0\xb3\xd1\x8b\xd0\xb9\xd0\xbd.\0"
	"\xe0\xa6\xb0\xe0\xa6\xac\xe0\xa6\xbf\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xb8\xe0\xa7\x8b\xe0\xa6\xae\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xae\xe0\xa6\x99\xe0\xa7\x8d\xe0\xa6\x97\xe0\xa6\xb2\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xac\xe0\xa7\x81\xe0\xa6\xa7\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xac\xe0\xa7\x83\xe0\xa6\xb9\xe0\xa6\xb8\xe0\xa7\x8d\xe0\xa6\xaa\xe0\xa6\xa4\xe0\xa6\xbf\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xb6\xe0\xa7\x81\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa6\xb0\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xb6\xe0\xa6\xa8\xe0\xa6\xbf\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa6\xb0\xe0\xa6\xac\xe0\xa6\xbf\0"
	"\xe0\xa6\xb8\xe0\xa7\x8b\xe0\xa6\xae\0"
	"\xe0\xa6\xae\xe0\xa6\x99\xe0\xa7\x8d\xe0\xa6\x97\xe0\xa6\xb2\0"
	"\xe0\xa6\xac\xe0\xa7\x81\xe0\xa6\xa7\0"
	"\xe0\xa6\xac\xe0\xa7\x83\xe0\xa6\xb9\xe0\xa6\xb8\xe0\xa7\x8d\xe0\xa6\xaa\xe0\xa6\xa4\xe0\xa6\xbf\0"
	"\xe0\xa6\xb6\xe0\xa7\x81\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa6\xb0\0"
	"\xe0\xa6\xb6\xe0\xa6\xa8\xe0\xa6\xbf\0"
	"\xe0\xa6\xb0\0"
	"\xe0\xa6\xb8\xe0\xa7\x8b\0"
	"\xe0\xa6\xae\0"
	"\xe0\xa6\xac\xe0\xa7\x81\0"
	"\xe0\xa6\xac\xe0\xa7\x83\0"
	"\xe0\xa6\xb6\xe0\xa7\x81\0"
	"\xe0\xa6\xb6\0"
	"\xe0\xa6\x9c\xe0\xa6\xbe\xe0\xa6\xa8\xe0\xa7\x81\xe0\xa6\xaf\xe0\xa6\xbc\xe0\xa6\xbe\xe0\xa6\xb0\xe0\xa7\x80\0"
	"\xe0\xa6\xab\xe0\xa7\x87\xe0\xa6\xac\xe0\xa7\x8d\xe0\xa6\xb0\xe0\xa7\x81\xe0\xa6\xaf\xe0\xa6\xbc\xe0\xa6\xbe\xe0\xa6\xb0\xe0\xa7\x80\0"
	"\xe0\xa6\xae\xe0\xa6\xbe\xe0\xa6\xb0\xe0\xa7\x8d\xe0\xa6\x9a\0"
	"\xe0\xa6\x8f\xe0\xa6\xaa\xe0\xa7\x8d\xe0\xa6\xb0\xe0\xa6\xbf\xe0\xa6\xb2\0"
	"\xe0\xa6\xae\xe0\xa7\x87\0"
	"\xe0\xa6\x9c\xe0\xa7\x81\xe0\xa6\xa8\0"
	"\xe0\xa6\x9c\xe0\xa7\x81\xe0\xa6\xb2\xe0\xa6\xbe\xe0\xa6\x87\0"
	"\xe0\xa6\x86\xe0\xa6\x97\xe0\xa6\xb8\xe0\xa7\x8d\xe0\xa6\x9f\0"
	"\xe0\xa6\xb8\xe0\xa7\x87\xe0\xa6\xaa\xe0\xa7\x8d\xe0\xa6\x9f\xe0\xa7\x87\xe0\xa6\xae\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa6\xb0\0"
	"\xe0\xa6\x85\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa6\x9f\xe0\xa7\x8b\xe0\xa6\xac\xe0\xa6\xb0\0"
	"\xe0\xa6\xa8\xe0\xa6\xad\xe0\xa7\x87\xe0\xa6\xae\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa6\xb0\0"
	"\xe0\xa6\xa1\xe0\xa6\xbf\xe0\xa6\xb8\xe0\xa7\x87\xe0\xa6\xae\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa6\xb0\0"
	"\xe0\xa8\x90\xe0\xa8\xa4\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\xb8\xe0\xa9\x8b\xe0\xa8\xae\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\xae\xe0\xa9\xb0\xe0\xa8\x97\xe0\xa8\xb2\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\xac\xe0\xa9\x81\xe0\xa9\xb1\xe0\xa8\xa7\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\xb5\xe0\xa9\x80\xe0\xa8\xb0\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\xb8\xe0\xa8\xbc\xe0\xa9\x81\xe0\xa9\xb1\xe0\xa8\x95\xe0\xa8\xb0\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\xb8\xe0\xa8\xbc\xe0\xa8\xa8\xe0\xa8\xbf\xe0\xa9\xb1\xe0\xa8\x9a\xe0\xa8\xb0\xe0\xa8\xb5\xe0\xa8\xbe\xe0\xa8\xb0\0"
	"\xe0\xa8\x90\xe0\xa8\xa4\0"
	"\xe0\xa8\xb8\xe0\xa9\x8b\xe0\xa8\xae\0"
	"\xe0\xa8\xae\xe0\xa9\xb0\xe0\xa8\x97\xe0\xa8\xb2\0"
	"\xe0\xa8\xac\xe0\xa9\x81\xe0\xa9\xb1\xe0\xa8\xa7\0"
	"\xe0\xa8\xb5\xe0\xa9\x80\xe0\xa8\xb0\0"
	"\xe0\xa8\xb8\xe0\xa8\xbc\xe0\xa9\x81\xe0\xa9\xb1\xe0\xa8\x95\xe0\xa8\xb0\0"
	"\xe0\xa8\xb8\xe0\xa8\xbc\xe0\xa8\xa8\xe0\xa8\xbf\xe0\xa9\xb1\xe0\xa8\x9a\xe0\xa8\xb0\0"
	"\xe0\xa8\x90\0"
	"\xe0\xa8\xb8\xe0\xa9\x8b\0"
	"\xe0\xa8\xae\xe0\xa9\xb0\0"
	"\xe0\xa8\xac\xe0\xa9\x81\xe0\xa9\xb1\0"
	"\xe0\xa8\xb5\xe0\xa9\x80\0"
	"\xe0\xa8\xb8\xe0\xa8\xbc\xe0\xa9\x81\xe0\xa9\xb1\0"
	"\xe0\xa8\xb8\xe0\xa8\xbc\0"
	"\xe0\xa8\x9c\xe0\xa8\xa8\xe0\xa8\xb5\xe0\xa8\xb0\xe0\xa9\x80\0"
	"\xe0\xa8\xab\xe0\xa8\xbc\xe0\xa8\xb0\xe0\xa8\xb5\xe0\xa8\xb0\xe0\xa9\x80\0"
	"\xe0\xa8\xae\xe0\xa8\xbe\xe0\xa8\xb0\xe0\xa8\x9a\0"
	"\xe0\xa8\x85\xe0\xa8\xaa\xe0\xa9\x8d\xe0\xa8\xb0\xe0\xa9\x88\xe0\xa8\xb2\0"
	"\xe0\xa8\xae\xe0\xa8\x88\0"
	"\xe0\xa8\x9c\xe0\xa9\x82\xe0\xa8\xa8\0"
	"\xe0\xa8\x9c\xe0\xa9\x81\xe0\xa8\xb2\xe0\xa8\xbe\xe0\xa8\x88\0"
	"\xe0\xa8\x85\xe0\xa8\x97\xe0\xa8\xb8\xe0\xa8\xa4\0"
	"\xe0\xa8\xb8\xe0\xa8\xa4\xe0\xa9\xb0\xe0\xa8\xac\xe0\xa8\xb0\0"
	"\xe0\xa8\x85\xe0\xa8\x95\xe0\xa8\xa4\xe0\xa9\x82\xe0\xa8\xac\xe0\xa8\xb0\0"
	"\xe0\xa8\xa8\xe0\xa8\xb5\xe0\xa9\xb0\xe0\xa8\xac\xe0\xa8\xb0\0"
	"\xe0\xa8\xa6\xe0\xa8\xb8\xe0\xa9\xb0\xe0\xa8\xac\xe0\xa8\xb0\0"
	"\xe0\xa8\x9c\xe0\xa8\xa8\0"
	"\xe0\xa8\xab\xe0\xa8\xbc\xe0\xa8\xb0\0"
	"\xe0\xa8\x85\xe0\xa8\xaa\xe0\xa9\x8d\xe0\xa8\xb0\xe0\xa9\x88\0"
	"\xe0\xa8\x9c\xe0\xa9\x81\xe0\xa8\xb2\xe0\xa8\xbe\0"
	"\xe0\xa8\x85\xe0\xa8\x97\0"
	"\xe0\xa8\xb8\xe0\xa8\xa4\xe0\xa9\xb0\0"
	"\xe0\xa8\x85\xe0\xa8\x95\xe0\xa8\xa4\xe0\xa9\x82\0"
	"\xe0\xa8\xa8\xe0\xa8\xb5\xe0\xa9\xb0\0"
	"\xe0\xa8\xa6\xe0\xa8\xb8\xe0\xa9\xb0\0"
	"\xe0\xaa\xb0\xe0\xaa\xb5\xe0\xaa\xbf\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\xb8\xe0\xab\x8b\xe0\xaa\xae\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\xae\xe0\xaa\x82\xe0\xaa\x97\xe0\xaa\xb3\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\xac\xe0\xab\x81\xe0\xaa\xa7\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\x97\xe0\xab\x81\xe0\xaa\xb0\xe0\xab\x81\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\xb6\xe0\xab\x81\xe0\xaa\x95\xe0\xab\x8d\xe0\xaa\xb0\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\xb6\xe0\xaa\xa8\xe0\xaa\xbf\xe0\xaa\xb5\xe0\xaa\xbe\xe0\xaa\xb0\0"
	"\xe0\xaa\xb0\xe0\xaa\xb5\xe0\xaa\xbf\0"
	"\xe0\xaa\xb8\xe0\xab\x8b\xe0\xaa\xae\0"
	"\xe0\xaa\xae\xe0\xaa\x82\xe0\xaa\x97\xe0\xaa\xb3\0"
	"\xe0\xaa\xac\xe0\xab\x81\xe0\xaa\xa7\0"
	"\xe0\xaa\x97\xe0\xab\x81\xe0\xaa\xb0\xe0\xab\x81\0"
	"\xe0\xaa\xb6\xe0\xab\x81\xe0\xaa\x95\xe0\xab\x8d\xe0\xaa\xb0\0"
	"\xe0\xaa\xb6\xe0\xaa\xa8\xe0\xaa\xbf\0"
	"\xe0\xaa\xb0\0"
	"\xe0\xaa\xb8\xe0\xab\x8b\0"
	"\xe0\xaa\xae\xe0\xaa\x82\0"
	"\xe0\xaa\xac\xe0\xab\x81\0"
	"\xe0\xaa\x97\xe0\xab\x81\0"
	"\xe0\xaa\xb6\xe0\xab\x81\0"
	"\xe0\xaa\xb6\0"
	"\xe0\xaa\x9c\xe0\xaa\xbe\xe0\xaa\xa8\xe0\xab\x8d\xe0\xaa\xaf\xe0\xab\x81\xe0\xaa\x86\xe0\xaa\xb0\xe0\xab\x80\0"
	"\xe0\xaa\xab\xe0\xab\x87\xe0\xaa\xac\xe0\xab\x8d\xe0\xaa\xb0\xe0\xab\x81\xe0\xaa\x86\xe0\xaa\xb0\xe0\xab\x80\0"
	"\xe0\xaa\xae\xe0\xaa\xbe\xe0\xaa\xb0\xe0\xab\x8d\xe0\xaa\x9a\0"
	"\xe0\xaa\x8f\xe0\xaa\xaa\xe0\xab\x8d\xe0\xaa\xb0\xe0\xaa\xbf\xe0\xaa\xb2\0"
	"\xe0\xaa\xae\xe0\xab\x87\0"
	"\xe0\xaa\x9c\xe0\xab\x82\xe0\xaa\xa8\0"
	"\xe0\xaa\x9c\xe0\xab\x81\xe0\xaa\xb2\xe0\xaa\xbe\xe0\xaa\x88\0"
	"\xe0\xaa\x91\xe0\xaa\x97\xe0\xaa\xb8\xe0\xab\x8d\xe0\xaa\x9f\0"
	"\xe0\xaa\xb8\xe0\xaa\xaa\xe0\xab\x8d\xe0\xaa\x9f\xe0\xab\x87\xe0\xaa\xae\xe0\xab\x8d\xe0\xaa\xac\xe0\xaa\xb0\0"
	"\xe0\xaa\x91\xe0\xaa\x95\xe0\xab\x8d\xe0\xaa\x9f\xe0\xab\x8b\xe0\xaa\xac\xe0\xaa\xb0\0"
	"\xe0\xaa\xa8\xe0\xaa\xb5\xe0\xab\x87\xe0\xaa\xae\xe0\xab\x8d\xe0\xaa\xac\xe0\xaa\xb0\0"
	"\xe0\xaa\xa1\xe0\xaa\xbf\xe0\xaa\xb8\xe0\xab\x87\xe0\xaa\xae\xe0\xab\x8d\xe0\xaa\xac\xe0\xaa\xb0\0"
	"\xe0\xaa\x9c\xe0\xaa\xbe\xe0\xaa\xa8\xe0\xab\x8d\xe0\xaa\xaf\xe0\xab\x81\0"
	"\xe0\xaa\xab\xe0\xab\x87\xe0\xaa\xac\xe0\xab\x8d\xe0\xaa\xb0\xe0\xab\x81\0"
	"\xe0\xaa\xb8\xe0\xaa\xaa\xe0\xab\x8d\xe0\xaa\x9f\xe0\xab\x87\0"
	"\xe0\xaa\x91\xe0\xaa\x95\xe0\xab\x8d\xe0\xaa\x9f\xe0\xab\x8b\0"
	"\xe0\xaa\xa8\xe0\xaa\xb5\xe0\xab\x87\0"
	"\xe0\xaa\xa1\xe0\xaa\xbf\xe0\xaa\xb8\xe0\xab\x87\0"
	"\xe0\xac\xb0\xe0\xac\xac\xe0\xac\xbf\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\xb8\xe0\xad\x8b\xe0\xac\xae\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\xae\xe0\xac\x99\xe0\xad\x8d\xe0\xac\x97\xe0\xac\xb3\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\xac\xe0\xad\x81\xe0\xac\xa7\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\x97\xe0\xad\x81\xe0\xac\xb0\xe0\xad\x81\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\xb6\xe0\xad\x81\xe0\xac\x95\xe0\xad\x8d\xe0\xac\xb0\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\xb6\xe0\xac\xa8\xe0\xac\xbf\xe0\xac\xac\xe0\xac\xbe\xe0\xac\xb0\0"
	"\xe0\xac\xb0\xe0\xac\xac\xe0\xac\xbf\0"
	"\xe0\xac\xb8\xe0\xad\x8b\xe0\xac\xae\0"
	"\xe0\xac\xae\xe0\xac\x99\xe0\xad\x8d\xe0\xac\x97\xe0\xac\xb3\0"
	"\xe0\xac\xac\xe0\xad\x81\xe0\xac\xa7\0"
	"\xe0\xac\x97\xe0\xad\x81\xe0\xac\xb0\xe0\xad\x81\0"
	"\xe0\xac\xb6\xe0\xad\x81\xe0\xac\x95\xe0\xad\x8d\xe0\xac\xb0\0"
	"\xe0\xac\xb6\xe0\xac\xa8\xe0\xac\xbf\0"
	"\xe0\xac\xb0\0"
	"\xe0\xac\xb8\xe0\xad\x8b\0"
	"\xe0\xac\xae\0"
	"\xe0\xac\xac\xe0\xad\x81\0"
	"\xe0\xac\x97\xe0\xad\x81\0"
	"\xe0\xac\xb6\xe0\xad\x81\0"
	"\xe0\xac\xb6\0"
	"\xe0\xac\x9c\xe0\xac\xbe\xe0\xac\xa8\xe0\xad\x81\xe0\xac\x86\xe0\xac\xb0\xe0\xad\x80\0"
	"\xe0\xac\xab\xe0\xad\x87\xe0\xac\xac\xe0\xad\x83\xe0\xac\x86\xe0\xac\xb0\xe0\xad\x80\0"
	"\xe0\xac\xae\xe0\xac\xbe\xe0\xac\xb0\xe0\xad\x8d\xe0\xac\x9a\xe0\xad\x8d\xe0\xac\x9a\0"
	"\xe0\xac\x85\xe0\xac\xaa\xe0\xad\x8d\xe0\xac\xb0\xe0\xad\x87\xe0\xac\xb2\0"
	"\xe0\xac\xae\xe0\xac\x87\0"
	"\xe0\xac\x9c\xe0\xad\x81\xe0\xac\xa8\0"
	"\xe0\xac\x9c\xe0\xad\x81\xe0\xac\xb2\xe0\xac\xbe\xe0\xac\x87\0"
	"\xe0\xac\x85\xe0\xac\x97\xe0\xac\xb7\xe0\xad\x8d\xe0\xac\x9f\0"
	"\xe0\xac\xb8\xe0\xad\x87\xe0\xac\xaa\xe0\xad\x8d\xe0\xac\x9f\xe0\xad\x87\xe0\xac\xae\xe0\xad\x8d\xe0\xac\xac\xe0\xac\xb0\0"
	"\xe0\xac\x85\xe0\xac\x95\xe0\xad\x8d\xe0\xac\x9f\xe0\xad\x8b\xe0\xac\xac\xe0\xac\xb0\0"
	"\xe0\xac\xa8\xe0\xac\xad\xe0\xad\x87\xe0\xac\xae\xe0\xad\x8d\xe0\xac\xac\xe0\xac\xb0\0"
	"\xe0\xac\xa1\xe0\xac\xbf\xe0\xac\xb8\xe0\xad\x87\xe0\xac\xae\xe0\xad\x8d\xe0\xac\xac\xe0\xac\xb0\0"
	"\xe0\xae\x9e\xe0\xae\xbe\xe0\xae\xaf\xe0\xae\xbf\xe0\xae\xb1\xe0\xaf\x81\0"
	"\xe0\xae\xa4\xe0\xae\xbf\xe0\xae\x99\xe0\xaf\x8d\xe0\xae\x95\xe0\xae\xb3\xe0\xaf\x8d\0"
	"\xe0\xae\x9a\xe0\xaf\x86\xe0\xae\xb5\xe0\xaf\x8d\xe0\xae\xb5\xe0\xae\xbe\xe0\xae\xaf\xe0\xaf\x8d\0"
	"\xe0\xae\xaa\xe0\xaf\x81\xe0\xae\xa4\xe0\xae\xa9\xe0\xaf\x8d\0"
	"\xe0\xae\xb5\xe0\xae\xbf\xe0\xae\xaf\xe0\xae\xbe\xe0\xae\xb4\xe0\xae\xa9\xe0\xaf\x8d\0"
	"\xe0\xae\xb5\xe0\xaf\x86\xe0\xae\xb3\xe0\xaf\x8d\xe0\xae\xb3\xe0\xae\xbf\0"
	"\xe0\xae\x9a\xe0\xae\xa9\xe0\xae\xbf\0"
	"\xe0\xae\x9e\xe0\xae\xbe\xe0\xae\xaf\xe0\xae\xbf.\0"
	"\xe0\xae\xa4\xe0\xae\xbf\xe0\xae\x99\xe0\xaf\x8d.\0"
	"\xe0\xae\x9a\xe0\xaf\x86\xe0\xae\xb5\xe0\xaf\x8d.\0"
	"\xe0\xae\xaa\xe0\xaf\x81\xe0\xae\xa4.\0"
	"\xe0\xae\xb5\xe0\xae\xbf\xe0\xae\xaf\xe0\xae\xbe.\0"
	"\xe0\xae\xb5\xe0\xaf\x86\xe0\xae\xb3\xe0\xaf\x8d.\0"
	"\xe0\xae\x9e\xe0\xae\xbe\0"
	"\xe0\xae\xa4\xe0\xae\xbf\0"
	"\xe0\xae\x9a\xe0\xaf\x86\0"
	"\xe0\xae\xaa\xe0\xaf\x81\0"
	"\xe0\xae\xb5\xe0\xae\xbf\0"
	"\xe0\xae\xb5\xe0\xaf\x86\0"
	"\xe0\xae\x9a\0"
	"\xe0\xae\x9c\xe0\xae\xa9\xe0\xae\xb5\xe0\xae\xb0\xe0\xae\xbf\0"
	"\xe0\xae\xaa\xe0\xae\xbf\xe0\xae\xaa\xe0\xaf\x8d\xe0\xae\xb0\xe0\xae\xb5\xe0\xae\xb0\xe0\xae\xbf\0"
	"\xe0\xae\xae\xe0\xae\xbe\xe0\xae\xb0\xe0\xaf\x8d\xe0\xae\x9a\xe0\xaf\x8d\0"
	"\xe0\xae\x8f\xe0\xae\xaa\xe0\xaf\x8d\xe0\xae\xb0\xe0\xae\xb2\xe0\xaf\x8d\0"
	"\xe0\xae\xae\xe0\xaf\x87\0"
	"\xe0\xae\x9c\xe0\xaf\x82\xe0\xae\xa9\xe0\xaf\x8d\0"
	"\xe0\xae\x9c\xe0\xaf\x82\xe0\xae\xb2\xe0\xaf\x88\0"
	"\xe0\xae\x86\xe0\xae\x95\xe0\xae\xb8\xe0\xaf\x8d\xe0\xae\x9f\xe0\xaf\x8d\0"
	"\xe0\xae\x9a\xe0\xaf\x86\xe0\xae\xaa\xe0\xaf\x8d\xe0\xae\x9f\xe0\xae\xae\xe0\xaf\x8d\xe0\xae\xaa\xe0\xae\xb0\xe0\xaf\x8d\0"
	"\xe0\xae\x85\xe0\xae\x95\xe0\xaf\x8d\xe0\xae\x9f\xe0\xaf\x8b\xe0\xae\xaa\xe0\xae\xb0\xe0\xaf\x8d\0"
	"\xe0\xae\xa8\xe0\xae\xb5\xe0\xae\xae\xe0\xaf\x8d\xe0\xae\xaa\xe0\xae\xb0\xe0\xaf\x8d\0"
	"\xe0\xae\x9f\xe0\xae\xbf\xe0\xae\x9a\xe0\xae\xae\xe0\xaf\x8d\xe0\xae\xaa\xe0\xae\xb0\xe0\xaf\x8d\0"
	"\xe0\xae\x9c\xe0\xae\xa9.\0"
	"\xe0\xae\xaa\xe0\xae\xbf\xe0\xae\xaa\xe0\xaf\x8d.\0"
	"\xe0\xae\xae\xe0\xae\xbe\xe0\xae\xb0\xe0\xaf\x8d.\0"
	"\xe0\xae\x8f\xe0\xae\xaa\xe0\xaf\x8d.\0"
	"\xe0\xae\x86\xe0\xae\x95.\0"
	"\xe0\xae\x9a\xe0\xaf\x86\xe0\xae\xaa\xe0\xaf\x8d.\0"
	"\xe0\xae\x85\xe0\xae\x95\xe0\xaf\x8d.\0"
	"\xe0\xae\xa8\xe0\xae\xb5.\0"
	"\xe0\xae\x9f\xe0\xae\xbf\xe0\xae\x9a.\0"
	"\xe0\xb0\x86\xe0\xb0\xa6\xe0\xb0\xbf\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\xb8\xe0\xb1\x8b\xe0\xb0\xae\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\xae\xe0\xb0\x82\xe0\xb0\x97\xe0\xb0\xb3\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\xac\xe0\xb1\x81\xe0\xb0\xa7\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\x97\xe0\xb1\x81\xe0\xb0\xb0\xe0\xb1\x81\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\xb6\xe0\xb1\x81\xe0\xb0\x95\xe0\xb1\x8d\xe0\xb0\xb0\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\xb6\xe0\xb0\xa8\xe0\xb0\xbf\xe0\xb0\xb5\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb0\x82\0"
	"\xe0\xb0\x86\xe0\xb0\xa6\xe0\xb0\xbf\0"
	"\xe0\xb0\xb8\xe0\xb1\x8b\xe0\xb0\xae\0"
	"\xe0\xb0\xae\xe0\xb0\x82\xe0\xb0\x97\xe0\xb0\xb3\0"
	"\xe0\xb0\xac\xe0\xb1\x81\xe0\xb0\xa7\0"
	"\xe0\xb0\x97\xe0\xb1\x81\xe0\xb0\xb0\xe0\xb1\x81\0"
	"\xe0\xb0\xb6\xe0\xb1\x81\xe0\xb0\x95\xe0\xb1\x8d\xe0\xb0\xb0\0"
	"\xe0\xb0\xb6\xe0\xb0\xa8\xe0\xb0\xbf\0"
	"\xe0\xb0\x86\0"
	"\xe0\xb0\xb8\xe0\xb1\x8b\0"
	"\xe0\xb0\xae\0"
	"\xe0\xb0\xac\xe0\xb1\x81\0"
	"\xe0\xb0\x97\xe0\xb1\x81\0"
	"\xe0\xb0\xb6\xe0\xb1\x81\0"
	"\xe0\xb0\xb6\0"
	"\xe0\xb0\x9c\xe0\xb0\xa8\xe0\xb0\xb5\xe0\xb0\xb0\xe0\xb0\xbf\0"
	"\xe0\xb0\xab\xe0\xb0\xbf\xe0\xb0\xac\xe0\xb1\x8d\xe0\xb0\xb0\xe0\xb0\xb5\xe0\xb0\xb0\xe0\xb0\xbf\0"
	"\xe0\xb0\xae\xe0\xb0\xbe\xe0\xb0\xb0\xe0\xb1\x8d\xe0\xb0\x9a\xe0\xb0\xbf\0"
	"\xe0\xb0\x8f\xe0\xb0\xaa\xe0\xb1\x8d\xe0\xb0\xb0\xe0\xb0\xbf\xe0\xb0\xb2\xe0\xb1\x8d\0"
	"\xe0\xb0\xae\xe0\xb1\x87\0"
	"\xe0\xb0\x9c\xe0\xb1\x82\xe0\xb0\xa8\xe0\xb1\x8d\0"
	"\xe0\xb0\x9c\xe0\xb1\x81\xe0\xb0\xb2\xe0\xb1\x88\0"
	"\xe0\xb0\x86\xe0\xb0\x97\xe0\xb0\xb8\xe0\xb1\x8d\xe0\xb0\x9f\xe0\xb1\x81\0"
	"\xe0\xb0\xb8\xe0\xb1\x86\xe0\xb0\xaa\xe0\xb1\x8d\xe0\xb0\x9f\xe0\xb1\x86\xe0\xb0\x82\xe0\xb0\xac\xe0\xb0\xb0\xe0\xb1\x8d\0"
	"\xe0\xb0\x85\xe0\xb0\x95\xe0\xb1\x8d\xe0\xb0\x9f\xe0\xb1\x8b\xe0\xb0\xac\xe0\xb0\xb0\xe0\xb1\x8d\0"
	"\xe0\xb0\xa8\xe0\xb0\xb5\xe0\xb0\x82\xe0\xb0\xac\xe0\xb0\xb0\xe0\xb1\x8d\0"
	"\xe0\xb0\xa1\xe0\xb0\xbf\xe0\xb0\xb8\xe0\xb1\x86\xe0\xb0\x82\xe0\xb0\xac\xe0\xb0\xb0\xe0\xb1\x8d\0"
	"\xe0\xb0\x9c\xe0\xb0\xa8\0"
	"\xe0\xb0\xab\xe0\xb0\xbf\xe0\xb0\xac\xe0\xb1\x8d\xe0\xb0\xb0\0"
	"\xe0\xb0\x8f\xe0\xb0\xaa\xe0\xb1\x8d\xe0\xb0\xb0\xe0\xb0\xbf\0"
	"\xe0\xb0\xb8\xe0\xb1\x86\xe0\xb0\xaa\xe0\xb1\x8d\xe0\xb0\x9f\xe0\xb1\x86\xe0\xb0\x82\0"
	"\xe0\xb0\x85\xe0\xb0\x95\xe0\xb1\x8d\xe0\xb0\x9f\xe0\xb1\x8b\0"
	"\xe0\xb0\xa8\xe0\xb0\xb5\xe0\xb0\x82\0"
	"\xe0\xb0\xa1\xe0\xb0\xbf\xe0\xb0\xb8\xe0\xb1\x86\xe0\xb0\x82\0"
	"\xe0\xb2\xad\xe0\xb2\xbe\xe0\xb2\xa8\xe0\xb3\x81\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\xb8\xe0\xb3\x8b\xe0\xb2\xae\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\xae\xe0\xb2\x82\xe0\xb2\x97\xe0\xb2\xb3\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\xac\xe0\xb3\x81\xe0\xb2\xa7\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\x97\xe0\xb3\x81\xe0\xb2\xb0\xe0\xb3\x81\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\xb6\xe0\xb3\x81\xe0\xb2\x95\xe0\xb3\x8d\xe0\xb2\xb0\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\xb6\xe0\xb2\xa8\xe0\xb2\xbf\xe0\xb2\xb5\xe0\xb2\xbe\xe0\xb2\xb0\0"
	"\xe0\xb2\xad\xe0\xb2\xbe\xe0\xb2\xa8\xe0\xb3\x81\0"
	"\xe0\xb2\xb8\xe0\xb3\x8b\xe0\xb2\xae\0"
	"\xe0\xb2\xae\xe0\xb2\x82\xe0\xb2\x97\xe0\xb2\xb3\0"
	"\xe0\xb2\xac\xe0\xb3\x81\xe0\xb2\xa7\0"
	"\xe0\xb2\x97\xe0\xb3\x81\xe0\xb2\xb0\xe0\xb3\x81\0"
	"\xe0\xb2\xb6\xe0\xb3\x81\xe0\xb2\x95\xe0\xb3\x8d\xe0\xb2\xb0\0"
	"\xe0\xb2\xb6\xe0\xb2\xa8\xe0\xb2\xbf\0"
	"\xe0\xb2\xad\xe0\xb2\xbe\0"
	"\xe0\xb2\xb8\xe0\xb3\x8b\0"
	"\xe0\xb2\xae\xe0\xb2\x82\0"
	"\xe0\xb2\xac\xe0\xb3\x81\0"
	"\xe0\xb2\x97\xe0\xb3\x81\0"
	"\xe0\xb2\xb6\xe0\xb3\x81\0"
	"\xe0\xb2\xb6\0"
	"\xe0\xb2\x9c\xe0\xb2\xa8\xe0\xb2\xb5\xe0\xb2\xb0\xe0\xb2\xbf\0"
	"\xe0\xb2\xab\xe0\xb3\x86\xe0\xb2\xac\xe0\xb3\x8d\xe0\xb2\xb0\xe0\xb2\xb5\xe0\xb2\xb0\xe0\xb2\xbf\0"
	"\xe0\xb2\xae\xe0\xb2\xbe\xe0\xb2\xb0\xe0\xb3\x8d\xe0\xb2\x9a\xe0\xb3\x8d\0"
	"\xe0\xb2\x8f\xe0\xb2\xaa\xe0\xb3\x8d\xe0\xb2\xb0\xe0\xb2\xbf\xe0\xb2\xb2\xe0\xb3\x8d\0"
	"\xe0\xb2\xae\xe0\xb3\x87\0"
	"\xe0\xb2\x9c\xe0\xb3\x82\xe0\xb2\xa8\xe0\xb3\x8d\0"
	"\xe0\xb2\x9c\xe0\xb3\x81\xe0\xb2\xb2\xe0\xb3\x88\0"
	"\xe0\xb2\x86\xe0\xb2\x97\xe0\xb2\xb8\xe0\xb3\x8d\xe0\xb2\x9f\xe0\xb3\x8d\0"
	"\xe0\xb2\xb8\xe0\xb3\x86\xe0\xb2\xaa\xe0\xb3\x8d\xe0\xb2\x9f\xe0\xb3\x86\xe0\xb2\x82\xe0\xb2\xac\xe0\xb2\xb0\xe0\xb3\x8d\0"
	"\xe0\xb2\x85\xe0\xb2\x95\xe0\xb3\x8d\xe0\xb2\x9f\xe0\xb3\x8b\xe0\xb2\xac\xe0\xb2\xb0\xe0\xb3\x8d\0"
	"\xe0\xb2\xa8\xe0\xb2\xb5\xe0\xb3\x86\xe0\xb2\x82\xe0\xb2\xac\xe0\xb2\xb0\xe0\xb3\x8d\0"
	"\xe0\xb2\xa1\xe0\xb2\xbf\xe0\xb2\xb8\xe0\xb3\x86\xe0\xb2\x82\xe0\xb2\xac\xe0\xb2\xb0\xe0\xb3\x8d\0"
	"\xe0\xb2\x9c\xe0\xb2\xa8\0"
	"\xe0\xb2\xab\xe0\xb3\x86\xe0\xb2\xac\xe0\xb3\x8d\xe0\xb2\xb0\0"
	"\xe0\xb2\x8f\xe0\xb2\xaa\xe0\xb3\x8d\xe0\xb2\xb0\xe0\xb2\xbf\0"
	"\xe0\xb2\x86\xe0\xb2\x97\0"
	"\xe0\xb2\xb8\xe0\xb3\x86\xe0\xb2\xaa\xe0\xb3\x8d\xe0\xb2\x9f\xe0\xb3\x86\xe0\xb2\x82\0"
	"\xe0\xb2\x85\xe0\xb2\x95\xe0\xb3\x8d\xe0\xb2\x9f\xe0\xb3\x8b\0"
	"\xe0\xb2\xa8\xe0\xb2\xb5\xe0\xb3\x86\xe0\xb2\x82\0"
	"\xe0\xb2\xa1\xe0\xb2\xbf\xe0\xb2\xb8\xe0\xb3\x86\xe0\xb2\x82\0"
	"\xe0\xb4\x9e\xe0\xb4\xbe\xe0\xb4\xaf\xe0\xb4\xb1\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9a\0"
	"\xe0\xb4\xa4\xe0\xb4\xbf\xe0\xb4\x99\xe0\xb5\x8d\xe0\xb4\x95\xe0\xb4\xb3\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9a\0"
	"\xe0\xb4\x9a\xe0\xb5\x8a\xe0\xb4\xb5\xe0\xb5\x8d\xe0\xb4\xb5\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe0\xb4\x9a\0"
	"\xe0\xb4\xac\xe0\xb5\x81\xe0\xb4\xa7\xe0\xb4\xa8\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9a\0"
	"\xe0\xb4\xb5\xe0\xb5\x8d\xe0\xb4\xaf\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9a\0"
	"\xe0\xb4\xb5\xe0\xb5\x86\xe0\xb4\xb3\xe0\xb5\x8d\xe0\xb4\xb3\xe0\xb4\xbf\xe0\xb4\xaf\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9a\0"
	"\xe0\xb4\xb6\xe0\xb4\xa8\xe0\xb4\xbf\xe0\xb4\xaf\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9a\0"
	"\xe0\xb4\x9e\xe0\xb4\xbe\xe0\xb4\xaf\xe0\xb5\xbc\0"
	"\xe0\xb4\xa4\xe0\xb4\xbf\xe0\xb4\x99\xe0\xb5\x8d\xe0\xb4\x95\xe0\xb5\xbe\0"
	"\xe0\xb4\x9a\xe0\xb5\x8a\xe0\xb4\xb5\xe0\xb5\x8d\xe0\xb4\xb5\0"
	"\xe0\xb4\xac\xe0\xb5\x81\xe0\xb4\xa7\xe0\xb5\xbb\0"
	"\xe0\xb4\xb5\xe0\xb5\x8d\xe0\xb4\xaf\xe0\xb4\xbe\xe0\xb4\xb4\xe0\xb4\x82\0"
	"\xe0\xb4\xb5\xe0\xb5\x86\xe0\xb4\xb3\xe0\xb5\x8d\xe0\xb4\xb3\xe0\xb4\xbf\0"
	"\xe0\xb4\xb6\xe0\xb4\xa8\xe0\xb4\xbf\0"
	"\xe0\xb4\x9e\xe0\xb4\xbe\0"
	"\xe0\xb4\xa4\xe0\xb4\xbf\0"
	"\xe0\xb4\x9a\xe0\xb5\x8a\0"
	"\xe0\xb4\xac\xe0\xb5\x81\0"
	"\xe0\xb4\xb5\xe0\xb5\x8d\xe0\xb4\xaf\xe0\xb4\xbe\0"
	"\xe0\xb4\xb5\xe0\xb5\x86\0"
	"\xe0\xb4\xb6\0"
	"\xe0\xb4\x9c\xe0\xb4\xa8\xe0\xb5\x81\xe0\xb4\xb5\xe0\xb4\xb0\xe0\xb4\xbf\0"
	"\xe0\xb4\xab\xe0\xb5\x86\xe0\xb4\xac\xe0\xb5\x8d\xe0\xb4\xb0\xe0\xb5\x81\xe0\xb4\xb5\xe0\xb4\xb0\xe0\xb4\xbf\0"
	"\xe0\xb4\xae\xe0\xb4\xbe\xe0\xb5\xbc\xe0\xb4\x9a\xe0\xb5\x8d\xe0\xb4\x9a\xe0\xb5\x8d\0"
	"\xe0\xb4\x8f\xe0\xb4\xaa\xe0\xb5\x8d\xe0\xb4\xb0\xe0\xb4\xbf\xe0\xb5\xbd\0"
	"\xe0\xb4\xae\xe0\xb5\x87\xe0\xb4\xaf\xe0\xb5\x8d\0"
	"\xe0\xb4\x9c\xe0\xb5\x82\xe0\xb5\xba\0"
	"\xe0\xb4\x9c\xe0\xb5\x82\xe0\xb4\xb2\xe0\xb5\x88\0"
	"\xe0\xb4\x93\xe0\xb4\x97\xe0\xb4\xb8\xe0\xb5\x8d\xe0\xb4\xb1\xe0\xb5\x8d\xe0\xb4\xb1\xe0\xb5\x8d\0"
	"\xe0\xb4\xb8\xe0\xb5\x86\xe0\xb4\xaa\xe0\xb5\x8d\xe0\xb4\xb1\xe0\xb5\x8d\xe0\xb4\xb1\xe0\xb4\x82\xe0\xb4\xac\xe0\xb5\xbc\0"
	"\xe0\xb4\x92\xe0\xb4\x95\xe0\xb5\x8d\xe2\x80\x8c\xe0\xb4\x9f\xe0\xb5\x8b\xe0\xb4\xac\xe0\xb5\xbc\0"
	"\xe0\xb4\xa8\xe0\xb4\xb5\xe0\xb4\x82\xe0\xb4\xac\xe0\xb5\xbc\0"
	"\xe0\xb4\xa1\xe0\xb4\xbf\xe0\xb4\xb8\xe0\xb4\x82\xe0\xb4\xac\xe0\xb5\xbc\0"
	"\xe0\xb4\x9c\xe0\xb4\xa8\xe0\xb5\x81\0"
	"\xe0\xb4\xab\xe0\xb5\x86\xe0\xb4\xac\xe0\xb5\x8d\xe0\xb4\xb0\xe0\xb5\x81\0"
	"\xe0\xb4\xae\xe0\xb4\xbe\xe0\xb5\xbc\0"
	"\xe0\xb4\x8f\xe0\xb4\xaa\xe0\xb5\x8d\xe0\xb4\xb0\xe0\xb4\xbf\0"
	"\xe0\xb4\x93\xe0\xb4\x97\0"
	"\xe0\xb4\xb8\xe0\xb5\x86\xe0\xb4\xaa\xe0\xb5\x8d\xe0\xb4\xb1\xe0\xb5\x8d\xe0\xb4\xb1\xe0\xb4\x82\0"
	"\xe0\xb4\x92\xe0\xb4\x95\xe0\xb5\x8d\xe0\xb4\x9f\xe0\xb5\x8b\0"
	"\xe0\xb4\xa8\xe0\xb4\xb5\xe0\xb4\x82\0"
	"\xe0\xb4\xa1\xe0\xb4\xbf\xe0\xb4\xb8\xe0\xb4\x82\0"
	"\xe0\xa6\xa6\xe0\xa7\x87\xe0\xa6\x93\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa6\xb8\xe0\xa7\x8b\xe0\xa6\xae\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa6\xae\xe0\xa6\x99\xe0\xa7\x8d\xe0\xa6\x97\xe0\xa6\xb2\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa6\xac\xe0\xa7\x81\xe0\xa6\xa7\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa6\xac\xe0\xa7\x83\xe0\xa6\xb9\xe0\xa6\xb7\xe0\xa7\x8d\xe0\xa6\xaa\xe0\xa6\xa4\xe0\xa6\xbf\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa6\xb6\xe0\xa7\x81\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa7\xb0\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa6\xb6\xe0\xa6\xa8\xe0\xa6\xbf\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa7\xb0\0"
	"\xe0\xa7\xb0\xe0\xa6\xac\xe0\xa6\xbf\0"
	"\xe0\xa6\xac\xe0\xa7\x83\xe0\xa6\xb9\xe0\xa6\xb7\xe0\xa7\x8d\xe0\xa6\xaa\xe0\xa6\xa4\xe0\xa6\xbf\0"
	"\xe0\xa6\xb6\xe0\xa7\x81\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa7\xb0\0"
	"\xe0\xa6\x9c\xe0\xa6\xbe\xe0\xa6\xa8\xe0\xa7\x81\xe0\xa7\xb1\xe0\xa6\xbe\xe0\xa7\xb0\xe0\xa7\x80\0"
	"\xe0\xa6\xab\xe0\xa7\x87\xe0\xa6\xac\xe0\xa7\x8d\xe0\xa7\xb0\xe0\xa7\x81\xe0\xa7\xb1\xe0\xa6\xbe\xe0\xa7\xb0\xe0\xa7\x80\0"
	"\xe0\xa6\xae\xe0\xa6\xbe\xe0\xa7\xb0\xe0\xa7\x8d\xe0\xa6\x9a\0"
	"\xe0\xa6\x8f\xe0\xa6\xaa\xe0\xa7\x8d\xe0\xa7\xb0\xe0\xa6\xbf\xe0\xa6\xb2\0"
	"\xe0\xa6\x86\xe0\xa6\x97\xe0\xa6\xb7\xe0\xa7\x8d\xe0\xa6\x9f\0"
	"\xe0\xa6\x9b\xe0\xa7\x87\xe0\xa6\xaa\xe0\xa7\x8d\xe0\xa6\xa4\xe0\xa7\x87\xe0\xa6\xae\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa7\xb0\0"
	"\xe0\xa6\x85\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa6\x9f\xe0\xa7\x8b\xe0\xa6\xac\xe0\xa7\xb0\0"
	"\xe0\xa6\xa8\xe0\xa7\xb1\xe0\xa7\x87\xe0\xa6\xae\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa7\xb0\0"
	"\xe0\xa6\xa1\xe0\xa6\xbf\xe0\xa6\x9a\xe0\xa7\x87\xe0\xa6\xae\xe0\xa7\x8d\xe0\xa6\xac\xe0\xa7\xb0\0"
	"\xe0\xa6\x9c\xe0\xa6\xbe\xe0\xa6\xa8\xe0\xa7\x81\0"
	"\xe0\xa6\xab\xe0\xa7\x87\xe0\xa6\xac\xe0\xa7\x8d\xe0\xa7\xb0\xe0\xa7\x81\0"
	"\xe0\xa6\x86\xe0\xa6\x97\0"
	"\xe0\xa6\xb8\xe0\xa7\x87\xe0\xa6\xaa\xe0\xa7\x8d\xe0\xa6\x9f\0"
	"\xe0\xa6\x85\xe0\xa6\x95\xe0\xa7\x8d\xe0\xa6\x9f\xe0\xa7\x8b\0"
	"\xe0\xa6\xa8\xe0\xa6\xad\xe0\xa7\x87\0"
	"\xe0\xa6\xa1\xe0\xa6\xbf\xe0\xa6\xb8\xe0\xa7\x87\0"
	"\xe0\xa4\xae\xe0\xa4\x82\xe0\xa4\x97\xe0\xa4\xb3\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xae\xe0\xa4\x82\xe0\xa4\x97\xe0\xa4\xb3\0"
	"\xe0\xa4\x9c\xe0\xa4\xbe\xe0\xa4\xa8\xe0\xa5\x87\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa5\x80\0"
	"\xe0\xa4\xab\xe0\xa5\x87\xe0\xa4\xac\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x81\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\xe0\xa5\x80\0"
	"\xe0\xa4\x8f\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa4\xbf\xe0\xa4\xb2\0"
	"\xe0\xa4\xae\xe0\xa5\x87\0"
	"\xe0\xa4\x9c\xe0\xa5\x81\xe0\xa4\xb2\xe0\xa5\x88\0"
	"\xe0\xa4\x91\xe0\xa4\x97\xe0\xa4\xb8\xe0\xa5\x8d\xe0\xa4\x9f\0"
	"\xe0\xa4\xb8\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x87\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\x91\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x8b\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\xa8\xe0\xa5\x8b\xe0\xa4\xb5\xe0\xa5\x8d\xe0\xa4\xb9\xe0\xa5\x87\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\xa1\xe0\xa4\xbf\xe0\xa4\xb8\xe0\xa5\x87\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\x9c\xe0\xa4\xbe\xe0\xa4\xa8\xe0\xa5\x87\0"
	"\xe0\xa4\xab\xe0\xa5\x87\xe0\xa4\xac\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x81\0"
	"\xe0\xa4\x8f\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa4\xbf\0"
	"\xe0\xa4\x91\xe0\xa4\x97\0"
	"\xe0\xa4\xb8\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x87\xe0\xa4\x82\0"
	"\xe0\xa4\x91\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x8b\0"
	"\xe0\xa4\xa8\xe0\xa5\x8b\xe0\xa4\xb5\xe0\xa5\x8d\xe0\xa4\xb9\xe0\xa5\x87\xe0\xa4\x82\0"
	"\xe0\xa4\xa1\xe0\xa4\xbf\xe0\xa4\xb8\xe0\xa5\x87\xe0\xa4\x82\0"
	"\xd0\xbd\xd1\x8f\xd0\xbc\0"
	"\xd0\xb4\xd0\xb0\xd0\xb2\xd0\xb0\xd0\xb0\0"
	"\xd0\xbc\xd1\x8f\xd0\xb3\xd0\xbc\xd0\xb0\xd1\x80\0"
	"\xd0\xbb\xd1\x85\xd0\xb0\xd0\xb3\xd0\xb2\xd0\xb0\0"
	"\xd0\xbf\xd2\xaf\xd1\x80\xd1\x8d\xd0\xb2\0"
	"\xd0\xb1\xd0\xb0\xd0\xb0\xd1\x81\xd0\xb0\xd0\xbd\0"
	"\xd0\xb1\xd1\x8f\xd0\xbc\xd0\xb1\xd0\xb0\0"
	"\xd0\x9d\xd1\x8f\0"
	"\xd0\x94\xd0\xb0\0"
	"\xd0\x9c\xd1\x8f\0"
	"\xd0\x9b\xd1\x85\0"
	"\xd0\x9f\xd2\xaf\0"
	"\xd0\x91\xd0\xb0\0"
	"\xd0\x91\xd1\x8f\0"
	"\xd0\x9d\xd1\x8d\xd0\xb3\xd0\xb4\xd2\xaf\xd0\xb3\xd1\x8d\xd1\x8d\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\xa5\xd0\xbe\xd1\x91\xd1\x80\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x93\xd1\x83\xd1\x80\xd0\xb0\xd0\xb2\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x94\xd3\xa9\xd1\x80\xd3\xa9\xd0\xb2\xd0\xb4\xd2\xaf\xd0\xb3\xd1\x8d\xd1\x8d\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\xa2\xd0\xb0\xd0\xb2\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x97\xd1\x83\xd1\x80\xd0\xb3\xd0\xb0\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x94\xd0\xbe\xd0\xbb\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x9d\xd0\xb0\xd0\xb9\xd0\xbc\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x95\xd1\x81\xd0\xb4\xd2\xaf\xd0\xb3\xd1\x8d\xd1\x8d\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x90\xd1\x80\xd0\xb0\xd0\xb2\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x90\xd1\x80\xd0\xb2\xd0\xb0\xd0\xbd \xd0\xbd\xd1\x8d\xd0\xb3\xd0\xb4\xd2\xaf\xd0\xb3\xd1\x8d\xd1\x8d\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xd0\x90\xd1\x80\xd0\xb2\xd0\xb0\xd0\xbd \xd1\x85\xd0\xbe\xd1\x91\xd1\x80\xd0\xb4\xd1\x83\xd0\xb3\xd0\xb0\xd0\xb0\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"1-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"2-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"3-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"4-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"5-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"6-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"7-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"8-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"9-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"10-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"11-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"12-\xd1\x80 \xd1\x81\xd0\xb0\xd1\x80\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\x89\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x98\xe0\xbc\x8b\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\x98\xe0\xbd\xb2\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbd\x98\xe0\xbd\xa2\xe0\xbc\x8b\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\xa3\xe0\xbe\xb7\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\x95\xe0\xbd\xb4\xe0\xbd\xa2\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\xb4\xe0\xbc\x8b\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\xe0\xbd\xa6\xe0\xbd\x84\xe0\xbd\xa6\xe0\xbc\x8b\0"
	"\xe0\xbd\x82\xe0\xbd\x9f\xe0\xbd\xa0\xe0\xbc\x8b\xe0\xbd\xa6\xe0\xbe\xa4\xe0\xbd\xba\xe0\xbd\x93\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x89\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x98\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\0"
	"\xe0\xbd\x98\xe0\xbd\xb2\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbd\x98\xe0\xbd\xa2\xe0\xbc\x8b\0"
	"\xe0\xbd\xa3\xe0\xbe\xb7\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x95\xe0\xbd\xb4\xe0\xbd\xa2\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\xb4\xe0\xbc\x8b\0"
	"\xe0\xbd\x94\xe0\xbc\x8b\xe0\xbd\xa6\xe0\xbd\x84\xe0\xbd\xa6\xe0\xbc\x8b\0"
	"\xe0\xbd\xa6\xe0\xbe\xa4\xe0\xbd\xba\xe0\xbd\x93\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x89\xe0\xbd\xb2\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\0"
	"\xe0\xbd\x98\xe0\xbd\xb2\xe0\xbd\x82\0"
	"\xe0\xbd\xa3\xe0\xbe\xb7\xe0\xbd\x82\0"
	"\xe0\xbd\x95\xe0\xbd\xb4\xe0\xbd\xa2\0"
	"\xe0\xbd\xa6\xe0\xbd\x84\xe0\xbd\xa6\0"
	"\xe0\xbd\xa6\xe0\xbe\xa4\xe0\xbd\xba\xe0\xbd\x93\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbd\x84\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbd\xbc\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\x89\xe0\xbd\xb2\xe0\xbd\xa6\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\xa6\xe0\xbd\xb4\xe0\xbd\x98\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x9e\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\xa3\xe0\xbe\x94\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbe\xb2\xe0\xbd\xb4\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x91\xe0\xbd\xb4\xe0\xbd\x93\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\xa2\xe0\xbe\x92\xe0\xbe\xb1\xe0\xbd\x91\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbd\x82\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x85\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x85\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\x85\xe0\xbd\xb2\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x85\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\x89\xe0\xbd\xb2\xe0\xbd\xa6\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbc\x8b\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbd\x84\xe0\xbc\x8b\xe0\xbd\x94\xe0\xbd\xbc\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\x89\xe0\xbd\xb2\xe0\xbd\xa6\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\xa6\xe0\xbd\xb4\xe0\xbd\x98\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x9e\xe0\xbd\xb2\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\xa3\xe0\xbe\x94\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbe\xb2\xe0\xbd\xb4\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x91\xe0\xbd\xb4\xe0\xbd\x93\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\xa2\xe0\xbe\x92\xe0\xbe\xb1\xe0\xbd\x91\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x91\xe0\xbd\x82\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x85\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x85\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\x85\xe0\xbd\xb2\xe0\xbd\x82\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbc\x8b\xe0\xbd\x96\xe0\xbd\x85\xe0\xbd\xb4\xe0\xbc\x8b\xe0\xbd\x82\xe0\xbd\x89\xe0\xbd\xb2\xe0\xbd\xa6\xe0\xbc\x8b\xe0\xbd\x94\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa1\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa2\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa3\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa4\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa5\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa6\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa7\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa8\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa9\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa1\xe0\xbc\xa0\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa1\xe0\xbc\xa1\0"
	"\xe0\xbd\x9f\xe0\xbe\xb3\xe0\xbc\x8b\xe0\xbc\xa1\xe0\xbc\xa2\0"
	"Dydd Sul\0"
	"Dydd Llun\0"
	"Dydd Mawrth\0"
	"Dydd Mercher\0"
	"Dydd Iau\0"
	"Dydd Gwener\0"
	"Dydd Sadwrn\0"
	"Sul\0"
	"Llun\0"
	"Mer\0"
	"Iau\0"
	"Gwe\0"
	"Sad\0"
	"Ll\0"
	"Ionawr\0"
	"Chwefror\0"
	"Mawrth\0"
	"Ebrill\0"
	"Mehefin\0"
	"Gorffennaf\0"
	"Awst\0"
	"Medi\0"
	"Hydref\0"
	"Tachwedd\0"
	"Rhagfyr\0"
	"Ion\0"
	"Chw\0"
	"Ebr\0"
	"Meh\0"
	"Gor\0"
	"Hyd\0"
	"Tach\0"
	"Rhag\0"
	"\xe1\x9e\xa2\xe1\x9e\xb6\xe1\x9e\x91\xe1\x9e\xb7\xe1\x9e\x8f\xe1\x9f\x92\xe1\x9e\x99\0"
	"\xe1\x9e\x85\xe1\x9f\x90\xe1\x9e\x93\xe1\x9f\x92\xe1\x9e\x91\0"
	"\xe1\x9e\xa2\xe1\x9e\x84\xe1\x9f\x92\xe1\x9e\x82\xe1\x9e\xb6\xe1\x9e\x9a\0"
	"\xe1\x9e\x96\xe1\x9e\xbb\xe1\x9e\x92\0"
	"\xe1\x9e\x96\xe1\x9f\x92\xe1\x9e\x9a\xe1\x9e\xa0\xe1\x9e\x9f\xe1\x9f\x92\xe1\x9e\x94\xe1\x9e\x8f\xe1\x9e\xb7\xe1\x9f\x8d\0"
	"\xe1\x9e\x9f\xe1\x9e\xbb\xe1\x9e\x80\xe1\x9f\x92\xe1\x9e\x9a\0"
	"\xe1\x9e\x9f\xe1\x9f\x85\xe1\x9e\x9a\xe1\x9f\x8d\0"
	"\xe1\x9e\xa2\0"
	"\xe1\x9e\x85\0"
	"\xe1\x9e\x96\0"
	"\xe1\x9e\x9f\0"
	"\xe1\x9e\x98\xe1\x9e\x80\xe1\x9e\x9a\xe1\x9e\xb6\0"
	"\xe1\x9e\x80\xe1\x9e\xbb\xe1\x9e\x98\xe1\x9f\x92\xe1\x9e\x97\xe1\x9f\x88\0"
	"\xe1\x9e\x98\xe1\x9e\xb8\xe1\x9e\x93\xe1\x9e\xb6\0"
	"\xe1\x9e\x98\xe1\x9f\x81\xe1\x9e\x9f\xe1\x9e\xb6\0"
	"\xe1\x9e\xa7\xe1\x9e\x9f\xe1\x9e\x97\xe1\x9e\xb6\0"
	"\xe1\x9e\x98\xe1\x9e\xb7\xe1\x9e\x90\xe1\x9e\xbb\xe1\x9e\x93\xe1\x9e\xb6\0"
	"\xe1\x9e\x80\xe1\x9e\x80\xe1\x9f\x92\xe1\x9e\x80\xe1\x9e\x8a\xe1\x9e\xb6\0"
	"\xe1\x9e\x9f\xe1\x9e\xb8\xe1\x9e\xa0\xe1\x9e\xb6\0"
	"\xe1\x9e\x80\xe1\x9e\x89\xe1\x9f\x92\xe1\x9e\x89\xe1\x9e\xb6\0"
	"\xe1\x9e\x8f\xe1\x9e\xbb\xe1\x9e\x9b\xe1\x9e\xb6\0"
	"\xe1\x9e\x9c\xe1\x9e\xb7\xe1\x9e\x85\xe1\x9f\x92\xe1\x9e\x86\xe1\x9e\xb7\xe1\x9e\x80\xe1\x9e\xb6\0"
	"\xe1\x9e\x92\xe1\x9f\x92\xe1\x9e\x93\xe1\x9e\xbc\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xba\xad\xe0\xba\xb2\xe0\xba\x97\xe0\xba\xb4\xe0\xba\x94\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xba\x88\xe0\xba\xb1\xe0\xba\x99\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xba\xad\xe0\xba\xb1\xe0\xba\x87\xe0\xba\x84\xe0\xba\xb2\xe0\xba\x99\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xba\x9e\xe0\xba\xb8\xe0\xba\x94\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xba\x9e\xe0\xba\xb0\xe0\xba\xab\xe0\xba\xb1\xe0\xba\x94\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xba\xaa\xe0\xba\xb8\xe0\xba\x81\0"
	"\xe0\xba\xa7\xe0\xba\xb1\xe0\xba\x99\xe0\xbb\x80\xe0\xba\xaa\xe0\xba\xbb\xe0\xba\xb2\0"
	"\xe0\xba\xad\xe0\xba\xb2\xe0\xba\x97\xe0\xba\xb4\xe0\xba\x94\0"
	"\xe0\xba\x88\xe0\xba\xb1\xe0\xba\x99\0"
	"\xe0\xba\xad\xe0\xba\xb1\xe0\xba\x87\xe0\xba\x84\xe0\xba\xb2\xe0\xba\x99\0"
	"\xe0\xba\x9e\xe0\xba\xb8\xe0\xba\x94\0"
	"\xe0\xba\x9e\xe0\xba\xb0\xe0\xba\xab\xe0\xba\xb1\xe0\xba\x94\0"
	"\xe0\xba\xaa\xe0\xba\xb8\xe0\xba\x81\0"
	"\xe0\xbb\x80\xe0\xba\xaa\xe0\xba\xbb\xe0\xba\xb2\0"
	"\xe0\xba\xad\xe0\xba\xb2\0"
	"\xe0\xba\x88\0"
	"\xe0\xba\xad\0"
	"\xe0\xba\x9e\0"
	"\xe0\xba\x9e\xe0\xba\xab\0"
	"\xe0\xba\xaa\xe0\xba\xb8\0"
	"\xe0\xba\xaa\0"
	"\xe0\xba\xa1\xe0\xba\xb1\xe0\xba\x87\xe0\xba\x81\xe0\xba\xad\xe0\xba\x99\0"
	"\xe0\xba\x81\xe0\xba\xb8\xe0\xba\xa1\xe0\xba\x9e\xe0\xba\xb2\0"
	"\xe0\xba\xa1\xe0\xba\xb5\xe0\xba\x99\xe0\xba\xb2\0"
	"\xe0\xbb\x80\xe0\xba\xa1\xe0\xba\xaa\xe0\xba\xb2\0"
	"\xe0\xba\x9e\xe0\xba\xb6\xe0\xba\x94\xe0\xba\xaa\xe0\xba\xb0\xe0\xba\x9e\xe0\xba\xb2\0"
	"\xe0\xba\xa1\xe0\xba\xb4\xe0\xba\x96\xe0\xba\xb8\xe0\xba\x99\xe0\xba\xb2\0"
	"\xe0\xba\x81\xe0\xbb\x8d\xe0\xba\xa5\xe0\xba\xb0\xe0\xba\x81\xe0\xba\xbb\xe0\xba\x94\0"
	"\xe0\xba\xaa\xe0\xba\xb4\xe0\xba\x87\xe0\xba\xab\xe0\xba\xb2\0"
	"\xe0\xba\x81\xe0\xba\xb1\xe0\xba\x99\xe0\xba\x8d\xe0\xba\xb2\0"
	"\xe0\xba\x95\xe0\xba\xb8\xe0\xba\xa5\xe0\xba\xb2\0"
	"\xe0\xba\x9e\xe0\xba\xb0\xe0\xba\x88\xe0\xba\xb4\xe0\xba\x81\0"
	"\xe0\xba\x97\xe0\xba\xb1\xe0\xba\x99\xe0\xba\xa7\xe0\xba\xb2\0"
	"\xe0\xba\xa1.\xe0\xba\x81.\0"
	"\xe0\xba\x81.\xe0\xba\x9e.\0"
	"\xe0\xba\xa1.\xe0\xba\x99.\0"
	"\xe0\xba\xa1.\xe0\xba\xaa.\0"
	"\xe0\xba\x9e.\xe0\xba\x9e.\0"
	"\xe0\xba\xa1\xe0\xba\xb4.\xe0\xba\x96.\0"
	"\xe0\xba\x81.\xe0\xba\xa5.\0"
	"\xe0\xba\xaa.\xe0\xba\xab.\0"
	"\xe0\xba\x81.\xe0\xba\x8d.\0"
	"\xe0\xba\x95.\xe0\xba\xa5.\0"
	"\xe0\xba\x9e.\xe0\xba\x88.\0"
	"\xe0\xba\x97.\xe0\xba\xa7.\0"
	"\xe1\x80\x90\xe1\x80\x94\xe1\x80\x84\xe1\x80\xba\xe1\x80\xb9\xe1\x80\x82\xe1\x80\x94\xe1\x80\xbd\xe1\x80\xb1\0"
	"\xe1\x80\x90\xe1\x80\x94\xe1\x80\x84\xe1\x80\xba\xe1\x80\xb9\xe1\x80\x9c\xe1\x80\xac\0"
	"\xe1\x80\xa1\xe1\x80\x84\xe1\x80\xba\xe1\x80\xb9\xe1\x80\x82\xe1\x80\xab\0"
	"\xe1\x80\x97\xe1\x80\xaf\xe1\x80\x92\xe1\x80\xb9\xe1\x80\x93\xe1\x80\x9f\xe1\x80\xb0\xe1\x80\xb8\0"
	"\xe1\x80\x80\xe1\x80\xbc\xe1\x80\xac\xe1\x80\x9e\xe1\x80\x95\xe1\x80\x90\xe1\x80\xb1\xe1\x80\xb8\0"
	"\xe1\x80\x9e\xe1\x80\xb1\xe1\x80\xac\xe1\x80\x80\xe1\x80\xbc\xe1\x80\xac\0"
	"\xe1\x80\x85\xe1\x80\x94\xe1\x80\xb1\0"
	"\xe1\x80\x90\0"
	"\xe1\x80\xa1\0"
	"\xe1\x80\x97\0"
	"\xe1\x80\x80\0"
	"\xe1\x80\x9e\0"
	"\xe1\x80\x85\0"
	"\xe1\x80\x87\xe1\x80\x94\xe1\x80\xba\xe1\x80\x94\xe1\x80\x9d\xe1\x80\xab\xe1\x80\x9b\xe1\x80\xae\0"
	"\xe1\x80\x96\xe1\x80\xb1\xe1\x80\x96\xe1\x80\xb1\xe1\x80\xac\xe1\x80\xba\xe1\x80\x9d\xe1\x80\xab\xe1\x80\x9b\xe1\x80\xae\0"
	"\xe1\x80\x99\xe1\x80\x90\xe1\x80\xba\0"
	"\xe1\x80\xa7\xe1\x80\x95\xe1\x80\xbc\xe1\x80\xae\0"
	"\xe1\x80\x99\xe1\x80\xb1\0"
	"\xe1\x80\x87\xe1\x80\xbd\xe1\x80\x94\xe1\x80\xba\0"
	"\xe1\x80\x87\xe1\x80\xb0\xe1\x80\x9c\xe1\x80\xad\xe1\x80\xaf\xe1\x80\x84\xe1\x80\xba\0"
	"\xe1\x80\xa9\xe1\x80\x82\xe1\x80\xaf\xe1\x80\x90\xe1\x80\xba\0"
	"\xe1\x80\x85\xe1\x80\x80\xe1\x80\xba\xe1\x80\x90\xe1\x80\x84\xe1\x80\xba\xe1\x80\x98\xe1\x80\xac\0"
	"\xe1\x80\xa1\xe1\x80\xb1\xe1\x80\xac\xe1\x80\x80\xe1\x80\xba\xe1\x80\x90\xe1\x80\xad\xe1\x80\xaf\xe1\x80\x98\xe1\x80\xac\0"
	"\xe1\x80\x94\xe1\x80\xad\xe1\x80\xaf\xe1\x80\x9d\xe1\x80\x84\xe1\x80\xba\xe1\x80\x98\xe1\x80\xac\0"
	"\xe1\x80\x92\xe1\x80\xae\xe1\x80\x87\xe1\x80\x84\xe1\x80\xba\xe1\x80\x98\xe1\x80\xac\0"
	"\xe1\x80\x87\xe1\x80\x94\xe1\x80\xba\0"
	"\xe1\x80\x96\xe1\x80\xb1\0"
	"\xe1\x80\xa7\0"
	"\xe1\x80\x87\xe1\x80\xb0\0"
	"\xe1\x80\xa9\0"
	"\xe1\x80\x85\xe1\x80\x80\xe1\x80\xba\0"
	"\xe1\x80\xa1\xe1\x80\xb1\xe1\x80\xac\xe1\x80\x80\xe1\x80\xba\0"
	"\xe1\x80\x94\xe1\x80\xad\xe1\x80\xaf\0"
	"\xe1\x80\x92\xe1\x80\xae\0"
	"luns\0"
	"m\xc3\xa9rcores\0"
	"xoves\0"
	"venres\0"
	"Dom.\0"
	"Luns\0"
	"Mar.\0"
	"M\xc3\xa9r.\0"
	"Xov.\0"
	"Ven.\0"
	"S\xc3\xa1\x62.\0"
	"Xaneiro\0"
	"Febreiro\0"
	"Marzo\0"
	"Abril\0"
	"Maio\0"
	"Xu\xc3\xb1o\0"
	"Xullo\0"
	"Agosto\0"
	"Setembro\0"
	"Outubro\0"
	"Novembro\0"
	"Decembro\0"
	"xaneiro\0"
	"febreiro\0"
	"xu\xc3\xb1o\0"
	"xullo\0"
	"decembro\0"
	"Xan.\0"
	"Abr.\0"
	"Xul.\0"
	"Ago.\0"
	"Set.\0"
	"Out.\0"
	"Dec.\0"
	"\xe0\xa4\x86\xe0\xa4\xa6\xe0\xa4\xbf\xe0\xa4\xa4\xe0\xa5\x8d\xe0\xa4\xaf\xe0\xa4\xb5\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xae\xe0\xa4\x82\xe0\xa4\x97\xe0\xa4\xb3\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\x93\xe0\xa4\x97\xe0\xa4\xb8\xe0\xa5\x8d\xe0\xa4\x9f\0"
	"\xe0\xa4\xb8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x87\xe0\xa4\x82\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\x93\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x8b\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xb6\x89\xe0\xb6\xbb\xe0\xb7\x92\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb7\x83\xe0\xb6\xb3\xe0\xb7\x94\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb6\x85\xe0\xb6\x9f\xe0\xb7\x84\xe0\xb6\xbb\xe0\xb7\x94\xe0\xb7\x80\xe0\xb7\x8f\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb6\xb6\xe0\xb6\xaf\xe0\xb7\x8f\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb6\xb6\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x84\xe0\xb7\x83\xe0\xb7\x8a\xe0\xb6\xb4\xe0\xb6\xad\xe0\xb7\x92\xe0\xb6\xb1\xe0\xb7\x8a\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb7\x83\xe0\xb7\x92\xe0\xb6\x9a\xe0\xb7\x94\xe0\xb6\xbb\xe0\xb7\x8f\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb7\x83\xe0\xb7\x99\xe0\xb6\xb1\xe0\xb7\x83\xe0\xb7\x94\xe0\xb6\xbb\xe0\xb7\x8f\xe0\xb6\xaf\xe0\xb7\x8f\0"
	"\xe0\xb6\x85\xe0\xb6\x9f\xe0\xb7\x84\0"
	"\xe0\xb6\xb6\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x84\xe0\xb7\x83\xe0\xb7\x8a\0"
	"\xe0\xb7\x83\xe0\xb7\x92\xe0\xb6\x9a\xe0\xb7\x94\0"
	"\xe0\xb7\x83\xe0\xb7\x99\xe0\xb6\xb1\0"
	"\xe0\xb6\x89\0"
	"\xe0\xb7\x83\0"
	"\xe0\xb6\x85\0"
	"\xe0\xb6\xb6\0"
	"\xe0\xb6\xb6\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\0"
	"\xe0\xb7\x83\xe0\xb7\x92\0"
	"\xe0\xb7\x83\xe0\xb7\x99\0"
	"\xe0\xb6\xa2\xe0\xb6\xb1\xe0\xb7\x80\xe0\xb7\x8f\xe0\xb6\xbb\xe0\xb7\x92\0"
	"\xe0\xb6\xb4\xe0\xb7\x99\xe0\xb6\xb6\xe0\xb6\xbb\xe0\xb7\x80\xe0\xb7\x8f\xe0\xb6\xbb\xe0\xb7\x92\0"
	"\xe0\xb6\xb8\xe0\xb7\x8f\xe0\xb6\xbb\xe0\xb7\x8a\xe0\xb6\xad\xe0\xb7\x94\0"
	"\xe0\xb6\x85\xe0\xb6\xb4\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x9a\xe0\xb6\xbd\xe0\xb7\x8a\0"
	"\xe0\xb6\xb8\xe0\xb7\x90\xe0\xb6\xba\xe0\xb7\x92\0"
	"\xe0\xb6\xa2\xe0\xb7\x96\xe0\xb6\xb1\xe0\xb7\x92\0"
	"\xe0\xb6\xa2\xe0\xb7\x96\xe0\xb6\xbd\xe0\xb7\x92\0"
	"\xe0\xb6\x85\xe0\xb6\x9c\xe0\xb7\x9d\xe0\xb7\x83\xe0\xb7\x8a\xe0\xb6\xad\xe0\xb7\x94\0"
	"\xe0\xb7\x83\xe0\xb7\x90\xe0\xb6\xb4\xe0\xb7\x8a\xe0\xb6\xad\xe0\xb7\x90\xe0\xb6\xb8\xe0\xb7\x8a\xe0\xb6\xb6\xe0\xb6\xbb\xe0\xb7\x8a\0"
	"\xe0\xb6\x94\xe0\xb6\x9a\xe0\xb7\x8a\xe0\xb6\xad\xe0\xb7\x9d\xe0\xb6\xb6\xe0\xb6\xbb\xe0\xb7\x8a\0"
	"\xe0\xb6\xb1\xe0\xb7\x9c\xe0\xb7\x80\xe0\xb7\x90\xe0\xb6\xb8\xe0\xb7\x8a\xe0\xb6\xb6\xe0\xb6\xbb\xe0\xb7\x8a\0"
	"\xe0\xb6\xaf\xe0\xb7\x99\xe0\xb7\x83\xe0\xb7\x90\xe0\xb6\xb8\xe0\xb7\x8a\xe0\xb6\xb6\xe0\xb6\xbb\xe0\xb7\x8a\0"
	"\xe0\xb6\xa2\xe0\xb6\xb1\0"
	"\xe0\xb6\xb4\xe0\xb7\x99\xe0\xb6\xb6\0"
	"\xe0\xb6\xb8\xe0\xb7\x8f\xe0\xb6\xbb\xe0\xb7\x8a\0"
	"\xe0\xb6\x85\xe0\xb6\x9c\xe0\xb7\x9d\0"
	"\xe0\xb7\x83\xe0\xb7\x90\xe0\xb6\xb4\xe0\xb7\x8a\0"
	"\xe0\xb6\x94\xe0\xb6\x9a\xe0\xb7\x8a\0"
	"\xe0\xb6\xb1\xe0\xb7\x9c\xe0\xb7\x80\xe0\xb7\x90\0"
	"\xe0\xb6\xaf\xe0\xb7\x99\xe0\xb7\x83\xe0\xb7\x90\0"
	"\xe1\x8e\xa4\xe1\x8e\xbe\xe1\x8f\x99\xe1\x8f\x93\xe1\x8f\x86\xe1\x8f\x8d\xe1\x8e\xac\0"
	"\xe1\x8e\xa4\xe1\x8e\xbe\xe1\x8f\x99\xe1\x8f\x93\xe1\x8f\x89\xe1\x8f\x85\xe1\x8e\xaf\0"
	"\xe1\x8f\x94\xe1\x8e\xb5\xe1\x8f\x81\xe1\x8e\xa2\xe1\x8e\xa6\0"
	"\xe1\x8f\xa6\xe1\x8e\xa2\xe1\x8f\x81\xe1\x8e\xa2\xe1\x8e\xa6\0"
	"\xe1\x8f\x85\xe1\x8e\xa9\xe1\x8f\x81\xe1\x8e\xa2\xe1\x8e\xa6\0"
	"\xe1\x8f\xa7\xe1\x8e\xbe\xe1\x8e\xa9\xe1\x8e\xb6\xe1\x8f\x8d\xe1\x8f\x97\0"
	"\xe1\x8e\xa4\xe1\x8e\xbe\xe1\x8f\x99\xe1\x8f\x93\xe1\x8f\x88\xe1\x8f\x95\xe1\x8e\xbe\0"
	"\xe1\x8f\x86\xe1\x8f\x8d\xe1\x8e\xac\0"
	"\xe1\x8f\x89\xe1\x8f\x85\xe1\x8e\xaf\0"
	"\xe1\x8f\x94\xe1\x8e\xb5\xe1\x8f\x81\0"
	"\xe1\x8f\xa6\xe1\x8e\xa2\xe1\x8f\x81\0"
	"\xe1\x8f\x85\xe1\x8e\xa9\xe1\x8f\x81\0"
	"\xe1\x8f\xa7\xe1\x8e\xbe\xe1\x8e\xa9\0"
	"\xe1\x8f\x88\xe1\x8f\x95\xe1\x8e\xbe\0"
	"\xe1\x8f\x86\0"
	"\xe1\x8f\x89\0"
	"\xe1\x8f\x94\0"
	"\xe1\x8f\xa6\0"
	"\xe1\x8f\x85\0"
	"\xe1\x8f\xa7\0"
	"\xe1\x8e\xa4\0"
	"\xe1\x8e\xa4\xe1\x8f\x83\xe1\x8e\xb8\xe1\x8f\x94\xe1\x8f\x85\0"
	"\xe1\x8e\xa7\xe1\x8e\xa6\xe1\x8e\xb5\0"
	"\xe1\x8e\xa0\xe1\x8f\x85\xe1\x8f\xb1\0"
	"\xe1\x8e\xa7\xe1\x8f\xac\xe1\x8f\x82\0"
	"\xe1\x8e\xa0\xe1\x8f\x82\xe1\x8f\x8d\xe1\x8e\xac\xe1\x8f\x98\0"
	"\xe1\x8f\x95\xe1\x8e\xad\xe1\x8e\xb7\xe1\x8f\xb1\0"
	"\xe1\x8e\xab\xe1\x8f\xb0\xe1\x8f\x89\xe1\x8f\x82\0"
	"\xe1\x8e\xa6\xe1\x8e\xb6\xe1\x8f\x82\0"
	"\xe1\x8f\x9a\xe1\x8e\xb5\xe1\x8f\x8d\xe1\x8f\x97\0"
	"\xe1\x8f\x9a\xe1\x8f\x82\xe1\x8f\x85\xe1\x8f\x97\0"
	"\xe1\x8f\x85\xe1\x8f\x93\xe1\x8f\x95\xe1\x8f\x86\0"
	"\xe1\x8e\xa5\xe1\x8f\x8d\xe1\x8e\xa9\xe1\x8f\xb1\0"
	"\xe1\x8e\xa4\xe1\x8f\x83\0"
	"\xe1\x8e\xa7\xe1\x8e\xa6\0"
	"\xe1\x8e\xa0\xe1\x8f\x85\0"
	"\xe1\x8e\xa7\xe1\x8f\xac\0"
	"\xe1\x8e\xa0\xe1\x8f\x82\0"
	"\xe1\x8f\x95\xe1\x8e\xad\0"
	"\xe1\x8e\xab\xe1\x8f\xb0\0"
	"\xe1\x8e\xa6\xe1\x8e\xb6\0"
	"\xe1\x8f\x9a\xe1\x8e\xb5\0"
	"\xe1\x8f\x9a\xe1\x8f\x82\0"
	"\xe1\x8f\x85\xe1\x8f\x93\0"
	"\xe1\x8e\xa5\xe1\x8f\x8d\0"
	"\xe1\x8a\xa5\xe1\x88\x91\xe1\x8b\xb5\0"
	"\xe1\x88\xb0\xe1\x8a\x9e\0"
	"\xe1\x88\x9b\xe1\x8a\xad\xe1\x88\xb0\xe1\x8a\x9e\0"
	"\xe1\x88\xa8\xe1\x89\xa1\xe1\x8b\x95\0"
	"\xe1\x88\x90\xe1\x88\x99\xe1\x88\xb5\0"
	"\xe1\x8b\x93\xe1\x88\xad\xe1\x89\xa5\0"
	"\xe1\x89\x85\xe1\x8b\xb3\xe1\x88\x9c\0"
	"\xe1\x88\x9b\xe1\x8a\xad\xe1\x88\xb0\0"
	"\xe1\x8a\xa5\0"
	"\xe1\x88\xb0\0"
	"\xe1\x88\x9b\0"
	"\xe1\x88\xa8\0"
	"\xe1\x88\x90\0"
	"\xe1\x8b\x93\0"
	"\xe1\x89\x85\0"
	"\xe1\x8c\x83\xe1\x8a\x95\xe1\x8b\xa9\xe1\x8b\x88\xe1\x88\xaa\0"
	"\xe1\x8d\x8c\xe1\x89\xa5\xe1\x88\xa9\xe1\x8b\x88\xe1\x88\xaa\0"
	"\xe1\x88\x9b\xe1\x88\xad\xe1\x89\xbd\0"
	"\xe1\x8a\xa4\xe1\x8d\x95\xe1\x88\xaa\xe1\x88\x8d\0"
	"\xe1\x88\x9c\xe1\x8b\xad\0"
	"\xe1\x8c\x81\xe1\x8a\x95\0"
	"\xe1\x8c\x81\xe1\x88\x8b\xe1\x8b\xad\0"
	"\xe1\x8a\xa6\xe1\x8c\x88\xe1\x88\xb5\xe1\x89\xb5\0"
	"\xe1\x88\xb4\xe1\x8d\x95\xe1\x89\xb4\xe1\x88\x9d\xe1\x89\xa0\xe1\x88\xad\0"
	"\xe1\x8a\xa6\xe1\x8a\xad\xe1\x89\xb6\xe1\x89\xa0\xe1\x88\xad\0"
	"\xe1\x8a\x96\xe1\x89\xac\xe1\x88\x9d\xe1\x89\xa0\xe1\x88\xad\0"
	"\xe1\x8b\xb2\xe1\x88\xb4\xe1\x88\x9d\xe1\x89\xa0\xe1\x88\xad\0"
	"\xe1\x8c\x83\xe1\x8a\x95\xe1\x8b\xa9\0"
	"\xe1\x8d\x8c\xe1\x89\xa5\xe1\x88\xa9\0"
	"\xe1\x8a\xa4\xe1\x8d\x95\xe1\x88\xaa\0"
	"\xe1\x8a\xa6\xe1\x8c\x88\xe1\x88\xb5\0"
	"\xe1\x88\xb4\xe1\x8d\x95\xe1\x89\xb4\0"
	"\xe1\x8a\xa6\xe1\x8a\xad\xe1\x89\xb6\0"
	"\xe1\x8a\x96\xe1\x89\xac\xe1\x88\x9d\0"
	"\xe1\x8b\xb2\xe1\x88\xb4\xe1\x88\x9d\0"
	"Asamas\0"
	"Aynas\0"
	"Asinas\0"
	"Akras\0"
	"Akwas\0"
	"Asimwas\0"
	"Asi\xe1\xb8\x8dyas\0"
	"Asa\0"
	"Ayn\0"
	"Asn\0"
	"Akr\0"
	"Akw\0"
	"Asm\0"
	"As\xe1\xb8\x8d\0"
	"Yennayer\0"
	"Yebrayer\0"
	"Ibrir\0"
	"Mayyu\0"
	"Yunyu\0"
	"Yulyuz\0"
	"\xc6\x94uct\0"
	"Cutanbir\0"
	"K\xe1\xb9\xaduber\0"
	"Nwanbir\0"
	"Dujanbir\0"
	"Yen\0"
	"Yeb\0"
	"Ibr\0"
	"Yun\0"
	"Yul\0"
	"\xc6\x94uc\0"
	"Cut\0"
	"K\xe1\xb9\xadu\0"
	"Nwa\0"
	"Duj\0"
	"\xe0\xa4\x86\xe0\xa4\x87\xe0\xa4\xa4\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb8\xe0\xa5\x8b\xe0\xa4\xae\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xae\xe0\xa4\x99\xe0\xa5\x8d\xe0\xa4\x97\xe0\xa4\xb2\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xac\xe0\xa5\x81\xe0\xa4\xa7\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xac\xe0\xa4\xbf\xe0\xa4\xb9\xe0\xa4\xbf\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb6\xe0\xa5\x81\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\xb6\xe0\xa4\xa8\xe0\xa4\xbf\xe0\xa4\xac\xe0\xa4\xbe\xe0\xa4\xb0\0"
	"\xe0\xa4\x86\xe0\xa4\x87\xe0\xa4\xa4\0"
	"\xe0\xa4\xae\xe0\xa4\x99\xe0\xa5\x8d\xe0\xa4\x97\xe0\xa4\xb2\0"
	"\xe0\xa4\xac\xe0\xa4\xbf\xe0\xa4\xb9\xe0\xa4\xbf\0"
	"\xe0\xa4\x86\0"
	"\xe0\xa4\xae\0"
	"\xe0\xa4\xac\xe0\xa4\xbf\0"
	"\xe0\xa4\xab\xe0\xa5\x87\xe0\xa4\xac\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x81\xe0\xa4\x85\xe0\xa4\xb0\xe0\xa5\x80\0"
	"\xe0\xa4\x85\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa4\xbf\xe0\xa4\xb2\0"
	"\xe0\xa4\x9c\xe0\xa5\x81\xe0\xa4\xa8\0"
	"\xe0\xa4\x85\xe0\xa4\x97\xe0\xa4\xb8\xe0\xa5\x8d\xe0\xa4\x9f\0"
	"\xe0\xa4\xb8\xe0\xa5\x87\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x87\xe0\xa4\xae\xe0\xa5\x8d\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\x85\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\x9f\xe0\xa5\x8b\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\xa8\xe0\xa5\x8b\xe0\xa4\xad\xe0\xa5\x87\xe0\xa4\xae\xe0\xa5\x8d\xe0\xa4\xac\xe0\xa4\xb0\0"
	"\xe0\xa4\xa1\xe0\xa4\xbf\xe0\xa4\xb8\xe0\xa5\x87\xe0\xa4\xae\xe0\xa5\x8d\xe0\xa4\xac\xe0\xa4\xb0\0"
	"snein\0"
	"moandei\0"
	"tiisdei\0"
	"woansdei\0"
	"tongersdei\0"
	"freed\0"
	"sneon\0"
	"si\0"
	"mo\0"
	"fr\0"
	"Jannewaris\0"
	"Febrewaris\0"
	"Maaie\0"
	"Juny\0"
	"Septimber\0"
	"Novimber\0"
	"Desimber\0"
	"Mrt\0"
	"\xd9\x88\xd8\xb1\xdb\x8c\0"
	"\xd8\xba\xd9\x88\xdb\x8c\xdb\x8c\0"
	"\xd8\xba\xd8\xa8\xd8\xb1\xda\xaf\xd9\x88\xd9\x84\xdb\x8c\0"
	"\xda\x86\xd9\x86\xda\xaf\xd8\xa7\xda\x9a\0"
	"\xd8\xb2\xd9\x85\xd8\xb1\xdb\x8c\0"
	"\xd9\x88\xda\x96\xdb\x8c\0"
	"\xd8\xaa\xd9\x84\xd9\x87\0"
	"\xd9\x84\xda\x93\xd9\x85\0"
	"\xd9\x84\xdb\x8c\xd9\x86\xd8\xaf\xdb\x8d\0"
	"\xd9\x85\xd8\xb1\xd8\xba\xd9\x88\xd9\x85\xdb\x8c\0"
	"\xd8\xb3\xd9\x84\xd9\x88\xd8\xa7\xd8\xba\xd9\x87\0"
	"\xda\xa9\xd8\xa8\0"
	"Linggo\0"
	"Lunes\0"
	"Martes\0"
	"Miyerkules\0"
	"Huwebes\0"
	"Biyernes\0"
	"Sabado\0"
	"Lin\0"
	"Lun\0"
	"Miy\0"
	"Huw\0"
	"Biy\0"
	"Enero\0"
	"Pebrero\0"
	"Marso\0"
	"Mayo\0"
	"Hunyo\0"
	"Hulyo\0"
	"Setyembre\0"
	"Oktubre\0"
	"Nobyembre\0"
	"Disyembre\0"
	"Ene\0"
	"Peb\0"
	"Abr\0"
	"Hun\0"
	"Hul\0"
	"Nob\0"
	"dewo\0"
	"aa\xc9\x93nde\0"
	"mawbaare\0"
	"njeslaare\0"
	"naasaande\0"
	"mawnde\0"
	"hoore-biir\0"
	"dew\0"
	"aa\xc9\x93\0"
	"maw\0"
	"naa\0"
	"mwd\0"
	"hbi\0"
	"d\0"
	"a\0"
	"m\0"
	"h\0"
	"siilo\0"
	"colte\0"
	"mbooy\0"
	"see\xc9\x97to\0"
	"duujal\0"
	"korse\0"
	"morso\0"
	"juko\0"
	"siilto\0"
	"yarkomaa\0"
	"jolal\0"
	"bowte\0"
	"sii\0"
	"col\0"
	"mbo\0"
	"see\0"
	"duu\0"
	"kor\0"
	"mor\0"
	"juk\0"
	"slt\0"
	"yar\0"
	"jol\0"
	"bow\0"
	"Lahadi\0"
	"Litinin\0"
	"Talata\0"
	"Laraba\0"
	"Alhamis\0"
	"Jumma\xca\xbc\x61\0"
	"Asabar\0"
	"Lah\0"
	"Lit\0"
	"Tal\0"
	"Lar\0"
	"Alh\0"
	"Janairu\0"
	"Faburairu\0"
	"Maris\0"
	"Afirilu\0"
	"Mayu\0"
	"Yuni\0"
	"Yuli\0"
	"Agusta\0"
	"Satumba\0"
	"Nuwamba\0"
	"Disamba\0"
	"Fab\0"
	"Afi\0"
	"Agu\0"
	"Nuw\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81 \xc3\x80\xc3\xack\xc3\xba\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81 Aj\xc3\xa9\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81 \xc3\x8cs\xe1\xba\xb9\xcc\x81gun\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81r\xc3\xba\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81\x62\xe1\xbb\x8d\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81 \xe1\xba\xb8t\xc3\xac\0"
	"\xe1\xbb\x8cj\xe1\xbb\x8d\xcc\x81 \xc3\x80\x62\xc3\xa1m\xe1\xba\xb9\xcc\x81ta\0"
	"\xc3\x80\xc3\xack\xc3\xba\0"
	"Aj\xc3\xa9\0"
	"\xc3\x8cs\xe1\xba\xb9\xcc\x81gun\0"
	"\xe1\xba\xb8t\xc3\xac\0"
	"\xc3\x80\x62\xc3\xa1m\xe1\xba\xb9\xcc\x81ta\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xe1\xb9\xa2\xe1\xba\xb9\xcc\x81r\xe1\xba\xb9\xcc\x81\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xc3\x88r\xc3\xa8l\xc3\xa8\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xe1\xba\xb8r\xe1\xba\xb9\xcc\x80n\xc3\xa0\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xc3\x8cgb\xc3\xa9\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xe1\xba\xb8\xcc\x80\x62ibi\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xc3\x92k\xc3\xba\x64u\0"
	"O\xe1\xb9\xa3\xc3\xb9 Ag\xe1\xba\xb9m\xe1\xbb\x8d\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xc3\x92g\xc3\xban\0"
	"O\xe1\xb9\xa3\xc3\xb9 Owewe\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xe1\xbb\x8c\xcc\x80w\xc3\xa0r\xc3\xa0\0"
	"O\xe1\xb9\xa3\xc3\xb9 B\xc3\xa9l\xc3\xba\0"
	"O\xe1\xb9\xa3\xc3\xb9 \xe1\xbb\x8c\xcc\x80p\xe1\xba\xb9\xcc\x80\0"
	"\xe1\xb9\xa2\xe1\xba\xb9\xcc\x81r\xe1\xba\xb9\xcc\x81\0"
	"\xc3\x88r\xc3\xa8l\xc3\xa8\0"
	"\xe1\xba\xb8r\xe1\xba\xb9\xcc\x80n\xc3\xa0\0"
	"\xc3\x8cgb\xc3\xa9\0"
	"\xe1\xba\xb8\xcc\x80\x62ibi\0"
	"\xc3\x92k\xc3\xba\x64u\0"
	"Ag\xe1\xba\xb9m\xe1\xbb\x8d\0"
	"\xc3\x92g\xc3\xban\0"
	"Owewe\0"
	"\xe1\xbb\x8c\xcc\x80w\xc3\xa0r\xc3\xa0\0"
	"B\xc3\xa9l\xc3\xba\0"
	"\xe1\xbb\x8c\xcc\x80p\xe1\xba\xb9\xcc\x80\0"
	"Sontaga\0"
	"Mosupalogo\0"
	"Labohlano\0"
	"Mokibelo\0"
	"Mok\0"
	"Janaware\0"
	"Feberware\0"
	"Mat\xc5\xa1he\0"
	"Aporele\0"
	"Julae\0"
	"Agostose\0"
	"Setemere\0"
	"Oktobore\0"
	"Nofemere\0"
	"Disemere\0"
	"Apo\0"
	"Nof\0"
	"Sonndeg\0"
	"M\xc3\xa9indeg\0"
	"D\xc3\xabnschdeg\0"
	"M\xc3\xabttwoch\0"
	"Donneschdeg\0"
	"Freideg\0"
	"Samschdeg\0"
	"M\xc3\xa9i\0"
	"D\xc3\xabn\0"
	"M\xc3\xabt\0"
	"Don\0"
	"Fre\0"
	"Sam\0"
	"M\xc3\xa4\x65rz\0"
	"Abr\xc3\xabll\0"
	"Mee\0"
	"M\xc3\xa4\x65\0"
	"sabaat\0"
	"ataasinngorneq\0"
	"marlunngorneq\0"
	"pingasunngorneq\0"
	"sisamanngorneq\0"
	"tallimanngorneq\0"
	"arfininngorneq\0"
	"ata\0"
	"pin\0"
	"sis\0"
	"tal\0"
	"arf\0"
	"martsi\0"
	"aprili\0"
	"maji\0"
	"augustusi\0"
	"septemberi\0"
	"oktoberi\0"
	"novemberi\0"
	"decemberi\0"
	"Mb\xe1\xbb\x8ds\xe1\xbb\x8b \xe1\xbb\xa4ka\0"
	"M\xe1\xbb\x8dnde\0"
	"Tiuzdee\0"
	"Wenezdee\0"
	"T\xe1\xbb\x8d\xe1\xbb\x8dzdee\0"
	"Fra\xe1\xbb\x8b\x64\x65\x65\0"
	"Sat\xe1\xbb\x8d\x64\x65\x65\0"
	"\xe1\xbb\xa4ka\0"
	"M\xe1\xbb\x8dn\0"
	"Tiu\0"
	"Wen\0"
	"T\xe1\xbb\x8d\xe1\xbb\x8d\0"
	"Fra\xe1\xbb\x8b\0"
	"Jen\xe1\xbb\xa5war\xe1\xbb\x8b\0"
	"Febr\xe1\xbb\xa5war\xe1\xbb\x8b\0"
	"Maach\xe1\xbb\x8b\0"
	"Eprel\0"
	"Juun\0"
	"Jula\xe1\xbb\x8b\0"
	"\xe1\xbb\x8cg\xe1\xbb\x8d\xe1\xbb\x8dst\0"
	"\xe1\xbb\x8cktoba\0"
	"Jen\0"
	"Maa\0"
	"Juu\0"
	"\xe1\xbb\x8cg\xe1\xbb\x8d\0"
	"\xe1\xbb\x8ckt\0"
	"Dilbata\0"
	"Wiixata\0"
	"Qibxata\0"
	"Roobii\0"
	"Kamiisa\0"
	"Jimaata\0"
	"Sanbata\0"
	"Dil\0"
	"Wix\0"
	"Qib\0"
	"Rob\0"
	"Jim\0"
	"San\0"
	"Amajjii\0"
	"Guraandhala\0"
	"Bitooteessa\0"
	"Elba\0"
	"Caamsa\0"
	"Waxabajjii\0"
	"Adooleessa\0"
	"Hagayya\0"
	"Fuulbana\0"
	"Onkololeessa\0"
	"Sadaasa\0"
	"Muddee\0"
	"Ama\0"
	"Gur\0"
	"Bit\0"
	"Elb\0"
	"Cam\0"
	"Wax\0"
	"Ado\0"
	"Hag\0"
	"Ful\0"
	"Onk\0"
	"\xe1\x88\xb0\xe1\x8a\x95\xe1\x89\xa0\xe1\x89\xb5\0"
	"\xe1\x88\xb0\xe1\x8a\x91\xe1\x8b\xad\0"
	"\xe1\x88\xa0\xe1\x88\x89\xe1\x88\xb5\0"
	"\xe1\x8a\x83\xe1\x88\x99\xe1\x88\xb5\0"
	"\xe1\x8b\x93\xe1\x88\xad\xe1\x89\xa2\0"
	"\xe1\x89\x80\xe1\x8b\xb3\xe1\x88\x9d\0"
	"\xe1\x88\xb0\xe1\x8a\x95\0"
	"\xe1\x88\xb0\xe1\x8a\x91\0"
	"\xe1\x88\xb0\xe1\x88\x89\0"
	"\xe1\x88\xa8\xe1\x89\xa1\0"
	"\xe1\x88\x93\xe1\x88\x99\0"
	"\xe1\x8b\x93\xe1\x88\xad\0"
	"\xe1\x89\x80\xe1\x8b\xb3\0"
	"\xe1\x88\xa0\0"
	"\xe1\x88\x93\0"
	"\xe1\x89\x80\0"
	"\xe1\x8c\xa5\xe1\x88\xaa\0"
	"\xe1\x88\x88\xe1\x8a\xab\xe1\x89\xb2\xe1\x89\xb5\0"
	"\xe1\x88\x98\xe1\x8c\x8b\xe1\x89\xa2\xe1\x89\xb5\0"
	"\xe1\x88\x9a\xe1\x8b\xab\xe1\x8b\x9d\xe1\x8b\xab\0"
	"\xe1\x8c\x8d\xe1\x8a\x95\xe1\x89\xa6\xe1\x89\xb5\0"
	"\xe1\x88\xb0\xe1\x8a\x90\0"
	"\xe1\x88\x93\xe1\x88\x9d\xe1\x88\x88\0"
	"\xe1\x8a\x90\xe1\x88\x93\xe1\x88\xb0\0"
	"\xe1\x88\x98\xe1\x88\xb5\xe1\x8a\xa8\xe1\x88\xa8\xe1\x88\x9d\0"
	"\xe1\x8c\xa5\xe1\x89\x85\xe1\x88\x9d\xe1\x89\xb2\0"
	"\xe1\x88\x95\xe1\x8b\xb3\xe1\x88\xad\0"
	"\xe1\x89\xb3\xe1\x88\x95\xe1\x88\xb3\xe1\x88\xb5\0"
	"\xe1\x88\x88\xe1\x8a\xab\0"
	"\xe1\x88\x98\xe1\x8c\x8b\0"
	"\xe1\x88\x9a\xe1\x8b\xab\0"
	"\xe1\x8c\x8d\xe1\x8a\x95\0"
	"\xe1\x88\x93\xe1\x88\x9d\0"
	"\xe1\x8a\x90\xe1\x88\x93\0"
	"\xe1\x88\x98\xe1\x88\xb5\0"
	"\xe1\x8c\xa5\xe1\x89\x85\0"
	"\xe1\x88\x95\xe1\x8b\xb3\0"
	"\xe1\x89\xb3\xe1\x88\x95\0"
	"L\xc4\x81pule\0"
	"Po\xca\xbb\x61kahi\0"
	"Po\xca\xbb\x61lua\0"
	"Po\xca\xbb\x61kolu\0"
	"Po\xca\xbb\x61h\xc4\x81\0"
	"Po\xca\xbb\x61lima\0"
	"Po\xca\xbb\x61ono\0"
	"LP\0"
	"P1\0"
	"P2\0"
	"P3\0"
	"P4\0"
	"P5\0"
	"P6\0"
	"Ianuali\0"
	"Pepeluali\0"
	"Malaki\0"
	"\xca\xbb\x41pelila\0"
	"Iune\0"
	"Iulai\0"
	"\xca\xbb\x41ukake\0"
	"Kepakemapa\0"
	"\xca\xbbOkakopa\0"
	"Nowemapa\0"
	"Kekemapa\0"
	"Ian.\0"
	"Pep.\0"
	"Mal.\0"
	"\xca\xbb\x41p.\0"
	"Iun.\0"
	"Iul.\0"
	"\xca\xbb\x41u.\0"
	"Kep.\0"
	"\xca\xbbOk.\0"
	"Now.\0"
	"Kek.\0"
	"Axad\0"
	"Isniin\0"
	"Talaado\0"
	"Arbaco\0"
	"Khamiis\0"
	"Jimco\0"
	"Sabti\0"
	"Axd\0"
	"Arb\0"
	"Kh\0"
	"Bisha Koobaad\0"
	"Bisha Labaad\0"
	"Bisha Saddexaad\0"
	"Bisha Afraad\0"
	"Bisha Shanaad\0"
	"Bisha Lixaad\0"
	"Bisha Todobaad\0"
	"Bisha Sideedaad\0"
	"Bisha Sagaalaad\0"
	"Bisha Tobnaad\0"
	"Bisha Kow iyo Tobnaad\0"
	"Bisha Laba iyo Tobnaad\0"
	"Kob\0"
	"Lab\0"
	"Afr\0"
	"Sha\0"
	"Lix\0"
	"Tod\0"
	"Sid\0"
	"Sag\0"
	"Tob\0"
	"KIT\0"
	"LIT\0"
	"\xea\x91\xad\xea\x86\x8f\xea\x91\x8d\0"
	"\xea\x86\x8f\xea\x8a\x82\xea\x8b\x8d\0"
	"\xea\x86\x8f\xea\x8a\x82\xea\x91\x8d\0"
	"\xea\x86\x8f\xea\x8a\x82\xea\x8c\x95\0"
	"\xea\x86\x8f\xea\x8a\x82\xea\x87\x96\0"
	"\xea\x86\x8f\xea\x8a\x82\xea\x89\xac\0"
	"\xea\x86\x8f\xea\x8a\x82\xea\x83\x98\0"
	"\xea\x91\xad\xea\x86\x8f\0"
	"\xea\x86\x8f\xea\x8b\x8d\0"
	"\xea\x86\x8f\xea\x91\x8d\0"
	"\xea\x86\x8f\xea\x8c\x95\0"
	"\xea\x86\x8f\xea\x87\x96\0"
	"\xea\x86\x8f\xea\x89\xac\0"
	"\xea\x86\x8f\xea\x83\x98\0"
	"\xea\x86\x8f\0"
	"\xea\x8b\x8d\0"
	"\xea\x91\x8d\0"
	"\xea\x8c\x95\0"
	"\xea\x87\x96\0"
	"\xea\x89\xac\0"
	"\xea\x83\x98\0"
	"\xea\x8b\x8d\xea\x86\xaa\0"
	"\xea\x91\x8d\xea\x86\xaa\0"
	"\xea\x8c\x95\xea\x86\xaa\0"
	"\xea\x87\x96\xea\x86\xaa\0"
	"\xea\x89\xac\xea\x86\xaa\0"
	"\xea\x83\x98\xea\x86\xaa\0"
	"\xea\x8f\x83\xea\x86\xaa\0"
	"\xea\x89\x86\xea\x86\xaa\0"
	"\xea\x88\xac\xea\x86\xaa\0"
	"\xea\x8a\xb0\xea\x86\xaa\0"
	"\xea\x8a\xb0\xea\x8a\xaa\xea\x86\xaa\0"
	"\xea\x8a\xb0\xea\x91\x8b\xea\x86\xaa\0"
	"Meurzh\0"
	"Merc\xca\xbcher\0"
	"Yaou\0"
	"Gwener\0"
	"Sadorn\0"
	"Meu.\0"
	"Mer.\0"
	"Gwe.\0"
	"Sad.\0"
	"Su\0"
	"Mz\0"
	"Mc\0"
	"Genver\0"
	"C\xca\xbchwevrer\0"
	"Ebrel\0"
	"Mae\0"
	"Mezheven\0"
	"Gouere\0"
	"Eost\0"
	"Gwengolo\0"
	"Here\0"
	"Du\0"
	"Kerzu\0"
	"Gen.\0"
	"C\xca\xbchwe.\0"
	"Meur.\0"
	"Ebr.\0"
	"Mezh.\0"
	"Goue.\0"
	"Gwen.\0"
	"Ker.\0"
	"\xd9\x8a\xdb\x95\xd9\x83\xd8\xb4\xdb\x95\xd9\x86\xd8\xa8\xdb\x95\0"
	"\xd8\xaf\xdb\x88\xd8\xb4\xdb\x95\xd9\x86\xd8\xa8\xdb\x95\0"
	"\xd8\xb3\xdb\x95\xd9\x8a\xd8\xb4\xdb\x95\xd9\x86\xd8\xa8\xdb\x95\0"
	"\xda\x86\xd8\xa7\xd8\xb1\xd8\xb4\xdb\x95\xd9\x86\xd8\xa8\xdb\x95\0"
	"\xd9\xbe\xdb\x95\xd9\x8a\xd8\xb4\xdb\x95\xd9\x86\xd8\xa8\xdb\x95\0"
	"\xd8\xac\xdb\x88\xd9\x85\xdb\x95\0"
	"\xd8\xb4\xdb\x95\xd9\x86\xd8\xa8\xdb\x95\0"
	"\xd9\x8a\xdb\x95\0"
	"\xd8\xaf\xdb\x88\0"
	"\xd8\xb3\xdb\x95\0"
	"\xda\x86\xd8\xa7\0"
	"\xd9\xbe\xdb\x95\0"
	"\xd8\xac\xdb\x88\0"
	"\xd8\xb4\xdb\x95\0"
	"\xd9\x8a\0"
	"\xd9\x8a\xd8\xa7\xd9\x86\xdb\x8b\xd8\xa7\xd8\xb1\0"
	"\xd9\x81\xdb\x90\xdb\x8b\xd8\xb1\xd8\xa7\xd9\x84\0"
	"\xd9\x85\xd8\xa7\xd8\xb1\xd8\xaa\0"
	"\xd8\xa6\xd8\xa7\xd9\xbe\xd8\xb1\xdb\x90\xd9\x84\0"
	"\xd9\x85\xd8\xa7\xd9\x8a\0"
	"\xd8\xa6\xd9\x89\xd9\x8a\xdb\x87\xd9\x86\0"
	"\xd8\xa6\xd9\x89\xd9\x8a\xdb\x87\xd9\x84\0"
	"\xd8\xa6\xd8\xa7\xdb\x8b\xd8\xba\xdb\x87\xd8\xb3\xd8\xaa\0"
	"\xd8\xb3\xdb\x90\xd9\x86\xd8\xaa\xdb\x95\xd8\xa8\xd9\x89\xd8\xb1\0"
	"\xd8\xa6\xdb\x86\xd9\x83\xd8\xaa\xdb\x95\xd8\xa8\xd9\x89\xd8\xb1\0"
	"\xd9\x86\xd9\x88\xd9\x8a\xd8\xa7\xd8\xa8\xd9\x89\xd8\xb1\0"
	"\xd8\xaf\xdb\x90\xd9\x83\xd8\xa7\xd8\xa8\xd9\x89\xd8\xb1\0"
	"Sunntig\0"
	"M\xc3\xa4\xc3\xa4ntig\0"
	"Ziischtig\0"
	"Mittwuch\0"
	"Dunschtig\0"
	"Friitig\0"
	"Samschtig\0"
	"Su.\0"
	"M\xc3\xa4.\0"
	"Zi.\0"
	"Mi.\0"
	"Du.\0"
	"Fr.\0"
	"Auguscht\0"
	"Sept\xc3\xa4mber\0"
	"Oktoober\0"
	"Nov\xc3\xa4mber\0"
	"Dez\xc3\xa4mber\0"
	"\xd0\xb1\xd0\xb0\xd1\x81\xd0\xba\xd1\x8b\xd2\xbb\xd1\x8b\xd0\xb0\xd0\xbd\xd0\xbd\xd1\x8c\xd0\xb0\0"
	"\xd0\xb1\xd1\x8d\xd0\xbd\xd0\xb8\xd0\xb4\xd0\xb8\xd1\x8d\xd0\xbd\xd0\xbd\xd1\x8c\xd0\xb8\xd0\xba\0"
	"\xd0\xbe\xd0\xbf\xd1\x82\xd1\x83\xd0\xbe\xd1\x80\xd1\x83\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x83\xd0\xba\0"
	"\xd1\x81\xd1\x8d\xd1\x80\xd1\x8d\xd0\xb4\xd1\x8d\0"
	"\xd1\x87\xd1\x8d\xd0\xbf\xd0\xbf\xd0\xb8\xd1\x8d\xd1\x80\0"
	"\xd0\x91\xd1\x8d\xd1\x8d\xd1\x82\xd0\xb8\xd2\xa5\xd1\x81\xd1\x8d\0"
	"\xd1\x81\xd1\x83\xd0\xb1\xd1\x83\xd0\xbe\xd1\x82\xd0\xb0\0"
	"\xd0\xb1\xd1\x81\0"
	"\xd0\xb1\xd0\xbd\0"
	"\xd0\xbe\xd0\xbf\0"
	"\xd1\x81\xd1\x8d\0"
	"\xd1\x87\xd0\xbf\0"
	"\xd0\xb1\xd1\x8d\0"
	"\xd0\x9e\0"
	"\xd1\x82\xd0\xbe\xd1\x85\xd1\x81\xd1\x83\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x83\0"
	"\xd0\xbe\xd0\xbb\xd1\x83\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x83\0"
	"\xd0\xba\xd1\x83\xd0\xbb\xd1\x83\xd0\xbd \xd1\x82\xd1\x83\xd1\x82\xd0\xb0\xd1\x80\0"
	"\xd0\xbc\xd1\x83\xd1\x83\xd1\x81 \xd1\x83\xd1\x81\xd1\x82\xd0\xb0\xd1\x80\0"
	"\xd1\x8b\xd0\xb0\xd0\xbc \xd1\x8b\xd0\xb9\xd0\xb0\0"
	"\xd0\xb1\xd1\x8d\xd1\x81 \xd1\x8b\xd0\xb9\xd0\xb0\0"
	"\xd0\xbe\xd1\x82 \xd1\x8b\xd0\xb9\xd0\xb0\0"
	"\xd0\xb0\xd1\x82\xd1\x8b\xd1\x80\xd0\xb4\xd1\x8c\xd1\x8b\xd1\x85 \xd1\x8b\xd0\xb9\xd0\xb0\0"
	"\xd0\xb1\xd0\xb0\xd0\xbb\xd0\xb0\xd2\x95\xd0\xb0\xd0\xbd \xd1\x8b\xd0\xb9\xd0\xb0\0"
	"\xd0\xb0\xd0\xbb\xd1\x82\xd1\x8b\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x8b\0"
	"\xd1\x81\xd1\x8d\xd1\x82\xd0\xb8\xd0\xbd\xd0\xbd\xd1\x8c\xd0\xb8\0"
	"\xd0\xb0\xd1\x85\xd1\x81\xd1\x8b\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x8b\0"
	"\xd0\xa2\xd0\xbe\xd1\x85\xd1\x81\xd1\x83\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x83\0"
	"\xd0\x9e\xd0\xbb\xd1\x83\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x83\0"
	"\xd0\x9a\xd1\x83\xd0\xbb\xd1\x83\xd0\xbd \xd1\x82\xd1\x83\xd1\x82\xd0\xb0\xd1\x80\0"
	"\xd0\x9c\xd1\x83\xd1\x83\xd1\x81 \xd1\x83\xd1\x81\xd1\x82\xd0\xb0\xd1\x80\0"
	"\xd0\xab\xd0\xb0\xd0\xbc \xd1\x8b\xd0\xb9\xd1\x8b\xd0\xbd\0"
	"\xd0\x91\xd1\x8d\xd1\x81 \xd1\x8b\xd0\xb9\xd1\x8b\xd0\xbd\0"
	"\xd0\x9e\xd1\x82 \xd1\x8b\xd0\xb9\xd1\x8b\xd0\xbd\0"
	"\xd0\x90\xd1\x82\xd1\x8b\xd1\x80\xd0\xb4\xd1\x8c\xd1\x8b\xd1\x85 \xd1\x8b\xd0\xb9\xd1\x8b\xd0\xbd\0"
	"\xd0\x91\xd0\xb0\xd0\xbb\xd0\xb0\xd2\x95\xd0\xb0\xd0\xbd \xd1\x8b\xd0\xb9\xd1\x8b\xd0\xbd\0"
	"\xd0\x90\xd0\xbb\xd1\x82\xd1\x8b\xd0\xbd\xd0\xbd\xd1\x8c\xd1\x8b\0"
	"\xd0\xa1\xd1\x8d\xd1\x82\xd0\xb8\xd0\xbd\xd0\xbd\xd1\x8c\xd0\xb8\0"
	"\xd0\xa2\xd0\xbe\xd1\x85\xd1\x81\0"
	"\xd0\x9e\xd0\xbb\xd1\x83\xd0\xbd\0"
	"\xd0\x9a\xd0\xbb\xd0\xbd\0"
	"\xd0\x9c\xd1\x81\xd1\x83\0"
	"\xd0\xab\xd0\xb0\xd0\xbc\0"
	"\xd0\x91\xd1\x8d\xd1\x81\0"
	"\xd0\x9e\xd1\x82\xd0\xb9\0"
	"\xd0\x90\xd1\x82\xd1\x80\0"
	"\xd0\x91\xd0\xbb\xd2\x95\0"
	"\xd0\x90\xd0\xbb\xd1\x82\0"
	"\xd0\xa1\xd1\x8d\xd1\x82\0"
	"\xd0\x90\xd1\x85\xd1\x81\0"
	"Ku cyumweru\0"
	"Kuwa mbere\0"
	"Kuwa kabiri\0"
	"Kuwa gatatu\0"
	"Kuwa kane\0"
	"Kuwa gatanu\0"
	"Kuwa gatandatu\0"
	"cyu.\0"
	"mbe.\0"
	"kab.\0"
	"gtu.\0"
	"kan.\0"
	"gnu.\0"
	"gnd.\0"
	"Mutarama\0"
	"Gashyantare\0"
	"Werurwe\0"
	"Mata\0"
	"Gicuransi\0"
	"Kamena\0"
	"Nyakanga\0"
	"Kanama\0"
	"Nzeli\0"
	"Ukwakira\0"
	"Ugushyingo\0"
	"Ukuboza\0"
	"mut.\0"
	"gas.\0"
	"wer.\0"
	"mat.\0"
	"gic.\0"
	"kam.\0"
	"nya.\0"
	"nze.\0"
	"ukw.\0"
	"ugu.\0"
	"uku.\0"
	"DiD\xc3\xb2mhnaich\0"
	"DiLuain\0"
	"DiM\xc3\xa0irt\0"
	"DiCiadain\0"
	"DiarDaoin\0"
	"DihAoine\0"
	"DiSathairne\0"
	"DiD\0"
	"DiL\0"
	"DiM\0"
	"DiC\0"
	"Dia\0"
	"Dih\0"
	"DiS\0"
	"Am Faoilleach\0"
	"An Gearran\0"
	"Am M\xc3\xa0rt\0"
	"An Giblean\0"
	"An C\xc3\xa8itean\0"
	"An t-\xc3\x92gmhios\0"
	"An t-Iuchar\0"
	"An L\xc3\xb9nastal\0"
	"An t-Sultain\0"
	"An D\xc3\xa0mhair\0"
	"An t-Samhain\0"
	"An D\xc3\xb9\x62hlachd\0"
	"dhen Fhaoilleach\0"
	"dhen Ghearran\0"
	"dhen Mh\xc3\xa0rt\0"
	"dhen Ghiblean\0"
	"dhen Ch\xc3\xa8itean\0"
	"dhen \xc3\x92gmhios\0"
	"dhen Iuchar\0"
	"dhen L\xc3\xb9nastal\0"
	"dhen t-Sultain\0"
	"dhen D\xc3\xa0mhair\0"
	"dhen t-Samhain\0"
	"dhen D\xc3\xb9\x62hlachd\0"
	"Faoi\0"
	"Gearr\0"
	"M\xc3\xa0rt\0"
	"Gibl\0"
	"C\xc3\xa8it\0"
	"\xc3\x92gmh\0"
	"Iuch\0"
	"L\xc3\xb9na\0"
	"Sult\0"
	"D\xc3\xa0mh\0"
	"D\xc3\xb9\x62h\0"
	"\xe9\x80\xb1\xe6\x97\xa5\0"
	"\xe9\x80\xb1\xe4\xb8\x80\0"
	"\xe9\x80\xb1\xe4\xba\x8c\0"
	"\xe9\x80\xb1\xe4\xb8\x89\0"
	"\xe9\x80\xb1\xe5\x9b\x9b\0"
	"\xe9\x80\xb1\xe4\xba\x94\0"
	"\xe9\x80\xb1\xe5\x85\xad\0"
	"\xd8\xa7\xd9\x84\xd8\xa3\xd8\xad\xd8\xaf\0"
	"\xd8\xa7\xd9\x84\xd8\xa7\xd8\xab\xd9\x86\xd9\x8a\xd9\x86\0"
	"\xd8\xa7\xd9\x84\xd8\xab\xd9\x84\xd8\xa7\xd8\xab\xd8\xa7\xd8\xa1\0"
	"\xd8\xa7\xd9\x84\xd8\xa3\xd8\xb1\xd8\xa8\xd8\xb9\xd8\xa7\xd8\xa1\0"
	"\xd8\xa7\xd9\x84\xd8\xae\xd9\x85\xd9\x8a\xd8\xb3\0"
	"\xd8\xa7\xd9\x84\xd8\xac\xd9\x85\xd8\xb9\xd8\xa9\0"
	"\xd8\xa7\xd9\x84\xd8\xb3\xd8\xa8\xd8\xaa\0"
	"\xd8\xad\0"
	"\xd9\x86\0"
	"\xd8\xab\0"
	"\xd8\xb1\0"
	"\xd8\xae\0"
	"\xd9\x83\xd8\xa7\xd9\x86\xd9\x88\xd9\x86 \xd8\xa7\xd9\x84\xd8\xab\xd8\xa7\xd9\x86\xd9\x8a\0"
	"\xd8\xb4\xd8\xa8\xd8\xa7\xd8\xb7\0"
	"\xd8\xa2\xd8\xb0\xd8\xa7\xd8\xb1\0"
	"\xd9\x86\xd9\x8a\xd8\xb3\xd8\xa7\xd9\x86\0"
	"\xd8\xa3\xd9\x8a\xd8\xa7\xd8\xb1\0"
	"\xd8\xad\xd8\xb2\xd9\x8a\xd8\xb1\xd8\xa7\xd9\x86\0"
	"\xd8\xaa\xd9\x85\xd9\x88\xd8\xb2\0"
	"\xd8\xa2\xd8\xa8\0"
	"\xd8\xa3\xd9\x8a\xd9\x84\xd9\x88\xd9\x84\0"
	"\xd8\xaa\xd8\xb4\xd8\xb1\xd9\x8a\xd9\x86 \xd8\xa7\xd9\x84\xd8\xa3\xd9\x88\xd9\x84\0"
	"\xd8\xaa\xd8\xb4\xd8\xb1\xd9\x8a\xd9\x86 \xd8\xa7\xd9\x84\xd8\xab\xd8\xa7\xd9\x86\xd9\x8a\0"
	"\xd9\x83\xd8\xa7\xd9\x86\xd9\x88\xd9\x86 \xd8\xa7\xd9\x84\xd8\xa3\xd9\x88\xd9\x84\0"
	"ene\0"
	"oct\0"
	"tysdag\0"
	"laurdag\0"
	"tys\0"
	"lau\0"
	"segunda\0"
	"ter\xc3\xa7\x61\0"
	"quarta\0"
	"quinta\0"
	"sexta\0"
	"Dum\0"
	"Mie\0"
	"Joi\0"
	"Vin\0"
	"S\xc3\xa2m\0"
	"Ma\0"
	"\xd9\xbe\xdb\x8c\xd8\xb1\0"
	"\xd0\xb1\xd0\xb0\xd0\xb7\xd0\xb0\xd1\x80\0"
	"\xd0\xb1\xd0\xb0\xd0\xb7\xd0\xb0\xd1\x80 \xd0\xb5\xd1\x80\xd1\x82\xd3\x99\xd1\x81\xd0\xb8\0"
	"\xd1\x87\xd3\x99\xd1\x80\xd1\x88\xd3\x99\xd0\xbd\xd0\xb1\xd3\x99 \xd0\xb0\xd1\x85\xd1\x88\xd0\xb0\xd0\xbc\xd1\x8b\0"
	"\xd1\x87\xd3\x99\xd1\x80\xd1\x88\xd3\x99\xd0\xbd\xd0\xb1\xd3\x99\0"
	"\xd2\xb9\xd2\xaf\xd0\xbc\xd3\x99 \xd0\xb0\xd1\x85\xd1\x88\xd0\xb0\xd0\xbc\xd1\x8b\0"
	"\xd2\xb9\xd2\xaf\xd0\xbc\xd3\x99\0"
	"\xd1\x88\xd3\x99\xd0\xbd\xd0\xb1\xd3\x99\0"
	"\xd0\x91.\0"
	"\xd0\x91.\xd0\x95.\0"
	"\xd0\xa7.\xd0\x90.\0"
	"\xd0\xa7.\0"
	"\xd2\xb8.\xd0\x90.\0"
	"\xd2\xb8.\0"
	"\xd0\xa8.\0"
	"\xd0\x88\xd0\xb0\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\0"
	"\xd0\x98\xd1\x98\xd1\x83\xd0\xbd\0"
	"\xd0\x98\xd1\x98\xd1\x83\xd0\xbb\0"
	"\xd0\xa1\xd0\xb5\xd0\xbd\xd1\x82\xd1\x98\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd0\x9e\xd0\xba\xd1\x82\xd1\x98\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd0\x9d\xd0\xbe\xd1\x98\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd1\x98\xd0\xb0\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\0"
	"\xd1\x84\xd0\xb5\xd0\xb2\xd1\x80\xd0\xb0\xd0\xbb\0"
	"\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb5\xd0\xbb\0"
	"\xd0\xb8\xd1\x98\xd1\x83\xd0\xbd\0"
	"\xd0\xb8\xd1\x98\xd1\x83\xd0\xbb\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\xd1\x82\xd1\x98\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd0\xbe\xd0\xba\xd1\x82\xd1\x98\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd0\xbd\xd0\xbe\xd1\x98\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd0\xb4\xd0\xb5\xd0\xba\xd0\xb0\xd0\xb1\xd1\x80\0"
	"\xd1\x98\xd0\xb0\xd0\xbd\0"
	"\xd0\xbc\xd0\xb0\xd1\x80\0"
	"\xd0\xb8\xd1\x98\xd0\xbd\0"
	"\xd0\xb8\xd1\x98\xd0\xbb\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\0"
	"\xd0\xbd\xd0\xbe\xd1\x98\0"
	"nje\xc5\xba\x65la\0"
	"p\xc3\xb3nje\xc5\xba\x65le\0"
	"wa\xc5\x82tora\0"
	"srjoda\0"
	"stw\xc3\xb3rtk\0"
	"p\xc4\x9btk\0"
	"wa\xc5\x82\0"
	"stw\0"
	"p\xc4\x9bt\0"
	"\xd1\x8f\xd0\xba\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb0\0"
	"\xd0\xb4\xd1\x83\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb0\0"
	"\xd1\x81\xd0\xb5\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb0\0"
	"\xd1\x87\xd0\xbe\xd1\x80\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb0\0"
	"\xd0\xbf\xd0\xb0\xd0\xb9\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb0\0"
	"\xd1\x88\xd0\xb0\xd0\xbd\xd0\xb1\xd0\xb0\0"
	"\xd0\xaf\xd0\xba\xd1\x88\0"
	"\xd0\x94\xd1\x83\xd1\x88\0"
	"\xd0\xa1\xd0\xb5\xd1\x88\0"
	"\xd0\xa7\xd0\xbe\xd1\x80\0"
	"\xd0\x9f\xd0\xb0\xd0\xb9\0"
	"\xd0\x96\xd1\x83\xd0\xbc\0"
	"\xd0\xa8\xd0\xb0\xd0\xbd\0"
	"\xd1\x8f\xd0\xbd\xd0\xb2\xd0\xb0\xd1\x80\0"
	"\xd0\xb8\xd1\x8e\xd0\xbd\0"
	"\xd0\xb8\xd1\x8e\xd0\xbb\0"
	"\xd1\x81\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\0"
	"\xd0\xbe\xd0\xba\xd1\x82\xd1\x8f\xd0\xb1\xd1\x80\0"
	"\xd0\xbd\xd0\xbe\xd1\x8f\xd0\xb1\xd1\x80\0"
	"\xd8\xa8\xd9\x8f\xd8\xaf\xda\xbe\0"
	"\xd9\x85\xd8\xa6\0"
	"\xd9\x8a\xd9\x86\xd8\xa7\xd9\x8a\xd8\xb1\0"
	"\xd9\x81\xd8\xa8\xd8\xb1\xd8\xa7\xd9\x8a\xd8\xb1\0"
	"\xd8\xa3\xd8\xa8\xd8\xb1\xd9\x8a\xd9\x84\0"
	"\xd9\x85\xd8\xa7\xd9\x8a\xd9\x88\0"
	"\xd9\x8a\xd9\x88\xd9\x86\xd9\x8a\xd9\x88\0"
	"\xd9\x8a\xd9\x88\xd9\x84\xd9\x8a\xd9\x88\0"
	"\xd8\xa3\xd8\xba\xd8\xb3\xd8\xb7\xd8\xb3\0"
	"\xd8\xb3\xd8\xa8\xd8\xaa\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xd8\xa3\xd9\x83\xd8\xaa\xd9\x88\xd8\xa8\xd8\xb1\0"
	"\xd9\x86\xd9\x88\xd9\x81\xd9\x85\xd8\xa8\xd8\xb1\0"
	"\xd8\xaf\xd9\x8a\xd8\xb3\xd9\x85\xd8\xa8\xd8\xb1\0"
	"J\xc3\xa4nner\0"
	"J\xc3\xa4n\0"
	"Sun.\0"
	"Mon.\0"
	"Tue.\0"
	"Wed.\0"
	"Thu.\0"
	"Fri.\0"
	"Sat.\0"
	"M.\0"
	"Tu.\0"
	"W.\0"
	"Th.\0"
	"F.\0"
	"Oct.\0"
	"juill.\0"
	"vuoss\xc3\xa1rgga\0"
	"ma\xc5\x8b\xc5\x8b\x65\x62\xc3\xa1rgga\0"
	"gaskavahku\0"
	"duorastaga\0"
	"bearjadaga\0"
	"l\xc3\xa1vvardaga\0"
	"U\0"
	"\xd8\xac\xd8\xa7\xd9\x86\xd9\x81\xd9\x8a\0"
	"\xd9\x81\xd9\x8a\xd9\x81\xd8\xb1\xd9\x8a\0"
	"\xd8\xa3\xd9\x81\xd8\xb1\xd9\x8a\xd9\x84\0"
	"\xd8\xac\xd9\x88\xd8\xa7\xd9\x86\0"
	"\xd8\xac\xd9\x88\xd9\x8a\xd9\x84\xd9\x8a\xd8\xa9\0"
	"\xd8\xa3\xd9\x88\xd8\xaa\0"
	"septembar\0"
	"oktobar\0"
	"novembar\0"
	"decembar\0"
	"avg\0"
	"\xd9\x8a\xd9\x88\xd9\x84\xd9\x8a\xd9\x88\xd8\xb2\0"
	"\xd8\xba\xd8\xb4\xd8\xaa\0"
	"\xd8\xb4\xd8\xaa\xd9\x86\xd8\xa8\xd8\xb1\0"
	"\xd9\x86\xd9\x88\xd9\x86\xd8\xa8\xd8\xb1\0"
	"\xd8\xaf\xd8\xac\xd9\x86\xd8\xa8\xd8\xb1\0"
	"ponedeljak\0"
	"ut.\0"
	"sr.\0"
	"sub.\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4\xd1\x98\xd0\xb5\xd1\x99\xd0\xb0\0"
	"\xd0\xbf\xd0\xbe\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb5\xd1\x99\xd0\xb0\xd0\xba\0"
	"\xd1\x83\xd1\x82\xd0\xbe\xd1\x80\xd0\xb0\xd0\xba\0"
	"\xd1\x81\xd1\x80\xd0\xb8\xd1\x98\xd0\xb5\xd0\xb4\xd0\xb0\0"
	"\xd1\x87\xd0\xb5\xd1\x82\xd0\xb2\xd1\x80\xd1\x82\xd0\xb0\xd0\xba\0"
	"\xd0\xbf\xd0\xb5\xd1\x82\xd0\xb0\xd0\xba\0"
	"\xd1\x83\xd1\x82.\0"
	"\xd1\x81\xd1\x80.\0"
	"\xd1\x81\xd1\x83\xd0\xb1.\0"
	"\xd1\x83\0"
	"\xd1\x98\xd0\xb0\xd0\xbd\xd1\x83\xd0\xb0\xd1\x80\0"
	"\xd1\x84\xd0\xb5\xd0\xb1\xd1\x80\xd1\x83\xd0\xb0\xd1\x80\0"
	"\xd1\x98\xd1\x83\xd0\xbd\0"
	"\xd1\x98\xd1\x83\xd0\xbb\0"
	"\xd1\x81\xd0\xb5\xd0\xbf\xd1\x82\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb0\xd1\x80\0"
	"\xd0\xbe\xd0\xba\xd1\x82\xd0\xbe\xd0\xb1\xd0\xb0\xd1\x80\0"
	"\xd0\xbd\xd0\xbe\xd0\xb2\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb0\xd1\x80\0"
	"\xd0\xb4\xd0\xb5\xd1\x86\xd0\xb5\xd0\xbc\xd0\xb1\xd0\xb0\xd1\x80\0"
	"\xd1\x84\xd0\xb5\xd0\xb1.\0"
	"\xd0\xbd\xd0\xbe\xd0\xb2.\0"
	"\xd0\xb4\xd0\xb5\xd1\x86.\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb5\xd1\x99\xd0\xb0\0"
	"\xd0\xbd\xd0\xb5\xd0\xb4\0"
	"\xd0\xbf\xd0\xbe\xd0\xbd\0"
	"\xd1\x83\xd1\x82\xd0\xbe\0"
	"\xd1\x81\xd1\x80\xd0\xb8\0"
	"\xd1\x87\xd0\xb5\xd1\x82\0"
	"\xd0\xbf\xd0\xb5\xd1\x82\0"
	"\xd1\x81\xd1\x83\xd0\xb1\0"
	"\xd1\x84\xd0\xb5\xd0\xb1\0"
	"\xd0\xbd\xd0\xbe\xd0\xb2\0"
	"\xd0\xb4\xd0\xb5\xd1\x86\0"
	"l\0"
	"j\0"
	"v\0"
	"sre\0"
	"pasepeeivi\0"
	"vuossaarg\xc3\xa2\0"
	"majebaarg\xc3\xa2\0"
	"koskoho\0"
	"tuor\xc3\xa2stuv\0"
	"v\xc3\xa1stuppeeivi\0"
	"l\xc3\xa1vurduv\0"
	"pas\0"
	"vuo\0"
	"kos\0"
	"tuo\0"
	"v\xc3\xa1s\0"
	"u\xc4\x91\xc4\x91\xc3\xa2ivem\xc3\xa1\xc3\xa1nu\0"
	"kuov\xc3\xa2m\xc3\xa1\xc3\xa1nu\0"
	"njuh\xc4\x8d\xc3\xa2m\xc3\xa1\xc3\xa1nu\0"
	"cu\xc3\xa1\xc5\x8buim\xc3\xa1\xc3\xa1nu\0"
	"vyesim\xc3\xa1\xc3\xa1nu\0"
	"kesim\xc3\xa1\xc3\xa1nu\0"
	"syeinim\xc3\xa1\xc3\xa1nu\0"
	"porgem\xc3\xa1\xc3\xa1nu\0"
	"\xc4\x8doh\xc4\x8d\xc3\xa2m\xc3\xa1\xc3\xa1nu\0"
	"roovv\xc3\xa2\x64m\xc3\xa1\xc3\xa1nu\0"
	"skamm\xc3\xa2m\xc3\xa1\xc3\xa1nu\0"
	"juovl\xc3\xa2m\xc3\xa1\xc3\xa1nu\0"
	"u\xc4\x91iv\0"
	"kuov\xc3\xa2\0"
	"njuh\xc4\x8d\xc3\xa2\0"
	"cu\xc3\xa1\xc5\x8bui\0"
	"vyesi\0"
	"kesi\0"
	"syeini\0"
	"porge\0"
	"\xc4\x8doh\xc4\x8d\xc3\xa2\0"
	"roovv\xc3\xa2\x64\0"
	"skamm\xc3\xa2\0"
	"juovl\xc3\xa2\0"
	"Febrero\0"
	"Junio\0"
	"Julio\0"
	"Setiembre\0"
	"Octubre\0"
	"Noviembre\0"
	"Diciembre\0"
	"setiembre\0"
	"Ene.\0"
	"May.\0"
	"Dic.\0"
	"\xd1\x81\xd1\x80\xd0\xb5\0"
	"f\xc3\xa9v.\0"
	"jui.\0"
	"\xd8\xa7\xd9\x84\xd8\xaa\xd9\x82\xd9\x88\xd9\x8a\xd9\x85 \xd8\xa7\xd9\x84\xd9\x87\xd8\xac\xd8\xb1\xd9\x8a\0"
	"\xd0\xb3\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8 \xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\0"
	"calendari gregori\xc3\xa0\0"
	"\xe5\x85\xac\xe5\x8e\x86\0"
	"Gregori\xc3\xa1nsk\xc3\xbd kalend\xc3\xa1\xc5\x99\0"
	"gregoriansk kalender\0"
	"Gregorianischer Kalender\0"
	"\xce\x93\xcf\x81\xce\xb7\xce\xb3\xce\xbf\xcf\x81\xce\xb9\xce\xb1\xce\xbd\xcf\x8c \xce\xb7\xce\xbc\xce\xb5\xcf\x81\xce\xbf\xce\xbb\xcf\x8c\xce\xb3\xce\xb9\xce\xbf\0"
	"Gregorian Calendar\0"
	"calendario gregoriano\0"
	"gregoriaaninen kalenteri\0"
	"calendrier gr\xc3\xa9gorien\0"
	"\xd7\x9c\xd7\x95\xd7\x97 \xd7\x94\xd7\xa9\xd7\xa0\xd7\x94 \xd7\x94\xd7\x92\xd7\xa8\xd7\x92\xd7\x95\xd7\xa8\xd7\x99\xd7\x90\xd7\xa0\xd7\x99\0"
	"Gergely-napt\xc3\xa1r\0"
	"Gregor\xc3\xadskt dagatal\0"
	"Calendario gregoriano\0"
	"\xe8\xa5\xbf\xe6\x9a\xa6(\xe3\x82\xb0\xe3\x83\xac\xe3\x82\xb4\xe3\x83\xaa\xe3\x82\xaa\xe6\x9a\xa6)\0"
	"\xec\x96\x91\xeb\xa0\xa5\0"
	"Gregoriaanse kalender\0"
	"kalendarz gregoria\xc5\x84ski\0"
	"Calend\xc3\xa1rio Gregoriano\0"
	"chalender gregorian\0"
	"calendar gregorian\0"
	"\xd0\xb3\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9 \xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\xd1\x8c\0"
	"gregorijanski kalendar\0"
	"gregori\xc3\xa1nsky kalend\xc3\xa1r\0"
	"kalendar gregorian\0"
	"\xe0\xb8\x9b\xe0\xb8\x8f\xe0\xb8\xb4\xe0\xb8\x97\xe0\xb8\xb4\xe0\xb8\x99\xe0\xb8\x9e\xe0\xb8\xb8\xe0\xb8\x97\xe0\xb8\x98\0"
	"Miladi Takvim\0"
	"\xd8\xac\xd8\xa7\xd8\xb1\xd8\xac\xdb\x8c\xd8\xa7\xd8\xa6\xdb\x8c \xda\xa9\xdb\x8c\xd9\x84\xd9\x86\xda\x88\xd8\xb1\0"
	"Kalender Gregorian\0"
	"\xd0\xb3\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xd1\x80\xd1\x96\xd0\xb0\xd0\xbd\xd1\x81\xd1\x8c\xd0\xba\xd0\xb8\xd0\xb9 \xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\0"
	"\xd0\xb3\xd1\x80\xd1\x8b\xd0\xb3\xd0\xb0\xd1\x80\xd1\x8b\xd1\x8f\xd0\xbd\xd1\x81\xd0\xba\xd1\x96 \xd0\xba\xd0\xb0\xd0\xbb\xd1\x8f\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\0"
	"gregorijanski koledar\0"
	"Gregoriuse kalender\0"
	"Gregora kalend\xc4\x81rs\0"
	"Grigaliaus kalendorius\0"
	"\xd8\xaa\xd9\x82\xd9\x88\xdb\x8c\xd9\x85 \xd9\x85\xdb\x8c\xd9\x84\xd8\xa7\xd8\xaf\xdb\x8c\0"
	"L\xe1\xbb\x8b\x63h Gregory\0"
	"\xd5\xa3\xd6\x80\xd5\xab\xd5\xa3\xd5\xb8\xd6\x80\xd5\xb5\xd5\xa1\xd5\xb6 \xd5\xbf\xd5\xb8\xd5\xb4\xd5\xa1\xd6\x80\0"
	"Qreqorian T\xc9\x99qvimi\0"
	"Egutegi gregoriarra\0"
	"gregorianska protyka\0"
	"\xd0\x93\xd1\x80\xd0\xb5\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd1\x98\xd0\xb0\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8 \xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\0"
	"ikhalenda lesi-Gregorian\0"
	"Gregoriese kalender\0"
	"\xe1\x83\x92\xe1\x83\xa0\xe1\x83\x98\xe1\x83\x92\xe1\x83\x9d\xe1\x83\xa0\xe1\x83\x98\xe1\x83\x90\xe1\x83\x9c\xe1\x83\xa3\xe1\x83\x9a\xe1\x83\x98 \xe1\x83\x99\xe1\x83\x90\xe1\x83\x9a\xe1\x83\x94\xe1\x83\x9c\xe1\x83\x93\xe1\x83\x90\xe1\x83\xa0\xe1\x83\x98\0"
	"gregorianskur kalendari\0"
	"\xe0\xa4\x97\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x87\xe0\xa4\x97\xe0\xa5\x8b\xe0\xa4\xb0\xe0\xa4\xbf\xe0\xa4\xaf\xe0\xa4\xa8 \xe0\xa4\x95\xe0\xa5\x88\xe0\xa4\xb2\xe0\xa5\x87\xe0\xa4\x82\xe0\xa4\xa1\xe0\xa4\xb0\0"
	"Kalendarju Gregorjan\0"
	"gregoria kaleander\0"
	"F\xc3\xa9ilire Ghr\xc3\xa9\x61g\xc3\xb3ra\0"
	"Kalendar Gregory\0"
	"\xd0\x93\xd1\x80\xd0\xb5\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd\xd0\xb4\xd1\x8b\xd2\x9b \xd0\xba\xd2\xaf\xd0\xbd\xd1\x82\xd1\x96\xd0\xb7\xd0\xb1\xd0\xb5\0"
	"\xd0\x93\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd \xd0\xb6\xd1\x8b\xd0\xbb\xd0\xbd\xd0\xb0\xd0\xb0\xd0\xbc\xd0\xb0\xd1\x81\xd1\x8b\0"
	"Kalenda ya Kigregori\0"
	"Gregor\xc3\xbd\x61n senenamasy\0"
	"grigorian taqvimi\0"
	"\xd0\xb3\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd \xd0\xb5\xd0\xbb \xd0\xb8\xd1\x81\xd3\x99\xd0\xb1\xd0\xb5\0"
	"\xe0\xa6\x97\xe0\xa7\x8d\xe0\xa6\xb0\xe0\xa6\xbf\xe0\xa6\x97\xe0\xa7\x8b\xe0\xa6\xb0\xe0\xa6\xbf\xe0\xa6\xaf\xe0\xa6\xbc\xe0\xa6\xbe\xe0\xa6\xa8 \xe0\xa6\x95\xe0\xa7\x8d\xe0\xa6\xaf\xe0\xa6\xbe\xe0\xa6\xb2\xe0\xa7\x87\xe0\xa6\xa8\xe0\xa7\x8d\xe0\xa6\xa1\xe0\xa6\xbe\xe0\xa6\xb0\0"
	"\xe0\xa8\x97\xe0\xa8\xb0\xe0\xa9\x87\xe0\xa8\x97\xe0\xa9\x8b\xe0\xa8\xb0\xe0\xa9\x80\xe0\xa8\x85\xe0\xa8\xa8 \xe0\xa8\x95\xe0\xa9\x88\xe0\xa8\xb2\xe0\xa9\xb0\xe0\xa8\xa1\xe0\xa8\xb0\0"
	"\xe0\xaa\x97\xe0\xab\x8d\xe0\xaa\xb0\xe0\xab\x87\xe0\xaa\x97\xe0\xab\x8b\xe0\xaa\xb0\xe0\xaa\xbf\xe0\xaa\x85\xe0\xaa\xa8 \xe0\xaa\x95\xe0\xab\x87\xe0\xaa\xb2\xe0\xab\x87\xe0\xaa\xa8\xe0\xab\x8d\xe0\xaa\xa1\xe0\xaa\xb0\0"
	"\xe0\xae\x95\xe0\xae\xbf\xe0\xae\xb0\xe0\xae\xbf\xe0\xae\x95\xe0\xaf\x8b\xe0\xae\xb0\xe0\xae\xbf\xe0\xae\xaf\xe0\xae\xa9\xe0\xaf\x8d \xe0\xae\xa8\xe0\xae\xbe\xe0\xae\xb3\xe0\xaf\x8d\xe0\xae\x95\xe0\xae\xbe\xe0\xae\x9f\xe0\xaf\x8d\xe0\xae\x9f\xe0\xae\xbf\0"
	"\xe0\xb0\x97\xe0\xb1\x8d\xe0\xb0\xb0\xe0\xb1\x87\xe0\xb0\x97\xe0\xb1\x8b\xe0\xb0\xb0\xe0\xb0\xbf\xe0\xb0\xaf\xe0\xb0\xa8\xe0\xb1\x8d \xe0\xb0\x95\xe0\xb1\x8d\xe0\xb0\xaf\xe0\xb0\xbe\xe0\xb0\xb2\xe0\xb1\x86\xe0\xb0\x82\xe0\xb0\xa1\xe0\xb0\xb0\xe0\xb1\x8d\0"
	"\xe0\xb2\x97\xe0\xb3\x8d\xe0\xb2\xb0\xe0\xb3\x86\xe0\xb2\x97\xe0\xb3\x8b\xe0\xb2\xb0\xe0\xb2\xbf\xe0\xb2\xaf\xe0\xb2\xa8\xe0\xb3\x8d \xe0\xb2\x95\xe0\xb3\x8d\xe0\xb2\xaf\xe0\xb2\xbe\xe0\xb2\xb2\xe0\xb3\x86\xe0\xb2\x82\xe0\xb2\xa1\xe0\xb2\xb0\xe0\xb3\x8d\0"
	"\xe0\xb4\x87\xe0\xb4\x82\xe0\xb4\x97\xe0\xb5\x8d\xe0\xb4\xb2\xe0\xb5\x80\xe0\xb4\xb7\xe0\xb5\x8d \xe0\xb4\x95\xe0\xb4\xb2\xe0\xb4\xa3\xe0\xb5\x8d\xe0\xb4\x9f\xe0\xb5\xbc\0"
	"\xe0\xa6\x97\xe0\xa7\x8d\xe0\xa7\xb0\xe0\xa6\xbf\xe0\xa6\x97\xe0\xa7\x8b\xe0\xa7\xb0\xe0\xa7\x80\xe0\xa6\xaf\xe0\xa6\xbc \xe0\xa6\xaa\xe0\xa6\x9e\xe0\xa7\x8d\xe0\xa6\x9c\xe0\xa6\xbf\xe0\xa6\x95\xe0\xa6\xbe\0"
	"\xe0\xa4\x97\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x87\xe0\xa4\x97\xe0\xa5\x8b\xe0\xa4\xb0\xe0\xa4\xbf\xe0\xa4\xaf\xe0\xa4\xa8 \xe0\xa4\xa6\xe0\xa4\xbf\xe0\xa4\xa8\xe0\xa4\xa6\xe0\xa4\xb0\xe0\xa5\x8d\xe0\xa4\xb6\xe0\xa4\xbf\xe0\xa4\x95\xe0\xa4\xbe\0"
	"\xd0\xb3\xd1\x80\xd0\xb5\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb9\xd0\xbd \xd1\x85\xd1\x83\xd0\xb0\xd0\xbd\xd0\xbb\xd0\xb8\0"
	"Calendr Gregori\0"
	"\xe1\x9e\x94\xe1\x9f\x92\xe1\x9e\x9a\xe1\x9e\x8f\xe1\x9e\xb7\xe1\x9e\x91\xe1\x9e\xb7\xe1\x9e\x93\xe2\x80\x8b\xe1\x9e\xa0\xe1\x9f\x92\xe1\x9e\x9f\xe1\x9e\x80\xe1\x9e\xa0\xe1\x9f\x92\xe1\x9e\x9f\xe1\x9f\x8a\xe1\x9e\xb8\0"
	"\xe0\xba\x9b\xe0\xba\xb0\xe0\xba\x95\xe0\xba\xb4\xe0\xba\x97\xe0\xba\xb4\xe0\xba\x99\xe0\xbb\x80\xe0\xba\x81\xe0\xba\xa3\xe0\xbb\x82\xe0\xba\x81\xe0\xba\xa3\xe0\xba\xbd\xe0\xba\x99\0"
	"\xe1\x80\x94\xe1\x80\xad\xe1\x80\xaf\xe1\x80\x84\xe1\x80\xba\xe1\x80\x84\xe1\x80\xb6\xe1\x80\x90\xe1\x80\x80\xe1\x80\xac\xe1\x80\x9e\xe1\x80\xaf\xe1\x80\xb6\xe1\x80\xb8 \xe1\x80\x95\xe1\x80\xbc\xe1\x80\x80\xe1\x80\xb9\xe1\x80\x81\xe1\x80\x92\xe1\x80\xad\xe1\x80\x94\xe1\x80\xba\0"
	"\xe0\xb6\x9c\xe0\xb7\x8a\xe2\x80\x8d\xe0\xb6\xbb\xe0\xb7\x99\xe0\xb6\x9c\xe0\xb6\xbb\xe0\xb7\x92\xe0\xb6\xba\xe0\xb7\x8f\xe0\xb6\xb1\xe0\xb7\x94 \xe0\xb6\xaf\xe0\xb7\x92\xe0\xb6\xb1 \xe0\xb6\xaf\xe0\xb6\xbb\xe0\xb7\x8a\xe0\xb7\x81\xe0\xb6\xb1\xe0\xb6\xba\0"
	"\xe1\x8e\xa9\xe1\x8e\xb4\xe1\x8e\xaa\xe1\x8e\xb5\xe1\x8e\xa0\xe1\x8f\x82 \xe1\x8f\x85\xe1\x8f\x99 \xe1\x8f\x97\xe1\x8f\x8e\xe1\x8f\x8d\xe1\x8f\x97\0"
	"\xe1\x8b\xa8\xe1\x8c\x8d\xe1\x88\xaa\xe1\x8c\x8e\xe1\x88\xaa\xe1\x8b\xab\xe1\x8a\x95 \xe1\x8b\xa8\xe1\x89\x80\xe1\x8a\x95 \xe1\x8a\xa0\xe1\x89\x86\xe1\x8c\xa3\xe1\x8c\xa0\xe1\x88\xad\0"
	"\xe0\xa4\x97\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x87\xe0\xa4\x97\xe0\xa5\x8b\xe0\xa4\xb0\xe0\xa4\xbf\xe0\xa4\xaf\xe0\xa4\xa8 \xe0\xa4\xaa\xe0\xa4\xbe\xe0\xa4\xa4\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa5\x8b\0"
	"Gregoriaanske kalinder\0"
	"Gregorian na Kalendaryo\0"
	"Gregorianesche Kalenner\0"
	"gregorianskit ullorsiutaat\0"
	"\xea\x84\x89\xea\x89\xbb\xea\x83\x85\xea\x91\x8d\0"
	"deiziadur gregorian\0"
	"\xd9\x85\xd9\x89\xd9\x84\xd8\xa7\xd8\xaf\xd9\x89\xd9\x8a\xdb\x95 \xd9\x8a\xd9\x89\xd9\x84\xd9\x86\xd8\xa7\xd9\x85\xdb\x95\xd8\xb3\xd9\x89\0"
	"Gregoriaanisch Kal\xc3\xa4nder\0"
	"Am M\xc3\xacosachan Griogarach\0"
	"\xe5\x85\xac\xe6\x9b\x86\0"
	"\xd8\xa7\xd9\x84\xd8\xaa\xd9\x82\xd9\x88\xd9\x8a\xd9\x85 \xd8\xa7\xd9\x84\xd9\x85\xd9\x8a\xd9\x84\xd8\xa7\xd8\xaf\xd9\x8a\0"
	"Calend\xc3\xa1rio gregoriano\0"
	"gregoria\xc5\x84ski kalender\0"
	"\xd0\x93\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb0\xd0\xbd \xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\xd0\xb8\0"
	"gregoriala\xc5\xa1 kalendar\0"
	"\xd0\xb3\xd1\x80\xd0\xb5\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd1\x98\xd0\xb0\xd0\xbd\xd1\x81\xd0\xba\xd0\xb8 \xd0\xba\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x80\0"
};


#endif


```

`Hazel/vendor/mono/include/mono/metadata/culture-info.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_CULTURE_INFO_H_
#define _MONO_METADATA_CULTURE_INFO_H_ 1

#include <glib.h>
#include <mono/metadata/object.h>

#define NUM_DAYS 7
#define NUM_MONTHS 13
#define GROUP_SIZE 2
#define NUM_CALENDARS 4

#define NUM_SHORT_DATE_PATTERNS 14
#define NUM_LONG_DATE_PATTERNS 10
#define NUM_SHORT_TIME_PATTERNS 12
#define NUM_LONG_TIME_PATTERNS 9
#define NUM_YEAR_MONTH_PATTERNS 8

#define idx2string(idx) (locale_strings + (idx))
#define pattern2string(idx) (patterns + (idx))
#define dtidx2string(idx) (datetime_strings + (idx))

/* need to change this if the string data ends up to not fit in a 64KB array. */
typedef guint16 stridx_t;

typedef struct {
	stridx_t month_day_pattern;
	stridx_t am_designator;
	stridx_t pm_designator;

	stridx_t day_names [NUM_DAYS];
	stridx_t abbreviated_day_names [NUM_DAYS];
	stridx_t shortest_day_names [NUM_DAYS];
	stridx_t month_names [NUM_MONTHS];
	stridx_t month_genitive_names [NUM_MONTHS];
	stridx_t abbreviated_month_names [NUM_MONTHS];
	stridx_t abbreviated_month_genitive_names [NUM_MONTHS];

	gint8 calendar_week_rule;
	gint8 first_day_of_week;

	stridx_t date_separator;
	stridx_t time_separator;

	stridx_t short_date_patterns [NUM_SHORT_DATE_PATTERNS];
	stridx_t long_date_patterns [NUM_LONG_DATE_PATTERNS];
	stridx_t short_time_patterns [NUM_SHORT_TIME_PATTERNS];
	stridx_t long_time_patterns [NUM_LONG_TIME_PATTERNS];
	stridx_t year_month_patterns [NUM_YEAR_MONTH_PATTERNS];
} DateTimeFormatEntry;

typedef struct {
	// 12x ushort -- 6 ints
	stridx_t currency_decimal_separator;
	stridx_t currency_group_separator;
	stridx_t number_decimal_separator;
	stridx_t number_group_separator;

	stridx_t currency_symbol;
	stridx_t percent_symbol;
	stridx_t nan_symbol;
	stridx_t per_mille_symbol;
	stridx_t negative_infinity_symbol;
	stridx_t positive_infinity_symbol;

	stridx_t negative_sign;
	stridx_t positive_sign;

	// 7x gint8 -- FIXME expand to 8, or sort by size.
	// For this reason, copy the data to a simpler "managed" form.
	gint8 currency_negative_pattern;
	gint8 currency_positive_pattern;
	gint8 percent_negative_pattern;
	gint8 percent_positive_pattern;
	gint8 number_negative_pattern;

	gint8 currency_decimal_digits;
	gint8 number_decimal_digits;

	gint currency_group_sizes [2];
	gint number_group_sizes [2];
} NumberFormatEntry;

// Due to the questionable layout of NumberFormatEntry, in particular
// 7x byte, make something more guaranteed to match between native and managed.
// mono/metadta/culture-info.h NumberFormatEntryManaged must match
// mcs/class/corlib/ReferenceSources/CultureData.cs NumberFormatEntryManaged.
// This is sorted alphabetically.
struct NumberFormatEntryManaged {
	gint32 currency_decimal_digits;
	gint32 currency_decimal_separator;
	gint32 currency_group_separator;
	gint32 currency_group_sizes0;
	gint32 currency_group_sizes1;
	gint32 currency_negative_pattern;
	gint32 currency_positive_pattern;
	gint32 currency_symbol;
	gint32 nan_symbol;
	gint32 negative_infinity_symbol;
	gint32 negative_sign;
	gint32 number_decimal_digits;
	gint32 number_decimal_separator;
	gint32 number_group_separator;
	gint32 number_group_sizes0;
	gint32 number_group_sizes1;
	gint32 number_negative_pattern;
	gint32 per_mille_symbol;
	gint32 percent_negative_pattern;
	gint32 percent_positive_pattern;
	gint32 percent_symbol;
	gint32 positive_infinity_symbol;
	gint32 positive_sign;
};

typedef struct {
	gint ansi;
	gint ebcdic;
	gint mac;
	gint oem;
	MonoBoolean is_right_to_left;
	char list_sep;
} TextInfoEntry;

typedef struct {
	gint16 lcid;
	gint16 parent_lcid;
	gint16 calendar_type;
	gint16 region_entry_index;
	stridx_t name;
	stridx_t englishname;
	stridx_t nativename;
	stridx_t win3lang;
	stridx_t iso3lang;
	stridx_t iso2lang;
	stridx_t territory;
	stridx_t native_calendar_names [NUM_CALENDARS];

	gint16 datetime_format_index;
	gint16 number_format_index;

	TextInfoEntry text_info;
} CultureInfoEntry;

typedef struct {
	stridx_t name;
	gint16 culture_entry_index;
} CultureInfoNameEntry;

typedef struct {
	gint16 geo_id;
	stridx_t iso2name;
	stridx_t iso3name;
	stridx_t win3name;
	stridx_t english_name;
	stridx_t native_name;
	stridx_t currency_symbol;
	stridx_t iso_currency_symbol;
	stridx_t currency_english_name;
	stridx_t currency_native_name;
} RegionInfoEntry;

typedef struct {
	stridx_t name;
	gint16 region_entry_index;
} RegionInfoNameEntry;

#endif


```

`Hazel/vendor/mono/include/mono/metadata/custom-attrs-internals.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_CUSTOM_ATTRS_INTERNALS_H__
#define __MONO_METADATA_CUSTOM_ATTRS_INTERNALS_H__

#include <mono/metadata/object.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/reflection.h>

MonoCustomAttrInfo*
mono_custom_attrs_from_builders (MonoImage *alloc_img, MonoImage *image, MonoArray *cattrs);

typedef gboolean (*MonoAssemblyMetadataCustomAttrIterFunc) (MonoImage *image, guint32 typeref_scope_token, const gchar* nspace, const gchar* name, guint32 method_token, gpointer user_data);

void
mono_assembly_metadata_foreach_custom_attr (MonoAssembly *assembly, MonoAssemblyMetadataCustomAttrIterFunc func, gpointer user_data);

void
mono_class_metadata_foreach_custom_attr (MonoClass *klass, MonoAssemblyMetadataCustomAttrIterFunc func, gpointer user_data);

gboolean
mono_assembly_is_weak_field (MonoImage *image, guint32 field_idx);

void
mono_assembly_init_weak_fields (MonoImage *image);

void
mono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArrayHandleOut typed_args_out, MonoArrayHandleOut named_args_out, CattrNamedArg **named_arg_info, MonoError *error);

void
mono_reflection_create_custom_attr_data_args_noalloc (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len,
													  gpointer **typed_args_out, gpointer **named_args_out, int *num_named_args,
													  CattrNamedArg **named_arg_info, MonoError *error);

#endif  /* __MONO_METADATA_REFLECTION_CUSTOM_ATTRS_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/debug-helpers.h`:

```h
/**
 * \file
 */

#ifndef __MONO_DEBUG_HELPERS_H__
#define __MONO_DEBUG_HELPERS_H__

#include <mono/metadata/class.h>

MONO_BEGIN_DECLS

typedef struct MonoDisHelper MonoDisHelper;

typedef char* (*MonoDisIndenter) (MonoDisHelper *dh, MonoMethod *method, uint32_t ip_offset);
typedef char* (*MonoDisTokener)  (MonoDisHelper *dh, MonoMethod *method, uint32_t token);

struct MonoDisHelper {
	const char *newline;
	const char *label_format;
	const char *label_target;
	MonoDisIndenter indenter;
	MonoDisTokener  tokener;
	void* user_data;
};

MONO_API char* mono_disasm_code_one (MonoDisHelper *dh, MonoMethod *method, const mono_byte *ip, const mono_byte** endp);
MONO_API char* mono_disasm_code     (MonoDisHelper *dh, MonoMethod *method, const mono_byte *ip, const mono_byte* end);

typedef struct MonoMethodDesc MonoMethodDesc;

MONO_API char*           mono_type_full_name (MonoType *type);

MONO_API char*           mono_signature_get_desc (MonoMethodSignature *sig, mono_bool include_namespace);

MONO_API char*           mono_context_get_desc (MonoGenericContext *context);

MONO_API MonoMethodDesc* mono_method_desc_new (const char *name, mono_bool include_namespace);
MONO_API MonoMethodDesc* mono_method_desc_from_method (MonoMethod *method);
MONO_API void            mono_method_desc_free (MonoMethodDesc *desc);
MONO_API mono_bool       mono_method_desc_match (MonoMethodDesc *desc, MonoMethod *method);
MONO_API mono_bool       mono_method_desc_is_full (MonoMethodDesc *desc);
MONO_API mono_bool       mono_method_desc_full_match (MonoMethodDesc *desc, MonoMethod *method);
MONO_API MonoMethod*     mono_method_desc_search_in_class (MonoMethodDesc *desc, MonoClass *klass);
MONO_API MonoMethod*     mono_method_desc_search_in_image (MonoMethodDesc *desc, MonoImage *image);

MONO_API char*           mono_method_full_name (MonoMethod *method, mono_bool signature);
MONO_API char*           mono_method_get_reflection_name (MonoMethod *method);

MONO_API char*           mono_field_full_name (MonoClassField *field);

MONO_END_DECLS

#endif /* __MONO_DEBUG_HELPERS_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/debug-internals.h`:

```h
#ifndef __DEBUG_INTERNALS_H__
#define __DEBUG_INTERNALS_H__

#include <glib.h>
#include <mono/metadata/debug-helpers.h>
#include <mono/metadata/mono-debug.h>
#include <mono/utils/mono-compiler.h>

struct _MonoDebugMethodInfo {
	MonoMethod *method;
	MonoDebugHandle *handle;
	uint32_t index;
	uint32_t data_offset;
	uint32_t lnt_offset;
};

typedef struct {
	int parent;
	int type;
	/* IL offsets */
	int start_offset, end_offset;
} MonoDebugCodeBlock;

typedef struct {
	char *name;
	int index;
	/* Might be null for the main scope */
	MonoDebugCodeBlock *block;
} MonoDebugLocalVar;

/*
 * Information about local variables retrieved from a symbol file.
 */
struct _MonoDebugLocalsInfo {
	int num_locals;
	MonoDebugLocalVar *locals;
	int num_blocks;
	MonoDebugCodeBlock *code_blocks;
};

/*
* Information about method await yield and resume offsets retrieved from a symbol file.
*/
struct _MonoDebugMethodAsyncInfo {
	uint32_t catch_handler_offset;
	int num_awaits;
	uint32_t *yield_offsets;
	uint32_t *resume_offsets;
	uint32_t *move_next_method_token;
};

struct _MonoDebugLineNumberEntry {
	uint32_t il_offset;
	uint32_t native_offset;
};

/*
 * Information about a source file retrieved from a symbol file.
 */
typedef struct {
	char *source_file;
	/* 16 byte long */
	guint8 *guid, *hash;
} MonoDebugSourceInfo;

typedef struct {
	int il_offset;
	int line, column;
	int end_line, end_column;
} MonoSymSeqPoint;

void            mono_debugger_lock                          (void);
void            mono_debugger_unlock                        (void);

MONO_LLVM_INTERNAL void
mono_debug_get_seq_points (MonoDebugMethodInfo *minfo, char **source_file,
			   GPtrArray **source_file_list, int **source_files,
			   MonoSymSeqPoint **seq_points, int *n_seq_points);

MONO_API void
mono_debug_free_locals (MonoDebugLocalsInfo *info);

void
mono_debug_free_method_async_debug_info (MonoDebugMethodAsyncInfo *info);

gboolean
mono_debug_image_has_debug_info (MonoImage *image);

MonoDebugSourceLocation *
mono_debug_lookup_source_location_by_il (MonoMethod *method, guint32 il_offset, MonoDomain *domain);

char*
mono_debug_image_get_sourcelink (MonoImage *image);

#endif /* __DEBUG_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/debug-mono-ppdb.h`:

```h
/**
 * \file
 * Support for the portable PDB symbol file format
 *
 *
 * Author:
 *	Mono Project (http://www.mono-project.com)
 *
 * Copyright 2015 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_METADATA_DEBUG_MONO_PPDB_H__
#define __MONO_METADATA_DEBUG_MONO_PPDB_H__

#include <config.h>
#include <mono/metadata/metadata-internals.h>
#include <mono/metadata/mono-debug.h>

MonoPPDBFile*
mono_ppdb_load_file (MonoImage *image, const guint8 *raw_contents, int size);

void
mono_ppdb_close (MonoDebugHandle *handle);

MonoDebugMethodInfo *
mono_ppdb_lookup_method (MonoDebugHandle *handle, MonoMethod *method);

MonoDebugSourceLocation *
mono_ppdb_lookup_location (MonoDebugMethodInfo *minfo, uint32_t offset);

void
mono_ppdb_get_seq_points (MonoDebugMethodInfo *minfo, char **source_file, GPtrArray **source_file_list, int **source_files, MonoSymSeqPoint **seq_points, int *n_seq_points);

MonoDebugLocalsInfo*
mono_ppdb_lookup_locals (MonoDebugMethodInfo *minfo);

MonoDebugMethodAsyncInfo*
mono_ppdb_lookup_method_async_debug_info (MonoDebugMethodInfo *minfo);

MonoImage *
mono_ppdb_get_image (MonoPPDBFile *ppdb);

char *
mono_ppdb_get_sourcelink (MonoDebugHandle *handle);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/debug-mono-symfile.h`:

```h
/**
 * \file
 * This header is only installed for use by the debugger:
 * the structures and the API declared here are not supported.
 * Copyright 2012 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_DEBUG_MONO_SYMFILE_H__
#define __MONO_DEBUG_MONO_SYMFILE_H__

#include <glib.h>
#include <mono/metadata/class.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/mono-debug.h>
#include <mono/metadata/debug-internals.h>

typedef struct MonoSymbolFileOffsetTable	MonoSymbolFileOffsetTable;
typedef struct MonoSymbolFileLineNumberEntry	MonoSymbolFileLineNumberEntry;
typedef struct MonoSymbolFileMethodAddress	MonoSymbolFileMethodAddress;
typedef struct MonoSymbolFileDynamicTable	MonoSymbolFileDynamicTable;
typedef struct MonoSymbolFileSourceEntry	MonoSymbolFileSourceEntry;
typedef struct MonoSymbolFileMethodEntry	MonoSymbolFileMethodEntry;

/* Keep in sync with OffsetTable in mcs/class/Mono.CSharp.Debugger/MonoSymbolTable.cs */
struct MonoSymbolFileOffsetTable {
	uint32_t _total_file_size;
	uint32_t _data_section_offset;
	uint32_t _data_section_size;
	uint32_t _compile_unit_count;
	uint32_t _compile_unit_table_offset;
	uint32_t _compile_unit_table_size;
	uint32_t _source_count;
	uint32_t _source_table_offset;
	uint32_t _source_table_size;
	uint32_t _method_count;
	uint32_t _method_table_offset;
	uint32_t _method_table_size;
	uint32_t _type_count;
	uint32_t _anonymous_scope_count;
	uint32_t _anonymous_scope_table_offset;
	uint32_t _anonymous_scope_table_size;
	uint32_t _line_number_table_line_base;
	uint32_t _line_number_table_line_range;
	uint32_t _line_number_table_opcode_base;
	uint32_t _is_aspx_source;
};

struct MonoSymbolFileSourceEntry {
	uint32_t _index;
	uint32_t _data_offset;
};

struct MonoSymbolFileMethodEntry {
	uint32_t _token;
	uint32_t _data_offset;
	uint32_t _line_number_table;
};

struct MonoSymbolFileMethodAddress {
	uint32_t size;
	const uint8_t *start_address;
	const uint8_t *end_address;
	const uint8_t *method_start_address;
	const uint8_t *method_end_address;
	const uint8_t *wrapper_address;
	uint32_t has_this;
	uint32_t num_params;
	uint32_t variable_table_offset;
	uint32_t type_table_offset;
	uint32_t num_line_numbers;
	uint32_t line_number_offset;
	uint8_t data [MONO_ZERO_LEN_ARRAY];
};

#define MONO_SYMBOL_FILE_MAJOR_VERSION		50
#define MONO_SYMBOL_FILE_MINOR_VERSION		0
#define MONO_SYMBOL_FILE_MAGIC			0x45e82623fd7fa614ULL

MONO_BEGIN_DECLS

MONO_API MonoSymbolFile *
mono_debug_open_mono_symbols       (MonoDebugHandle          *handle,
				    const uint8_t            *raw_contents,
				    int                       size,
				    mono_bool                 in_the_debugger);

MONO_API void
mono_debug_close_mono_symbol_file  (MonoSymbolFile           *symfile);

MONO_API mono_bool
mono_debug_symfile_is_loaded       (MonoSymbolFile           *symfile);

MONO_API MonoDebugSourceLocation *
mono_debug_symfile_lookup_location (MonoDebugMethodInfo      *minfo,
				    uint32_t                  offset);

MONO_API void
mono_debug_symfile_free_location   (MonoDebugSourceLocation  *location);

MONO_API MonoDebugMethodInfo *
mono_debug_symfile_lookup_method   (MonoDebugHandle          *handle,
				    MonoMethod               *method);

MONO_API MonoDebugLocalsInfo*
mono_debug_symfile_lookup_locals (MonoDebugMethodInfo *minfo);

void
mono_debug_symfile_get_seq_points (MonoDebugMethodInfo *minfo, char **source_file, GPtrArray **source_file_list, int **source_files, MonoSymSeqPoint **seq_points, int *n_seq_points);

MONO_END_DECLS

#endif /* __MONO_SYMFILE_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/domain-internals.h`:

```h
/**
 * \file
 * Appdomain-related internal data structures and functions.
 * Copyright 2012 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_DOMAIN_INTERNALS_H__
#define __MONO_METADATA_DOMAIN_INTERNALS_H__

#include <mono/utils/mono-forward-internal.h>
#include <mono/metadata/object-forward.h>
#include <mono/metadata/appdomain.h>
#include <mono/metadata/mempool.h>
#include <mono/metadata/lock-tracer.h>
#include <mono/utils/mono-codeman.h>
#include <mono/metadata/mono-hash.h>
#include <mono/metadata/mono-conc-hash.h>
#include <mono/utils/mono-compiler.h>
#include <mono/utils/mono-internal-hash.h>
#include <mono/metadata/loader-internals.h>
#include <mono/metadata/mempool-internals.h>
#include <mono/metadata/handle-decl.h>

/* Mono appdomain support is deeply itegrated in the runtime, as a result, even
 * though .NET Standard does not include System.AppDomain in
 * System.Private.CoreLib, we still depend on having an appdomain class.
 * So we move it to Mono.MonoDomain
 *
 */
#ifndef ENABLE_NETCORE
#define MONO_APPDOMAIN_CLASS_NAME_SPACE "System"
#define MONO_APPDOMAIN_CLASS_NAME "AppDomain"
#define MONO_APPDOMAIN_SETUP_CLASS_NAME_SPACE "System"
#define MONO_APPDOMAIN_SETUP_CLASS_NAME "AppDomainSetup"
#else
#define MONO_APPDOMAIN_CLASS_NAME_SPACE "Mono"
#define MONO_APPDOMAIN_CLASS_NAME "MonoDomain"
#define MONO_APPDOMAIN_SETUP_CLASS_NAME_SPACE "Mono"
#define MONO_APPDOMAIN_SETUP_CLASS_NAME "MonoDomainSetup"
#endif

/*
 * If this is set, the memory belonging to appdomains is not freed when a domain is
 * unloaded, and assemblies loaded by the appdomain are not unloaded either. This
 * allows us to use typed gc in non-default appdomains too, leading to increased
 * performance.
 */ 
extern gboolean mono_dont_free_domains;

/* This is a copy of System.AppDomainSetup */
typedef struct {
	MonoObject object;
	MonoString *application_base;
	MonoString *application_name;
	MonoString *cache_path;
	MonoString *configuration_file;
	MonoString *dynamic_base;
	MonoString *license_file;
	MonoString *private_bin_path;
	MonoString *private_bin_path_probe;
	MonoString *shadow_copy_directories;
	MonoString *shadow_copy_files;
	MonoBoolean publisher_policy;
	MonoBoolean path_changed;
	int loader_optimization;
	MonoBoolean disallow_binding_redirects;
	MonoBoolean disallow_code_downloads;
	MonoObject *activation_arguments; /* it is System.Object in 1.x, ActivationArguments in 2.0 */
	MonoObject *domain_initializer;
	MonoObject *application_trust; /* it is System.Object in 1.x, ApplicationTrust in 2.0 */
	MonoArray *domain_initializer_args;
	MonoBoolean disallow_appbase_probe;
	MonoArray *configuration_bytes;
	MonoArray *serialized_non_primitives;
} MonoAppDomainSetup;

typedef struct _MonoJitInfoTable MonoJitInfoTable;
typedef struct _MonoJitInfoTableChunk MonoJitInfoTableChunk;

#define MONO_JIT_INFO_TABLE_CHUNK_SIZE		64

struct _MonoJitInfoTableChunk
{
	int		       refcount;
	volatile int           num_elements;
	volatile gint8        *last_code_end;
	MonoJitInfo *next_tombstone;
	MonoJitInfo * volatile data [MONO_JIT_INFO_TABLE_CHUNK_SIZE];
};

struct _MonoJitInfoTable
{
	MonoDomain	       *domain;
	int			num_chunks;
	int			num_valid;
	MonoJitInfoTableChunk  *chunks [MONO_ZERO_LEN_ARRAY];
};

#define MONO_SIZEOF_JIT_INFO_TABLE (sizeof (struct _MonoJitInfoTable) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)

typedef GArray MonoAotModuleInfoTable;

typedef struct {
	guint32  flags;
	gint32   exvar_offset;
	gpointer try_start;
	gpointer try_end;
	gpointer handler_start;
	/*
	 * For LLVM compiled code, this is the index of the il clause
	 * associated with this handler.
	 */
	int clause_index;
	uint32_t try_offset;
	uint32_t try_len;
	uint32_t handler_offset;
	uint32_t handler_len;
	union {
		MonoClass *catch_class;
		gpointer filter;
		gpointer handler_end;
	} data;
} MonoJitExceptionInfo;

/*
 * Contains information about the type arguments for generic shared methods.
 */
typedef struct {
	gboolean is_gsharedvt;
} MonoGenericSharingContext;

/* Simplified DWARF location list entry */
typedef struct {
	/* Whenever the value is in a register */
	gboolean is_reg;
	/*
	 * If is_reg is TRUE, the register which contains the value. Otherwise
	 * the base register.
	 */
	int reg;
	/*
	 * If is_reg is FALSE, the offset of the stack location relative to 'reg'.
	 * Otherwise, 0.
	 */
	int offset;
	/*
	 * Offsets of the PC interval where the value is in this location.
	 */
	int from, to;
} MonoDwarfLocListEntry;

typedef struct
{
	MonoGenericSharingContext *generic_sharing_context;
	int nlocs;
	MonoDwarfLocListEntry *locations;
	gint32 this_offset;
	guint8 this_reg;
	gboolean has_this:1;
	gboolean this_in_reg:1;
} MonoGenericJitInfo;

/*
A try block hole is used to represent a non-contiguous part of
of a segment of native code protected by a given .try block.
Usually, a try block is defined as a contiguous segment of code.
But in some cases it's needed to have some parts of it to not be protected.
For example, given "try {} finally {}", the code in the .try block to call
the finally part looks like:

try {
    ...
	call finally_block
	adjust stack
	jump outside try block
	...
} finally {
	...
}

The instructions between the call and the jump should not be under the try block since they happen
after the finally block executes, which means if an async exceptions happens at that point we would
execute the finally clause twice. So, to avoid this, we introduce a hole in the try block to signal
that those instructions are not protected.
*/
typedef struct
{
	guint32 offset;
	guint16 clause;
	guint16 length;
} MonoTryBlockHoleJitInfo;

typedef struct
{
	guint16 num_holes;
	MonoTryBlockHoleJitInfo holes [MONO_ZERO_LEN_ARRAY];
} MonoTryBlockHoleTableJitInfo;

typedef struct
{
	guint32 stack_size;
	guint32 epilog_size;
} MonoArchEHJitInfo;

typedef struct {
	/* Relative to code_start */
	int thunks_offset;
	int thunks_size;
} MonoThunkJitInfo;

typedef struct {
	guint8 *unw_info;
	int unw_info_len;
} MonoUnwindJitInfo;

typedef enum {
	JIT_INFO_NONE = 0,
	JIT_INFO_HAS_GENERIC_JIT_INFO = (1 << 0),
	JIT_INFO_HAS_TRY_BLOCK_HOLES = (1 << 1),
	JIT_INFO_HAS_ARCH_EH_INFO = (1 << 2),
	JIT_INFO_HAS_THUNK_INFO = (1 << 3),
	/*
	 * If this is set, the unwind info is stored in the structure, instead of being pointed to by the
	 * 'unwind_info' field.
	 */
	JIT_INFO_HAS_UNWIND_INFO = (1 << 4)
} MonoJitInfoFlags;

G_ENUM_FUNCTIONS (MonoJitInfoFlags)

struct _MonoJitInfo {
	/* NOTE: These first two elements (method and
	   next_jit_code_hash) must be in the same order and at the
	   same offset as in RuntimeMethod, because of the jit_code_hash
	   internal hash table in MonoDomain. */
	union {
		MonoMethod *method;
		MonoImage *image;
		MonoAotModule *aot_info;
		MonoTrampInfo *tramp_info;
	} d;
	union {
		MonoJitInfo *next_jit_code_hash;
		MonoJitInfo *next_tombstone;
	} n;
	gpointer    code_start;
	guint32     unwind_info;
	int         code_size;
	guint32     num_clauses:15;
	/* Whenever the code is domain neutral or 'shared' */
	gboolean    domain_neutral:1;
	gboolean    has_generic_jit_info:1;
	gboolean    has_try_block_holes:1;
	gboolean    has_arch_eh_info:1;
	gboolean    has_thunk_info:1;
	gboolean    has_unwind_info:1;
	gboolean    from_aot:1;
	gboolean    from_llvm:1;
	gboolean    dbg_attrs_inited:1;
	gboolean    dbg_hidden:1;
	/* Whenever this jit info was loaded in async context */
	gboolean    async:1;
	gboolean    dbg_step_through:1;
	gboolean    dbg_non_user_code:1;
	/*
	 * Whenever this jit info refers to a trampoline.
	 * d.tramp_info contains additional data in this case.
	 */
	gboolean    is_trampoline:1;
	/* Whenever this jit info refers to an interpreter method */
	gboolean    is_interp:1;

	/* FIXME: Embed this after the structure later*/
	gpointer    gc_info; /* Currently only used by SGen */

	gpointer    seq_points;
	
	MonoJitExceptionInfo clauses [MONO_ZERO_LEN_ARRAY];
	/* There is an optional MonoGenericJitInfo after the clauses */
	/* There is an optional MonoTryBlockHoleTableJitInfo after MonoGenericJitInfo clauses*/
	/* There is an optional MonoArchEHJitInfo after MonoTryBlockHoleTableJitInfo */
	/* There is an optional MonoThunkJitInfo after MonoArchEHJitInfo */
};

#define MONO_SIZEOF_JIT_INFO (offsetof (struct _MonoJitInfo, clauses))

typedef struct {
	gpointer *static_data; /* Used to free the static data without going through the MonoAppContext object itself. */
	uint32_t gc_handle;
} ContextStaticData;

struct _MonoAppContext {
	MonoObject obj;
	gint32 domain_id;
	gint32 context_id;
	gpointer *static_data;
	ContextStaticData *data;
};

/* Lock-free allocator */
typedef struct {
	guint8 *mem;
	gpointer prev;
	int size, pos;
} LockFreeMempoolChunk;

typedef struct {
	LockFreeMempoolChunk *current, *chunks;
} LockFreeMempool;

/*
 * We have two unloading states because the domain
 * must remain fully functional while AppDomain::DomainUnload is
 * processed.
 * After that unloading began and all domain facilities are teared down
 * such as execution of new threadpool jobs.  
 */
typedef enum {
	MONO_APPDOMAIN_CREATED,
	MONO_APPDOMAIN_UNLOADING_START,
	MONO_APPDOMAIN_UNLOADING,
	MONO_APPDOMAIN_UNLOADED
} MonoAppDomainState;

typedef struct _MonoThunkFreeList {
	guint32 size;
	int length;		/* only valid for the wait list */
	struct _MonoThunkFreeList *next;
} MonoThunkFreeList;

typedef struct _MonoJitCodeHash MonoJitCodeHash;

struct _MonoDomain {
	/*
	 * This lock must never be taken before the loader lock,
	 * i.e. if both are taken by the same thread, the loader lock
	 * must taken first.
	 */
	MonoCoopMutex    lock;
	MonoMemPool        *mp;
	MonoCodeManager    *code_mp;
	/*
	 * keep all the managed objects close to each other for the precise GC
	 * For the Boehm GC we additionally keep close also other GC-tracked pointers.
	 */
#define MONO_DOMAIN_FIRST_OBJECT setup
	MonoAppDomainSetup *setup;
	MonoAppDomain      *domain;
	MonoAppContext     *default_context;
	MonoException      *out_of_memory_ex;
	MonoException      *null_reference_ex;
	MonoException      *stack_overflow_ex;
	/* typeof (void) */
	MonoObject         *typeof_void;
	/* Ephemeron Tombstone*/
	MonoObject         *ephemeron_tombstone;
	/* new MonoType [0] */
	MonoArray          *empty_types;
	MonoString         *empty_string;
	/* 
	 * The fields between FIRST_GC_TRACKED and LAST_GC_TRACKED are roots, but
	 * not object references.
	 */
#define MONO_DOMAIN_FIRST_GC_TRACKED env
	MonoGHashTable     *env;
	MonoGHashTable     *ldstr_table;
	/* hashtables for Reflection handles */
	MonoGHashTable     *type_hash;
	MonoConcGHashTable     *refobject_hash;
	/* maps class -> type initialization exception object */
	MonoGHashTable    *type_init_exception_hash;
	/* maps delegate trampoline addr -> delegate object */
	MonoGHashTable     *delegate_hash_table;
#define MONO_DOMAIN_LAST_GC_TRACKED delegate_hash_table
	guint32            state;
	/* Needed by Thread:GetDomainID() */
	gint32             domain_id;
	gint32             shadow_serial;
	/*
	 * For framework Mono, this is every assembly loaded in this
	 * domain. For netcore, this is every assembly loaded in every ALC in
	 * this domain.  In netcore, the thread that adds an assembly to its
	 * MonoAssemblyLoadContext:loaded_assemblies should also add it to this
	 * list.
	 */
	GSList             *domain_assemblies;
	MonoAssembly       *entry_assembly;
	char               *friendly_name;
	GPtrArray          *class_vtable_array;
	/* maps remote class key -> MonoRemoteClass */
	GHashTable         *proxy_vtable_hash;
	/* Protected by 'jit_code_hash_lock' */
	MonoInternalHashTable jit_code_hash;
	mono_mutex_t    jit_code_hash_lock;
	int		    num_jit_info_table_duplicates;
	MonoJitInfoTable * 
	  volatile          jit_info_table;
	/*
	 * Contains information about AOT loaded code.
	 * Only used in the root domain.
	 */
	MonoJitInfoTable *
	  volatile          aot_modules;
	GSList		   *jit_info_free_queue;
	/* Used when loading assemblies */
	gchar **search_path;
	gchar *private_bin_path;
	LockFreeMempool *lock_free_mp;
	
	/* Used by remoting proxies */
	MonoMethod         *create_proxy_for_type_method;
	MonoMethod         *private_invoke_method;
	/* Used to store offsets of thread and context static fields */
	GHashTable         *special_static_fields;
	/* 
	 * This must be a GHashTable, since these objects can't be finalized
	 * if the hashtable contains a GC visible reference to them.
	 */
	GHashTable         *finalizable_objects_hash;

	/* Protects the three hashes above */
	mono_mutex_t   finalizable_objects_hash_lock;
	/* Used when accessing 'domain_assemblies' */
	mono_mutex_t    assemblies_lock;

	GHashTable	   *generic_virtual_cases;

	/* Information maintained by the JIT engine */
	gpointer runtime_info;

	/* Information maintained by mono-debug.c */
	gpointer debug_info;

	/* Contains the compiled runtime invoke wrapper used by finalizers */
	gpointer            finalize_runtime_invoke;

	/* Contains the compiled runtime invoke wrapper used by async resylt creation to capture thread context*/
	gpointer            capture_context_runtime_invoke;

	/* Contains the compiled method used by async resylt creation to capture thread context*/
	gpointer            capture_context_method;

	/* Assembly bindings, the per-domain part */
	GSList *assembly_bindings;
	gboolean assembly_bindings_parsed;

	/* Used by socket-io.c */
	/* These are domain specific, since the assembly can be unloaded */
	MonoImage *socket_assembly;
	MonoClass *sockaddr_class;
	MonoClassField *sockaddr_data_field;
	MonoClassField *sockaddr_data_length_field;

	/* Cache function pointers for architectures  */
	/* that require wrappers */
	GHashTable *ftnptrs_hash;

	/* Maps MonoMethod* to weak links to DynamicMethod objects */
	GHashTable *method_to_dyn_method;

	/* <ThrowUnobservedTaskExceptions /> support */
	gboolean throw_unobserved_task_exceptions;

	guint32 execution_context_field_offset;

#ifdef ENABLE_NETCORE
	GSList *alcs;
	MonoAssemblyLoadContext *default_alc;
	MonoCoopMutex alcs_lock; /* Used when accessing 'alcs' */
#endif
};

typedef struct  {
	guint16 major, minor, build, revision;
} AssemblyVersionSet;

/* MonoRuntimeInfo: Contains information about versions supported by this runtime */
typedef struct  {
	const char runtime_version [12];
	const char framework_version [4];
	const AssemblyVersionSet version_sets [5];
} MonoRuntimeInfo;

#define mono_domain_assemblies_lock(domain) mono_locks_os_acquire(&(domain)->assemblies_lock, DomainAssembliesLock)
#define mono_domain_assemblies_unlock(domain) mono_locks_os_release(&(domain)->assemblies_lock, DomainAssembliesLock)
#define mono_domain_jit_code_hash_lock(domain) mono_locks_os_acquire(&(domain)->jit_code_hash_lock, DomainJitCodeHashLock)
#define mono_domain_jit_code_hash_unlock(domain) mono_locks_os_release(&(domain)->jit_code_hash_lock, DomainJitCodeHashLock)

typedef MonoDomain* (*MonoLoadFunc) (const char *filename, const char *runtime_version);

MONO_LLVM_INTERNAL void mono_domain_lock (MonoDomain *domain);
MONO_LLVM_INTERNAL void mono_domain_unlock (MonoDomain *domain);

void
mono_install_runtime_load  (MonoLoadFunc func);

MonoDomain*
mono_runtime_load (const char *filename, const char *runtime_version);

typedef void (*MonoCreateDomainFunc) (MonoDomain *domain);

void
mono_install_create_domain_hook (MonoCreateDomainFunc func);

typedef void (*MonoFreeDomainFunc) (MonoDomain *domain);

void
mono_install_free_domain_hook (MonoFreeDomainFunc func);

void
mono_runtime_quit_internal (void);

void 
mono_cleanup (void);

void
mono_close_exe_image (void);

int
mono_jit_info_size (MonoJitInfoFlags flags, int num_clauses, int num_holes);

void
mono_jit_info_init (MonoJitInfo *ji, MonoMethod *method, guint8 *code, int code_size,
					MonoJitInfoFlags flags, int num_clauses, int num_holes);

MonoJitInfoTable *
mono_jit_info_table_new (MonoDomain *domain);

void
mono_jit_info_table_free (MonoJitInfoTable *table);

void
mono_jit_info_table_add    (MonoDomain *domain, MonoJitInfo *ji);

void
mono_jit_info_table_remove (MonoDomain *domain, MonoJitInfo *ji);

void
mono_jit_info_add_aot_module (MonoImage *image, gpointer start, gpointer end);

MonoGenericJitInfo*
mono_jit_info_get_generic_jit_info (MonoJitInfo *ji);

MonoGenericSharingContext*
mono_jit_info_get_generic_sharing_context (MonoJitInfo *ji);

void
mono_jit_info_set_generic_sharing_context (MonoJitInfo *ji, MonoGenericSharingContext *gsctx);

char *
mono_make_shadow_copy (const char *filename, MonoError *error);

gboolean
mono_is_shadow_copy_enabled (MonoDomain *domain, const gchar *dir_name);

gpointer
mono_domain_alloc  (MonoDomain *domain, guint size);

#define mono_domain_alloc(domain, size) (g_cast (mono_domain_alloc ((domain), (size))))

gpointer
mono_domain_alloc0 (MonoDomain *domain, guint size);

#define mono_domain_alloc0(domain, size) (g_cast (mono_domain_alloc0 ((domain), (size))))

gpointer
mono_domain_alloc0_lock_free (MonoDomain *domain, guint size);

#define mono_domain_alloc0_lock_free(domain, size) (g_cast (mono_domain_alloc0_lock_free ((domain), (size))))

MONO_LLVM_INTERNAL void*
mono_domain_code_reserve (MonoDomain *domain, int size);

#define mono_domain_code_reserve(domain, size) (g_cast (mono_domain_code_reserve ((domain), (size))))

void*
mono_domain_code_reserve_align (MonoDomain *domain, int size, int alignment);

#define mono_domain_code_reserve_align(domain, size, align) (g_cast (mono_domain_code_reserve_align ((domain), (size), (align))))

void
mono_domain_code_commit (MonoDomain *domain, void *data, int size, int newsize);

void
mono_domain_code_foreach (MonoDomain *domain, MonoCodeManagerFunc func, void *user_data);

void
mono_domain_unset (void);

void
mono_domain_set_internal_with_options (MonoDomain *domain, gboolean migrate_exception);

gboolean
mono_domain_set_config_checked (MonoDomain *domain, const char *base_dir, const char *config_file_name, MonoError *error);

MonoTryBlockHoleTableJitInfo*
mono_jit_info_get_try_block_hole_table_info (MonoJitInfo *ji);

MonoArchEHJitInfo*
mono_jit_info_get_arch_eh_info (MonoJitInfo *ji);

MonoThunkJitInfo*
mono_jit_info_get_thunk_info (MonoJitInfo *ji);

MonoUnwindJitInfo*
mono_jit_info_get_unwind_info (MonoJitInfo *ji);

/* 
 * Installs a new function which is used to return a MonoJitInfo for a method inside
 * an AOT module.
 */
typedef MonoJitInfo *(*MonoJitInfoFindInAot)         (MonoDomain *domain, MonoImage *image, gpointer addr);
void          mono_install_jit_info_find_in_aot (MonoJitInfoFindInAot func);

void
mono_jit_code_hash_init (MonoInternalHashTable *jit_code_hash);

MonoAssembly *
mono_assembly_load_corlib (const MonoRuntimeInfo *runtime, MonoImageOpenStatus *status);

const MonoRuntimeInfo*
mono_get_runtime_info (void);

void
mono_runtime_set_no_exec (gboolean val);

gboolean
mono_runtime_get_no_exec (void);

void
mono_domain_parse_assembly_bindings (MonoDomain *domain, int amajor, int aminor, gchar *domain_config_file_name);

gboolean
mono_assembly_name_parse (const char *name, MonoAssemblyName *aname);

MonoAssembly *
mono_domain_assembly_open_internal (MonoDomain *domain, MonoAssemblyLoadContext *alc, const char *name);

MonoImage *mono_assembly_open_from_bundle (MonoAssemblyLoadContext *alc,
					   const char *filename,
					   MonoImageOpenStatus *status,
					   gboolean refonly);

MonoAssembly *
mono_try_assembly_resolve (MonoAssemblyLoadContext *alc, const char *fname, MonoAssembly *requesting, gboolean refonly, MonoError *error);

MonoAssembly *
mono_domain_assembly_postload_search (MonoAssemblyLoadContext *alc, MonoAssembly *requesting, MonoAssemblyName *aname, gboolean refonly, gboolean postload, gpointer user_data, MonoError *error);

void mono_domain_set_options_from_config (MonoDomain *domain);

int mono_framework_version (void);

void mono_reflection_cleanup_domain (MonoDomain *domain);

void mono_assembly_cleanup_domain_bindings (guint32 domain_id);

MonoJitInfo* mono_jit_info_table_find_internal (MonoDomain *domain, gpointer addr, gboolean try_aot, gboolean allow_trampolines);

void mono_enable_debug_domain_unload (gboolean enable);

void
mono_runtime_init_checked (MonoDomain *domain, MonoThreadStartCB start_cb, MonoThreadAttachCB attach_cb, MonoError *error);

void
mono_context_init_checked (MonoDomain *domain, MonoError *error);

gboolean
mono_assembly_has_reference_assembly_attribute (MonoAssembly *assembly, MonoError *error);

GPtrArray*
mono_domain_get_assemblies (MonoDomain *domain, gboolean refonly);

void
mono_runtime_register_appctx_properties (int nprops, const char **keys,  const char **values);

void
mono_runtime_install_appctx_properties (void);

gboolean 
mono_domain_set_fast (MonoDomain *domain, gboolean force);

MonoAssemblyLoadContext *
mono_domain_default_alc (MonoDomain *domain);

#ifdef ENABLE_NETCORE
MonoAssemblyLoadContext *
mono_domain_create_individual_alc (MonoDomain *domain, uint32_t this_gchandle, gboolean collectible, MonoError *error);
#endif

static inline
MonoAssemblyLoadContext *
mono_domain_ambient_alc (MonoDomain *domain)
{
	/*
	 * FIXME: All the callers of mono_domain_ambient_alc should get an ALC
	 * passed to them from their callers.
	 */
	return mono_domain_default_alc (domain);
}

#endif /* __MONO_METADATA_DOMAIN_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/dynamic-image-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_DYNAMIC_IMAGE_INTERNALS_H__
#define __MONO_METADATA_DYNAMIC_IMAGE_INTERNALS_H__

#include <mono/metadata/object.h>
#include <mono/metadata/metadata-internals.h>
#include <mono/metadata/object-internals.h>

typedef struct {
	guint32 import_lookup_table;
	guint32 timestamp;
	guint32 forwarder;
	guint32 name_rva;
	guint32 import_address_table_rva;
} MonoIDT;

typedef struct {
	guint32 name_rva;
	guint32 flags;
} MonoILT;


typedef enum {
	MONO_DYN_IMAGE_TOK_NEW, /* assert if same token is registered already */
	MONO_DYN_IMAGE_TOK_SAME_OK, /* allow collision only with the same object */
	MONO_DYN_IMAGE_TOK_REPLACE, /* keep the new object, always */
} MonoDynamicImageTokCollision;

void
mono_dynamic_images_init (void);

void
mono_dynamic_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObjectHandle obj, int tok_collision);

gboolean
mono_dynamic_image_is_valid_token (MonoDynamicImage *image, guint32 token);

MonoObjectHandle
mono_dynamic_image_get_registered_token (MonoDynamicImage *dynimage, guint32 token, MonoError *error);

MonoDynamicImage*
mono_dynamic_image_create (MonoDynamicAssembly *assembly, char *assembly_name, char *module_name);

guint32
mono_dynamic_image_add_to_blob_cached (MonoDynamicImage *assembly, gconstpointer b1, int s1, gconstpointer b2, int s2);

void
mono_dynimage_alloc_table (MonoDynamicTable *table, guint nrows);

#endif  /* __MONO_METADATA_DYNAMIC_IMAGE_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/dynamic-stream-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_DYNAMIC_STREAM_INTERNALS_H__
#define __MONO_METADATA_DYNAMIC_STREAM_INTERNALS_H__

#include <mono/metadata/object.h>
#include <mono/metadata/metadata-internals.h>

void
mono_dynstream_init (MonoDynamicStream *stream);

guint32
mono_dynstream_insert_string (MonoDynamicStream *sh, const char *str);

guint32
mono_dynstream_insert_mstring (MonoDynamicStream *sh, MonoString *str, MonoError *error);

guint32
mono_dynstream_add_data (MonoDynamicStream *stream, gconstpointer data, guint32 len);

guint32
mono_dynstream_add_zero (MonoDynamicStream *stream, guint32 len);

void
mono_dynstream_data_align (MonoDynamicStream *stream);

#endif  /* __MONO_METADATA_DYNAMIC_STREAM_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/environment.h`:

```h
/**
 * \file
 * System.Environment support internal calls
 *
 * Author:
 *	Dick Porter (dick@ximian.com)
 *
 * (C) 2002 Ximian, Inc
 */

#ifndef _MONO_METADATA_ENVIRONMENT_H_
#define _MONO_METADATA_ENVIRONMENT_H_

#include <mono/utils/mono-publib.h>

MONO_BEGIN_DECLS

MONO_API int32_t mono_environment_exitcode_get (void);
MONO_API void mono_environment_exitcode_set (int32_t value);

MONO_END_DECLS

#endif /* _MONO_METADATA_ENVIRONMENT_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/exception-internals.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_EXCEPTION_INTERNALS_H_
#define _MONO_METADATA_EXCEPTION_INTERNALS_H_

#include <glib.h>

#include <mono/metadata/object.h>
#include <mono/metadata/handle.h>
#include <mono/utils/mono-error.h>

MonoExceptionHandle
mono_get_exception_type_initialization_handle (const gchar *type_name, MonoExceptionHandle inner, MonoError *error);

MonoExceptionHandle
mono_get_exception_reflection_type_load_checked (MonoArrayHandle types, MonoArrayHandle exceptions, MonoError *error);

MonoExceptionHandle
mono_get_exception_runtime_wrapped_handle (MonoObjectHandle wrapped_exception, MonoError *error);

MonoExceptionHandle
mono_exception_from_name_two_strings_checked (MonoImage *image, const char *name_space,
					      const char *name, MonoStringHandle a1, MonoStringHandle a2,
					      MonoError *error);

MonoExceptionHandle
mono_exception_from_token_two_strings_checked (MonoImage *image, uint32_t token,
					       MonoStringHandle a1, MonoStringHandle a2,
					       MonoError *error);

typedef int (*MonoGetSeqPointFunc) (MonoDomain *domain, MonoMethod *method, gint32 native_offset);

void
mono_install_get_seq_point (MonoGetSeqPointFunc func);

void
mono_error_set_method_missing (MonoError *error, MonoClass *klass, const char *method_name, MonoMethodSignature *sig, const char *reason, ...) MONO_ATTR_FORMAT_PRINTF(5,6);

void
mono_error_set_field_missing (MonoError *oerror, MonoClass *klass, const char *field_name, MonoType *sig, const char *reason, ...) MONO_ATTR_FORMAT_PRINTF(5,6);

void
mono_error_set_bad_image (MonoError *error, MonoImage *image, const char *msg_format, ...) MONO_ATTR_FORMAT_PRINTF(3,4);

void
mono_error_set_bad_image_by_name (MonoError *error, const char *image_name, const char *msg_format, ...) MONO_ATTR_FORMAT_PRINTF(3,4);

void
mono_error_set_file_not_found (MonoError *oerror, const char *file_name, const char *msg_format, ...) MONO_ATTR_FORMAT_PRINTF(3,4);

void
mono_error_set_simple_file_not_found (MonoError *oerror, const char *assembly_name, gboolean refection_only);

MonoExceptionHandle
mono_corlib_exception_new_with_args (const char *name_space, const char *name, const char *arg_0, const char *arg_1, MonoError *error);

MonoExceptionHandle
mono_exception_new_by_name_msg (MonoImage *image, const char *name_space,
			      const char *name, const char *msg, MonoError *error);

MonoExceptionHandle
mono_exception_new_argument (const char *arg, const char *msg, MonoError *error);

MonoExceptionHandle
mono_exception_new_argument_null (const char *arg, MonoError *error);

MonoExceptionHandle
mono_exception_new_argument_out_of_range(const char *arg, const char *msg, MonoError *error);

MonoExceptionHandle
mono_exception_new_thread_interrupted (MonoError *error);

MonoExceptionHandle
mono_exception_new_thread_abort (MonoError *error);

MonoExceptionHandle
mono_exception_new_serialization (const char *msg, MonoError *error);

MonoExceptionHandle
mono_exception_new_invalid_operation (const char *msg, MonoError *error);

MonoExceptionHandle
mono_error_convert_to_exception_handle (MonoError *error);

MonoExceptionHandle
mono_get_exception_out_of_memory_handle (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/exception.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_EXCEPTION_H_
#define _MONO_METADATA_EXCEPTION_H_

#include <mono/metadata/object-forward.h>
#include <mono/metadata/object.h>
#include <mono/metadata/image.h>

MONO_BEGIN_DECLS

MONO_API MonoException *
mono_exception_from_name               (MonoImage *image, 
					const char* name_space, 
					const char *name);

MONO_API MonoException *
mono_exception_from_token              (MonoImage *image, uint32_t token);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_exception_from_name_two_strings (MonoImage *image, const char *name_space,
				      const char *name, MonoString *a1, MonoString *a2);

MONO_API MonoException *
mono_exception_from_name_msg	       (MonoImage *image, const char *name_space,
					const char *name, const char *msg);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_exception_from_token_two_strings (MonoImage *image, uint32_t token,
						   MonoString *a1, MonoString *a2);

MONO_API MonoException *
mono_exception_from_name_domain        (MonoDomain *domain, MonoImage *image, 
					const char* name_space, 
					const char *name);

MONO_API MonoException *
mono_get_exception_divide_by_zero      (void);

MONO_API MonoException *
mono_get_exception_security            (void);

MONO_API MonoException *
mono_get_exception_arithmetic          (void);

MONO_API MonoException *
mono_get_exception_overflow            (void);

MONO_API MonoException *
mono_get_exception_null_reference      (void);

MONO_API MonoException *
mono_get_exception_execution_engine    (const char *msg);

MONO_API MonoException *
mono_get_exception_thread_abort        (void);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_thread_state        (const char *msg);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_thread_interrupted  (void);

MONO_API MonoException *
mono_get_exception_serialization       (const char *msg);

MONO_API MonoException *
mono_get_exception_invalid_cast        (void);

MONO_API MonoException *
mono_get_exception_invalid_operation (const char *msg);

MONO_API MonoException *
mono_get_exception_index_out_of_range  (void);

MONO_API MonoException *
mono_get_exception_array_type_mismatch (void);

MONO_API MonoException *
mono_get_exception_type_load           (MonoString *class_name, char *assembly_name);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_missing_method      (const char *class_name, const char *member_name);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_missing_field       (const char *class_name, const char *member_name);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_not_implemented     (const char *msg);

MONO_API MonoException *
mono_get_exception_not_supported       (const char *msg);

MONO_API MONO_RT_EXTERNAL_ONLY MonoException*
mono_get_exception_argument_null       (const char *arg);

MONO_API MonoException *
mono_get_exception_argument            (const char *arg, const char *msg);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_argument_out_of_range (const char *arg);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_io                    (const char *msg);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_file_not_found        (MonoString *fname);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_file_not_found2       (const char *msg, MonoString *fname);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_type_initialization (const char *type_name, MonoException *inner);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_synchronization_lock (const char *msg);

MONO_API MonoException *
mono_get_exception_cannot_unload_appdomain (const char *msg);

MONO_API MonoException *
mono_get_exception_appdomain_unloaded (void);

MONO_API MonoException *
mono_get_exception_bad_image_format (const char *msg);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_bad_image_format2 (const char *msg, MonoString *fname);

MONO_API MonoException *
mono_get_exception_stack_overflow (void);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_out_of_memory (void);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_field_access (void);

MONO_API MonoException *
mono_get_exception_method_access (void);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_reflection_type_load (MonoArray *types, MonoArray *exceptions);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoException *
mono_get_exception_runtime_wrapped (MonoObject *wrapped_exception);

/* Installs a function which is called when the runtime encounters an unhandled exception.
 * This hook isn't expected to return.
 * If no hook has been installed, the runtime will print a message before aborting.
 */
typedef void  (*MonoUnhandledExceptionFunc)         (MonoObject *exc, void *user_data);
MONO_API void mono_install_unhandled_exception_hook (MonoUnhandledExceptionFunc func, void *user_data);
void          mono_invoke_unhandled_exception_hook  (MonoObject *exc);

MONO_END_DECLS

#endif /* _MONO_METADATA_EXCEPTION_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/external-only.h`:

```h
/**
 * \file
 *   Shorthand and markers for functions only used by embedders.
 * MONO_ENTER_GC_UNSAFE is also a good indication of external_only.
 *
 * Author:
 *   Jay Krell (jaykrell@microsoft.com)
 *
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef MONO_EXTERNAL_ONLY

#define MONO_EXTERNAL_ONLY_GC_UNSAFE(t, expr) \
	t result; 		\
	MONO_ENTER_GC_UNSAFE; 	\
	result = expr;		\
	MONO_EXIT_GC_UNSAFE;	\
	return result;

#define MONO_EXTERNAL_ONLY_GC_UNSAFE_VOID(expr) \
	MONO_ENTER_GC_UNSAFE; 	\
	expr;			\
	MONO_EXIT_GC_UNSAFE;	\

#define MONO_EXTERNAL_ONLY(t, expr) return expr;
#define MONO_EXTERNAL_ONLY_VOID(expr) expr;

#endif /* MONO_EXTERNAL_ONLY */

```

`Hazel/vendor/mono/include/mono/metadata/fdhandle.h`:

```h

#ifndef __MONO_METADATA_FDHANDLE_H__
#define __MONO_METADATA_FDHANDLE_H__

#include <config.h>
#include <glib.h>

#include "utils/refcount.h"

typedef enum {
	MONO_FDTYPE_FILE,
	MONO_FDTYPE_CONSOLE,
	MONO_FDTYPE_PIPE,
	MONO_FDTYPE_SOCKET,
	MONO_FDTYPE_COUNT
} MonoFDType;

typedef struct {
	MonoRefCount ref;
	MonoFDType type;
	gint fd;
} MonoFDHandle;

typedef struct {
	void (*close) (MonoFDHandle *fdhandle);
	void (*destroy) (MonoFDHandle *fdhandle);
} MonoFDHandleCallback;

void
mono_fdhandle_register (MonoFDType type, MonoFDHandleCallback *callback);

void
mono_fdhandle_init (MonoFDHandle *fdhandle, MonoFDType type, gint fd);

void
mono_fdhandle_insert (MonoFDHandle *fdhandle);

gboolean
mono_fdhandle_try_insert (MonoFDHandle *fdhandle);

gboolean
mono_fdhandle_lookup_and_ref (gint fd, MonoFDHandle **fdhandle);

void
mono_fdhandle_unref (MonoFDHandle *fdhandle);

gboolean
mono_fdhandle_close (gint fd);

#endif /* __MONO_METADATA_FDHANDLE_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/file-mmap.h`:

```h
/**
 * \file
 * Managed mmap wrappers.
 *
 * Authors:
 *	Rodrigo Kumpera
 *
 * Copyright 2014 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_METADATA_FILE_MMAP_H_
#define _MONO_METADATA_FILE_MMAP_H_

#include <config.h>
#include <glib.h>

#include <mono/metadata/object-internals.h>
#include <mono/utils/mono-compiler.h>
#include <mono/metadata/icalls.h>

ICALL_EXPORT
void
mono_mmap_close (void *mmap_handle, MonoError *error);

// inheritability is an enum with the values 0 and 1.
ICALL_EXPORT
void
mono_mmap_configure_inheritability (void *mmap_handle, gint32 inheritability, MonoError *error);

ICALL_EXPORT
void
mono_mmap_flush (void *mmap_handle, MonoError *error);

ICALL_EXPORT
void*
mono_mmap_open_file (const gunichar2 *path, gint path_length, int mode, const gunichar2 *mapName, gint mapName_length, gint64 *capacity, int access, int options, int *win32error, MonoError *error);

ICALL_EXPORT
void*
mono_mmap_open_handle (void *handle, const gunichar2 *mapName, gint mapName_length, gint64 *capacity, int access, int options, int *win32error, MonoError *error);

ICALL_EXPORT
int
mono_mmap_map (void *handle, gint64 offset, gint64 *size, int access, void **mmap_handle, void **base_address, MonoError *error);

ICALL_EXPORT
MonoBoolean
mono_mmap_unmap (void *base_address, MonoError *error);

#endif /* _MONO_METADATA_FILE_MMAP_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/filewatcher.h`:

```h
/**
 * \file
 * File System Watcher internal calls
 *
 * Authors:
 *	Gonzalo Paniagua Javier (gonzalo@ximian.com)
 *
 * (C) 2004 Novell, Inc. (http://www.novell.com)
 */

#ifndef _MONO_METADATA_FILEWATCHER_H
#define _MONO_METADATA_FILEWATCHER_H

#include <mono/metadata/object.h>
#include "mono/utils/mono-compiler.h"
#include <glib.h>
#include <mono/metadata/icalls.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if !ENABLE_NETCORE

ICALL_EXPORT
gint ves_icall_System_IO_FSW_SupportsFSW (void);

ICALL_EXPORT
int ves_icall_System_IO_KqueueMonitor_kevent_notimeout (int *kq, gpointer changelist, int nchanges, gpointer eventlist, int nevents);

#endif

#ifdef HOST_IOS // This will obsoleted by System.Native as soon as it's ported to iOS
MONO_API char* SystemNative_RealPath(const char* path);
MONO_API void SystemNative_Sync (void);
#endif

#endif

```

`Hazel/vendor/mono/include/mono/metadata/gc-internals.h`:

```h
/**
 * \file
 * Internal GC interface
 *
 * Author: Paolo Molaro <lupus@ximian.com>
 *
 * (C) 2002 Ximian, Inc.
 * Copyright 2012 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_METADATA_GC_INTERNAL_H__
#define __MONO_METADATA_GC_INTERNAL_H__

#include <glib.h>
#include <mono/utils/gc_wrapper.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/threads-types.h>
#include <mono/sgen/gc-internal-agnostic.h>
#include <mono/metadata/icalls.h>

#define mono_domain_finalizers_lock(domain) mono_os_mutex_lock (&(domain)->finalizable_objects_hash_lock);
#define mono_domain_finalizers_unlock(domain) mono_os_mutex_unlock (&(domain)->finalizable_objects_hash_lock);

/* Register a memory area as a conservatively scanned GC root */
#define MONO_GC_REGISTER_ROOT_PINNING(x,src,key,msg) mono_gc_register_root ((char*)&(x), sizeof(x), MONO_GC_DESCRIPTOR_NULL, (src), (key), (msg))

#define MONO_GC_UNREGISTER_ROOT(x) mono_gc_deregister_root ((char*)&(x))

/*
 * Return a GC descriptor for an array containing N pointers to memory allocated
 * by mono_gc_alloc_fixed ().
 */
/* For SGEN, the result of alloc_fixed () is not GC tracked memory */
#define MONO_GC_ROOT_DESCR_FOR_FIXED(n) (mono_gc_is_moving () ? mono_gc_make_root_descr_all_refs (0) : MONO_GC_DESCRIPTOR_NULL)

/* Register a memory location holding a single object reference as a GC root */
#define MONO_GC_REGISTER_ROOT_SINGLE(x,src,key,msg) do { \
	g_assert (sizeof (x) == sizeof (MonoObject*)); \
	mono_gc_register_root ((char*)&(x), sizeof(MonoObject*), mono_gc_make_root_descr_all_refs (1), (src), (key),(msg)); \
	} while (0)

/*
 * This is used for fields which point to objects which are kept alive by other references
 * when using Boehm.
 */
#define MONO_GC_REGISTER_ROOT_IF_MOVING(x,src,key,msg) do { \
	if (mono_gc_is_moving ()) \
		MONO_GC_REGISTER_ROOT_SINGLE(x,src,key,msg);		\
} while (0)

#define MONO_GC_UNREGISTER_ROOT_IF_MOVING(x) do { \
	if (mono_gc_is_moving ()) \
		MONO_GC_UNREGISTER_ROOT (x);			\
} while (0)

/* useful until we keep track of gc-references in corlib etc. */
#define IS_GC_REFERENCE(class,t) (mono_gc_is_moving () ? FALSE : ((t)->type == MONO_TYPE_U && (class)->image == mono_defaults.corlib))

void   mono_object_register_finalizer               (MonoObject  *obj);

void
mono_object_register_finalizer_handle (MonoObjectHandle obj);

extern void mono_gc_init (void);
extern void mono_gc_base_init (void);
extern void mono_gc_cleanup (void);
extern void mono_gc_base_cleanup (void);
extern void mono_gc_init_icalls (void);

/*
 * Return whenever the current thread is registered with the GC (i.e. started
 * by the GC pthread wrappers on unix.
 */
extern gboolean mono_gc_is_gc_thread (void);

extern gboolean mono_gc_is_finalizer_internal_thread (MonoInternalThread *thread);

extern void mono_gc_set_stack_end (void *stack_end);

/* only valid after the RECLAIM_START GC event and before RECLAIM_END
 * Not exported in public headers, but can be linked to (unsupported).
 */
gboolean mono_object_is_alive (MonoObject* obj);
gboolean mono_gc_is_finalizer_thread (MonoThread *thread);

void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);

/*Ephemeron functionality. Sgen only*/
gboolean    mono_gc_ephemeron_array_add (MonoObject *obj);

/* User defined marking function */
/* It should work like this:
 * foreach (ref in GC references in the are structure pointed to by ADDR)
 *    mark_func (ref)
 */
typedef void (*MonoGCMarkFunc)     (MonoObject **addr, void *gc_data);
typedef void (*MonoGCRootMarkFunc) (void *addr, MonoGCMarkFunc mark_func, void *gc_data);

/* Create a descriptor with a user defined marking function */
MonoGCDescriptor mono_gc_make_root_descr_user (MonoGCRootMarkFunc marker);

/* Return whenever user defined marking functions are supported */
gboolean mono_gc_user_markers_supported (void);

/* desc is the result from mono_gc_make_descr*. A NULL value means
 * all the words might contain GC pointers.
 * The memory is non-moving and it will be explicitly deallocated.
 * size bytes will be available from the returned address (ie, descr
 * must not be stored in the returned memory)
 */
MonoObject* mono_gc_alloc_fixed      (size_t size, MonoGCDescriptor descr, MonoGCRootSource source, void *key, const char *msg);

// C++ callers outside of metadata (mini/tasklets.c) must use mono_gc_alloc_fixed_no_descriptor
// instead of mono_gc_alloc_fixed, or else compile twice -- boehm and sgen.
MonoObject*
mono_gc_alloc_fixed_no_descriptor (size_t size, MonoGCRootSource source, void *key, const char *msg);

void  mono_gc_free_fixed             (void* addr);

/* make sure the gchandle was allocated for an object in domain */
gboolean mono_gchandle_is_in_domain (guint32 gchandle, MonoDomain *domain);
void     mono_gchandle_free_domain  (MonoDomain *domain);

typedef void (*FinalizerThreadCallback) (gpointer user_data);

MonoObject*
mono_gc_alloc_pinned_obj (MonoVTable *vtable, size_t size);

MonoObjectHandle
mono_gc_alloc_handle_pinned_obj (MonoVTable *vtable, gsize size);

MonoObject*
mono_gc_alloc_obj (MonoVTable *vtable, size_t size);

MonoObjectHandle
mono_gc_alloc_handle_obj (MonoVTable *vtable, gsize size);

MonoArray*
mono_gc_alloc_vector (MonoVTable *vtable, size_t size, uintptr_t max_length);

MonoArrayHandle
mono_gc_alloc_handle_vector (MonoVTable *vtable, gsize size, gsize max_length);

MonoArray*
mono_gc_alloc_array (MonoVTable *vtable, size_t size, uintptr_t max_length, uintptr_t bounds_size);

MonoArrayHandle
mono_gc_alloc_handle_array (MonoVTable *vtable, gsize size, gsize max_length, gsize bounds_size);

MonoString*
mono_gc_alloc_string (MonoVTable *vtable, size_t size, gint32 len);

MonoStringHandle
mono_gc_alloc_handle_string (MonoVTable *vtable, gsize size, gint32 len);

MonoObject*
mono_gc_alloc_mature (MonoVTable *vtable, size_t size);

MonoGCDescriptor mono_gc_make_descr_for_string (gsize *bitmap, int numbits);

MonoObjectHandle
mono_gc_alloc_handle_mature (MonoVTable *vtable, gsize size);

void mono_gc_register_obj_with_weak_fields (void *obj);
void
mono_gc_register_object_with_weak_fields (MonoObjectHandle obj);

typedef void (*MonoFinalizationProc)(gpointer, gpointer); // same as SGenFinalizationProc, GC_finalization_proc

void  mono_gc_register_for_finalization (MonoObject *obj, MonoFinalizationProc user_data);
void  mono_gc_add_memory_pressure (gint64 value);
MONO_API int   mono_gc_register_root (char *start, size_t size, MonoGCDescriptor descr, MonoGCRootSource source, void *key, const char *msg);
void  mono_gc_deregister_root (char* addr);
void  mono_gc_finalize_domain (MonoDomain *domain);
void  mono_gc_run_finalize (void *obj, void *data);
void  mono_gc_clear_domain (MonoDomain * domain);
/* Signal early termination of finalizer processing inside the gc */
void  mono_gc_suspend_finalizers (void);


/* 
 * Register a root which can only be written using a write barrier.
 * Writes to the root must be done using a write barrier (MONO_ROOT_SETREF).
 * If the root uses an user defined mark routine, the writes are not required to be
 * to the area between START and START+SIZE.
 * The write barrier allows the GC to avoid scanning this root at each collection, so it
 * is more efficient.
 * FIXME: Add an API for clearing remset entries if a root with a user defined
 * mark routine is deleted.
 */
int mono_gc_register_root_wbarrier (char *start, size_t size, MonoGCDescriptor descr, MonoGCRootSource source, void *key, const char *msg);

void mono_gc_wbarrier_set_root (gpointer ptr, MonoObject *value);

/* Set a field of a root registered using mono_gc_register_root_wbarrier () */
#define MONO_ROOT_SETREF(s,fieldname,value) do {	\
	mono_gc_wbarrier_set_root (&((s)->fieldname), (MonoObject*)value); \
} while (0)

/* fast allocation support */

typedef enum {
	// Regular fast path allocator.
	MANAGED_ALLOCATOR_REGULAR,
	// Managed allocator that just calls into the runtime.
	MANAGED_ALLOCATOR_SLOW_PATH,
	// Managed allocator that works like the regular one but also calls into the profiler.
	MANAGED_ALLOCATOR_PROFILER,
} ManagedAllocatorVariant;

int mono_gc_get_aligned_size_for_allocator (int size);
MonoMethod* mono_gc_get_managed_allocator (MonoClass *klass, gboolean for_box, gboolean known_instance_size);
MonoMethod* mono_gc_get_managed_array_allocator (MonoClass *klass);
MonoMethod *mono_gc_get_managed_allocator_by_type (int atype, ManagedAllocatorVariant variant);

guint32 mono_gc_get_managed_allocator_types (void);

/* Return a short string identifying the GC, indented to be saved in AOT images */
const char *mono_gc_get_gc_name (void);

/* Fast write barriers */
MonoMethod* mono_gc_get_specific_write_barrier (gboolean is_concurrent);
MonoMethod* mono_gc_get_write_barrier (void);

/* Fast valuetype copy */
/* WARNING: [dest, dest + size] must be within the bounds of a single type, otherwise the GC will lose remset entries */
G_EXTERN_C void mono_gc_wbarrier_range_copy (gpointer dest, gconstpointer src, int size);

typedef void (*MonoRangeCopyFunction)(gpointer, gconstpointer, int size);

MonoRangeCopyFunction
mono_gc_get_range_copy_func (void);

/* 
 * Functions supplied by the runtime and called by the GC. Currently only used
 * by SGEN.
 */
typedef struct {
	/* 
	 * Function called during thread startup/attach to allocate thread-local data 
	 * needed by the other functions.
	 */
	gpointer (*thread_attach_func) (void);
	/* 
	 * Function called during thread deatch to free the data allocated by
	 * thread_attach_func.
	 */
	void (*thread_detach_func) (gpointer user_data);
	/* 
	 * Function called from every thread when suspending for GC. It can save
	 * data needed for marking from thread stacks. user_data is the data returned 
	 * by attach_func. This might called with GC locks held and the word stopped,
	 * so it shouldn't do any synchronization etc.
	 */
	void (*thread_suspend_func) (gpointer user_data, void *sigcontext, MonoContext *ctx);
	/* 
	 * Function called to mark from thread stacks. user_data is the data returned 
	 * by attach_func. This is called twice, with the word stopped:
	 * - in the first pass, it should mark areas of the stack using
	 *   conservative marking by calling mono_gc_conservatively_scan_area ().
	 * - in the second pass, it should mark the remaining areas of the stack
	 *   using precise marking by calling mono_gc_scan_object ().
	 */
	void (*thread_mark_func) (gpointer user_data, guint8 *stack_start, guint8 *stack_end, gboolean precise, void *gc_data);
	/*
	 * Function called for debugging to get the current managed method for
	 * tracking the provenances of objects.
	 */
	gpointer (*get_provenance_func) (void);
	/*
	 * Same as thread_mark_func, mark the intepreter frames.
	 */
	void (*interp_mark_func) (gpointer thread_info, GcScanFunc func, gpointer gc_data, gboolean precise);
} MonoGCCallbacks;

/* Set the callback functions callable by the GC */
void mono_gc_set_gc_callbacks (MonoGCCallbacks *callbacks);
MonoGCCallbacks *mono_gc_get_gc_callbacks (void);

/* Functions callable from the thread mark func */

/* Scan the memory area between START and END conservatively */
void mono_gc_conservatively_scan_area (void *start, void *end);

/* Scan OBJ, returning its new address */
void *mono_gc_scan_object (void *obj, void *gc_data);

/* Return the suspend signal number used by the GC to suspend threads,
   or -1 if not applicable. */
int mono_gc_get_suspend_signal (void);

/* Return the suspend signal number used by the GC to suspend threads,
   or -1 if not applicable. */
int mono_gc_get_restart_signal (void);

/*
 * Return a human readable description of the GC in malloc-ed memory.
 */
char* mono_gc_get_description (void);

/*
 * Configure the GC to desktop mode
 */
void mono_gc_set_desktop_mode (void);

/*
 * Return whenever this GC can move objects
 */
gboolean mono_gc_is_moving (void);

typedef void* (*MonoGCLockedCallbackFunc) (void *data);

void* mono_gc_invoke_with_gc_lock (MonoGCLockedCallbackFunc func, void *data);

int mono_gc_get_los_limit (void);

guint64 mono_gc_get_allocated_bytes_for_current_thread (void);

guint64 mono_gc_get_total_allocated_bytes (MonoBoolean precise);

void mono_gc_get_gcmemoryinfo (gint64* fragmented_bytes,
						       gint64* heap_size_bytes,
						       gint64* high_memory_load_threshold_bytes,
						       gint64* memory_load_bytes,
 						       gint64* total_available_memory_bytes);

guint8* mono_gc_get_card_table (int *shift_bits, gpointer *card_mask);
guint8* mono_gc_get_target_card_table (int *shift_bits, target_mgreg_t *card_mask);
gboolean mono_gc_card_table_nursery_check (void);

void* mono_gc_get_nursery (int *shift_bits, size_t *size);

// Don't use directly; set/unset MONO_THREAD_INFO_FLAGS_NO_GC instead.
void mono_gc_skip_thread_changing (gboolean skip);
void mono_gc_skip_thread_changed (gboolean skip);

#ifndef HOST_WIN32
int mono_gc_pthread_create (pthread_t *new_thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
#endif

/*
 * Return whenever GC is disabled
 */
gboolean mono_gc_is_disabled (void);

/*
 * Return whenever this is the null GC
 */
gboolean mono_gc_is_null (void);

void mono_gc_set_string_length (MonoString *str, gint32 new_length);

#if defined(__MACH__)
void mono_gc_register_mach_exception_thread (pthread_t thread);
pthread_t mono_gc_get_mach_exception_thread (void);
#endif

gboolean mono_gc_precise_stack_mark_enabled (void);

typedef struct _RefQueueEntry RefQueueEntry;

struct _RefQueueEntry {
	void *dis_link;
	guint32 gchandle;
	MonoDomain *domain;
	void *user_data;
	RefQueueEntry *next;
};

struct _MonoReferenceQueue {
	RefQueueEntry *queue;
	mono_reference_queue_callback callback;
	MonoReferenceQueue *next;
	gboolean should_be_deleted;
};

enum {
	MONO_GC_FINALIZER_EXTENSION_VERSION = 1,
};

typedef struct {
	int version;
	gboolean (*is_class_finalization_aware) (MonoClass *klass);
	void (*object_queued_for_finalization) (MonoObject *object);
} MonoGCFinalizerCallbacks;

MONO_API void mono_gc_register_finalizer_callbacks (MonoGCFinalizerCallbacks *callbacks);


#ifdef HOST_WIN32
BOOL APIENTRY mono_gc_dllmain (HMODULE module_handle, DWORD reason, LPVOID reserved);
#endif

MonoVTable *mono_gc_get_vtable (MonoObject *obj);

guint mono_gc_get_vtable_bits (MonoClass *klass);

void mono_gc_register_altstack (gpointer stack, gint32 stack_size, gpointer altstack, gint32 altstack_size);

gboolean mono_gc_is_critical_method (MonoMethod *method);

G_EXTERN_C // due to THREAD_INFO_TYPE varying
gpointer mono_gc_thread_attach (THREAD_INFO_TYPE *info);

G_EXTERN_C // due to THREAD_INFO_TYPE varying
void mono_gc_thread_detach (THREAD_INFO_TYPE *info);

G_EXTERN_C // due to THREAD_INFO_TYPE varying
void mono_gc_thread_detach_with_lock (THREAD_INFO_TYPE *info);

G_EXTERN_C // due to THREAD_INFO_TYPE varying
gboolean mono_gc_thread_in_critical_region (THREAD_INFO_TYPE *info);

/* If set, print debugging messages around finalizers. */
extern gboolean mono_log_finalizers;

/* If set, do not run finalizers. */
extern gboolean mono_do_not_finalize;
/* List of names of classes not to finalize. */
extern gchar **mono_do_not_finalize_class_names;

#endif /* __MONO_METADATA_GC_INTERNAL_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/handle-decl.h`:

```h
/**
 * \file
 * Handle to object in native code
 *
 * Authors:
 *  - Ludovic Henry <ludovic@xamarin.com>
 *  - Aleksey Klieger <aleksey.klieger@xamarin.com>
 *  - Rodrigo Kumpera <kumpera@xamarin.com>
 *
 * Copyright 2016 Dot net foundation.
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_HANDLE_DECL_H__
#define __MONO_HANDLE_DECL_H__

#include <config.h>
#include <glib.h>
#include <mono/metadata/object-forward.h>
#include <mono/utils/mono-compiler.h>

// Type-safe handles are a struct with a pointer to pointer.
// The only operations allowed on them are the functions/macros in this file, and assignment
// from same handle type to same handle type.
//
// Raw handles are void* but still same underlying representation, really void**.
//
// marshal-ilgen.c does not know how to marshal type safe handles.
// It passes/accepts raw handles and generated wrappers in C convert.

/*
Handle macros/functions
*/

#define TYPED_HANDLE_NAME(TYPE) TYPE ## Handle
#define TYPED_OUT_HANDLE_NAME(TYPE) TYPE ## HandleOut
#define TYPED_IN_OUT_HANDLE_NAME(TYPE) TYPE ## HandleInOut

// internal helpers:
#define MONO_HANDLE_CAST_FOR(type) mono_handle_cast_##type
#define MONO_HANDLE_TYPECHECK_FOR(type) mono_handle_typecheck_##type

/*
 * TYPED_HANDLE_DECL(SomeType):
 *   Expands to a decl for handles to SomeType.
 *
 * For example, TYPED_HANDLE_DECL(MonoObject) (see below) expands to:
 *
 * typedef struct {
 *   MonoObject **__raw;
 * } MonoObjectHandle,
 *   MonoObjectHandleOut,
 *   MonoObjectHandleInOut;
 *
 * Out is intended for out parameters, InOut is intended for ref parameters.
 * This is not enforced.
 * Internal helper functions are also generated.
 */
#ifdef __cplusplus
#define MONO_IF_CPLUSPLUS(x) x
#else
#define MONO_IF_CPLUSPLUS(x) /* nothing */
#endif

#define TYPED_HANDLE_DECL(TYPE)							\
	typedef struct {							\
		MONO_IF_CPLUSPLUS (						\
			MONO_ALWAYS_INLINE					\
			TYPE * GetRaw () const { return __raw ? *__raw : NULL; } \
			TYPE * volatile * Ref () { g_assert (__raw); return __raw; } \
		)								\
		TYPE * volatile *__raw;						\
	} TYPED_HANDLE_NAME (TYPE),						\
	  TYPED_OUT_HANDLE_NAME (TYPE),						\
	  TYPED_IN_OUT_HANDLE_NAME (TYPE);					\
/* Do not call these functions directly. Use MONO_HANDLE_NEW and MONO_HANDLE_CAST. */ \
/* Another way to do this involved casting mono_handle_new function to a different type. */ \
static inline MONO_ALWAYS_INLINE TYPED_HANDLE_NAME (TYPE) 	\
MONO_HANDLE_CAST_FOR (TYPE) (MonoRawHandle a)			\
{								\
	TYPED_HANDLE_NAME (TYPE) b = { (TYPE**)a };		\
	return b;						\
}								\
static inline MONO_ALWAYS_INLINE MonoObject* 			\
MONO_HANDLE_TYPECHECK_FOR (TYPE) (TYPE *a)			\
{								\
	return (MonoObject*)a;					\
}								\
/* Out/InOut synonyms for icall-def.h HANDLES () */		\
static inline MONO_ALWAYS_INLINE TYPED_HANDLE_NAME (TYPE) 	\
MONO_HANDLE_CAST_FOR (TYPE##Out) (gpointer a)			\
{								\
	return MONO_HANDLE_CAST_FOR (TYPE) (a);			\
}								\
static inline MONO_ALWAYS_INLINE MonoObject* 			\
MONO_HANDLE_TYPECHECK_FOR (TYPE##Out) (TYPE *a)			\
{								\
	return MONO_HANDLE_TYPECHECK_FOR (TYPE) (a);		\
}								\
static inline MONO_ALWAYS_INLINE TYPED_HANDLE_NAME (TYPE) 	\
MONO_HANDLE_CAST_FOR (TYPE##InOut) (gpointer a)			\
{								\
	return MONO_HANDLE_CAST_FOR (TYPE) (a);			\
}								\
static inline MONO_ALWAYS_INLINE MonoObject* 			\
MONO_HANDLE_TYPECHECK_FOR (TYPE##InOut) (TYPE *a)		\
{								\
	return MONO_HANDLE_TYPECHECK_FOR (TYPE) (a);		\
}

#endif /* __MONO_HANDLE_DECL_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/handle.h`:

```h
/**
 * \file
 * Handle to object in native code
 *
 * Authors:
 *  - Ludovic Henry <ludovic@xamarin.com>
 *  - Aleksey Klieger <aleksey.klieger@xamarin.com>
 *  - Rodrigo Kumpera <kumpera@xamarin.com>
 *
 * Copyright 2016 Dot net foundation.
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_HANDLE_H__
#define __MONO_HANDLE_H__

#include <config.h>
#include <glib.h>

#include <mono/metadata/handle-decl.h>
#include <mono/metadata/object.h>
#include <mono/metadata/class.h>
#include <mono/utils/mono-error-internals.h>
#include <mono/utils/mono-threads.h>
#include <mono/utils/checked-build.h>
#include <mono/metadata/class-internals.h>

/*
Handle stack.

The handle stack is designed so it's efficient to pop a large amount of entries at once.
The stack is made out of a series of fixed size segments.

To do bulk operations you use a stack mark.
	
*/

/*
3 is the number of fields besides the data in the struct;
128 words makes each chunk 512 or 1024 bytes each
*/
#define OBJECTS_PER_HANDLES_CHUNK (128 - 3)

/*
Whether this config needs stack watermark recording to know where to start scanning from.
*/
#ifdef HOST_WATCHOS
#define MONO_NEEDS_STACK_WATERMARK 1
#endif

typedef struct _HandleChunk HandleChunk;

/*
 * Define MONO_HANDLE_TRACK_OWNER to store the file and line number of each call to MONO_HANDLE_NEW
 * in the handle stack.  (This doubles the amount of memory used for handles, so it's only useful for debugging).
 */
/*#define MONO_HANDLE_TRACK_OWNER*/

/*
 * Define MONO_HANDLE_TRACK_SP to record the C stack pointer at the time of each HANDLE_FUNCTION_ENTER and
 * to ensure that when a new handle is allocated the previous newest handle is not lower in the stack.
 * This is useful to catch missing HANDLE_FUNCTION_ENTER / HANDLE_FUNCTION_RETURN pairs which could cause
 * handle leaks.
 */
/*#define MONO_HANDLE_TRACK_SP*/

typedef struct {
	gpointer o; /* MonoObject ptr */
#ifdef MONO_HANDLE_TRACK_OWNER
	const char *owner;
	gpointer backtrace_ips[7]; /* result of backtrace () at time of allocation */
#endif
#ifdef MONO_HANDLE_TRACK_SP
	gpointer alloc_sp; /* sp from HandleStack:stackmark_sp at time of allocation */
#endif
} HandleChunkElem;

struct _HandleChunk {
	int size; //number of handles
	HandleChunk *prev, *next;
	HandleChunkElem elems [OBJECTS_PER_HANDLES_CHUNK];
};

typedef struct MonoHandleStack {
	HandleChunk *top; //alloc from here
	HandleChunk *bottom; //scan from here
#ifdef MONO_HANDLE_TRACK_SP
	gpointer stackmark_sp; // C stack pointer top when from most recent mono_stack_mark_init
#endif
} HandleStack;

// Keep this in sync with RuntimeStructs.cs
typedef struct {
	int size;
	HandleChunk *chunk;
#ifdef MONO_HANDLE_TRACK_SP
	gpointer prev_sp; // C stack pointer from prior mono_stack_mark_init
#endif
} HandleStackMark;

// There are two types of handles.
//  Pointers to volatile pointers in managed frames.
//    These are allocated by icall wrappers in marshal-ilgen.c.
//  Pointers to non-volatile pointers in TLS.
//    These are allocated by MONO_HANDLE_NEW.
typedef void volatile * MonoRawHandle;

typedef void (*GcScanFunc) (gpointer*, gpointer);


/* If Centrinel is analyzing Mono, use the SUPPRESS macros to mark the bodies
 * of the handle macros as allowed to perform operations on raw pointers to
 * managed objects.  Take care to UNSUPPRESS the _arguments_ to the macros - we
 * want warnings if the argument uses pointers unsafely.
 */
#ifdef __CENTRINEL__
#define MONO_HANDLE_SUPPRESS_SCOPE(b) __CENTRINEL_SUPPRESS_SCOPE(b)
#define MONO_HANDLE_SUPPRESS(expr) __CENTRINEL_SUPPRESS(expr)
#define MONO_HANDLE_UNSUPPRESS(expr) __CENTRINEL_UNSUPPRESS(expr)
#else
#define MONO_HANDLE_SUPPRESS_SCOPE(b) ;
#define MONO_HANDLE_SUPPRESS(expr) (expr)
#define MONO_HANDLE_UNSUPPRESS(expr) (expr)
#endif

#ifndef MONO_HANDLE_TRACK_OWNER
MonoRawHandle mono_handle_new (MonoObject *object, MonoThreadInfo *info);
#else
MonoRawHandle mono_handle_new (MonoObject *object, MonoThreadInfo *info, const char* owner);
#endif

void mono_handle_stack_scan (HandleStack *stack, GcScanFunc func, gpointer gc_data, gboolean precise, gboolean check);
gboolean mono_handle_stack_is_empty (HandleStack *stack);
HandleStack* mono_handle_stack_alloc (void);
void mono_handle_stack_free (HandleStack *handlestack);
MonoRawHandle mono_stack_mark_pop_value (MonoThreadInfo *info, HandleStackMark *stackmark, MonoRawHandle value);
MonoThreadInfo* mono_stack_mark_record_size (MonoThreadInfo *info, HandleStackMark *stackmark, const char *func_name);
void mono_handle_stack_free_domain (HandleStack *stack, MonoDomain *domain);

#ifdef MONO_HANDLE_TRACK_SP
void mono_handle_chunk_leak_check (HandleStack *handles);
#endif

static inline void
mono_stack_mark_init (MonoThreadInfo *info, HandleStackMark *stackmark)
{
#ifdef MONO_HANDLE_TRACK_SP
	gpointer sptop = &stackmark;
#endif
	HandleStack *handles = info->handle_stack;
	stackmark->size = handles->top->size;
	stackmark->chunk = handles->top;
#ifdef MONO_HANDLE_TRACK_SP
	stackmark->prev_sp = handles->stackmark_sp;
	handles->stackmark_sp = sptop;
#endif
}

static inline void
mono_stack_mark_pop (MonoThreadInfo *info, HandleStackMark *stackmark)
{
	HandleStack *handles = info->handle_stack;
	HandleChunk *old_top = stackmark->chunk;
	old_top->size = stackmark->size;
	mono_memory_write_barrier ();
	handles->top = old_top;
#ifdef MONO_HANDLE_TRACK_SP
	mono_memory_write_barrier (); /* write to top before prev_sp */
	handles->stackmark_sp = stackmark->prev_sp;
#endif
}

// There are deliberately locals and a constant NULL global with this same name.
extern MonoThreadInfo * const mono_thread_info_current_var;

/*
Icall macros
*/
#define SETUP_ICALL_COMMON	\
	do { \
		MONO_DISABLE_WARNING(4459) /* declaration of 'identifier' hides global declaration */ \
		ERROR_DECL (error);	\
		/* There are deliberately locals and a constant NULL global with this same name. */ \
		MonoThreadInfo *mono_thread_info_current_var = mono_thread_info_current (); \
		MONO_RESTORE_WARNING \

#define CLEAR_ICALL_COMMON	\
	mono_error_set_pending_exception (error);

// FIXME There should be fast and slow versions of this, i.e. with and without local variable.
#define SETUP_ICALL_FRAME	\
	HandleStackMark __mark;	\
	mono_stack_mark_init (mono_thread_info_current_var ? mono_thread_info_current_var : mono_thread_info_current (), &__mark);

// FIXME This should be one function call since it is not fully inlined.
#define CLEAR_ICALL_FRAME	\
	mono_stack_mark_pop (mono_stack_mark_record_size (mono_thread_info_current_var, &__mark, __FUNCTION__), &__mark);

// FIXME This should be one function call since it is not fully inlined.
#define CLEAR_ICALL_FRAME_VALUE(RESULT, HANDLE)				\
	(RESULT) = g_cast (mono_stack_mark_pop_value (mono_stack_mark_record_size (mono_thread_info_current_var, &__mark, __FUNCTION__), &__mark, (HANDLE)));

#define HANDLE_FUNCTION_ENTER() do {				\
	MONO_DISABLE_WARNING(4459) /* declaration of 'identifier' hides global declaration */ \
	/* There are deliberately locals and a constant NULL global with this same name. */ \
	MonoThreadInfo *mono_thread_info_current_var = mono_thread_info_current ();	\
	MONO_RESTORE_WARNING \
	SETUP_ICALL_FRAME					\

#define HANDLE_FUNCTION_RETURN()		\
	CLEAR_ICALL_FRAME;			\
	} while (0)

// Do not do this often, but icall state can be manually managed.
//
// SETUP_ICALL_FUNCTION
// loop { // Does not have to be a loop.
//    SETUP_ICALL_FRAME
//    ..
//    CLEAR_ICALL_FRAME
// }
//
// As with HANDLE_FUNCTION_RETURN, you must not
// skip CLEAR_ICALL_FRAME -- no break, continue, return, or goto (goto label at CLEAR_ICALL_FRAME is idiom).
//
#define SETUP_ICALL_FUNCTION \
	MONO_DISABLE_WARNING(4459) /* declaration of 'identifier' hides global declaration */ \
	/* There are deliberately locals and a constant NULL global with this same name. */ \
	MonoThreadInfo *mono_thread_info_current_var = mono_thread_info_current () \
	MONO_RESTORE_WARNING

// A common use of manual icall frame management is for loop.
// It can also be used for conditionality, where only some paths
// through a function allocate handles and frame teardown does
// coincide with function return. For example: emit_invoke_call.
//
#define HANDLE_LOOP_PREPARE SETUP_ICALL_FUNCTION

// Return a non-pointer or non-managed pointer, e.g. gboolean.
// VAL should be a local variable or at least not use handles in the current frame.
// i.e. it is "val", not "expr".
#define HANDLE_FUNCTION_RETURN_VAL(VAL)		\
	CLEAR_ICALL_FRAME;			\
	return (VAL);				\
	} while (0)

// Return a raw pointer from coop handle.
#define HANDLE_FUNCTION_RETURN_OBJ(HANDLE)			\
	do {							\
		void* __result = MONO_HANDLE_RAW (HANDLE);	\
		CLEAR_ICALL_FRAME;				\
		return g_cast (__result);			\
	} while (0); } while (0);

// Return a coop handle from coop handle.
#define HANDLE_FUNCTION_RETURN_REF(TYPE, HANDLE)			\
	do {								\
		MonoObjectHandle __result;				\
		CLEAR_ICALL_FRAME_VALUE (__result.__raw, (HANDLE).__raw); \
		return MONO_HANDLE_CAST (TYPE, __result);		\
	} while (0); } while (0);

#ifdef MONO_NEEDS_STACK_WATERMARK

static void
mono_thread_info_pop_stack_mark (MonoThreadInfo *info, void *old_mark)
{
	info->stack_mark = old_mark;
}

static void*
mono_thread_info_push_stack_mark (MonoThreadInfo *info, void *mark)
{
	void *old = info->stack_mark;
	info->stack_mark = mark;
	return old;
}

#define SETUP_STACK_WATERMARK	\
	int __dummy;	\
	__builtin_unwind_init ();	\
	void *__old_stack_mark = mono_thread_info_push_stack_mark (mono_thread_info_current_var, &__dummy);

#define CLEAR_STACK_WATERMARK	\
	mono_thread_info_pop_stack_mark (mono_thread_info_current_var, __old_stack_mark);

#else
#define SETUP_STACK_WATERMARK
#define CLEAR_STACK_WATERMARK
#endif

#define ICALL_ENTRY()	\
	SETUP_ICALL_COMMON	\
	SETUP_ICALL_FRAME	\
	SETUP_STACK_WATERMARK

#define ICALL_RETURN()	\
	do {	\
		CLEAR_STACK_WATERMARK	\
		CLEAR_ICALL_COMMON	\
		CLEAR_ICALL_FRAME	\
		return;	\
	} while (0); } while (0)

#define ICALL_RETURN_VAL(VAL)	\
	do {	\
		CLEAR_STACK_WATERMARK	\
		CLEAR_ICALL_COMMON	\
		CLEAR_ICALL_FRAME	\
		return VAL;	\
	} while (0); } while (0)

#define ICALL_RETURN_OBJ(HANDLE)	\
	do {	\
		CLEAR_STACK_WATERMARK	\
		CLEAR_ICALL_COMMON	\
		void* __ret = MONO_HANDLE_RAW (HANDLE);	\
		CLEAR_ICALL_FRAME	\
		return g_cast (__ret);	\
	} while (0); } while (0)

/*
Handle macros/functions
*/
#ifdef MONO_HANDLE_TRACK_OWNER
#define STRINGIFY_(x) #x
#define STRINGIFY(x) STRINGIFY_(x)
#define HANDLE_OWNER (__FILE__ ":" STRINGIFY (__LINE__))
#endif

//XXX add functions to get/set raw, set field, set field to null, set array, set array to null
#define MONO_HANDLE_DCL(TYPE, NAME) TYPED_HANDLE_NAME(TYPE) NAME = MONO_HANDLE_NEW (TYPE, (NAME ## _raw))

// With Visual C++ compiling as C, the type of a ternary expression
// yielding two unrelated non-void pointers is the type of the first, plus a warning.
// This can be used to simulate gcc typeof extension.
// Otherwise we are forced to evaluate twice, or use C++.
#ifdef _MSC_VER
typedef struct _MonoTypeofCastHelper *MonoTypeofCastHelper; // a pointer type unrelated to anything else
#define MONO_TYPEOF_CAST(typeexpr, expr) __pragma(warning(suppress:4133))(0 ? (typeexpr) : (MonoTypeofCastHelper)(expr))
#else
#define MONO_TYPEOF_CAST(typeexpr, expr) ((__typeof__ (typeexpr))(expr))
#endif

/*
 * Create handle for the object OBJECT.
 * The handle will keep the object alive and pinned.
 */
#ifndef MONO_HANDLE_TRACK_OWNER

#define MONO_HANDLE_NEW(type, object) \
	(MONO_HANDLE_CAST_FOR (type) (mono_handle_new (MONO_HANDLE_TYPECHECK_FOR (type) (object), mono_thread_info_current_var)))

#else

#define MONO_HANDLE_NEW(type, object) \
	(MONO_HANDLE_CAST_FOR (type) (mono_handle_new (MONO_HANDLE_TYPECHECK_FOR (type) (object), mono_thread_info_current_var, HANDLE_OWNER)))

#endif

#define MONO_HANDLE_CAST(type, value) (MONO_HANDLE_CAST_FOR (type) ((value).__raw))

/*
 * Return the raw object reference stored in the handle.
 * The objref is valid while the handle is alive and
 * points to it.
 */
#ifdef __cplusplus
#define MONO_HANDLE_RAW(handle)     ((handle).GetRaw())
#else
#define MONO_HANDLE_RAW(handle)     (MONO_TYPEOF_CAST (*(handle).__raw, mono_handle_raw ((handle).__raw)))
#endif
#define MONO_HANDLE_IS_NULL(handle) (mono_handle_is_null ((handle).__raw))

#define MONO_BOOL(x)             (!!MONO_HANDLE_SUPPRESS (x))
#define MONO_HANDLE_BOOL(handle) (MONO_BOOL (!MONO_HANDLE_IS_NULL (handle)))

/*
WARNING WARNING WARNING

The following functions require a particular evaluation ordering to ensure correctness.
We must not have exposed handles while any sort of evaluation is happening as that very evaluation might trigger
a safepoint and break us.

This is why we evaluate index and value before any call to MONO_HANDLE_RAW or other functions that deal with naked objects.
*/
#define MONO_HANDLE_SETRAW(HANDLE, FIELD, VALUE) do {			\
		MONO_HANDLE_SUPPRESS_SCOPE(1);				\
		MonoObject *__val = MONO_HANDLE_SUPPRESS ((MonoObject*)(MONO_HANDLE_UNSUPPRESS (VALUE))); \
		MONO_OBJECT_SETREF_INTERNAL (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE)), FIELD, __val); \
	} while (0)

// handle->field = value for managed pointer
#define MONO_HANDLE_SET(HANDLE, FIELD, VALUE) do {			\
		MonoObjectHandle __val = MONO_HANDLE_CAST (MonoObject, VALUE);	\
		do {							\
			MONO_HANDLE_SUPPRESS_SCOPE(1);			\
			MONO_OBJECT_SETREF_INTERNAL (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE)), FIELD, MONO_HANDLE_RAW (__val)); \
		} while (0);						\
	} while (0)

// resultHandle = handle->field
/* N.B. RESULT is evaluated before HANDLE */
#define MONO_HANDLE_GET(RESULT, HANDLE, FIELD) do {			\
		MonoObjectHandle __dest = MONO_HANDLE_CAST (MonoObject, RESULT);	\
		MONO_HANDLE_SUPPRESS (*(gpointer*)__dest.__raw = (gpointer)MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE))->FIELD); \
	} while (0)

// Get handle->field as a type-handle.
#define MONO_HANDLE_NEW_GET(TYPE,HANDLE,FIELD) (MONO_HANDLE_NEW(TYPE,MONO_HANDLE_SUPPRESS (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE))->FIELD)))

// Get handle->field, where field is not a pointer (an integer or non-managed pointer).
#define MONO_HANDLE_GETVAL(HANDLE, FIELD) MONO_HANDLE_SUPPRESS (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE))->FIELD)

// Get handle->field as a boolean, i.e. typically compare managed pointer to NULL,
// though any type is ok.
#define MONO_HANDLE_GET_BOOL(handle, field) (MONO_BOOL (MONO_HANDLE_GETVAL (handle, field)))

// handle->field = (type)value, for non-managed pointers
// This would be easier to write with the gcc extension typeof,
// but it is not widely enough implemented (i.e. Microsoft C).
// The value copy is needed in cases computing value causes a GC
#define MONO_HANDLE_SETVAL(HANDLE, FIELD, TYPE, VALUE) do {	\
		TYPE __val = (VALUE);	\
		if (0) { TYPE * typecheck G_GNUC_UNUSED = &MONO_HANDLE_SUPPRESS (MONO_HANDLE_RAW (HANDLE)->FIELD); } \
		MONO_HANDLE_SUPPRESS (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE))->FIELD = __val); \
	 } while (0)

// handle [idx] = value (for managed pointers)
#define MONO_HANDLE_ARRAY_SETREF(HANDLE, IDX, VALUE) do {	\
		uintptr_t __idx = (IDX);	\
   		MonoObjectHandle __val = MONO_HANDLE_CAST (MonoObject, VALUE);		\
		{	/* FIXME scope needed by Centrinel */		\
			/* FIXME mono_array_setref_fast is not an expression. */ \
			MONO_HANDLE_SUPPRESS_SCOPE(1);			\
			mono_array_setref_fast (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE)), __idx, MONO_HANDLE_RAW (__val)); \
		}							\
	} while (0)

// handle [idx] = (type)value (for non-managed types)
#define MONO_HANDLE_ARRAY_SETVAL(HANDLE, TYPE, IDX, VALUE) do {		\
		uintptr_t __idx = (IDX);				\
   		TYPE __val = (VALUE);					\
		{	/* FIXME scope needed by Centrinel */		\
			/* FIXME mono_array_set is not an expression. */ \
			MONO_HANDLE_SUPPRESS_SCOPE(1);			\
			mono_array_set_internal (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE)), TYPE, __idx, __val); \
		}							\
	} while (0)

#if 0 // This is never used.
// handle [idx] = value
#define MONO_HANDLE_ARRAY_SETRAW(HANDLE, IDX, VALUE) do {	\
		MONO_HANDLE_SUPPRESS_SCOPE(1);			\
		uintptr_t __idx = MONO_HANDLE_UNSUPPRESS(IDX);	\
		MonoObject *__val = (MonoObject*)(VALUE);	\
		mono_array_setref_fast (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (HANDLE)), __idx, __val); \
	} while (0)
#endif

/* N.B. DEST is evaluated AFTER all the other arguments */
#define MONO_HANDLE_ARRAY_GETVAL(DEST, HANDLE, TYPE, IDX) do {		\
		MonoArrayHandle __arr = (HANDLE);			\
		uintptr_t __idx = (IDX);				\
		TYPE __result = MONO_HANDLE_SUPPRESS (mono_array_get_internal (MONO_HANDLE_RAW(__arr), TYPE, __idx)); \
		(DEST) =  __result;					\
	} while (0)

// dest = handle [idx] (for managed pointers)
#define MONO_HANDLE_ARRAY_GETREF(DEST, HANDLE, IDX) do {		\
		mono_handle_array_getref (MONO_HANDLE_CAST(MonoObject, (DEST)), (HANDLE), (IDX)); \
	} while (0)

#define MONO_HANDLE_ASSIGN_RAW(DESTH, SRCP) (mono_handle_assign_raw (MONO_HANDLE_CAST (MonoObject, (DESTH)), (SRCP)))
#define MONO_HANDLE_ASSIGN(DESTH, SRCH)     (MONO_HANDLE_ASSIGN_RAW ((DESTH), MONO_HANDLE_RAW (SRCH)))

#define MONO_HANDLE_DOMAIN(HANDLE) MONO_HANDLE_SUPPRESS (mono_object_domain (MONO_HANDLE_RAW (MONO_HANDLE_CAST (MonoObject, MONO_HANDLE_UNSUPPRESS (HANDLE)))))

#define mono_handle_domain(handle) MONO_HANDLE_DOMAIN ((handle))

/* Given an object and a MonoClassField, return the value (must be non-object)
 * of the field.  It's the caller's responsibility to check that the object is
 * of the correct class. */
#define MONO_HANDLE_GET_FIELD_VAL(HANDLE,TYPE,FIELD) (*(TYPE *)(mono_handle_unsafe_field_addr (MONO_HANDLE_CAST (MonoObject, (HANDLE)), (FIELD))))
#define MONO_HANDLE_GET_FIELD_BOOL(handle, type, field) (MONO_BOOL (MONO_HANDLE_GET_FIELD_VAL ((handle), type, (field))))

#define MONO_HANDLE_NEW_GET_FIELD(HANDLE,TYPE,FIELD) MONO_HANDLE_NEW (TYPE, MONO_HANDLE_SUPPRESS (*(TYPE**)(mono_handle_unsafe_field_addr (MONO_HANDLE_CAST (MonoObject, MONO_HANDLE_UNSUPPRESS (HANDLE)), (FIELD)))))

#define MONO_HANDLE_SET_FIELD_VAL(HANDLE,TYPE,FIELD,VAL) do {		\
		MonoObjectHandle __obj = (HANDLE);			\
		MonoClassField *__field = (FIELD);			\
		TYPE __value = (VAL);					\
		*(TYPE*)(mono_handle_unsafe_field_addr (__obj, __field)) = __value; \
	} while (0)

#define MONO_HANDLE_SET_FIELD_REF(HANDLE,FIELD,VALH) do {		\
		MonoObjectHandle __obj = MONO_HANDLE_CAST (MonoObject, (HANDLE)); \
		MonoClassField *__field = (FIELD);			\
		MonoObjectHandle __value = MONO_HANDLE_CAST (MonoObject, (VALH)); \
		MONO_HANDLE_SUPPRESS (mono_gc_wbarrier_generic_store_internal (mono_handle_unsafe_field_addr (__obj, __field), MONO_HANDLE_RAW (__value))); \
	} while (0)

#define MONO_HANDLE_GET_CLASS(handle) (MONO_HANDLE_GETVAL (MONO_HANDLE_CAST (MonoObject, (handle)), vtable)->klass)

/* Baked typed handles we all want */
TYPED_HANDLE_DECL (MonoString);
TYPED_HANDLE_DECL (MonoArray);
TYPED_HANDLE_DECL (MonoObject);
TYPED_HANDLE_DECL (MonoException);
TYPED_HANDLE_DECL (MonoAppContext);

// Structs cannot be cast to structs.
// As well, a function is needed because an anonymous struct cannot be initialized in C.
static inline MonoObjectHandle
mono_handle_cast (gpointer a)
{
	return *(MonoObjectHandle*)&a;
}

static inline MONO_ALWAYS_INLINE gboolean
mono_handle_is_null (MonoRawHandle raw_handle)
{
	MONO_HANDLE_SUPPRESS_SCOPE (1);
	MonoObjectHandle *handle = (MonoObjectHandle*)&raw_handle;
	return !handle->__raw || !*handle->__raw;
}

static inline MONO_ALWAYS_INLINE gpointer
mono_handle_raw (MonoRawHandle raw_handle)
{
	MONO_HANDLE_SUPPRESS_SCOPE (1);
	MonoObjectHandle *handle = (MonoObjectHandle*)&raw_handle;
	return handle->__raw ? *handle->__raw : NULL;
}

/* Unfortunately MonoThreadHandle is already a typedef used for something unrelated.  So
 * the coop handle for MonoThread* is MonoThreadObjectHandle.
 */
typedef MonoThread MonoThreadObject;
TYPED_HANDLE_DECL (MonoThreadObject);

/*
This is the constant for a handle that points nowhere.
Constant handles may be initialized to it, but non-constant
handles must be NEW'ed. Uses of these are suspicious and should
be reviewed and probably changed FIXME.
*/
#define NULL_HANDLE (mono_null_value_handle ())
#define NULL_HANDLE_INIT { 0 }
static inline MonoObjectHandle
mono_null_value_handle (void)
{
	MonoObjectHandle result = NULL_HANDLE_INIT;
	return result;
}
#define NULL_HANDLE_STRING 		(MONO_HANDLE_CAST (MonoString, NULL_HANDLE))
#define NULL_HANDLE_ARRAY  		(MONO_HANDLE_CAST (MonoArray,  NULL_HANDLE))
#define NULL_HANDLE_STRING_BUILDER	(MONO_HANDLE_CAST (MonoStringBuilder, NULL_HANDLE))

#if __cplusplus

// Use this to convert a THandle to a raw T** such as for a ref or out parameter, without
// copying back and forth through an intermediate. The handle must already be allocated,
// such as icall marshaling does for out and ref parameters.
#define MONO_HANDLE_REF(h) (h.Ref ())

#else

static inline void volatile*
mono_handle_ref (void volatile* p)
{
	g_assert (p);
	return p;
}

// Use this to convert a THandle to a raw T** such as for a ref or out parameter, without
// copying back and forth through an intermediate. The handle must already be allocated,
// such as icall marshaling does for out and ref parameters.
#define MONO_HANDLE_REF(handle) (MONO_TYPEOF_CAST ((handle).__raw, mono_handle_ref ((handle).__raw)))

#endif

static inline MonoObjectHandle
mono_handle_assign_raw (MonoObjectHandleOut dest, void *src)
{
	g_assert (dest.__raw);
	MONO_HANDLE_SUPPRESS (*dest.__raw = (MonoObject*)src);
	return dest;
}

/* It is unsafe to call this function directly - it does not pin the handle!  Use MONO_HANDLE_GET_FIELD_VAL(). */
static inline gpointer
mono_handle_unsafe_field_addr (MonoObjectHandle h, MonoClassField *field)
{
	return MONO_HANDLE_SUPPRESS (((gchar *)MONO_HANDLE_RAW (h)) + field->offset);
}

//FIXME this should go somewhere else
MonoStringHandle mono_string_new_handle (MonoDomain *domain, const char *data, MonoError *error);
MonoArrayHandle mono_array_new_handle (MonoDomain *domain, MonoClass *eclass, uintptr_t n, MonoError *error);
MonoArrayHandle
mono_array_new_full_handle (MonoDomain *domain, MonoClass *array_class, uintptr_t *lengths, intptr_t *lower_bounds, MonoError *error);

#define mono_array_handle_setref(array,index,value) MONO_HANDLE_ARRAY_SETREF ((array), (index), (value))

void
mono_handle_array_getref (MonoObjectHandleOut dest, MonoArrayHandle array, uintptr_t index);

#define mono_handle_class(o) MONO_HANDLE_SUPPRESS (mono_object_class (MONO_HANDLE_RAW (MONO_HANDLE_UNSUPPRESS (o))))

#define mono_handle_vtable(o) MONO_HANDLE_GETVAL (o, vtable)

/* Local handles to global GC handles and back */

uint32_t
mono_gchandle_from_handle (MonoObjectHandle handle, mono_bool pinned);

MonoObjectHandle
mono_gchandle_get_target_handle (uint32_t gchandle);

gboolean
mono_gchandle_target_equal (uint32_t gchandle, MonoObjectHandle equal);

void
mono_gchandle_target_is_null_or_equal (uint32_t gchandle, MonoObjectHandle equal, gboolean *is_null,
	gboolean *is_equal);

void
mono_gchandle_set_target_handle (guint32 gchandle, MonoObjectHandle obj);

void
mono_array_handle_memcpy_refs (MonoArrayHandle dest, uintptr_t dest_idx, MonoArrayHandle src, uintptr_t src_idx, uintptr_t len);

/* Pins the MonoArray using a gchandle and returns a pointer to the
 * element with the given index (where each element is of the given
 * size.  Call mono_gchandle_free to unpin.
 */
gpointer
mono_array_handle_pin_with_size (MonoArrayHandle handle, int size, uintptr_t index, uint32_t *gchandle);

#define MONO_ARRAY_HANDLE_PIN(handle,type,index,gchandle_out) ((type*)mono_array_handle_pin_with_size (MONO_HANDLE_CAST(MonoArray,(handle)), sizeof (type), (index), (gchandle_out)))

void
mono_value_copy_array_handle (MonoArrayHandle dest, int dest_idx, gconstpointer src, int count);

gunichar2 *
mono_string_handle_pin_chars (MonoStringHandle s, uint32_t *gchandle_out);

gpointer
mono_object_handle_pin_unbox (MonoObjectHandle boxed_valuetype_obj, uint32_t *gchandle_out);

static inline gpointer
mono_handle_unbox_unsafe (MonoObjectHandle handle)
{
	g_assert (m_class_is_valuetype (MONO_HANDLE_GETVAL (handle, vtable)->klass));
	return MONO_HANDLE_SUPPRESS (MONO_HANDLE_RAW (handle) + 1);
}

void
mono_error_set_exception_handle (MonoError *error, MonoExceptionHandle exc);

MonoAppContextHandle
mono_context_get_handle (void);

void
mono_context_set_handle (MonoAppContextHandle new_context);

guint32
mono_gchandle_new_weakref_from_handle (MonoObjectHandle handle);

int
mono_handle_hash (MonoObjectHandle object);

guint32
mono_gchandle_new_weakref_from_handle_track_resurrection (MonoObjectHandle handle);

#endif /* __MONO_HANDLE_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/icall-decl.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_ICALL_DECL_H__
#define __MONO_METADATA_ICALL_DECL_H__

#include "appdomain-icalls.h"
#include "class.h"
#include "console-io.h"
#include "environment.h"
#include "file-mmap.h"
#include "filewatcher.h"
#include "gc-internals.h"
#include "handle-decl.h"
#include "handle.h"
#include "locales.h"
#include "marshal.h"
#include "monitor.h"
#include "mono-perfcounters.h"
#include "object-forward.h"
#include "object-internals.h"
#include "rand.h"
#include "reflection.h"
#include "security-core-clr.h"
#include "security-manager.h"
#include "security.h"
#include "string-icalls.h"
#include "threadpool-io.h"
#include "threadpool.h"
#include "mono/utils/mono-digest.h"
#include "mono/utils/mono-forward-internal.h"
#include "w32event.h"
#include "w32file.h"
#include "w32mutex.h"
#include "w32process.h"
#include "w32semaphore.h"
#include "w32socket.h"
#include "mono/utils/mono-proclib.h"

/* From MonoProperty.cs */
typedef enum {
	PInfo_Attributes = 1,
	PInfo_GetMethod  = 1 << 1,
	PInfo_SetMethod  = 1 << 2,
	PInfo_ReflectedType = 1 << 3,
	PInfo_DeclaringType = 1 << 4,
	PInfo_Name = 1 << 5
} PInfo;

#include "icall-table.h"

#define NOHANDLES(inner) inner
#define HANDLES_REUSE_WRAPPER(...) /* nothing */

// Generate prototypes for coop icall wrappers and coop icalls.
#define MONO_HANDLE_REGISTER_ICALL(func, ret, nargs, argtypes) \
	MONO_HANDLE_DECLARE (,,func ## _impl, ret, nargs, argtypes); \
	MONO_HANDLE_REGISTER_ICALL_DECLARE_RAW (func, ret, nargs, argtypes);
#define ICALL_TYPE(id, name, first)	/* nothing */
#define ICALL(id, name, func) 		/* nothing */
#define HANDLES(id, name, func, ret, nargs, argtypes) \
	MONO_HANDLE_DECLARE_RAW (id, name, func, ret, nargs, argtypes); \
	MONO_HANDLE_DECLARE (id, name, func, ret, nargs, argtypes);
#include "icall-def.h"
#undef ICALL_TYPE
#undef ICALL
#undef HANDLES
#undef HANDLES_REUSE_WRAPPER
#undef NOHANDLES
#undef MONO_HANDLE_REGISTER_ICALL

// This is sorted.
// grep ICALL_EXPORT | sort | uniq
ICALL_EXPORT MonoAssemblyName* ves_icall_System_Reflection_AssemblyName_GetNativeName (MonoAssembly*);
ICALL_EXPORT MonoBoolean ves_icall_RuntimeTypeHandle_is_subclass_of (MonoType*, MonoType*);
ICALL_EXPORT MonoBoolean ves_icall_System_Environment_GetIs64BitOperatingSystem (void);
ICALL_EXPORT MonoBoolean ves_icall_System_Environment_get_HasShutdownStarted (void);
ICALL_EXPORT MonoBoolean ves_icall_System_GCHandle_CheckCurrentDomain (guint32 gchandle);
ICALL_EXPORT MonoBoolean ves_icall_System_IO_DriveInfo_GetDiskFreeSpace (const gunichar2*, gint32, guint64*, guint64*, guint64*, gint32*);
ICALL_EXPORT MonoBoolean ves_icall_System_Reflection_AssemblyName_ParseAssemblyName (const char*, MonoAssemblyName*, MonoBoolean*, MonoBoolean* is_token_defined_arg);
ICALL_EXPORT MonoBoolean ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_SufficientExecutionStack (void);
ICALL_EXPORT MonoBoolean ves_icall_System_Threading_Thread_YieldInternal (void);
ICALL_EXPORT void ves_icall_System_Threading_Thread_GetCurrentThread (MonoThread * volatile *);
ICALL_EXPORT void ves_icall_System_ArgIterator_Setup (MonoArgIterator*, char*, char*);
ICALL_EXPORT MonoType* ves_icall_System_ArgIterator_IntGetNextArgType (MonoArgIterator*);
ICALL_EXPORT void ves_icall_System_ArgIterator_IntGetNextArg (MonoArgIterator*, MonoTypedRef*);
ICALL_EXPORT void ves_icall_System_ArgIterator_IntGetNextArgWithType (MonoArgIterator*, MonoTypedRef*, MonoType*);
ICALL_EXPORT double ves_icall_System_Math_Abs_double (double);
ICALL_EXPORT double ves_icall_System_Math_Acos (double);
ICALL_EXPORT double ves_icall_System_Math_Acosh (double);
ICALL_EXPORT double ves_icall_System_Math_Asin (double);
ICALL_EXPORT double ves_icall_System_Math_Asinh (double);
ICALL_EXPORT double ves_icall_System_Math_Atan (double);
ICALL_EXPORT double ves_icall_System_Math_Atan2 (double, double);
ICALL_EXPORT double ves_icall_System_Math_Atanh (double);
ICALL_EXPORT double ves_icall_System_Math_Cbrt (double);
ICALL_EXPORT double ves_icall_System_Math_Ceiling (double);
ICALL_EXPORT double ves_icall_System_Math_Cos (double);
ICALL_EXPORT double ves_icall_System_Math_Cosh (double);
ICALL_EXPORT double ves_icall_System_Math_Exp (double);
ICALL_EXPORT double ves_icall_System_Math_FMod (double, double);
ICALL_EXPORT double ves_icall_System_Math_Floor (double);
ICALL_EXPORT double ves_icall_System_Math_Log (double);
ICALL_EXPORT double ves_icall_System_Math_Log10 (double);
ICALL_EXPORT double ves_icall_System_Math_ModF (double, double*);
ICALL_EXPORT double ves_icall_System_Math_Pow (double, double);
ICALL_EXPORT double ves_icall_System_Math_Round (double);
ICALL_EXPORT double ves_icall_System_Math_Sin (double);
ICALL_EXPORT double ves_icall_System_Math_Sinh (double);
ICALL_EXPORT double ves_icall_System_Math_Sqrt (double);
ICALL_EXPORT double ves_icall_System_Math_Tan (double);
ICALL_EXPORT double ves_icall_System_Math_Tanh (double);
ICALL_EXPORT float ves_icall_System_MathF_Acos (float);
ICALL_EXPORT float ves_icall_System_MathF_Acosh (float);
ICALL_EXPORT float ves_icall_System_MathF_Asin (float);
ICALL_EXPORT float ves_icall_System_MathF_Asinh (float);
ICALL_EXPORT float ves_icall_System_MathF_Atan (float);
ICALL_EXPORT float ves_icall_System_MathF_Atan2 (float, float);
ICALL_EXPORT float ves_icall_System_MathF_Atanh (float);
ICALL_EXPORT float ves_icall_System_MathF_Cbrt (float);
ICALL_EXPORT float ves_icall_System_MathF_Ceiling (float);
ICALL_EXPORT float ves_icall_System_MathF_Cos (float);
ICALL_EXPORT float ves_icall_System_MathF_Cosh (float);
ICALL_EXPORT float ves_icall_System_MathF_Exp (float);
ICALL_EXPORT float ves_icall_System_MathF_FMod (float, float);
ICALL_EXPORT float ves_icall_System_MathF_Floor (float);
ICALL_EXPORT float ves_icall_System_MathF_Log (float);
ICALL_EXPORT float ves_icall_System_MathF_Log10 (float);
ICALL_EXPORT float ves_icall_System_MathF_ModF (float, float*);
ICALL_EXPORT float ves_icall_System_MathF_Pow (float, float);
ICALL_EXPORT float ves_icall_System_MathF_Sin (float);
ICALL_EXPORT float ves_icall_System_MathF_Sinh (float);
ICALL_EXPORT float ves_icall_System_MathF_Sqrt (float);
ICALL_EXPORT float ves_icall_System_MathF_Tan (float);
ICALL_EXPORT float ves_icall_System_MathF_Tanh (float);
ICALL_EXPORT float ves_icall_System_Math_Abs_single (float);
#if ENABLE_NETCORE
ICALL_EXPORT gint32 ves_icall_System_Math_ILogB (double);
ICALL_EXPORT double ves_icall_System_Math_Log2 (double);
ICALL_EXPORT double ves_icall_System_Math_ScaleB (double, gint32);
ICALL_EXPORT double ves_icall_System_Math_FusedMultiplyAdd (double, double, double);
ICALL_EXPORT gint32 ves_icall_System_MathF_ILogB (float);
ICALL_EXPORT float ves_icall_System_MathF_Log2 (float);
ICALL_EXPORT float ves_icall_System_MathF_ScaleB (float, gint32);
ICALL_EXPORT float ves_icall_System_MathF_FusedMultiplyAdd (float, float, float);
#endif
ICALL_EXPORT gint ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData (void);
ICALL_EXPORT gint32 ves_icall_System_Environment_get_ProcessorCount (void);
ICALL_EXPORT gint32 ves_icall_System_Environment_get_TickCount (void);
#if ENABLE_NETCORE
ICALL_EXPORT gint64 ves_icall_System_Environment_get_TickCount64 (void);
#endif
ICALL_EXPORT gint64 ves_icall_System_DateTime_GetSystemTimeAsFileTime (void);
ICALL_EXPORT gint64 ves_icall_System_Diagnostics_Process_GetProcessData (int, gint32, MonoProcessError*);
ICALL_EXPORT gint64 ves_icall_System_Diagnostics_Stopwatch_GetTimestamp (void);
ICALL_EXPORT gint64 ves_icall_System_GC_GetTotalMemory (MonoBoolean forceCollection);
ICALL_EXPORT gint64 ves_icall_System_Threading_Timer_GetTimeMonotonic (void);
ICALL_EXPORT gpointer ves_icall_System_GCHandle_GetAddrOfPinnedObject (guint32 handle);
ICALL_EXPORT int ves_icall_Interop_Sys_DoubleToString (double, char*, char*, int);
ICALL_EXPORT int ves_icall_System_Environment_get_Platform (void);
ICALL_EXPORT int ves_icall_System_GC_GetCollectionCount (int);
ICALL_EXPORT int ves_icall_System_GC_GetMaxGeneration (void);
ICALL_EXPORT gint64 ves_icall_System_GC_GetAllocatedBytesForCurrentThread (void);
ICALL_EXPORT int ves_icall_System_Threading_Thread_SystemMaxStackSize (void);
ICALL_EXPORT int ves_icall_get_method_attributes (MonoMethod* method);
ICALL_EXPORT void ves_icall_Mono_Runtime_RegisterReportingForNativeLib (const char*, const char*);
ICALL_EXPORT void ves_icall_Mono_Runtime_RegisterReportingForAllNativeLibs (void);
ICALL_EXPORT void ves_icall_System_Array_GetGenericValue_icall (MonoArray**, guint32, gpointer);
ICALL_EXPORT void ves_icall_System_Array_SetGenericValue_icall (MonoArray**, guint32, gpointer);
ICALL_EXPORT void ves_icall_System_Buffer_MemcpyInternal (gpointer dest, gconstpointer src, gint32 count);
ICALL_EXPORT void ves_icall_System_Environment_Exit (int);
ICALL_EXPORT void ves_icall_System_GCHandle_FreeHandle (guint32 handle);
ICALL_EXPORT void ves_icall_System_GC_InternalCollect (int generation);
ICALL_EXPORT void ves_icall_System_GC_RecordPressure (gint64);
ICALL_EXPORT void ves_icall_System_GC_WaitForPendingFinalizers (void);
ICALL_EXPORT void ves_icall_System_GC_GetGCMemoryInfo (gint64*, gint64*, gint64*, gint64*, gint64*);

#if !ENABLE_NETCORE
ICALL_EXPORT void ves_icall_System_IO_LogcatTextWriter_Log (const char*, gint32, const char*);
#endif
ICALL_EXPORT void ves_icall_System_NumberFormatter_GetFormatterTables (guint64 const**, gint32 const**, gunichar2 const**, gunichar2 const**, gint64 const**, gint32 const**);
#if ENABLE_NETCORE
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_Memmove (guint8*, guint8*, size_t);
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_RhBulkMoveWithWriteBarrier (guint8*, guint8*, size_t);
#else
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_Memmove (guint8*, guint8*, guint);
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_Memmove_wbarrier (guint8*, guint8*, guint, MonoType*);
#endif
#if ENABLE_NETCORE
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_ZeroMemory (guint8*, size_t);
#else
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_ZeroMemory (guint8*, guint);
#endif
ICALL_EXPORT void ves_icall_System_Runtime_RuntimeImports_ecvt_s(char*, size_t, double, int, int*, int*);

#if defined(ENABLE_MONODROID) || defined(ENABLE_MONOTOUCH) || defined(TARGET_WASM)
ICALL_EXPORT gpointer ves_icall_System_IO_Compression_DeflateStreamNative_CreateZStream (gint32 compress, MonoBoolean gzip, gpointer feeder, gpointer data);
ICALL_EXPORT gint32 ves_icall_System_IO_Compression_DeflateStreamNative_CloseZStream (gpointer stream);
ICALL_EXPORT gint32 ves_icall_System_IO_Compression_DeflateStreamNative_Flush (gpointer stream);
ICALL_EXPORT gint32 ves_icall_System_IO_Compression_DeflateStreamNative_ReadZStream (gpointer stream, gpointer buffer, gint32 length);
ICALL_EXPORT gint32 ves_icall_System_IO_Compression_DeflateStreamNative_WriteZStream (gpointer stream, gpointer buffer, gint32 length);
#endif

#if defined(ENABLE_MONODROID)
ICALL_EXPORT gpointer ves_icall_System_Net_NetworkInformation_LinuxNetworkChange_CreateNLSocket (void);
ICALL_EXPORT gint32 ves_icall_System_Net_NetworkInformation_LinuxNetworkChange_ReadEvents (gpointer sock, gpointer buffer, gint32 count, gint32 size);
ICALL_EXPORT gpointer ves_icall_System_Net_NetworkInformation_LinuxNetworkChange_CloseNLSocket (gpointer sock);
#endif

ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_CloseProcess (gpointer handle);
ICALL_EXPORT gpointer ves_icall_Microsoft_Win32_NativeMethods_GetCurrentProcess (void);
ICALL_EXPORT gint32 ves_icall_Microsoft_Win32_NativeMethods_GetCurrentProcessId (void);
ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_GetExitCodeProcess (gpointer handle, gint32 *exitcode);
ICALL_EXPORT gint32 ves_icall_Microsoft_Win32_NativeMethods_GetPriorityClass (gpointer handle);
ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_GetProcessTimes (gpointer handle, gint64 *creation_time, gint64 *exit_time, gint64 *kernel_time, gint64 *user_time);
ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_GetProcessWorkingSetSize (gpointer handle, gsize *min, gsize *max);
ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_SetPriorityClass (gpointer handle, gint32 priorityClass);
ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_SetProcessWorkingSetSize (gpointer handle, gsize min, gsize max);
ICALL_EXPORT MonoBoolean ves_icall_Microsoft_Win32_NativeMethods_TerminateProcess (gpointer handle, gint32 exitcode);
ICALL_EXPORT gint32 ves_icall_Microsoft_Win32_NativeMethods_WaitForInputIdle (gpointer handle, gint32 milliseconds);

ICALL_EXPORT MonoBoolean ves_icall_Mono_TlsProviderFactory_IsBtlsSupported (void);

ICALL_EXPORT void ves_icall_Mono_Runtime_AnnotateMicrosoftTelemetry (const char *key, const char *value);
ICALL_EXPORT void ves_icall_Mono_Runtime_DisableMicrosoftTelemetry (void);
ICALL_EXPORT int ves_icall_Mono_Runtime_CheckCrashReportingLog (const char *directory, MonoBoolean clear);
ICALL_EXPORT void ves_icall_Mono_Runtime_EnableCrashReportingLog (const char *directory);

ICALL_EXPORT void ves_icall_System_Array_InternalCreate (MonoArray *volatile* result, MonoType* type, gint32 rank, gint32* pLengths, gint32* pLowerBounds);
ICALL_EXPORT MonoBoolean ves_icall_System_Array_CanChangePrimitive (MonoReflectionType *volatile* ref_src_type_handle, MonoReflectionType *volatile* ref_dst_type_handle, MonoBoolean reliable);

ICALL_EXPORT MonoBoolean ves_icall_System_Diagnostics_Debugger_IsAttached_internal (void);
ICALL_EXPORT MonoBoolean ves_icall_System_Diagnostics_Debugger_IsLogging (void);
ICALL_EXPORT void ves_icall_System_Diagnostics_Debugger_Log (int level, MonoString *volatile* category, MonoString *volatile* message);

ICALL_EXPORT void ves_icall_Mono_RuntimeGPtrArrayHandle_GPtrArrayFree (GPtrArray *ptr_array);
ICALL_EXPORT void ves_icall_Mono_RuntimeMarshal_FreeAssemblyName (MonoAssemblyName *aname, MonoBoolean free_struct);
ICALL_EXPORT void ves_icall_Mono_SafeStringMarshal_GFree (void *c_str);
ICALL_EXPORT char* ves_icall_Mono_SafeStringMarshal_StringToUtf8 (MonoString *volatile* s);
ICALL_EXPORT MonoType* ves_icall_Mono_RuntimeClassHandle_GetTypeFromClass (MonoClass *klass);

ICALL_EXPORT MonoBoolean ves_icall_Mono_Security_Cryptography_KeyPairPersistence_CanSecure (const gunichar2*);
ICALL_EXPORT MonoBoolean ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsMachineProtected (const gunichar2*);
ICALL_EXPORT MonoBoolean ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsUserProtected (const gunichar2*);
ICALL_EXPORT MonoBoolean ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectMachine (const gunichar2*);
ICALL_EXPORT MonoBoolean ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectUser (const gunichar2*);
ICALL_EXPORT void ves_icall_Mono_Interop_ComInteropProxy_AddProxy  (gpointer pUnk, MonoComInteropProxy *volatile* proxy_handle);
ICALL_EXPORT void ves_icall_Mono_Interop_ComInteropProxy_FindProxy (gpointer pUnk, MonoComInteropProxy *volatile* proxy_handle);

ICALL_EXPORT gpointer    ves_icall_System_Net_Sockets_Socket_Accept_icall (gsize, gint32*, MonoBoolean);
ICALL_EXPORT gint32      ves_icall_System_Net_Sockets_Socket_Available_icall (gsize, gint32*);
ICALL_EXPORT void        ves_icall_System_Net_Sockets_Socket_Blocking_icall (gsize sock, MonoBoolean block, gint32 *werror);
ICALL_EXPORT void        ves_icall_System_Net_Sockets_Socket_Close_icall (gsize sock, gint32 *werror);
ICALL_EXPORT void        ves_icall_System_Net_Sockets_Socket_Disconnect_icall (gsize sock, MonoBoolean reuse, gint32 *werror);
ICALL_EXPORT MonoBoolean ves_icall_System_Net_Sockets_Socket_Duplicate_icall (gpointer handle, gint32 targetProcessId, gpointer *duplicate_handle, gint32 *werror);
ICALL_EXPORT void        ves_icall_System_Net_Sockets_Socket_Listen_icall (gsize sock, guint32 backlog, gint32 *werror);
ICALL_EXPORT MonoBoolean ves_icall_System_Net_Sockets_Socket_Poll_icall (gsize sock, gint mode, gint timeout, gint32 *werror);
ICALL_EXPORT gint32      ves_icall_System_Net_Sockets_Socket_Receive_icall (gsize sock, gchar *buffer, gint32 count, gint32 flags, gint32 *werror, MonoBoolean blocking);
ICALL_EXPORT gint32      ves_icall_System_Net_Sockets_Socket_Receive_array_icall (gsize sock, WSABUF *buffers, gint32 count, gint32 flags, gint32 *werror, MonoBoolean blocking);
ICALL_EXPORT gint32      ves_icall_System_Net_Sockets_Socket_Send_icall (gsize sock, gchar *buffer, gint32 count, gint32 flags, gint32 *werror, MonoBoolean blocking);
ICALL_EXPORT gint32      ves_icall_System_Net_Sockets_Socket_Send_array_icall (gsize sock, WSABUF *buffers, gint32 count, gint32 flags, gint32 *werror, MonoBoolean blocking);
ICALL_EXPORT void        ves_icall_System_Net_Sockets_Socket_Shutdown_icall (gsize sock, gint32 how, gint32 *werror);
ICALL_EXPORT MonoBoolean ves_icall_System_Net_Sockets_Socket_SupportPortReuse_icall (MonoProtocolType proto);

ICALL_EXPORT gpointer   ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMem		(int);
ICALL_EXPORT gpointer   ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMemSize	(gsize);
ICALL_EXPORT gpointer   ves_icall_System_Runtime_InteropServices_Marshal_AllocHGlobal		(gsize);
ICALL_EXPORT gpointer   ves_icall_System_Runtime_InteropServices_Marshal_ReAllocCoTaskMem	(gpointer ptr, int size);
ICALL_EXPORT gpointer   ves_icall_System_Runtime_InteropServices_Marshal_ReAllocHGlobal		(gpointer, gsize);
ICALL_EXPORT      char* ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalAnsi    (const gunichar2*, int);
ICALL_EXPORT gunichar2*	ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalUni	(const gunichar2*, int);

ICALL_EXPORT gpointer    ves_icall_System_Threading_Semaphore_CreateSemaphore_icall     (gint32 initialCount, gint32 maximumCount, const gunichar2 *name, gint32 name_length, gint32 *win32error);
ICALL_EXPORT gpointer    ves_icall_System_Threading_Semaphore_OpenSemaphore_icall       (const gunichar2 *name, gint32 name_length, gint32 rights, gint32 *win32error);
ICALL_EXPORT MonoBoolean ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal (gpointer handle, gint32 releaseCount, gint32 *prevcount);

#endif // __MONO_METADATA_ICALL_DECL_H__

```

`Hazel/vendor/mono/include/mono/metadata/icall-def-netcore.h`:

```h
ICALL_TYPE(SAFEWAITHANDLE, "Microsoft.Win32.SafeHandles.SafeWaitHandle", SAFEWAITHANDLE_1) // && UNIX
NOHANDLES(ICALL(SAFEWAITHANDLE_1, "CloseEventInternal", ves_icall_System_Threading_Events_CloseEvent_internal))

ICALL_TYPE(RUNTIME, "Mono.Runtime", RUNTIME_20)
NOHANDLES(ICALL(RUNTIME_20, "AnnotateMicrosoftTelemetry_internal", ves_icall_Mono_Runtime_AnnotateMicrosoftTelemetry))
NOHANDLES(ICALL(RUNTIME_19, "CheckCrashReportLog_internal", ves_icall_Mono_Runtime_CheckCrashReportingLog))
NOHANDLES(ICALL(RUNTIME_1, "DisableMicrosoftTelemetry", ves_icall_Mono_Runtime_DisableMicrosoftTelemetry))
HANDLES(RUNTIME_15, "DumpStateSingle_internal", ves_icall_Mono_Runtime_DumpStateSingle, MonoString, 2, (guint64_ref, guint64_ref))
HANDLES(RUNTIME_16, "DumpStateTotal_internal", ves_icall_Mono_Runtime_DumpStateTotal, MonoString, 2, (guint64_ref, guint64_ref))
NOHANDLES(ICALL(RUNTIME_18, "EnableCrashReportLog_internal", ves_icall_Mono_Runtime_EnableCrashReportingLog))
HANDLES(RUNTIME_2, "EnableMicrosoftTelemetry_internal", ves_icall_Mono_Runtime_EnableMicrosoftTelemetry, void, 6, (const_char_ptr, const_char_ptr, const_char_ptr, const_char_ptr, const_char_ptr, const_char_ptr))
HANDLES(RUNTIME_3, "ExceptionToState_internal", ves_icall_Mono_Runtime_ExceptionToState, MonoString, 3, (MonoException, guint64_ref, guint64_ref))
HANDLES(RUNTIME_4, "GetDisplayName", ves_icall_Mono_Runtime_GetDisplayName, MonoString, 0, ())
HANDLES(RUNTIME_12, "GetNativeStackTrace", ves_icall_Mono_Runtime_GetNativeStackTrace, MonoString, 1, (MonoException))
NOHANDLES(ICALL(RUNTIME_21, "RegisterReportingForAllNativeLibs_internal", ves_icall_Mono_Runtime_RegisterReportingForAllNativeLibs))
NOHANDLES(ICALL(RUNTIME_17, "RegisterReportingForNativeLib_internal", ves_icall_Mono_Runtime_RegisterReportingForNativeLib))
HANDLES(RUNTIME_13, "SendMicrosoftTelemetry_internal", ves_icall_Mono_Runtime_SendMicrosoftTelemetry, void, 3, (const_char_ptr, guint64, guint64))
HANDLES(RUNTIME_14, "WriteStateToFile_internal", ves_icall_Mono_Runtime_DumpTelemetry, void, 3, (const_char_ptr, guint64, guint64))

ICALL_TYPE(RTCLASS, "Mono.RuntimeClassHandle", RTCLASS_1)
NOHANDLES(ICALL(RTCLASS_1, "GetTypeFromClass", ves_icall_Mono_RuntimeClassHandle_GetTypeFromClass))

ICALL_TYPE(RTPTRARRAY, "Mono.RuntimeGPtrArrayHandle", RTPTRARRAY_1)
NOHANDLES(ICALL(RTPTRARRAY_1, "GPtrArrayFree", ves_icall_Mono_RuntimeGPtrArrayHandle_GPtrArrayFree))

ICALL_TYPE(RTMARSHAL, "Mono.RuntimeMarshal", RTMARSHAL_1)
NOHANDLES(ICALL(RTMARSHAL_1, "FreeAssemblyName", ves_icall_Mono_RuntimeMarshal_FreeAssemblyName))

ICALL_TYPE(SAFESTRMARSHAL, "Mono.SafeStringMarshal", SAFESTRMARSHAL_1)
NOHANDLES(ICALL(SAFESTRMARSHAL_1, "GFree", ves_icall_Mono_SafeStringMarshal_GFree))
NOHANDLES(ICALL(SAFESTRMARSHAL_2, "StringToUtf8_icall", ves_icall_Mono_SafeStringMarshal_StringToUtf8))

ICALL_TYPE(ARGI, "System.ArgIterator", ARGI_1)
NOHANDLES(ICALL(ARGI_1, "IntGetNextArg",         ves_icall_System_ArgIterator_IntGetNextArg))
NOHANDLES(ICALL(ARGI_2, "IntGetNextArgType",     ves_icall_System_ArgIterator_IntGetNextArgType))
NOHANDLES(ICALL(ARGI_3, "IntGetNextArgWithType", ves_icall_System_ArgIterator_IntGetNextArgWithType))
NOHANDLES(ICALL(ARGI_4, "Setup",                 ves_icall_System_ArgIterator_Setup))

ICALL_TYPE(ARRAY, "System.Array", ARRAY_0)
NOHANDLES(ICALL(ARRAY_0, "CanChangePrimitive", ves_icall_System_Array_CanChangePrimitive))
HANDLES(ARRAY_4, "FastCopy",         ves_icall_System_Array_FastCopy, MonoBoolean, 5, (MonoArray, int, MonoArray, int, int))
HANDLES(ARRAY_4a, "GetCorElementTypeOfElementType", ves_icall_System_Array_GetCorElementTypeOfElementType, gint32, 1, (MonoArray))
NOHANDLES(ICALL(ARRAY_5, "GetGenericValue_icall", ves_icall_System_Array_GetGenericValue_icall))
HANDLES(ARRAY_6, "GetLength",        ves_icall_System_Array_GetLength, gint32, 2, (MonoArray, gint32))
HANDLES(ARRAY_7, "GetLowerBound",    ves_icall_System_Array_GetLowerBound, gint32, 2, (MonoArray, gint32))
HANDLES(ARRAY_9, "GetValue",         ves_icall_System_Array_GetValue, MonoObject, 2, (MonoArray, MonoArray))
HANDLES(ARRAY_10, "GetValueImpl",    ves_icall_System_Array_GetValueImpl, MonoObject, 2, (MonoArray, guint32))
NOHANDLES(ICALL(ARRAY_10a, "InternalCreate", ves_icall_System_Array_InternalCreate))
HANDLES(ARRAY_10b, "IsValueOfElementType", ves_icall_System_Array_IsValueOfElementType, gint32, 2, (MonoArray, MonoObject))
NOHANDLES(ICALL(ARRAY_11, "SetGenericValue_icall", ves_icall_System_Array_SetGenericValue_icall))
HANDLES(ARRAY_12, "SetValue",         ves_icall_System_Array_SetValue, void, 3, (MonoArray, MonoObject, MonoArray))
HANDLES(ARRAY_13, "SetValueImpl",  ves_icall_System_Array_SetValueImpl, void, 3, (MonoArray, MonoObject, guint32))
HANDLES(ARRAY_14, "SetValueRelaxedImpl",  ves_icall_System_Array_SetValueRelaxedImpl, void, 3, (MonoArray, MonoObject, guint32))

ICALL_TYPE(BUFFER, "System.Buffer", BUFFER_0)
NOHANDLES(ICALL(BUFFER_0, "BulkMoveWithWriteBarrier", ves_icall_System_Runtime_RuntimeImports_RhBulkMoveWithWriteBarrier))
NOHANDLES(ICALL(BUFFER_2, "__Memmove", ves_icall_System_Runtime_RuntimeImports_Memmove))
NOHANDLES(ICALL(BUFFER_3, "__ZeroMemory", ves_icall_System_Runtime_RuntimeImports_ZeroMemory))

ICALL_TYPE(DELEGATE, "System.Delegate", DELEGATE_1)
HANDLES(DELEGATE_1, "AllocDelegateLike_internal", ves_icall_System_Delegate_AllocDelegateLike_internal, MonoMulticastDelegate, 1, (MonoDelegate))
HANDLES(DELEGATE_2, "CreateDelegate_internal", ves_icall_System_Delegate_CreateDelegate_internal, MonoObject, 4, (MonoReflectionType, MonoObject, MonoReflectionMethod, MonoBoolean))
HANDLES(DELEGATE_3, "GetVirtualMethod_internal", ves_icall_System_Delegate_GetVirtualMethod_internal, MonoReflectionMethod, 1, (MonoDelegate))

ICALL_TYPE(DEBUGR, "System.Diagnostics.Debugger", DEBUGR_1)
NOHANDLES(ICALL(DEBUGR_1, "IsAttached_internal", ves_icall_System_Diagnostics_Debugger_IsAttached_internal))
NOHANDLES(ICALL(DEBUGR_2, "IsLogging", ves_icall_System_Diagnostics_Debugger_IsLogging))
NOHANDLES(ICALL(DEBUGR_3, "Log_icall", ves_icall_System_Diagnostics_Debugger_Log))

ICALL_TYPE(ENUM, "System.Enum", ENUM_1)
HANDLES(ENUM_1, "GetEnumValuesAndNames", ves_icall_System_Enum_GetEnumValuesAndNames, MonoBoolean, 3, (MonoReflectionType, MonoArrayOut, MonoArrayOut))
HANDLES(ENUM_2, "InternalBoxEnum", ves_icall_System_Enum_ToObject, MonoObject, 2, (MonoReflectionType, guint64))
HANDLES(ENUM_3, "InternalGetCorElementType", ves_icall_System_Enum_InternalGetCorElementType, int, 1, (MonoObject))
HANDLES(ENUM_4, "InternalGetUnderlyingType", ves_icall_System_Enum_get_underlying_type, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(ENUM_5, "InternalHasFlag", ves_icall_System_Enum_InternalHasFlag, MonoBoolean, 2, (MonoObject, MonoObject))

ICALL_TYPE(ENV, "System.Environment", ENV_1)
NOHANDLES(ICALL(ENV_1, "Exit", ves_icall_System_Environment_Exit))
HANDLES(ENV_1a, "FailFast", ves_icall_System_Environment_FailFast, void, 3, (MonoString, MonoException, MonoString))
HANDLES(ENV_2, "GetCommandLineArgs", ves_icall_System_Environment_GetCommandLineArgs, MonoArray, 0, ())
HANDLES(ENV_3, "GetEnvironmentVariableNames", ves_icall_System_Environment_GetEnvironmentVariableNames, MonoArray, 0, ())
NOHANDLES(ICALL(ENV_4, "GetProcessorCount", ves_icall_System_Environment_get_ProcessorCount))
NOHANDLES(ICALL(ENV_9, "get_ExitCode", mono_environment_exitcode_get))
HANDLES(ENV_11, "get_MachineName", ves_icall_System_Environment_get_MachineName, MonoString, 0, ())
NOHANDLES(ICALL(ENV_13, "get_Platform", ves_icall_System_Environment_get_Platform))
NOHANDLES(ICALL(ENV_15, "get_TickCount", ves_icall_System_Environment_get_TickCount))
NOHANDLES(ICALL(ENV_15a, "get_TickCount64", ves_icall_System_Environment_get_TickCount64))
HANDLES(ENV_16, "get_UserName", ves_icall_System_Environment_get_UserName, MonoString, 0, ())
HANDLES(ENV_17, "internalGetEnvironmentVariable_native", ves_icall_System_Environment_GetEnvironmentVariable_native, MonoString, 1, (const_char_ptr))
NOHANDLES(ICALL(ENV_20, "set_ExitCode", mono_environment_exitcode_set))

ICALL_TYPE(GC, "System.GC", GC_10)
NOHANDLES(ICALL(GC_10, "GetAllocatedBytesForCurrentThread", ves_icall_System_GC_GetAllocatedBytesForCurrentThread))
NOHANDLES(ICALL(GC_0, "GetCollectionCount", ves_icall_System_GC_GetCollectionCount))
HANDLES(GC_0a, "GetGeneration", ves_icall_System_GC_GetGeneration, int, 1, (MonoObject))
NOHANDLES(ICALL(GC_0b, "GetMaxGeneration", ves_icall_System_GC_GetMaxGeneration))
HANDLES(GC_11, "GetTotalAllocatedBytes", ves_icall_System_GC_GetTotalAllocatedBytes, guint64, 1, (MonoBoolean))
NOHANDLES(ICALL(GC_1, "GetTotalMemory", ves_icall_System_GC_GetTotalMemory))
NOHANDLES(ICALL(GC_2, "InternalCollect", ves_icall_System_GC_InternalCollect))
NOHANDLES(ICALL(GC_4a, "RecordPressure", ves_icall_System_GC_RecordPressure))
NOHANDLES(ICALL(GC_6, "WaitForPendingFinalizers", ves_icall_System_GC_WaitForPendingFinalizers))
NOHANDLES(ICALL(GC_12, "_GetGCMemoryInfo", ves_icall_System_GC_GetGCMemoryInfo))
HANDLES(GC_6b, "_ReRegisterForFinalize", ves_icall_System_GC_ReRegisterForFinalize, void, 1, (MonoObject))
HANDLES(GC_7, "_SuppressFinalize", ves_icall_System_GC_SuppressFinalize, void, 1, (MonoObject))
HANDLES(GC_9, "get_ephemeron_tombstone", ves_icall_System_GC_get_ephemeron_tombstone, MonoObject, 0, ())
HANDLES(GC_8, "register_ephemeron_array", ves_icall_System_GC_register_ephemeron_array, void, 1, (MonoObject))

ICALL_TYPE(STREAM, "System.IO.Stream", STREAM_1)
HANDLES(STREAM_1, "HasOverriddenBeginEndRead", ves_icall_System_IO_Stream_HasOverriddenBeginEndRead, MonoBoolean, 1, (MonoObject))
HANDLES(STREAM_2, "HasOverriddenBeginEndWrite", ves_icall_System_IO_Stream_HasOverriddenBeginEndWrite, MonoBoolean, 1, (MonoObject))

ICALL_TYPE(MATH, "System.Math", MATH_19)
NOHANDLES(ICALL(MATH_19, "Abs(double)", ves_icall_System_Math_Abs_double))
NOHANDLES(ICALL(MATH_20, "Abs(single)", ves_icall_System_Math_Abs_single))
NOHANDLES(ICALL(MATH_1, "Acos", ves_icall_System_Math_Acos))
NOHANDLES(ICALL(MATH_1a, "Acosh", ves_icall_System_Math_Acosh))
NOHANDLES(ICALL(MATH_2, "Asin", ves_icall_System_Math_Asin))
NOHANDLES(ICALL(MATH_2a, "Asinh", ves_icall_System_Math_Asinh))
NOHANDLES(ICALL(MATH_3, "Atan", ves_icall_System_Math_Atan))
NOHANDLES(ICALL(MATH_4, "Atan2", ves_icall_System_Math_Atan2))
NOHANDLES(ICALL(MATH_4a, "Atanh", ves_icall_System_Math_Atanh))
NOHANDLES(ICALL(MATH_4b, "Cbrt", ves_icall_System_Math_Cbrt))
NOHANDLES(ICALL(MATH_21, "Ceiling", ves_icall_System_Math_Ceiling))
NOHANDLES(ICALL(MATH_5, "Cos", ves_icall_System_Math_Cos))
NOHANDLES(ICALL(MATH_6, "Cosh", ves_icall_System_Math_Cosh))
NOHANDLES(ICALL(MATH_7, "Exp", ves_icall_System_Math_Exp))
NOHANDLES(ICALL(MATH_7a, "FMod", ves_icall_System_Math_FMod))
NOHANDLES(ICALL(MATH_8, "Floor", ves_icall_System_Math_Floor))
NOHANDLES(ICALL(MATH_22, "FusedMultiplyAdd", ves_icall_System_Math_FusedMultiplyAdd))
NOHANDLES(ICALL(MATH_23, "ILogB", ves_icall_System_Math_ILogB))
NOHANDLES(ICALL(MATH_9, "Log", ves_icall_System_Math_Log))
NOHANDLES(ICALL(MATH_10, "Log10", ves_icall_System_Math_Log10))
NOHANDLES(ICALL(MATH_24, "Log2", ves_icall_System_Math_Log2))
NOHANDLES(ICALL(MATH_10a, "ModF", ves_icall_System_Math_ModF))
NOHANDLES(ICALL(MATH_11, "Pow", ves_icall_System_Math_Pow))
NOHANDLES(ICALL(MATH_12, "Round", ves_icall_System_Math_Round))
NOHANDLES(ICALL(MATH_25, "ScaleB", ves_icall_System_Math_ScaleB))
NOHANDLES(ICALL(MATH_14, "Sin", ves_icall_System_Math_Sin))
NOHANDLES(ICALL(MATH_15, "Sinh", ves_icall_System_Math_Sinh))
NOHANDLES(ICALL(MATH_16, "Sqrt", ves_icall_System_Math_Sqrt))
NOHANDLES(ICALL(MATH_17, "Tan", ves_icall_System_Math_Tan))
NOHANDLES(ICALL(MATH_18, "Tanh", ves_icall_System_Math_Tanh))

ICALL_TYPE(MATHF, "System.MathF", MATHF_1)
NOHANDLES(ICALL(MATHF_1, "Acos", ves_icall_System_MathF_Acos))
NOHANDLES(ICALL(MATHF_2, "Acosh", ves_icall_System_MathF_Acosh))
NOHANDLES(ICALL(MATHF_3, "Asin", ves_icall_System_MathF_Asin))
NOHANDLES(ICALL(MATHF_4, "Asinh", ves_icall_System_MathF_Asinh))
NOHANDLES(ICALL(MATHF_5, "Atan", ves_icall_System_MathF_Atan))
NOHANDLES(ICALL(MATHF_6, "Atan2", ves_icall_System_MathF_Atan2))
NOHANDLES(ICALL(MATHF_7, "Atanh", ves_icall_System_MathF_Atanh))
NOHANDLES(ICALL(MATHF_8, "Cbrt", ves_icall_System_MathF_Cbrt))
NOHANDLES(ICALL(MATHF_9, "Ceiling", ves_icall_System_MathF_Ceiling))
NOHANDLES(ICALL(MATHF_10, "Cos", ves_icall_System_MathF_Cos))
NOHANDLES(ICALL(MATHF_11, "Cosh", ves_icall_System_MathF_Cosh))
NOHANDLES(ICALL(MATHF_12, "Exp", ves_icall_System_MathF_Exp))
NOHANDLES(ICALL(MATHF_22, "FMod", ves_icall_System_MathF_FMod))
NOHANDLES(ICALL(MATHF_13, "Floor", ves_icall_System_MathF_Floor))
NOHANDLES(ICALL(MATHF_24, "FusedMultiplyAdd", ves_icall_System_MathF_FusedMultiplyAdd))
NOHANDLES(ICALL(MATHF_25, "ILogB", ves_icall_System_MathF_ILogB))
NOHANDLES(ICALL(MATHF_14, "Log", ves_icall_System_MathF_Log))
NOHANDLES(ICALL(MATHF_15, "Log10", ves_icall_System_MathF_Log10))
NOHANDLES(ICALL(MATHF_26, "Log2", ves_icall_System_MathF_Log2))
NOHANDLES(ICALL(MATHF_23, "ModF(single,single*)", ves_icall_System_MathF_ModF))
NOHANDLES(ICALL(MATHF_16, "Pow", ves_icall_System_MathF_Pow))
NOHANDLES(ICALL(MATHF_27, "ScaleB", ves_icall_System_MathF_ScaleB))
NOHANDLES(ICALL(MATHF_17, "Sin", ves_icall_System_MathF_Sin))
NOHANDLES(ICALL(MATHF_18, "Sinh", ves_icall_System_MathF_Sinh))
NOHANDLES(ICALL(MATHF_19, "Sqrt", ves_icall_System_MathF_Sqrt))
NOHANDLES(ICALL(MATHF_20, "Tan", ves_icall_System_MathF_Tan))
NOHANDLES(ICALL(MATHF_21, "Tanh", ves_icall_System_MathF_Tanh))

ICALL_TYPE(OBJ, "System.Object", OBJ_3)
HANDLES(OBJ_3, "MemberwiseClone", ves_icall_System_Object_MemberwiseClone, MonoObject, 1, (MonoObject))

ICALL_TYPE(ASSEM, "System.Reflection.Assembly", ASSEM_2)
HANDLES(ASSEM_2, "GetCallingAssembly", ves_icall_System_Reflection_Assembly_GetCallingAssembly, MonoReflectionAssembly, 0, ())
HANDLES(ASSEM_3, "GetEntryAssemblyNative", ves_icall_System_Reflection_Assembly_GetEntryAssembly, MonoReflectionAssembly, 0, ())
HANDLES(ASSEM_4, "GetExecutingAssembly", ves_icall_System_Reflection_Assembly_GetExecutingAssembly, MonoReflectionAssembly, 1, (MonoStackCrawlMark_ptr))
HANDLES(ASSEM_5, "InternalGetAssemblyName", ves_icall_System_Reflection_Assembly_InternalGetAssemblyName, void, 3, (MonoString, MonoAssemblyName_ref, MonoStringOut))
HANDLES(ASSEM_6, "InternalGetType", ves_icall_System_Reflection_Assembly_InternalGetType, MonoReflectionType, 5, (MonoReflectionAssembly, MonoReflectionModule, MonoString, MonoBoolean, MonoBoolean))
HANDLES(ASSEM_7, "InternalLoad", ves_icall_System_Reflection_Assembly_InternalLoad, MonoReflectionAssembly, 3, (MonoString, MonoStackCrawlMark_ptr, gpointer))

ICALL_TYPE(ASSEMN, "System.Reflection.AssemblyName", ASSEMN_0)
NOHANDLES(ICALL(ASSEMN_0, "GetNativeName", ves_icall_System_Reflection_AssemblyName_GetNativeName))
NOHANDLES(ICALL(ASSEMN_3, "ParseAssemblyName", ves_icall_System_Reflection_AssemblyName_ParseAssemblyName))
NOHANDLES(ICALL(ASSEMN_2, "get_public_token", mono_digest_get_public_token))

ICALL_TYPE(MCATTR, "System.Reflection.CustomAttribute", MCATTR_1)
HANDLES(MCATTR_1, "GetCustomAttributesDataInternal", ves_icall_MonoCustomAttrs_GetCustomAttributesDataInternal, MonoArray, 1, (MonoObject))
HANDLES(MCATTR_2, "GetCustomAttributesInternal", ves_icall_MonoCustomAttrs_GetCustomAttributesInternal, MonoArray, 3, (MonoObject, MonoReflectionType, MonoBoolean))
HANDLES(MCATTR_3, "IsDefinedInternal", ves_icall_MonoCustomAttrs_IsDefinedInternal, MonoBoolean, 2, (MonoObject, MonoReflectionType))

ICALL_TYPE(CATTR_DATA, "System.Reflection.CustomAttributeData", CATTR_DATA_1)
HANDLES(CATTR_DATA_1, "ResolveArgumentsInternal", ves_icall_System_Reflection_CustomAttributeData_ResolveArgumentsInternal, void, 6, (MonoReflectionMethod, MonoReflectionAssembly, gpointer, guint32, MonoArrayOut, MonoArrayOut))

ICALL_TYPE(ASSEMB, "System.Reflection.Emit.AssemblyBuilder", ASSEMB_1)
HANDLES(ASSEMB_1, "UpdateNativeCustomAttributes", ves_icall_AssemblyBuilder_UpdateNativeCustomAttributes, void, 1, (MonoReflectionAssemblyBuilder))
HANDLES(ASSEMB_2, "basic_init", ves_icall_AssemblyBuilder_basic_init, void, 1, (MonoReflectionAssemblyBuilder))

ICALL_TYPE(CATTRB, "System.Reflection.Emit.CustomAttributeBuilder", CATTRB_1)
HANDLES(CATTRB_1, "GetBlob", ves_icall_CustomAttributeBuilder_GetBlob, MonoArray, 7, (MonoReflectionAssembly, MonoObject, MonoArray, MonoArray, MonoArray, MonoArray, MonoArray))

ICALL_TYPE(DYNM, "System.Reflection.Emit.DynamicMethod", DYNM_1)
HANDLES(DYNM_1, "create_dynamic_method", ves_icall_DynamicMethod_create_dynamic_method, void, 1, (MonoReflectionDynamicMethod))

ICALL_TYPE(ENUMB, "System.Reflection.Emit.EnumBuilder", ENUMB_1)
HANDLES(ENUMB_1, "setup_enum_type", ves_icall_EnumBuilder_setup_enum_type, void, 2, (MonoReflectionType, MonoReflectionType))

ICALL_TYPE(MODULEB, "System.Reflection.Emit.ModuleBuilder", MODULEB_10)
HANDLES(MODULEB_10, "GetRegisteredToken", ves_icall_ModuleBuilder_GetRegisteredToken, MonoObject, 2, (MonoReflectionModuleBuilder, guint32))
HANDLES(MODULEB_8, "RegisterToken", ves_icall_ModuleBuilder_RegisterToken, void, 3, (MonoReflectionModuleBuilder, MonoObject, guint32))
HANDLES(MODULEB_2, "basic_init", ves_icall_ModuleBuilder_basic_init, void, 1, (MonoReflectionModuleBuilder))
HANDLES(MODULEB_5, "getMethodToken", ves_icall_ModuleBuilder_getMethodToken, gint32, 3, (MonoReflectionModuleBuilder, MonoReflectionMethod, MonoArray))
HANDLES(MODULEB_6, "getToken", ves_icall_ModuleBuilder_getToken, gint32, 3, (MonoReflectionModuleBuilder, MonoObject, MonoBoolean))
HANDLES(MODULEB_7, "getUSIndex", ves_icall_ModuleBuilder_getUSIndex, guint32, 2, (MonoReflectionModuleBuilder, MonoString))
HANDLES(MODULEB_9, "set_wrappers_type", ves_icall_ModuleBuilder_set_wrappers_type, void, 2, (MonoReflectionModuleBuilder, MonoReflectionType))

ICALL_TYPE(SIGH, "System.Reflection.Emit.SignatureHelper", SIGH_1)
HANDLES(SIGH_1, "get_signature_field", ves_icall_SignatureHelper_get_signature_field, MonoArray, 1, (MonoReflectionSigHelper))
HANDLES(SIGH_2, "get_signature_local", ves_icall_SignatureHelper_get_signature_local, MonoArray, 1, (MonoReflectionSigHelper))

ICALL_TYPE(TYPEB, "System.Reflection.Emit.TypeBuilder", TYPEB_1)
HANDLES(TYPEB_1, "create_runtime_class", ves_icall_TypeBuilder_create_runtime_class, MonoReflectionType, 1, (MonoReflectionTypeBuilder))

ICALL_TYPE(FIELDI, "System.Reflection.FieldInfo", FILEDI_1)
HANDLES(FILEDI_1, "get_marshal_info", ves_icall_System_Reflection_FieldInfo_get_marshal_info, MonoReflectionMarshalAsAttribute, 1, (MonoReflectionField))

HANDLES(FILEDI_2, "internal_from_handle_type", ves_icall_System_Reflection_FieldInfo_internal_from_handle_type, MonoReflectionField, 2, (MonoClassField_ref, MonoType_ref))

ICALL_TYPE(MBASE, "System.Reflection.MethodBase", MBASE_1)
HANDLES(MBASE_1, "GetCurrentMethod", ves_icall_GetCurrentMethod, MonoReflectionMethod, 0, ())

ICALL_TYPE(MMETHI, "System.Reflection.MonoMethodInfo", MMETHI_4)
NOHANDLES(ICALL(MMETHI_4, "get_method_attributes", ves_icall_get_method_attributes))
HANDLES(MMETHI_1, "get_method_info", ves_icall_get_method_info, void, 2, (MonoMethod_ptr, MonoMethodInfo_ref))
HANDLES(MMETHI_2, "get_parameter_info", ves_icall_System_Reflection_MonoMethodInfo_get_parameter_info, MonoArray, 2, (MonoMethod_ptr, MonoReflectionMethod))
HANDLES(MMETHI_3, "get_retval_marshal", ves_icall_System_MonoMethodInfo_get_retval_marshal, MonoReflectionMarshalAsAttribute, 1, (MonoMethod_ptr))

ICALL_TYPE(RASSEM, "System.Reflection.RuntimeAssembly", RASSEM_1)
HANDLES(RASSEM_1, "GetExportedTypes", ves_icall_System_Reflection_RuntimeAssembly_GetExportedTypes, MonoArray, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_1a, "GetFilesInternal", ves_icall_System_Reflection_RuntimeAssembly_GetFilesInternal, MonoObject, 3, (MonoReflectionAssembly, MonoString, MonoBoolean))
HANDLES(RASSEM_2, "GetManifestModuleInternal", ves_icall_System_Reflection_Assembly_GetManifestModuleInternal, MonoReflectionModule, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_3, "GetManifestResourceInfoInternal", ves_icall_System_Reflection_RuntimeAssembly_GetManifestResourceInfoInternal, MonoBoolean, 3, (MonoReflectionAssembly, MonoString, MonoManifestResourceInfo))
HANDLES(RASSEM_4, "GetManifestResourceInternal", ves_icall_System_Reflection_RuntimeAssembly_GetManifestResourceInternal, gpointer, 4, (MonoReflectionAssembly, MonoString, gint32_ref, MonoReflectionModuleOut))
HANDLES(RASSEM_5, "GetManifestResourceNames", ves_icall_System_Reflection_RuntimeAssembly_GetManifestResourceNames, MonoArray, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_6, "GetModulesInternal", ves_icall_System_Reflection_RuntimeAssembly_GetModulesInternal, MonoArray, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_6b, "GetTopLevelForwardedTypes", ves_icall_System_Reflection_RuntimeAssembly_GetTopLevelForwardedTypes, MonoArray, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_7, "InternalGetReferencedAssemblies", ves_icall_System_Reflection_Assembly_InternalGetReferencedAssemblies, GPtrArray_ptr, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_8, "InternalImageRuntimeVersion", ves_icall_System_Reflection_RuntimeAssembly_InternalImageRuntimeVersion, MonoString, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_9, "get_EntryPoint", ves_icall_System_Reflection_RuntimeAssembly_get_EntryPoint, MonoReflectionMethod, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_10, "get_code_base", ves_icall_System_Reflection_RuntimeAssembly_get_code_base, MonoString, 2, (MonoReflectionAssembly, MonoBoolean))
HANDLES(RASSEM_11, "get_fullname", ves_icall_System_Reflection_RuntimeAssembly_get_fullname, MonoString, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_12, "get_location", ves_icall_System_Reflection_RuntimeAssembly_get_location, MonoString, 1, (MonoReflectionAssembly))

ICALL_TYPE(MCMETH, "System.Reflection.RuntimeConstructorInfo", MCMETH_1)
HANDLES(MCMETH_1, "GetGenericMethodDefinition_impl", ves_icall_RuntimeMethodInfo_GetGenericMethodDefinition, MonoReflectionMethod, 1, (MonoReflectionMethod))
HANDLES(MCMETH_2, "InternalInvoke", ves_icall_InternalInvoke, MonoObject, 4, (MonoReflectionMethod, MonoObject, MonoArray, MonoExceptionOut))
HANDLES(MCMETH_3, "get_core_clr_security_level", ves_icall_RuntimeMethodInfo_get_core_clr_security_level, int, 1, (MonoReflectionMethod))
HANDLES_REUSE_WRAPPER(MCMETH_4, "get_metadata_token", ves_icall_reflection_get_token)

ICALL_TYPE(MEV, "System.Reflection.RuntimeEventInfo", MEV_1)
HANDLES(MEV_1, "get_event_info", ves_icall_RuntimeEventInfo_get_event_info, void, 2, (MonoReflectionMonoEvent, MonoEventInfo_ref))
HANDLES_REUSE_WRAPPER(MEV_2, "get_metadata_token", ves_icall_reflection_get_token)
HANDLES(MEV_3, "internal_from_handle_type", ves_icall_System_Reflection_EventInfo_internal_from_handle_type, MonoReflectionEvent, 2, (MonoEvent_ref, MonoType_ref))

ICALL_TYPE(MFIELD, "System.Reflection.RuntimeFieldInfo", MFIELD_1)
HANDLES(MFIELD_1, "GetFieldOffset", ves_icall_RuntimeFieldInfo_GetFieldOffset, gint32, 1, (MonoReflectionField))
HANDLES(MFIELD_2, "GetParentType", ves_icall_RuntimeFieldInfo_GetParentType, MonoReflectionType, 2, (MonoReflectionField, MonoBoolean))
HANDLES(MFIELD_3, "GetRawConstantValue", ves_icall_RuntimeFieldInfo_GetRawConstantValue, MonoObject, 1, (MonoReflectionField))
HANDLES(MFIELD_4, "GetTypeModifiers", ves_icall_System_Reflection_FieldInfo_GetTypeModifiers, MonoArray, 2, (MonoReflectionField, MonoBoolean))
HANDLES(MFIELD_5, "GetValueInternal", ves_icall_RuntimeFieldInfo_GetValueInternal, MonoObject, 2, (MonoReflectionField, MonoObject))
HANDLES(MFIELD_6, "ResolveType", ves_icall_RuntimeFieldInfo_ResolveType, MonoReflectionType, 1, (MonoReflectionField))
HANDLES(MFIELD_7, "SetValueInternal", ves_icall_RuntimeFieldInfo_SetValueInternal, void, 3, (MonoReflectionField, MonoObject, MonoObject))
HANDLES_REUSE_WRAPPER(MFIELD_8, "UnsafeGetValue", ves_icall_RuntimeFieldInfo_GetValueInternal)
HANDLES(MFIELD_9, "get_core_clr_security_level", ves_icall_RuntimeFieldInfo_get_core_clr_security_level, int, 1, (MonoReflectionField))
HANDLES_REUSE_WRAPPER(MFIELD_10, "get_metadata_token", ves_icall_reflection_get_token)

ICALL_TYPE(RMETHODINFO, "System.Reflection.RuntimeMethodInfo", RMETHODINFO_1)
HANDLES(RMETHODINFO_1, "GetGenericArguments", ves_icall_RuntimeMethodInfo_GetGenericArguments, MonoArray, 1, (MonoReflectionMethod))
HANDLES_REUSE_WRAPPER(RMETHODINFO_2, "GetGenericMethodDefinition_impl", ves_icall_RuntimeMethodInfo_GetGenericMethodDefinition)
HANDLES(RMETHODINFO_3, "GetMethodBodyInternal", ves_icall_System_Reflection_RuntimeMethodInfo_GetMethodBodyInternal, MonoReflectionMethodBody, 1, (MonoMethod_ptr))
HANDLES(RMETHODINFO_4, "GetMethodFromHandleInternalType_native", ves_icall_System_Reflection_RuntimeMethodInfo_GetMethodFromHandleInternalType_native, MonoReflectionMethod, 3, (MonoMethod_ptr, MonoType_ptr, MonoBoolean))
HANDLES(RMETHODINFO_5, "GetPInvoke", ves_icall_RuntimeMethodInfo_GetPInvoke, void, 4, (MonoReflectionMethod, int_ref, MonoStringOut, MonoStringOut))
HANDLES_REUSE_WRAPPER(RMETHODINFO_6, "InternalInvoke", ves_icall_InternalInvoke)
HANDLES(RMETHODINFO_7, "MakeGenericMethod_impl", ves_icall_RuntimeMethodInfo_MakeGenericMethod_impl, MonoReflectionMethod, 2, (MonoReflectionMethod, MonoArray))
HANDLES(RMETHODINFO_8, "get_IsGenericMethod", ves_icall_RuntimeMethodInfo_get_IsGenericMethod, MonoBoolean, 1, (MonoReflectionMethod))
HANDLES(RMETHODINFO_9, "get_IsGenericMethodDefinition", ves_icall_RuntimeMethodInfo_get_IsGenericMethodDefinition, MonoBoolean, 1, (MonoReflectionMethod))
HANDLES(RMETHODINFO_10, "get_base_method", ves_icall_RuntimeMethodInfo_get_base_method, MonoReflectionMethod, 2, (MonoReflectionMethod, MonoBoolean))
HANDLES_REUSE_WRAPPER(RMETHODINFO_11, "get_core_clr_security_level", ves_icall_RuntimeMethodInfo_get_core_clr_security_level)
HANDLES_REUSE_WRAPPER(RMETHODINFO_12, "get_metadata_token", ves_icall_reflection_get_token)
HANDLES(RMETHODINFO_13, "get_name", ves_icall_RuntimeMethodInfo_get_name, MonoString, 1, (MonoReflectionMethod))

ICALL_TYPE(MODULE, "System.Reflection.RuntimeModule", MODULE_2)
HANDLES(MODULE_2, "GetGlobalType", ves_icall_System_Reflection_RuntimeModule_GetGlobalType, MonoReflectionType, 1, (MonoImage_ptr))
HANDLES(MODULE_3, "GetGuidInternal", ves_icall_System_Reflection_RuntimeModule_GetGuidInternal, void, 2, (MonoImage_ptr, MonoArray))
HANDLES(MODULE_14, "GetHINSTANCE", ves_icall_System_Reflection_RuntimeModule_GetHINSTANCE, gpointer, 1, (MonoImage_ptr))
HANDLES(MODULE_4, "GetMDStreamVersion", ves_icall_System_Reflection_RuntimeModule_GetMDStreamVersion, gint32, 1, (MonoImage_ptr))
HANDLES(MODULE_5, "GetPEKind", ves_icall_System_Reflection_RuntimeModule_GetPEKind, void, 3, (MonoImage_ptr, gint32_ptr, gint32_ptr))
HANDLES(MODULE_6, "InternalGetTypes", ves_icall_System_Reflection_RuntimeModule_InternalGetTypes, MonoArray, 1, (MonoImage_ptr))
HANDLES(MODULE_7, "ResolveFieldToken", ves_icall_System_Reflection_RuntimeModule_ResolveFieldToken, MonoClassField_ptr, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_8, "ResolveMemberToken", ves_icall_System_Reflection_RuntimeModule_ResolveMemberToken, MonoObject, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_9, "ResolveMethodToken", ves_icall_System_Reflection_RuntimeModule_ResolveMethodToken, MonoMethod_ptr, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_10, "ResolveSignature", ves_icall_System_Reflection_RuntimeModule_ResolveSignature, MonoArray, 3, (MonoImage_ptr, guint32, MonoResolveTokenError_ref))
HANDLES(MODULE_11, "ResolveStringToken", ves_icall_System_Reflection_RuntimeModule_ResolveStringToken, MonoString, 3, (MonoImage_ptr, guint32, MonoResolveTokenError_ref))
HANDLES(MODULE_12, "ResolveTypeToken", ves_icall_System_Reflection_RuntimeModule_ResolveTypeToken, MonoType_ptr, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_13, "get_MetadataToken", ves_icall_reflection_get_token, guint32, 1, (MonoObject))

ICALL_TYPE(PARAMI, "System.Reflection.RuntimeParameterInfo", MPARAMI_1)
HANDLES_REUSE_WRAPPER(MPARAMI_1, "GetMetadataToken", ves_icall_reflection_get_token)
HANDLES(MPARAMI_2, "GetTypeModifiers", ves_icall_RuntimeParameterInfo_GetTypeModifiers, MonoArray, 4, (MonoReflectionType, MonoObject, int, MonoBoolean))

ICALL_TYPE(MPROP, "System.Reflection.RuntimePropertyInfo", MPROP_1)
HANDLES(MPROP_1, "GetTypeModifiers", ves_icall_RuntimePropertyInfo_GetTypeModifiers, MonoArray, 2, (MonoReflectionProperty, MonoBoolean))
HANDLES(MPROP_2, "get_default_value", ves_icall_property_info_get_default_value, MonoObject, 1, (MonoReflectionProperty))
HANDLES_REUSE_WRAPPER(MPROP_3, "get_metadata_token", ves_icall_reflection_get_token)
HANDLES(MPROP_4, "get_property_info", ves_icall_RuntimePropertyInfo_get_property_info, void, 3, (MonoReflectionProperty, MonoPropertyInfo_ref, PInfo))
HANDLES(MPROP_5, "internal_from_handle_type", ves_icall_System_Reflection_RuntimePropertyInfo_internal_from_handle_type, MonoReflectionProperty, 2, (MonoProperty_ptr, MonoType_ptr))

ICALL_TYPE(RUNH, "System.Runtime.CompilerServices.RuntimeHelpers", RUNH_1)
HANDLES(RUNH_1, "GetObjectValue", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetObjectValue, MonoObject, 1, (MonoObject))
HANDLES(RUNH_2, "GetUninitializedObjectInternal", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetUninitializedObjectInternal, MonoObject, 1, (MonoType_ptr))
HANDLES(RUNH_3, "InitializeArray", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray, void, 2, (MonoArray, MonoClassField_ptr))
HANDLES(RUNH_7, "InternalGetHashCode", mono_object_hash_icall, int, 1, (MonoObject))
HANDLES(RUNH_3a, "PrepareMethod", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_PrepareMethod, void, 3, (MonoMethod_ptr, gpointer, int))
HANDLES(RUNH_4, "RunClassConstructor", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunClassConstructor, void, 1, (MonoType_ptr))
HANDLES(RUNH_5, "RunModuleConstructor", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunModuleConstructor, void, 1, (MonoImage_ptr))
NOHANDLES(ICALL(RUNH_5h, "SufficientExecutionStack", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_SufficientExecutionStack))

ICALL_TYPE(GCH, "System.Runtime.InteropServices.GCHandle", GCH_1)
HANDLES(GCH_1, "InternalAlloc", ves_icall_System_GCHandle_InternalAlloc, gpointer, 2, (MonoObject, gint32))
HANDLES(GCH_2, "InternalFree", ves_icall_System_GCHandle_InternalFree, void, 1, (gpointer))
HANDLES(GCH_3, "InternalGet", ves_icall_System_GCHandle_InternalGet, MonoObject, 1, (gpointer))
HANDLES(GCH_4, "InternalSet", ves_icall_System_GCHandle_InternalSet, void, 2, (gpointer, MonoObject))

ICALL_TYPE(MARSHAL, "System.Runtime.InteropServices.Marshal", MARSHAL_2)
NOHANDLES(ICALL(MARSHAL_2, "AllocCoTaskMem", ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMem))
NOHANDLES(ICALL(MARSHAL_3, "AllocHGlobal", ves_icall_System_Runtime_InteropServices_Marshal_AllocHGlobal))
NOHANDLES(ICALL(MARSHAL_50, "BufferToBSTR", ves_icall_System_Runtime_InteropServices_Marshal_BufferToBSTR))
HANDLES(MARSHAL_4, "DestroyStructure", ves_icall_System_Runtime_InteropServices_Marshal_DestroyStructure, void, 2, (gpointer, MonoReflectionType))
NOHANDLES(ICALL(MARSHAL_5, "FreeBSTR", ves_icall_System_Runtime_InteropServices_Marshal_FreeBSTR))
NOHANDLES(ICALL(MARSHAL_6, "FreeCoTaskMem", ves_icall_System_Runtime_InteropServices_Marshal_FreeCoTaskMem))
NOHANDLES(ICALL(MARSHAL_7, "FreeHGlobal", ves_icall_System_Runtime_InteropServices_Marshal_FreeHGlobal))
HANDLES(MARSHAL_9, "GetDelegateForFunctionPointerInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointerInternal, MonoDelegate, 2, (gpointer, MonoReflectionType))
HANDLES(MARSHAL_10, "GetFunctionPointerForDelegateInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetFunctionPointerForDelegateInternal, gpointer, 1, (MonoDelegate))
NOHANDLES(ICALL(MARSHAL_11, "GetLastWin32Error", ves_icall_System_Runtime_InteropServices_Marshal_GetLastWin32Error))
HANDLES(MARSHAL_48a, "IsPinnableType", ves_icall_System_Runtime_InteropServices_Marshal_IsPinnableType, MonoBoolean, 1, (MonoReflectionType))
HANDLES(MARSHAL_12, "OffsetOf", ves_icall_System_Runtime_InteropServices_Marshal_OffsetOf, int, 2, (MonoReflectionType, MonoString))
HANDLES(MARSHAL_13, "PrelinkInternal", ves_icall_System_Runtime_InteropServices_Marshal_Prelink, void, 1, (MonoReflectionMethod))
HANDLES(MARSHAL_17, "PtrToStringBSTR", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringBSTR, MonoString, 1, (mono_bstr_const))
HANDLES(MARSHAL_20, "PtrToStructureInternal", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructureInternal, void, 3, (gconstpointer, MonoObject, MonoBoolean))
NOHANDLES(ICALL(MARSHAL_43, "ReAllocCoTaskMem", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocCoTaskMem))
NOHANDLES(ICALL(MARSHAL_23, "ReAllocHGlobal", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocHGlobal))
NOHANDLES(ICALL(MARSHAL_29a, "SetLastWin32Error", ves_icall_System_Runtime_InteropServices_Marshal_SetLastWin32Error))
HANDLES(MARSHAL_30, "SizeOf", ves_icall_System_Runtime_InteropServices_Marshal_SizeOf, guint32, 1, (MonoReflectionType))
HANDLES(MARSHAL_31, "SizeOfHelper", ves_icall_System_Runtime_InteropServices_Marshal_SizeOfHelper, guint32, 2, (MonoReflectionType, MonoBoolean))
HANDLES(MARSHAL_34, "StructureToPtr", ves_icall_System_Runtime_InteropServices_Marshal_StructureToPtr, void, 3, (MonoObject, gpointer, MonoBoolean))

ICALL_TYPE(NATIVEL, "System.Runtime.InteropServices.NativeLibrary", NATIVEL_1)
HANDLES(NATIVEL_1, "FreeLib", ves_icall_System_Runtime_InteropServices_NativeLibrary_FreeLib, void, 1, (gpointer))
HANDLES(NATIVEL_2, "GetSymbol", ves_icall_System_Runtime_InteropServices_NativeLibrary_GetSymbol, gpointer, 3, (gpointer, MonoString, MonoBoolean))
HANDLES(NATIVEL_3, "LoadByName", ves_icall_System_Runtime_InteropServices_NativeLibrary_LoadByName, gpointer, 5, (MonoString, MonoReflectionAssembly, MonoBoolean, guint32, MonoBoolean))
HANDLES(NATIVEL_4, "LoadFromPath", ves_icall_System_Runtime_InteropServices_NativeLibrary_LoadFromPath, gpointer, 2, (MonoString, MonoBoolean))

ICALL_TYPE(ALC, "System.Runtime.Loader.AssemblyLoadContext", ALC_5)
HANDLES(ALC_5, "GetLoadContextForAssembly", ves_icall_System_Runtime_Loader_AssemblyLoadContext_GetLoadContextForAssembly, gpointer, 1, (MonoReflectionAssembly))
HANDLES(ALC_4, "InternalGetLoadedAssemblies", ves_icall_System_Runtime_Loader_AssemblyLoadContext_InternalGetLoadedAssemblies, MonoArray, 0, ())
HANDLES(ALC_2, "InternalInitializeNativeALC", ves_icall_System_Runtime_Loader_AssemblyLoadContext_InternalInitializeNativeALC, gpointer, 3, (gpointer, MonoBoolean, MonoBoolean))
HANDLES(ALC_1, "InternalLoadFile", ves_icall_System_Runtime_Loader_AssemblyLoadContext_InternalLoadFile, MonoReflectionAssembly, 3, (gpointer, MonoString, MonoStackCrawlMark_ptr))
HANDLES(ALC_3, "InternalLoadFromStream", ves_icall_System_Runtime_Loader_AssemblyLoadContext_InternalLoadFromStream, MonoReflectionAssembly, 5, (gpointer, gpointer, gint32, gpointer, gint32))

ICALL_TYPE(RFH, "System.RuntimeFieldHandle", RFH_1)
HANDLES(RFH_1, "GetValueDirect", ves_icall_System_RuntimeFieldHandle_GetValueDirect, MonoObject, 4, (MonoReflectionField, MonoReflectionType, MonoTypedRef_ptr, MonoReflectionType))
HANDLES(RFH_1a, "SetValueDirect", ves_icall_System_RuntimeFieldHandle_SetValueDirect, void, 5, (MonoReflectionField, MonoReflectionType, MonoTypedRef_ptr, MonoObject, MonoReflectionType))
HANDLES_REUSE_WRAPPER(RFH_2, "SetValueInternal", ves_icall_RuntimeFieldInfo_SetValueInternal)

ICALL_TYPE(MHAN, "System.RuntimeMethodHandle", MHAN_1)
HANDLES(MHAN_1, "GetFunctionPointer", ves_icall_RuntimeMethodHandle_GetFunctionPointer, gpointer, 1, (MonoMethod_ptr))

ICALL_TYPE(RT, "System.RuntimeType", RT_1)
HANDLES(RT_1, "CreateInstanceInternal", ves_icall_System_Activator_CreateInstanceInternal, MonoObject, 1, (MonoReflectionType))
HANDLES(RT_2, "GetConstructors_native", ves_icall_RuntimeType_GetConstructors_native, GPtrArray_ptr, 2, (MonoReflectionType, guint32))
HANDLES(RT_30, "GetCorrespondingInflatedConstructor", ves_icall_RuntimeType_GetCorrespondingInflatedMethod, MonoReflectionMethod, 2, (MonoReflectionType, MonoReflectionMethod))
HANDLES_REUSE_WRAPPER(RT_31, "GetCorrespondingInflatedMethod", ves_icall_RuntimeType_GetCorrespondingInflatedMethod)
HANDLES(RT_3, "GetEvents_native", ves_icall_RuntimeType_GetEvents_native, GPtrArray_ptr, 3, (MonoReflectionType, char_ptr, guint32))
HANDLES(RT_5, "GetFields_native", ves_icall_RuntimeType_GetFields_native, GPtrArray_ptr, 4, (MonoReflectionType, char_ptr, guint32, guint32))
HANDLES(RT_6, "GetGenericArgumentsInternal", ves_icall_RuntimeType_GetGenericArguments, MonoArray, 2, (MonoReflectionType, MonoBoolean))
HANDLES(RT_9, "GetGenericParameterPosition", ves_icall_RuntimeType_GetGenericParameterPosition, gint32, 1, (MonoReflectionType))
HANDLES(RT_10, "GetInterfaceMapData", ves_icall_RuntimeType_GetInterfaceMapData, void, 4, (MonoReflectionType, MonoReflectionType, MonoArrayOut, MonoArrayOut))
HANDLES(RT_11, "GetInterfaces", ves_icall_RuntimeType_GetInterfaces, MonoArray, 1, (MonoReflectionType))
HANDLES(RT_12, "GetMethodsByName_native", ves_icall_RuntimeType_GetMethodsByName_native, GPtrArray_ptr, 4, (MonoReflectionType, const_char_ptr, guint32, guint32))
HANDLES(RT_13, "GetNestedTypes_native", ves_icall_RuntimeType_GetNestedTypes_native, GPtrArray_ptr, 4, (MonoReflectionType, char_ptr, guint32, guint32))
HANDLES(RT_14, "GetPacking", ves_icall_RuntimeType_GetPacking, void, 3, (MonoReflectionType, guint32_ref, guint32_ref))
HANDLES(RT_15, "GetPropertiesByName_native", ves_icall_RuntimeType_GetPropertiesByName_native, GPtrArray_ptr, 4, (MonoReflectionType, char_ptr, guint32, guint32))
HANDLES(RT_17, "MakeGenericType", ves_icall_RuntimeType_MakeGenericType, MonoReflectionType, 2, (MonoReflectionType, MonoArray))
HANDLES(RT_18, "MakePointerType", ves_icall_RuntimeType_MakePointerType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RT_19, "getFullName", ves_icall_System_RuntimeType_getFullName, MonoString, 3, (MonoReflectionType, MonoBoolean, MonoBoolean))
HANDLES(RT_21, "get_DeclaringMethod", ves_icall_RuntimeType_get_DeclaringMethod, MonoReflectionMethod, 1, (MonoReflectionType))
HANDLES(RT_22, "get_DeclaringType", ves_icall_RuntimeType_get_DeclaringType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RT_23, "get_Name", ves_icall_RuntimeType_get_Name, MonoString, 1, (MonoReflectionType))
HANDLES(RT_24, "get_Namespace", ves_icall_RuntimeType_get_Namespace, MonoString, 1, (MonoReflectionType))
HANDLES(RT_26, "make_array_type", ves_icall_RuntimeType_make_array_type, MonoReflectionType, 2, (MonoReflectionType, int))
HANDLES(RT_27, "make_byref_type", ves_icall_RuntimeType_make_byref_type, MonoReflectionType, 1, (MonoReflectionType))

ICALL_TYPE(RTH, "System.RuntimeTypeHandle", RTH_1)
HANDLES(RTH_1, "GetArrayRank", ves_icall_RuntimeTypeHandle_GetArrayRank, gint32, 1, (MonoReflectionType))
HANDLES(RTH_2, "GetAssembly", ves_icall_RuntimeTypeHandle_GetAssembly, MonoReflectionAssembly, 1, (MonoReflectionType))
HANDLES(RTH_3, "GetAttributes", ves_icall_RuntimeTypeHandle_GetAttributes, guint32, 1, (MonoReflectionType))
HANDLES(RTH_4, "GetBaseType", ves_icall_RuntimeTypeHandle_GetBaseType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RTH_4a, "GetCorElementType", ves_icall_RuntimeTypeHandle_GetCorElementType, guint32, 1, (MonoReflectionType))
HANDLES(RTH_5, "GetElementType", ves_icall_RuntimeTypeHandle_GetElementType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RTH_19, "GetGenericParameterInfo", ves_icall_RuntimeTypeHandle_GetGenericParameterInfo, MonoGenericParamInfo_ptr, 1, (MonoReflectionType))
HANDLES(RTH_6, "GetGenericTypeDefinition_impl", ves_icall_RuntimeTypeHandle_GetGenericTypeDefinition_impl, MonoReflectionType, 1, (MonoReflectionType))
HANDLES_REUSE_WRAPPER(RTH_7, "GetMetadataToken", ves_icall_reflection_get_token)
HANDLES(RTH_8, "GetModule", ves_icall_RuntimeTypeHandle_GetModule, MonoReflectionModule, 1, (MonoReflectionType))
HANDLES(RTH_9, "HasInstantiation", ves_icall_RuntimeTypeHandle_HasInstantiation, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_20, "HasReferences", ves_icall_RuntimeTypeHandle_HasReferences, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_21, "IsByRefLike", ves_icall_RuntimeTypeHandle_IsByRefLike, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_12, "IsComObject", ves_icall_RuntimeTypeHandle_IsComObject, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_13, "IsGenericTypeDefinition", ves_icall_RuntimeTypeHandle_IsGenericTypeDefinition, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_14, "IsGenericVariable", ves_icall_RuntimeTypeHandle_IsGenericVariable, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_15, "IsInstanceOfType", ves_icall_RuntimeTypeHandle_IsInstanceOfType, guint32, 2, (MonoReflectionType, MonoObject))
//HANDLES(RTH_17a, "is_subclass_of", ves_icall_RuntimeTypeHandle_is_subclass_of, MonoBoolean, 2, (MonoType_ptr, MonoType_ptr))
HANDLES(RTH_17a, "internal_from_name", ves_icall_System_RuntimeTypeHandle_internal_from_name, MonoReflectionType, 6, (MonoString, MonoStackCrawlMark_ptr, MonoReflectionAssembly, MonoBoolean, MonoBoolean, MonoBoolean))
NOHANDLES(ICALL(RTH_17b, "is_subclass_of", ves_icall_RuntimeTypeHandle_is_subclass_of))
HANDLES(RTH_18, "type_is_assignable_from", ves_icall_RuntimeTypeHandle_type_is_assignable_from, guint32, 2, (MonoReflectionType, MonoReflectionType))

ICALL_TYPE(STRING, "System.String", STRING_1)
NOHANDLES(ICALL(STRING_1, ".ctor(System.ReadOnlySpan`1<char>)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_1a, ".ctor(char*)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_2, ".ctor(char*,int,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_3, ".ctor(char,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_4, ".ctor(char[])", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_5, ".ctor(char[],int,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_6, ".ctor(sbyte*)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_7, ".ctor(sbyte*,int,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_8, ".ctor(sbyte*,int,int,System.Text.Encoding)", ves_icall_System_String_ctor_RedirectToCreateString))
HANDLES(STRING_9, "FastAllocateString", ves_icall_System_String_FastAllocateString, MonoString, 1, (gint32))
HANDLES(STRING_10, "InternalIntern", ves_icall_System_String_InternalIntern, MonoString, 1, (MonoString))
HANDLES(STRING_11, "InternalIsInterned", ves_icall_System_String_InternalIsInterned, MonoString, 1, (MonoString))

ICALL_TYPE(NATIVEC, "System.Threading.EventWaitHandle", EWH_1) // && Unix
HANDLES(EWH_1, "CreateEventInternal", ves_icall_System_Threading_Events_CreateEvent_icall, gpointer, 5, (MonoBoolean, MonoBoolean, const_gunichar2_ptr, gint32, gint32_ref))
NOHANDLES(ICALL(EWH_2, "ResetEventInternal",  ves_icall_System_Threading_Events_ResetEvent_internal))
NOHANDLES(ICALL(EWH_3, "SetEventInternal",    ves_icall_System_Threading_Events_SetEvent_internal))

ICALL_TYPE(ILOCK, "System.Threading.Interlocked", ILOCK_1)
NOHANDLES(ICALL(ILOCK_1, "Add(int&,int)", ves_icall_System_Threading_Interlocked_Add_Int))
NOHANDLES(ICALL(ILOCK_2, "Add(long&,long)", ves_icall_System_Threading_Interlocked_Add_Long))
NOHANDLES(ICALL(ILOCK_4, "CompareExchange(double&,double,double)", ves_icall_System_Threading_Interlocked_CompareExchange_Double))
NOHANDLES(ICALL(ILOCK_5, "CompareExchange(int&,int,int)", ves_icall_System_Threading_Interlocked_CompareExchange_Int))
NOHANDLES(ICALL(ILOCK_6, "CompareExchange(int&,int,int,bool&)", ves_icall_System_Threading_Interlocked_CompareExchange_Int_Success))
NOHANDLES(ICALL(ILOCK_7, "CompareExchange(intptr&,intptr,intptr)", ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr))
NOHANDLES(ICALL(ILOCK_8, "CompareExchange(long&,long,long)", ves_icall_System_Threading_Interlocked_CompareExchange_Long))
NOHANDLES(ICALL(ILOCK_9, "CompareExchange(object&,object&,object&,object&)", ves_icall_System_Threading_Interlocked_CompareExchange_Object))
NOHANDLES(ICALL(ILOCK_10, "CompareExchange(single&,single,single)", ves_icall_System_Threading_Interlocked_CompareExchange_Single))
NOHANDLES(ICALL(ILOCK_11, "Decrement(int&)", ves_icall_System_Threading_Interlocked_Decrement_Int))
NOHANDLES(ICALL(ILOCK_12, "Decrement(long&)", ves_icall_System_Threading_Interlocked_Decrement_Long))
NOHANDLES(ICALL(ILOCK_14, "Exchange(double&,double)", ves_icall_System_Threading_Interlocked_Exchange_Double))
NOHANDLES(ICALL(ILOCK_15, "Exchange(int&,int)", ves_icall_System_Threading_Interlocked_Exchange_Int))
NOHANDLES(ICALL(ILOCK_16, "Exchange(intptr&,intptr)", ves_icall_System_Threading_Interlocked_Exchange_IntPtr))
NOHANDLES(ICALL(ILOCK_17, "Exchange(long&,long)", ves_icall_System_Threading_Interlocked_Exchange_Long))
NOHANDLES(ICALL(ILOCK_18, "Exchange(object&,object&,object&)", ves_icall_System_Threading_Interlocked_Exchange_Object))
NOHANDLES(ICALL(ILOCK_19, "Exchange(single&,single)", ves_icall_System_Threading_Interlocked_Exchange_Single))
NOHANDLES(ICALL(ILOCK_20, "Increment(int&)", ves_icall_System_Threading_Interlocked_Increment_Int))
NOHANDLES(ICALL(ILOCK_21, "Increment(long&)", ves_icall_System_Threading_Interlocked_Increment_Long))
NOHANDLES(ICALL(ILOCK_22, "MemoryBarrierProcessWide", ves_icall_System_Threading_Interlocked_MemoryBarrierProcessWide))
NOHANDLES(ICALL(ILOCK_23, "Read(long&)", ves_icall_System_Threading_Interlocked_Read_Long))

ICALL_TYPE(MONIT, "System.Threading.Monitor", MONIT_0)
HANDLES(MONIT_0, "Enter", ves_icall_System_Threading_Monitor_Monitor_Enter, void, 1, (MonoObject))
HANDLES(MONIT_1, "Exit", mono_monitor_exit_icall, void, 1, (MonoObject))
HANDLES(MONIT_2, "Monitor_pulse", ves_icall_System_Threading_Monitor_Monitor_pulse, void, 1, (MonoObject))
HANDLES(MONIT_3, "Monitor_pulse_all", ves_icall_System_Threading_Monitor_Monitor_pulse_all, void, 1, (MonoObject))
HANDLES(MONIT_4, "Monitor_test_owner", ves_icall_System_Threading_Monitor_Monitor_test_owner, MonoBoolean, 1, (MonoObject))
HANDLES(MONIT_5, "Monitor_test_synchronised", ves_icall_System_Threading_Monitor_Monitor_test_synchronised, MonoBoolean, 1, (MonoObject))
HANDLES(MONIT_7, "Monitor_wait", ves_icall_System_Threading_Monitor_Monitor_wait, MonoBoolean, 3, (MonoObject, guint32, MonoBoolean))
NOHANDLES(ICALL(MONIT_8, "get_LockContentionCount", ves_icall_System_Threading_Monitor_Monitor_LockContentionCount))
HANDLES(MONIT_9, "try_enter_with_atomic_var", ves_icall_System_Threading_Monitor_Monitor_try_enter_with_atomic_var, void, 4, (MonoObject, guint32, MonoBoolean, MonoBoolean_ref))

ICALL_TYPE(MUTEX, "System.Threading.Mutex", MUTEX_1)
HANDLES(MUTEX_1, "CreateMutex_icall", ves_icall_System_Threading_Mutex_CreateMutex_icall, gpointer, 4, (MonoBoolean, const_gunichar2_ptr, gint32, MonoBoolean_ref))
HANDLES(MUTEX_2, "OpenMutex_icall", ves_icall_System_Threading_Mutex_OpenMutex_icall, gpointer, 4, (const_gunichar2_ptr, gint32, gint32, gint32_ref))
NOHANDLES(ICALL(MUTEX_3, "ReleaseMutex_internal", ves_icall_System_Threading_Mutex_ReleaseMutex_internal))

ICALL_TYPE(SEMA, "System.Threading.Semaphore", SEMA_1)
NOHANDLES(ICALL(SEMA_1, "CreateSemaphore_icall", ves_icall_System_Threading_Semaphore_CreateSemaphore_icall))
NOHANDLES(ICALL(SEMA_2, "OpenSemaphore_icall", ves_icall_System_Threading_Semaphore_OpenSemaphore_icall))
NOHANDLES(ICALL(SEMA_3, "ReleaseSemaphore_internal", ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal))

ICALL_TYPE(THREAD, "System.Threading.Thread", THREAD_1)
HANDLES(THREAD_1, "ClrState", ves_icall_System_Threading_Thread_ClrState, void, 2, (MonoInternalThread, guint32))
HANDLES(ITHREAD_2, "FreeInternal", ves_icall_System_Threading_InternalThread_Thread_free_internal, void, 1, (MonoInternalThread))
HANDLES(THREAD_15, "GetCurrentOSThreadId", ves_icall_System_Threading_Thread_GetCurrentOSThreadId, guint64, 0, ())
HANDLES(THREAD_16, "GetCurrentProcessorNumber", ves_icall_System_Threading_Thread_GetCurrentProcessorNumber, gint32, 0, ())
HANDLES(THREAD_3, "GetState", ves_icall_System_Threading_Thread_GetState, guint32, 1, (MonoInternalThread))
HANDLES(THREAD_4, "InitInternal", ves_icall_System_Threading_Thread_InitInternal, void, 1, (MonoThreadObject))
NOHANDLES(ICALL(THREAD_5, "InitializeCurrentThread_icall", ves_icall_System_Threading_Thread_GetCurrentThread))
HANDLES(THREAD_6, "InterruptInternal", ves_icall_System_Threading_Thread_Interrupt_internal, void, 1, (MonoThreadObject))
HANDLES(THREAD_7, "JoinInternal", ves_icall_System_Threading_Thread_Join_internal, MonoBoolean, 2, (MonoThreadObject, int))
HANDLES(THREAD_8, "SetName_icall", ves_icall_System_Threading_Thread_SetName_icall, void, 3, (MonoInternalThread, const_gunichar2_ptr, gint32))
HANDLES(THREAD_9, "SetPriority", ves_icall_System_Threading_Thread_SetPriority, void, 2, (MonoThreadObject, int))
HANDLES(THREAD_10, "SetState", ves_icall_System_Threading_Thread_SetState, void, 2, (MonoInternalThread, guint32))
HANDLES(THREAD_11, "SleepInternal", ves_icall_System_Threading_Thread_Sleep_internal, void, 2, (gint32, MonoBoolean))
HANDLES(THREAD_13, "StartInternal", ves_icall_System_Threading_Thread_StartInternal, void, 1, (MonoThreadObject))
NOHANDLES(ICALL(THREAD_14, "YieldInternal", ves_icall_System_Threading_Thread_YieldInternal))

ICALL_TYPE(WAITH, "System.Threading.WaitHandle", WAITH_1)
HANDLES(WAITH_1, "SignalAndWait_Internal", ves_icall_System_Threading_WaitHandle_SignalAndWait_Internal, gint32, 3, (gpointer, gpointer, gint32))
HANDLES(WAITH_2, "Wait_internal", ves_icall_System_Threading_WaitHandle_Wait_internal, gint32, 4, (gpointer_ptr, gint32, MonoBoolean, gint32))

ICALL_TYPE(TYPE, "System.Type", TYPE_1)
HANDLES(TYPE_1, "internal_from_handle", ves_icall_System_Type_internal_from_handle, MonoReflectionType, 1, (MonoType_ref))

ICALL_TYPE(TYPEDR, "System.TypedReference", TYPEDR_1)
HANDLES(TYPEDR_1, "InternalMakeTypedReference", ves_icall_System_TypedReference_InternalMakeTypedReference, void, 4, (MonoTypedRef_ptr, MonoObject, MonoArray, MonoReflectionType))
HANDLES(TYPEDR_2, "InternalToObject", ves_icall_System_TypedReference_ToObject, MonoObject, 1, (MonoTypedRef_ptr))

ICALL_TYPE(VALUET, "System.ValueType", VALUET_1)
HANDLES(VALUET_1, "InternalEquals", ves_icall_System_ValueType_Equals, MonoBoolean, 3, (MonoObject, MonoObject, MonoArrayOut))
HANDLES(VALUET_2, "InternalGetHashCode", ves_icall_System_ValueType_InternalGetHashCode, gint32, 2, (MonoObject, MonoArrayOut))

```

`Hazel/vendor/mono/include/mono/metadata/icall-def.h`:

```h
/**
 * \file
 * This file contains the default set of the mono internal calls.
 * Each type that has internal call methods must be declared here
 * with the ICALL_TYPE macro as follows:
 *
 * 	ICALL_TYPE(typeid, typename, first_icall_id)
 *
 * typeid must be a C symbol name unique to the type, don't worry about namespace
 * 	pollution, since it will be automatically prefixed to avoid it.
 * typename is a C string containing the full name of the type
 * first_icall_id is the symbol ID of the first internal call of the declared
 * 	type (see below)
 *
 * The list of internal calls of the methods of a type must follow the
 * type declaration. Each internal call is defined by the following macro:
 *
 * 	ICALL(icallid, methodname, cfuncptr)
 *
 * icallid must be a C symbol, unique for each icall defined in this file and
 * typically equal to the typeid + '_' + a sequential number.
 * methodname is a C string defining the method name and the optional signature
 * (the signature is required only when several internal calls in the type
 * have the same name)
 * cfuncptr is the C function that implements the internal call. Note that this
 * file is included at the end of metadata/icall.c, so the C function must be
 * visible to the compiler there.
 *
 * *** Adding a new internal call ***
 * Remember that ICALL_TYPE declarations must be kept sorted wrt each other
 * ICALL_TYPE declaration. The same happens for ICALL declarations, but only
 * limited to the icall list of each type. The sorting is based on the type or
 * method name.
 * When adding a new icall, make sure it is inserted correctly in the list and
 * that it defines a unique ID. ID are currently numbered and ordered, but if
 * you need to insert a method in the middle, don't bother renaming all the symbols.
 * Remember to change also the first_icall_id argument in the ICALL_TYPE
 * declaration if you add a new icall at the beginning of a type's icall list.
 *
 *
 * *** (Experimental) Cooperative GC support via Handles and MonoError ***
 * An icall can use the coop GC handles infrastructure from handles.h to avoid some
 * boilerplate when manipulating managed objects from runtime code and to use MonoError for
 * threading exceptions out to managed callerrs:
 *
 * HANDLES(icallid, methodname, cfuncptr, return-type, number-of-parameters, (parameter-types))
 * types:
 *   managed types are just MonoObject, MonoString, etc. `*` and Handle prefix are appended automatically.
 *   Types must be single identifiers, and be handled in icall-table.h.
 *   MonoError is added to the list automatically.
 *   A function with no parameters is "0, ()"
 *   "Out" and "InOut" types are appended with "Out" and "InOut". In is assumed.
 *   Out and InOut raw pointers get "**" appended. In gets just "*".
 *   Out/InOut only applied to managed pointers/handles.
 *   Things like "int*" are supported by typedefs like "typedef int *int_ptr".
 *   "void*" and "HANDLE" are written "gpointer".
 *   The list of available types is in icall-table.h.
 *   Using a type not there errors unceremoniously.
 *
 * An icall with a HANDLES() declaration wrapped around it will have a generated wrapper
 * that:
 *   (1) Updates the coop handle stack on entry and exit
 *   (2) Call the cfuncptr with a new signature:
 *     (a) All managed object reference in arguments will be wrapped in a type-unsafe handle
 *         (i.e., MonoString* becomes struct { MonoString* raw }* aka MonoRawHandle*)
 *     (b) the same for the return value (MonoObject* return becomes MonoObjectHandle)
 *     (c) An additional final argument is added of type MonoError*
 *     example:    class object {
 *                     [MethodImplOptions(InternalCall)]
 *                     String some_icall (object[] x);
 *                 }
 *     should be implemented as:
 *        MonoStringHandle some_icall (MonoObjectHandle this_handle, MonoArrayHandle x_handle, MonoError *error);
 *   (3) The wrapper will automatically call mono_error_set_pending_exception (error) and raise the resulting exception.
 * Note:  valuetypes use the same calling convention as normal.
 *
 * HANDLES() wrappers are generated dynamically by marshal-ilgen.c, using metadata to see types, producing type-unsafe handles (void*).
 * HANDLES() additional small wrappers are generated statically by icall-table.h, using the signatures here, producing
 * type-safe handles, i.e. MonoString* => MonoRawHandle* => struct { MonoString** raw }.
 *
 */

//
// _ref means marshal-ilgen.c created a handle for an interior pointer.
// _ptr means marshal-ilgen.c passed the parameter through unchanged.
// At the C level, they are the same.
//
// If the C# managed declaration for an icall, with 7 parameters, is:
// 	object your_internal_call (int x, object y, ref int z, IntPtr p, ref MyStruct c, ref MyClass, out string s);
//
// you should write:
// 	HANDLES(ID_n, "your_internal_call", "ves_icall_your_internal_call", MonoObject, 7, (gint32, MonoObject, gint32_ref, gpointer, MyStruct_ref, MyClassInOut, MonoStringOut))
//
// 7 is the number of parameters, the length of the last macro parameter.
// IntPtr is unchecked. You could also say gsize or gssize.
//
// and marshal-ilgen.c will generate a call to
// 	MonoRawHandle* ves_icall_your_internal_call_raw (gint32, MonoRawHandle*, gint32*, gpointer, MyStruct*, MonoRawHandle*, MonoRawHandle*);
//
// whose body will be generated by the HANDLES() macro, and which will call the following function that you have to implement:
// 	MonoObjectHandle ves_icall_your_internal_call (gint32, MonoObjectHandle, gint32*, gpointer, MyStruct*, MyClassHandleInOut, MonoStringOut, MonoError *error);
//
// Note the extra MonoError* argument.
// Note that "ref" becomes "HandleInOut" for managed types.
// "_ref" becomes "*" for unmanaged types.
// "_out" becomes "HandleOut" or "*".
// "HandleIn" is the default for managed types, and is just called "Handle".
//

#if ENABLE_NETCORE
#include "icall-def-netcore.h"
#else

ICALL_TYPE(CLR_INTEROP_SYS, "Interop/Sys", CLR_INTEROP_SYS_1)
NOHANDLES(ICALL(CLR_INTEROP_SYS_1, "DoubleToString", ves_icall_Interop_Sys_DoubleToString))

ICALL_TYPE(NATIVEMETHODS, "Microsoft.Win32.NativeMethods", NATIVEMETHODS_1)
NOHANDLES(ICALL(NATIVEMETHODS_1, "CloseProcess", ves_icall_Microsoft_Win32_NativeMethods_CloseProcess))
NOHANDLES(ICALL(NATIVEMETHODS_2, "GetCurrentProcess", ves_icall_Microsoft_Win32_NativeMethods_GetCurrentProcess))
NOHANDLES(ICALL(NATIVEMETHODS_3, "GetCurrentProcessId", ves_icall_Microsoft_Win32_NativeMethods_GetCurrentProcessId))
NOHANDLES(ICALL(NATIVEMETHODS_4, "GetExitCodeProcess", ves_icall_Microsoft_Win32_NativeMethods_GetExitCodeProcess))
NOHANDLES(ICALL(NATIVEMETHODS_5, "GetPriorityClass", ves_icall_Microsoft_Win32_NativeMethods_GetPriorityClass))
NOHANDLES(ICALL(NATIVEMETHODS_6, "GetProcessTimes", ves_icall_Microsoft_Win32_NativeMethods_GetProcessTimes))
NOHANDLES(ICALL(NATIVEMETHODS_7, "GetProcessWorkingSetSize", ves_icall_Microsoft_Win32_NativeMethods_GetProcessWorkingSetSize))
NOHANDLES(ICALL(NATIVEMETHODS_8, "SetPriorityClass", ves_icall_Microsoft_Win32_NativeMethods_SetPriorityClass))
NOHANDLES(ICALL(NATIVEMETHODS_9, "SetProcessWorkingSetSize", ves_icall_Microsoft_Win32_NativeMethods_SetProcessWorkingSetSize))
NOHANDLES(ICALL(NATIVEMETHODS_10, "TerminateProcess", ves_icall_Microsoft_Win32_NativeMethods_TerminateProcess))
NOHANDLES(ICALL(NATIVEMETHODS_11, "WaitForInputIdle", ves_icall_Microsoft_Win32_NativeMethods_WaitForInputIdle))

#ifndef DISABLE_COM
ICALL_TYPE(COMPROX, "Mono.Interop.ComInteropProxy", COMPROX_1)
NOHANDLES(ICALL(COMPROX_1, "AddProxy", ves_icall_Mono_Interop_ComInteropProxy_AddProxy))
NOHANDLES(ICALL(COMPROX_2, "FindProxy", ves_icall_Mono_Interop_ComInteropProxy_FindProxy))
#endif

ICALL_TYPE(TLS_PROVIDER_FACTORY, "Mono.Net.Security.MonoTlsProviderFactory", TLS_PROVIDER_FACTORY_1)
NOHANDLES(ICALL(TLS_PROVIDER_FACTORY_1, "IsBtlsSupported", ves_icall_Mono_TlsProviderFactory_IsBtlsSupported))

ICALL_TYPE(RUNTIME, "Mono.Runtime", RUNTIME_20)
NOHANDLES(ICALL(RUNTIME_20, "AnnotateMicrosoftTelemetry_internal", ves_icall_Mono_Runtime_AnnotateMicrosoftTelemetry))
NOHANDLES(ICALL(RUNTIME_19, "CheckCrashReportLog_internal", ves_icall_Mono_Runtime_CheckCrashReportingLog))
NOHANDLES(ICALL(RUNTIME_1, "DisableMicrosoftTelemetry", ves_icall_Mono_Runtime_DisableMicrosoftTelemetry))
HANDLES(RUNTIME_15, "DumpStateSingle_internal", ves_icall_Mono_Runtime_DumpStateSingle, MonoString, 2, (guint64_ref, guint64_ref))
HANDLES(RUNTIME_16, "DumpStateTotal_internal", ves_icall_Mono_Runtime_DumpStateTotal, MonoString, 2, (guint64_ref, guint64_ref))
NOHANDLES(ICALL(RUNTIME_18, "EnableCrashReportLog_internal", ves_icall_Mono_Runtime_EnableCrashReportingLog))
HANDLES(RUNTIME_2, "EnableMicrosoftTelemetry_internal", ves_icall_Mono_Runtime_EnableMicrosoftTelemetry, void, 6, (const_char_ptr, const_char_ptr, const_char_ptr, const_char_ptr, const_char_ptr, const_char_ptr))
HANDLES(RUNTIME_3, "ExceptionToState_internal", ves_icall_Mono_Runtime_ExceptionToState, MonoString, 3, (MonoException, guint64_ref, guint64_ref))
HANDLES(RUNTIME_4, "GetDisplayName", ves_icall_Mono_Runtime_GetDisplayName, MonoString, 0, ())
HANDLES(RUNTIME_12, "GetNativeStackTrace", ves_icall_Mono_Runtime_GetNativeStackTrace, MonoString, 1, (MonoException))
NOHANDLES(ICALL(RUNTIME_21, "RegisterReportingForAllNativeLibs_internal", ves_icall_Mono_Runtime_RegisterReportingForAllNativeLibs))
NOHANDLES(ICALL(RUNTIME_17, "RegisterReportingForNativeLib_internal", ves_icall_Mono_Runtime_RegisterReportingForNativeLib))
HANDLES(RUNTIME_13, "SendMicrosoftTelemetry_internal", ves_icall_Mono_Runtime_SendMicrosoftTelemetry, void, 3, (const_char_ptr, guint64, guint64))
HANDLES(RUNTIME_14, "WriteStateToFile_internal", ves_icall_Mono_Runtime_DumpTelemetry, void, 3, (const_char_ptr, guint64, guint64))

ICALL_TYPE(RTCLASS, "Mono.RuntimeClassHandle", RTCLASS_1)
NOHANDLES(ICALL(RTCLASS_1, "GetTypeFromClass", ves_icall_Mono_RuntimeClassHandle_GetTypeFromClass))

ICALL_TYPE(RTPTRARRAY, "Mono.RuntimeGPtrArrayHandle", RTPTRARRAY_1)
NOHANDLES(ICALL(RTPTRARRAY_1, "GPtrArrayFree", ves_icall_Mono_RuntimeGPtrArrayHandle_GPtrArrayFree))

ICALL_TYPE(RTMARSHAL, "Mono.RuntimeMarshal", RTMARSHAL_1)
NOHANDLES(ICALL(RTMARSHAL_1, "FreeAssemblyName", ves_icall_Mono_RuntimeMarshal_FreeAssemblyName))

ICALL_TYPE(SAFESTRMARSHAL, "Mono.SafeStringMarshal", SAFESTRMARSHAL_1)
NOHANDLES(ICALL(SAFESTRMARSHAL_1, "GFree", ves_icall_Mono_SafeStringMarshal_GFree))
NOHANDLES(ICALL(SAFESTRMARSHAL_2, "StringToUtf8_icall", ves_icall_Mono_SafeStringMarshal_StringToUtf8))

#ifndef PLATFORM_RO_FS
ICALL_TYPE(KPAIR, "Mono.Security.Cryptography.KeyPairPersistence", KPAIR_1)
NOHANDLES(ICALL(KPAIR_1, "_CanSecure", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_CanSecure))
NOHANDLES(ICALL(KPAIR_2, "_IsMachineProtected", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsMachineProtected))
NOHANDLES(ICALL(KPAIR_3, "_IsUserProtected", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsUserProtected))
NOHANDLES(ICALL(KPAIR_4, "_ProtectMachine", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectMachine))
NOHANDLES(ICALL(KPAIR_5, "_ProtectUser", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectUser))
#endif /* !PLATFORM_RO_FS */

ICALL_TYPE(APPDOM, "System.AppDomain", APPDOM_23)
HANDLES(APPDOM_23, "DoUnhandledException", ves_icall_System_AppDomain_DoUnhandledException, void, 2, (MonoAppDomain, MonoException))
HANDLES(APPDOM_1, "ExecuteAssembly", ves_icall_System_AppDomain_ExecuteAssembly, gint32, 3, (MonoAppDomain, MonoReflectionAssembly, MonoArray))
HANDLES(APPDOM_2, "GetAssemblies", ves_icall_System_AppDomain_GetAssemblies, MonoArray, 2, (MonoAppDomain, MonoBoolean))
HANDLES(APPDOM_3, "GetData", ves_icall_System_AppDomain_GetData, MonoObject, 2, (MonoAppDomain, MonoString))
HANDLES(APPDOM_4, "InternalGetContext", ves_icall_System_AppDomain_InternalGetContext, MonoAppContext, 0, ())
HANDLES(APPDOM_5, "InternalGetDefaultContext", ves_icall_System_AppDomain_InternalGetDefaultContext, MonoAppContext, 0, ())
HANDLES(APPDOM_6, "InternalGetProcessGuid", ves_icall_System_AppDomain_InternalGetProcessGuid, MonoString, 1, (MonoString))
HANDLES(APPDOM_7, "InternalIsFinalizingForUnload", ves_icall_System_AppDomain_InternalIsFinalizingForUnload, MonoBoolean, 1, (gint32))
HANDLES(APPDOM_8, "InternalPopDomainRef", ves_icall_System_AppDomain_InternalPopDomainRef, void, 0, ())
HANDLES(APPDOM_9, "InternalPushDomainRef", ves_icall_System_AppDomain_InternalPushDomainRef, void, 1, (MonoAppDomain))
HANDLES(APPDOM_10, "InternalPushDomainRefByID", ves_icall_System_AppDomain_InternalPushDomainRefByID, void, 1, (gint32))
HANDLES(APPDOM_11, "InternalSetContext", ves_icall_System_AppDomain_InternalSetContext, MonoAppContext, 1, (MonoAppContext))
HANDLES(APPDOM_12, "InternalSetDomain", ves_icall_System_AppDomain_InternalSetDomain, MonoAppDomain, 1, (MonoAppDomain))
HANDLES(APPDOM_13, "InternalSetDomainByID", ves_icall_System_AppDomain_InternalSetDomainByID, MonoAppDomain, 1, (gint32))
HANDLES(APPDOM_14, "InternalUnload", ves_icall_System_AppDomain_InternalUnload, void, 1, (gint32))
HANDLES(APPDOM_15, "LoadAssembly",    ves_icall_System_AppDomain_LoadAssembly, MonoReflectionAssembly, 5, (MonoAppDomain, MonoString, MonoObject, MonoBoolean, MonoStackCrawlMark_ptr))
HANDLES(APPDOM_16, "LoadAssemblyRaw", ves_icall_System_AppDomain_LoadAssemblyRaw, MonoReflectionAssembly, 5, (MonoAppDomain, MonoArray, MonoArray, MonoObject, MonoBoolean))
HANDLES(APPDOM_17, "SetData", ves_icall_System_AppDomain_SetData, void, 3, (MonoAppDomain, MonoString, MonoObject))
HANDLES(APPDOM_18, "createDomain", ves_icall_System_AppDomain_createDomain, MonoAppDomain, 2, (MonoString, MonoAppDomainSetup))
HANDLES(APPDOM_19, "getCurDomain", ves_icall_System_AppDomain_getCurDomain, MonoAppDomain, 0, ())
HANDLES(APPDOM_20, "getFriendlyName", ves_icall_System_AppDomain_getFriendlyName, MonoString, 1, (MonoAppDomain))
HANDLES(APPDOM_21, "getRootDomain", ves_icall_System_AppDomain_getRootDomain, MonoAppDomain, 0, ())
HANDLES(APPDOM_22, "getSetup", ves_icall_System_AppDomain_getSetup, MonoAppDomainSetup, 1, (MonoAppDomain))

ICALL_TYPE(ARGI, "System.ArgIterator", ARGI_1)
NOHANDLES(ICALL(ARGI_1, "IntGetNextArg",         ves_icall_System_ArgIterator_IntGetNextArg))
NOHANDLES(ICALL(ARGI_2, "IntGetNextArgType",     ves_icall_System_ArgIterator_IntGetNextArgType))
NOHANDLES(ICALL(ARGI_3, "IntGetNextArgWithType", ves_icall_System_ArgIterator_IntGetNextArgWithType))
NOHANDLES(ICALL(ARGI_4, "Setup",                 ves_icall_System_ArgIterator_Setup))

ICALL_TYPE(ARRAY, "System.Array", ARRAY_1)
HANDLES(ARRAY_1, "ClearInternal", ves_icall_System_Array_ClearInternal, void, 3, (MonoArray, int, int))
HANDLES(ARRAY_3, "CreateInstanceImpl",   ves_icall_System_Array_CreateInstanceImpl, MonoArray, 3, (MonoReflectionType, MonoArray, MonoArray))
HANDLES(ARRAY_4, "FastCopy",         ves_icall_System_Array_FastCopy, MonoBoolean, 5, (MonoArray, int, MonoArray, int, int))
NOHANDLES(ICALL(ARRAY_5, "GetGenericValue_icall", ves_icall_System_Array_GetGenericValue_icall))
HANDLES(ARRAY_6, "GetLength",        ves_icall_System_Array_GetLength, gint32, 2, (MonoArray, gint32))
HANDLES(ARRAY_15, "GetLongLength",   ves_icall_System_Array_GetLongLength, gint64, 2, (MonoArray, gint32))
HANDLES(ARRAY_7, "GetLowerBound",    ves_icall_System_Array_GetLowerBound, gint32, 2, (MonoArray, gint32))
HANDLES(ARRAY_8, "GetRank",          ves_icall_System_Array_GetRank, gint32, 1, (MonoObject))
HANDLES(ARRAY_9, "GetValue",         ves_icall_System_Array_GetValue, MonoObject, 2, (MonoArray, MonoArray))
HANDLES(ARRAY_10, "GetValueImpl",    ves_icall_System_Array_GetValueImpl, MonoObject, 2, (MonoArray, guint32))
NOHANDLES(ICALL(ARRAY_11, "SetGenericValue_icall", ves_icall_System_Array_SetGenericValue_icall))
HANDLES(ARRAY_12, "SetValue",         ves_icall_System_Array_SetValue, void, 3, (MonoArray, MonoObject, MonoArray))
HANDLES(ARRAY_13, "SetValueImpl",  ves_icall_System_Array_SetValueImpl, void, 3, (MonoArray, MonoObject, guint32))

ICALL_TYPE(BUFFER, "System.Buffer", BUFFER_1)
HANDLES(BUFFER_1, "InternalBlockCopy", ves_icall_System_Buffer_BlockCopyInternal, MonoBoolean, 5, (MonoArray, gint32, MonoArray, gint32, gint32))
NOHANDLES(ICALL(BUFFER_5, "InternalMemcpy", ves_icall_System_Buffer_MemcpyInternal))
HANDLES(BUFFER_2, "_ByteLength", ves_icall_System_Buffer_ByteLengthInternal, gint32, 1, (MonoArray))

ICALL_TYPE(CLRCONFIG, "System.CLRConfig", CLRCONFIG_1)
HANDLES(CLRCONFIG_1, "CheckThrowUnobservedTaskExceptions", ves_icall_System_CLRConfig_CheckThrowUnobservedTaskExceptions, MonoBoolean, 0, ())

ICALL_TYPE(DEFAULTC, "System.Configuration.DefaultConfig", DEFAULTC_1)
HANDLES(DEFAULTC_1, "get_bundled_machine_config", ves_icall_System_Configuration_DefaultConfig_get_bundled_machine_config, MonoString, 0, ())
HANDLES(DEFAULTC_2, "get_machine_config_path", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path, MonoString, 0, ())

/* Note that the below icall shares the same function as DefaultConfig uses */
ICALL_TYPE(INTCFGHOST, "System.Configuration.InternalConfigurationHost", INTCFGHOST_1)
HANDLES(INTCFGHOST_1, "get_bundled_app_config", ves_icall_System_Configuration_InternalConfigurationHost_get_bundled_app_config, MonoString, 0, ())
HANDLES(INTCFGHOST_2, "get_bundled_machine_config", ves_icall_System_Configuration_InternalConfigurationHost_get_bundled_machine_config, MonoString, 0, ())

ICALL_TYPE(CONSOLE, "System.ConsoleDriver", CONSOLE_1)
HANDLES(CONSOLE_1, "InternalKeyAvailable", ves_icall_System_ConsoleDriver_InternalKeyAvailable, gint32, 1, (gint32))
HANDLES(CONSOLE_2, "Isatty", ves_icall_System_ConsoleDriver_Isatty, MonoBoolean, 1, (gpointer/*HANDLE*/))
HANDLES(CONSOLE_3, "SetBreak", ves_icall_System_ConsoleDriver_SetBreak, MonoBoolean, 1, (MonoBoolean))
HANDLES(CONSOLE_4, "SetEcho", ves_icall_System_ConsoleDriver_SetEcho, MonoBoolean, 1, (MonoBoolean))
HANDLES(CONSOLE_5, "TtySetup", ves_icall_System_ConsoleDriver_TtySetup, MonoBoolean, 4, (MonoString, MonoString, MonoArrayOut, int_ptr_ref))

ICALL_TYPE(DTIME, "System.DateTime", DTIME_1)
NOHANDLES(ICALL(DTIME_1, "GetSystemTimeAsFileTime", ves_icall_System_DateTime_GetSystemTimeAsFileTime))

ICALL_TYPE(DELEGATE, "System.Delegate", DELEGATE_1)
HANDLES(DELEGATE_1, "AllocDelegateLike_internal", ves_icall_System_Delegate_AllocDelegateLike_internal, MonoMulticastDelegate, 1, (MonoDelegate))
HANDLES(DELEGATE_2, "CreateDelegate_internal", ves_icall_System_Delegate_CreateDelegate_internal, MonoObject, 4, (MonoReflectionType, MonoObject, MonoReflectionMethod, MonoBoolean))
HANDLES(DELEGATE_3, "GetVirtualMethod_internal", ves_icall_System_Delegate_GetVirtualMethod_internal, MonoReflectionMethod, 1, (MonoDelegate))

ICALL_TYPE(DEBUGR, "System.Diagnostics.Debugger", DEBUGR_1)
NOHANDLES(ICALL(DEBUGR_1, "IsAttached_internal", ves_icall_System_Diagnostics_Debugger_IsAttached_internal))
NOHANDLES(ICALL(DEBUGR_2, "IsLogging", ves_icall_System_Diagnostics_Debugger_IsLogging))
NOHANDLES(ICALL(DEBUGR_3, "Log_icall", ves_icall_System_Diagnostics_Debugger_Log))

ICALL_TYPE(TRACEL, "System.Diagnostics.DefaultTraceListener", TRACEL_1)
HANDLES(TRACEL_1, "WriteWindowsDebugString", ves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString, void, 1, (const_gunichar2_ptr))

ICALL_TYPE(FILEV, "System.Diagnostics.FileVersionInfo", FILEV_1)
HANDLES(FILEV_1, "GetVersionInfo_icall", ves_icall_System_Diagnostics_FileVersionInfo_GetVersionInfo_internal, void, 3, (MonoObject, const_gunichar2_ptr, int))

ICALL_TYPE(PERFCTR, "System.Diagnostics.PerformanceCounter", PERFCTR_1)
NOHANDLES(ICALL(PERFCTR_1, "FreeData", mono_perfcounter_free_data))
HANDLES(PERFCTR_2, "GetImpl_icall", mono_perfcounter_get_impl, gpointer, 8,
	(const_gunichar2_ptr, gint32, const_gunichar2_ptr, gint32, const_gunichar2_ptr, gint32, gint32_ref, MonoBoolean_ref))
NOHANDLES(ICALL(PERFCTR_3, "GetSample", mono_perfcounter_get_sample))
NOHANDLES(ICALL(PERFCTR_4, "UpdateValue", mono_perfcounter_update_value))

ICALL_TYPE(PERFCTRCAT, "System.Diagnostics.PerformanceCounterCategory", PERFCTRCAT_1)
HANDLES(PERFCTRCAT_1, "CategoryDelete_icall", mono_perfcounter_category_del, MonoBoolean, 2, (const_gunichar2_ptr, gint32))
HANDLES(PERFCTRCAT_2, "CategoryHelpInternal_icall",   mono_perfcounter_category_help, MonoString, 2, (const_gunichar2_ptr, gint32))
HANDLES(PERFCTRCAT_3, "CounterCategoryExists_icall", mono_perfcounter_category_exists, MonoBoolean, 4, (const_gunichar2_ptr, gint32, const_gunichar2_ptr, gint32))
HANDLES(PERFCTRCAT_4, "Create_icall",     mono_perfcounter_create, MonoBoolean, 6, (const_gunichar2_ptr, gint32, const_gunichar2_ptr, gint32, gint32, MonoArray))
HANDLES(PERFCTRCAT_5, "GetCategoryNames", mono_perfcounter_category_names, MonoArray, 0, ())
HANDLES(PERFCTRCAT_6, "GetCounterNames_icall", mono_perfcounter_counter_names, MonoArray, 2, (const_gunichar2_ptr, gint32))
HANDLES(PERFCTRCAT_7, "GetInstanceNames_icall", mono_perfcounter_instance_names, MonoArray, 2, (const_gunichar2_ptr, gint32))
HANDLES(PERFCTRCAT_8, "InstanceExistsInternal_icall", mono_perfcounter_instance_exists, MonoBoolean, 4, (const_gunichar2_ptr, gint32, const_gunichar2_ptr, gint32))

ICALL_TYPE(PROCESS, "System.Diagnostics.Process", PROCESS_1)
HANDLES(PROCESS_1, "CreateProcess_internal", ves_icall_System_Diagnostics_Process_CreateProcess_internal,
	MonoBoolean, 5, (MonoW32ProcessStartInfo, gpointer, gpointer, gpointer, MonoW32ProcessInfo_ref))
HANDLES(PROCESS_4, "GetModules_icall", ves_icall_System_Diagnostics_Process_GetModules_internal, MonoArray, 2, (MonoObject, PROCESS_HANDLE))
NOHANDLES(ICALL(PROCESS_5H, "GetProcessData", ves_icall_System_Diagnostics_Process_GetProcessData))
HANDLES(PROCESS_6, "GetProcess_internal", ves_icall_System_Diagnostics_Process_GetProcess_internal, gpointer, 1, (guint32))
HANDLES(PROCESS_7, "GetProcesses_internal", ves_icall_System_Diagnostics_Process_GetProcesses_internal, MonoArray, 0, ())
HANDLES(PROCESS_10, "ProcessName_icall", ves_icall_System_Diagnostics_Process_ProcessName_internal, MonoString, 1, (PROCESS_HANDLE))
HANDLES(PROCESS_13, "ShellExecuteEx_internal", ves_icall_System_Diagnostics_Process_ShellExecuteEx_internal, MonoBoolean, 2, (MonoW32ProcessStartInfo, MonoW32ProcessInfo_ref))

ICALL_TYPE(STOPWATCH, "System.Diagnostics.Stopwatch", STOPWATCH_1)
NOHANDLES(ICALL(STOPWATCH_1, "GetTimestamp", ves_icall_System_Diagnostics_Stopwatch_GetTimestamp))

ICALL_TYPE(ENUM, "System.Enum", ENUM_1)
HANDLES(ENUM_1, "GetEnumValuesAndNames", ves_icall_System_Enum_GetEnumValuesAndNames, MonoBoolean, 3, (MonoReflectionType, MonoArrayOut, MonoArrayOut))
HANDLES(ENUM_2, "InternalBoxEnum", ves_icall_System_Enum_ToObject, MonoObject, 2, (MonoReflectionType, guint64))
HANDLES(ENUM_3, "InternalCompareTo", ves_icall_System_Enum_compare_value_to, int, 2, (MonoObject, MonoObject))
HANDLES(ENUM_3a, "InternalGetCorElementType", ves_icall_System_Enum_InternalGetCorElementType, int, 1, (MonoObject))
HANDLES(ENUM_4, "InternalGetUnderlyingType", ves_icall_System_Enum_get_underlying_type, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(ENUM_5, "InternalHasFlag", ves_icall_System_Enum_InternalHasFlag, MonoBoolean, 2, (MonoObject, MonoObject))
HANDLES(ENUM_6, "get_hashcode", ves_icall_System_Enum_get_hashcode, int, 1, (MonoObject))
HANDLES(ENUM_7, "get_value", ves_icall_System_Enum_get_value, MonoObject, 1, (MonoObject))

ICALL_TYPE(ENV, "System.Environment", ENV_1)
NOHANDLES(ICALL(ENV_1, "Exit", ves_icall_System_Environment_Exit))
HANDLES(ENV_1a, "FailFast", ves_icall_System_Environment_FailFast, void, 3, (MonoString, MonoException, MonoString))
HANDLES(ENV_2, "GetCommandLineArgs", ves_icall_System_Environment_GetCommandLineArgs, MonoArray, 0, ())
HANDLES(ENV_3, "GetEnvironmentVariableNames", ves_icall_System_Environment_GetEnvironmentVariableNames, MonoArray, 0, ())
NOHANDLES(ICALL(ENV_31, "GetIs64BitOperatingSystem", ves_icall_System_Environment_GetIs64BitOperatingSystem))
HANDLES(ENV_4, "GetLogicalDrivesInternal", ves_icall_System_Environment_GetLogicalDrivesInternal, MonoArray, 0, ())
HANDLES_REUSE_WRAPPER(ENV_5, "GetMachineConfigPath", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path, MonoString, 0, ())
HANDLES(ENV_51, "GetNewLine", ves_icall_System_Environment_get_NewLine, MonoString, 0, ())
HANDLES(ENV_6, "GetOSVersionString", ves_icall_System_Environment_GetOSVersionString, MonoString, 0, ())
NOHANDLES(ICALL(ENV_6a, "GetPageSize", mono_pagesize))
HANDLES(ENV_7, "GetWindowsFolderPath", ves_icall_System_Environment_GetWindowsFolderPath, MonoString, 1, (int))
HANDLES(ENV_8, "InternalSetEnvironmentVariable", ves_icall_System_Environment_InternalSetEnvironmentVariable, void, 4, (const_gunichar2_ptr, gint32, const_gunichar2_ptr, gint32))
NOHANDLES(ICALL(ENV_9, "get_ExitCode", mono_environment_exitcode_get))
NOHANDLES(ICALL(ENV_10, "get_HasShutdownStarted", ves_icall_System_Environment_get_HasShutdownStarted))
HANDLES(ENV_11, "get_MachineName", ves_icall_System_Environment_get_MachineName, MonoString, 0, ())
NOHANDLES(ICALL(ENV_13, "get_Platform", ves_icall_System_Environment_get_Platform))
NOHANDLES(ICALL(ENV_14, "get_ProcessorCount", ves_icall_System_Environment_get_ProcessorCount))
NOHANDLES(ICALL(ENV_15, "get_TickCount", ves_icall_System_Environment_get_TickCount))
HANDLES(ENV_16, "get_UserName", ves_icall_System_Environment_get_UserName, MonoString, 0, ())
HANDLES(ENV_16b, "get_bundled_machine_config", ves_icall_System_Environment_get_bundled_machine_config, MonoString, 0, ())
HANDLES(ENV_16m, "internalBroadcastSettingChange", ves_icall_System_Environment_BroadcastSettingChange, void, 0, ())
HANDLES(ENV_17, "internalGetEnvironmentVariable_native", ves_icall_System_Environment_GetEnvironmentVariable_native, MonoString, 1, (const_char_ptr))
HANDLES(ENV_18, "internalGetGacPath", ves_icall_System_Environment_GetGacPath, MonoString, 0, ())
HANDLES(ENV_19, "internalGetHome", ves_icall_System_Environment_InternalGetHome, MonoString, 0, ())
NOHANDLES(ICALL(ENV_20, "set_ExitCode", mono_environment_exitcode_set))
ICALL_TYPE(GC, "System.GC", GC_10)
NOHANDLES(ICALL(GC_10, "GetAllocatedBytesForCurrentThread", ves_icall_System_GC_GetAllocatedBytesForCurrentThread))
NOHANDLES(ICALL(GC_0, "GetCollectionCount", ves_icall_System_GC_GetCollectionCount))
HANDLES(GC_0a, "GetGeneration", ves_icall_System_GC_GetGeneration, int, 1, (MonoObject))
NOHANDLES(ICALL(GC_0b, "GetMaxGeneration", ves_icall_System_GC_GetMaxGeneration))
NOHANDLES(ICALL(GC_1, "GetTotalMemory", ves_icall_System_GC_GetTotalMemory))
NOHANDLES(ICALL(GC_2, "InternalCollect", ves_icall_System_GC_InternalCollect))
NOHANDLES(ICALL(GC_4a, "RecordPressure", ves_icall_System_GC_RecordPressure))
NOHANDLES(ICALL(GC_6, "WaitForPendingFinalizers", ves_icall_System_GC_WaitForPendingFinalizers))
HANDLES(GC_6b, "_ReRegisterForFinalize", ves_icall_System_GC_ReRegisterForFinalize, void, 1, (MonoObject))
HANDLES(GC_7, "_SuppressFinalize", ves_icall_System_GC_SuppressFinalize, void, 1, (MonoObject))
HANDLES(GC_9, "get_ephemeron_tombstone", ves_icall_System_GC_get_ephemeron_tombstone, MonoObject, 0, ())
HANDLES(GC_8, "register_ephemeron_array", ves_icall_System_GC_register_ephemeron_array, void, 1, (MonoObject))

ICALL_TYPE(CALDATA, "System.Globalization.CalendarData", CALDATA_1)
HANDLES(CALDATA_1, "fill_calendar_data", ves_icall_System_Globalization_CalendarData_fill_calendar_data, MonoBoolean, 3, (MonoCalendarData, MonoString, gint32))

ICALL_TYPE(COMPINF, "System.Globalization.CompareInfo", COMPINF_4)
NOHANDLES(ICALL(COMPINF_4, "internal_compare_icall", ves_icall_System_Globalization_CompareInfo_internal_compare))
NOHANDLES(ICALL(COMPINF_6, "internal_index_icall", ves_icall_System_Globalization_CompareInfo_internal_index))

ICALL_TYPE(CULDATA, "System.Globalization.CultureData", CULDATA_1)
HANDLES(CULDATA_1, "fill_culture_data", ves_icall_System_Globalization_CultureData_fill_culture_data, void, 2, (MonoCultureData, gint32))
NOHANDLES(ICALL(CULDATA_2, "fill_number_data", ves_icall_System_Globalization_CultureData_fill_number_data))

ICALL_TYPE(CULINF, "System.Globalization.CultureInfo", CULINF_5)
HANDLES(CULINF_5, "construct_internal_locale_from_lcid", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_lcid, MonoBoolean, 2, (MonoCultureInfo, gint32))
HANDLES(CULINF_6, "construct_internal_locale_from_name", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_name, MonoBoolean, 2, (MonoCultureInfo, MonoString))
HANDLES(CULINF_7, "get_current_locale_name", ves_icall_System_Globalization_CultureInfo_get_current_locale_name, MonoString, 0, ())
HANDLES(CULINF_9, "internal_get_cultures", ves_icall_System_Globalization_CultureInfo_internal_get_cultures, MonoArray, 3, (MonoBoolean, MonoBoolean, MonoBoolean))

ICALL_TYPE(REGINF, "System.Globalization.RegionInfo", REGINF_2)
HANDLES(REGINF_2, "construct_internal_region_from_name", ves_icall_System_Globalization_RegionInfo_construct_internal_region_from_name, MonoBoolean, 2, (MonoRegionInfo, MonoString))

#if defined(ENABLE_MONODROID) || defined(ENABLE_MONOTOUCH) || defined(TARGET_WASM)
ICALL_TYPE(DEFLATESTREAM, "System.IO.Compression.DeflateStreamNative", DEFLATESTREAM_1)
NOHANDLES(ICALL(DEFLATESTREAM_1, "CloseZStream", ves_icall_System_IO_Compression_DeflateStreamNative_CloseZStream))
NOHANDLES(ICALL(DEFLATESTREAM_2, "CreateZStream", ves_icall_System_IO_Compression_DeflateStreamNative_CreateZStream))
NOHANDLES(ICALL(DEFLATESTREAM_3, "Flush", ves_icall_System_IO_Compression_DeflateStreamNative_Flush))
NOHANDLES(ICALL(DEFLATESTREAM_4, "ReadZStream", ves_icall_System_IO_Compression_DeflateStreamNative_ReadZStream))
NOHANDLES(ICALL(DEFLATESTREAM_5, "WriteZStream", ves_icall_System_IO_Compression_DeflateStreamNative_WriteZStream))
#endif

#ifndef PLATFORM_NO_DRIVEINFO
ICALL_TYPE(IODRIVEINFO, "System.IO.DriveInfo", IODRIVEINFO_1)
NOHANDLES(ICALL(IODRIVEINFO_1, "GetDiskFreeSpaceInternal", ves_icall_System_IO_DriveInfo_GetDiskFreeSpace))
HANDLES(IODRIVEINFO_2, "GetDriveFormatInternal", ves_icall_System_IO_DriveInfo_GetDriveFormat, MonoString, 2, (const_gunichar2_ptr, int))
HANDLES(IODRIVEINFO_3, "GetDriveTypeInternal", ves_icall_System_IO_DriveInfo_GetDriveType, guint32, 2, (const_gunichar2_ptr, int))
#endif

ICALL_TYPE(FAMW, "System.IO.FAMWatcher", FAMW_1)
HANDLES(FAMW_1, "InternalFAMNextEvent", ves_icall_System_IO_FAMW_InternalFAMNextEvent, int, 4, (gpointer, MonoStringOut, int_ref, int_ref))

ICALL_TYPE(FILEW, "System.IO.FileSystemWatcher", FILEW_4)
NOHANDLES(ICALL(FILEW_4, "InternalSupportsFSW", ves_icall_System_IO_FSW_SupportsFSW))

ICALL_TYPE(KQUEM, "System.IO.KqueueMonitor", KQUEM_1)
NOHANDLES(ICALL(KQUEM_1, "kevent_notimeout", ves_icall_System_IO_KqueueMonitor_kevent_notimeout))

ICALL_TYPE(LOGCATEXTWRITER, "System.IO.LogcatTextWriter", LOGCATEXTWRITER_1)
NOHANDLES(ICALL(LOGCATEXTWRITER_1, "Log", ves_icall_System_IO_LogcatTextWriter_Log))

ICALL_TYPE(MMAPIMPL, "System.IO.MemoryMappedFiles.MemoryMapImpl", MMAPIMPL_1)
// FIXME rename to ves_icall...
HANDLES(MMAPIMPL_1, "CloseMapping", mono_mmap_close, void, 1, (gpointer))
HANDLES(MMAPIMPL_2, "ConfigureHandleInheritability", mono_mmap_configure_inheritability, void, 2, (gpointer, gint32))
HANDLES(MMAPIMPL_3, "Flush", mono_mmap_flush, void,  1, (gpointer))
HANDLES(MMAPIMPL_4, "MapInternal", mono_mmap_map, int, 6, (gpointer, gint64, gint64_ref, int, gpointer_ref, gpointer_ref))
HANDLES(MMAPIMPL_5, "OpenFileInternal", mono_mmap_open_file, gpointer, 9, (const_gunichar2_ptr, int, int, const_gunichar2_ptr, int, gint64_ref, int, int, int_ref))
HANDLES(MMAPIMPL_6, "OpenHandleInternal", mono_mmap_open_handle, gpointer, 7, (gpointer, const_gunichar2_ptr, int, gint64_ref, int, int, int_ref))
HANDLES(MMAPIMPL_7, "Unmap", mono_mmap_unmap, MonoBoolean, 1, (gpointer))

ICALL_TYPE(MONOIO, "System.IO.MonoIO", MONOIO_39)
NOHANDLES(ICALL(MONOIO_39, "Cancel_internal", ves_icall_System_IO_MonoIO_Cancel))
NOHANDLES(ICALL(MONOIO_1, "Close(intptr,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Close))
#ifndef PLATFORM_RO_FS
NOHANDLES(ICALL(MONOIO_2, "CopyFile(char*,char*,bool,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_CopyFile))
NOHANDLES(ICALL(MONOIO_3, "CreateDirectory(char*,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_CreateDirectory))
NOHANDLES(ICALL(MONOIO_4, "CreatePipe", ves_icall_System_IO_MonoIO_CreatePipe))
NOHANDLES(ICALL(MONOIO_5, "DeleteFile(char*,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_DeleteFile))
#endif /* !PLATFORM_RO_FS */
NOHANDLES(ICALL(MONOIO_38, "DumpHandles", ves_icall_System_IO_MonoIO_DumpHandles))
NOHANDLES(ICALL(MONOIO_34, "DuplicateHandle", ves_icall_System_IO_MonoIO_DuplicateHandle))
NOHANDLES(ICALL(MONOIO_37a, "FindCloseFile", ves_icall_System_IO_MonoIO_FindCloseFile))
HANDLES(MONOIO_35a, "FindFirstFile", ves_icall_System_IO_MonoIO_FindFirstFile, gpointer, 4, (const_gunichar2_ptr, MonoStringOut, gint32_ref, gint32_ref))
HANDLES(MONOIO_36a, "FindNextFile", ves_icall_System_IO_MonoIO_FindNextFile, MonoBoolean, 4, (gpointer, MonoStringOut, gint32_ref, gint32_ref))
NOHANDLES(ICALL(MONOIO_6, "Flush(intptr,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Flush))
HANDLES(MONOIO_7, "GetCurrentDirectory(System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_GetCurrentDirectory, MonoString, 1, (gint32_ref))
NOHANDLES(ICALL(MONOIO_8, "GetFileAttributes(char*,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_GetFileAttributes))
NOHANDLES(ICALL(MONOIO_9, "GetFileStat(char*,System.IO.MonoIOStat&,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_GetFileStat))
NOHANDLES(ICALL(MONOIO_11, "GetFileType(intptr,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_GetFileType))
NOHANDLES(ICALL(MONOIO_12, "GetLength(intptr,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_GetLength))
#ifndef PLATFORM_RO_FS
NOHANDLES(ICALL(MONOIO_14, "Lock(intptr,long,long,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Lock))
NOHANDLES(ICALL(MONOIO_15, "MoveFile(char*,char*,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_MoveFile))
#endif /* !PLATFORM_RO_FS */
NOHANDLES(ICALL(MONOIO_16, "Open(char*,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileOptions,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Open))
HANDLES(MONOIO_17, "Read(intptr,byte[],int,int,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Read, gint32, 5, (gpointer, MonoArray, gint32, gint32, gint32_ref))
#ifndef PLATFORM_RO_FS
NOHANDLES(ICALL(MONOIO_18, "RemoveDirectory(char*,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_RemoveDirectory))
NOHANDLES(ICALL(MONOIO_18M, "ReplaceFile(char*,char*,char*,bool,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_ReplaceFile))
#endif /* !PLATFORM_RO_FS */
NOHANDLES(ICALL(MONOIO_19, "Seek(intptr,long,System.IO.SeekOrigin,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Seek))
NOHANDLES(ICALL(MONOIO_20, "SetCurrentDirectory(char*,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_SetCurrentDirectory))
NOHANDLES(ICALL(MONOIO_21, "SetFileAttributes(char*,System.IO.FileAttributes,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_SetFileAttributes))
NOHANDLES(ICALL(MONOIO_22, "SetFileTime(intptr,long,long,long,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_SetFileTime))
NOHANDLES(ICALL(MONOIO_23, "SetLength(intptr,long,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_SetLength))
#ifndef PLATFORM_RO_FS
NOHANDLES(ICALL(MONOIO_24, "Unlock(intptr,long,long,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Unlock))
#endif
HANDLES(MONOIO_25, "Write(intptr,byte[],int,int,System.IO.MonoIOError&)", ves_icall_System_IO_MonoIO_Write, gint32, 5, (gpointer, MonoArray, gint32, gint32, gint32_ref))
NOHANDLES(ICALL(MONOIO_26, "get_AltDirectorySeparatorChar", ves_icall_System_IO_MonoIO_get_AltDirectorySeparatorChar))
NOHANDLES(ICALL(MONOIO_27, "get_ConsoleError", ves_icall_System_IO_MonoIO_get_ConsoleError))
NOHANDLES(ICALL(MONOIO_28, "get_ConsoleInput", ves_icall_System_IO_MonoIO_get_ConsoleInput))
NOHANDLES(ICALL(MONOIO_29, "get_ConsoleOutput", ves_icall_System_IO_MonoIO_get_ConsoleOutput))
NOHANDLES(ICALL(MONOIO_30, "get_DirectorySeparatorChar", ves_icall_System_IO_MonoIO_get_DirectorySeparatorChar))
HANDLES(MONOIO_31, "get_InvalidPathChars", ves_icall_System_IO_MonoIO_get_InvalidPathChars, MonoArray, 0, ())
NOHANDLES(ICALL(MONOIO_32, "get_PathSeparator", ves_icall_System_IO_MonoIO_get_PathSeparator))
NOHANDLES(ICALL(MONOIO_33, "get_VolumeSeparatorChar", ves_icall_System_IO_MonoIO_get_VolumeSeparatorChar))

ICALL_TYPE(IOPATH, "System.IO.Path", IOPATH_1)
HANDLES(IOPATH_1, "get_temp_path", ves_icall_System_IO_get_temp_path, MonoString, 0, ())

ICALL_TYPE(IOSELECTOR, "System.IOSelector", IOSELECTOR_1)
HANDLES(IOSELECTOR_1, "Add", ves_icall_System_IOSelector_Add, void, 2, (gpointer, MonoIOSelectorJob))
NOHANDLES(ICALL(IOSELECTOR_2, "Remove", ves_icall_System_IOSelector_Remove))

ICALL_TYPE(MATH, "System.Math", MATH_19)
NOHANDLES(ICALL(MATH_19, "Abs(double)", ves_icall_System_Math_Abs_double))
NOHANDLES(ICALL(MATH_20, "Abs(single)", ves_icall_System_Math_Abs_single))
NOHANDLES(ICALL(MATH_1, "Acos", ves_icall_System_Math_Acos))
NOHANDLES(ICALL(MATH_1a, "Acosh", ves_icall_System_Math_Acosh))
NOHANDLES(ICALL(MATH_2, "Asin", ves_icall_System_Math_Asin))
NOHANDLES(ICALL(MATH_2a, "Asinh", ves_icall_System_Math_Asinh))
NOHANDLES(ICALL(MATH_3, "Atan", ves_icall_System_Math_Atan))
NOHANDLES(ICALL(MATH_4, "Atan2", ves_icall_System_Math_Atan2))
NOHANDLES(ICALL(MATH_4a, "Atanh", ves_icall_System_Math_Atanh))
NOHANDLES(ICALL(MATH_4b, "Cbrt", ves_icall_System_Math_Cbrt))
NOHANDLES(ICALL(MATH_21, "Ceiling", ves_icall_System_Math_Ceiling))
NOHANDLES(ICALL(MATH_5, "Cos", ves_icall_System_Math_Cos))
NOHANDLES(ICALL(MATH_6, "Cosh", ves_icall_System_Math_Cosh))
NOHANDLES(ICALL(MATH_7, "Exp", ves_icall_System_Math_Exp))
NOHANDLES(ICALL(MATH_7a, "FMod", ves_icall_System_Math_FMod))
NOHANDLES(ICALL(MATH_8, "Floor", ves_icall_System_Math_Floor))
NOHANDLES(ICALL(MATH_9, "Log", ves_icall_System_Math_Log))
NOHANDLES(ICALL(MATH_10, "Log10", ves_icall_System_Math_Log10))
NOHANDLES(ICALL(MATH_10a, "ModF", ves_icall_System_Math_ModF))
NOHANDLES(ICALL(MATH_11, "Pow", ves_icall_System_Math_Pow))
NOHANDLES(ICALL(MATH_12, "Round", ves_icall_System_Math_Round))
NOHANDLES(ICALL(MATH_14, "Sin", ves_icall_System_Math_Sin))
NOHANDLES(ICALL(MATH_15, "Sinh", ves_icall_System_Math_Sinh))
NOHANDLES(ICALL(MATH_16, "Sqrt", ves_icall_System_Math_Sqrt))
NOHANDLES(ICALL(MATH_17, "Tan", ves_icall_System_Math_Tan))
NOHANDLES(ICALL(MATH_18, "Tanh", ves_icall_System_Math_Tanh))

ICALL_TYPE(MATHF, "System.MathF", MATHF_1)
NOHANDLES(ICALL(MATHF_1, "Acos", ves_icall_System_MathF_Acos))
NOHANDLES(ICALL(MATHF_2, "Acosh", ves_icall_System_MathF_Acosh))
NOHANDLES(ICALL(MATHF_3, "Asin", ves_icall_System_MathF_Asin))
NOHANDLES(ICALL(MATHF_4, "Asinh", ves_icall_System_MathF_Asinh))
NOHANDLES(ICALL(MATHF_5, "Atan", ves_icall_System_MathF_Atan))
NOHANDLES(ICALL(MATHF_6, "Atan2", ves_icall_System_MathF_Atan2))
NOHANDLES(ICALL(MATHF_7, "Atanh", ves_icall_System_MathF_Atanh))
NOHANDLES(ICALL(MATHF_8, "Cbrt", ves_icall_System_MathF_Cbrt))
NOHANDLES(ICALL(MATHF_9, "Ceiling", ves_icall_System_MathF_Ceiling))
NOHANDLES(ICALL(MATHF_10, "Cos", ves_icall_System_MathF_Cos))
NOHANDLES(ICALL(MATHF_11, "Cosh", ves_icall_System_MathF_Cosh))
NOHANDLES(ICALL(MATHF_12, "Exp", ves_icall_System_MathF_Exp))
NOHANDLES(ICALL(MATHF_22, "FMod", ves_icall_System_MathF_FMod))
NOHANDLES(ICALL(MATHF_13, "Floor", ves_icall_System_MathF_Floor))
NOHANDLES(ICALL(MATHF_14, "Log", ves_icall_System_MathF_Log))
NOHANDLES(ICALL(MATHF_15, "Log10", ves_icall_System_MathF_Log10))
NOHANDLES(ICALL(MATHF_23, "ModF(single,single*)", ves_icall_System_MathF_ModF))
NOHANDLES(ICALL(MATHF_16, "Pow", ves_icall_System_MathF_Pow))
NOHANDLES(ICALL(MATHF_17, "Sin", ves_icall_System_MathF_Sin))
NOHANDLES(ICALL(MATHF_18, "Sinh", ves_icall_System_MathF_Sinh))
NOHANDLES(ICALL(MATHF_19, "Sqrt", ves_icall_System_MathF_Sqrt))
NOHANDLES(ICALL(MATHF_20, "Tan", ves_icall_System_MathF_Tan))
NOHANDLES(ICALL(MATHF_21, "Tanh", ves_icall_System_MathF_Tanh))

ICALL_TYPE(MCATTR, "System.MonoCustomAttrs", MCATTR_1)
HANDLES(MCATTR_1, "GetCustomAttributesDataInternal", ves_icall_MonoCustomAttrs_GetCustomAttributesDataInternal, MonoArray, 1, (MonoObject))
HANDLES(MCATTR_2, "GetCustomAttributesInternal", ves_icall_MonoCustomAttrs_GetCustomAttributesInternal, MonoArray, 3, (MonoObject, MonoReflectionType, MonoBoolean))
HANDLES(MCATTR_3, "IsDefinedInternal", ves_icall_MonoCustomAttrs_IsDefinedInternal, MonoBoolean, 2, (MonoObject, MonoReflectionType))

#ifndef DISABLE_SOCKETS
ICALL_TYPE(NDNS, "System.Net.Dns", NDNS_1)
HANDLES(NDNS_1, "GetHostByAddr_icall", ves_icall_System_Net_Dns_GetHostByAddr, MonoBoolean, 5, (MonoString, MonoStringOut, MonoArrayOut, MonoArrayOut, gint32))
HANDLES(NDNS_2, "GetHostByName_icall", ves_icall_System_Net_Dns_GetHostByName, MonoBoolean, 5, (MonoString, MonoStringOut, MonoArrayOut, MonoArrayOut, gint32))
HANDLES(NDNS_3, "GetHostName_icall", ves_icall_System_Net_Dns_GetHostName, MonoBoolean, 1, (MonoStringOut))
#endif

#if defined(ENABLE_MONODROID)
ICALL_TYPE(LINUXNETWORKCHANGE, "System.Net.NetworkInformation.LinuxNetworkChange", LINUXNETWORKCHANGE_1)
NOHANDLES(ICALL(LINUXNETWORKCHANGE_1, "CloseNLSocket", ves_icall_System_Net_NetworkInformation_LinuxNetworkChange_CloseNLSocket))
NOHANDLES(ICALL(LINUXNETWORKCHANGE_2, "CreateNLSocket", ves_icall_System_Net_NetworkInformation_LinuxNetworkChange_CreateNLSocket))
NOHANDLES(ICALL(LINUXNETWORKCHANGE_3, "ReadEvents", ves_icall_System_Net_NetworkInformation_LinuxNetworkChange_ReadEvents))
#endif

#if !defined(DISABLE_SOCKETS)
ICALL_TYPE(MAC_IFACE_PROPS, "System.Net.NetworkInformation.MacOsIPInterfaceProperties", MAC_IFACE_PROPS_1)
HANDLES(MAC_IFACE_PROPS_1, "ParseRouteInfo_icall", ves_icall_System_Net_NetworkInformation_MacOsIPInterfaceProperties_ParseRouteInfo, MonoBoolean, 2, (MonoString, MonoArrayOut))

ICALL_TYPE(SOCK, "System.Net.Sockets.Socket", SOCK_1)
NOHANDLES(ICALL(SOCK_1, "Accept_icall", ves_icall_System_Net_Sockets_Socket_Accept_icall))
NOHANDLES(ICALL(SOCK_2, "Available_icall", ves_icall_System_Net_Sockets_Socket_Available_icall))
HANDLES(SOCK_3, "Bind_icall", ves_icall_System_Net_Sockets_Socket_Bind_icall, void, 3, (gsize, MonoObject, gint32_ref))
NOHANDLES(ICALL(SOCK_4, "Blocking_icall", ves_icall_System_Net_Sockets_Socket_Blocking_icall))
NOHANDLES(ICALL(SOCK_5, "Close_icall", ves_icall_System_Net_Sockets_Socket_Close_icall))
HANDLES(SOCK_6, "Connect_icall", ves_icall_System_Net_Sockets_Socket_Connect_icall, void, 4, (gsize, MonoObject, gint32_ref, MonoBoolean))
NOHANDLES(ICALL(SOCK_6a, "Disconnect_icall", ves_icall_System_Net_Sockets_Socket_Disconnect_icall))
NOHANDLES(ICALL(SOCK_6b, "Duplicate_icall", ves_icall_System_Net_Sockets_Socket_Duplicate_icall))
//FIXME The array is ref but the icall does not write to it.
HANDLES(SOCK_7, "GetSocketOption_arr_icall", ves_icall_System_Net_Sockets_Socket_GetSocketOption_arr_icall, void, 5, (gsize, gint32, gint32, MonoArray, gint32_ref))
HANDLES(SOCK_8, "GetSocketOption_obj_icall", ves_icall_System_Net_Sockets_Socket_GetSocketOption_obj_icall, void, 5, (gsize, gint32, gint32, MonoObjectOut, gint32_ref))
HANDLES(SOCK_21, "IOControl_icall", ves_icall_System_Net_Sockets_Socket_IOControl_icall, int, 5, (gsize, gint32, MonoArray, MonoArray, gint32_ref))
NOHANDLES(ICALL(SOCK_9, "Listen_icall", ves_icall_System_Net_Sockets_Socket_Listen_icall))
HANDLES(SOCK_10, "LocalEndPoint_icall", ves_icall_System_Net_Sockets_Socket_LocalEndPoint_icall, MonoObject, 3, (gsize, gint32, gint32_ref))
NOHANDLES(ICALL(SOCK_11, "Poll_icall", ves_icall_System_Net_Sockets_Socket_Poll_icall))
HANDLES(SOCK_13, "ReceiveFrom_icall", ves_icall_System_Net_Sockets_Socket_ReceiveFrom_icall, gint32, 7, (gsize, char_ptr, gint32, gint32, MonoObjectInOut, gint32_ref, MonoBoolean))
NOHANDLES(ICALL(SOCK_11a, "Receive_array_icall", ves_icall_System_Net_Sockets_Socket_Receive_array_icall))
NOHANDLES(ICALL(SOCK_12, "Receive_icall", ves_icall_System_Net_Sockets_Socket_Receive_icall))
HANDLES(SOCK_14, "RemoteEndPoint_icall", ves_icall_System_Net_Sockets_Socket_RemoteEndPoint_icall, MonoObject, 3, (gsize, gint32, gint32_ref))
HANDLES(SOCK_15, "Select_icall", ves_icall_System_Net_Sockets_Socket_Select_icall, void, 3, (MonoArrayInOut, gint32, gint32_ref))
HANDLES(SOCK_15a, "SendFile_icall", ves_icall_System_Net_Sockets_Socket_SendFile_icall, MonoBoolean, 7, (gsize, MonoString, MonoArray, MonoArray, int, gint32_ref, MonoBoolean))
HANDLES(SOCK_16, "SendTo_icall", ves_icall_System_Net_Sockets_Socket_SendTo_icall, gint32, 7, (gsize, char_ptr, gint32, gint32, MonoObject, gint32_ref, MonoBoolean))
NOHANDLES(ICALL(SOCK_16a, "Send_array_icall", ves_icall_System_Net_Sockets_Socket_Send_array_icall))
NOHANDLES(ICALL(SOCK_17, "Send_icall", ves_icall_System_Net_Sockets_Socket_Send_icall))
HANDLES(SOCK_18, "SetSocketOption_icall", ves_icall_System_Net_Sockets_Socket_SetSocketOption_icall, void, 7, (gsize, gint32, gint32, MonoObject, MonoArray, gint32, gint32_ref))
NOHANDLES(ICALL(SOCK_19, "Shutdown_icall", ves_icall_System_Net_Sockets_Socket_Shutdown_icall))
HANDLES(SOCK_20, "Socket_icall", ves_icall_System_Net_Sockets_Socket_Socket_icall, gpointer, 4, (gint32, gint32, gint32, gint32_ref))
NOHANDLES(ICALL(SOCK_20a, "SupportsPortReuse", ves_icall_System_Net_Sockets_Socket_SupportPortReuse_icall))
HANDLES(SOCK_21a, "cancel_blocking_socket_operation", ves_icall_cancel_blocking_socket_operation, void, 1, (MonoThreadObject))

ICALL_TYPE(SOCKEX, "System.Net.Sockets.SocketException", SOCKEX_1)
NOHANDLES(ICALL(SOCKEX_1, "WSAGetLastError_icall", ves_icall_System_Net_Sockets_SocketException_WSAGetLastError_icall))
#endif /* !DISABLE_SOCKETS */

ICALL_TYPE(NUMBER_FORMATTER, "System.NumberFormatter", NUMBER_FORMATTER_1)
NOHANDLES(ICALL(NUMBER_FORMATTER_1, "GetFormatterTables", ves_icall_System_NumberFormatter_GetFormatterTables))

ICALL_TYPE(OBJ, "System.Object", OBJ_1)
HANDLES(OBJ_1, "GetType", ves_icall_System_Object_GetType, MonoReflectionType, 1, (MonoObject))
HANDLES(OBJ_2, "InternalGetHashCode", mono_object_hash_icall, int, 1, (MonoObject))
HANDLES(OBJ_3, "MemberwiseClone", ves_icall_System_Object_MemberwiseClone, MonoObject, 1, (MonoObject))

ICALL_TYPE(ASSEM, "System.Reflection.Assembly", ASSEM_2)
HANDLES(ASSEM_2, "GetCallingAssembly", ves_icall_System_Reflection_Assembly_GetCallingAssembly, MonoReflectionAssembly, 0, ())
HANDLES(ASSEM_3, "GetEntryAssembly", ves_icall_System_Reflection_Assembly_GetEntryAssembly, MonoReflectionAssembly, 0, ())
HANDLES(ASSEM_4, "GetExecutingAssembly", ves_icall_System_Reflection_Assembly_GetExecutingAssembly, MonoReflectionAssembly, 0, ())
HANDLES(ASSEM_13, "GetTypes", ves_icall_System_Reflection_Assembly_GetTypes, MonoArray, 2, (MonoReflectionAssembly, MonoBoolean))
HANDLES(ASSEM_14, "InternalGetAssemblyName", ves_icall_System_Reflection_Assembly_InternalGetAssemblyName, void, 3, (MonoString, MonoAssemblyName_ref, MonoStringOut))
HANDLES(ASSEM_12, "InternalGetReferencedAssemblies", ves_icall_System_Reflection_Assembly_InternalGetReferencedAssemblies, GPtrArray_ptr, 1, (MonoReflectionAssembly))
HANDLES(ASSEM_15, "InternalGetType", ves_icall_System_Reflection_Assembly_InternalGetType, MonoReflectionType, 5, (MonoReflectionAssembly, MonoReflectionModule, MonoString, MonoBoolean, MonoBoolean))
HANDLES(ASSEM_16a, "LoadFile_internal", ves_icall_System_Reflection_Assembly_LoadFile_internal, MonoReflectionAssembly, 2, (MonoString, MonoStackCrawlMark_ptr))
HANDLES(ASSEM_17, "LoadFrom", ves_icall_System_Reflection_Assembly_LoadFrom, MonoReflectionAssembly, 3, (MonoString, MonoBoolean, MonoStackCrawlMark_ptr))
HANDLES(ASSEM_26, "load_with_partial_name", ves_icall_System_Reflection_Assembly_load_with_partial_name, MonoReflectionAssembly, 2, (MonoString, MonoObject))

ICALL_TYPE(ASSEMN, "System.Reflection.AssemblyName", ASSEMN_0)
NOHANDLES(ICALL(ASSEMN_0, "GetNativeName", ves_icall_System_Reflection_AssemblyName_GetNativeName))
NOHANDLES(ICALL(ASSEMN_3, "ParseAssemblyName", ves_icall_System_Reflection_AssemblyName_ParseAssemblyName))
NOHANDLES(ICALL(ASSEMN_2, "get_public_token", mono_digest_get_public_token))

ICALL_TYPE(CATTR_DATA, "System.Reflection.CustomAttributeData", CATTR_DATA_1)
HANDLES(CATTR_DATA_1, "ResolveArgumentsInternal", ves_icall_System_Reflection_CustomAttributeData_ResolveArgumentsInternal, void, 6, (MonoReflectionMethod, MonoReflectionAssembly, gpointer, guint32, MonoArrayOut, MonoArrayOut))

ICALL_TYPE(ASSEMB, "System.Reflection.Emit.AssemblyBuilder", ASSEMB_1)
HANDLES(ASSEMB_1, "UpdateNativeCustomAttributes", ves_icall_AssemblyBuilder_UpdateNativeCustomAttributes, void, 1, (MonoReflectionAssemblyBuilder))
HANDLES(ASSEMB_2, "basic_init", ves_icall_AssemblyBuilder_basic_init, void, 1, (MonoReflectionAssemblyBuilder))

#ifndef DISABLE_REFLECTION_EMIT
ICALL_TYPE(CATTRB, "System.Reflection.Emit.CustomAttributeBuilder", CATTRB_1)
HANDLES(CATTRB_1, "GetBlob", ves_icall_CustomAttributeBuilder_GetBlob, MonoArray, 7, (MonoReflectionAssembly, MonoObject, MonoArray, MonoArray, MonoArray, MonoArray, MonoArray))
#endif

ICALL_TYPE(DYNM, "System.Reflection.Emit.DynamicMethod", DYNM_1)
HANDLES(DYNM_1, "create_dynamic_method", ves_icall_DynamicMethod_create_dynamic_method, void, 1, (MonoReflectionDynamicMethod))

ICALL_TYPE(ENUMB, "System.Reflection.Emit.EnumBuilder", ENUMB_1)
HANDLES(ENUMB_1, "setup_enum_type", ves_icall_EnumBuilder_setup_enum_type, void, 2, (MonoReflectionType, MonoReflectionType))

ICALL_TYPE(MODULEB, "System.Reflection.Emit.ModuleBuilder", MODULEB_10)
HANDLES(MODULEB_10, "GetRegisteredToken", ves_icall_ModuleBuilder_GetRegisteredToken, MonoObject, 2, (MonoReflectionModuleBuilder, guint32))
HANDLES(MODULEB_8, "RegisterToken", ves_icall_ModuleBuilder_RegisterToken, void, 3, (MonoReflectionModuleBuilder, MonoObject, guint32))
HANDLES(MODULEB_1, "WriteToFile", ves_icall_ModuleBuilder_WriteToFile, void, 2, (MonoReflectionModuleBuilder, FILE_HANDLE))
HANDLES(MODULEB_2, "basic_init", ves_icall_ModuleBuilder_basic_init, void, 1, (MonoReflectionModuleBuilder))
HANDLES(MODULEB_3, "build_metadata", ves_icall_ModuleBuilder_build_metadata, void, 1, (MonoReflectionModuleBuilder))
HANDLES(MODULEB_5, "getMethodToken", ves_icall_ModuleBuilder_getMethodToken, gint32, 3, (MonoReflectionModuleBuilder, MonoReflectionMethod, MonoArray))
HANDLES(MODULEB_6, "getToken", ves_icall_ModuleBuilder_getToken, gint32, 3, (MonoReflectionModuleBuilder, MonoObject, MonoBoolean))
HANDLES(MODULEB_7, "getUSIndex", ves_icall_ModuleBuilder_getUSIndex, guint32, 2, (MonoReflectionModuleBuilder, MonoString))
HANDLES(MODULEB_9, "set_wrappers_type", ves_icall_ModuleBuilder_set_wrappers_type, void, 2, (MonoReflectionModuleBuilder, MonoReflectionType))

ICALL_TYPE(SIGH, "System.Reflection.Emit.SignatureHelper", SIGH_1)
HANDLES(SIGH_1, "get_signature_field", ves_icall_SignatureHelper_get_signature_field, MonoArray, 1, (MonoReflectionSigHelper))
HANDLES(SIGH_2, "get_signature_local", ves_icall_SignatureHelper_get_signature_local, MonoArray, 1, (MonoReflectionSigHelper))

ICALL_TYPE(TYPEB, "System.Reflection.Emit.TypeBuilder", TYPEB_1)
HANDLES(TYPEB_1, "create_runtime_class", ves_icall_TypeBuilder_create_runtime_class, MonoReflectionType, 1, (MonoReflectionTypeBuilder))

ICALL_TYPE(EVENTI, "System.Reflection.EventInfo", EVENTI_1)
HANDLES(EVENTI_1, "internal_from_handle_type", ves_icall_System_Reflection_EventInfo_internal_from_handle_type, MonoReflectionEvent, 2, (MonoEvent_ref, MonoType_ref))

ICALL_TYPE(FIELDI, "System.Reflection.FieldInfo", FILEDI_1)
HANDLES(FILEDI_1, "get_marshal_info", ves_icall_System_Reflection_FieldInfo_get_marshal_info, MonoReflectionMarshalAsAttribute, 1, (MonoReflectionField))

HANDLES(FILEDI_2, "internal_from_handle_type", ves_icall_System_Reflection_FieldInfo_internal_from_handle_type, MonoReflectionField, 2, (MonoClassField_ref, MonoType_ref))

ICALL_TYPE(MBASE, "System.Reflection.MethodBase", MBASE_1)
HANDLES(MBASE_1, "GetCurrentMethod", ves_icall_GetCurrentMethod, MonoReflectionMethod, 0, ())

ICALL_TYPE(MMETHI, "System.Reflection.MonoMethodInfo", MMETHI_4)
NOHANDLES(ICALL(MMETHI_4, "get_method_attributes", ves_icall_get_method_attributes))
HANDLES(MMETHI_1, "get_method_info", ves_icall_get_method_info, void, 2, (MonoMethod_ptr, MonoMethodInfo_ref))
HANDLES(MMETHI_2, "get_parameter_info", ves_icall_System_Reflection_MonoMethodInfo_get_parameter_info, MonoArray, 2, (MonoMethod_ptr, MonoReflectionMethod))
HANDLES(MMETHI_3, "get_retval_marshal", ves_icall_System_MonoMethodInfo_get_retval_marshal, MonoReflectionMarshalAsAttribute, 1, (MonoMethod_ptr))

ICALL_TYPE(RASSEM, "System.Reflection.RuntimeAssembly", RASSEM_1)
HANDLES(RASSEM_1, "GetAotIdInternal", ves_icall_System_Reflection_RuntimeAssembly_GetAotIdInternal, MonoBoolean, 1, (MonoArray))
HANDLES(RASSEM_2, "GetFilesInternal", ves_icall_System_Reflection_RuntimeAssembly_GetFilesInternal, MonoObject, 3, (MonoReflectionAssembly, MonoString, MonoBoolean))
HANDLES(RASSEM_3, "GetManifestModuleInternal", ves_icall_System_Reflection_Assembly_GetManifestModuleInternal, MonoReflectionModule, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_4, "GetManifestResourceInfoInternal", ves_icall_System_Reflection_RuntimeAssembly_GetManifestResourceInfoInternal, MonoBoolean, 3, (MonoReflectionAssembly, MonoString, MonoManifestResourceInfo))
HANDLES(RASSEM_5, "GetManifestResourceInternal", ves_icall_System_Reflection_RuntimeAssembly_GetManifestResourceInternal, gpointer, 4, (MonoReflectionAssembly, MonoString, gint32_ref, MonoReflectionModuleOut))
HANDLES(RASSEM_6, "GetManifestResourceNames", ves_icall_System_Reflection_RuntimeAssembly_GetManifestResourceNames, MonoArray, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_7, "GetModulesInternal", ves_icall_System_Reflection_RuntimeAssembly_GetModulesInternal, MonoArray, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_8, "InternalImageRuntimeVersion", ves_icall_System_Reflection_RuntimeAssembly_InternalImageRuntimeVersion, MonoString, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_9, "LoadPermissions", ves_icall_System_Reflection_RuntimeAssembly_LoadPermissions, MonoBoolean, 7, (MonoReflectionAssembly, char_ptr_ref, guint32_ref, char_ptr_ref, guint32_ref, char_ptr_ref, guint32_ref))
HANDLES(RASSEM_10, "get_EntryPoint", ves_icall_System_Reflection_RuntimeAssembly_get_EntryPoint, MonoReflectionMethod, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_11, "get_ReflectionOnly", ves_icall_System_Reflection_RuntimeAssembly_get_ReflectionOnly, MonoBoolean, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_12, "get_code_base", ves_icall_System_Reflection_RuntimeAssembly_get_code_base, MonoString, 2, (MonoReflectionAssembly, MonoBoolean))
HANDLES(RASSEM_13, "get_fullname", ves_icall_System_Reflection_RuntimeAssembly_get_fullname, MonoString, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_14, "get_global_assembly_cache", ves_icall_System_Reflection_RuntimeAssembly_get_global_assembly_cache, MonoBoolean, 1, (MonoReflectionAssembly))
HANDLES(RASSEM_15, "get_location", ves_icall_System_Reflection_RuntimeAssembly_get_location, MonoString, 1, (MonoReflectionAssembly))

ICALL_TYPE(MCMETH, "System.Reflection.RuntimeConstructorInfo", MCMETH_1)
HANDLES(MCMETH_1, "GetGenericMethodDefinition_impl", ves_icall_RuntimeMethodInfo_GetGenericMethodDefinition, MonoReflectionMethod, 1, (MonoReflectionMethod))
HANDLES(MCMETH_2, "InternalInvoke", ves_icall_InternalInvoke, MonoObject, 4, (MonoReflectionMethod, MonoObject, MonoArray, MonoExceptionOut))
HANDLES(MCMETH_3, "get_core_clr_security_level", ves_icall_RuntimeMethodInfo_get_core_clr_security_level, int, 1, (MonoReflectionMethod))
HANDLES_REUSE_WRAPPER(MCMETH_4, "get_metadata_token", ves_icall_reflection_get_token)

ICALL_TYPE(MEV, "System.Reflection.RuntimeEventInfo", MEV_1)
HANDLES(MEV_1, "get_event_info", ves_icall_RuntimeEventInfo_get_event_info, void, 2, (MonoReflectionMonoEvent, MonoEventInfo_ref))
HANDLES_REUSE_WRAPPER(MEV_2, "get_metadata_token", ves_icall_reflection_get_token)

ICALL_TYPE(MFIELD, "System.Reflection.RuntimeFieldInfo", MFIELD_1)
HANDLES(MFIELD_1, "GetFieldOffset", ves_icall_RuntimeFieldInfo_GetFieldOffset, gint32, 1, (MonoReflectionField))
HANDLES(MFIELD_2, "GetParentType", ves_icall_RuntimeFieldInfo_GetParentType, MonoReflectionType, 2, (MonoReflectionField, MonoBoolean))
HANDLES(MFIELD_3, "GetRawConstantValue", ves_icall_RuntimeFieldInfo_GetRawConstantValue, MonoObject, 1, (MonoReflectionField))
HANDLES(MFIELD_4, "GetTypeModifiers", ves_icall_System_Reflection_FieldInfo_GetTypeModifiers, MonoArray, 2, (MonoReflectionField, MonoBoolean))
HANDLES(MFIELD_5, "GetValueInternal", ves_icall_RuntimeFieldInfo_GetValueInternal, MonoObject, 2, (MonoReflectionField, MonoObject))
HANDLES(MFIELD_6, "ResolveType", ves_icall_RuntimeFieldInfo_ResolveType, MonoReflectionType, 1, (MonoReflectionField))
HANDLES(MFIELD_7, "SetValueInternal", ves_icall_RuntimeFieldInfo_SetValueInternal, void, 3, (MonoReflectionField, MonoObject, MonoObject))
HANDLES_REUSE_WRAPPER(MFIELD_8, "UnsafeGetValue", ves_icall_RuntimeFieldInfo_GetValueInternal)
HANDLES(MFIELD_9, "get_core_clr_security_level", ves_icall_RuntimeFieldInfo_get_core_clr_security_level, int, 1, (MonoReflectionField))
HANDLES_REUSE_WRAPPER(MFIELD_10, "get_metadata_token", ves_icall_reflection_get_token)

ICALL_TYPE(RMETHODINFO, "System.Reflection.RuntimeMethodInfo", RMETHODINFO_1)
HANDLES(RMETHODINFO_1, "GetGenericArguments", ves_icall_RuntimeMethodInfo_GetGenericArguments, MonoArray, 1, (MonoReflectionMethod))
HANDLES_REUSE_WRAPPER(RMETHODINFO_2, "GetGenericMethodDefinition_impl", ves_icall_RuntimeMethodInfo_GetGenericMethodDefinition)
HANDLES(RMETHODINFO_3, "GetMethodBodyInternal", ves_icall_System_Reflection_RuntimeMethodInfo_GetMethodBodyInternal, MonoReflectionMethodBody, 1, (MonoMethod_ptr))
HANDLES(RMETHODINFO_4, "GetMethodFromHandleInternalType_native", ves_icall_System_Reflection_RuntimeMethodInfo_GetMethodFromHandleInternalType_native, MonoReflectionMethod, 3, (MonoMethod_ptr, MonoType_ptr, MonoBoolean))
HANDLES(RMETHODINFO_5, "GetPInvoke", ves_icall_RuntimeMethodInfo_GetPInvoke, void, 4, (MonoReflectionMethod, int_ref, MonoStringOut, MonoStringOut))
HANDLES_REUSE_WRAPPER(RMETHODINFO_6, "InternalInvoke", ves_icall_InternalInvoke)
HANDLES(RMETHODINFO_7, "MakeGenericMethod_impl", ves_icall_RuntimeMethodInfo_MakeGenericMethod_impl, MonoReflectionMethod, 2, (MonoReflectionMethod, MonoArray))
HANDLES(RMETHODINFO_8, "get_IsGenericMethod", ves_icall_RuntimeMethodInfo_get_IsGenericMethod, MonoBoolean, 1, (MonoReflectionMethod))
HANDLES(RMETHODINFO_9, "get_IsGenericMethodDefinition", ves_icall_RuntimeMethodInfo_get_IsGenericMethodDefinition, MonoBoolean, 1, (MonoReflectionMethod))
HANDLES(RMETHODINFO_10, "get_base_method", ves_icall_RuntimeMethodInfo_get_base_method, MonoReflectionMethod, 2, (MonoReflectionMethod, MonoBoolean))
HANDLES_REUSE_WRAPPER(RMETHODINFO_11, "get_core_clr_security_level", ves_icall_RuntimeMethodInfo_get_core_clr_security_level)
HANDLES_REUSE_WRAPPER(RMETHODINFO_12, "get_metadata_token", ves_icall_reflection_get_token)
HANDLES(RMETHODINFO_13, "get_name", ves_icall_RuntimeMethodInfo_get_name, MonoString, 1, (MonoReflectionMethod))

ICALL_TYPE(MODULE, "System.Reflection.RuntimeModule", MODULE_2)
HANDLES(MODULE_2, "GetGlobalType", ves_icall_System_Reflection_RuntimeModule_GetGlobalType, MonoReflectionType, 1, (MonoImage_ptr))
HANDLES(MODULE_3, "GetGuidInternal", ves_icall_System_Reflection_RuntimeModule_GetGuidInternal, void, 2, (MonoImage_ptr, MonoArray))
HANDLES(MODULE_14, "GetHINSTANCE", ves_icall_System_Reflection_RuntimeModule_GetHINSTANCE, gpointer, 1, (MonoImage_ptr))
HANDLES(MODULE_4, "GetMDStreamVersion", ves_icall_System_Reflection_RuntimeModule_GetMDStreamVersion, gint32, 1, (MonoImage_ptr))
HANDLES(MODULE_5, "GetPEKind", ves_icall_System_Reflection_RuntimeModule_GetPEKind, void, 3, (MonoImage_ptr, gint32_ptr, gint32_ptr))
HANDLES(MODULE_6, "InternalGetTypes", ves_icall_System_Reflection_RuntimeModule_InternalGetTypes, MonoArray, 1, (MonoImage_ptr))
HANDLES(MODULE_7, "ResolveFieldToken", ves_icall_System_Reflection_RuntimeModule_ResolveFieldToken, MonoClassField_ptr, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_8, "ResolveMemberToken", ves_icall_System_Reflection_RuntimeModule_ResolveMemberToken, MonoObject, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_9, "ResolveMethodToken", ves_icall_System_Reflection_RuntimeModule_ResolveMethodToken, MonoMethod_ptr, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_10, "ResolveSignature", ves_icall_System_Reflection_RuntimeModule_ResolveSignature, MonoArray, 3, (MonoImage_ptr, guint32, MonoResolveTokenError_ref))
HANDLES(MODULE_11, "ResolveStringToken", ves_icall_System_Reflection_RuntimeModule_ResolveStringToken, MonoString, 3, (MonoImage_ptr, guint32, MonoResolveTokenError_ref))
HANDLES(MODULE_12, "ResolveTypeToken", ves_icall_System_Reflection_RuntimeModule_ResolveTypeToken, MonoType_ptr, 5, (MonoImage_ptr, guint32, MonoArray, MonoArray, MonoResolveTokenError_ref))
HANDLES(MODULE_13, "get_MetadataToken", ves_icall_reflection_get_token, guint32, 1, (MonoObject))

ICALL_TYPE(PARAMI, "System.Reflection.RuntimeParameterInfo", MPARAMI_1)
HANDLES_REUSE_WRAPPER(MPARAMI_1, "GetMetadataToken", ves_icall_reflection_get_token)
HANDLES(MPARAMI_2, "GetTypeModifiers", ves_icall_RuntimeParameterInfo_GetTypeModifiers, MonoArray, 4, (MonoReflectionType, MonoObject, int, MonoBoolean))

ICALL_TYPE(MPROP, "System.Reflection.RuntimePropertyInfo", MPROP_1)
HANDLES(MPROP_1, "GetTypeModifiers", ves_icall_RuntimePropertyInfo_GetTypeModifiers, MonoArray, 2, (MonoReflectionProperty, MonoBoolean))
HANDLES(MPROP_2, "get_default_value", ves_icall_property_info_get_default_value, MonoObject, 1, (MonoReflectionProperty))
HANDLES_REUSE_WRAPPER(MPROP_3, "get_metadata_token", ves_icall_reflection_get_token)
HANDLES(MPROP_4, "get_property_info", ves_icall_RuntimePropertyInfo_get_property_info, void, 3, (MonoReflectionProperty, MonoPropertyInfo_ref, PInfo))
HANDLES(MPROP_5, "internal_from_handle_type", ves_icall_System_Reflection_RuntimePropertyInfo_internal_from_handle_type, MonoReflectionProperty, 2, (MonoProperty_ptr, MonoType_ptr))

ICALL_TYPE(RUNH, "System.Runtime.CompilerServices.RuntimeHelpers", RUNH_1)
HANDLES(RUNH_1, "GetObjectValue", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetObjectValue, MonoObject, 1, (MonoObject))
HANDLES(RUNH_3, "InitializeArray", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray, void, 2, (MonoArray, MonoClassField_ptr))
HANDLES(RUNH_4, "RunClassConstructor", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunClassConstructor, void, 1, (MonoType_ptr))
HANDLES(RUNH_5, "RunModuleConstructor", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunModuleConstructor, void, 1, (MonoImage_ptr))
NOHANDLES(ICALL(RUNH_5h, "SufficientExecutionStack", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_SufficientExecutionStack))
NOHANDLES(ICALL(RUNH_6, "get_OffsetToStringData", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData))

ICALL_TYPE(GCH, "System.Runtime.InteropServices.GCHandle", GCH_1)
NOHANDLES(ICALL(GCH_1, "CheckCurrentDomain", ves_icall_System_GCHandle_CheckCurrentDomain))
NOHANDLES(ICALL(GCH_2, "FreeHandle", ves_icall_System_GCHandle_FreeHandle))
NOHANDLES(ICALL(GCH_3, "GetAddrOfPinnedObject", ves_icall_System_GCHandle_GetAddrOfPinnedObject))
HANDLES(GCH_4, "GetTarget", ves_icall_System_GCHandle_GetTarget, MonoObject, 1, (guint32))
HANDLES(GCH_5, "GetTargetHandle", ves_icall_System_GCHandle_GetTargetHandle, guint32, 3, (MonoObject, guint32, gint32))

#if !defined(DISABLE_COM) || defined (HOST_WIN32)
ICALL_TYPE(MARSHAL, "System.Runtime.InteropServices.Marshal", MARSHAL_1)
NOHANDLES(ICALL(MARSHAL_1, "AddRefInternal", ves_icall_System_Runtime_InteropServices_Marshal_AddRefInternal))
#else
ICALL_TYPE(MARSHAL, "System.Runtime.InteropServices.Marshal", MARSHAL_2)
#endif
NOHANDLES(ICALL(MARSHAL_2, "AllocCoTaskMem", ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMem))
NOHANDLES(ICALL(MARSHAL_51,"AllocCoTaskMemSize(uintptr)", ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMemSize))
NOHANDLES(ICALL(MARSHAL_3, "AllocHGlobal", ves_icall_System_Runtime_InteropServices_Marshal_AllocHGlobal))
NOHANDLES(ICALL(MARSHAL_50, "BufferToBSTR", ves_icall_System_Runtime_InteropServices_Marshal_BufferToBSTR))
HANDLES(MARSHAL_4, "DestroyStructure", ves_icall_System_Runtime_InteropServices_Marshal_DestroyStructure, void, 2, (gpointer, MonoReflectionType))
NOHANDLES(ICALL(MARSHAL_5, "FreeBSTR", ves_icall_System_Runtime_InteropServices_Marshal_FreeBSTR))
NOHANDLES(ICALL(MARSHAL_6, "FreeCoTaskMem", ves_icall_System_Runtime_InteropServices_Marshal_FreeCoTaskMem))
NOHANDLES(ICALL(MARSHAL_7, "FreeHGlobal", ves_icall_System_Runtime_InteropServices_Marshal_FreeHGlobal))
#ifndef DISABLE_COM
HANDLES(MARSHAL_44, "GetCCW", ves_icall_System_Runtime_InteropServices_Marshal_GetCCW, gpointer, 2, (MonoObject, MonoReflectionType))
HANDLES(MARSHAL_8, "GetComSlotForMethodInfoInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetComSlotForMethodInfoInternal, guint32, 1, (MonoReflectionMethod))
#endif
HANDLES(MARSHAL_9, "GetDelegateForFunctionPointerInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointerInternal, MonoDelegate, 2, (gpointer, MonoReflectionType))
HANDLES(MARSHAL_10, "GetFunctionPointerForDelegateInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetFunctionPointerForDelegateInternal, gpointer, 1, (MonoDelegate))
#ifndef DISABLE_COM
HANDLES(MARSHAL_52, "GetHRForException_WinRT", ves_icall_System_Runtime_InteropServices_Marshal_GetHRForException_WinRT, int, 1, (MonoException))
HANDLES(MARSHAL_45, "GetIDispatchForObjectInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetIDispatchForObjectInternal, gpointer, 1, (MonoObject))
HANDLES(MARSHAL_46, "GetIUnknownForObjectInternal", ves_icall_System_Runtime_InteropServices_Marshal_GetIUnknownForObjectInternal, gpointer, 1, (MonoObject))
#endif
NOHANDLES(ICALL(MARSHAL_11, "GetLastWin32Error", ves_icall_System_Runtime_InteropServices_Marshal_GetLastWin32Error))
#ifndef DISABLE_COM
HANDLES(MARSHAL_53, "GetNativeActivationFactory", ves_icall_System_Runtime_InteropServices_Marshal_GetNativeActivationFactory, MonoObject, 1, (MonoObject))
HANDLES(MARSHAL_47, "GetObjectForCCW", ves_icall_System_Runtime_InteropServices_Marshal_GetObjectForCCW, MonoObject, 1, (gpointer))
HANDLES(MARSHAL_54, "GetRawIUnknownForComObjectNoAddRef", ves_icall_System_Runtime_InteropServices_Marshal_GetRawIUnknownForComObjectNoAddRef, gpointer, 1, (MonoObject))
HANDLES(MARSHAL_48, "IsComObject", ves_icall_System_Runtime_InteropServices_Marshal_IsComObject, MonoBoolean, 1, (MonoObject))
#endif
HANDLES(MARSHAL_48a, "IsPinnableType", ves_icall_System_Runtime_InteropServices_Marshal_IsPinnableType, MonoBoolean, 1, (MonoReflectionType))
HANDLES(MARSHAL_12, "OffsetOf", ves_icall_System_Runtime_InteropServices_Marshal_OffsetOf, int, 2, (MonoReflectionType, MonoString))
HANDLES(MARSHAL_13, "Prelink", ves_icall_System_Runtime_InteropServices_Marshal_Prelink, void, 1, (MonoReflectionMethod))
HANDLES(MARSHAL_14, "PrelinkAll", ves_icall_System_Runtime_InteropServices_Marshal_PrelinkAll, void, 1, (MonoReflectionType))
HANDLES(MARSHAL_15, "PtrToStringAnsi(intptr)", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringAnsi, MonoString, 1, (const_char_ptr))
HANDLES(MARSHAL_16, "PtrToStringAnsi(intptr,int)", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringAnsi_len, MonoString, 2, (const_char_ptr, gint32))
HANDLES(MARSHAL_17, "PtrToStringBSTR", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringBSTR, MonoString, 1, (mono_bstr_const))
HANDLES(MARSHAL_18, "PtrToStringUni(intptr)", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringUni, MonoString, 1, (const_gunichar2_ptr))
HANDLES(MARSHAL_19, "PtrToStringUni(intptr,int)", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringUni_len, MonoString, 2, (const_gunichar2_ptr, gint32))
HANDLES(MARSHAL_20, "PtrToStructure(intptr,System.Type)", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructure_type, MonoObject, 2, (gconstpointer, MonoReflectionType))
HANDLES(MARSHAL_21, "PtrToStructure(intptr,object)", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructure, void, 2, (gconstpointer, MonoObject))
#if !defined (DISABLE_COM) || defined (HOST_WIN32)
NOHANDLES(ICALL(MARSHAL_22, "QueryInterfaceInternal", ves_icall_System_Runtime_InteropServices_Marshal_QueryInterfaceInternal))
#endif
NOHANDLES(ICALL(MARSHAL_43, "ReAllocCoTaskMem", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocCoTaskMem))
NOHANDLES(ICALL(MARSHAL_23, "ReAllocHGlobal", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocHGlobal))
#ifndef DISABLE_COM
HANDLES(MARSHAL_49, "ReleaseComObjectInternal", ves_icall_System_Runtime_InteropServices_Marshal_ReleaseComObjectInternal, gint32, 1, (MonoObject))
#endif
#if !defined (DISABLE_COM) || defined (HOST_WIN32)
NOHANDLES(ICALL(MARSHAL_29, "ReleaseInternal", ves_icall_System_Runtime_InteropServices_Marshal_ReleaseInternal))
#endif
NOHANDLES(ICALL(MARSHAL_29a, "SetLastWin32Error", ves_icall_System_Runtime_InteropServices_Marshal_SetLastWin32Error))
HANDLES(MARSHAL_30, "SizeOf", ves_icall_System_Runtime_InteropServices_Marshal_SizeOf, guint32, 1, (MonoReflectionType))
HANDLES(MARSHAL_31, "SizeOfHelper", ves_icall_System_Runtime_InteropServices_Marshal_SizeOfHelper, guint32, 2, (MonoReflectionType, MonoBoolean))
NOHANDLES(ICALL(MARSHAL_32, "StringToHGlobalAnsi", ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalAnsi))
NOHANDLES(ICALL(MARSHAL_33, "StringToHGlobalUni", ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalUni))
HANDLES(MARSHAL_34, "StructureToPtr", ves_icall_System_Runtime_InteropServices_Marshal_StructureToPtr, void, 3, (MonoObject, gpointer, MonoBoolean))
HANDLES(MARSHAL_35, "UnsafeAddrOfPinnedArrayElement", ves_icall_System_Runtime_InteropServices_Marshal_UnsafeAddrOfPinnedArrayElement, gpointer, 2, (MonoArray, int))
HANDLES(MARSHAL_41, "copy_from_unmanaged_fixed", ves_icall_System_Runtime_InteropServices_Marshal_copy_from_unmanaged, void, 5, (gconstpointer, gint32, MonoArray, gint32, gpointer))
HANDLES(MARSHAL_42, "copy_to_unmanaged_fixed", ves_icall_System_Runtime_InteropServices_Marshal_copy_to_unmanaged, void, 5, (MonoArray, gint32, gpointer, gint32, gconstpointer))

ICALL_TYPE(RUNTIMEINFO, "System.Runtime.InteropServices.RuntimeInformation", RUNTIMEINFO_1)
HANDLES(RUNTIMEINFO_1, "GetOSName", ves_icall_System_Runtime_InteropServices_RuntimeInformation_GetOSName, MonoString, 0, ())
HANDLES(RUNTIMEINFO_2, "GetRuntimeArchitecture", ves_icall_System_Runtime_InteropServices_RuntimeInformation_GetRuntimeArchitecture, MonoString, 0, ())

#ifndef DISABLE_COM
ICALL_TYPE(WINDOWSRUNTIME_UNM, "System.Runtime.InteropServices.WindowsRuntime.UnsafeNativeMethods", WINDOWSRUNTIME_UNM_0)
HANDLES(WINDOWSRUNTIME_UNM_0, "GetRestrictedErrorInfo", ves_icall_System_Runtime_InteropServices_WindowsRuntime_UnsafeNativeMethods_GetRestrictedErrorInfo, MonoObject, 0, ())
HANDLES(WINDOWSRUNTIME_UNM_1, "RoOriginateLanguageException", ves_icall_System_Runtime_InteropServices_WindowsRuntime_UnsafeNativeMethods_RoOriginateLanguageException, MonoBoolean, 3, (int, MonoString, gpointer))
HANDLES(WINDOWSRUNTIME_UNM_2, "RoReportUnhandledError", ves_icall_System_Runtime_InteropServices_WindowsRuntime_UnsafeNativeMethods_RoReportUnhandledError, void, 1, (MonoObject))
HANDLES(WINDOWSRUNTIME_UNM_3, "WindowsCreateString", ves_icall_System_Runtime_InteropServices_WindowsRuntime_UnsafeNativeMethods_WindowsCreateString, int, 3, (MonoString, int, gpointer_ptr))
HANDLES(WINDOWSRUNTIME_UNM_4, "WindowsDeleteString", ves_icall_System_Runtime_InteropServices_WindowsRuntime_UnsafeNativeMethods_WindowsDeleteString, int, 1, (gpointer))
HANDLES(WINDOWSRUNTIME_UNM_5, "WindowsGetStringRawBuffer", ves_icall_System_Runtime_InteropServices_WindowsRuntime_UnsafeNativeMethods_WindowsGetStringRawBuffer, mono_unichar2_ptr, 2, (gpointer, unsigned_ptr))
#endif

ICALL_TYPE(ACTS, "System.Runtime.Remoting.Activation.ActivationServices", ACTS_1)
HANDLES(ACTS_1, "AllocateUninitializedClassInstance", ves_icall_System_Runtime_Activation_ActivationServices_AllocateUninitializedClassInstance, MonoObject, 1, (MonoReflectionType))
HANDLES(ACTS_2, "EnableProxyActivation", ves_icall_System_Runtime_Activation_ActivationServices_EnableProxyActivation, void, 2, (MonoReflectionType, MonoBoolean))

ICALL_TYPE(CONTEXT, "System.Runtime.Remoting.Contexts.Context", CONTEXT_1)
HANDLES(CONTEXT_1, "RegisterContext", ves_icall_System_Runtime_Remoting_Contexts_Context_RegisterContext, void, 1, (MonoAppContext))
HANDLES(CONTEXT_2, "ReleaseContext", ves_icall_System_Runtime_Remoting_Contexts_Context_ReleaseContext, void, 1, (MonoAppContext))

ICALL_TYPE(ARES, "System.Runtime.Remoting.Messaging.AsyncResult", ARES_1)
HANDLES(ARES_1, "Invoke", ves_icall_System_Runtime_Remoting_Messaging_AsyncResult_Invoke, MonoObject, 1, (MonoAsyncResult))

#ifndef DISABLE_REMOTING
ICALL_TYPE(REALP, "System.Runtime.Remoting.Proxies.RealProxy", REALP_1)
HANDLES(REALP_1, "InternalGetProxyType", ves_icall_Remoting_RealProxy_InternalGetProxyType, MonoReflectionType, 1, (MonoTransparentProxy))
HANDLES(REALP_2, "InternalGetTransparentProxy", ves_icall_Remoting_RealProxy_GetTransparentProxy, MonoObject, 2, (MonoObject, MonoString))

ICALL_TYPE(REMSER, "System.Runtime.Remoting.RemotingServices", REMSER_0)
HANDLES(REMSER_0, "GetVirtualMethod", ves_icall_Remoting_RemotingServices_GetVirtualMethod, MonoReflectionMethod, 2, (MonoReflectionType, MonoReflectionMethod))
HANDLES(REMSER_1, "InternalExecute", ves_icall_InternalExecute, MonoObject, 4, (MonoReflectionMethod, MonoObject, MonoArray, MonoArrayOut))
HANDLES(REMSER_2, "IsTransparentProxy", ves_icall_IsTransparentProxy, MonoBoolean, 1, (MonoObject))
#endif

ICALL_TYPE(RUNIMPORT, "System.Runtime.RuntimeImports", RUNIMPORT_1)
NOHANDLES(ICALL(RUNIMPORT_1, "Memmove", ves_icall_System_Runtime_RuntimeImports_Memmove))
NOHANDLES(ICALL(RUNIMPORT_2, "Memmove_wbarrier", ves_icall_System_Runtime_RuntimeImports_Memmove_wbarrier))
NOHANDLES(ICALL(RUNIMPORT_3, "ZeroMemory", ves_icall_System_Runtime_RuntimeImports_ZeroMemory))
NOHANDLES(ICALL(RUNIMPORT_4, "_ecvt_s", ves_icall_System_Runtime_RuntimeImports_ecvt_s))

ICALL_TYPE(RVH, "System.Runtime.Versioning.VersioningHelper", RVH_1)
HANDLES(RVH_1, "GetRuntimeId", ves_icall_System_Runtime_Versioning_VersioningHelper_GetRuntimeId, gint32, 0, ())

ICALL_TYPE(RFH, "System.RuntimeFieldHandle", RFH_1)
HANDLES(RFH_1, "GetValueDirect", ves_icall_System_RuntimeFieldHandle_GetValueDirect, MonoObject, 4, (MonoReflectionField, MonoReflectionType, MonoTypedRef_ptr, MonoReflectionType))
HANDLES(RFH_1a, "SetValueDirect", ves_icall_System_RuntimeFieldHandle_SetValueDirect, void, 5, (MonoReflectionField, MonoReflectionType, MonoTypedRef_ptr, MonoObject, MonoReflectionType))
HANDLES_REUSE_WRAPPER(RFH_2, "SetValueInternal", ves_icall_RuntimeFieldInfo_SetValueInternal)

ICALL_TYPE(MHAN, "System.RuntimeMethodHandle", MHAN_1)
HANDLES(MHAN_1, "GetFunctionPointer", ves_icall_RuntimeMethodHandle_GetFunctionPointer, gpointer, 1, (MonoMethod_ptr))

ICALL_TYPE(RT, "System.RuntimeType", RT_1)
HANDLES(RT_1, "CreateInstanceInternal", ves_icall_System_Activator_CreateInstanceInternal, MonoObject, 1, (MonoReflectionType))
HANDLES(RT_2, "GetConstructors_native", ves_icall_RuntimeType_GetConstructors_native, GPtrArray_ptr, 2, (MonoReflectionType, guint32))
HANDLES(RT_30, "GetCorrespondingInflatedConstructor", ves_icall_RuntimeType_GetCorrespondingInflatedMethod, MonoReflectionMethod, 2, (MonoReflectionType, MonoReflectionMethod))
HANDLES_REUSE_WRAPPER(RT_31, "GetCorrespondingInflatedMethod", ves_icall_RuntimeType_GetCorrespondingInflatedMethod)
HANDLES(RT_3, "GetEvents_native", ves_icall_RuntimeType_GetEvents_native, GPtrArray_ptr, 3, (MonoReflectionType, char_ptr, guint32))
HANDLES(RT_5, "GetFields_native", ves_icall_RuntimeType_GetFields_native, GPtrArray_ptr, 4, (MonoReflectionType, char_ptr, guint32, guint32))
HANDLES(RT_6, "GetGenericArgumentsInternal", ves_icall_RuntimeType_GetGenericArguments, MonoArray, 2, (MonoReflectionType, MonoBoolean))
HANDLES(RT_9, "GetGenericParameterPosition", ves_icall_RuntimeType_GetGenericParameterPosition, gint32, 1, (MonoReflectionType))
HANDLES(RT_10, "GetInterfaceMapData", ves_icall_RuntimeType_GetInterfaceMapData, void, 4, (MonoReflectionType, MonoReflectionType, MonoArrayOut, MonoArrayOut))
HANDLES(RT_11, "GetInterfaces", ves_icall_RuntimeType_GetInterfaces, MonoArray, 1, (MonoReflectionType))
HANDLES(RT_12, "GetMethodsByName_native", ves_icall_RuntimeType_GetMethodsByName_native, GPtrArray_ptr, 4, (MonoReflectionType, const_char_ptr, guint32, guint32))
HANDLES(RT_13, "GetNestedTypes_native", ves_icall_RuntimeType_GetNestedTypes_native, GPtrArray_ptr, 4, (MonoReflectionType, char_ptr, guint32, guint32))
HANDLES(RT_14, "GetPacking", ves_icall_RuntimeType_GetPacking, void, 3, (MonoReflectionType, guint32_ref, guint32_ref))
HANDLES(RT_15, "GetPropertiesByName_native", ves_icall_RuntimeType_GetPropertiesByName_native, GPtrArray_ptr, 4, (MonoReflectionType, char_ptr, guint32, guint32))
HANDLES(RT_16, "GetTypeCodeImplInternal", ves_icall_type_GetTypeCodeInternal, guint32, 1, (MonoReflectionType))
HANDLES(RT_28, "IsTypeExportedToWindowsRuntime", ves_icall_System_RuntimeType_IsTypeExportedToWindowsRuntime, MonoBoolean, 0, ())
HANDLES(RT_29, "IsWindowsRuntimeObjectType", ves_icall_System_RuntimeType_IsWindowsRuntimeObjectType, MonoBoolean, 0, ())
HANDLES(RT_17, "MakeGenericType", ves_icall_RuntimeType_MakeGenericType, MonoReflectionType, 2, (MonoReflectionType, MonoArray))
HANDLES(RT_18, "MakePointerType", ves_icall_RuntimeType_MakePointerType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RT_19, "getFullName", ves_icall_System_RuntimeType_getFullName, MonoString, 3, (MonoReflectionType, MonoBoolean, MonoBoolean))
HANDLES(RT_21, "get_DeclaringMethod", ves_icall_RuntimeType_get_DeclaringMethod, MonoReflectionMethod, 1, (MonoReflectionType))
HANDLES(RT_22, "get_DeclaringType", ves_icall_RuntimeType_get_DeclaringType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RT_23, "get_Name", ves_icall_RuntimeType_get_Name, MonoString, 1, (MonoReflectionType))
HANDLES(RT_24, "get_Namespace", ves_icall_RuntimeType_get_Namespace, MonoString, 1, (MonoReflectionType))
HANDLES(RT_25, "get_core_clr_security_level", ves_icall_RuntimeType_get_core_clr_security_level, int, 1, (MonoReflectionType))
HANDLES(RT_26, "make_array_type", ves_icall_RuntimeType_make_array_type, MonoReflectionType, 2, (MonoReflectionType, int))
HANDLES(RT_27, "make_byref_type", ves_icall_RuntimeType_make_byref_type, MonoReflectionType, 1, (MonoReflectionType))

ICALL_TYPE(RTH, "System.RuntimeTypeHandle", RTH_1)
HANDLES(RTH_1, "GetArrayRank", ves_icall_RuntimeTypeHandle_GetArrayRank, gint32, 1, (MonoReflectionType))
HANDLES(RTH_2, "GetAssembly", ves_icall_RuntimeTypeHandle_GetAssembly, MonoReflectionAssembly, 1, (MonoReflectionType))
HANDLES(RTH_3, "GetAttributes", ves_icall_RuntimeTypeHandle_GetAttributes, guint32, 1, (MonoReflectionType))
HANDLES(RTH_4, "GetBaseType", ves_icall_RuntimeTypeHandle_GetBaseType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RTH_4a, "GetCorElementType", ves_icall_RuntimeTypeHandle_GetCorElementType, guint32, 1, (MonoReflectionType))
HANDLES(RTH_5, "GetElementType", ves_icall_RuntimeTypeHandle_GetElementType, MonoReflectionType, 1, (MonoReflectionType))
HANDLES(RTH_19, "GetGenericParameterInfo", ves_icall_RuntimeTypeHandle_GetGenericParameterInfo, MonoGenericParamInfo_ptr, 1, (MonoReflectionType))
HANDLES(RTH_6, "GetGenericTypeDefinition_impl", ves_icall_RuntimeTypeHandle_GetGenericTypeDefinition_impl, MonoReflectionType, 1, (MonoReflectionType))
HANDLES_REUSE_WRAPPER(RTH_7, "GetMetadataToken", ves_icall_reflection_get_token)
HANDLES(RTH_8, "GetModule", ves_icall_RuntimeTypeHandle_GetModule, MonoReflectionModule, 1, (MonoReflectionType))
HANDLES(RTH_9, "HasInstantiation", ves_icall_RuntimeTypeHandle_HasInstantiation, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_20, "HasReferences", ves_icall_RuntimeTypeHandle_HasReferences, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_21, "IsByRefLike", ves_icall_RuntimeTypeHandle_IsByRefLike, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_12, "IsComObject", ves_icall_RuntimeTypeHandle_IsComObject, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_13, "IsGenericTypeDefinition", ves_icall_RuntimeTypeHandle_IsGenericTypeDefinition, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_14, "IsGenericVariable", ves_icall_RuntimeTypeHandle_IsGenericVariable, MonoBoolean, 1, (MonoReflectionType))
HANDLES(RTH_15, "IsInstanceOfType", ves_icall_RuntimeTypeHandle_IsInstanceOfType, guint32, 2, (MonoReflectionType, MonoObject))
//HANDLES(RTH_17a, "is_subclass_of", ves_icall_RuntimeTypeHandle_is_subclass_of, MonoBoolean, 2, (MonoType_ptr, MonoType_ptr))
HANDLES(RTH_17a, "internal_from_name", ves_icall_System_RuntimeTypeHandle_internal_from_name, MonoReflectionType, 6, (MonoString, MonoStackCrawlMark_ptr, MonoReflectionAssembly, MonoBoolean, MonoBoolean, MonoBoolean))
NOHANDLES(ICALL(RTH_17b, "is_subclass_of", ves_icall_RuntimeTypeHandle_is_subclass_of))
HANDLES(RTH_18, "type_is_assignable_from", ves_icall_RuntimeTypeHandle_type_is_assignable_from, guint32, 2, (MonoReflectionType, MonoReflectionType))

ICALL_TYPE(RNG, "System.Security.Cryptography.RNGCryptoServiceProvider", RNG_1)
HANDLES(RNG_1, "RngClose", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngClose, void, 1, (gpointer))
HANDLES(RNG_2, "RngGetBytes", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngGetBytes, gpointer, 3, (gpointer, guchar_ptr, gssize))
HANDLES(RNG_3, "RngInitialize", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize, gpointer, 2, (const_guchar_ptr, gssize))
HANDLES(RNG_4, "RngOpen", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngOpen, MonoBoolean, 0, ())

ICALL_TYPE(EVID, "System.Security.Policy.Evidence", EVID_1)
HANDLES(EVID_1, "IsAuthenticodePresent", ves_icall_System_Security_Policy_Evidence_IsAuthenticodePresent, MonoBoolean, 1, (MonoReflectionAssembly))

ICALL_TYPE(WINID, "System.Security.Principal.WindowsIdentity", WINID_1)
HANDLES(WINID_1, "GetCurrentToken", ves_icall_System_Security_Principal_WindowsIdentity_GetCurrentToken, gpointer, 0, ())
HANDLES(WINID_2, "GetTokenName", ves_icall_System_Security_Principal_WindowsIdentity_GetTokenName, MonoString, 1, (gpointer))
HANDLES(WINID_3, "GetUserToken", ves_icall_System_Security_Principal_WindowsIdentity_GetUserToken, gpointer, 1, (MonoString))
HANDLES(WINID_4, "_GetRoles", ves_icall_System_Security_Principal_WindowsIdentity_GetRoles, MonoArray, 1, (gpointer))

ICALL_TYPE(WINIMP, "System.Security.Principal.WindowsImpersonationContext", WINIMP_1)
HANDLES(WINIMP_1, "CloseToken", ves_icall_System_Security_Principal_WindowsImpersonationContext_CloseToken, MonoBoolean, 1, (gpointer))
HANDLES(WINIMP_2, "DuplicateToken", ves_icall_System_Security_Principal_WindowsImpersonationContext_DuplicateToken, gpointer, 1, (gpointer))
HANDLES(WINIMP_3, "RevertToSelf", ves_icall_System_Security_Principal_WindowsImpersonationContext_RevertToSelf, MonoBoolean, 0, ())
HANDLES(WINIMP_4, "SetCurrentToken", ves_icall_System_Security_Principal_WindowsImpersonationContext_SetCurrentToken, MonoBoolean, 1, (gpointer))

ICALL_TYPE(WINPRIN, "System.Security.Principal.WindowsPrincipal", WINPRIN_1)
HANDLES(WINPRIN_1, "IsMemberOfGroupId", ves_icall_System_Security_Principal_WindowsPrincipal_IsMemberOfGroupId, MonoBoolean, 2, (gpointer, gpointer))
HANDLES(WINPRIN_2, "IsMemberOfGroupName", ves_icall_System_Security_Principal_WindowsPrincipal_IsMemberOfGroupName, MonoBoolean, 2, (gpointer, const_char_ptr))

ICALL_TYPE(SECSTRING, "System.Security.SecureString", SECSTRING_1)
HANDLES(SECSTRING_1, "DecryptInternal", ves_icall_System_Security_SecureString_DecryptInternal, void, 2, (MonoArray, MonoObject))
HANDLES(SECSTRING_2, "EncryptInternal", ves_icall_System_Security_SecureString_EncryptInternal, void, 2, (MonoArray, MonoObject))

ICALL_TYPE(SECMAN, "System.Security.SecurityManager", SECMAN_1)
NOHANDLES(ICALL(SECMAN_1, "get_RequiresElevatedPermissions", mono_security_core_clr_require_elevated_permissions))
NOHANDLES(ICALL(SECMAN_2, "get_SecurityEnabled", ves_icall_System_Security_SecurityManager_get_SecurityEnabled))
NOHANDLES(ICALL(SECMAN_3, "set_SecurityEnabled", ves_icall_System_Security_SecurityManager_set_SecurityEnabled))

ICALL_TYPE(STRING, "System.String", STRING_1)
NOHANDLES(ICALL(STRING_1, ".ctor(System.ReadOnlySpan`1<char>)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_1a, ".ctor(char*)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_2, ".ctor(char*,int,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_3, ".ctor(char,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_4, ".ctor(char[])", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_5, ".ctor(char[],int,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_6, ".ctor(sbyte*)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_7, ".ctor(sbyte*,int,int)", ves_icall_System_String_ctor_RedirectToCreateString))
NOHANDLES(ICALL(STRING_8, ".ctor(sbyte*,int,int,System.Text.Encoding)", ves_icall_System_String_ctor_RedirectToCreateString))
HANDLES(STRING_9, "FastAllocateString", ves_icall_System_String_FastAllocateString, MonoString, 1, (gint32))
HANDLES(STRING_10, "InternalIntern", ves_icall_System_String_InternalIntern, MonoString, 1, (MonoString))
HANDLES(STRING_11, "InternalIsInterned", ves_icall_System_String_InternalIsInterned, MonoString, 1, (MonoString))

ICALL_TYPE(TENC, "System.Text.EncodingHelper", TENC_1)
HANDLES(TENC_1, "InternalCodePage", ves_icall_System_Text_EncodingHelper_InternalCodePage, MonoString, 1, (gint32_ref))

ICALL_TYPE(UNORM, "System.Text.Normalization", UNORM_1)
HANDLES(UNORM_1, "load_normalization_resource", ves_icall_System_Text_Normalization_load_normalization_resource, void, 6, (guint8_ptr_ref, guint8_ptr_ref, guint8_ptr_ref, guint8_ptr_ref, guint8_ptr_ref, guint8_ptr_ref))

ICALL_TYPE(ILOCK, "System.Threading.Interlocked", ILOCK_1)
NOHANDLES(ICALL(ILOCK_1, "Add(int&,int)", ves_icall_System_Threading_Interlocked_Add_Int))
NOHANDLES(ICALL(ILOCK_2, "Add(long&,long)", ves_icall_System_Threading_Interlocked_Add_Long))
NOHANDLES(ICALL(ILOCK_4, "CompareExchange(double&,double,double)", ves_icall_System_Threading_Interlocked_CompareExchange_Double))
NOHANDLES(ICALL(ILOCK_5, "CompareExchange(int&,int,int)", ves_icall_System_Threading_Interlocked_CompareExchange_Int))
NOHANDLES(ICALL(ILOCK_6, "CompareExchange(int&,int,int,bool&)", ves_icall_System_Threading_Interlocked_CompareExchange_Int_Success))
NOHANDLES(ICALL(ILOCK_7, "CompareExchange(intptr&,intptr,intptr)", ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr))
NOHANDLES(ICALL(ILOCK_8, "CompareExchange(long&,long,long)", ves_icall_System_Threading_Interlocked_CompareExchange_Long))
NOHANDLES(ICALL(ILOCK_9, "CompareExchange(object&,object&,object&,object&)", ves_icall_System_Threading_Interlocked_CompareExchange_Object))
NOHANDLES(ICALL(ILOCK_10, "CompareExchange(single&,single,single)", ves_icall_System_Threading_Interlocked_CompareExchange_Single))
NOHANDLES(ICALL(ILOCK_11, "Decrement(int&)", ves_icall_System_Threading_Interlocked_Decrement_Int))
NOHANDLES(ICALL(ILOCK_12, "Decrement(long&)", ves_icall_System_Threading_Interlocked_Decrement_Long))
NOHANDLES(ICALL(ILOCK_14, "Exchange(double&,double)", ves_icall_System_Threading_Interlocked_Exchange_Double))
NOHANDLES(ICALL(ILOCK_15, "Exchange(int&,int)", ves_icall_System_Threading_Interlocked_Exchange_Int))
NOHANDLES(ICALL(ILOCK_16, "Exchange(intptr&,intptr)", ves_icall_System_Threading_Interlocked_Exchange_IntPtr))
NOHANDLES(ICALL(ILOCK_17, "Exchange(long&,long)", ves_icall_System_Threading_Interlocked_Exchange_Long))
NOHANDLES(ICALL(ILOCK_18, "Exchange(object&,object&,object&)", ves_icall_System_Threading_Interlocked_Exchange_Object))
NOHANDLES(ICALL(ILOCK_19, "Exchange(single&,single)", ves_icall_System_Threading_Interlocked_Exchange_Single))
NOHANDLES(ICALL(ILOCK_20, "Increment(int&)", ves_icall_System_Threading_Interlocked_Increment_Int))
NOHANDLES(ICALL(ILOCK_21, "Increment(long&)", ves_icall_System_Threading_Interlocked_Increment_Long))
NOHANDLES(ICALL(ILOCK_22, "MemoryBarrierProcessWide", ves_icall_System_Threading_Interlocked_MemoryBarrierProcessWide))
NOHANDLES(ICALL(ILOCK_23, "Read(long&)", ves_icall_System_Threading_Interlocked_Read_Long))

ICALL_TYPE(ITHREAD, "System.Threading.InternalThread", ITHREAD_1)
HANDLES(ITHREAD_1, "Thread_free_internal", ves_icall_System_Threading_InternalThread_Thread_free_internal, void, 1, (MonoInternalThread))

ICALL_TYPE(MONIT, "System.Threading.Monitor", MONIT_8)
HANDLES(MONIT_8, "Enter", ves_icall_System_Threading_Monitor_Monitor_Enter, void, 1, (MonoObject))
HANDLES(MONIT_1, "Exit", mono_monitor_exit_icall, void, 1, (MonoObject))
HANDLES(MONIT_2, "Monitor_pulse", ves_icall_System_Threading_Monitor_Monitor_pulse, void, 1, (MonoObject))
HANDLES(MONIT_3, "Monitor_pulse_all", ves_icall_System_Threading_Monitor_Monitor_pulse_all, void, 1, (MonoObject))
HANDLES(MONIT_4, "Monitor_test_owner", ves_icall_System_Threading_Monitor_Monitor_test_owner, MonoBoolean, 1, (MonoObject))
HANDLES(MONIT_5, "Monitor_test_synchronised", ves_icall_System_Threading_Monitor_Monitor_test_synchronised, MonoBoolean, 1, (MonoObject))
HANDLES(MONIT_7, "Monitor_wait", ves_icall_System_Threading_Monitor_Monitor_wait, MonoBoolean, 2, (MonoObject, guint32))
HANDLES(MONIT_9, "try_enter_with_atomic_var", ves_icall_System_Threading_Monitor_Monitor_try_enter_with_atomic_var, void, 3, (MonoObject, guint32, MonoBoolean_ref))

ICALL_TYPE(MUTEX, "System.Threading.Mutex", MUTEX_1)
HANDLES(MUTEX_1, "CreateMutex_icall", ves_icall_System_Threading_Mutex_CreateMutex_icall, gpointer, 4, (MonoBoolean, const_gunichar2_ptr, gint32, MonoBoolean_ref))
HANDLES(MUTEX_2, "OpenMutex_icall", ves_icall_System_Threading_Mutex_OpenMutex_icall, gpointer, 4, (const_gunichar2_ptr, gint32, gint32, gint32_ref))
NOHANDLES(ICALL(MUTEX_3, "ReleaseMutex_internal", ves_icall_System_Threading_Mutex_ReleaseMutex_internal))

ICALL_TYPE(NATIVEC, "System.Threading.NativeEventCalls", NATIVEC_1)
NOHANDLES(ICALL(NATIVEC_1, "CloseEvent_internal", ves_icall_System_Threading_Events_CloseEvent_internal))
HANDLES(NATIVEC_2, "CreateEvent_icall", ves_icall_System_Threading_Events_CreateEvent_icall, gpointer, 5, (MonoBoolean, MonoBoolean, const_gunichar2_ptr, gint32, gint32_ref))
HANDLES(NATIVEC_3, "OpenEvent_icall", ves_icall_System_Threading_Events_OpenEvent_icall, gpointer, 4, (const_gunichar2_ptr, gint32, gint32, gint32_ref))
NOHANDLES(ICALL(NATIVEC_4, "ResetEvent_internal",  ves_icall_System_Threading_Events_ResetEvent_internal))
NOHANDLES(ICALL(NATIVEC_5, "SetEvent_internal",    ves_icall_System_Threading_Events_SetEvent_internal))

ICALL_TYPE(SEMA, "System.Threading.Semaphore", SEMA_1)
NOHANDLES(ICALL(SEMA_1, "CreateSemaphore_icall", ves_icall_System_Threading_Semaphore_CreateSemaphore_icall))
NOHANDLES(ICALL(SEMA_2, "OpenSemaphore_icall", ves_icall_System_Threading_Semaphore_OpenSemaphore_icall))
NOHANDLES(ICALL(SEMA_3, "ReleaseSemaphore_internal", ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal))

ICALL_TYPE(THREAD, "System.Threading.Thread", THREAD_1)
HANDLES(THREAD_1, "Abort_internal(System.Threading.InternalThread,object)", ves_icall_System_Threading_Thread_Abort, void, 2, (MonoInternalThread, MonoObject))
HANDLES(THREAD_1a, "ByteArrayToCurrentDomain(byte[])", ves_icall_System_Threading_Thread_ByteArrayToCurrentDomain, MonoArray, 1, (MonoArray))
HANDLES(THREAD_1b, "ByteArrayToRootDomain(byte[])", ves_icall_System_Threading_Thread_ByteArrayToRootDomain, MonoArray, 1, (MonoArray))
HANDLES(THREAD_2, "ClrState(System.Threading.InternalThread,System.Threading.ThreadState)", ves_icall_System_Threading_Thread_ClrState, void, 2, (MonoInternalThread, guint32))
HANDLES(THREAD_2a, "ConstructInternalThread", ves_icall_System_Threading_Thread_ConstructInternalThread, void, 1, (MonoThreadObject))
HANDLES(THREAD_55, "GetAbortExceptionState", ves_icall_System_Threading_Thread_GetAbortExceptionState, MonoObject, 1, (MonoThreadObject))
NOHANDLES(ICALL(THREAD_60, "GetCurrentThread_icall", ves_icall_System_Threading_Thread_GetCurrentThread))
HANDLES(THREAD_7, "GetDomainID", ves_icall_System_Threading_Thread_GetDomainID, gint32, 0, ())
HANDLES(THREAD_8, "GetName_internal(System.Threading.InternalThread)", ves_icall_System_Threading_Thread_GetName_internal, MonoString, 1, (MonoInternalThread))
HANDLES(THREAD_57, "GetPriorityNative", ves_icall_System_Threading_Thread_GetPriority, int, 1, (MonoThreadObject))
HANDLES(THREAD_59, "GetStackTraces", ves_icall_System_Threading_Thread_GetStackTraces, void, 2, (MonoArrayOut, MonoArrayOut))
HANDLES(THREAD_11, "GetState(System.Threading.InternalThread)", ves_icall_System_Threading_Thread_GetState, guint32, 1, (MonoInternalThread))
HANDLES(THREAD_53, "InterruptInternal", ves_icall_System_Threading_Thread_Interrupt_internal, void, 1, (MonoThreadObject))
HANDLES(THREAD_12, "JoinInternal", ves_icall_System_Threading_Thread_Join_internal, MonoBoolean, 2, (MonoThreadObject, int))
NOHANDLES(ICALL(THREAD_13, "MemoryBarrier", ves_icall_System_Threading_Thread_MemoryBarrier))
HANDLES(THREAD_14, "ResetAbortNative", ves_icall_System_Threading_Thread_ResetAbort, void, 1, (MonoThreadObject))
HANDLES(THREAD_15, "ResumeInternal", ves_icall_System_Threading_Thread_Resume, void, 1, (MonoThreadObject))
HANDLES(THREAD_18, "SetName_icall", ves_icall_System_Threading_Thread_SetName_icall, void, 3, (MonoInternalThread, const_gunichar2_ptr, gint32))
HANDLES(THREAD_58, "SetPriorityNative", ves_icall_System_Threading_Thread_SetPriority, void, 2, (MonoThreadObject, int))
HANDLES(THREAD_21, "SetState(System.Threading.InternalThread,System.Threading.ThreadState)", ves_icall_System_Threading_Thread_SetState, void, 2, (MonoInternalThread, guint32))
HANDLES(THREAD_22, "SleepInternal", ves_icall_System_Threading_Thread_Sleep_internal, void, 1, (gint32))
HANDLES(THREAD_54, "SpinWait_nop", ves_icall_System_Threading_Thread_SpinWait_nop, void, 0, ())
HANDLES(THREAD_23, "SuspendInternal", ves_icall_System_Threading_Thread_Suspend, void, 1, (MonoThreadObject))
// FIXME SystemMaxStackStize should be SystemMaxStackSize
NOHANDLES(ICALL(THREAD_56, "SystemMaxStackStize", ves_icall_System_Threading_Thread_SystemMaxStackSize))
HANDLES(THREAD_25, "Thread_internal", ves_icall_System_Threading_Thread_Thread_internal, MonoBoolean, 2, (MonoThreadObject, MonoObject))
NOHANDLES(ICALL(THREAD_26, "VolatileRead(byte&)", ves_icall_System_Threading_Thread_VolatileRead1))
NOHANDLES(ICALL(THREAD_27, "VolatileRead(double&)", ves_icall_System_Threading_Thread_VolatileReadDouble))
NOHANDLES(ICALL(THREAD_28, "VolatileRead(int&)", ves_icall_System_Threading_Thread_VolatileRead4))
NOHANDLES(ICALL(THREAD_29, "VolatileRead(int16&)", ves_icall_System_Threading_Thread_VolatileRead2))
NOHANDLES(ICALL(THREAD_30, "VolatileRead(intptr&)", ves_icall_System_Threading_Thread_VolatileReadIntPtr))
NOHANDLES(ICALL(THREAD_31, "VolatileRead(long&)", ves_icall_System_Threading_Thread_VolatileRead8))
NOHANDLES(ICALL(THREAD_32, "VolatileRead(object&)", ves_icall_System_Threading_Thread_VolatileReadObject))
NOHANDLES(ICALL(THREAD_33, "VolatileRead(sbyte&)", ves_icall_System_Threading_Thread_VolatileRead1))
NOHANDLES(ICALL(THREAD_34, "VolatileRead(single&)", ves_icall_System_Threading_Thread_VolatileReadFloat))
NOHANDLES(ICALL(THREAD_35, "VolatileRead(uint&)", ves_icall_System_Threading_Thread_VolatileRead4))
NOHANDLES(ICALL(THREAD_36, "VolatileRead(uint16&)", ves_icall_System_Threading_Thread_VolatileRead2))
NOHANDLES(ICALL(THREAD_37, "VolatileRead(uintptr&)", ves_icall_System_Threading_Thread_VolatileReadIntPtr))
NOHANDLES(ICALL(THREAD_38, "VolatileRead(ulong&)", ves_icall_System_Threading_Thread_VolatileRead8))
NOHANDLES(ICALL(THREAD_39, "VolatileWrite(byte&,byte)", ves_icall_System_Threading_Thread_VolatileWrite1))
NOHANDLES(ICALL(THREAD_40, "VolatileWrite(double&,double)", ves_icall_System_Threading_Thread_VolatileWriteDouble))
NOHANDLES(ICALL(THREAD_41, "VolatileWrite(int&,int)", ves_icall_System_Threading_Thread_VolatileWrite4))
NOHANDLES(ICALL(THREAD_42, "VolatileWrite(int16&,int16)", ves_icall_System_Threading_Thread_VolatileWrite2))
NOHANDLES(ICALL(THREAD_43, "VolatileWrite(intptr&,intptr)", ves_icall_System_Threading_Thread_VolatileWriteIntPtr))
NOHANDLES(ICALL(THREAD_44, "VolatileWrite(long&,long)", ves_icall_System_Threading_Thread_VolatileWrite8))
NOHANDLES(ICALL(THREAD_45, "VolatileWrite(object&,object)", ves_icall_System_Threading_Thread_VolatileWriteObject))
NOHANDLES(ICALL(THREAD_46, "VolatileWrite(sbyte&,sbyte)", ves_icall_System_Threading_Thread_VolatileWrite1))
NOHANDLES(ICALL(THREAD_47, "VolatileWrite(single&,single)", ves_icall_System_Threading_Thread_VolatileWriteFloat))
NOHANDLES(ICALL(THREAD_48, "VolatileWrite(uint&,uint)", ves_icall_System_Threading_Thread_VolatileWrite4))
NOHANDLES(ICALL(THREAD_49, "VolatileWrite(uint16&,uint16)", ves_icall_System_Threading_Thread_VolatileWrite2))
NOHANDLES(ICALL(THREAD_50, "VolatileWrite(uintptr&,uintptr)", ves_icall_System_Threading_Thread_VolatileWriteIntPtr))
NOHANDLES(ICALL(THREAD_51, "VolatileWrite(ulong&,ulong)", ves_icall_System_Threading_Thread_VolatileWrite8))
NOHANDLES(ICALL(THREAD_9, "YieldInternal", ves_icall_System_Threading_Thread_YieldInternal))

ICALL_TYPE(THREADP, "System.Threading.ThreadPool", THREADP_2)
HANDLES(THREADP_2, "GetAvailableThreadsNative", ves_icall_System_Threading_ThreadPool_GetAvailableThreadsNative, void, 2, (gint32_ref, gint32_ref))
HANDLES(THREADP_3, "GetMaxThreadsNative", ves_icall_System_Threading_ThreadPool_GetMaxThreadsNative, void, 2, (gint32_ref, gint32_ref))
HANDLES(THREADP_4, "GetMinThreadsNative", ves_icall_System_Threading_ThreadPool_GetMinThreadsNative, void, 2, (gint32_ref, gint32_ref))
HANDLES(THREADP_5, "InitializeVMTp", ves_icall_System_Threading_ThreadPool_InitializeVMTp, void, 1, (MonoBoolean_ref))
HANDLES(THREADP_7, "NotifyWorkItemComplete", ves_icall_System_Threading_ThreadPool_NotifyWorkItemComplete, MonoBoolean, 0, ())
HANDLES(THREADP_8, "NotifyWorkItemProgressNative", ves_icall_System_Threading_ThreadPool_NotifyWorkItemProgressNative, void, 0, ())
HANDLES(THREADP_8m, "NotifyWorkItemQueued", ves_icall_System_Threading_ThreadPool_NotifyWorkItemQueued, void, 0, ())
HANDLES(THREADP_11, "ReportThreadStatus", ves_icall_System_Threading_ThreadPool_ReportThreadStatus, void, 1, (MonoBoolean))
HANDLES(THREADP_12, "RequestWorkerThread", ves_icall_System_Threading_ThreadPool_RequestWorkerThread, MonoBoolean, 0, ())
HANDLES(THREADP_13, "SetMaxThreadsNative", ves_icall_System_Threading_ThreadPool_SetMaxThreadsNative, MonoBoolean, 2, (gint32, gint32))
HANDLES(THREADP_14, "SetMinThreadsNative", ves_icall_System_Threading_ThreadPool_SetMinThreadsNative, MonoBoolean, 2, (gint32, gint32))

ICALL_TYPE(TTIMER, "System.Threading.Timer", TTIMER_1)
NOHANDLES(ICALL(TTIMER_1, "GetTimeMonotonic", ves_icall_System_Threading_Timer_GetTimeMonotonic))

ICALL_TYPE(VOLATILE, "System.Threading.Volatile", VOLATILE_1)
NOHANDLES(ICALL(VOLATILE_1, "Read(double&)", ves_icall_System_Threading_Volatile_ReadDouble))
NOHANDLES(ICALL(VOLATILE_2, "Read(long&)", ves_icall_System_Threading_Volatile_Read8))
NOHANDLES(ICALL(VOLATILE_3, "Read(ulong&)", ves_icall_System_Threading_Volatile_ReadU8))
NOHANDLES(ICALL(VOLATILE_4, "Write(double&,double)", ves_icall_System_Threading_Volatile_WriteDouble))
NOHANDLES(ICALL(VOLATILE_5, "Write(long&,long)", ves_icall_System_Threading_Volatile_Write8))
NOHANDLES(ICALL(VOLATILE_6, "Write(ulong&,ulong)", ves_icall_System_Threading_Volatile_WriteU8))

ICALL_TYPE(WAITH, "System.Threading.WaitHandle", WAITH_1)
HANDLES(WAITH_1, "SignalAndWait_Internal", ves_icall_System_Threading_WaitHandle_SignalAndWait_Internal, gint32, 3, (gpointer, gpointer, gint32))
HANDLES(WAITH_2, "Wait_internal", ves_icall_System_Threading_WaitHandle_Wait_internal, gint32, 4, (gpointer_ptr, gint32, MonoBoolean, gint32))

ICALL_TYPE(TYPE, "System.Type", TYPE_1)
HANDLES(TYPE_1, "internal_from_handle", ves_icall_System_Type_internal_from_handle, MonoReflectionType, 1, (MonoType_ref))

ICALL_TYPE(TYPEDR, "System.TypedReference", TYPEDR_1)
HANDLES(TYPEDR_1, "InternalMakeTypedReference", ves_icall_System_TypedReference_InternalMakeTypedReference, void, 4, (MonoTypedRef_ptr, MonoObject, MonoArray, MonoReflectionType))
HANDLES(TYPEDR_2, "InternalToObject", ves_icall_System_TypedReference_ToObject, MonoObject, 1, (MonoTypedRef_ptr))

ICALL_TYPE(VALUET, "System.ValueType", VALUET_1)
HANDLES(VALUET_1, "InternalEquals", ves_icall_System_ValueType_Equals, MonoBoolean, 3, (MonoObject, MonoObject, MonoArrayOut))
HANDLES(VALUET_2, "InternalGetHashCode", ves_icall_System_ValueType_InternalGetHashCode, gint32, 2, (MonoObject, MonoArrayOut))

ICALL_TYPE(WEBIC, "System.Web.Util.ICalls", WEBIC_1)
HANDLES_REUSE_WRAPPER(WEBIC_1, "GetMachineConfigPath", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path, MonoString, 0, ())
HANDLES(WEBIC_2, "GetMachineInstallDirectory", ves_icall_System_Web_Util_ICalls_get_machine_install_dir, MonoString, 0, ())
HANDLES(WEBIC_3, "GetUnmanagedResourcesPtr", ves_icall_get_resources_ptr, MonoBoolean, 3, (MonoReflectionAssembly, gpointer_ref, gint32_ref))

#ifndef DISABLE_COM
ICALL_TYPE(COMOBJ, "System.__ComObject", COMOBJ_1)
HANDLES(COMOBJ_1, "CreateRCW", ves_icall_System_ComObject_CreateRCW, MonoObject, 1, (MonoReflectionType))
HANDLES(COMOBJ_2, "GetInterfaceInternal", ves_icall_System_ComObject_GetInterfaceInternal, gpointer, 3, (MonoComObject, MonoReflectionType, MonoBoolean))
HANDLES(COMOBJ_3, "ReleaseInterfaces", ves_icall_System_ComObject_ReleaseInterfaces, void, 1, (MonoComObject))
#endif

#endif

// This is similar to HANDLES() but is for icalls passed to register_jit_icall.
// There is no metadata for these. No signature matching.
// Presently their wrappers are less efficient, but hopefully that can be fixed,
// by making a direct call to them, inserting the LMF below them (possibly,
// providing it to them via a function pointer, if it cannot be done in C),
// and of course using managed-style coop handles within them.
// Alternately, ilgen.
//
// This is not just for register_icall, for any time coop wrappers are needed,
// that there is no metadata for. For example embedding API.

// helper for the managed alloc support
MONO_HANDLE_REGISTER_ICALL (ves_icall_string_alloc, MonoString, 1, (int))

// Windows: Allocates with CoTaskMemAlloc.
// Unix: Allocates with g_malloc.
// Either way: Free with mono_marshal_free (Windows:CoTaskMemFree, Unix:g_free).
MONO_HANDLE_REGISTER_ICALL (mono_string_to_utf8str, gpointer, 1, (MonoString))

MONO_HANDLE_REGISTER_ICALL (mono_array_to_byte_byvalarray, void, 3, (gpointer, MonoArray, guint32))
MONO_HANDLE_REGISTER_ICALL (mono_array_to_lparray, gpointer, 1, (MonoArray))
MONO_HANDLE_REGISTER_ICALL (mono_array_to_savearray, gpointer, 1, (MonoArray))
MONO_HANDLE_REGISTER_ICALL (mono_byvalarray_to_byte_array, void, 3, (MonoArray, const_char_ptr, guint32))
MONO_HANDLE_REGISTER_ICALL (mono_delegate_to_ftnptr, gpointer, 1, (MonoDelegate))
MONO_HANDLE_REGISTER_ICALL (mono_free_lparray, void, 2, (MonoArray, gpointer_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_ftnptr_to_delegate, MonoDelegate, 2, (MonoClass_ptr, gpointer))
MONO_HANDLE_REGISTER_ICALL (mono_marshal_asany, gpointer, 3, (MonoObject, MonoMarshalNative, int))
MONO_HANDLE_REGISTER_ICALL (mono_marshal_free_asany, void, 4, (MonoObject, gpointer, MonoMarshalNative, int))
MONO_HANDLE_REGISTER_ICALL (mono_marshal_string_to_utf16_copy, gunichar2_ptr, 1, (MonoString))
MONO_HANDLE_REGISTER_ICALL (mono_object_isinst_icall, MonoObject, 2, (MonoObject, MonoClass_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_string_builder_to_utf16, gunichar2_ptr, 1, (MonoStringBuilder))
MONO_HANDLE_REGISTER_ICALL (mono_string_builder_to_utf8, char_ptr, 1, (MonoStringBuilder))
MONO_HANDLE_REGISTER_ICALL (mono_string_from_bstr_icall, MonoString, 1, (mono_bstr_const))
MONO_HANDLE_REGISTER_ICALL (mono_string_from_byvalstr, MonoString, 2, (const_char_ptr, int))
MONO_HANDLE_REGISTER_ICALL (mono_string_from_byvalwstr, MonoString, 2, (const_gunichar2_ptr, int))
MONO_HANDLE_REGISTER_ICALL (mono_string_new_len_wrapper, MonoString, 2, (const_char_ptr, guint))
MONO_HANDLE_REGISTER_ICALL (mono_string_new_wrapper_internal, MonoString, 1, (const_char_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_string_to_ansibstr, gpointer, 1, (MonoString))
MONO_HANDLE_REGISTER_ICALL (mono_string_to_bstr, mono_bstr, 1, (MonoString))
MONO_HANDLE_REGISTER_ICALL (mono_string_to_byvalstr, void, 3, (char_ptr, MonoString, int))
MONO_HANDLE_REGISTER_ICALL (mono_string_to_byvalwstr, void, 3, (gunichar2_ptr, MonoString, int))
MONO_HANDLE_REGISTER_ICALL (mono_string_to_utf16_internal, mono_unichar2_ptr, 1, (MonoString))
MONO_HANDLE_REGISTER_ICALL (mono_string_to_utf32_internal, mono_unichar4_ptr, 1, (MonoString)) // embedding API
MONO_HANDLE_REGISTER_ICALL (mono_string_utf16_to_builder, void, 2, (MonoStringBuilder, const_gunichar2_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_string_utf16_to_builder2, MonoStringBuilder, 1, (const_gunichar2_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_string_utf8_to_builder, void, 2, (MonoStringBuilder, const_char_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_string_utf8_to_builder2, MonoStringBuilder, 1, (const_char_ptr))
MONO_HANDLE_REGISTER_ICALL (mono_type_from_handle, MonoReflectionType, 1, (MonoType_ptr)) // called by icalls
MONO_HANDLE_REGISTER_ICALL (ves_icall_marshal_alloc, gpointer, 1, (gsize))
MONO_HANDLE_REGISTER_ICALL (ves_icall_mono_marshal_xdomain_copy_value, MonoObject, 1, (MonoObject))
MONO_HANDLE_REGISTER_ICALL (ves_icall_mono_string_from_utf16, MonoString, 1, (const_gunichar2_ptr))
MONO_HANDLE_REGISTER_ICALL (ves_icall_mono_string_to_utf8, char_ptr, 1, (MonoString))
MONO_HANDLE_REGISTER_ICALL (ves_icall_string_new_wrapper, MonoString, 1, (const_char_ptr))

```

`Hazel/vendor/mono/include/mono/metadata/icall-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_ICALL_INTERNALS_H__
#define __MONO_METADATA_ICALL_INTERNALS_H__

#include <config.h>
#include <glib.h>
#include <mono/metadata/object-internals.h>

// On Windows platform implementation of bellow methods are hosted in separate source file
// icall-windows.c or icall-windows-*.c. On other platforms the implementation is still keept
// in icall.c still declared as static and in some places even inlined.
#ifdef HOST_WIN32
void
mono_icall_make_platform_path (gchar *path);

const gchar *
mono_icall_get_file_path_prefix (const gchar *path);

gpointer
mono_icall_module_get_hinstance (MonoImage *image);

MonoStringHandle
mono_icall_get_machine_name (MonoError *error);

int
mono_icall_get_platform (void);

MonoStringHandle
mono_icall_get_new_line (MonoError *error);

MonoBoolean
mono_icall_is_64bit_os (void);

MonoArrayHandle
mono_icall_get_environment_variable_names (MonoError *error);

void
mono_icall_set_environment_variable (MonoString *name, MonoString *value);

MonoStringHandle
mono_icall_get_windows_folder_path (int folder, MonoError *error);

void
mono_icall_write_windows_debug_string (const gunichar2 *message);

gint32
mono_icall_wait_for_input_idle (gpointer handle, gint32 milliseconds);
#endif  /* HOST_WIN32 */

// On platforms not using classic WIN API support the  implementation of bellow methods are hosted in separate source file
// icall-windows-*.c. On platforms using classic WIN API the implementation is still keept in icall.c and still declared
// static and in some places even inlined.
#if !G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
MonoArray *
mono_icall_get_logical_drives (void);

guint32
mono_icall_drive_info_get_drive_type (MonoString *root_path_name);
#endif  /* !G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) */

gconstpointer
mono_lookup_internal_call_full (MonoMethod *method, gboolean warn_on_missing, mono_bool *uses_handles, mono_bool *foreign);

MONO_PAL_API void
mono_add_internal_call_with_flags (const char *name, const void* method, gboolean cooperative);

MONO_PROFILER_API void
mono_add_internal_call_internal (const char *name, gconstpointer method);

MonoAssembly*
mono_runtime_get_caller_from_stack_mark (MonoStackCrawlMark *stack_mark);

typedef enum {
	MONO_ICALL_FLAGS_NONE = 0,
	MONO_ICALL_FLAGS_FOREIGN = 1 << 1,
	MONO_ICALL_FLAGS_USES_HANDLES = 1 << 2,
	MONO_ICALL_FLAGS_COOPERATIVE = 1 << 3
} MonoInternalCallFlags;

gconstpointer
mono_lookup_internal_call_full_with_flags (MonoMethod *method, gboolean warn_on_missing, guint32 *flags);

gboolean
mono_is_missing_icall_addr (gconstpointer addr);

#ifdef __cplusplus

#if !HOST_ANDROID

#include <type_traits>

#endif

template <typename T>
#if HOST_ANDROID
inline void
#else
inline typename std::enable_if<std::is_function<T>::value ||
			       std::is_function<typename std::remove_pointer<T>::type>::value >::type
#endif
mono_add_internal_call_with_flags (const char *name, T method, gboolean cooperative)
{
	return mono_add_internal_call_with_flags (name, (const void*)method, cooperative);
}

template <typename T>
#if HOST_ANDROID
inline void
#else
inline typename std::enable_if<std::is_function<T>::value ||
			       std::is_function<typename std::remove_pointer<T>::type>::value >::type
#endif
mono_add_internal_call_internal (const char *name, T method)
{
	return mono_add_internal_call_internal (name, (const void*)method);
}

#endif // __cplusplus

#endif /* __MONO_METADATA_ICALL_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/icall-signatures.h`:

```h
/**
 * \file
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 *
 * Previously JIT icall signatures were presented as strings,
 * subject to parsing and hashing and allocations and locking.
 * Here they are statically allocated and almost statically initialized.
 * There is no parsing, locking, or hashing.
 */
#ifndef __MONO_METADATA_ICALL_SIGNATURES_H__
#define __MONO_METADATA_ICALL_SIGNATURES_H__

// FIXME Some of these are only needed under ifdef.
// FIXME Some of these are redundant like obj vs. object, int vs. int32.
//
// count and types, where first type is return type
// and the rest are the parameter types.
//
// There are tradeoffs either way as to if return
// type is part of the parameter list.
//
// Define the following symbols via token pasting.
// These are listed here for code search.
//
// mono_icall_sig_object
// mono_icall_sig_ptr
// mono_icall_sig_void
// mono_icall_sig_double_double
// mono_icall_sig_double_int32
// mono_icall_sig_double_long
// mono_icall_sig_double_ptr
// mono_icall_sig_float_long
// mono_icall_sig_int_obj
// mono_icall_sig_int16_double
// mono_icall_sig_int32_double
// mono_icall_sig_int32_obj
// mono_icall_sig_int32_object // alias of previous
// mono_icall_sig_int8_double
// mono_icall_sig_long_double
// mono_icall_sig_long_float
// mono_icall_sig_obj_ptr
// mono_icall_sig_object_int
// mono_icall_sig_object_int32
// mono_icall_sig_object_object
// mono_icall_sig_object_ptr // alias
// mono_icall_sig_ptr_int
// mono_icall_sig_ptr_obj
// mono_icall_sig_ptr_object // alias of previous
// mono_icall_sig_ptr_ptr
// mono_icall_sig_uint16_double
// mono_icall_sig_uint32_double
// mono_icall_sig_uint32_float
// mono_icall_sig_uint8_double
// mono_icall_sig_ulong_double
// mono_icall_sig_ulong_float
// mono_icall_sig_void_int
// mono_icall_sig_void_int32
// mono_icall_sig_void_object
// mono_icall_sig_void_ptr
// mono_icall_sig_bool_ptr_ptrref
// mono_icall_sig_double_double_double
// mono_icall_sig_float_float_float
// mono_icall_sig_int_obj_ptr
// mono_icall_sig_int32_int32_int32
// mono_icall_sig_int32_int32_ptr
// mono_icall_sig_int32_int32_ptrref
// mono_icall_sig_int32_ptr_ptr
// mono_icall_sig_int32_ptr_ptrref
// mono_icall_sig_long_long_int32
// mono_icall_sig_long_long_long
// mono_icall_sig_obj_ptr_int // alias
// mono_icall_sig_object_int_object
// mono_icall_sig_object_object_ptr
// mono_icall_sig_object_ptr_int
// mono_icall_sig_object_ptr_int32
// mono_icall_sig_object_ptr_ptr
// mono_icall_sig_ptr_int32_ptrref
// mono_icall_sig_ptr_object_ptr
// mono_icall_sig_ptr_ptr_int
// mono_icall_sig_ptr_ptr_int32
// mono_icall_sig_ptr_ptr_ptr
// mono_icall_sig_ptr_ptr_ptrref
// mono_icall_sig_ptr_uint32_ptrref
// mono_icall_sig_uint32_double_double
// mono_icall_sig_uint32_ptr_int32
// mono_icall_sig_void_double_ptr
// mono_icall_sig_void_int32_ptrref
// mono_icall_sig_void_obj_ptr
// mono_icall_sig_void_object_object
// mono_icall_sig_void_object_ptr // alias
// mono_icall_sig_void_ptr_int
// mono_icall_sig_void_ptr_int32
// mono_icall_sig_void_ptr_object
// mono_icall_sig_void_ptr_ptr
// mono_icall_sig_void_ptr_ptrref
// mono_icall_sig_void_uint32_ptrref
// mono_icall_sig_bool_ptr_int32_ptrref
// mono_icall_sig_int32_int32_ptr_ptrref
// mono_icall_sig_int32_ptr_int32_ptr
// mono_icall_sig_int32_ptr_int32_ptrref
// mono_icall_sig_object_int_object_object
// mono_icall_sig_object_object_ptr_ptr
// mono_icall_sig_object_ptr_int_int
// mono_icall_sig_object_ptr_int_int32
// mono_icall_sig_object_ptr_int_ptr
// mono_icall_sig_object_ptr_ptr_int32
// mono_icall_sig_ptr_object_int32_int32
// mono_icall_sig_ptr_object_ptr_ptr
// mono_icall_sig_ptr_ptr_int_ptr
// mono_icall_sig_ptr_ptr_int32_ptrref
// mono_icall_sig_ptr_ptr_ptr_ptr
// mono_icall_sig_ptr_ptr_ptr_ptrref
// mono_icall_sig_ptr_ptr_uint32_ptrref
// mono_icall_sig_void_object_object_ptr
// mono_icall_sig_void_object_ptr_int32
// mono_icall_sig_void_ptr_int_object
// mono_icall_sig_void_ptr_int_ptr
// mono_icall_sig_void_ptr_object_int32
// mono_icall_sig_void_ptr_ptr_int
// mono_icall_sig_void_ptr_ptr_int32
// mono_icall_sig_void_ptr_ptr_ptr
// mono_icall_sig_void_ptr_ptr_ptrref
// mono_icall_sig_int32_object_ptr_ptr_ptr
// mono_icall_sig_object_object_ptr_ptr_ptr
// mono_icall_sig_object_ptr_int_int_int
// mono_icall_sig_ptr_object_int_ptr_ptr
// mono_icall_sig_ptr_ptr_int32_ptr_ptrref
// mono_icall_sig_ptr_ptr_ptr_int32_ptrref
// mono_icall_sig_ptr_ptr_ptr_ptr_ptrref
// mono_icall_sig_ptr_ptr_ptr_ptrref_ptrref
// mono_icall_sig_void_object_ptr_int32_int32
// mono_icall_sig_void_object_ptr_ptr_ptr
// mono_icall_sig_void_ptr_int_int_object
// mono_icall_sig_void_ptr_ptr_ptr_ptr
// mono_icall_sig_ptr_ptr_ptr_ptr_ptr
// mono_icall_sig_int_int_int_ptr_ptr_ptr
// mono_icall_sig_int_ptr_int_int_ptr_object
// mono_icall_sig_object_ptr_int_int_int_int
// mono_icall_sig_object_ptr_ptr_ptr_ptr_ptr
// mono_icall_sig_ptr_ptr_int32_ptr_ptr_ptrref
// mono_icall_sig_void_ptr_ptr_int32_ptr_ptrref
// mono_icall_sig_void_ptr_ptr_ptr_ptr_ptr
// mono_icall_sig_ptr_ptr_ptr_ptr_ptr_ptr
// mono_icall_sig_int32_ptr_ptr_ptr_ptr_ptr_int32
// mono_icall_sig_void_ptr_ptr_ptr_ptr_ptr_ptr
// mono_icall_sig_ptr_ptr_ptr_ptr_ptr_ptr_ptr
// mono_icall_sig_void_ptr_ptr_int32_ptr_ptrref_ptr_ptrref

#define ICALL_SIGS				\
ICALL_SIG (1, (object))				\
ICALL_SIG (1, (ptr))				\
ICALL_SIG (1, (void))				\
ICALL_SIG (2, (double, double))			\
ICALL_SIG (2, (double, int32))			\
ICALL_SIG (2, (double, long))			\
ICALL_SIG (2, (double, ptr))			\
ICALL_SIG (2, (float, long))			\
ICALL_SIG (2, (int, obj))			\
ICALL_SIG (2, (int16, double))			\
ICALL_SIG (2, (int32, double))			\
ICALL_SIG (2, (int32, obj))			\
ICALL_SIG (2, (int32, object))			\
ICALL_SIG (2, (int8, double))			\
ICALL_SIG (2, (long, double))			\
ICALL_SIG (2, (long, float))			\
ICALL_SIG (2, (obj, ptr))			\
ICALL_SIG (2, (object, int))			\
ICALL_SIG (2, (object, int32))			\
ICALL_SIG (2, (object, object))			\
ICALL_SIG (2, (object, ptr))			\
ICALL_SIG (2, (ptr, int))			\
ICALL_SIG (2, (ptr, obj))			\
ICALL_SIG (2, (ptr, object))			\
ICALL_SIG (2, (ptr, ptr))			\
ICALL_SIG (2, (uint16, double))			\
ICALL_SIG (2, (uint32, double))			\
ICALL_SIG (2, (uint32, float))			\
ICALL_SIG (2, (uint8, double))			\
ICALL_SIG (2, (ulong, double))			\
ICALL_SIG (2, (ulong, float))			\
ICALL_SIG (2, (void, int))			\
ICALL_SIG (2, (void, int32))			\
ICALL_SIG (2, (void, object))			\
ICALL_SIG (2, (void, ptr))			\
ICALL_SIG (3, (bool, ptr, ptrref))		\
ICALL_SIG (3, (double, double, double))		\
ICALL_SIG (3, (float, float, float))		\
ICALL_SIG (3, (int, obj, ptr))			\
ICALL_SIG (3, (int32, int32, int32))		\
ICALL_SIG (3, (int32, int32, ptr))		\
ICALL_SIG (3, (int32, int32, ptrref))		\
ICALL_SIG (3, (int32, ptr, ptr))		\
ICALL_SIG (3, (int32, ptr, ptrref))		\
ICALL_SIG (3, (long, long, int32))		\
ICALL_SIG (3, (long, long, long))		\
ICALL_SIG (3, (obj, ptr, int))			\
ICALL_SIG (3, (object, int, object))		\
ICALL_SIG (3, (object, object, ptr))		\
ICALL_SIG (3, (object, ptr, int))		\
ICALL_SIG (3, (object, ptr, int32))		\
ICALL_SIG (3, (object, ptr, ptr))		\
ICALL_SIG (3, (ptr, int32, ptrref))		\
ICALL_SIG (3, (ptr, object, ptr))		\
ICALL_SIG (3, (ptr, ptr, int))			\
ICALL_SIG (3, (ptr, ptr, int32))		\
ICALL_SIG (3, (ptr, ptr, ptr))			\
ICALL_SIG (3, (ptr, ptr, ptrref))		\
ICALL_SIG (3, (ptr, uint32, ptrref))		\
ICALL_SIG (3, (uint32, double, double))		\
ICALL_SIG (3, (uint32, ptr, int32))		\
ICALL_SIG (3, (void, double, ptr))		\
ICALL_SIG (3, (void, int32, ptrref))		\
ICALL_SIG (3, (void, obj, ptr))			\
ICALL_SIG (3, (void, object, object))		\
ICALL_SIG (3, (void, object, ptr))		\
ICALL_SIG (3, (void, ptr, int))			\
ICALL_SIG (3, (void, ptr, int32))		\
ICALL_SIG (3, (void, ptr, object))		\
ICALL_SIG (3, (void, ptr, ptr))			\
ICALL_SIG (3, (void, ptr, ptrref))		\
ICALL_SIG (3, (void, uint32, ptrref))		\
ICALL_SIG (4, (bool, ptr, int32, ptrref))	\
ICALL_SIG (4, (int32, int32, ptr, ptrref))	\
ICALL_SIG (4, (int32, ptr, int32, ptr))		\
ICALL_SIG (4, (int32, ptr, int32, ptrref))	\
ICALL_SIG (4, (object, int, object, object))	\
ICALL_SIG (4, (object, object, ptr, ptr))	\
ICALL_SIG (4, (object, ptr, int, int))		\
ICALL_SIG (4, (object, ptr, int, int32))	\
ICALL_SIG (4, (object, ptr, int, ptr))	    \
ICALL_SIG (4, (object, ptr, ptr, int32))	\
ICALL_SIG (4, (ptr, object, int32, int32))	\
ICALL_SIG (4, (ptr, object, ptr, ptr))		\
ICALL_SIG (4, (ptr, ptr, int, ptr))		\
ICALL_SIG (4, (ptr, ptr, int32, ptrref))	\
ICALL_SIG (4, (ptr, ptr, ptr, ptr))		\
ICALL_SIG (4, (ptr, ptr, ptr, ptrref))		\
ICALL_SIG (4, (ptr, ptr, uint32, ptrref))	\
ICALL_SIG (4, (void, object, object, ptr))	\
ICALL_SIG (4, (void, object, ptr, int32))	\
ICALL_SIG (4, (void, ptr, int, object))		\
ICALL_SIG (4, (void, ptr, int, ptr))		\
ICALL_SIG (4, (void, ptr, object, int32))	\
ICALL_SIG (4, (void, ptr, ptr, int))		\
ICALL_SIG (4, (void, ptr, ptr, int32))		\
ICALL_SIG (4, (void, ptr, ptr, ptr))		\
ICALL_SIG (4, (void, ptr, ptr, ptrref))	\
ICALL_SIG (5, (int32, object, ptr, ptr, ptr)) 	\
ICALL_SIG (5, (object, object, ptr, ptr, ptr))	\
ICALL_SIG (5, (object, ptr, int, int, int))	\
ICALL_SIG (5, (ptr, object, int, ptr, ptr))	\
ICALL_SIG (5, (ptr, ptr, int32, ptr, ptrref))	\
ICALL_SIG (5, (ptr, ptr, ptr, int32, ptrref))	\
ICALL_SIG (5, (ptr, ptr, ptr, ptr, ptrref))	\
ICALL_SIG (5, (ptr, ptr, ptr, ptrref, ptrref))	\
ICALL_SIG (5, (void, object, ptr, int32, int32)) 	\
ICALL_SIG (5, (void, object, ptr, ptr, ptr))		\
ICALL_SIG (5, (void, ptr, int, int, object))		\
ICALL_SIG (5, (void, ptr, ptr, ptr, ptr))	\
ICALL_SIG (5, (void, ptr, ptr, int, object))	\
ICALL_SIG (5, (void, ptr, ptr, int, ptr))	\
ICALL_SIG (5, (ptr, ptr, ptr, ptr, ptr))	\
ICALL_SIG (6, (int, int, int, ptr, ptr, ptr))		\
ICALL_SIG (6, (int, ptr, int, int, ptr, object))	\
ICALL_SIG (6, (object, ptr, int, int, int, int))	\
ICALL_SIG (6, (object, ptr, ptr, ptr, ptr, ptr))	\
ICALL_SIG (6, (ptr, ptr, int32, ptr, ptr, ptrref))	\
ICALL_SIG (6, (void, ptr, ptr, int32, ptr, ptrref))	\
ICALL_SIG (6, (void, ptr, ptr, ptr, ptr, ptr))	\
ICALL_SIG (6, (ptr, ptr, ptr, ptr, ptr, ptr))	\
ICALL_SIG (7, (int32, ptr, ptr, ptr, ptr, ptr, int32))	\
ICALL_SIG (7, (void, ptr, ptr, ptr, ptr, ptr, ptr))	\
ICALL_SIG (7, (ptr, ptr, ptr, ptr, ptr, ptr, ptr))	\
ICALL_SIG (8, (void, ptr, ptr, int32, ptr, ptrref, ptr, ptrref)) 	\

// ICALL_SIG_NAME: mono_icall_sig pasted with its parameters with underscores between each.
#define ICALL_SIG_NAME_1(a) 		 	 mono_icall_sig_ ## a
#define ICALL_SIG_NAME_2(a, b) 		 	 mono_icall_sig_ ## a ## _ ## b
#define ICALL_SIG_NAME_3(a, b, c) 	 	 mono_icall_sig_ ## a ## _ ## b ## _ ## c
#define ICALL_SIG_NAME_4(a, b, c, d) 	 	 mono_icall_sig_ ## a ## _ ## b ## _ ## c ## _ ## d
#define ICALL_SIG_NAME_5(a, b, c, d, e)    	 mono_icall_sig_ ## a ## _ ## b ## _ ## c ## _ ## d ## _ ## e
#define ICALL_SIG_NAME_6(a, b, c, d, e, f) 	 mono_icall_sig_ ## a ## _ ## b ## _ ## c ## _ ## d ## _ ## e ## _ ## f
#define ICALL_SIG_NAME_7(a, b, c, d, e, f, g)	 mono_icall_sig_ ## a ## _ ## b ## _ ## c ## _ ## d ## _ ## e ## _ ## f ## _ ## g
#define ICALL_SIG_NAME_8(a, b, c, d, e, f, g, h) mono_icall_sig_ ## a ## _ ## b ## _ ## c ## _ ## d ## _ ## e ## _ ## f ## _ ## g ## _ ## h

#define ICALL_SIG_NAME(n, types) ICALL_SIG_NAME_ ## n types

// Declare each icall_sig as a MonoMethodSignature * const.
// The address is constant but the contents are not quite.
#define ICALL_SIG(n, types) extern MonoMethodSignature * const ICALL_SIG_NAME (n, types);

ICALL_SIGS

#undef ICALL_SIG

void
mono_create_icall_signatures (void);

#endif // __MONO_METADATA_ICALL_SIGNATURES_H__

```

`Hazel/vendor/mono/include/mono/metadata/icall-table.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_ICALL_TABLE_H__
#define __MONO_METADATA_ICALL_TABLE_H__

#include <config.h>
#include <glib.h>
#include <mono/utils/mono-publib.h>
#include "marshal.h"
#include "icalls.h"

#define MONO_ICALL_TABLE_CALLBACKS_VERSION 2

typedef struct {
	int version;
	gpointer (*lookup) (MonoMethod *method, char *classname, char *methodname, char *sigstart, gboolean *uses_handles);
	const char* (*lookup_icall_symbol) (gpointer func);
} MonoIcallTableCallbacks;

ICALL_EXTERN_C
void
mono_install_icall_table_callbacks (const MonoIcallTableCallbacks *cb);

MONO_API void
mono_icall_table_init (void);

// It helps for types to be single tokens, though this can be relaxed in some places.
// Marshaling a "ptr" does nothing -- just pass it on unchanged.
// Marshaling a "ref" also does nothing at this layer, but
// creates a handle in  marshal-ilgen.c.
// "ref" means "can be an interior pointer".
// "ptr" means "to a local".
// It is generally difficult to know, and "ref" is safer.
// Presently it does not matter.
typedef gint32  *gint32_ptr;
typedef gsize *gsize_ptr;
typedef guchar *guchar_ptr;
typedef const guchar *const_guchar_ptr;
typedef gpointer *gpointer_ptr;
typedef const char *const_char_ptr;
typedef char *char_ptr;
typedef char **char_ptr_ptr;
typedef gunichar2 *gunichar2_ptr;
typedef const gunichar2 *const_gunichar2_ptr;
typedef int *int_ptr;
typedef int **int_ptr_ref;
typedef guint8 **guint8_ptr_ref;
typedef GPtrArray *GPtrArray_ptr;
// HANDLE is not used just to avoid duplicate typedef warnings with some compilers.
// gpointer == void* == HANDLE == FILE_HANDLE == PROCESS_HANDLE.
typedef gpointer PROCESS_HANDLE;
typedef gpointer FILE_HANDLE;
typedef MonoAssemblyName *MonoAssemblyName_ptr;
typedef MonoBoolean *MonoBoolean_ptr;
typedef MonoClass *MonoClass_ptr;
typedef MonoClassField *MonoClassField_ptr;
typedef MonoEvent *MonoEvent_ptr;
typedef MonoImage *MonoImage_ptr;
typedef MonoMethod *MonoMethod_ptr;
typedef MonoProperty *MonoProperty_ptr;
typedef MonoPropertyInfo *MonoPropertyInfo_ref;
typedef MonoType *MonoType_ptr;
typedef MonoTypedRef *MonoTypedRef_ptr;
typedef MonoStackCrawlMark *MonoStackCrawlMark_ptr;
typedef MonoVTable *MonoVTable_ptr;
typedef unsigned *unsigned_ptr;
typedef mono_unichar2 *mono_unichar2_ptr;
typedef mono_unichar4 *mono_unichar4_ptr;
typedef WSABUF *WSABUF_ptr;

typedef char **char_ptr_ref;
typedef gint32  *gint32_ref;
typedef gint64  *gint64_ref;
typedef gpointer *gpointer_ref;
typedef gsize *gsize_ref;
typedef guint32 *guint32_ref;
typedef guint64 *guint64_ref;
typedef int *int_ref;
typedef MonoAssemblyName *MonoAssemblyName_ref;
typedef MonoBoolean *MonoBoolean_ref;
typedef MonoClassField *MonoClassField_ref;
typedef MonoEvent *MonoEvent_ref;
typedef MonoEventInfo *MonoEventInfo_ref;
typedef MonoGenericParamInfo *MonoGenericParamInfo_ptr;
typedef MonoMethod *MonoMethod_ref;
typedef MonoMethodInfo *MonoMethodInfo_ref;
typedef MonoResolveTokenError *MonoResolveTokenError_ref;
typedef MonoType *MonoType_ref;
typedef MonoTypedRef *MonoTypedRef_ref;
typedef MonoW32ProcessInfo *MonoW32ProcessInfo_ref;

// Maybe do this in TYPED_HANDLE_DECL.
typedef MonoArray MonoArrayOut;
typedef MonoArray MonoArrayInOut;
typedef MonoArrayHandle MonoArrayOutHandle;
typedef MonoArrayHandle MonoArrayInOutHandle;
typedef MonoException MonoExceptionOut;
typedef MonoExceptionHandle MonoExceptionOutHandle;
typedef MonoObject MonoObjectOut;
typedef MonoObject MonoObjectInOut;
typedef MonoObjectHandle MonoObjectOutHandle;
typedef MonoObjectHandle MonoObjectInOutHandle;
typedef MonoReflectionModule MonoReflectionModuleOut;
typedef MonoReflectionModuleHandle MonoReflectionModuleOutHandle;
typedef MonoString MonoStringOut;
typedef MonoStringHandle MonoStringOutHandle;

// How the arguments and return value of an icall should be wrapped.
// The names and meanings are from marshal-ilgen.c.
// 	ICALL_HANDLES_WRAP_NONE
// 	ICALL_HANDLES_WRAP_OBJ
// 	ICALL_HANDLES_WRAP_OBJ_INOUT
// 	ICALL_HANDLES_WRAP_OBJ_OUT
// 	ICALL_HANDLES_WRAP_VALUETYPE_REF
//
// In the present implementation, all that matters is, handle-or-not,
// in and out and inout are the same, and none and valuetype_ref are the same.
// Handle creation is in marshal-ilgen.c.

// Map a type to a type class: Void and above.
#define MONO_HANDLE_TYPE_WRAP_void 			Void
#define MONO_HANDLE_TYPE_WRAP_GPtrArray_ptr  		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoBoolean   		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_const_gunichar2_ptr	ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gunichar2_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gint   			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gint32   			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gint64   			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gpointer   		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gconstpointer   		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gsize   			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gssize   			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_guchar_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_guint     		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_const_guchar_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_guint32  			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_guint64  			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_int 			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_uint     			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_PInfo			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_mono_bstr			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_mono_bstr_const		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_unsigned_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_mono_unichar2_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_mono_unichar4_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoImage_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoClassField_ptr	ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoMarshalNative		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoProperty_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoProtocolType		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_size_t			ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoVTable_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_WSABUF_ptr		ICALL_HANDLES_WRAP_NONE

#define MONO_HANDLE_TYPE_WRAP_MonoAssemblyName_ref	ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoBoolean_ref 		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoClassField_ref  	ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoEvent_ref		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoEventInfo_ref		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoMethod_ref 		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoMethodInfo_ref	ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoPropertyInfo_ref	ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoType_ref  		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoTypedRef_ref 		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_gint32_ref   		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_gint64_ref  		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_gpointer_ref   		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_gsize_ref   		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_guint32_ref   		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_guint64_ref   		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_int_ref  			ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_gint32_ref  			ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_int_ptr_ref  		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_char_ptr_ref		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_guint8_ptr_ref		ICALL_HANDLES_WRAP_VALUETYPE_REF
#define MONO_HANDLE_TYPE_WRAP_MonoResolveTokenError_ref	ICALL_HANDLES_WRAP_VALUETYPE_REF

// HANDLE is not used just to avoid duplicate typedef warnings with some compilers.
// gpointer == void* == HANDLE == FILE_HANDLE == PROCESS_HANDLE.
#define MONO_HANDLE_TYPE_WRAP_char_ptr   		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_const_char_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_FILE_HANDLE		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoClass_ptr  		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoEvent_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoGenericParamInfo_ptr	ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoMethod_ptr 		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoType_ptr  		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoTypedRef_ptr 		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_MonoStackCrawlMark_ptr  	ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gint32_ptr   		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_gpointer_ptr		ICALL_HANDLES_WRAP_NONE
#define MONO_HANDLE_TYPE_WRAP_PROCESS_HANDLE		ICALL_HANDLES_WRAP_NONE

// Please keep this sorted (grep ICALL_HANDLES_WRAP_OBJ$ | sort)
#define MONO_HANDLE_TYPE_WRAP_MonoAppContext 			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoAppDomain			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoAppDomainSetup		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoArray				ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoAsyncResult			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoCalendarData		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoComInteropProxy		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoComObject			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoCultureData		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoCultureInfo		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoDelegate			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoException			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoInternalThread		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoIOSelectorJob			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoObject			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoManifestResourceInfo 		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoMulticastDelegate		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionAssembly		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionAssemblyBuilder 	ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionDynamicMethod 	ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionEvent		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionMonoEvent		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionField		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionMarshalAsAttribute	ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionMethod     		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionMethodBody 		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionModule 		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionModuleBuilder 	ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionParameter		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionProperty		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionSigHelper		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionType		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionTypeBuilder		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoRegionInfo		ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoString			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoStringBuilder			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoThreadObject			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoTransparentProxy			ICALL_HANDLES_WRAP_OBJ
#define MONO_HANDLE_TYPE_WRAP_MonoW32ProcessStartInfo		ICALL_HANDLES_WRAP_OBJ

#define MONO_HANDLE_TYPE_WRAP_MonoExceptionOut		ICALL_HANDLES_WRAP_OBJ_OUT
#define MONO_HANDLE_TYPE_WRAP_MonoObjectOut		ICALL_HANDLES_WRAP_OBJ_OUT
#define MONO_HANDLE_TYPE_WRAP_MonoStringOut		ICALL_HANDLES_WRAP_OBJ_OUT
#define MONO_HANDLE_TYPE_WRAP_MonoArrayOut		ICALL_HANDLES_WRAP_OBJ_OUT
#define MONO_HANDLE_TYPE_WRAP_MonoReflectionModuleOut 	ICALL_HANDLES_WRAP_OBJ_OUT

#define MONO_HANDLE_TYPE_WRAP_MonoW32ProcessInfo_ref	ICALL_HANDLES_WRAP_VALUETYPE_REF

// These are rare, and could be eliminated.
// They could be return values, or just separate out parameters.
#define MONO_HANDLE_TYPE_WRAP_MonoObjectInOut	ICALL_HANDLES_WRAP_OBJ_INOUT
#define MONO_HANDLE_TYPE_WRAP_MonoArrayInOut	ICALL_HANDLES_WRAP_OBJ_INOUT

// Do macro_prefix for type type, mapping type to a type class.
// Note that the macro can further be followed by parameters.
#define MONO_HANDLE_DO3(macro_prefix, type) macro_prefix ## type
#define MONO_HANDLE_DO2(macro_prefix, type) MONO_HANDLE_DO3 (macro_prefix, type)
#define MONO_HANDLE_DO(macro_prefix, type)  MONO_HANDLE_DO2 (macro_prefix, MONO_HANDLE_TYPE_WRAP_ ## type)

#define MONO_HANDLE_RETURN_BEGIN(type)				MONO_HANDLE_DO (MONO_HANDLE_RETURN_BEGIN_, type) (type)
#define MONO_HANDLE_RETURN_BEGIN_Void(type)			/* nothing */
#define MONO_HANDLE_RETURN_BEGIN_ICALL_HANDLES_WRAP_NONE(type)  type icall_result =
#define MONO_HANDLE_RETURN_BEGIN_ICALL_HANDLES_WRAP_OBJ(type)   type ## Handle icall_result =

#define MONO_HANDLE_RETURN_END(type)				MONO_HANDLE_DO (MONO_HANDLE_RETURN_END_, type);
#define MONO_HANDLE_RETURN_END_Void				HANDLE_FUNCTION_RETURN ()
#define MONO_HANDLE_RETURN_END_ICALL_HANDLES_WRAP_NONE   	HANDLE_FUNCTION_RETURN_VAL (icall_result)
#define MONO_HANDLE_RETURN_END_ICALL_HANDLES_WRAP_OBJ		HANDLE_FUNCTION_RETURN_OBJ (icall_result)

// Convert raw handles to typed handles, just by casting and copying a pointer.
#define MONO_HANDLE_MARSHAL(type, n)					MONO_HANDLE_DO (MONO_HANDLE_MARSHAL_, type) (type, n)
#define MONO_HANDLE_MARSHAL_ICALL_HANDLES_WRAP_NONE(type, n)     	a ## n
#define MONO_HANDLE_MARSHAL_ICALL_HANDLES_WRAP_OBJ(type, n)		*(type ## Handle*)&a ## n
#define MONO_HANDLE_MARSHAL_ICALL_HANDLES_WRAP_OBJ_OUT(type, n)		*(type ## Handle*)&a ## n
#define MONO_HANDLE_MARSHAL_ICALL_HANDLES_WRAP_OBJ_INOUT(type, n)	*(type ## Handle*)&a ## n
#define MONO_HANDLE_MARSHAL_ICALL_HANDLES_WRAP_VALUETYPE_REF(type, n)	a ## n

// Declare and initialize a local for an object in, out, inout parameters, upon input.
#define MONO_HANDLE_REGISTER_ICALL_LOCALS(type, n)					MONO_HANDLE_DO (MONO_HANDLE_REGISTER_ICALL_LOCALS_, type) (type, n)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_ICALL_HANDLES_WRAP_NONE(type, n)     		/* nothing */
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_ICALL_HANDLES_WRAP_OBJ(type, n)		type ## Handle a ## n = MONO_HANDLE_NEW (type, a ## n ## _raw);
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_ICALL_HANDLES_WRAP_OBJ_OUT(type, n)		unused_untested_looks_correct1 type ## Handle a ## n = MONO_HANDLE_NEW (type, NULL);
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_ICALL_HANDLES_WRAP_OBJ_INOUT(type, n)		unused_untested_looks_correct2 type ## Handle a ## n = MONO_HANDLE_NEW (type, *a ## n ## _raw);
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_ICALL_HANDLES_WRAP_VALUETYPE_REF(type, n)	FIXME restore mono_icall_handle_new_interior from e8b037642104527bd9b9ba70d502210b9c12d2b8 \
											type ## Handle a ## n = mono_icall_handle_new_interior (a ## n ## _raw);
// Produce all the locals, i.e. up to one per parameter.
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_0()					/* nothing  */
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_1(t0)					MONO_HANDLE_REGISTER_ICALL_LOCALS (t0, 0)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_2(t0, t1)				MONO_HANDLE_REGISTER_ICALL_LOCALS_1 (t0) 				MONO_HANDLE_REGISTER_ICALL_LOCALS (t1, 1)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_3(t0, t1, t2)				MONO_HANDLE_REGISTER_ICALL_LOCALS_2 (t0, t1) 				MONO_HANDLE_REGISTER_ICALL_LOCALS (t2, 2)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_4(t0, t1, t2, t3)			MONO_HANDLE_REGISTER_ICALL_LOCALS_3 (t0, t1, t2)			MONO_HANDLE_REGISTER_ICALL_LOCALS (t3, 3)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_5(t0, t1, t2, t3, t4)			MONO_HANDLE_REGISTER_ICALL_LOCALS_4 (t0, t1, t2, t3)			MONO_HANDLE_REGISTER_ICALL_LOCALS (t4, 4)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_6(t0, t1, t2, t3, t4, t5)		MONO_HANDLE_REGISTER_ICALL_LOCALS_5 (t0, t1, t2, t3, t4) 		MONO_HANDLE_REGISTER_ICALL_LOCALS (t5, 5)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_7(t0, t1, t2, t3, t4, t5, t6)		MONO_HANDLE_REGISTER_ICALL_LOCALS_6 (t0, t1, t2, t3, t4, t5) 		MONO_HANDLE_REGISTER_ICALL_LOCALS (t6, 6)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_8(t0, t1, t2, t3, t4, t5, t6, t7)	MONO_HANDLE_REGISTER_ICALL_LOCALS_7 (t0, t1, t2, t3, t4, t5, t6) 	MONO_HANDLE_REGISTER_ICALL_LOCALS (t7, 7)
#define MONO_HANDLE_REGISTER_ICALL_LOCALS_9(t0, t1, t2, t3, t4, t5, t6, t7, t8)	MONO_HANDLE_REGISTER_ICALL_LOCALS_8 (t0, t1, t2, t3, t4, t5, t6, t7)	MONO_HANDLE_REGISTER_ICALL_LOCALS (t8, 8)

// Convert a typed handle to raw pointer upon output.
#define MONO_HANDLE_REGISTER_ICALL_OUT(type, n)					MONO_HANDLE_DO (MONO_HANDLE_REGISTER_ICALL_OUT_, type) (type, n)
#define MONO_HANDLE_REGISTER_ICALL_OUT_ICALL_HANDLES_WRAP_NONE(type, n)		/* nothing */
#define MONO_HANDLE_REGISTER_ICALL_OUT_ICALL_HANDLES_WRAP_OBJ(type, n)		/* nothing */
#define MONO_HANDLE_REGISTER_ICALL_OUT_ICALL_HANDLES_WRAP_OBJ_OUT(type, n)	unused_untested_looks_correct3 *a ## n ## _raw = MONO_HANDLE_RAW (a ## n);
#define MONO_HANDLE_REGISTER_ICALL_OUT_ICALL_HANDLES_WRAP_OBJ_INOUT		unused_untested_looks_correct4 *a ## n ## _raw = MONO_HANDLE_RAW (a ## n);
#define MONO_HANDLE_REGISTER_ICALL_OUT_ICALL_HANDLES_VALUETYPE_REF(type, n)	/* nothing */

// Convert all the typed handles to raw pointers upon output, i.e. up to one per parameter.
#define MONO_HANDLE_REGISTER_ICALL_OUT_0()					/* nothing  */
#define MONO_HANDLE_REGISTER_ICALL_OUT_1(t0)					MONO_HANDLE_REGISTER_ICALL_OUT (t0, 0)
#define MONO_HANDLE_REGISTER_ICALL_OUT_2(t0, t1)				MONO_HANDLE_REGISTER_ICALL_OUT_1 (t0) 					MONO_HANDLE_REGISTER_ICALL_OUT (t1, 1)
#define MONO_HANDLE_REGISTER_ICALL_OUT_3(t0, t1, t2)				MONO_HANDLE_REGISTER_ICALL_OUT_2 (t0, t1) 				MONO_HANDLE_REGISTER_ICALL_OUT (t2, 2)
#define MONO_HANDLE_REGISTER_ICALL_OUT_4(t0, t1, t2, t3)			MONO_HANDLE_REGISTER_ICALL_OUT_3 (t0, t1, t2)				MONO_HANDLE_REGISTER_ICALL_OUT (t3, 3)
#define MONO_HANDLE_REGISTER_ICALL_OUT_5(t0, t1, t2, t3, t4)			MONO_HANDLE_REGISTER_ICALL_OUT_4 (t0, t1, t2, t3)			MONO_HANDLE_REGISTER_ICALL_OUT (t4, 4)
#define MONO_HANDLE_REGISTER_ICALL_OUT_6(t0, t1, t2, t3, t4, t5)		MONO_HANDLE_REGISTER_ICALL_OUT_5 (t0, t1, t2, t3, t4) 			MONO_HANDLE_REGISTER_ICALL_OUT (t5, 5)
#define MONO_HANDLE_REGISTER_ICALL_OUT_7(t0, t1, t2, t3, t4, t5, t6)		MONO_HANDLE_REGISTER_ICALL_OUT_6 (t0, t1, t2, t3, t4, t5) 		MONO_HANDLE_REGISTER_ICALL_OUT (t6, 6)
#define MONO_HANDLE_REGISTER_ICALL_OUT_8(t0, t1, t2, t3, t4, t5, t6, t7)	MONO_HANDLE_REGISTER_ICALL_OUT_7 (t0, t1, t2, t3, t4, t5, t6) 		MONO_HANDLE_REGISTER_ICALL_OUT (t7, 7)
#define MONO_HANDLE_REGISTER_ICALL_OUT_9(t0, t1, t2, t3, t4, t5, t6, t7, t8)	MONO_HANDLE_REGISTER_ICALL_OUT_8 (t0, t1, t2, t3, t4, t5, t6, t7)	MONO_HANDLE_REGISTER_ICALL_OUT (t8, 8)

#define MONO_HANDLE_TYPE_TYPED(type)					MONO_HANDLE_DO (MONO_HANDLE_TYPE_TYPED_, type) (type)
#define MONO_HANDLE_TYPE_TYPED_Void(type)				type
#define MONO_HANDLE_TYPE_TYPED_ICALL_HANDLES_WRAP_NONE(type)		type
#define MONO_HANDLE_TYPE_TYPED_ICALL_HANDLES_WRAP_OBJ(type)		type ## Handle
#define MONO_HANDLE_TYPE_TYPED_ICALL_HANDLES_WRAP_OBJ_OUT(type)		type ## Handle
#define MONO_HANDLE_TYPE_TYPED_ICALL_HANDLES_WRAP_OBJ_INOUT(type)	type ## Handle
#define MONO_HANDLE_TYPE_TYPED_ICALL_HANDLES_WRAP_VALUETYPE_REF(type)	type

// Map a type to a raw handle, or itself.
#define MONO_HANDLE_TYPE_RAWHANDLE(type)					MONO_HANDLE_DO (MONO_HANDLE_TYPE_RAWHANDLE_, type) (type)
#define MONO_HANDLE_TYPE_RAWHANDLE_Void(type)					type
#define MONO_HANDLE_TYPE_RAWHANDLE_ICALL_HANDLES_WRAP_NONE(type)		type
#define MONO_HANDLE_TYPE_RAWHANDLE_ICALL_HANDLES_WRAP_OBJ(type)			MonoRawHandle
#define MONO_HANDLE_TYPE_RAWHANDLE_ICALL_HANDLES_WRAP_OBJ_OUT(type)		MonoRawHandle
#define MONO_HANDLE_TYPE_RAWHANDLE_ICALL_HANDLES_WRAP_OBJ_INOUT(type)		MonoRawHandle
#define MONO_HANDLE_TYPE_RAWHANDLE_ICALL_HANDLES_WRAP_VALUETYPE_REF(type)	type

// Map a type to a raw pointer, or itself.
#define MONO_HANDLE_TYPE_RAWPOINTER(type)					MONO_HANDLE_DO (MONO_HANDLE_TYPE_RAWPOINTER_, type) (type)
#define MONO_HANDLE_TYPE_RAWPOINTER_Void(type)					type
#define MONO_HANDLE_TYPE_RAWPOINTER_ICALL_HANDLES_WRAP_NONE(type)		type
#define MONO_HANDLE_TYPE_RAWPOINTER_ICALL_HANDLES_WRAP_OBJ(type)		type*
// Only used for return types.
//#define MONO_HANDLE_TYPE_RAWPOINTER_ICALL_HANDLES_WRAP_OBJ_OUT(type)		type*
//#define MONO_HANDLE_TYPE_RAWPOINTER_ICALL_HANDLES_WRAP_OBJ_INOUT(type)	type*
#define MONO_HANDLE_TYPE_RAWPOINTER_ICALL_HANDLES_WRAP_VALUETYPE_REF(type)	type

// Type/name in raw handle prototype and implementation.
#define MONO_HANDLE_ARG_RAWHANDLE(type, n)					MONO_HANDLE_DO (MONO_HANDLE_ARG_RAWHANDLE_, type) (type, n)
#define MONO_HANDLE_ARG_RAWHANDLE_ICALL_HANDLES_WRAP_NONE(type, n)		MONO_HANDLE_TYPE_RAWHANDLE (type) a ## n
#define MONO_HANDLE_ARG_RAWHANDLE_ICALL_HANDLES_WRAP_OBJ(type, n)		MONO_HANDLE_TYPE_RAWHANDLE (type) a ## n
#define MONO_HANDLE_ARG_RAWHANDLE_ICALL_HANDLES_WRAP_OBJ_OUT(type, n)		MONO_HANDLE_TYPE_RAWHANDLE (type) a ## n
#define MONO_HANDLE_ARG_RAWHANDLE_ICALL_HANDLES_WRAP_OBJ_INOUT(type, n)	MONO_HANDLE_TYPE_RAWHANDLE (type) a ## n
#define MONO_HANDLE_ARG_RAWHANDLE_ICALL_HANDLES_WRAP_VALUETYPE_REF(type, n)	MONO_HANDLE_TYPE_RAWHANDLE (type) a ## n

// Type/name in raw pointer prototype and implementation.
#define MONO_HANDLE_ARG_RAWPOINTER(type, n)					MONO_HANDLE_DO (MONO_HANDLE_ARG_RAWPOINTER_, type) (type, n)
#define MONO_HANDLE_ARG_RAWPOINTER_ICALL_HANDLES_WRAP_NONE(type, n)		MONO_HANDLE_TYPE_RAWPOINTER (type) a ## n
#define MONO_HANDLE_ARG_RAWPOINTER_ICALL_HANDLES_WRAP_OBJ(type, n)		MONO_HANDLE_TYPE_RAWPOINTER (type) a ## n ## _raw
#define MONO_HANDLE_ARG_RAWPOINTER_ICALL_HANDLES_WRAP_OBJ_OUT(type, n)		unused_untested_looks_correct5 MONO_HANDLE_TYPE_RAWPOINTER (type) a ## n ## _raw
#define MONO_HANDLE_ARG_RAWPOINTER_ICALL_HANDLES_WRAP_OBJ_INOUT(type, n)	unused_untested_looks_correct6 MONO_HANDLE_TYPE_RAWPOINTER (type) a ## n ## _raw
#define MONO_HANDLE_ARG_RAWPOINTER_ICALL_HANDLES_WRAP_VALUETYPE_REF(type, n)	FIXME //MONO_HANDLE_TYPE_RAWPOINTER (type) a ## n

// Generate a parameter list, types only, for a function accepting/returning typed handles.
#define MONO_HANDLE_FOREACH_TYPE_TYPED_0()	   			     /* nothing */
#define MONO_HANDLE_FOREACH_TYPE_TYPED_1(t0) 	   			     MONO_HANDLE_TYPE_TYPED (t0)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_2(t0, t1)     			     MONO_HANDLE_FOREACH_TYPE_TYPED_1 (t0) 				,MONO_HANDLE_TYPE_TYPED (t1)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_3(t0, t1, t2)			     MONO_HANDLE_FOREACH_TYPE_TYPED_2 (t0, t1)		        	,MONO_HANDLE_TYPE_TYPED (t2)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_4(t0, t1, t2, t3)		     MONO_HANDLE_FOREACH_TYPE_TYPED_3 (t0, t1, t2) 			,MONO_HANDLE_TYPE_TYPED (t3)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_5(t0, t1, t2, t3, t4) 		     MONO_HANDLE_FOREACH_TYPE_TYPED_4 (t0, t1, t2, t3) 			,MONO_HANDLE_TYPE_TYPED (t4)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_6(t0, t1, t2, t3, t4, t5)             MONO_HANDLE_FOREACH_TYPE_TYPED_5 (t0, t1, t2, t3, t4) 		,MONO_HANDLE_TYPE_TYPED (t5)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_7(t0, t1, t2, t3, t4, t5, t6) 	     MONO_HANDLE_FOREACH_TYPE_TYPED_6 (t0, t1, t2, t3, t4, t5) 	 	,MONO_HANDLE_TYPE_TYPED (t6)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_8(t0, t1, t2, t3, t4, t5, t6, t7)     MONO_HANDLE_FOREACH_TYPE_TYPED_7 (t0, t1, t2, t3, t4, t5, t6)	,MONO_HANDLE_TYPE_TYPED (t7)
#define MONO_HANDLE_FOREACH_TYPE_TYPED_9(t0, t1, t2, t3, t4, t5, t6, t7, t8) MONO_HANDLE_FOREACH_TYPE_TYPED_8 (t0, t1, t2, t3, t4, t5, t6, t7)	,MONO_HANDLE_TYPE_TYPED (t8)

// Generate a parameter list, types and names, for a function accepting raw handles and no MonoError,
// and returning a raw pointer.
#define MONO_HANDLE_FOREACH_ARG_RAW_0()						void
#define MONO_HANDLE_FOREACH_ARG_RAW_1(t0) 	   	  			MONO_HANDLE_ARG_RAWHANDLE (t0, 0)
#define MONO_HANDLE_FOREACH_ARG_RAW_2(t0, t1)	  				MONO_HANDLE_FOREACH_ARG_RAW_1 (t0),             		MONO_HANDLE_ARG_RAWHANDLE (t1, 1)
#define MONO_HANDLE_FOREACH_ARG_RAW_3(t0, t1, t2)	  			MONO_HANDLE_FOREACH_ARG_RAW_2 (t0, t1),         		MONO_HANDLE_ARG_RAWHANDLE (t2, 2)
#define MONO_HANDLE_FOREACH_ARG_RAW_4(t0, t1, t2, t3)				MONO_HANDLE_FOREACH_ARG_RAW_3 (t0, t1, t2),     		MONO_HANDLE_ARG_RAWHANDLE (t3, 3)
#define MONO_HANDLE_FOREACH_ARG_RAW_5(t0, t1, t2, t3, t4)			MONO_HANDLE_FOREACH_ARG_RAW_4 (t0, t1, t2, t3), 		MONO_HANDLE_ARG_RAWHANDLE (t4, 4)
#define MONO_HANDLE_FOREACH_ARG_RAW_6(t0, t1, t2, t3, t4, t5)			MONO_HANDLE_FOREACH_ARG_RAW_5 (t0, t1, t2, t3, t4), 		MONO_HANDLE_ARG_RAWHANDLE (t5, 5)
#define MONO_HANDLE_FOREACH_ARG_RAW_7(t0, t1, t2, t3, t4, t5, t6)		MONO_HANDLE_FOREACH_ARG_RAW_6 (t0, t1, t2, t3, t4, t5), 	MONO_HANDLE_ARG_RAWHANDLE (t6, 6)
#define MONO_HANDLE_FOREACH_ARG_RAW_8(t0, t1, t2, t3, t4, t5, t6, t7)		MONO_HANDLE_FOREACH_ARG_RAW_7 (t0, t1, t2, t3, t4, t5, t6),	MONO_HANDLE_ARG_RAWHANDLE (t7, 7)
#define MONO_HANDLE_FOREACH_ARG_RAW_9(t0, t1, t2, t3, t4, t5, t6, t7, t8)  	MONO_HANDLE_FOREACH_ARG_RAW_8 (t0, t1, t2, t3, t4, t5, t6, t7),	MONO_HANDLE_ARG_RAWHANDLE (t8, 8)

// Generate a parameter list, types and names, for a function accepting raw pointers and no MonoError,
// and returning a raw pointer.
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_0()						void
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_1(t0) 	   	  			MONO_HANDLE_ARG_RAWPOINTER (t0, 0)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_2(t0, t1)	  				MONO_HANDLE_FOREACH_ARG_RAWPOINTER_1 (t0),             			MONO_HANDLE_ARG_RAWPOINTER (t1, 1)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_3(t0, t1, t2)	  			MONO_HANDLE_FOREACH_ARG_RAWPOINTER_2 (t0, t1),         			MONO_HANDLE_ARG_RAWPOINTER (t2, 2)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_4(t0, t1, t2, t3)				MONO_HANDLE_FOREACH_ARG_RAWPOINTER_3 (t0, t1, t2),     			MONO_HANDLE_ARG_RAWPOINTER (t3, 3)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_5(t0, t1, t2, t3, t4)			MONO_HANDLE_FOREACH_ARG_RAWPOINTER_4 (t0, t1, t2, t3), 			MONO_HANDLE_ARG_RAWPOINTER (t4, 4)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_6(t0, t1, t2, t3, t4, t5)			MONO_HANDLE_FOREACH_ARG_RAWPOINTER_5 (t0, t1, t2, t3, t4), 		MONO_HANDLE_ARG_RAWPOINTER (t5, 5)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_7(t0, t1, t2, t3, t4, t5, t6)		MONO_HANDLE_FOREACH_ARG_RAWPOINTER_6 (t0, t1, t2, t3, t4, t5), 		MONO_HANDLE_ARG_RAWPOINTER (t6, 6)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_8(t0, t1, t2, t3, t4, t5, t6, t7)		MONO_HANDLE_FOREACH_ARG_RAWPOINTER_7 (t0, t1, t2, t3, t4, t5, t6),	MONO_HANDLE_ARG_RAWPOINTER (t7, 7)
#define MONO_HANDLE_FOREACH_ARG_RAWPOINTER_9(t0, t1, t2, t3, t4, t5, t6, t7, t8)	MONO_HANDLE_FOREACH_ARG_RAWPOINTER_8 (t0, t1, t2, t3, t4, t5, t6, t7),	MONO_HANDLE_ARG_RAWPOINTER (t8, 8)

#define MONO_HANDLE_REGISTER_ICALL_CALL_0 /*  nothing */
#define MONO_HANDLE_REGISTER_ICALL_CALL_1 a0,
#define MONO_HANDLE_REGISTER_ICALL_CALL_2 MONO_HANDLE_REGISTER_ICALL_CALL_1 a1,
#define MONO_HANDLE_REGISTER_ICALL_CALL_3 MONO_HANDLE_REGISTER_ICALL_CALL_2 a2,
#define MONO_HANDLE_REGISTER_ICALL_CALL_4 MONO_HANDLE_REGISTER_ICALL_CALL_3 a3,
#define MONO_HANDLE_REGISTER_ICALL_CALL_5 MONO_HANDLE_REGISTER_ICALL_CALL_4 a4,
#define MONO_HANDLE_REGISTER_ICALL_CALL_6 MONO_HANDLE_REGISTER_ICALL_CALL_5 a5,
#define MONO_HANDLE_REGISTER_ICALL_CALL_7 MONO_HANDLE_REGISTER_ICALL_CALL_6 a6,
#define MONO_HANDLE_REGISTER_ICALL_CALL_8 MONO_HANDLE_REGISTER_ICALL_CALL_7 a7,
#define MONO_HANDLE_REGISTER_ICALL_CALL_9 MONO_HANDLE_REGISTER_ICALL_CALL_8 a8,

// Call from the wrapper to the actual icall, passing on the
// WRAP_NONE parameters directly, casting handles from raw to typed.
#define MONO_HANDLE_CALL_0()					/* nothing  */
#define MONO_HANDLE_CALL_1(t0)					MONO_HANDLE_MARSHAL (t0, 0)
#define MONO_HANDLE_CALL_2(t0, t1)				MONO_HANDLE_CALL_1 (t0), 				MONO_HANDLE_MARSHAL (t1, 1)
#define MONO_HANDLE_CALL_3(t0, t1, t2)				MONO_HANDLE_CALL_2 (t0, t1), 				MONO_HANDLE_MARSHAL (t2, 2)
#define MONO_HANDLE_CALL_4(t0, t1, t2, t3)			MONO_HANDLE_CALL_3 (t0, t1, t2),			MONO_HANDLE_MARSHAL (t3, 3)
#define MONO_HANDLE_CALL_5(t0, t1, t2, t3, t4)			MONO_HANDLE_CALL_4 (t0, t1, t2, t3),			MONO_HANDLE_MARSHAL (t4, 4)
#define MONO_HANDLE_CALL_6(t0, t1, t2, t3, t4, t5)		MONO_HANDLE_CALL_5 (t0, t1, t2, t3, t4), 		MONO_HANDLE_MARSHAL (t5, 5)
#define MONO_HANDLE_CALL_7(t0, t1, t2, t3, t4, t5, t6)		MONO_HANDLE_CALL_6 (t0, t1, t2, t3, t4, t5), 		MONO_HANDLE_MARSHAL (t6, 6)
#define MONO_HANDLE_CALL_8(t0, t1, t2, t3, t4, t5, t6, t7)	MONO_HANDLE_CALL_7 (t0, t1, t2, t3, t4, t5, t6), 	MONO_HANDLE_MARSHAL (t7, 7)
#define MONO_HANDLE_CALL_9(t0, t1, t2, t3, t4, t5, t6, t7, t8)	MONO_HANDLE_CALL_8 (t0, t1, t2, t3, t4, t5, t6, t7),	MONO_HANDLE_MARSHAL (t8, 8)

// Place a comma after a parameter list of length n, i.e. nothing for 0, else comma.
#define MONO_HANDLE_COMMA_0 /* nothing */
#define MONO_HANDLE_COMMA_1 ,
#define MONO_HANDLE_COMMA_2 ,
#define MONO_HANDLE_COMMA_3 ,
#define MONO_HANDLE_COMMA_4 ,
#define MONO_HANDLE_COMMA_5 ,
#define MONO_HANDLE_COMMA_6 ,
#define MONO_HANDLE_COMMA_7 ,
#define MONO_HANDLE_COMMA_8 ,
#define MONO_HANDLE_COMMA_9 ,

// Declare the function that takes/returns typed handles and a MonoError.
#define MONO_HANDLE_DECLARE(id, name, func, rettype, n, argtypes)	\
MONO_HANDLE_TYPE_TYPED (rettype)					\
func (MONO_HANDLE_FOREACH_TYPE_TYPED_ ## n argtypes MONO_HANDLE_COMMA_ ## n MonoError *error)

// Declare the function wrapper that takes raw handles and returns a raw pointer.
#define MONO_HANDLE_DECLARE_RAW(id, name, func, rettype, n, argtypes)	\
ICALL_EXPORT MONO_HANDLE_TYPE_RAWPOINTER (rettype)				\
func ## _raw ( MONO_HANDLE_FOREACH_ARG_RAW_ ## n argtypes)

// Implement ves_icall_foo_raw over ves_icall_foo.
// Raw handles are converted to/from typed handles and the rest is passed through.
// This is for functions in icall-def.h.

#define MONO_HANDLE_IMPLEMENT(id, name, func, rettype, n, argtypes)	\
										\
MONO_HANDLE_DECLARE_RAW (id, name, func, rettype, n, argtypes)			\
{										\
	HANDLE_FUNCTION_ENTER ();						\
										\
	ERROR_DECL (error);							\
										\
	MONO_HANDLE_RETURN_BEGIN (rettype)					\
										\
	func (MONO_HANDLE_CALL_ ## n argtypes MONO_HANDLE_COMMA_ ## n error);	\
										\
	mono_error_set_pending_exception (error);				\
										\
	MONO_HANDLE_RETURN_END (rettype)					\
}										\

// Declare the function that takes/returns raw pointers and no MonoError.
#define MONO_HANDLE_REGISTER_ICALL_DECLARE_RAW(func, rettype, n, argtypes)	\
ICALL_EXPORT MONO_HANDLE_TYPE_RAWPOINTER (rettype)				\
func ( MONO_HANDLE_FOREACH_ARG_RAWPOINTER_ ## n argtypes)

// Implement ves_icall_foo over ves_icall_foo_impl.
//
// Raw pointers are converted to/from handles and the rest is passed through.
// The in/out/inout-ness of parameters must be correct. (unlike MONO_HANDLE_IMPLEMENT)
// Valuetype-refs are not handled. (unlike MONO_HANDLE_IMPLEMENT)
// Handle creation is less efficient than MONO_HANDLE_IMPLEMENT (marshal-ilgen.c) -- using TLS
// and per-handle work.
//
// In future this should produce an array of IcallHandlesWrap and send that through
// to emit_native_icall_wrapper_ilgen to gain its efficient handles.
//
// Or put the handles directly in the coop frame, or pointers to them.
// i.e. one TLS access at function start and end.
//
// This is for functions passed to mono_register_jit_icall_info, etc.

#define MONO_HANDLE_REGISTER_ICALL_IMPLEMENT(func, rettype, n, argtypes)	\
										\
MONO_HANDLE_REGISTER_ICALL_DECLARE_RAW (func, rettype, n, argtypes)		\
{										\
	HANDLE_FUNCTION_ENTER ();						\
										\
	ERROR_DECL (error);							\
										\
	MONO_HANDLE_REGISTER_ICALL_LOCALS_ ## n argtypes			\
										\
	MONO_HANDLE_RETURN_BEGIN (rettype)					\
										\
	func ## _impl (MONO_HANDLE_REGISTER_ICALL_CALL_ ## n error);			\
										\
	MONO_HANDLE_REGISTER_ICALL_OUT_ ## n argtypes				\
										\
	mono_error_set_pending_exception (error);				\
										\
	MONO_HANDLE_RETURN_END (rettype)					\
}										\

#endif

```

`Hazel/vendor/mono/include/mono/metadata/icall-windows-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_ICALL_WINDOWS_INTERNALS_H__
#define __MONO_METADATA_ICALL_WINDOWS_INTERNALS_H__

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32
#include "mono/metadata/icall-internals.h"
#include "mono/metadata/object.h"
#include "mono/metadata/object-internals.h"
#include "mono/metadata/class.h"
#include "mono/metadata/class-internals.h"
#endif /* HOST_WIN32 */
#endif /* __MONO_METADATA_ICALL_WINDOWS_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/icalls.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_ICALLS_H__
#define __MONO_METADATA_ICALLS_H__

#include <mono/utils/mono-publib.h>

#ifdef ENABLE_ICALL_EXPORT
#define ICALL_EXPORT MONO_API
#define ICALL_EXTERN_C G_EXTERN_C
#else
/* Can't be static as icall.c defines icalls referenced by icall-tables.c */
#define ICALL_EXPORT /* nothing */
#define ICALL_EXTERN_C /* nothing */
#endif

#endif // __MONO_METADATA_ICALLS_H__

```

`Hazel/vendor/mono/include/mono/metadata/image-internals.h`:

```h
/**
 * \file
 * Copyright 2015 Xamarin Inc
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_IMAGE_INTERNALS_H__
#define __MONO_METADATA_IMAGE_INTERNALS_H__

#include <mono/metadata/image.h>
#include <mono/metadata/loader-internals.h>

MonoImage*
mono_image_loaded_internal (MonoAssemblyLoadContext *alc, const char *name, mono_bool refonly);

MonoImage*
mono_image_load_file_for_image_checked (MonoImage *image, int fileidx, MonoError *error);

MonoImage*
mono_image_load_module_checked (MonoImage *image, int idx, MonoError *error);

MonoImage *
mono_image_open_a_lot (MonoAssemblyLoadContext *alc, const char *fname, MonoImageOpenStatus *status, gboolean refonly, gboolean load_from_context);

gboolean
mono_is_problematic_image (MonoImage *image);

gboolean
mono_is_problematic_file (const char *fname);

#endif /* __MONO_METADATA_IMAGE_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/image.h`:

```h
/**
 * \file
 */

#ifndef _MONONET_METADATA_IMAGE_H_ 
#define _MONONET_METADATA_IMAGE_H_

#include <stdio.h>
#include <mono/utils/mono-publib.h>
#include <mono/utils/mono-error.h>
#include <mono/metadata/object-forward.h>

MONO_BEGIN_DECLS

typedef struct _MonoAssembly MonoAssembly;
typedef struct _MonoAssemblyName MonoAssemblyName;
typedef struct _MonoTableInfo MonoTableInfo;

typedef enum {
	MONO_IMAGE_OK,
	MONO_IMAGE_ERROR_ERRNO,
	MONO_IMAGE_MISSING_ASSEMBLYREF,
	MONO_IMAGE_IMAGE_INVALID
} MonoImageOpenStatus;

MONO_API void          mono_images_init    (void);
MONO_API void          mono_images_cleanup (void);

MONO_API MonoImage    *mono_image_open     (const char *fname,
				   MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage             *mono_image_open_full (const char *fname,
				   MonoImageOpenStatus *status, mono_bool refonly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage             *mono_pe_file_open     (const char *fname,
				     MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage    *mono_image_open_from_data (char *data, uint32_t data_len, mono_bool need_copy,
                                         MonoImageOpenStatus *status);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage    *mono_image_open_from_data_full (char *data, uint32_t data_len, mono_bool need_copy,
                                         MonoImageOpenStatus *status, mono_bool refonly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage    *mono_image_open_from_data_with_name (char *data, uint32_t data_len, mono_bool need_copy,
                                                   MonoImageOpenStatus *status, mono_bool refonly, const char *name);
MONO_API void          mono_image_fixup_vtable (MonoImage *image);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage             *mono_image_loaded   (const char *name);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage             *mono_image_loaded_full   (const char *name, mono_bool refonly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage             *mono_image_loaded_by_guid (const char *guid);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoImage             *mono_image_loaded_by_guid_full (const char *guid, mono_bool refonly);
MONO_API void          mono_image_init     (MonoImage *image);
MONO_API void          mono_image_close    (MonoImage *image);
MONO_API void          mono_image_addref   (MonoImage *image);
MONO_API const char   *mono_image_strerror (MonoImageOpenStatus status);

MONO_API int           mono_image_ensure_section     (MonoImage *image,
					     const char *section);
MONO_API int           mono_image_ensure_section_idx (MonoImage *image,
					     int section);

MONO_API uint32_t       mono_image_get_entry_point    (MonoImage *image);
MONO_API const char   *mono_image_get_resource       (MonoImage *image, uint32_t offset, uint32_t *size);
MONO_API MONO_RT_EXTERNAL_ONLY MonoImage*    mono_image_load_file_for_image (MonoImage *image, int fileidx);

MONO_API MONO_RT_EXTERNAL_ONLY MonoImage*    mono_image_load_module (MonoImage *image, int idx);

MONO_API const char*   mono_image_get_name       (MonoImage *image);
MONO_API const char*   mono_image_get_filename   (MonoImage *image);
MONO_API const char *  mono_image_get_guid       (MonoImage *image);
MONO_API MonoAssembly* mono_image_get_assembly   (MonoImage *image);
MONO_API mono_bool     mono_image_is_dynamic     (MonoImage *image);
MONO_API char*         mono_image_rva_map        (MonoImage *image, uint32_t rva);

MONO_API const MonoTableInfo *mono_image_get_table_info (MonoImage *image, int table_id);
MONO_API int                  mono_image_get_table_rows (MonoImage *image, int table_id);
MONO_API int                  mono_table_info_get_rows  (const MonoTableInfo *table);

/* This actually returns a MonoPEResourceDataEntry *, but declaring it
 * causes an include file loop.
 */
MONO_API void*      mono_image_lookup_resource (MonoImage *image, uint32_t res_id,
					  uint32_t lang_id, mono_unichar2 *name);

MONO_API const char*   mono_image_get_public_key  (MonoImage *image, uint32_t *size);
MONO_API const char*   mono_image_get_strong_name (MonoImage *image, uint32_t *size);
MONO_API uint32_t       mono_image_strong_name_position (MonoImage *image, uint32_t *size);
MONO_API void          mono_image_add_to_name_cache (MonoImage *image, 
			const char *nspace, const char *name, uint32_t idx);
MONO_API mono_bool     mono_image_has_authenticode_entry (MonoImage *image);

MONO_END_DECLS

#endif

```

`Hazel/vendor/mono/include/mono/metadata/jit-icall-reg.h`:

```h
/**
 * \file
 *   Enum for JIT icalls: MonoJitICallId MONO_JIT_ICALL_mono_foo, etc.
 *   Static storage for JIT icall info: mono_get_jit_icall_info().
 *
 *   mono_find_jit_icall_info (MonoJitICallId)
 *     Convert enum to pointer.
 *
 *   mono_find_jit_icall_info ((MonoJitICallId)int)
 *     Convert int to pointer.
 *
 *  mono_jit_icall_info_id (MonoJitICallInfo*)
 *     Convert pointer to enum.
 *
 *   mono_jit_icall_info_index (MonoJitICallInfo*)
 *     Convert pointer to int.
 *
 *   &mono_get_icall_info ()->name
 *     Convert name to pointer.
 *
 *   MONO_JIT_ICALL_ ## name
 *     Convert name to enum.
 *
 *   All conversions are just a few instructions.
 *
 * Author:
 *   Jay Krell (jaykrell@microsoft.com)
 *
 * Copyright 2019 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

// No include guard needed.

// Changes within MONO_JIT_ICALLS require revising MONO_AOT_FILE_VERSION.
#define MONO_JIT_ICALLS \
	\
MONO_JIT_ICALL (ZeroIsReserved)	\
	\
/* These must be ordered like MonoTrampolineType. */	\
MONO_JIT_ICALL (generic_trampoline_jit)	\
MONO_JIT_ICALL (generic_trampoline_jump)	\
MONO_JIT_ICALL (generic_trampoline_rgctx_lazy_fetch)	\
MONO_JIT_ICALL (generic_trampoline_aot)	\
MONO_JIT_ICALL (generic_trampoline_aot_plt)	\
MONO_JIT_ICALL (generic_trampoline_delegate)	\
MONO_JIT_ICALL (generic_trampoline_generic_virtual_remoting)	\
MONO_JIT_ICALL (generic_trampoline_vcall)	\
	\
/* These must be ordered like MonoTlsKey (alphabetical). */ \
MONO_JIT_ICALL (mono_tls_get_domain_extern) \
MONO_JIT_ICALL (mono_tls_get_jit_tls_extern) \
MONO_JIT_ICALL (mono_tls_get_lmf_addr_extern) \
MONO_JIT_ICALL (mono_tls_get_sgen_thread_info_extern) \
MONO_JIT_ICALL (mono_tls_get_thread_extern) \
	\
MONO_JIT_ICALL (__emul_fadd)	\
MONO_JIT_ICALL (__emul_fcmp_ceq)	\
MONO_JIT_ICALL (__emul_fcmp_cgt)	\
MONO_JIT_ICALL (__emul_fcmp_cgt_un)	\
MONO_JIT_ICALL (__emul_fcmp_clt)	\
MONO_JIT_ICALL (__emul_fcmp_clt_un)	\
MONO_JIT_ICALL (__emul_fcmp_eq)	\
MONO_JIT_ICALL (__emul_fcmp_ge)	\
MONO_JIT_ICALL (__emul_fcmp_ge_un)	\
MONO_JIT_ICALL (__emul_fcmp_gt)	\
MONO_JIT_ICALL (__emul_fcmp_gt_un)	\
MONO_JIT_ICALL (__emul_fcmp_le)	\
MONO_JIT_ICALL (__emul_fcmp_le_un)	\
MONO_JIT_ICALL (__emul_fcmp_lt)	\
MONO_JIT_ICALL (__emul_fcmp_lt_un)	\
MONO_JIT_ICALL (__emul_fcmp_ne_un)	\
MONO_JIT_ICALL (__emul_fconv_to_i)	\
MONO_JIT_ICALL (__emul_fconv_to_i1)	\
MONO_JIT_ICALL (__emul_fconv_to_i2)	\
MONO_JIT_ICALL (__emul_fconv_to_i4)	\
MONO_JIT_ICALL (__emul_fconv_to_i8)	\
MONO_JIT_ICALL (__emul_fconv_to_ovf_i8)	\
MONO_JIT_ICALL (__emul_fconv_to_ovf_u8)	\
MONO_JIT_ICALL (__emul_fconv_to_ovf_u8_un)	\
MONO_JIT_ICALL (__emul_fconv_to_r4)	\
MONO_JIT_ICALL (__emul_fconv_to_u)	\
MONO_JIT_ICALL (__emul_fconv_to_u1)	\
MONO_JIT_ICALL (__emul_fconv_to_u2)	\
MONO_JIT_ICALL (__emul_fconv_to_u4)	\
MONO_JIT_ICALL (__emul_fconv_to_u8)	\
MONO_JIT_ICALL (__emul_fdiv)	\
MONO_JIT_ICALL (__emul_fmul)	\
MONO_JIT_ICALL (__emul_fneg)	\
MONO_JIT_ICALL (__emul_frem)	\
MONO_JIT_ICALL (__emul_fsub)	\
MONO_JIT_ICALL (__emul_iconv_to_r_un) \
MONO_JIT_ICALL (__emul_iconv_to_r4) \
MONO_JIT_ICALL (__emul_iconv_to_r8) \
MONO_JIT_ICALL (__emul_lconv_to_r4) \
MONO_JIT_ICALL (__emul_lconv_to_r8) \
MONO_JIT_ICALL (__emul_lconv_to_r8_un) \
MONO_JIT_ICALL (__emul_ldiv) \
MONO_JIT_ICALL (__emul_ldiv_un) \
MONO_JIT_ICALL (__emul_lmul) \
MONO_JIT_ICALL (__emul_lmul_ovf) \
MONO_JIT_ICALL (__emul_lmul_ovf_un) \
MONO_JIT_ICALL (__emul_lrem) \
MONO_JIT_ICALL (__emul_lrem_un) \
MONO_JIT_ICALL (__emul_lshl) \
MONO_JIT_ICALL (__emul_lshr) \
MONO_JIT_ICALL (__emul_lshr_un) \
MONO_JIT_ICALL (__emul_op_idiv) \
MONO_JIT_ICALL (__emul_op_idiv_un) \
MONO_JIT_ICALL (__emul_op_imul) \
MONO_JIT_ICALL (__emul_op_imul_ovf) \
MONO_JIT_ICALL (__emul_op_imul_ovf_un) \
MONO_JIT_ICALL (__emul_op_irem) \
MONO_JIT_ICALL (__emul_op_irem_un) \
MONO_JIT_ICALL (__emul_rconv_to_i8) \
MONO_JIT_ICALL (__emul_rconv_to_ovf_i8) \
MONO_JIT_ICALL (__emul_rconv_to_ovf_u8) \
MONO_JIT_ICALL (__emul_rconv_to_ovf_u8_un) \
MONO_JIT_ICALL (__emul_rconv_to_u4)	\
MONO_JIT_ICALL (__emul_rconv_to_u8) \
MONO_JIT_ICALL (__emul_rrem) \
MONO_JIT_ICALL (cominterop_get_ccw) \
MONO_JIT_ICALL (cominterop_get_ccw_object) \
MONO_JIT_ICALL (cominterop_get_function_pointer) \
MONO_JIT_ICALL (cominterop_get_interface) \
MONO_JIT_ICALL (cominterop_get_method_interface) \
MONO_JIT_ICALL (cominterop_object_is_rcw) \
MONO_JIT_ICALL (cominterop_restore_domain) \
MONO_JIT_ICALL (cominterop_set_ccw_object_domain) \
MONO_JIT_ICALL (cominterop_type_from_handle) \
MONO_JIT_ICALL (g_free) \
MONO_JIT_ICALL (interp_to_native_trampoline)	\
MONO_JIT_ICALL (mini_llvm_init_gshared_method_mrgctx) \
MONO_JIT_ICALL (mini_llvm_init_gshared_method_this) \
MONO_JIT_ICALL (mini_llvm_init_gshared_method_vtable) \
MONO_JIT_ICALL (mini_llvm_init_method) \
MONO_JIT_ICALL (mini_llvmonly_init_delegate) \
MONO_JIT_ICALL (mini_llvmonly_init_delegate_virtual) \
MONO_JIT_ICALL (mini_llvmonly_init_vtable_slot) \
MONO_JIT_ICALL (mini_llvmonly_resolve_generic_virtual_call) \
MONO_JIT_ICALL (mini_llvmonly_resolve_generic_virtual_iface_call) \
MONO_JIT_ICALL (mini_llvmonly_resolve_iface_call_gsharedvt) \
MONO_JIT_ICALL (mini_llvmonly_resolve_vcall_gsharedvt) \
MONO_JIT_ICALL (mini_llvmonly_throw_nullref_exception) \
MONO_JIT_ICALL (mono_amd64_resume_unwind)	\
MONO_JIT_ICALL (mono_amd64_start_gsharedvt_call)	\
MONO_JIT_ICALL (mono_amd64_throw_corlib_exception)	\
MONO_JIT_ICALL (mono_amd64_throw_exception)	\
MONO_JIT_ICALL (mono_arch_rethrow_exception) \
MONO_JIT_ICALL (mono_arch_throw_corlib_exception) \
MONO_JIT_ICALL (mono_arch_throw_exception) \
MONO_JIT_ICALL (mono_arm_resume_unwind)	\
MONO_JIT_ICALL (mono_arm_start_gsharedvt_call)	\
MONO_JIT_ICALL (mono_arm_throw_exception)	\
MONO_JIT_ICALL (mono_arm_throw_exception_by_token)	\
MONO_JIT_ICALL (mono_arm_unaligned_stack)	\
MONO_JIT_ICALL (mono_array_new_1) \
MONO_JIT_ICALL (mono_array_new_2) \
MONO_JIT_ICALL (mono_array_new_3) \
MONO_JIT_ICALL (mono_array_new_4) \
MONO_JIT_ICALL (mono_array_new_n_icall) \
MONO_JIT_ICALL (mono_array_to_byte_byvalarray) \
MONO_JIT_ICALL (mono_array_to_lparray) \
MONO_JIT_ICALL (mono_array_to_savearray) \
MONO_JIT_ICALL (mono_break) \
MONO_JIT_ICALL (mono_byvalarray_to_byte_array) \
MONO_JIT_ICALL (mono_chkstk_win64) \
MONO_JIT_ICALL (mono_ckfinite) \
MONO_JIT_ICALL (mono_class_interface_match) \
MONO_JIT_ICALL (mono_class_static_field_address) \
MONO_JIT_ICALL (mono_compile_method_icall) \
MONO_JIT_ICALL (mono_context_get_icall) \
MONO_JIT_ICALL (mono_context_set_icall) \
MONO_JIT_ICALL (mono_create_corlib_exception_0) \
MONO_JIT_ICALL (mono_create_corlib_exception_1) \
MONO_JIT_ICALL (mono_create_corlib_exception_2) \
MONO_JIT_ICALL (mono_debug_personality) \
MONO_JIT_ICALL (mono_debugger_agent_breakpoint_from_context) \
MONO_JIT_ICALL (mono_debugger_agent_single_step_from_context) \
MONO_JIT_ICALL (mono_debugger_agent_user_break) \
MONO_JIT_ICALL (mono_delegate_begin_invoke) \
MONO_JIT_ICALL (mono_delegate_end_invoke) \
MONO_JIT_ICALL (mono_delegate_to_ftnptr) \
MONO_JIT_ICALL (mono_domain_get) \
MONO_JIT_ICALL (mono_dummy_jit_icall) \
MONO_JIT_ICALL (mono_exception_from_token) \
MONO_JIT_ICALL (mono_fill_class_rgctx) \
MONO_JIT_ICALL (mono_fill_method_rgctx) \
MONO_JIT_ICALL (mono_fload_r4) \
MONO_JIT_ICALL (mono_fload_r4_arg) \
MONO_JIT_ICALL (mono_free_bstr) \
MONO_JIT_ICALL (mono_free_lparray) \
MONO_JIT_ICALL (mono_fstore_r4) \
MONO_JIT_ICALL (mono_ftnptr_to_delegate) \
MONO_JIT_ICALL (mono_gc_alloc_obj) \
MONO_JIT_ICALL (mono_gc_alloc_string) \
MONO_JIT_ICALL (mono_gc_alloc_vector) \
MONO_JIT_ICALL (mono_gc_wbarrier_generic_nostore_internal) \
MONO_JIT_ICALL (mono_gc_wbarrier_range_copy) \
MONO_JIT_ICALL (mono_gchandle_get_target_internal) \
MONO_JIT_ICALL (mono_generic_class_init) \
MONO_JIT_ICALL (mono_get_assembly_object) \
MONO_JIT_ICALL (mono_get_method_object) \
MONO_JIT_ICALL (mono_get_native_calli_wrapper) \
MONO_JIT_ICALL (mono_get_special_static_data) \
MONO_JIT_ICALL (mono_gsharedvt_constrained_call) \
MONO_JIT_ICALL (mono_gsharedvt_value_copy) \
MONO_JIT_ICALL (mono_helper_compile_generic_method) \
MONO_JIT_ICALL (mono_helper_ldstr) \
MONO_JIT_ICALL (mono_helper_ldstr_mscorlib) \
MONO_JIT_ICALL (mono_helper_newobj_mscorlib) \
MONO_JIT_ICALL (mono_helper_stelem_ref_check) \
MONO_JIT_ICALL (mono_init_vtable_slot) \
MONO_JIT_ICALL (mono_interp_entry_from_trampoline) \
MONO_JIT_ICALL (mono_interp_to_native_trampoline) \
MONO_JIT_ICALL (mono_isfinite_double) \
MONO_JIT_ICALL (mono_jit_set_domain) \
MONO_JIT_ICALL (mono_ldftn) \
MONO_JIT_ICALL (mono_ldtoken_wrapper) \
MONO_JIT_ICALL (mono_ldtoken_wrapper_generic_shared) \
MONO_JIT_ICALL (mono_ldvirtfn) \
MONO_JIT_ICALL (mono_ldvirtfn_gshared) \
MONO_JIT_ICALL (mono_llvm_clear_exception) \
MONO_JIT_ICALL (mono_llvm_load_exception) \
MONO_JIT_ICALL (mono_llvm_match_exception) \
MONO_JIT_ICALL (mono_llvm_resume_exception) \
MONO_JIT_ICALL (mono_llvm_resume_unwind_trampoline) \
MONO_JIT_ICALL (mono_llvm_rethrow_exception) \
MONO_JIT_ICALL (mono_llvm_rethrow_exception_trampoline) \
MONO_JIT_ICALL (mono_llvm_set_unhandled_exception_handler) \
MONO_JIT_ICALL (mono_llvm_throw_corlib_exception) \
MONO_JIT_ICALL (mono_llvm_throw_corlib_exception_abs_trampoline) \
MONO_JIT_ICALL (mono_llvm_throw_corlib_exception_trampoline) \
MONO_JIT_ICALL (mono_llvm_throw_exception) \
MONO_JIT_ICALL (mono_llvm_throw_exception_trampoline) \
MONO_JIT_ICALL (mono_llvmonly_init_delegate) \
MONO_JIT_ICALL (mono_llvmonly_init_delegate_virtual) \
MONO_JIT_ICALL (mono_marshal_asany) \
MONO_JIT_ICALL (mono_marshal_check_domain_image) \
MONO_JIT_ICALL (mono_marshal_clear_last_error) \
MONO_JIT_ICALL (mono_marshal_free) \
MONO_JIT_ICALL (mono_marshal_free_array) \
MONO_JIT_ICALL (mono_marshal_free_asany) \
MONO_JIT_ICALL (mono_marshal_get_type_object) \
MONO_JIT_ICALL (mono_marshal_isinst_with_cache) \
MONO_JIT_ICALL (mono_marshal_safearray_begin) \
MONO_JIT_ICALL (mono_marshal_safearray_create) \
MONO_JIT_ICALL (mono_marshal_safearray_end) \
MONO_JIT_ICALL (mono_marshal_safearray_free_indices) \
MONO_JIT_ICALL (mono_marshal_safearray_get_value) \
MONO_JIT_ICALL (mono_marshal_safearray_next) \
MONO_JIT_ICALL (mono_marshal_safearray_set_value) \
MONO_JIT_ICALL (mono_marshal_set_domain_by_id) \
MONO_JIT_ICALL (mono_marshal_set_last_error) \
MONO_JIT_ICALL (mono_marshal_set_last_error_windows) \
MONO_JIT_ICALL (mono_marshal_string_to_utf16) \
MONO_JIT_ICALL (mono_marshal_string_to_utf16_copy) \
MONO_JIT_ICALL (mono_marshal_xdomain_copy_out_value) \
MONO_JIT_ICALL (mono_monitor_enter_fast) \
MONO_JIT_ICALL (mono_monitor_enter_internal) \
MONO_JIT_ICALL (mono_monitor_enter_v4_fast) \
MONO_JIT_ICALL (mono_monitor_enter_v4_internal) \
MONO_JIT_ICALL (mono_object_castclass_unbox) \
MONO_JIT_ICALL (mono_object_castclass_with_cache) \
MONO_JIT_ICALL (mono_object_isinst_icall) \
MONO_JIT_ICALL (mono_object_isinst_with_cache) \
MONO_JIT_ICALL (mono_ppc_throw_exception)	\
MONO_JIT_ICALL (mono_profiler_raise_exception_clause) \
MONO_JIT_ICALL (mono_profiler_raise_gc_allocation) \
MONO_JIT_ICALL (mono_profiler_raise_method_enter) \
MONO_JIT_ICALL (mono_profiler_raise_method_leave) \
MONO_JIT_ICALL (mono_profiler_raise_method_tail_call) \
MONO_JIT_ICALL (mono_remoting_update_exception) \
MONO_JIT_ICALL (mono_remoting_wrapper) \
MONO_JIT_ICALL (mono_resolve_generic_virtual_call) \
MONO_JIT_ICALL (mono_resolve_generic_virtual_iface_call) \
MONO_JIT_ICALL (mono_resolve_iface_call_gsharedvt) \
MONO_JIT_ICALL (mono_resolve_vcall_gsharedvt) \
MONO_JIT_ICALL (mono_resume_unwind) \
MONO_JIT_ICALL (mono_rethrow_preserve_exception) \
MONO_JIT_ICALL (mono_string_builder_to_utf16) \
MONO_JIT_ICALL (mono_string_builder_to_utf8) \
MONO_JIT_ICALL (mono_string_from_bstr_icall) \
MONO_JIT_ICALL (mono_string_from_byvalstr) \
MONO_JIT_ICALL (mono_string_from_byvalwstr) \
MONO_JIT_ICALL (mono_string_new_len_wrapper) \
MONO_JIT_ICALL (mono_string_new_wrapper_internal) \
MONO_JIT_ICALL (mono_string_to_ansibstr) \
MONO_JIT_ICALL (mono_string_to_bstr) \
MONO_JIT_ICALL (mono_string_to_byvalstr) \
MONO_JIT_ICALL (mono_string_to_byvalwstr) \
MONO_JIT_ICALL (mono_string_to_utf16_internal) \
MONO_JIT_ICALL (mono_string_to_utf8str) \
MONO_JIT_ICALL (mono_string_utf16_to_builder) \
MONO_JIT_ICALL (mono_string_utf16_to_builder2) \
MONO_JIT_ICALL (mono_string_utf8_to_builder) \
MONO_JIT_ICALL (mono_string_utf8_to_builder2) \
MONO_JIT_ICALL (mono_struct_delete_old) \
MONO_JIT_ICALL (mono_thread_force_interruption_checkpoint_noraise) \
MONO_JIT_ICALL (mono_thread_get_undeniable_exception) \
MONO_JIT_ICALL (mono_thread_interruption_checkpoint) \
MONO_JIT_ICALL (mono_threads_attach_coop) \
MONO_JIT_ICALL (mono_threads_detach_coop) \
MONO_JIT_ICALL (mono_threads_enter_gc_safe_region_unbalanced) \
MONO_JIT_ICALL (mono_threads_enter_gc_unsafe_region_unbalanced) \
MONO_JIT_ICALL (mono_threads_exit_gc_safe_region_unbalanced) \
MONO_JIT_ICALL (mono_threads_exit_gc_unsafe_region_unbalanced) \
MONO_JIT_ICALL (mono_threads_state_poll) \
MONO_JIT_ICALL (mono_throw_exception) \
MONO_JIT_ICALL (mono_throw_method_access) \
MONO_JIT_ICALL (mono_throw_bad_image) \
MONO_JIT_ICALL (mono_trace_enter_method) \
MONO_JIT_ICALL (mono_trace_leave_method) \
MONO_JIT_ICALL (mono_upgrade_remote_class_wrapper) \
MONO_JIT_ICALL (mono_value_copy_internal) \
MONO_JIT_ICALL (mono_x86_start_gsharedvt_call)	\
MONO_JIT_ICALL (mono_x86_throw_corlib_exception)	\
MONO_JIT_ICALL (mono_x86_throw_exception)	\
MONO_JIT_ICALL (native_to_interp_trampoline)	\
MONO_JIT_ICALL (personality) \
MONO_JIT_ICALL (pthread_getspecific) \
MONO_JIT_ICALL (rgctx_fetch_trampoline_general)	\
MONO_JIT_ICALL (sdb_breakpoint_trampoline)	\
MONO_JIT_ICALL (sdb_single_step_trampoline)	\
MONO_JIT_ICALL (type_from_handle) \
MONO_JIT_ICALL (ves_icall_array_new) \
MONO_JIT_ICALL (ves_icall_array_new_specific) \
MONO_JIT_ICALL (ves_icall_marshal_alloc) \
MONO_JIT_ICALL (ves_icall_mono_delegate_ctor) \
MONO_JIT_ICALL (ves_icall_mono_delegate_ctor_interp) \
MONO_JIT_ICALL (ves_icall_mono_ldstr) \
MONO_JIT_ICALL (ves_icall_mono_marshal_xdomain_copy_value) \
MONO_JIT_ICALL (ves_icall_mono_string_from_utf16) \
MONO_JIT_ICALL (ves_icall_mono_string_to_utf8) \
MONO_JIT_ICALL (ves_icall_object_new) \
MONO_JIT_ICALL (ves_icall_object_new_specific) \
MONO_JIT_ICALL (ves_icall_runtime_class_init) \
MONO_JIT_ICALL (ves_icall_string_alloc) \
MONO_JIT_ICALL (ves_icall_string_new_wrapper) \
MONO_JIT_ICALL (ves_icall_thread_finish_async_abort) \
	\
MONO_JIT_ICALL (count) \

#define MONO_JIT_ICALL_mono_get_lmf_addr MONO_JIT_ICALL_mono_tls_get_lmf_addr_extern

typedef enum MonoJitICallId
{
#define MONO_JIT_ICALL(x) MONO_JIT_ICALL_ ## x,
MONO_JIT_ICALLS
#undef MONO_JIT_ICALL
} MonoJitICallId;

typedef union MonoJitICallInfos {
	struct {
#define MONO_JIT_ICALL(x) MonoJitICallInfo x;
MONO_JIT_ICALLS
#undef MONO_JIT_ICALL
	};
	MonoJitICallInfo array [MONO_JIT_ICALL_count];
} MonoJitICallInfos;

// Indirect mono_jit_icall_info access through a function or macro due to loaded LLVM.
//
#if MONO_LLVM_LOADED

MONO_LLVM_INTERNAL MonoJitICallInfos*
mono_get_jit_icall_info (void);

#else

extern MonoJitICallInfos mono_jit_icall_info;

#define mono_get_jit_icall_info() (&mono_jit_icall_info)

#endif

// Convert MonoJitICallInfo* to an int or enum.
//
#define mono_jit_icall_info_index(x) ((x) - mono_get_jit_icall_info ()->array)
#define mono_jit_icall_info_id(x) ((MonoJitICallId)mono_jit_icall_info_index(x))

// Given an enum/id, get the MonoJitICallInfo*.
//
static inline MonoJitICallInfo*
mono_find_jit_icall_info (MonoJitICallId id)
{
	const guint index = (guint)id;

	g_assert (index < MONO_JIT_ICALL_count);
	g_static_assert (MONO_JIT_ICALL_count < 0x200); // fits in 9 bits

	return &mono_get_jit_icall_info ()->array [index];
}

#if __cplusplus
// MonoJumpInfo.jit_icall_id is gsize instead of MonoJitICallId in order
// to fully overlap pointers, and not match union reads with writes.
inline MonoJitICallInfo*
mono_find_jit_icall_info (gsize id)
{
	return mono_find_jit_icall_info ((MonoJitICallId)id);
}
#endif

```

`Hazel/vendor/mono/include/mono/metadata/loaded-images-internals.h`:

```h
/**
* \file
*/

#ifndef _MONO_METADATA_IMAGE_HASHES_H_
#define _MONO_METADATA_IMAGE_HASHES_H_

#include <glib.h>
#include <mono/metadata/object-forward.h>
#include <mono/metadata/loader-internals.h>
#include <mono/utils/mono-forward.h>
#include <mono/utils/mono-error.h>

/*
 * The "loaded images" hashes keep track of the various assemblies and netmodules loaded
 * There are four, for all combinations of [look up by path or assembly name?]
 * and [normal or reflection-only load?, as in Assembly.ReflectionOnlyLoad]
 */
enum {
	MONO_LOADED_IMAGES_HASH_PATH = 0,
	MONO_LOADED_IMAGES_HASH_PATH_REFONLY = 1,
	MONO_LOADED_IMAGES_HASH_NAME = 2,
	MONO_LOADED_IMAGES_HASH_NAME_REFONLY = 3,
	MONO_LOADED_IMAGES_HASH_COUNT = 4
};

struct _MonoLoadedImages {
	MonoAssemblyLoadContext *owner; /* NULL if global */
	GHashTable *loaded_images_hashes [MONO_LOADED_IMAGES_HASH_COUNT];
};

void
mono_loaded_images_init (MonoLoadedImages *li, MonoAssemblyLoadContext *owner);

void
mono_loaded_images_cleanup (MonoLoadedImages *li, gboolean shutdown);

void
mono_loaded_images_free (MonoLoadedImages *li);

GHashTable *
mono_loaded_images_get_hash (MonoLoadedImages *li, gboolean refonly);

GHashTable *
mono_loaded_images_get_by_name_hash (MonoLoadedImages *li, gboolean refonly);

gboolean
mono_loaded_images_remove_image (MonoImage *image);

MonoLoadedImages*
mono_image_get_loaded_images_for_modules (MonoImage *image);

#ifndef ENABLE_NETCORE
MonoLoadedImages*
mono_get_global_loaded_images (void);
#endif

MonoImage *
mono_find_image_owner (void *ptr);

void
mono_images_lock (void);

void
mono_images_unlock (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/loader-internals.h`:

```h
/**
* \file
*/

#ifndef _MONO_METADATA_LOADER_INTERNALS_H_
#define _MONO_METADATA_LOADER_INTERNALS_H_

#include <glib.h>
#include <mono/metadata/appdomain.h>
#include <mono/metadata/image.h>
#include <mono/metadata/object-forward.h>
#include <mono/utils/mono-forward.h>
#include <mono/utils/mono-error.h>
#include <mono/utils/mono-coop-mutex.h>

typedef struct _MonoLoadedImages MonoLoadedImages;
typedef struct _MonoAssemblyLoadContext MonoAssemblyLoadContext;

#ifndef DISABLE_DLLMAP
typedef struct _MonoDllMap MonoDllMap;
struct _MonoDllMap {
	char *dll;
	char *target;
	char *func;
	char *target_func;
	MonoDllMap *next;
};
#endif

#ifdef ENABLE_NETCORE
/* FIXME: this probably belongs somewhere else */
struct _MonoAssemblyLoadContext {
	MonoDomain *domain;
	MonoLoadedImages *loaded_images;
	GSList *loaded_assemblies;
	MonoCoopMutex assemblies_lock;
	/* Handle of the corresponding managed object.  If the ALC is
	 * collectible, the handle is weak, otherwise it's strong.
	 */
	uint32_t gchandle;

	// Used in native-library.c for the hash table below; do not access anywhere else
	MonoCoopMutex pinvoke_lock;
	// Maps malloc-ed char* pinvoke scope -> MonoDl*
	GHashTable *pinvoke_scopes;
};
#endif /* ENABLE_NETCORE */

void
mono_global_loader_data_lock (void);

void
mono_global_loader_data_unlock (void);

gpointer
mono_lookup_pinvoke_call_internal (MonoMethod *method, MonoError *error);

#ifndef DISABLE_DLLMAP
void
mono_dllmap_insert_internal (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc);

void
mono_global_dllmap_cleanup (void);
#endif

void
mono_global_loader_cache_init (void);

void
mono_global_loader_cache_cleanup (void);

#ifdef ENABLE_NETCORE
void
mono_set_pinvoke_search_directories (int dir_count, char **dirs);

void
mono_alc_init (MonoAssemblyLoadContext *alc, MonoDomain *domain);

void
mono_alc_cleanup (MonoAssemblyLoadContext *alc);

void
mono_alc_assemblies_lock (MonoAssemblyLoadContext *alc);

void
mono_alc_assemblies_unlock (MonoAssemblyLoadContext *alc);

gboolean
mono_alc_is_default (MonoAssemblyLoadContext *alc);

MonoAssembly*
mono_alc_invoke_resolve_using_load_nofail (MonoAssemblyLoadContext *alc, MonoAssemblyName *aname);

MonoAssembly*
mono_alc_invoke_resolve_using_resolving_event_nofail (MonoAssemblyLoadContext *alc, MonoAssemblyName *aname);

MonoAssembly*
mono_alc_invoke_resolve_using_resolve_satellite_nofail (MonoAssemblyLoadContext *alc, MonoAssemblyName *aname);

#endif /* ENABLE_NETCORE */

static inline MonoDomain *
mono_alc_domain (MonoAssemblyLoadContext *alc)
{
#ifdef ENABLE_NETCORE
	return alc->domain;
#else
	return mono_domain_get ();
#endif
}

MonoLoadedImages *
mono_alc_get_loaded_images (MonoAssemblyLoadContext *alc);

MONO_API void
mono_loader_save_bundled_library (int fd, uint64_t offset, uint64_t size, const char *destfname);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/loader.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_LOADER_H_
#define _MONO_METADATA_LOADER_H_ 1

#include <mono/utils/mono-forward.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/image.h>
#include <mono/utils/mono-error.h>

MONO_BEGIN_DECLS

typedef mono_bool (*MonoStackWalk)     (MonoMethod *method, int32_t native_offset, int32_t il_offset, mono_bool managed, void* data);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod *
mono_get_method             (MonoImage *image, uint32_t token, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod *
mono_get_method_full        (MonoImage *image, uint32_t token, MonoClass *klass,
			     MonoGenericContext *context);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod *
mono_get_method_constrained (MonoImage *image, uint32_t token, MonoClass *constrained_class,
			     MonoGenericContext *context, MonoMethod **cil_method);

MONO_API void               
mono_free_method           (MonoMethod *method);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethodSignature*
mono_method_get_signature_full (MonoMethod *method, MonoImage *image, uint32_t token,
				MonoGenericContext *context);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethodSignature*
mono_method_get_signature  (MonoMethod *method, MonoImage *image, uint32_t token);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethodSignature*
mono_method_signature      (MonoMethod *method);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethodHeader*
mono_method_get_header     (MonoMethod *method);

MONO_API const char*
mono_method_get_name       (MonoMethod *method);

MONO_API MonoClass*
mono_method_get_class      (MonoMethod *method);

MONO_API uint32_t
mono_method_get_token      (MonoMethod *method);

MONO_API uint32_t
mono_method_get_flags      (MonoMethod *method, uint32_t *iflags);

MONO_API uint32_t
mono_method_get_index      (MonoMethod *method);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_add_internal_call     (const char *name, const void* method);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_dangerous_add_raw_internal_call (const char *name, const void* method);

MONO_API void*
mono_lookup_internal_call (MonoMethod *method);

MONO_API const char*
mono_lookup_icall_symbol (MonoMethod *m);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc);

MONO_API MONO_RT_EXTERNAL_ONLY void*
mono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg);

MONO_API void
mono_method_get_param_names (MonoMethod *method, const char **names);

MONO_API uint32_t
mono_method_get_param_token (MonoMethod *method, int idx);

MONO_API void
mono_method_get_marshal_info (MonoMethod *method, MonoMarshalSpec **mspecs);

MONO_API mono_bool
mono_method_has_marshal_info (MonoMethod *method);

MONO_API MonoMethod*
mono_method_get_last_managed  (void);

MONO_API void
mono_stack_walk         (MonoStackWalk func, void* user_data);

/* Use this if the IL offset is not needed: it's faster */
MONO_API void
mono_stack_walk_no_il   (MonoStackWalk func, void* user_data);

typedef mono_bool (*MonoStackWalkAsyncSafe)     (MonoMethod *method, MonoDomain *domain, void *base_address, int offset, void* data);
MONO_API void
mono_stack_walk_async_safe   (MonoStackWalkAsyncSafe func, void *initial_sig_context, void* user_data);

MONO_API MonoMethodHeader*
mono_method_get_header_checked (MonoMethod *method, MonoError *error);

MONO_END_DECLS

#endif


```

`Hazel/vendor/mono/include/mono/metadata/locales.h`:

```h
/**
 * \file
 * Culture-sensitive handling
 *
 * Authors:
 *	Dick Porter (dick@ximian.com)
 *
 * (C) 2003 Ximian, Inc.
 */

#ifndef _MONO_METADATA_LOCALES_H_
#define _MONO_METADATA_LOCALES_H_

#include <glib.h>

#include <mono/metadata/object-internals.h>
#include <mono/metadata/icalls.h>

#if !ENABLE_NETCORE

/* This is a copy of System.Globalization.CompareOptions */
typedef enum {
	CompareOptions_None=0x00,
	CompareOptions_IgnoreCase=0x01,
	CompareOptions_IgnoreNonSpace=0x02,
	CompareOptions_IgnoreSymbols=0x04,
	CompareOptions_IgnoreKanaType=0x08,
	CompareOptions_IgnoreWidth=0x10,
	CompareOptions_StringSort=0x20000000,
	CompareOptions_Ordinal=0x40000000
} MonoCompareOptions;

typedef struct NumberFormatEntryManaged NumberFormatEntryManaged;

ICALL_EXPORT
gconstpointer
ves_icall_System_Globalization_CultureData_fill_number_data (gint32 number_index, NumberFormatEntryManaged *managed);

ICALL_EXPORT
void ves_icall_System_Globalization_CultureInfo_construct_internal_locale (MonoCultureInfo *this_obj, MonoString *locale);

ICALL_EXPORT
void ves_icall_System_Globalization_CompareInfo_construct_compareinfo (MonoCompareInfo *comp, MonoString *locale);

ICALL_EXPORT gint32
ves_icall_System_Globalization_CompareInfo_internal_compare (const gunichar2 *str1, gint32 len1,
	const gunichar2 *str2, gint32 len2, gint32 options);

ICALL_EXPORT
void ves_icall_System_Globalization_CompareInfo_free_internal_collator (MonoCompareInfo *this_obj);

ICALL_EXPORT gint32
ves_icall_System_Globalization_CompareInfo_internal_index (const gunichar2 *source, gint32 sindex,
	gint32 count, const gunichar2 *value, gint32 value_length, MonoBoolean first);

#endif /* !ENABLE_NETCORE */

#define MONO_LOCALE_INVARIANT (0x007F)

#endif /* _MONO_METADATA_FILEIO_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/lock-tracer.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_LOCK_TRACER_H__
#define __MONO_METADATA_LOCK_TRACER_H__

/*This is a private header*/
#include <glib.h>

#include "mono/utils/mono-os-mutex.h"
#include "mono/utils/mono-coop-mutex.h"

typedef enum {
	InvalidLock = 0,
	LoaderLock,
	ImageDataLock,
	DomainLock,
	DomainAssembliesLock,
	DomainJitCodeHashLock,
	IcallLock,
	AssemblyBindingLock,
	MarshalLock,
	ClassesLock,
	LoaderGlobalDataLock,
	ThreadsLock,
} RuntimeLocks;

#ifdef LOCK_TRACER

void mono_locks_tracer_init (void);

void mono_locks_lock_acquired (RuntimeLocks kind, gpointer lock);
void mono_locks_lock_released (RuntimeLocks kind, gpointer lock);

#else

#define mono_locks_tracer_init() do {} while (0)

#define mono_locks_lock_acquired(__UNUSED0, __UNUSED1) do {} while (0)
#define mono_locks_lock_released(__UNUSED0, __UNUSED1) do {} while (0)

#endif

#define mono_locks_os_acquire(LOCK,NAME)	\
	do {	\
		mono_os_mutex_lock (LOCK);	\
		mono_locks_lock_acquired (NAME, LOCK);	\
	} while (0)

#define mono_locks_os_release(LOCK,NAME)	\
	do {	\
		mono_locks_lock_released (NAME, LOCK);	\
		mono_os_mutex_unlock (LOCK);	\
	} while (0)

#define mono_locks_coop_acquire(LOCK,NAME)	\
	do {	\
		mono_coop_mutex_lock (LOCK);	\
		mono_locks_lock_acquired (NAME, LOCK);	\
	} while (0)

#define mono_locks_coop_release(LOCK,NAME)	\
	do {	\
		mono_locks_lock_released (NAME, LOCK);	\
		mono_coop_mutex_unlock (LOCK);	\
	} while (0)

#endif /* __MONO_METADATA_LOCK_TRACER_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/marshal-ilgen.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_MARSHAL_ILGEN_H__
#define __MONO_MARSHAL_ILGEN_H__

MONO_API void
mono_marshal_ilgen_init (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/marshal-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_MARSHAL_INTERNALS_H__
#define __MONO_METADATA_MARSHAL_INTERNALS_H__

#include <config.h>
#include <glib.h>
#include <mono/metadata/object-internals.h>

MonoObjectHandle
mono_marshal_xdomain_copy_value_handle (MonoObjectHandle val, MonoError *error);

void*
mono_marshal_alloc_co_task_mem (size_t size);

void
mono_marshal_free_co_task_mem (void *ptr);

gpointer
mono_marshal_realloc_co_task_mem (gpointer ptr, size_t size);

void
mono_marshal_free_hglobal (void *ptr);

gpointer
mono_marshal_realloc_hglobal (gpointer ptr, size_t size);

void*
mono_marshal_alloc_hglobal (size_t size);

void*
mono_marshal_alloc_hglobal_error (gsize size, MonoError*);

typedef enum {
	TYPECHECK_OBJECT_ARG_POS = 0,
	TYPECHECK_CLASS_ARG_POS = 1,
	TYPECHECK_CACHE_ARG_POS = 2
} MarshalTypeCheckPositions;

#endif /* __MONO_METADATA_MARSHAL_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/marshal-windows-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_MARSHAL_WINDOWS_INTERNALS_H__
#define __MONO_METADATA_MARSHAL_WINDOWS_INTERNALS_H__

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32
#include "mono/metadata/marshal.h"
#include "mono/metadata/marshal-internals.h"
#include "mono/metadata/exception.h"
#endif /* HOST_WIN32 */

#endif /* __MONO_METADATA_MARSHAL_WINDOWS_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/marshal.h`:

```h
/**
 * \file
 * Routines for marshaling complex types in P/Invoke methods.
 * 
 * Author:
 *   Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2002 Ximian, Inc.  http://www.ximian.com
 *
 */

#ifndef __MONO_MARSHAL_H__
#define __MONO_MARSHAL_H__

#include <mono/metadata/class.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/class-internals.h>
#include <mono/metadata/opcodes.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/method-builder.h>
#include <mono/metadata/remoting.h>
#include <mono/utils/mono-error.h>
#include <mono/metadata/icalls.h>

typedef gunichar2 *mono_bstr;
typedef const gunichar2 *mono_bstr_const;

#define mono_marshal_find_bitfield_offset(type, elem, byte_offset, bitmask) \
	do { \
		type tmp; \
		memset (&tmp, 0, sizeof (tmp)); \
		tmp.elem = 1; \
		mono_marshal_find_nonzero_bit_offset ((guint8*)&tmp, sizeof (tmp), (byte_offset), (bitmask)); \
	} while (0)


GENERATE_TRY_GET_CLASS_WITH_CACHE_DECL(stringbuilder)


/*
 * This structure holds the state kept by the emit_ marshalling functions.
 * This is exported so it can be used by cominterop.c.
 */
typedef struct {
	MonoMethodBuilder *mb;
	MonoMethodSignature *sig;
	MonoMethodPInvoke *piinfo;
	int *orig_conv_args; /* Locals containing the original values of byref args */
	int retobj_var;
	int vtaddr_var;
	MonoClass *retobj_class;
	MonoMethodSignature *csig; /* Might need to be changed due to MarshalAs directives */
	MonoImage *image; /* The image to use for looking up custom marshallers */
} EmitMarshalContext;

typedef enum {
	/*
	 * This is invoked to convert arguments from the current types to
	 * the underlying types expected by the platform routine.  If required,
	 * the methods create a temporary variable with the proper type, and return
	 * the location for it (either the passed argument, or the newly allocated
	 * local slot).
	 */
	MARSHAL_ACTION_CONV_IN,

	/*
	 * This operation is called to push the actual value that was optionally
	 * converted on the first stage
	 */
	MARSHAL_ACTION_PUSH,

	/*
	 * Convert byref arguments back or free resources allocated during the
	 * CONV_IN stage
	 */
	MARSHAL_ACTION_CONV_OUT,

	/*
	 * The result from the unmanaged call is at the top of the stack when
	 * this action is invoked.    The result should be stored in the
	 * third local variable slot. 
	 */
	MARSHAL_ACTION_CONV_RESULT,

	MARSHAL_ACTION_MANAGED_CONV_IN,
	MARSHAL_ACTION_MANAGED_CONV_OUT,
	MARSHAL_ACTION_MANAGED_CONV_RESULT
} MarshalAction;

/*
 * This is an extension of the MONO_WRAPPER_ enum to avoid adding more elements to that
 * enum.
 */
typedef enum {
	WRAPPER_SUBTYPE_NONE,
	/* Subtypes of MONO_WRAPPER_MANAGED_TO_MANAGED */
	WRAPPER_SUBTYPE_ELEMENT_ADDR,
	WRAPPER_SUBTYPE_STRING_CTOR,
	/* Subtypes of MONO_WRAPPER_STELEMREF */
	WRAPPER_SUBTYPE_VIRTUAL_STELEMREF,
	/* Subtypes of MONO_WRAPPER_OTHER */
	WRAPPER_SUBTYPE_FAST_MONITOR_ENTER,
	WRAPPER_SUBTYPE_FAST_MONITOR_ENTER_V4,
	WRAPPER_SUBTYPE_FAST_MONITOR_EXIT,
	WRAPPER_SUBTYPE_PTR_TO_STRUCTURE,
	WRAPPER_SUBTYPE_STRUCTURE_TO_PTR,
	/* Subtypes of MONO_WRAPPER_CASTCLASS */
	WRAPPER_SUBTYPE_CASTCLASS_WITH_CACHE,
	WRAPPER_SUBTYPE_ISINST_WITH_CACHE,
	/* Subtypes of MONO_WRAPPER_RUNTIME_INVOKE */
	WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL,
	WRAPPER_SUBTYPE_RUNTIME_INVOKE_DYNAMIC,
	WRAPPER_SUBTYPE_RUNTIME_INVOKE_DIRECT,
	WRAPPER_SUBTYPE_RUNTIME_INVOKE_VIRTUAL,
	/* Subtypes of MONO_WRAPPER_MANAGED_TO_NATIVE */
	WRAPPER_SUBTYPE_ICALL_WRAPPER, // specifically JIT icalls
	WRAPPER_SUBTYPE_NATIVE_FUNC_AOT,
	WRAPPER_SUBTYPE_PINVOKE,
	/* Subtypes of MONO_WRAPPER_OTHER */
	WRAPPER_SUBTYPE_SYNCHRONIZED_INNER,
	WRAPPER_SUBTYPE_GSHAREDVT_IN,
	WRAPPER_SUBTYPE_GSHAREDVT_OUT,
	WRAPPER_SUBTYPE_ARRAY_ACCESSOR,
	/* Subtypes of MONO_WRAPPER_MANAGED_TO_MANAGED */
	WRAPPER_SUBTYPE_GENERIC_ARRAY_HELPER,
	/* Subtypes of MONO_WRAPPER_DELEGATE_INVOKE */
	WRAPPER_SUBTYPE_DELEGATE_INVOKE_VIRTUAL,
	WRAPPER_SUBTYPE_DELEGATE_INVOKE_BOUND,
	/* Subtypes of MONO_WRAPPER_OTHER */
	WRAPPER_SUBTYPE_GSHAREDVT_IN_SIG,
	WRAPPER_SUBTYPE_GSHAREDVT_OUT_SIG,
	WRAPPER_SUBTYPE_INTERP_IN,
	WRAPPER_SUBTYPE_INTERP_LMF,
	WRAPPER_SUBTYPE_AOT_INIT,
	WRAPPER_SUBTYPE_LLVM_FUNC
} WrapperSubtype;

typedef struct {
	MonoMethod *method;
	MonoClass *klass;
} NativeToManagedWrapperInfo;

typedef struct {
	MonoMethod *method;
} StringCtorWrapperInfo;

typedef struct {
	int kind;
} VirtualStelemrefWrapperInfo;

typedef struct {
	guint32 rank, elem_size;
} ElementAddrWrapperInfo;

typedef struct {
	MonoMethod *method;
	/* For WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL */
	MonoMethodSignature *sig;
} RuntimeInvokeWrapperInfo;

typedef struct {
	MonoMethod *method;
} ManagedToNativeWrapperInfo;

typedef struct {
	MonoMethod *method;
} SynchronizedWrapperInfo;

typedef struct {
	MonoMethod *method;
} SynchronizedInnerWrapperInfo;

typedef struct {
	MonoMethod *method;
} GenericArrayHelperWrapperInfo;

typedef struct {
	MonoJitICallId jit_icall_id;
} ICallWrapperInfo;

typedef struct {
	MonoMethod *method;
} ArrayAccessorWrapperInfo;

typedef struct {
	MonoClass *klass;
} ProxyWrapperInfo;

typedef struct {
	const char *gc_name;
	int alloc_type;
} AllocatorWrapperInfo;

typedef struct {
	MonoMethod *method;
} UnboxWrapperInfo;

typedef struct {
	MonoMethod *method;
} RemotingWrapperInfo;

typedef struct {
	MonoMethodSignature *sig;
} GsharedvtWrapperInfo;

typedef struct {
	MonoMethod *method;
} DelegateInvokeWrapperInfo;

typedef struct {
	MonoMethodSignature *sig;
} InterpInWrapperInfo;

typedef enum {
	AOT_INIT_METHOD = 0,
	AOT_INIT_METHOD_GSHARED_MRGCTX = 1,
	AOT_INIT_METHOD_GSHARED_THIS = 2,
	AOT_INIT_METHOD_GSHARED_VTABLE = 3
} MonoAotInitSubtype;

typedef struct {
	// We emit this code when we init the module,
	// and later match up the native code with this method
	// using the name.
	MonoAotInitSubtype subtype;
} AOTInitWrapperInfo;

typedef enum {
	LLVM_FUNC_WRAPPER_GC_POLL = 0
} MonoLLVMFuncWrapperSubtype;

typedef struct {
	// We emit this code when we init the module,
	// and later match up the native code with this method
	// using the name.
	MonoLLVMFuncWrapperSubtype subtype;
} LLVMFuncWrapperInfo;

/*
 * This structure contains additional information to uniquely identify a given wrapper
 * method. It can be retrieved by mono_marshal_get_wrapper_info () for certain types
 * of wrappers, i.e. ones which do not have a 1-1 association with a method/class.
 */
typedef struct {
	WrapperSubtype subtype;
	union {
		/* RUNTIME_INVOKE_... */
		RuntimeInvokeWrapperInfo runtime_invoke;
		/* STRING_CTOR */
		StringCtorWrapperInfo string_ctor;
		/* ELEMENT_ADDR */
		ElementAddrWrapperInfo element_addr;
		/* VIRTUAL_STELEMREF */
		VirtualStelemrefWrapperInfo virtual_stelemref;
		/* MONO_WRAPPER_NATIVE_TO_MANAGED */
		NativeToManagedWrapperInfo native_to_managed;
		/* MONO_WRAPPER_MANAGED_TO_NATIVE */
		ManagedToNativeWrapperInfo managed_to_native;
		/* SYNCHRONIZED */
		SynchronizedWrapperInfo synchronized;
		/* SYNCHRONIZED_INNER */
		SynchronizedInnerWrapperInfo synchronized_inner;
		/* GENERIC_ARRAY_HELPER */
		GenericArrayHelperWrapperInfo generic_array_helper;
		/* ICALL_WRAPPER */
		ICallWrapperInfo icall;
		/* ARRAY_ACCESSOR */
		ArrayAccessorWrapperInfo array_accessor;
		/* PROXY_ISINST etc. */
		ProxyWrapperInfo proxy;
		/* ALLOC */
		AllocatorWrapperInfo alloc;
		/* UNBOX */
		UnboxWrapperInfo unbox;
		/* MONO_WRAPPER_REMOTING_INVOKE/MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK/MONO_WRAPPER_XDOMAIN_INVOKE */
		RemotingWrapperInfo remoting;
		/* GSHAREDVT_IN_SIG/GSHAREDVT_OUT_SIG */
		GsharedvtWrapperInfo gsharedvt;
		/* DELEGATE_INVOKE */
		DelegateInvokeWrapperInfo delegate_invoke;
		/* INTERP_IN */
		InterpInWrapperInfo interp_in;
		/* AOT_INIT */
		AOTInitWrapperInfo aot_init;
		/* LLVM_FUNC */
		LLVMFuncWrapperInfo llvm_func;
	} d;
} WrapperInfo;

typedef enum {
	STELEMREF_OBJECT, /*no check at all*/
	STELEMREF_SEALED_CLASS, /*check vtable->klass->element_type */
	STELEMREF_CLASS, /*only the klass->parents check*/
	STELEMREF_CLASS_SMALL_IDEPTH, /* like STELEMREF_CLASS bit without the idepth check */
	STELEMREF_INTERFACE, /*interfaces without variant generic arguments. */
	STELEMREF_COMPLEX, /*arrays, MBR or types with variant generic args - go straight to icalls*/
	STELEMREF_KIND_COUNT
} MonoStelemrefKind;


#define MONO_MARSHAL_CALLBACKS_VERSION 4

typedef struct {
	int version;
	int (*emit_marshal_array) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_boolean) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_ptr) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_char) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_scalar) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);

	int (*emit_marshal_custom) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_asany) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_vtype) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_string) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_safehandle) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_handleref) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_object) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	int (*emit_marshal_variant) (EmitMarshalContext *m, int argnum, MonoType *t, MonoMarshalSpec *spec, int conv_arg, MonoType **conv_arg_type, MarshalAction action);
	void (*emit_castclass) (MonoMethodBuilder *mb);
	void (*emit_struct_to_ptr) (MonoMethodBuilder *mb, MonoClass *klass);
	void (*emit_ptr_to_struct) (MonoMethodBuilder *mb, MonoClass *klass);
	void (*emit_isinst) (MonoMethodBuilder *mb);
	void (*emit_virtual_stelemref) (MonoMethodBuilder *mb, const char **param_names, MonoStelemrefKind kind);
	void (*emit_stelemref) (MonoMethodBuilder *mb);
	void (*emit_array_address) (MonoMethodBuilder *mb, int rank, int elem_size);
	void (*emit_native_wrapper) (MonoImage *image, MonoMethodBuilder *mb, MonoMethodSignature *sig, MonoMethodPInvoke *piinfo, MonoMarshalSpec **mspecs, gpointer func, gboolean aot, gboolean check_exceptions, gboolean func_param, gboolean skip_gc_trans);
	void (*emit_managed_wrapper) (MonoMethodBuilder *mb, MonoMethodSignature *invoke_sig, MonoMarshalSpec **mspecs, EmitMarshalContext* m, MonoMethod *method, uint32_t target_handle);
	void (*emit_runtime_invoke_body) (MonoMethodBuilder *mb, const char **param_names, MonoImage *image, MonoMethod *method, MonoMethodSignature *sig, MonoMethodSignature *callsig, gboolean virtual_, gboolean need_direct_wrapper);
	void (*emit_runtime_invoke_dynamic) (MonoMethodBuilder *mb);
	void (*emit_delegate_begin_invoke) (MonoMethodBuilder *mb, MonoMethodSignature *sig);
	void (*emit_delegate_end_invoke) (MonoMethodBuilder *mb, MonoMethodSignature *sig);
	void (*emit_delegate_invoke_internal) (MonoMethodBuilder *mb, MonoMethodSignature *sig, MonoMethodSignature *invoke_sig, gboolean static_method_with_first_arg_bound, gboolean callvirt, gboolean closed_over_null, MonoMethod *method, MonoMethod *target_method, MonoClass *target_class, MonoGenericContext *ctx, MonoGenericContainer *container);
	void (*emit_synchronized_wrapper) (MonoMethodBuilder *mb, MonoMethod *method, MonoGenericContext *ctx, MonoGenericContainer *container, MonoMethod *enter_method, MonoMethod *exit_method, MonoMethod *gettypefromhandle_method);
	void (*emit_unbox_wrapper) (MonoMethodBuilder *mb, MonoMethod *method);
	void (*emit_array_accessor_wrapper) (MonoMethodBuilder *mb, MonoMethod *method, MonoMethodSignature *sig, MonoGenericContext *ctx);
	void (*emit_generic_array_helper) (MonoMethodBuilder *mb, MonoMethod *method, MonoMethodSignature *csig);
	void (*emit_thunk_invoke_wrapper) (MonoMethodBuilder *mb, MonoMethod *method, MonoMethodSignature *csig);
	void (*emit_create_string_hack) (MonoMethodBuilder *mb, MonoMethodSignature *csig, MonoMethod *res);
	void (*emit_native_icall_wrapper) (MonoMethodBuilder *mb, MonoMethod *method, MonoMethodSignature *csig, gboolean check_exceptions, gboolean aot, MonoMethodPInvoke *pinfo);
	void (*emit_icall_wrapper) (MonoMethodBuilder *mb, MonoJitICallInfo *callinfo, MonoMethodSignature *csig2, gboolean check_exceptions);
	void (*emit_return) (MonoMethodBuilder *mb);
	void (*emit_vtfixup_ftnptr) (MonoMethodBuilder *mb, MonoMethod *method, int param_count, guint16 type);
	void (*mb_skip_visibility) (MonoMethodBuilder *mb);
	void (*mb_set_dynamic) (MonoMethodBuilder *mb);
	void (*mb_emit_exception) (MonoMethodBuilder *mb, const char *exc_nspace, const char *exc_name, const char *msg);
	void (*mb_emit_exception_for_error) (MonoMethodBuilder *mb, const MonoError *emitted_error);
	void (*mb_emit_byte) (MonoMethodBuilder *mb, guint8 op);
} MonoMarshalCallbacks;

/*type of the function pointer of methods returned by mono_marshal_get_runtime_invoke*/
typedef MonoObject *(*RuntimeInvokeFunction) (MonoObject *this_obj, void **params, MonoObject **exc, void* compiled_method);

typedef void (*RuntimeInvokeDynamicFunction) (void *args, MonoObject **exc, void* compiled_method);

void
mono_install_marshal_callbacks (MonoMarshalCallbacks *cb);

/* marshaling helper functions */

void
mono_marshal_init (void);

void
mono_marshal_init_tls (void);

void
mono_marshal_cleanup (void);

gint32
mono_class_native_size (MonoClass *klass, guint32 *align);

MonoMarshalType *
mono_marshal_load_type_info (MonoClass* klass);

gint32
mono_marshal_type_size (MonoType *type, MonoMarshalSpec *mspec, guint32 *align,
			gboolean as_field, gboolean unicode);

int            
mono_type_native_stack_size (MonoType *type, guint32 *alignment);

mono_bstr
mono_ptr_to_bstr (const gunichar2* ptr, int slen);

void mono_delegate_free_ftnptr (MonoDelegate *delegate);

void
mono_marshal_ftnptr_eh_callback (guint32 gchandle);

MONO_PAL_API void
mono_marshal_set_last_error (void);

ICALL_EXTERN_C
void
mono_marshal_clear_last_error (void);

guint
mono_type_to_ldind (MonoType *type);

guint
mono_type_to_stind (MonoType *type);

/* functions to create various architecture independent helper functions */

MonoMethod *
mono_marshal_method_from_wrapper (MonoMethod *wrapper);

WrapperInfo*
mono_wrapper_info_create (MonoMethodBuilder *mb, WrapperSubtype subtype);

void
mono_marshal_set_wrapper_info (MonoMethod *method, WrapperInfo *info);

MONO_LLVM_INTERNAL WrapperInfo*
mono_marshal_get_wrapper_info (MonoMethod *wrapper);

MonoMethod *
mono_marshal_get_delegate_begin_invoke (MonoMethod *method);

MonoMethod *
mono_marshal_get_delegate_end_invoke (MonoMethod *method);

MonoMethod *
mono_marshal_get_delegate_invoke (MonoMethod *method, MonoDelegate *del);

MonoMethod *
mono_marshal_get_delegate_invoke_internal (MonoMethod *method, gboolean callvirt, gboolean static_method_with_first_arg_bound, MonoMethod *target_method);

MonoMethod *
mono_marshal_get_runtime_invoke_full (MonoMethod *method, gboolean virtual_, gboolean need_direct_wrapper);

MonoMethod *
mono_marshal_get_runtime_invoke (MonoMethod *method, gboolean is_virtual);

MonoMethod*
mono_marshal_get_runtime_invoke_dynamic (void);

MonoMethod *
mono_marshal_get_runtime_invoke_for_sig (MonoMethodSignature *sig);

MonoMethodSignature*
mono_marshal_get_string_ctor_signature (MonoMethod *method);

MonoMethod *
mono_marshal_get_managed_wrapper (MonoMethod *method, MonoClass *delegate_klass, uint32_t this_loc, MonoError *exernal_error);

gpointer
mono_marshal_get_vtfixup_ftnptr (MonoImage *image, guint32 token, guint16 type);

MonoMethod *
mono_marshal_get_icall_wrapper (MonoJitICallInfo *callinfo, gboolean check_exceptions);

MONO_LLVM_INTERNAL MonoMethod *
mono_marshal_get_aot_init_wrapper (MonoAotInitSubtype subtype);

MONO_LLVM_INTERNAL const char *
mono_marshal_get_aot_init_wrapper_name (MonoAotInitSubtype subtype);

MONO_LLVM_INTERNAL MonoMethod *
mono_marshal_get_llvm_func_wrapper (MonoLLVMFuncWrapperSubtype subtype);

MonoMethod *
mono_marshal_get_native_wrapper (MonoMethod *method, gboolean check_exceptions, gboolean aot);

MonoMethod *
mono_marshal_get_native_func_wrapper (MonoImage *image, MonoMethodSignature *sig, MonoMethodPInvoke *piinfo, MonoMarshalSpec **mspecs, gpointer func);

MonoMethod*
mono_marshal_get_native_func_wrapper_aot (MonoClass *klass);

MonoMethod *
mono_marshal_get_struct_to_ptr (MonoClass *klass);

MonoMethod *
mono_marshal_get_ptr_to_struct (MonoClass *klass);

MonoMethod *
mono_marshal_get_synchronized_wrapper (MonoMethod *method);

MonoMethod *
mono_marshal_get_synchronized_inner_wrapper (MonoMethod *method);

MonoMethod *
mono_marshal_get_unbox_wrapper (MonoMethod *method);

MonoMethod *
mono_marshal_get_castclass_with_cache (void);

MonoMethod *
mono_marshal_get_isinst_with_cache (void);

MonoMethod *
mono_marshal_get_stelemref (void);

MonoMethod*
mono_marshal_get_virtual_stelemref (MonoClass *array_class);

MonoMethod**
mono_marshal_get_virtual_stelemref_wrappers (int *nwrappers);

MonoMethod*
mono_marshal_get_array_address (int rank, int elem_size);

MonoMethod *
mono_marshal_get_array_accessor_wrapper (MonoMethod *method);

MonoMethod *
mono_marshal_get_generic_array_helper (MonoClass *klass, const gchar *name, MonoMethod *method);

MonoMethod *
mono_marshal_get_thunk_invoke_wrapper (MonoMethod *method);

MonoMethod*
mono_marshal_get_gsharedvt_in_wrapper (void);

MonoMethod*
mono_marshal_get_gsharedvt_out_wrapper (void);

void
mono_marshal_free_dynamic_wrappers (MonoMethod *method);

void
mono_marshal_lock_internal (void);

void
mono_marshal_unlock_internal (void);

/* marshaling internal calls */

void * 
mono_marshal_alloc (gsize size, MonoError *error);

ICALL_EXTERN_C
void 
mono_marshal_free (gpointer ptr);

ICALL_EXTERN_C
void
mono_marshal_free_array (gpointer *ptr, int size);

gboolean 
mono_marshal_free_ccw (MonoObject* obj);

void
mono_cominterop_release_all_rcws (void); 

MONO_API void *
mono_marshal_string_to_utf16 (MonoString *s);

ICALL_EXTERN_C
void
mono_marshal_set_last_error_windows (int error);

ICALL_EXTERN_C
void 
mono_struct_delete_old (MonoClass *klass, char *ptr);

int
mono_emit_marshal (EmitMarshalContext *m, int argnum, MonoType *t, 
	      MonoMarshalSpec *spec, int conv_arg, 
	      MonoType **conv_arg_type, MarshalAction action);

ICALL_EXTERN_C
MonoObject *
mono_marshal_isinst_with_cache (MonoObject *obj, MonoClass *klass, uintptr_t *cache);

ICALL_EXTERN_C
MonoAsyncResult *
mono_delegate_begin_invoke (MonoDelegate *delegate, gpointer *params);

ICALL_EXTERN_C
MonoObject *
mono_delegate_end_invoke (MonoDelegate *delegate, gpointer *params);

MonoMarshalNative
mono_marshal_get_string_encoding (MonoMethodPInvoke *piinfo, MonoMarshalSpec *spec);

MonoMarshalConv
mono_marshal_get_string_to_ptr_conv (MonoMethodPInvoke *piinfo, MonoMarshalSpec *spec);

MonoMarshalConv
mono_marshal_get_stringbuilder_to_ptr_conv (MonoMethodPInvoke *piinfo, MonoMarshalSpec *spec);

MonoMarshalConv
mono_marshal_get_ptr_to_stringbuilder_conv (MonoMethodPInvoke *piinfo, MonoMarshalSpec *spec, gboolean *need_free);

MonoMarshalConv
mono_marshal_get_ptr_to_string_conv (MonoMethodPInvoke *piinfo, MonoMarshalSpec *spec, gboolean *need_free);

MonoType*
mono_marshal_boolean_conv_in_get_local_type (MonoMarshalSpec *spec, guint8 *ldc_op /*out*/);

MonoClass*
mono_marshal_boolean_managed_conv_in_get_conv_arg_class (MonoMarshalSpec *spec, guint8 *ldop/*out*/);

gboolean
mono_pinvoke_is_unicode (MonoMethodPInvoke *piinfo);

gboolean
mono_marshal_need_free (MonoType *t, MonoMethodPInvoke *piinfo, MonoMarshalSpec *spec);

ICALL_EXTERN_C
MonoObject* mono_marshal_get_type_object (MonoClass *klass);

ICALL_EXPORT
guint32 
ves_icall_System_Runtime_InteropServices_Marshal_GetLastWin32Error (void);

ICALL_EXPORT
void
ves_icall_System_Runtime_InteropServices_Marshal_SetLastWin32Error (guint32 err);

ICALL_EXPORT
mono_bstr
ves_icall_System_Runtime_InteropServices_Marshal_BufferToBSTR (const gunichar2 *ptr, int len);

ICALL_EXPORT
void
ves_icall_System_Runtime_InteropServices_Marshal_FreeCoTaskMem (void *ptr);

ICALL_EXPORT
void
ves_icall_System_Runtime_InteropServices_Marshal_FreeHGlobal (void *ptr);

ICALL_EXPORT
void
ves_icall_System_Runtime_InteropServices_Marshal_FreeBSTR (mono_bstr_const ptr);

ICALL_EXPORT
int
ves_icall_System_Runtime_InteropServices_Marshal_AddRefInternal (MonoIUnknown *pUnk);

ICALL_EXPORT
int
ves_icall_System_Runtime_InteropServices_Marshal_QueryInterfaceInternal (MonoIUnknown *pUnk, gconstpointer riid, gpointer* ppv);

ICALL_EXPORT
int
ves_icall_System_Runtime_InteropServices_Marshal_ReleaseInternal (MonoIUnknown *pUnk);

MONO_API void
mono_win32_compat_CopyMemory (gpointer dest, gconstpointer source, gsize length);

MONO_API void
mono_win32_compat_FillMemory (gpointer dest, gsize length, guchar fill);

MONO_API void
mono_win32_compat_MoveMemory (gpointer dest, gconstpointer source, gsize length);

MONO_API void
mono_win32_compat_ZeroMemory (gpointer dest, gsize length);

MONO_LLVM_INTERNAL void
mono_marshal_find_nonzero_bit_offset (guint8 *buf, int len, int *byte_offset, guint8 *bitmask);

MonoMethodSignature*
mono_signature_no_pinvoke (MonoMethod *method);

/* Called from cominterop.c/remoting.c */

void
mono_marshal_emit_native_wrapper (MonoImage *image, MonoMethodBuilder *mb, MonoMethodSignature *sig, MonoMethodPInvoke *piinfo, MonoMarshalSpec **mspecs, gpointer func, gboolean aot, gboolean check_exceptions, gboolean func_param, gboolean skip_gc_trans);

void
mono_marshal_emit_managed_wrapper (MonoMethodBuilder *mb, MonoMethodSignature *invoke_sig, MonoMarshalSpec **mspecs, EmitMarshalContext* m, MonoMethod *method, uint32_t target_handle);

GHashTable*
mono_marshal_get_cache (GHashTable **var, GHashFunc hash_func, GCompareFunc equal_func);

MonoMethod*
mono_marshal_find_in_cache (GHashTable *cache, gpointer key);

MonoMethod*
mono_mb_create_and_cache (GHashTable *cache, gpointer key,
						  MonoMethodBuilder *mb, MonoMethodSignature *sig,
						  int max_stack);
void
mono_marshal_emit_thread_interrupt_checkpoint (MonoMethodBuilder *mb);

void
mono_marshal_emit_thread_force_interrupt_checkpoint (MonoMethodBuilder *mb);

void
mono_marshal_use_aot_wrappers (gboolean use);

int
mono_mb_emit_save_args (MonoMethodBuilder *mb, MonoMethodSignature *sig, gboolean save_this);

void
mono_mb_emit_restore_result (MonoMethodBuilder *mb, MonoType *return_type);

MonoMethod*
mono_mb_create (MonoMethodBuilder *mb, MonoMethodSignature *sig,
				int max_stack, WrapperInfo *info);

MonoMethod*
mono_mb_create_and_cache_full (GHashTable *cache, gpointer key,
							   MonoMethodBuilder *mb, MonoMethodSignature *sig,
							   int max_stack, WrapperInfo *info, gboolean *out_found);

#endif /* __MONO_MARSHAL_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mempool-internals.h`:

```h
/**
 * \file
 */

#ifndef _MONO_MEMPOOL_INTERNALS_H_
#define _MONO_MEMPOOL_INTERNALS_H_

#include <glib.h>

#include "mono/utils/mono-compiler.h"
#include "mono/metadata/mempool.h"

static inline GList*
g_list_prepend_mempool (MonoMemPool *mp, GList *list, gpointer data)
{
	GList *new_list;
	
	new_list = (GList *) mono_mempool_alloc (mp, sizeof (GList));
	new_list->data = data;
	new_list->prev = list ? list->prev : NULL;
    new_list->next = list;

    if (new_list->prev)
            new_list->prev->next = new_list;
    if (list)
            list->prev = new_list;

	return new_list;
}

static inline GSList*
g_slist_prepend_mempool (MonoMemPool *mp, GSList *list, gpointer  data)
{
	GSList *new_list;
	
	new_list = (GSList *) mono_mempool_alloc (mp, sizeof (GSList));
	new_list->data = data;
	new_list->next = list;

	return new_list;
}

static inline GSList*
g_slist_append_mempool (MonoMemPool *mp, GSList *list, gpointer data)
{
	GSList *new_list;
	GSList *last;

	new_list = (GSList *) mono_mempool_alloc (mp, sizeof (GSList));
	new_list->data = data;
	new_list->next = NULL;

	if (list) {
		last = list;
		while (last->next)
			last = last->next;
		last->next = new_list;

		return list;
	} else
		return new_list;
}

static inline GList*
g_list_append_mempool (MonoMemPool *mp, GList *list, gpointer data)
{
	GList *new_list;

	new_list = (GList *) mono_mempool_alloc0 (mp, sizeof (GList));
	new_list->data = data;
	new_list->prev = g_list_last (list);
	if (new_list->prev)
		new_list->prev->next = new_list;

	return list ? list : new_list;
}

char*
mono_mempool_strdup_vprintf (MonoMemPool *pool, const char *format, va_list args);

char*
mono_mempool_strdup_printf (MonoMemPool *pool, const char *format, ...) MONO_ATTR_FORMAT_PRINTF(2,3);

long
mono_mempool_get_bytes_allocated (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/mempool.h`:

```h
/**
 * \file
 */

#ifndef _MONO_MEMPOOL_H_
#define _MONO_MEMPOOL_H_

#include <mono/utils/mono-publib.h>

typedef struct _MonoMemPool MonoMemPool;

MONO_API MonoMemPool *
mono_mempool_new           (void);

MONO_API MonoMemPool *
mono_mempool_new_size      (int initial_size);

MONO_API void
mono_mempool_destroy       (MonoMemPool *pool);

MONO_API void
mono_mempool_invalidate    (MonoMemPool *pool);

MONO_API void
mono_mempool_stats         (MonoMemPool *pool);

MONO_API void*
mono_mempool_alloc         (MonoMemPool *pool, unsigned int size);

#define mono_mempool_alloc(pool, size) (g_cast (mono_mempool_alloc ((pool), (size))))

MONO_API void*
mono_mempool_alloc0        (MonoMemPool *pool, unsigned int size);

#define mono_mempool_alloc0(pool, size) (g_cast (mono_mempool_alloc0 ((pool), (size))))

MONO_API mono_bool
mono_mempool_contains_addr (MonoMemPool *pool, void* addr);

MONO_API char*
mono_mempool_strdup        (MonoMemPool *pool, const char *s);

MONO_API uint32_t
mono_mempool_get_allocated (MonoMemPool *pool);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/metadata-internals.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_INTERNALS_H__
#define __MONO_METADATA_INTERNALS_H__

#include "mono/utils/mono-forward-internal.h"
#include "mono/metadata/image.h"
#include "mono/metadata/blob.h"
#include "mono/metadata/cil-coff.h"
#include "mono/metadata/mempool.h"
#include "mono/metadata/domain-internals.h"
#include "mono/metadata/mono-hash.h"
#include "mono/utils/mono-compiler.h"
#include "mono/utils/mono-dl.h"
#include "mono/utils/monobitset.h"
#include "mono/utils/mono-property-hash.h"
#include "mono/utils/mono-value-hash.h"
#include <mono/utils/mono-error.h>
#include "mono/utils/mono-conc-hashtable.h"
#include "mono/utils/refcount.h"

struct _MonoType {
	union {
		MonoClass *klass; /* for VALUETYPE and CLASS */
		MonoType *type;   /* for PTR */
		MonoArrayType *array; /* for ARRAY */
		MonoMethodSignature *method;
		MonoGenericParam *generic_param; /* for VAR and MVAR */
		MonoGenericClass *generic_class; /* for GENERICINST */
	} data;
	unsigned int attrs    : 16; /* param attributes or field flags */
	MonoTypeEnum type     : 8;
	unsigned int has_cmods : 1;  
	unsigned int byref    : 1;
	unsigned int pinned   : 1;  /* valid when included in a local var signature */
};

typedef struct {
	unsigned int required : 1;
	MonoType *type;
} MonoSingleCustomMod;

/* Aggregate custom modifiers can happen if a generic VAR or MVAR is inflated,
 * and both the VAR and the type that will be used to inflated it have custom
 * modifiers, but they come from different images.  (e.g. inflating 'class G<T>
 * {void Test (T modopt(IsConst) t);}' with 'int32 modopt(IsLong)' where G is
 * in image1 and the int32 is in image2.)
 *
 * Moreover, we can't just store an image and a type token per modifier, because
 * Roslyn and C++/CLI sometimes create modifiers that mention generic parameters that must be inflated, like:
 *     void .CL1`1.Test(!0 modopt(System.Nullable`1<!0>))
 * So we have to store a resolved MonoType*.
 *
 * Because the types come from different images, we allocate the aggregate
 * custom modifiers container object in the mempool of a MonoImageSet to ensure
 * that it doesn't have dangling image pointers.
 */
typedef struct {
	uint8_t count;
	MonoSingleCustomMod modifiers[1]; /* Actual length is count */
} MonoAggregateModContainer;

/* ECMA says upto 64 custom modifiers.  It's possible we could see more at
 * runtime due to modifiers being appended together when we inflate type.  In
 * that case we should revisit the places where this define is used to make
 * sure that we don't blow up the stack (or switch to heap allocation for
 * temporaries).
 */
#define MONO_MAX_EXPECTED_CMODS 64

typedef struct {
	MonoType unmodified;
	gboolean is_aggregate;
	union {
		MonoCustomModContainer cmods;
		/* the actual aggregate modifiers are in a MonoImageSet mempool
		 * that includes all the images of all the modifier types and
		 * also the type that this aggregate container is a part of.*/
		MonoAggregateModContainer *amods;
	} mods;
} MonoTypeWithModifiers;

gboolean
mono_type_is_aggregate_mods (const MonoType *t);

static inline void
mono_type_with_mods_init (MonoType *dest, uint8_t num_mods, gboolean is_aggregate)
{
	if (num_mods == 0) {
		dest->has_cmods = 0;
		return;
	}
	dest->has_cmods = 1;
	MonoTypeWithModifiers *dest_full = (MonoTypeWithModifiers *)dest;
	dest_full->is_aggregate = !!is_aggregate;
	if (is_aggregate)
		dest_full->mods.amods = NULL;
	else
		dest_full->mods.cmods.count = num_mods;
}

MonoCustomModContainer *
mono_type_get_cmods (const MonoType *t);

MonoAggregateModContainer *
mono_type_get_amods (const MonoType *t);

void
mono_type_set_amods (MonoType *t, MonoAggregateModContainer *amods);

static inline uint8_t
mono_type_custom_modifier_count (const MonoType *t)
{
	if (!t->has_cmods)
		return 0;
	MonoTypeWithModifiers *full = (MonoTypeWithModifiers *)t;
	if (full->is_aggregate)
		return full->mods.amods->count;
	else
		return full->mods.cmods.count;
}

MonoType *
mono_type_get_custom_modifier (const MonoType *ty, uint8_t idx, gboolean *required, MonoError *error);

// Note: sizeof (MonoType) is dangerous. It can copy the num_mods
// field without copying the variably sized array. This leads to
// memory unsafety on the stack and/or heap, when we try to traverse
// this array.
//
// Use mono_sizeof_monotype 
// to get the size of the memory to copy.
#define MONO_SIZEOF_TYPE sizeof (MonoType)

size_t 
mono_sizeof_type_with_mods (uint8_t num_mods, gboolean aggregate);

size_t 
mono_sizeof_type (const MonoType *ty);

size_t
mono_sizeof_aggregate_modifiers (uint8_t num_mods);

MonoAggregateModContainer *
mono_metadata_get_canonical_aggregate_modifiers (MonoAggregateModContainer *candidate);

#define MONO_SECMAN_FLAG_INIT(x)		(x & 0x2)
#define MONO_SECMAN_FLAG_GET_VALUE(x)		(x & 0x1)
#define MONO_SECMAN_FLAG_SET_VALUE(x,y)		do { x = ((y) ? 0x3 : 0x2); } while (0)

#define MONO_PUBLIC_KEY_TOKEN_LENGTH	17

#define MONO_PROCESSOR_ARCHITECTURE_NONE 0
#define MONO_PROCESSOR_ARCHITECTURE_MSIL 1
#define MONO_PROCESSOR_ARCHITECTURE_X86 2
#define MONO_PROCESSOR_ARCHITECTURE_IA64 3
#define MONO_PROCESSOR_ARCHITECTURE_AMD64 4
#define MONO_PROCESSOR_ARCHITECTURE_ARM 5

struct _MonoAssemblyName {
	const char *name;
	const char *culture;
	const char *hash_value;
	const mono_byte* public_key;
	// string of 16 hex chars + 1 NULL
	mono_byte public_key_token [MONO_PUBLIC_KEY_TOKEN_LENGTH];
	uint32_t hash_alg;
	uint32_t hash_len;
	uint32_t flags;
#ifdef ENABLE_NETCORE
	int major, minor, build, revision, arch;
#else
	uint16_t major, minor, build, revision, arch;
#endif
};

struct MonoTypeNameParse {
	char *name_space;
	char *name;
	MonoAssemblyName assembly;
	GList *modifiers; /* 0 -> byref, -1 -> pointer, > 0 -> array rank */
	GPtrArray *type_arguments;
	GList *nested;
};


typedef enum MonoAssemblyContextKind {
	/* Default assembly context: Load(String) and assembly references */
	MONO_ASMCTX_DEFAULT = 0,
	/* Reflection-only only context: ReflectionOnlyLoad and ReeflectionOnlyLoadFrom */
	MONO_ASMCTX_REFONLY = 1,
	/* LoadFrom context: LoadFrom() and references */
	MONO_ASMCTX_LOADFROM = 2,
	/* Individual assembly context (.NET Framework docs call this "not in
	 * any context"): LoadFile(String) and Load(byte[]) are here.
	 */
	MONO_ASMCTX_INDIVIDUAL = 3,

	MONO_ASMCTX_LAST = 3
} MonoAssemblyContextKind;

typedef struct _MonoAssemblyContext {
	MonoAssemblyContextKind kind;
} MonoAssemblyContext;

struct _MonoAssembly {
	/* 
	 * The number of appdomains which have this assembly loaded plus the number of 
	 * assemblies referencing this assembly through an entry in their image->references
	 * arrays. The latter is needed because entries in the image->references array
	 * might point to assemblies which are only loaded in some appdomains, and without
	 * the additional reference, they can be freed at any time.
	 * The ref_count is initially 0.
	 */
	int ref_count; /* use atomic operations only */
	char *basedir;
	MonoAssemblyName aname;
	MonoImage *image;
	GSList *friend_assembly_names; /* Computed by mono_assembly_load_friends () */
	guint8 friend_assembly_names_inited;
	guint8 in_gac;
	guint8 dynamic;
	guint8 corlib_internal;
	MonoAssemblyContext context;
	guint8 wrap_non_exception_throws;
	guint8 wrap_non_exception_throws_inited;
	guint8 jit_optimizer_disabled;
	guint8 jit_optimizer_disabled_inited;
	/* security manager flags (one bit is for lazy initialization) */
	guint32 ecma:2;		/* Has the ECMA key */
	guint32 aptc:2;		/* Has the [AllowPartiallyTrustedCallers] attributes */
	guint32 fulltrust:2;	/* Has FullTrust permission */
	guint32 unmanaged:2;	/* Has SecurityPermissionFlag.UnmanagedCode permission */
	guint32 skipverification:2;	/* Has SecurityPermissionFlag.SkipVerification permission */
};

typedef struct {
	/*
	 * indexed by MonoMethodSignature 
	 * Protected by the marshal lock
	 */
	GHashTable *delegate_invoke_cache;
	GHashTable *delegate_begin_invoke_cache;
	GHashTable *delegate_end_invoke_cache;
	GHashTable *runtime_invoke_signature_cache;
	GHashTable *runtime_invoke_sig_cache;

	/*
	 * indexed by SignaturePointerPair
	 */
	GHashTable *delegate_abstract_invoke_cache;

	/*
	 * indexed by MonoMethod pointers
	 * Protected by the marshal lock
	 */
	GHashTable *runtime_invoke_method_cache;
	GHashTable *managed_wrapper_cache;

	GHashTable *native_wrapper_cache;
	GHashTable *native_wrapper_aot_cache;
	GHashTable *native_wrapper_check_cache;
	GHashTable *native_wrapper_aot_check_cache;

	GHashTable *native_func_wrapper_aot_cache;
	GHashTable *remoting_invoke_cache;
	GHashTable *synchronized_cache;
	GHashTable *unbox_wrapper_cache;
	GHashTable *cominterop_invoke_cache;
	GHashTable *cominterop_wrapper_cache; /* LOCKING: marshal lock */
	GHashTable *thunk_invoke_cache;
} MonoWrapperCaches;

typedef struct {
	const char* data;
	guint32  size;
} MonoStreamHeader;

struct _MonoTableInfo {
	const char *base;
	guint       rows     : 24;
	guint       row_size : 8;

	/*
	 * Tables contain up to 9 columns and the possible sizes of the
	 * fields in the documentation are 1, 2 and 4 bytes.  So we
	 * can encode in 2 bits the size.
	 *
	 * A 32 bit value can encode the resulting size
	 *
	 * The top eight bits encode the number of columns in the table.
	 * we only need 4, but 8 is aligned no shift required. 
	 */
	guint32   size_bitfield;
};

#define REFERENCE_MISSING ((gpointer) -1)

typedef struct {
	gboolean (*match) (MonoImage*);
	gboolean (*load_pe_data) (MonoImage*);
	gboolean (*load_cli_data) (MonoImage*);
	gboolean (*load_tables) (MonoImage*);
} MonoImageLoader;

/* Represents the physical bytes for an image (usually in the file system, but
 * could be in memory).
 *
 * The MonoImageStorage owns the raw data for an image and is responsible for
 * cleanup.
 *
 * May be shared by multiple MonoImage objects if they opened the same
 * underlying file or byte blob in memory.
 *
 * There is an abstract string key (usually a file path, but could be formed in
 * other ways) that is used to share MonoImageStorage objects among images.
 *
 */
typedef struct {
	MonoRefCount ref;

	/* key used for lookups.  owned by this image storage. */
	char *key;

	/* If the raw data was allocated from a source such as mmap, the allocator may store resource tracking information here. */
	void *raw_data_handle;
	char *raw_data;
	guint32 raw_data_len;
	/* data was allocated with mono_file_map and must be unmapped */
	guint8 raw_buffer_used    : 1;
	/* data was allocated with malloc and must be freed */
	guint8 raw_data_allocated : 1;
	/* data was allocated with mono_file_map_fileio */
	guint8 fileio_used : 1;

#ifdef HOST_WIN32
	/* Module was loaded using LoadLibrary. */
	guint8 is_module_handle : 1;

	/* Module entry point is _CorDllMain. */
	guint8 has_entry_point : 1;
#endif
} MonoImageStorage;

struct _MonoImage {
	/*
	 * This count is incremented during these situations:
	 *   - An assembly references this MonoImage through its 'image' field
	 *   - This MonoImage is present in the 'files' field of an image
	 *   - This MonoImage is present in the 'modules' field of an image
	 *   - A thread is holding a temporary reference to this MonoImage between
	 *     calls to mono_image_open and mono_image_close ()
	 */
	int   ref_count;

	MonoImageStorage *storage;

	/* Aliases storage->raw_data when storage is non-NULL. Otherwise NULL. */
	char *raw_data;
	guint32 raw_data_len;

	/* Whenever this is a dynamically emitted module */
	guint8 dynamic : 1;

	/* Whenever this is a reflection only image */
	guint8 ref_only : 1;

	/* Whenever this image contains uncompressed metadata */
	guint8 uncompressed_metadata : 1;

	/* Whenever this image contains metadata only without PE data */
	guint8 metadata_only : 1;

	/*  Whether this image belongs to load-from context */
	guint8 load_from_context: 1;

	guint8 checked_module_cctor : 1;
	guint8 has_module_cctor : 1;

	guint8 idx_string_wide : 1;
	guint8 idx_guid_wide : 1;
	guint8 idx_blob_wide : 1;

	/* Whenever this image is considered as platform code for the CoreCLR security model */
	guint8 core_clr_platform_code : 1;

	/* The path to the file for this image or an arbitrary name for images loaded from data. */
	char *name;

	/* The path to the file for this image or NULL */
	char *filename;

	/* The assembly name reported in the file for this image (expected to be NULL for a netmodule) */
	const char *assembly_name;

	/* The module name reported in the file for this image (could be NULL for a malformed file) */
	const char *module_name;
	guint32 time_date_stamp;

	char *version;
	gint16 md_version_major, md_version_minor;
	char *guid;
	MonoCLIImageInfo    *image_info;
	MonoMemPool         *mempool; /*protected by the image lock*/

	char                *raw_metadata;
			    
	MonoStreamHeader     heap_strings;
	MonoStreamHeader     heap_us;
	MonoStreamHeader     heap_blob;
	MonoStreamHeader     heap_guid;
	MonoStreamHeader     heap_tables;
	MonoStreamHeader     heap_pdb;
			    
	const char          *tables_base;

	/* For PPDB files */
	guint64 referenced_tables;
	int *referenced_table_rows;

	/**/
	MonoTableInfo        tables [MONO_TABLE_NUM];

	/*
	 * references is initialized only by using the mono_assembly_open
	 * function, and not by using the lowlevel mono_image_open.
	 *
	 * It is NULL terminated.
	 */
	MonoAssembly **references;
	int nreferences;

	/* Code files in the assembly. The main assembly has a "file" table and also a "module"
	 * table, where the module table is a subset of the file table. We track both lists,
	 * and because we can lazy-load them at different times we reference-increment both.
	 */
	/* No netmodules in netcore, but for System.Reflection.Emit support we still use modules */
	MonoImage **modules;
	guint32 module_count;
	gboolean *modules_loaded;

	MonoImage **files;
	guint32 file_count;

	MonoAotModule *aot_module;

	guint8 aotid[16];

	/*
	 * The Assembly this image was loaded from.
	 */
	MonoAssembly *assembly;

#ifdef ENABLE_NETCORE
	/*
	 * The AssemblyLoadContext that this image was loaded into.
	 */
	MonoAssemblyLoadContext *alc;
#endif

	/*
	 * Indexed by method tokens and typedef tokens.
	 */
	GHashTable *method_cache; /*protected by the image lock*/
	MonoInternalHashTable class_cache;

	/* Indexed by memberref + methodspec tokens */
	GHashTable *methodref_cache; /*protected by the image lock*/

	/*
	 * Indexed by fielddef and memberref tokens
	 */
	MonoConcurrentHashTable *field_cache; /*protected by the image lock*/

	/* indexed by typespec tokens. */
	MonoConcurrentHashTable *typespec_cache; /* protected by the image lock */
	/* indexed by token */
	GHashTable *memberref_signatures;

	/* Indexed by blob heap indexes */
	GHashTable *method_signatures;

	/*
	 * Indexes namespaces to hash tables that map class name to typedef token.
	 */
	GHashTable *name_cache;  /*protected by the image lock*/

	/*
	 * Indexed by MonoClass
	 */
	GHashTable *array_cache;
	GHashTable *ptr_cache;

	GHashTable *szarray_cache;
	/* This has a separate lock to improve scalability */
	mono_mutex_t szarray_cache_lock;

	/*
	 * indexed by SignaturePointerPair
	 */
	GHashTable *delegate_bound_static_invoke_cache;
	GHashTable *native_func_wrapper_cache;

	/*
	 * indexed by MonoMethod pointers 
	 */
	GHashTable *wrapper_param_names;
	GHashTable *array_accessor_cache;

	/*
	 * indexed by MonoClass pointers
	 */
	GHashTable *ldfld_wrapper_cache;
	GHashTable *ldflda_wrapper_cache;
	GHashTable *stfld_wrapper_cache;
	GHashTable *isinst_cache;

	GHashTable *icall_wrapper_cache;
	GHashTable *castclass_cache;
	GHashTable *proxy_isinst_cache;
	GHashTable *rgctx_template_hash; /* LOCKING: templates lock */

	/* Contains rarely used fields of runtime structures belonging to this image */
	MonoPropertyHash *property_hash;

	void *reflection_info;

	/*
	 * user_info is a public field and is not touched by the
	 * metadata engine
	 */
	void *user_info;

#ifndef DISABLE_DLLMAP
	/* dll map entries */
	MonoDllMap *dll_map;
#endif

	/* interfaces IDs from this image */
	/* protected by the classes lock */
	MonoBitSet *interface_bitset;

	/* when the image is being closed, this is abused as a list of
	   malloc'ed regions to be freed. */
	GSList *reflection_info_unregister_classes;

	/* List of dependent image sets containing this image */
	/* Protected by image_sets_lock */
	GSList *image_sets;

	/* Caches for wrappers that DO NOT reference generic */
	/* arguments */
	MonoWrapperCaches wrapper_caches;

	/* Pre-allocated anon generic params for the first N generic
	 * parameters, for a small N */
	MonoGenericParam *var_gparam_cache_fast;
	MonoGenericParam *mvar_gparam_cache_fast;
	/* Anon generic parameters past N, if needed */
	MonoConcurrentHashTable *var_gparam_cache;
	MonoConcurrentHashTable *mvar_gparam_cache;

#ifndef ENABLE_NETCORE
	/* Maps malloc-ed char* pinvoke scope -> MonoDl* */
	GHashTable *pinvoke_scopes;
#endif

	/* The loader used to load this image */
	MonoImageLoader *loader;

	// Containers for MonoGenericParams associated with this image but not with any specific class or method. Created on demand.
	// This could happen, for example, for MonoTypes associated with TypeSpec table entries.
	MonoGenericContainer *anonymous_generic_class_container;
	MonoGenericContainer *anonymous_generic_method_container;

	gboolean weak_fields_inited;
	/* Contains 1 based indexes */
	GHashTable *weak_field_indexes;

	/*
	 * No other runtime locks must be taken while holding this lock.
	 * It's meant to be used only to mutate and query structures part of this image.
	 */
	mono_mutex_t    lock;
};

/*
 * Generic instances and aggregated custom modifiers depend on many images, and they need to be deleted if one
 * of the images they depend on is unloaded. For example,
 * List<Foo> depends on both List's image and Foo's image.
 * A MonoImageSet is the owner of all generic instances depending on the same set of
 * images.
 */
typedef struct {
	int nimages;
	MonoImage **images;

	// Generic-specific caches
	GHashTable *ginst_cache, *gmethod_cache, *gsignature_cache;
	MonoConcurrentHashTable *gclass_cache;

	/* mirror caches of ones already on MonoImage. These ones contain generics */
	GHashTable *szarray_cache, *array_cache, *ptr_cache;

	MonoWrapperCaches wrapper_caches;

	GHashTable *aggregate_modifiers_cache;

	/* Indexed by MonoGenericParam pointers */
	GHashTable **gshared_types;
	/* The length of the above array */
	int gshared_types_len;

	mono_mutex_t    lock;

	/*
	 * Memory for generic instances owned by this image set should be allocated from
	 * this mempool, using the mono_image_set_alloc family of functions.
	 */
	MonoMemPool         *mempool;
} MonoImageSet;

enum {
	MONO_SECTION_TEXT,
	MONO_SECTION_RSRC,
	MONO_SECTION_RELOC,
	MONO_SECTION_MAX
};

typedef struct {
	GHashTable *hash;
	char *data;
	guint32 alloc_size; /* malloced bytes */
	guint32 index;
	guint32 offset; /* from start of metadata */
} MonoDynamicStream;

typedef struct {
	guint32 alloc_rows;
	guint32 rows;
	guint8  row_size; /*  calculated later with column_sizes */
	guint8  columns;
	guint32 next_idx;
	guint32 *values; /* rows * columns */
} MonoDynamicTable;

/* "Dynamic" assemblies and images arise from System.Reflection.Emit */
struct _MonoDynamicAssembly {
	MonoAssembly assembly;
	char *strong_name;
	guint32 strong_name_size;
	guint8 run;
	guint8 save;
	MonoDomain *domain;
};

struct _MonoDynamicImage {
	MonoImage image;
	guint32 meta_size;
	guint32 text_rva;
	guint32 metadata_rva;
	guint32 image_base;
	guint32 cli_header_offset;
	guint32 iat_offset;
	guint32 idt_offset;
	guint32 ilt_offset;
	guint32 imp_names_offset;
	struct {
		guint32 rva;
		guint32 size;
		guint32 offset;
		guint32 attrs;
	} sections [MONO_SECTION_MAX];
	GHashTable *typespec;
	GHashTable *typeref;
	GHashTable *handleref;
	MonoGHashTable *tokens;
	GHashTable *blob_cache;
	GHashTable *standalonesig_cache;
	GList *array_methods;
	GPtrArray *gen_params;
	MonoGHashTable *token_fixups;
	GHashTable *method_to_table_idx;
	GHashTable *field_to_table_idx;
	GHashTable *method_aux_hash;
	GHashTable *vararg_aux_hash;
	MonoGHashTable *generic_def_objects;
	/*
	 * Maps final token values to the object they describe.
	 */
	MonoGHashTable *remapped_tokens;
	gboolean run;
	gboolean save;
	gboolean initial_image;
	guint32 pe_kind, machine;
	char *strong_name;
	guint32 strong_name_size;
	char *win32_res;
	guint32 win32_res_size;
	guint8 *public_key;
	int public_key_len;
	MonoDynamicStream sheap;
	MonoDynamicStream code; /* used to store method headers and bytecode */
	MonoDynamicStream resources; /* managed embedded resources */
	MonoDynamicStream us;
	MonoDynamicStream blob;
	MonoDynamicStream tstream;
	MonoDynamicStream guid;
	MonoDynamicTable tables [MONO_TABLE_NUM];
	MonoClass *wrappers_type; /*wrappers are bound to this type instead of <Module>*/
};

/* Contains information about assembly binding */
typedef struct _MonoAssemblyBindingInfo {
	char *name;
	char *culture;
	guchar public_key_token [MONO_PUBLIC_KEY_TOKEN_LENGTH];
	int major;
	int minor;
	AssemblyVersionSet old_version_bottom;
	AssemblyVersionSet old_version_top;
	AssemblyVersionSet new_version;
	guint has_old_version_bottom : 1;
	guint has_old_version_top : 1;
	guint has_new_version : 1;
	guint is_valid : 1;
	gint32 domain_id; /*Needed to unload per-domain binding*/
} MonoAssemblyBindingInfo;

struct _MonoMethodHeader {
	const unsigned char  *code;
#ifdef MONO_SMALL_CONFIG
	guint16      code_size;
#else
	guint32      code_size;
#endif
	guint16      max_stack   : 15;
	unsigned int is_transient: 1; /* mono_metadata_free_mh () will actually free this header */
	unsigned int num_clauses : 15;
	/* if num_locals != 0, then the following apply: */
	unsigned int init_locals : 1;
	guint16      num_locals;
	MonoExceptionClause *clauses;
	MonoBitSet  *volatile_args;
	MonoBitSet  *volatile_locals;
	MonoType    *locals [MONO_ZERO_LEN_ARRAY];
};

typedef struct {
	const unsigned char *code;
	guint32      code_size;
	guint16      max_stack;
	gboolean     has_clauses;
	gboolean     has_locals;
} MonoMethodHeaderSummary;

// FIXME? offsetof (MonoMethodHeader, locals)?
#define MONO_SIZEOF_METHOD_HEADER (sizeof (struct _MonoMethodHeader) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)

struct _MonoMethodSignature {
	MonoType     *ret;
#ifdef MONO_SMALL_CONFIG
	guint8        param_count;
	gint8         sentinelpos;
	unsigned int  generic_param_count : 5;
#else
	guint16       param_count;
	gint16        sentinelpos;
	unsigned int  generic_param_count : 16;
#endif
	unsigned int  call_convention     : 6;
	unsigned int  hasthis             : 1;
	unsigned int  explicit_this       : 1;
	unsigned int  pinvoke             : 1;
	unsigned int  is_inflated         : 1;
	unsigned int  has_type_parameters : 1;
	MonoType     *params [MONO_ZERO_LEN_ARRAY];
};

/*
 * AOT cache configuration loaded from config files.
 * Doesn't really belong here.
 */
typedef struct {
	/*
	 * Enable aot caching for applications whose main assemblies are in
	 * this list.
	 */
	GSList *apps;
	GSList *assemblies;
	char *aot_options;
} MonoAotCacheConfig;

#define MONO_SIZEOF_METHOD_SIGNATURE (sizeof (struct _MonoMethodSignature) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)

static inline gboolean
image_is_dynamic (MonoImage *image)
{
#ifdef DISABLE_REFLECTION_EMIT
	return FALSE;
#else
	return image->dynamic;
#endif
}

static inline gboolean
assembly_is_dynamic (MonoAssembly *assembly)
{
#ifdef DISABLE_REFLECTION_EMIT
	return FALSE;
#else
	return assembly->dynamic;
#endif
}

/* for use with allocated memory blocks (assumes alignment is to 8 bytes) */
guint mono_aligned_addr_hash (gconstpointer ptr);

void
mono_image_check_for_module_cctor (MonoImage *image);

gpointer
mono_image_alloc  (MonoImage *image, guint size);

gpointer
mono_image_alloc0 (MonoImage *image, guint size);

#define mono_image_new0(image,type,size) ((type *) mono_image_alloc0 (image, sizeof (type)* (size)))

char*
mono_image_strdup (MonoImage *image, const char *s);

char*
mono_image_strdup_vprintf (MonoImage *image, const char *format, va_list args);

char*
mono_image_strdup_printf (MonoImage *image, const char *format, ...) MONO_ATTR_FORMAT_PRINTF(2,3);

GList*
mono_g_list_prepend_image (MonoImage *image, GList *list, gpointer data);

GSList*
mono_g_slist_append_image (MonoImage *image, GSList *list, gpointer data);

void
mono_image_lock (MonoImage *image);

void
mono_image_unlock (MonoImage *image);

gpointer
mono_image_property_lookup (MonoImage *image, gpointer subject, guint32 property);

void
mono_image_property_insert (MonoImage *image, gpointer subject, guint32 property, gpointer value);

void
mono_image_property_remove (MonoImage *image, gpointer subject);

gboolean
mono_image_close_except_pools (MonoImage *image);

void
mono_image_close_finish (MonoImage *image);

typedef void  (*MonoImageUnloadFunc) (MonoImage *image, gpointer user_data);

void
mono_install_image_unload_hook (MonoImageUnloadFunc func, gpointer user_data);

void
mono_remove_image_unload_hook (MonoImageUnloadFunc func, gpointer user_data);

void
mono_install_image_loader (const MonoImageLoader *loader);

void
mono_image_append_class_to_reflection_info_set (MonoClass *klass);

gpointer
mono_image_set_alloc  (MonoImageSet *set, guint size);

gpointer
mono_image_set_alloc0 (MonoImageSet *set, guint size);

void
mono_image_set_lock (MonoImageSet *set);

void
mono_image_set_unlock (MonoImageSet *set);

char*
mono_image_set_strdup (MonoImageSet *set, const char *s);

MonoImageSet *
mono_metadata_get_image_set_for_aggregate_modifiers (MonoAggregateModContainer *amods);

MonoImageSet *
mono_metadata_get_image_set_for_type (MonoType *type);

MonoImageSet *
mono_metadata_merge_image_sets (MonoImageSet *set1, MonoImageSet *set2);

#define mono_image_set_new0(image,type,size) ((type *) mono_image_set_alloc0 (image, sizeof (type)* (size)))

gboolean
mono_image_load_cli_header (MonoImage *image, MonoCLIImageInfo *iinfo);

gboolean
mono_image_load_metadata (MonoImage *image, MonoCLIImageInfo *iinfo);

const char*
mono_metadata_string_heap_checked (MonoImage *meta, uint32_t table_index, MonoError *error);
const char *
mono_metadata_blob_heap_null_ok (MonoImage *meta, guint32 index);
const char*
mono_metadata_blob_heap_checked (MonoImage *meta, uint32_t table_index, MonoError *error);
gboolean
mono_metadata_decode_row_checked (const MonoImage *image, const MonoTableInfo *t, int idx, uint32_t *res, int res_size, MonoError *error);

MonoType*
mono_metadata_get_shared_type (MonoType *type);

void
mono_metadata_clean_for_image (MonoImage *image);

void
mono_metadata_clean_generic_classes_for_image (MonoImage *image);

MONO_API void
mono_metadata_cleanup (void);

const char *   mono_meta_table_name              (int table);
void           mono_metadata_compute_table_bases (MonoImage *meta);

gboolean
mono_metadata_interfaces_from_typedef_full  (MonoImage             *image,
											 guint32                table_index,
											 MonoClass           ***interfaces,
											 guint                 *count,
											 gboolean               heap_alloc_result,
											 MonoGenericContext    *context,
											 MonoError *error);

MONO_API MonoMethodSignature *
mono_metadata_parse_method_signature_full   (MonoImage             *image,
					     MonoGenericContainer  *generic_container,
					     int                     def,
					     const char             *ptr,
					     const char            **rptr,
					     MonoError *error);

MONO_API MonoMethodHeader *
mono_metadata_parse_mh_full                 (MonoImage             *image,
					     MonoGenericContainer  *container,
					     const char            *ptr,
						 MonoError *error);

MonoMethodSignature  *mono_metadata_parse_signature_checked (MonoImage *image, 
							     uint32_t    token,
							     MonoError *error);

gboolean
mono_method_get_header_summary (MonoMethod *method, MonoMethodHeaderSummary *summary);

int* mono_metadata_get_param_attrs          (MonoImage *m, int def, int param_count);
gboolean mono_metadata_method_has_param_attrs (MonoImage *m, int def);

guint
mono_metadata_generic_context_hash          (const MonoGenericContext *context);

gboolean
mono_metadata_generic_context_equal         (const MonoGenericContext *g1,
					     const MonoGenericContext *g2);

MonoGenericInst *
mono_metadata_parse_generic_inst            (MonoImage             *image,
					     MonoGenericContainer  *container,
					     int                    count,
					     const char            *ptr,
					     const char           **rptr,
						 MonoError *error);

MonoGenericInst *
mono_metadata_get_generic_inst              (int 		    type_argc,
					     MonoType 		  **type_argv);

MonoGenericInst *
mono_metadata_get_canonical_generic_inst    (MonoGenericInst *candidate);

MonoGenericClass *
mono_metadata_lookup_generic_class          (MonoClass		   *gclass,
					     MonoGenericInst	   *inst,
					     gboolean		    is_dynamic);

MonoGenericInst * mono_metadata_inflate_generic_inst  (MonoGenericInst *ginst, MonoGenericContext *context, MonoError *error);

guint
mono_metadata_generic_param_hash (MonoGenericParam *p);

gboolean
mono_metadata_generic_param_equal (MonoGenericParam *p1, MonoGenericParam *p2);

void mono_dynamic_stream_reset  (MonoDynamicStream* stream);
MONO_API void mono_assembly_addref       (MonoAssembly *assembly);
void mono_assembly_load_friends (MonoAssembly* ass);
gboolean mono_assembly_has_skip_verification (MonoAssembly* ass);

void mono_assembly_release_gc_roots (MonoAssembly *assembly);
gboolean mono_assembly_close_except_image_pools (MonoAssembly *assembly);
void mono_assembly_close_finish (MonoAssembly *assembly);


gboolean mono_public_tokens_are_equal (const unsigned char *pubt1, const unsigned char *pubt2);

void mono_config_parse_publisher_policy (const char *filename, MonoAssemblyBindingInfo *binding_info);
void mono_config_parse_assembly_bindings (const char *filename, int major, int minor, void *user_data,
					  void (*infocb)(MonoAssemblyBindingInfo *info, void *user_data));

gboolean
mono_assembly_name_parse_full 		     (const char	   *name,
					      MonoAssemblyName	   *aname,
					      gboolean save_public_key,
					      gboolean *is_version_defined,
						  gboolean *is_token_defined);

gboolean
mono_assembly_fill_assembly_name_full (MonoImage *image, MonoAssemblyName *aname, gboolean copyBlobs);


MONO_API guint32 mono_metadata_get_generic_param_row (MonoImage *image, guint32 token, guint32 *owner);

MonoGenericParam*
mono_metadata_create_anon_gparam (MonoImage *image, gint32 param_num, gboolean is_mvar);

void mono_unload_interface_ids (MonoBitSet *bitset);


MonoType *mono_metadata_type_dup (MonoImage *image, const MonoType *original);
MonoType *mono_metadata_type_dup_with_cmods (MonoImage *image, const MonoType *original, const MonoType *cmods_source);

MonoMethodSignature  *mono_metadata_signature_dup_full (MonoImage *image,MonoMethodSignature *sig);
MonoMethodSignature  *mono_metadata_signature_dup_mempool (MonoMemPool *mp, MonoMethodSignature *sig);
MonoMethodSignature  *mono_metadata_signature_dup_add_this (MonoImage *image, MonoMethodSignature *sig, MonoClass *klass);

MonoGenericInst *
mono_get_shared_generic_inst (MonoGenericContainer *container);

int
mono_type_stack_size_internal (MonoType *t, int *align, gboolean allow_open);

MONO_API void            mono_type_get_desc (GString *res, MonoType *type, mono_bool include_namespace);

gboolean
mono_metadata_type_equal_full (MonoType *t1, MonoType *t2, gboolean signature_only);

MonoMarshalSpec *
mono_metadata_parse_marshal_spec_full (MonoImage *image, MonoImage *parent_image, const char *ptr);

guint	       mono_metadata_generic_inst_hash (gconstpointer data);
gboolean       mono_metadata_generic_inst_equal (gconstpointer ka, gconstpointer kb);

MONO_API void
mono_metadata_field_info_with_mempool (
					  MonoImage *meta, 
				      guint32       table_index,
				      guint32      *offset,
				      guint32      *rva,
				      MonoMarshalSpec **marshal_spec);

MonoClassField*
mono_metadata_get_corresponding_field_from_generic_type_definition (MonoClassField *field);

MonoEvent*
mono_metadata_get_corresponding_event_from_generic_type_definition (MonoEvent *event);

MonoProperty*
mono_metadata_get_corresponding_property_from_generic_type_definition (MonoProperty *property);

guint32
mono_metadata_signature_size (MonoMethodSignature *sig);

guint mono_metadata_str_hash (gconstpointer v1);

gboolean mono_image_load_pe_data (MonoImage *image);

gboolean mono_image_load_cli_data (MonoImage *image);

void mono_image_load_names (MonoImage *image);

MonoImage *mono_image_open_raw (MonoAssemblyLoadContext *alc, const char *fname, MonoImageOpenStatus *status);

MonoImage *mono_image_open_metadata_only (MonoAssemblyLoadContext *alc, const char *fname, MonoImageOpenStatus *status);

MonoImage *mono_image_open_from_data_internal (MonoAssemblyLoadContext *alc, char *data, guint32 data_len, gboolean need_copy, MonoImageOpenStatus *status, gboolean refonly, gboolean metadata_only, const char *name);

MonoException *mono_get_exception_field_access_msg (const char *msg);

MonoException *mono_get_exception_method_access_msg (const char *msg);

MonoMethod* mono_method_from_method_def_or_ref (MonoImage *m, guint32 tok, MonoGenericContext *context, MonoError *error);

MonoMethod *mono_get_method_constrained_with_method (MonoImage *image, MonoMethod *method, MonoClass *constrained_class, MonoGenericContext *context, MonoError *error);
MonoMethod *mono_get_method_constrained_checked (MonoImage *image, guint32 token, MonoClass *constrained_class, MonoGenericContext *context, MonoMethod **cil_method, MonoError *error);

void mono_type_set_alignment (MonoTypeEnum type, int align);

MonoAotCacheConfig *mono_get_aot_cache_config (void);
MonoType *
mono_type_create_from_typespec_checked (MonoImage *image, guint32 type_spec, MonoError *error);

MonoMethodSignature*
mono_method_get_signature_checked (MonoMethod *method, MonoImage *image, guint32 token, MonoGenericContext *context, MonoError *error);
	
MonoMethod *
mono_get_method_checked (MonoImage *image, guint32 token, MonoClass *klass, MonoGenericContext *context, MonoError *error);

guint32
mono_metadata_localscope_from_methoddef (MonoImage *meta, guint32 index);

void
mono_wrapper_caches_free (MonoWrapperCaches *cache);

MonoWrapperCaches*
mono_method_get_wrapper_cache (MonoMethod *method);

MonoWrapperCaches*
mono_method_get_wrapper_cache (MonoMethod *method);

MonoType*
mono_metadata_parse_type_checked (MonoImage *m, MonoGenericContainer *container, short opt_attrs, gboolean transient, const char *ptr, const char **rptr, MonoError *error);

MonoGenericContainer *
mono_get_anonymous_container_for_image (MonoImage *image, gboolean is_mvar);

char *
mono_image_set_description (MonoImageSet *);

MonoImageSet *
mono_find_image_set_owner (void *ptr);

void
mono_loader_register_module (const char *name, MonoDl *module);

gboolean
mono_assembly_is_problematic_version (const char *name, guint16 major, guint16 minor, guint16 build, guint16 revision);

void
mono_ginst_get_desc (GString *str, MonoGenericInst *ginst);

void
mono_loader_set_strict_assembly_name_check (gboolean enabled);

gboolean
mono_loader_get_strict_assembly_name_check (void);

gboolean
mono_type_in_image (MonoType *type, MonoImage *image);

gboolean
mono_type_is_valid_generic_argument (MonoType *type);

MonoAssemblyContextKind
mono_asmctx_get_kind (const MonoAssemblyContext *ctx);

#define MONO_CLASS_IS_INTERFACE_INTERNAL(c) ((mono_class_get_flags (c) & TYPE_ATTRIBUTE_INTERFACE) || mono_type_is_generic_parameter (m_class_get_byval_arg (c)))

static inline gboolean
m_image_is_raw_data_allocated (MonoImage *image)
{
	return image->storage ? image->storage->raw_data_allocated : FALSE;
}

static inline gboolean
m_image_is_fileio_used (MonoImage *image)
{
	return image->storage ? image->storage->fileio_used : FALSE;
}

#ifdef HOST_WIN32
static inline gboolean
m_image_is_module_handle (MonoImage *image)
{
	return image->storage ? image->storage->is_module_handle : FALSE;
}

static inline gboolean
m_image_has_entry_point (MonoImage *image)
{
	return image->storage ? image->storage->has_entry_point : FALSE;
}
#endif

static inline const char *
m_image_get_name (MonoImage *image)
{
	return image->name;
}

static inline const char *
m_image_get_filename (MonoImage *image)
{
	return image->filename;
}

static inline const char *
m_image_get_assembly_name (MonoImage *image)
{
	return image->assembly_name;
}

static inline
MonoAssemblyLoadContext *
mono_image_get_alc (MonoImage *image)
{
#ifndef ENABLE_NETCORE
	return NULL;
#else
	return image->alc;
#endif
}

static inline
MonoAssemblyLoadContext *
mono_assembly_get_alc (MonoAssembly *assm)
{
	return mono_image_get_alc (assm->image);
}

/**
 * mono_type_get_type_internal:
 * \param type the \c MonoType operated on
 * \returns the IL type value for \p type. This is one of the \c MonoTypeEnum
 * enum members like \c MONO_TYPE_I4 or \c MONO_TYPE_STRING.
 */
static inline int
mono_type_get_type_internal (MonoType *type)
{
	return type->type;
}

/**
 * mono_type_get_signature:
 * \param type the \c MonoType operated on
 * It is only valid to call this function if \p type is a \c MONO_TYPE_FNPTR .
 * \returns the \c MonoMethodSignature pointer that describes the signature
 * of the function pointer \p type represents.
 */
static inline MonoMethodSignature*
mono_type_get_signature_internal (MonoType *type)
{
	g_assert (type->type == MONO_TYPE_FNPTR);
	return type->data.method;
}

/**
 * mono_type_is_byref_internal:
 * \param type the \c MonoType operated on
 * \returns TRUE if \p type represents a type passed by reference,
 * FALSE otherwise.
 */
static inline mono_bool
mono_type_is_byref_internal (MonoType *type)
{
	return type->byref;
}

/**
 * mono_type_get_class_internal:
 * \param type the \c MonoType operated on
 * It is only valid to call this function if \p type is a \c MONO_TYPE_CLASS or a
 * \c MONO_TYPE_VALUETYPE . For more general functionality, use \c mono_class_from_mono_type_internal,
 * instead.
 * \returns the \c MonoClass pointer that describes the class that \p type represents.
 */
static inline MonoClass*
mono_type_get_class_internal (MonoType *type)
{
	/* FIXME: review the runtime users before adding the assert here */
	return type->data.klass;
}

/**
 * mono_type_get_array_type_internal:
 * \param type the \c MonoType operated on
 * It is only valid to call this function if \p type is a \c MONO_TYPE_ARRAY .
 * \returns a \c MonoArrayType struct describing the array type that \p type
 * represents. The info includes details such as rank, array element type
 * and the sizes and bounds of multidimensional arrays.
 */
static inline MonoArrayType*
mono_type_get_array_type_internal (MonoType *type)
{
	return type->data.array;
}

#endif /* __MONO_METADATA_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/metadata.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_H__
#define __MONO_METADATA_H__

#include <mono/utils/mono-publib.h>

#include <mono/utils/mono-forward.h>
#include <mono/metadata/blob.h>
#include <mono/metadata/row-indexes.h>
#include <mono/metadata/image.h>
#include <mono/metadata/object-forward.h>

MONO_BEGIN_DECLS

#define MONO_TYPE_ISSTRUCT(t) mono_type_is_struct (t)
#define MONO_TYPE_IS_VOID(t) mono_type_is_void (t)
#define MONO_TYPE_IS_POINTER(t) mono_type_is_pointer (t)
#define MONO_TYPE_IS_REFERENCE(t) mono_type_is_reference (t)

#define MONO_CLASS_IS_INTERFACE(c) ((mono_class_get_flags (c) & TYPE_ATTRIBUTE_INTERFACE) || mono_type_is_generic_parameter (mono_class_get_type (c)))

#define MONO_CLASS_IS_IMPORT(c) ((mono_class_get_flags (c) & TYPE_ATTRIBUTE_IMPORT))

typedef enum {
	MONO_EXCEPTION_CLAUSE_NONE,
	MONO_EXCEPTION_CLAUSE_FILTER,
	MONO_EXCEPTION_CLAUSE_FINALLY,
	MONO_EXCEPTION_CLAUSE_FAULT = 4
} MonoExceptionEnum;

typedef enum {
	MONO_CALL_DEFAULT,
	MONO_CALL_C,
	MONO_CALL_STDCALL,
	MONO_CALL_THISCALL,
	MONO_CALL_FASTCALL,
	MONO_CALL_VARARG
} MonoCallConvention;

/* ECMA lamespec: the old spec had more info... */
typedef enum {
	MONO_NATIVE_BOOLEAN = 0x02, /* 4 bytes, 0 is false, != 0 is true */
	MONO_NATIVE_I1 = 0x03,
	MONO_NATIVE_U1 = 0x04,
	MONO_NATIVE_I2 = 0x05,
	MONO_NATIVE_U2 = 0x06,
	MONO_NATIVE_I4 = 0x07,
	MONO_NATIVE_U4 = 0x08,
	MONO_NATIVE_I8 = 0x09,
	MONO_NATIVE_U8 = 0x0a,
	MONO_NATIVE_R4 = 0x0b,
	MONO_NATIVE_R8 = 0x0c,
	MONO_NATIVE_CURRENCY = 0x0f,
	MONO_NATIVE_BSTR = 0x13, /* prefixed length, Unicode */
	MONO_NATIVE_LPSTR = 0x14, /* ANSI, null terminated */
	MONO_NATIVE_LPWSTR = 0x15, /* UNICODE, null terminated */
	MONO_NATIVE_LPTSTR = 0x16, /* plattform dep., null terminated */
	MONO_NATIVE_BYVALTSTR = 0x17,
	MONO_NATIVE_IUNKNOWN = 0x19,
	MONO_NATIVE_IDISPATCH = 0x1a,
	MONO_NATIVE_STRUCT = 0x1b,
	MONO_NATIVE_INTERFACE = 0x1c,
	MONO_NATIVE_SAFEARRAY = 0x1d,
	MONO_NATIVE_BYVALARRAY = 0x1e,
	MONO_NATIVE_INT   = 0x1f,
	MONO_NATIVE_UINT  = 0x20,
	MONO_NATIVE_VBBYREFSTR  = 0x22,
	MONO_NATIVE_ANSIBSTR  = 0x23,  /* prefixed length, ANSI */
	MONO_NATIVE_TBSTR  = 0x24, /* prefixed length, plattform dep. */
	MONO_NATIVE_VARIANTBOOL  = 0x25,
	MONO_NATIVE_FUNC  = 0x26,
	MONO_NATIVE_ASANY = 0x28,
	MONO_NATIVE_LPARRAY = 0x2a,
	MONO_NATIVE_LPSTRUCT = 0x2b,
	MONO_NATIVE_CUSTOM = 0x2c,
	MONO_NATIVE_ERROR = 0x2d,
	// TODO: MONO_NATIVE_IINSPECTABLE = 0x2e
	// TODO: MONO_NATIVE_HSTRING = 0x2f
	MONO_NATIVE_UTF8STR = 0x30,
	MONO_NATIVE_MAX = 0x50 /* no info */
} MonoMarshalNative;

/* Used only in context of SafeArray */
typedef enum {
	MONO_VARIANT_EMPTY = 0x00,
	MONO_VARIANT_NULL = 0x01,
	MONO_VARIANT_I2 = 0x02,
	MONO_VARIANT_I4 = 0x03,
	MONO_VARIANT_R4 = 0x04,
	MONO_VARIANT_R8 = 0x05,
	MONO_VARIANT_CY = 0x06,
	MONO_VARIANT_DATE = 0x07,
	MONO_VARIANT_BSTR = 0x08,
	MONO_VARIANT_DISPATCH = 0x09,
	MONO_VARIANT_ERROR = 0x0a,
	MONO_VARIANT_BOOL = 0x0b,
	MONO_VARIANT_VARIANT = 0x0c,
	MONO_VARIANT_UNKNOWN = 0x0d,
	MONO_VARIANT_DECIMAL = 0x0e,
	MONO_VARIANT_I1 = 0x10,
	MONO_VARIANT_UI1 = 0x11,
	MONO_VARIANT_UI2 = 0x12,
	MONO_VARIANT_UI4 = 0x13,
	MONO_VARIANT_I8 = 0x14,
	MONO_VARIANT_UI8 = 0x15,
	MONO_VARIANT_INT = 0x16,
	MONO_VARIANT_UINT = 0x17,
	MONO_VARIANT_VOID = 0x18,
	MONO_VARIANT_HRESULT = 0x19,
	MONO_VARIANT_PTR = 0x1a,
	MONO_VARIANT_SAFEARRAY = 0x1b,
	MONO_VARIANT_CARRAY = 0x1c,
	MONO_VARIANT_USERDEFINED = 0x1d,
	MONO_VARIANT_LPSTR = 0x1e,
	MONO_VARIANT_LPWSTR = 0x1f,
	MONO_VARIANT_RECORD = 0x24,
	MONO_VARIANT_FILETIME = 0x40,
	MONO_VARIANT_BLOB = 0x41,
	MONO_VARIANT_STREAM = 0x42,
	MONO_VARIANT_STORAGE = 0x43,
	MONO_VARIANT_STREAMED_OBJECT = 0x44,
	MONO_VARIANT_STORED_OBJECT = 0x45,
	MONO_VARIANT_BLOB_OBJECT = 0x46,
	MONO_VARIANT_CF = 0x47,
	MONO_VARIANT_CLSID = 0x48,
	MONO_VARIANT_VECTOR = 0x1000,
	MONO_VARIANT_ARRAY = 0x2000,
	MONO_VARIANT_BYREF = 0x4000
} MonoMarshalVariant;

typedef enum {
	MONO_MARSHAL_CONV_NONE,
	MONO_MARSHAL_CONV_BOOL_VARIANTBOOL,
	MONO_MARSHAL_CONV_BOOL_I4,
	MONO_MARSHAL_CONV_STR_BSTR,
	MONO_MARSHAL_CONV_STR_LPSTR,
	MONO_MARSHAL_CONV_LPSTR_STR,
	MONO_MARSHAL_CONV_LPTSTR_STR,
	MONO_MARSHAL_CONV_STR_LPWSTR,
	MONO_MARSHAL_CONV_LPWSTR_STR,
	MONO_MARSHAL_CONV_STR_LPTSTR,
	MONO_MARSHAL_CONV_STR_ANSIBSTR,
	MONO_MARSHAL_CONV_STR_TBSTR,
	MONO_MARSHAL_CONV_STR_BYVALSTR,
	MONO_MARSHAL_CONV_STR_BYVALWSTR,
	MONO_MARSHAL_CONV_SB_LPSTR,
	MONO_MARSHAL_CONV_SB_LPTSTR,
	MONO_MARSHAL_CONV_SB_LPWSTR,
	MONO_MARSHAL_CONV_LPSTR_SB,
	MONO_MARSHAL_CONV_LPTSTR_SB,
	MONO_MARSHAL_CONV_LPWSTR_SB,
	MONO_MARSHAL_CONV_ARRAY_BYVALARRAY,
	MONO_MARSHAL_CONV_ARRAY_BYVALCHARARRAY,
	MONO_MARSHAL_CONV_ARRAY_SAVEARRAY,
	MONO_MARSHAL_CONV_ARRAY_LPARRAY,
	MONO_MARSHAL_FREE_LPARRAY,
	MONO_MARSHAL_CONV_OBJECT_INTERFACE,
	MONO_MARSHAL_CONV_OBJECT_IDISPATCH,
	MONO_MARSHAL_CONV_OBJECT_IUNKNOWN,
	MONO_MARSHAL_CONV_OBJECT_STRUCT,
	MONO_MARSHAL_CONV_DEL_FTN,
	MONO_MARSHAL_CONV_FTN_DEL,
	MONO_MARSHAL_FREE_ARRAY,
	MONO_MARSHAL_CONV_BSTR_STR,
	MONO_MARSHAL_CONV_SAFEHANDLE,
	MONO_MARSHAL_CONV_HANDLEREF,
	MONO_MARSHAL_CONV_STR_UTF8STR,
	MONO_MARSHAL_CONV_SB_UTF8STR,
	MONO_MARSHAL_CONV_UTF8STR_STR,
	MONO_MARSHAL_CONV_UTF8STR_SB,
	MONO_MARSHAL_CONV_FIXED_BUFFER
} MonoMarshalConv;

#define MONO_MARSHAL_CONV_INVALID ((MonoMarshalConv)-1)

typedef struct {
	MonoMarshalNative native;
	union {
		struct {
			MonoMarshalNative elem_type;
			int32_t num_elem; /* -1 if not set */
			int16_t param_num; /* -1 if not set */
			int16_t elem_mult; /* -1 if not set */
		} array_data;
		struct {
			char *custom_name;
			char *cookie;
			MonoImage *image;
		} custom_data;
		struct {
			MonoMarshalVariant elem_type;
			int32_t num_elem;
		} safearray_data;
	} data;
} MonoMarshalSpec;

MONO_API void         mono_metadata_init (void);

MONO_API void         mono_metadata_decode_row (const MonoTableInfo   *t,
				       int                    idx,
				       uint32_t               *res,
				       int                    res_size);

MONO_API uint32_t      mono_metadata_decode_row_col (const MonoTableInfo *t, 
					   int            idx, 
					   unsigned int          col);

/*
 * This macro is used to extract the size of the table encoded in
 * the size_bitfield of MonoTableInfo.
 */
#define mono_metadata_table_size(bitfield,table) ((((bitfield) >> ((table)*2)) & 0x3) + 1)
#define mono_metadata_table_count(bitfield) ((bitfield) >> 24)

MONO_API int mono_metadata_compute_size (MonoImage   *meta,
                                int             tableindex,
                                uint32_t        *result_bitfield);

/*
 *
 */
MONO_API const char    *mono_metadata_locate        (MonoImage *meta, int table, int idx);
MONO_API const char    *mono_metadata_locate_token  (MonoImage *meta, uint32_t token);
					   
MONO_API const char    *mono_metadata_string_heap   (MonoImage *meta, uint32_t table_index);
MONO_API const char    *mono_metadata_blob_heap     (MonoImage *meta, uint32_t table_index);
MONO_API const char    *mono_metadata_user_string   (MonoImage *meta, uint32_t table_index);
MONO_API const char    *mono_metadata_guid_heap     (MonoImage *meta, uint32_t table_index);

MONO_API uint32_t mono_metadata_typedef_from_field  (MonoImage *meta, uint32_t table_index);
MONO_API uint32_t mono_metadata_typedef_from_method (MonoImage *meta, uint32_t table_index);
MONO_API uint32_t mono_metadata_nested_in_typedef   (MonoImage *meta, uint32_t table_index);
MONO_API uint32_t mono_metadata_nesting_typedef     (MonoImage *meta, uint32_t table_index, uint32_t start_index);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoClass** mono_metadata_interfaces_from_typedef (MonoImage *meta, uint32_t table_index, unsigned int *count);

MONO_API uint32_t     mono_metadata_events_from_typedef     (MonoImage *meta, uint32_t table_index, unsigned int *end_idx);
MONO_API uint32_t     mono_metadata_methods_from_event      (MonoImage *meta, uint32_t table_index, unsigned int *end);
MONO_API uint32_t     mono_metadata_properties_from_typedef (MonoImage *meta, uint32_t table_index, unsigned int *end);
MONO_API uint32_t     mono_metadata_methods_from_property   (MonoImage *meta, uint32_t table_index, unsigned int *end);
MONO_API uint32_t     mono_metadata_packing_from_typedef    (MonoImage *meta, uint32_t table_index, uint32_t *packing, uint32_t *size);
MONO_API const char* mono_metadata_get_marshal_info        (MonoImage *meta, uint32_t idx, mono_bool is_field);
MONO_API uint32_t     mono_metadata_custom_attrs_from_index (MonoImage *meta, uint32_t cattr_index);

MONO_API MonoMarshalSpec *mono_metadata_parse_marshal_spec (MonoImage *image, const char *ptr);

MONO_API void mono_metadata_free_marshal_spec (MonoMarshalSpec *spec);

MONO_API uint32_t     mono_metadata_implmap_from_method     (MonoImage *meta, uint32_t method_idx);

MONO_API void        mono_metadata_field_info (MonoImage *meta, 
				      uint32_t       table_index,
				      uint32_t      *offset,
				      uint32_t      *rva,
				      MonoMarshalSpec **marshal_spec);

MONO_API uint32_t     mono_metadata_get_constant_index (MonoImage *meta, uint32_t token, uint32_t hint);

/*
 * Functions to extract information from the Blobs
 */
MONO_API uint32_t mono_metadata_decode_value     (const char            *ptr,
                                        const char           **rptr);
MONO_API int32_t mono_metadata_decode_signed_value (const char *ptr, const char **rptr);

MONO_API uint32_t mono_metadata_decode_blob_size (const char            *ptr,
                                        const char           **rptr);

MONO_API void mono_metadata_encode_value (uint32_t value, char *bug, char **endbuf);

#define MONO_OFFSET_IN_CLAUSE(clause,offset) \
	((clause)->try_offset <= (offset) && (offset) < ((clause)->try_offset + (clause)->try_len))
#define MONO_OFFSET_IN_HANDLER(clause,offset) \
	((clause)->handler_offset <= (offset) && (offset) < ((clause)->handler_offset + (clause)->handler_len))
#define MONO_OFFSET_IN_FILTER(clause,offset) \
	((clause)->flags == MONO_EXCEPTION_CLAUSE_FILTER && (clause)->data.filter_offset <= (offset) && (offset) < ((clause)->handler_offset))

typedef struct {
	uint32_t flags;
	uint32_t try_offset;
	uint32_t try_len;
	uint32_t handler_offset;
	uint32_t handler_len;
	union {
		uint32_t filter_offset;
		MonoClass *catch_class;
	} data;
} MonoExceptionClause;

typedef struct _MonoType MonoType;
typedef struct _MonoGenericInst MonoGenericInst;
typedef struct _MonoGenericClass MonoGenericClass;
typedef struct _MonoGenericContext MonoGenericContext;
typedef struct _MonoGenericContainer MonoGenericContainer;
typedef struct _MonoGenericParam MonoGenericParam;
typedef struct _MonoArrayType MonoArrayType;
typedef struct _MonoMethodSignature MonoMethodSignature;

/* FIXME: Keeping this name alive for now, since it is part of the exposed API, even though no entrypoint uses it.  */
typedef struct invalid_name MonoGenericMethod;

typedef struct {
	unsigned int required : 1;
	unsigned int token    : 31;
} MonoCustomMod;

typedef struct _MonoCustomModContainer {
	uint8_t count; /* max 64 modifiers follow at the end */
	MonoImage *image; /* Image containing types in modifiers array */
	MonoCustomMod modifiers [1]; /* Actual length is count */
} MonoCustomModContainer;

struct _MonoArrayType {
	MonoClass *eklass;
	// Number of dimensions of the array
	uint8_t rank;

	// Arrays recording known upper and lower index bounds for each dimension
	uint8_t numsizes;
	uint8_t numlobounds;
	int *sizes;
	int *lobounds;
};

typedef struct _MonoMethodHeader MonoMethodHeader;

typedef enum {
	MONO_PARSE_TYPE,
	MONO_PARSE_MOD_TYPE,
	MONO_PARSE_LOCAL,
	MONO_PARSE_PARAM,
	MONO_PARSE_RET,
	MONO_PARSE_FIELD
} MonoParseTypeMode;

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_type_is_byref       (MonoType *type);

MONO_API MONO_RT_EXTERNAL_ONLY int
mono_type_get_type       (MonoType *type);

/* For MONO_TYPE_FNPTR */
MONO_API MONO_RT_EXTERNAL_ONLY MonoMethodSignature*
mono_type_get_signature  (MonoType *type);

/* For MONO_TYPE_CLASS, VALUETYPE */
MONO_API MONO_RT_EXTERNAL_ONLY MonoClass*
mono_type_get_class      (MonoType *type);

MONO_API MonoArrayType*
mono_type_get_array_type (MonoType *type);

/* For MONO_TYPE_PTR */
MONO_API MonoType*
mono_type_get_ptr_type (MonoType *type);

MONO_API MonoClass*
mono_type_get_modifiers  (MonoType *type, mono_bool *is_required, void **iter);

MONO_API mono_bool mono_type_is_struct    (MonoType *type);
MONO_API mono_bool mono_type_is_void      (MonoType *type);
MONO_API mono_bool mono_type_is_pointer   (MonoType *type);
MONO_API mono_bool mono_type_is_reference (MonoType *type);
MONO_API mono_bool mono_type_is_generic_parameter (MonoType *type);

MONO_API MonoType*
mono_signature_get_return_type (MonoMethodSignature *sig);

MONO_API MonoType*
mono_signature_get_params      (MonoMethodSignature *sig, void **iter);

MONO_API uint32_t
mono_signature_get_param_count (MonoMethodSignature *sig);

MONO_API uint32_t
mono_signature_get_call_conv   (MonoMethodSignature *sig);

MONO_API int
mono_signature_vararg_start    (MonoMethodSignature *sig);

MONO_API mono_bool
mono_signature_is_instance     (MonoMethodSignature *sig);

MONO_API mono_bool
mono_signature_explicit_this   (MonoMethodSignature *sig);

MONO_API mono_bool
mono_signature_param_is_out    (MonoMethodSignature *sig, int param_num);

MONO_API uint32_t     mono_metadata_parse_typedef_or_ref (MonoImage      *m,
                                                const char      *ptr,
                                                const char     **rptr);
MONO_API int            mono_metadata_parse_custom_mod  (MonoImage      *m,
						MonoCustomMod   *dest,
						const char      *ptr,
						const char     **rptr);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoArrayType *mono_metadata_parse_array       (MonoImage      *m,
						const char      *ptr,
						const char     **rptr);
MONO_API void           mono_metadata_free_array        (MonoArrayType     *array);
MONO_API MONO_RT_EXTERNAL_ONLY MonoType      *mono_metadata_parse_type        (MonoImage      *m,
						MonoParseTypeMode  mode,
						short              opt_attrs,
						const char        *ptr,
						const char       **rptr);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoType      *mono_metadata_parse_param       (MonoImage      *m,
						const char      *ptr,
						const char      **rptr);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoType      *mono_metadata_parse_field_type  (MonoImage      *m,
		                                short            field_flags,
						const char      *ptr,
						const char      **rptr);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoType      *mono_type_create_from_typespec  (MonoImage        *image,
					        uint32_t           type_spec);
MONO_API void           mono_metadata_free_type         (MonoType        *type);
MONO_API int            mono_type_size                  (MonoType        *type, 
						int             *alignment);
MONO_API int            mono_type_stack_size            (MonoType        *type, 
						int             *alignment);

MONO_API mono_bool       mono_type_generic_inst_is_valuetype      (MonoType *type);
MONO_API mono_bool       mono_metadata_generic_class_is_valuetype (MonoGenericClass *gclass);

MONO_API unsigned int          mono_metadata_type_hash         (MonoType *t1);
MONO_API mono_bool       mono_metadata_type_equal        (MonoType *t1, MonoType *t2);

MONO_API MonoMethodSignature  *mono_metadata_signature_alloc (MonoImage *image, uint32_t nparams);

MONO_API MonoMethodSignature  *mono_metadata_signature_dup (MonoMethodSignature *sig);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoMethodSignature  *mono_metadata_parse_signature (MonoImage *image, 
						     uint32_t    token);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoMethodSignature  *mono_metadata_parse_method_signature (MonoImage            *m,
                                                            int                    def,
                                                            const char            *ptr,
                                                            const char           **rptr);
MONO_API void                  mono_metadata_free_method_signature  (MonoMethodSignature   *method);

MONO_API mono_bool          mono_metadata_signature_equal (MonoMethodSignature *sig1, 
						 MonoMethodSignature *sig2);

MONO_API unsigned int             mono_signature_hash (MonoMethodSignature *sig);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoMethodHeader *mono_metadata_parse_mh (MonoImage *m, const char *ptr);
MONO_API void              mono_metadata_free_mh  (MonoMethodHeader *mh);

/* MonoMethodHeader acccessors */
MONO_API const unsigned char*
mono_method_header_get_code (MonoMethodHeader *header, uint32_t* code_size, uint32_t* max_stack);

MONO_API MonoType**
mono_method_header_get_locals (MonoMethodHeader *header, uint32_t* num_locals, mono_bool *init_locals);

MONO_API int
mono_method_header_get_num_clauses (MonoMethodHeader *header);

MONO_API int
mono_method_header_get_clauses (MonoMethodHeader *header, MonoMethod *method, void **iter, MonoExceptionClause *clause);

MONO_API uint32_t 
mono_type_to_unmanaged (MonoType *type, MonoMarshalSpec *mspec, 
			mono_bool as_field, mono_bool unicode, MonoMarshalConv *conv);

/*
 * Makes a token based on a table and an index
 */
#define mono_metadata_make_token(table,idx) (((table) << 24)| (idx))

/*
 * Returns the table index that this token encodes.
 */
#define mono_metadata_token_table(token) ((token) >> 24)

 /*
 * Returns the index that a token refers to
 */
#define mono_metadata_token_index(token) ((token) & 0xffffff)


#define mono_metadata_token_code(token) ((token) & 0xff000000)

MONO_API uint32_t mono_metadata_token_from_dor (uint32_t dor_index);

MONO_API char *mono_guid_to_string (const uint8_t *guid);

MONO_API char *mono_guid_to_string_minimal (const uint8_t *guid);

MONO_API uint32_t mono_metadata_declsec_from_index (MonoImage *meta, uint32_t idx);

MONO_API uint32_t mono_metadata_translate_token_index (MonoImage *image, int table, uint32_t idx);

MONO_API void    mono_metadata_decode_table_row (MonoImage *image, int table,
				       int                    idx,
				       uint32_t               *res,
				       int                    res_size);

MONO_API uint32_t      mono_metadata_decode_table_row_col (MonoImage *image, int table,
					   int            idx, 
					   unsigned int          col);

MONO_END_DECLS

#endif /* __MONO_METADATA_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/method-builder-ilgen-internals.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METHOD_BUILDER_ILGEN_INTERNALS_H__
#define __MONO_METHOD_BUILDER_ILGEN_INTERNALS_H__

#include "config.h"
#include <mono/metadata/class.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/class-internals.h>
#include <mono/metadata/opcodes.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/method-builder.h>

/* ilgen version */
struct _MonoMethodBuilder {
	MonoMethod *method;
	gchar *name;
	gboolean no_dup_name;
	GList *locals_list;
	gint locals;
	gboolean dynamic;
	gboolean skip_visibility;
	gboolean init_locals;
	guint32 code_size;
	guint32 pos;
	guchar *code;
	gint num_clauses;
	MonoExceptionClause *clauses;
	const gchar **param_names;
	MonoBitSet *volatile_args;
	MonoBitSet *volatile_locals;
};

#endif

```

`Hazel/vendor/mono/include/mono/metadata/method-builder-ilgen.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METHOD_BUILDER_ILGEN_H__
#define __MONO_METHOD_BUILDER_ILGEN_H__

#include "config.h"
#include <mono/metadata/class.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/class-internals.h>
#include <mono/metadata/opcodes.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/method-builder.h>

MONO_API void
mono_method_builder_ilgen_init (void);

void
mono_mb_patch_addr (MonoMethodBuilder *mb, int pos, int value);

void
mono_mb_patch_addr_s (MonoMethodBuilder *mb, int pos, gint8 value);

void
mono_mb_patch_branch (MonoMethodBuilder *mb, guint32 pos);

void
mono_mb_patch_short_branch (MonoMethodBuilder *mb, guint32 pos);

int
mono_mb_get_label (MonoMethodBuilder *mb);

int
mono_mb_get_pos (MonoMethodBuilder *mb);

void
mono_mb_emit_ptr (MonoMethodBuilder *mb, gpointer ptr);

void
mono_mb_emit_calli (MonoMethodBuilder *mb, MonoMethodSignature *sig);

void
mono_mb_emit_native_call (MonoMethodBuilder *mb, MonoMethodSignature *sig, gpointer func);

#ifdef __cplusplus
template <typename T>
inline void
mono_mb_emit_native_call (MonoMethodBuilder *mb, MonoMethodSignature *sig, T func)
{
	mono_mb_emit_native_call (mb, sig, (gpointer)func);
}
#endif // __cplusplus

void
mono_mb_emit_managed_call (MonoMethodBuilder *mb, MonoMethod *method, MonoMethodSignature *opt_sig);

void
mono_mb_emit_icall_id (MonoMethodBuilder *mb, MonoJitICallId jit_icall_id);

#define mono_mb_emit_icall(mb, name) (mono_mb_emit_icall_id ((mb), MONO_JIT_ICALL_ ## name))

int
mono_mb_add_local (MonoMethodBuilder *mb, MonoType *type);

void
mono_mb_emit_ldarg (MonoMethodBuilder *mb, guint argnum);

void
mono_mb_emit_ldarg_addr (MonoMethodBuilder *mb, guint argnum);

void
mono_mb_emit_ldloc (MonoMethodBuilder *mb, guint num);

void
mono_mb_emit_ldloc_addr (MonoMethodBuilder *mb, guint locnum);

void
mono_mb_emit_stloc (MonoMethodBuilder *mb, guint num);

void
mono_mb_emit_exception (MonoMethodBuilder *mb, const char *exc_name, const char *msg);

void
mono_mb_emit_exception_full (MonoMethodBuilder *mb, const char *exc_nspace, const char *exc_name, const char *msg);

void
mono_mb_emit_exception_for_error (MonoMethodBuilder *mb, MonoError *error);

void
mono_mb_emit_icon (MonoMethodBuilder *mb, gint32 value);

void
mono_mb_emit_icon8 (MonoMethodBuilder *mb, gint64 value);

guint32
mono_mb_emit_branch (MonoMethodBuilder *mb, guint8 op);

guint32
mono_mb_emit_short_branch (MonoMethodBuilder *mb, guint8 op);

void
mono_mb_emit_branch_label (MonoMethodBuilder *mb, guint8 op, guint32 label);

void
mono_mb_emit_add_to_local (MonoMethodBuilder *mb, guint16 local, gint32 incr);

void
mono_mb_emit_ldflda (MonoMethodBuilder *mb, gint32 offset);

void
mono_mb_emit_byte (MonoMethodBuilder *mb, guint8 op);

void
mono_mb_emit_i2 (MonoMethodBuilder *mb, gint16 data);

void
mono_mb_emit_i4 (MonoMethodBuilder *mb, gint32 data);

void
mono_mb_emit_i8 (MonoMethodBuilder *mb, gint64 data);

void
mono_mb_emit_op (MonoMethodBuilder *mb, guint8 op, gpointer data);

void
mono_mb_emit_ldstr (MonoMethodBuilder *mb, char *str);

void
mono_mb_set_clauses (MonoMethodBuilder *mb, int num_clauses, MonoExceptionClause *clauses);

void
mono_mb_set_param_names (MonoMethodBuilder *mb, const char **param_names);

char*
mono_mb_strdup (MonoMethodBuilder *mb, const char *s);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/method-builder-internals.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METHOD_BUILDER_INTERNALS_H__
#define __MONO_METHOD_BUILDER_INTERNALS_H__

#include "config.h"
#include <mono/metadata/class.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/class-internals.h>
#include <mono/metadata/opcodes.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/method-builder.h>

/* noilgen version */
struct _MonoMethodBuilder {
	MonoMethod *method;
	gchar *name;
	gboolean no_dup_name;
};

#endif

```

`Hazel/vendor/mono/include/mono/metadata/method-builder.h`:

```h
/**
 * \file
 * Functions for creating IL methods at runtime.
 * 
 * Author:
 *   Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2002 Ximian, Inc.  http://www.ximian.com
 *
 */

#ifndef __MONO_METHOD_BUILDER_H__
#define __MONO_METHOD_BUILDER_H__

#include "config.h"
#include <mono/metadata/class.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/class-internals.h>
#include <mono/metadata/opcodes.h>
#include <mono/metadata/reflection.h>

typedef struct _MonoMethodBuilder MonoMethodBuilder;

#define MONO_METHOD_BUILDER_CALLBACKS_VERSION 1

typedef struct {
	int version;
	MonoMethodBuilder* (*new_base) (MonoClass *klass, MonoWrapperType type);
	void (*free) (MonoMethodBuilder *mb);
	MonoMethod* (*create_method) (MonoMethodBuilder *mb, MonoMethodSignature *signature, int max_stack);
} MonoMethodBuilderCallbacks;

MonoMethodBuilder *
mono_mb_new (MonoClass *klass, const char *name, MonoWrapperType type);

MonoMethodBuilder *
mono_mb_new_no_dup_name (MonoClass *klass, const char *name, MonoWrapperType type);

void
mono_mb_free (MonoMethodBuilder *mb);

MonoMethod *
mono_mb_create_method (MonoMethodBuilder *mb, MonoMethodSignature *signature, int max_stack);

guint32
mono_mb_add_data (MonoMethodBuilder *mb, gpointer data);

char*
mono_mb_strdup (MonoMethodBuilder *mb, const char *s);

void
mono_install_method_builder_callbacks (MonoMethodBuilderCallbacks *cb);

#endif /* __MONO_METHOD_BUILDER_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/monitor.h`:

```h
/**
 * \file
 * Monitor locking functions
 *
 * Author:
 *	Dick Porter (dick@ximian.com)
 *
 * (C) 2003 Ximian, Inc
 */

#ifndef _MONO_METADATA_MONITOR_H_
#define _MONO_METADATA_MONITOR_H_

#include <glib.h>
#include <mono/metadata/object.h>
#include <mono/utils/mono-compiler.h>
#include <mono/utils/mono-coop-mutex.h>
#include <mono/metadata/icalls.h>

#define OWNER_MASK		0x0000ffff
#define ENTRY_COUNT_MASK	0xffff0000
#define ENTRY_COUNT_WAITERS	0x80000000
#define ENTRY_COUNT_ZERO	0x7fff0000
#define ENTRY_COUNT_SHIFT	16

struct _MonoThreadsSync
{
	/*
	 * The entry count field can be negative, which would mean that the entry_sem is
	 * signaled and nobody is waiting to acquire it. This can happen when the thread
	 * that was waiting is either interrupted or timeouts, and the owner releases
	 * the lock before the forementioned thread updates the entry count.
	 *
	 * The 0 entry_count value is encoded as ENTRY_COUNT_ZERO, positive numbers being
	 * greater than it and negative numbers smaller than it.
	 */
	guint32 status;			/* entry_count (16) | owner_id (16) */
	guint32 nest;
#ifdef HAVE_MOVING_COLLECTOR
	gint32 hash_code;
#endif
	GSList *wait_list;
	void *data;
	MonoCoopMutex *entry_mutex;
	MonoCoopCond *entry_cond;
};

/*
 * Lock word format:
 *
 * The least significant bit stores whether a hash for the object is computed
 * which is stored either in the lock word or in the MonoThreadsSync structure
 * that the lock word points to.
 *
 * The second bit stores whether the lock word is inflated, containing an
 * address to the MonoThreadsSync structure.
 *
 * If both bits are 0, either the lock word is free (entire lock word is 0)
 * or it is a thin/flat lock.
 *
 * 32-bit
 *            LOCK_WORD_FLAT:    [owner:22 | nest:8 | status:2]
 *       LOCK_WORD_THIN_HASH:    [hash:30 | status:2]
 *        LOCK_WORD_INFLATED:    [sync:30 | status:2]
 *        LOCK_WORD_FAT_HASH:    [sync:30 | status:2]
 *
 * 64-bit
 *            LOCK_WORD_FLAT:    [unused:22 | owner:32 | nest:8 | status:2]
 *       LOCK_WORD_THIN_HASH:    [hash:62 | status:2]
 *        LOCK_WORD_INFLATED:    [sync:62 | status:2]
 *        LOCK_WORD_FAT_HASH:    [sync:62 | status:2]
 *
 * In order to save processing time and to have one additional value, the nest
 * count starts from 0 for the lock word (just valid thread ID in the lock word
 * means that the thread holds the lock once, although nest is 0).
 * FIXME Have the same convention on inflated locks
 */

typedef union {
	gsize lock_word;
	MonoThreadsSync *sync;
} LockWord;

enum {
	LOCK_WORD_FLAT = 0,
	LOCK_WORD_HAS_HASH = 1,
	LOCK_WORD_INFLATED = 2,

	LOCK_WORD_STATUS_BITS = 2,
	LOCK_WORD_NEST_BITS = 8,

	LOCK_WORD_STATUS_MASK = (1 << LOCK_WORD_STATUS_BITS) - 1,
	LOCK_WORD_NEST_MASK = ((1 << LOCK_WORD_NEST_BITS) - 1) << LOCK_WORD_STATUS_BITS,

	LOCK_WORD_HASH_SHIFT = LOCK_WORD_STATUS_BITS,
	LOCK_WORD_NEST_SHIFT = LOCK_WORD_STATUS_BITS,
	LOCK_WORD_OWNER_SHIFT = LOCK_WORD_STATUS_BITS + LOCK_WORD_NEST_BITS
};

MONO_API void
mono_locks_dump (gboolean include_untaken);

void
mono_monitor_init (void);

void
mono_monitor_cleanup (void);

ICALL_EXTERN_C
MonoBoolean
mono_monitor_enter_internal (MonoObject *obj);

ICALL_EXTERN_C
void
mono_monitor_enter_v4_internal (MonoObject *obj, MonoBoolean *lock_taken);

ICALL_EXTERN_C
guint32
mono_monitor_enter_fast (MonoObject *obj);

ICALL_EXTERN_C
guint32
mono_monitor_enter_v4_fast (MonoObject *obj, MonoBoolean *lock_taken);

guint32
mono_monitor_get_object_monitor_gchandle (MonoObject *object);

void
mono_monitor_threads_sync_members_offset (int *status_offset, int *nest_offset);
#define MONO_THREADS_SYNC_MEMBER_OFFSET(o)	((o)>>8)
#define MONO_THREADS_SYNC_MEMBER_SIZE(o)	((o)&0xff)

#if ENABLE_NETCORE
ICALL_EXPORT
gint64
ves_icall_System_Threading_Monitor_Monitor_LockContentionCount (void);
#endif

#endif /* _MONO_METADATA_MONITOR_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-basic-block.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_BASIC_BLOCK_H__
#define __MONO_METADATA_BASIC_BLOCK_H__

#include <glib.h>
#include <mono/metadata/metadata.h>
#include <mono/utils/mono-compiler.h>
#include <mono/utils/mono-error.h>
#include <mono/metadata/opcodes.h>

typedef struct _MonoSimpleBasicBlock MonoSimpleBasicBlock;

struct _MonoSimpleBasicBlock {
	MonoSimpleBasicBlock *next, *left, *right, *parent;
	GSList *out_bb;
	int start, end;
	unsigned colour   : 1;
	unsigned dead     : 1;
};

MonoSimpleBasicBlock*
mono_basic_block_split (MonoMethod *method, MonoError *error, MonoMethodHeader *header);

void
mono_basic_block_free (MonoSimpleBasicBlock *bb);

/*This function is here because opcodes.h is a public header*/
int
mono_opcode_value_and_size (const unsigned char **ip, const unsigned char *end, MonoOpcodeEnum *value);

int
mono_opcode_size (const unsigned char *ip, const unsigned char *end);

#endif  /* __MONO_METADATA_BASIC_BLOCK_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-conc-hash.h`:

```h
/**
 * \file
 * GC-aware concurrent hashtable, based on utils/mono-conc-hashtable
 */

#ifndef __MONO_CONC_G_HASH_H__
#define __MONO_CONC_G_HASH_H__

#include <mono/metadata/mono-hash.h>


typedef struct _MonoConcGHashTable MonoConcGHashTable;

MonoConcGHashTable * mono_conc_g_hash_table_new_type (GHashFunc hash_func, GEqualFunc key_equal_func, MonoGHashGCType type, MonoGCRootSource source, void *key, const char *msg);
gpointer mono_conc_g_hash_table_lookup (MonoConcGHashTable *hash, gconstpointer key);
gboolean mono_conc_g_hash_table_lookup_extended (MonoConcGHashTable *hash, gconstpointer key, gpointer *orig_key, gpointer *value);
void mono_conc_g_hash_table_foreach (MonoConcGHashTable *hash, GHFunc func, gpointer user_data);
void mono_conc_g_hash_table_destroy (MonoConcGHashTable *hash);
gpointer mono_conc_g_hash_table_insert (MonoConcGHashTable *h, gpointer k, gpointer v);
gpointer mono_conc_g_hash_table_remove (MonoConcGHashTable *hash, gconstpointer key);

#endif /* __MONO_CONC_G_HASH_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-config-dirs.h`:

```h
/**
 * \file
 */

#ifndef __MONO_CONFIG_INTERNAL_H__
#define __MONO_CONFIG_INTERNAL_H__

#include <config.h>
#include <glib.h>

const char*
mono_config_get_assemblies_dir (void);

const char*
mono_config_get_cfg_dir (void);

const char*
mono_config_get_bin_dir (void);

const char*
mono_config_get_reloc_lib_dir (void);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/mono-config-internals.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_CONFIG_INTERNALS_H__
#define __MONO_METADATA_CONFIG_INTERNALS_H__

#include "mono/metadata/mono-config.h"

void 
mono_config_for_assembly_internal (MonoImage *assembly);

#endif /* __MONO_METADATA_CONFIG_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-config.h`:

```h
/**
 * \file
 *
 * Author: Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2002 Ximian, Inc.
 */
#ifndef __MONO_METADATA_CONFIG_H__
#define __MONO_METADATA_CONFIG_H__

#include <mono/utils/mono-publib.h>
#include <mono/metadata/image.h>

MONO_BEGIN_DECLS

MONO_API const char *mono_config_get_os (void);
MONO_API const char *mono_config_get_cpu (void);
MONO_API const char *mono_config_get_wordsize (void);

MONO_API const char* mono_get_config_dir (void);
MONO_API void        mono_set_config_dir (const char *dir);

MONO_API const char* mono_get_machine_config (void);

MONO_API void mono_config_cleanup      (void);
MONO_API void mono_config_parse        (const char *filename);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_config_for_assembly (MonoImage *assembly);
MONO_API void mono_config_parse_memory (const char *buffer);

MONO_API const char* mono_config_string_for_assembly_file (const char *filename);

MONO_API void mono_config_set_server_mode (mono_bool server_mode);
MONO_API mono_bool mono_config_is_server_mode (void);

MONO_END_DECLS

#endif /* __MONO_METADATA_CONFIG_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/mono-debug.h`:

```h
/**
 * \file
 * This header is only installed for use by the debugger:
 * the structures and the API declared here are not supported.
 */

#ifndef __MONO_DEBUG_H__
#define __MONO_DEBUG_H__

#include <mono/utils/mono-publib.h>
#include <mono/metadata/image.h>
#include <mono/metadata/appdomain.h>

MONO_BEGIN_DECLS

typedef struct _MonoSymbolTable			MonoSymbolTable;
typedef struct _MonoDebugDataTable		MonoDebugDataTable;

typedef struct _MonoSymbolFile			MonoSymbolFile;
typedef struct _MonoPPDBFile			MonoPPDBFile;

typedef struct _MonoDebugHandle			MonoDebugHandle;

typedef struct _MonoDebugLineNumberEntry	MonoDebugLineNumberEntry;

typedef struct _MonoDebugVarInfo		MonoDebugVarInfo;
typedef struct _MonoDebugMethodJitInfo		MonoDebugMethodJitInfo;
typedef struct _MonoDebugMethodAddress		MonoDebugMethodAddress;
typedef struct _MonoDebugMethodAddressList	MonoDebugMethodAddressList;
typedef struct _MonoDebugClassEntry		MonoDebugClassEntry;

typedef struct _MonoDebugMethodInfo		MonoDebugMethodInfo;
typedef struct _MonoDebugLocalsInfo		MonoDebugLocalsInfo;
typedef struct _MonoDebugMethodAsyncInfo	MonoDebugMethodAsyncInfo;
typedef struct _MonoDebugSourceLocation		MonoDebugSourceLocation;

typedef struct _MonoDebugList			MonoDebugList;

typedef enum {
	MONO_DEBUG_FORMAT_NONE,
	MONO_DEBUG_FORMAT_MONO,
	/* Deprecated, the mdb debugger is not longer supported. */
	MONO_DEBUG_FORMAT_DEBUGGER
} MonoDebugFormat;

/*
 * NOTE:
 * We intentionally do not use GList here since the debugger needs to know about
 * the layout of the fields.
*/
struct _MonoDebugList {
	MonoDebugList *next;
	const void* data;
};

struct _MonoSymbolTable {
	uint64_t magic;
	uint32_t version;
	uint32_t total_size;

	/*
	 * Corlib and metadata info.
	 */
	MonoDebugHandle *corlib;
	MonoDebugDataTable *global_data_table;
	MonoDebugList *data_tables;

	/*
	 * The symbol files.
	 */
	MonoDebugList *symbol_files;
};

struct _MonoDebugHandle {
	uint32_t index;
	char *image_file;
	MonoImage *image;
	MonoDebugDataTable *type_table;
	MonoSymbolFile *symfile;
	MonoPPDBFile *ppdb;
};

struct _MonoDebugMethodJitInfo {
	const mono_byte *code_start;
	uint32_t code_size;
	uint32_t prologue_end;
	uint32_t epilogue_begin;
	const mono_byte *wrapper_addr;
	uint32_t num_line_numbers;
	MonoDebugLineNumberEntry *line_numbers;
	uint32_t has_var_info;
	uint32_t num_params;
	MonoDebugVarInfo *this_var;
	MonoDebugVarInfo *params;
	uint32_t num_locals;
	MonoDebugVarInfo *locals;
	MonoDebugVarInfo *gsharedvt_info_var;
	MonoDebugVarInfo *gsharedvt_locals_var;
};

struct _MonoDebugMethodAddressList {
	uint32_t size;
	uint32_t count;
	mono_byte data [MONO_ZERO_LEN_ARRAY];
};

struct _MonoDebugSourceLocation {
	char *source_file;
	uint32_t row, column;
	uint32_t il_offset;
};

MONO_API mono_bool mono_debug_enabled (void);

/*
 * These bits of the MonoDebugLocalInfo's "index" field are flags specifying
 * where the variable is actually stored.
 *
 * See relocate_variable() in debug-symfile.c for more info.
 */
#define MONO_DEBUG_VAR_ADDRESS_MODE_FLAGS		0xf0000000

/* The variable is in register "index". */
#define MONO_DEBUG_VAR_ADDRESS_MODE_REGISTER		0

/* The variable is at offset "offset" from register "index". */
#define MONO_DEBUG_VAR_ADDRESS_MODE_REGOFFSET		0x10000000

/* The variable is in the two registers "offset" and "index". */
#define MONO_DEBUG_VAR_ADDRESS_MODE_TWO_REGISTERS	0x20000000

/* The variable is dead. */
#define MONO_DEBUG_VAR_ADDRESS_MODE_DEAD		0x30000000

/* Same as REGOFFSET, but do an indirection */
#define MONO_DEBUG_VAR_ADDRESS_MODE_REGOFFSET_INDIR		0x40000000

/* gsharedvt local */
#define MONO_DEBUG_VAR_ADDRESS_MODE_GSHAREDVT_LOCAL		0x50000000

/* variable is a vt address */
#define MONO_DEBUG_VAR_ADDRESS_MODE_VTADDR		0x60000000

struct _MonoDebugVarInfo {
	uint32_t index;
	uint32_t offset;
	uint32_t size;
	uint32_t begin_scope;
	uint32_t end_scope;
	MonoType *type;
};

#define MONO_DEBUGGER_MAJOR_VERSION			81
#define MONO_DEBUGGER_MINOR_VERSION			6
#define MONO_DEBUGGER_MAGIC				0x7aff65af4253d427ULL

MONO_API void mono_debug_init (MonoDebugFormat format);
MONO_API void mono_debug_open_image_from_memory (MonoImage *image, const mono_byte *raw_contents, int size);
MONO_API void mono_debug_cleanup (void);

MONO_API void mono_debug_close_image (MonoImage *image);

MONO_API void mono_debug_domain_unload (MonoDomain *domain);
MONO_API void mono_debug_domain_create (MonoDomain *domain);

MONO_API MonoDebugMethodAddress *
mono_debug_add_method (MonoMethod *method, MonoDebugMethodJitInfo *jit, MonoDomain *domain);

MONO_API void
mono_debug_remove_method (MonoMethod *method, MonoDomain *domain);

MONO_API MonoDebugMethodInfo *
mono_debug_lookup_method (MonoMethod *method);

MONO_API MonoDebugMethodAddressList *
mono_debug_lookup_method_addresses (MonoMethod *method);

MONO_API MonoDebugMethodJitInfo*
mono_debug_find_method (MonoMethod *method, MonoDomain *domain);

MONO_API MonoDebugHandle *
mono_debug_get_handle (MonoImage *image);

MONO_API void
mono_debug_free_method_jit_info (MonoDebugMethodJitInfo *jit);


MONO_API void
mono_debug_add_delegate_trampoline (void* code, int size);

MONO_API MonoDebugLocalsInfo*
mono_debug_lookup_locals (MonoMethod *method);

MonoDebugMethodAsyncInfo*
mono_debug_lookup_method_async_debug_info (MonoMethod *method);

// The intent here is really MONO_LLVM_INTERNAL but that is not necessarily available.
MONO_API
MonoDebugSourceLocation *
mono_debug_method_lookup_location (MonoDebugMethodInfo *minfo, int il_offset);

/*
 * Line number support.
 */

MONO_API MonoDebugSourceLocation *
mono_debug_lookup_source_location (MonoMethod *method, uint32_t address, MonoDomain *domain);

MONO_API int32_t
mono_debug_il_offset_from_address (MonoMethod *method, MonoDomain *domain, uint32_t native_offset);

MONO_API void
mono_debug_free_source_location (MonoDebugSourceLocation *location);

MONO_API char *
mono_debug_print_stack_frame (MonoMethod *method, uint32_t native_offset, MonoDomain *domain);

/*
 * Mono Debugger support functions
 *
 * These methods are used by the JIT while running inside the Mono Debugger.
 */

MONO_API int             mono_debugger_method_has_breakpoint       (MonoMethod *method);
MONO_API int             mono_debugger_insert_breakpoint           (const char *method_name, mono_bool include_namespace);

MONO_API void mono_set_is_debugger_attached (mono_bool attached);
MONO_API mono_bool mono_is_debugger_attached (void);

MONO_END_DECLS

#endif /* __MONO_DEBUG_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-endian.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_ENDIAN_H_
#define _MONO_METADATA_ENDIAN_H_ 1

#include <glib.h>

typedef union {
	guint32 ival;
	float fval;
} mono_rfloat;

typedef union {
	guint64 ival;
	double fval;
	unsigned char cval [8];
} mono_rdouble;

#if defined(__s390x__)

#define read16(x)	__builtin_bswap16(*((guint16 *)(x)))
#define read32(x)	__builtin_bswap32(*((guint32 *)(x)))
#define read64(x)	__builtin_bswap64(*((guint64 *)(x)))

#else

# if NO_UNALIGNED_ACCESS

guint16 mono_read16 (const unsigned char *x);
guint32 mono_read32 (const unsigned char *x);
guint64 mono_read64 (const unsigned char *x);

#define read16(x) (mono_read16 ((const unsigned char *)(x)))
#define read32(x) (mono_read32 ((const unsigned char *)(x)))
#define read64(x) (mono_read64 ((const unsigned char *)(x)))

# else

#define read16(x) GUINT16_FROM_LE (*((const guint16 *) (x)))
#define read32(x) GUINT32_FROM_LE (*((const guint32 *) (x)))
#define read64(x) GUINT64_FROM_LE (*((const guint64 *) (x)))

# endif

#endif

#define readr4(x,dest)	\
	do {	\
		mono_rfloat mf;	\
		mf.ival = read32 ((x));	\
		*(dest) = mf.fval;	\
	} while (0)

#define readr8(x,dest)	\
	do {	\
		mono_rdouble mf;	\
		mf.ival = read64 ((x));	\
		*(dest) = mf.fval;	\
	} while (0)

#endif /* _MONO_METADATA_ENDIAN_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-gc.h`:

```h
/**
 * \file
 * GC related public interface
 *
 */
#ifndef __METADATA_MONO_GC_H__
#define __METADATA_MONO_GC_H__

#include <mono/metadata/object.h>

MONO_BEGIN_DECLS

typedef int (*MonoGCReferences) (MonoObject *obj, MonoClass *klass, uintptr_t size, uintptr_t num, MonoObject **refs, uintptr_t *offsets, void *data);

/**
 * This enum is used by the profiler API when reporting root registration.
 */
typedef enum {
	/**
	 * Roots external to Mono. Embedders may only use this value.
	 */
	MONO_ROOT_SOURCE_EXTERNAL = 0,
	/**
	 * Thread call stack.
	 *
	 * The \c key parameter is a thread ID as a \c uintptr_t.
	 */
	MONO_ROOT_SOURCE_STACK = 1,
	/**
	 * Roots in the finalizer queue. This is a pseudo-root.
	 */
	MONO_ROOT_SOURCE_FINALIZER_QUEUE = 2,
	/**
	 * Managed \c static variables.
	 *
	 * The \c key parameter is a \c MonoVTable pointer.
	 */
	MONO_ROOT_SOURCE_STATIC = 3,
	/**
	 * Managed \c static variables with \c ThreadStaticAttribute.
	 *
	 * The \c key parameter is a thread ID as a \c uintptr_t.
	 */
	MONO_ROOT_SOURCE_THREAD_STATIC = 4,
	/**
	 * Managed \c static variables with \c ContextStaticAttribute.
	 *
	 * The \c key parameter is a \c MonoAppContext pointer.
	 */
	MONO_ROOT_SOURCE_CONTEXT_STATIC = 5,
	/**
	 * \c GCHandle structures.
	 */
	MONO_ROOT_SOURCE_GC_HANDLE = 6,
	/**
	 * Roots in the just-in-time compiler.
	 */
	MONO_ROOT_SOURCE_JIT = 7,
	/**
	 * Roots in the threading subsystem.
	 *
	 * The \c key parameter, if not \c NULL, is a thread ID as a \c uintptr_t.
	 */
	MONO_ROOT_SOURCE_THREADING = 8,
	/**
	 * Roots in application domains.
	 *
	 * The \c key parameter, if not \c NULL, is a \c MonoDomain pointer.
	 */
	MONO_ROOT_SOURCE_DOMAIN = 9,
	/**
	 * Roots in reflection code.
	 *
	 * The \c key parameter, if not \c NULL, is a \c MonoVTable pointer.
	 */
	MONO_ROOT_SOURCE_REFLECTION = 10,
	/**
	 * Roots from P/Invoke or other marshaling infrastructure.
	 */
	MONO_ROOT_SOURCE_MARSHAL = 11,
	/**
	 * Roots in the thread pool data structures.
	 */
	MONO_ROOT_SOURCE_THREAD_POOL = 12,
	/**
	 * Roots in the debugger agent.
	 */
	MONO_ROOT_SOURCE_DEBUGGER = 13,
	/**
	 * Roots in the runtime handle stack. This is a pseudo-root.
	 *
	 * The \c key parameter is a thread ID as a \c uintptr_t.
	 */
	MONO_ROOT_SOURCE_HANDLE = 14,
	/**
	 * Roots in the ephemeron arrays. This is a pseudo-root.
	 */
	MONO_ROOT_SOURCE_EPHEMERON = 15,
	/**
	 * Roots in the toggleref arrays. This is a pseudo-root.
	 */
	MONO_ROOT_SOURCE_TOGGLEREF = 16,
} MonoGCRootSource;

typedef enum {
	MONO_GC_HANDLE_TYPE_MIN = 0,
	MONO_GC_HANDLE_WEAK = MONO_GC_HANDLE_TYPE_MIN,
	MONO_GC_HANDLE_WEAK_TRACK_RESURRECTION,
	MONO_GC_HANDLE_NORMAL,
	MONO_GC_HANDLE_PINNED,
	MONO_GC_HANDLE_TYPE_MAX,
} MonoGCHandleType;

MONO_API void   mono_gc_collect         (int generation);
MONO_API int    mono_gc_max_generation  (void);
MONO_API int    mono_gc_get_generation  (MonoObject *object);
MONO_API int    mono_gc_collection_count (int generation);
MONO_API int64_t mono_gc_get_used_size   (void);
MONO_API int64_t mono_gc_get_heap_size   (void);
MONO_API MonoBoolean mono_gc_pending_finalizers (void);
MONO_API void     mono_gc_finalize_notify    (void);
MONO_API int    mono_gc_invoke_finalizers (void);
/* heap walking is only valid in the pre-stop-world event callback */
MONO_API int    mono_gc_walk_heap        (int flags, MonoGCReferences callback, void *data);

MONO_END_DECLS

#endif /* __METADATA_MONO_GC_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/mono-hash-internals.h`:

```h
/**
 * \file
 */

#ifndef __MONO_G_HASH_INTERNALS_H__
#define __MONO_G_HASH_INTERNALS_H__

#include "mono/metadata/mono-hash.h"
#include "mono/metadata/mono-gc.h"

MonoGHashTable *
mono_g_hash_table_new_type_internal (GHashFunc hash_func, GEqualFunc key_equal_func, MonoGHashGCType type, MonoGCRootSource source, void *key, const char *msg);

void 
mono_g_hash_table_insert_internal (MonoGHashTable *h, gpointer k, gpointer v);

#endif /* __MONO_G_HASH_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-hash.h`:

```h
/**
 * \file
 * GC-aware hashtable, based on Eglib's Hashtable
 *
 * Authors:
 *   Paolo Molaro (lupus@xamarin.com)
 *
 * Copyright 2013 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_G_HASH_H__
#define __MONO_G_HASH_H__

#include <mono/metadata/mono-gc.h>

/* do not change the values of this enum */
typedef enum {
	MONO_HASH_KEY_GC = 1,
	MONO_HASH_VALUE_GC = 2,
	MONO_HASH_KEY_VALUE_GC = MONO_HASH_KEY_GC | MONO_HASH_VALUE_GC,
} MonoGHashGCType;

extern gint32 mono_g_hash_table_max_chain_length;

typedef struct _MonoGHashTable MonoGHashTable;

MONO_API MONO_RT_EXTERNAL_ONLY MonoGHashTable *
mono_g_hash_table_new_type (GHashFunc hash_func, GEqualFunc key_equal_func, MonoGHashGCType type, MonoGCRootSource source, void *key, const char *msg);
MONO_API guint    mono_g_hash_table_size            (MonoGHashTable *hash);
MONO_API gpointer mono_g_hash_table_lookup          (MonoGHashTable *hash, gconstpointer key);
MONO_API gboolean mono_g_hash_table_lookup_extended (MonoGHashTable *hash, gconstpointer key, gpointer *orig_key, gpointer *value);
MONO_API void     mono_g_hash_table_foreach         (MonoGHashTable *hash, GHFunc func, gpointer user_data);
MONO_API gpointer mono_g_hash_table_find            (MonoGHashTable *hash, GHRFunc predicate, gpointer user_data);
MONO_API gboolean mono_g_hash_table_remove          (MonoGHashTable *hash, gconstpointer key);
MONO_API guint    mono_g_hash_table_foreach_remove  (MonoGHashTable *hash, GHRFunc func, gpointer user_data);
MONO_API void     mono_g_hash_table_destroy         (MonoGHashTable *hash);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_g_hash_table_insert (MonoGHashTable *h, gpointer k, gpointer v);
MONO_API void     mono_g_hash_table_replace         (MonoGHashTable *h, gpointer k, gpointer v);
MONO_API void     mono_g_hash_table_print_stats     (MonoGHashTable *table);

#endif /* __MONO_G_HASH_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/mono-mlist.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_MONO_MLIST_H__
#define __MONO_METADATA_MONO_MLIST_H__

/*
 * mono-mlist.h: Managed object list implementation
 */

#include <mono/metadata/object.h>

typedef struct _MonoMList MonoMList;
MONO_API MONO_RT_EXTERNAL_ONLY
MonoMList*  mono_mlist_alloc       (MonoObject *data);
MONO_API MonoObject* mono_mlist_get_data    (MonoMList* list);
MONO_API void        mono_mlist_set_data    (MonoMList* list, MonoObject *data);
MONO_API MonoMList*  mono_mlist_set_next    (MonoMList* list, MonoMList *next);
MONO_API int         mono_mlist_length      (MonoMList* list);
MONO_API MonoMList*  mono_mlist_next        (MonoMList* list);
MONO_API MonoMList*  mono_mlist_last        (MonoMList* list);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoMList*  mono_mlist_prepend     (MonoMList* list, MonoObject *data);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoMList*  mono_mlist_append      (MonoMList* list, MonoObject *data);

MonoMList*  mono_mlist_prepend_checked      (MonoMList* list, MonoObject *data, MonoError *error);
MonoMList*  mono_mlist_append_checked       (MonoMList* list, MonoObject *data, MonoError *error);

MONO_API MonoMList*  mono_mlist_remove_item (MonoMList* list, MonoMList *item);

#endif /* __MONO_METADATA_MONO_MLIST_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/mono-perfcounters-def.h`:

```h
/**
 * \file
 * Define the system and runtime performance counters.
 * Each category is defined with the macro:
 * 	PERFCTR_CAT(catid, name, help, type, instances, first_counter_id)
 * and after that follows the counters inside the category, defined by the macro:
 * 	PERFCTR_COUNTER(counter_id, name, help, type, field)
 * field is the field inside MonoPerfCounters per predefined counters.
 * Note we set it to unused for unrelated counters: it is unused
 * in those cases.
 */
PERFCTR_CAT(CPU, "Processor", "", MultiInstance, CPU, CPU_USER_TIME)
PERFCTR_COUNTER(CPU_USER_TIME, "% User Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(CPU_PRIV_TIME, "% Privileged Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(CPU_INTR_TIME, "% Interrupt Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(CPU_DCP_TIME,  "% DCP Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(CPU_PROC_TIME, "% Processor Time", "", Timer100NsInverse, unused)

PERFCTR_CAT(PROC, "Process", "", MultiInstance, Process, PROC_USER_TIME)
PERFCTR_COUNTER(PROC_USER_TIME, "% User Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(PROC_PRIV_TIME, "% Privileged Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(PROC_PROC_TIME, "% Processor Time", "", Timer100Ns, unused)
PERFCTR_COUNTER(PROC_THREADS,   "Thread Count", "", NumberOfItems64, unused)
PERFCTR_COUNTER(PROC_VBYTES,    "Virtual Bytes", "", NumberOfItems64, unused)
PERFCTR_COUNTER(PROC_WSET,      "Working Set", "", NumberOfItems64, unused)
PERFCTR_COUNTER(PROC_PBYTES,    "Private Bytes", "", NumberOfItems64, unused)

/* sample runtime counter */
PERFCTR_CAT(MONO_MEM, "Mono Memory", "", SingleInstance, Mono, MEM_NUM_OBJECTS)
PERFCTR_COUNTER(MEM_NUM_OBJECTS, "Allocated Objects", "", NumberOfItems64, unused)
PERFCTR_COUNTER(MEM_PHYS_TOTAL, "Total Physical Memory", "Physical memory installed in the machine, in bytes", NumberOfItems64, unused)
PERFCTR_COUNTER(MEM_PHYS_AVAILABLE, "Available Physical Memory", "Physical memory available in the machine, in bytes", NumberOfItems64, unused)

PERFCTR_CAT(ASPNET, "ASP.NET", "", MultiInstance, Mono, ASPNET_REQ_Q)
PERFCTR_COUNTER(ASPNET_REQ_Q, "Requests Queued", "", NumberOfItems64, aspnet_requests_queued)
PERFCTR_COUNTER(ASPNET_REQ_TOTAL, "Requests Total", "", NumberOfItems32, aspnet_requests)
PERFCTR_COUNTER(ASPNET_REQ_PSEC, "Requests/Sec", "", RateOfCountsPerSecond32, aspnet_requests)

PERFCTR_CAT(JIT, ".NET CLR JIT", "", MultiInstance, Mono, JIT_BYTES)
PERFCTR_COUNTER(JIT_BYTES, "# of IL Bytes JITted", "", NumberOfItems32, jit_bytes)
PERFCTR_COUNTER(JIT_METHODS, "# of IL Methods JITted", "", NumberOfItems32, jit_methods)
PERFCTR_COUNTER(JIT_TIME, "% Time in JIT", "", RawFraction, jit_time)
PERFCTR_COUNTER(JIT_BYTES_PSEC, "IL Bytes Jitted/Sec", "", RateOfCountsPerSecond32, jit_bytes)
PERFCTR_COUNTER(JIT_FAILURES, "Standard Jit Failures", "", NumberOfItems32, jit_failures)

PERFCTR_CAT(EXC, ".NET CLR Exceptions", "", MultiInstance, Mono, EXC_THROWN)
PERFCTR_COUNTER(EXC_THROWN, "# of Exceps Thrown", "", NumberOfItems32, exceptions_thrown)
PERFCTR_COUNTER(EXC_THROWN_PSEC, "# of Exceps Thrown/Sec", "", RateOfCountsPerSecond32, exceptions_thrown)
PERFCTR_COUNTER(EXC_FILTERS_PSEC, "# of Filters/Sec", "", RateOfCountsPerSecond32, exceptions_filters)
PERFCTR_COUNTER(EXC_FINALLYS_PSEC, "# of Finallys/Sec", "", RateOfCountsPerSecond32, exceptions_finallys)
PERFCTR_COUNTER(EXC_CATCH_DEPTH, "Throw to Catch Depth/Sec", "", NumberOfItems32, exceptions_depth)

PERFCTR_CAT(GC, ".NET CLR Memory", "", MultiInstance, Mono, GC_GEN0)
PERFCTR_COUNTER(GC_GEN0, "# Gen 0 Collections", "", NumberOfItems32, gc_collections0)
PERFCTR_COUNTER(GC_GEN1, "# Gen 1 Collections", "", NumberOfItems32, gc_collections1)
PERFCTR_COUNTER(GC_GEN2, "# Gen 2 Collections", "", NumberOfItems32, gc_collections2)
PERFCTR_COUNTER(GC_PROM0, "Promoted Memory from Gen 0", "", NumberOfItems32, gc_promotions0)
PERFCTR_COUNTER(GC_PROM1, "Promoted Memory from Gen 1", "", NumberOfItems32, gc_promotions1)
PERFCTR_COUNTER(GC_PROM0SEC, "Gen 0 Promoted Bytes/Sec", "", RateOfCountsPerSecond32, gc_promotions0)
PERFCTR_COUNTER(GC_PROM1SEC, "Gen 1 Promoted Bytes/Sec", "", RateOfCountsPerSecond32, gc_promotions1)
PERFCTR_COUNTER(GC_PROMFIN, "Promoted Finalization-Memory from Gen 0", "", NumberOfItems32, gc_promotion_finalizers)
PERFCTR_COUNTER(GC_GEN0SIZE, "Gen 0 heap size", "", NumberOfItems64, gc_gen0size)
PERFCTR_COUNTER(GC_GEN1SIZE, "Gen 1 heap size", "", NumberOfItems64, gc_gen1size)
PERFCTR_COUNTER(GC_GEN2SIZE, "Gen 2 heap size", "", NumberOfItems64, gc_gen2size)
PERFCTR_COUNTER(GC_LOSIZE, "Large Object Heap size", "", NumberOfItems32, gc_lossize)
PERFCTR_COUNTER(GC_FINSURV, "Finalization Survivors", "", NumberOfItems32, gc_fin_survivors)
PERFCTR_COUNTER(GC_NHANDLES, "# GC Handles", "", NumberOfItems32, gc_num_handles)
PERFCTR_COUNTER(GC_BYTESSEC, "Allocated Bytes/sec", "", RateOfCountsPerSecond32, gc_allocated)
PERFCTR_COUNTER(GC_INDGC, "# Induced GC", "", NumberOfItems32, gc_induced)
PERFCTR_COUNTER(GC_PERCTIME, "% Time in GC", "", RawFraction, gc_time)
PERFCTR_COUNTER(GC_BYTES, "# Bytes in all Heaps", "", NumberOfItems64, gc_total_bytes)
PERFCTR_COUNTER(GC_COMMBYTES, "# Total committed Bytes", "", NumberOfItems64, gc_committed_bytes)
PERFCTR_COUNTER(GC_RESBYTES, "# Total reserved Bytes", "", NumberOfItems64, gc_reserved_bytes)
PERFCTR_COUNTER(GC_PINNED, "# of Pinned Objects", "", NumberOfItems32, gc_num_pinned)
PERFCTR_COUNTER(GC_SYNKB, "# of Sink Blocks in use", "", NumberOfItems32, gc_sync_blocks)

PERFCTR_CAT(REMOTING, ".NET CLR Remoting", "", MultiInstance, Mono, REMOTING_CALLSEC)
PERFCTR_COUNTER(REMOTING_CALLSEC, "Remote Calls/sec", "", RateOfCountsPerSecond32, remoting_calls)
PERFCTR_COUNTER(REMOTING_CALLS, "Total Remote Calls", "", NumberOfItems32, remoting_calls)
PERFCTR_COUNTER(REMOTING_CHANNELS, "Channels", "", NumberOfItems32, remoting_channels)
PERFCTR_COUNTER(REMOTING_CPROXIES, "Context Proxies", "", NumberOfItems32, remoting_proxies)
PERFCTR_COUNTER(REMOTING_CBLOADED, "Context-Bound Classes Loaded", "", NumberOfItems32, remoting_classes)
PERFCTR_COUNTER(REMOTING_CBALLOCSEC, "Context-Bound Objects Alloc / sec", "", RateOfCountsPerSecond32, remoting_objects)
PERFCTR_COUNTER(REMOTING_CONTEXTS, "Contexts", "", NumberOfItems32, remoting_contexts)

PERFCTR_CAT(LOADING, ".NET CLR Loading", "", MultiInstance, Mono, LOADING_CLASSES)
PERFCTR_COUNTER(LOADING_CLASSES, "Current Classes Loaded", "", NumberOfItems32, loader_classes)
PERFCTR_COUNTER(LOADING_TOTCLASSES, "Total Classes Loaded", "", NumberOfItems32, loader_total_classes)
PERFCTR_COUNTER(LOADING_CLASSESSEC, "Rate of Classes Loaded", "", RateOfCountsPerSecond32, loader_total_classes)
PERFCTR_COUNTER(LOADING_APPDOMAINS, "Current appdomains", "", NumberOfItems32, loader_appdomains)
PERFCTR_COUNTER(LOADING_TOTAPPDOMAINS, "Total Appdomains", "", NumberOfItems32, loader_total_appdomains)
PERFCTR_COUNTER(LOADING_APPDOMAINSEC, "Rate of appdomains", "", RateOfCountsPerSecond32, loader_total_appdomains)
PERFCTR_COUNTER(LOADING_ASSEMBLIES, "Current Assemblies", "", NumberOfItems32, loader_assemblies)
PERFCTR_COUNTER(LOADING_TOTASSEMBLIES, "Total Assemblies", "", NumberOfItems32, loader_total_assemblies)
PERFCTR_COUNTER(LOADING_ASSEMBLIESEC, "Rate of Assemblies", "", RateOfCountsPerSecond32, loader_total_assemblies)
PERFCTR_COUNTER(LOADING_FAILURES, "Total # of Load Failures", "", NumberOfItems32, loader_failures)
PERFCTR_COUNTER(LOADING_FAILURESSEC, "Rate of Load Failures", "", RateOfCountsPerSecond32, loader_failures)
PERFCTR_COUNTER(LOADING_BYTES, "Bytes in Loader Heap", "", NumberOfItems32, loader_bytes)
PERFCTR_COUNTER(LOADING_APPUNLOADED, "Total appdomains unloaded", "", NumberOfItems32, loader_appdomains_uloaded)
PERFCTR_COUNTER(LOADING_APPUNLOADEDSEC, "Rate of appdomains unloaded", "", RateOfCountsPerSecond32, loader_appdomains_uloaded)

PERFCTR_CAT(THREAD, ".NET CLR LocksAndThreads", "", MultiInstance, Mono, THREAD_CONTENTIONS)
PERFCTR_COUNTER(THREAD_CONTENTIONS, "Total # of Contentions", "", NumberOfItems32, thread_contentions)
PERFCTR_COUNTER(THREAD_CONTENTIONSSEC, "Contention Rate / sec", "", RateOfCountsPerSecond32, thread_contentions)
PERFCTR_COUNTER(THREAD_QUEUELEN, "Current Queue Length", "", NumberOfItems32, thread_queue_len)
PERFCTR_COUNTER(THREAD_QUEUELENP, "Queue Length Peak", "", NumberOfItems32, thread_queue_max)
PERFCTR_COUNTER(THREAD_QUEUELENSEC, "Queue Length / sec", "", RateOfCountsPerSecond32, thread_queue_max)
PERFCTR_COUNTER(THREAD_NUMLOG, "# of current logical Threads", "", NumberOfItems32, thread_num_logical)
PERFCTR_COUNTER(THREAD_NUMPHYS, "# of current physical Threads", "", NumberOfItems32, thread_num_physical)
PERFCTR_COUNTER(THREAD_NUMREC, "# of current recognized threads", "", NumberOfItems32, thread_cur_recognized)
PERFCTR_COUNTER(THREAD_TOTREC, "# of total recognized threads", "", NumberOfItems32, thread_num_recognized)
PERFCTR_COUNTER(THREAD_TOTRECSEC, "rate of recognized threads / sec", "", RateOfCountsPerSecond32, thread_num_recognized)

PERFCTR_CAT(INTEROP, ".NET CLR Interop", "", MultiInstance, Mono, INTEROP_NUMCCW)
PERFCTR_COUNTER(INTEROP_NUMCCW, "# of CCWs", "", NumberOfItems32, interop_num_ccw)
PERFCTR_COUNTER(INTEROP_STUBS, "# of Stubs", "", NumberOfItems32, interop_num_stubs)
PERFCTR_COUNTER(INTEROP_MARSH, "# of marshalling", "", NumberOfItems32, interop_num_marshals)

PERFCTR_CAT(SECURITY, ".NET CLR Security", "", MultiInstance, Mono, SECURITY_CHECKS)
PERFCTR_COUNTER(SECURITY_CHECKS, "Total Runtime Checks", "", NumberOfItems32, security_num_checks)
PERFCTR_COUNTER(SECURITY_LCHECKS, "# Link Time Checks", "", NumberOfItems32, security_num_link_checks)
PERFCTR_COUNTER(SECURITY_PERCTIME, "% Time in RT checks", "", RawFraction, security_time)
PERFCTR_COUNTER(SECURITY_SWDEPTH, "Stack Walk Depth", "", NumberOfItems32, security_depth)

PERFCTR_CAT(THREADPOOL, "Mono Threadpool", "", MultiInstance, Mono, THREADPOOL_WORKITEMS)
PERFCTR_COUNTER(THREADPOOL_WORKITEMS, "Work Items Added", "", NumberOfItems64, threadpool_workitems)
PERFCTR_COUNTER(THREADPOOL_WORKITEMS_PSEC, "Work Items Added/Sec", "", RateOfCountsPerSecond32, threadpool_workitems)
PERFCTR_COUNTER(THREADPOOL_IOWORKITEMS, "IO Work Items Added", "", NumberOfItems64, threadpool_ioworkitems)
PERFCTR_COUNTER(THREADPOOL_IOWORKITEMS_PSEC, "IO Work Items Added/Sec", "", RateOfCountsPerSecond32, threadpool_ioworkitems)
PERFCTR_COUNTER(THREADPOOL_THREADS, "# of Threads", "", NumberOfItems32, threadpool_threads)
PERFCTR_COUNTER(THREADPOOL_IOTHREADS, "# of IO Threads", "", NumberOfItems32, threadpool_iothreads)

PERFCTR_CAT(NETWORK, "Network Interface", "", MultiInstance, NetworkInterface, NETWORK_BYTESRECSEC)
PERFCTR_COUNTER(NETWORK_BYTESRECSEC, "Bytes Received/sec", "", RateOfCountsPerSecond64, unused)
PERFCTR_COUNTER(NETWORK_BYTESSENTSEC, "Bytes Sent/sec", "", RateOfCountsPerSecond64, unused)
PERFCTR_COUNTER(NETWORK_BYTESTOTALSEC, "Bytes Total/sec", "", RateOfCountsPerSecond64, unused)

```

`Hazel/vendor/mono/include/mono/metadata/mono-perfcounters.h`:

```h
/**
 * \file
 */

#ifndef __MONO_PERFCOUNTERS_H__
#define __MONO_PERFCOUNTERS_H__

#include <glib.h>
#include <mono/metadata/object.h>
#include <mono/utils/mono-compiler.h>
#include <mono/metadata/icalls.h>

typedef struct _MonoCounterSample MonoCounterSample;

ICALL_EXPORT
MonoBoolean mono_perfcounter_get_sample (void *impl, MonoBoolean only_value, MonoCounterSample *sample);

ICALL_EXPORT
gint64 mono_perfcounter_update_value    (void *impl, MonoBoolean do_incr, gint64 value);

ICALL_EXPORT
void   mono_perfcounter_free_data       (void *impl);

typedef gboolean (*PerfCounterEnumCallback) (char *category_name, char *name, unsigned char type, gint64 value, gpointer user_data);
MONO_API void mono_perfcounter_foreach (PerfCounterEnumCallback cb, gpointer user_data);

#endif /* __MONO_PERFCOUNTERS_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/mono-ptr-array.h`:

```h
/**
 * \file
 * GC aware equivalente of g_ptr_array
 *
 * Author:
 *	Rodrigo Kumpera  <rkumpera@novell.com>
 *
 * (C) 2010 Novell, Inc
 */

#ifndef __MONO_PTR_ARRAY_H__
#define __MONO_PTR_ARRAY_H__


#include <glib.h>

#include "mono/metadata/gc-internals.h"

/* This is an implementation of a growable pointer array that avoids doing memory allocations for small sizes.
 * It works by allocating an initial small array on stack and only going to gc tracked memory if needed.
 * The array elements are assumed to be object references.
 */
typedef struct {
	void **data;
	int size;
	int capacity;
	MonoGCRootSource source;
	void *key;
	const char *msg;
} MonoPtrArray;

#define MONO_PTR_ARRAY_MAX_ON_STACK (16)

#define mono_ptr_array_init(ARRAY, INITIAL_SIZE, SOURCE, KEY, MSG) do {\
	(ARRAY).size = 0; \
	(ARRAY).capacity = MAX (INITIAL_SIZE, MONO_PTR_ARRAY_MAX_ON_STACK); \
	(ARRAY).source = SOURCE; \
	(ARRAY).key = KEY; \
	(ARRAY).msg = MSG; \
	(ARRAY).data = INITIAL_SIZE > MONO_PTR_ARRAY_MAX_ON_STACK \
		? (void **)mono_gc_alloc_fixed (sizeof (void*) * INITIAL_SIZE, mono_gc_make_root_descr_all_refs (INITIAL_SIZE), SOURCE, NULL, MSG) \
		: g_newa (void*, MONO_PTR_ARRAY_MAX_ON_STACK); \
} while (0)

#define mono_ptr_array_destroy(ARRAY) do {\
	if ((ARRAY).capacity > MONO_PTR_ARRAY_MAX_ON_STACK) \
		mono_gc_free_fixed ((ARRAY).data); \
} while (0)

#define mono_ptr_array_append(ARRAY, VALUE) do { \
	if ((ARRAY).size >= (ARRAY).capacity) {\
	void **__tmp = (void **)mono_gc_alloc_fixed (sizeof (void*) * (ARRAY).capacity * 2, mono_gc_make_root_descr_all_refs ((ARRAY).capacity * 2), (ARRAY).source, (ARRAY).key, (ARRAY).msg); \
		mono_gc_memmove_aligned ((void *)__tmp, (ARRAY).data, (ARRAY).capacity * sizeof (void*)); \
		if ((ARRAY).capacity > MONO_PTR_ARRAY_MAX_ON_STACK)	\
			mono_gc_free_fixed ((ARRAY).data);	\
		(ARRAY).data = __tmp;	\
		(ARRAY).capacity *= 2;\
	}\
	((ARRAY).data [(ARRAY).size++] = VALUE); \
} while (0)

#define mono_ptr_array_sort(ARRAY, COMPARE_FUNC) do { \
	mono_qsort ((ARRAY).data, (ARRAY).size, sizeof (gpointer), (COMPARE_FUNC)); \
} while (0)

#define mono_ptr_array_set(ARRAY, IDX, VALUE) do { \
	((ARRAY).data [(IDX)] = VALUE); \
} while (0)

#define mono_ptr_array_get(ARRAY, IDX) ((ARRAY).data [(IDX)])

#define mono_ptr_array_size(ARRAY) ((ARRAY).size)

#define mono_ptr_array_reset(ARRAY) do { \
	(ARRAY).size = 0; \
} while (0)

#define mono_ptr_array_clear(ARRAY) do { \
	(ARRAY).size = 0; \
	mono_gc_bzero_aligned ((ARRAY).data, (ARRAY).capacity * sizeof (void*)); \
} while (0)

#endif

```

`Hazel/vendor/mono/include/mono/metadata/mono-security-windows-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_MONO_SECURITY_WINDOWS_INTERNALS_H__
#define __MONO_METADATA_MONO_SECURITY_WINDOWS_INTERNALS_H__

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32
#include "mono/metadata/security.h"
#include "mono/metadata/object.h"
#include "mono/metadata/object-internals.h"
#include "mono/metadata/metadata.h"
#include "mono/metadata/metadata-internals.h"

gint32
mono_security_win_get_token_name (gpointer token, gunichar2 ** uniname, MonoError *error);

gboolean
mono_security_win_is_machine_protected (const gunichar2 *path, MonoError *error);

gboolean
mono_security_win_is_user_protected (const gunichar2 *path, MonoError *error);

gboolean
mono_security_win_protect_machine (const gunichar2 *path, MonoError *error);

gboolean
mono_security_win_protect_user (const gunichar2 *path, MonoError *error);

#endif /* HOST_WIN32 */

#endif /* __MONO_METADATA_MONO_SECURITY_WINDOWS_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/normalization-tables.h`:

```h
static const guint8 props [] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,0,
0,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
128,0,128,128,128,128,128,128,128,128,128,0,0,0,0,0,
128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
128,0,128,128,128,128,128,128,128,128,128,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,0,0,0,0,0,0,0,146,0,18,0,0,0,0,18,
0,0,18,18,146,18,0,128,18,18,18,0,18,18,18,0,
3,3,131,3,131,131,128,131,3,3,131,3,3,3,3,131,
0,3,3,3,131,131,131,0,128,3,3,3,131,3,0,0,
3,3,131,3,131,131,128,131,3,3,131,3,3,3,3,131,
0,3,3,3,131,131,131,0,128,3,3,3,131,3,0,3,
3,3,131,131,3,3,3,3,3,3,3,3,3,3,3,3,
0,0,131,131,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,
3,0,18,18,3,3,3,3,0,3,3,3,3,3,3,18,
18,0,0,3,3,3,3,3,3,18,0,0,131,131,3,3,
3,3,0,0,3,3,3,3,3,3,131,131,3,3,3,3,
131,131,3,3,3,3,0,0,131,131,131,131,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,146,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
131,131,0,0,0,0,0,0,0,0,0,0,0,0,0,131,
131,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,
0,0,0,0,18,18,18,18,18,18,18,18,18,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,
3,3,3,3,0,0,3,3,3,3,131,131,3,3,3,3,
3,18,18,18,3,3,0,0,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,3,
0,0,0,0,0,0,131,131,131,131,3,3,3,3,131,131,
3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,128,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,18,18,18,18,18,18,0,0,
18,18,18,18,18,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
168,168,168,168,168,0,168,168,168,168,168,168,168,0,0,168,
0,168,0,168,168,0,0,0,0,0,0,168,0,0,0,0,
0,0,0,168,168,168,168,168,168,0,0,0,0,168,168,0,
168,168,0,0,0,0,0,0,168,0,0,0,0,0,0,0,
87,87,168,87,87,168,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,87,0,0,0,0,0,18,0,0,0,87,0,
0,0,0,0,18,147,131,87,131,131,131,0,131,0,131,131,
131,128,0,0,0,128,0,128,0,128,0,0,0,0,0,128,
0,128,0,0,0,128,0,0,0,128,3,3,131,131,131,131,
131,128,0,0,0,128,0,128,0,128,0,0,0,0,0,128,
0,128,0,0,0,128,0,0,0,128,131,131,131,131,131,0,
18,18,146,19,19,18,18,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,0,18,18,0,0,0,18,0,0,0,0,0,0,
3,3,0,3,0,0,128,3,0,0,0,0,3,3,3,0,
128,0,0,128,0,128,128,128,128,3,128,0,0,0,128,0,
0,0,0,128,0,0,0,128,0,0,0,128,0,128,0,0,
128,0,0,128,0,128,128,128,128,3,128,0,0,0,128,0,
0,0,0,128,0,0,0,128,0,0,0,128,0,128,0,0,
3,3,0,3,0,0,128,3,0,0,0,0,3,3,3,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,128,128,3,3,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,0,0,3,3,128,128,3,3,3,3,3,3,
0,0,3,3,3,3,3,3,128,128,3,3,3,3,3,3,
3,3,3,3,3,3,0,0,3,3,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,128,0,0,128,128,128,0,0,128,0,0,128,
0,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
128,128,128,128,128,128,128,0,128,128,128,128,128,0,128,0,
128,128,0,128,128,0,128,128,128,128,128,0,0,0,0,0,
0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,3,3,3,3,128,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,
0,0,0,168,168,168,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,18,18,18,18,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,128,3,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,128,3,0,128,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,128,128,128,0,0,0,0,128,0,0,0,
0,128,128,0,0,0,0,0,128,3,0,128,0,0,0,128,
128,3,0,128,3,0,0,0,0,0,0,0,168,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,87,87,87,87,87,87,87,87,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,128,128,0,0,0,0,0,0,0,0,0,0,0,0,128,
0,0,0,0,0,0,0,0,0,0,0,0,128,0,168,0,
0,0,0,0,0,0,0,128,0,0,0,3,3,0,0,0,
0,0,0,0,0,0,0,168,0,0,0,0,87,87,0,87,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,128,128,0,0,0,0,128,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,
0,0,128,87,0,0,87,0,128,0,0,0,128,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,87,87,87,0,0,87,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,128,0,168,0,
0,0,0,0,0,0,0,128,3,0,0,3,3,0,0,0,
0,0,0,0,0,0,168,168,0,0,0,0,87,87,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,128,0,3,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,168,0,
0,0,0,0,0,0,128,128,0,0,3,3,3,0,0,0,
0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,128,0,3,0,0,0,0,0,0,0,
0,0,0,0,0,0,168,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,
3,0,168,0,0,0,128,3,3,0,131,3,0,0,0,0,
0,0,0,0,0,168,168,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,168,0,
0,0,0,0,0,0,128,128,0,0,3,3,3,0,0,0,
0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,168,
0,0,0,0,0,0,0,0,0,128,3,0,131,3,3,168,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,18,18,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
128,0,128,87,0,0,0,0,0,0,0,0,128,87,0,0,
0,128,87,0,0,0,128,87,0,0,0,128,87,0,0,0,
0,0,0,0,0,0,0,0,0,87,0,0,0,0,0,0,
0,128,128,87,128,87,87,18,87,18,0,0,0,0,0,0,
128,87,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
128,0,128,87,0,0,0,0,0,0,0,0,128,87,0,0,
0,128,87,0,0,0,128,87,0,0,0,128,87,0,0,0,
0,0,128,128,0,128,0,128,0,87,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,128,3,0,0,0,0,0,0,0,168,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,
40,40,40,40,40,40,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,40,40,40,40,40,40,40,40,
40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,
40,40,40,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,128,3,128,3,128,3,128,3,128,3,0,
0,128,3,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,168,0,0,0,0,128,3,128,3,128,128,
3,3,128,3,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,18,18,18,0,
18,18,18,18,18,18,18,18,18,18,18,0,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,0,0,0,0,0,
0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,131,131,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,131,131,3,3,3,3,
3,3,131,131,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,18,19,0,0,0,0,
131,131,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,131,131,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,131,131,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,
131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,
131,131,3,3,3,3,0,0,131,131,3,3,3,3,0,0,
131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,
131,131,3,3,3,3,3,3,131,131,3,3,3,3,3,3,
131,131,3,3,3,3,0,0,131,131,3,3,3,3,0,0,
131,131,3,3,3,3,3,3,0,131,0,3,0,3,0,3,
131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,
131,87,3,87,131,87,3,87,3,87,3,87,131,87,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,0,131,3,3,3,3,87,3,18,87,146,
18,19,3,3,3,0,131,3,3,87,3,87,3,19,19,19,
3,3,3,87,0,0,3,3,3,3,3,87,0,19,19,19,
3,3,3,87,3,3,3,3,3,3,3,87,3,19,87,87,
0,0,3,3,3,0,131,3,3,87,3,87,3,87,146,0,
87,87,146,146,18,18,18,18,18,18,18,0,0,0,0,0,
0,18,0,0,0,0,0,18,0,0,0,0,0,0,0,0,
0,0,0,0,18,18,18,0,0,0,0,0,0,0,0,18,
0,0,0,18,18,0,18,18,0,0,0,0,18,0,18,0,
0,0,0,0,0,0,0,18,18,18,0,0,0,0,0,0,
0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,0,0,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,
18,18,18,18,18,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,0,18,18,18,0,18,18,18,18,18,18,18,
18,18,18,18,0,18,18,0,0,18,18,18,18,18,0,0,
18,18,18,0,18,0,87,0,18,0,87,87,18,18,0,18,
18,18,0,18,18,18,18,18,18,18,0,18,18,18,18,18,
18,0,0,0,0,18,18,18,18,18,0,0,0,0,0,0,
0,0,0,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
128,0,128,0,128,0,0,0,0,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,
128,0,128,0,128,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,128,3,0,0,0,128,3,0,128,3,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,128,3,128,3,0,0,0,0,0,18,18,0,18,
18,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,
0,3,0,128,3,128,0,3,128,3,0,0,0,128,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,128,3,0,128,128,0,0,0,0,0,0,0,3,3,3,
3,3,128,128,3,3,128,128,3,3,128,128,128,128,0,0,
3,3,128,128,3,3,128,128,3,3,0,0,0,0,0,0,
0,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,128,0,0,0,0,0,128,128,0,128,3,3,3,3,
0,0,128,128,128,128,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,0,0,0,0,0,0,3,3,3,3,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,87,87,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,87,128,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,18,18,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,0,0,0,0,0,0,0,128,128,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,18,0,18,18,18,0,0,0,0,0,
0,0,0,0,0,0,128,0,0,0,0,128,3,128,3,128,
3,128,3,128,3,128,3,128,3,128,3,128,3,128,3,128,
3,128,3,0,128,3,128,3,128,3,0,0,0,0,0,128,
3,3,128,3,3,128,3,3,128,3,3,128,3,3,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,3,0,0,0,0,168,168,18,18,128,3,18,
0,0,0,0,0,0,128,0,0,0,0,128,3,128,3,128,
3,128,3,128,3,128,3,128,3,128,3,128,3,128,3,128,
3,128,3,0,128,3,128,3,128,3,0,0,0,0,0,128,
3,3,128,3,3,128,3,3,128,3,3,128,3,3,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,
128,128,128,0,3,0,0,3,3,3,3,0,0,128,3,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,
0,0,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,0,0,
87,0,87,0,0,87,87,87,87,87,87,87,87,87,87,0,
87,0,87,0,0,87,87,0,0,0,87,87,87,87,0,0,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,0,0,0,0,0,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,
87,87,87,87,87,87,87,87,87,87,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,0,0,0,0,0,0,0,0,0,
0,0,0,18,18,18,18,18,0,0,0,0,0,87,0,87,
18,18,18,18,18,18,18,18,18,18,87,87,87,87,87,87,
87,87,87,87,87,87,87,0,87,87,87,87,87,0,87,0,
87,87,0,87,87,0,87,87,87,215,87,87,87,87,87,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
0,0,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,0,0,18,18,18,18,18,18,18,18,18,
18,18,18,0,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,0,18,18,18,18,0,0,0,0,
18,18,18,0,18,0,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,0,0,0,
0,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,
0,0,18,18,18,18,18,18,0,0,18,18,18,18,18,18,
0,0,18,18,18,18,18,18,0,0,18,18,18,0,0,0,
18,18,18,18,18,18,18,0,18,18,18,18,18,18,18,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0};
static const guint32 mappedChars [] = {
0,32,0,32,769,0,32,771,0,32,772,0,32,773,0,32,
774,0,32,775,0,32,776,0,32,778,0,32,779,0,32,787,
0,32,788,0,32,807,0,32,808,0,32,819,0,32,834,0,
32,837,0,32,1611,0,32,1612,0,32,1612,1617,0,32,1613,0,
32,1613,1617,0,32,1614,0,32,1614,1617,0,32,1615,0,32,1615,
1617,0,32,1616,0,32,1616,1617,0,32,1617,0,32,1617,1648,0,
32,1618,0,32,12441,0,32,12442,0,33,0,33,33,0,33,63,
0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,40,
49,41,0,40,49,48,41,0,40,49,49,41,0,40,49,50,
41,0,40,49,51,41,0,40,49,52,41,0,40,49,53,41,
0,40,49,54,41,0,40,49,55,41,0,40,49,56,41,0,
40,49,57,41,0,40,50,41,0,40,50,48,41,0,40,51,
41,0,40,52,41,0,40,53,41,0,40,54,41,0,40,55,
41,0,40,56,41,0,40,57,41,0,40,97,41,0,40,98,
41,0,40,99,41,0,40,100,41,0,40,101,41,0,40,102,
41,0,40,103,41,0,40,104,41,0,40,105,41,0,40,106,
41,0,40,107,41,0,40,108,41,0,40,109,41,0,40,110,
41,0,40,111,41,0,40,112,41,0,40,113,41,0,40,114,
41,0,40,115,41,0,40,116,41,0,40,117,41,0,40,118,
41,0,40,119,41,0,40,120,41,0,40,121,41,0,40,122,
41,0,40,4352,41,0,40,4352,4449,41,0,40,4354,41,0,40,
4354,4449,41,0,40,4355,41,0,40,4355,4449,41,0,40,4357,41,
0,40,4357,4449,41,0,40,4358,41,0,40,4358,4449,41,0,40,
4359,41,0,40,4359,4449,41,0,40,4361,41,0,40,4361,4449,41,
0,40,4363,41,0,40,4363,4449,41,0,40,4363,4457,4364,4453,4523,
41,0,40,4363,4457,4370,4462,41,0,40,4364,41,0,40,4364,4449,
41,0,40,4364,4462,41,0,40,4366,41,0,40,4366,4449,41,0,
40,4367,41,0,40,4367,4449,41,0,40,4368,41,0,40,4368,4449,
41,0,40,4369,41,0,40,4369,4449,41,0,40,4370,41,0,40,
4370,4449,41,0,40,19968,41,0,40,19971,41,0,40,19977,41,0,
40,20061,41,0,40,20108,41,0,40,20116,41,0,40,20195,41,0,
40,20225,41,0,40,20241,41,0,40,20843,41,0,40,20845,41,0,
40,21172,41,0,40,21313,41,0,40,21332,41,0,40,21517,41,0,
40,21628,41,0,40,22235,41,0,40,22303,41,0,40,23398,41,0,
40,26085,41,0,40,26376,41,0,40,26377,41,0,40,26408,41,0,
40,26666,41,0,40,27700,41,0,40,28779,41,0,40,29305,41,0,
40,30435,41,0,40,31038,41,0,40,31069,41,0,40,31085,41,0,
40,33258,41,0,40,33267,41,0,40,36001,41,0,40,36039,41,0,
40,37329,41,0,41,0,42,0,43,0,44,0,45,0,46,0,
46,46,0,46,46,46,0,47,0,48,0,48,28857,0,49,0,
49,46,0,49,48,0,49,48,46,0,49,48,26085,0,49,48,
26376,0,49,48,28857,0,49,49,0,49,49,46,0,49,49,26085,
0,49,49,26376,0,49,49,28857,0,49,50,0,49,50,46,0,
49,50,26085,0,49,50,26376,0,49,50,28857,0,49,51,0,49,
51,46,0,49,51,26085,0,49,51,28857,0,49,52,0,49,52,
46,0,49,52,26085,0,49,52,28857,0,49,53,0,49,53,46,
0,49,53,26085,0,49,53,28857,0,49,54,0,49,54,46,0,
49,54,26085,0,49,54,28857,0,49,55,0,49,55,46,0,49,
55,26085,0,49,55,28857,0,49,56,0,49,56,46,0,49,56,
26085,0,49,56,28857,0,49,57,0,49,57,46,0,49,57,26085,
0,49,57,28857,0,49,8260,0,49,8260,50,0,49,8260,51,0,
49,8260,52,0,49,8260,53,0,49,8260,54,0,49,8260,56,0,
49,26085,0,49,26376,0,49,28857,0,50,0,50,46,0,50,48,
0,50,48,46,0,50,48,26085,0,50,48,28857,0,50,49,0,
50,49,26085,0,50,49,28857,0,50,50,0,50,50,26085,0,50,
50,28857,0,50,51,0,50,51,26085,0,50,51,28857,0,50,52,
0,50,52,26085,0,50,52,28857,0,50,53,0,50,53,26085,0,
50,54,0,50,54,26085,0,50,55,0,50,55,26085,0,50,56,
0,50,56,26085,0,50,57,0,50,57,26085,0,50,8260,51,0,
50,8260,53,0,50,26085,0,50,26376,0,50,28857,0,51,0,51,
46,0,51,48,0,51,48,26085,0,51,49,0,51,49,26085,0,
51,50,0,51,51,0,51,52,0,51,53,0,51,54,0,51,
55,0,51,56,0,51,57,0,51,8260,52,0,51,8260,53,0,
51,8260,56,0,51,26085,0,51,26376,0,51,28857,0,52,0,52,
46,0,52,48,0,52,49,0,52,50,0,52,51,0,52,52,
0,52,53,0,52,54,0,52,55,0,52,56,0,52,57,0,
52,8260,53,0,52,26085,0,52,26376,0,52,28857,0,53,0,53,
46,0,53,48,0,53,8260,54,0,53,8260,56,0,53,26085,0,
53,26376,0,53,28857,0,54,0,54,46,0,54,26085,0,54,26376,
0,54,28857,0,55,0,55,46,0,55,8260,56,0,55,26085,0,
55,26376,0,55,28857,0,56,0,56,46,0,56,26085,0,56,26376,
0,56,28857,0,57,0,57,46,0,57,26085,0,57,26376,0,57,
28857,0,58,0,58,58,61,0,59,0,60,0,60,824,0,61,
0,61,61,0,61,61,61,0,61,824,0,62,0,62,824,0,
63,0,63,33,0,63,63,0,64,0,65,0,65,85,0,65,
768,0,65,769,0,65,770,0,65,771,0,65,772,0,65,774,
0,65,775,0,65,776,0,65,777,0,65,778,0,65,780,0,
65,783,0,65,785,0,65,803,0,65,805,0,65,808,0,65,
8725,109,0,66,0,66,113,0,66,775,0,66,803,0,66,817,
0,67,0,67,111,46,0,67,769,0,67,770,0,67,775,0,
67,780,0,67,807,0,67,8725,107,103,0,68,0,68,90,0,
68,122,0,68,381,0,68,382,0,68,775,0,68,780,0,68,
803,0,68,807,0,68,813,0,68,817,0,69,0,69,768,0,
69,769,0,69,770,0,69,771,0,69,772,0,69,774,0,69,
775,0,69,776,0,69,777,0,69,780,0,69,783,0,69,785,
0,69,803,0,69,807,0,69,808,0,69,813,0,69,816,0,
70,0,70,65,88,0,70,775,0,71,0,71,66,0,71,72,
122,0,71,80,97,0,71,121,0,71,769,0,71,770,0,71,
772,0,71,774,0,71,775,0,71,780,0,71,807,0,72,0,
72,80,0,72,103,0,72,122,0,72,770,0,72,775,0,72,
776,0,72,780,0,72,803,0,72,807,0,72,814,0,73,0,
73,73,0,73,73,73,0,73,74,0,73,85,0,73,86,0,
73,88,0,73,768,0,73,769,0,73,770,0,73,771,0,73,
772,0,73,774,0,73,775,0,73,776,0,73,777,0,73,780,
0,73,783,0,73,785,0,73,803,0,73,808,0,73,816,0,
74,0,74,770,0,75,0,75,66,0,75,75,0,75,77,0,
75,769,0,75,780,0,75,803,0,75,807,0,75,817,0,76,
0,76,74,0,76,84,68,0,76,106,0,76,183,0,76,769,
0,76,780,0,76,803,0,76,807,0,76,813,0,76,817,0,
77,0,77,66,0,77,72,122,0,77,80,97,0,77,86,0,
77,87,0,77,769,0,77,775,0,77,803,0,77,937,0,78,
0,78,74,0,78,106,0,78,111,0,78,768,0,78,769,0,
78,771,0,78,775,0,78,780,0,78,803,0,78,807,0,78,
813,0,78,817,0,79,0,79,768,0,79,769,0,79,770,0,
79,771,0,79,772,0,79,774,0,79,775,0,79,776,0,79,
777,0,79,779,0,79,780,0,79,783,0,79,785,0,79,795,
0,79,803,0,79,808,0,80,0,80,72,0,80,80,77,0,
80,82,0,80,84,69,0,80,97,0,80,769,0,80,775,0,
81,0,82,0,82,115,0,82,769,0,82,775,0,82,780,0,
82,783,0,82,785,0,82,803,0,82,807,0,82,817,0,83,
0,83,77,0,83,118,0,83,769,0,83,770,0,83,775,0,
83,780,0,83,803,0,83,806,0,83,807,0,84,0,84,69,
76,0,84,72,122,0,84,77,0,84,775,0,84,780,0,84,
803,0,84,806,0,84,807,0,84,813,0,84,817,0,85,0,
85,768,0,85,769,0,85,770,0,85,771,0,85,772,0,85,
774,0,85,776,0,85,777,0,85,778,0,85,779,0,85,780,
0,85,783,0,85,785,0,85,795,0,85,803,0,85,804,0,
85,808,0,85,813,0,85,816,0,86,0,86,73,0,86,73,
73,0,86,73,73,73,0,86,771,0,86,803,0,86,8725,109,
0,87,0,87,98,0,87,768,0,87,769,0,87,770,0,87,
775,0,87,776,0,87,803,0,88,0,88,73,0,88,73,73,
0,88,775,0,88,776,0,89,0,89,768,0,89,769,0,89,
770,0,89,771,0,89,772,0,89,775,0,89,776,0,89,777,
0,89,803,0,90,0,90,769,0,90,770,0,90,775,0,90,
780,0,90,803,0,90,817,0,91,0,92,0,93,0,94,0,
95,0,96,0,97,0,97,46,109,46,0,97,47,99,0,97,
47,115,0,97,702,0,97,768,0,97,769,0,97,770,0,97,
771,0,97,772,0,97,774,0,97,775,0,97,776,0,97,777,
0,97,778,0,97,780,0,97,783,0,97,785,0,97,803,0,
97,805,0,97,808,0,98,0,98,97,114,0,98,775,0,98,
803,0,98,817,0,99,0,99,47,111,0,99,47,117,0,99,
97,108,0,99,99,0,99,100,0,99,109,0,99,109,178,0,
99,109,179,0,99,769,0,99,770,0,99,775,0,99,780,0,
99,807,0,100,0,100,66,0,100,97,0,100,109,0,100,109,
178,0,100,109,179,0,100,122,0,100,382,0,100,775,0,100,
780,0,100,803,0,100,807,0,100,813,0,100,817,0,100,8467,
0,101,0,101,86,0,101,114,103,0,101,768,0,101,769,0,
101,770,0,101,771,0,101,772,0,101,774,0,101,775,0,101,
776,0,101,777,0,101,780,0,101,783,0,101,785,0,101,803,
0,101,807,0,101,808,0,101,813,0,101,816,0,102,0,102,
102,0,102,102,105,0,102,102,108,0,102,105,0,102,108,0,
102,109,0,102,775,0,103,0,103,97,108,0,103,769,0,103,
770,0,103,772,0,103,774,0,103,775,0,103,780,0,103,807,
0,104,0,104,80,97,0,104,97,0,104,770,0,104,775,0,
104,776,0,104,780,0,104,803,0,104,807,0,104,814,0,104,
817,0,105,0,105,105,0,105,105,105,0,105,106,0,105,110,
0,105,118,0,105,120,0,105,768,0,105,769,0,105,770,0,
105,771,0,105,772,0,105,774,0,105,776,0,105,777,0,105,
780,0,105,783,0,105,785,0,105,803,0,105,808,0,105,816,
0,106,0,106,770,0,106,780,0,107,0,107,65,0,107,72,
122,0,107,80,97,0,107,86,0,107,87,0,107,99,97,108,
0,107,103,0,107,109,0,107,109,178,0,107,109,179,0,107,
116,0,107,769,0,107,780,0,107,803,0,107,807,0,107,817,
0,107,937,0,107,8467,0,108,0,108,106,0,108,109,0,108,
110,0,108,111,103,0,108,120,0,108,183,0,108,769,0,108,
780,0,108,803,0,108,807,0,108,813,0,108,817,0,109,0,
109,65,0,109,86,0,109,87,0,109,98,0,109,103,0,109,
105,108,0,109,109,0,109,109,178,0,109,109,179,0,109,111,
108,0,109,115,0,109,178,0,109,179,0,109,769,0,109,775,
0,109,803,0,109,8467,0,109,8725,115,0,109,8725,115,178,0,
110,0,110,65,0,110,70,0,110,86,0,110,87,0,110,106,
0,110,109,0,110,115,0,110,768,0,110,769,0,110,771,0,
110,775,0,110,780,0,110,803,0,110,807,0,110,813,0,110,
817,0,111,0,111,86,0,111,768,0,111,769,0,111,770,0,
111,771,0,111,772,0,111,774,0,111,775,0,111,776,0,111,
777,0,111,779,0,111,780,0,111,783,0,111,785,0,111,795,
0,111,803,0,111,808,0,112,0,112,46,109,46,0,112,65,
0,112,70,0,112,86,0,112,87,0,112,99,0,112,115,0,
112,769,0,112,775,0,113,0,114,0,114,97,100,0,114,97,
100,8725,115,0,114,97,100,8725,115,178,0,114,769,0,114,775,
0,114,780,0,114,783,0,114,785,0,114,803,0,114,807,0,
114,817,0,115,0,115,114,0,115,116,0,115,769,0,115,770,
0,115,775,0,115,780,0,115,803,0,115,806,0,115,807,0,
116,0,116,775,0,116,776,0,116,780,0,116,803,0,116,806,
0,116,807,0,116,813,0,116,817,0,117,0,117,768,0,117,
769,0,117,770,0,117,771,0,117,772,0,117,774,0,117,776,
0,117,777,0,117,778,0,117,779,0,117,780,0,117,783,0,
117,785,0,117,795,0,117,803,0,117,804,0,117,808,0,117,
813,0,117,816,0,118,0,118,105,0,118,105,105,0,118,105,
105,105,0,118,771,0,118,803,0,119,0,119,768,0,119,769,
0,119,770,0,119,775,0,119,776,0,119,778,0,119,803,0,
120,0,120,105,0,120,105,105,0,120,775,0,120,776,0,121,
0,121,768,0,121,769,0,121,770,0,121,771,0,121,772,0,
121,775,0,121,776,0,121,777,0,121,778,0,121,803,0,122,
0,122,769,0,122,770,0,122,775,0,122,780,0,122,803,0,
122,817,0,123,0,124,0,125,0,126,0,162,0,163,0,165,
0,166,0,168,768,0,168,769,0,168,834,0,172,0,175,0,
176,67,0,176,70,0,180,0,183,0,194,768,0,194,769,0,
194,771,0,194,777,0,196,772,0,197,0,197,769,0,198,0,
198,769,0,198,772,0,199,769,0,202,768,0,202,769,0,202,
771,0,202,777,0,207,769,0,212,768,0,212,769,0,212,771,
0,212,777,0,213,769,0,213,772,0,213,776,0,214,772,0,
216,769,0,220,768,0,220,769,0,220,772,0,220,780,0,226,
768,0,226,769,0,226,771,0,226,777,0,228,772,0,229,769,
0,230,769,0,230,772,0,231,769,0,234,768,0,234,769,0,
234,771,0,234,777,0,239,769,0,240,0,244,768,0,244,769,
0,244,771,0,244,777,0,245,769,0,245,772,0,245,776,0,
246,772,0,248,769,0,252,768,0,252,769,0,252,772,0,252,
780,0,258,768,0,258,769,0,258,771,0,258,777,0,259,768,
0,259,769,0,259,771,0,259,777,0,274,768,0,274,769,0,
275,768,0,275,769,0,295,0,331,0,332,768,0,332,769,0,
333,768,0,333,769,0,346,775,0,347,775,0,352,775,0,353,
775,0,360,769,0,361,769,0,362,776,0,363,776,0,383,116,
0,383,775,0,398,0,400,0,416,768,0,416,769,0,416,771,
0,416,777,0,416,803,0,417,768,0,417,769,0,417,771,0,
417,777,0,417,803,0,427,0,431,768,0,431,769,0,431,771,
0,431,777,0,431,803,0,432,768,0,432,769,0,432,771,0,
432,777,0,432,803,0,439,780,0,490,772,0,491,772,0,546,
0,550,772,0,551,772,0,552,774,0,553,774,0,558,772,0,
559,772,0,592,0,593,0,594,0,596,0,597,0,601,0,603,
0,604,0,607,0,609,0,611,0,613,0,614,0,616,0,617,
0,618,0,621,0,623,0,624,0,625,0,626,0,627,0,628,
0,629,0,632,0,633,0,635,0,641,0,642,0,643,0,649,
0,650,0,651,0,652,0,656,0,657,0,658,0,658,780,0,
661,0,669,0,671,0,697,0,700,110,0,768,0,769,0,776,
769,0,787,0,901,0,902,0,904,0,905,0,906,0,908,0,
910,0,911,0,912,0,913,768,0,913,769,0,913,772,0,913,
774,0,913,787,0,913,788,0,913,837,0,915,0,917,768,0,
917,769,0,917,787,0,917,788,0,919,768,0,919,769,0,919,
787,0,919,788,0,919,837,0,920,0,921,768,0,921,769,0,
921,772,0,921,774,0,921,776,0,921,787,0,921,788,0,927,
768,0,927,769,0,927,787,0,927,788,0,928,0,929,788,0,
931,0,933,0,933,768,0,933,769,0,933,772,0,933,774,0,
933,776,0,933,788,0,937,0,937,768,0,937,769,0,937,787,
0,937,788,0,937,837,0,940,0,940,837,0,941,0,942,0,
942,837,0,943,0,944,0,945,768,0,945,769,0,945,772,0,
945,774,0,945,787,0,945,788,0,945,834,0,945,837,0,946,
0,947,0,948,0,949,0,949,768,0,949,769,0,949,787,0,
949,788,0,951,768,0,951,769,0,951,787,0,951,788,0,951,
834,0,951,837,0,952,0,953,0,953,768,0,953,769,0,953,
772,0,953,774,0,953,776,0,953,787,0,953,788,0,953,834,
0,954,0,956,0,956,65,0,956,70,0,956,86,0,956,87,
0,956,103,0,956,109,0,956,115,0,956,8467,0,959,768,0,
959,769,0,959,787,0,959,788,0,960,0,961,0,961,787,0,
961,788,0,962,0,965,768,0,965,769,0,965,772,0,965,774,
0,965,776,0,965,787,0,965,788,0,965,834,0,966,0,967,
0,969,768,0,969,769,0,969,787,0,969,788,0,969,834,0,
969,837,0,970,768,0,970,769,0,970,834,0,971,768,0,971,
769,0,971,834,0,972,0,973,0,974,0,974,837,0,978,769,
0,978,776,0,1030,776,0,1040,774,0,1040,776,0,1043,769,0,
1045,768,0,1045,774,0,1045,776,0,1046,774,0,1046,776,0,1047,
776,0,1048,768,0,1048,772,0,1048,774,0,1048,776,0,1050,769,
0,1054,776,0,1059,772,0,1059,774,0,1059,776,0,1059,779,0,
1063,776,0,1067,776,0,1069,776,0,1072,774,0,1072,776,0,1075,
769,0,1077,768,0,1077,774,0,1077,776,0,1078,774,0,1078,776,
0,1079,776,0,1080,768,0,1080,772,0,1080,774,0,1080,776,0,
1082,769,0,1085,0,1086,776,0,1091,772,0,1091,774,0,1091,776,
0,1091,779,0,1095,776,0,1099,776,0,1101,776,0,1110,776,0,
1140,783,0,1141,783,0,1240,776,0,1241,776,0,1256,776,0,1257,
776,0,1381,1410,0,1396,1381,0,1396,1387,0,1396,1389,0,1396,1398,
0,1406,1398,0,1488,0,1488,1463,0,1488,1464,0,1488,1468,0,1488,
1500,0,1489,0,1489,1468,0,1489,1471,0,1490,0,1490,1468,0,1491,
0,1491,1468,0,1492,0,1492,1468,0,1493,1465,0,1493,1468,0,1494,
1468,0,1496,1468,0,1497,1460,0,1497,1468,0,1498,1468,0,1499,0,
1499,1468,0,1499,1471,0,1500,0,1500,1468,0,1501,0,1502,1468,0,
1504,1468,0,1505,1468,0,1506,0,1507,1468,0,1508,1468,0,1508,1471,
0,1510,1468,0,1511,1468,0,1512,0,1512,1468,0,1513,1468,0,1513,
1473,0,1513,1474,0,1514,0,1514,1468,0,1522,1463,0,1569,0,1570,
0,1571,0,1572,0,1573,0,1574,0,1574,1575,0,1574,1580,0,1574,
1581,0,1574,1582,0,1574,1585,0,1574,1586,0,1574,1605,0,1574,1606,
0,1574,1607,0,1574,1608,0,1574,1609,0,1574,1610,0,1574,1734,0,
1574,1735,0,1574,1736,0,1574,1744,0,1574,1749,0,1575,0,1575,1603,
1576,1585,0,1575,1604,1604,1607,0,1575,1611,0,1575,1619,0,1575,1620,
0,1575,1621,0,1575,1652,0,1576,0,1576,1580,0,1576,1581,0,1576,
1581,1610,0,1576,1582,0,1576,1582,1610,0,1576,1585,0,1576,1586,0,
1576,1605,0,1576,1606,0,1576,1607,0,1576,1609,0,1576,1610,0,1577,
0,1578,0,1578,1580,0,1578,1580,1605,0,1578,1580,1609,0,1578,1580,
1610,0,1578,1581,0,1578,1581,1580,0,1578,1581,1605,0,1578,1582,0,
1578,1582,1605,0,1578,1582,1609,0,1578,1582,1610,0,1578,1585,0,1578,
1586,0,1578,1605,0,1578,1605,1580,0,1578,1605,1581,0,1578,1605,1582,
0,1578,1605,1609,0,1578,1605,1610,0,1578,1606,0,1578,1607,0,1578,
1609,0,1578,1610,0,1579,0,1579,1580,0,1579,1585,0,1579,1586,0,
1579,1605,0,1579,1606,0,1579,1607,0,1579,1609,0,1579,1610,0,1580,
0,1580,1581,0,1580,1581,1609,0,1580,1581,1610,0,1580,1604,32,1580,
1604,1575,1604,1607,0,1580,1605,0,1580,1605,1581,0,1580,1605,1609,0,
1580,1605,1610,0,1580,1609,0,1580,1610,0,1581,0,1581,1580,0,1581,
1580,1610,0,1581,1605,0,1581,1605,1609,0,1581,1605,1610,0,1581,1609,
0,1581,1610,0,1582,0,1582,1580,0,1582,1581,0,1582,1605,0,1582,
1609,0,1582,1610,0,1583,0,1584,0,1584,1648,0,1585,0,1585,1587,
1608,1604,0,1585,1648,0,1585,1740,1575,1604,0,1586,0,1587,0,1587,
1580,0,1587,1580,1581,0,1587,1580,1609,0,1587,1581,0,1587,1581,1580,
0,1587,1582,0,1587,1582,1609,0,1587,1582,1610,0,1587,1585,0,1587,
1605,0,1587,1605,1580,0,1587,1605,1581,0,1587,1605,1605,0,1587,1607,
0,1587,1609,0,1587,1610,0,1588,0,1588,1580,0,1588,1580,1610,0,
1588,1581,0,1588,1581,1605,0,1588,1581,1610,0,1588,1582,0,1588,1585,
0,1588,1605,0,1588,1605,1582,0,1588,1605,1605,0,1588,1607,0,1588,
1609,0,1588,1610,0,1589,0,1589,1581,0,1589,1581,1581,0,1589,1581,
1610,0,1589,1582,0,1589,1585,0,1589,1604,1593,1605,0,1589,1604,1609,
0,1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,
1587,1604,1605,0,1589,1604,1746,0,1589,1605,0,1589,1605,1605,0,1589,
1609,0,1589,1610,0,1590,0,1590,1580,0,1590,1581,0,1590,1581,1609,
0,1590,1581,1610,0,1590,1582,0,1590,1582,1605,0,1590,1585,0,1590,
1605,0,1590,1609,0,1590,1610,0,1591,0,1591,1581,0,1591,1605,0,
1591,1605,1581,0,1591,1605,1605,0,1591,1605,1610,0,1591,1609,0,1591,
1610,0,1592,0,1592,1605,0,1593,0,1593,1580,0,1593,1580,1605,0,
1593,1604,1610,1607,0,1593,1605,0,1593,1605,1605,0,1593,1605,1609,0,
1593,1605,1610,0,1593,1609,0,1593,1610,0,1594,0,1594,1580,0,1594,
1605,0,1594,1605,1605,0,1594,1605,1609,0,1594,1605,1610,0,1594,1609,
0,1594,1610,0,1600,1611,0,1600,1614,0,1600,1614,1617,0,1600,1615,
0,1600,1615,1617,0,1600,1616,0,1600,1616,1617,0,1600,1617,0,1600,
1618,0,1601,0,1601,1580,0,1601,1581,0,1601,1582,0,1601,1582,1605,
0,1601,1605,0,1601,1605,1610,0,1601,1609,0,1601,1610,0,1602,0,
1602,1581,0,1602,1604,1746,0,1602,1605,0,1602,1605,1581,0,1602,1605,
1605,0,1602,1605,1610,0,1602,1609,0,1602,1610,0,1603,0,1603,1575,
0,1603,1580,0,1603,1581,0,1603,1582,0,1603,1604,0,1603,1605,0,
1603,1605,1605,0,1603,1605,1610,0,1603,1609,0,1603,1610,0,1604,0,
1604,1570,0,1604,1571,0,1604,1573,0,1604,1575,0,1604,1580,0,1604,
1580,1580,0,1604,1580,1605,0,1604,1580,1610,0,1604,1581,0,1604,1581,
1605,0,1604,1581,1609,0,1604,1581,1610,0,1604,1582,0,1604,1582,1605,
0,1604,1605,0,1604,1605,1581,0,1604,1605,1610,0,1604,1607,0,1604,
1609,0,1604,1610,0,1605,0,1605,1575,0,1605,1580,0,1605,1580,1581,
0,1605,1580,1582,0,1605,1580,1605,0,1605,1580,1610,0,1605,1581,0,
1605,1581,1580,0,1605,1581,1605,0,1605,1581,1605,1583,0,1605,1581,1610,
0,1605,1582,0,1605,1582,1580,0,1605,1582,1605,0,1605,1582,1610,0,
1605,1605,0,1605,1605,1610,0,1605,1609,0,1605,1610,0,1606,0,1606,
1580,0,1606,1580,1581,0,1606,1580,1605,0,1606,1580,1609,0,1606,1580,
1610,0,1606,1581,0,1606,1581,1605,0,1606,1581,1609,0,1606,1581,1610,
0,1606,1582,0,1606,1585,0,1606,1586,0,1606,1605,0,1606,1605,1609,
0,1606,1605,1610,0,1606,1606,0,1606,1607,0,1606,1609,0,1606,1610,
0,1607,0,1607,1580,0,1607,1605,0,1607,1605,1580,0,1607,1605,1605,
0,1607,1609,0,1607,1610,0,1607,1648,0,1608,0,1608,1587,1604,1605,
0,1608,1620,0,1608,1652,0,1609,0,1609,1648,0,1610,0,1610,1580,
0,1610,1580,1610,0,1610,1581,0,1610,1581,1610,0,1610,1582,0,1610,
1585,0,1610,1586,0,1610,1605,0,1610,1605,1605,0,1610,1605,1610,0,
1610,1606,0,1610,1607,0,1610,1609,0,1610,1610,0,1610,1620,0,1610,
1652,0,1649,0,1655,0,1657,0,1658,0,1659,0,1662,0,1663,0,
1664,0,1667,0,1668,0,1670,0,1671,0,1672,0,1676,0,1677,0,
1678,0,1681,0,1688,0,1700,0,1702,0,1705,0,1709,0,1711,0,
1713,0,1715,0,1722,0,1723,0,1726,0,1728,0,1729,0,1729,1620,
0,1733,0,1734,0,1735,0,1735,1652,0,1736,0,1737,0,1739,0,
1740,0,1744,0,1746,0,1746,1620,0,1747,0,1749,1620,0,2325,2364,
0,2326,2364,0,2327,2364,0,2332,2364,0,2337,2364,0,2338,2364,0,
2344,2364,0,2347,2364,0,2351,2364,0,2352,2364,0,2355,2364,0,2465,
2492,0,2466,2492,0,2479,2492,0,2503,2494,0,2503,2519,0,2582,2620,
0,2583,2620,0,2588,2620,0,2603,2620,0,2610,2620,0,2616,2620,0,
2849,2876,0,2850,2876,0,2887,2878,0,2887,2902,0,2887,2903,0,2962,
3031,0,3014,3006,0,3014,3031,0,3015,3006,0,3142,3158,0,3263,3285,
0,3270,3266,0,3270,3285,0,3270,3286,0,3274,3285,0,3398,3390,0,
3398,3415,0,3399,3390,0,3545,3530,0,3545,3535,0,3545,3551,0,3548,
3530,0,3661,3634,0,3755,3737,0,3755,3745,0,3789,3762,0,3851,0,
3904,4021,0,3906,4023,0,3916,4023,0,3921,4023,0,3926,4023,0,3931,
4023,0,3953,3954,0,3953,3956,0,3953,3968,0,3984,4021,0,3986,4023,
0,3996,4023,0,4001,4023,0,4006,4023,0,4011,4023,0,4018,3968,0,
4018,3969,0,4019,3968,0,4019,3969,0,4133,4142,0,4316,0,4352,0,
4352,4449,0,4353,0,4354,0,4354,4449,0,4355,0,4355,4449,0,4356,
0,4357,0,4357,4449,0,4358,0,4358,4449,0,4359,0,4359,4449,0,
4360,0,4361,0,4361,4449,0,4362,0,4363,0,4363,4449,0,4363,4462,
0,4364,0,4364,4449,0,4364,4462,4363,4468,0,4365,0,4366,0,4366,
4449,0,4366,4449,4535,4352,4457,0,4367,0,4367,4449,0,4368,0,4368,
4449,0,4369,0,4369,4449,0,4370,0,4370,4449,0,4372,0,4373,0,
4378,0,4380,0,4381,0,4382,0,4384,0,4385,0,4386,0,4387,0,
4391,0,4393,0,4395,0,4396,0,4397,0,4398,0,4399,0,4402,0,
4406,0,4416,0,4423,0,4428,0,4439,0,4440,0,4441,0,4448,0,
4449,0,4450,0,4451,0,4452,0,4453,0,4454,0,4455,0,4456,0,
4457,0,4458,0,4459,0,4460,0,4461,0,4462,0,4463,0,4464,0,
4465,0,4466,0,4467,0,4468,0,4469,0,4484,0,4485,0,4488,0,
4497,0,4498,0,4500,0,4510,0,4513,0,4522,0,4524,0,4525,0,
4528,0,4529,0,4530,0,4531,0,4532,0,4533,0,4551,0,4552,0,
4556,0,4558,0,4563,0,4567,0,4569,0,4573,0,4575,0,4593,0,
4594,0,6917,6965,0,6919,6965,0,6921,6965,0,6923,6965,0,6925,6965,
0,6929,6965,0,6970,6965,0,6972,6965,0,6974,6965,0,6975,6965,0,
6978,6965,0,7426,0,7446,0,7447,0,7452,0,7453,0,7461,0,7547,
0,7557,0,7734,772,0,7735,772,0,7770,772,0,7771,772,0,7778,
775,0,7779,775,0,7840,770,0,7840,774,0,7841,770,0,7841,774,
0,7864,770,0,7865,770,0,7884,770,0,7885,770,0,7936,768,0,
7936,769,0,7936,834,0,7936,837,0,7937,768,0,7937,769,0,7937,
834,0,7937,837,0,7938,837,0,7939,837,0,7940,837,0,7941,837,
0,7942,837,0,7943,837,0,7944,768,0,7944,769,0,7944,834,0,
7944,837,0,7945,768,0,7945,769,0,7945,834,0,7945,837,0,7946,
837,0,7947,837,0,7948,837,0,7949,837,0,7950,837,0,7951,837,
0,7952,768,0,7952,769,0,7953,768,0,7953,769,0,7960,768,0,
7960,769,0,7961,768,0,7961,769,0,7968,768,0,7968,769,0,7968,
834,0,7968,837,0,7969,768,0,7969,769,0,7969,834,0,7969,837,
0,7970,837,0,7971,837,0,7972,837,0,7973,837,0,7974,837,0,
7975,837,0,7976,768,0,7976,769,0,7976,834,0,7976,837,0,7977,
768,0,7977,769,0,7977,834,0,7977,837,0,7978,837,0,7979,837,
0,7980,837,0,7981,837,0,7982,837,0,7983,837,0,7984,768,0,
7984,769,0,7984,834,0,7985,768,0,7985,769,0,7985,834,0,7992,
768,0,7992,769,0,7992,834,0,7993,768,0,7993,769,0,7993,834,
0,8000,768,0,8000,769,0,8001,768,0,8001,769,0,8008,768,0,
8008,769,0,8009,768,0,8009,769,0,8016,768,0,8016,769,0,8016,
834,0,8017,768,0,8017,769,0,8017,834,0,8025,768,0,8025,769,
0,8025,834,0,8032,768,0,8032,769,0,8032,834,0,8032,837,0,
8033,768,0,8033,769,0,8033,834,0,8033,837,0,8034,837,0,8035,
837,0,8036,837,0,8037,837,0,8038,837,0,8039,837,0,8040,768,
0,8040,769,0,8040,834,0,8040,837,0,8041,768,0,8041,769,0,
8041,834,0,8041,837,0,8042,837,0,8043,837,0,8044,837,0,8045,
837,0,8046,837,0,8047,837,0,8048,837,0,8052,837,0,8060,837,
0,8118,837,0,8127,768,0,8127,769,0,8127,834,0,8134,837,0,
8182,837,0,8190,768,0,8190,769,0,8190,834,0,8194,0,8195,0,
8208,0,8211,0,8212,0,8229,0,8230,0,8242,8242,0,8242,8242,8242,
0,8242,8242,8242,8242,0,8245,8245,0,8245,8245,8245,0,8254,0,8361,
0,8592,0,8592,824,0,8593,0,8594,0,8594,824,0,8595,0,8596,
824,0,8656,824,0,8658,824,0,8660,824,0,8707,824,0,8712,824,
0,8715,824,0,8721,0,8722,0,8739,824,0,8741,824,0,8747,8747,
0,8747,8747,8747,0,8747,8747,8747,8747,0,8750,8750,0,8750,8750,8750,
0,8764,824,0,8771,824,0,8773,824,0,8776,824,0,8781,824,0,
8801,824,0,8804,824,0,8805,824,0,8818,824,0,8819,824,0,8822,
824,0,8823,824,0,8826,824,0,8827,824,0,8828,824,0,8829,824,
0,8834,824,0,8835,824,0,8838,824,0,8839,824,0,8849,824,0,
8850,824,0,8866,824,0,8872,824,0,8873,824,0,8875,824,0,8882,
824,0,8883,824,0,8884,824,0,8885,824,0,9474,0,9632,0,9675,
0,10629,0,10630,0,10973,824,0,11617,0,12289,0,12290,0,12296,0,
12297,0,12298,0,12299,0,12300,0,12301,0,12302,0,12303,0,12304,0,
12305,0,12306,0,12308,0,12309,0,12310,0,12311,0,12358,12441,0,12363,
12441,0,12365,12441,0,12367,12441,0,12369,12441,0,12371,12441,0,12373,12441,
0,12375,12441,0,12377,12441,0,12379,12441,0,12381,12441,0,12383,12441,0,
12385,12441,0,12388,12441,0,12390,12441,0,12392,12441,0,12399,12441,0,12399,
12442,0,12402,12441,0,12402,12442,0,12405,12441,0,12405,12442,0,12408,12441,
0,12408,12442,0,12411,12441,0,12411,12442,0,12424,12426,0,12441,0,12442,
0,12445,12441,0,12449,0,12450,0,12450,12497,12540,12488,0,12450,12523,12501,
12449,0,12450,12531,12506,12450,0,12450,12540,12523,0,12451,0,12452,0,12452,
12491,12531,12464,0,12452,12531,12481,0,12453,0,12454,0,12454,12441,0,12454,
12457,12531,0,12455,0,12456,0,12456,12473,12463,12540,12489,0,12456,12540,12459,
12540,0,12457,0,12458,0,12458,12531,12473,0,12458,12540,12512,0,12459,0,
12459,12441,0,12459,12452,12522,0,12459,12521,12483,12488,0,12459,12525,12522,12540,
0,12460,12525,12531,0,12460,12531,12510,0,12461,0,12461,12441,0,12461,12517,
12522,12540,0,12461,12525,0,12461,12525,12464,12521,12512,0,12461,12525,12513,12540,
12488,12523,0,12461,12525,12527,12483,12488,0,12462,12460,0,12462,12491,12540,0,
12462,12523,12480,12540,0,12463,0,12463,12441,0,12463,12523,12476,12452,12525,0,
12463,12525,12540,12493,0,12464,12521,12512,0,12464,12521,12512,12488,12531,0,12465,
0,12465,12441,0,12465,12540,12473,0,12467,0,12467,12441,0,12467,12488,0,
12467,12523,12490,0,12467,12540,12509,0,12469,0,12469,12441,0,12469,12452,12463,
12523,0,12469,12531,12481,12540,12512,0,12471,0,12471,12441,0,12471,12522,12531,
12464,0,12473,0,12473,12441,0,12475,0,12475,12441,0,12475,12531,12481,0,
12475,12531,12488,0,12477,0,12477,12441,0,12479,0,12479,12441,0,12480,12540,
12473,0,12481,0,12481,12441,0,12483,0,12484,0,12484,12441,0,12486,0,
12486,12441,0,12487,12471,0,12488,0,12488,12441,0,12488,12531,0,12489,12523,
0,12490,0,12490,12494,0,12491,0,12492,0,12493,0,12494,0,12494,12483,
12488,0,12495,0,12495,12441,0,12495,12442,0,12495,12452,12484,0,12496,12540,
12524,12523,0,12497,12540,12475,12531,12488,0,12497,12540,12484,0,12498,0,12498,
12441,0,12498,12442,0,12499,12523,0,12500,12450,12473,12488,12523,0,12500,12463,
12523,0,12500,12467,0,12501,0,12501,12441,0,12501,12442,0,12501,12449,12521,
12483,12489,0,12501,12451,12540,12488,0,12501,12521,12531,0,12502,12483,12471,12455,
12523,0,12504,0,12504,12441,0,12504,12442,0,12504,12463,12479,12540,12523,0,
12504,12523,12484,0,12505,12540,12479,0,12506,12477,0,12506,12491,12498,0,12506,
12531,12473,0,12506,12540,12472,0,12507,0,12507,12441,0,12507,12442,0,12507,
12531,0,12507,12540,12523,0,12507,12540,12531,0,12508,12523,12488,0,12509,12452,
12531,12488,0,12509,12531,12489,0,12510,0,12510,12452,12463,12525,0,12510,12452,
12523,0,12510,12483,12495,0,12510,12523,12463,0,12510,12531,12471,12519,12531,0,
12511,0,12511,12463,12525,12531,0,12511,12522,0,12511,12522,12496,12540,12523,0,
12512,0,12513,0,12513,12460,0,12513,12460,12488,12531,0,12513,12540,12488,12523,
0,12514,0,12515,0,12516,0,12516,12540,12489,0,12516,12540,12523,0,12517,
0,12518,0,12518,12450,12531,0,12519,0,12520,0,12521,0,12522,0,12522,
12483,12488,12523,0,12522,12521,0,12523,0,12523,12500,12540,0,12523,12540,12502,
12523,0,12524,0,12524,12512,0,12524,12531,12488,12466,12531,0,12525,0,12527,
0,12527,12441,0,12527,12483,12488,0,12528,0,12528,12441,0,12529,0,12529,
12441,0,12530,0,12530,12441,0,12531,0,12539,0,12540,0,12541,12441,0,
12593,0,12594,0,12595,0,12596,0,12597,0,12598,0,12599,0,12600,0,
12601,0,12602,0,12603,0,12604,0,12605,0,12606,0,12607,0,12608,0,
12609,0,12610,0,12611,0,12612,0,12613,0,12614,0,12615,0,12616,0,
12617,0,12618,0,12619,0,12620,0,12621,0,12622,0,12623,0,12624,0,
12625,0,12626,0,12627,0,12628,0,12629,0,12630,0,12631,0,12632,0,
12633,0,12634,0,12635,0,12636,0,12637,0,12638,0,12639,0,12640,0,
12641,0,12642,0,12643,0,12644,0,15261,0,16408,0,16441,0,19968,0,
19969,0,19971,0,19977,0,19978,0,19979,0,19981,0,19993,0,20006,0,
20008,0,20013,0,20018,0,20022,0,20025,0,20031,0,20057,0,20061,0,
20098,0,20101,0,20102,0,20108,0,20116,0,20128,0,20142,0,20154,0,
20160,0,20196,0,20225,0,20241,0,20352,0,20358,0,20363,0,20398,0,
20415,0,20523,0,20698,0,20711,0,20778,0,20799,0,20800,0,20805,0,
20813,0,20837,0,20840,0,20841,0,20843,0,20845,0,20864,0,20866,0,
20886,0,20889,0,20907,0,20917,0,20919,0,20937,0,20940,0,20956,0,
20958,0,20960,0,20981,0,20992,0,20999,0,21015,0,21033,0,21050,0,
21129,0,21147,0,21155,0,21172,0,21191,0,21193,0,21202,0,21214,0,
21220,0,21237,0,21241,0,21242,0,21269,0,21271,0,21274,0,21304,0,
21307,0,21311,0,21313,0,21316,0,21317,0,21329,0,21332,0,21340,0,
21353,0,21360,0,21365,0,21378,0,21430,0,21443,0,21448,0,21475,0,
21477,0,21491,0,21517,0,21519,0,21533,0,21570,0,21693,0,21845,0,
21895,0,21913,0,21917,0,21952,0,21986,0,22022,0,22120,0,22231,0,
22235,0,22265,0,22303,0,22320,0,22592,0,22618,0,22622,0,22696,0,
22707,0,22744,0,22751,0,22763,0,22786,0,22794,0,22805,0,22812,0,
22823,0,22823,27491,0,22825,0,22852,0,22856,0,22865,0,22868,0,22899,
0,23138,0,23336,0,23376,0,23398,0,23424,0,23429,0,23447,0,23527,
0,23534,0,23544,0,23567,0,23586,0,23608,0,23615,0,23650,0,23652,
0,23653,0,23662,0,23665,0,23833,0,23888,0,23994,0,24027,0,24037,
0,24038,0,24049,0,24062,0,24178,0,24179,25104,0,24180,0,24186,0,
24191,0,24230,0,24265,0,24266,0,24274,0,24275,0,24281,0,24300,0,
24308,0,24318,0,24324,0,24331,0,24339,0,24400,0,24417,0,24425,0,
24435,0,24459,0,24489,0,24493,0,24515,0,24565,0,24594,0,24604,0,
24724,0,24792,0,24801,0,24840,0,24900,0,24910,0,24928,0,24936,0,
24974,0,24976,0,25074,0,25078,0,25088,0,25096,0,25134,0,25140,0,
25142,0,25163,0,25289,0,25295,0,25299,0,25342,0,25467,0,25504,0,
25540,0,25628,0,25682,0,25754,0,25796,0,25903,0,25908,0,25935,0,
25942,0,25976,0,25991,0,26007,0,26009,0,26020,0,26041,0,26053,0,
26080,0,26082,0,26085,0,26126,27835,0,26131,0,26157,21644,0,26228,0,
26248,0,26257,0,26292,0,26310,0,26352,0,26356,0,26376,0,26377,0,
26391,0,26395,0,26408,0,26446,0,26454,0,26491,0,26519,0,26611,0,
26647,0,26666,0,26666,24335,20250,31038,0,26753,0,26757,0,26792,0,27138,
0,27155,0,27347,0,27396,0,27424,0,27490,0,27491,0,27511,0,27513,
0,27566,0,27571,0,27578,0,27595,0,27597,0,27604,0,27611,0,27663,
0,27668,0,27700,0,27784,0,27852,0,27877,0,27880,0,27931,0,27934,
0,27969,0,28010,0,28023,0,28107,0,28122,0,28138,0,28186,0,28316,
0,28346,0,28363,0,28369,0,28379,0,28431,0,28450,0,28451,0,28651,
0,28670,0,28702,0,28779,0,28825,0,28872,0,28889,0,29001,0,29038,
0,29134,0,29136,0,29200,0,29211,0,29226,0,29227,0,29237,0,29238,
0,29243,0,29247,0,29255,0,29273,0,29275,0,29282,0,29305,0,29356,
0,29359,0,29376,0,29436,0,29482,0,29557,0,29572,0,29575,0,29577,
0,29618,0,29662,0,29702,0,29705,0,29730,0,29801,0,29809,0,29833,
0,29848,0,29916,0,29926,0,29958,0,29976,0,29983,0,29992,0,30000,
0,30002,0,30007,0,30011,0,30041,0,30053,0,30064,0,30091,0,30098,
0,30178,0,30237,0,30239,0,30274,0,30313,0,30326,0,30333,0,30382,
0,30399,0,30410,0,30427,0,30435,0,30439,0,30446,0,30452,0,30465,
0,30528,0,30538,0,30631,0,30683,0,30690,0,30707,0,30827,0,30860,
0,30865,0,30922,0,30924,0,30971,0,31018,0,31034,0,31036,0,31038,
0,31048,0,31049,0,31056,0,31062,0,31069,0,31070,0,31077,0,31103,
0,31117,0,31118,0,31119,0,31150,0,31160,0,31166,0,31178,0,31192,
0,31260,0,31296,0,31348,0,31361,0,31409,0,31435,0,31481,0,31520,
0,31680,0,31806,0,31840,0,31859,0,31867,0,31890,0,31934,0,31958,
0,31975,0,31992,0,32016,0,32034,0,32047,0,32091,0,32160,0,32190,
0,32244,0,32265,0,32311,0,32321,0,32566,0,32574,0,32593,0,32626,
0,32633,0,32645,0,32650,0,32666,0,32701,0,32769,0,32773,0,32780,
0,32786,0,32819,0,32838,0,32879,0,32894,0,32895,0,32905,0,32907,
0,33240,0,33251,0,33256,0,33258,0,33261,0,33267,0,33276,0,33292,
0,33307,0,33311,0,33390,0,33391,0,33394,0,33400,0,33401,0,33509,
0,33590,0,33618,0,33737,0,33775,0,33777,0,33853,0,33865,0,33879,
0,34030,0,34044,0,34253,0,34298,0,34310,0,34322,0,34349,0,34367,
0,34381,0,34396,0,34411,0,34681,0,34746,0,34847,0,34880,0,34892,
0,34915,0,35010,0,35023,0,35041,0,35064,0,35088,0,35137,0,35172,
0,35198,0,35206,0,35211,0,35222,0,35282,0,35328,0,35498,0,35519,
0,35531,0,35538,0,35542,0,35565,0,35576,0,35582,0,35585,0,35641,
0,35672,0,35712,0,35722,0,35895,0,35910,0,35912,0,35925,0,35960,
0,35997,0,36001,0,36034,0,36039,0,36040,0,36051,0,36104,0,36196,
0,36208,0,36275,0,36335,0,36523,0,36554,0,36646,0,36650,0,36664,
0,36667,0,36706,0,36763,0,36784,0,36789,0,36790,0,36899,0,36920,
0,36969,0,36978,0,36988,0,37007,0,37009,0,37070,0,37117,0,37193,
0,37226,0,37273,0,37300,0,37318,0,37324,0,37327,0,37329,0,37428,
0,37494,0,37636,0,37706,0,38263,0,38272,0,38317,0,38428,0,38446,
0,38475,0,38477,0,38517,0,38520,0,38524,0,38534,0,38563,0,38582,
0,38584,0,38585,0,38626,0,38627,0,38632,0,38646,0,38647,0,38706,
0,38728,0,38737,0,38742,0,38750,0,38754,0,38761,0,38859,0,38875,
0,38893,0,38899,0,38911,0,38913,0,38917,0,38923,0,38936,0,38971,
0,39006,0,39080,0,39131,0,39135,0,39151,0,39164,0,39208,0,39318,
0,39321,0,39340,0,39409,0,39530,0,39592,0,39640,0,39647,0,39698,
0,39717,0,39727,0,39730,0,39740,0,39770,0,39791,0,40023,0,40165,
0,40372,0,40442,0,40478,0,40565,0,40575,0,40599,0,40607,0,40613,
0,40635,0,40643,0,40653,0,40654,0,40657,0,40697,0,40701,0,40718,
0,40723,0,40736,0,40763,0,40771,0,40778,0,40786,0,40845,0,40846,
0,40860,0,40863,0,40864,0,42863,0,64329,1473,0,64329,1474,0,141380,
0,141386,0,144341,0,152137,0,154832,0,163539,0,0};
static const guint16 charMapIndex [] = {
8599,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,21,0,2004,0,0,0,0,9,
0,0,841,957,3,3699,0,0,36,638,2610,0,816,808,1000,0,
1199,1202,1205,1208,1220,1226,0,1283,1325,1328,1331,1346,1475,1478,1481,1496,
0,1632,1655,1658,1661,1664,1676,0,0,1824,1827,1830,1842,1948,0,0,
2022,2025,2028,2031,2043,2049,0,2128,2186,2189,2192,2207,2343,2346,2349,2361,
0,2589,2615,2618,2621,2624,2636,0,0,2796,2799,2802,2814,2916,0,2931,
1211,2034,1214,2037,1244,2067,1271,2116,1274,2119,1277,2122,1280,2125,1308,2159,
0,0,1337,2198,1340,2201,1343,2204,1367,2228,1352,2213,1404,2271,1410,2277,
1413,2280,1419,2286,1433,2298,0,0,1484,2352,1487,2355,1490,2358,1514,2379,
1493,0,1463,2331,1522,2387,1545,2443,0,1566,2476,1575,2485,1569,2479,1563,
2473,0,0,1629,2586,1644,2601,1638,2595,3432,0,0,1667,2627,1670,2630,
1682,2642,0,0,1735,2715,1753,2733,1741,2721,1767,2747,1770,2750,1785,2765,
1776,2756,1813,2785,1804,2776,0,0,1833,2805,1836,2808,1839,2811,1848,2820,
1851,2823,1872,2844,1916,2881,1951,2919,1963,1974,2945,1980,2951,1983,2954,2739,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1694,2654,0,0,0,0,0,0,0,0,0,0,0,0,0,1863,
2835,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1299,1302,2153,1553,1560,2457,1617,1620,2574,1229,2052,1502,
2367,1685,2645,1854,2826,3081,3164,3078,3161,3084,3167,3075,3158,0,3014,3099,
3329,3332,3027,3108,0,0,1416,2283,1539,2437,1700,2660,3321,3324,3318,3421,
2390,1293,1296,2150,1401,2268,0,0,1626,2583,3019,3102,3024,3105,3072,3155,
1232,2055,1235,2058,1355,2216,1358,2219,1505,2370,1508,2373,1688,2648,1691,2651,
1744,2724,1747,2727,1857,2829,1860,2832,1782,2762,1810,2782,0,0,1442,2307,
0,0,0,0,0,0,1217,2040,1364,2225,3069,3152,3063,3146,1673,2633,
3341,3344,1957,2925,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2289,3371,2385,2696,3397,3399,3401,2873,2911,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,15,18,24,39,6,27,0,0,
3367,2455,2739,2896,3424,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3435,3437,0,3442,3439,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,3430,0,0,0,0,0,48,0,0,0,1160,0,
0,0,0,0,3,2982,3465,3000,3488,3500,3517,0,3538,0,3559,3579,
3798,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,3526,3568,3610,3642,3654,3676,
3807,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,3685,3761,3728,3752,3780,0,
3631,3669,3554,3822,3825,3773,3737,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3697,3739,3747,0,3512,3637,0,0,0,3552,0,0,0,0,0,0,
3840,3846,0,3837,0,0,0,3828,0,0,0,0,3870,3858,3879,0,
0,0,0,0,0,0,0,0,0,3864,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3930,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3906,3912,0,3903,0,0,0,3965,0,0,0,0,3936,3924,3947,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3968,3971,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3849,3915,0,0,0,0,0,0,0,0,0,0,0,0,0,
3831,3897,3834,3900,0,0,3843,3909,0,0,3974,3977,3852,3918,3855,3921,
0,0,3861,3927,3867,3933,3873,3941,0,0,3980,3983,3894,3962,3876,3944,
3882,3950,3885,3953,3888,3956,0,0,3891,3959,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,3986,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,4203,4206,5137,4209,5196,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,4212,5140,5271,5199,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5291,0,5262,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5286,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,5312,0,0,0,0,0,0,
0,5321,0,0,5324,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5294,5297,5300,5303,5306,5309,5315,5318,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,5336,5339,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5327,5330,0,5333,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5354,0,0,5357,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,5342,5345,5348,0,0,5351,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5369,0,0,5366,5372,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5360,5363,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5375,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,5378,5384,5381,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5387,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5390,0,0,0,0,0,0,5396,5399,0,5393,5402,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,5405,5411,5408,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,5414,0,5417,5423,5420,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5426,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5435,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5429,5432,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5438,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5443,0,0,0,0,0,0,0,0,0,5446,0,0,
0,0,5449,0,0,0,0,5452,0,0,0,0,5455,0,0,0,
0,0,0,0,0,0,0,0,0,5440,0,0,0,0,0,0,
0,0,0,5458,0,5461,5485,5488,5491,5494,0,0,0,0,0,0,
0,5464,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5470,0,0,0,0,0,0,0,0,0,5473,0,0,
0,0,5476,0,0,0,0,5479,0,0,0,0,5482,0,0,0,
0,0,0,0,0,0,0,0,0,5467,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5497,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5500,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1194,3022,1251,0,
1291,1323,3252,1385,1422,1454,1520,1525,1551,1584,1615,0,1653,3327,1703,1730,
1788,1822,1905,2004,3347,3349,5779,2070,2131,2177,3357,3359,3361,2262,0,2393,
2494,3208,2610,3353,5781,5783,2663,2768,2794,5787,3381,2853,5789,3631,3633,3635,
3773,3775,2322,2696,2794,2853,3631,3633,3739,3773,3775,0,0,0,0,0,
0,0,0,0,0,0,0,0,3939,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,3351,2085,3355,3129,3361,
2237,3363,3365,3369,3373,3375,3377,5791,3426,3379,5793,3428,3385,3383,3387,3389,
3391,3393,3395,3403,3405,3286,3407,3409,5785,3411,3413,2943,3415,3417,3419,3669,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1241,2064,1256,2076,1259,2079,1262,2082,3030,3111,1305,2156,1311,2162,1320,2171,
1314,2165,1317,2168,3194,3200,3197,3203,1370,2231,1373,2234,3335,3338,1382,2259,
1407,2274,1436,2301,1445,2310,1439,2304,1448,2313,1451,2316,1517,2382,3045,3126,
1536,2434,1542,2440,1548,2446,1572,2482,5795,5798,1581,2491,1578,2488,1603,2539,
1606,2542,1609,2545,1635,2592,1641,2598,1650,2607,1647,2604,3060,3143,3066,3149,
3210,3216,3213,3219,1722,2688,1725,2691,1738,2718,1750,2730,5801,5804,1756,2736,
1773,2753,1779,2759,3222,3225,3228,3231,5807,5810,1801,2770,1807,2779,1819,2791,
1816,2788,1869,2841,1878,2850,1875,2847,3234,3237,3240,3243,1895,2867,1898,2870,
1910,2875,1913,2878,1922,2887,1919,2884,1925,2893,1937,2905,1940,2908,1960,2928,
1977,2948,1986,2957,1989,2960,2319,2773,2890,2937,2019,3249,0,0,0,0,
1238,2061,1223,2046,3005,3090,3002,3087,3011,3096,3008,3093,5813,5819,3173,3185,
3170,3182,3179,3191,3176,3188,5816,5822,1361,2222,1349,2210,1334,2195,3036,3117,
3033,3114,3042,3123,3039,3120,5825,5828,1499,2364,1511,2376,1697,2657,1679,2639,
3051,3134,3048,3131,3057,3140,3054,3137,5831,5834,3259,3274,3256,3271,3265,3280,
3262,3277,3268,3283,1866,2838,1845,2817,3291,3306,3288,3303,3297,3312,3294,3309,
3300,3315,1945,2913,1969,2940,1966,2934,1954,2922,0,0,0,0,0,0,
3619,3622,5837,5849,5840,5852,5843,5855,3474,3477,5879,5891,5882,5894,5885,5897,
3645,3648,5921,5927,5924,5930,0,0,3491,3494,5933,5939,5936,5942,0,0,
3657,3660,5945,5957,5948,5960,5951,5963,3503,3506,5987,5999,5990,6002,5993,6005,
3688,3691,6029,6038,6032,6041,6035,6044,3529,3532,6047,6056,6050,6059,6053,6062,
3731,3734,6065,6071,6068,6074,0,0,3541,3544,6077,6083,6080,6086,0,0,
3764,3767,6089,6098,6092,6101,6095,6104,0,3571,0,6107,0,6110,0,6113,
3783,3786,6116,6128,6119,6131,6122,6134,3582,3585,6158,6170,6161,6173,6164,6176,
3607,3591,3639,3596,3651,3598,3673,3603,3725,3813,3749,3815,3777,3817,0,0,
5846,5858,5861,5864,5867,5870,5873,5876,5888,5900,5903,5906,5909,5912,5915,5918,
5954,5966,5969,5972,5975,5978,5981,5984,5996,6008,6011,6014,6017,6020,6023,6026,
6125,6137,6140,6143,6146,6149,6152,6155,6167,6179,6182,6185,6188,6191,6194,6197,
3616,3613,6200,3628,3593,0,3625,6209,3471,3468,3462,3446,3480,30,3671,30,
45,2985,6203,3666,3600,0,3663,6221,3485,3448,3497,3450,3509,6212,6215,6218,
3682,3679,3795,3460,0,0,3694,3801,3523,3520,3514,3452,0,6227,6230,6233,
3758,3755,3804,3605,3741,3744,3770,3810,3565,3562,3556,3456,3549,2979,3444,2002,
0,0,6206,3792,3819,0,3789,6224,3535,3454,3576,3458,3588,2998,33,0,
6236,6238,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
0,6240,0,0,0,0,0,42,0,0,0,0,0,0,0,0,
0,0,0,0,622,624,627,0,0,0,0,0,0,0,0,1,
0,0,0,6250,6253,0,6262,6265,0,0,0,0,107,0,12,0,
0,0,0,0,0,0,0,1189,1186,110,0,0,0,0,0,0,
0,0,0,0,0,0,0,6257,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
633,2322,0,0,1021,1069,1094,1108,1126,1140,616,6310,1167,125,612,2560,
633,638,841,957,1021,1069,1094,1108,1126,1140,616,6310,1167,125,612,0,
2004,2177,2610,2896,3357,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1732,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2011,2015,1265,2992,0,2087,2091,3254,0,2995,2262,1422,1422,1422,2289,3206,
1454,1454,1551,2455,0,1615,1623,0,0,1703,1728,1730,1730,1730,0,0,
1761,1790,1798,0,1972,0,3574,0,1972,0,1525,3017,1251,1265,0,2177,
1323,1376,0,1584,2610,4004,4018,4026,4031,2322,0,1378,3737,3633,3483,3547,
6308,0,0,0,0,1291,2131,2177,2322,2385,0,0,0,0,0,0,
0,0,0,812,940,820,944,1004,1056,824,1077,828,1008,1081,1113,805,
1454,1456,1459,1469,1881,1883,1886,1890,1472,1928,1930,1933,1551,1265,1291,1584,
2322,2324,2327,2337,2853,2855,2858,2862,2340,2896,2898,2901,2455,2085,2131,2494,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,6275,6282,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,6287,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,6290,6296,6293,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6299,0,0,0,0,6302,0,0,6305,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6312,0,6315,0,0,0,0,0,6318,6321,0,6330,
6333,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,6337,0,0,6340,0,0,6343,0,6346,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1176,0,6352,0,0,0,0,0,0,0,0,0,0,6349,1164,1181,
6355,6358,0,0,6361,6364,0,0,6367,6370,0,0,0,0,0,0,
6373,6376,0,0,6385,6388,0,0,6391,6394,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6403,6406,6409,6412,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6379,6382,6397,6400,0,0,0,0,0,0,6415,6418,6421,6424,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,6446,6448,0,0,0,0,0,
638,841,957,1021,1069,1094,1108,1126,1140,643,662,681,700,715,730,745,
760,775,790,846,127,181,190,194,198,202,206,210,214,131,136,141,
146,151,156,161,166,171,176,185,640,843,959,1023,1071,1096,1110,1128,
1142,646,665,684,703,718,733,748,763,778,793,849,218,222,226,230,
234,238,242,246,250,254,258,262,266,270,274,278,282,286,290,294,
298,302,306,310,314,318,1194,1251,1265,1291,1323,1376,1385,1422,1454,1520,
1525,1551,1584,1615,1653,1703,1728,1730,1759,1788,1822,1881,1905,1928,1943,1972,
2004,2070,2085,2131,2177,2237,2262,2289,2322,2385,2393,2455,2494,2560,2610,2663,
2694,2696,2739,2768,2794,2853,2873,2896,2911,2943,633,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6325,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1156,1169,1172,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6437,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6440,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7833,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8595,0,0,0,0,0,0,0,0,0,0,0,0,
7278,7296,7302,7306,7308,7314,7318,7322,7326,7354,7362,7368,7374,7376,7380,7394,
7396,7398,7410,7428,7432,7436,7438,7444,7454,7456,7462,7464,7468,7470,7502,7508,
7526,7528,7530,7532,7536,7551,7557,7561,7571,7573,7575,7577,7587,7589,7597,7599,
7603,7605,7607,7614,7616,7632,7634,7638,7640,7642,7644,7648,7656,7690,7696,7698,
7722,7724,7732,7734,7738,7740,7744,7748,7768,7772,7780,7815,7817,7823,7827,7831,
7835,7837,7839,7841,7843,7893,7913,7919,7921,7923,7925,7927,7929,7935,7947,7951,
7971,7973,7977,7979,7981,7983,7997,7999,8011,8013,8015,8017,8027,8039,8041,8043,
8059,8089,8091,8101,8107,8109,8119,8131,8153,8157,8165,8169,8171,8175,8177,8179,
8187,8189,8195,8199,8203,8205,8207,8209,8211,8213,8217,8219,8257,8261,8269,8271,
8273,8289,8293,8297,8299,8327,8329,8333,8335,8337,8351,8353,8355,8359,8361,8373,
8375,8377,8393,8399,8407,8409,8413,8423,8425,8429,8447,8451,8457,8467,8471,8473,
8475,8477,8481,8483,8487,8499,8501,8503,8511,8513,8515,8521,8523,8525,8529,8531,
8533,8535,8537,8543,8551,8553,8559,8561,8563,8565,8569,8571,8573,8575,8577,8579,
8581,8585,8587,8589,8593,8597,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,6466,0,7444,7446,7448,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6479,0,6482,0,
6485,0,6488,0,6491,0,6494,0,6497,0,6500,0,6503,0,6506,0,
6509,0,6512,0,0,6515,0,6518,0,6521,0,0,0,0,0,0,
6524,6527,0,6530,6533,0,6536,6539,0,6542,6545,0,6548,6551,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6476,0,0,0,0,0,0,99,102,0,6561,6554,
0,0,0,0,0,0,0,0,0,0,0,0,6640,0,6667,0,
6711,0,6737,0,6746,0,6762,0,6778,0,6788,0,6793,0,6806,0,
6811,0,6820,0,0,6827,0,6832,0,6840,0,0,0,0,0,0,
6868,6871,0,6895,6898,0,6919,6922,0,6948,6951,0,6985,6988,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6604,0,0,7137,7146,7151,7156,0,0,0,7165,6749,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,5502,5507,5706,5509,5708,5710,5514,5519,5521,5712,5714,5716,5718,5720,5722,
5600,5526,5531,5536,5610,5538,5543,5545,5553,5563,5565,5576,5581,5586,5591,5648,
5650,5652,5654,5656,5658,5660,5662,5664,5666,5668,5670,5672,5674,5676,5678,5680,
5682,5684,5686,5688,5646,5596,5598,5724,5726,5728,5730,5732,5734,5736,5602,5738,
5740,5604,5606,5608,5612,5614,5616,5618,5620,5622,5624,5626,5628,5630,5632,5634,
5636,5638,5742,5744,5640,5642,5644,5690,5692,5694,5696,5698,5700,5702,5704,0,
0,0,7278,7318,7284,7504,7286,7298,7288,7985,7308,7292,7280,7541,7510,7326,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
322,331,340,349,358,367,376,385,409,423,432,441,450,459,326,335,
344,353,362,371,380,389,413,427,436,445,454,463,418,394,402,0,
468,484,476,532,488,508,472,504,480,516,548,568,564,556,608,536,
544,560,552,580,524,572,600,584,512,492,528,540,576,496,604,520,
588,500,592,596,0,0,0,0,0,0,0,0,0,0,0,0,
1715,861,872,883,894,905,912,919,926,933,962,969,976,979,982,985,
5502,5509,5514,5521,5526,5531,5538,5545,5553,5565,5576,5581,5586,5591,5504,5511,
5516,5523,5528,5533,5540,5547,5555,5567,5578,5583,5588,5593,5570,5558,5550,0,
7278,7318,7284,7504,7320,7370,7282,7368,7310,7444,7772,7893,7843,7780,8413,7508,
7748,7794,7774,8063,7476,7933,8339,8073,7414,8095,7987,7551,8385,7352,7458,7851,
8489,7334,7378,7819,7286,7298,7288,7601,7474,7440,7565,7559,8023,7332,8343,7452,
7534,988,991,994,997,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053,1074,
835,951,1015,1063,1088,1102,1120,1134,1148,654,673,692,1427,2182,2179,1556,
6566,6589,6602,6613,6628,6638,6665,6709,6735,6744,6760,6776,6786,6791,6804,6809,
6818,6825,6830,6838,6849,6854,6856,6858,6860,6866,6893,6917,6946,6983,7015,7040,
7056,7058,7073,7077,7089,7097,7099,7101,7111,7122,7133,7135,7144,7149,7154,0,
6568,6573,6578,6583,6591,6596,6607,6615,6621,6630,6634,6643,6647,6652,6657,6661,
6697,6700,6670,6704,6675,6678,6684,6691,6725,6729,6714,6720,6740,6752,6756,6765,
6770,6781,6796,6800,6814,6835,6846,6843,6851,6862,6874,6883,6889,6878,6904,6910,
6914,6901,6925,6931,6940,6936,6954,6968,6971,6960,6975,6979,6964,7006,7002,6991,
7011,6994,6998,7017,7022,7026,7030,7034,7042,7047,7050,7060,7063,7068,7079,7083,
7091,7103,7108,7113,7117,7124,7127,7140,635,838,954,1018,1066,1091,1105,1123,
1137,1151,658,677,696,711,726,741,756,771,786,801,857,868,879,890,
901,2291,2136,1196,2072,2612,2682,2139,2142,2146,1466,7609,7755,7538,7750,7796,
2670,2562,3701,2496,2395,1527,1586,1387,2095,2412,2673,2565,3704,3713,2508,2417,
1430,2398,1589,1390,1794,3722,2548,2174,2452,2256,2577,3716,2515,2105,2420,2518,
2108,2533,2423,2522,2112,2536,2427,2551,2555,1719,2402,1593,1394,2698,2702,2708,
2685,2580,3719,2530,2676,2568,3707,2499,2406,1597,2679,2571,3710,2502,2409,1600,
2449,1612,2006,1253,2099,2102,1286,1267,2133,1398,2295,1424,2334,1530,1533,2431,
2460,2463,2466,2470,2505,2511,2526,1705,2665,1708,1712,2741,1764,1907,1901,1247,
832,948,1012,1060,1085,1099,1117,1131,1145,650,669,688,707,722,737,752,
767,782,797,853,864,875,886,897,908,915,922,929,936,965,972,2264,
8331,7770,8361,8345,7877,7300,7472,8593,8593,7547,8413,7488,7545,7686,8009,8163,
8255,8265,8281,8391,7807,7853,7899,7955,8235,8401,8517,7312,7460,7813,7911,8253,
8549,7593,7887,8245,8287,7700,8193,8267,7622,7776,7859,7941,8395,7338,7384,7422,
7720,7811,7909,8025,8171,8249,8259,8357,8463,8539,8547,8047,8079,8141,8229,8419,
8553,8309,7524,7636,8117,8185,7931,8051,8341,8461,7522,7581,7809,7865,7881,8137,
8149,8433,7420,8191,7390,7388,8097,8143,8233,8437,8323,7702,7807,8315,7304,7567,
7660,7949,7995,7434,8055,7344,7652,7290,7847,7730,8135,7466,7516,8031,8237,8301,
7829,8375,7845,7706,8223,7710,7993,7324,7366,7386,7801,8129,8215,8307,8411,7426,
7482,7551,7630,7742,7889,8057,8427,8519,8555,8567,7410,7766,7821,8371,7612,7682,
7688,7718,7885,7901,7967,8093,8145,8183,8363,8241,8381,8421,7402,7412,7484,7897,
8275,8301,7620,7658,7708,7825,8115,7945,7330,7506,7567,7595,7662,7953,7963,8167,
8181,8415,8459,8465,8493,7340,8087,8405,8449,7668,7316,7348,7569,7579,7736,7807,
7905,8007,8243,8389,8589,7760,8431,7408,7786,7790,7857,7871,7959,7991,8045,8133,
8497,7370,7692,8439,7346,7591,7867,8365,7650,7672,7792,7949,8443,7404,7478,7585,
7753,7782,7805,7849,7957,8001,8161,8277,8279,8409,8453,7442,7873,7480,7907,7969,
8247,8445,8541,8557,7788,7863,8197,8107,8111,8123,7939,7895,8321,7328,8225,7406,
7400,7618,7704,8127,7563,7855,7764,8369,8271,8435,8293,7626,7356,7494,0,0,
7514,0,7758,0,0,7392,7943,8019,8061,8075,8077,8085,8469,8125,8169,0,
8251,0,8313,0,0,8383,8397,0,0,0,8505,8507,8509,8545,0,0,
7342,7350,7360,7418,7424,7450,7492,7498,7500,7512,7518,7583,7587,7664,7678,7680,
7684,7726,7746,7762,7803,7861,7869,7883,7903,7915,7961,8049,8063,8067,8065,8069,
8071,8073,8081,8083,8099,8103,8113,8145,8147,8151,8159,8173,8201,8221,8221,8239,
8283,8295,8317,8319,8347,8349,8379,8383,8455,8485,8495,0,0,0,0,0,
7294,7382,7364,7336,7358,7372,7416,7430,7492,7486,7490,7496,7514,7520,7543,7549,
7553,7555,7624,7628,7646,7654,7666,7674,7670,7680,7676,7684,7694,7712,7714,7716,
7728,7758,7776,7778,7784,7823,7829,7857,7879,7875,7883,7891,7903,8037,7917,7937,
7943,7965,7975,7989,8003,8005,8019,8021,8029,8035,8033,8053,8105,8113,8121,8139,
8145,8155,8173,8227,8231,8263,8285,8291,8295,8303,8313,8305,8317,8315,8311,8319,
8325,8349,8367,8387,8403,8417,8441,8455,8469,8479,8485,8491,8495,8527,8593,8609,
8607,8611,7272,7274,7276,8613,8615,8617,8583,8591,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2239,2250,2253,2242,2246,3246,2744,0,0,0,0,0,0,0,0,0,
0,0,0,3998,3989,3992,4001,3995,0,0,0,0,0,4053,0,4122,
4086,4004,4031,4036,4062,4070,4075,4103,4117,616,4111,4114,8601,8604,4006,4009,
4012,4020,4028,4033,4038,4044,4047,0,4050,4056,4059,4064,4072,0,4077,0,
4080,4083,0,4088,4091,0,4097,4100,4105,4108,4119,4041,4023,4067,4094,4015,
5202,5202,5210,5210,5210,5210,5212,5212,5212,5212,5216,5216,5216,5216,5208,5208,
5208,5208,5214,5214,5214,5214,5206,5206,5206,5206,5238,5238,5238,5238,5240,5240,
5240,5240,5220,5220,5220,5220,5218,5218,5218,5218,5222,5222,5222,5222,5224,5224,
5224,5224,5230,5230,5228,5228,5232,5232,5226,5226,5236,5236,5234,5234,5242,5242,
5242,5242,5246,5246,5246,5246,5250,5250,5250,5250,5248,5248,5248,5248,5252,5252,
5254,5254,5254,5254,5258,5258,5260,5260,5260,5260,5256,5256,5256,5256,5284,5284,
5289,5289,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,5244,5244,5244,5244,5269,5269,5267,5267,5274,5274,5204,5278,5278,
5265,5265,5276,5276,5282,5282,5282,5282,5143,5143,4137,4137,4185,4185,4164,4164,
4176,4176,4173,4173,4179,4179,4182,4182,4182,4167,4167,4167,5280,5280,5280,5280,
4140,4143,4155,4167,4170,4217,4220,4227,4240,4249,4252,4259,4274,4285,4306,4335,
4338,4343,4352,4361,4364,4369,4389,4412,4419,4438,4441,4444,4479,4490,4497,4511,
4583,4632,4647,4650,4661,4671,4682,4685,4708,4713,4725,4748,4751,4804,4807,4810,
4817,4824,4827,4832,4839,4854,4857,4862,4865,4868,4871,4874,4877,4888,4891,4908,
4923,4938,4945,4959,4962,4970,4989,5009,5024,5031,5034,5039,5058,5073,5082,5099,
5102,5107,5110,5121,5124,5150,5157,5164,5173,5190,5193,4457,4467,5145,57,64,
71,78,85,92,4149,4152,4155,4158,4167,4170,4234,4237,4240,4243,4249,4252,
4300,4303,4306,4329,4335,4338,4346,4349,4352,4355,4361,4364,4824,4827,4854,4857,
4862,4874,4877,4888,4891,4945,4959,4962,4967,5024,5076,5079,5082,5093,5099,5102,
5145,5167,5170,5173,5184,5190,5193,4140,4143,4146,4155,4161,4217,4220,4227,4240,
4246,4259,4274,4285,4306,4332,4352,4369,4389,4412,4419,4438,4444,4479,4490,4497,
4511,4583,4594,4632,4647,4650,4661,4671,4682,4708,4713,4725,4748,4751,4804,4807,
4810,4817,4832,4839,4865,4868,4871,4874,4877,4908,4923,4938,4945,4956,4970,4989,
5009,5024,5039,5058,5073,5082,5096,5107,5110,5127,5150,5157,5164,5173,5187,4155,
4161,4240,4246,4306,4332,4352,4358,4511,4526,4561,4572,4874,4877,4945,5082,5096,
5173,5187,4778,4785,4792,4700,4703,4740,4743,4766,4769,4529,4532,4575,4578,4430,
4433,4404,4407,4447,4450,4639,4642,4674,4677,4537,4544,4555,4561,4558,4508,4597,
4668,4700,4703,4740,4743,4766,4769,4529,4532,4575,4578,4430,4433,4404,4407,4447,
4450,4639,4642,4674,4677,4537,4544,4555,4561,4558,4508,4597,4668,4537,4544,4555,
4561,4526,4572,4685,4479,4490,4497,4537,4544,4555,4685,4708,4200,4200,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4262,4277,4277,4281,4288,4309,4313,4317,4392,4392,4426,4422,4493,4482,4486,4518,
4518,4514,4522,4522,4586,4586,4635,4547,4547,4540,4564,4564,4568,4568,4653,4664,
4664,4688,4688,4692,4696,4716,4728,4728,4732,4754,4762,4758,4813,4813,4842,4846,
4926,4934,4930,4911,4911,4941,4941,4948,4948,4992,4996,5005,4973,4981,5012,5016,
0,0,4977,5113,5117,5061,5065,5046,5046,5050,5089,5085,5176,5176,4230,4270,
4266,4296,4292,4325,4321,4400,4372,4396,4500,4590,4551,4657,4919,4952,5160,5153,
5180,5027,4850,5069,4842,4926,4736,4884,5042,5020,4915,4880,4915,5042,4376,4415,
4985,4820,4223,4880,4716,4635,4504,5054,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4628,4835,4195,4190,5000,4600,4462,4720,5132,4605,4609,4380,4470,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
618,6442,6444,1154,1160,105,1184,6472,6474,6248,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6246,6244,6242,2000,2000,125,612,2963,2967,6468,6470,6462,6464,6450,6452,6446,
6448,6454,6456,6458,6460,0,0,1992,1996,6269,6269,6269,6269,2000,2000,2000,
618,6442,622,0,1160,1154,1184,105,6244,125,612,2963,2967,6468,6470,115,
121,614,616,620,1162,1179,1167,0,1994,117,119,1192,0,0,0,0,
51,4772,54,0,61,0,68,4775,75,4782,82,4789,89,4796,96,4799,
4125,4127,4127,4129,4129,4131,4131,4133,4133,4135,4135,4135,4135,4188,4188,4215,
4215,4215,4215,4255,4255,4257,4257,4257,4257,4341,4341,4341,4341,4367,4367,4367,
4367,4410,4410,4410,4410,4436,4436,4436,4436,4453,4453,4455,4455,4460,4460,4475,
4475,4477,4477,4477,4477,4535,4535,4535,4535,4581,4581,4581,4581,4645,4645,4645,
4645,4680,4680,4680,4680,4706,4706,4706,4706,4711,4711,4711,4711,4746,4746,4746,
4746,4802,4802,4802,4802,4830,4830,4830,4830,4860,4860,4860,4860,4894,4894,4894,
4894,4965,4965,4965,4965,5037,5037,5037,5037,5105,5105,5105,5105,5130,5130,5143,
5143,5148,5148,5148,5148,4896,4896,4899,4899,4902,4902,4905,4905,0,0,0,
0,105,113,115,117,119,121,123,125,612,614,616,618,620,622,631,
633,638,841,957,1021,1069,1094,1108,1126,1140,1154,1160,1162,1167,1179,1184,
1192,1194,1251,1265,1291,1323,1376,1385,1422,1454,1520,1525,1551,1584,1615,1653,
1703,1728,1730,1759,1788,1822,1881,1905,1928,1943,1972,1992,1994,1996,1998,2000,
2002,2004,2070,2085,2131,2177,2237,2262,2289,2322,2385,2393,2455,2494,2560,2610,
2663,2694,2696,2739,2768,2794,2853,2873,2896,2911,2943,2963,2965,2967,2969,6433,
6435,6444,6454,6456,6442,7161,7154,6564,6587,6600,6611,6626,7075,7087,7095,6823,
7163,6566,6589,6602,6613,6628,6638,6665,6709,6735,6744,6760,6776,6786,6791,6804,
6809,6818,6825,6830,6838,6849,6854,6856,6858,6860,6866,6893,6917,6946,6983,7015,
7040,7056,7058,7073,7077,7089,7097,7099,7101,7111,7122,7133,7135,7159,6557,6559,
7270,7168,7170,7172,7174,7176,7178,7180,7182,7184,7186,7188,7190,7192,7194,7196,
7198,7200,7202,7204,7206,7208,7210,7212,7214,7216,7218,7220,7222,7224,7226,0,
0,0,7228,7230,7232,7234,7236,7238,0,0,7240,7242,7244,7246,7248,7250,
0,0,7252,7254,7256,7258,7260,7262,0,0,7264,7266,7268,0,0,0,
2971,2973,2988,2990,2977,2975,6271,0,6427,6273,6278,6280,6285,6429,6431,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0};
static const guint16 helperIndex [] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1160,1164,1176,1181,0,
0,1199,1256,1271,1305,1325,1382,1401,1433,1475,1522,1525,1566,1603,1626,1655,
1722,0,1735,1767,1801,1824,1895,1910,1937,1945,1974,0,0,0,0,0,
2002,2022,2076,2116,2156,2186,2259,2268,2298,2343,2387,2434,2476,2539,2583,2615,
2688,0,2715,2747,2770,2796,2867,2875,2905,2913,2945,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2979,0,0,0,0,0,0,0,
0,0,0,0,2998,0,0,3000,0,0,0,0,0,0,0,0,
0,0,3002,0,3014,3017,3024,3030,0,0,3033,0,0,0,0,3045,
0,0,0,0,3048,3060,3069,0,3072,0,0,0,3075,0,0,0,
0,0,3087,0,3099,3102,3105,3111,0,0,3114,0,0,0,0,3126,
0,0,0,0,3131,3143,3152,0,3155,0,0,0,3158,0,0,0,
0,0,3170,3182,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3194,3200,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,3210,3216,0,0,
0,0,0,0,0,0,0,0,0,0,3222,3225,0,0,0,0,
3228,3231,0,0,0,0,0,0,3234,3237,3240,3243,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3249,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3256,3271,0,0,0,0,0,0,0,0,0,0,0,0,0,3288,
3303,0,0,0,0,0,0,3318,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,3321,3324,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3329,3332,3335,3338,0,0,0,0,3341,3344,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3421,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3430,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3435,3437,0,0,0,0,0,0,3439,0,0,0,0,0,0,0,
0,0,0,3442,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,3444,3446,0,3448,3450,3452,0,3454,0,3456,3458,
3460,3462,0,0,0,3485,0,3497,0,3514,0,0,0,0,0,3535,
0,3549,0,0,0,3556,0,0,0,3574,0,0,3591,3596,3598,3603,
3605,3607,0,0,0,3639,0,3651,0,3671,0,0,0,0,0,3725,
0,3741,0,0,0,3749,0,0,0,3777,3795,3804,3813,3815,3817,0,
0,0,3822,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3828,0,0,0,0,0,0,0,0,0,
3831,0,0,3837,0,3840,3849,3855,3858,0,3870,0,0,0,3873,0,
0,0,0,3876,0,0,0,3888,0,0,0,3891,0,3894,0,0,
3897,0,0,3903,0,3906,3915,3921,3924,0,3936,0,0,0,3941,0,
0,0,0,3944,0,0,0,3956,0,0,0,3959,0,3962,0,0,
0,0,0,0,0,0,3965,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,3968,3971,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,3974,3977,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,3980,3983,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4006,4020,4028,4033,4038,4041,4047,0,4050,4053,4059,4064,4072,0,4077,0,
4080,4083,0,4088,4091,0,4097,4100,4105,4108,4119,0,0,0,0,0,
0,0,4122,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4203,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5137,0,5196,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,5262,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,5286,0,0,5291,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,5294,5297,5300,0,0,0,0,5303,0,0,0,
0,5306,5309,0,0,0,0,0,5312,0,0,5315,0,0,0,5318,
5321,0,0,5324,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,5327,5330,0,0,0,0,0,0,0,0,0,0,0,0,5333,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,5336,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5342,5345,0,0,0,0,5348,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,5351,0,0,0,0,
0,0,5354,0,0,0,0,0,5357,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,5360,5363,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,5366,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,5375,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5378,5384,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5387,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5390,
0,0,0,0,0,0,5393,0,0,0,5402,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5405,5411,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,5414,0,0,5423,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5440,0,5443,0,0,0,0,0,0,0,0,0,5446,0,0,0,
0,5449,0,0,0,0,5452,0,0,0,0,5455,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,5458,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5467,0,5470,0,0,0,0,0,0,0,0,0,5473,0,0,0,
0,5476,0,0,0,0,5479,0,0,0,0,5482,0,0,0,0,
0,0,5485,5491,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,5497,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,5795,5798,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,5801,5804,0,0,0,0,
0,0,5807,5810,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5813,5819,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5825,5828,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5831,5834,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5837,5849,5861,5864,5867,5870,5873,5876,5879,5891,5903,5906,5909,5912,5915,5918,
5921,5927,0,0,0,0,0,0,5933,5939,0,0,0,0,0,0,
5945,5957,5969,5972,5975,5978,5981,5984,5987,5999,6011,6014,6017,6020,6023,6026,
6029,6038,0,0,0,0,0,0,6047,6056,0,0,0,0,0,0,
6065,6071,0,0,0,0,0,0,6077,6083,0,0,0,0,0,0,
6089,6098,0,0,0,0,0,0,0,6107,0,0,0,0,0,0,
6116,6128,6140,6143,6146,6149,6152,6155,6158,6170,6182,6185,6188,6191,6194,6197,
6200,0,0,0,6203,0,0,0,0,0,0,0,6206,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,6209,0,0,0,0,0,0,0,0,6212,
0,0,0,0,0,0,6221,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,6224,0,0,0,0,0,0,0,6227,0,
0,0,6236,6238,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6275,0,6282,0,6287,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6290,0,6293,0,6296,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,6299,0,0,0,0,6302,0,0,6305,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,6312,0,6315,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6337,0,0,0,
0,0,0,6340,0,6343,0,0,6346,0,0,0,0,6349,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,6352,0,0,6355,6358,0,0,0,0,0,0,0,0,0,0,
0,0,6361,6364,0,0,6367,6370,0,0,6373,6376,6379,6382,0,0,
0,0,6385,6388,0,0,6391,6394,0,0,0,0,0,0,0,0,
0,6397,6400,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,6403,0,0,0,0,0,6406,6409,0,6412,0,0,0,0,
0,0,6415,6418,6421,6424,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,6446,6448,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,6476,0,0,0,0,6479,0,6482,0,6485,
0,6488,0,6491,0,6494,0,6497,0,6500,0,6503,0,6506,0,6509,
0,6512,0,0,6515,0,6518,0,6521,0,0,0,0,0,0,6524,
0,0,6530,0,0,6536,0,0,6542,0,0,6548,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,6561,0,0,
0,0,0,0,0,0,6604,0,0,0,0,6640,0,6667,0,6711,
0,6737,0,6746,0,6762,0,6778,0,6788,0,6793,0,6806,0,6811,
0,6820,0,0,6827,0,6832,0,6840,0,0,0,0,0,0,6868,
0,0,6895,0,0,6919,0,0,6948,0,0,6985,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7137,
7146,7151,7156,0,0,0,0,0,0,0,0,0,0,7165,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,7272,0,0,
0,0,0,0,0,0,0,0,7274,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,7290,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,7294,0,0,0,0,0,0,0,0,0,
0,0,7300,0,0,0,0,0,0,7304,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7312,0,0,0,7316,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7324,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7328,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7330,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7336,0,0,0,0,0,7338,0,0,0,0,7340,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7342,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7344,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7346,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7348,0,0,0,0,0,
0,0,0,0,0,0,0,7350,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7356,0,0,0,0,7358,0,0,0,0,0,0,0,7360,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7364,7366,0,0,0,7370,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7372,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7382,0,7384,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7386,0,0,7388,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7390,0,7392,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7400,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7402,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7404,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7406,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7408,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7410,0,0,0,0,
0,0,0,7412,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7416,0,7418,0,0,0,0,0,0,
0,0,7420,0,0,0,0,0,0,0,0,0,0,0,7422,0,
0,0,0,0,7424,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7426,0,0,0,0,7430,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7434,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7442,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,7450,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7460,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7466,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7472,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7478,
0,0,0,0,0,0,0,0,0,0,0,0,0,7480,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7482,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,7484,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7486,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7488,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7490,0,0,0,7492,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7494,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7496,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,7498,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7500,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7506,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7512,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7514,0,0,0,7516,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7518,0,0,0,0,0,0,0,
0,0,0,7520,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7522,0,0,0,0,0,0,7524,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7543,0,0,0,7545,0,0,0,0,0,0,0,
0,7547,0,0,7549,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7551,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7553,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7555,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7563,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7567,0,0,0,0,0,0,7569,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7579,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7581,0,7583,7585,0,0,0,0,0,0,0,0,7587,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7591,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7593,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7595,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7612,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,7618,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7620,7622,0,0,0,0,0,
0,0,7624,7626,0,0,0,0,0,7628,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7630,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7636,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7646,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7650,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7652,0,0,0,7654,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7658,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7660,0,0,0,0,0,0,0,0,0,7662,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7664,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7666,0,0,0,0,0,0,0,
0,7668,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7670,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7672,0,0,0,0,0,0,0,0,0,7674,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7676,0,0,0,0,0,0,0,7678,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7680,0,
7682,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7684,0,0,0,7686,0,0,0,0,0,0,0,0,0,
7688,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7692,0,
0,0,0,0,7694,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7700,0,0,0,0,0,7702,
0,0,0,7704,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7706,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7708,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7710,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7712,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7714,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7716,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7718,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7720,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7726,
0,0,0,0,0,0,7728,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7730,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7736,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7742,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7746,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7753,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7758,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7760,0,0,0,0,0,0,0,
0,7762,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7764,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,7766,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7770,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7776,0,0,0,7778,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7782,0,
0,0,0,0,0,0,7784,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7786,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7788,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7790,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7792,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,7801,0,0,0,7803,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7805,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7807,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7809,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7811,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,7813,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7821,0,7823,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7825,0,
0,0,0,0,0,0,0,0,0,0,7829,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7845,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7847,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7849,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7853,0,0,7855,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,7857,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7859,0,0,0,0,0,
0,0,0,0,0,0,0,7861,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7863,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7865,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7867,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7869,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7871,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7873,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7875,0,0,0,0,
0,7877,0,0,0,0,0,0,0,0,0,7879,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7881,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7883,7885,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7887,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7889,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7891,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7895,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7897,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7899,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7901,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7903,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7905,0,
7907,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7909,0,0,0,0,0,0,0,0,0,0,7911,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7915,0,0,0,0,
0,0,0,0,0,7917,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7931,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7937,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7939,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7941,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7943,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7945,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7949,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7953,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,7955,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,7957,0,0,7959,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7961,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7963,0,0,0,0,0,0,
0,7965,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7967,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,7969,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,7975,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7989,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7991,0,0,0,0,0,0,
0,0,0,0,0,7993,0,0,0,0,0,0,0,0,0,0,
7995,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8001,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8003,0,8005,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8007,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8009,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8019,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8021,0,0,0,0,
0,0,0,0,0,0,0,8025,0,0,0,0,0,0,0,0,
0,0,0,0,8029,0,0,0,0,0,0,0,0,0,0,0,
0,8031,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8033,0,0,0,0,0,0,0,0,0,8035,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,8037,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8045,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,8047,0,0,0,
0,8049,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8051,0,8053,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8055,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8057,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,8061,0,8063,0,
0,0,0,0,0,0,0,0,8065,8067,0,0,0,0,0,0,
8069,0,0,0,0,0,8071,0,0,0,0,0,0,8073,8075,0,
0,0,0,0,0,8077,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8079,
0,0,0,0,0,0,0,0,0,0,0,0,0,8081,8083,8085,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8087,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8093,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,8097,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8099,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8107,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8113,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8115,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8117,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8121,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8123,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8125,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8127,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,8129,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8133,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8135,0,0,0,0,0,0,0,0,0,0,0,0,8137,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8139,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8141,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8143,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8145,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8147,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,8149,0,0,0,0,0,0,0,0,
0,8151,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8155,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8159,0,0,0,0,0,0,8161,0,0,0,0,0,0,
0,0,0,0,0,8163,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8167,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8169,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8171,0,0,0,8173,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8181,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8183,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8185,0,
0,0,0,0,0,0,0,0,0,0,0,8191,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8193,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8197,0,0,0,0,8201,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8215,
0,0,0,0,0,0,0,0,0,8221,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,8223,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8225,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8227,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8229,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8231,
0,8233,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8235,0,0,
0,0,0,0,0,0,0,0,0,8237,0,0,0,0,0,0,
0,0,0,0,0,0,0,8239,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8241,0,
0,0,0,0,0,0,0,0,0,0,0,0,8243,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8245,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8247,0,0,0,0,0,
0,0,0,0,0,0,8249,0,0,0,0,0,0,0,0,0,
0,0,8251,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8253,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8255,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,8259,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8263,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8265,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8267,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,8271,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8275,0,0,0,0,0,0,0,0,0,0,0,0,8277,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8279,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8281,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8283,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8285,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8287,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8291,0,0,0,0,8293,0,0,0,0,
0,0,0,0,0,0,8295,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8301,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8303,
0,0,0,0,0,0,0,0,0,0,0,8305,0,0,0,0,
0,0,8307,0,0,0,8309,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8311,0,0,
0,0,0,0,0,0,0,0,8313,0,0,0,0,0,8315,0,
0,8317,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8319,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8321,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8323,0,0,0,0,0,0,0,0,0,8325,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8331,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8341,0,0,0,0,0,8345,0,0,0,0,0,0,0,
0,0,0,8347,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8349,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8357,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8361,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8363,0,0,0,8365,0,0,0,0,0,
0,0,0,0,0,0,0,0,8367,0,0,8369,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8371,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
8375,0,0,0,0,0,8379,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8381,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8383,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8387,0,0,0,0,0,0,0,0,0,8389,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8391,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8395,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8397,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8401,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8403,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8405,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,8409,0,0,8411,
0,8413,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8415,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8417,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8419,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8421,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8427,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8431,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8433,0,8435,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,8437,0,0,8439,0,0,0,8441,0,0,0,
0,0,0,0,0,0,8443,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8445,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8449,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8453,8455,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,8459,8461,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8463,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8465,0,0,0,0,0,0,0,
0,0,0,0,0,0,8469,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8479,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8485,
0,0,0,0,0,0,0,0,0,0,0,8491,0,0,0,0,
0,0,0,0,0,0,0,0,8493,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,8495,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8497,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8505,
0,0,0,0,0,0,0,0,0,0,0,0,8507,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,8509,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8517,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8519,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,8527,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8539,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,8541,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8545,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,8547,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8549,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8553,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,8555,0,0,0,0,0,0,0,8557,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,8567,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8583,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8589,8591,0,
0,0,0,0,0,0,0,0,0,0,0,0,8593,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,8601,0,0,0,0,0,0,
0};
static const guint16 mapIdxToComposite [] = {
0,0,0,0,0,0,0,0,894,0,0,0,8814,0,0,0,
0,0,0,0,0,0,0,0,8800,0,0,0,0,8815,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,
0,0,193,0,0,194,0,0,195,0,0,256,0,0,258,0,
0,550,0,0,196,0,0,7842,0,0,197,0,0,461,0,0,
512,0,0,514,0,0,7840,0,0,7680,0,0,260,0,0,0,
0,0,0,0,0,0,0,0,7682,0,0,7684,0,0,7686,0,
0,0,0,0,0,0,0,262,0,0,264,0,0,266,0,0,
268,0,0,199,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7690,0,0,270,0,0,7692,
0,0,7696,0,0,7698,0,0,7694,0,0,0,0,200,0,0,
201,0,0,202,0,0,7868,0,0,274,0,0,276,0,0,278,
0,0,203,0,0,7866,0,0,282,0,0,516,0,0,518,0,
0,7864,0,0,552,0,0,280,0,0,7704,0,0,7706,0,0,
0,0,0,0,0,0,7710,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,500,0,0,284,0,0,7712,
0,0,286,0,0,288,0,0,486,0,0,290,0,0,0,0,
0,0,0,0,0,0,0,0,0,292,0,0,7714,0,0,7718,
0,0,542,0,0,7716,0,0,7720,0,0,7722,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,204,0,0,205,0,0,206,0,0,296,0,0,298,
0,0,300,0,0,304,0,0,207,0,0,7880,0,0,463,0,
0,520,0,0,522,0,0,7882,0,0,302,0,0,7724,0,0,
0,0,308,0,0,8490,0,0,0,0,0,0,0,0,0,0,
7728,0,0,488,0,0,7730,0,0,310,0,0,7732,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,313,0,
0,317,0,0,7734,0,0,315,0,0,7740,0,0,7738,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7742,0,0,7744,0,0,7746,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,504,0,0,323,0,0,
209,0,0,7748,0,0,327,0,0,7750,0,0,325,0,0,7754,
0,0,7752,0,0,0,0,210,0,0,211,0,0,212,0,0,
213,0,0,332,0,0,334,0,0,558,0,0,214,0,0,7886,
0,0,336,0,0,465,0,0,524,0,0,526,0,0,416,0,
0,7884,0,0,490,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,7764,0,0,7766,0,0,
0,0,0,0,0,0,0,340,0,0,7768,0,0,344,0,0,
528,0,0,530,0,0,7770,0,0,342,0,0,7774,0,0,0,
0,0,0,0,0,0,0,346,0,0,348,0,0,7776,0,0,
352,0,0,7778,0,0,536,0,0,350,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,7786,0,0,356,0,0,7788,
0,0,538,0,0,354,0,0,7792,0,0,7790,0,0,0,0,
217,0,0,218,0,0,219,0,0,360,0,0,362,0,0,364,
0,0,220,0,0,7910,0,0,366,0,0,368,0,0,467,0,
0,532,0,0,534,0,0,431,0,0,7908,0,0,7794,0,0,
370,0,0,7798,0,0,7796,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7804,0,0,7806,0,0,0,0,0,
0,0,0,0,0,0,7808,0,0,7810,0,0,372,0,0,7814,
0,0,7812,0,0,7816,0,0,0,0,0,0,0,0,0,0,
0,7818,0,0,7820,0,0,0,0,7922,0,0,221,0,0,374,
0,0,7928,0,0,562,0,0,7822,0,0,376,0,0,7926,0,
0,7924,0,0,0,0,377,0,0,7824,0,0,379,0,0,381,
0,0,7826,0,0,7828,0,0,0,0,0,0,0,0,0,0,
0,0,8175,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,224,0,0,225,0,0,226,0,0,227,
0,0,257,0,0,259,0,0,551,0,0,228,0,0,7843,0,
0,229,0,0,462,0,0,513,0,0,515,0,0,7841,0,0,
7681,0,0,261,0,0,0,0,0,0,0,0,7683,0,0,7685,
0,0,7687,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,263,0,0,265,0,0,267,0,0,269,0,0,
231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7691,0,0,271,
0,0,7693,0,0,7697,0,0,7699,0,0,7695,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,232,0,0,233,0,0,
234,0,0,7869,0,0,275,0,0,277,0,0,279,0,0,235,
0,0,7867,0,0,283,0,0,517,0,0,519,0,0,7865,0,
0,553,0,0,281,0,0,7705,0,0,7707,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7711,0,0,0,0,0,0,0,0,501,0,0,285,
0,0,7713,0,0,287,0,0,289,0,0,487,0,0,291,0,
0,0,0,0,0,0,0,0,0,0,293,0,0,7715,0,0,
7719,0,0,543,0,0,7717,0,0,7721,0,0,7723,0,0,7830,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,236,0,0,237,0,0,238,0,0,
297,0,0,299,0,0,301,0,0,239,0,0,7881,0,0,464,
0,0,521,0,0,523,0,0,7883,0,0,303,0,0,7725,0,
0,0,0,309,0,0,496,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,7729,0,0,489,0,0,7731,0,0,311,0,0,7733,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,314,0,0,318,
0,0,7735,0,0,316,0,0,7741,0,0,7739,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,7743,0,0,7745,0,
0,7747,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,505,0,0,324,0,0,241,0,0,
7749,0,0,328,0,0,7751,0,0,326,0,0,7755,0,0,7753,
0,0,0,0,0,0,0,242,0,0,243,0,0,244,0,0,
245,0,0,333,0,0,335,0,0,559,0,0,246,0,0,7887,
0,0,337,0,0,466,0,0,525,0,0,527,0,0,417,0,
0,7885,0,0,491,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
7765,0,0,7767,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,341,0,0,7769,0,
0,345,0,0,529,0,0,531,0,0,7771,0,0,343,0,0,
7775,0,0,0,0,0,0,0,0,0,0,347,0,0,349,0,
0,7777,0,0,353,0,0,7779,0,0,537,0,0,351,0,0,
0,0,7787,0,0,7831,0,0,357,0,0,7789,0,0,539,0,
0,355,0,0,7793,0,0,7791,0,0,0,0,249,0,0,250,
0,0,251,0,0,361,0,0,363,0,0,365,0,0,252,0,
0,7911,0,0,367,0,0,369,0,0,468,0,0,533,0,0,
535,0,0,432,0,0,7909,0,0,7795,0,0,371,0,0,7799,
0,0,7797,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7805,0,0,7807,0,0,0,0,7809,0,0,7811,0,
0,373,0,0,7815,0,0,7813,0,0,7832,0,0,7817,0,0,
0,0,0,0,0,0,0,0,0,7819,0,0,7821,0,0,0,
0,7923,0,0,253,0,0,375,0,0,7929,0,0,563,0,0,
7823,0,0,255,0,0,7927,0,0,7833,0,0,7925,0,0,0,
0,378,0,0,7825,0,0,380,0,0,382,0,0,7827,0,0,
7829,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8173,0,0,901,0,0,8129,0,0,0,0,0,0,
0,0,0,0,0,0,8189,0,903,0,7846,0,0,7844,0,0,
7850,0,0,7848,0,0,478,0,0,8491,0,506,0,0,0,0,
508,0,0,482,0,0,7688,0,0,7872,0,0,7870,0,0,7876,
0,0,7874,0,0,7726,0,0,7890,0,0,7888,0,0,7894,0,
0,7892,0,0,7756,0,0,556,0,0,7758,0,0,554,0,0,
510,0,0,475,0,0,471,0,0,469,0,0,473,0,0,7847,
0,0,7845,0,0,7851,0,0,7849,0,0,479,0,0,507,0,
0,509,0,0,483,0,0,7689,0,0,7873,0,0,7871,0,0,
7877,0,0,7875,0,0,7727,0,0,0,0,7891,0,0,7889,0,
0,7895,0,0,7893,0,0,7757,0,0,557,0,0,7759,0,0,
555,0,0,511,0,0,476,0,0,472,0,0,470,0,0,474,
0,0,7856,0,0,7854,0,0,7860,0,0,7858,0,0,7857,0,
0,7855,0,0,7861,0,0,7859,0,0,7700,0,0,7702,0,0,
7701,0,0,7703,0,0,0,0,0,0,7760,0,0,7762,0,0,
7761,0,0,7763,0,0,7780,0,0,7781,0,0,7782,0,0,7783,
0,0,7800,0,0,7801,0,0,7802,0,0,7803,0,0,0,0,
0,7835,0,0,0,0,0,0,7900,0,0,7898,0,0,7904,0,
0,7902,0,0,7906,0,0,7901,0,0,7899,0,0,7905,0,0,
7903,0,0,7907,0,0,0,0,7914,0,0,7912,0,0,7918,0,
0,7916,0,0,7920,0,0,7915,0,0,7913,0,0,7919,0,0,
7917,0,0,7921,0,0,494,0,0,492,0,0,493,0,0,0,
0,480,0,0,481,0,0,7708,0,0,7709,0,0,560,0,0,
561,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,495,0,0,
0,0,0,0,0,0,884,0,0,0,0,832,0,833,0,836,
0,0,835,0,8174,0,8123,0,8137,0,8139,0,8155,0,8185,0,
8171,0,8187,0,8147,0,8122,0,0,902,0,0,8121,0,0,8120,
0,0,7944,0,0,7945,0,0,8124,0,0,0,0,8136,0,0,
904,0,0,7960,0,0,7961,0,0,8138,0,0,905,0,0,7976,
0,0,7977,0,0,8140,0,0,0,0,8154,0,0,906,0,0,
8153,0,0,8152,0,0,938,0,0,7992,0,0,7993,0,0,8184,
0,0,908,0,0,8008,0,0,8009,0,0,0,0,8172,0,0,
0,0,0,0,8170,0,0,910,0,0,8169,0,0,8168,0,0,
939,0,0,8025,0,0,8486,0,8186,0,0,911,0,0,8040,0,
0,8041,0,0,8188,0,0,8049,0,8116,0,0,8051,0,8053,0,
8132,0,0,8055,0,8163,0,8048,0,0,940,0,0,8113,0,0,
8112,0,0,7936,0,0,7937,0,0,8118,0,0,8115,0,0,0,
0,0,0,0,0,0,0,8050,0,0,941,0,0,7952,0,0,
7953,0,0,8052,0,0,942,0,0,7968,0,0,7969,0,0,8134,
0,0,8131,0,0,0,0,8126,0,8054,0,0,943,0,0,8145,
0,0,8144,0,0,970,0,0,7984,0,0,7985,0,0,8150,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,8056,0,0,
972,0,0,8000,0,0,8001,0,0,0,0,0,0,8164,0,0,
8165,0,0,0,0,8058,0,0,973,0,0,8161,0,0,8160,0,
0,971,0,0,8016,0,0,8017,0,0,8166,0,0,0,0,0,
0,8060,0,0,974,0,0,8032,0,0,8033,0,0,8182,0,0,
8179,0,0,8146,0,0,912,0,0,8151,0,0,8162,0,0,944,
0,0,8167,0,0,8057,0,8059,0,8061,0,8180,0,0,979,0,
0,980,0,0,1031,0,0,1232,0,0,1234,0,0,1027,0,0,
1024,0,0,1238,0,0,1025,0,0,1217,0,0,1244,0,0,1246,
0,0,1037,0,0,1250,0,0,1049,0,0,1252,0,0,1036,0,
0,1254,0,0,1262,0,0,1038,0,0,1264,0,0,1266,0,0,
1268,0,0,1272,0,0,1260,0,0,1233,0,0,1235,0,0,1107,
0,0,1104,0,0,1239,0,0,1105,0,0,1218,0,0,1245,0,
0,1247,0,0,1117,0,0,1251,0,0,1081,0,0,1253,0,0,
1116,0,0,0,0,1255,0,0,1263,0,0,1118,0,0,1265,0,
0,1267,0,0,1269,0,0,1273,0,0,1261,0,0,1111,0,0,
1142,0,0,1143,0,0,1242,0,0,1243,0,0,1258,0,0,1259,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,64302,0,0,64303,0,0,64304,0,0,0,
0,0,0,0,64305,0,0,64332,0,0,0,0,64306,0,0,0,
0,64307,0,0,0,0,64308,0,0,64331,0,0,64309,0,0,64310,
0,0,64312,0,0,64285,0,0,64313,0,0,64314,0,0,0,0,
64315,0,0,64333,0,0,0,0,64316,0,0,0,0,64318,0,0,
64320,0,0,64321,0,0,0,0,64323,0,0,64324,0,0,64334,0,
0,64326,0,0,64327,0,0,0,0,64328,0,0,64329,0,0,64298,
0,0,64299,0,0,0,0,64330,0,0,64287,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1570,0,0,1571,0,
0,1573,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1572,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1574,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1730,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1747,0,0,0,0,1728,0,0,2392,0,
0,2393,0,0,2394,0,0,2395,0,0,2396,0,0,2397,0,0,
2345,0,0,2398,0,0,2399,0,0,2353,0,0,2356,0,0,2524,
0,0,2525,0,0,2527,0,0,2507,0,0,2508,0,0,2649,0,
0,2650,0,0,2651,0,0,2654,0,0,2611,0,0,2614,0,0,
2908,0,0,2909,0,0,2891,0,0,2888,0,0,2892,0,0,2964,
0,0,3018,0,0,3020,0,0,3019,0,0,3144,0,0,3264,0,
0,3274,0,0,3271,0,0,3272,0,0,3275,0,0,3402,0,0,
3404,0,0,3403,0,0,3546,0,0,3548,0,0,3550,0,0,3549,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3945,0,0,3907,0,0,3917,0,0,3922,0,0,3927,0,0,3932,
0,0,3955,0,0,3957,0,0,3969,0,0,4025,0,0,3987,0,
0,3997,0,0,4002,0,0,4007,0,0,4012,0,0,3958,0,0,
0,0,0,3960,0,0,0,0,0,4134,0,0,0,0,0,0,
0,0,6918,0,0,6920,0,0,6922,0,0,6924,0,0,6926,0,
0,6930,0,0,6971,0,0,6973,0,0,6976,0,0,6977,0,0,
6979,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,7736,0,0,7737,0,0,7772,0,0,7773,0,0,7784,
0,0,7785,0,0,7852,0,0,7862,0,0,7853,0,0,7863,0,
0,7878,0,0,7879,0,0,7896,0,0,7897,0,0,7938,0,0,
7940,0,0,7942,0,0,8064,0,0,7939,0,0,7941,0,0,7943,
0,0,8065,0,0,8066,0,0,8067,0,0,8068,0,0,8069,0,
0,8070,0,0,8071,0,0,7946,0,0,7948,0,0,7950,0,0,
8072,0,0,7947,0,0,7949,0,0,7951,0,0,8073,0,0,8074,
0,0,8075,0,0,8076,0,0,8077,0,0,8078,0,0,8079,0,
0,7954,0,0,7956,0,0,7955,0,0,7957,0,0,7962,0,0,
7964,0,0,7963,0,0,7965,0,0,7970,0,0,7972,0,0,7974,
0,0,8080,0,0,7971,0,0,7973,0,0,7975,0,0,8081,0,
0,8082,0,0,8083,0,0,8084,0,0,8085,0,0,8086,0,0,
8087,0,0,7978,0,0,7980,0,0,7982,0,0,8088,0,0,7979,
0,0,7981,0,0,7983,0,0,8089,0,0,8090,0,0,8091,0,
0,8092,0,0,8093,0,0,8094,0,0,8095,0,0,7986,0,0,
7988,0,0,7990,0,0,7987,0,0,7989,0,0,7991,0,0,7994,
0,0,7996,0,0,7998,0,0,7995,0,0,7997,0,0,7999,0,
0,8002,0,0,8004,0,0,8003,0,0,8005,0,0,8010,0,0,
8012,0,0,8011,0,0,8013,0,0,8018,0,0,8020,0,0,8022,
0,0,8019,0,0,8021,0,0,8023,0,0,8027,0,0,8029,0,
0,8031,0,0,8034,0,0,8036,0,0,8038,0,0,8096,0,0,
8035,0,0,8037,0,0,8039,0,0,8097,0,0,8098,0,0,8099,
0,0,8100,0,0,8101,0,0,8102,0,0,8103,0,0,8042,0,
0,8044,0,0,8046,0,0,8104,0,0,8043,0,0,8045,0,0,
8047,0,0,8105,0,0,8106,0,0,8107,0,0,8108,0,0,8109,
0,0,8110,0,0,8111,0,0,8114,0,0,8130,0,0,8178,0,
0,8119,0,0,8141,0,0,8142,0,0,8143,0,0,8135,0,0,
8183,0,0,8157,0,0,8158,0,0,8159,0,0,8192,0,8193,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8602,0,0,0,0,0,0,8603,0,0,0,0,8622,
0,0,8653,0,0,8655,0,0,8654,0,0,8708,0,0,8713,0,
0,8716,0,0,0,0,0,0,8740,0,0,8742,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,8769,0,0,8772,0,0,8775,0,0,8777,0,0,8813,0,0,
8802,0,0,8816,0,0,8817,0,0,8820,0,0,8821,0,0,8824,
0,0,8825,0,0,8832,0,0,8833,0,0,8928,0,0,8929,0,
0,8836,0,0,8837,0,0,8840,0,0,8841,0,0,8930,0,0,
8931,0,0,8876,0,0,8877,0,0,8878,0,0,8879,0,0,8938,
0,0,8939,0,0,8940,0,0,8941,0,0,0,0,0,0,0,
0,0,0,0,0,10972,0,0,0,0,0,0,0,0,9001,0,
9002,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,12436,0,0,12364,
0,0,12366,0,0,12368,0,0,12370,0,0,12372,0,0,12374,0,
0,12376,0,0,12378,0,0,12380,0,0,12382,0,0,12384,0,0,
12386,0,0,12389,0,0,12391,0,0,12393,0,0,12400,0,0,12401,
0,0,12403,0,0,12404,0,0,12406,0,0,12407,0,0,12409,0,
0,12410,0,0,12412,0,0,12413,0,0,0,0,0,0,0,0,
0,12446,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,12532,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
12460,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,12462,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,12464,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,12466,0,0,0,0,0,0,0,0,12468,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,12470,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,12472,0,0,0,0,0,
0,0,0,0,12474,0,0,0,0,12476,0,0,0,0,0,0,
0,0,0,0,0,0,12478,0,0,0,0,12480,0,0,0,0,
0,0,0,0,12482,0,0,0,0,0,0,12485,0,0,0,0,
12487,0,0,0,0,0,0,0,12489,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,12496,0,0,12497,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12499,
0,0,12500,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,12502,0,0,12503,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,12505,0,0,12506,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,12508,0,0,12509,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,12535,0,0,0,0,0,0,0,0,12536,0,0,0,0,12537,
0,0,0,0,12538,0,0,0,0,0,0,0,0,12542,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,64210,0,64211,0,64212,0,0,0,
0,0,0,0,0,0,0,0,0,0,63847,0,0,0,64112,0,
0,0,0,0,63749,0,0,0,63838,0,0,0,0,0,0,0,
63771,0,0,0,63930,0,0,0,0,0,0,0,63863,0,0,0,
63997,0,63912,0,0,0,0,0,64115,0,63789,0,63925,0,64048,0,
63845,0,63956,0,63931,0,64049,0,0,0,0,0,64012,0,64116,0,
64050,0,0,0,64114,0,63864,0,0,0,63953,0,64117,0,0,0,
0,0,0,0,0,0,64113,0,63790,0,63865,0,63829,0,63828,0,
64021,0,0,0,0,0,0,0,64000,0,63900,0,63965,0,63999,0,
63943,0,63882,0,63901,0,0,0,64118,0,64051,0,63826,0,63791,0,
64052,0,63871,0,0,0,64119,0,0,0,63843,0,0,0,0,0,
0,0,63979,0,0,0,0,0,0,0,64053,0,0,0,0,0,
0,0,0,0,63772,0,0,0,0,0,63851,0,0,0,0,0,
63750,0,0,0,0,0,63966,0,63981,0,63872,0,63902,0,64121,0,
63755,0,64122,0,64054,0,64013,0,64123,0,64055,0,64056,0,0,0,
0,0,63913,0,0,0,0,0,64057,0,64124,0,63852,0,64058,0,
64125,0,63818,0,63810,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,64126,0,63756,0,63753,0,64127,0,63873,
0,64128,0,64129,0,0,0,0,0,0,0,64004,0,0,0,63914,
0,63932,0,0,0,0,0,0,0,0,0,63933,0,63819,0,64059,
0,63967,0,64060,0,0,0,63957,0,63777,0,63915,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,63886,0,0,0,
0,0,64001,0,63906,0,63784,0,64130,0,64011,0,64131,0,63874,0,
0,0,0,0,63811,0,0,0,0,0,0,0,0,0,64132,0,
0,0,63960,0,63846,0,64133,0,0,0,63907,0,63840,0,63916,0,
64061,0,64134,0,63929,0,64136,0,63961,0,64135,0,64138,0,64062,0,
64063,0,63887,0,64139,0,63757,0,63888,0,0,0,63954,0,64140,0,
0,0,0,0,63781,0,63835,0,64002,0,63859,0,63908,0,63861,0,
64141,0,64142,0,64143,0,63889,0,63792,0,0,0,0,0,64065,0,
64144,0,63849,0,0,0,0,0,63934,0,0,0,0,0,63875,0,
0,0,64066,0,0,0,0,0,0,63968,0,0,0,0,64018,0,
63941,0,64067,0,64006,0,63883,0,0,0,63745,0,0,0,0,0,
64146,0,64147,0,0,0,63969,0,64148,0,63944,0,63988,0,63945,0,
63962,0,0,0,0,0,0,0,0,63866,0,64068,0,63970,0,63764,
0,63820,0,63793,0,63773,0,0,0,0,0,0,0,63884,0,64149,
0,63909,0,0,0,64150,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,63858,0,63848,0,63971,0,0,0,63765,0,64005,
0,64151,0,63786,0,64069,0,63989,0,63821,0,63958,0,64070,0,63947,
0,63980,0,64153,0,63748,0,64152,0,63822,0,64071,0,63890,0,63778,
0,63876,0,64155,0,0,0,63995,0,63903,0,63766,0,63891,0,64072,
0,63936,0,63982,0,63794,0,63774,0,0,0,64073,0,64158,0,0,
0,0,0,0,0,0,0,0,0,0,0,63814,0,0,0,0,
0,64159,0,63994,0,63787,0,64022,0,63911,0,0,0,63963,0,0,
0,63917,0,63767,0,63972,0,63948,0,64074,0,63918,0,64161,0,63892,
0,63983,0,0,0,0,0,64162,0,0,0,0,0,0,0,0,
0,0,0,0,0,64163,0,63949,0,63862,0,63842,0,0,0,0,
0,63973,0,64164,0,64165,0,63937,0,63758,0,0,0,0,0,0,
0,0,0,64166,0,64167,0,0,0,63795,0,0,0,64168,0,63853,
0,64170,0,64169,0,64157,0,0,0,0,0,0,0,63950,0,63803,
0,64075,0,63815,0,64171,0,63844,0,63877,0,0,0,64024,0,64076,
0,64078,0,64077,0,64079,0,64080,0,64081,0,64025,0,64026,0,63804,
0,64082,0,64083,0,64027,0,63926,0,0,0,0,0,63893,0,0,
0,63830,0,64084,0,0,0,64085,0,64172,0,63991,0,0,0,63992,
0,64086,0,63910,0,63812,0,0,0,64174,0,63993,0,64029,0,64003,
0,63867,0,0,0,63951,0,63850,0,63823,0,64175,0,63805,0,63831,
0,64087,0,64088,0,63824,0,64089,0,0,0,64177,0,0,0,64090,
0,63974,0,63759,0,0,0,63919,0,64030,0,63796,0,64178,0,0,
0,0,0,0,0,63920,0,63895,0,63813,0,0,0,0,0,63827,
0,63782,0,0,0,63990,0,0,0,64092,0,0,0,0,0,0,
0,0,0,0,0,0,0,63868,0,0,0,0,0,64093,0,63860,
0,63998,0,64179,0,63806,0,64180,0,63832,0,63768,0,63854,0,64095,
0,63897,0,63938,0,63779,0,63984,0,63797,0,64032,0,63775,0,63760,
0,0,0,63798,0,0,0,64181,0,63761,0,63783,0,0,0,64008,
0,0,0,63904,0,63975,0,63976,0,63762,0,64096,0,64182,0,63780,
0,0,0,64183,0,64010,0,64097,0,0,0,0,0,63905,0,64185,
0,64187,0,63869,0,63809,0,64190,0,64034,0,64189,0,64188,0,64099,
0,63996,0,63834,0,64192,0,0,0,0,0,63744,0,0,0,0,
0,0,0,0,0,63816,0,0,0,63747,0,64100,0,64101,0,0,
0,0,0,0,0,63799,0,0,0,63746,0,63896,0,63959,0,64194,
0,64007,0,63885,0,0,0,63857,0,0,0,64102,0,63898,0,64037,
0,0,0,64195,0,63939,0,63763,0,0,0,63788,0,64038,0,0,
0,63769,0,64196,0,63927,0,0,0,63977,0,63870,0,63754,0,63921,
0,64197,0,63807,0,63899,0,0,0,0,0,63878,0,0,0,63942,
0,63825,0,64009,0,63833,0,63955,0,64198,0,63964,0,63985,0,0,
0,63928,0,0,0,63978,0,64199,0,0,0,63922,0,63817,0,63800,
0,63923,0,0,0,64028,0,0,0,0,0,0,0,0,0,64201,
0,0,0,0,0,64202,0,0,0,0,0,64203,0,63924,0,64204,
0,63952,0,0,0,0,0,0,0,64042,0,64043,0,64044,0,0,
0,0,0,0,0,63770,0,63879,0,0,0,0,0,0,0,64205,
0,0,0,0,0,0,0,0,0,0,0,63801,0,63986,0,0,
0,64045,0,63802,0,63776,0,0,0,63808,0,63880,0,63987,0,0,
0,0,0,0,0,0,0,63881,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,64216,0,0,0,0,0,63940,0,64217,
0,63752,0,0,0,0,0,0,0,64300,0,0,64301,0,0,64208,
0,64207,0,64209,0,64213,0,64214,0,64215,0,0,0,0,0,0,
0};
static const guint8 combiningClass [] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,230,
230,230,230,230,230,232,220,220,220,220,232,216,220,220,220,220,
220,202,202,220,220,220,220,202,202,220,220,220,220,220,220,220,
220,220,220,220,1,1,1,1,1,220,220,220,220,230,230,230,
230,230,230,230,230,240,230,220,220,220,230,230,230,220,220,0,
230,230,230,220,220,220,220,230,232,220,220,230,233,234,234,233,
0,0,0,230,230,230,230,230,0,0,0,0,0,0,0,0,
0,220,230,230,230,230,220,230,230,230,222,220,230,230,230,230,
230,230,220,220,220,220,220,220,230,230,220,230,230,222,228,230,
10,11,12,13,14,15,16,17,18,19,19,20,21,22,0,23,
0,24,25,0,230,220,0,18,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
230,230,230,230,230,230,230,230,30,31,32,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,27,28,29,30,31,
32,33,34,230,230,220,220,230,230,230,230,230,220,230,230,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,230,230,230,230,230,230,230,0,0,230,
230,230,230,220,230,0,0,230,230,0,220,230,230,220,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
230,220,230,230,220,230,230,220,220,220,230,220,220,230,220,230,
230,230,220,230,220,230,220,230,220,230,230,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,230,220,230,230,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,84,91,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,
0,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,
0,0,0,0,0,0,0,0,103,103,9,0,0,0,0,0,
0,0,0,0,0,0,0,0,107,107,107,107,0,0,0,0,
0,0,0,0,0,0,0,0,118,118,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,122,122,122,122,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,220,220,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,220,0,220,0,216,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,129,130,0,132,0,0,0,0,0,130,130,130,130,0,0,
130,0,230,230,9,0,230,230,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,220,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,7,0,9,9,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,230,
0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,
0,0,9,0,0,0,0,0,0,0,0,0,0,230,0,0,
0,0,0,0,0,0,0,0,0,228,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,222,230,220,0,0,0,0,
0,0,0,0,0,0,0,230,220,0,0,0,0,0,0,0,
230,230,220,230,230,230,230,230,230,230,220,230,230,234,214,220,
230,230,1,1,230,230,230,230,1,1,1,230,230,0,0,0,
0,230,0,0,0,1,1,230,220,230,1,1,220,220,220,220,
0,0,0,0,0,0,0,0,0,0,218,228,232,222,224,224,
0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,
0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,
230,230,230,230,230,230,230,0,0,0,0,0,0,0,0,0,
0};

```

`Hazel/vendor/mono/include/mono/metadata/null-gc-handles.h`:

```h
#ifndef __METADATA_NULL_GC_HANDLES_H__
#define __METADATA_NULL_GC_HANDLES_H__

void
null_gc_handles_init (void);

#endif /* __METADATA_NULL_GC_HANDLES_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/number-formatter.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_NUMBER_FORMATTER_H_
#define _MONO_METADATA_NUMBER_FORMATTER_H_ 1

static const guint64 Formatter_MantissaBitsTable [] = {
	4556951262222748432ULL, 9113902524445496865ULL, 1822780504889099373ULL, 
	3645561009778198746ULL, 7291122019556397492ULL, 14582244039112794984ULL, 
	2916448807822558996ULL, 5832897615645117993ULL, 11665795231290235987ULL, 
	2333159046258047197ULL, 4666318092516094394ULL, 9332636185032188789ULL, 
	1866527237006437757ULL, 3733054474012875515ULL, 7466108948025751031ULL, 
	14932217896051502063ULL, 2986443579210300412ULL, 5972887158420600825ULL, 
	11945774316841201651ULL, 2389154863368240330ULL, 4778309726736480660ULL, 
	9556619453472961320ULL, 1911323890694592264ULL, 3822647781389184528ULL, 
	7645295562778369056ULL, 15290591125556738113ULL, 3058118225111347622ULL, 
	6116236450222695245ULL, 12232472900445390490ULL, 2446494580089078098ULL, 
	4892989160178156196ULL, 9785978320356312392ULL, 1957195664071262478ULL, 
	3914391328142524957ULL, 7828782656285049914ULL, 15657565312570099828ULL, 
	3131513062514019965ULL, 6263026125028039931ULL, 12526052250056079862ULL, 
	2505210450011215972ULL, 5010420900022431944ULL, 10020841800044863889ULL, 
	2004168360008972777ULL, 4008336720017945555ULL, 8016673440035891111ULL, 
	16033346880071782223ULL, 3206669376014356444ULL, 6413338752028712889ULL, 
	12826677504057425779ULL, 2565335500811485155ULL, 5130671001622970311ULL, 
	10261342003245940623ULL, 2052268400649188124ULL, 4104536801298376249ULL, 
	8209073602596752498ULL, 16418147205193504997ULL, 3283629441038700999ULL, 
	6567258882077401998ULL, 13134517764154803997ULL, 2626903552830960799ULL, 
	5253807105661921599ULL, 10507614211323843198ULL, 2101522842264768639ULL, 
	4203045684529537279ULL, 8406091369059074558ULL, 16812182738118149117ULL, 
	3362436547623629823ULL, 6724873095247259646ULL, 13449746190494519293ULL, 
	2689949238098903858ULL, 5379898476197807717ULL, 10759796952395615435ULL, 
	2151959390479123087ULL, 4303918780958246174ULL, 8607837561916492348ULL, 
	17215675123832984696ULL, 3443135024766596939ULL, 6886270049533193878ULL, 
	13772540099066387756ULL, 2754508019813277551ULL, 5509016039626555102ULL, 
	11018032079253110205ULL, 2203606415850622041ULL, 4407212831701244082ULL, 
	8814425663402488164ULL, 17628851326804976328ULL, 3525770265360995265ULL, 
	7051540530721990531ULL, 14103081061443981063ULL, 2820616212288796212ULL, 
	5641232424577592425ULL, 11282464849155184850ULL, 2256492969831036970ULL, 
	4512985939662073940ULL, 9025971879324147880ULL, 18051943758648295760ULL, 
	3610388751729659152ULL, 7220777503459318304ULL, 14441555006918636608ULL, 
	2888311001383727321ULL, 5776622002767454643ULL, 11553244005534909286ULL, 
	2310648801106981857ULL, 4621297602213963714ULL, 9242595204427927429ULL, 
	1848519040885585485ULL, 3697038081771170971ULL, 7394076163542341943ULL, 
	14788152327084683887ULL, 2957630465416936777ULL, 5915260930833873554ULL, 
	11830521861667747109ULL, 2366104372333549421ULL, 4732208744667098843ULL, 
	9464417489334197687ULL, 1892883497866839537ULL, 3785766995733679075ULL, 
	7571533991467358150ULL, 15143067982934716300ULL, 3028613596586943260ULL, 
	6057227193173886520ULL, 12114454386347773040ULL, 2422890877269554608ULL, 
	4845781754539109216ULL, 9691563509078218432ULL, 1938312701815643686ULL, 
	3876625403631287372ULL, 7753250807262574745ULL, 15506501614525149491ULL, 
	3101300322905029898ULL, 6202600645810059796ULL, 12405201291620119593ULL, 
	2481040258324023918ULL, 4962080516648047837ULL, 9924161033296095674ULL, 
	1984832206659219134ULL, 3969664413318438269ULL, 7939328826636876539ULL, 
	15878657653273753079ULL, 3175731530654750615ULL, 6351463061309501231ULL, 
	12702926122619002463ULL, 2540585224523800492ULL, 5081170449047600985ULL, 
	10162340898095201970ULL, 2032468179619040394ULL, 4064936359238080788ULL, 
	8129872718476161576ULL, 16259745436952323153ULL, 3251949087390464630ULL, 
	6503898174780929261ULL, 13007796349561858522ULL, 2601559269912371704ULL, 
	5203118539824743409ULL, 10406237079649486818ULL, 2081247415929897363ULL, 
	4162494831859794727ULL, 8324989663719589454ULL, 16649979327439178909ULL, 
	3329995865487835781ULL, 6659991730975671563ULL, 13319983461951343127ULL, 
	2663996692390268625ULL, 5327993384780537250ULL, 10655986769561074501ULL, 
	2131197353912214900ULL, 4262394707824429800ULL, 8524789415648859601ULL, 
	17049578831297719202ULL, 3409915766259543840ULL, 6819831532519087681ULL, 
	13639663065038175362ULL, 2727932613007635072ULL, 5455865226015270144ULL, 
	10911730452030540289ULL, 2182346090406108057ULL, 4364692180812216115ULL, 
	8729384361624432231ULL, 17458768723248864463ULL, 3491753744649772892ULL, 
	6983507489299545785ULL, 13967014978599091570ULL, 2793402995719818314ULL, 
	5586805991439636628ULL, 11173611982879273256ULL, 2234722396575854651ULL, 
	4469444793151709302ULL, 8938889586303418605ULL, 17877779172606837210ULL, 
	3575555834521367442ULL, 7151111669042734884ULL, 14302223338085469768ULL, 
	2860444667617093953ULL, 5720889335234187907ULL, 11441778670468375814ULL, 
	2288355734093675162ULL, 4576711468187350325ULL, 9153422936374700651ULL, 
	1830684587274940130ULL, 3661369174549880260ULL, 7322738349099760521ULL, 
	14645476698199521043ULL, 2929095339639904208ULL, 5858190679279808417ULL, 
	11716381358559616834ULL, 2343276271711923366ULL, 4686552543423846733ULL, 
	9373105086847693467ULL, 1874621017369538693ULL, 3749242034739077387ULL, 
	7498484069478154774ULL, 14996968138956309548ULL, 2999393627791261909ULL, 
	5998787255582523819ULL, 11997574511165047638ULL, 2399514902233009527ULL, 
	4799029804466019055ULL, 9598059608932038110ULL, 1919611921786407622ULL, 
	3839223843572815244ULL, 7678447687145630488ULL, 15356895374291260977ULL, 
	3071379074858252195ULL, 6142758149716504390ULL, 12285516299433008781ULL, 
	2457103259886601756ULL, 4914206519773203512ULL, 9828413039546407025ULL, 
	1965682607909281405ULL, 3931365215818562810ULL, 7862730431637125620ULL, 
	15725460863274251240ULL, 3145092172654850248ULL, 6290184345309700496ULL, 
	12580368690619400992ULL, 2516073738123880198ULL, 5032147476247760397ULL, 
	10064294952495520794ULL, 2012858990499104158ULL, 4025717980998208317ULL, 
	8051435961996416635ULL, 16102871923992833270ULL, 3220574384798566654ULL, 
	6441148769597133308ULL, 12882297539194266616ULL, 2576459507838853323ULL, 
	5152919015677706646ULL, 10305838031355413293ULL, 2061167606271082658ULL, 
	4122335212542165317ULL, 8244670425084330634ULL, 16489340850168661269ULL, 
	3297868170033732253ULL, 6595736340067464507ULL, 13191472680134929015ULL, 
	2638294536026985803ULL, 5276589072053971606ULL, 10553178144107943212ULL, 
	2110635628821588642ULL, 4221271257643177284ULL, 8442542515286354569ULL, 
	16885085030572709139ULL, 3377017006114541827ULL, 6754034012229083655ULL, 
	13508068024458167311ULL, 2701613604891633462ULL, 5403227209783266924ULL, 
	10806454419566533849ULL, 2161290883913306769ULL, 4322581767826613539ULL, 
	8645163535653227079ULL, 17290327071306454158ULL, 3458065414261290831ULL, 
	6916130828522581663ULL, 13832261657045163327ULL, 2766452331409032665ULL, 
	5532904662818065330ULL, 11065809325636130661ULL, 2213161865127226132ULL, 
	4426323730254452264ULL, 8852647460508904529ULL, 17705294921017809058ULL, 
	3541058984203561811ULL, 7082117968407123623ULL, 14164235936814247246ULL, 
	2832847187362849449ULL, 5665694374725698898ULL, 11331388749451397797ULL, 
	2266277749890279559ULL, 4532555499780559119ULL, 9065110999561118238ULL, 
	1813022199912223647ULL, 3626044399824447295ULL, 7252088799648894590ULL, 
	14504177599297789180ULL, 2900835519859557836ULL, 5801671039719115672ULL, 
	11603342079438231344ULL, 2320668415887646268ULL, 4641336831775292537ULL, 
	9282673663550585075ULL, 1856534732710117015ULL, 3713069465420234030ULL, 
	7426138930840468060ULL, 14852277861680936121ULL, 2970455572336187224ULL, 
	5940911144672374448ULL, 11881822289344748896ULL, 2376364457868949779ULL, 
	4752728915737899558ULL, 9505457831475799117ULL, 1901091566295159823ULL, 
	3802183132590319647ULL, 7604366265180639294ULL, 15208732530361278588ULL, 
	3041746506072255717ULL, 6083493012144511435ULL, 12166986024289022870ULL, 
	2433397204857804574ULL, 4866794409715609148ULL, 9733588819431218296ULL, 
	1946717763886243659ULL, 3893435527772487318ULL, 7786871055544974637ULL, 
	15573742111089949274ULL, 3114748422217989854ULL, 6229496844435979709ULL, 
	12458993688871959419ULL, 2491798737774391883ULL, 4983597475548783767ULL, 
	9967194951097567535ULL, 1993438990219513507ULL, 3986877980439027014ULL, 
	7973755960878054028ULL, 15947511921756108056ULL, 3189502384351221611ULL, 
	6379004768702443222ULL, 12758009537404886445ULL, 2551601907480977289ULL, 
	5103203814961954578ULL, 10206407629923909156ULL, 2041281525984781831ULL, 
	4082563051969563662ULL, 8165126103939127325ULL, 16330252207878254650ULL, 
	3266050441575650930ULL, 6532100883151301860ULL, 13064201766302603720ULL, 
	2612840353260520744ULL, 5225680706521041488ULL, 10451361413042082976ULL, 
	2090272282608416595ULL, 4180544565216833190ULL, 8361089130433666380ULL, 
	16722178260867332761ULL, 3344435652173466552ULL, 6688871304346933104ULL, 
	13377742608693866209ULL, 2675548521738773241ULL, 5351097043477546483ULL, 
	10702194086955092967ULL, 2140438817391018593ULL, 4280877634782037187ULL, 
	8561755269564074374ULL, 17123510539128148748ULL, 3424702107825629749ULL, 
	6849404215651259499ULL, 13698808431302518998ULL, 2739761686260503799ULL, 
	5479523372521007599ULL, 10959046745042015198ULL, 2191809349008403039ULL, 
	4383618698016806079ULL, 8767237396033612159ULL, 17534474792067224318ULL, 
	3506894958413444863ULL, 7013789916826889727ULL, 14027579833653779454ULL, 
	2805515966730755890ULL, 5611031933461511781ULL, 11222063866923023563ULL, 
	2244412773384604712ULL, 4488825546769209425ULL, 8977651093538418850ULL, 
	17955302187076837701ULL, 3591060437415367540ULL, 7182120874830735080ULL, 
	14364241749661470161ULL, 2872848349932294032ULL, 5745696699864588064ULL, 
	11491393399729176129ULL, 2298278679945835225ULL, 4596557359891670451ULL, 
	9193114719783340903ULL, 1838622943956668180ULL, 3677245887913336361ULL, 
	7354491775826672722ULL, 14708983551653345445ULL, 2941796710330669089ULL, 
	5883593420661338178ULL, 11767186841322676356ULL, 2353437368264535271ULL, 
	4706874736529070542ULL, 9413749473058141084ULL, 1882749894611628216ULL, 
	3765499789223256433ULL, 7530999578446512867ULL, 15061999156893025735ULL, 
	3012399831378605147ULL, 6024799662757210294ULL, 12049599325514420588ULL, 
	2409919865102884117ULL, 4819839730205768235ULL, 9639679460411536470ULL, 
	1927935892082307294ULL, 3855871784164614588ULL, 7711743568329229176ULL, 
	15423487136658458353ULL, 3084697427331691670ULL, 6169394854663383341ULL, 
	12338789709326766682ULL, 2467757941865353336ULL, 4935515883730706673ULL, 
	9871031767461413346ULL, 1974206353492282669ULL, 3948412706984565338ULL, 
	7896825413969130677ULL, 15793650827938261354ULL, 3158730165587652270ULL, 
	6317460331175304541ULL, 12634920662350609083ULL, 2526984132470121816ULL, 
	5053968264940243633ULL, 10107936529880487266ULL, 2021587305976097453ULL, 
	4043174611952194906ULL, 8086349223904389813ULL, 16172698447808779626ULL, 
	3234539689561755925ULL, 6469079379123511850ULL, 12938158758247023701ULL, 
	2587631751649404740ULL, 5175263503298809480ULL, 10350527006597618960ULL, 
	2070105401319523792ULL, 4140210802639047584ULL, 8280421605278095168ULL, 
	16560843210556190337ULL, 3312168642111238067ULL, 6624337284222476135ULL, 
	13248674568444952270ULL, 2649734913688990454ULL, 5299469827377980908ULL, 
	10598939654755961816ULL, 2119787930951192363ULL, 4239575861902384726ULL, 
	8479151723804769452ULL, 16958303447609538905ULL, 3391660689521907781ULL, 
	6783321379043815562ULL, 13566642758087631124ULL, 2713328551617526224ULL, 
	5426657103235052449ULL, 10853314206470104899ULL, 2170662841294020979ULL, 
	4341325682588041959ULL, 8682651365176083919ULL, 17365302730352167839ULL, 
	3473060546070433567ULL, 6946121092140867135ULL, 13892242184281734271ULL, 
	2778448436856346854ULL, 5556896873712693708ULL, 11113793747425387417ULL, 
	2222758749485077483ULL, 4445517498970154966ULL, 8891034997940309933ULL, 
	17782069995880619867ULL, 3556413999176123973ULL, 7112827998352247947ULL, 
	14225655996704495894ULL, 2845131199340899178ULL, 5690262398681798357ULL, 
	11380524797363596715ULL, 2276104959472719343ULL, 4552209918945438686ULL, 
	9104419837890877372ULL, 1820883967578175474ULL, 3641767935156350948ULL, 
	7283535870312701897ULL, 14567071740625403795ULL, 2913414348125080759ULL, 
	5826828696250161518ULL, 11653657392500323036ULL, 2330731478500064607ULL, 
	4661462957000129214ULL, 9322925914000258429ULL, 1864585182800051685ULL, 
	3729170365600103371ULL, 7458340731200206743ULL, 14916681462400413486ULL, 
	2983336292480082697ULL, 5966672584960165394ULL, 11933345169920330789ULL, 
	2386669033984066157ULL, 4773338067968132315ULL, 9546676135936264631ULL, 
	1909335227187252926ULL, 3818670454374505852ULL, 7637340908749011705ULL, 
	15274681817498023410ULL, 3054936363499604682ULL, 6109872726999209364ULL, 
	12219745453998418728ULL, 2443949090799683745ULL, 4887898181599367491ULL, 
	9775796363198734982ULL, 1955159272639746996ULL, 3910318545279493993ULL, 
	7820637090558987986ULL, 15641274181117975972ULL, 3128254836223595194ULL, 
	6256509672447190388ULL, 12513019344894380777ULL, 2502603868978876155ULL, 
	5005207737957752311ULL, 10010415475915504622ULL, 2002083095183100924ULL, 
	4004166190366201848ULL, 8008332380732403697ULL, 16016664761464807395ULL, 
	3203332952292961479ULL, 6406665904585922958ULL, 12813331809171845916ULL, 
	2562666361834369183ULL, 5125332723668738366ULL, 10250665447337476733ULL, 
	2050133089467495346ULL, 4100266178934990693ULL, 8200532357869981386ULL, 
	16401064715739962772ULL, 3280212943147992554ULL, 6560425886295985109ULL, 
	13120851772591970218ULL, 2624170354518394043ULL, 5248340709036788087ULL, 
	10496681418073576174ULL, 2099336283614715234ULL, 4198672567229430469ULL, 
	8397345134458860939ULL, 16794690268917721879ULL, 3358938053783544375ULL, 
	6717876107567088751ULL, 13435752215134177503ULL, 2687150443026835500ULL, 
	5374300886053671001ULL, 10748601772107342002ULL, 2149720354421468400ULL, 
	4299440708842936801ULL, 8598881417685873602ULL, 17197762835371747204ULL, 
	3439552567074349440ULL, 6879105134148698881ULL, 13758210268297397763ULL, 
	2751642053659479552ULL, 5503284107318959105ULL, 11006568214637918210ULL, 
	2201313642927583642ULL, 4402627285855167284ULL, 8805254571710334568ULL, 
	17610509143420669137ULL, 3522101828684133827ULL, 7044203657368267654ULL, 
	14088407314736535309ULL, 2817681462947307061ULL, 5635362925894614123ULL, 
	11270725851789228247ULL, 2254145170357845649ULL, 4508290340715691299ULL, 
	9016580681431382598ULL, 18033161362862765196ULL, 3606632272572553039ULL, 
	7213264545145106078ULL, 14426529090290212157ULL, 2885305818058042431ULL, 
	5770611636116084862ULL, 11541223272232169725ULL, 2308244654446433945ULL, 
	4616489308892867890ULL, 9232978617785735780ULL, 1846595723557147156ULL, 
	3693191447114294312ULL, 7386382894228588624ULL, 14772765788457177249ULL, 
	2954553157691435449ULL, 5909106315382870899ULL, 11818212630765741799ULL, 
	2363642526153148359ULL, 4727285052306296719ULL, 9454570104612593439ULL, 
	1890914020922518687ULL, 3781828041845037375ULL, 7563656083690074751ULL, 
	15127312167380149503ULL, 3025462433476029900ULL, 6050924866952059801ULL, 
	12101849733904119602ULL, 2420369946780823920ULL, 4840739893561647841ULL, 
	9681479787123295682ULL, 1936295957424659136ULL, 3872591914849318272ULL, 
	7745183829698636545ULL, 15490367659397273091ULL, 3098073531879454618ULL, 
	6196147063758909236ULL, 12392294127517818473ULL, 2478458825503563694ULL, 
	4956917651007127389ULL, 9913835302014254778ULL, 1982767060402850955ULL, 
	3965534120805701911ULL, 7931068241611403822ULL, 15862136483222807645ULL, 
	3172427296644561529ULL, 6344854593289123058ULL, 12689709186578246116ULL, 
	2537941837315649223ULL, 5075883674631298446ULL, 10151767349262596893ULL, 
	2030353469852519378ULL, 4060706939705038757ULL, 8121413879410077514ULL, 
	16242827758820155028ULL, 3248565551764031005ULL, 6497131103528062011ULL, 
	12994262207056124023ULL, 2598852441411224804ULL, 5197704882822449609ULL, 
	10395409765644899218ULL, 2079081953128979843ULL, 4158163906257959687ULL, 
	8316327812515919374ULL, 16632655625031838749ULL, 3326531125006367749ULL, 
	6653062250012735499ULL, 13306124500025470999ULL, 2661224900005094199ULL, 
	5322449800010188399ULL, 10644899600020376799ULL, 2128979920004075359ULL, 
	4257959840008150719ULL, 8515919680016301439ULL, 17031839360032602879ULL, 
	3406367872006520575ULL, 6812735744013041151ULL, 13625471488026082303ULL, 
	2725094297605216460ULL, 5450188595210432921ULL, 10900377190420865842ULL, 
	2180075438084173168ULL, 4360150876168346337ULL, 8720301752336692674ULL, 
	17440603504673385348ULL, 3488120700934677069ULL, 6976241401869354139ULL, 
	13952482803738708279ULL, 2790496560747741655ULL, 5580993121495483311ULL, 
	11161986242990966623ULL, 2232397248598193324ULL, 4464794497196386649ULL, 
	8929588994392773298ULL, 17859177988785546597ULL, 3571835597757109319ULL, 
	7143671195514218638ULL, 14287342391028437277ULL, 2857468478205687455ULL, 
	5714936956411374911ULL, 11429873912822749822ULL, 2285974782564549964ULL, 
	4571949565129099928ULL, 9143899130258199857ULL, 1828779826051639971ULL, 
	3657559652103279943ULL, 7315119304206559886ULL, 14630238608413119772ULL, 
	2926047721682623954ULL, 5852095443365247908ULL, 11704190886730495817ULL, 
	2340838177346099163ULL, 4681676354692198327ULL, 9363352709384396654ULL, 
	1872670541876879330ULL, 3745341083753758661ULL, 7490682167507517323ULL, 
	14981364335015034646ULL, 2996272867003006929ULL, 5992545734006013858ULL, 
	11985091468012027717ULL, 2397018293602405543ULL, 4794036587204811087ULL, 
	9588073174409622174ULL, 1917614634881924434ULL, 3835229269763848869ULL, 
	7670458539527697739ULL, 15340917079055395478ULL, 3068183415811079095ULL, 
	6136366831622158191ULL, 12272733663244316382ULL, 2454546732648863276ULL, 
	4909093465297726553ULL, 9818186930595453106ULL, 1963637386119090621ULL, 
	3927274772238181242ULL, 7854549544476362484ULL, 15709099088952724969ULL, 
	3141819817790544993ULL, 6283639635581089987ULL, 12567279271162179975ULL, 
	2513455854232435995ULL, 5026911708464871990ULL, 10053823416929743980ULL, 
	2010764683385948796ULL, 4021529366771897592ULL, 8043058733543795184ULL, 
	16086117467087590369ULL, 3217223493417518073ULL, 6434446986835036147ULL, 
	12868893973670072295ULL, 2573778794734014459ULL, 5147557589468028918ULL, 
	10295115178936057836ULL, 2059023035787211567ULL, 4118046071574423134ULL, 
	8236092143148846269ULL, 16472184286297692538ULL, 3294436857259538507ULL, 
	6588873714519077015ULL, 13177747429038154030ULL, 2635549485807630806ULL, 
	5271098971615261612ULL, 10542197943230523224ULL, 2108439588646104644ULL, 
	4216879177292209289ULL, 8433758354584418579ULL, 16867516709168837158ULL, 
	3373503341833767431ULL, 6747006683667534863ULL, 13494013367335069727ULL, 
	2698802673467013945ULL, 5397605346934027890ULL, 10795210693868055781ULL, 
	2159042138773611156ULL, 4318084277547222312ULL, 8636168555094444625ULL, 
	17272337110188889250ULL, 3454467422037777850ULL, 6908934844075555700ULL, 
	13817869688151111400ULL, 2763573937630222280ULL, 5527147875260444560ULL, 
	11054295750520889120ULL, 2210859150104177824ULL, 4421718300208355648ULL, 
	8843436600416711296ULL, 17686873200833422592ULL, 3537374640166684518ULL, 
	7074749280333369037ULL, 14149498560666738074ULL, 2829899712133347614ULL, 
	5659799424266695229ULL, 11319598848533390459ULL, 2263919769706678091ULL, 
	4527839539413356183ULL, 9055679078826712367ULL, 1811135815765342473ULL, 
	3622271631530684947ULL, 7244543263061369894ULL, 14489086526122739788ULL, 
	2897817305224547957ULL, 5795634610449095915ULL, 11591269220898191830ULL, 
	2318253844179638366ULL, 4636507688359276732ULL, 9273015376718553464ULL, 
	1854603075343710692ULL, 3709206150687421385ULL, 7418412301374842771ULL, 
	14836824602749685542ULL, 2967364920549937108ULL, 5934729841099874217ULL, 
	11869459682199748434ULL, 2373891936439949686ULL, 4747783872879899373ULL, 
	9495567745759798747ULL, 1899113549151959749ULL, 3798227098303919498ULL, 
	7596454196607838997ULL, 15192908393215677995ULL, 3038581678643135599ULL, 
	6077163357286271198ULL, 12154326714572542396ULL, 2430865342914508479ULL, 
	4861730685829016958ULL, 9723461371658033917ULL, 1944692274331606783ULL, 
	3889384548663213566ULL, 7778769097326427133ULL, 15557538194652854267ULL, 
	3111507638930570853ULL, 6223015277861141707ULL, 12446030555722283414ULL, 
	2489206111144456682ULL, 4978412222288913365ULL, 9956824444577826731ULL, 
	1991364888915565346ULL, 3982729777831130692ULL, 7965459555662261385ULL, 
	15930919111324522770ULL, 3186183822264904554ULL, 6372367644529809108ULL, 
	12744735289059618216ULL, 2548947057811923643ULL, 5097894115623847286ULL, 
	10195788231247694572ULL, 2039157646249538914ULL, 4078315292499077829ULL, 
	8156630584998155658ULL, 16313261169996311316ULL, 3262652233999262263ULL, 
	6525304467998524526ULL, 13050608935997049053ULL, 2610121787199409810ULL, 
	5220243574398819621ULL, 10440487148797639242ULL, 2088097429759527848ULL, 
	4176194859519055697ULL, 8352389719038111394ULL, 16704779438076222788ULL, 
	3340955887615244557ULL, 6681911775230489115ULL, 13363823550460978230ULL, 
	2672764710092195646ULL, 5345529420184391292ULL, 10691058840368782584ULL, 
	2138211768073756516ULL, 4276423536147513033ULL, 8552847072295026067ULL, 
	17105694144590052135ULL, 3421138828918010427ULL, 6842277657836020854ULL, 
	13684555315672041708ULL, 2736911063134408341ULL, 5473822126268816683ULL, 
	10947644252537633366ULL, 2189528850507526673ULL, 4379057701015053346ULL, 
	8758115402030106693ULL, 17516230804060213386ULL, 3503246160812042677ULL, 
	7006492321624085354ULL, 14012984643248170709ULL, 2802596928649634141ULL, 
	5605193857299268283ULL, 11210387714598536567ULL, 2242077542919707313ULL, 
	4484155085839414626ULL, 8968310171678829253ULL, 17936620343357658507ULL, 
	3587324068671531701ULL, 7174648137343063403ULL, 14349296274686126806ULL, 
	2869859254937225361ULL, 5739718509874450722ULL, 11479437019748901445ULL, 
	2295887403949780289ULL, 4591774807899560578ULL, 9183549615799121156ULL, 
	1836709923159824231ULL, 3673419846319648462ULL, 7346839692639296924ULL, 
	14693679385278593849ULL, 2938735877055718769ULL, 5877471754111437539ULL, 
	11754943508222875079ULL, 2350988701644575015ULL, 4701977403289150031ULL, 
	9403954806578300063ULL, 1880790961315660012ULL, 3761581922631320025ULL, 
	7523163845262640050ULL, 15046327690525280101ULL, 3009265538105056020ULL, 
	6018531076210112040ULL, 12037062152420224081ULL, 2407412430484044816ULL, 
	4814824860968089632ULL, 9629649721936179265ULL, 1925929944387235853ULL, 
	3851859888774471706ULL, 7703719777548943412ULL, 15407439555097886824ULL, 
	3081487911019577364ULL, 6162975822039154729ULL, 12325951644078309459ULL, 
	2465190328815661891ULL, 4930380657631323783ULL, 9860761315262647567ULL, 
	1972152263052529513ULL, 3944304526105059027ULL, 7888609052210118054ULL, 
	15777218104420236108ULL, 3155443620884047221ULL, 6310887241768094443ULL, 
	12621774483536188886ULL, 2524354896707237777ULL, 5048709793414475554ULL, 
	10097419586828951109ULL, 2019483917365790221ULL, 4038967834731580443ULL, 
	8077935669463160887ULL, 16155871338926321774ULL, 3231174267785264354ULL, 
	6462348535570528709ULL, 12924697071141057419ULL, 2584939414228211483ULL, 
	5169878828456422967ULL, 10339757656912845935ULL, 2067951531382569187ULL, 
	4135903062765138374ULL, 8271806125530276748ULL, 16543612251060553497ULL, 
	3308722450212110699ULL, 6617444900424221398ULL, 13234889800848442797ULL, 
	2646977960169688559ULL, 5293955920339377119ULL, 10587911840678754238ULL, 
	2117582368135750847ULL, 4235164736271501695ULL, 8470329472543003390ULL, 
	16940658945086006781ULL, 3388131789017201356ULL, 6776263578034402712ULL, 
	13552527156068805425ULL, 2710505431213761085ULL, 5421010862427522170ULL, 
	10842021724855044340ULL, 2168404344971008868ULL, 4336808689942017736ULL, 
	8673617379884035472ULL, 17347234759768070944ULL, 3469446951953614188ULL, 
	6938893903907228377ULL, 13877787807814456755ULL, 2775557561562891351ULL, 
	5551115123125782702ULL, 11102230246251565404ULL, 2220446049250313080ULL, 
	4440892098500626161ULL, 8881784197001252323ULL, 17763568394002504646ULL, 
	3552713678800500929ULL, 7105427357601001858ULL, 14210854715202003717ULL, 
	2842170943040400743ULL, 5684341886080801486ULL, 11368683772161602973ULL, 
	2273736754432320594ULL, 4547473508864641189ULL, 9094947017729282379ULL, 
	1818989403545856475ULL, 3637978807091712951ULL, 7275957614183425903ULL, 
	14551915228366851806ULL, 2910383045673370361ULL, 5820766091346740722ULL, 
	11641532182693481445ULL, 2328306436538696289ULL, 4656612873077392578ULL, 
	9313225746154785156ULL, 1862645149230957031ULL, 3725290298461914062ULL, 
	7450580596923828125ULL, 14901161193847656250ULL, 2980232238769531250ULL, 
	5960464477539062500ULL, 11920928955078125000ULL, 2384185791015625000ULL, 
	4768371582031250000ULL, 9536743164062500000ULL, 1907348632812500000ULL, 
	3814697265625000000ULL, 7629394531250000000ULL, 15258789062500000000ULL, 
	3051757812500000000ULL, 6103515625000000000ULL, 12207031250000000000ULL, 
	2441406250000000000ULL, 4882812500000000000ULL, 9765625000000000000ULL, 
	1953125000000000000ULL, 3906250000000000000ULL, 7812500000000000000ULL, 
	15625000000000000000ULL, 3125000000000000000ULL, 6250000000000000000ULL, 
	12500000000000000000ULL, 2500000000000000000ULL, 5000000000000000000ULL, 
	10000000000000000000ULL, 2000000000000000000ULL, 4000000000000000000ULL, 
	8000000000000000000ULL, 16000000000000000000ULL, 3200000000000000000ULL, 
	6400000000000000000ULL, 12800000000000000000ULL, 2560000000000000000ULL, 
	5120000000000000000ULL, 10240000000000000000ULL, 2048000000000000000ULL, 
	4096000000000000000ULL, 8192000000000000000ULL, 16384000000000000000ULL, 
	3276800000000000000ULL, 6553600000000000000ULL, 13107200000000000000ULL, 
	2621440000000000000ULL, 5242880000000000000ULL, 10485760000000000000ULL, 
	2097152000000000000ULL, 4194304000000000000ULL, 8388608000000000000ULL, 
	16777216000000000000ULL, 3355443200000000000ULL, 6710886400000000000ULL, 
	13421772800000000000ULL, 2684354560000000000ULL, 5368709120000000000ULL, 
	10737418240000000000ULL, 2147483648000000000ULL, 4294967296000000000ULL, 
	8589934592000000000ULL, 17179869184000000000ULL, 3435973836800000000ULL, 
	6871947673600000000ULL, 13743895347200000000ULL, 2748779069440000000ULL, 
	5497558138880000000ULL, 10995116277760000000ULL, 2199023255552000000ULL, 
	4398046511104000000ULL, 8796093022208000000ULL, 17592186044416000000ULL, 
	3518437208883200000ULL, 7036874417766400000ULL, 14073748835532800000ULL, 
	2814749767106560000ULL, 5629499534213120000ULL, 11258999068426240000ULL, 
	2251799813685248000ULL, 4503599627370496000ULL, 9007199254740992000ULL, 
	18014398509481984000ULL, 3602879701896396800ULL, 7205759403792793600ULL, 
	14411518807585587200ULL, 2882303761517117440ULL, 5764607523034234880ULL, 
	11529215046068469760ULL, 2305843009213693952ULL, 4611686018427387904ULL, 
	9223372036854775808ULL, 1844674407370955161ULL, 3689348814741910323ULL, 
	7378697629483820646ULL, 14757395258967641292ULL, 2951479051793528258ULL, 
	5902958103587056517ULL, 11805916207174113034ULL, 2361183241434822606ULL, 
	4722366482869645213ULL, 9444732965739290427ULL, 1888946593147858085ULL, 
	3777893186295716170ULL, 7555786372591432341ULL, 15111572745182864683ULL, 
	3022314549036572936ULL, 6044629098073145873ULL, 12089258196146291747ULL, 
	2417851639229258349ULL, 4835703278458516698ULL, 9671406556917033397ULL, 
	1934281311383406679ULL, 3868562622766813359ULL, 7737125245533626718ULL, 
	15474250491067253436ULL, 3094850098213450687ULL, 6189700196426901374ULL, 
	12379400392853802748ULL, 2475880078570760549ULL, 4951760157141521099ULL, 
	9903520314283042199ULL, 1980704062856608439ULL, 3961408125713216879ULL, 
	7922816251426433759ULL, 15845632502852867518ULL, 3169126500570573503ULL, 
	6338253001141147007ULL, 12676506002282294014ULL, 2535301200456458802ULL, 
	5070602400912917605ULL, 10141204801825835211ULL, 2028240960365167042ULL, 
	4056481920730334084ULL, 8112963841460668169ULL, 16225927682921336339ULL, 
	3245185536584267267ULL, 6490371073168534535ULL, 12980742146337069071ULL, 
	2596148429267413814ULL, 5192296858534827628ULL, 10384593717069655257ULL, 
	2076918743413931051ULL, 4153837486827862102ULL, 8307674973655724205ULL, 
	16615349947311448411ULL, 3323069989462289682ULL, 6646139978924579364ULL, 
	13292279957849158729ULL, 2658455991569831745ULL, 5316911983139663491ULL, 
	10633823966279326983ULL, 2126764793255865396ULL, 4253529586511730793ULL, 
	8507059173023461586ULL, 17014118346046923173ULL, 3402823669209384634ULL, 
	6805647338418769269ULL, 13611294676837538538ULL, 2722258935367507707ULL, 
	5444517870735015415ULL, 10889035741470030830ULL, 2177807148294006166ULL, 
	4355614296588012332ULL, 8711228593176024664ULL, 17422457186352049329ULL, 
	3484491437270409865ULL, 6968982874540819731ULL, 13937965749081639463ULL, 
	2787593149816327892ULL, 5575186299632655785ULL, 11150372599265311570ULL, 
	2230074519853062314ULL, 4460149039706124628ULL, 8920298079412249256ULL, 
	17840596158824498513ULL, 3568119231764899702ULL, 7136238463529799405ULL, 
	14272476927059598810ULL, 2854495385411919762ULL, 5708990770823839524ULL, 
	11417981541647679048ULL, 2283596308329535809ULL, 4567192616659071619ULL, 
	9134385233318143238ULL, 1826877046663628647ULL, 3653754093327257295ULL, 
	7307508186654514591ULL, 14615016373309029182ULL, 2923003274661805836ULL, 
	5846006549323611672ULL, 11692013098647223345ULL, 2338402619729444669ULL, 
	4676805239458889338ULL, 9353610478917778676ULL, 1870722095783555735ULL, 
	3741444191567111470ULL, 7482888383134222941ULL, 14965776766268445882ULL, 
	2993155353253689176ULL, 5986310706507378352ULL, 11972621413014756705ULL, 
	2394524282602951341ULL, 4789048565205902682ULL, 9578097130411805364ULL, 
	1915619426082361072ULL, 3831238852164722145ULL, 7662477704329444291ULL, 
	15324955408658888583ULL, 3064991081731777716ULL, 6129982163463555433ULL, 
	12259964326927110866ULL, 2451992865385422173ULL, 4903985730770844346ULL, 
	9807971461541688693ULL, 1961594292308337738ULL, 3923188584616675477ULL, 
	7846377169233350954ULL, 15692754338466701909ULL, 3138550867693340381ULL, 
	6277101735386680763ULL, 12554203470773361527ULL, 2510840694154672305ULL, 
	5021681388309344611ULL, 10043362776618689222ULL, 2008672555323737844ULL, 
	4017345110647475688ULL, 8034690221294951377ULL, 16069380442589902755ULL, 
	3213876088517980551ULL, 6427752177035961102ULL, 12855504354071922204ULL, 
	2571100870814384440ULL, 5142201741628768881ULL, 10284403483257537763ULL, 
	2056880696651507552ULL, 4113761393303015105ULL, 8227522786606030210ULL, 
	16455045573212060421ULL, 3291009114642412084ULL, 6582018229284824168ULL, 
	13164036458569648337ULL, 2632807291713929667ULL, 5265614583427859334ULL, 
	10531229166855718669ULL, 2106245833371143733ULL, 4212491666742287467ULL, 
	8424983333484574935ULL, 16849966666969149871ULL, 3369993333393829974ULL, 
	6739986666787659948ULL, 13479973333575319897ULL, 2695994666715063979ULL, 
	5391989333430127958ULL, 10783978666860255917ULL, 2156795733372051183ULL, 
	4313591466744102367ULL, 8627182933488204734ULL, 17254365866976409468ULL, 
	3450873173395281893ULL, 6901746346790563787ULL, 13803492693581127574ULL, 
	2760698538716225514ULL, 5521397077432451029ULL, 11042794154864902059ULL, 
	2208558830972980411ULL, 4417117661945960823ULL, 8834235323891921647ULL, 
	17668470647783843295ULL, 3533694129556768659ULL, 7067388259113537318ULL, 
	14134776518227074636ULL, 2826955303645414927ULL, 5653910607290829854ULL, 
	11307821214581659709ULL, 2261564242916331941ULL, 4523128485832663883ULL, 
	9046256971665327767ULL, 18092513943330655534ULL, 3618502788666131106ULL, 
	7237005577332262213ULL, 14474011154664524427ULL, 2894802230932904885ULL, 
	5789604461865809771ULL, 11579208923731619542ULL, 2315841784746323908ULL, 
	4631683569492647816ULL, 9263367138985295633ULL, 1852673427797059126ULL, 
	3705346855594118253ULL, 7410693711188236507ULL, 14821387422376473014ULL, 
	2964277484475294602ULL, 5928554968950589205ULL, 11857109937901178411ULL, 
	2371421987580235682ULL, 4742843975160471364ULL, 9485687950320942729ULL, 
	1897137590064188545ULL, 3794275180128377091ULL, 7588550360256754183ULL, 
	15177100720513508366ULL, 3035420144102701673ULL, 6070840288205403346ULL, 
	12141680576410806693ULL, 2428336115282161338ULL, 4856672230564322677ULL, 
	9713344461128645354ULL, 1942668892225729070ULL, 3885337784451458141ULL, 
	7770675568902916283ULL, 15541351137805832567ULL, 3108270227561166513ULL, 
	6216540455122333026ULL, 12433080910244666053ULL, 2486616182048933210ULL, 
	4973232364097866421ULL, 9946464728195732843ULL, 1989292945639146568ULL, 
	3978585891278293137ULL, 7957171782556586274ULL, 15914343565113172548ULL, 
	3182868713022634509ULL, 6365737426045269019ULL, 12731474852090538039ULL, 
	2546294970418107607ULL, 5092589940836215215ULL, 10185179881672430431ULL, 
	2037035976334486086ULL, 4074071952668972172ULL, 8148143905337944345ULL, 
	16296287810675888690ULL, 3259257562135177738ULL, 6518515124270355476ULL, 
	13037030248540710952ULL, 2607406049708142190ULL, 5214812099416284380ULL, 
	10429624198832568761ULL, 2085924839766513752ULL, 4171849679533027504ULL, 
	8343699359066055009ULL, 16687398718132110018ULL, 3337479743626422003ULL, 
	6674959487252844007ULL, 13349918974505688014ULL, 2669983794901137602ULL, 
	5339967589802275205ULL, 10679935179604550411ULL, 2135987035920910082ULL, 
	4271974071841820164ULL, 8543948143683640329ULL, 17087896287367280659ULL, 
	3417579257473456131ULL, 6835158514946912263ULL, 13670317029893824527ULL, 
	2734063405978764905ULL, 5468126811957529810ULL, 10936253623915059621ULL, 
	2187250724783011924ULL, 4374501449566023848ULL, 8749002899132047697ULL, 
	17498005798264095394ULL, 3499601159652819078ULL, 6999202319305638157ULL, 
	13998404638611276315ULL, 2799680927722255263ULL, 5599361855444510526ULL, 
	11198723710889021052ULL, 2239744742177804210ULL, 4479489484355608421ULL, 
	8958978968711216842ULL, 17917957937422433684ULL, 3583591587484486736ULL, 
	7167183174968973473ULL, 14334366349937946947ULL, 2866873269987589389ULL, 
	5733746539975178779ULL, 11467493079950357558ULL, 2293498615990071511ULL, 
	4586997231980143023ULL, 9173994463960286046ULL, 1834798892792057209ULL, 
	3669597785584114418ULL, 7339195571168228837ULL, 14678391142336457674ULL, 
	2935678228467291534ULL, 5871356456934583069ULL, 11742712913869166139ULL, 
	2348542582773833227ULL, 4697085165547666455ULL, 9394170331095332911ULL, 
	1878834066219066582ULL, 3757668132438133164ULL, 7515336264876266329ULL, 
	15030672529752532658ULL, 3006134505950506531ULL, 6012269011901013063ULL, 
	12024538023802026126ULL, 2404907604760405225ULL, 4809815209520810450ULL, 
	9619630419041620901ULL, 1923926083808324180ULL, 3847852167616648360ULL, 
	7695704335233296721ULL, 15391408670466593442ULL, 3078281734093318688ULL, 
	6156563468186637376ULL, 12313126936373274753ULL, 2462625387274654950ULL, 
	4925250774549309901ULL, 9850501549098619803ULL, 1970100309819723960ULL, 
	3940200619639447921ULL, 7880401239278895842ULL, 15760802478557791684ULL, 
	3152160495711558336ULL, 6304320991423116673ULL, 12608641982846233347ULL, 
	2521728396569246669ULL, 5043456793138493339ULL, 10086913586276986678ULL, 
	2017382717255397335ULL, 4034765434510794671ULL, 8069530869021589342ULL, 
	16139061738043178685ULL, 3227812347608635737ULL, 6455624695217271474ULL, 
	12911249390434542948ULL, 2582249878086908589ULL, 5164499756173817179ULL, 
	10328999512347634358ULL, 2065799902469526871ULL, 4131599804939053743ULL, 
	8263199609878107486ULL, 16526399219756214973ULL, 3305279843951242994ULL, 
	6610559687902485989ULL, 13221119375804971979ULL, 2644223875160994395ULL, 
	5288447750321988791ULL, 10576895500643977583ULL, 2115379100128795516ULL, 
	4230758200257591033ULL, 8461516400515182066ULL, 16923032801030364133ULL, 
	3384606560206072826ULL, 6769213120412145653ULL, 13538426240824291306ULL, 
	2707685248164858261ULL, 5415370496329716522ULL, 10830740992659433045ULL, 
	2166148198531886609ULL, 4332296397063773218ULL, 8664592794127546436ULL, 
	17329185588255092872ULL, 3465837117651018574ULL, 6931674235302037148ULL, 
	13863348470604074297ULL, 2772669694120814859ULL, 5545339388241629719ULL, 
	11090678776483259438ULL, 2218135755296651887ULL, 4436271510593303775ULL, 
	8872543021186607550ULL, 17745086042373215101ULL, 3549017208474643020ULL, 
	7098034416949286040ULL, 14196068833898572081ULL, 2839213766779714416ULL, 
	5678427533559428832ULL, 11356855067118857664ULL, 2271371013423771532ULL, 
	4542742026847543065ULL, 9085484053695086131ULL, 1817096810739017226ULL, 
	3634193621478034452ULL, 7268387242956068905ULL, 14536774485912137810ULL, 
	2907354897182427562ULL, 5814709794364855124ULL, 11629419588729710248ULL, 
	2325883917745942049ULL, 4651767835491884099ULL, 9303535670983768199ULL, 
	1860707134196753639ULL, 3721414268393507279ULL, 7442828536787014559ULL, 
	14885657073574029118ULL, 2977131414714805823ULL, 5954262829429611647ULL, 
	11908525658859223294ULL, 2381705131771844658ULL, 4763410263543689317ULL, 
	9526820527087378635ULL, 1905364105417475727ULL, 3810728210834951454ULL, 
	7621456421669902908ULL, 15242912843339805817ULL, 3048582568667961163ULL, 
	6097165137335922326ULL, 12194330274671844653ULL, 2438866054934368930ULL, 
	4877732109868737861ULL, 9755464219737475723ULL, 1951092843947495144ULL, 
	3902185687894990289ULL, 7804371375789980578ULL, 15608742751579961156ULL, 
	3121748550315992231ULL, 6243497100631984462ULL, 12486994201263968925ULL, 
	2497398840252793785ULL, 4994797680505587570ULL, 9989595361011175140ULL, 
	1997919072202235028ULL, 3995838144404470056ULL, 7991676288808940112ULL, 
	15983352577617880224ULL, 3196670515523576044ULL, 6393341031047152089ULL, 
	12786682062094304179ULL, 2557336412418860835ULL, 5114672824837721671ULL, 
	10229345649675443343ULL, 2045869129935088668ULL, 4091738259870177337ULL, 
	8183476519740354675ULL, 16366953039480709350ULL, 3273390607896141870ULL, 
	6546781215792283740ULL, 13093562431584567480ULL, 2618712486316913496ULL, 
	5237424972633826992ULL, 10474849945267653984ULL, 2094969989053530796ULL, 
	4189939978107061593ULL, 8379879956214123187ULL, 16759759912428246374ULL, 
	3351951982485649274ULL, 6703903964971298549ULL, 13407807929942597099ULL, 
	2681561585988519419ULL, 5363123171977038839ULL, 10726246343954077679ULL, 
	2145249268790815535ULL, 4290498537581631071ULL, 8580997075163262143ULL, 
	17161994150326524287ULL, 3432398830065304857ULL, 6864797660130609714ULL, 
	13729595320261219429ULL, 2745919064052243885ULL, 5491838128104487771ULL, 
	10983676256208975543ULL, 2196735251241795108ULL, 4393470502483590217ULL, 
	8786941004967180435ULL, 17573882009934360870ULL, 3514776401986872174ULL, 
	7029552803973744348ULL, 14059105607947488696ULL, 2811821121589497739ULL, 
	5623642243178995478ULL, 11247284486357990957ULL, 2249456897271598191ULL, 
	4498913794543196382ULL, 8997827589086392765ULL, 17995655178172785531ULL, 
	3599131035634557106ULL, 7198262071269114212ULL, 14396524142538228424ULL, 
	2879304828507645684ULL, 5758609657015291369ULL, 11517219314030582739ULL, 
	2303443862806116547ULL, 4606887725612233095ULL, 9213775451224466191ULL, 
	1842755090244893238ULL, 3685510180489786476ULL, 7371020360979572953ULL, 
	14742040721959145907ULL, 2948408144391829181ULL, 5896816288783658362ULL, 
	11793632577567316725ULL, 2358726515513463345ULL, 4717453031026926690ULL, 
	9434906062053853380ULL, 1886981212410770676ULL, 3773962424821541352ULL, 
	7547924849643082704ULL, 15095849699286165408ULL, 3019169939857233081ULL, 
	6038339879714466163ULL, 12076679759428932327ULL, 2415335951885786465ULL, 
	4830671903771572930ULL, 9661343807543145861ULL, 1932268761508629172ULL, 
	3864537523017258344ULL, 7729075046034516689ULL, 15458150092069033378ULL, 
	3091630018413806675ULL, 6183260036827613351ULL, 12366520073655226703ULL, 
	2473304014731045340ULL, 4946608029462090681ULL, 9893216058924181362ULL, 
	1978643211784836272ULL, 3957286423569672544ULL, 7914572847139345089ULL, 
	15829145694278690179ULL, 3165829138855738035ULL, 6331658277711476071ULL, 
	12663316555422952143ULL, 2532663311084590428ULL, 5065326622169180857ULL, 
	10130653244338361715ULL, 2026130648867672343ULL, 4052261297735344686ULL, 
	8104522595470689372ULL, 16209045190941378744ULL, 3241809038188275748ULL, 
	6483618076376551497ULL, 12967236152753102995ULL, 2593447230550620599ULL, 
	5186894461101241198ULL, 10373788922202482396ULL, 2074757784440496479ULL, 
	4149515568880992958ULL, 8299031137761985917ULL, 16598062275523971834ULL, 
	3319612455104794366ULL, 6639224910209588733ULL, 13278449820419177467ULL, 
	2655689964083835493ULL, 5311379928167670986ULL, 10622759856335341973ULL, 
	2124551971267068394ULL, 4249103942534136789ULL, 8498207885068273579ULL, 
	16996415770136547158ULL, 3399283154027309431ULL, 6798566308054618863ULL, 
	13597132616109237726ULL, 2719426523221847545ULL, 5438853046443695090ULL, 
	10877706092887390181ULL, 2175541218577478036ULL, 4351082437154956072ULL, 
	8702164874309912144ULL, 17404329748619824289ULL, 3480865949723964857ULL, 
	6961731899447929715ULL, 13923463798895859431ULL, 2784692759779171886ULL, 
	5569385519558343772ULL, 11138771039116687545ULL, 2227754207823337509ULL, 
	4455508415646675018ULL, 8911016831293350036ULL, 17822033662586700072ULL, 
	3564406732517340014ULL, 7128813465034680029ULL, 14257626930069360058ULL, 
	2851525386013872011ULL, 5703050772027744023ULL, 11406101544055488046ULL, 
	2281220308811097609ULL, 4562440617622195218ULL, 9124881235244390437ULL, 
	1824976247048878087ULL, 3649952494097756174ULL, 7299904988195512349ULL, 
	14599809976391024699ULL, 2919961995278204939ULL, 5839923990556409879ULL, 
	11679847981112819759ULL, 2335969596222563951ULL, 4671939192445127903ULL, 
	9343878384890255807ULL, 1868775676978051161ULL, 3737551353956102323ULL, 
	7475102707912204646ULL, 14950205415824409292ULL, 2990041083164881858ULL, 
	5980082166329763716ULL, 11960164332659527433ULL, 2392032866531905486ULL, 
	4784065733063810973ULL, 9568131466127621947ULL, 1913626293225524389ULL, 
	3827252586451048778ULL, 7654505172902097557ULL, 15309010345804195115ULL, 
	3061802069160839023ULL, 6123604138321678046ULL, 12247208276643356092ULL, 
	2449441655328671218ULL, 4898883310657342436ULL, 9797766621314684873ULL, 
	1959553324262936974ULL, 3919106648525873949ULL, 7838213297051747899ULL, 
	15676426594103495798ULL, 3135285318820699159ULL, 6270570637641398319ULL, 
	12541141275282796638ULL, 2508228255056559327ULL, 5016456510113118655ULL, 
	10032913020226237310ULL, 2006582604045247462ULL, 4013165208090494924ULL, 
	8026330416180989848ULL, 16052660832361979697ULL, 3210532166472395939ULL, 
	6421064332944791878ULL, 12842128665889583757ULL, 2568425733177916751ULL, 
	5136851466355833503ULL, 10273702932711667006ULL, 2054740586542333401ULL, 
	4109481173084666802ULL, 8218962346169333605ULL, 16437924692338667210ULL, 
	3287584938467733442ULL, 6575169876935466884ULL, 13150339753870933768ULL, 
	2630067950774186753ULL, 5260135901548373507ULL, 10520271803096747014ULL, 
	2104054360619349402ULL, 4208108721238698805ULL, 8416217442477397611ULL, 
	16832434884954795223ULL, 3366486976990959044ULL, 6732973953981918089ULL, 
	13465947907963836178ULL, 2693189581592767235ULL, 5386379163185534471ULL, 
	10772758326371068942ULL, 2154551665274213788ULL, 4309103330548427577ULL, 
	8618206661096855154ULL, 17236413322193710308ULL, 3447282664438742061ULL, 
	6894565328877484123ULL, 13789130657754968246ULL, 2757826131550993649ULL, 
	5515652263101987298ULL, 11031304526203974597ULL, 2206260905240794919ULL, 
	4412521810481589838ULL, 8825043620963179677ULL, 17650087241926359355ULL, 
	3530017448385271871ULL, 7060034896770543742ULL, 14120069793541087484ULL, 
	2824013958708217496ULL, 5648027917416434993ULL, 11296055834832869987ULL, 
	2259211166966573997ULL, 4518422333933147995ULL, 9036844667866295990ULL, 
	18073689335732591980ULL, 3614737867146518396ULL, 7229475734293036792ULL, 
	14458951468586073584ULL, 2891790293717214716ULL, 5783580587434429433ULL, 
	11567161174868858867ULL, 2313432234973771773ULL, 4626864469947543547ULL, 
	9253728939895087094ULL, 1850745787979017418ULL, 3701491575958034837ULL, 
	7402983151916069675ULL, 14805966303832139350ULL, 2961193260766427870ULL, 
	5922386521532855740ULL, 11844773043065711480ULL, 2368954608613142296ULL, 
	4737909217226284592ULL, 9475818434452569184ULL, 1895163686890513836ULL, 
	3790327373781027673ULL, 7580654747562055347ULL, 15161309495124110694ULL, 
	3032261899024822138ULL, 6064523798049644277ULL, 12129047596099288555ULL, 
	2425809519219857711ULL, 4851619038439715422ULL, 9703238076879430844ULL, 
	1940647615375886168ULL, 3881295230751772337ULL, 7762590461503544675ULL, 
	15525180923007089351ULL, 3105036184601417870ULL, 6210072369202835740ULL, 
	12420144738405671481ULL, 2484028947681134296ULL, 4968057895362268592ULL, 
	9936115790724537184ULL, 1987223158144907436ULL, 3974446316289814873ULL, 
	7948892632579629747ULL, 15897785265159259495ULL, 3179557053031851899ULL, 
	6359114106063703798ULL, 12718228212127407596ULL, 2543645642425481519ULL, 
	5087291284850963038ULL, 10174582569701926077ULL, 2034916513940385215ULL, 
	4069833027880770430ULL, 8139666055761540861ULL, 16279332111523081723ULL, 
	3255866422304616344ULL, 6511732844609232689ULL, 13023465689218465379ULL, 
	2604693137843693075ULL, 5209386275687386151ULL, 10418772551374772303ULL, 
	2083754510274954460ULL, 4167509020549908921ULL, 8335018041099817842ULL, 
	16670036082199635685ULL, 3334007216439927137ULL, 6668014432879854274ULL, 
	13336028865759708548ULL, 2667205773151941709ULL, 5334411546303883419ULL, 
	10668823092607766838ULL, 2133764618521553367ULL, 4267529237043106735ULL, 
	8535058474086213470ULL, 17070116948172426941ULL, 3414023389634485388ULL, 
	6828046779268970776ULL, 13656093558537941553ULL, 2731218711707588310ULL, 
	5462437423415176621ULL, 10924874846830353242ULL, 2184974969366070648ULL, 
	4369949938732141297ULL, 8739899877464282594ULL, 17479799754928565188ULL, 
	3495959950985713037ULL, 6991919901971426075ULL, 13983839803942852150ULL, 
	2796767960788570430ULL, 5593535921577140860ULL, 11187071843154281720ULL, 
	2237414368630856344ULL, 4474828737261712688ULL, 8949657474523425376ULL, 
	17899314949046850752ULL, 3579862989809370150ULL, 7159725979618740301ULL, 
	14319451959237480602ULL, 2863890391847496120ULL, 5727780783694992240ULL, 
	11455561567389984481ULL, 2291112313477996896ULL, 4582224626955993792ULL, 
	9164449253911987585ULL, 1832889850782397517ULL, 3665779701564795034ULL, 
	7331559403129590068ULL, 14663118806259180136ULL, 2932623761251836027ULL, 
	5865247522503672054ULL, 11730495045007344109ULL, 2346099009001468821ULL, 
	4692198018002937643ULL, 9384396036005875287ULL, 1876879207201175057ULL, 
	3753758414402350114ULL, 7507516828804700229ULL, 15015033657609400459ULL, 
	3003006731521880091ULL, 6006013463043760183ULL, 12012026926087520367ULL, 
	2402405385217504073ULL, 4804810770435008147ULL, 9609621540870016294ULL, 
	1921924308174003258ULL, 3843848616348006517ULL, 7687697232696013035ULL, 
	15375394465392026070ULL, 3075078893078405214ULL, 6150157786156810428ULL, 
	12300315572313620856ULL, 2460063114462724171ULL, 4920126228925448342ULL, 
	9840252457850896685ULL, 1968050491570179337ULL, 3936100983140358674ULL, 
	7872201966280717348ULL, 15744403932561434696ULL, 3148880786512286939ULL, 
	6297761573024573878ULL, 12595523146049147757ULL, 2519104629209829551ULL, 
	5038209258419659102ULL, 10076418516839318205ULL, 2015283703367863641ULL, 
	4030567406735727282ULL, 8061134813471454564ULL, 16122269626942909129ULL, 
	3224453925388581825ULL, 6448907850777163651ULL, 12897815701554327303ULL, 
	2579563140310865460ULL, 5159126280621730921ULL, 10318252561243461842ULL, 
	2063650512248692368ULL, 4127301024497384737ULL, 8254602048994769474ULL, 
	16509204097989538948ULL, 3301840819597907789ULL, 6603681639195815579ULL, 
	13207363278391631158ULL, 2641472655678326231ULL, 5282945311356652463ULL, 
	10565890622713304927ULL, 2113178124542660985ULL, 4226356249085321970ULL, 
	8452712498170643941ULL, 16905424996341287883ULL, 3381084999268257576ULL, 
	6762169998536515153ULL, 13524339997073030306ULL, 2704867999414606061ULL, 
	5409735998829212122ULL, 10819471997658424245ULL, 2163894399531684849ULL, 
	4327788799063369698ULL, 8655577598126739396ULL, 17311155196253478792ULL, 
	3462231039250695758ULL, 6924462078501391516ULL, 13848924157002783033ULL, 
	2769784831400556606ULL, 5539569662801113213ULL, 11079139325602226427ULL, 
	2215827865120445285ULL, 4431655730240890570ULL, 8863311460481781141ULL, 
	17726622920963562283ULL, 3545324584192712456ULL, 7090649168385424913ULL, 
	14181298336770849826ULL, 2836259667354169965ULL, 5672519334708339930ULL, 
	11345038669416679861ULL, 2269007733883335972ULL, 4538015467766671944ULL, 
	9076030935533343889ULL, 18152061871066687778ULL, 3630412374213337555ULL, 
	7260824748426675111ULL, 14521649496853350222ULL, 2904329899370670044ULL, 
	5808659798741340089ULL, 11617319597482680178ULL, 2323463919496536035ULL, 
	4646927838993072071ULL, 9293855677986144142ULL, 1858771135597228828ULL, 
	3717542271194457656ULL, 7435084542388915313ULL, 14870169084777830627ULL, 
	2974033816955566125ULL, 5948067633911132251ULL, 11896135267822264502ULL, 
	2379227053564452900ULL, 4758454107128905800ULL, 9516908214257811601ULL, 
	1903381642851562320ULL, 3806763285703124640ULL, 7613526571406249281ULL, 
	15227053142812498563ULL, 3045410628562499712ULL, 6090821257124999425ULL, 
	12181642514249998850ULL, 2436328502849999770ULL, 4872657005699999540ULL, 
	9745314011399999080ULL, 1949062802279999816ULL, 3898125604559999632ULL, 
	7796251209119999264ULL, 15592502418239998528ULL, 3118500483647999705ULL, 
	6237000967295999411ULL, 12474001934591998822ULL, 2494800386918399764ULL, 
	4989600773836799529ULL, 9979201547673599058ULL, 1995840309534719811ULL, 
	3991680619069439623ULL, 7983361238138879246ULL, 15966722476277758493ULL, 
	3193344495255551698ULL, 6386688990511103397ULL, 12773377981022206794ULL, 
	2554675596204441358ULL, 5109351192408882717ULL, 10218702384817765435ULL, 
	2043740476963553087ULL, 4087480953927106174ULL, 8174961907854212348ULL, 
	16349923815708424697ULL, 3269984763141684939ULL, 6539969526283369878ULL, 
	13079939052566739757ULL, 2615987810513347951ULL, 5231975621026695903ULL, 
	10463951242053391806ULL, 2092790248410678361ULL, 4185580496821356722ULL, 
	8371160993642713444ULL, 16742321987285426889ULL, 3348464397457085377ULL, 
	6696928794914170755ULL, 13393857589828341511ULL, 2678771517965668302ULL, 
	5357543035931336604ULL, 10715086071862673209ULL, 2143017214372534641ULL, 
	4286034428745069283ULL, 8572068857490138567ULL, 17144137714980277135ULL, 
	3428827542996055427ULL, 6857655085992110854ULL, 13715310171984221708ULL, 
	2743062034396844341ULL, 5486124068793688683ULL, 10972248137587377366ULL, 
	2194449627517475473ULL, 4388899255034950946ULL, 8777798510069901893ULL, 
	17555597020139803786ULL, 3511119404027960757ULL, 7022238808055921514ULL, 
	14044477616111843029ULL, 2808895523222368605ULL, 5617791046444737211ULL, 
	11235582092889474423ULL, 2247116418577894884ULL, 4494232837155789769ULL, 
	8988465674311579538ULL, 17976931348623159077ULL, 3595386269724631815ULL, 
	7190772539449263630ULL, 14381545078898527261ULL, 2876309015779705452ULL, 
	5752618031559410904ULL, 11505236063118821809ULL, 2301047212623764361ULL, 
	4602094425247528723ULL, 9204188850495057447ULL, 1840837770099011489ULL, 
	3681675540198022979ULL, 7363351080396045958ULL, 
};

static const gint32 Formatter_TensExponentTable [] = {
	-323, -323, -322, -322, -322, -322, -321, -321, -321, -320, -320, -320, 
	-319, -319, -319, -319, -318, -318, -318, -317, -317, -317, -316, -316, 
	-316, -316, -315, -315, -315, -314, -314, -314, -313, -313, -313, -313, 
	-312, -312, -312, -311, -311, -311, -310, -310, -310, -310, -309, -309, 
	-309, -308, -308, -308, -307, -307, -307, -307, -306, -306, -306, -305, 
	-305, -305, -304, -304, -304, -304, -303, -303, -303, -302, -302, -302, 
	-301, -301, -301, -301, -300, -300, -300, -299, -299, -299, -298, -298, 
	-298, -298, -297, -297, -297, -296, -296, -296, -295, -295, -295, -295, 
	-294, -294, -294, -293, -293, -293, -292, -292, -292, -291, -291, -291, 
	-291, -290, -290, -290, -289, -289, -289, -288, -288, -288, -288, -287, 
	-287, -287, -286, -286, -286, -285, -285, -285, -285, -284, -284, -284, 
	-283, -283, -283, -282, -282, -282, -282, -281, -281, -281, -280, -280, 
	-280, -279, -279, -279, -279, -278, -278, -278, -277, -277, -277, -276, 
	-276, -276, -276, -275, -275, -275, -274, -274, -274, -273, -273, -273, 
	-273, -272, -272, -272, -271, -271, -271, -270, -270, -270, -270, -269, 
	-269, -269, -268, -268, -268, -267, -267, -267, -267, -266, -266, -266, 
	-265, -265, -265, -264, -264, -264, -263, -263, -263, -263, -262, -262, 
	-262, -261, -261, -261, -260, -260, -260, -260, -259, -259, -259, -258, 
	-258, -258, -257, -257, -257, -257, -256, -256, -256, -255, -255, -255, 
	-254, -254, -254, -254, -253, -253, -253, -252, -252, -252, -251, -251, 
	-251, -251, -250, -250, -250, -249, -249, -249, -248, -248, -248, -248, 
	-247, -247, -247, -246, -246, -246, -245, -245, -245, -245, -244, -244, 
	-244, -243, -243, -243, -242, -242, -242, -242, -241, -241, -241, -240, 
	-240, -240, -239, -239, -239, -239, -238, -238, -238, -237, -237, -237, 
	-236, -236, -236, -235, -235, -235, -235, -234, -234, -234, -233, -233, 
	-233, -232, -232, -232, -232, -231, -231, -231, -230, -230, -230, -229, 
	-229, -229, -229, -228, -228, -228, -227, -227, -227, -226, -226, -226, 
	-226, -225, -225, -225, -224, -224, -224, -223, -223, -223, -223, -222, 
	-222, -222, -221, -221, -221, -220, -220, -220, -220, -219, -219, -219, 
	-218, -218, -218, -217, -217, -217, -217, -216, -216, -216, -215, -215, 
	-215, -214, -214, -214, -214, -213, -213, -213, -212, -212, -212, -211, 
	-211, -211, -211, -210, -210, -210, -209, -209, -209, -208, -208, -208, 
	-208, -207, -207, -207, -206, -206, -206, -205, -205, -205, -204, -204, 
	-204, -204, -203, -203, -203, -202, -202, -202, -201, -201, -201, -201, 
	-200, -200, -200, -199, -199, -199, -198, -198, -198, -198, -197, -197, 
	-197, -196, -196, -196, -195, -195, -195, -195, -194, -194, -194, -193, 
	-193, -193, -192, -192, -192, -192, -191, -191, -191, -190, -190, -190, 
	-189, -189, -189, -189, -188, -188, -188, -187, -187, -187, -186, -186, 
	-186, -186, -185, -185, -185, -184, -184, -184, -183, -183, -183, -183, 
	-182, -182, -182, -181, -181, -181, -180, -180, -180, -180, -179, -179, 
	-179, -178, -178, -178, -177, -177, -177, -176, -176, -176, -176, -175, 
	-175, -175, -174, -174, -174, -173, -173, -173, -173, -172, -172, -172, 
	-171, -171, -171, -170, -170, -170, -170, -169, -169, -169, -168, -168, 
	-168, -167, -167, -167, -167, -166, -166, -166, -165, -165, -165, -164, 
	-164, -164, -164, -163, -163, -163, -162, -162, -162, -161, -161, -161, 
	-161, -160, -160, -160, -159, -159, -159, -158, -158, -158, -158, -157, 
	-157, -157, -156, -156, -156, -155, -155, -155, -155, -154, -154, -154, 
	-153, -153, -153, -152, -152, -152, -152, -151, -151, -151, -150, -150, 
	-150, -149, -149, -149, -149, -148, -148, -148, -147, -147, -147, -146, 
	-146, -146, -145, -145, -145, -145, -144, -144, -144, -143, -143, -143, 
	-142, -142, -142, -142, -141, -141, -141, -140, -140, -140, -139, -139, 
	-139, -139, -138, -138, -138, -137, -137, -137, -136, -136, -136, -136, 
	-135, -135, -135, -134, -134, -134, -133, -133, -133, -133, -132, -132, 
	-132, -131, -131, -131, -130, -130, -130, -130, -129, -129, -129, -128, 
	-128, -128, -127, -127, -127, -127, -126, -126, -126, -125, -125, -125, 
	-124, -124, -124, -124, -123, -123, -123, -122, -122, -122, -121, -121, 
	-121, -121, -120, -120, -120, -119, -119, -119, -118, -118, -118, -117, 
	-117, -117, -117, -116, -116, -116, -115, -115, -115, -114, -114, -114, 
	-114, -113, -113, -113, -112, -112, -112, -111, -111, -111, -111, -110, 
	-110, -110, -109, -109, -109, -108, -108, -108, -108, -107, -107, -107, 
	-106, -106, -106, -105, -105, -105, -105, -104, -104, -104, -103, -103, 
	-103, -102, -102, -102, -102, -101, -101, -101, -100, -100, -100, -99, 
	-99, -99, -99, -98, -98, -98, -97, -97, -97, -96, -96, -96, 
	-96, -95, -95, -95, -94, -94, -94, -93, -93, -93, -93, -92, 
	-92, -92, -91, -91, -91, -90, -90, -90, -89, -89, -89, -89, 
	-88, -88, -88, -87, -87, -87, -86, -86, -86, -86, -85, -85, 
	-85, -84, -84, -84, -83, -83, -83, -83, -82, -82, -82, -81, 
	-81, -81, -80, -80, -80, -80, -79, -79, -79, -78, -78, -78, 
	-77, -77, -77, -77, -76, -76, -76, -75, -75, -75, -74, -74, 
	-74, -74, -73, -73, -73, -72, -72, -72, -71, -71, -71, -71, 
	-70, -70, -70, -69, -69, -69, -68, -68, -68, -68, -67, -67, 
	-67, -66, -66, -66, -65, -65, -65, -65, -64, -64, -64, -63, 
	-63, -63, -62, -62, -62, -62, -61, -61, -61, -60, -60, -60, 
	-59, -59, -59, -58, -58, -58, -58, -57, -57, -57, -56, -56, 
	-56, -55, -55, -55, -55, -54, -54, -54, -53, -53, -53, -52, 
	-52, -52, -52, -51, -51, -51, -50, -50, -50, -49, -49, -49, 
	-49, -48, -48, -48, -47, -47, -47, -46, -46, -46, -46, -45, 
	-45, -45, -44, -44, -44, -43, -43, -43, -43, -42, -42, -42, 
	-41, -41, -41, -40, -40, -40, -40, -39, -39, -39, -38, -38, 
	-38, -37, -37, -37, -37, -36, -36, -36, -35, -35, -35, -34, 
	-34, -34, -34, -33, -33, -33, -32, -32, -32, -31, -31, -31, 
	-30, -30, -30, -30, -29, -29, -29, -28, -28, -28, -27, -27, 
	-27, -27, -26, -26, -26, -25, -25, -25, -24, -24, -24, -24, 
	-23, -23, -23, -22, -22, -22, -21, -21, -21, -21, -20, -20, 
	-20, -19, -19, -19, -18, -18, -18, -18, -17, -17, -17, -16, 
	-16, -16, -15, -15, -15, -15, -14, -14, -14, -13, -13, -13, 
	-12, -12, -12, -12, -11, -11, -11, -10, -10, -10, -9, -9, 
	-9, -9, -8, -8, -8, -7, -7, -7, -6, -6, -6, -6, 
	-5, -5, -5, -4, -4, -4, -3, -3, -3, -3, -2, -2, 
	-2, -1, -1, -1, 0, 0, 0, 1, 1, 1, 1, 2, 
	2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 
	6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 
	9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 
	13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 
	16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20, 
	20, 20, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 
	24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 
	27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 31, 
	31, 31, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 
	35, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 
	38, 38, 39, 39, 39, 40, 40, 40, 41, 41, 41, 41, 
	42, 42, 42, 43, 43, 43, 44, 44, 44, 44, 45, 45, 
	45, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 49, 
	49, 49, 50, 50, 50, 50, 51, 51, 51, 52, 52, 52, 
	53, 53, 53, 53, 54, 54, 54, 55, 55, 55, 56, 56, 
	56, 56, 57, 57, 57, 58, 58, 58, 59, 59, 59, 60, 
	60, 60, 60, 61, 61, 61, 62, 62, 62, 63, 63, 63, 
	63, 64, 64, 64, 65, 65, 65, 66, 66, 66, 66, 67, 
	67, 67, 68, 68, 68, 69, 69, 69, 69, 70, 70, 70, 
	71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 74, 74, 
	74, 75, 75, 75, 75, 76, 76, 76, 77, 77, 77, 78, 
	78, 78, 78, 79, 79, 79, 80, 80, 80, 81, 81, 81, 
	81, 82, 82, 82, 83, 83, 83, 84, 84, 84, 84, 85, 
	85, 85, 86, 86, 86, 87, 87, 87, 88, 88, 88, 88, 
	89, 89, 89, 90, 90, 90, 91, 91, 91, 91, 92, 92, 
	92, 93, 93, 93, 94, 94, 94, 94, 95, 95, 95, 96, 
	96, 96, 97, 97, 97, 97, 98, 98, 98, 99, 99, 99, 
	100, 100, 100, 100, 101, 101, 101, 102, 102, 102, 103, 103, 
	103, 103, 104, 104, 104, 105, 105, 105, 106, 106, 106, 106, 
	107, 107, 107, 108, 108, 108, 109, 109, 109, 109, 110, 110, 
	110, 111, 111, 111, 112, 112, 112, 112, 113, 113, 113, 114, 
	114, 114, 115, 115, 115, 116, 116, 116, 116, 117, 117, 117, 
	118, 118, 118, 119, 119, 119, 119, 120, 120, 120, 121, 121, 
	121, 122, 122, 122, 122, 123, 123, 123, 124, 124, 124, 125, 
	125, 125, 125, 126, 126, 126, 127, 127, 127, 128, 128, 128, 
	128, 129, 129, 129, 130, 130, 130, 131, 131, 131, 131, 132, 
	132, 132, 133, 133, 133, 134, 134, 134, 134, 135, 135, 135, 
	136, 136, 136, 137, 137, 137, 137, 138, 138, 138, 139, 139, 
	139, 140, 140, 140, 140, 141, 141, 141, 142, 142, 142, 143, 
	143, 143, 143, 144, 144, 144, 145, 145, 145, 146, 146, 146, 
	147, 147, 147, 147, 148, 148, 148, 149, 149, 149, 150, 150, 
	150, 150, 151, 151, 151, 152, 152, 152, 153, 153, 153, 153, 
	154, 154, 154, 155, 155, 155, 156, 156, 156, 156, 157, 157, 
	157, 158, 158, 158, 159, 159, 159, 159, 160, 160, 160, 161, 
	161, 161, 162, 162, 162, 162, 163, 163, 163, 164, 164, 164, 
	165, 165, 165, 165, 166, 166, 166, 167, 167, 167, 168, 168, 
	168, 168, 169, 169, 169, 170, 170, 170, 171, 171, 171, 171, 
	172, 172, 172, 173, 173, 173, 174, 174, 174, 175, 175, 175, 
	175, 176, 176, 176, 177, 177, 177, 178, 178, 178, 178, 179, 
	179, 179, 180, 180, 180, 181, 181, 181, 181, 182, 182, 182, 
	183, 183, 183, 184, 184, 184, 184, 185, 185, 185, 186, 186, 
	186, 187, 187, 187, 187, 188, 188, 188, 189, 189, 189, 190, 
	190, 190, 190, 191, 191, 191, 192, 192, 192, 193, 193, 193, 
	193, 194, 194, 194, 195, 195, 195, 196, 196, 196, 196, 197, 
	197, 197, 198, 198, 198, 199, 199, 199, 199, 200, 200, 200, 
	201, 201, 201, 202, 202, 202, 202, 203, 203, 203, 204, 204, 
	204, 205, 205, 205, 206, 206, 206, 206, 207, 207, 207, 208, 
	208, 208, 209, 209, 209, 209, 210, 210, 210, 211, 211, 211, 
	212, 212, 212, 212, 213, 213, 213, 214, 214, 214, 215, 215, 
	215, 215, 216, 216, 216, 217, 217, 217, 218, 218, 218, 218, 
	219, 219, 219, 220, 220, 220, 221, 221, 221, 221, 222, 222, 
	222, 223, 223, 223, 224, 224, 224, 224, 225, 225, 225, 226, 
	226, 226, 227, 227, 227, 227, 228, 228, 228, 229, 229, 229, 
	230, 230, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 
	233, 234, 234, 234, 234, 235, 235, 235, 236, 236, 236, 237, 
	237, 237, 237, 238, 238, 238, 239, 239, 239, 240, 240, 240, 
	240, 241, 241, 241, 242, 242, 242, 243, 243, 243, 243, 244, 
	244, 244, 245, 245, 245, 246, 246, 246, 246, 247, 247, 247, 
	248, 248, 248, 249, 249, 249, 249, 250, 250, 250, 251, 251, 
	251, 252, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255, 
	255, 255, 255, 256, 256, 256, 257, 257, 257, 258, 258, 258, 
	258, 259, 259, 259, 260, 260, 260, 261, 261, 261, 261, 262, 
	262, 262, 263, 263, 263, 264, 264, 264, 265, 265, 265, 265, 
	266, 266, 266, 267, 267, 267, 268, 268, 268, 268, 269, 269, 
	269, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 273, 
	273, 273, 274, 274, 274, 274, 275, 275, 275, 276, 276, 276, 
	277, 277, 277, 277, 278, 278, 278, 279, 279, 279, 280, 280, 
	280, 280, 281, 281, 281, 282, 282, 282, 283, 283, 283, 283, 
	284, 284, 284, 285, 285, 285, 286, 286, 286, 286, 287, 287, 
	287, 288, 288, 288, 289, 289, 289, 289, 290, 290, 290, 291, 
	291, 291, 292, 292, 292, 293, 293, 293, 
};

static const gunichar2 Formatter_DigitLowerTable [] = {
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

static const gunichar2 Formatter_DigitUpperTable [] = {
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

static const gint64 Formatter_TenPowersList [] = {
	1LL,
	10LL,
	100LL,
	1000LL,
	10000LL,
	100000LL,
	1000000LL,
	10000000LL,
	100000000LL,
	1000000000LL,
	10000000000LL,
	100000000000LL,
	1000000000000LL,
	10000000000000LL,
	100000000000000LL,
	1000000000000000LL,
	10000000000000000LL,
	100000000000000000LL,
	1000000000000000000LL,
};

// DecHexDigits s a translation table from a decimal number to its
// digits hexadecimal representation (e.g. DecHexDigits [34] = 0x34).
static const gint32 Formatter_DecHexDigits [] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
};

#endif

```

`Hazel/vendor/mono/include/mono/metadata/number-ms.h`:

```h
/**
 * \file
 */

#ifndef __MONO_NUMBER_MS_H__
#define __MONO_NUMBER_MS_H__

#include <glib.h>

// Double floating point Bias
#define MONO_DOUBLE_BIAS 1022

// Structure to access an encoded double floating point
typedef struct {
#if G_BYTE_ORDER == G_BIG_ENDIAN
	guint sign   : 1;
	guint exp    : 11;
	guint mantHi : 20;
	guint mantLo : 32;

#define MONO_INIT_DOUBLE(sign, exp, mantHi, mantLo) { sign, exp, mantHi, mantLo }

#else // BIGENDIAN
	guint mantLo : 32;
	guint mantHi : 20;
	guint exp    : 11;
	guint sign   : 1;

#define MONO_INIT_DOUBLE(sign, exp, mantHi, mantLo) { mantLo, mantHi, exp, sign }

#endif
} MonoDouble;

typedef union {
	MonoDouble s;
	gdouble d;
} MonoDouble_double;

#endif

```

`Hazel/vendor/mono/include/mono/metadata/object-forward.h`:

```h
/**
 * \file
 *
 * Forward declarations of opaque types, and typedefs thereof.
 *
 */

#ifndef __MONO_OBJECT_FORWARD_H__
#define __MONO_OBJECT_FORWARD_H__

#include <mono/utils/mono-publib.h>

typedef struct _MonoClass MonoClass;
typedef struct _MonoImage MonoImage;
typedef struct _MonoMethod MonoMethod;

typedef struct _MonoObject MONO_RT_MANAGED_ATTR MonoObject;
typedef struct _MonoException MONO_RT_MANAGED_ATTR MonoException;
typedef struct _MonoReflectionAssembly MONO_RT_MANAGED_ATTR MonoReflectionAssembly;
typedef struct _MonoReflectionTypeBuilder MONO_RT_MANAGED_ATTR MonoReflectionTypeBuilder;

#endif /* __MONO_OBJECT_FORWARD_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/object-internals.h`:

```h
/**
 * \file
 */

#ifndef __MONO_OBJECT_INTERNALS_H__
#define __MONO_OBJECT_INTERNALS_H__

#include <mono/utils/mono-forward-internal.h>
#include <mono/metadata/object-forward.h>
#include <mono/metadata/handle-decl.h>

#include <mono/metadata/object.h>
#include <mono/metadata/threads.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/mempool.h>
#include <mono/metadata/class-internals.h>
#include <mono/metadata/threads-types.h>
#include <mono/metadata/handle.h>
#include <mono/metadata/abi-details.h>
#include "mono/utils/mono-compiler.h"
#include "mono/utils/mono-error.h"
#include "mono/utils/mono-error-internals.h"
#include "mono/utils/mono-machine.h"
#include "mono/utils/mono-stack-unwinding.h"
#include "mono/utils/mono-tls.h"
#include "mono/utils/mono-coop-mutex.h"
#include <mono/metadata/icalls.h>

/* Use this as MONO_CHECK_ARG (arg,expr,) in functions returning void */
#define MONO_CHECK_ARG(arg, expr, retval) do {				\
	if (G_UNLIKELY (!(expr)))					\
	{								\
		if (0) { (void)(arg); } /* check if the name exists */	\
		ERROR_DECL (error);					\
		mono_error_set_argument_format (error, #arg, "assertion `%s' failed", #expr); \
		mono_error_set_pending_exception (error);		\
		return retval;						\
	} 								\
} while (0)

#define MONO_CHECK_ARG_NULL_NAMED(arg, argname, retval) do {	\
	if (G_UNLIKELY (!(arg)))				\
	{							\
		ERROR_DECL (error);				\
		mono_error_set_argument_null (error, (argname), "");	\
		mono_error_set_pending_exception (error);	\
		return retval;					\
	}							\
} while (0)
/* Use this as MONO_CHECK_ARG_NULL (arg,) in functions returning void */
#define MONO_CHECK_ARG_NULL(arg, retval) do { 			\
	if (G_UNLIKELY (!(arg)))				\
	{							\
		mono_error_set_argument_null (error, #arg, "");	\
		return retval;					\
	}							\
} while (0)

/* Use this as MONO_CHECK_ARG_NULL_HANDLE (arg,) in functions returning void */
#define MONO_CHECK_ARG_NULL_HANDLE(arg, retval) do { 		\
	if (G_UNLIKELY (MONO_HANDLE_IS_NULL (arg)))		\
	{							\
		mono_error_set_argument_null (error, #arg, "");	\
		return retval;					\
	}							\
} while (0)

#define MONO_CHECK_ARG_NULL_HANDLE_NAMED(arg, argname, retval) do { \
	if (G_UNLIKELY (MONO_HANDLE_IS_NULL (arg)))		\
	{							\
		mono_error_set_argument_null (error, (argname), "");	\
		return retval;					\
	}							\
} while (0)

/* Use this as MONO_CHECK_NULL (arg,) in functions returning void */
#define MONO_CHECK_NULL(arg, retval) do { 			\
	if (G_UNLIKELY (!(arg)))				\
	{							\
		ERROR_DECL (error);				\
		mono_error_set_null_reference (error);		\
		mono_error_set_pending_exception (error);	\
		return retval;					\
	} 							\
} while (0)

MonoClass *
mono_class_create_array (MonoClass *element_class, uint32_t rank);

MonoArrayHandle
mono_array_new_specific_handle (MonoVTable *vtable, uintptr_t n, MonoError *error);

MonoArray*
mono_array_new_specific_checked (MonoVTable *vtable, uintptr_t n, MonoError *error);

/* 
 * Macros which cache.
 * These should be used instead of the original versions.
 */

static inline MonoClass*
mono_array_class_get_cached_function (MonoClass *eclass, MonoClass **aclass)
{
	MonoClass *a = *aclass;
	if (a)
		return a;
	a = mono_class_create_array (eclass, 1);
	g_assert (a);
	if (a)
		*aclass = a;
	return *aclass;
}

// eclass should be a run-time constant
// If you get an error using this macro, you need to manually instantiate the MonoClass *foo ## _array cache.
// See for example object_class_array.
#define mono_array_class_get_cached(eclass) (mono_array_class_get_cached_function ((eclass), &(eclass ## _array)))

static inline MonoArray*
mono_array_new_cached_function (MonoDomain *domain, MonoClass *aclass, int size, MonoError *error)
{
	MonoVTable *vtable = mono_class_vtable_checked (domain, aclass, error);
	MonoArray *arr = NULL;
	if (is_ok (error))
		arr = mono_array_new_specific_checked (vtable, size, error);
	return arr;
}

// eclass should be a run-time constant
// If you get an error using this macro, you need to manually instantiate the MonoClass *foo ## _array cache.
// See for example object_class_array.
#define mono_array_new_cached(domain, eclass, size, error) \
	mono_array_new_cached_function ((domain), mono_array_class_get_cached (eclass), (size), (error))

static inline MonoArrayHandle
mono_array_new_cached_handle_function (MonoDomain *domain, MonoClass *aclass, int size, MonoError *error)
{
	MonoVTable *vtable = mono_class_vtable_checked (domain, aclass, error);
	MonoArrayHandle arr = NULL_HANDLE_ARRAY;
	if (is_ok (error))
		arr = mono_array_new_specific_handle (vtable, size, error);
	return arr;
}

// eclass should be a run-time constant
// If you get an error using this macro, you need to manually instantiate the MonoClass *foo ## _array cache.
// See for example object_class_array.
#define mono_array_new_cached_handle(domain, eclass, size, error) \
	mono_array_new_cached_handle_function ((domain), mono_array_class_get_cached (eclass), (size), (error))

#ifdef MONO_BIG_ARRAYS
typedef uint64_t mono_array_size_t;
typedef int64_t mono_array_lower_bound_t;
#define MONO_ARRAY_MAX_INDEX G_MAXINT64
#define MONO_ARRAY_MAX_SIZE  G_MAXUINT64
#else
typedef uint32_t mono_array_size_t;
typedef int32_t mono_array_lower_bound_t;
#define MONO_ARRAY_MAX_INDEX ((int32_t) 0x7fffffff)
#define MONO_ARRAY_MAX_SIZE  ((uint32_t) 0xffffffff)
#endif

typedef struct {
	mono_array_size_t length;
	mono_array_lower_bound_t lower_bound;
} MonoArrayBounds;

struct _MonoArray {
	MonoObject obj;
	/* bounds is NULL for szarrays */
	MonoArrayBounds *bounds;
	/* total number of elements of the array */
	mono_array_size_t max_length; 
	/* we use mono_64bitaligned_t to ensure proper alignment on platforms that need it */
	mono_64bitaligned_t vector [MONO_ZERO_LEN_ARRAY];
};

#define MONO_SIZEOF_MONO_ARRAY (MONO_STRUCT_OFFSET (MonoArray, vector))

struct _MonoString {
	MonoObject object;
	int32_t length;
	mono_unichar2 chars [MONO_ZERO_LEN_ARRAY];
};

#define MONO_SIZEOF_MONO_STRING (MONO_STRUCT_OFFSET (MonoString, chars))

#define mono_object_class(obj) (((MonoObject*)(obj))->vtable->klass)
#define mono_object_domain(obj) (((MonoObject*)(obj))->vtable->domain)

#define mono_string_chars_fast(s) ((mono_unichar2*)(s)->chars)
#define mono_string_length_fast(s) ((s)->length)

/**
 * mono_array_length_internal:
 * \param array a \c MonoArray*
 * \returns the total number of elements in the array. This works for
 * both vectors and multidimensional arrays.
 */
#define mono_array_length_internal(array) ((array)->max_length)

static inline
uintptr_t
mono_array_handle_length (MonoArrayHandle arr)
{
	MONO_REQ_GC_UNSAFE_MODE;

	return mono_array_length_internal (MONO_HANDLE_RAW (arr));
}

// Equivalent to mono_array_addr_with_size, except:
// 1. A macro instead of a function -- the types of size and index are open.
// 2. mono_array_addr_with_size could, but does not, do GC mode transitions.
#define mono_array_addr_with_size_fast(array,size,index) ( ((char*)(array)->vector) + (size) * (index) )

#define mono_array_addr_fast(array,type,index) ((type*)(void*) mono_array_addr_with_size_fast (array, sizeof (type), index))
#define mono_array_get_fast(array,type,index) ( *(type*)mono_array_addr_fast ((array), type, (index)) )
#define mono_array_set_fast(array,type,index,value)	\
	do {	\
		type *__p = (type *) mono_array_addr_fast ((array), type, (index));	\
		*__p = (value);	\
	} while (0)
#define mono_array_setref_fast(array,index,value)	\
	do {	\
		void **__p = (void **) mono_array_addr_fast ((array), void*, (index));	\
		mono_gc_wbarrier_set_arrayref_internal ((array), __p, (MonoObject*)(value));	\
		/* *__p = (value);*/	\
	} while (0)
#define mono_array_memcpy_refs_fast(dest,destidx,src,srcidx,count)	\
	do {	\
		void **__p = (void **) mono_array_addr_fast ((dest), void*, (destidx));	\
		void **__s = mono_array_addr_fast ((src), void*, (srcidx));	\
		mono_gc_wbarrier_arrayref_copy_internal (__p, __s, (count));	\
	} while (0)

// _internal is like _fast, but preserves the preexisting subtlety of the closed types of things:
//  	int size
//	uintptr_t idx
// in order to mimic non-_internal but without the GC mode transitions, or at least,
// to avoid the runtime using the embedding API, whether or not it has GC mode transitions.
static inline char*
mono_array_addr_with_size_internal (MonoArray *array, int size, uintptr_t idx)
{
	return mono_array_addr_with_size_fast (array, size, idx);
}

#define mono_array_addr_internal(array,type,index) ((type*)(void*) mono_array_addr_with_size_internal (array, sizeof (type), index))
#define mono_array_get_internal(array,type,index) ( *(type*)mono_array_addr_internal ((array), type, (index)) )
#define mono_array_set_internal(array,type,index,value)	\
	do {	\
		type *__p = (type *) mono_array_addr_internal ((array), type, (index));	\
		*__p = (value);	\
	} while (0)
#define mono_array_setref_internal(array,index,value)	\
	do {	\
		void **__p = (void **) mono_array_addr_internal ((array), void*, (index));	\
		mono_gc_wbarrier_set_arrayref_internal ((array), __p, (MonoObject*)(value));	\
		/* *__p = (value);*/	\
	} while (0)
#define mono_array_memcpy_refs_internal(dest,destidx,src,srcidx,count)	\
	do {	\
		void **__p = (void **) mono_array_addr_internal ((dest), void*, (destidx));	\
		void **__s = mono_array_addr_internal ((src), void*, (srcidx));	\
		mono_gc_wbarrier_arrayref_copy_internal (__p, __s, (count));	\
	} while (0)

static inline gboolean
mono_handle_array_has_bounds (MonoArrayHandle arr)
{
	return MONO_HANDLE_GETVAL (arr, bounds) != NULL;
}

static inline void
mono_handle_array_get_bounds_dim (MonoArrayHandle arr, gint32 dim, MonoArrayBounds *bounds)
{
	*bounds = MONO_HANDLE_GETVAL (arr, bounds [dim]);
}

typedef struct {
	MonoObject obj;
#ifndef ENABLE_NETCORE
	MonoObject *identity;
#endif
} MonoMarshalByRefObject;

TYPED_HANDLE_DECL (MonoMarshalByRefObject);

/* This is a copy of System.AppDomain */
struct _MonoAppDomain {
	MonoMarshalByRefObject mbr;
	MonoDomain *data;
};

/* Safely access System.AppDomain from native code */
TYPED_HANDLE_DECL (MonoAppDomain);

/* Safely access System.AppDomainSetup from native code.  (struct is in domain-internals.h) */
TYPED_HANDLE_DECL (MonoAppDomainSetup);

typedef struct _MonoStringBuilder MonoStringBuilder;
TYPED_HANDLE_DECL (MonoStringBuilder);

struct _MonoStringBuilder {
	MonoObject object;
	MonoArray  *chunkChars;
	MonoStringBuilder* chunkPrevious;      // Link to the block logically before this block
	int chunkLength;                  // The index in ChunkChars that represent the end of the block
	int chunkOffset;                  // The logial offset (sum of all characters in previous blocks)
	int maxCapacity;
};

static inline int
mono_string_builder_capacity (MonoStringBuilderHandle sbh)
{
	MonoStringBuilder *sb = MONO_HANDLE_RAW (sbh);
	return sb->chunkOffset + sb->chunkChars->max_length;
}

static inline int
mono_string_builder_string_length (MonoStringBuilderHandle sbh)
{
	MonoStringBuilder *sb = MONO_HANDLE_RAW (sbh);
	return sb->chunkOffset + sb->chunkLength;
}

typedef struct {
	MonoType *type;
	gpointer  value;
	MonoClass *klass;
} MonoTypedRef;

typedef struct {
	gpointer args;
} MonoArgumentHandle;

typedef struct {
	MonoMethodSignature *sig;
	gpointer args;
	gint32 next_arg;
	gint32 num_args;
} MonoArgIterator;

struct _MonoException {
	MonoObject object;
	MonoString *class_name;
	MonoString *message;
	MonoObject *_data;
	MonoObject *inner_ex;
	MonoString *help_link;
	/* Stores the IPs and the generic sharing infos
	   (vtable/MRGCTX) of the frames. */
	MonoArray  *trace_ips;
	MonoString *stack_trace;
	MonoString *remote_stack_trace;
	gint32	    remote_stack_index;
	/* Dynamic methods referenced by the stack trace */
	MonoObject *dynamic_methods;
	gint32	    hresult;
	MonoString *source;
	MonoObject *serialization_manager;
	MonoObject *captured_traces;
	MonoArray  *native_trace_ips;
	gint32 caught_in_unmanaged;
};

typedef struct {
	MonoException base;
} MonoSystemException;

TYPED_HANDLE_DECL (MonoSystemException);

#ifndef ENABLE_NETCORE
typedef struct {
	MonoSystemException base;
	MonoString *param_name;
} MonoArgumentException;
#endif

typedef struct {
	MonoObject   object;
	MonoObject  *async_state;
	MonoObject  *handle;
	MonoObject  *async_delegate;
	gpointer    *data;
	MonoObject  *object_data;
	MonoBoolean  sync_completed;
	MonoBoolean  completed;
	MonoBoolean  endinvoke_called;
	MonoObject  *async_callback;
	MonoObject  *execution_context;
	MonoObject  *original_context;
	gint64	     add_time;
} MonoAsyncResult;

TYPED_HANDLE_DECL (MonoAsyncResult);

typedef struct {
	MonoMarshalByRefObject object;
	gpointer     handle;
} MonoWaitHandle;

TYPED_HANDLE_DECL (MonoWaitHandle);

/* This is a copy of System.Runtime.Remoting.Messaging.CallType */
typedef enum {
	CallType_Sync = 0,
	CallType_BeginInvoke = 1,
	CallType_EndInvoke = 2,
	CallType_OneWay = 3
} MonoCallType;

/* System.Threading.StackCrawlMark */
/*
 * This type is used to identify the method where execution has entered
 * the BCL during stack walks. The outermost public method should
 * define it like this:
 * StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
 * and pass the stackMark as a byref argument down the call chain
 * until it reaches an icall.
 */
typedef enum {
	STACK_CRAWL_ME = 0,
	STACK_CRAWL_CALLER = 1,
	STACK_CRAWL_CALLERS_CALLER = 2,
	STACK_CRAWL_THREAD = 3
} MonoStackCrawlMark;

/* MonoSafeHandle is in class-internals.h. */
/* Safely access System.Net.Sockets.SafeSocketHandle from native code */
TYPED_HANDLE_DECL (MonoSafeHandle);

/* This corresponds to System.Type */
struct _MonoReflectionType {
	MonoObject object;
	MonoType  *type;
};

/* Safely access System.Type from native code */
TYPED_HANDLE_DECL (MonoReflectionType);

typedef struct {
	MonoObject  object;
	MonoReflectionType *class_to_proxy;	
	MonoObject *context;
	MonoObject *unwrapped_server;
	gint32      target_domain_id;
	MonoString *target_uri;
	MonoObject *object_identity;
	MonoObject *obj_TP;
	MonoObject *stub_data;
} MonoRealProxy;

/* Safely access System.Runtime.Remoting.Proxies.RealProxy from native code */
TYPED_HANDLE_DECL (MonoRealProxy);

typedef struct _MonoIUnknown MonoIUnknown;
typedef struct _MonoIUnknownVTable MonoIUnknownVTable;

/* STDCALL on windows, CDECL everywhere else to work with XPCOM and MainWin COM */
#ifdef HOST_WIN32
#define STDCALL __stdcall
#else
#define STDCALL
#endif

struct _MonoIUnknownVTable
{
	int (STDCALL *QueryInterface)(MonoIUnknown *pUnk, gconstpointer riid, gpointer* ppv);
	int (STDCALL *AddRef)(MonoIUnknown *pUnk);
	int (STDCALL *Release)(MonoIUnknown *pUnk);
};

struct _MonoIUnknown
{
	const MonoIUnknownVTable *vtable;
};

typedef struct {
	MonoMarshalByRefObject object;
	MonoIUnknown *iunknown;
	GHashTable* itf_hash;
	MonoObject *synchronization_context;
} MonoComObject;

TYPED_HANDLE_DECL (MonoComObject);

typedef struct {
	MonoRealProxy real_proxy;
	MonoComObject *com_object;
	gint32 ref_count;
} MonoComInteropProxy;

TYPED_HANDLE_DECL (MonoComInteropProxy);

typedef struct {
	MonoObject	 object;
	MonoRealProxy	*rp;	
	MonoRemoteClass *remote_class;
	MonoBoolean	 custom_type_info;
} MonoTransparentProxy;

/* Safely access System.Runtime.Remoting.Proxies.TransparentProxy from native code */
TYPED_HANDLE_DECL (MonoTransparentProxy);

typedef struct {
	MonoObject obj;
	MonoReflectionMethod *method;
	MonoArray  *args;		
	MonoArray  *names;		
	MonoArray  *arg_types;	
	MonoObject *ctx;
	MonoObject *rval;
	MonoObject *exc;
	MonoAsyncResult *async_result;
	guint32	    call_type;
} MonoMethodMessage;

TYPED_HANDLE_DECL (MonoMethodMessage);

/* Keep in sync with the System.MonoAsyncCall */
typedef struct {
	MonoObject object;
	MonoMethodMessage *msg;
	MonoMethod *cb_method;
	MonoDelegate *cb_target;
	MonoObject *state;
	MonoObject *res;
	MonoArray *out_args;
} MonoAsyncCall;

TYPED_HANDLE_DECL (MonoAsyncCall);

typedef struct {
	MonoObject obj;
	MonoArray *frames;
	MonoArray *captured_traces;
	MonoBoolean debug_info;
} MonoStackTrace;

TYPED_HANDLE_DECL (MonoStackTrace);

typedef struct {
	MonoObject obj;
	gint32 il_offset;
	gint32 native_offset;
	gint64 method_address;
	gint32 method_index;
	MonoReflectionMethod *method;
	MonoString *filename;
	gint32 line;
	gint32 column;
	MonoString *internal_method_name;
} MonoStackFrame;

TYPED_HANDLE_DECL (MonoStackFrame);

typedef enum {
	MONO_THREAD_FLAG_DONT_MANAGE = 1, // Don't wait for or abort this thread
	MONO_THREAD_FLAG_NAME_SET = 2, // Thread name set from managed code
	MONO_THREAD_FLAG_APPDOMAIN_ABORT = 4, // Current requested abort originates from appdomain unload
} MonoThreadFlags;

struct _MonoThreadInfo;

typedef struct MonoThreadName {
	char* volatile chars;      // null check outside of lock
	gint32 free; // bool
	gint32 length;
} MonoThreadName;

void
mono_gstring_append_thread_name (GString*, MonoInternalThread*);


/*
 * NETCORE: There is only one thread object,
 * thread->internal_thread points to itself.
 */
struct _MonoInternalThread {
	// FIXME: Mechanize keeping this in sync with managed.
	MonoObject  obj;
	volatile int lock_thread_id; /* to be used as the pre-shifted thread id in thin locks. Used for appdomain_ref push/pop */
	MonoThreadHandle *handle;
	gpointer native_handle;
	MonoThreadName name;
	guint32	    state;      /* must be accessed while longlived->synch_cs is locked */
	MonoException *abort_exc;
	int abort_state_handle;
	guint64 tid;	/* This is accessed as a gsize in the code (so it can hold a 64bit pointer on systems that need it), but needs to reserve 64 bits of space on all machines as it corresponds to a field in managed code */
	gsize debugger_thread; // FIXME switch to bool as soon as CI testing with corlib version bump works
	gpointer *static_data;
	struct _MonoThreadInfo *thread_info;
	MonoAppContext *current_appcontext;
	MonoThread *root_domain_thread;
	MonoObject *_serialized_principal;
	int _serialized_principal_version;
	gpointer appdomain_refs;
	/* This is modified using atomic ops, so keep it a gint32 */
	gint32 __interruption_requested;
	/* data that must live as long as this managed object is not finalized
	 * or as long as the underlying thread is attached, whichever is
	 * longer */
	MonoLongLivedThreadData *longlived;
	MonoBoolean threadpool_thread;
	MonoBoolean thread_interrupt_requested;
	int stack_size;
	guint8	apartment_state;
	gint32 critical_region_level;
	gint32 managed_id;
	guint32 small_id;
	MonoThreadManageCallback manage_callback;
	gsize    flags;
	gpointer thread_pinning_ref;
	gsize __abort_protected_block_count;
	gint32 priority;
	GPtrArray *owned_mutexes;
	MonoOSEvent *suspended;
	gint32 self_suspended; // TRUE | FALSE
	gsize thread_state;

#ifdef ENABLE_NETCORE
	struct _MonoInternalThread *internal_thread;
	MonoObject *start_obj;
	MonoException *pending_exception;
#else
	void* unused [3]; // same size as netcore
#endif
	/* This is used only to check that we are in sync between the representation
	 * of MonoInternalThread in native and InternalThread in managed
	 *
	 * DO NOT RENAME! DO NOT ADD FIELDS AFTER! */
	gpointer last;
};

#ifndef ENABLE_NETCORE
struct _MonoThread {
	MonoObject obj;
	MonoInternalThread *internal_thread;
	MonoObject *start_obj;
	MonoException *pending_exception;
};
#endif

typedef struct {
	guint32 state;
	MonoObject *additional;
} MonoStreamingContext;

#if !ENABLE_NETCORE
typedef struct {
	MonoObject obj;
	MonoBoolean readOnly;
	MonoString *AMDesignator;
	MonoString *PMDesignator;
	MonoString *DateSeparator;
	MonoString *TimeSeparator;
	MonoString *ShortDatePattern;
	MonoString *LongDatePattern;
	MonoString *ShortTimePattern;
	MonoString *LongTimePattern;
	MonoString *MonthDayPattern;
	MonoString *YearMonthPattern;
	guint32 FirstDayOfWeek;
	guint32 CalendarWeekRule;
	MonoArray *AbbreviatedDayNames;
	MonoArray *DayNames;
	MonoArray *MonthNames;
	MonoArray *GenitiveMonthNames;
	MonoArray *AbbreviatedMonthNames;
	MonoArray *GenitiveAbbreviatedMonthNames;
	MonoArray *ShortDatePatterns;
	MonoArray *LongDatePatterns;
	MonoArray *ShortTimePatterns;
	MonoArray *LongTimePatterns;
	MonoArray *MonthDayPatterns;
	MonoArray *YearMonthPatterns;
	MonoArray *ShortestDayNames;
} MonoDateTimeFormatInfo;

typedef struct 
{
	MonoObject obj;
	MonoArray *numberGroupSizes;
	MonoArray *currencyGroupSizes;
	MonoArray *percentGroupSizes;
	MonoString *positiveSign;
	MonoString *negativeSign;
	MonoString *numberDecimalSeparator;
	MonoString *numberGroupSeparator;
	MonoString *currencyGroupSeparator;
	MonoString *currencyDecimalSeparator;
	MonoString *currencySymbol;
	MonoString *ansiCurrencySymbol;	/* unused */
	MonoString *naNSymbol;
	MonoString *positiveInfinitySymbol;
	MonoString *negativeInfinitySymbol;
	MonoString *percentDecimalSeparator;
	MonoString *percentGroupSeparator;
	MonoString *percentSymbol;
	MonoString *perMilleSymbol;
	MonoString *nativeDigits; /* unused */
	gint32 dataItem; /* unused */
	guint32 numberDecimalDigits;
	gint32 currencyDecimalDigits;
	gint32 currencyPositivePattern;
	gint32 currencyNegativePattern;
	gint32 numberNegativePattern;
	gint32 percentPositivePattern;
	gint32 percentNegativePattern;
	gint32 percentDecimalDigits;
} MonoNumberFormatInfo;

typedef struct {
	MonoObject obj;
	gint32 lcid;
	MonoString *icu_name;
	gpointer ICU_collator;
} MonoCompareInfo;

typedef struct {
	MonoObject obj;
	MonoString *NativeName;
	MonoArray *ShortDatePatterns;
	MonoArray *YearMonthPatterns;
	MonoArray *LongDatePatterns;
	MonoString *MonthDayPattern;

	MonoArray *EraNames;
	MonoArray *AbbreviatedEraNames;
	MonoArray *AbbreviatedEnglishEraNames;
	MonoArray *DayNames;
	MonoArray *AbbreviatedDayNames;
	MonoArray *SuperShortDayNames;
	MonoArray *MonthNames;
	MonoArray *AbbreviatedMonthNames;
	MonoArray *GenitiveMonthNames;
	MonoArray *GenitiveAbbreviatedMonthNames;
} MonoCalendarData;

TYPED_HANDLE_DECL (MonoCalendarData);

typedef struct {
	MonoObject obj;
	MonoString *AMDesignator;
	MonoString *PMDesignator;
	MonoString *TimeSeparator;
	MonoArray *LongTimePatterns;
	MonoArray *ShortTimePatterns;
	guint32 FirstDayOfWeek;
	guint32 CalendarWeekRule;
} MonoCultureData;

TYPED_HANDLE_DECL (MonoCultureData);

typedef struct {
	MonoObject obj;
	MonoBoolean is_read_only;
	gint32 lcid;
	gint32 parent_lcid;
	gint32 datetime_index;
	gint32 number_index;
	gint32 calendar_type;
	MonoBoolean use_user_override;
	MonoNumberFormatInfo *number_format;
	MonoDateTimeFormatInfo *datetime_format;
	MonoObject *textinfo;
	MonoString *name;
	MonoString *englishname;
	MonoString *nativename;
	MonoString *iso3lang;
	MonoString *iso2lang;
	MonoString *win3lang;
	MonoString *territory;
	MonoArray *native_calendar_names;
	MonoCompareInfo *compareinfo;
	const void* text_info_data;
} MonoCultureInfo;

TYPED_HANDLE_DECL (MonoCultureInfo);

typedef struct {
	MonoObject obj;
	gint32 geo_id;
	MonoString *iso2name;
	MonoString *iso3name;
	MonoString *win3name;
	MonoString *english_name;
	MonoString *native_name;
	MonoString *currency_symbol;
	MonoString *iso_currency_symbol;
	MonoString *currency_english_name;
	MonoString *currency_native_name;
} MonoRegionInfo;

TYPED_HANDLE_DECL (MonoRegionInfo);

#endif /* !ENABLE_NETCORE */

typedef struct {
	MonoObject object;
	guint32 intType;
} MonoInterfaceTypeAttribute;

/* Safely access System.Delegate from native code */
TYPED_HANDLE_DECL (MonoDelegate);

/* 
 * Callbacks supplied by the runtime and called by the modules in metadata/
 * This interface is easier to extend than adding a new function type +
 * a new 'install' function for every callback.
 */
typedef struct {
	gpointer (*create_ftnptr) (MonoDomain *domain, gpointer addr);
	gpointer (*get_addr_from_ftnptr) (gpointer descr);
	char*    (*get_runtime_build_info) (void);
	const char*    (*get_runtime_build_version) (void);
	gpointer (*get_vtable_trampoline) (MonoVTable *vtable, int slot_index);
	gpointer (*get_imt_trampoline) (MonoVTable *vtable, int imt_slot_index);
	gboolean (*imt_entry_inited) (MonoVTable *vtable, int imt_slot_index);
	void     (*set_cast_details) (MonoClass *from, MonoClass *to);
	void     (*debug_log) (int level, MonoString *category, MonoString *message);
	gboolean (*debug_log_is_enabled) (void);
	void     (*init_delegate) (MonoDelegateHandle delegate, MonoError *error);
	MonoObject* (*runtime_invoke) (MonoMethod *method, void *obj, void **params, MonoObject **exc, MonoError *error);
	void*    (*compile_method) (MonoMethod *method, MonoError *error);
	gpointer (*create_jump_trampoline) (MonoDomain *domain, MonoMethod *method, gboolean add_sync_wrapper, MonoError *error);
	gpointer (*create_jit_trampoline) (MonoDomain *domain, MonoMethod *method, MonoError *error);
	/* used to free a dynamic method */
	void     (*free_method) (MonoDomain *domain, MonoMethod *method);
	gpointer (*create_remoting_trampoline) (MonoDomain *domain, MonoMethod *method, MonoRemotingTarget target, MonoError *error);
	gpointer (*create_delegate_trampoline) (MonoDomain *domain, MonoClass *klass);
	gpointer (*interp_get_remoting_invoke) (MonoMethod *method, gpointer imethod, MonoError *error);
	GHashTable *(*get_weak_field_indexes) (MonoImage *image);
	void     (*install_state_summarizer) (void);
	gboolean (*is_interpreter_enabled) (void);
} MonoRuntimeCallbacks;

typedef gboolean (*MonoInternalStackWalk) (MonoStackFrameInfo *frame, MonoContext *ctx, gpointer data);
typedef gboolean (*MonoInternalExceptionFrameWalk) (MonoMethod *method, gpointer ip, size_t native_offset, gboolean managed, gpointer user_data);

typedef struct {
	void (*mono_walk_stack_with_ctx) (MonoInternalStackWalk func, MonoContext *ctx, MonoUnwindOptions options, void *user_data);
	void (*mono_walk_stack_with_state) (MonoInternalStackWalk func, MonoThreadUnwindState *state, MonoUnwindOptions options, void *user_data);
	void (*mono_raise_exception) (MonoException *ex);
	void (*mono_raise_exception_with_ctx) (MonoException *ex, MonoContext *ctx);
	gboolean (*mono_exception_walk_trace) (MonoException *ex, MonoInternalExceptionFrameWalk func, gpointer user_data);
	gboolean (*mono_install_handler_block_guard) (MonoThreadUnwindState *unwind_state);
	void (*mono_uninstall_current_handler_block_guard) (void);
	gboolean (*mono_current_thread_has_handle_block_guard) (void);
	gboolean (*mono_above_abort_threshold) (void);
	void (*mono_clear_abort_threshold) (void);
	void (*mono_reraise_exception) (MonoException *ex);
	void (*mono_summarize_managed_stack) (MonoThreadSummary *out);
	void (*mono_summarize_unmanaged_stack) (MonoThreadSummary *out);
	void (*mono_summarize_exception) (MonoException *exc, MonoThreadSummary *out);
	void (*mono_register_native_library) (const char *module_path, const char *module_name);
	void (*mono_allow_all_native_libraries) (void);
} MonoRuntimeExceptionHandlingCallbacks;

MONO_COLD void mono_set_pending_exception (MonoException *exc);

/* remoting and async support */

MonoAsyncResult *
mono_async_result_new	    (MonoDomain *domain, gpointer handle, 
			     MonoObject *state, gpointer data, MonoObject *object_data, MonoError *error);
MonoWaitHandle *
mono_wait_handle_new	    (MonoDomain *domain, gpointer handle, MonoError *error);

gpointer
mono_wait_handle_get_handle (MonoWaitHandle *handle);

gboolean
mono_message_init	    (MonoDomain *domain, MonoMethodMessage *this_obj, 
			     MonoReflectionMethod *method, MonoArray *out_args, MonoError *error);

MonoMethodMessage *
mono_method_call_message_new (MonoMethod *method, gpointer *params, MonoMethod *invoke, 
			      MonoDelegate **cb, MonoObject **state, MonoError *error);

void
mono_method_return_message_restore (MonoMethod *method, gpointer *params, MonoArray *out_args, MonoError *error);

gboolean
mono_delegate_ctor_with_method (MonoObjectHandle this_obj, MonoObjectHandle target, gpointer addr, MonoMethod *method, MonoError *error);

gboolean
mono_delegate_ctor	    (MonoObjectHandle this_obj, MonoObjectHandle target, gpointer addr, MonoError *error);

MonoMethod *
mono_get_delegate_invoke_checked (MonoClass *klass, MonoError *error);

MonoMethod *
mono_get_delegate_begin_invoke_checked (MonoClass *klass, MonoError *error);

MonoMethod *
mono_get_delegate_end_invoke_checked (MonoClass *klass, MonoError *error);

void
mono_runtime_free_method    (MonoDomain *domain, MonoMethod *method);

void
mono_install_callbacks      (MonoRuntimeCallbacks *cbs);

MonoRuntimeCallbacks*
mono_get_runtime_callbacks (void);

void
mono_install_eh_callbacks (MonoRuntimeExceptionHandlingCallbacks *cbs);

MonoRuntimeExceptionHandlingCallbacks *
mono_get_eh_callbacks (void);

void
mono_raise_exception_deprecated (MonoException *ex);

void
mono_reraise_exception_deprecated (MonoException *ex);

void
mono_raise_exception_with_context (MonoException *ex, MonoContext *ctx);

void
mono_type_initialization_init (void);

void
mono_type_initialization_cleanup (void);

int
mono_thread_kill           (MonoInternalThread *thread, int signal);

MonoNativeTlsKey
mono_thread_get_tls_key    (void);

gint32
mono_thread_get_tls_offset (void);

MonoNativeTlsKey
mono_domain_get_tls_key    (void);

gint32
mono_domain_get_tls_offset (void);

/* Reflection and Reflection.Emit support */

/*
 * Handling System.Type objects:
 *
 *   Fields defined as System.Type in managed code should be defined as MonoObject* 
 * in unmanaged structures, and the monotype_cast () function should be used for 
 * casting them to MonoReflectionType* to avoid crashes/security issues when 
 * encountering instances of user defined subclasses of System.Type.
 */

#define IS_MONOTYPE(obj) (!(obj) || (m_class_get_image (mono_object_class ((obj))) == mono_defaults.corlib && ((MonoReflectionType*)(obj))->type != NULL))

#define IS_MONOTYPE_HANDLE(obj) IS_MONOTYPE (MONO_HANDLE_RAW (obj))

/* This should be used for accessing members of Type[] arrays */
#define mono_type_array_get(arr,index) monotype_cast (mono_array_get_internal ((arr), gpointer, (index)))

/*
 * Cast an object to MonoReflectionType, making sure it is a System.MonoType or
 * a subclass of it.
 */
static inline MonoReflectionType*
monotype_cast (MonoObject *obj)
{
	g_assert (IS_MONOTYPE (obj));

	return (MonoReflectionType*)obj;
}

/*
 * The following structure must match the C# implementation in our corlib.
 */

struct _MonoReflectionMethod {
	MonoObject object;
	MonoMethod *method;
	MonoString *name;
	MonoReflectionType *reftype;
};

/* Safely access System.Reflection.MonoMethod from native code */
TYPED_HANDLE_DECL (MonoReflectionMethod);

struct _MonoDelegate {
	MonoObject object;
	/* The compiled code of the target method */
	gpointer method_ptr;
	/* The invoke code */
	gpointer invoke_impl;
	MonoObject *target;
	MonoMethod *method;
	gpointer delegate_trampoline;
	/* Extra argument passed to the target method in llvmonly mode */
	gpointer extra_arg;
	/* 
	 * If non-NULL, this points to a memory location which stores the address of 
	 * the compiled code of the method, or NULL if it is not yet compiled.
	 */
	guint8 **method_code;
	gpointer interp_method;
	/* Interp method that is executed when invoking the delegate */
	gpointer interp_invoke_impl;
	MonoReflectionMethod *method_info;
	MonoReflectionMethod *original_method_info;
	MonoObject *data;
	MonoBoolean method_is_virtual;
};

typedef struct _MonoMulticastDelegate MonoMulticastDelegate;
struct _MonoMulticastDelegate {
	MonoDelegate delegate;
	MonoArray *delegates;
};

/* Safely access System.MulticastDelegate from native code */
TYPED_HANDLE_DECL (MonoMulticastDelegate);

struct _MonoReflectionField {
	MonoObject object;
	MonoClass *klass;
	MonoClassField *field;
	MonoString *name;
	MonoReflectionType *type;
	guint32 attrs;
};

/* Safely access System.Reflection.MonoField from native code */
TYPED_HANDLE_DECL (MonoReflectionField);

struct _MonoReflectionProperty {
	MonoObject object;
	MonoClass *klass;
	MonoProperty *property;
};

/* Safely access System.Reflection.MonoProperty from native code */
TYPED_HANDLE_DECL (MonoReflectionProperty);

/*This is System.EventInfo*/
struct _MonoReflectionEvent {
	MonoObject object;
#ifndef ENABLE_NETCORE
	MonoObject *cached_add_event;
#endif
};

/* Safely access System.Reflection.EventInfo from native code */
TYPED_HANDLE_DECL (MonoReflectionEvent);

typedef struct {
	MonoReflectionEvent object;
	MonoClass *klass;
	MonoEvent *event;
} MonoReflectionMonoEvent;

/* Safely access Systme.Reflection.MonoEvent from native code */
TYPED_HANDLE_DECL (MonoReflectionMonoEvent);

typedef struct {
	MonoObject object;
} MonoReflectionParameter;

/* Safely access System.Reflection.ParameterInfo from native code */
TYPED_HANDLE_DECL (MonoReflectionParameter);

struct _MonoReflectionMethodBody {
	MonoObject object;
};

/* Safely access System.Reflection.MethodBody from native code */
TYPED_HANDLE_DECL (MonoReflectionMethodBody);

/* System.RuntimeAssembly */
struct _MonoReflectionAssembly {
	MonoObject object;
	MonoAssembly *assembly;
	/* CAS related */
	MonoObject *evidence;	/* Evidence */
};

typedef struct {
	MonoReflectionType *utype;
	MonoArray *values;
	MonoArray *names;
} MonoEnumInfo;

typedef struct {
	MonoReflectionType *parent;
	MonoReflectionType *ret;
	guint32 attrs;
	guint32 implattrs;
	guint32 callconv;
} MonoMethodInfo;

typedef struct {
	MonoReflectionType *parent;
	MonoReflectionType *declaring_type;
	MonoString *name;
	MonoReflectionMethod *get;
	MonoReflectionMethod *set;
	guint32 attrs;
} MonoPropertyInfo;

typedef struct {
	MonoReflectionType *declaring_type;
	MonoReflectionType *reflected_type;
	MonoString *name;
	MonoReflectionMethod *add_method;
	MonoReflectionMethod *remove_method;
	MonoReflectionMethod *raise_method;
	guint32 attrs;
	MonoArray *other_methods;
} MonoEventInfo;

typedef struct {
	MonoObject *member;
	gint32 code_pos;
} MonoReflectionILTokenInfo;

typedef struct {
	MonoObject object;
	MonoArray *code;
	gint32 code_len;
	gint32 max_stack;
	gint32 cur_stack;
	MonoArray *locals;
	MonoArray *ex_handlers;
	gint32 num_token_fixups;
	MonoArray *token_fixups;
} MonoReflectionILGen;

typedef struct {
	MonoArray *handlers;
	gint32 start;
	gint32 len;
	gint32 label;
} MonoILExceptionInfo;

typedef struct {
	MonoObject *extype;
	gint32 type;
	gint32 start;
	gint32 len;
	gint32 filter_offset;
} MonoILExceptionBlock;

typedef struct {
	MonoObject object;
	MonoObject *catch_type;
	gint32 filter_offset;
	gint32 flags;
	gint32 try_offset;
	gint32 try_length;
	gint32 handler_offset;
	gint32 handler_length;
} MonoReflectionExceptionHandlingClause;


/* Safely access System.Reflection.ExceptionHandlingClause from native code */
TYPED_HANDLE_DECL (MonoReflectionExceptionHandlingClause);

typedef struct {
	MonoObject object;
	MonoReflectionType *local_type;
	MonoBoolean is_pinned;
	guint16 local_index;
} MonoReflectionLocalVariableInfo;

/* Safely access System.Reflection.LocalVariableInfo from native code */
TYPED_HANDLE_DECL (MonoReflectionLocalVariableInfo);

typedef struct {
	/*
	 * Must have the same layout as MonoReflectionLocalVariableInfo, since
	 * LocalBuilder inherits from it under net 2.0.
	 */
	MonoObject object;
	MonoObject *type;
	MonoBoolean is_pinned;
	guint16 local_index;
	MonoString *name;
} MonoReflectionLocalBuilder;

typedef struct {
	MonoObject object;
	gint32 count;
	gint32 type;
	gint32 eltype;
	MonoString *guid;
	MonoString *mcookie;
	MonoString *marshaltype;
	MonoObject *marshaltyperef;
	gint32 param_num;
	MonoBoolean has_size;
} MonoReflectionMarshal;

typedef struct {
	MonoObject object;
	MonoObject* methodb;
	MonoString *name;
	MonoArray *cattrs;
	MonoReflectionMarshal *marshal_info;
	guint32 attrs;
	int position;
	guint32 table_idx;
	MonoObject *def_value;
} MonoReflectionParamBuilder;

typedef struct {
	MonoObject object;
	MonoMethod *mhandle;
	MonoReflectionILGen *ilgen;
	MonoArray *parameters;
	guint32 attrs;
	guint32 iattrs;
	guint32 table_idx;
	guint32 call_conv;
	MonoObject *type;
	MonoArray *pinfo;
	MonoArray *cattrs;
	MonoBoolean init_locals;
	MonoArray *param_modreq;
	MonoArray *param_modopt;
	MonoArray *permissions;
} MonoReflectionCtorBuilder;

/* Safely access System.Reflection.Emit.ConstructorBuilder from native code */
TYPED_HANDLE_DECL (MonoReflectionCtorBuilder);

typedef struct {
	MonoObject object;
	MonoMethod *mhandle;
	MonoObject *rtype;
	MonoArray *parameters;
	guint32 attrs;
	guint32 iattrs;
	MonoString *name;
	guint32 table_idx;
	MonoArray *code;
	MonoReflectionILGen *ilgen;
	MonoObject *type;
	MonoArray *pinfo;
	MonoArray *cattrs;
	MonoArray *override_methods;
	MonoString *dll;
	MonoString *dllentry;
	guint32 charset;
	guint32 extra_flags;
	guint32 native_cc;
	guint32 call_conv;
	MonoBoolean init_locals;
	MonoGenericContainer *generic_container;
	MonoArray *generic_params;
	MonoArray *return_modreq;
	MonoArray *return_modopt;
	MonoArray *param_modreq;
	MonoArray *param_modopt;
	MonoArray *permissions;
} MonoReflectionMethodBuilder;

/* Safely access System.Reflection.Emit.MethodBuilder from native code */
TYPED_HANDLE_DECL (MonoReflectionMethodBuilder);

typedef struct {
	MonoObject object;
	MonoMethod *mhandle;
	MonoReflectionType *parent;
	MonoReflectionType *ret;
	MonoArray *parameters;
	MonoString *name;
	guint32 table_idx;
	guint32 call_conv;
} MonoReflectionArrayMethod;

/* Safely access System.Reflection.Emit.MonoArrayMethod from native code */
TYPED_HANDLE_DECL (MonoReflectionArrayMethod);

typedef struct {
	MonoArray *data;
	MonoString *name;
	MonoString *filename;
	guint32 attrs;
	guint32 offset;
	MonoObject *stream;
} MonoReflectionResource;

typedef struct {
	guint32 res_type;
	guint32 res_id;
	guint32 lang_id;
	MonoArray *res_data;
} MonoReflectionWin32Resource;

typedef struct {
	guint32 action;
	MonoString *pset;
} MonoReflectionPermissionSet;

typedef struct {
	MonoReflectionAssembly assembly;
	MonoDynamicAssembly *dynamic_assembly;
	MonoReflectionMethod *entry_point;
	MonoArray *modules;
	MonoString *name;
	MonoString *dir;
	MonoArray *cattrs;
	MonoArray *resources;
	MonoArray *public_key;
	MonoString *version;
	MonoString *culture;
	guint32 algid;
	guint32 flags;
	guint32 pekind;
	MonoBoolean delay_sign;
	guint32 access;
	MonoArray *loaded_modules;
	MonoArray *win32_resources;
	/* CAS related */
	MonoArray *permissions_minimum;
	MonoArray *permissions_optional;
	MonoArray *permissions_refused;
	gint32 pe_kind;
	gint32 machine;
	MonoBoolean corlib_internal;
	MonoArray *type_forwarders;
	MonoArray *pktoken; /* as hexadecimal byte[] */
} MonoReflectionAssemblyBuilder;

/* Safely access System.Reflection.Emit.AssemblyBuilder from native code */
TYPED_HANDLE_DECL (MonoReflectionAssemblyBuilder);

typedef struct {
	MonoObject object;
	guint32 attrs;
	MonoObject *type;
	MonoString *name;
	MonoObject *def_value;
	gint32 offset;
	MonoReflectionType *typeb;
	MonoArray *rva_data;
	MonoArray *cattrs;
	MonoReflectionMarshal *marshal_info;
	MonoClassField *handle;
	MonoArray *modreq;
	MonoArray *modopt;
} MonoReflectionFieldBuilder;

/* Safely access System.Reflection.Emit.FieldBuilder from native code */ 
TYPED_HANDLE_DECL (MonoReflectionFieldBuilder);

typedef struct {
	MonoObject object;
	guint32 attrs;
	MonoString *name;
	MonoObject *type;
	MonoArray *parameters;
	MonoArray *cattrs;
	MonoObject *def_value;
	MonoReflectionMethodBuilder *set_method;
	MonoReflectionMethodBuilder *get_method;
	gint32 table_idx;
	MonoObject *type_builder;
	MonoArray *returnModReq;
	MonoArray *returnModOpt;
	MonoArray *paramModReq;
	MonoArray *paramModOpt;
	guint32 call_conv;
} MonoReflectionPropertyBuilder;

/* System.RuntimeModule */
struct _MonoReflectionModule {
	MonoObject	obj;
	MonoImage  *image;
	MonoReflectionAssembly *assembly;
	MonoString *fqname;
	MonoString *name;
	MonoString *scopename;
	MonoBoolean is_resource;
	guint32 token;
};

/* Safely access System.Reflection.Module from native code */
TYPED_HANDLE_DECL (MonoReflectionModule);

typedef struct {
	MonoReflectionModule module;
	MonoDynamicImage *dynamic_image;
	gint32     num_types;
	MonoArray *types;
	MonoArray *cattrs;
	MonoArray *guid;
	guint32    table_idx;
	MonoReflectionAssemblyBuilder *assemblyb;
	MonoArray *global_methods;
	MonoArray *global_fields;
	gboolean is_main;
	MonoArray *resources;
	GHashTable *unparented_classes;
	MonoArray *table_indexes;
} MonoReflectionModuleBuilder;

/* Safely acess System.Reflection.Emit.ModuleBuidler from native code */
TYPED_HANDLE_DECL (MonoReflectionModuleBuilder);

typedef enum {
	MonoTypeBuilderNew = 0,
	MonoTypeBuilderEntered = 1,
	MonoTypeBuilderFinished = 2
} MonoTypeBuilderState;

struct _MonoReflectionTypeBuilder {
	MonoReflectionType type;
	MonoString *name;
	MonoString *nspace;
	MonoObject *parent;
	MonoReflectionType *nesting_type;
	MonoArray *interfaces;
	gint32     num_methods;
	MonoArray *methods;
	MonoArray *ctors;
	MonoArray *properties;
	gint32     num_fields;
	MonoArray *fields;
	MonoArray *events;
	MonoArray *cattrs;
	MonoArray *subtypes;
	guint32 attrs;
	guint32 table_idx;
	MonoReflectionModuleBuilder *module;
	gint32 class_size;
	gint32 packing_size;
	MonoGenericContainer *generic_container;
	MonoArray *generic_params;
	MonoArray *permissions;
	MonoReflectionType *created;
	gint32 state;
};

typedef struct {
	MonoReflectionType type;
	MonoReflectionType *element_type;
	gint32 rank;
} MonoReflectionArrayType;

/* Safely access System.Reflection.Emit.ArrayType (in DerivedTypes.cs) from native code */
TYPED_HANDLE_DECL (MonoReflectionArrayType);

typedef struct {
	MonoReflectionType type;
	MonoReflectionType *element_type;
} MonoReflectionDerivedType;

/* Safely access System.Reflection.Emit.SymbolType and subclasses (in DerivedTypes.cs) from native code */
TYPED_HANDLE_DECL (MonoReflectionDerivedType);

typedef struct {
	MonoReflectionType type;
	MonoReflectionTypeBuilder *tbuilder;
	MonoReflectionMethodBuilder *mbuilder;
	MonoString *name;
	guint32 index;
	MonoReflectionType *base_type;
	MonoArray *iface_constraints;
	MonoArray *cattrs;
	guint32 attrs;
} MonoReflectionGenericParam;

/* Safely access System.Reflection.Emit.GenericTypeParameterBuilder from native code */
TYPED_HANDLE_DECL (MonoReflectionGenericParam);

typedef struct {
	MonoReflectionType type;
	MonoReflectionTypeBuilder *tb;
} MonoReflectionEnumBuilder;

/* Safely access System.Reflection.Emit.EnumBuilder from native code */
TYPED_HANDLE_DECL (MonoReflectionEnumBuilder);

typedef struct _MonoReflectionGenericClass MonoReflectionGenericClass;
struct _MonoReflectionGenericClass {
	MonoReflectionType type;
	MonoReflectionType *generic_type; /*Can be either a MonoType or a TypeBuilder*/
	MonoArray *type_arguments;
};

/* Safely access System.Reflection.Emit.TypeBuilderInstantiation from native code */
TYPED_HANDLE_DECL (MonoReflectionGenericClass);

typedef struct {
	MonoObject  obj;
	MonoString *name;
	MonoString *codebase;
	gint32 major, minor, build, revision;
	MonoObject  *cultureInfo;
	guint32     flags;
	guint32     hashalg;
	MonoObject  *keypair;
	MonoArray   *publicKey;
	MonoArray   *keyToken;
	guint32     versioncompat;
	MonoObject *version;
	guint32     processor_architecture;
} MonoReflectionAssemblyName;

/* Safely access System.Reflection.AssemblyName from native code */
TYPED_HANDLE_DECL (MonoReflectionAssemblyName);

typedef struct {
	MonoObject  obj;
	MonoString *name;
	MonoReflectionType *type;
	MonoReflectionTypeBuilder *typeb;
	MonoArray *cattrs;
	MonoReflectionMethodBuilder *add_method;
	MonoReflectionMethodBuilder *remove_method;
	MonoReflectionMethodBuilder *raise_method;
	MonoArray *other_methods;
	guint32 attrs;
	guint32 table_idx;
} MonoReflectionEventBuilder;

typedef struct {
	MonoObject  obj;
	MonoReflectionMethod *ctor;
	MonoArray *data;
} MonoReflectionCustomAttr;

TYPED_HANDLE_DECL (MonoReflectionCustomAttr);

#if ENABLE_NETCORE
typedef struct {
	MonoObject object;
	guint32 utype;
	gint32 safe_array_subtype;
	MonoReflectionType *marshal_safe_array_user_defined_subtype;
	gint32 IidParameterIndex;
	guint32 array_subtype;
	gint16 size_param_index;
	gint32 size_const;
	MonoString *marshal_type;
	MonoReflectionType *marshal_type_ref;
	MonoString *marshal_cookie;
} MonoReflectionMarshalAsAttribute;
#else
typedef struct {
	MonoObject object;
	MonoString *marshal_cookie;
	MonoString *marshal_type;
	MonoReflectionType *marshal_type_ref;
	MonoReflectionType *marshal_safe_array_user_defined_subtype;
	guint32 utype;
	guint32 array_subtype;
	gint32 safe_array_subtype;
	gint32 size_const;
	gint32 IidParameterIndex;
	gint16 size_param_index;
} MonoReflectionMarshalAsAttribute;
#endif

/* Safely access System.Runtime.InteropServices.MarshalAsAttribute */
TYPED_HANDLE_DECL (MonoReflectionMarshalAsAttribute);

typedef struct {
	MonoObject object;
	gint32 call_conv;
	gint32 charset;
	MonoBoolean best_fit_mapping;
	MonoBoolean throw_on_unmappable;
	MonoBoolean set_last_error;
} MonoReflectionUnmanagedFunctionPointerAttribute;

typedef struct {
	MonoObject object;
	MonoString *guid;
} MonoReflectionGuidAttribute;

typedef struct {
	MonoObject object;
	MonoMethod *mhandle;
	MonoString *name;
	MonoReflectionType *rtype;
	MonoArray *parameters;
	guint32 attrs;
	guint32 call_conv;
	MonoReflectionModule *module;
	MonoBoolean skip_visibility;
	MonoBoolean init_locals;
	MonoReflectionILGen *ilgen;
	gint32 nrefs;
	MonoArray *refs;
	GSList *referenced_by;
	MonoReflectionType *owner;
} MonoReflectionDynamicMethod;	

/* Safely access System.Reflection.Emit.DynamicMethod from native code */
TYPED_HANDLE_DECL (MonoReflectionDynamicMethod);

typedef struct {
	MonoObject object;
	MonoReflectionModuleBuilder *module;
	MonoArray *arguments;
	guint32 type;
	MonoReflectionType *return_type;
	guint32 call_conv;
	guint32 unmanaged_call_conv;
	MonoArray *modreqs;
	MonoArray *modopts;
} MonoReflectionSigHelper;

/* Safely access System.Reflection.Emit.SignatureHelper from native code */
TYPED_HANDLE_DECL (MonoReflectionSigHelper);

typedef struct {
	MonoObject object;
	MonoBoolean visible;
} MonoReflectionComVisibleAttribute;

typedef struct {
	MonoObject object;
	MonoReflectionType *type;
} MonoReflectionComDefaultInterfaceAttribute;

enum {
	RESOURCE_LOCATION_EMBEDDED = 1,
	RESOURCE_LOCATION_ANOTHER_ASSEMBLY = 2,
	RESOURCE_LOCATION_IN_MANIFEST = 4
};

typedef struct {
	MonoObject object;
	MonoReflectionAssembly *assembly;
	MonoString *filename;
	guint32 location;
} MonoManifestResourceInfo;

/* Safely access System.Reflection.ManifestResourceInfo from native code */
TYPED_HANDLE_DECL (MonoManifestResourceInfo);

/* A boxed IntPtr */
typedef struct {
	MonoObject object;
	gpointer m_value;
} MonoIntPtr;

/* Keep in sync with System.GenericParameterAttributes */
typedef enum {
	GENERIC_PARAMETER_ATTRIBUTE_NON_VARIANT		= 0,
	GENERIC_PARAMETER_ATTRIBUTE_COVARIANT		= 1,
	GENERIC_PARAMETER_ATTRIBUTE_CONTRAVARIANT	= 2,
	GENERIC_PARAMETER_ATTRIBUTE_VARIANCE_MASK	= 3,

	GENERIC_PARAMETER_ATTRIBUTE_NO_SPECIAL_CONSTRAINT	= 0,
	GENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT	= 4,
	GENERIC_PARAMETER_ATTRIBUTE_VALUE_TYPE_CONSTRAINT	= 8,
	GENERIC_PARAMETER_ATTRIBUTE_CONSTRUCTOR_CONSTRAINT	= 16,
	GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK	= 28
} GenericParameterAttributes;

typedef struct {
	MonoType *type;
	MonoClassField *field;
	MonoProperty *prop;
} CattrNamedArg;

/* All MonoInternalThread instances should be pinned, so it's safe to use the raw ptr.  However
 * for uniformity, icall wrapping will make handles anyway.  So this is the method for getting the payload.
 */
static inline MonoInternalThread*
mono_internal_thread_handle_ptr (MonoInternalThreadHandle h)
{
	/* The SUPPRESS here prevents a Centrinel warning due to merely seeing this
	 * function definition.  Callees will still get a warning unless we
	 * attach a suppress attribute to the declaration.
	 */
	return MONO_HANDLE_SUPPRESS (MONO_HANDLE_RAW (h));
}

gboolean          mono_image_create_pefile (MonoReflectionModuleBuilder *module, gpointer file, MonoError *error);
guint32       mono_image_insert_string (MonoReflectionModuleBuilderHandle module, MonoStringHandle str, MonoError *error);
guint32       mono_image_create_token  (MonoDynamicImage *assembly, MonoObjectHandle obj, gboolean create_methodspec, gboolean register_token, MonoError *error);
void          mono_dynamic_image_free (MonoDynamicImage *image);
void          mono_dynamic_image_free_image (MonoDynamicImage *image);
void          mono_dynamic_image_release_gc_roots (MonoDynamicImage *image);

void        mono_reflection_setup_internal_class  (MonoReflectionTypeBuilder *tb);

void        mono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides, MonoError *error);

void mono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb);

ICALL_EXPORT
void
ves_icall_SymbolType_create_unmanaged_type (MonoReflectionType *type);

void        mono_reflection_register_with_runtime (MonoReflectionType *type);

MonoMethodSignature * mono_reflection_lookup_signature (MonoImage *image, MonoMethod *method, guint32 token, MonoError *error);

MonoArrayHandle mono_param_get_objects_internal  (MonoDomain *domain, MonoMethod *method, MonoClass *refclass, MonoError *error);

MonoClass*
mono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic);
MonoType*
mono_reflection_bind_generic_parameters (MonoReflectionTypeHandle type, int type_argc, MonoType **types, MonoError *error);
void
mono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *fields);

ICALL_EXPORT
MonoReflectionEvent *
ves_icall_TypeBuilder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb);

MonoReflectionMarshalAsAttributeHandle
mono_reflection_marshal_as_attribute_from_marshal_spec (MonoDomain *domain, MonoClass *klass, MonoMarshalSpec *spec, MonoError *error);

gpointer
mono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context, MonoError *error);

gboolean
mono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass, MonoError *error);

gboolean
mono_image_build_metadata (MonoReflectionModuleBuilder *module, MonoError *error);

gboolean
mono_get_constant_value_from_blob (MonoDomain* domain, MonoTypeEnum type, const char *blob, void *value, MonoStringHandleOut string_handle, MonoError *error);

gboolean
mono_metadata_read_constant_value (const char *blob, MonoTypeEnum type, void *value, MonoError *error);

char*
mono_string_from_blob (const char *str, MonoError *error);

void
mono_release_type_locks (MonoInternalThread *thread);

/**
 * mono_string_handle_length:
 * \param s \c MonoString
 * \returns the length in characters of the string
 */
#ifdef ENABLE_CHECKED_BUILD_GC

int
mono_string_handle_length (MonoStringHandle s);

#else

#define mono_string_handle_length(s) (MONO_HANDLE_GETVAL ((s), length))

#endif

char *
mono_string_handle_to_utf8 (MonoStringHandle s, MonoError *error);

char *
mono_string_to_utf8_image (MonoImage *image, MonoStringHandle s, MonoError *error);

MonoArrayHandle
mono_array_clone_in_domain (MonoDomain *domain, MonoArrayHandle array, MonoError *error);

MonoArray*
mono_array_clone_checked (MonoArray *array, MonoError *error);

void
mono_array_full_copy (MonoArray *src, MonoArray *dest);

gboolean
mono_array_calc_byte_len (MonoClass *klass, uintptr_t len, uintptr_t *res);

MonoArray*
mono_array_new_checked (MonoDomain *domain, MonoClass *eclass, uintptr_t n, MonoError *error);

MonoArray*
mono_array_new_full_checked (MonoDomain *domain, MonoClass *array_class, uintptr_t *lengths, intptr_t *lower_bounds, MonoError *error);

ICALL_EXPORT
MonoArray*
ves_icall_array_new (MonoDomain *domain, MonoClass *eclass, uintptr_t n);

ICALL_EXPORT
MonoArray*
ves_icall_array_new_specific (MonoVTable *vtable, uintptr_t n);

#ifndef DISABLE_REMOTING
MonoRemoteClass*
mono_remote_class (MonoDomain *domain, MonoStringHandle class_name, MonoClass *proxy_class, MonoError *error);

gboolean
mono_remote_class_is_interface_proxy (MonoRemoteClass *remote_class);

MonoObject *
mono_remoting_invoke (MonoObject *real_proxy, MonoMethodMessage *msg, MonoObject **exc, MonoArray **out_args, MonoError *error);

gpointer
mono_remote_class_vtable (MonoDomain *domain, MonoRemoteClass *remote_class, MonoRealProxyHandle real_proxy, MonoError *error);

gboolean
mono_upgrade_remote_class (MonoDomain *domain, MonoObjectHandle tproxy, MonoClass *klass, MonoError *error);

void*
mono_load_remote_field_checked (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, void **res, MonoError *error);

MonoObject *
mono_load_remote_field_new_checked (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, MonoError *error);

gboolean
mono_store_remote_field_checked (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, void* val, MonoError *error);

gboolean
mono_store_remote_field_new_checked (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, MonoObject *arg, MonoError *error);


#endif

gpointer
mono_create_ftnptr (MonoDomain *domain, gpointer addr);

gpointer
mono_get_addr_from_ftnptr (gpointer descr);

void
mono_nullable_init (guint8 *buf, MonoObject *value, MonoClass *klass);

void
mono_nullable_init_from_handle (guint8 *buf, MonoObjectHandle value, MonoClass *klass);

void
mono_nullable_init_unboxed (guint8 *buf, gpointer value, MonoClass *klass);

MonoObject *
mono_value_box_checked (MonoDomain *domain, MonoClass *klass, void* val, MonoError *error);

MonoObjectHandle
mono_value_box_handle (MonoDomain *domain, MonoClass *klass, gpointer val, MonoError *error);

MonoObject*
mono_nullable_box (gpointer buf, MonoClass *klass, MonoError *error);

MonoObjectHandle
mono_nullable_box_handle (gpointer buf, MonoClass *klass, MonoError *error);

// A code size optimization (source and object) equivalent to MONO_HANDLE_NEW (MonoObject, NULL);
MonoObjectHandle
mono_new_null (void);

#ifdef MONO_SMALL_CONFIG
#define MONO_IMT_SIZE 9
#else
#define MONO_IMT_SIZE 19
#endif

typedef union {
	int vtable_slot;
	gpointer target_code;
} MonoImtItemValue;

typedef struct _MonoImtBuilderEntry {
	gpointer key;
	struct _MonoImtBuilderEntry *next;
	MonoImtItemValue value;
	int children;
	guint8 has_target_code : 1;
} MonoImtBuilderEntry;

typedef struct _MonoIMTCheckItem MonoIMTCheckItem;

struct _MonoIMTCheckItem {
	gpointer          key;
	int               check_target_idx;
	MonoImtItemValue  value;
	guint8           *jmp_code;
	guint8           *code_target;
	guint8            is_equals;
	guint8            compare_done;
	guint8            chunk_size;
	guint8            short_branch;
	guint8            has_target_code;
};

typedef gpointer (*MonoImtTrampolineBuilder) (MonoVTable *vtable, MonoDomain *domain,
		MonoIMTCheckItem **imt_entries, int count, gpointer fail_trunk);

void
mono_install_imt_trampoline_builder (MonoImtTrampolineBuilder func);

void
mono_set_always_build_imt_trampolines (gboolean value);

void
mono_vtable_build_imt_slot (MonoVTable* vtable, int imt_slot);

guint32
mono_method_get_imt_slot (MonoMethod *method);

void
mono_method_add_generic_virtual_invocation (MonoDomain *domain, MonoVTable *vtable,
											gpointer *vtable_slot,
											MonoMethod *method, gpointer code);

gpointer
mono_method_alloc_generic_virtual_trampoline (MonoDomain *domain, int size);

#define mono_method_alloc_generic_virtual_trampoline(domain, size) (g_cast (mono_method_alloc_generic_virtual_trampoline ((domain), (size))))

typedef enum {
	MONO_UNHANDLED_POLICY_LEGACY,
	MONO_UNHANDLED_POLICY_CURRENT
} MonoRuntimeUnhandledExceptionPolicy;

MonoRuntimeUnhandledExceptionPolicy
mono_runtime_unhandled_exception_policy_get (void);
void
mono_runtime_unhandled_exception_policy_set (MonoRuntimeUnhandledExceptionPolicy policy);

void
mono_unhandled_exception_checked (MonoObjectHandle exc, MonoError *error);

MonoVTable *
mono_class_try_get_vtable (MonoDomain *domain, MonoClass *klass);

gboolean
mono_runtime_run_module_cctor (MonoImage *image, MonoDomain *domain, MonoError *error);

gboolean
mono_runtime_class_init_full (MonoVTable *vtable, MonoError *error);

void
mono_method_clear_object (MonoDomain *domain, MonoMethod *method);

gsize*
mono_class_compute_bitmap (MonoClass *klass, gsize *bitmap, int size, int offset, int *max_set, gboolean static_fields);

MonoObjectHandle
mono_object_xdomain_representation (MonoObjectHandle obj, MonoDomain *target_domain, MonoError *error);

gboolean
mono_class_is_reflection_method_or_constructor (MonoClass *klass);

MonoObjectHandle
mono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob, MonoStringHandleOut string_handle, MonoError *error);

gboolean
mono_class_has_ref_info (MonoClass *klass);

MonoReflectionTypeBuilder*
mono_class_get_ref_info_raw (MonoClass *klass);

void
mono_class_set_ref_info (MonoClass *klass, MonoObjectHandle obj);

void
mono_class_free_ref_info (MonoClass *klass);

MonoObject *
mono_object_new_pinned (MonoDomain *domain, MonoClass *klass, MonoError *error);

MonoObjectHandle
mono_object_new_pinned_handle (MonoDomain *domain, MonoClass *klass, MonoError *error);

MonoObject *
mono_object_new_specific_checked (MonoVTable *vtable, MonoError *error);

ICALL_EXPORT
MonoObject *
ves_icall_object_new (MonoDomain *domain, MonoClass *klass);
	
ICALL_EXPORT
MonoObject *
ves_icall_object_new_specific (MonoVTable *vtable);

MonoObject *
mono_object_new_alloc_specific_checked (MonoVTable *vtable, MonoError *error);

void
mono_field_get_value_internal (MonoObject *obj, MonoClassField *field, void *value);

void
mono_field_static_get_value_checked (MonoVTable *vt, MonoClassField *field, void *value, MonoStringHandleOut string_handle, MonoError *error);

void
mono_field_static_get_value_for_thread (MonoInternalThread *thread, MonoVTable *vt, MonoClassField *field, void *value, MonoStringHandleOut string_handle, MonoError *error);

MonoMethod*
mono_object_handle_get_virtual_method (MonoObjectHandle obj, MonoMethod *method, MonoError *error);

/* exported, used by the debugger */
MONO_API void *
mono_vtable_get_static_field_data (MonoVTable *vt);

MonoObject *
mono_field_get_value_object_checked (MonoDomain *domain, MonoClassField *field, MonoObject *obj, MonoError *error);

MonoObjectHandle
mono_static_field_get_value_handle (MonoDomain *domain, MonoClassField *field, MonoError *error);

gboolean
mono_property_set_value_handle (MonoProperty *prop, MonoObjectHandle obj, void **params, MonoError *error);

MonoObject*
mono_property_get_value_checked (MonoProperty *prop, void *obj, void **params, MonoError *error);

MonoString*
mono_object_try_to_string (MonoObject *obj, MonoObject **exc, MonoError *error);

char *
mono_string_to_utf8_ignore (MonoString *s);

gboolean
mono_monitor_is_il_fastpath_wrapper (MonoMethod *method);

MonoStringHandle
mono_string_is_interned_lookup (MonoStringHandle str, gboolean insert, MonoError *error);

/**
 * mono_string_intern_checked:
 * \param str String to intern
 * \param error set on error.
 * Interns the string passed.
 * \returns The interned string. On failure returns NULL and sets \p error
 */
#define mono_string_intern_checked(str, error) (mono_string_is_interned_lookup ((str), TRUE, (error)))

/**
 * mono_string_is_interned_internal:
 * \param o String to probe
 * \returns Whether the string has been interned.
 */
#define mono_string_is_interned_internal(str, error) (mono_string_is_interned_lookup ((str), FALSE, (error)))

char *
mono_exception_handle_get_native_backtrace (MonoExceptionHandle exc);

char *
mono_exception_get_managed_backtrace (MonoException *exc);

void
mono_copy_value (MonoType *type, void *dest, void *value, int deref_pointer);

void
mono_error_raise_exception_deprecated (MonoError *target_error);

gboolean
mono_error_set_pending_exception_slow (MonoError *error);

static inline gboolean
mono_error_set_pending_exception (MonoError *error)
{
	return is_ok (error) ? FALSE : mono_error_set_pending_exception_slow (error);
}

MonoArray *
mono_glist_to_array (GList *list, MonoClass *eclass, MonoError *error);

MonoObject *
mono_object_new_checked (MonoDomain *domain, MonoClass *klass, MonoError *error);

MonoObjectHandle
mono_object_new_handle (MonoDomain *domain, MonoClass *klass, MonoError *error);

// This function skips handling of remoting and COM.
// "alloc" means "less".
MonoObjectHandle
mono_object_new_alloc_by_vtable (MonoVTable *vtable, MonoError *error);

MonoObject*
mono_object_new_mature (MonoVTable *vtable, MonoError *error);

MonoObjectHandle
mono_object_new_handle_mature (MonoVTable *vtable, MonoError *error);

MonoObject *
mono_object_clone_checked (MonoObject *obj, MonoError *error);

MonoObjectHandle
mono_object_clone_handle (MonoObjectHandle obj, MonoError *error);

MonoObject *
mono_object_isinst_checked (MonoObject *obj, MonoClass *klass, MonoError *error);

MonoObjectHandle
mono_object_handle_isinst (MonoObjectHandle obj, MonoClass *klass, MonoError *error);

MonoObjectHandle
mono_object_handle_isinst_mbyref (MonoObjectHandle obj, MonoClass *klass, MonoError *error);

gboolean
mono_object_handle_isinst_mbyref_raw (MonoObjectHandle obj, MonoClass *klass, MonoError *error);

MonoStringHandle
mono_string_new_size_handle (MonoDomain *domain, gint32 len, MonoError *error);

MonoString*
mono_string_new_len_checked (MonoDomain *domain, const char *text, guint length, MonoError *error);

MonoString *
mono_string_new_size_checked (MonoDomain *domain, gint32 len, MonoError *error);

MonoString*
mono_ldstr_checked (MonoDomain *domain, MonoImage *image, uint32_t str_index, MonoError *error);

MonoStringHandle
mono_ldstr_handle (MonoDomain *domain, MonoImage *image, uint32_t str_index, MonoError *error);

MONO_PROFILER_API MonoString*
mono_string_new_checked (MonoDomain *domain, const char *text, MonoError *merror);

MonoString*
mono_string_new_wtf8_len_checked (MonoDomain *domain, const char *text, guint length, MonoError *error);

MonoString *
mono_string_new_utf16_checked (MonoDomain *domain, const gunichar2 *text, gint32 len, MonoError *error);

MonoStringHandle
mono_string_new_utf16_handle (MonoDomain *domain, const gunichar2 *text, gint32 len, MonoError *error);

MonoStringHandle
mono_string_new_utf8_len (MonoDomain *domain, const char *text, guint length, MonoError *error);

MonoString *
mono_string_from_utf16_checked (const mono_unichar2 *data, MonoError *error);

MonoString *
mono_string_from_utf32_checked (const mono_unichar4 *data, MonoError *error);

char*
mono_ldstr_utf8 (MonoImage *image, guint32 idx, MonoError *error);

char*
mono_utf16_to_utf8 (const mono_unichar2 *s, gsize slength, MonoError *error);

char*
mono_utf16_to_utf8len (const mono_unichar2 *s, gsize slength, gsize *utf8_length, MonoError *error);

gboolean
mono_runtime_object_init_checked (MonoObject *this_obj, MonoError *error);

MONO_PROFILER_API MonoObject*
mono_runtime_try_invoke (MonoMethod *method, void *obj, void **params, MonoObject **exc, MonoError *error);

// The exc parameter is deliberately missing and so far this has proven to reduce code duplication.
// In particular, if an exception is returned from underlying otherwise succeeded call,
// is set into the MonoError with mono_error_set_exception_instance.
// The result is that caller need only check MonoError.
MonoObjectHandle
mono_runtime_try_invoke_handle (MonoMethod *method, MonoObjectHandle obj, void **params, MonoError* error);

MonoObject*
mono_runtime_invoke_checked (MonoMethod *method, void *obj, void **params, MonoError *error);

MonoObjectHandle
mono_runtime_invoke_handle (MonoMethod *method, MonoObjectHandle obj, void **params, MonoError* error);

void
mono_runtime_invoke_handle_void (MonoMethod *method, MonoObjectHandle obj, void **params, MonoError* error);

MonoObject*
mono_runtime_try_invoke_array (MonoMethod *method, void *obj, MonoArray *params,
			       MonoObject **exc, MonoError *error);

MonoObject*
mono_runtime_invoke_array_checked (MonoMethod *method, void *obj, MonoArray *params,
				   MonoError *error);

void* 
mono_compile_method_checked (MonoMethod *method, MonoError *error);

MonoObject*
mono_runtime_delegate_try_invoke (MonoObject *delegate, void **params,
				  MonoObject **exc, MonoError *error);

MonoObject*
mono_runtime_delegate_invoke_checked (MonoObject *delegate, void **params,
				      MonoError *error);

MonoArrayHandle
mono_runtime_get_main_args_handle (MonoError *error);

int
mono_runtime_run_main_checked (MonoMethod *method, int argc, char* argv[],
			       MonoError *error);

int
mono_runtime_try_run_main (MonoMethod *method, int argc, char* argv[],
			   MonoObject **exc);

int
mono_runtime_exec_main_checked (MonoMethod *method, MonoArray *args, MonoError *error);

int
mono_runtime_try_exec_main (MonoMethod *method, MonoArray *args, MonoObject **exc);

MonoAssembly*
mono_try_assembly_resolve_handle (MonoAssemblyLoadContext *alc, MonoStringHandle fname, MonoAssembly *requesting, gboolean refonly, MonoError *error);

gboolean
mono_runtime_object_init_handle (MonoObjectHandle this_obj, MonoError *error);

/* GC write barriers support */
void
mono_gc_wbarrier_object_copy_handle (MonoObjectHandle obj, MonoObjectHandle src);

MonoMethod*
mono_class_get_virtual_method (MonoClass *klass, MonoMethod *method, gboolean is_proxy, MonoError *error);

MonoStringHandle
mono_string_empty_handle (MonoDomain *domain);

/*
 * mono_object_get_data:
 *
 *   Return a pointer to the beginning of data inside a MonoObject.
 */
static inline gpointer
mono_object_get_data (MonoObject *o)
{
	return (guint8*)o + MONO_ABI_SIZEOF (MonoObject);
}

#define mono_handle_get_data_unsafe(handle) ((gpointer)((guint8*)MONO_HANDLE_RAW (handle) + MONO_ABI_SIZEOF (MonoObject)))

gpointer
mono_vtype_get_field_addr (gpointer vtype, MonoClassField *field);

#define MONO_OBJECT_SETREF_INTERNAL(obj,fieldname,value) do {	\
		mono_gc_wbarrier_set_field_internal ((MonoObject*)(obj), &((obj)->fieldname), (MonoObject*)value);	\
		/*(obj)->fieldname = (value);*/	\
	} while (0)

/* This should be used if 's' can reside on the heap */
#define MONO_STRUCT_SETREF_INTERNAL(s,field,value) do { \
        mono_gc_wbarrier_generic_store_internal (&((s)->field), (MonoObject*)(value)); \
    } while (0)

static inline gunichar2*
mono_string_chars_internal (MonoString *s)
{
	MONO_REQ_GC_UNSAFE_MODE;
	return s->chars;
}

static inline int
mono_string_length_internal (MonoString *s)
{
	MONO_REQ_GC_UNSAFE_MODE;
	return s->length;
}

MonoString*
mono_string_empty_internal (MonoDomain *domain);

char *
mono_string_to_utf8len (MonoStringHandle s, gsize *utf8len, MonoError *error);

char*
mono_string_to_utf8_checked_internal (MonoString *string_obj, MonoError *error);

mono_bool
mono_string_equal_internal (MonoString *s1, MonoString *s2);

unsigned
mono_string_hash_internal (MonoString *s);

int
mono_object_hash_internal (MonoObject* obj);

ICALL_EXTERN_C
void
mono_value_copy_internal (void* dest, const void* src, MonoClass *klass);

void
mono_value_copy_array_internal (MonoArray *dest, int dest_idx, const void* src, int count);

MONO_PROFILER_API MonoVTable* mono_object_get_vtable_internal (MonoObject *obj);

MonoDomain*
mono_object_get_domain_internal (MonoObject *obj);

static inline gpointer
mono_object_unbox_internal (MonoObject *obj)
{
	/* add assert for valuetypes? */
	g_assert (m_class_is_valuetype (mono_object_class (obj)));
	return mono_object_get_data (obj);
}

ICALL_EXPORT
void
mono_monitor_exit_internal (MonoObject *obj);

MONO_PROFILER_API unsigned mono_object_get_size_internal (MonoObject *o);

MONO_PROFILER_API MonoDomain* mono_vtable_domain_internal (MonoVTable *vtable);

MONO_PROFILER_API MonoClass* mono_vtable_class_internal (MonoVTable *vtable);

MonoMethod*
mono_object_get_virtual_method_internal (MonoObject *obj, MonoMethod *method);

MonoMethod*
mono_get_delegate_invoke_internal (MonoClass *klass);

MonoMethod*
mono_get_delegate_begin_invoke_internal (MonoClass *klass);

MonoMethod*
mono_get_delegate_end_invoke_internal (MonoClass *klass);

void
mono_unhandled_exception_internal (MonoObject *exc);

void
mono_print_unhandled_exception_internal (MonoObject *exc);

void
mono_raise_exception_internal (MonoException *ex);

void
mono_field_set_value_internal (MonoObject *obj, MonoClassField *field, void *value);

void
mono_field_static_set_value_internal (MonoVTable *vt, MonoClassField *field, void *value);

void
mono_field_get_value_internal (MonoObject *obj, MonoClassField *field, void *value);

MonoMethod* mono_get_context_capture_method (void);

guint8*
mono_runtime_get_aotid_arr (void);

/* GC handles support
 *
 * A handle can be created to refer to a managed object and either prevent it
 * from being garbage collected or moved or to be able to know if it has been
 * collected or not (weak references).
 * mono_gchandle_new () is used to prevent an object from being garbage collected
 * until mono_gchandle_free() is called. Use a TRUE value for the pinned argument to
 * prevent the object from being moved (this should be avoided as much as possible
 * and this should be used only for shorts periods of time or performance will suffer).
 * To create a weakref use mono_gchandle_new_weakref (): track_resurrection should
 * usually be false (see the GC docs for more details).
 * mono_gchandle_get_target () can be used to get the object referenced by both kinds
 * of handle: for a weakref handle, if an object has been collected, it will return NULL.
 */
uint32_t
mono_gchandle_new_internal (MonoObject *obj, mono_bool pinned);

uint32_t
mono_gchandle_new_weakref_internal (MonoObject *obj, mono_bool track_resurrection);

ICALL_EXTERN_C
MonoObject*
mono_gchandle_get_target_internal (uint32_t gchandle);

void mono_gchandle_free_internal (uint32_t gchandle);

/* Reference queue support
 *
 * A reference queue is used to get notifications of when objects are collected.
 * Call mono_gc_reference_queue_new to create a new queue and pass the callback that
 * will be invoked when registered objects are collected.
 * Call mono_gc_reference_queue_add to register a pair of objects and data within a queue.
 * The callback will be triggered once an object is both unreachable and finalized.
 */
MonoReferenceQueue*
mono_gc_reference_queue_new_internal (mono_reference_queue_callback callback);

void
mono_gc_reference_queue_free_internal (MonoReferenceQueue *queue);

mono_bool
mono_gc_reference_queue_add_internal (MonoReferenceQueue *queue, MonoObject *obj, void *user_data);

#define mono_gc_reference_queue_add_handle(queue, obj, user_data) \
	(mono_gc_reference_queue_add_internal ((queue), MONO_HANDLE_RAW (MONO_HANDLE_CAST (MonoObject, obj)), (user_data)))

/* GC write barriers support */
void
mono_gc_wbarrier_set_field_internal (MonoObject *obj, void* field_ptr, MonoObject* value);

void
mono_gc_wbarrier_set_arrayref_internal  (MonoArray *arr, void* slot_ptr, MonoObject* value);

void
mono_gc_wbarrier_arrayref_copy_internal (void* dest_ptr, const void* src_ptr, int count);

void
mono_gc_wbarrier_generic_store_internal (void volatile* ptr, MonoObject* value);

void
mono_gc_wbarrier_generic_store_atomic_internal (void *ptr, MonoObject *value);

ICALL_EXTERN_C
void
mono_gc_wbarrier_generic_nostore_internal (void* ptr);

void
mono_gc_wbarrier_value_copy_internal (void* dest, const void* src, int count, MonoClass *klass);

void
mono_gc_wbarrier_object_copy_internal (MonoObject* obj, MonoObject *src);

#endif /* __MONO_OBJECT_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/object-offsets.h`:

```h

/**
\file
This is a parameterized header. It's supposed/ok to be included multiple times.

Input defines: (those to be defined by the includer file)

Required:
DECL_OFFSET(struct,field)
DECL_OFFSET2(struct,field,offset)
DECL_ALIGN2(name,alignment)

Optional:
USE_CROSS_COMPILE_OFFSETS - if defined, force the cross compiler offsets to be used, otherwise
	they will only be used if MONO_CROSS_COMPILE is defined
DISABLE_METADATA_OFFSETS - Disable the definition of offsets for structures defined in metadata/.
DISABLE_JIT_OFFSETS - Disable the definition of offsets for structures defined in mini/.

The last two are needed because metadata shouldn't include JIT offsets since the structures
are not defined, while the JIT shouldn't include metadata offsets, since some of them
are GC specific, and the JIT needs to remain GC agnostic.

Output defines:

HAS_CROSS_COMPILER_OFFSETS - if set, it means we found some cross offsets, it doesnt mean we'll use it.
USED_CROSS_COMPILER_OFFSETS - if set, it means we used the cross offsets

Environment defines (from config.h and CFLAGS):

MONO_GENERATING_OFFSETS - Set by an offsets generating tool to disable the usage of any (possibly non-existing) generated header.
MONO_OFFSETS_FILE - Name of the header file containing the offsets to be used.

*/


#undef HAS_CROSS_COMPILER_OFFSETS
#undef USED_CROSS_COMPILER_OFFSETS

#if !defined (MONO_GENERATING_OFFSETS) && defined (MONO_OFFSETS_FILE)
#include MONO_OFFSETS_FILE
#endif

#ifndef USED_CROSS_COMPILER_OFFSETS

DECL_SIZE(gint8)
DECL_SIZE(gint16)
DECL_SIZE(gint32)
DECL_SIZE(gint64)
DECL_SIZE(float)
DECL_SIZE(double)
DECL_SIZE(gpointer)

// Offsets for structures defined in metadata/
#ifndef DISABLE_METADATA_OFFSETS
DECL_OFFSET(MonoObject, vtable)
DECL_OFFSET(MonoObject, synchronisation)

DECL_OFFSET(MonoClass, interface_bitmap)
DECL_OFFSET(MonoClass, _byval_arg)
DECL_OFFSET(MonoClass, cast_class)
DECL_OFFSET(MonoClass, element_class)
DECL_OFFSET(MonoClass, idepth)
DECL_OFFSET(MonoClass, instance_size)
DECL_OFFSET(MonoClass, interface_id)
DECL_OFFSET(MonoClass, max_interface_id)
DECL_OFFSET(MonoClass, parent)
DECL_OFFSET(MonoClass, rank)
DECL_OFFSET(MonoClass, sizes)
DECL_OFFSET(MonoClass, supertypes)
DECL_OFFSET(MonoClass, class_kind)

DECL_OFFSET(MonoVTable, klass)
DECL_OFFSET(MonoVTable, max_interface_id)
DECL_OFFSET(MonoVTable, interface_bitmap)
DECL_OFFSET(MonoVTable, vtable)
DECL_OFFSET(MonoVTable, rank)
DECL_OFFSET(MonoVTable, initialized)
DECL_OFFSET(MonoVTable, flags)
DECL_OFFSET(MonoVTable, type)
DECL_OFFSET(MonoVTable, runtime_generic_context)

DECL_OFFSET(MonoDomain, stack_overflow_ex)

DECL_OFFSET(MonoDelegate, target)
DECL_OFFSET(MonoDelegate, method_ptr)
DECL_OFFSET(MonoDelegate, invoke_impl)
DECL_OFFSET(MonoDelegate, method)
DECL_OFFSET(MonoDelegate, method_code)
DECL_OFFSET(MonoDelegate, method_is_virtual)
DECL_OFFSET(MonoDelegate, extra_arg)

DECL_OFFSET(MonoInternalThread, tid)
DECL_OFFSET(MonoInternalThread, small_id)
DECL_OFFSET(MonoInternalThread, static_data)
DECL_OFFSET(MonoInternalThread, last)

DECL_OFFSET(MonoMulticastDelegate, delegates)

DECL_OFFSET(MonoTransparentProxy, rp)
DECL_OFFSET(MonoTransparentProxy, remote_class)
DECL_OFFSET(MonoTransparentProxy, custom_type_info)

DECL_OFFSET(MonoRealProxy, target_domain_id)
DECL_OFFSET(MonoRealProxy, context)
DECL_OFFSET(MonoRealProxy, unwrapped_server)

DECL_OFFSET(MonoRemoteClass, proxy_class)

DECL_OFFSET(MonoArray, vector)
DECL_OFFSET(MonoArray, max_length)
DECL_OFFSET(MonoArray, bounds)

DECL_OFFSET(MonoArrayBounds, lower_bound)
DECL_OFFSET(MonoArrayBounds, length)

DECL_OFFSET(MonoSafeHandle, handle)

DECL_OFFSET(MonoHandleRef, handle)

DECL_OFFSET(MonoComInteropProxy, com_object)

DECL_OFFSET(MonoString, length)
DECL_OFFSET(MonoString, chars)

DECL_OFFSET(MonoException, message)

DECL_OFFSET(MonoTypedRef, type)
DECL_OFFSET(MonoTypedRef, klass)
DECL_OFFSET(MonoTypedRef, value)

//Internal structs
DECL_OFFSET(MonoThreadsSync, status)
DECL_OFFSET(MonoThreadsSync, nest)

DECL_OFFSET(MonoProfilerCallContext, method)
DECL_OFFSET(MonoProfilerCallContext, return_value)
DECL_OFFSET(MonoProfilerCallContext, args)

#ifdef HAVE_SGEN_GC
DECL_OFFSET(SgenClientThreadInfo, in_critical_region)
DECL_OFFSET(SgenThreadInfo, tlab_next)
DECL_OFFSET(SgenThreadInfo, tlab_temp_end)
#endif

#endif //DISABLE METADATA OFFSETS

// Offsets for structures defined in mini/
#ifndef DISABLE_JIT_OFFSETS
DECL_SIZE(MonoMethodRuntimeGenericContext)
DECL_SIZE(MonoLMF)
DECL_SIZE(MonoTypedRef)
DECL_SIZE(CallContext)
DECL_SIZE(MonoContext)

DECL_OFFSET(MonoLMF, previous_lmf)

DECL_OFFSET(MonoMethodRuntimeGenericContext, class_vtable)

DECL_OFFSET(MonoJitTlsData, lmf)
DECL_OFFSET(MonoJitTlsData, class_cast_from)
DECL_OFFSET(MonoJitTlsData, class_cast_to)

DECL_OFFSET(MonoGSharedVtMethodRuntimeInfo, locals_size)
DECL_OFFSET(MonoGSharedVtMethodRuntimeInfo, entries) //XXX more to fix here

DECL_OFFSET(MonoContinuation, stack_used_size)
DECL_OFFSET(MonoContinuation, saved_stack)
DECL_OFFSET(MonoContinuation, return_sp)
DECL_OFFSET(MonoContinuation, lmf)
DECL_OFFSET(MonoContinuation, return_ip)

DECL_OFFSET(MonoDelegateTrampInfo, method)
DECL_OFFSET(MonoDelegateTrampInfo, invoke_impl)
DECL_OFFSET(MonoDelegateTrampInfo, method_ptr)

// Architecture-specific offsets
// -----------------------------

#if defined(TARGET_WASM)
DECL_OFFSET(MonoContext, wasm_ip)
DECL_OFFSET(MonoContext, wasm_bp)
DECL_OFFSET(MonoContext, wasm_sp)
DECL_OFFSET(MonoContext, llvm_exc_reg)

DECL_OFFSET(MonoLMF, lmf_addr)

#elif defined(TARGET_X86)
DECL_OFFSET(MonoContext, eax)
DECL_OFFSET(MonoContext, ebx)
DECL_OFFSET(MonoContext, ecx)
DECL_OFFSET(MonoContext, edx)
DECL_OFFSET(MonoContext, edi)
DECL_OFFSET(MonoContext, esi)
DECL_OFFSET(MonoContext, esp)
DECL_OFFSET(MonoContext, ebp)
DECL_OFFSET(MonoContext, eip)

DECL_OFFSET(MonoLMF, method)
DECL_OFFSET(MonoLMF, lmf_addr)
DECL_OFFSET(MonoLMF, esp)
DECL_OFFSET(MonoLMF, ebx)
DECL_OFFSET(MonoLMF, edi)
DECL_OFFSET(MonoLMF, esi)
DECL_OFFSET(MonoLMF, ebp)
DECL_OFFSET(MonoLMF, eip)
#elif defined(TARGET_AMD64)
DECL_OFFSET(MonoContext, gregs)
DECL_OFFSET(MonoContext, fregs)

DECL_OFFSET(MonoLMF, rsp)
DECL_OFFSET(MonoLMF, rbp)

DECL_OFFSET(DynCallArgs, res)

DECL_OFFSET(MonoLMFTramp, ctx)
DECL_OFFSET(MonoLMFTramp, lmf_addr)
#elif defined(TARGET_ARM)
DECL_OFFSET(MonoLMF, sp)
DECL_OFFSET(MonoLMF, fp)
DECL_OFFSET(MonoLMF, ip)
DECL_OFFSET(MonoLMF, iregs)
DECL_OFFSET(MonoLMF, fregs)
DECL_OFFSET(DynCallArgs, fpregs)
DECL_OFFSET(DynCallArgs, has_fpregs)
DECL_OFFSET(DynCallArgs, regs)
DECL_OFFSET(DynCallArgs, n_stackargs)
DECL_OFFSET(SeqPointInfo, ss_tramp_addr)
#elif defined(TARGET_ARM64)
DECL_OFFSET(MonoLMF, pc)
DECL_OFFSET(MonoLMF, gregs)
DECL_OFFSET(DynCallArgs, regs)
DECL_OFFSET(DynCallArgs, fpregs)
DECL_OFFSET(DynCallArgs, n_stackargs)
DECL_OFFSET(DynCallArgs, n_fpargs)
DECL_OFFSET(DynCallArgs, n_fpret)
#endif

// Shared architecture offfsets
// ----------------------------

#if defined(TARGET_ARM) || defined(TARGET_ARM64)
DECL_OFFSET (MonoContext, pc)
DECL_OFFSET (MonoContext, regs)
DECL_OFFSET (MonoContext, fregs)

DECL_OFFSET(MonoLMF, lmf_addr)

DECL_OFFSET(DynCallArgs, res)
DECL_OFFSET(DynCallArgs, res2)
#endif

#if defined(TARGET_ARM)
DECL_OFFSET(MonoLMF, method)
DECL_OFFSET(GSharedVtCallInfo, stack_usage)
DECL_OFFSET(GSharedVtCallInfo, vret_arg_reg)
DECL_OFFSET(GSharedVtCallInfo, ret_marshal)
DECL_OFFSET(GSharedVtCallInfo, vret_slot)
DECL_OFFSET(GSharedVtCallInfo, gsharedvt_in)

DECL_OFFSET(SeqPointInfo, ss_trigger_page)
#endif

#if defined(TARGET_ARM64)
DECL_OFFSET (MonoContext, has_fregs)

DECL_OFFSET(GSharedVtCallInfo, stack_usage)
DECL_OFFSET(GSharedVtCallInfo, gsharedvt_in)
DECL_OFFSET(GSharedVtCallInfo, ret_marshal)
DECL_OFFSET(GSharedVtCallInfo, vret_slot)
#endif

#if defined(TARGET_AMD64) || defined(TARGET_ARM64)
DECL_OFFSET(SeqPointInfo, ss_tramp_addr)
#endif

#if defined(TARGET_AMD64) || defined(TARGET_ARM) || defined(TARGET_ARM64)
DECL_OFFSET(SeqPointInfo, bp_addrs)

DECL_OFFSET(CallContext, gregs)
DECL_OFFSET(CallContext, fregs)
DECL_OFFSET(CallContext, stack_size)
DECL_OFFSET(CallContext, stack)
#endif

#if defined(TARGET_X86)
DECL_OFFSET(GSharedVtCallInfo, stack_usage)
DECL_OFFSET(GSharedVtCallInfo, vret_slot)
DECL_OFFSET(GSharedVtCallInfo, vret_arg_slot)
DECL_OFFSET(GSharedVtCallInfo, ret_marshal)
DECL_OFFSET(GSharedVtCallInfo, gsharedvt_in)
#endif

DECL_OFFSET(MonoFtnDesc, arg)
DECL_OFFSET(MonoFtnDesc, addr)

#endif //DISABLE_JIT_OFFSETS

#endif //USED_CROSS_COMPILER_OFFSETS

#undef DECL_OFFSET
#undef DECL_OFFSET2
#undef DECL_ALIGN2
#undef DECL_SIZE
#undef DECL_SIZE2
#undef USE_CROSS_COMPILE_OFFSETS

```

`Hazel/vendor/mono/include/mono/metadata/object.h`:

```h
/**
 * \file
 */

#ifndef _MONO_CLI_OBJECT_H_
#define _MONO_CLI_OBJECT_H_

#include <mono/utils/mono-forward.h>
#include <mono/metadata/object-forward.h>
#include <mono/metadata/class.h>
#include <mono/utils/mono-error.h>

MONO_BEGIN_DECLS

typedef struct _MonoString MONO_RT_MANAGED_ATTR MonoString;
typedef struct _MonoArray MONO_RT_MANAGED_ATTR MonoArray;
typedef struct _MonoReflectionMethod MONO_RT_MANAGED_ATTR MonoReflectionMethod;
typedef struct _MonoReflectionModule MONO_RT_MANAGED_ATTR MonoReflectionModule;
typedef struct _MonoReflectionField MONO_RT_MANAGED_ATTR MonoReflectionField;
typedef struct _MonoReflectionProperty MONO_RT_MANAGED_ATTR MonoReflectionProperty;
typedef struct _MonoReflectionEvent MONO_RT_MANAGED_ATTR MonoReflectionEvent;
typedef struct _MonoReflectionType MONO_RT_MANAGED_ATTR MonoReflectionType;
typedef struct _MonoDelegate MONO_RT_MANAGED_ATTR MonoDelegate;
typedef struct _MonoThreadsSync MonoThreadsSync;
#ifdef ENABLE_NETCORE
typedef struct _MonoInternalThread MONO_RT_MANAGED_ATTR MonoThread;
#else
typedef struct _MonoThread MONO_RT_MANAGED_ATTR MonoThread;
#endif
typedef struct _MonoDynamicAssembly MonoDynamicAssembly;
typedef struct _MonoDynamicImage MonoDynamicImage;
typedef struct _MonoReflectionMethodBody MONO_RT_MANAGED_ATTR MonoReflectionMethodBody;
typedef struct _MonoAppContext MONO_RT_MANAGED_ATTR MonoAppContext;

struct _MonoObject {
	MonoVTable *vtable;
	MonoThreadsSync *synchronisation;
};

typedef MonoObject* (*MonoInvokeFunc)	     (MonoMethod *method, void *obj, void **params, MonoObject **exc, MonoError *error);
typedef void*    (*MonoCompileFunc)	     (MonoMethod *method);
typedef void	    (*MonoMainThreadFunc)    (void* user_data);

#define MONO_OBJECT_SETREF(obj,fieldname,value) do {	\
		mono_gc_wbarrier_set_field ((MonoObject*)(obj), &((obj)->fieldname), (MonoObject*)value);	\
		/*(obj)->fieldname = (value);*/	\
	} while (0)

/* This should be used if 's' can reside on the heap */
#define MONO_STRUCT_SETREF(s,field,value) do { \
        mono_gc_wbarrier_generic_store (&((s)->field), (MonoObject*)(value)); \
    } while (0)

#define mono_array_addr(array,type,index) ((type*)mono_array_addr_with_size ((array), sizeof (type), (index)))
#define mono_array_get(array,type,index) ( *(type*)mono_array_addr ((array), type, (index)) ) 
#define mono_array_set(array,type,index,value)	\
	do {	\
		type *__p = (type *) mono_array_addr ((array), type, (index));	\
		*__p = (value);	\
	} while (0)
#define mono_array_setref(array,index,value)	\
	do {	\
		void **__p = (void **) mono_array_addr ((array), void*, (index));	\
		mono_gc_wbarrier_set_arrayref ((array), __p, (MonoObject*)(value));	\
		/* *__p = (value);*/	\
	} while (0)
#define mono_array_memcpy_refs(dest,destidx,src,srcidx,count)	\
	do {	\
		void **__p = (void **) mono_array_addr ((dest), void*, (destidx));	\
		void **__s = mono_array_addr ((src), void*, (srcidx));	\
		mono_gc_wbarrier_arrayref_copy (__p, __s, (count));	\
	} while (0)

MONO_API MONO_RT_EXTERNAL_ONLY mono_unichar2 *mono_string_chars  (MonoString *s);
MONO_API MONO_RT_EXTERNAL_ONLY int            mono_string_length (MonoString *s);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_object_new		    (MonoDomain *domain, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoObject *
mono_object_new_specific    (MonoVTable *vtable);

/* can be used for classes without finalizer in non-profiling mode */
MONO_API MONO_RT_EXTERNAL_ONLY
MonoObject *
mono_object_new_fast	    (MonoVTable *vtable);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoObject *
mono_object_new_alloc_specific (MonoVTable *vtable);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoObject *
mono_object_new_from_token  (MonoDomain *domain, MonoImage *image, uint32_t token);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray*
mono_array_new		    (MonoDomain *domain, MonoClass *eclass, uintptr_t n);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray*
mono_array_new_full	    (MonoDomain *domain, MonoClass *array_class,
			     uintptr_t *lengths, intptr_t *lower_bounds);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray *
mono_array_new_specific	    (MonoVTable *vtable, uintptr_t n);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray*
mono_array_clone	    (MonoArray *array);

MONO_API MONO_RT_EXTERNAL_ONLY char*
mono_array_addr_with_size   (MonoArray *array, int size, uintptr_t idx);

MONO_API MONO_RT_EXTERNAL_ONLY uintptr_t
mono_array_length           (MonoArray *array);

MONO_API MONO_RT_EXTERNAL_ONLY MonoString*
mono_string_empty	      (MonoDomain *domain);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_empty_wrapper   (void);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_new_utf16	    (MonoDomain *domain, const mono_unichar2 *text, int32_t len);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_new_size	    (MonoDomain *domain, int32_t len);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_ldstr		    (MonoDomain *domain, MonoImage *image, uint32_t str_index);

MONO_API MONO_RT_EXTERNAL_ONLY MonoString*
mono_string_is_interned	    (MonoString *str);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_intern	    (MonoString *str);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_new		    (MonoDomain *domain, const char *text);

MONO_API MONO_RT_EXTERNAL_ONLY MonoString*
mono_string_new_wrapper	    (const char *text);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_new_len	    (MonoDomain *domain, const char *text, unsigned int length);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString*
mono_string_new_utf32	    (MonoDomain *domain, const mono_unichar4 *text, int32_t len);

MONO_API MONO_RT_EXTERNAL_ONLY
char *
mono_string_to_utf8	    (MonoString *string_obj);

MONO_API MONO_RT_EXTERNAL_ONLY char *
mono_string_to_utf8_checked (MonoString *string_obj, MonoError *error);

MONO_API MONO_RT_EXTERNAL_ONLY mono_unichar2 *
mono_string_to_utf16	    (MonoString *string_obj);

MONO_API MONO_RT_EXTERNAL_ONLY mono_unichar4 *
mono_string_to_utf32	    (MonoString *string_obj);

MONO_API MONO_RT_EXTERNAL_ONLY MonoString *
mono_string_from_utf16	    (/*const*/ mono_unichar2 *data);

MONO_API MONO_RT_EXTERNAL_ONLY MonoString *
mono_string_from_utf32	    (/*const*/ mono_unichar4 *data);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_string_equal           (MonoString *s1, MonoString *s2);

MONO_API MONO_RT_EXTERNAL_ONLY unsigned int
mono_string_hash            (MonoString *s);

MONO_API MONO_RT_EXTERNAL_ONLY int
mono_object_hash            (MonoObject* obj);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoString *
mono_object_to_string (MonoObject *obj, MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_value_box		    (MonoDomain *domain, MonoClass *klass, void* val);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_value_copy             (void* dest, /*const*/ void* src, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_value_copy_array       (MonoArray *dest, int dest_idx, void* src, int count);

MONO_API MONO_RT_EXTERNAL_ONLY MonoVTable*
mono_object_get_vtable      (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY MonoDomain*
mono_object_get_domain      (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass*
mono_object_get_class       (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY void*
mono_object_unbox	    (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_object_clone	    (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_object_isinst	    (MonoObject *obj, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_object_isinst_mbyref   (MonoObject *obj, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_object_castclass_mbyref (MonoObject *obj, MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_monitor_try_enter       (MonoObject *obj, uint32_t ms);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_monitor_enter           (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_monitor_enter_v4        (MonoObject *obj, char *lock_taken);

MONO_API MONO_RT_EXTERNAL_ONLY unsigned int
mono_object_get_size         (MonoObject *o);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_monitor_exit            (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_raise_exception	    (MonoException *ex);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_runtime_set_pending_exception (MonoException *exc, mono_bool overwrite);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_reraise_exception	    (MonoException *ex);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_runtime_object_init    (MonoObject *this_obj);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_runtime_class_init	    (MonoVTable *vtable);

MONO_API MONO_RT_EXTERNAL_ONLY MonoDomain*
mono_vtable_domain          (MonoVTable *vtable);

MONO_API MONO_RT_EXTERNAL_ONLY MonoClass*
mono_vtable_class           (MonoVTable *vtable);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod*
mono_object_get_virtual_method (MonoObject *obj, MonoMethod *method);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject*
mono_runtime_invoke	    (MonoMethod *method, void *obj, void **params,
			     MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod*
mono_get_delegate_invoke    (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod*
mono_get_delegate_begin_invoke (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoMethod*
mono_get_delegate_end_invoke (MonoClass *klass);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject*
mono_runtime_delegate_invoke (MonoObject *delegate, void **params,
			      MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject*
mono_runtime_invoke_array   (MonoMethod *method, void *obj, MonoArray *params,
			     MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY void*
mono_method_get_unmanaged_thunk (MonoMethod *method);

MONO_API MONO_RT_EXTERNAL_ONLY MonoArray*
mono_runtime_get_main_args  (void);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_runtime_exec_managed_code (MonoDomain *domain,
				MonoMainThreadFunc main_func,
				void* main_args);

MONO_API MONO_RT_EXTERNAL_ONLY int
mono_runtime_run_main	    (MonoMethod *method, int argc, char* argv[], 
			     MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY int
mono_runtime_exec_main	    (MonoMethod *method, MonoArray *args,
			     MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY int
mono_runtime_set_main_args  (int argc, char* argv[]);

/* The following functions won't be available with mono was configured with remoting disabled. */
/*#ifndef DISABLE_REMOTING */
MONO_API MONO_RT_EXTERNAL_ONLY void*
mono_load_remote_field (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, void **res);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_load_remote_field_new (MonoObject *this_obj, MonoClass *klass, MonoClassField *field);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_store_remote_field (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, void* val);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_store_remote_field_new (MonoObject *this_obj, MonoClass *klass, MonoClassField *field, MonoObject *arg);

/* #endif */

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_unhandled_exception    (MonoObject *exc);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_print_unhandled_exception (MonoObject *exc);

MONO_API MONO_RT_EXTERNAL_ONLY
void*
mono_compile_method	   (MonoMethod *method);

/* accessors for fields and properties */
MONO_API MONO_RT_EXTERNAL_ONLY void
mono_field_set_value (MonoObject *obj, MonoClassField *field, void *value);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_field_static_set_value (MonoVTable *vt, MonoClassField *field, void *value);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_field_get_value (MonoObject *obj, MonoClassField *field, void *value);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_field_static_get_value (MonoVTable *vt, MonoClassField *field, void *value);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject *
mono_field_get_value_object (MonoDomain *domain, MonoClassField *field, MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_property_set_value (MonoProperty *prop, void *obj, void **params, MonoObject **exc);

MONO_API MONO_RT_EXTERNAL_ONLY MonoObject*
mono_property_get_value (MonoProperty *prop, void *obj, void **params, MonoObject **exc);

/* GC handles support
 *
 * A handle can be created to refer to a managed object and either prevent it
 * from being garbage collected or moved or to be able to know if it has been 
 * collected or not (weak references).
 * mono_gchandle_new () is used to prevent an object from being garbage collected
 * until mono_gchandle_free() is called. Use a TRUE value for the pinned argument to
 * prevent the object from being moved (this should be avoided as much as possible 
 * and this should be used only for shorts periods of time or performance will suffer).
 * To create a weakref use mono_gchandle_new_weakref (): track_resurrection should
 * usually be false (see the GC docs for more details).
 * mono_gchandle_get_target () can be used to get the object referenced by both kinds
 * of handle: for a weakref handle, if an object has been collected, it will return NULL.
 */
MONO_API MONO_RT_EXTERNAL_ONLY uint32_t     mono_gchandle_new         (MonoObject *obj, mono_bool pinned);
MONO_API MONO_RT_EXTERNAL_ONLY uint32_t     mono_gchandle_new_weakref (MonoObject *obj, mono_bool track_resurrection);
MONO_API MONO_RT_EXTERNAL_ONLY MonoObject*  mono_gchandle_get_target  (uint32_t gchandle);
MONO_API MONO_RT_EXTERNAL_ONLY void         mono_gchandle_free        (uint32_t gchandle);

/* Reference queue support
 *
 * A reference queue is used to get notifications of when objects are collected.
 * Call mono_gc_reference_queue_new to create a new queue and pass the callback that
 * will be invoked when registered objects are collected.
 * Call mono_gc_reference_queue_add to register a pair of objects and data within a queue.
 * The callback will be triggered once an object is both unreachable and finalized.
 */

typedef void (*mono_reference_queue_callback) (void *user_data);
typedef struct _MonoReferenceQueue MonoReferenceQueue;

MONO_API MONO_RT_EXTERNAL_ONLY MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_reference_queue_free (MonoReferenceQueue *queue);
MONO_API MONO_RT_EXTERNAL_ONLY mono_bool mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data);

/* GC write barriers support */
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_set_field     (MonoObject *obj, void* field_ptr, MonoObject* value);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_set_arrayref  (MonoArray *arr, void* slot_ptr, MonoObject* value);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_arrayref_copy (void* dest_ptr, /*const*/ void* src_ptr, int count);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_generic_store (void* ptr, MonoObject* value);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_generic_store_atomic (void *ptr, MonoObject *value);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_generic_nostore (void* ptr);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_value_copy    (void* dest, /*const*/ void* src, int count, MonoClass *klass);
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_wbarrier_object_copy   (MonoObject* obj, MonoObject *src);

MONO_END_DECLS

#endif

```

`Hazel/vendor/mono/include/mono/metadata/opcodes.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_OPCODES_H__
#define __MONO_METADATA_OPCODES_H__

/*
 * opcodes.h: CIL instruction information
 *
 * Author:
 *   Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2002 Ximian, Inc.
 */

#include <mono/utils/mono-publib.h>

MONO_BEGIN_DECLS

#define MONO_CUSTOM_PREFIX 0xf0

#define OPDEF(a,b,c,d,e,f,g,h,i,j) \
	MONO_ ## a,

typedef enum MonoOpcodeEnum {
	MonoOpcodeEnum_Invalid = -1,
#include "mono/cil/opcode.def"
	MONO_CEE_LAST
} MonoOpcodeEnum;

#undef OPDEF

enum {
	MONO_FLOW_NEXT,
	MONO_FLOW_BRANCH,
	MONO_FLOW_COND_BRANCH,
	MONO_FLOW_ERROR,
	MONO_FLOW_CALL,
	MONO_FLOW_RETURN,
	MONO_FLOW_META
};

enum {
	MonoInlineNone          = 0,
	MonoInlineType          = 1,
	MonoInlineField         = 2,
	MonoInlineMethod        = 3,
	MonoInlineTok           = 4,
	MonoInlineString        = 5,
	MonoInlineSig           = 6,
	MonoInlineVar           = 7,
	MonoShortInlineVar      = 8,
	MonoInlineBrTarget      = 9,
	MonoShortInlineBrTarget = 10,
	MonoInlineSwitch        = 11,
	MonoInlineR             = 12,
	MonoShortInlineR        = 13,
	MonoInlineI             = 14,
	MonoShortInlineI        = 15,
	MonoInlineI8            = 16,
};

typedef struct {
	unsigned char argument;
	unsigned char flow_type;
	unsigned short opval;
} MonoOpcode;

MONO_API_DATA const MonoOpcode mono_opcodes [];

MONO_API const char*
mono_opcode_name (int opcode);

MONO_API MonoOpcodeEnum
mono_opcode_value (const mono_byte **ip, const mono_byte *end);

MONO_END_DECLS

#endif /* __MONO_METADATA_OPCODES_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/profiler-events.h`:

```h
/*
 * Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
 */

/*
 * To #include this file, #define the following macros first:
 *
 * MONO_PROFILER_EVENT_0(name, type)
 * MONO_PROFILER_EVENT_1(name, type, arg1_type, arg1_name)
 * MONO_PROFILER_EVENT_2(name, type, arg1_type, arg1_name, arg2_type, arg2_name)
 * MONO_PROFILER_EVENT_3(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name)
 * MONO_PROFILER_EVENT_4(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name)
 * MONO_PROFILER_EVENT_5(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name, arg5_type, arg5_name)
 *
 * To add new callbacks to the API, simply add a line in this file and use
 * MONO_PROFILER_RAISE to raise the event wherever.
 *
 * If you need more arguments then the current macros provide, add another
 * macro and update all areas where the macros are used. Remember that this is
 * a public header and not all users will be defining the newly added macro. So
 * to prevent errors in existing code, you must add something like this at the
 * beginning of this file:
 *
 * #ifndef MONO_PROFILER_EVENT_6
 * #define MONO_PROFILER_EVENT_6(...) # Do nothing.
 * #endif
 */

#ifndef MONO_PROFILER_EVENT_5
#define MONO_PROFILER_EVENT_5(...)
#endif

MONO_PROFILER_EVENT_0(runtime_initialized, RuntimeInitialized)
MONO_PROFILER_EVENT_0(runtime_shutdown_begin, RuntimeShutdownBegin)
MONO_PROFILER_EVENT_0(runtime_shutdown_end, RuntimeShutdownEnd)

MONO_PROFILER_EVENT_1(context_loaded, ContextLoaded, MonoAppContext *, context)
MONO_PROFILER_EVENT_1(context_unloaded, ContextUnloaded, MonoAppContext *, context)

MONO_PROFILER_EVENT_1(domain_loading, DomainLoading, MonoDomain *, domain)
MONO_PROFILER_EVENT_1(domain_loaded, DomainLoaded, MonoDomain *, domain)
MONO_PROFILER_EVENT_1(domain_unloading, DomainUnloading, MonoDomain *, domain)
MONO_PROFILER_EVENT_1(domain_unloaded, DomainUnloaded, MonoDomain *, domain)
MONO_PROFILER_EVENT_2(domain_name, DomainName, MonoDomain *, domain, const char *, name)

MONO_PROFILER_EVENT_1(jit_begin, JitBegin, MonoMethod *, method)
MONO_PROFILER_EVENT_1(jit_failed, JitFailed, MonoMethod *, method)
MONO_PROFILER_EVENT_2(jit_done, JitDone, MonoMethod *, method, MonoJitInfo *, jinfo)
MONO_PROFILER_EVENT_2(jit_chunk_created, JitChunkCreated, const mono_byte *, chunk, uintptr_t, size)
MONO_PROFILER_EVENT_1(jit_chunk_destroyed, JitChunkDestroyed, const mono_byte *, chunk)
MONO_PROFILER_EVENT_4(jit_code_buffer, JitCodeBuffer, const mono_byte *, buffer, uint64_t, size, MonoProfilerCodeBufferType, type, const void *, data)

MONO_PROFILER_EVENT_1(class_loading, ClassLoading, MonoClass *, klass)
MONO_PROFILER_EVENT_1(class_failed, ClassFailed, MonoClass *, klass)
MONO_PROFILER_EVENT_1(class_loaded, ClassLoaded, MonoClass *, klass)

MONO_PROFILER_EVENT_1(vtable_loading, VTableLoading, MonoVTable *, vtable)
MONO_PROFILER_EVENT_1(vtable_failed, VTableFailed, MonoVTable *, vtable)
MONO_PROFILER_EVENT_1(vtable_loaded, VTableLoaded, MonoVTable *, vtable)

MONO_PROFILER_EVENT_1(image_loading, ModuleLoading, MonoImage *, image)
MONO_PROFILER_EVENT_1(image_failed, ModuleFailed, MonoImage *, image)
MONO_PROFILER_EVENT_1(image_loaded, ModuleLoaded, MonoImage *, image)
MONO_PROFILER_EVENT_1(image_unloading, ModuleUnloading, MonoImage *, image)
MONO_PROFILER_EVENT_1(image_unloaded, ModuleUnloaded, MonoImage *, image)

MONO_PROFILER_EVENT_1(assembly_loading, AssemblyLoading, MonoAssembly *, assembly)
MONO_PROFILER_EVENT_1(assembly_loaded, AssemblyLLoaded, MonoAssembly *, assembly)
MONO_PROFILER_EVENT_1(assembly_unloading, AssemblyLUnloading, MonoAssembly *, assembly)
MONO_PROFILER_EVENT_1(assembly_unloaded, AssemblyLUnloaded, MonoAssembly *, assembly)

MONO_PROFILER_EVENT_2(method_enter, MethodEnter, MonoMethod *, method, MonoProfilerCallContext *, context)
MONO_PROFILER_EVENT_2(method_leave, MethodLeave, MonoMethod *, method, MonoProfilerCallContext *, context)
MONO_PROFILER_EVENT_2(method_tail_call, MethodTailCall, MonoMethod *, method, MonoMethod *, target)
MONO_PROFILER_EVENT_2(method_exception_leave, MethodExceptionLeave, MonoMethod *, method, MonoObject *, exception)
MONO_PROFILER_EVENT_1(method_free, MethodFree, MonoMethod *, method)
MONO_PROFILER_EVENT_1(method_begin_invoke, MethodBeginInvoke, MonoMethod *, method)
MONO_PROFILER_EVENT_1(method_end_invoke, MethodEndInvoke, MonoMethod *, method)

MONO_PROFILER_EVENT_1(exception_throw, ExceptionThrow, MonoObject *, exception)
MONO_PROFILER_EVENT_4(exception_clause, ExceptionClause, MonoMethod *, method, uint32_t, index, MonoExceptionEnum, type, MonoObject *, exception)

MONO_PROFILER_EVENT_3(gc_event, GCEvent2, MonoProfilerGCEvent, event, uint32_t, generation, mono_bool, is_serial)
MONO_PROFILER_EVENT_1(gc_allocation, GCAllocation, MonoObject *, object)
MONO_PROFILER_EVENT_2(gc_moves, GCMoves, MonoObject *const *, objects, uint64_t, count)
MONO_PROFILER_EVENT_1(gc_resize, GCResize, uintptr_t, size)
MONO_PROFILER_EVENT_3(gc_handle_created, GCHandleCreated, uint32_t, handle, MonoGCHandleType, type, MonoObject *, object)
MONO_PROFILER_EVENT_2(gc_handle_deleted, GCHandleDeleted, uint32_t, handle, MonoGCHandleType, type)
MONO_PROFILER_EVENT_0(gc_finalizing, GCFinalizing)
MONO_PROFILER_EVENT_0(gc_finalized, GCFinalized)
MONO_PROFILER_EVENT_1(gc_finalizing_object, GCFinalizingObject, MonoObject *, object)
MONO_PROFILER_EVENT_1(gc_finalized_object, GCFinalizedObject, MonoObject *, object)
MONO_PROFILER_EVENT_5(gc_root_register, RootRegister, const mono_byte *, start, uintptr_t, size, MonoGCRootSource, source, const void *, key, const char *, name)
MONO_PROFILER_EVENT_1(gc_root_unregister, RootUnregister, const mono_byte *, start)
MONO_PROFILER_EVENT_3(gc_roots, GCRoots, uint64_t, count, const mono_byte *const *, addresses, MonoObject *const *, objects)

MONO_PROFILER_EVENT_1(monitor_contention, MonitorContention, MonoObject *, object)
MONO_PROFILER_EVENT_1(monitor_failed, MonitorFailed, MonoObject *, object)
MONO_PROFILER_EVENT_1(monitor_acquired, MonitorAcquired, MonoObject *, object)

MONO_PROFILER_EVENT_1(thread_started, ThreadStarted, uintptr_t, tid)
MONO_PROFILER_EVENT_1(thread_stopping, ThreadStopping, uintptr_t, tid)
MONO_PROFILER_EVENT_1(thread_stopped, ThreadStopped, uintptr_t, tid)
MONO_PROFILER_EVENT_1(thread_exited, ThreadExited, uintptr_t, tid)
MONO_PROFILER_EVENT_2(thread_name, ThreadName, uintptr_t, tid, const char *, name)

MONO_PROFILER_EVENT_2(sample_hit, SampleHit, const mono_byte *, ip, const void *, context)

```

`Hazel/vendor/mono/include/mono/metadata/profiler-legacy.h`:

```h
/*
 * Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
 */

#ifndef __MONO_PROFILER_LEGACY_H__
#define __MONO_PROFILER_LEGACY_H__

#include <mono/utils/mono-publib.h>
#include <mono/utils/mono-forward.h>
#include <mono/metadata/object-forward.h>
#include <mono/metadata/profiler.h>

/*
 * The following code is here to maintain compatibility with a few profiler API
 * functions used by Xamarin.{Android,iOS,Mac} so that they keep working
 * regardless of which system Mono version is used.
 *
 * TODO: Remove this some day if we're OK with breaking compatibility.
 */

typedef void *MonoLegacyProfiler;

typedef void (*MonoLegacyProfileFunc) (MonoLegacyProfiler *prof);
typedef void (*MonoLegacyProfileThreadFunc) (MonoLegacyProfiler *prof, uintptr_t tid);
typedef void (*MonoLegacyProfileGCFunc) (MonoLegacyProfiler *prof, MonoProfilerGCEvent event, int generation);
typedef void (*MonoLegacyProfileGCResizeFunc) (MonoLegacyProfiler *prof, int64_t new_size);
typedef void (*MonoLegacyProfileJitResult) (MonoLegacyProfiler *prof, MonoMethod *method, MonoJitInfo *jinfo, int result);
typedef void (*MonoLegacyProfileAllocFunc) (MonoLegacyProfiler *prof, MonoObject *obj, MonoClass *klass);
typedef void (*MonoLegacyProfileMethodFunc) (MonoLegacyProfiler *prof, MonoMethod *method);
typedef void (*MonoLegacyProfileExceptionFunc) (MonoLegacyProfiler *prof, MonoObject *object);
typedef void (*MonoLegacyProfileExceptionClauseFunc) (MonoLegacyProfiler *prof, MonoMethod *method, int clause_type, int clause_num);

MONO_DEPRECATED void mono_profiler_install (MonoLegacyProfiler *prof, MonoLegacyProfileFunc callback);
MONO_DEPRECATED void mono_profiler_install_thread (MonoLegacyProfileThreadFunc start, MonoLegacyProfileThreadFunc end);
MONO_DEPRECATED void mono_profiler_install_gc (MonoLegacyProfileGCFunc callback, MonoLegacyProfileGCResizeFunc heap_resize_callback);
MONO_DEPRECATED void mono_profiler_install_jit_end (MonoLegacyProfileJitResult end);
MONO_DEPRECATED void mono_profiler_set_events (int flags);
MONO_DEPRECATED void mono_profiler_install_allocation (MonoLegacyProfileAllocFunc callback);
MONO_DEPRECATED void mono_profiler_install_enter_leave (MonoLegacyProfileMethodFunc enter, MonoLegacyProfileMethodFunc fleave);
MONO_DEPRECATED void mono_profiler_install_exception (MonoLegacyProfileExceptionFunc throw_callback, MonoLegacyProfileMethodFunc exc_method_leave, MonoLegacyProfileExceptionClauseFunc clause_callback);

#endif // __MONO_PROFILER_LEGACY_H__

```

`Hazel/vendor/mono/include/mono/metadata/profiler-private.h`:

```h
/*
 * Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
 */

#ifndef __MONO_PROFILER_PRIVATE_H__
#define __MONO_PROFILER_PRIVATE_H__

#include <mono/metadata/class-internals.h>
#include <mono/metadata/profiler.h>
#include <mono/utils/mono-context.h>
#include <mono/utils/mono-os-mutex.h>
#include <mono/utils/mono-os-semaphore.h>
#include <mono/metadata/icalls.h>

struct _MonoProfilerDesc {
	MonoProfilerHandle next;
	MonoProfiler *prof;
	volatile gpointer cleanup_callback;
	volatile gpointer coverage_filter;
	volatile gpointer call_instrumentation_filter;

#define _MONO_PROFILER_EVENT(name) \
	volatile gpointer name ## _cb;
#define MONO_PROFILER_EVENT_0(name, type) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_1(name, type, arg1_type, arg1_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_2(name, type, arg1_type, arg1_name, arg2_type, arg2_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_3(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_4(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_5(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name, arg5_type, arg5_name) \
	_MONO_PROFILER_EVENT(name)
#include <mono/metadata/profiler-events.h>
#undef MONO_PROFILER_EVENT_0
#undef MONO_PROFILER_EVENT_1
#undef MONO_PROFILER_EVENT_2
#undef MONO_PROFILER_EVENT_3
#undef MONO_PROFILER_EVENT_4
#undef MONO_PROFILER_EVENT_5
#undef _MONO_PROFILER_EVENT
};

typedef struct {
	gboolean startup_done;

	MonoProfilerHandle profilers;

	gboolean code_coverage;
	mono_mutex_t coverage_mutex;
	GHashTable *coverage_hash;

	MonoProfilerHandle sampling_owner;
	MonoSemType sampling_semaphore;
	MonoProfilerSampleMode sample_mode;
	guint32 sample_freq;

	gboolean allocations;

	gboolean clauses;

	gboolean call_contexts;
	void (*context_enable) (void);
	gpointer (*context_get_this) (MonoProfilerCallContext *);
	gpointer (*context_get_argument) (MonoProfilerCallContext *, guint32);
	gpointer (*context_get_local) (MonoProfilerCallContext *, guint32);
	gpointer (*context_get_result) (MonoProfilerCallContext *);
	void (*context_free_buffer) (gpointer);

#define _MONO_PROFILER_EVENT(name) \
	volatile gint32 name ## _count;
#define MONO_PROFILER_EVENT_0(name, type) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_1(name, type, arg1_type, arg1_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_2(name, type, arg1_type, arg1_name, arg2_type, arg2_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_3(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_4(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name) \
	_MONO_PROFILER_EVENT(name)
#define MONO_PROFILER_EVENT_5(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name, arg5_type, arg5_name) \
	_MONO_PROFILER_EVENT(name)
#include <mono/metadata/profiler-events.h>
#undef MONO_PROFILER_EVENT_0
#undef MONO_PROFILER_EVENT_1
#undef MONO_PROFILER_EVENT_2
#undef MONO_PROFILER_EVENT_3
#undef MONO_PROFILER_EVENT_4
#undef MONO_PROFILER_EVENT_5
#undef _MONO_PROFILER_EVENT
} MonoProfilerState;

extern MonoProfilerState mono_profiler_state;

typedef struct {
	guchar *cil_code;
	guint32 count;
} MonoProfilerCoverageInfoEntry;

typedef struct {
	guint32 entries;
	MonoProfilerCoverageInfoEntry data [MONO_ZERO_LEN_ARRAY];
} MonoProfilerCoverageInfo;

void mono_profiler_started (void);
void mono_profiler_cleanup (void);

static inline gboolean
mono_profiler_installed (void)
{
	return !!mono_profiler_state.profilers;
}

gboolean mono_profiler_coverage_instrumentation_enabled (MonoMethod *method);
MonoProfilerCoverageInfo *mono_profiler_coverage_alloc (MonoMethod *method, guint32 entries);

struct _MonoProfilerCallContext {
	/*
	 * Must be the first field (the JIT relies on it). Only filled out if this
	 * is a JIT frame; otherwise, zeroed.
	 */
	MonoContext context;
	/*
	 * A non-NULL MonoInterpFrameHandle if this is an interpreter frame.
	 */
	gpointer interp_frame;
	MonoMethod *method;
	/*
	 * Points to the return value for an epilogue context. For a prologue, this
	 * is set to NULL.
	 */
	gpointer return_value;
	/*
	 * Points to an array of addresses of stack slots holding the arguments.
	 */
	gpointer *args;
};

MonoProfilerCallInstrumentationFlags mono_profiler_get_call_instrumentation_flags (MonoMethod *method);

gboolean mono_profiler_sampling_enabled (void);
void mono_profiler_sampling_thread_post (void);
void mono_profiler_sampling_thread_wait (void);

static inline gboolean
mono_profiler_allocations_enabled (void)
{
	return mono_profiler_state.allocations;
}

static inline gboolean
mono_profiler_clauses_enabled (void)
{
	return mono_profiler_state.clauses;
}

#define _MONO_PROFILER_EVENT(name, ...) \
	ICALL_EXPORT void mono_profiler_raise_ ## name (__VA_ARGS__);
#define MONO_PROFILER_EVENT_0(name, type) \
	_MONO_PROFILER_EVENT(name, void)
#define MONO_PROFILER_EVENT_1(name, type, arg1_type, arg1_name) \
	_MONO_PROFILER_EVENT(name, arg1_type arg1_name)
#define MONO_PROFILER_EVENT_2(name, type, arg1_type, arg1_name, arg2_type, arg2_name) \
	_MONO_PROFILER_EVENT(name, arg1_type arg1_name, arg2_type arg2_name)
#define MONO_PROFILER_EVENT_3(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name) \
	_MONO_PROFILER_EVENT(name, arg1_type arg1_name, arg2_type arg2_name, arg3_type arg3_name)
#define MONO_PROFILER_EVENT_4(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name) \
	_MONO_PROFILER_EVENT(name, arg1_type arg1_name, arg2_type arg2_name, arg3_type arg3_name, arg4_type arg4_name)
#define MONO_PROFILER_EVENT_5(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name, arg5_type, arg5_name) \
	_MONO_PROFILER_EVENT(name, arg1_type arg1_name, arg2_type arg2_name, arg3_type arg3_name, arg4_type arg4_name, arg5_type arg5_name)
#include <mono/metadata/profiler-events.h>
#undef MONO_PROFILER_EVENT_0
#undef MONO_PROFILER_EVENT_1
#undef MONO_PROFILER_EVENT_2
#undef MONO_PROFILER_EVENT_3
#undef MONO_PROFILER_EVENT_4
#undef MONO_PROFILER_EVENT_5
#undef _MONO_PROFILER_EVENT

/* These are the macros the rest of the runtime should use. */

#define MONO_PROFILER_ENABLED(name) \
	G_UNLIKELY (mono_profiler_state.name ## _count)

#define MONO_PROFILER_RAISE(name, args) \
	do { \
		if (MONO_PROFILER_ENABLED (name)) \
			mono_profiler_raise_ ## name args; \
	} while (0)

#endif // __MONO_PROFILER_PRIVATE_H__

```

`Hazel/vendor/mono/include/mono/metadata/profiler.h`:

```h
/*
 * Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
 */

#ifndef __MONO_PROFILER_H__
#define __MONO_PROFILER_H__

#include <mono/metadata/appdomain.h>
#include <mono/metadata/mono-gc.h>
#include <mono/metadata/object.h>

MONO_BEGIN_DECLS

/**
 * This value will be incremented whenever breaking changes to the profiler API
 * are made. This macro is intended for use in profiler modules that wish to
 * support older versions of the profiler API.
 *
 * Version 2:
 * - Major overhaul of the profiler API.
 * Version 3:
 * - Added mono_profiler_enable_clauses (). This must now be called to enable
 *   raising exception_clause events.
 * - The exception argument to exception_clause events can now be NULL for
 *   finally clauses invoked in the non-exceptional case.
 * - The type argument to exception_clause events will now correctly indicate
 *   that the catch portion of the clause is being executed in the case of
 *   try-filter-catch clauses.
 * - Removed the iomap_report event.
 * - Removed the old gc_event event and renamed gc_event2 to gc_event.
 */
#define MONO_PROFILER_API_VERSION 3

typedef struct _MonoProfiler MonoProfiler;
typedef struct _MonoProfilerDesc *MonoProfilerHandle;

typedef void (*MonoProfilerCleanupCallback) (MonoProfiler *prof);

MONO_API void mono_profiler_load (const char *desc);
MONO_API MonoProfilerHandle mono_profiler_create (MonoProfiler *prof);
MONO_API void mono_profiler_set_cleanup_callback (MonoProfilerHandle handle, MonoProfilerCleanupCallback cb);

typedef struct {
	MonoMethod *method;
	uint32_t il_offset;
	uint32_t counter;
	const char *file_name;
	uint32_t line;
	uint32_t column;
} MonoProfilerCoverageData;

typedef mono_bool (*MonoProfilerCoverageFilterCallback) (MonoProfiler *prof, MonoMethod *method);
typedef void (*MonoProfilerCoverageCallback) (MonoProfiler *prof, const MonoProfilerCoverageData *data);

MONO_API mono_bool mono_profiler_enable_coverage (void);
MONO_API void mono_profiler_set_coverage_filter_callback (MonoProfilerHandle handle, MonoProfilerCoverageFilterCallback cb);
MONO_API mono_bool mono_profiler_get_coverage_data (MonoProfilerHandle handle, MonoMethod *method, MonoProfilerCoverageCallback cb);

typedef enum {
	/**
	 * Do not perform sampling. Will make the sampling thread sleep until the
	 * sampling mode is changed to one of the below modes.
	 */
	MONO_PROFILER_SAMPLE_MODE_NONE = 0,
	/**
	 * Try to base sampling frequency on process activity. Falls back to
	 * MONO_PROFILER_SAMPLE_MODE_REAL if such a clock is not available.
	 */
	MONO_PROFILER_SAMPLE_MODE_PROCESS = 1,
	/**
	 * Base sampling frequency on wall clock time. Uses a monotonic clock when
	 * available (all major platforms).
	 */
	MONO_PROFILER_SAMPLE_MODE_REAL = 2,
} MonoProfilerSampleMode;

MONO_API mono_bool mono_profiler_enable_sampling (MonoProfilerHandle handle);
MONO_API mono_bool mono_profiler_set_sample_mode (MonoProfilerHandle handle, MonoProfilerSampleMode mode, uint32_t freq);
MONO_API mono_bool mono_profiler_get_sample_mode (MonoProfilerHandle handle, MonoProfilerSampleMode *mode, uint32_t *freq);

MONO_API mono_bool mono_profiler_enable_allocations (void);
MONO_API mono_bool mono_profiler_enable_clauses (void);

typedef struct _MonoProfilerCallContext MonoProfilerCallContext;

typedef enum {
	/**
	 * Do not instrument calls.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_NONE = 0,
	/**
	 * Instrument method entries.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_ENTER = 1 << 1,
	/**
	 * Also capture a call context for method entries.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_ENTER_CONTEXT = 1 << 2,
	/**
	 * Instrument method exits.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_LEAVE = 1 << 3,
	/**
	 * Also capture a call context for method exits.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_LEAVE_CONTEXT = 1 << 4,
	/**
	 * Instrument method exits as a result of a tail call.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_TAIL_CALL = 1 << 5,
	/**
	 * Instrument exceptional method exits.
	 */
	MONO_PROFILER_CALL_INSTRUMENTATION_EXCEPTION_LEAVE = 1 << 6,
} MonoProfilerCallInstrumentationFlags;

typedef MonoProfilerCallInstrumentationFlags (*MonoProfilerCallInstrumentationFilterCallback) (MonoProfiler *prof, MonoMethod *method);

MONO_API void mono_profiler_set_call_instrumentation_filter_callback (MonoProfilerHandle handle, MonoProfilerCallInstrumentationFilterCallback cb);
MONO_API mono_bool mono_profiler_enable_call_context_introspection (void);
MONO_API void *mono_profiler_call_context_get_this (MonoProfilerCallContext *context);
MONO_API void *mono_profiler_call_context_get_argument (MonoProfilerCallContext *context, uint32_t position);
MONO_API void *mono_profiler_call_context_get_local (MonoProfilerCallContext *context, uint32_t position);
MONO_API void *mono_profiler_call_context_get_result (MonoProfilerCallContext *context);
MONO_API void mono_profiler_call_context_free_buffer (void *buffer);

typedef enum {
	/**
	 * The \c data parameter is a \c MonoMethod pointer.
	 */
	MONO_PROFILER_CODE_BUFFER_METHOD = 0,
	/**
	 * \deprecated No longer used.
	 */
	MONO_PROFILER_CODE_BUFFER_METHOD_TRAMPOLINE = 1,
	/**
	 * The \c data parameter is a \c MonoMethod pointer.
	 */
	MONO_PROFILER_CODE_BUFFER_UNBOX_TRAMPOLINE = 2,
	MONO_PROFILER_CODE_BUFFER_IMT_TRAMPOLINE = 3,
	MONO_PROFILER_CODE_BUFFER_GENERICS_TRAMPOLINE = 4,
	/**
	 * The \c data parameter is a C string.
	 */
	MONO_PROFILER_CODE_BUFFER_SPECIFIC_TRAMPOLINE = 5,
	MONO_PROFILER_CODE_BUFFER_HELPER = 6,
	/**
	 * \deprecated No longer used.
	 */
	MONO_PROFILER_CODE_BUFFER_MONITOR = 7,
	MONO_PROFILER_CODE_BUFFER_DELEGATE_INVOKE = 8,
	MONO_PROFILER_CODE_BUFFER_EXCEPTION_HANDLING = 9,
} MonoProfilerCodeBufferType;

typedef enum {
	MONO_GC_EVENT_PRE_STOP_WORLD = 6,
	/**
	 * When this event arrives, the GC and suspend locks are acquired.
	 */
	MONO_GC_EVENT_PRE_STOP_WORLD_LOCKED = 10,
	MONO_GC_EVENT_POST_STOP_WORLD = 7,
	MONO_GC_EVENT_START = 0,
	MONO_GC_EVENT_END = 5,
	MONO_GC_EVENT_PRE_START_WORLD = 8,
	/**
	 * When this event arrives, the GC and suspend locks are released.
	 */
	MONO_GC_EVENT_POST_START_WORLD_UNLOCKED = 11,
	MONO_GC_EVENT_POST_START_WORLD = 9,
} MonoProfilerGCEvent;

/*
 * The macros below will generate the majority of the callback API. Refer to
 * mono/metadata/profiler-events.h for a list of callbacks. They are expanded
 * like so:
 *
 * typedef void (*MonoProfilerRuntimeInitializedCallback (MonoProfiler *prof);
 * MONO_API void mono_profiler_set_runtime_initialized_callback (MonoProfiler *prof, MonoProfilerRuntimeInitializedCallback cb);
 *
 * typedef void (*MonoProfilerRuntimeShutdownCallback (MonoProfiler *prof);
 * MONO_API void mono_profiler_set_runtime_shutdown_callback (MonoProfiler *prof, MonoProfilerRuntimeShutdownCallback cb);
 *
 * typedef void (*MonoProfilerContextLoadedCallback (MonoProfiler *prof);
 * MONO_API void mono_profiler_set_context_loaded_callback (MonoProfiler *prof, MonoProfilerContextLoadedCallback cb);
 *
 * typedef void (*MonoProfilerContextUnloadedCallback (MonoProfiler *prof);
 * MONO_API void mono_profiler_set_context_unloaded_callback (MonoProfiler *prof, MonoProfilerContextUnloadedCallback cb);
 *
 * Etc.
 *
 * To remove a callback, pass NULL instead of a valid function pointer.
 * Callbacks can be changed at any point, but note that doing so is inherently
 * racy with respect to threads that aren't suspended, i.e. you may still see a
 * call from another thread right after you change a callback.
 *
 * These functions are async safe.
 */

#define _MONO_PROFILER_EVENT(type, ...) \
	typedef void (*MonoProfiler ## type ## Callback) (__VA_ARGS__);
#define MONO_PROFILER_EVENT_0(name, type) \
		_MONO_PROFILER_EVENT(type, MonoProfiler *prof)
#define MONO_PROFILER_EVENT_1(name, type, arg1_type, arg1_name) \
		_MONO_PROFILER_EVENT(type, MonoProfiler *prof, arg1_type arg1_name)
#define MONO_PROFILER_EVENT_2(name, type, arg1_type, arg1_name, arg2_type, arg2_name) \
		_MONO_PROFILER_EVENT(type, MonoProfiler *prof, arg1_type arg1_name, arg2_type arg2_name)
#define MONO_PROFILER_EVENT_3(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name) \
		_MONO_PROFILER_EVENT(type, MonoProfiler *prof, arg1_type arg1_name, arg2_type arg2_name, arg3_type arg3_name)
#define MONO_PROFILER_EVENT_4(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name) \
		_MONO_PROFILER_EVENT(type, MonoProfiler *prof, arg1_type arg1_name, arg2_type arg2_name, arg3_type arg3_name, arg4_type arg4_name)
#define MONO_PROFILER_EVENT_5(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name, arg5_type, arg5_name) \
		_MONO_PROFILER_EVENT(type, MonoProfiler *prof, arg1_type arg1_name, arg2_type arg2_name, arg3_type arg3_name, arg4_type arg4_name, arg5_type arg5_name)
#include <mono/metadata/profiler-events.h>
#undef MONO_PROFILER_EVENT_0
#undef MONO_PROFILER_EVENT_1
#undef MONO_PROFILER_EVENT_2
#undef MONO_PROFILER_EVENT_3
#undef MONO_PROFILER_EVENT_4
#undef MONO_PROFILER_EVENT_5
#undef _MONO_PROFILER_EVENT

#define _MONO_PROFILER_EVENT(name, type) \
	MONO_API void mono_profiler_set_ ## name ## _callback (MonoProfilerHandle handle, MonoProfiler ## type ## Callback cb);
#define MONO_PROFILER_EVENT_0(name, type) \
	_MONO_PROFILER_EVENT(name, type)
#define MONO_PROFILER_EVENT_1(name, type, arg1_type, arg1_name) \
	_MONO_PROFILER_EVENT(name, type)
#define MONO_PROFILER_EVENT_2(name, type, arg1_type, arg1_name, arg2_type, arg2_name) \
	_MONO_PROFILER_EVENT(name, type)
#define MONO_PROFILER_EVENT_3(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name) \
	_MONO_PROFILER_EVENT(name, type)
#define MONO_PROFILER_EVENT_4(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name) \
	_MONO_PROFILER_EVENT(name, type)
#define MONO_PROFILER_EVENT_5(name, type, arg1_type, arg1_name, arg2_type, arg2_name, arg3_type, arg3_name, arg4_type, arg4_name, arg5_type, arg5_name) \
	_MONO_PROFILER_EVENT(name, type)
#include <mono/metadata/profiler-events.h>
#undef MONO_PROFILER_EVENT_0
#undef MONO_PROFILER_EVENT_1
#undef MONO_PROFILER_EVENT_2
#undef MONO_PROFILER_EVENT_3
#undef MONO_PROFILER_EVENT_4
#undef MONO_PROFILER_EVENT_5
#undef _MONO_PROFILER_EVENT

MONO_END_DECLS

#endif // __MONO_PROFILER_H__

```

`Hazel/vendor/mono/include/mono/metadata/property-bag.h`:

```h
/**
 * \file
 * Linearizable property bag.
 *
 * Authors:
 *   Rodrigo Kumpera (kumpera@gmail.com)
 *
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_PROPERTY_BAG_H__
#define __MONO_METADATA_PROPERTY_BAG_H__

#include <mono/utils/mono-compiler.h>

typedef struct _MonoPropertyBagItem MonoPropertyBagItem;

struct _MonoPropertyBagItem {
	MonoPropertyBagItem *next;
	int tag;
};

typedef struct {
	MonoPropertyBagItem *head;
} MonoPropertyBag;

void* mono_property_bag_get (MonoPropertyBag *bag, int tag);
void* mono_property_bag_add (MonoPropertyBag *bag, void *value);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/rand.h`:

```h
/**
 * \file
 * System.Security.Cryptography.RNGCryptoServiceProvider support
 *
 * Author:
 *      Mark Crichton (crichton@gimp.org)
 *	Sebastien Pouliot (sebastien@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 * Copyright (C) 2004-2005 Novell, Inc (http://www.novell.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_METADATA_RAND_H_
#define _MONO_METADATA_RAND_H_

#include <glib.h>
#include <mono/metadata/object.h>
#include "mono/utils/mono-compiler.h"
#include <mono/metadata/icalls.h>

#endif

```

`Hazel/vendor/mono/include/mono/metadata/reflection-cache.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_REFLECTION_CACHE_H__
#define __MONO_METADATA_REFLECTION_CACHE_H__

#include <glib.h>
#include <mono/metadata/domain-internals.h>
#include <mono/metadata/handle.h>
#include <mono/metadata/mono-hash.h>
#include <mono/metadata/mempool.h>
#include <mono/utils/mono-error-internals.h>

/*
 * We need to return always the same object for MethodInfo, FieldInfo etc..
 * but we need to consider the reflected type.
 * type uses a different hash, since it uses custom hash/equal functions.
 */

typedef struct {
	gpointer item;
	MonoClass *refclass;
} ReflectedEntry;

gboolean
mono_reflected_equal (gconstpointer a, gconstpointer b);

guint
mono_reflected_hash (gconstpointer a);

static inline ReflectedEntry*
alloc_reflected_entry (MonoDomain *domain)
{
	if (!mono_gc_is_moving ())
		return g_new0 (ReflectedEntry, 1);
	else
		return (ReflectedEntry *)mono_mempool_alloc (domain->mp, sizeof (ReflectedEntry));
}

static inline void
free_reflected_entry (ReflectedEntry *entry)
{
	if (!mono_gc_is_moving ())
		g_free (entry);
}

static inline MonoObject*
cache_object (MonoDomain *domain, MonoClass *klass, gpointer item, MonoObject* o)
{
	MonoObject *obj;
	ReflectedEntry pe;
	pe.item = item;
	pe.refclass = klass;

	mono_domain_lock (domain);
	if (!domain->refobject_hash)
		domain->refobject_hash = mono_conc_g_hash_table_new_type (mono_reflected_hash, mono_reflected_equal, MONO_HASH_VALUE_GC, MONO_ROOT_SOURCE_DOMAIN, domain, "Domain Reflection Object Table");

	obj = (MonoObject*) mono_conc_g_hash_table_lookup (domain->refobject_hash, &pe);
	if (obj == NULL) {
		ReflectedEntry *e = alloc_reflected_entry (domain);
		e->item = item;
		e->refclass = klass;
		mono_conc_g_hash_table_insert (domain->refobject_hash, e, o);
		obj = o;
	}
	mono_domain_unlock (domain);
	return obj;
}


static inline MonoObjectHandle
cache_object_handle (MonoDomain *domain, MonoClass *klass, gpointer item, MonoObjectHandle o)
{
	ReflectedEntry pe;
	pe.item = item;
	pe.refclass = klass;

	mono_domain_lock (domain);
	if (!domain->refobject_hash)
		domain->refobject_hash = mono_conc_g_hash_table_new_type (mono_reflected_hash, mono_reflected_equal, MONO_HASH_VALUE_GC, MONO_ROOT_SOURCE_DOMAIN, domain, "Domain Reflection Object Table");

	MonoObjectHandle obj = MONO_HANDLE_NEW (MonoObject, (MonoObject*)mono_conc_g_hash_table_lookup (domain->refobject_hash, &pe));
	if (MONO_HANDLE_IS_NULL (obj)) {
		ReflectedEntry *e = alloc_reflected_entry (domain);
		e->item = item;
		e->refclass = klass;
		mono_conc_g_hash_table_insert (domain->refobject_hash, e, MONO_HANDLE_RAW (o));
		MONO_HANDLE_ASSIGN (obj, o);
	}
	mono_domain_unlock (domain);
	return obj;
}

#define CACHE_OBJECT(t,p,o,k) ((t) (cache_object (domain, (k), (p), (o))))
#define CACHE_OBJECT_HANDLE(t,p,o,k) (MONO_HANDLE_CAST (t, cache_object_handle (domain, (k), (p), (o))))

static inline MonoObjectHandle
check_object_handle (MonoDomain* domain, MonoClass *klass, gpointer item)
{
	ReflectedEntry e;
	e.item = item;
	e.refclass = klass;
	MonoConcGHashTable *hash = domain->refobject_hash;
	if (!hash)
		return MONO_HANDLE_NEW (MonoObject, NULL);

	return MONO_HANDLE_NEW (MonoObject, (MonoObject*)mono_conc_g_hash_table_lookup (hash, &e));
}


typedef MonoObjectHandle (*ReflectionCacheConstructFunc_handle) (MonoDomain*, MonoClass*, gpointer, gpointer, MonoError *);

static inline MonoObjectHandle
check_or_construct_handle (MonoDomain *domain, MonoClass *klass, gpointer item, gpointer user_data, MonoError *error, ReflectionCacheConstructFunc_handle construct)
{
	error_init (error);
	MonoObjectHandle obj = check_object_handle (domain, klass, item);
	if (!MONO_HANDLE_IS_NULL (obj))
		return obj;
	MONO_HANDLE_ASSIGN (obj, construct (domain, klass, item, user_data, error));
	return_val_if_nok (error, NULL_HANDLE);
	if (MONO_HANDLE_IS_NULL (obj))
		return obj;
	/* note no caching if there was an error in construction */
	return cache_object_handle (domain, klass, item, obj);
}

#define CHECK_OR_CONSTRUCT_HANDLE(t,p,k,construct,ud) \
	(MONO_HANDLE_CAST (t, check_or_construct_handle ( \
		domain, (k), (p), (ud), error, (ReflectionCacheConstructFunc_handle) (construct))))

#endif /*__MONO_METADATA_REFLECTION_CACHE_H__*/

```

`Hazel/vendor/mono/include/mono/metadata/reflection-internals.h`:

```h
/**
 * \file
 * Copyright 2014 Xamarin Inc
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_REFLECTION_INTERNALS_H__
#define __MONO_METADATA_REFLECTION_INTERNALS_H__

#include <mono/metadata/object-internals.h>
#include <mono/metadata/reflection.h>
#include <mono/metadata/class-internals.h>
#include <mono/utils/mono-compiler.h>
#include <mono/utils/mono-error.h>

/* Safely access System.Reflection.Assembly from native code */
TYPED_HANDLE_DECL (MonoReflectionAssembly)

/* Safely access System.Reflection.Emit.TypeBuilder from native code */
TYPED_HANDLE_DECL (MonoReflectionTypeBuilder)

MonoReflectionAssemblyHandle
mono_domain_try_type_resolve_name (MonoDomain *domain, MonoAssembly *assembly, MonoStringHandle name, MonoError *error);

#ifndef ENABLE_NETCORE
MonoReflectionAssemblyHandle
mono_domain_try_type_resolve_typebuilder (MonoDomain *domain, MonoReflectionTypeBuilderHandle typebuilder, MonoError *error);
#endif

MonoReflectionTypeBuilderHandle
mono_class_get_ref_info (MonoClass *klass);

gboolean
mono_reflection_parse_type_checked (char *name, MonoTypeNameParse *info, MonoError *error);

gboolean
mono_reflection_is_usertype (MonoReflectionTypeHandle ref);

MonoReflectionType*
mono_reflection_type_resolve_user_types (MonoReflectionType *type, MonoError *error);

MonoType *
mono_reflection_type_handle_mono_type (MonoReflectionTypeHandle ref_type, MonoError *error);

MonoType*
mono_reflection_get_type_checked (MonoAssemblyLoadContext *alc, MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean search_mscorlib, gboolean *type_resolve, MonoError *error);

MonoType*
mono_reflection_type_from_name_checked (char *name, MonoAssemblyLoadContext *alc, MonoImage *image, MonoError *error);

guint32
mono_reflection_get_token_checked (MonoObjectHandle obj, MonoError *error);

MonoObject*
mono_custom_attrs_get_attr_checked (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass, MonoError *error);

MonoCustomAttrInfo*
mono_reflection_get_custom_attrs_info_checked (MonoObjectHandle obj, MonoError *error);

MonoArrayHandle
mono_reflection_get_custom_attrs_data_checked (MonoObjectHandle obj, MonoError *error);

MonoArrayHandle
mono_reflection_get_custom_attrs_by_type_handle (MonoObjectHandle obj, MonoClass *attr_klass, MonoError *error);

MonoArrayHandle
mono_reflection_get_custom_attrs_blob_checked (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues, MonoError *error);

MonoCustomAttrInfo*
mono_custom_attrs_from_index_checked    (MonoImage *image, uint32_t idx, gboolean ignore_missing, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_method_checked   (MonoMethod *method, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_class_checked   	(MonoClass *klass, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_assembly_checked	(MonoAssembly *assembly, gboolean ignore_missing, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_property_checked	(MonoClass *klass, MonoProperty *property, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_event_checked	(MonoClass *klass, MonoEvent *event, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_field_checked	(MonoClass *klass, MonoClassField *field, MonoError *error);
MonoCustomAttrInfo*
mono_custom_attrs_from_param_checked	(MonoMethod *method, uint32_t param, MonoError *error);


char*
mono_identifier_unescape_type_name_chars (char* identifier);

MonoImage *
mono_find_dynamic_image_owner (void *ptr);

MonoReflectionAssemblyHandle
mono_assembly_get_object_handle (MonoDomain *domain, MonoAssembly *assembly, MonoError *error);

MonoReflectionType*
mono_type_get_object_checked (MonoDomain *domain, MonoType *type, MonoError *error);

MonoReflectionTypeHandle
mono_type_get_object_handle (MonoDomain *domain, MonoType *type, MonoError *error);

MonoReflectionField*
mono_field_get_object_checked (MonoDomain *domain, MonoClass *klass, MonoClassField *field, MonoError *error);

MonoReflectionFieldHandle
mono_field_get_object_handle (MonoDomain *domain, MonoClass *klass, MonoClassField *field, MonoError *error);

MonoReflectionMethod*
mono_method_get_object_checked (MonoDomain *domain, MonoMethod *method, MonoClass *refclass, MonoError *error);

MonoReflectionMethodHandle
mono_method_get_object_handle (MonoDomain *domain, MonoMethod *method, MonoClass *refclass, MonoError *error);

MonoReflectionProperty*
mono_property_get_object_checked (MonoDomain *domain, MonoClass *klass, MonoProperty *property, MonoError *error);

MonoReflectionPropertyHandle
mono_property_get_object_handle (MonoDomain *domain, MonoClass *klass, MonoProperty *property, MonoError *error);

MonoReflectionEventHandle
mono_event_get_object_handle (MonoDomain *domain, MonoClass *klass, MonoEvent *event, MonoError *error);

MonoReflectionModuleHandle
mono_module_get_object_handle (MonoDomain *domain, MonoImage *image, MonoError *error);

MonoReflectionModuleHandle
mono_module_file_get_object_handle (MonoDomain *domain, MonoImage *image, int table_index, MonoError *error);

MonoReflectionMethodBodyHandle
mono_method_body_get_object_handle (MonoDomain *domain, MonoMethod *method, MonoError *error);

MonoClass *
mono_class_from_mono_type_handle (MonoReflectionTypeHandle h);

MonoMethod*
mono_runtime_get_caller_no_system_or_reflection (void);

MonoAssembly*
mono_runtime_get_caller_from_stack_mark (MonoStackCrawlMark *stack_mark);

void
mono_reflection_get_param_info_member_and_pos (MonoReflectionParameterHandle p, MonoObjectHandle member_impl, int *out_position);

#endif /* __MONO_METADATA_REFLECTION_INTERNALS_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/reflection.h`:

```h
/**
 * \file
 */

#ifndef __METADATA_REFLECTION_H__
#define __METADATA_REFLECTION_H__

#include <mono/utils/mono-publib.h>
#include <mono/metadata/object.h>

MONO_BEGIN_DECLS

typedef struct MonoTypeNameParse MonoTypeNameParse;

typedef struct {
	MonoMethod *ctor;
	uint32_t     data_size;
	const mono_byte* data;
} MonoCustomAttrEntry;

typedef struct {
	int num_attrs;
	int cached;
	MonoImage *image;
	MonoCustomAttrEntry attrs [MONO_ZERO_LEN_ARRAY];
} MonoCustomAttrInfo;

#define MONO_SIZEOF_CUSTOM_ATTR_INFO (offsetof (MonoCustomAttrInfo, attrs))

/* 
 * Information which isn't in the MonoMethod structure is stored here for
 * dynamic methods.
 */
typedef struct {
	char **param_names;
	MonoMarshalSpec **param_marshall;
	MonoCustomAttrInfo **param_cattr;
	uint8_t** param_defaults;
	uint32_t *param_default_types;
	char *dllentry, *dll;
} MonoReflectionMethodAux;

typedef enum {
	ResolveTokenError_OutOfRange,
	ResolveTokenError_BadTable,
	ResolveTokenError_Other
} MonoResolveTokenError;

MONO_API MONO_RT_EXTERNAL_ONLY
int           mono_reflection_parse_type (char *name, MonoTypeNameParse *info);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoType*     mono_reflection_get_type   (MonoImage* image, MonoTypeNameParse *info, mono_bool ignorecase, mono_bool *type_resolve);
MONO_API void          mono_reflection_free_type_info (MonoTypeNameParse *info);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoType*     mono_reflection_type_from_name (char *name, MonoImage *image);
MONO_API MONO_RT_EXTERNAL_ONLY
uint32_t      mono_reflection_get_token (MonoObject *obj);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionAssembly* mono_assembly_get_object (MonoDomain *domain, MonoAssembly *assembly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionModule*   mono_module_get_object   (MonoDomain *domain, MonoImage *image);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionModule*   mono_module_file_get_object (MonoDomain *domain, MonoImage *image, int table_index);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionType*     mono_type_get_object     (MonoDomain *domain, MonoType *type);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionMethod*   mono_method_get_object   (MonoDomain *domain, MonoMethod *method, MonoClass *refclass);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionField*    mono_field_get_object    (MonoDomain *domain, MonoClass *klass, MonoClassField *field);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionProperty* mono_property_get_object (MonoDomain *domain, MonoClass *klass, MonoProperty *property);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionEvent*    mono_event_get_object    (MonoDomain *domain, MonoClass *klass, MonoEvent *event);
/* note: this one is slightly different: we keep the whole array of params in the cache */
MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray* mono_param_get_objects  (MonoDomain *domain, MonoMethod *method);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoReflectionMethodBody* mono_method_body_get_object (MonoDomain *domain, MonoMethod *method);

MONO_API MonoObject *mono_get_dbnull_object (MonoDomain *domain);

MONO_API MonoArray*  mono_reflection_get_custom_attrs_by_type (MonoObject *obj, MonoClass *attr_klass, MonoError *error);
MONO_API MonoArray*  mono_reflection_get_custom_attrs (MonoObject *obj);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray*  mono_reflection_get_custom_attrs_data (MonoObject *obj);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray*  mono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *porpValues, MonoArray *fields, MonoArray* fieldValues);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_reflection_get_custom_attrs_info (MonoObject *obj);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoArray*  mono_custom_attrs_construct (MonoCustomAttrInfo *cinfo);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_index    (MonoImage *image, uint32_t idx);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_method   (MonoMethod *method);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_class    (MonoClass *klass);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_assembly (MonoAssembly *assembly);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_property (MonoClass *klass, MonoProperty *property);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_event    (MonoClass *klass, MonoEvent *event);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_field    (MonoClass *klass, MonoClassField *field);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoCustomAttrInfo* mono_custom_attrs_from_param    (MonoMethod *method, uint32_t param);
MONO_API mono_bool           mono_custom_attrs_has_attr      (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass);
MONO_API MONO_RT_EXTERNAL_ONLY
MonoObject*         mono_custom_attrs_get_attr      (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass);
MONO_API void                mono_custom_attrs_free          (MonoCustomAttrInfo *ainfo);


#define MONO_DECLSEC_ACTION_MIN		0x1
#define MONO_DECLSEC_ACTION_MAX		0x12

enum {
	MONO_DECLSEC_FLAG_REQUEST 			= 0x00000001,
	MONO_DECLSEC_FLAG_DEMAND			= 0x00000002,
	MONO_DECLSEC_FLAG_ASSERT			= 0x00000004,
	MONO_DECLSEC_FLAG_DENY				= 0x00000008,
	MONO_DECLSEC_FLAG_PERMITONLY			= 0x00000010,
	MONO_DECLSEC_FLAG_LINKDEMAND			= 0x00000020,
	MONO_DECLSEC_FLAG_INHERITANCEDEMAND		= 0x00000040,
	MONO_DECLSEC_FLAG_REQUEST_MINIMUM		= 0x00000080,
	MONO_DECLSEC_FLAG_REQUEST_OPTIONAL		= 0x00000100,
	MONO_DECLSEC_FLAG_REQUEST_REFUSE		= 0x00000200,
	MONO_DECLSEC_FLAG_PREJIT_GRANT			= 0x00000400,
	MONO_DECLSEC_FLAG_PREJIT_DENY			= 0x00000800,
	MONO_DECLSEC_FLAG_NONCAS_DEMAND			= 0x00001000,
	MONO_DECLSEC_FLAG_NONCAS_LINKDEMAND		= 0x00002000,
	MONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND	= 0x00004000,
	MONO_DECLSEC_FLAG_LINKDEMAND_CHOICE		= 0x00008000,
	MONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE	= 0x00010000,
	MONO_DECLSEC_FLAG_DEMAND_CHOICE			= 0x00020000
};

MONO_API uint32_t mono_declsec_flags_from_method (MonoMethod *method);
MONO_API uint32_t mono_declsec_flags_from_class (MonoClass *klass);
MONO_API uint32_t mono_declsec_flags_from_assembly (MonoAssembly *assembly);

/* this structure MUST be kept in synch with RuntimeDeclSecurityEntry
 * located in /mcs/class/corlib/System.Security/SecurityFrame.cs */
typedef struct {
	char *blob;				/* pointer to metadata blob */
	uint32_t size;				/* size of the metadata blob */
	uint32_t index;
} MonoDeclSecurityEntry;

typedef struct {
	MonoDeclSecurityEntry demand;
	MonoDeclSecurityEntry noncasdemand;
	MonoDeclSecurityEntry demandchoice;
} MonoDeclSecurityActions;

MONO_API MonoBoolean mono_declsec_get_demands (MonoMethod *callee, MonoDeclSecurityActions* demands);
MONO_API MonoBoolean mono_declsec_get_linkdemands (MonoMethod *callee, MonoDeclSecurityActions* klass, MonoDeclSecurityActions* cmethod);
MONO_API MonoBoolean mono_declsec_get_inheritdemands_class (MonoClass *klass, MonoDeclSecurityActions* demands);
MONO_API MonoBoolean mono_declsec_get_inheritdemands_method (MonoMethod *callee, MonoDeclSecurityActions* demands);

MONO_API MonoBoolean mono_declsec_get_method_action (MonoMethod *method, uint32_t action, MonoDeclSecurityEntry *entry);
MONO_API MonoBoolean mono_declsec_get_class_action (MonoClass *klass, uint32_t action, MonoDeclSecurityEntry *entry);
MONO_API MonoBoolean mono_declsec_get_assembly_action (MonoAssembly *assembly, uint32_t action, MonoDeclSecurityEntry *entry);

MONO_API MONO_RT_EXTERNAL_ONLY
MonoType* mono_reflection_type_get_type (MonoReflectionType *reftype);

MONO_API MonoAssembly* mono_reflection_assembly_get_assembly (MonoReflectionAssembly *refassembly);

MONO_END_DECLS

#endif /* __METADATA_REFLECTION_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/remoting.h`:

```h
/**
 * \file
 * Remoting support
 *
 * (C) 2014 Xamarin, Inc.  http://www.xamarin.com
 *
 */

#ifndef __MONO_REMOTING_H__
#define __MONO_REMOTING_H__

#include "config.h"
#include <mono/metadata/class.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/class-internals.h>

void mono_remoting_init (void);

#ifndef DISABLE_REMOTING

MonoMethod *
mono_marshal_get_remoting_invoke (MonoMethod *method, MonoError *error);

MonoMethod *
mono_marshal_get_xappdomain_invoke (MonoMethod *method, MonoError *error);

MonoMethod *
mono_marshal_get_remoting_invoke_for_target (MonoMethod *method, MonoRemotingTarget target_type, MonoError *error);

MonoMethod *
mono_marshal_get_remoting_invoke_with_check (MonoMethod *method, MonoError *error);

MonoMethod *
mono_marshal_get_stfld_wrapper (MonoType *type);

MonoMethod *
mono_marshal_get_ldfld_wrapper (MonoType *type);

MonoMethod *
mono_marshal_get_ldflda_wrapper (MonoType *type);

MonoMethod *
mono_marshal_get_proxy_cancast (MonoClass *klass);

#endif

#endif

```

`Hazel/vendor/mono/include/mono/metadata/row-indexes.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_ROW_INDEXES_H__
#define __MONO_METADATA_ROW_INDEXES_H__

/*
 * The last entry in the enum is used to give the number
 * of columns in the row.
 */

enum {
	MONO_ASSEMBLY_HASH_ALG,
	MONO_ASSEMBLY_MAJOR_VERSION,
	MONO_ASSEMBLY_MINOR_VERSION,
	MONO_ASSEMBLY_BUILD_NUMBER,
	MONO_ASSEMBLY_REV_NUMBER,
	MONO_ASSEMBLY_FLAGS,
	MONO_ASSEMBLY_PUBLIC_KEY,
	MONO_ASSEMBLY_NAME,
	MONO_ASSEMBLY_CULTURE,
	MONO_ASSEMBLY_SIZE
};

enum {
	MONO_ASSEMBLYOS_PLATFORM,
	MONO_ASSEMBLYOS_MAJOR_VERSION,
	MONO_ASSEMBLYOS_MINOR_VERSION,
	MONO_ASSEMBLYOS_SIZE
};

enum {
	MONO_ASSEMBLY_PROCESSOR,
	MONO_ASSEMBLY_PROCESSOR_SIZE
};

enum {
	MONO_ASSEMBLYREF_MAJOR_VERSION,
	MONO_ASSEMBLYREF_MINOR_VERSION,
	MONO_ASSEMBLYREF_BUILD_NUMBER,
	MONO_ASSEMBLYREF_REV_NUMBER,
	MONO_ASSEMBLYREF_FLAGS,
	MONO_ASSEMBLYREF_PUBLIC_KEY,
	MONO_ASSEMBLYREF_NAME,
	MONO_ASSEMBLYREF_CULTURE,
	MONO_ASSEMBLYREF_HASH_VALUE,
	MONO_ASSEMBLYREF_SIZE
};

enum {
	MONO_ASSEMBLYREFOS_PLATFORM,
	MONO_ASSEMBLYREFOS_MAJOR_VERSION,
	MONO_ASSEMBLYREFOS_MINOR_VERSION,
	MONO_ASSEMBLYREFOS_ASSEMBLYREF,
	MONO_ASSEMBLYREFOS_SIZE
};

enum {
	MONO_ASSEMBLYREFPROC_PROCESSOR,
	MONO_ASSEMBLYREFPROC_ASSEMBLYREF,
	MONO_ASSEMBLYREFPROC_SIZE
};

enum {
	MONO_CLASS_LAYOUT_PACKING_SIZE,
	MONO_CLASS_LAYOUT_CLASS_SIZE,
	MONO_CLASS_LAYOUT_PARENT,
	MONO_CLASS_LAYOUT_SIZE
};

enum {
	MONO_CONSTANT_TYPE,
	MONO_CONSTANT_PADDING,
	MONO_CONSTANT_PARENT,
	MONO_CONSTANT_VALUE,
	MONO_CONSTANT_SIZE
};

enum {
	MONO_CUSTOM_ATTR_PARENT,
	MONO_CUSTOM_ATTR_TYPE,
	MONO_CUSTOM_ATTR_VALUE,
	MONO_CUSTOM_ATTR_SIZE
};

enum {
	MONO_DECL_SECURITY_ACTION,
	MONO_DECL_SECURITY_PARENT,
	MONO_DECL_SECURITY_PERMISSIONSET,
	MONO_DECL_SECURITY_SIZE
};

enum {
	MONO_EVENT_MAP_PARENT,
	MONO_EVENT_MAP_EVENTLIST,
	MONO_EVENT_MAP_SIZE
};

enum {
	MONO_EVENT_FLAGS,
	MONO_EVENT_NAME,
	MONO_EVENT_TYPE,
	MONO_EVENT_SIZE
};

enum {
	MONO_EVENT_POINTER_EVENT,
	MONO_EVENT_POINTER_SIZE
};

enum {
	MONO_EXP_TYPE_FLAGS,
	MONO_EXP_TYPE_TYPEDEF,
	MONO_EXP_TYPE_NAME,
	MONO_EXP_TYPE_NAMESPACE,
	MONO_EXP_TYPE_IMPLEMENTATION,
	MONO_EXP_TYPE_SIZE
};

enum {
	MONO_FIELD_FLAGS,
	MONO_FIELD_NAME,
	MONO_FIELD_SIGNATURE,
	MONO_FIELD_SIZE
};

enum {
	MONO_FIELD_LAYOUT_OFFSET,
	MONO_FIELD_LAYOUT_FIELD,
	MONO_FIELD_LAYOUT_SIZE
};

enum {
	MONO_FIELD_MARSHAL_PARENT,
	MONO_FIELD_MARSHAL_NATIVE_TYPE,
	MONO_FIELD_MARSHAL_SIZE
};

enum {
	MONO_FIELD_POINTER_FIELD,
	MONO_FIELD_POINTER_SIZE
};

enum {
	MONO_FIELD_RVA_RVA,
	MONO_FIELD_RVA_FIELD,
	MONO_FIELD_RVA_SIZE
};

enum {
	MONO_FILE_FLAGS,
	MONO_FILE_NAME,
	MONO_FILE_HASH_VALUE,
	MONO_FILE_SIZE
};

enum {
	MONO_IMPLMAP_FLAGS,
	MONO_IMPLMAP_MEMBER,
	MONO_IMPLMAP_NAME,
	MONO_IMPLMAP_SCOPE,
	MONO_IMPLMAP_SIZE
};

enum {
	MONO_INTERFACEIMPL_CLASS,
	MONO_INTERFACEIMPL_INTERFACE,
	MONO_INTERFACEIMPL_SIZE
};

enum {
	MONO_MANIFEST_OFFSET,
	MONO_MANIFEST_FLAGS,
	MONO_MANIFEST_NAME,
	MONO_MANIFEST_IMPLEMENTATION,
	MONO_MANIFEST_SIZE
};

enum {
	MONO_MEMBERREF_CLASS,
	MONO_MEMBERREF_NAME,
	MONO_MEMBERREF_SIGNATURE,
	MONO_MEMBERREF_SIZE
};

enum {
	MONO_METHOD_RVA,
	MONO_METHOD_IMPLFLAGS,
	MONO_METHOD_FLAGS,
	MONO_METHOD_NAME,
	MONO_METHOD_SIGNATURE,
	MONO_METHOD_PARAMLIST,
	MONO_METHOD_SIZE
};

enum {
	MONO_METHODIMPL_CLASS,
	MONO_METHODIMPL_BODY,
	MONO_METHODIMPL_DECLARATION,
	MONO_METHODIMPL_SIZE
};

enum {
	MONO_METHOD_POINTER_METHOD,
	MONO_METHOD_POINTER_SIZE
};

enum {
	MONO_METHOD_SEMA_SEMANTICS,
	MONO_METHOD_SEMA_METHOD,
	MONO_METHOD_SEMA_ASSOCIATION,
	MONO_METHOD_SEMA_SIZE
};

enum {
	MONO_MODULE_GENERATION,
	MONO_MODULE_NAME,
	MONO_MODULE_MVID,
	MONO_MODULE_ENC,
	MONO_MODULE_ENCBASE,
	MONO_MODULE_SIZE
};

enum {
	MONO_MODULEREF_NAME,
	MONO_MODULEREF_SIZE
};

enum {
	MONO_NESTED_CLASS_NESTED,
	MONO_NESTED_CLASS_ENCLOSING,
	MONO_NESTED_CLASS_SIZE
};

enum {
	MONO_PARAM_FLAGS,
	MONO_PARAM_SEQUENCE,
	MONO_PARAM_NAME,
	MONO_PARAM_SIZE
};

enum {
	MONO_PARAM_POINTER_PARAM,
	MONO_PARAM_POINTER_SIZE
};

enum {
	MONO_PROPERTY_FLAGS,
	MONO_PROPERTY_NAME,
	MONO_PROPERTY_TYPE,
	MONO_PROPERTY_SIZE
};

enum {
	MONO_PROPERTY_POINTER_PROPERTY,
	MONO_PROPERTY_POINTER_SIZE
};

enum {
	MONO_PROPERTY_MAP_PARENT,
	MONO_PROPERTY_MAP_PROPERTY_LIST,
	MONO_PROPERTY_MAP_SIZE
};

enum {
	MONO_STAND_ALONE_SIGNATURE,
	MONO_STAND_ALONE_SIGNATURE_SIZE
};

enum {
	MONO_TYPEDEF_FLAGS,
	MONO_TYPEDEF_NAME,
	MONO_TYPEDEF_NAMESPACE,
	MONO_TYPEDEF_EXTENDS,
	MONO_TYPEDEF_FIELD_LIST,
	MONO_TYPEDEF_METHOD_LIST,
	MONO_TYPEDEF_SIZE
};

enum {
	MONO_TYPEREF_SCOPE,
	MONO_TYPEREF_NAME,
	MONO_TYPEREF_NAMESPACE,
	MONO_TYPEREF_SIZE
};

enum {
	MONO_TYPESPEC_SIGNATURE,
	MONO_TYPESPEC_SIZE
};

enum {
	MONO_GENERICPARAM_NUMBER,
	MONO_GENERICPARAM_FLAGS,
	MONO_GENERICPARAM_OWNER,
	MONO_GENERICPARAM_NAME,
	
	MONO_GENERICPARAM_SIZE
};

enum {
	MONO_METHODSPEC_METHOD,
	MONO_METHODSPEC_SIGNATURE,
	MONO_METHODSPEC_SIZE
};

enum {
	MONO_GENPARCONSTRAINT_GENERICPAR,
	MONO_GENPARCONSTRAINT_CONSTRAINT,
	MONO_GENPARCONSTRAINT_SIZE
};

enum {
	MONO_DOCUMENT_NAME,
	MONO_DOCUMENT_HASHALG,
	MONO_DOCUMENT_HASH,
	MONO_DOCUMENT_LANGUAGE,
	MONO_DOCUMENT_SIZE
};

enum {
	MONO_METHODBODY_DOCUMENT,
	MONO_METHODBODY_SEQ_POINTS,
	MONO_METHODBODY_SIZE
};

enum {
	MONO_LOCALSCOPE_METHOD,
	MONO_LOCALSCOPE_IMPORTSCOPE,
	MONO_LOCALSCOPE_VARIABLELIST,
	MONO_LOCALSCOPE_CONSTANTLIST,
	MONO_LOCALSCOPE_STARTOFFSET,
	MONO_LOCALSCOPE_LENGTH,
	MONO_LOCALSCOPE_SIZE
};

enum {
	MONO_LOCALVARIABLE_ATTRIBUTES,
	MONO_LOCALVARIABLE_INDEX,
	MONO_LOCALVARIABLE_NAME,
	MONO_LOCALVARIABLE_SIZE
};

enum {
	MONO_CUSTOMDEBUGINFORMATION_PARENT,
	MONO_CUSTOMDEBUGINFORMATION_KIND,
	MONO_CUSTOMDEBUGINFORMATION_VALUE,
	MONO_CUSTOMDEBUGINFORMATION_SIZE
};

/*
 * Coded Tokens
 * The _BITS entry is for the bits used in the token.
 * The _MASK entry is for mask the index out.
 */

enum {
	MONO_TYPEDEFORREF_TYPEDEF,
	MONO_TYPEDEFORREF_TYPEREF,
	MONO_TYPEDEFORREF_TYPESPEC,
	MONO_TYPEDEFORREF_BITS = 2,
	MONO_TYPEDEFORREF_MASK = 3
};

enum {
	MONO_HASCONSTANT_FIEDDEF,
	MONO_HASCONSTANT_PARAM,
	MONO_HASCONSTANT_PROPERTY,
	MONO_HASCONSTANT_BITS = 2,
	MONO_HASCONSTANT_MASK = 3
};

enum {
	MONO_CUSTOM_ATTR_METHODDEF,
	MONO_CUSTOM_ATTR_FIELDDEF,
	MONO_CUSTOM_ATTR_TYPEREF,
	MONO_CUSTOM_ATTR_TYPEDEF,
	MONO_CUSTOM_ATTR_PARAMDEF,
	MONO_CUSTOM_ATTR_INTERFACE,
	MONO_CUSTOM_ATTR_MEMBERREF,
	MONO_CUSTOM_ATTR_MODULE,
	MONO_CUSTOM_ATTR_PERMISSION,
	MONO_CUSTOM_ATTR_PROPERTY,
	MONO_CUSTOM_ATTR_EVENT,
	MONO_CUSTOM_ATTR_SIGNATURE,
	MONO_CUSTOM_ATTR_MODULEREF,
	MONO_CUSTOM_ATTR_TYPESPEC,
	MONO_CUSTOM_ATTR_ASSEMBLY,
	MONO_CUSTOM_ATTR_ASSEMBLYREF,
	MONO_CUSTOM_ATTR_FILE,
	MONO_CUSTOM_ATTR_EXP_TYPE,
	MONO_CUSTOM_ATTR_MANIFEST,
	MONO_CUSTOM_ATTR_GENERICPAR,
	MONO_CUSTOM_ATTR_GENERICPARAMCONSTRAINT,
	MONO_CUSTOM_ATTR_BITS = 5,
	MONO_CUSTOM_ATTR_MASK = 0x1F
};

enum {
	MONO_HAS_FIELD_MARSHAL_FIELDSREF,
	MONO_HAS_FIELD_MARSHAL_PARAMDEF,
	MONO_HAS_FIELD_MARSHAL_BITS = 1,
	MONO_HAS_FIELD_MARSHAL_MASK = 1
};

enum {
	MONO_HAS_DECL_SECURITY_TYPEDEF,
	MONO_HAS_DECL_SECURITY_METHODDEF,
	MONO_HAS_DECL_SECURITY_ASSEMBLY,
	MONO_HAS_DECL_SECURITY_BITS = 2,
	MONO_HAS_DECL_SECURITY_MASK = 3
};

enum {
	MONO_MEMBERREF_PARENT_TYPEDEF, /* not used */
	MONO_MEMBERREF_PARENT_TYPEREF,
	MONO_MEMBERREF_PARENT_MODULEREF,
	MONO_MEMBERREF_PARENT_METHODDEF,
	MONO_MEMBERREF_PARENT_TYPESPEC,
	MONO_MEMBERREF_PARENT_BITS = 3,
	MONO_MEMBERREF_PARENT_MASK = 7
};

enum {
	MONO_HAS_SEMANTICS_EVENT,
	MONO_HAS_SEMANTICS_PROPERTY,
	MONO_HAS_SEMANTICS_BITS = 1,
	MONO_HAS_SEMANTICS_MASK = 1
};

enum {
	MONO_METHODDEFORREF_METHODDEF,
	MONO_METHODDEFORREF_METHODREF,
	MONO_METHODDEFORREF_BITS = 1,
	MONO_METHODDEFORREF_MASK = 1
};

enum {
	MONO_MEMBERFORWD_FIELDDEF,
	MONO_MEMBERFORWD_METHODDEF,
	MONO_MEMBERFORWD_BITS = 1,
	MONO_MEMBERFORWD_MASK = 1
};

enum {
	MONO_IMPLEMENTATION_FILE,
	MONO_IMPLEMENTATION_ASSEMBLYREF,
	MONO_IMPLEMENTATION_EXP_TYPE,
	MONO_IMPLEMENTATION_BITS = 2,
	MONO_IMPLEMENTATION_MASK = 3
};

enum {
	MONO_CUSTOM_ATTR_TYPE_TYPEREF, /* not used */
	MONO_CUSTOM_ATTR_TYPE_TYPEDEF, /* not used */
	MONO_CUSTOM_ATTR_TYPE_METHODDEF,
	MONO_CUSTOM_ATTR_TYPE_MEMBERREF,
	MONO_CUSTOM_ATTR_TYPE_STRING, /* not used */
	MONO_CUSTOM_ATTR_TYPE_BITS = 3,
	MONO_CUSTOM_ATTR_TYPE_MASK = 7
};

enum {
	MONO_RESOLUTION_SCOPE_MODULE,
	MONO_RESOLUTION_SCOPE_MODULEREF,
	MONO_RESOLUTION_SCOPE_ASSEMBLYREF,
	MONO_RESOLUTION_SCOPE_TYPEREF,
	MONO_RESOLUTION_SCOPE_BITS = 2,
	MONO_RESOLUTION_SCOPE_MASK = 3
};

/* Kept for compatibility since this is a public header file */
enum {
	MONO_RESOLTION_SCOPE_MODULE,
	MONO_RESOLTION_SCOPE_MODULEREF,
	MONO_RESOLTION_SCOPE_ASSEMBLYREF,
	MONO_RESOLTION_SCOPE_TYPEREF,
	MONO_RESOLTION_SCOPE_BITS = 2,
	MONO_RESOLTION_SCOPE_MASK = 3
};

enum {
	MONO_TYPEORMETHOD_TYPE,
	MONO_TYPEORMETHOD_METHOD,
	MONO_TYPEORMETHOD_BITS = 1,
	MONO_TYPEORMETHOD_MASK = 1
};

#endif /* __MONO_METADATA_ROW_INDEXES_H__ */



```

`Hazel/vendor/mono/include/mono/metadata/runtime.h`:

```h
/**
 * \file
 * Runtime functions
 *
 * Author:
 *	Jonathan Pryor
 *
 * (C) 2010 Novell, Inc.
 */

#ifndef _MONO_METADATA_RUNTIME_H_
#define _MONO_METADATA_RUNTIME_H_

#include <glib.h>
#include <mono/metadata/metadata.h>
#include <mono/utils/mono-publib.h>
#include <mono/utils/mono-compiler.h>

gboolean mono_runtime_try_shutdown (void);

void mono_runtime_init_tls (void);

MONO_PROFILER_API char* mono_runtime_get_aotid (void);

#endif /* _MONO_METADATA_RUNTIME_H_ */



```

`Hazel/vendor/mono/include/mono/metadata/security-core-clr.h`:

```h
/**
 * \file
 * CoreCLR security
 *
 * Author:
 *	Mark Probst <mark.probst@gmail.com>
 *
 * (C) 2007, 2010 Novell, Inc
 */

#ifndef _MONO_METADATA_SECURITY_CORE_CLR_H_
#define _MONO_METADATA_SECURITY_CORE_CLR_H_

#include <glib.h>
#include <mono/metadata/reflection.h>
#include <mono/utils/mono-compiler.h>

typedef enum {
	/* We compare these values as integers, so the order must not
	   be changed. */
	MONO_SECURITY_CORE_CLR_TRANSPARENT = 0,
	MONO_SECURITY_CORE_CLR_SAFE_CRITICAL,
	MONO_SECURITY_CORE_CLR_CRITICAL
} MonoSecurityCoreCLRLevel;

typedef enum {
	//The following flags can be used in combination, and control specific behaviour of the CoreCLR securit system.

	//Default coreclr behaviour, as used in moonlight.
	MONO_SECURITY_CORE_CLR_OPTIONS_DEFAULT = 0,

	//Allow transparent code to execute methods and access fields that are not in platformcode,
	//even if those methods and fields are private or otherwise not visible to the calling code.
	MONO_SECURITY_CORE_CLR_OPTIONS_RELAX_REFLECTION = 1,

	//Allow delegates to be created that point at methods that are not in platformcode,
	//even if those methods and fields are private or otherwise not visible to the calling code.
	MONO_SECURITY_CORE_CLR_OPTIONS_RELAX_DELEGATE = 2
} MonoSecurityCoreCLROptions;

extern gboolean mono_security_core_clr_test;

extern void mono_security_core_clr_check_inheritance (MonoClass *klass);
extern void mono_security_core_clr_check_override (MonoClass *klass, MonoMethod *override, MonoMethod *base);

extern gboolean
mono_security_core_clr_ensure_reflection_access_field (MonoClassField *field, MonoError *error);
extern gboolean
mono_security_core_clr_ensure_reflection_access_method (MonoMethod *method, MonoError *error);
extern gboolean mono_security_core_clr_ensure_delegate_creation (MonoMethod *method, MonoError *error);
extern MonoException* mono_security_core_clr_ensure_dynamic_method_resolved_object (gpointer ref, MonoClass *handle_class);

extern gboolean mono_security_core_clr_can_access_internals (MonoImage *accessing, MonoImage* accessed);

extern MonoException* mono_security_core_clr_is_field_access_allowed (MonoMethod *caller, MonoClassField *field);
extern MonoException* mono_security_core_clr_is_call_allowed (MonoMethod *caller, MonoMethod *callee);

extern MonoSecurityCoreCLRLevel mono_security_core_clr_class_level (MonoClass *klass);
extern MonoSecurityCoreCLRLevel mono_security_core_clr_field_level (MonoClassField *field, gboolean with_class_level);
extern MonoSecurityCoreCLRLevel mono_security_core_clr_method_level (MonoMethod *method, gboolean with_class_level);

extern gboolean mono_security_core_clr_is_platform_image (MonoImage *image);
extern gboolean mono_security_core_clr_determine_platform_image (MonoImage *image);

MONO_API gboolean mono_security_core_clr_require_elevated_permissions (void);

MONO_API void mono_security_core_clr_set_options (MonoSecurityCoreCLROptions options);
MONO_API MonoSecurityCoreCLROptions mono_security_core_clr_get_options (void);

#endif	/* _MONO_METADATA_SECURITY_CORE_CLR_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/security-manager.h`:

```h
/**
 * \file
 * Security Manager
 *
 * Author:
 *	Sebastien Pouliot  <sebastien@ximian.com>
 *
 * Copyright (C) 2004-2005 Novell, Inc (http://www.novell.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_METADATA_SECURITY_MANAGER_H_
#define _MONO_METADATA_SECURITY_MANAGER_H_

#include <string.h>

#include "object.h"
#include "metadata-internals.h"
#include "domain-internals.h"
#include "tokentype.h"
#include "threads.h"
#include "marshal.h"
#include "image.h"
#include "reflection.h"
#include "tabledefs.h"
#include <mono/metadata/icalls.h>

/* Definitions */

#define MONO_ECMA_KEY_LENGTH			16
#define MONO_PUBLIC_KEY_HEADER_LENGTH		32
#define MONO_MINIMUM_PUBLIC_KEY_LENGTH		48
#define MONO_DEFAULT_PUBLIC_KEY_LENGTH		128

#define MONO_PUBLIC_KEY_BIT_SIZE(x)		((x - MONO_PUBLIC_KEY_HEADER_LENGTH) << 3)

enum {
	MONO_METADATA_SECURITY_OK		= 0x00,
	MONO_METADATA_INHERITANCEDEMAND_CLASS	= 0x01,
	MONO_METADATA_INHERITANCEDEMAND_METHOD	= 0x02
};

typedef enum {
	MONO_SECURITY_MODE_NONE,
	MONO_SECURITY_MODE_CORE_CLR,
} MonoSecurityMode;

/* Structures */

typedef struct {
	MonoClass *securitymanager;		/* System.Security.SecurityManager */
} MonoSecurityManager;

gboolean mono_is_ecma_key (const char *publickey, int size);

MonoSecurityManager* mono_security_manager_get_methods (void);

/* Security mode */
void mono_security_set_mode (MonoSecurityMode mode);
MonoSecurityMode mono_security_get_mode (void);

/* internal calls */
ICALL_EXPORT
MonoBoolean ves_icall_System_Security_SecurityManager_get_SecurityEnabled (void);

ICALL_EXPORT
void ves_icall_System_Security_SecurityManager_set_SecurityEnabled (MonoBoolean value);

#ifndef DISABLE_SECURITY
#define mono_security_core_clr_enabled() (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)
#else
#define mono_security_core_clr_enabled() (FALSE)
#endif

#endif /* _MONO_METADATA_SECURITY_MANAGER_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/security.h`:

```h
/**
 * \file
 * Security internal calls
 *
 * Author:
 *	Sebastien Pouliot  <sebastien@ximian.com>
 *
 * (C) 2004 Novell (http://www.novell.com)
 */


#ifndef _MONO_METADATA_SECURITY_H_
#define _MONO_METADATA_SECURITY_H_

#include <glib.h>
#include <mono/metadata/object.h>
#include <mono/metadata/object-internals.h>
#include <mono/utils/mono-compiler.h>
#include <mono/utils/mono-error.h>
#include <mono/utils/mono-publib.h>
#include <mono/metadata/icalls.h>
#include "reflection-internals.h"

/* System.Security.Principal.WindowsIdentity */
gpointer
mono_security_principal_windows_identity_get_current_token (MonoError *error);

#endif /* _MONO_METADATA_SECURITY_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/seq-points-data.h`:

```h
/**
 * \file
 * Copyright 2015 Xamarin Inc
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
 
#ifndef __MONO_SEQ_POINTS_DATA_H__
#define __MONO_SEQ_POINTS_DATA_H__

#include <glib.h>

#define MONO_SEQ_POINT_FLAG_NONEMPTY_STACK 1
#define MONO_SEQ_POINT_FLAG_EXIT_IL 2
#define MONO_SEQ_POINT_FLAG_NESTED_CALL 4

/* IL offsets used to mark the sequence points belonging to method entry/exit events */
#define METHOD_ENTRY_IL_OFFSET -1
#define METHOD_EXIT_IL_OFFSET 0xffffff

#define SEQ_POINT_AOT_EXT ".msym"

/* Native offset used to mark seq points in dead code */
#define SEQ_POINT_NATIVE_OFFSET_DEAD_CODE -1 

typedef struct {
	int il_offset, native_offset, flags;
	/* Offset of indexes of successor sequence points on the compressed buffer */
	int next_offset;
	/* Number of entries in next */
	int next_len;
} SeqPoint;

typedef struct MonoSeqPointInfo {
	int dummy [1];
} MonoSeqPointInfo;

typedef struct {
	SeqPoint seq_point;
	guint8* ptr;
	guint8* begin;
	guint8* end;
	gboolean has_debug_data;
} SeqPointIterator;

void
mono_seq_point_info_free (gpointer info);

gboolean
mono_seq_point_iterator_next (SeqPointIterator* it);

void
mono_seq_point_iterator_init (SeqPointIterator* it, MonoSeqPointInfo* info);

void
mono_seq_point_init_next (MonoSeqPointInfo* info, SeqPoint sp, SeqPoint* next);

int
mono_seq_point_info_write (MonoSeqPointInfo* info, guint8* buffer);

int
mono_seq_point_info_read (MonoSeqPointInfo** info, guint8* buffer, gboolean copy);

int
mono_seq_point_info_get_write_size (MonoSeqPointInfo* info);

gboolean
mono_seq_point_info_add_seq_point (GByteArray* array, SeqPoint *sp, SeqPoint *last_seq_point, GSList *next, gboolean has_debug_data);

MonoSeqPointInfo*
mono_seq_point_info_new (int len, gboolean alloc_data, guint8 *data, gboolean has_debug_data, int *out_size);

gboolean
mono_seq_point_find_prev_by_native_offset (MonoSeqPointInfo* info, int native_offset, SeqPoint* seq_point);

gboolean
mono_seq_point_find_next_by_native_offset (MonoSeqPointInfo* info, int native_offset, SeqPoint* seq_point);

gboolean
mono_seq_point_find_by_il_offset (MonoSeqPointInfo* info, int il_offset, SeqPoint* seq_point);

/*
 * SeqPointData struct and functions
 * This is used to store/load/use sequence point from a file
 */

typedef struct {
	guint32 method_token;
	guint32 method_index;
	MonoSeqPointInfo* seq_points;
	gboolean free_seq_points;
} SeqPointDataEntry;

typedef struct {
	SeqPointDataEntry* entries;
	int entry_count;
	int entry_capacity;
} SeqPointData;

void
mono_seq_point_data_init (SeqPointData *data, int entry_capacity);

void
mono_seq_point_data_free (SeqPointData *data);

gboolean
mono_seq_point_data_read (SeqPointData *data, char *path);

gboolean
mono_seq_point_data_write (SeqPointData *data, char *path);

void
mono_seq_point_data_add (SeqPointData *data, guint32 methodToken, guint32 methodIndex, MonoSeqPointInfo* info);

gboolean
mono_seq_point_data_get (SeqPointData *data, guint32 methodToken, guint32 methodIndex, MonoSeqPointInfo** info);

gboolean
mono_seq_point_data_get_il_offset (char *path, guint32 methodToken, guint32 methodIndex, guint32 native_offset, guint32 *il_offset);

#endif /* __MONO_SEQ_POINTS_DATA_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/sgen-bridge-internals.h`:

```h
/**
 * \file
 * The cross-GC bridge.
 *
 * Copyright (C) 2015 Xamarin Inc
 *
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef __MONO_SGENBRIDGEINTERNAL_H__
#define __MONO_SGENBRIDGEINTERNAL_H__

#include "config.h"

#ifdef HAVE_SGEN_GC

#include "mono/utils/mono-compiler.h"

#include "mono/sgen/sgen-gc.h"
#include "mono/metadata/sgen-bridge.h"

extern volatile gboolean mono_bridge_processing_in_progress;
extern MonoGCBridgeCallbacks mono_bridge_callbacks;

gboolean sgen_need_bridge_processing (void);
void sgen_bridge_reset_data (void);
void sgen_bridge_processing_stw_step (void);
void sgen_bridge_processing_finish (int generation);
gboolean sgen_is_bridge_object (GCObject *obj);
MonoGCBridgeObjectKind sgen_bridge_class_kind (MonoClass *klass);
void sgen_bridge_register_finalized_object (GCObject *object);
void sgen_bridge_describe_pointer (GCObject *object);

gboolean sgen_is_bridge_object (GCObject *obj);
void sgen_mark_bridge_object (GCObject *obj);

gboolean sgen_bridge_handle_gc_param (const char *opt);
gboolean sgen_bridge_handle_gc_debug (const char *opt);
void sgen_bridge_print_gc_debug_usage (void);

typedef struct {
	char *dump_prefix;
	gboolean accounting;
	gboolean scc_precise_merge; // Used by Tarjan
	// Disables reporting SCCs with no bridge objects on tarjan. Used when comparing outputs
	// of two bridge processors, in order to keep consistency.
	gboolean disable_non_bridge_scc;
} SgenBridgeProcessorConfig;

typedef struct {
	void (*reset_data) (void);
	void (*processing_stw_step) (void);
	void (*processing_build_callback_data) (int generation);
	void (*processing_after_callback) (int generation);
	MonoGCBridgeObjectKind (*class_kind) (MonoClass *klass);
	void (*register_finalized_object) (GCObject *object);
	void (*describe_pointer) (GCObject *object);

	/* Should be called once, immediately after init */
	void (*set_config) (const SgenBridgeProcessorConfig *);

	/*
	 * These are set by processing_build_callback_data().
	 */
	int num_sccs;
	MonoGCBridgeSCC **api_sccs;

	int num_xrefs;
	MonoGCBridgeXRef *api_xrefs;
} SgenBridgeProcessor;

void sgen_old_bridge_init (SgenBridgeProcessor *collector);
void sgen_new_bridge_init (SgenBridgeProcessor *collector);
void sgen_tarjan_bridge_init (SgenBridgeProcessor *collector);
void sgen_set_bridge_implementation (const char *name);
void sgen_bridge_set_dump_prefix (const char *prefix);
void sgen_init_bridge (void);

#endif

#endif

```

`Hazel/vendor/mono/include/mono/metadata/sgen-bridge.h`:

```h
/**
 * \file
 * Copyright 2011 Novell, Inc.
 * 
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

/*
 * The bridge is a mechanism for SGen to let clients override the death of some
 * unreachable objects.  We use it in monodroid to do garbage collection across
 * the Mono and Java heaps.
 *
 * The client (Monodroid) can designate some objects as "bridged", which means
 * that they participate in the bridge processing step once SGen considers them
 * unreachable, i.e., dead.  Bridged objects must be registered for
 * finalization.
 *
 * When SGen is done marking, it puts together a list of all dead bridged
 * objects.  This is passed to the bridge processor, which does an analysis to
 * simplify the graph: It replaces strongly-connected components with single
 * nodes, and may remove nodes corresponding to components which do not contain
 * bridged objects.
 *
 * The output of the SCC analysis is passed to the client's `cross_references()`
 * callback.  This consists of 2 arrays, an array of SCCs (MonoGCBridgeSCC),
 * and an array of "xrefs" (edges between SCCs, MonoGCBridgeXRef).  Edges are
 * encoded as pairs of "API indices", ie indexes in the SCC array.  The client
 * is expected to set the `is_alive` flag on those strongly connected components
 * that it wishes to be kept alive.
 *
 * In monodroid each bridged object has a corresponding Java mirror object.  In
 * the bridge callback it reifies the Mono object graph in the Java heap so that
 * the full, combined object graph is now instantiated on the Java side.  Then
 * it triggers a Java GC, waits for it to finish, and checks which of the Java
 * mirror objects are still alive.  For those it sets the `is_alive` flag and
 * returns from the callback.
 *
 * The SCC analysis is done while the world is stopped, but the callback is made
 * with the world running again.  Weak links to bridged objects and other
 * objects reachable from them are kept until the callback returns, at which
 * point all links to bridged objects that don't have `is_alive` set are nulled.
 * Note that weak links to non-bridged objects reachable from bridged objects
 * are not nulled.  This might be considered a bug.
 *
 * There are three different implementations of the bridge processor, each of
 * which implements 8 callbacks (see SgenBridgeProcessor).  The implementations
 * differ in the algorithm they use to compute the "simplified" SCC graph.
 */

#ifndef _MONO_SGEN_BRIDGE_H_
#define _MONO_SGEN_BRIDGE_H_

#include <mono/utils/mono-publib.h>

MONO_BEGIN_DECLS

enum {
	SGEN_BRIDGE_VERSION = 5
};
	
typedef enum {
	/* Instances of this class should be scanned when computing the transitive dependency among bridges. E.g. List<object>*/
	GC_BRIDGE_TRANSPARENT_CLASS,
	/* Instances of this class should not be scanned when computing the transitive dependency among bridges. E.g. String*/
	GC_BRIDGE_OPAQUE_CLASS,
	/* Instances of this class should be bridged and have their dependency computed. */
	GC_BRIDGE_TRANSPARENT_BRIDGE_CLASS,
	/* Instances of this class should be bridged but no dependencies should not be calculated. */
	GC_BRIDGE_OPAQUE_BRIDGE_CLASS,
} MonoGCBridgeObjectKind;

typedef struct {
	mono_bool is_alive;	/* to be set by the cross reference callback */
	int num_objs;
	MonoObject *objs [MONO_ZERO_LEN_ARRAY];
} MonoGCBridgeSCC;

typedef struct {
	int src_scc_index;
	int dst_scc_index;
} MonoGCBridgeXRef;

typedef struct {
	int bridge_version;
	/*
	 * Tells the runtime which classes to even consider when looking for
	 * bridged objects.  If subclasses are to be considered as well, the
	 * subclass check must be done in the callback.
	 */
	MonoGCBridgeObjectKind (*bridge_class_kind) (MonoClass *klass);
	/*
	 * This is only called on objects for whose classes
	 * `bridge_class_kind()` returned `XXX_BRIDGE_CLASS`.
	 */
	mono_bool (*is_bridge_object) (MonoObject *object);
	void (*cross_references) (int num_sccs, MonoGCBridgeSCC **sccs, int num_xrefs, MonoGCBridgeXRef *xrefs);
} MonoGCBridgeCallbacks;

/*
 * Note: This may be called at any time, but cannot be called concurrently
 * with (during and on a separate thread from) sgen init. Callers are
 * responsible for enforcing this.
 */
MONO_API void mono_gc_register_bridge_callbacks (MonoGCBridgeCallbacks *callbacks);

MONO_API void mono_gc_wait_for_bridge_processing (void);

MONO_END_DECLS

#endif

```

`Hazel/vendor/mono/include/mono/metadata/sgen-client-mono.h`:

```h
/**
 * \file
 * Mono's client definitions for SGen.
 *
 * Copyright (C) 2014 Xamarin Inc
 *
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifdef SGEN_DEFINE_OBJECT_VTABLE

#include "sgen/sgen-archdep.h"
#include "utils/mono-threads.h"
#include "utils/mono-mmap.h"
#include "metadata/object-internals.h"

typedef MonoObject GCObject;
typedef MonoVTable* GCVTable;

static inline GCVTable
SGEN_LOAD_VTABLE_UNCHECKED (GCObject *obj)
{
	return obj->vtable;
}

static inline SgenDescriptor
sgen_vtable_get_descriptor (GCVTable vtable)
{
	return (SgenDescriptor)vtable->gc_descr;
}

typedef struct _SgenClientThreadInfo SgenClientThreadInfo;
struct _SgenClientThreadInfo {
	MonoThreadInfo info;

	/*
	 * `skip` is set to TRUE when STW fails to suspend a thread, most probably because
	 * the underlying thread is dead.
	*/
	gboolean skip, suspend_done;
	volatile int in_critical_region;

#ifdef SGEN_POSIX_STW
	/* This is -1 until the first suspend. */
	int signal;
	/* FIXME: kill this, we only use signals on systems that have rt-posix, which doesn't have issues with duplicates. */
	unsigned int stop_count; /* to catch duplicate signals. */
#endif

	gpointer runtime_data;

	void *stack_end;
	void *stack_start;
	void *stack_start_limit;

	MonoContext ctx;		/* ditto */
};

#else

#include "metadata/profiler-private.h"
#include "utils/dtrace.h"
#include "utils/mono-counters.h"
#include "utils/mono-logger-internals.h"
#include "utils/mono-time.h"
#include "utils/mono-os-semaphore.h"
#include "metadata/sgen-bridge-internals.h"

extern void mono_sgen_register_moved_object (void *obj, void *destination);
extern void mono_sgen_gc_event_moves (void);
extern void mono_sgen_gc_event_resize (void);

extern void mono_sgen_init_stw (void);

enum {
	INTERNAL_MEM_EPHEMERON_LINK = INTERNAL_MEM_FIRST_CLIENT,
	INTERNAL_MEM_MOVED_OBJECT,
	INTERNAL_MEM_MAX
};

static inline mword
sgen_mono_array_size (GCVTable vtable, MonoArray *array, mword *bounds_size, mword descr)
{
	mword size, size_without_bounds;
	int element_size;

	if ((descr & DESC_TYPE_MASK) == DESC_TYPE_VECTOR)
		element_size = ((descr) >> VECTOR_ELSIZE_SHIFT) & MAX_ELEMENT_SIZE;
	else
		element_size = m_class_get_sizes (vtable->klass).element_size;

	size_without_bounds = size = MONO_SIZEOF_MONO_ARRAY + (mword)element_size * mono_array_length_internal (array);

	if (G_UNLIKELY (array->bounds)) {
		size += sizeof (mono_array_size_t) - 1;
		size &= ~(sizeof (mono_array_size_t) - 1);
		size += sizeof (MonoArrayBounds) * m_class_get_rank (vtable->klass);
	}

	if (bounds_size)
		*bounds_size = size - size_without_bounds;
	return size;
}

#define SGEN_CLIENT_OBJECT_HEADER_SIZE		(sizeof (GCObject))
#define SGEN_CLIENT_MINIMUM_OBJECT_SIZE		SGEN_CLIENT_OBJECT_HEADER_SIZE

static mword /*__attribute__ ((__noinline__)) not sure if this hint is a good idea*/
sgen_client_slow_object_get_size (GCVTable vtable, GCObject* o)
{
	MonoClass *klass = ((MonoVTable*)vtable)->klass;

	/*
	 * We depend on mono_string_length_fast and
	 * mono_array_length_internal not using the object's vtable.
	 */
	if (klass == mono_defaults.string_class) {
		return MONO_SIZEOF_MONO_STRING + 2 * mono_string_length_fast ((MonoString*) o) + 2;
	} else if (m_class_get_rank (klass)) {
		return sgen_mono_array_size (vtable, (MonoArray*)o, NULL, 0);
	} else {
		/* from a created object: the class must be inited already */
		return m_class_get_instance_size (klass);
	}
}

/*
 * This function can be called on an object whose first word, the
 * vtable field, is not intact.  This is necessary for the parallel
 * collector.
 */
static MONO_NEVER_INLINE mword
sgen_client_par_object_get_size (GCVTable vtable, GCObject* o)
{
	SgenDescriptor descr = sgen_vtable_get_descriptor (vtable);
	mword type = descr & DESC_TYPE_MASK;

	if (type == DESC_TYPE_RUN_LENGTH || type == DESC_TYPE_SMALL_PTRFREE) {
		mword size = descr & 0xfff8;
		SGEN_ASSERT (9, size >= sizeof (MonoObject), "Run length object size to small");
		return size;
	} else if (descr == SGEN_DESC_STRING) {
		return G_STRUCT_OFFSET (MonoString, chars) + 2 * mono_string_length_fast ((MonoString*) o) + 2;
	} else if (type == DESC_TYPE_VECTOR) {
		return sgen_mono_array_size (vtable, (MonoArray*)o, NULL, descr);
	}

	return sgen_client_slow_object_get_size (vtable, o);
}

static MONO_ALWAYS_INLINE size_t G_GNUC_UNUSED
sgen_client_array_element_size (GCVTable gc_vtable)
{
	MonoVTable *vt = (MonoVTable*)gc_vtable;
	return mono_array_element_size (vt->klass);
}

static MONO_ALWAYS_INLINE G_GNUC_UNUSED char*
sgen_client_array_data_start (GCObject *obj)
{
	return (char*)(obj) +  G_STRUCT_OFFSET (MonoArray, vector);
}

static MONO_ALWAYS_INLINE size_t G_GNUC_UNUSED
sgen_client_array_length (GCObject *obj)
{
	return mono_array_length_internal ((MonoArray*)obj);
}

static MONO_ALWAYS_INLINE gboolean G_GNUC_UNUSED
sgen_client_object_is_array_fill (GCObject *o)
{
	return ((MonoObject*)o)->synchronisation == GINT_TO_POINTER (-1);
}

static MONO_ALWAYS_INLINE void G_GNUC_UNUSED
sgen_client_pre_copy_checks (char *destination, GCVTable gc_vtable, void *obj, mword objsize)
{
	MonoVTable *vt = (MonoVTable*)gc_vtable;
	SGEN_ASSERT (9, m_class_is_inited (vt->klass), "vtable %p for class %s:%s was not initialized", vt, m_class_get_name_space (vt->klass), m_class_get_name (vt->klass));
}

static MONO_ALWAYS_INLINE void G_GNUC_UNUSED
sgen_client_update_copied_object (char *destination, GCVTable gc_vtable, void *obj, mword objsize)
{
	MonoVTable *vt = (MonoVTable*)gc_vtable;
	if (G_UNLIKELY (vt->rank && ((MonoArray*)obj)->bounds)) {
		MonoArray *array = (MonoArray*)destination;
		array->bounds = (MonoArrayBounds*)((char*)destination + ((char*)((MonoArray*)obj)->bounds - (char*)obj));
		SGEN_LOG (9, "Array instance %p: size: %lu, rank: %d, length: %lu", array, (unsigned long)objsize, vt->rank, (unsigned long)mono_array_length_internal (array));
	}

	if (MONO_PROFILER_ENABLED (gc_moves))
		mono_sgen_register_moved_object (obj, destination);
}

#ifdef XDOMAIN_CHECKS_IN_WBARRIER
extern gboolean sgen_mono_xdomain_checks;

#define sgen_client_wbarrier_generic_nostore_check(ptr) do {		\
		/* FIXME: ptr_in_heap must be called with the GC lock held */ \
		if (sgen_mono_xdomain_checks && *(MonoObject**)ptr && ptr_in_heap (ptr)) { \
			char *start = find_object_for_ptr (ptr);	\
			MonoObject *value = *(MonoObject**)ptr;		\
			LOCK_GC;					\
			SGEN_ASSERT (0, start, "Write barrier outside an object?"); \
			if (start) {					\
				MonoObject *obj = (MonoObject*)start;	\
				if (obj->vtable->domain != value->vtable->domain) \
					SGEN_ASSERT (0, is_xdomain_ref_allowed (ptr, start, obj->vtable->domain), "Cross-domain ref not allowed"); \
			}						\
			UNLOCK_GC;					\
		}							\
	} while (0)
#else
#define sgen_client_wbarrier_generic_nostore_check(ptr)
#endif

static gboolean G_GNUC_UNUSED
sgen_client_object_has_critical_finalizer (GCObject *obj)
{
	MonoClass *klass;

	if (!mono_defaults.critical_finalizer_object)
		return FALSE;

	klass = SGEN_LOAD_VTABLE (obj)->klass;

	return mono_class_has_parent_fast (klass, mono_defaults.critical_finalizer_object);
}

const char* sgen_client_vtable_get_namespace (GCVTable vtable);
const char* sgen_client_vtable_get_name (GCVTable vtable);

static gboolean G_GNUC_UNUSED
sgen_client_bridge_need_processing (void)
{
	return sgen_need_bridge_processing ();
}

static void G_GNUC_UNUSED
sgen_client_bridge_reset_data (void)
{
	sgen_bridge_reset_data ();
}

static void G_GNUC_UNUSED
sgen_client_bridge_processing_stw_step (void)
{
	sgen_bridge_processing_stw_step ();
}

static void G_GNUC_UNUSED
sgen_client_bridge_wait_for_processing (void)
{
	mono_gc_wait_for_bridge_processing ();
}

static void G_GNUC_UNUSED
sgen_client_bridge_processing_finish (int generation)
{
	sgen_bridge_processing_finish (generation);
}

static gboolean G_GNUC_UNUSED
sgen_client_bridge_is_bridge_object (GCObject *obj)
{
	return sgen_is_bridge_object (obj);
}

static void G_GNUC_UNUSED
sgen_client_bridge_register_finalized_object (GCObject *object)
{
	sgen_bridge_register_finalized_object (object);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_collection_requested (int generation, size_t requested_size, gboolean force)
{
	MONO_GC_REQUESTED (generation, requested_size, force);
}

void
sgen_client_binary_protocol_collection_begin (int minor_gc_count, int generation);

void
sgen_client_binary_protocol_collection_end (int minor_gc_count, int generation, long long num_objects_scanned, long long num_unique_objects_scanned);

static void G_GNUC_UNUSED
sgen_client_binary_protocol_concurrent_start (void)
{
	MONO_GC_CONCURRENT_START_BEGIN (GENERATION_OLD);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_concurrent_update (void)
{
	MONO_GC_CONCURRENT_UPDATE_FINISH_BEGIN (GENERATION_OLD, sgen_get_major_collector ()->get_and_reset_num_major_objects_marked ());
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_concurrent_finish (void)
{
	MONO_GC_CONCURRENT_UPDATE_FINISH_BEGIN (GENERATION_OLD, sgen_get_major_collector ()->get_and_reset_num_major_objects_marked ());
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_sweep_begin (int generation, int full_sweep)
{
	MONO_GC_SWEEP_BEGIN (generation, full_sweep);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_sweep_end (int generation, int full_sweep)
{
	MONO_GC_SWEEP_END (generation, full_sweep);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_world_stopping (int generation, long long timestamp, gpointer thread)
{
	MONO_GC_WORLD_STOP_BEGIN ();
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_world_stopped (int generation, long long timestamp, long long total_major_cards, long long marked_major_cards, long long total_los_cards, long long marked_los_cards)
{
	MONO_GC_WORLD_STOP_END ();
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_world_restarting (int generation, long long timestamp, long long total_major_cards, long long marked_major_cards, long long total_los_cards, long long marked_los_cards)
{
	MONO_GC_WORLD_RESTART_BEGIN (generation);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_world_restarted (int generation, long long timestamp)
{
	MONO_GC_WORLD_RESTART_END (generation);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_block_alloc (gpointer addr, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_block_free (gpointer addr, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_block_set_state (gpointer addr, size_t size, int old, int new_)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_mark_start (int generation)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_mark_end (int generation)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_reclaim_start (int generation)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_reclaim_end (int generation)
{
}

static void
mono_binary_protocol_alloc_generic (gpointer obj, gpointer vtable, size_t size, gboolean pinned)
{
#ifdef ENABLE_DTRACE
	const char *name_space = sgen_client_vtable_get_namespace ((GCVTable)vtable);
	const char *name = sgen_client_vtable_get_name ((GCVTable)vtable);

	if (sgen_ptr_in_nursery (obj)) {
		if (G_UNLIKELY (MONO_GC_NURSERY_OBJ_ALLOC_ENABLED ()))
			MONO_GC_NURSERY_OBJ_ALLOC ((mword)obj, size, name_space, name);
	} else {
		if (size > SGEN_MAX_SMALL_OBJ_SIZE) {
			if (G_UNLIKELY (MONO_GC_MAJOR_OBJ_ALLOC_LARGE_ENABLED ()))
				MONO_GC_MAJOR_OBJ_ALLOC_LARGE ((mword)obj, size, name_space, name);
		} else if (pinned) {
			MONO_GC_MAJOR_OBJ_ALLOC_PINNED ((mword)obj, size, name_space, name);
		}
	}
#endif
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_alloc (gpointer obj, gpointer vtable, size_t size, gpointer provenance)
{
	mono_binary_protocol_alloc_generic (obj, vtable, size, FALSE);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_alloc_pinned (gpointer obj, gpointer vtable, size_t size, gpointer provenance)
{
	mono_binary_protocol_alloc_generic (obj, vtable, size, TRUE);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_alloc_degraded (gpointer obj, gpointer vtable, size_t size, gpointer provenance)
{
	MONO_GC_MAJOR_OBJ_ALLOC_DEGRADED ((mword)obj, size, sgen_client_vtable_get_namespace ((GCVTable)vtable), sgen_client_vtable_get_name ((GCVTable)vtable));
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_card_scan (gpointer start, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_pin_stage (gpointer addr_ptr, gpointer addr)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_cement_stage (gpointer addr)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_pin (gpointer obj, gpointer vtable, size_t size)
{
#ifdef ENABLE_DTRACE
	if (G_UNLIKELY (MONO_GC_OBJ_PINNED_ENABLED ())) {
		int gen = sgen_ptr_in_nursery (obj) ? GENERATION_NURSERY : GENERATION_OLD;
		MONO_GC_OBJ_PINNED ((mword)obj,
				sgen_safe_object_get_size ((GCObject*)obj),
				sgen_client_vtable_get_namespace ((GCVTable)vtable), sgen_client_vtable_get_name ((GCVTable)vtable), gen);
	}
#endif
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_mark (gpointer obj, gpointer vtable, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_scan_begin (gpointer obj, gpointer vtable, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_scan_vtype_begin (gpointer obj, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_scan_process_reference (gpointer obj, gpointer ptr, gpointer value)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_scan_stack (gpointer thread, gpointer stack_start, gpointer stack_end, int skip_reason)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_wbarrier (gpointer ptr, gpointer value, gpointer value_vtable)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_cement (gpointer ptr, gpointer vtable, size_t size)
{
#ifdef ENABLE_DTRACE
	if (G_UNLIKELY (MONO_GC_OBJ_CEMENTED_ENABLED())) {
		MONO_GC_OBJ_CEMENTED ((mword)ptr, sgen_safe_object_get_size ((GCObject*)ptr),
				sgen_client_vtable_get_namespace ((GCVTable)vtable), sgen_client_vtable_get_name ((GCVTable)vtable));
	}
#endif
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_copy (gpointer from, gpointer to, gpointer vtable, size_t size)
{
#ifdef ENABLE_DTRACE
	if (G_UNLIKELY (MONO_GC_OBJ_MOVED_ENABLED ())) {
		int dest_gen = sgen_ptr_in_nursery (to) ? GENERATION_NURSERY : GENERATION_OLD;
		int src_gen = sgen_ptr_in_nursery (from) ? GENERATION_NURSERY : GENERATION_OLD;
		MONO_GC_OBJ_MOVED ((mword)to, (mword)from, dest_gen, src_gen, size, sgen_client_vtable_get_namespace ((GCVTable)vtable), sgen_client_vtable_get_name ((GCVTable)vtable));
	}
#endif
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_global_remset (gpointer ptr, gpointer value, gpointer value_vtable)
{
#ifdef ENABLE_DTRACE
	if (G_UNLIKELY (MONO_GC_GLOBAL_REMSET_ADD_ENABLED ())) {
		MONO_GC_GLOBAL_REMSET_ADD ((mword)ptr, (mword)value, sgen_safe_object_get_size ((GCObject*)value),
				sgen_client_vtable_get_namespace ((GCVTable)value_vtable), sgen_client_vtable_get_name ((GCVTable)value_vtable));
	}
#endif
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_mod_union_remset (gpointer obj, gpointer ptr, gpointer value, gpointer value_vtable)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_ptr_update (gpointer ptr, gpointer old_value, gpointer new_value, gpointer vtable, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_cleanup (gpointer ptr, gpointer vtable, size_t size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_dislink_add (gpointer link, gpointer obj, gboolean track)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_dislink_update (gpointer link, gpointer obj, gboolean track)
{
#ifdef ENABLE_DTRACE
	if (MONO_GC_WEAK_UPDATE_ENABLED ()) {
		GCVTable vt = obj ? SGEN_LOAD_VTABLE (obj) : NULL;
		MONO_GC_WEAK_UPDATE ((mword)link,
				(mword)obj,
				obj ? sgen_safe_object_get_size ((GCObject*)obj) : 0u,
				obj ? sgen_client_vtable_get_namespace (vt) : NULL,
				obj ? sgen_client_vtable_get_name (vt) : NULL,
				track ? 1 : 0);
	}
#endif
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_dislink_remove (gpointer link, gboolean track)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_empty (gpointer start, size_t size)
{
	if (sgen_ptr_in_nursery (start))
		MONO_GC_NURSERY_SWEPT ((mword)start, size);
	else
		MONO_GC_MAJOR_SWEPT ((mword)start, size);
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_thread_suspend (gpointer thread, gpointer stopped_ip)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_thread_restart (gpointer thread)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_thread_register (gpointer thread)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_thread_unregister (gpointer thread)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_missing_remset (gpointer obj, gpointer obj_vtable, int offset, gpointer value, gpointer value_vtable, gboolean value_pinned)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_cement_reset (void)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_domain_unload_begin (gpointer domain)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_domain_unload_end (gpointer domain)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_gray_enqueue (gpointer queue, gpointer cursor, gpointer value)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_gray_dequeue (gpointer queue, gpointer cursor, gpointer value)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_major_card_table_scan_start (long long timestamp, gboolean mod_union)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_major_card_table_scan_end (long long timestamp, gboolean mod_union)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_los_card_table_scan_start (long long timestamp, gboolean mod_union)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_los_card_table_scan_end (long long timestamp, gboolean mod_union)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_finish_gray_stack_start (long long timestamp, int generation)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_finish_gray_stack_end (long long timestamp, int generation)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_worker_finish (long long timestamp, gboolean forced)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_evacuating_blocks (size_t block_size)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_concurrent_sweep_end (long long timestamp)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_header (long long check, int version, int ptr_size, gboolean little_endian)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_pin_stats (int objects_pinned_in_nursery, size_t bytes_pinned_in_nursery, int objects_pinned_in_major, size_t bytes_pinned_in_major)
{
}

static void G_GNUC_UNUSED
sgen_client_root_registered (char *start, size_t size, MonoGCRootSource source, void *key, const char *msg)
{
	MONO_PROFILER_RAISE (gc_root_register, ((const mono_byte *) start, size, source, key, msg));
}

static void G_GNUC_UNUSED
sgen_client_root_deregistered (char *start)
{
	MONO_PROFILER_RAISE (gc_root_unregister, ((const mono_byte *) start));
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_worker_finish_stats (int worker_index, int generation, gboolean forced, long long major_scan, long long los_scan, long long work_time)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_collection_end_stats (long long major_scan, long long los_scan, long long finish_stack)
{
}

static void G_GNUC_UNUSED
sgen_client_binary_protocol_ephemeron_ref (gpointer list, gpointer key, gpointer val)
{
}

#define TLAB_ACCESS_INIT	SgenThreadInfo *__thread_info__ = mono_tls_get_sgen_thread_info ()
#define IN_CRITICAL_REGION (__thread_info__->client_info.in_critical_region)

/* Enter must be visible before anything is done in the critical region. */
#define ENTER_CRITICAL_REGION do { mono_atomic_store_acquire (&IN_CRITICAL_REGION, 1); } while (0)

/* Exit must make sure all critical regions stores are visible before it signal the end of the region. 
 * We don't need to emit a full barrier since we
 */
#define EXIT_CRITICAL_REGION  do { mono_atomic_store_release (&IN_CRITICAL_REGION, 0); } while (0)

#ifndef DISABLE_CRITICAL_REGION
/*
 * We can only use a critical region in the managed allocator if the JIT supports OP_ATOMIC_STORE_I4.
 *
 * TODO: Query the JIT instead of this ifdef hack.
 */
#if defined (TARGET_X86) || defined (TARGET_AMD64) || (defined (TARGET_ARM) && defined (HAVE_ARMV7)) || defined (TARGET_ARM64) || defined (TARGET_RISCV)
#define MANAGED_ALLOCATOR_CAN_USE_CRITICAL_REGION
#endif
#endif

#define SGEN_TV_DECLARE(name) gint64 name
#define SGEN_TV_GETTIME(tv) tv = mono_100ns_ticks ()
#define SGEN_TV_ELAPSED(start,end) ((gint64)(end-start))

guint64 mono_time_since_last_stw (void);

gboolean sgen_has_critical_method (void);
gboolean sgen_is_critical_method (MonoMethod *method);

void sgen_set_use_managed_allocator (gboolean flag);
gboolean sgen_is_managed_allocator (MonoMethod *method);
gboolean sgen_has_managed_allocator (void);

void sgen_scan_for_registered_roots_in_domain (MonoDomain *domain, int root_type);
void sgen_null_links_for_domain (MonoDomain *domain);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/sgen-dynarray.h`:

```h
/**
 * \file
 * Copyright 2016 Xamarin, Inc.
 *
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

 // Growable array implementation used by sgen-new-bridge and sgen-tarjan-bridge.

typedef struct {
	int size;
	int capacity;		/* if negative, data points to another DynArray's data */
	char *data;
} DynArray;

/*Specializations*/

// IntArray supports an optimization (in sgen-new-bridge.c): If capacity is less than 0 it is a "copy" and does not own its buffer.
typedef struct {
	DynArray array;
} DynIntArray;

// PtrArray supports an optimization: If size is equal to 1 it is a "singleton" and data points to the single held item, not to a buffer.
typedef struct {
	DynArray array;
} DynPtrArray;

typedef struct {
	DynArray array;
} DynSCCArray;

static void
dyn_array_init (DynArray *da)
{
	da->size = 0;
	da->capacity = 0;
	da->data = NULL;
}

static void
dyn_array_uninit (DynArray *da, int elem_size)
{
	if (da->capacity < 0) {
		dyn_array_init (da);
		return;
	}

	if (da->capacity == 0)
		return;

	sgen_free_internal_dynamic (da->data, elem_size * da->capacity, INTERNAL_MEM_BRIDGE_DATA);
	da->data = NULL;
}

static void
dyn_array_empty (DynArray *da)
{
	if (da->capacity < 0)
		dyn_array_init (da);
	else
		da->size = 0;
}

static char *
dyn_array_ensure_capacity_internal (DynArray *da, int capacity, int elem_size)
{
	if (da->capacity <= 0)
		da->capacity = 2;
	while (capacity > da->capacity)
		da->capacity *= 2;

	return (char *)sgen_alloc_internal_dynamic (elem_size * da->capacity, INTERNAL_MEM_BRIDGE_DATA, TRUE);
}

static void
dyn_array_ensure_capacity (DynArray *da, int capacity, int elem_size)
{
	int old_capacity = da->capacity;
	char *new_data;

	g_assert (capacity > 0);

	if (capacity <= old_capacity)
		return;

	new_data = dyn_array_ensure_capacity_internal (da, capacity, elem_size);
	memcpy (new_data, da->data, elem_size * da->size);
	if (old_capacity > 0)
		sgen_free_internal_dynamic (da->data, elem_size * old_capacity, INTERNAL_MEM_BRIDGE_DATA);
	da->data = new_data;
}

static gboolean
dyn_array_is_copy (DynArray *da)
{
	return da->capacity < 0;
}

static void
dyn_array_ensure_independent (DynArray *da, int elem_size)
{
	if (!dyn_array_is_copy (da))
		return;
	dyn_array_ensure_capacity (da, da->size, elem_size);
	g_assert (da->capacity > 0);
}

static void*
dyn_array_add (DynArray *da, int elem_size)
{
	void *p;

	dyn_array_ensure_capacity (da, da->size + 1, elem_size);

	p = da->data + da->size * elem_size;
	++da->size;
	return p;
}

static void
dyn_array_copy (DynArray *dst, DynArray *src, int elem_size)
{
	dyn_array_uninit (dst, elem_size);

	if (src->size == 0)
		return;

	dst->size = src->size;
	dst->capacity = -1;
	dst->data = src->data;
}

/* int */
static inline void
dyn_array_int_init (DynIntArray *da)
{
	dyn_array_init (&da->array);
}

static inline void
dyn_array_int_uninit (DynIntArray *da)
{
	dyn_array_uninit (&da->array, sizeof (int));
}

static inline int
dyn_array_int_size (DynIntArray *da)
{
	return da->array.size;
}

#ifdef NEW_XREFS
static void
dyn_array_int_empty (DynIntArray *da)
{
	dyn_array_empty (&da->array);
}
#endif

static inline void
dyn_array_int_add (DynIntArray *da, int x)
{
	int *p = (int *)dyn_array_add (&da->array, sizeof (int));
	*p = x;
}

static inline int
dyn_array_int_get (DynIntArray *da, int x)
{
	return ((int*)da->array.data)[x];
}

#ifdef NEW_XREFS
static void
dyn_array_int_set (DynIntArray *da, int idx, int val)
{
	((int*)da->array.data)[idx] = val;
}
#endif

static inline void
dyn_array_int_ensure_independent (DynIntArray *da)
{
	dyn_array_ensure_independent (&da->array, sizeof (int));
}

static inline void
dyn_array_int_copy (DynIntArray *dst, DynIntArray *src)
{
	dyn_array_copy (&dst->array, &src->array, sizeof (int));
}

static inline gboolean
dyn_array_int_is_copy (DynIntArray *da)
{
	return dyn_array_is_copy (&da->array);
}

/* ptr */

static inline void
dyn_array_ptr_init (DynPtrArray *da)
{
	dyn_array_init (&da->array);
}

static void
dyn_array_ptr_uninit (DynPtrArray *da)
{
#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (da->array.capacity == 1)
		dyn_array_ptr_init (da);
	else
#endif
		dyn_array_uninit (&da->array, sizeof (void*));
}

static int
dyn_array_ptr_size (DynPtrArray *da)
{
	return da->array.size;
}

static void
dyn_array_ptr_empty (DynPtrArray *da)
{
#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (da->array.capacity == 1)
		dyn_array_ptr_init (da);
	else
#endif
		dyn_array_empty (&da->array);
}

static void*
dyn_array_ptr_get (DynPtrArray *da, int x)
{
#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (da->array.capacity == 1) {
		g_assert (x == 0);
		return da->array.data;
	}
#endif
	return ((void**)da->array.data)[x];
}

static inline void
dyn_array_ptr_set (DynPtrArray *da, int x, void *ptr)
{
#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (da->array.capacity == 1) {
		g_assert (x == 0);
		da->array.data = (char*)ptr;
	} else
#endif
	{
		((void**)da->array.data)[x] = ptr;
	}
}

static void
dyn_array_ptr_add (DynPtrArray *da, void *ptr)
{
	void **p;

#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (da->array.capacity == 0) {
		da->array.capacity = 1;
		da->array.size = 1;
		p = (void**)&da->array.data;
	} else if (da->array.capacity == 1) {
		void *ptr0 = da->array.data;
		void **p0;
		dyn_array_init (&da->array);
		p0 = (void **)dyn_array_add (&da->array, sizeof (void*));
		*p0 = ptr0;
		p = (void **)dyn_array_add (&da->array, sizeof (void*));
	} else
#endif
	{
		p = (void **)dyn_array_add (&da->array, sizeof (void*));
	}
	*p = ptr;
}

#define dyn_array_ptr_push dyn_array_ptr_add

static void*
dyn_array_ptr_pop (DynPtrArray *da)
{
	int size = da->array.size;
	void *p;
	g_assert (size > 0);
#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (da->array.capacity == 1) {
		p = dyn_array_ptr_get (da, 0);
		dyn_array_init (&da->array);
	} else
#endif
	{
		g_assert (da->array.capacity > 1);
		dyn_array_ensure_independent (&da->array, sizeof (void*));
		p = dyn_array_ptr_get (da, size - 1);
		--da->array.size;
	}
	return p;
}

static void
dyn_array_ptr_ensure_capacity (DynPtrArray *da, int capacity)
{
#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
	if (capacity == 1 && da->array.capacity < 1) {
		da->array.capacity = 1;
	} else if (da->array.capacity == 1) // TODO size==1
	{
		if (capacity > 1)
		{
			void *ptr = dyn_array_ptr_get (da, 0);
			da->array.data = dyn_array_ensure_capacity_internal(&da->array, capacity, sizeof (void*));
			dyn_array_ptr_set (da, 0, ptr);
		}
	}
#endif
	{
		dyn_array_ensure_capacity (&da->array, capacity, sizeof (void*));
	}
}

static inline void
dyn_array_ptr_set_all (DynPtrArray *dst, DynPtrArray *src)
{
	const int copysize = src->array.size;
	if (copysize > 0) {
		dyn_array_ptr_ensure_capacity (dst, copysize);

#ifdef OPTIMIZATION_SINGLETON_DYN_ARRAY
		if (copysize == 1) {
			dyn_array_ptr_set (dst, 0, dyn_array_ptr_get (src, 0));
		} else
#endif
		{
			memcpy (dst->array.data, src->array.data, copysize * sizeof (void*));
		}
	}
	dst->array.size = src->array.size;
}

```

`Hazel/vendor/mono/include/mono/metadata/sgen-mono-ilgen.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_SGEN_MONO_ILGEN_H__
#define __MONO_SGEN_MONO_ILGEN_H__

#include "config.h"

MONO_API void
mono_sgen_mono_ilgen_init (void);
#endif

```

`Hazel/vendor/mono/include/mono/metadata/sgen-mono.h`:

```h
/**
 * \file
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_SGEN_MONO_H__
#define __MONO_SGEN_MONO_H__

#define MONO_SGEN_MONO_CALLBACKS_VERSION 1

typedef struct {
	int version;
	void (*emit_nursery_check) (MonoMethodBuilder *mb, gboolean is_concurrent);
	void (*emit_managed_allocator) (MonoMethodBuilder *mb, gboolean slowpath, gboolean profiler, int atype);
} MonoSgenMonoCallbacks;

void
mono_install_sgen_mono_callbacks (MonoSgenMonoCallbacks *cb);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/sgen-toggleref.h`:

```h
/**
 * \file
 * toggleref support for sgen
 *
 * Copyright 2011 Xamarin, Inc.
 *
 * Author:
 *  Rodrigo Kumpera (kumpera@gmail.com)
 * 
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_SGEN_TOGGLEREF_H_
#define _MONO_SGEN_TOGGLEREF_H_

#include <mono/utils/mono-publib.h>

/* GC toggle ref support */

typedef enum {
	MONO_TOGGLE_REF_DROP,
	MONO_TOGGLE_REF_STRONG,
	MONO_TOGGLE_REF_WEAK
} MonoToggleRefStatus;

MONO_API void mono_gc_toggleref_register_callback (MonoToggleRefStatus (*proccess_toggleref) (MonoObject *obj));
MONO_API MONO_RT_EXTERNAL_ONLY void mono_gc_toggleref_add (MonoObject *object, mono_bool strong_ref);

#endif

```

`Hazel/vendor/mono/include/mono/metadata/sre-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_SRE_INTERNALS_H__
#define __MONO_METADATA_SRE_INTERNALS_H__

#include <mono/metadata/object-internals.h>

/* Keep in sync with System.Reflection.Emit.AssemblyBuilderAccess */
enum MonoAssemblyBuilderAccess {
	MonoAssemblyBuilderAccess_Run = 1,                /* 0b0001 */
	MonoAssemblyBuilderAccess_Save = 2,               /* 0b0010 */
	MonoAssemblyBuilderAccess_RunAndSave = 3,         /* Run | Save */
	MonoAssemblyBuilderAccess_ReflectionOnly = 6,     /* Refonly | Save */
	MonoAssemblyBuilderAccess_RunAndCollect = 9,      /* Collect | Run */
};

typedef struct _ArrayMethod ArrayMethod;

typedef struct {
	guint32 owner;
	MonoReflectionGenericParam *gparam;
} GenericParamTableEntry;

typedef struct {
	MonoReflectionILGen *ilgen;
	MonoReflectionType *rtype;
	MonoArray *parameters;
	MonoArray *generic_params;
	MonoGenericContainer *generic_container;
	MonoArray *pinfo;
	MonoArray *opt_types;
	guint32 attrs;
	guint32 iattrs;
	guint32 call_conv;
	guint32 *table_idx; /* note: it's a pointer */
	MonoArray *code;
	MonoObject *type;
	MonoString *name;
	MonoBoolean init_locals;
	MonoBoolean skip_visibility;
	MonoArray *return_modreq;
	MonoArray *return_modopt;
	MonoArray *param_modreq;
	MonoArray *param_modopt;
	MonoArray *permissions;
	MonoMethod *mhandle;
	guint32 nrefs;
	gpointer *refs;
	/* for PInvoke */
	int charset, extra_flags, native_cc;
	MonoString *dll, *dllentry;
} ReflectionMethodBuilder; /* FIXME raw pointers to managed objects */

void
mono_reflection_emit_init (void);

void
mono_reflection_dynimage_basic_init (MonoReflectionAssemblyBuilder *assemblyb, MonoError *error);

gpointer
mono_image_g_malloc0 (MonoImage *image, guint size);

#define mono_image_g_malloc0(image, size) (g_cast (mono_image_g_malloc0 ((image), (size))))

gboolean
mono_is_sre_type_builder (MonoClass *klass);

gboolean
mono_is_sre_generic_instance (MonoClass *klass);

gboolean
mono_is_sre_method_on_tb_inst (MonoClass *klass);

gboolean
mono_is_sre_ctor_builder (MonoClass *klass);

gboolean
mono_is_sre_ctor_on_tb_inst (MonoClass *klass);

gboolean
mono_is_sr_mono_cmethod (MonoClass *klass);

gboolean
mono_is_sr_mono_property (MonoClass *klass);

MonoType*
mono_reflection_type_get_handle (MonoReflectionType *ref, MonoError *error);

gpointer
mono_reflection_resolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context, MonoError *error);

gpointer
mono_reflection_resolve_object_handle (MonoImage *image, MonoObjectHandle obj, MonoClass **handle_class, MonoGenericContext *context, MonoError *error);

MonoType* mono_type_array_get_and_resolve (MonoArrayHandle array, int idx, MonoError* error);

void
mono_sre_array_method_free (ArrayMethod *am);

void
mono_sre_generic_param_table_entry_free (GenericParamTableEntry *entry);

gboolean
mono_reflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb,
						   MonoError *error);
gboolean
mono_reflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb,
						 MonoError *error);
							    
guint32
mono_reflection_resolution_scope_from_image (MonoDynamicImage *assembly, MonoImage *image);

guint32 mono_reflection_method_count_clauses (MonoReflectionILGen *ilgen);


/* sre-encode */

guint32
mono_dynimage_encode_field_signature (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb, MonoError *error);

guint32
mono_dynimage_encode_constant (MonoDynamicImage *assembly, MonoObject *val, MonoTypeEnum *ret_type);

guint32
mono_dynimage_encode_locals (MonoDynamicImage *assembly, MonoReflectionILGen *ilgen, MonoError *error);

guint32
mono_dynimage_encode_fieldref_signature (MonoDynamicImage *assembly, MonoImage *field_image, MonoType *type);

guint32
mono_dynimage_encode_method_signature (MonoDynamicImage *assembly, MonoMethodSignature *sig);

guint32
mono_dynimage_encode_method_builder_signature (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb,
					       MonoError *error);

guint32
mono_dynimage_encode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context);

guint32
mono_dynimage_encode_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec);

guint32
mono_dynimage_encode_reflection_sighelper (MonoDynamicImage *assembly, MonoReflectionSigHelperHandle helper,
					   MonoError *error);

/* sre-encode, without DISABLE_REFLECTION_EMIT_SAVE (o.w. g_assert_not_reached ()) */

guint32
mono_dynimage_save_encode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo, MonoError *error);

guint32
mono_dynimage_save_encode_property_signature (MonoDynamicImage *assembly, MonoReflectionPropertyBuilder *fb, MonoError *error);

guint32
mono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec);

#endif  /* __MONO_METADATA_SRE_INTERNALS_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/string-icalls.h`:

```h
/**
 * \file
 */

#ifndef _MONO_CLI_STRING_ICALLS_H_
#define _MONO_CLI_STRING_ICALLS_H_

/*
 * string-icalls.h: String internal calls for the corlib
 *
 * Author:
 *   Patrik Torstensson (patrik.torstensson@labs2.com)
 *
 * (C) 2001 Ximian, Inc.
 */

#include <glib.h>
#include <mono/metadata/class.h>
#include <mono/metadata/object.h>
#include "mono/utils/mono-compiler.h"
#include <mono/metadata/icalls.h>

ICALL_EXPORT
void
ves_icall_System_String_ctor_RedirectToCreateString (void);

ICALL_EXPORT
int
ves_icall_System_String_GetLOSLimit (void);

#endif /* _MONO_CLI_STRING_ICALLS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/tabledefs.h`:

```h
/**
 * \file
 * This file contains the various definitions for constants
 * found on the metadata tables
 *
 * Author:
 *   Miguel de Icaza (miguel@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 *
 * From the ECMA documentation
 */
 
#ifndef _MONO_METADATA_TABLEDEFS_H_
#define _MONO_METADATA_TABLEDEFS_H_

/*
 * 22.1.1  Values for AssemblyHashAlgorithm 
 */

enum {
	ASSEMBLY_HASH_NONE,
	ASSEMBLY_HASH_MD5  = 0x8003,
	ASSEMBLY_HASH_SHA1 = 0x8004
};

/*
 * 22.1.4 Flags for Event.EventAttributes
 */

enum {
	EVENT_SPECIALNAME   = 0x0200,
	EVENT_RTSPECIALNAME = 0x0400
};

/*
 * 22.1.6 Flags for FileAttributes
 */

enum {
	FILE_CONTAINS_METADATA      = 0,
	FILE_CONTAINS_NO_METADATA   = 1
};

/* keep in synch with System.Security.Permissions.SecurityAction enum 
   (except for the special non-CAS cases) */
enum {
	SECURITY_ACTION_DEMAND        = 2,
	SECURITY_ACTION_ASSERT        = 3,
	SECURITY_ACTION_DENY          = 4,
	SECURITY_ACTION_PERMITONLY    = 5,
	SECURITY_ACTION_LINKDEMAND    = 6,
	SECURITY_ACTION_INHERITDEMAND = 7,
	SECURITY_ACTION_REQMIN        = 8,
	SECURITY_ACTION_REQOPT        = 9,
	SECURITY_ACTION_REQREFUSE     = 10,
	/* Special cases (non CAS permissions) */
	SECURITY_ACTION_NONCASDEMAND        = 13,
	SECURITY_ACTION_NONCASLINKDEMAND    = 14,
	SECURITY_ACTION_NONCASINHERITANCE   = 15,
	/* Fx 2.0 actions (for both CAS and non-CAS permissions) */
	SECURITY_ACTION_LINKDEMANDCHOICE    = 16,
	SECURITY_ACTION_INHERITDEMANDCHOICE = 17,
	SECURITY_ACTION_DEMANDCHOICE        = 18
};

/*
 *
 * 22.1.8 Flags for ManifestResource
 */
#define MANIFEST_RESOURCE_VISIBILITY_MASK    0x00000007
#define MANIFEST_RESOURCE_PUBLIC             0x00000001
#define MANIFEST_RESOURCE_PRIVATE            0x00000002

/*
 * Field Attributes (21.1.5).
 */

#define FIELD_ATTRIBUTE_FIELD_ACCESS_MASK     0x0007
#define FIELD_ATTRIBUTE_COMPILER_CONTROLLED   0x0000
#define FIELD_ATTRIBUTE_PRIVATE               0x0001
#define FIELD_ATTRIBUTE_FAM_AND_ASSEM         0x0002
#define FIELD_ATTRIBUTE_ASSEMBLY              0x0003
#define FIELD_ATTRIBUTE_FAMILY                0x0004
#define FIELD_ATTRIBUTE_FAM_OR_ASSEM          0x0005
#define FIELD_ATTRIBUTE_PUBLIC                0x0006

#define FIELD_ATTRIBUTE_STATIC                0x0010
#define FIELD_ATTRIBUTE_INIT_ONLY             0x0020
#define FIELD_ATTRIBUTE_LITERAL               0x0040
#define FIELD_ATTRIBUTE_NOT_SERIALIZED        0x0080
#define FIELD_ATTRIBUTE_SPECIAL_NAME          0x0200
#define FIELD_ATTRIBUTE_PINVOKE_IMPL          0x2000

/* For runtime use only */
#define FIELD_ATTRIBUTE_RESERVED_MASK         0x9500
#define FIELD_ATTRIBUTE_RT_SPECIAL_NAME       0x0400
#define FIELD_ATTRIBUTE_HAS_FIELD_MARSHAL     0x1000
#define FIELD_ATTRIBUTE_HAS_DEFAULT           0x8000
#define FIELD_ATTRIBUTE_HAS_FIELD_RVA         0x0100

/*
 * Type Attributes (21.1.13).
 */
#define TYPE_ATTRIBUTE_VISIBILITY_MASK       0x00000007
#define TYPE_ATTRIBUTE_NOT_PUBLIC            0x00000000
#define TYPE_ATTRIBUTE_PUBLIC                0x00000001
#define TYPE_ATTRIBUTE_NESTED_PUBLIC         0x00000002
#define TYPE_ATTRIBUTE_NESTED_PRIVATE        0x00000003
#define TYPE_ATTRIBUTE_NESTED_FAMILY         0x00000004
#define TYPE_ATTRIBUTE_NESTED_ASSEMBLY       0x00000005
#define TYPE_ATTRIBUTE_NESTED_FAM_AND_ASSEM  0x00000006
#define TYPE_ATTRIBUTE_NESTED_FAM_OR_ASSEM   0x00000007

#define TYPE_ATTRIBUTE_LAYOUT_MASK           0x00000018
#define TYPE_ATTRIBUTE_AUTO_LAYOUT           0x00000000
#define TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT     0x00000008
#define TYPE_ATTRIBUTE_EXPLICIT_LAYOUT       0x00000010

#define TYPE_ATTRIBUTE_CLASS_SEMANTIC_MASK   0x00000020
#define TYPE_ATTRIBUTE_CLASS                 0x00000000
#define TYPE_ATTRIBUTE_INTERFACE             0x00000020

#define TYPE_ATTRIBUTE_ABSTRACT              0x00000080
#define TYPE_ATTRIBUTE_SEALED                0x00000100
#define TYPE_ATTRIBUTE_SPECIAL_NAME          0x00000400

#define TYPE_ATTRIBUTE_IMPORT                0x00001000
#define TYPE_ATTRIBUTE_SERIALIZABLE          0x00002000
#define TYPE_ATTRIBUTE_WINDOWS_RUNTIME       0x00004000


#define TYPE_ATTRIBUTE_STRING_FORMAT_MASK    0x00030000
#define TYPE_ATTRIBUTE_ANSI_CLASS            0x00000000
#define TYPE_ATTRIBUTE_UNICODE_CLASS         0x00010000
#define TYPE_ATTRIBUTE_AUTO_CLASS            0x00020000

#define TYPE_ATTRIBUTE_BEFORE_FIELD_INIT     0x00100000
#define TYPE_ATTRIBUTE_FORWARDER             0x00200000

#define TYPE_ATTRIBUTE_RESERVED_MASK         0x00040800
#define TYPE_ATTRIBUTE_RT_SPECIAL_NAME       0x00000800
#define TYPE_ATTRIBUTE_HAS_SECURITY          0x00040000

/*
 * Method Attributes (22.1.9)
 */

#define METHOD_IMPL_ATTRIBUTE_CODE_TYPE_MASK       0x0003
#define METHOD_IMPL_ATTRIBUTE_IL                   0x0000
#define METHOD_IMPL_ATTRIBUTE_NATIVE               0x0001
#define METHOD_IMPL_ATTRIBUTE_OPTIL                0x0002
#define METHOD_IMPL_ATTRIBUTE_RUNTIME              0x0003

#define METHOD_IMPL_ATTRIBUTE_MANAGED_MASK         0x0004
#define METHOD_IMPL_ATTRIBUTE_UNMANAGED            0x0004
#define METHOD_IMPL_ATTRIBUTE_MANAGED              0x0000

#define METHOD_IMPL_ATTRIBUTE_FORWARD_REF          0x0010
#define METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG         0x0080
#define METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL        0x1000
#define METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED         0x0020
#define METHOD_IMPL_ATTRIBUTE_NOINLINING           0x0008
#define METHOD_IMPL_ATTRIBUTE_NOOPTIMIZATION       0x0040
#define METHOD_IMPL_ATTRIBUTE_MAX_METHOD_IMPL_VAL  0xffff
#define METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING  0x0100

#define METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK        0x0007
#define METHOD_ATTRIBUTE_COMPILER_CONTROLLED       0x0000
#define METHOD_ATTRIBUTE_PRIVATE                   0x0001
#define METHOD_ATTRIBUTE_FAM_AND_ASSEM             0x0002
#define METHOD_ATTRIBUTE_ASSEM                     0x0003
#define METHOD_ATTRIBUTE_FAMILY                    0x0004
#define METHOD_ATTRIBUTE_FAM_OR_ASSEM              0x0005
#define METHOD_ATTRIBUTE_PUBLIC                    0x0006

#define METHOD_ATTRIBUTE_STATIC                    0x0010
#define METHOD_ATTRIBUTE_FINAL                     0x0020
#define METHOD_ATTRIBUTE_VIRTUAL                   0x0040
#define METHOD_ATTRIBUTE_HIDE_BY_SIG               0x0080

#define METHOD_ATTRIBUTE_VTABLE_LAYOUT_MASK        0x0100
#define METHOD_ATTRIBUTE_REUSE_SLOT                0x0000
#define METHOD_ATTRIBUTE_NEW_SLOT                  0x0100

#define METHOD_ATTRIBUTE_STRICT                    0x0200
#define METHOD_ATTRIBUTE_ABSTRACT                  0x0400
#define METHOD_ATTRIBUTE_SPECIAL_NAME              0x0800

#define METHOD_ATTRIBUTE_PINVOKE_IMPL              0x2000
#define METHOD_ATTRIBUTE_UNMANAGED_EXPORT          0x0008

#define METHOD_ATTRIBUTE_REQSECOBJ                 0x8000

/*
 * For runtime use only
 */
#define METHOD_ATTRIBUTE_RESERVED_MASK             0xd000
#define METHOD_ATTRIBUTE_RT_SPECIAL_NAME           0x1000
#define METHOD_ATTRIBUTE_HAS_SECURITY              0x4000
#define METHOD_ATTRIBUTE_REQUIRE_SEC_OBJECT        0x8000


/*
 * Method Semantics ([MethodSemanticAttributes]) 22.1.10
 */

#define METHOD_SEMANTIC_SETTER    0x0001
#define METHOD_SEMANTIC_GETTER    0x0002
#define METHOD_SEMANTIC_OTHER     0x0004
#define METHOD_SEMANTIC_ADD_ON    0x0008
#define METHOD_SEMANTIC_REMOVE_ON 0x0010
#define METHOD_SEMANTIC_FIRE      0x0020

/*
 * Flags for Params (22.1.12)
 */
#define PARAM_ATTRIBUTE_IN                 0x0001
#define PARAM_ATTRIBUTE_OUT                0x0002
#define PARAM_ATTRIBUTE_OPTIONAL           0x0010
#define PARAM_ATTRIBUTE_RESERVED_MASK      0xf000
#define PARAM_ATTRIBUTE_HAS_DEFAULT        0x1000
#define PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL  0x2000
#define PARAM_ATTRIBUTE_UNUSED             0xcfe0

/*
 * 22.1.12 PropertyAttributes
 */
#define PROPERTY_ATTRIBUTE_SPECIAL_NAME    0x0200
#define PROPERTY_ATTRIBUTE_RESERVED_MASK   0xf400
#define PROPERTY_ATTRIBUTE_RT_SPECIAL_NAME 0x0400
#define PROPERTY_ATTRIBUTE_HAS_DEFAULT     0x1000
#define PROPERTY_ATTRIBUTE_UNUSED          0xe9ff

/*
 * 22.1.7 Flags for ImplMap [PInvokeAttributes]
 */
#define PINVOKE_ATTRIBUTE_NO_MANGLE           0x0001
#define PINVOKE_ATTRIBUTE_CHAR_SET_MASK       0x0006
#define PINVOKE_ATTRIBUTE_CHAR_SET_NOT_SPEC   0x0000
#define PINVOKE_ATTRIBUTE_CHAR_SET_ANSI       0x0002
#define PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE    0x0004
#define PINVOKE_ATTRIBUTE_CHAR_SET_AUTO       0x0006
#define PINVOKE_ATTRIBUTE_BEST_FIT_ENABLED    0x0010
#define PINVOKE_ATTRIBUTE_BEST_FIT_DISABLED   0x0020
#define PINVOKE_ATTRIBUTE_BEST_FIT_MASK       0x0030
#define PINVOKE_ATTRIBUTE_SUPPORTS_LAST_ERROR 0x0040
#define PINVOKE_ATTRIBUTE_CALL_CONV_MASK      0x0700
#define PINVOKE_ATTRIBUTE_CALL_CONV_WINAPI    0x0100
#define PINVOKE_ATTRIBUTE_CALL_CONV_CDECL     0x0200
#define PINVOKE_ATTRIBUTE_CALL_CONV_STDCALL   0x0300
#define PINVOKE_ATTRIBUTE_CALL_CONV_THISCALL  0x0400
#define PINVOKE_ATTRIBUTE_CALL_CONV_FASTCALL  0x0500
#define PINVOKE_ATTRIBUTE_THROW_ON_UNMAPPABLE_ENABLED    0x1000
#define PINVOKE_ATTRIBUTE_THROW_ON_UNMAPPABLE_DISABLED   0x2000
#define PINVOKE_ATTRIBUTE_THROW_ON_UNMAPPABLE_MASK       0x3000
#define PINVOKE_ATTRIBUTE_BEST_FIT_MASK       0x0030
#define PINVOKE_ATTRIBUTE_CALL_CONV_GENERIC   0x0010
#define PINVOKE_ATTRIBUTE_CALL_CONV_GENERICINST 0x000a

/**
 * 21.5 AssemblyRefs
 */
#define ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG      0x00000001
#define ASSEMBLYREF_RETARGETABLE_FLAG         0x00000100
#define ASSEMBLYREF_ENABLEJITCOMPILE_TRACKING_FLAG 0x00008000
#define ASSEMBLYREF_DISABLEJITCOMPILE_OPTIMIZER_FLAG 0x00004000
#endif

```

`Hazel/vendor/mono/include/mono/metadata/threadpool-io.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_THREADPOOL_IO_H_
#define _MONO_METADATA_THREADPOOL_IO_H_

#include <config.h>
#include <glib.h>

#ifndef ENABLE_NETCORE

#include <mono/metadata/object-internals.h>
#include <mono/metadata/icalls.h>

typedef struct _MonoIOSelectorJob MonoIOSelectorJob;

TYPED_HANDLE_DECL (MonoIOSelectorJob);

ICALL_EXPORT
void
ves_icall_System_IOSelector_Remove (gpointer handle);

void
mono_threadpool_io_remove_socket (int fd);
void
mono_threadpool_io_remove_domain_jobs (MonoDomain *domain);
void
mono_threadpool_io_cleanup (void);

#endif /* ENABLE_NETCORE */

#endif /* _MONO_METADATA_THREADPOOL_IO_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/threadpool-worker.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_THREADPOOL_WORKER_H
#define _MONO_METADATA_THREADPOOL_WORKER_H

#include <config.h>
#include <glib.h>

#ifndef ENABLE_NETCORE

typedef void (*MonoThreadPoolWorkerCallback)(void);

void
mono_threadpool_worker_init (MonoThreadPoolWorkerCallback callback);

void
mono_threadpool_worker_cleanup (void);

void
mono_threadpool_worker_request (void);

gboolean
mono_threadpool_worker_notify_completed (void);

gint32
mono_threadpool_worker_get_min (void);
gboolean
mono_threadpool_worker_set_min (gint32 value);

gint32
mono_threadpool_worker_get_max (void);
gboolean
mono_threadpool_worker_set_max (gint32 value);

void
mono_threadpool_worker_set_suspended (gboolean suspended);

#endif /* ENABLE_NETCORE */

#endif /* _MONO_METADATA_THREADPOOL_WORKER_H */

```

`Hazel/vendor/mono/include/mono/metadata/threadpool.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_THREADPOOL_H_
#define _MONO_METADATA_THREADPOOL_H_

#include <config.h>
#include <glib.h>

#include <mono/metadata/exception.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/icalls.h>

void
mono_threadpool_cleanup (void);

MonoAsyncResult *
mono_threadpool_begin_invoke (MonoDomain *domain, MonoObject *target, MonoMethod *method, gpointer *params, MonoError *error);
MonoObject *
mono_threadpool_end_invoke (MonoAsyncResult *ares, MonoArray **out_args, MonoObject **exc, MonoError *error);

gboolean
mono_threadpool_remove_domain_jobs (MonoDomain *domain, int timeout);

void
mono_threadpool_suspend (void);
void
mono_threadpool_resume (void);

/* Internals */

gboolean
mono_threadpool_enqueue_work_item (MonoDomain *domain, MonoObject *work_item, MonoError *error);

#endif // _MONO_METADATA_THREADPOOL_H_

```

`Hazel/vendor/mono/include/mono/metadata/threads-types.h`:

```h
/**
 * \file
 * Generic thread typedef support (includes system-specific files)
 *
 * Author:
 *	Dick Porter (dick@ximian.com)
 *
 * (C) 2001 Ximian, Inc
 * (C) Copyright 2002-2006 Novell, Inc
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_METADATA_THREADS_TYPES_H_
#define _MONO_METADATA_THREADS_TYPES_H_

#include <glib.h>

#include <mono/utils/mono-forward-internal.h>
#include <mono/metadata/object.h>
#include "mono/metadata/handle.h"
#include "mono/utils/mono-compiler.h"
#include "mono/utils/mono-membar.h"
#include "mono/utils/mono-threads.h"
#include "mono/metadata/class-internals.h"
#include <mono/metadata/icalls.h>

/* This is a copy of System.Threading.ThreadState */
typedef enum {
	ThreadState_Running = 0x00000000,
	ThreadState_SuspendRequested = 0x00000002,
	ThreadState_Background = 0x00000004,
	ThreadState_Unstarted = 0x00000008,
	ThreadState_Stopped = 0x00000010,
	ThreadState_WaitSleepJoin = 0x00000020,
	ThreadState_Suspended = 0x00000040,
	ThreadState_AbortRequested = 0x00000080,
	ThreadState_Aborted = 0x00000100
} MonoThreadState;

G_ENUM_FUNCTIONS (MonoThreadState)

/* This is a copy of System.Threading.ApartmentState */
typedef enum {
	ThreadApartmentState_STA = 0x00000000,
	ThreadApartmentState_MTA = 0x00000001,
	ThreadApartmentState_Unknown = 0x00000002
} MonoThreadApartmentState;

typedef enum {
// These values match System.Threading.ThreadPriority.
// These values match System.Diagnostics.ThreadPriorityLevel and Windows, but are offset by 2.
	MONO_THREAD_PRIORITY_LOWEST       = 0,
	MONO_THREAD_PRIORITY_BELOW_NORMAL = 1,
	MONO_THREAD_PRIORITY_NORMAL       = 2,
	MONO_THREAD_PRIORITY_ABOVE_NORMAL = 3,
	MONO_THREAD_PRIORITY_HIGHEST      = 4,
} MonoThreadPriority;

#define SPECIAL_STATIC_NONE 0
#define SPECIAL_STATIC_THREAD 1
#define SPECIAL_STATIC_CONTEXT 2

/* It's safe to access System.Threading.InternalThread from native code via a
 * raw pointer because all instances should be pinned.  But for uniformity of
 * icall wrapping, let's declare a MonoInternalThreadHandle anyway.
 */
TYPED_HANDLE_DECL (MonoInternalThread);

typedef void (*MonoThreadCleanupFunc) (MonoNativeThreadId tid);
/* INFO has type MonoThreadInfo* */
typedef void (*MonoThreadNotifyPendingExcFunc) (gpointer info);

void
mono_thread_callbacks_init (void);

typedef enum {
	MONO_THREAD_CREATE_FLAGS_NONE         = 0x0,
	MONO_THREAD_CREATE_FLAGS_THREADPOOL   = 0x1,
	MONO_THREAD_CREATE_FLAGS_DEBUGGER     = 0x2,
	MONO_THREAD_CREATE_FLAGS_FORCE_CREATE = 0x4,
	MONO_THREAD_CREATE_FLAGS_SMALL_STACK  = 0x8,
} MonoThreadCreateFlags;

// FIXME func should be MonoThreadStart and remove the template
MonoInternalThread*
mono_thread_create_internal (MonoDomain *domain, gpointer func, gpointer arg, MonoThreadCreateFlags flags, MonoError *error);

#ifdef __cplusplus
template <typename T>
inline MonoInternalThread*
mono_thread_create_internal (MonoDomain *domain, T func, gpointer arg, MonoThreadCreateFlags flags, MonoError *error)
{
	return mono_thread_create_internal(domain, (gpointer)func, arg, flags, error);
}
#endif

MonoInternalThreadHandle
mono_thread_create_internal_handle (MonoDomain *domain, gpointer func, gpointer arg, MonoThreadCreateFlags flags, MonoError *error);

#ifdef __cplusplus
template <typename T>
inline MonoInternalThreadHandle
mono_thread_create_internal_handle (MonoDomain *domain, T func, gpointer arg, MonoThreadCreateFlags flags, MonoError *error)
{
	return mono_thread_create_internal_handle(domain, (gpointer)func, arg, flags, error);
}
#endif

void
mono_thread_manage_internal (void);

/* Data owned by a MonoInternalThread that must live until both the finalizer
 * for MonoInternalThread has run, and the underlying machine thread has
 * detached.
 *
 * Normally a thread is first detached and then the InternalThread object is
 * finalized and collected.  However during shutdown, when the root domain is
 * finalized, all the InternalThread objects are finalized first and the
 * machine threads are detached later.
 */
typedef struct {
  MonoRefCount ref;
  MonoCoopMutex *synch_cs;
} MonoLongLivedThreadData;

void mono_threads_install_cleanup (MonoThreadCleanupFunc func);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_SetName_internal (MonoInternalThread *this_obj, MonoString *name);

ICALL_EXPORT
MonoObject* ves_icall_System_Threading_Thread_GetCachedCurrentCulture (MonoInternalThread *this_obj);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_SetCachedCurrentCulture (MonoThread *this_obj, MonoObject *culture);

ICALL_EXPORT
MonoObject* ves_icall_System_Threading_Thread_GetCachedCurrentUICulture (MonoInternalThread *this_obj);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_SetCachedCurrentUICulture (MonoThread *this_obj, MonoObject *culture);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_Increment_Int(gint32 *location);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Increment_Long(gint64 *location);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_Decrement_Int(gint32 *location);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Decrement_Long(gint64 * location);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_Exchange_Int(gint32 *location, gint32 value);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Exchange_Long(gint64 *location, gint64 value);

ICALL_EXPORT
void ves_icall_System_Threading_Interlocked_Exchange_Object (MonoObject *volatile*location, MonoObject *volatile*value, MonoObject *volatile*res);

ICALL_EXPORT
gpointer ves_icall_System_Threading_Interlocked_Exchange_IntPtr(gpointer *location, gpointer value);

ICALL_EXPORT
gfloat ves_icall_System_Threading_Interlocked_Exchange_Single(gfloat *location, gfloat value);

ICALL_EXPORT
gdouble ves_icall_System_Threading_Interlocked_Exchange_Double(gdouble *location, gdouble value);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_CompareExchange_Int(gint32 *location, gint32 value, gint32 comparand);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_CompareExchange_Int_Success(gint32 *location, gint32 value, gint32 comparand, MonoBoolean *success);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_CompareExchange_Long(gint64 *location, gint64 value, gint64 comparand);

ICALL_EXPORT
void ves_icall_System_Threading_Interlocked_CompareExchange_Object (MonoObject *volatile*location, MonoObject *volatile*value, MonoObject *volatile*comparand, MonoObject *volatile*res);

ICALL_EXPORT
gpointer ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr(gpointer *location, gpointer value, gpointer comparand);

ICALL_EXPORT
gfloat ves_icall_System_Threading_Interlocked_CompareExchange_Single(gfloat *location, gfloat value, gfloat comparand);

ICALL_EXPORT
gdouble ves_icall_System_Threading_Interlocked_CompareExchange_Double(gdouble *location, gdouble value, gdouble comparand);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_Add_Int(gint32 *location, gint32 value);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Add_Long(gint64 *location, gint64 value);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Read_Long(gint64 *location);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_Increment_Int(gint32 *location);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Increment_Long(gint64 *location);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Interlocked_Decrement_Int(gint32 *location);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Interlocked_Decrement_Long(gint64 * location);

ICALL_EXPORT
void ves_icall_System_Threading_Interlocked_MemoryBarrierProcessWide (void);

ICALL_EXPORT
gint8 ves_icall_System_Threading_Thread_VolatileRead1 (void *ptr);

ICALL_EXPORT
gint16 ves_icall_System_Threading_Thread_VolatileRead2 (void *ptr);

ICALL_EXPORT
gint32 ves_icall_System_Threading_Thread_VolatileRead4 (void *ptr);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Thread_VolatileRead8 (void *ptr);

ICALL_EXPORT
void * ves_icall_System_Threading_Thread_VolatileReadIntPtr (void *ptr);

ICALL_EXPORT
void * ves_icall_System_Threading_Thread_VolatileReadObject (void *ptr);

ICALL_EXPORT
double ves_icall_System_Threading_Thread_VolatileReadDouble (void *ptr);

ICALL_EXPORT
float ves_icall_System_Threading_Thread_VolatileReadFloat (void *ptr);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWrite1 (void *ptr, gint8);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWrite2 (void *ptr, gint16);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWrite4 (void *ptr, gint32);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWrite8 (void *ptr, gint64);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWriteIntPtr (void *ptr, void *);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWriteObject (void *ptr, MonoObject *);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWriteFloat (void *ptr, float);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_VolatileWriteDouble (void *ptr, double);

ICALL_EXPORT
gint64 ves_icall_System_Threading_Volatile_Read8 (void *ptr);

ICALL_EXPORT
guint64 ves_icall_System_Threading_Volatile_ReadU8 (void *ptr);

ICALL_EXPORT
double ves_icall_System_Threading_Volatile_ReadDouble (void *ptr);

ICALL_EXPORT
void ves_icall_System_Threading_Volatile_Write8 (void *ptr, gint64);

ICALL_EXPORT
void ves_icall_System_Threading_Volatile_WriteU8 (void *ptr, guint64);

ICALL_EXPORT
void ves_icall_System_Threading_Volatile_WriteDouble (void *ptr, double);

ICALL_EXPORT
void ves_icall_System_Threading_Thread_MemoryBarrier (void);

void
mono_threads_register_app_context (MonoAppContextHandle ctx, MonoError *error);
void
mono_threads_release_app_context (MonoAppContext* ctx, MonoError *error);

MONO_PROFILER_API MonoInternalThread *mono_thread_internal_current (void);

MonoInternalThreadHandle
mono_thread_internal_current_handle (void);

void mono_thread_internal_abort (MonoInternalThread *thread, gboolean appdomain_unload);
void mono_thread_internal_suspend_for_shutdown (MonoInternalThread *thread);

gboolean mono_thread_internal_has_appdomain_ref (MonoInternalThread *thread, MonoDomain *domain);

void mono_thread_internal_reset_abort (MonoInternalThread *thread);

void mono_thread_internal_unhandled_exception (MonoObject* exc);

void mono_alloc_special_static_data_free (GHashTable *special_static_fields);
gboolean mono_thread_current_check_pending_interrupt (void);

void mono_thread_set_state (MonoInternalThread *thread, MonoThreadState state);
void mono_thread_clr_state (MonoInternalThread *thread, MonoThreadState state);
gboolean mono_thread_test_state (MonoInternalThread *thread, MonoThreadState test);
gboolean mono_thread_test_and_set_state (MonoInternalThread *thread, MonoThreadState test, MonoThreadState set);
void mono_thread_clear_and_set_state (MonoInternalThread *thread, MonoThreadState clear, MonoThreadState set);

void mono_thread_init_apartment_state (void);
void mono_thread_cleanup_apartment_state (void);

void mono_threads_set_shutting_down (void);

MONO_API MonoException* mono_thread_get_undeniable_exception (void);

ICALL_EXPORT
void ves_icall_thread_finish_async_abort (void);

#if HOST_WIN32

void
mono_thread_set_name_windows (HANDLE thread_handle, PCWSTR thread_name);

#define MONO_THREAD_NAME_WINDOWS_CONSTANT(x) L ## x

#else

#define mono_thread_set_name_windows(thread_handle, thread_name) /* nothing */

#define MONO_THREAD_NAME_WINDOWS_CONSTANT(x) NULL

#endif

typedef enum {
    MonoSetThreadNameFlag_None      = 0x0000,
    MonoSetThreadNameFlag_Permanent = 0x0001,
    MonoSetThreadNameFlag_Reset     = 0x0002,
    MonoSetThreadNameFlag_Constant  = 0x0004,
    MonoSetThreadNameFlag_RepeatedlyButOptimized = 0x0008,
} MonoSetThreadNameFlags;

G_ENUM_FUNCTIONS (MonoSetThreadNameFlags)

MONO_PROFILER_API
void
mono_thread_set_name (MonoInternalThread *thread,
		      const char* name8, size_t name8_length, const gunichar2* name16,
		      MonoSetThreadNameFlags flags, MonoError *error);

#define mono_thread_set_name_constant_ignore_error(thread, name, flags) \
	mono_thread_set_name ((thread), name, G_N_ELEMENTS (name) - 1,  \
		MONO_THREAD_NAME_WINDOWS_CONSTANT (name),               \
		(flags) | MonoSetThreadNameFlag_Constant, NULL)

#ifndef ENABLE_NETCORE
void mono_thread_suspend_all_other_threads (void);
#endif
gboolean mono_threads_abort_appdomain_threads (MonoDomain *domain, int timeout);

void mono_thread_push_appdomain_ref (MonoDomain *domain);
void mono_thread_pop_appdomain_ref (void);
gboolean mono_thread_has_appdomain_ref (MonoThread *thread, MonoDomain *domain);

gboolean mono_thread_interruption_requested (void);

ICALL_EXTERN_C
MonoException*
mono_thread_interruption_checkpoint (void);

gboolean
mono_thread_interruption_checkpoint_bool (void);

void
mono_thread_interruption_checkpoint_void (void);

MonoExceptionHandle
mono_thread_interruption_checkpoint_handle (void);

ICALL_EXTERN_C
MonoException* mono_thread_force_interruption_checkpoint_noraise (void);

/**
 * mono_thread_interruption_request_flag:
 *
 * A flag that will be non-zero if an interruption has
 * been requested for a thread. The thread to interrupt may not be the current
 * thread, so an additional call to mono_thread_interruption_requested () or
 * mono_thread_interruption_checkpoint () is always needed if the flag is not
 * zero.
 */
extern gint32 mono_thread_interruption_request_flag;

uint32_t mono_alloc_special_static_data (uint32_t static_type, uint32_t size, uint32_t align, uintptr_t *bitmap, int numbits);

ICALL_EXTERN_C
void*    mono_get_special_static_data   (uint32_t offset);

gpointer mono_get_special_static_data_for_thread (MonoInternalThread *thread, guint32 offset);

void
mono_thread_resume_interruption (gboolean exec);
void mono_threads_perform_thread_dump (void);

// FIXME Correct the type of func and remove the template.
gboolean
mono_thread_create_checked (MonoDomain *domain, gpointer func, gpointer arg, MonoError *error);

#ifdef __cplusplus
template <typename T>
inline gboolean
mono_thread_create_checked (MonoDomain *domain, T func, gpointer arg, MonoError *error)
{
	return mono_thread_create_checked (domain, (gpointer)func, arg, error);
}
#endif

void mono_threads_add_joinable_runtime_thread (MonoThreadInfo *thread_info);
void mono_threads_add_joinable_thread (gpointer tid);
void mono_threads_join_threads (void);
void mono_thread_join (gpointer tid);

MONO_API gpointer
mono_threads_attach_coop (MonoDomain *domain, gpointer *dummy);

MONO_API void
mono_threads_detach_coop (gpointer cookie, gpointer *dummy);

MonoDomain*
mono_threads_attach_coop_internal (MonoDomain *domain, gpointer *cookie, MonoStackData *stackdata);

void
mono_threads_detach_coop_internal (MonoDomain *orig_domain, gpointer cookie, MonoStackData *stackdata);

void mono_threads_begin_abort_protected_block (void);
gboolean mono_threads_end_abort_protected_block (void);

gboolean
mono_thread_internal_current_is_attached (void);

void
mono_thread_internal_describe (MonoInternalThread *internal, GString *str);

gboolean
mono_thread_internal_is_current (MonoInternalThread *internal);

gboolean
mono_threads_is_current_thread_in_protected_block (void);

gboolean
mono_threads_is_critical_method (MonoMethod *method);

gpointer
mono_threads_enter_gc_unsafe_region_unbalanced_internal (MonoStackData *stackdata);

void
mono_threads_exit_gc_unsafe_region_unbalanced_internal (gpointer cookie, MonoStackData *stackdata);

gpointer
mono_threads_enter_gc_safe_region_unbalanced_internal (MonoStackData *stackdata);

void
mono_threads_exit_gc_safe_region_unbalanced_internal (gpointer cookie, MonoStackData *stackdata);

// Set directory to store thread dumps captured by SIGQUIT
void
mono_set_thread_dump_dir(gchar* dir);

MONO_COLD void
mono_set_pending_exception_handle (MonoExceptionHandle exc);

#define MONO_MAX_SUMMARY_NAME_LEN 140
#define MONO_MAX_THREAD_NAME_LEN 140
#define MONO_MAX_SUMMARY_THREADS 32
#define MONO_MAX_SUMMARY_FRAMES 80
#define MONO_MAX_SUMMARY_EXCEPTIONS 15

typedef struct {
	gboolean is_managed;
	char str_descr [MONO_MAX_SUMMARY_NAME_LEN];
	struct {
		int token;
		int il_offset;
		int native_offset;
		const char *guid;

#ifndef MONO_PRIVATE_CRASHES
		// We use ifdef to make it a compile-time error to store this 
		// symbolicated string on release builds
		const char *name;
#endif
		const char *filename;
		guint32 image_size;
		guint32 time_date_stamp;
	} managed_data;
	struct {
		intptr_t ip;
		gint32 offset;
		char module [MONO_MAX_SUMMARY_NAME_LEN];
		gboolean is_trampoline;
		gboolean has_name;
	} unmanaged_data;
} MonoFrameSummary;

typedef struct {
	MonoClass *managed_exc_type;

	int num_managed_frames;
	MonoFrameSummary managed_frames [MONO_MAX_SUMMARY_FRAMES];
} MonoExcSummary;

typedef struct {
	guint64 offset_free_hash;
	guint64 offset_rich_hash;
} MonoStackHash;

typedef struct {
	gboolean done; // Needed because cond wait can have spurious wakeups
	MonoSemType done_wait; // Readers are finished with this

	// For managed stack walking

	MonoDomain *domain;
	MonoJitTlsData *jit_tls;
	MonoLMF *lmf;

	// Emitted attributes

	gboolean is_managed;

	char name [MONO_MAX_THREAD_NAME_LEN];

	intptr_t info_addr;
	intptr_t native_thread_id;

	// Print reason we don't have a complete
	// managed trace
	const char *error_msg;

	int num_managed_frames;
	MonoFrameSummary managed_frames [MONO_MAX_SUMMARY_FRAMES];

	int num_unmanaged_frames;
	MonoFrameSummary unmanaged_frames [MONO_MAX_SUMMARY_FRAMES];

	int num_exceptions;
	MonoExcSummary exceptions [MONO_MAX_SUMMARY_EXCEPTIONS];

	MonoStackHash hashes;

	MonoContext *ctx;
	MonoContext ctx_mem;
} MonoThreadSummary;

void
mono_threads_summarize_init (void);

gboolean
mono_threads_summarize (MonoContext *ctx, gchar **out, MonoStackHash *hashes, gboolean silent, gboolean signal_handler_controller, gchar *mem, size_t provided_size);

gboolean
mono_threads_summarize_execute (MonoContext *ctx, gchar **out, MonoStackHash *hashes, gboolean silent, gchar *mem, size_t provided_size);

gboolean
mono_threads_summarize_one (MonoThreadSummary *out, MonoContext *ctx);

#endif /* _MONO_METADATA_THREADS_TYPES_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/threads.h`:

```h
/**
 * \file
 * Threading API
 *
 * Author:
 *	Dick Porter (dick@ximian.com)
 *	Patrik Torstensson (patrik.torstensson@labs2.com)
 *
 * (C) 2001 Ximian, Inc
 */

#ifndef _MONO_METADATA_THREADS_H_
#define _MONO_METADATA_THREADS_H_

#include <mono/utils/mono-publib.h>
#include <mono/metadata/object.h>
#include <mono/metadata/appdomain.h>

MONO_BEGIN_DECLS

/* This callback should return TRUE if the runtime must wait for the thread, FALSE otherwise */
typedef mono_bool (*MonoThreadManageCallback) (MonoThread* thread);

MONO_API void mono_thread_init (MonoThreadStartCB start_cb,
			      MonoThreadAttachCB attach_cb);
MONO_API void mono_thread_cleanup (void);
MONO_API MONO_RT_EXTERNAL_ONLY
void mono_thread_manage(void);

MONO_API MonoThread *mono_thread_current (void);

MONO_API void        mono_thread_set_main (MonoThread *thread);
MONO_API MonoThread *mono_thread_get_main (void);

MONO_API MONO_RT_EXTERNAL_ONLY void mono_thread_stop (MonoThread *thread);

MONO_API void mono_thread_new_init (intptr_t tid, void* stack_start,
				  void* func);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_thread_create (MonoDomain *domain, void* func, void* arg);

MONO_API MonoThread *mono_thread_attach (MonoDomain *domain);
MONO_API void mono_thread_detach (MonoThread *thread);
MONO_API void mono_thread_exit (void);

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_threads_attach_tools_thread (void);

MONO_API char   *mono_thread_get_name_utf8 (MonoThread *thread);
MONO_API int32_t mono_thread_get_managed_id (MonoThread *thread);

MONO_API void     mono_thread_set_manage_callback (MonoThread *thread, MonoThreadManageCallback func);

MONO_API void mono_threads_set_default_stacksize (uint32_t stacksize);
MONO_API uint32_t mono_threads_get_default_stacksize (void);

MONO_API void mono_threads_request_thread_dump (void);

MONO_API mono_bool mono_thread_is_foreign (MonoThread *thread);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_thread_detach_if_exiting (void);

MONO_END_DECLS

#endif /* _MONO_METADATA_THREADS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/tokentype.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_TOKENTYPE_H_
#define _MONO_METADATA_TOKENTYPE_H_

/*
 * These tokens match the table ID except for the last
 * three (string, name and base type which are special)
 */
 
typedef enum {
	MONO_TOKEN_MODULE            = 0x00000000,
	MONO_TOKEN_TYPE_REF          = 0x01000000,
	MONO_TOKEN_TYPE_DEF          = 0x02000000,
	MONO_TOKEN_FIELD_DEF         = 0x04000000,
	MONO_TOKEN_METHOD_DEF        = 0x06000000, 
	MONO_TOKEN_PARAM_DEF         = 0x08000000,
	MONO_TOKEN_INTERFACE_IMPL    = 0x09000000,
	MONO_TOKEN_MEMBER_REF        = 0x0a000000,
	MONO_TOKEN_CUSTOM_ATTRIBUTE  = 0x0c000000,
	MONO_TOKEN_PERMISSION        = 0x0e000000,
	MONO_TOKEN_SIGNATURE         = 0x11000000,
	MONO_TOKEN_EVENT             = 0x14000000,
	MONO_TOKEN_PROPERTY          = 0x17000000,
	MONO_TOKEN_MODULE_REF        = 0x1a000000,
	MONO_TOKEN_TYPE_SPEC         = 0x1b000000,
	MONO_TOKEN_ASSEMBLY          = 0x20000000,
	MONO_TOKEN_ASSEMBLY_REF      = 0x23000000,
	MONO_TOKEN_FILE              = 0x26000000,
	MONO_TOKEN_EXPORTED_TYPE     = 0x27000000,
	MONO_TOKEN_MANIFEST_RESOURCE = 0x28000000,
	MONO_TOKEN_GENERIC_PARAM     = 0x2a000000,
	MONO_TOKEN_METHOD_SPEC       = 0x2b000000,

	/*
	 * These do not match metadata tables directly
	 */
	MONO_TOKEN_STRING            = 0x70000000,
	MONO_TOKEN_NAME              = 0x71000000,
	MONO_TOKEN_BASE_TYPE         = 0x72000000
} MonoTokenType;

#endif /* _MONO_METADATA_TOKENTYPE_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/verify-internals.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_VERIFY_INTERNAL_H__
#define __MONO_METADATA_VERIFY_INTERNAL_H__

#include <glib.h>
#include <mono/metadata/metadata.h>
#include <mono/utils/mono-compiler.h>
#include <mono/utils/mono-error.h>

typedef enum {
	MONO_VERIFIER_MODE_OFF,
	MONO_VERIFIER_MODE_VALID,
	MONO_VERIFIER_MODE_VERIFIABLE,
	MONO_VERIFIER_MODE_STRICT
} MiniVerifierMode;

void mono_verifier_set_mode (MiniVerifierMode mode);
void mono_verifier_enable_verify_all (void);

gboolean mono_verifier_is_enabled_for_image (MonoImage *image);
gboolean mono_verifier_is_enabled_for_method (MonoMethod *method);
gboolean mono_verifier_is_enabled_for_class (MonoClass *klass);

gboolean mono_verifier_is_method_full_trust (MonoMethod *method);
gboolean mono_verifier_is_class_full_trust (MonoClass *klass);
gboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *klass);
gboolean mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method);

gboolean mono_verifier_verify_class (MonoClass *klass);

GSList* mono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility, gboolean is_fulltrust);

gboolean mono_verifier_verify_pe_data (MonoImage *image, MonoError *error);
gboolean mono_verifier_verify_cli_data (MonoImage *image, MonoError *error);
gboolean mono_verifier_verify_table_data (MonoImage *image, MonoError *error);

gboolean mono_verifier_verify_full_table_data (MonoImage *image, MonoError *error);

gboolean mono_verifier_verify_field_signature (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_method_header (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_method_signature (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_standalone_signature (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_typespec_signature (MonoImage *image, guint32 offset, guint32 token, MonoError *error);
gboolean mono_verifier_verify_methodspec_signature (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_string_signature (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_cattr_blob (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_cattr_content (MonoImage *image, MonoMethod *ctor, const guchar *data, guint32 size, MonoError *error);
gboolean mono_verifier_is_sig_compatible (MonoImage *image, MonoMethod *method, MonoMethodSignature *signature);
gboolean mono_verifier_verify_memberref_method_signature (MonoImage *image, guint32 offset, MonoError *error);
gboolean mono_verifier_verify_memberref_field_signature (MonoImage *image, guint32 offset, MonoError *error);

gboolean mono_verifier_verify_typeref_row (MonoImage *image, guint32 row, MonoError *error);
gboolean mono_verifier_verify_methodimpl_row (MonoImage *image, guint32 row, MonoError *error);
gboolean mono_verifier_is_signature_compatible (MonoMethodSignature *target, MonoMethodSignature *candidate);

/*Token validation macros and functions */
#define IS_MEMBER_REF(token) (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF)
#define IS_METHOD_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_METHOD)
#define IS_METHOD_SPEC(token) (mono_metadata_token_table (token) == MONO_TABLE_METHODSPEC)
#define IS_FIELD_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_FIELD)

#define IS_TYPE_REF(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPEREF)
#define IS_TYPE_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPEDEF)
#define IS_TYPE_SPEC(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPESPEC)
#define IS_METHOD_DEF_OR_REF_OR_SPEC(token) (IS_METHOD_DEF (token) || IS_MEMBER_REF (token) || IS_METHOD_SPEC (token))
#define IS_TYPE_DEF_OR_REF_OR_SPEC(token) (IS_TYPE_DEF (token) || IS_TYPE_REF (token) || IS_TYPE_SPEC (token))
#define IS_FIELD_DEF_OR_REF(token) (IS_FIELD_DEF (token) || IS_MEMBER_REF (token))

#endif  /* __MONO_METADATA_VERIFY_INTERNAL_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/verify.h`:

```h
/**
 * \file
 */

#ifndef __MONO_METADATA_VERIFY_H__
#define __MONO_METADATA_VERIFY_H__

#include <mono/metadata/metadata.h>
#include <mono/metadata/image.h>
#include <mono/metadata/loader.h>
#include <glib.h> /* GSList dep */

MONO_BEGIN_DECLS

typedef enum {
	MONO_VERIFY_OK,
	MONO_VERIFY_ERROR,
	MONO_VERIFY_WARNING,
	MONO_VERIFY_CLS = 4,
	MONO_VERIFY_ALL = 7,

	/* Status signaling code that is not verifiable.*/
	MONO_VERIFY_NOT_VERIFIABLE = 8,

	/*OR it with other flags*/
	
	/* Abort the verification if the code is not verifiable.
	 * The standard behavior is to abort if the code is not valid.
	 * */
	MONO_VERIFY_FAIL_FAST = 16,


	/* Perform less verification of the code. This flag should be used
	 * if one wants the verifier to be more compatible to the MS runtime.
	 * Mind that this is not to be more compatible with MS peverify, but
	 * with the runtime itself, that has a less strict verifier.
	 */
	MONO_VERIFY_NON_STRICT = 32,

	/*Skip all visibility related checks*/
	MONO_VERIFY_SKIP_VISIBILITY = 64,

	/*Skip all visibility related checks*/
	MONO_VERIFY_REPORT_ALL_ERRORS = 128

} MonoVerifyStatus;

typedef struct {
	char            *message;
	MonoVerifyStatus status;
} MonoVerifyInfo;

typedef struct {
	MonoVerifyInfo info;
	int8_t exception_type; /*should be one of MONO_EXCEPTION_* */
} MonoVerifyInfoExtended;


MONO_API GSList* mono_method_verify       (MonoMethod *method, int level);
MONO_API void    mono_free_verify_list    (GSList *list);
MONO_API char*   mono_verify_corlib       (void);

MONO_END_DECLS

#endif  /* __MONO_METADATA_VERIFY_H__ */


```

`Hazel/vendor/mono/include/mono/metadata/w32error.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32ERROR_H_
#define _MONO_METADATA_W32ERROR_H_

#include <config.h>
#include <glib.h>

#if !defined(HOST_WIN32)

#define ERROR_SUCCESS              0
#define ERROR_FILE_NOT_FOUND       2
#define ERROR_PATH_NOT_FOUND       3
#define ERROR_TOO_MANY_OPEN_FILES  4
#define ERROR_ACCESS_DENIED        5
#define ERROR_INVALID_HANDLE       6
#define ERROR_NOT_ENOUGH_MEMORY    8
#define ERROR_BAD_FORMAT           11
#define ERROR_INVALID_ACCESS       12
#define ERROR_INVALID_DATA         13
#define ERROR_OUTOFMEMORY          14
#define ERROR_NOT_SAME_DEVICE      17
#define ERROR_NO_MORE_FILES        18
#define ERROR_BAD_LENGTH           24
#define ERROR_SEEK                 25
#define ERROR_WRITE_FAULT          29
#define ERROR_GEN_FAILURE          31
#define ERROR_SHARING_VIOLATION    32
#define ERROR_LOCK_VIOLATION       33
#define ERROR_HANDLE_DISK_FULL     39
#define ERROR_NOT_SUPPORTED        50
#define ERROR_DEV_NOT_EXIST        55
#define ERROR_FILE_EXISTS          80
#define ERROR_CANNOT_MAKE          82
#define ERROR_INVALID_PARAMETER    87
#define ERROR_INVALID_NAME         123
#define ERROR_PROC_NOT_FOUND       127
#define ERROR_DIR_NOT_EMPTY        145
#define ERROR_ALREADY_EXISTS       183
#define ERROR_BAD_EXE_FORMAT       193
#define ERROR_FILENAME_EXCED_RANGE 206
#define ERROR_DIRECTORY            267
#define ERROR_IO_PENDING           997
#define ERROR_CANT_RESOLVE_FILENAME 1921
#define ERROR_ENCRYPTION_FAILED    6000
#define WSA_INVALID_PARAMETER      ERROR_INVALID_PARAMETER
#define WSA_INVALID_HANDLE         ERROR_INVALID_HANDLE
#define WSAEINTR                   10004
#define WSAEBADF                   10009
#define WSAEACCES                  10013
#define WSAEFAULT                  10014
#define WSAEINVAL                  10022
#define WSAEMFILE                  10024
#define WSAEWOULDBLOCK             10035
#define WSAEINPROGRESS             10036
#define WSAEALREADY                10037
#define WSAENOTSOCK                10038
#define WSAEDESTADDRREQ            10039
#define WSAEMSGSIZE                10040
#define WSAEPROTOTYPE              10041
#define WSAENOPROTOOPT             10042
#define WSAEPROTONOSUPPORT         10043
#define WSAESOCKTNOSUPPORT         10044
#define WSAEOPNOTSUPP              10045
#define WSAEAFNOSUPPORT            10047
#define WSAEADDRINUSE              10048
#define WSAEADDRNOTAVAIL           10049
#define WSAENETDOWN                10050
#define WSAENETUNREACH             10051
#define WSAECONNRESET              10054
#define WSAENOBUFS                 10055
#define WSAEISCONN                 10056
#define WSAENOTCONN                10057
#define WSAESHUTDOWN               10058
#define WSAETIMEDOUT               10060
#define WSAECONNREFUSED            10061
#define WSAELOOP                   10062
#define WSAENAMETOOLONG            10063
#define WSAEHOSTDOWN               10064
#define WSAEHOSTUNREACH            10065
#define WSASYSCALLFAILURE          10107
#define WSAENXIO                   100001

#endif

guint32
mono_w32error_get_last (void);

void
mono_w32error_set_last (guint32 error);

guint32
mono_w32error_unix_to_win32 (guint32 error);

#endif /* _MONO_METADATA_W32ERROR_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32event.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32EVENT_H_
#define _MONO_METADATA_W32EVENT_H_

#include <config.h>
#include <glib.h>

#include "object.h"
#include "object-internals.h"
#include "w32handle-namespace.h"
#include <mono/metadata/icalls.h>

void
mono_w32event_init (void);

gpointer
mono_w32event_create (gboolean manual, gboolean initial);

gboolean
mono_w32event_close (gpointer handle);

void
mono_w32event_set (gpointer handle);

void
mono_w32event_reset (gpointer handle);

ICALL_EXPORT
gboolean
ves_icall_System_Threading_Events_SetEvent_internal (gpointer handle);

ICALL_EXPORT
gboolean
ves_icall_System_Threading_Events_ResetEvent_internal (gpointer handle);

ICALL_EXPORT
void
ves_icall_System_Threading_Events_CloseEvent_internal (gpointer handle);

typedef struct MonoW32HandleNamedEvent MonoW32HandleNamedEvent;

MonoW32HandleNamespace*
mono_w32event_get_namespace (MonoW32HandleNamedEvent *event);

#endif /* _MONO_METADATA_W32EVENT_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32file-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef _MONO_METADATA_W32FILE_INTERNALS_H_
#define _MONO_METADATA_W32FILE_INTERNALS_H_

#include <config.h>
#include <glib.h>

#endif /* _MONO_METADATA_W32FILE_INTERNALS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32file-unix-glob.h`:

```h
/*	$OpenBSD: glob.h,v 1.10 2005/12/13 00:35:22 millert Exp $	*/
/*	$NetBSD: glob.h,v 1.5 1994/10/26 00:55:56 cgd Exp $	*/

/**
 * \file
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Guido van Rossum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)glob.h	8.1 (Berkeley) 6/2/93
 */

#ifndef __MONO_METADATA_W32FILE_UNIX_GLOB_H__
#define	__MONO_METADATA_W32FILE_UNIX_GLOB_H__

#include <glib.h>

struct stat;
typedef struct {
	int gl_pathc;		/* Count of total paths so far. */
	int gl_offs;		/* Reserved at beginning of gl_pathv. */
	int gl_flags;		/* Copy of flags parameter to glob. */
	char **gl_pathv;	/* List of paths matching pattern. */
} mono_w32file_unix_glob_t;

#define W32FILE_UNIX_GLOB_APPEND	0x0001	/* Append to output from previous call. */
#define W32FILE_UNIX_GLOB_UNIQUE	0x0040	/* When appending only add items that aren't already in the list */
#define	W32FILE_UNIX_GLOB_NOSPACE	(-1)	/* Malloc call failed. */
#define	W32FILE_UNIX_GLOB_ABORTED	(-2)	/* Unignored error. */
#define	W32FILE_UNIX_GLOB_NOMATCH	(-3)	/* No match and W32FILE_UNIX_GLOB_NOCHECK not set. */
#define	W32FILE_UNIX_GLOB_NOSYS	(-4)	/* Function not supported. */

#define	W32FILE_UNIX_GLOB_MAGCHAR	0x0100	/* Pattern had globbing characters. */
#define W32FILE_UNIX_GLOB_LIMIT	0x2000	/* Limit pattern match output to ARG_MAX */
#define W32FILE_UNIX_GLOB_IGNORECASE 0x4000	/* Ignore case when matching */
#define W32FILE_UNIX_GLOB_ABEND	W32FILE_UNIX_GLOB_ABORTED /* backward compatibility */

int
mono_w32file_unix_glob (GDir *dir, const char *, int, mono_w32file_unix_glob_t *);

void
mono_w32file_unix_globfree (mono_w32file_unix_glob_t *);

#endif /* !__MONO_METADATA_W32FILE_UNIX_GLOB_H__ */

```

`Hazel/vendor/mono/include/mono/metadata/w32file-win32-internals.h`:

```h
/**
 * \file
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef _MONO_METADATA_W32FILE_WIN32_INTERNALS_H_
#define _MONO_METADATA_W32FILE_WIN32_INTERNALS_H_

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32
#include "mono/metadata/w32file.h"
#include "mono/metadata/w32file-internals.h"
#endif /* HOST_WIN32 */
#endif /* _MONO_METADATA_W32FILE_WIN32_INTERNALS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32file.h`:

```h
/**
 * \file
 * File IO internal calls
 *
 * Authors:
 *	Dick Porter (dick@ximian.com)
 *	Dan Lewis (dihlewis@yahoo.co.uk)
 *
 * (C) 2001 Ximian, Inc.
 * Copyright 2012 Xamarin Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef _MONO_METADATA_W32FILE_H_
#define _MONO_METADATA_W32FILE_H_

#include <config.h>
#include <glib.h>

#include <mono/metadata/object-internals.h>
#include <mono/utils/mono-compiler.h>
#include <mono/metadata/icalls.h>

/* This is a copy of System.IO.FileAccess */
typedef enum {
	FileAccess_Read=0x01,
	FileAccess_Write=0x02,
	FileAccess_ReadWrite=FileAccess_Read|FileAccess_Write
} MonoFileAccess;

/* This is a copy of System.IO.FileMode */
typedef enum {
	FileMode_CreateNew=1,
	FileMode_Create=2,
	FileMode_Open=3,
	FileMode_OpenOrCreate=4,
	FileMode_Truncate=5,
	FileMode_Append=6
} MonoFileMode;

/* This is a copy of System.IO.FileShare */
typedef enum {
	FileShare_None=0x0,
	FileShare_Read=0x01,
	FileShare_Write=0x02,
	FileShare_ReadWrite=FileShare_Read|FileShare_Write,
	FileShare_Delete=0x04
} MonoFileShare;

/* This is a copy of System.IO.FileOptions */
typedef enum {
	FileOptions_None = 0,
	FileOptions_Temporary = 1,		// Internal.   See note in System.IO.FileOptions
	FileOptions_Encrypted = 0x4000,
	FileOptions_DeleteOnClose = 0x4000000,
	FileOptions_SequentialScan = 0x8000000,
	FileOptions_RandomAccess = 0x10000000,
	FileOptions_Asynchronous = 0x40000000,
	FileOptions_WriteThrough = 0x80000000
} MonoFileOptions;

/* This is a copy of System.IO.SeekOrigin */
typedef enum {
	SeekOrigin_Begin=0,
	SeekOrigin_Current=1,
	SeekOrigin_End=2
} MonoSeekOrigin;

/* This is a copy of System.IO.MonoIOStat */
typedef struct _MonoIOStat {
	gint32 attributes;
	gint64 length;
	gint64 creation_time;
	gint64 last_access_time;
	gint64 last_write_time;
} MonoIOStat;

/* This is a copy of System.IO.FileAttributes */
typedef enum {
	FileAttributes_ReadOnly=0x00001,
	FileAttributes_Hidden=0x00002,
	FileAttributes_System=0x00004,
	FileAttributes_Directory=0x00010,
	FileAttributes_Archive=0x00020,
	FileAttributes_Device=0x00040,
	FileAttributes_Normal=0x00080,
	FileAttributes_Temporary=0x00100,
	FileAttributes_SparseFile=0x00200,
	FileAttributes_ReparsePoint=0x00400,
	FileAttributes_Compressed=0x00800,
	FileAttributes_Offline=0x01000,
	FileAttributes_NotContentIndexed=0x02000,
	FileAttributes_Encrypted=0x04000,
	FileAttributes_MonoExecutable= (int) 0x80000000
} MonoFileAttributes;
/* This is not used anymore
typedef struct _MonoFSAsyncResult {
	MonoObject obj;
	MonoObject *state;
	MonoBoolean completed;
	MonoBoolean done;
	MonoException *exc;
	MonoWaitHandle *wait_handle;
	MonoDelegate *async_callback;
	MonoBoolean completed_synch;
	MonoArray *buffer;
	gint offset;
	gint count;
	gint original_count;
	gint bytes_read;
	MonoDelegate *real_cb;
} MonoFSAsyncResult;
*/
/* System.IO.MonoIO */

#if !ENABLE_NETCORE

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_CreateDirectory (const gunichar2 *path, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_RemoveDirectory (const gunichar2 *path, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_FindCloseFile (gpointer hnd);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_SetCurrentDirectory (const gunichar2 *path,
						gint32 *error);
ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_MoveFile (const gunichar2 *path, const gunichar2 *dest,
				     gint32 *error);
ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_CopyFile (const gunichar2 *path, const gunichar2 *dest,
				     MonoBoolean overwrite, gint32 *error);
ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_DeleteFile (const gunichar2 *path, gint32 *error);

ICALL_EXPORT
gint32
ves_icall_System_IO_MonoIO_GetFileAttributes (const gunichar2 *path, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_SetFileAttributes (const gunichar2 *path, gint32 attrs,
					      gint32 *error);
ICALL_EXPORT
gint32
ves_icall_System_IO_MonoIO_GetFileType (gpointer handle, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_GetFileStat (const gunichar2 *path, MonoIOStat *stat,
					gint32 *error);
ICALL_EXPORT
gpointer
ves_icall_System_IO_MonoIO_Open (const gunichar2 *filename, gint32 mode,
				 gint32 access_mode, gint32 share, gint32 options,
				 gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_Cancel (gpointer handle, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_Close (gpointer handle, gint32 *error);

ICALL_EXPORT
gint64
ves_icall_System_IO_MonoIO_Seek (gpointer handle, gint64 offset, gint32 origin,
				 gint32 *error);
ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_Flush (gpointer handle, gint32 *error);

ICALL_EXPORT
gint64
ves_icall_System_IO_MonoIO_GetLength (gpointer handle, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_SetLength (gpointer handle, gint64 length,
				      gint32 *error);
ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_SetFileTime (gpointer handle, gint64 creation_time,
					gint64 last_access_time,
					gint64 last_write_time, gint32 *error);
ICALL_EXPORT
gpointer
ves_icall_System_IO_MonoIO_get_ConsoleOutput (void);

ICALL_EXPORT
gpointer
ves_icall_System_IO_MonoIO_get_ConsoleInput (void);

ICALL_EXPORT
gpointer
ves_icall_System_IO_MonoIO_get_ConsoleError (void);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_CreatePipe (gpointer *read_handle, gpointer *write_handle, gint32 *error);

ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_DuplicateHandle (gpointer source_process_handle, gpointer source_handle,
		gpointer target_process_handle, gpointer *target_handle, gint32 access, gint32 inherit, gint32 options, gint32 *error);

ICALL_EXPORT
gunichar2
ves_icall_System_IO_MonoIO_get_VolumeSeparatorChar (void);

ICALL_EXPORT
gunichar2
ves_icall_System_IO_MonoIO_get_DirectorySeparatorChar (void);

ICALL_EXPORT
gunichar2
ves_icall_System_IO_MonoIO_get_AltDirectorySeparatorChar (void);

ICALL_EXPORT
gunichar2
ves_icall_System_IO_MonoIO_get_PathSeparator (void);

ICALL_EXPORT
void ves_icall_System_IO_MonoIO_Lock (gpointer handle, gint64 position,
					     gint64 length, gint32 *error);

ICALL_EXPORT
void ves_icall_System_IO_MonoIO_Unlock (gpointer handle, gint64 position,
					       gint64 length, gint32 *error);
ICALL_EXPORT
MonoBoolean
ves_icall_System_IO_MonoIO_ReplaceFile (const gunichar2 *source_file_name, const gunichar2 *destination_file_name,
					const gunichar2 *destination_backup_file_name, MonoBoolean ignore_metadata_errors,
					gint32 *error);

ICALL_EXPORT
void
ves_icall_System_IO_MonoIO_DumpHandles (void);

#endif /* !ENABLE_NETCORE */

#if defined (TARGET_IOS) || defined (TARGET_ANDROID)

MONO_API MONO_RT_EXTERNAL_ONLY gint64
mono_filesize_from_path (MonoString *path);

extern gint64
mono_filesize_from_fd (int fd);

#endif

#if !defined(HOST_WIN32)

#define GENERIC_READ    0x80000000
#define GENERIC_WRITE   0x40000000
#define GENERIC_EXECUTE 0x20000000
#define GENERIC_ALL     0x10000000

#define FILE_SHARE_NONE   0x00000000
#define FILE_SHARE_READ   0x00000001
#define FILE_SHARE_WRITE  0x00000002
#define FILE_SHARE_DELETE 0x00000004

#define CREATE_NEW        1
#define CREATE_ALWAYS     2
#define OPEN_EXISTING     3
#define OPEN_ALWAYS       4
#define TRUNCATE_EXISTING 5

#define FILE_ATTRIBUTE_READONLY            0x00000001
#define FILE_ATTRIBUTE_HIDDEN              0x00000002
#define FILE_ATTRIBUTE_SYSTEM              0x00000004
#define FILE_ATTRIBUTE_DIRECTORY           0x00000010
#define FILE_ATTRIBUTE_ARCHIVE             0x00000020
#define FILE_ATTRIBUTE_ENCRYPTED           0x00000040
#define FILE_ATTRIBUTE_NORMAL              0x00000080
#define FILE_ATTRIBUTE_TEMPORARY           0x00000100
#define FILE_ATTRIBUTE_SPARSE_FILE         0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT       0x00000400
#define FILE_ATTRIBUTE_COMPRESSED          0x00000800
#define FILE_ATTRIBUTE_OFFLINE             0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000
#define FILE_FLAG_OPEN_NO_RECALL           0x00100000
#define FILE_FLAG_OPEN_REPARSE_POINT       0x00200000
#define FILE_FLAG_POSIX_SEMANTICS          0x01000000
#define FILE_FLAG_BACKUP_SEMANTICS         0x02000000
#define FILE_FLAG_DELETE_ON_CLOSE          0x04000000
#define FILE_FLAG_SEQUENTIAL_SCAN          0x08000000
#define FILE_FLAG_RANDOM_ACCESS            0x10000000
#define FILE_FLAG_NO_BUFFERING             0x20000000
#define FILE_FLAG_OVERLAPPED               0x40000000
#define FILE_FLAG_WRITE_THROUGH            0x80000000

#define REPLACEFILE_WRITE_THROUGH       0x00000001
#define REPLACEFILE_IGNORE_MERGE_ERRORS 0x00000002

#define MAX_PATH 260

#define INVALID_SET_FILE_POINTER ((guint32) 0xFFFFFFFF)
#define INVALID_FILE_SIZE        ((guint32) 0xFFFFFFFF)
#define INVALID_FILE_ATTRIBUTES  ((guint32) 0xFFFFFFFF)

#define FILE_TYPE_UNKNOWN 0x0000
#define FILE_TYPE_DISK    0x0001
#define FILE_TYPE_CHAR    0x0002
#define FILE_TYPE_PIPE    0x0003
#define FILE_TYPE_REMOTE  0x8000

#define FILE_BEGIN   0
#define FILE_CURRENT 1
#define FILE_END     2

#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6

typedef struct {
	guint16 wYear;
	guint16 wMonth;
	guint16 wDayOfWeek;
	guint16 wDay;
	guint16 wHour;
	guint16 wMinute;
	guint16 wSecond;
	guint16 wMilliseconds;
} SYSTEMTIME;

typedef struct {
#if G_BYTE_ORDER == G_BIG_ENDIAN
	guint32 dwHighDateTime;
	guint32 dwLowDateTime;
#else
	guint32 dwLowDateTime;
	guint32 dwHighDateTime;
#endif
} FILETIME;

typedef struct {
	guint32 dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	guint32 nFileSizeHigh;
	guint32 nFileSizeLow;
	guint32 dwReserved0;
	guint32 dwReserved1;
	gunichar2 cFileName [MAX_PATH];
	gunichar2 cAlternateFileName [14];
} WIN32_FIND_DATA;

#endif /* !defined(HOST_WIN32) */

void
mono_w32file_init (void);

void
mono_w32file_cleanup (void);

gpointer
mono_w32file_create(const gunichar2 *name, guint32 fileaccess, guint32 sharemode, guint32 createmode, guint32 attrs);

gboolean
mono_w32file_cancel (gpointer handle);

gboolean
mono_w32file_close (gpointer handle);

gboolean
mono_w32file_delete (const gunichar2 *name);

gboolean
mono_w32file_read (gpointer handle, gpointer buffer, guint32 numbytes, guint32 *bytesread, gint32 *win32error);

gboolean
mono_w32file_write (gpointer handle, gconstpointer buffer, guint32 numbytes, guint32 *byteswritten, gint32 *win32error);

gboolean
mono_w32file_flush (gpointer handle);

gboolean
mono_w32file_truncate (gpointer handle);

guint32
mono_w32file_seek (gpointer handle, gint32 movedistance, gint32 *highmovedistance, guint32 method);

gboolean
mono_w32file_move (const gunichar2 *path, const gunichar2 *dest, gint32 *error);

gboolean
mono_w32file_copy (const gunichar2 *path, const gunichar2 *dest, gboolean overwrite, gint32 *error);

gboolean
mono_w32file_lock (gpointer handle, gint64 position, gint64 length, gint32 *error);

gboolean
mono_w32file_replace (const gunichar2 *destination_file_name, const gunichar2 *source_file_name, const gunichar2 *destination_backup_file_name, guint32 flags, gint32 *error);

gboolean
mono_w32file_unlock (gpointer handle, gint64 position, gint64 length, gint32 *error);

gpointer
mono_w32file_get_console_output (void);

gpointer
mono_w32file_get_console_error (void);

gpointer
mono_w32file_get_console_input (void);

gint64
mono_w32file_get_file_size (gpointer handle, gint32 *error);

gint
mono_w32file_get_type (gpointer handle);

gboolean
mono_w32file_set_times (gpointer handle, const FILETIME *create_time, const FILETIME *access_time, const FILETIME *write_time);

gboolean
mono_w32file_filetime_to_systemtime (const FILETIME *file_time, SYSTEMTIME *system_time);

gpointer
mono_w32file_find_first (const gunichar2 *pattern, WIN32_FIND_DATA *find_data);

gboolean
mono_w32file_find_next (gpointer handle, WIN32_FIND_DATA *find_data);

gboolean
mono_w32file_find_close (gpointer handle);

gboolean
mono_w32file_create_directory (const gunichar2 *name);

gboolean
mono_w32file_remove_directory (const gunichar2 *name);

guint32
mono_w32file_get_attributes (const gunichar2 *name);

gboolean
mono_w32file_get_attributes_ex (const gunichar2 *name, MonoIOStat *stat);

gboolean
mono_w32file_set_attributes (const gunichar2 *name, guint32 attrs);

guint32
mono_w32file_get_cwd (guint32 length, gunichar2 *buffer);

gboolean
mono_w32file_set_cwd (const gunichar2 *path);

gboolean
mono_w32file_create_pipe (gpointer *readpipe, gpointer *writepipe, guint32 size);

gint32
mono_w32file_get_logical_drive (guint32 len, gunichar2 *buf);

#ifndef PLATFORM_NO_DRIVEINFO
gboolean
mono_w32file_get_disk_free_space (const gunichar2 *path_name, guint64 *free_bytes_avail, guint64 *total_number_of_bytes, guint64 *total_number_of_free_bytes);
#endif // PLATFORM_NO_DRIVEINFO

gboolean
mono_w32file_get_file_system_type (const gunichar2 *path, gunichar2 *fsbuffer, gint fsbuffersize);

#endif /* _MONO_METADATA_W32FILE_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32handle-namespace.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32HANDLE_NAMESPACE_H_
#define _MONO_METADATA_W32HANDLE_NAMESPACE_H_

#include <config.h>
#include <glib.h>

#include "mono/metadata/w32handle.h"

#define MONO_W32HANDLE_NAMESPACE_MAX_PATH 260

typedef struct {
	gchar name [MONO_W32HANDLE_NAMESPACE_MAX_PATH + 1];
} MonoW32HandleNamespace;

void
mono_w32handle_namespace_init (void);

void
mono_w32handle_namespace_lock (void);

void
mono_w32handle_namespace_unlock (void);

gpointer
mono_w32handle_namespace_search_handle (MonoW32Type type, const gchar *name);

#endif /* _MONO_METADATA_W32HANDLE_NAMESPACE_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32handle.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32HANDLE_H_
#define _MONO_METADATA_W32HANDLE_H_

#include <config.h>
#include <glib.h>

#ifdef HOST_WIN32
#include <windows.h>
#else
#define INVALID_HANDLE_VALUE ((gpointer)-1)
#endif

#include "mono/utils/mono-coop-mutex.h"
#include "mono/utils/mono-error.h"

#define MONO_W32HANDLE_MAXIMUM_WAIT_OBJECTS 64
#define MONO_INFINITE_WAIT ((guint32) 0xFFFFFFFF)

typedef enum {
	MONO_W32TYPE_UNUSED = 0,
	MONO_W32TYPE_SEM,
	MONO_W32TYPE_MUTEX,
	MONO_W32TYPE_EVENT,
	MONO_W32TYPE_PROCESS,
	MONO_W32TYPE_NAMEDMUTEX,
	MONO_W32TYPE_NAMEDSEM,
	MONO_W32TYPE_NAMEDEVENT,
	MONO_W32TYPE_COUNT
} MonoW32Type;

typedef struct {
	MonoW32Type type;
	guint ref;
	gboolean signalled;
	gboolean in_use;
	MonoCoopMutex signal_mutex;
	MonoCoopCond signal_cond;
	gpointer specific;
} MonoW32Handle;

typedef enum {
	MONO_W32HANDLE_WAIT_RET_SUCCESS_0   =  0,
	MONO_W32HANDLE_WAIT_RET_ABANDONED_0 =  MONO_W32HANDLE_WAIT_RET_SUCCESS_0 + MONO_W32HANDLE_MAXIMUM_WAIT_OBJECTS,
	MONO_W32HANDLE_WAIT_RET_ALERTED     = -1,
	MONO_W32HANDLE_WAIT_RET_TIMEOUT     = -2,
	MONO_W32HANDLE_WAIT_RET_FAILED      = -3,
	MONO_W32HANDLE_WAIT_RET_TOO_MANY_POSTS = -4,
	MONO_W32HANDLE_WAIT_RET_NOT_OWNED_BY_CALLER = -5
} MonoW32HandleWaitRet;

typedef struct 
{
	void (*close)(gpointer data);

	/* mono_w32handle_signal_and_wait */
	gint32 (*signal)(MonoW32Handle *handle_data);

	/* Called by mono_w32handle_wait_one and mono_w32handle_wait_multiple,
	 * with the handle locked (shared handles aren't locked.)
	 * Returns TRUE if ownership was established, false otherwise.
	 * If TRUE, *abandoned contains a status code such as
	 * WAIT_OBJECT_0 or WAIT_ABANDONED_0.
	 */
	gboolean (*own_handle)(MonoW32Handle *handle_data, gboolean *abandoned);

	/* Called by mono_w32handle_wait_one and mono_w32handle_wait_multiple, if the
	 * handle in question is "ownable" (ie mutexes), to see if the current
	 * thread already owns this handle
	 */
	gboolean (*is_owned)(MonoW32Handle *handle_data);

	/* Called by mono_w32handle_wait_one and mono_w32handle_wait_multiple,
	 * if the handle in question needs a special wait function
	 * instead of using the normal handle signal mechanism.
	 * Returns the mono_w32handle_wait_one return code.
	 */
	MonoW32HandleWaitRet (*special_wait)(MonoW32Handle *handle_data, guint32 timeout, gboolean *alerted);

	/* Called by mono_w32handle_wait_one and mono_w32handle_wait_multiple,
	 * if the handle in question needs some preprocessing before the
	 * signal wait.
	 */
	void (*prewait)(MonoW32Handle *handle_data);

	/* Called when dumping the handles */
	void (*details)(MonoW32Handle *handle_data);

	/* Called to get the name of the handle type */
	const char* (*type_name) (void);

	/* Called to get the size of the handle type */
	gsize (*typesize) (void);
} MonoW32HandleOps;

typedef enum {
	MONO_W32HANDLE_CAP_WAIT         = 0x01,
	MONO_W32HANDLE_CAP_SIGNAL       = 0x02,
	MONO_W32HANDLE_CAP_OWN          = 0x04,
	MONO_W32HANDLE_CAP_SPECIAL_WAIT = 0x08,
} MonoW32HandleCapability;

void
mono_w32handle_init (void);

void
mono_w32handle_cleanup (void);

void
mono_w32handle_register_ops (MonoW32Type type, const MonoW32HandleOps *ops);

gpointer
mono_w32handle_new (MonoW32Type type, gpointer handle_specific);

gpointer
mono_w32handle_duplicate (MonoW32Handle *handle_data);

gboolean
mono_w32handle_close (gpointer handle);

const gchar*
mono_w32handle_get_typename (MonoW32Type type);

gboolean
mono_w32handle_lookup_and_ref (gpointer handle, MonoW32Handle **handle_data);

void
mono_w32handle_unref (MonoW32Handle *handle_data);

void
mono_w32handle_foreach (gboolean (*on_each)(MonoW32Handle *handle_data, gpointer user_data), gpointer user_data);

void
mono_w32handle_dump (void);

void
mono_w32handle_register_capabilities (MonoW32Type type, MonoW32HandleCapability caps);

void
mono_w32handle_set_signal_state (MonoW32Handle *handle_data, gboolean state, gboolean broadcast);

gboolean
mono_w32handle_issignalled (MonoW32Handle *handle_data);

void
mono_w32handle_lock (MonoW32Handle *handle_data);

gboolean
mono_w32handle_trylock (MonoW32Handle *handle_data);

void
mono_w32handle_unlock (MonoW32Handle *handle_data);

MonoW32HandleWaitRet
mono_w32handle_wait_one (gpointer handle, guint32 timeout, gboolean alertable);

MonoW32HandleWaitRet
mono_w32handle_wait_multiple (gpointer *handles, gsize nhandles, gboolean waitall, guint32 timeout, gboolean alertable, MonoError *error);

MonoW32HandleWaitRet
mono_w32handle_signal_and_wait (gpointer signal_handle, gpointer wait_handle, guint32 timeout, gboolean alertable);

#ifdef HOST_WIN32
static inline MonoW32HandleWaitRet
mono_w32handle_convert_wait_ret (guint32 res, guint32 numobjects)
{
	if (res >= WAIT_OBJECT_0 && res <= WAIT_OBJECT_0 + numobjects - 1)
		return (MonoW32HandleWaitRet)(MONO_W32HANDLE_WAIT_RET_SUCCESS_0 + (res - WAIT_OBJECT_0));
	else if (res >= WAIT_ABANDONED_0 && res <= WAIT_ABANDONED_0 + numobjects - 1)
		return (MonoW32HandleWaitRet)(MONO_W32HANDLE_WAIT_RET_ABANDONED_0 + (res - WAIT_ABANDONED_0));
	else if (res == WAIT_IO_COMPLETION)
		return MONO_W32HANDLE_WAIT_RET_ALERTED;
	else if (res == WAIT_TIMEOUT)
		return MONO_W32HANDLE_WAIT_RET_TIMEOUT;
	else if (res == WAIT_FAILED)
		return MONO_W32HANDLE_WAIT_RET_FAILED;
	else
		g_error ("%s: unknown res value %d", __func__, res);
}
#endif


#endif /* _MONO_METADATA_W32HANDLE_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32mutex.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32MUTEX_H_
#define _MONO_METADATA_W32MUTEX_H_

#include <config.h>
#include <glib.h>

#include "object.h"
#include "object-internals.h"
#include "w32handle-namespace.h"
#include <mono/metadata/icalls.h>

void
mono_w32mutex_init (void);

ICALL_EXPORT
MonoBoolean
ves_icall_System_Threading_Mutex_ReleaseMutex_internal (gpointer handle);

typedef struct MonoW32HandleNamedMutex MonoW32HandleNamedMutex;

MonoW32HandleNamespace*
mono_w32mutex_get_namespace (MonoW32HandleNamedMutex *mutex);

#ifndef HOST_WIN32
void
mono_w32mutex_abandon (MonoInternalThread *internal);
#endif

#endif /* _MONO_METADATA_W32MUTEX_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32process-internals.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32PROCESS_INTERNALS_H_
#define _MONO_METADATA_W32PROCESS_INTERNALS_H_

#include <config.h>
#include <glib.h>

#ifndef HOST_WIN32

typedef struct {
	guint32 dwSignature; /* Should contain 0xFEEF04BD on le machines */
	guint32 dwStrucVersion;
	guint32 dwFileVersionMS;
	guint32 dwFileVersionLS;
	guint32 dwProductVersionMS;
	guint32 dwProductVersionLS;
	guint32 dwFileFlagsMask;
	guint32 dwFileFlags;
	guint32 dwFileOS;
	guint32 dwFileType;
	guint32 dwFileSubtype;
	guint32 dwFileDateMS;
	guint32 dwFileDateLS;
} VS_FIXEDFILEINFO;

typedef struct {
	gpointer lpBaseOfDll;
	guint32 SizeOfImage;
	gpointer EntryPoint;
} MODULEINFO;

#define VS_FF_DEBUG		0x0001
#define VS_FF_PRERELEASE	0x0002
#define VS_FF_PATCHED		0x0004
#define VS_FF_PRIVATEBUILD	0x0008
#define VS_FF_INFOINFERRED	0x0010
#define VS_FF_SPECIALBUILD	0x0020

guint32
mono_w32process_get_pid (gpointer handle);

gboolean
mono_w32process_try_get_modules (gpointer process, gpointer *modules, guint32 size, guint32 *needed);

gboolean
mono_w32process_module_get_name (gpointer process, gpointer module, gunichar2 **str, guint32 *len);

gboolean
mono_w32process_module_get_filename (gpointer process, gpointer module, gunichar2 **str, guint32 *len);

gboolean
mono_w32process_module_get_information (gpointer process, gpointer module, MODULEINFO *modinfo, guint32 size);

gboolean
mono_w32process_get_fileversion_info (const gunichar2 *filename, gpointer *data);

gboolean
mono_w32process_ver_query_value (gconstpointer datablock, const gunichar2 *subblock, gpointer *buffer, guint32 *len);

guint32
mono_w32process_ver_language_name (guint32 lang, gunichar2 *lang_out, guint32 lang_len);

#endif /* HOST_WIN32 */

#endif /* _MONO_METADATA_W32PROCESS_INTERNALS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32process-unix-internals.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32PROCESS_UNIX_INTERNALS_H_
#define _MONO_METADATA_W32PROCESS_UNIX_INTERNALS_H_

#include <config.h>
#include <glib.h>

/*
 * FOR EXCLUSIVE USE BY w32process-unix.c
 */

#if defined(HOST_DARWIN)
#define USE_OSX_BACKEND
#elif (defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(HAVE_LINK_H)
#define USE_BSD_BACKEND
#elif defined(__HAIKU__)
#define USE_HAIKU_BACKEND
/* Define header for team_info */
#include <os/kernel/OS.h>
#else
#define USE_DEFAULT_BACKEND
#endif

typedef struct {
	gpointer address_start;
	gpointer address_end;
	gchar *perms;
	gpointer address_offset;
	guint64 device;
	guint64 inode;
	gchar *filename;
} MonoW32ProcessModule;

gchar*
mono_w32process_get_name (pid_t pid);

GSList*
mono_w32process_get_modules (pid_t pid);

void
mono_w32process_platform_init_once (void);

static void G_GNUC_UNUSED
mono_w32process_module_free (MonoW32ProcessModule *module)
{
	g_free (module->perms);
	g_free (module->filename);
	g_free (module);
}

/*
 * Used to look through the GSList* returned by mono_w32process_get_modules
 */
static gint G_GNUC_UNUSED
mono_w32process_module_equals (gconstpointer a, gconstpointer b)
{
	MonoW32ProcessModule *want = (MonoW32ProcessModule *)a;
	MonoW32ProcessModule *compare = (MonoW32ProcessModule *)b;
	return (want->device == compare->device && want->inode == compare->inode) ? 0 : 1;
}

#endif /* _MONO_METADATA_W32PROCESS_UNIX_INTERNALS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32process.h`:

```h
/**
 * \file
 * System.Diagnostics.Process support
 *
 * Author:
 *	Dick Porter (dick@ximian.com)
 *
 * (C) 2002 Ximian, Inc.
 */

#ifndef _MONO_METADATA_W32PROCESS_H_
#define _MONO_METADATA_W32PROCESS_H_

#include <config.h>
#include <glib.h>

#if HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#include <mono/metadata/object.h>
#include "object-internals.h"
#include "marshal.h"

typedef enum {
	MONO_W32PROCESS_PRIORITY_CLASS_NORMAL       = 0x0020,
	MONO_W32PROCESS_PRIORITY_CLASS_IDLE         = 0x0040,
	MONO_W32PROCESS_PRIORITY_CLASS_HIGH         = 0x0080,
	MONO_W32PROCESS_PRIORITY_CLASS_REALTIME     = 0x0100,
	MONO_W32PROCESS_PRIORITY_CLASS_BELOW_NORMAL = 0x4000,
	MONO_W32PROCESS_PRIORITY_CLASS_ABOVE_NORMAL = 0x8000,
} MonoW32ProcessPriorityClass;

typedef struct 
{
	gpointer process_handle;
	guint32 pid; /* Contains mono_w32error_get_last () on failure */
	MonoArray *env_variables;
	MonoString *username;
	MonoString *domain;
	mono_bstr password; /* BSTR from SecureString in 2.0 profile */
	MonoBoolean load_user_profile;
} MonoW32ProcessInfo;

typedef struct
{
	MonoObject object;
	MonoString *filename;
	MonoString *arguments;
	MonoString *working_directory;
	MonoString *verb;
	guint32 window_style;
	MonoBoolean error_dialog;
	gpointer error_dialog_parent_handle;
	MonoBoolean use_shell_execute;

	MonoString *unused_username;
	MonoString *unused_domain;
	MonoObject *unused_password; /* SecureString in 2.0 profile, dummy in 1.x */
	MonoString *unused_password_in_clear_text;
	MonoBoolean unused_load_user_profile;
	MonoBoolean unused_redirect_standard_input;
	MonoBoolean unused_redirect_standard_output;
	MonoBoolean unused_redirect_standard_error;
	MonoObject *unused_encoding_stdout;
	MonoObject *unused_encoding_stderr;

	MonoBoolean create_no_window;

	MonoObject *unused_weak_parent_process;
	MonoObject *unused_envVars;

} MonoW32ProcessStartInfo;

TYPED_HANDLE_DECL (MonoW32ProcessStartInfo);

typedef uint32_t gchandle_t; // FIXME use this more, make it typesafe.

typedef struct _MonoCreateProcessCoop {
	gunichar2 *filename;
	gunichar2 *arguments;
	gunichar2 *working_directory;
	gunichar2 *verb;
	gunichar2 *username;
	gunichar2 *domain;
	struct {
		MonoStringHandle filename;
		MonoStringHandle arguments;
		MonoStringHandle working_directory;
		MonoStringHandle verb;
		MonoStringHandle username;
		MonoStringHandle domain;
	} coophandle;
	struct {
		gchandle_t filename;
		gchandle_t arguments;
		gchandle_t working_directory;
		gchandle_t verb;
		gchandle_t username;
		gchandle_t domain;
	} gchandle;
	struct {
		gsize filename;
		gsize arguments;
		gsize working_directory;
		gsize verb;
		gsize username;
		gsize domain;
	} length;
} MonoCreateProcessCoop;

void
mono_createprocess_coop_init (MonoCreateProcessCoop *coop, MonoW32ProcessStartInfoHandle proc_start_info, MonoW32ProcessInfo *process_info);

void
mono_createprocess_coop_cleanup (MonoCreateProcessCoop *coop);

void
mono_w32process_init (void);

void
mono_w32process_cleanup (void);

void
mono_w32process_signal_finished (void);

#ifndef HOST_WIN32

void
mono_w32process_set_cli_launcher (gchar *path);

gchar*
mono_w32process_get_path (pid_t pid);

#endif
#endif /* _MONO_METADATA_W32PROCESS_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32semaphore.h`:

```h
/**
 * \file
 */

#ifndef _MONO_METADATA_W32SEMAPHORE_H_
#define _MONO_METADATA_W32SEMAPHORE_H_

#include <config.h>
#include <glib.h>
#include "object.h"
#include "w32handle-namespace.h"
#include <mono/metadata/icalls.h>

void
mono_w32semaphore_init (void);

typedef struct MonoW32HandleNamedSemaphore MonoW32HandleNamedSemaphore;

MonoW32HandleNamespace*
mono_w32semaphore_get_namespace (MonoW32HandleNamedSemaphore *semaphore);

#endif /* _MONO_METADATA_W32SEMAPHORE_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32socket-internals.h`:

```h
/**
 * \file
 *
 * Copyright 2016 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#ifndef __MONO_METADATA_W32SOCKET_INTERNALS_H__
#define __MONO_METADATA_W32SOCKET_INTERNALS_H__

#include <config.h>
#include <glib.h>

#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#include <mono/utils/w32api.h>

#ifndef HAVE_SOCKLEN_T
#define socklen_t int
#endif

#ifndef HOST_WIN32

#define TF_DISCONNECT 0x01
#define TF_REUSE_SOCKET 0x02

typedef struct {
	gpointer Head;
	guint32 HeadLength;
	gpointer Tail;
	guint32 TailLength;
} TRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

typedef struct {
	guint32 Data1;
	guint16 Data2;
	guint16 Data3;
	guint8 Data4[8];
} GUID;

typedef struct {
	guint32 Internal;
	guint32 InternalHigh;
	guint32 Offset;
	guint32 OffsetHigh;
	gpointer hEvent;
	gpointer handle1;
	gpointer handle2;
} OVERLAPPED;

#endif

void
mono_w32socket_initialize (void);

void
mono_w32socket_cleanup (void);

SOCKET
mono_w32socket_accept (SOCKET s, struct sockaddr *addr, socklen_t *addrlen, gboolean blocking);

int
mono_w32socket_connect (SOCKET s, const struct sockaddr *name, int namelen, gboolean blocking);

int
mono_w32socket_recv (SOCKET s, char *buf, int len, int flags, gboolean blocking);

int
mono_w32socket_recvfrom (SOCKET s, char *buf, int len, int flags, struct sockaddr *from, socklen_t *fromlen, gboolean blocking);

int
mono_w32socket_recvbuffers (SOCKET s, LPWSABUF lpBuffers, guint32 dwBufferCount, guint32 *lpNumberOfBytesRecvd, guint32 *lpFlags, gpointer lpOverlapped, gpointer lpCompletionRoutine, gboolean blocking);

int
mono_w32socket_send (SOCKET s, void *buf, int len, int flags, gboolean blocking);

int
mono_w32socket_sendto (SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen, gboolean blocking);

int
mono_w32socket_sendbuffers (SOCKET s, LPWSABUF lpBuffers, guint32 dwBufferCount, guint32 *lpNumberOfBytesRecvd, guint32 lpFlags, gpointer lpOverlapped, gpointer lpCompletionRoutine, gboolean blocking);

#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT | HAVE_UWP_WINAPI_SUPPORT)

BOOL
mono_w32socket_transmit_file (SOCKET hSocket, gpointer hFile, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, guint32 dwReserved, gboolean blocking);

#endif

#ifndef HOST_WIN32

SOCKET
mono_w32socket_socket (int domain, int type, int protocol);

gint
mono_w32socket_bind (SOCKET sock, struct sockaddr *addr, socklen_t addrlen);

gint
mono_w32socket_getpeername (SOCKET sock, struct sockaddr *name, socklen_t *namelen);

gint
mono_w32socket_getsockname (SOCKET sock, struct sockaddr *name, socklen_t *namelen);

gint
mono_w32socket_getsockopt (SOCKET sock, gint level, gint optname, gpointer optval, socklen_t *optlen);

gint
mono_w32socket_setsockopt (SOCKET sock, gint level, gint optname, gconstpointer optval, socklen_t optlen);

gint
mono_w32socket_listen (SOCKET sock, gint backlog);

gint
mono_w32socket_shutdown (SOCKET sock, gint how);

gint
mono_w32socket_ioctl (SOCKET sock, gint32 command, gchar *input, gint inputlen, gchar *output, gint outputlen, glong *written);

gboolean
mono_w32socket_close (SOCKET sock);

#endif /* HOST_WIN32 */

gint
mono_w32socket_disconnect (SOCKET sock, gboolean reuse);

gint
mono_w32socket_set_blocking (SOCKET socket, gboolean blocking);

gint
mono_w32socket_get_available (SOCKET socket, guint64 *amount);

void
mono_w32socket_set_last_error (gint32 error);

gint32
mono_w32socket_get_last_error (void);

gint32
mono_w32socket_convert_error (gint error);

gboolean
mono_w32socket_duplicate (gpointer handle, gint32 targetProcessId, gpointer *duplicate_handle);

#endif // __MONO_METADATA_W32SOCKET_INTERNALS_H__

```

`Hazel/vendor/mono/include/mono/metadata/w32socket.h`:

```h
/**
 * \file
 * System.Net.Sockets.Socket support
 *
 * Author:
 *	Dick Porter (dick@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 */

#ifndef _MONO_METADATA_W32SOCKET_H_
#define _MONO_METADATA_W32SOCKET_H_

#include <config.h>
#include <glib.h>
#include <mono/metadata/object-internals.h>
#include <mono/metadata/icalls.h>

#ifndef HOST_WIN32
#define INVALID_SOCKET ((SOCKET)(guint32)(~0))
#define SOCKET_ERROR (-1)

typedef gint SOCKET;

typedef struct {
	guint32 len;
	gpointer buf;
} WSABUF, *LPWSABUF;
#endif

/* This is a copy of System.Net.Sockets.SocketType */
typedef enum {
	SocketType_Stream=1,
	SocketType_Dgram=2,
	SocketType_Raw=3,
	SocketType_Rdm=4,
	SocketType_Seqpacket=5,
	SocketType_Unknown=-1
} MonoSocketType;

/* This is a copy of System.Net.Sockets.AddressFamily */
typedef enum {
	AddressFamily_Unknown=-1,
	AddressFamily_Unspecified=0,
	AddressFamily_Unix=1,
	AddressFamily_InterNetwork=2,
	AddressFamily_ImpLink=3,
	AddressFamily_Pup=4,
	AddressFamily_Chaos=5,
	AddressFamily_NS=6,
	AddressFamily_Ipx=6,
	AddressFamily_Iso=7,
	AddressFamily_Osi=7,
	AddressFamily_Ecma=8,
	AddressFamily_DataKit=9,
	AddressFamily_Ccitt=10,
	AddressFamily_Sna=11,
	AddressFamily_DecNet=12,
	AddressFamily_DataLink=13,
	AddressFamily_Lat=14,
	AddressFamily_HyperChannel=15,
	AddressFamily_AppleTalk=16,
	AddressFamily_NetBios=17,
	AddressFamily_VoiceView=18,
	AddressFamily_FireFox=19,
	AddressFamily_Banyan=21,
	AddressFamily_Atm=22,
	AddressFamily_InterNetworkV6=23,
	AddressFamily_Cluster=24,
	AddressFamily_Ieee12844=25,
	AddressFamily_Irda=26,
	AddressFamily_NetworkDesigners=28
} MonoAddressFamily;

/* This is a copy of System.Net.Sockets.ProtocolType */
typedef enum {
	ProtocolType_IP=0,
	ProtocolType_Icmp=1,
	ProtocolType_Igmp=2,
	ProtocolType_Ggp=3,
	ProtocolType_Tcp=6,
	ProtocolType_Pup=12,
	ProtocolType_Udp=17,
	ProtocolType_Idp=22,
	ProtocolType_IPv6=41,
	ProtocolType_ND=77,
	ProtocolType_Raw=255,
	ProtocolType_Unspecified=0,
	ProtocolType_Ipx=1000,
	ProtocolType_Spx=1256,
	ProtocolType_SpxII=1257,
	ProtocolType_Unknown=-1
} MonoProtocolType;

/* This is a copy of System.Net.Sockets.SocketOptionLevel */
typedef enum {
	SocketOptionLevel_Socket=65535,
	SocketOptionLevel_IP=0,
	SocketOptionLevel_IPv6=41,
	SocketOptionLevel_Tcp=6,
	SocketOptionLevel_Udp=17
} MonoSocketOptionLevel;

/* This is a copy of System.Net.Sockets.SocketOptionName */
typedef enum {
	SocketOptionName_Debug=1,
	SocketOptionName_AcceptConnection=2,
	SocketOptionName_ReuseAddress=4,
	SocketOptionName_KeepAlive=8,
	SocketOptionName_DontRoute=16,
	SocketOptionName_IPProtectionLevel = 23,
	SocketOptionName_IPv6Only = 27,
	SocketOptionName_Broadcast=32,
	SocketOptionName_UseLoopback=64,
	SocketOptionName_Linger=128,
	SocketOptionName_OutOfBandInline=256,
	SocketOptionName_DontLinger= -129,
	SocketOptionName_ExclusiveAddressUse= -5,
	SocketOptionName_SendBuffer= 4097,
	SocketOptionName_ReceiveBuffer=4098,
	SocketOptionName_SendLowWater=4099,
	SocketOptionName_ReceiveLowWater=4100,
	SocketOptionName_SendTimeout=4101,
	SocketOptionName_ReceiveTimeout=4102,
	SocketOptionName_Error=4103,
	SocketOptionName_Type=4104,
	SocketOptionName_MaxConnections=2147483647,
	SocketOptionName_IPOptions=1,
	SocketOptionName_HeaderIncluded=2,
	SocketOptionName_TypeOfService=3,
	SocketOptionName_IpTimeToLive=4,
	SocketOptionName_MulticastInterface=9,
	SocketOptionName_MulticastTimeToLive=10,
	SocketOptionName_MulticastLoopback=11,
	SocketOptionName_AddMembership=12,
	SocketOptionName_DropMembership=13,
	SocketOptionName_DontFragment=14,
	SocketOptionName_AddSourceMembership=15,
	SocketOptionName_DropSourceMembership=16,
	SocketOptionName_BlockSource=17,
	SocketOptionName_UnblockSource=18,
	SocketOptionName_PacketInformation=19,
	SocketOptionName_NoDelay=1,
	SocketOptionName_BsdUrgent=2,
	SocketOptionName_Expedited=2,
	SocketOptionName_NoChecksum=1,
	SocketOptionName_ChecksumCoverage=20,
	SocketOptionName_HopLimit=21,

	/* This is Mono-specific, keep it in sync with
	 * Mono.Posix/PeerCred.cs
	 */
	SocketOptionName_PeerCred=10001
} MonoSocketOptionName;

/* This is a copy of System.Net.Sockets.SocketFlags */
typedef enum {
	SocketFlags_None = 0x0000,
	SocketFlags_OutOfBand = 0x0001,
	SocketFlags_MaxIOVectorLength = 0x0010,
	SocketFlags_Peek = 0x0002,
	SocketFlags_DontRoute = 0x0004,
	SocketFlags_Partial = 0x8000
} MonoSocketFlags;

typedef struct
{
	MonoObject obj;
	gint pid;
	gint uid;
	gint gid;
} MonoPeerCredData;

/* Safely access Mono.Posix.PeerCredData from native code */
TYPED_HANDLE_DECL (MonoPeerCredData);

ICALL_EXPORT
gint32
ves_icall_System_Net_Sockets_SocketException_WSAGetLastError_icall (void);

void
mono_network_init(void);

void
mono_network_cleanup(void);

#endif /* _MONO_METADATA_W32SOCKET_H_ */

```

`Hazel/vendor/mono/include/mono/metadata/w32subset.h`:

```h
/**
 * \file
 * Define Win32 API subset defaults.
 * Other subsetters can fork this file, or
 * define symbols ahead of it, or after it (with undef).
 *
 * Note that #if of an undefined symbols is defined as if 0,
 * so that an implicit default here.
 *
 * Copyright 2018 Microsoft
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#ifndef HAVE_API_SUPPORT_WIN32_GET_COMPUTER_NAME
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_GET_COMPUTER_NAME 1
#else
#define HAVE_API_SUPPORT_WIN32_GET_COMPUTER_NAME 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_GET_DRIVE_TYPE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_GET_DRIVE_TYPE 1
#else
#define HAVE_API_SUPPORT_WIN32_GET_DRIVE_TYPE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_REPLACE_FILE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_REPLACE_FILE 1
#else
#define HAVE_API_SUPPORT_WIN32_REPLACE_FILE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_COPY_FILE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_COPY_FILE 1
#else
#define HAVE_API_SUPPORT_WIN32_COPY_FILE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_COPY_FILE2 // not on Windows7
#if G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_COPY_FILE2 1
#else
#define HAVE_API_SUPPORT_WIN32_COPY_FILE2 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_LOCK_FILE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_LOCK_FILE 1
#else
#define HAVE_API_SUPPORT_WIN32_LOCK_FILE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_UNLOCK_FILE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_UNLOCK_FILE 1
#else
#define HAVE_API_SUPPORT_WIN32_UNLOCK_FILE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_MOVE_FILE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_MOVE_FILE 1
#else
#define HAVE_API_SUPPORT_WIN32_MOVE_FILE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_MOVE_FILE_EX
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_MOVE_FILE_EX 1
#else
#define HAVE_API_SUPPORT_WIN32_MOVE_FILE_EX 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_GET_STD_HANDLE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_GET_STD_HANDLE 1
#else
#define HAVE_API_SUPPORT_WIN32_GET_STD_HANDLE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_GET_FILE_SIZE_EX
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) || G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_GET_FILE_SIZE_EX 1
#else
#define HAVE_API_SUPPORT_WIN32_GET_FILE_SIZE_EX 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_GET_LOGICAL_DRIVE_STRINGS
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_GET_LOGICAL_DRIVE_STRINGS 1
#else
#define HAVE_API_SUPPORT_WIN32_GET_LOGICAL_DRIVE_STRINGS 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_SH_GET_FOLDER_PATH
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_SH_GET_FOLDER_PATH 1
#else
#define HAVE_API_SUPPORT_WIN32_SH_GET_FOLDER_PATH 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_SEND_MESSAGE_TIMEOUT
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_SEND_MESSAGE_TIMEOUT 1
#else
#define HAVE_API_SUPPORT_WIN32_SEND_MESSAGE_TIMEOUT 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_WAIT_FOR_INPUT_IDLE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_WAIT_FOR_INPUT_IDLE 1
#else
#define HAVE_API_SUPPORT_WIN32_WAIT_FOR_INPUT_IDLE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_SIGNAL_OBJECT_AND_WAIT
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_SIGNAL_OBJECT_AND_WAIT 1
#else
#define HAVE_API_SUPPORT_WIN32_SIGNAL_OBJECT_AND_WAIT 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_MSG_WAIT_FOR_MULTIPLE_OBJECTS
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_MSG_WAIT_FOR_MULTIPLE_OBJECTS 1
#else
#define HAVE_API_SUPPORT_WIN32_MSG_WAIT_FOR_MULTIPLE_OBJECTS 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_SET_ERROR_MODE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_SET_ERROR_MODE 1
#else
#define HAVE_API_SUPPORT_WIN32_SET_ERROR_MODE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_LOAD_LIBRARY
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_LOAD_LIBRARY 1
#else
#define HAVE_API_SUPPORT_WIN32_LOAD_LIBRARY 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_LOAD_PACKAGED_LIBRARY
#if G_HAVE_API_SUPPORT(HAVE_UWP_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_LOAD_PACKAGED_LIBRARY 1
#else
#define HAVE_API_SUPPORT_WIN32_LOAD_PACKAGED_LIBRARY 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_GET_MODULE_HANDLE
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_GET_MODULE_HANDLE 1
#else
#define HAVE_API_SUPPORT_WIN32_GET_MODULE_HANDLE 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_SET_THREAD_CONTEXT
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_SET_THREAD_CONTEXT 1
#else
#define HAVE_API_SUPPORT_WIN32_SET_THREAD_CONTEXT 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_CANCEL_SYNCHRONOUS_IO
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_CANCEL_SYNCHRONOUS_IO 1
#else
#define HAVE_API_SUPPORT_WIN32_CANCEL_SYNCHRONOUS_IO 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_OPEN_THREAD
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_OPEN_THREAD 1
#else
#define HAVE_API_SUPPORT_WIN32_OPEN_THREAD 0
#endif
#endif

#ifndef HAVE_API_SUPPORT_WIN32_IS_WOW64_PROCESS
#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT)
#define HAVE_API_SUPPORT_WIN32_IS_WOW64_PROCESS 1
#else
#define HAVE_API_SUPPORT_WIN32_IS_WOW64_PROCESS 0
#endif
#endif

#ifndef HAVE_SET_THREAD_DESCRIPTION
#define HAVE_SET_THREAD_DESCRIPTION 0
#endif

#ifndef HAVE_SET_THREAD_NAME
// https://github.com/microsoft/xbox-live-api/blob/90b38b434d9c13ce4916c116cd28a98b239e38e2/InProgressSamples/Kits/ATGTK/ThreadHelpers.h#L21
#if defined(_XBOX_ONE) && defined(_TITLE)
#define HAVE_SET_THREAD_NAME 1
#else
#define HAVE_SET_THREAD_NAME 0
#endif
#endif

```

`Hazel/vendor/mono/include/mono/metadata/wrapper-types.h`:

```h
/**
 * \file
 * NOTE NOTE NOTE
 * No additional wrapper types should be added.
 * If a new wrapper is asolutely necessary, an existing one needs
 * to be removed first (with all the change that implies).
 */
WRAPPER(NONE, "none")
WRAPPER(DELEGATE_INVOKE, "delegate-invoke")
WRAPPER(DELEGATE_BEGIN_INVOKE, "delegate-begin-invoke")
WRAPPER(DELEGATE_END_INVOKE, "delegate-end-invoke")
WRAPPER(RUNTIME_INVOKE, "runtime-invoke")
WRAPPER(NATIVE_TO_MANAGED, "native-to-managed")
WRAPPER(MANAGED_TO_NATIVE, "managed-to-native")
WRAPPER(MANAGED_TO_MANAGED, "managed-to-managed")
WRAPPER(REMOTING_INVOKE, "remoting-invoke")
WRAPPER(REMOTING_INVOKE_WITH_CHECK, "remoting-invoke-with-check")
WRAPPER(XDOMAIN_INVOKE, "xdomain-invoke")
WRAPPER(XDOMAIN_DISPATCH, "xdomain-dispatch")
WRAPPER(LDFLD, "ldfld")
WRAPPER(STFLD, "stfld")
WRAPPER(SYNCHRONIZED, "synchronized")
WRAPPER(DYNAMIC_METHOD, "dynamic-method")
WRAPPER(CASTCLASS, "castclass")
WRAPPER(PROXY_ISINST, "proxy_isinst")
WRAPPER(STELEMREF, "stelemref")
WRAPPER(UNBOX, "unbox")
WRAPPER(LDFLDA, "ldflda")
WRAPPER(WRITE_BARRIER, "write-barrier")
WRAPPER(OTHER, "other")
WRAPPER(COMINTEROP_INVOKE, "cominterop-invoke")
WRAPPER(COMINTEROP, "cominterop")
WRAPPER(ALLOC, "alloc")



```

`Hazel/vendor/mono/include/mono/utils/mono-counters.h`:

```h
/**
 * \file
 */

#ifndef __MONO_COUNTERS_H__
#define __MONO_COUNTERS_H__

#include <stdio.h>
#include <mono/utils/mono-publib.h>

enum {
	/* Counter type, bits 0-7. */
	MONO_COUNTER_INT,    /* 32 bit int */
	MONO_COUNTER_UINT,    /* 32 bit uint */
	MONO_COUNTER_WORD,   /* pointer-sized int */
	MONO_COUNTER_LONG,   /* 64 bit int */
	MONO_COUNTER_ULONG,   /* 64 bit uint */
	MONO_COUNTER_DOUBLE,
	MONO_COUNTER_STRING, /* char* */
	MONO_COUNTER_TIME_INTERVAL, /* 64 bits signed int holding usecs. */
	MONO_COUNTER_TYPE_MASK = 0xf,
	MONO_COUNTER_CALLBACK = 128, /* ORed with the other values */
	MONO_COUNTER_SECTION_MASK = 0x00ffff00,
	/* Sections, bits 8-23 (16 bits) */
	MONO_COUNTER_JIT      = 1 << 8,
	MONO_COUNTER_GC       = 1 << 9,
	MONO_COUNTER_METADATA = 1 << 10,
	MONO_COUNTER_GENERICS = 1 << 11,
	MONO_COUNTER_SECURITY = 1 << 12,
	MONO_COUNTER_RUNTIME  = 1 << 13,
	MONO_COUNTER_SYSTEM   = 1 << 14,
	MONO_COUNTER_PERFCOUNTERS = 1 << 15,
	MONO_COUNTER_PROFILER = 1 << 16,
	MONO_COUNTER_INTERP   = 1 << 17,
	MONO_COUNTER_TIERED   = 1 << 18,
	MONO_COUNTER_LAST_SECTION,

	/* Unit, bits 24-27 (4 bits) */
	MONO_COUNTER_UNIT_SHIFT = 24,
	MONO_COUNTER_UNIT_MASK = 0xFu << MONO_COUNTER_UNIT_SHIFT,
	MONO_COUNTER_RAW        = 0 << 24,  /* Raw value */
	MONO_COUNTER_BYTES      = 1 << 24, /* Quantity of bytes. RSS, active heap, etc */
	MONO_COUNTER_TIME       = 2 << 24,  /* Time interval in 100ns units. Minor pause, JIT compilation*/
	MONO_COUNTER_COUNT      = 3 << 24, /*  Number of things (threads, queued jobs) or Number of events triggered (Major collections, Compiled methods).*/
	MONO_COUNTER_PERCENTAGE = 4 << 24, /* [0-1] Fraction Percentage of something. Load average. */

	/* Monotonicity, bits 28-31 (4 bits) */
	MONO_COUNTER_VARIANCE_SHIFT = 28,
	MONO_COUNTER_VARIANCE_MASK = 0xFu << MONO_COUNTER_VARIANCE_SHIFT,
	MONO_COUNTER_MONOTONIC      = 1 << 28, /* This counter value always increase/decreases over time. Reported by --stat. */
	MONO_COUNTER_CONSTANT       = 1 << 29, /* Fixed value. Used by configuration data. */
	MONO_COUNTER_VARIABLE       = 1 << 30, /* This counter value can be anything on each sampling. Only interesting when sampling. */
};

typedef struct _MonoCounter MonoCounter;

MONO_API void mono_counters_enable (int section_mask);
MONO_API void mono_counters_init (void);

/* 
 * register addr as the address of a counter of type type.
 * It may be a function pointer if MONO_COUNTER_CALLBACK is specified:
 * the function should return the value and take no arguments.
 */
MONO_API void mono_counters_register (const char* descr, int type, void *addr);
MONO_API void mono_counters_register_with_size (const char *name, int type, void *addr, int size);

typedef void (*MonoCounterRegisterCallback) (MonoCounter*);
MONO_API void mono_counters_on_register (MonoCounterRegisterCallback callback);

/* 
 * Create a readable dump of the counters for section_mask sections (ORed section values)
 */
MONO_API void mono_counters_dump (int section_mask, FILE *outfile);

MONO_API void mono_counters_cleanup (void);

typedef mono_bool (*CountersEnumCallback) (MonoCounter *counter, void *user_data);

MONO_API void mono_counters_foreach (CountersEnumCallback cb, void *user_data);

MONO_API int mono_counters_sample (MonoCounter *counter, void *buffer, int buffer_size);

MONO_API const char* mono_counter_get_name (MonoCounter *name);
MONO_API int mono_counter_get_type (MonoCounter *counter);
MONO_API int mono_counter_get_section (MonoCounter *counter);
MONO_API int mono_counter_get_unit (MonoCounter *counter);
MONO_API int mono_counter_get_variance (MonoCounter *counter);
MONO_API size_t mono_counter_get_size (MonoCounter *counter);

typedef enum {
	MONO_RESOURCE_JIT_CODE, /* bytes */
	MONO_RESOURCE_METADATA, /* bytes */
	MONO_RESOURCE_GC_HEAP,  /* bytes */
	MONO_RESOURCE_COUNT /* non-ABI value */
} MonoResourceType;

typedef void (*MonoResourceCallback) (int resource_type, uintptr_t value, int is_soft);

MONO_API int  mono_runtime_resource_limit        (int resource_type, uintptr_t soft_limit, uintptr_t hard_limit);
MONO_API void mono_runtime_resource_set_callback (MonoResourceCallback callback);
MONO_API void mono_runtime_resource_check_limit  (int resource_type, uintptr_t value);

#endif /* __MONO_COUNTERS_H__ */


```

`Hazel/vendor/mono/include/mono/utils/mono-dl-fallback.h`:

```h
/**
 * \file
 */

#ifndef __MONO_UTILS_DL_FALLBACK_H__
#define __MONO_UTILS_DL_FALLBACK_H__

#include <mono/utils/mono-publib.h>

MONO_BEGIN_DECLS

enum {
	MONO_DL_EAGER  = 0,
	MONO_DL_LAZY   = 1,
	// If MONO_DL_LOCAL is set, it will trump MONO_DL_GLOBAL.
	MONO_DL_LOCAL  = 2,
	// MONO_DL_MASK is unused internally and no longer a full mask on netcore, given the introduction of MONO_DL_GLOBAL. Avoid.
	MONO_DL_MASK   = 3,
	// Only applicable when building Mono in netcore mode.
	MONO_DL_GLOBAL = 4
};

/*
 * This is the dynamic loader fallback API
 */
typedef struct MonoDlFallbackHandler MonoDlFallbackHandler;

/*
 * The "err" variable contents must be allocated using g_malloc or g_strdup
 */
typedef void* (*MonoDlFallbackLoad) (const char *name, int flags, char **err, void *user_data);
typedef void* (*MonoDlFallbackSymbol) (void *handle, const char *name, char **err, void *user_data);
typedef void* (*MonoDlFallbackClose) (void *handle, void *user_data);

MONO_API MonoDlFallbackHandler *mono_dl_fallback_register (MonoDlFallbackLoad load_func, MonoDlFallbackSymbol symbol_func,
						  MonoDlFallbackClose close_func, void *user_data);

MONO_API void                   mono_dl_fallback_unregister (MonoDlFallbackHandler *handler);

MONO_END_DECLS

#endif /* __MONO_UTILS_DL_FALLBACK_H__ */


```

`Hazel/vendor/mono/include/mono/utils/mono-error.h`:

```h
/**
 * \file
 */

#ifndef __MONO_ERROR_H__
#define __MONO_ERROR_H__

#include <mono/utils/mono-publib.h>

enum {
	/*
	The supplied strings were dup'd by means of calling mono_error_dup_strings.
	*/
	MONO_ERROR_FREE_STRINGS = 0x0001,

	/*
	Something happened while processing the error and the resulting message is incomplete.
	*/
	MONO_ERROR_INCOMPLETE = 0x0002,
	/*
	This MonoError is heap allocated in a mempool
        */
	MONO_ERROR_MEMPOOL_BOXED = 0x0004
};

enum {
	MONO_ERROR_NONE = 0,
	MONO_ERROR_MISSING_METHOD = 1,
	MONO_ERROR_MISSING_FIELD = 2,
	MONO_ERROR_TYPE_LOAD = 3,
	MONO_ERROR_FILE_NOT_FOUND = 4,
	MONO_ERROR_BAD_IMAGE = 5,
	MONO_ERROR_OUT_OF_MEMORY = 6,
	MONO_ERROR_ARGUMENT = 7,
	MONO_ERROR_ARGUMENT_NULL = 11,
	MONO_ERROR_ARGUMENT_OUT_OF_RANGE = 14,
	MONO_ERROR_NOT_VERIFIABLE = 8,
	MONO_ERROR_INVALID_PROGRAM = 12,
	MONO_ERROR_MEMBER_ACCESS = 13,

	/*
	 * This is a generic error mechanism is you need to raise an arbitrary corlib exception.
	 * You must pass the exception name otherwise prepare_exception will fail with internal execution. 
	 */
	MONO_ERROR_GENERIC = 9,
	/* This one encapsulates a managed exception instance */
	MONO_ERROR_EXCEPTION_INSTANCE = 10,

	/* Not a valid error code - indicates that the error was cleaned up and reused */
	MONO_ERROR_CLEANUP_CALLED_SENTINEL = 0xffff
};

#ifdef _MSC_VER
__pragma(warning (push))
__pragma(warning (disable:4201))
#endif

/*Keep in sync with MonoErrorInternal*/
typedef union _MonoError {
	// Merge two uint16 into one uint32 so it can be initialized
	// with one instruction instead of two.
	uint32_t init;
	struct {
		uint16_t error_code;
		uint16_t private_flags; /*DON'T TOUCH */
		void *hidden_1 [12]; /*DON'T TOUCH */
	};
} MonoErrorExternal;

#ifdef _MSC_VER
__pragma(warning (pop))
#endif

#ifdef MONO_INSIDE_RUNTIME
typedef union _MonoErrorInternal MonoError;
#else
typedef MonoErrorExternal MonoError;
#endif

/* Mempool-allocated MonoError.*/
typedef struct _MonoErrorBoxed MonoErrorBoxed;

MONO_BEGIN_DECLS

MONO_API MONO_RT_EXTERNAL_ONLY void
mono_error_init (MonoError *error);

MONO_API void
mono_error_init_flags (MonoError *error, unsigned short flags);

MONO_API void
mono_error_cleanup (MonoError *error);

MONO_API MONO_RT_EXTERNAL_ONLY mono_bool
mono_error_ok (MonoError *error);

MONO_API unsigned short
mono_error_get_error_code (MonoError *error);

MONO_API const char*
mono_error_get_message (MonoError *error);

MONO_END_DECLS

#endif

```

`Hazel/vendor/mono/include/mono/utils/mono-forward.h`:

```h
/**
 * \file
 *
 * (C) 2018 Microsoft, Inc.
 *
 */
#ifndef _MONO_UTILS_FORWARD_
#define _MONO_UTILS_FORWARD_

typedef struct _MonoDomain MonoDomain;
typedef struct _MonoJitInfo MonoJitInfo;

#endif

```

`Hazel/vendor/mono/include/mono/utils/mono-logger.h`:

```h
/**
 * \file
 */

#ifndef __MONO_LOGGER_H__
#define __MONO_LOGGER_H__

#include <mono/utils/mono-publib.h>
MONO_BEGIN_DECLS

MONO_API void 
mono_trace_set_level_string (const char *value);

MONO_API void 
mono_trace_set_mask_string (const char *value);

typedef void (*MonoPrintCallback) (const char *string, mono_bool is_stdout);
typedef void (*MonoLogCallback) (const char *log_domain, const char *log_level, const char *message, mono_bool fatal, void *user_data);

MONO_API void
mono_trace_set_log_handler (MonoLogCallback callback, void *user_data);

MONO_API void
mono_trace_set_print_handler (MonoPrintCallback callback);

MONO_API void
mono_trace_set_printerr_handler (MonoPrintCallback callback);

MONO_END_DECLS

#endif /* __MONO_LOGGER_H__ */

```

`Hazel/vendor/mono/include/mono/utils/mono-publib.h`:

```h
/**
 * \file
 */

#ifndef __MONO_PUBLIB_H__
#define __MONO_PUBLIB_H__

/* 
 * Minimal general purpose header for use in public mono header files.
 * We can't include config.h, so we use compiler-specific preprocessor
 * directives where needed.
 */

#ifdef  __cplusplus
#define MONO_BEGIN_DECLS  extern "C" {
#define MONO_END_DECLS    }
#else
#define MONO_BEGIN_DECLS /* nothing */
#define MONO_END_DECLS   /* nothing */
#endif

MONO_BEGIN_DECLS

/* VS 2010 and later have stdint.h */
#if defined(_MSC_VER)

#if _MSC_VER < 1600

typedef __int8			int8_t;
typedef unsigned __int8		uint8_t;
typedef __int16			int16_t;
typedef unsigned __int16	uint16_t;
typedef __int32			int32_t;
typedef unsigned __int32	uint32_t;
typedef __int64			int64_t;
typedef unsigned __int64	uint64_t;

#else

#include <stdint.h>

#endif

#define MONO_API_EXPORT __declspec(dllexport)
#define MONO_API_IMPORT __declspec(dllimport)

#else

#include <stdint.h>

#if defined (__clang__) || defined (__GNUC__)
#define MONO_API_EXPORT __attribute__ ((__visibility__ ("default")))
#else
#define MONO_API_EXPORT
#endif
#define MONO_API_IMPORT

#endif /* end of compiler-specific stuff */

#include <stdlib.h>

#ifdef __cplusplus
#define MONO_EXTERN_C extern "C"
#else
#define MONO_EXTERN_C /* nothing */
#endif

#if defined(MONO_DLL_EXPORT)
	#define MONO_API_NO_EXTERN_C MONO_API_EXPORT
#elif defined(MONO_DLL_IMPORT)
	#define MONO_API_NO_EXTERN_C MONO_API_IMPORT
#else
	#define MONO_API_NO_EXTERN_C /* nothing  */
#endif

#define MONO_API MONO_EXTERN_C MONO_API_NO_EXTERN_C

// extern "C" extern int c; // warning: duplicate 'extern' declaration specifier [-Wduplicate-decl-specifier]
//
// Therefore, remove extern on functions as always meaningless/redundant,
// and provide MONO_API_DATA for data, that always has one and only one extern.
#ifdef __cplusplus
#define MONO_API_DATA MONO_API
#else
#define MONO_API_DATA extern MONO_API
#endif

typedef int32_t		mono_bool;
typedef uint8_t		mono_byte;
typedef mono_byte       MonoBoolean;
#ifdef _WIN32
MONO_END_DECLS
#include <wchar.h>
typedef wchar_t 	mono_unichar2;
MONO_BEGIN_DECLS
#else
typedef uint16_t	mono_unichar2;
#endif
typedef uint32_t	mono_unichar4;

typedef void	(*MonoFunc)	(void* data, void* user_data);
typedef void	(*MonoHFunc)	(void* key, void* value, void* user_data);

MONO_API void mono_free (void *);

#define MONO_ALLOCATOR_VTABLE_VERSION 1

typedef struct {
	int version;
	void *(*malloc)      (size_t size);
	void *(*realloc)     (void *mem, size_t count);
	void (*free)        (void *mem);
	void *(*calloc)      (size_t count, size_t size);
} MonoAllocatorVTable;

MONO_API mono_bool
mono_set_allocator_vtable (MonoAllocatorVTable* vtable);


#define MONO_CONST_RETURN const

/*
 * When embedding, you have to define MONO_ZERO_LEN_ARRAY before including any
 * other Mono header file if you use a different compiler from the one used to
 * build Mono.
 */
#ifndef MONO_ZERO_LEN_ARRAY
#ifdef __GNUC__
#define MONO_ZERO_LEN_ARRAY 0
#else
#define MONO_ZERO_LEN_ARRAY 1
#endif
#endif

#if defined (MONO_INSIDE_RUNTIME)

#if defined (__CENTRINEL__)
/* Centrinel is an analyzer that warns about raw pointer to managed objects
 * inside Mono.
 */
#define MONO_RT_MANAGED_ATTR __CENTRINEL_MANAGED_ATTR
#define MONO_RT_CENTRINEL_SUPPRESS __CENTRINEL_SUPPRESS_ATTR(1)
#else
#define MONO_RT_MANAGED_ATTR
#define MONO_RT_CENTRINEL_SUPPRESS
#endif

#if defined (__clang__) || defined (__GNUC__)
// attribute(deprecated(message)) was introduced in gcc 4.5.
// attribute(deprecated))         was introduced in gcc 4.0.
// Compare: https://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Function-Attributes.html
//          https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Function-Attributes.html
//          https://gcc.gnu.org/onlinedocs/gcc-4.5.0/gcc/Function-Attributes.html
#if defined (__clang__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
#define MONO_RT_EXTERNAL_ONLY \
	__attribute__ ((__deprecated__ ("The mono runtime must not call this function."))) \
	MONO_RT_CENTRINEL_SUPPRESS
#elif __GNUC__ >= 4
#define MONO_RT_EXTERNAL_ONLY __attribute__ ((__deprecated__)) MONO_RT_CENTRINEL_SUPPRESS
#else
#define MONO_RT_EXTERNAL_ONLY MONO_RT_CENTRINEL_SUPPRESS
#endif

#if defined (__clang__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
// Pragmas for controlling diagnostics appear to be from gcc 4.2.
// This is used in place of configure gcc -Werror=deprecated-declarations:
// 1. To be portable across build systems.
// 2. configure is very sensitive to compiler flags; they break autoconf's probes.
// Though #2 can be mitigated by being late in configure.
#pragma GCC diagnostic error "-Wdeprecated-declarations"
#endif

#else
#define MONO_RT_EXTERNAL_ONLY MONO_RT_CENTRINEL_SUPPRESS
#endif // clang or gcc

#else
#define MONO_RT_EXTERNAL_ONLY
#define MONO_RT_MANAGED_ATTR
#endif /* MONO_INSIDE_RUNTIME */

#if defined (__clang__) || defined (__GNUC__)
#define _MONO_DEPRECATED __attribute__ ((__deprecated__))
#elif defined (_MSC_VER)
#define _MONO_DEPRECATED __declspec (deprecated)
#else
#define _MONO_DEPRECATED
#endif

#define MONO_DEPRECATED MONO_API MONO_RT_EXTERNAL_ONLY _MONO_DEPRECATED

MONO_END_DECLS

#endif /* __MONO_PUBLIB_H__ */

```

`Hazel/vendor/stb_image/stb_image.cpp`:

```cpp
#include "hzpch.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
```

`Hazel/vendor/stb_image/stb_image.h`:

```h
/* stb_image - v2.23 - public domain image loader - http://nothings.org/stb
								  no warranty implied; use at your own risk

   Do this:
	  #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
	  Primarily of interest to game developers and other people who can
		  avoid problematic images and only need the trivial interface

	  JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
	  PNG 1/2/4/8/16-bit-per-channel

	  TGA (not sure what subset, if a subset)
	  BMP non-1bpp, non-RLE
	  PSD (composited view only, no extra channels, 8/16 bit-per-channel)

	  GIF (*comp always reports as 4-channel)
	  HDR (radiance rgbE format)
	  PIC (Softimage PIC)
	  PNM (PPM and PGM binary only)

	  Animated GIF still needs a proper API, but here's one way to do it:
		  http://gist.github.com/urraka/685d9a6340b26b830d49

	  - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
	  - decode from arbitrary I/O callbacks
	  - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

	  2.23  (2019-08-11) fix clang static analysis warning
	  2.22  (2019-03-04) gif fixes, fix warnings
	  2.21  (2019-02-25) fix typo in comment
	  2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
	  2.19  (2018-02-11) fix warning
	  2.18  (2018-01-30) fix warnings
	  2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
	  2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
	  2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
	  2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
	  2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
	  2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
	  2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
						 RGB-format JPEG; remove white matting in PSD;
						 allocate large structures on the stack;
						 correct channel count for PNG & BMP
	  2.10  (2016-01-22) avoid warning introduced in 2.09
	  2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
	Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
	Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
	Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
	Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
	Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
	Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
	Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
	github:urraka (animated gif)           Junggon Kim (PNM comments)
	Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
										   socks-the-fox (16-bit PNG)
										   Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
	Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
	Arseny Kapoulkine
	John-Mark Allen
	Carmelo J Fdez-Aguera

 Bug & warning fixes
	Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko
	Christpher Lloyd        Jerry Jansson      Joseph Thomson     Phil Jordan
	Dave Moore              Roy Eltham         Hayaki Saito       Nathan Reed
	Won Chun                Luke Graham        Johan Duparc       Nick Verigakis
	the Horde3D community   Thomas Ruf         Ronny Chevalier    github:rlyeh
	Janez Zemva             John Bartholomew   Michal Cichon      github:romigrou
	Jonathan Blow           Ken Hamada         Tero Hanninen      github:svdijk
	Laurent Gomila          Cort Stratton      Sergio Gonzalez    github:snagar
	Aruelien Pocheville     Thibault Reuille   Cass Everitt       github:Zelex
	Ryamond Barbiero        Paul Du Bois       Engin Manap        github:grim210
	Aldo Culquicondor       Philipp Wiesemann  Dale Weiler        github:sammyhw
	Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:phprus
	Julian Raschke          Gregory Mullen     Baldur Karlsson    github:poppolopoppo
	Christian Floisand      Kevin Schmidt      JR Smith           github:darealshinji
	Blazej Dariusz Roszkowski                                     github:Michaelangel007
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB, even though
// they are internally encoded differently. You can disable this conversion
// by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through (which
// is BGR stored in RGB).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//


#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
	STBI_default = 0, // only used for desired_channels

	STBI_grey = 1,
	STBI_grey_alpha = 2,
	STBI_rgb = 3,
	STBI_rgb_alpha = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

	//////////////////////////////////////////////////////////////////////////////
	//
	// PRIMARY API - works on images of any type
	//

	//
	// load image by filename, open file, or memory buffer
	//

	typedef struct
	{
		int(*read)  (void *user, char *data, int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
		void(*skip)  (void *user, int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
		int(*eof)   (void *user);                       // returns nonzero if we are at end of file/data
	} stbi_io_callbacks;

	////////////////////////////////////
	//
	// 8-bits-per-channel interface
	//

	STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc           const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
	STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
	STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
	STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
	// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
	STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
	STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

	////////////////////////////////////
	//
	// 16-bits-per-channel interface
	//

	STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
	STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
	STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
	STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

	////////////////////////////////////
	//
	// float-per-channel interface
	//
#ifndef STBI_NO_LINEAR
	STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
	STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
	STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
	STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif
#endif

#ifndef STBI_NO_HDR
	STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
	STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
	STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
	STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

	// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
	STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
	STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
	STBIDEF int      stbi_is_hdr(char const *filename);
	STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


	// get a VERY brief reason for failure
	// NOT THREADSAFE
	STBIDEF const char *stbi_failure_reason(void);

	// free the loaded image -- this is just free()
	STBIDEF void     stbi_image_free(void *retval_from_stbi_load);

	// get image dimensions & components without fully decoding
	STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
	STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
	STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
	STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
	STBIDEF int      stbi_info(char const *filename, int *x, int *y, int *comp);
	STBIDEF int      stbi_info_from_file(FILE *f, int *x, int *y, int *comp);
	STBIDEF int      stbi_is_16_bit(char const *filename);
	STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



	// for image formats that explicitly notate that they have premultiplied alpha,
	// we just return the colors as stored in the file. set this flag to force
	// unpremultiplication. results are undefined if the unpremultiply overflow.
	STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

	// indicate whether we should process iphone images back to canonical format,
	// or just pass them through "as-is"
	STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

	// flip the image vertically, so the first pixel in the output array is the bottom left
	STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

	// ZLIB client - used by PNG, available for other purposes

	STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
	STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
	STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
	STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

	STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
	STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
#ifndef STBI_ONLY_JPEG
#define STBI_NO_JPEG
#endif
#ifndef STBI_ONLY_PNG
#define STBI_NO_PNG
#endif
#ifndef STBI_ONLY_BMP
#define STBI_NO_BMP
#endif
#ifndef STBI_ONLY_PSD
#define STBI_NO_PSD
#endif
#ifndef STBI_ONLY_TGA
#define STBI_NO_TGA
#endif
#ifndef STBI_ONLY_GIF
#define STBI_NO_GIF
#endif
#ifndef STBI_ONLY_HDR
#define STBI_NO_HDR
#endif
#ifndef STBI_ONLY_PIC
#define STBI_NO_PIC
#endif
#ifndef STBI_ONLY_PNM
#define STBI_NO_PNM
#endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp, pow
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
#ifdef __cplusplus
#define stbi_inline inline
#else
#define stbi_inline
#endif
#else
#define stbi_inline __forceinline
#endif


#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32) == 4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
#define stbi_lrot(x,y)  _lrotl(x,y)
#else
#define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
	int info[4];
	__cpuid(info, 1);
	return info[3];
}
#else
static int stbi__cpuid3(void)
{
	int res;
	__asm {
		mov  eax, 1
		cpuid
		mov  res, edx
	}
	return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
	int info3 = stbi__cpuid3();
	return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
	// If we're even attempting to compile this on GCC/Clang, that means
	// -msse2 is on, which means the compiler is allowed to use SSE2
	// instructions at will, and so are we.
	return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
// assume GCC or Clang on ARM targets
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
	stbi__uint32 img_x, img_y;
	int img_n, img_out_n;

	stbi_io_callbacks io;
	void *io_user_data;

	int read_from_callbacks;
	int buflen;
	stbi_uc buffer_start[128];

	stbi_uc *img_buffer, *img_buffer_end;
	stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
	s->io.read = NULL;
	s->read_from_callbacks = 0;
	s->img_buffer = s->img_buffer_original = (stbi_uc *)buffer;
	s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *)buffer + len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
	s->io = *c;
	s->io_user_data = user;
	s->buflen = sizeof(s->buffer_start);
	s->read_from_callbacks = 1;
	s->img_buffer_original = s->buffer_start;
	stbi__refill_buffer(s);
	s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
	return (int)fread(data, 1, size, (FILE*)user);
}

static void stbi__stdio_skip(void *user, int n)
{
	fseek((FILE*)user, n, SEEK_CUR);
}

static int stbi__stdio_eof(void *user)
{
	return feof((FILE*)user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
	stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *)f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
	// conceptually rewind SHOULD rewind to the beginning of the stream,
	// but we just rewind to the beginning of the initial buffer, because
	// we only use it after doing 'test', which only ever looks at at most 92 bytes
	s->img_buffer = s->img_buffer_original;
	s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
	STBI_ORDER_RGB,
	STBI_ORDER_BGR
};

typedef struct
{
	int bits_per_channel;
	int num_channels;
	int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

// this is not threadsafe
static const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
	return stbi__g_failure_reason;
}

static int stbi__err(const char *str)
{
	stbi__g_failure_reason = str;
	return 0;
}

static void *stbi__malloc(size_t size)
{
	return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
	if (b < 0) return 0;
	// now 0 <= b <= INT_MAX, hence also
	// 0 <= INT_MAX - b <= INTMAX.
	// And "a + b <= INT_MAX" (which might overflow) is the
	// same as a <= INT_MAX - b (no overflow)
	return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
	if (a < 0 || b < 0) return 0;
	if (b == 0) return 1; // mul-by-0 is always safe
	// portable way to check for no overflows in a*b
	return a <= INT_MAX / b;
}

// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
	return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
	return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
		stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
	return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
		stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
	if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
	return stbi__malloc(a*b + add);
}

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
	if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
	return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
	if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
	return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
#define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
#define stbi__err(x,y)  stbi__err(y)
#else
#define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
	STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
	stbi__vertically_flip_on_load = flag_true_if_should_flip;
}

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
	memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
	ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
	ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
	ri->num_channels = 0;

#ifndef STBI_NO_JPEG
	if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_PNG
	if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_BMP
	if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_GIF
	if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_PSD
	if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp, ri, bpc);
#endif
#ifndef STBI_NO_PIC
	if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_PNM
	if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp, ri);
#endif

#ifndef STBI_NO_HDR
	if (stbi__hdr_test(s)) {
		float *hdr = stbi__hdr_load(s, x, y, comp, req_comp, ri);
		return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
	}
#endif

#ifndef STBI_NO_TGA
	// test tga last because it's a crappy test!
	if (stbi__tga_test(s))
		return stbi__tga_load(s, x, y, comp, req_comp, ri);
#endif

	return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
	int i;
	int img_len = w * h * channels;
	stbi_uc *reduced;

	reduced = (stbi_uc *)stbi__malloc(img_len);
	if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	for (i = 0; i < img_len; ++i)
		reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	STBI_FREE(orig);
	return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
	int i;
	int img_len = w * h * channels;
	stbi__uint16 *enlarged;

	enlarged = (stbi__uint16 *)stbi__malloc(img_len * 2);
	if (enlarged == NULL) return (stbi__uint16 *)stbi__errpuc("outofmem", "Out of memory");

	for (i = 0; i < img_len; ++i)
		enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

	STBI_FREE(orig);
	return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
	int row;
	size_t bytes_per_row = (size_t)w * bytes_per_pixel;
	stbi_uc temp[2048];
	stbi_uc *bytes = (stbi_uc *)image;

	for (row = 0; row < (h >> 1); row++) {
		stbi_uc *row0 = bytes + row * bytes_per_row;
		stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
		// swap row0 with row1
		size_t bytes_left = bytes_per_row;
		while (bytes_left) {
			size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
			memcpy(temp, row0, bytes_copy);
			memcpy(row0, row1, bytes_copy);
			memcpy(row1, temp, bytes_copy);
			row0 += bytes_copy;
			row1 += bytes_copy;
			bytes_left -= bytes_copy;
		}
	}
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
	int slice;
	int slice_size = w * h * bytes_per_pixel;

	stbi_uc *bytes = (stbi_uc *)image;
	for (slice = 0; slice < z; ++slice) {
		stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
		bytes += slice_size;
	}
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi__result_info ri;
	void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

	if (result == NULL)
		return NULL;

	if (ri.bits_per_channel != 8) {
		STBI_ASSERT(ri.bits_per_channel == 16);
		result = stbi__convert_16_to_8((stbi__uint16 *)result, *x, *y, req_comp == 0 ? *comp : req_comp);
		ri.bits_per_channel = 8;
	}

	// @TODO: move stbi__convert_format to here

	if (stbi__vertically_flip_on_load) {
		int channels = req_comp ? req_comp : *comp;
		stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
	}

	return (unsigned char *)result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi__result_info ri;
	void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

	if (result == NULL)
		return NULL;

	if (ri.bits_per_channel != 16) {
		STBI_ASSERT(ri.bits_per_channel == 8);
		result = stbi__convert_8_to_16((stbi_uc *)result, *x, *y, req_comp == 0 ? *comp : req_comp);
		ri.bits_per_channel = 16;
	}

	// @TODO: move stbi__convert_format16 to here
	// @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

	if (stbi__vertically_flip_on_load) {
		int channels = req_comp ? req_comp : *comp;
		stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
	}

	return (stbi__uint16 *)result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
	if (stbi__vertically_flip_on_load && result != NULL) {
		int channels = req_comp ? req_comp : *comp;
		stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
	}
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int)bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
	FILE *f;
#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
	wchar_t wMode[64];
	wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)))
		return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)))
		return 0;

#if _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
	f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != fopen_s(&f, filename, mode))
		f = 0;
#else
	f = fopen(filename, mode);
#endif
	return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	unsigned char *result;
	if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
	result = stbi_load_from_file(f, x, y, comp, req_comp);
	fclose(f);
	return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
	unsigned char *result;
	stbi__context s;
	stbi__start_file(&s, f);
	result = stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);
	if (result) {
		// need to 'unget' all the characters in the IO buffer
		fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);
	}
	return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
	stbi__uint16 *result;
	stbi__context s;
	stbi__start_file(&s, f);
	result = stbi__load_and_postprocess_16bit(&s, x, y, comp, req_comp);
	if (result) {
		// need to 'unget' all the characters in the IO buffer
		fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);
	}
	return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	stbi__uint16 *result;
	if (!f) return (stbi_us *)stbi__errpuc("can't fopen", "Unable to open file");
	result = stbi_load_from_file_16(f, x, y, comp, req_comp);
	fclose(f);
	return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
	unsigned char *result;
	stbi__context s;
	stbi__start_mem(&s, buffer, len);

	result = (unsigned char*)stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
	if (stbi__vertically_flip_on_load) {
		stbi__vertical_flip_slices(result, *x, *y, *z, *comp);
	}

	return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	unsigned char *data;
#ifndef STBI_NO_HDR
	if (stbi__hdr_test(s)) {
		stbi__result_info ri;
		float *hdr_data = stbi__hdr_load(s, x, y, comp, req_comp, &ri);
		if (hdr_data)
			stbi__float_postprocess(hdr_data, x, y, comp, req_comp);
		return hdr_data;
	}
#endif
	data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
	if (data)
		return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
	return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__loadf_main(&s, x, y, comp, req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__loadf_main(&s, x, y, comp, req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
	float *result;
	FILE *f = stbi__fopen(filename, "rb");
	if (!f) return stbi__errpf("can't fopen", "Unable to open file");
	result = stbi_loadf_from_file(f, x, y, comp, req_comp);
	fclose(f);
	return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s, f);
	return stbi__loadf_main(&s, x, y, comp, req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
#ifndef STBI_NO_HDR
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__hdr_test(&s);
#else
	STBI_NOTUSED(buffer);
	STBI_NOTUSED(len);
	return 0;
#endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr(char const *filename)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result = 0;
	if (f) {
		result = stbi_is_hdr_from_file(f);
		fclose(f);
	}
	return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
#ifndef STBI_NO_HDR
	long pos = ftell(f);
	int res;
	stbi__context s;
	stbi__start_file(&s, f);
	res = stbi__hdr_test(&s);
	fseek(f, pos, SEEK_SET);
	return res;
#else
	STBI_NOTUSED(f);
	return 0;
#endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
#ifndef STBI_NO_HDR
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
	return stbi__hdr_test(&s);
#else
	STBI_NOTUSED(clbk);
	STBI_NOTUSED(user);
	return 0;
#endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma = 2.2f, stbi__l2h_scale = 1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i = 1.0f / 2.2f, stbi__h2l_scale_i = 1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
	STBI__SCAN_load = 0,
	STBI__SCAN_type,
	STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
	int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);
	if (n == 0) {
		// at end of file, treat same as if from memory, but need to handle case
		// where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
		s->read_from_callbacks = 0;
		s->img_buffer = s->buffer_start;
		s->img_buffer_end = s->buffer_start + 1;
		*s->img_buffer = 0;
	}
	else {
		s->img_buffer = s->buffer_start;
		s->img_buffer_end = s->buffer_start + n;
	}
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
	if (s->img_buffer < s->img_buffer_end)
		return *s->img_buffer++;
	if (s->read_from_callbacks) {
		stbi__refill_buffer(s);
		return *s->img_buffer++;
	}
	return 0;
}

stbi_inline static int stbi__at_eof(stbi__context *s)
{
	if (s->io.read) {
		if (!(s->io.eof)(s->io_user_data)) return 0;
		// if feof() is true, check if buffer = end
		// special case: we've only got the special 0 character at the end
		if (s->read_from_callbacks == 0) return 1;
	}

	return s->img_buffer >= s->img_buffer_end;
}

static void stbi__skip(stbi__context *s, int n)
{
	if (n < 0) {
		s->img_buffer = s->img_buffer_end;
		return;
	}
	if (s->io.read) {
		int blen = (int)(s->img_buffer_end - s->img_buffer);
		if (blen < n) {
			s->img_buffer = s->img_buffer_end;
			(s->io.skip)(s->io_user_data, n - blen);
			return;
		}
	}
	s->img_buffer += n;
}

static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
	if (s->io.read) {
		int blen = (int)(s->img_buffer_end - s->img_buffer);
		if (blen < n) {
			int res, count;

			memcpy(buffer, s->img_buffer, blen);

			count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);
			res = (count == (n - blen));
			s->img_buffer = s->img_buffer_end;
			return res;
		}
	}

	if (s->img_buffer + n <= s->img_buffer_end) {
		memcpy(buffer, s->img_buffer, n);
		s->img_buffer += n;
		return 1;
	}
	else
		return 0;
}

static int stbi__get16be(stbi__context *s)
{
	int z = stbi__get8(s);
	return (z << 8) + stbi__get8(s);
}

static stbi__uint32 stbi__get32be(stbi__context *s)
{
	stbi__uint32 z = stbi__get16be(s);
	return (z << 16) + stbi__get16be(s);
}

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
	int z = stbi__get8(s);
	return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
	stbi__uint32 z = stbi__get16le(s);
	return z + (stbi__get16le(s) << 16);
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings


//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
	return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}

static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
	int i, j;
	unsigned char *good;

	if (req_comp == img_n) return data;
	STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	good = (unsigned char *)stbi__malloc_mad3(req_comp, x, y, 0);
	if (good == NULL) {
		STBI_FREE(data);
		return stbi__errpuc("outofmem", "Out of memory");
	}

	for (j = 0; j < (int)y; ++j) {
		unsigned char *src = data + j * x * img_n;
		unsigned char *dest = good + j * x * req_comp;

#define STBI__COMBO(a,b)  ((a)*8+(b))
#define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
		// convert source image with img_n components to one with req_comp components;
		// avoid switch per pixel, so use switch per scanline and massive macros
		switch (STBI__COMBO(img_n, req_comp)) {
			STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 255; } break;
			STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
			STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 255; } break;
			STBI__CASE(2, 1) { dest[0] = src[0]; } break;
			STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
			STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;
			STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 255; } break;
			STBI__CASE(3, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;
			STBI__CASE(3, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = 255; } break;
			STBI__CASE(4, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;
			STBI__CASE(4, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = src[3]; } break;
			STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;
		default: STBI_ASSERT(0);
		}
#undef STBI__CASE
	}

	STBI_FREE(data);
	return good;
}

static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
	return (stbi__uint16)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}

static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
	int i, j;
	stbi__uint16 *good;

	if (req_comp == img_n) return data;
	STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	good = (stbi__uint16 *)stbi__malloc(req_comp * x * y * 2);
	if (good == NULL) {
		STBI_FREE(data);
		return (stbi__uint16 *)stbi__errpuc("outofmem", "Out of memory");
	}

	for (j = 0; j < (int)y; ++j) {
		stbi__uint16 *src = data + j * x * img_n;
		stbi__uint16 *dest = good + j * x * req_comp;

#define STBI__COMBO(a,b)  ((a)*8+(b))
#define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
		// convert source image with img_n components to one with req_comp components;
		// avoid switch per pixel, so use switch per scanline and massive macros
		switch (STBI__COMBO(img_n, req_comp)) {
			STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 0xffff; } break;
			STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
			STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 0xffff; } break;
			STBI__CASE(2, 1) { dest[0] = src[0]; } break;
			STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
			STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;
			STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 0xffff; } break;
			STBI__CASE(3, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;
			STBI__CASE(3, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = 0xffff; } break;
			STBI__CASE(4, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;
			STBI__CASE(4, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = src[3]; } break;
			STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;
		default: STBI_ASSERT(0);
		}
#undef STBI__CASE
	}

	STBI_FREE(data);
	return good;
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
	int i, k, n;
	float *output;
	if (!data) return NULL;
	output = (float *)stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
	if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
	// compute number of non-alpha components
	if (comp & 1) n = comp; else n = comp - 1;
	for (i = 0; i < x*y; ++i) {
		for (k = 0; k < n; ++k) {
			output[i*comp + k] = (float)(pow(data[i*comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
		}
	}
	if (n < comp) {
		for (i = 0; i < x*y; ++i) {
			output[i*comp + n] = data[i*comp + n] / 255.0f;
		}
	}
	STBI_FREE(data);
	return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
	int i, k, n;
	stbi_uc *output;
	if (!data) return NULL;
	output = (stbi_uc *)stbi__malloc_mad3(x, y, comp, 0);
	if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
	// compute number of non-alpha components
	if (comp & 1) n = comp; else n = comp - 1;
	for (i = 0; i < x*y; ++i) {
		for (k = 0; k < n; ++k) {
			float z = (float)pow(data[i*comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
			if (z < 0) z = 0;
			if (z > 255) z = 255;
			output[i*comp + k] = (stbi_uc)stbi__float2int(z);
		}
		if (k < comp) {
			float z = data[i*comp + k] * 255 + 0.5f;
			if (z < 0) z = 0;
			if (z > 255) z = 255;
			output[i*comp + k] = (stbi_uc)stbi__float2int(z);
		}
	}
	STBI_FREE(data);
	return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
	stbi_uc  fast[1 << FAST_BITS];
	// weirdly, repacking this into AoS is a 10% speed loss, instead of a win
	stbi__uint16 code[256];
	stbi_uc  values[256];
	stbi_uc  size[257];
	unsigned int maxcode[18];
	int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
	stbi__context *s;
	stbi__huffman huff_dc[4];
	stbi__huffman huff_ac[4];
	stbi__uint16 dequant[4][64];
	stbi__int16 fast_ac[4][1 << FAST_BITS];

	// sizes for components, interleaved MCUs
	int img_h_max, img_v_max;
	int img_mcu_x, img_mcu_y;
	int img_mcu_w, img_mcu_h;

	// definition of jpeg image component
	struct
	{
		int id;
		int h, v;
		int tq;
		int hd, ha;
		int dc_pred;

		int x, y, w2, h2;
		stbi_uc *data;
		void *raw_data, *raw_coeff;
		stbi_uc *linebuf;
		short   *coeff;   // progressive only
		int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
	} img_comp[4];

	stbi__uint32   code_buffer; // jpeg entropy-coded buffer
	int            code_bits;   // number of valid bits
	unsigned char  marker;      // marker seen while filling entropy buffer
	int            nomore;      // flag if we saw a marker so must stop

	int            progressive;
	int            spec_start;
	int            spec_end;
	int            succ_high;
	int            succ_low;
	int            eob_run;
	int            jfif;
	int            app14_color_transform; // Adobe APP14 tag
	int            rgb;

	int scan_n, order[4];
	int restart_interval, todo;

	// kernels
	void(*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
	void(*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
	stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
	int i, j, k = 0;
	unsigned int code;
	// build size list for each symbol (from JPEG spec)
	for (i = 0; i < 16; ++i)
		for (j = 0; j < count[i]; ++j)
			h->size[k++] = (stbi_uc)(i + 1);
	h->size[k] = 0;

	// compute actual symbols (from jpeg spec)
	code = 0;
	k = 0;
	for (j = 1; j <= 16; ++j) {
		// compute delta to add to code to compute symbol id
		h->delta[j] = k - code;
		if (h->size[k] == j) {
			while (h->size[k] == j)
				h->code[k++] = (stbi__uint16)(code++);
			if (code - 1 >= (1u << j)) return stbi__err("bad code lengths", "Corrupt JPEG");
		}
		// compute largest code + 1 for this size, preshifted as needed later
		h->maxcode[j] = code << (16 - j);
		code <<= 1;
	}
	h->maxcode[j] = 0xffffffff;

	// build non-spec acceleration table; 255 is flag for not-accelerated
	memset(h->fast, 255, 1 << FAST_BITS);
	for (i = 0; i < k; ++i) {
		int s = h->size[i];
		if (s <= FAST_BITS) {
			int c = h->code[i] << (FAST_BITS - s);
			int m = 1 << (FAST_BITS - s);
			for (j = 0; j < m; ++j) {
				h->fast[c + j] = (stbi_uc)i;
			}
		}
	}
	return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
	int i;
	for (i = 0; i < (1 << FAST_BITS); ++i) {
		stbi_uc fast = h->fast[i];
		fast_ac[i] = 0;
		if (fast < 255) {
			int rs = h->values[fast];
			int run = (rs >> 4) & 15;
			int magbits = rs & 15;
			int len = h->size[fast];

			if (magbits && len + magbits <= FAST_BITS) {
				// magnitude code followed by receive_extend code
				int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
				int m = 1 << (magbits - 1);
				if (k < m) k += (~0U << magbits) + 1;
				// if the result is small enough, we can fit it in fast_ac table
				if (k >= -128 && k <= 127)
					fast_ac[i] = (stbi__int16)((k * 256) + (run * 16) + (len + magbits));
			}
		}
	}
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
	do {
		unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
		if (b == 0xff) {
			int c = stbi__get8(j->s);
			while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
			if (c != 0) {
				j->marker = (unsigned char)c;
				j->nomore = 1;
				return;
			}
		}
		j->code_buffer |= b << (24 - j->code_bits);
		j->code_bits += 8;
	} while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17] = { 0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535 };

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
	unsigned int temp;
	int c, k;

	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	// look at the top FAST_BITS and determine what symbol ID it is,
	// if the code is <= FAST_BITS
	c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
	k = h->fast[c];
	if (k < 255) {
		int s = h->size[k];
		if (s > j->code_bits)
			return -1;
		j->code_buffer <<= s;
		j->code_bits -= s;
		return h->values[k];
	}

	// naive test is to shift the code_buffer down so k bits are
	// valid, then test against maxcode. To speed this up, we've
	// preshifted maxcode left so that it has (16-k) 0s at the
	// end; in other words, regardless of the number of bits, it
	// wants to be compared against something shifted to have 16;
	// that way we don't need to shift inside the loop.
	temp = j->code_buffer >> 16;
	for (k = FAST_BITS + 1; ; ++k)
		if (temp < h->maxcode[k])
			break;
	if (k == 17) {
		// error! code not found
		j->code_bits -= 16;
		return -1;
	}

	if (k > j->code_bits)
		return -1;

	// convert the huffman code to the symbol id
	c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
	STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

	// convert the id to a symbol
	j->code_bits -= k;
	j->code_buffer <<= k;
	return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = { 0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767 };

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
	unsigned int k;
	int sgn;
	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
	k = stbi_lrot(j->code_buffer, n);
	STBI_ASSERT(n >= 0 && n < (int)(sizeof(stbi__bmask) / sizeof(*stbi__bmask)));
	j->code_buffer = k & ~stbi__bmask[n];
	k &= stbi__bmask[n];
	j->code_bits -= n;
	return k + (stbi__jbias[n] & ~sgn);
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
	unsigned int k;
	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
	k = stbi_lrot(j->code_buffer, n);
	j->code_buffer = k & ~stbi__bmask[n];
	k &= stbi__bmask[n];
	j->code_bits -= n;
	return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
	unsigned int k;
	if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
	k = j->code_buffer;
	j->code_buffer <<= 1;
	--j->code_bits;
	return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64 + 15] =
{
	0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
	int diff, dc, k;
	int t;

	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
	t = stbi__jpeg_huff_decode(j, hdc);
	if (t < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	// 0 all the ac values now so we can do it 32-bits at a time
	memset(data, 0, 64 * sizeof(data[0]));

	diff = t ? stbi__extend_receive(j, t) : 0;
	dc = j->img_comp[b].dc_pred + diff;
	j->img_comp[b].dc_pred = dc;
	data[0] = (short)(dc * dequant[0]);

	// decode AC components, see JPEG spec
	k = 1;
	do {
		unsigned int zig;
		int c, r, s;
		if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
		c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
		r = fac[c];
		if (r) { // fast-AC path
			k += (r >> 4) & 15; // run
			s = r & 15; // combined length
			j->code_buffer <<= s;
			j->code_bits -= s;
			// decode into unzigzag'd location
			zig = stbi__jpeg_dezigzag[k++];
			data[zig] = (short)((r >> 8) * dequant[zig]);
		}
		else {
			int rs = stbi__jpeg_huff_decode(j, hac);
			if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
			s = rs & 15;
			r = rs >> 4;
			if (s == 0) {
				if (rs != 0xf0) break; // end block
				k += 16;
			}
			else {
				k += r;
				// decode into unzigzag'd location
				zig = stbi__jpeg_dezigzag[k++];
				data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);
			}
		}
	} while (k < 64);
	return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
	int diff, dc;
	int t;
	if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	if (j->succ_high == 0) {
		// first scan for DC coefficient, must be first
		memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now
		t = stbi__jpeg_huff_decode(j, hdc);
		diff = t ? stbi__extend_receive(j, t) : 0;

		dc = j->img_comp[b].dc_pred + diff;
		j->img_comp[b].dc_pred = dc;
		data[0] = (short)(dc << j->succ_low);
	}
	else {
		// refinement scan for DC coefficient
		if (stbi__jpeg_get_bit(j))
			data[0] += (short)(1 << j->succ_low);
	}
	return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
	int k;
	if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	if (j->succ_high == 0) {
		int shift = j->succ_low;

		if (j->eob_run) {
			--j->eob_run;
			return 1;
		}

		k = j->spec_start;
		do {
			unsigned int zig;
			int c, r, s;
			if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
			c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
			r = fac[c];
			if (r) { // fast-AC path
				k += (r >> 4) & 15; // run
				s = r & 15; // combined length
				j->code_buffer <<= s;
				j->code_bits -= s;
				zig = stbi__jpeg_dezigzag[k++];
				data[zig] = (short)((r >> 8) << shift);
			}
			else {
				int rs = stbi__jpeg_huff_decode(j, hac);
				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
				s = rs & 15;
				r = rs >> 4;
				if (s == 0) {
					if (r < 15) {
						j->eob_run = (1 << r);
						if (r)
							j->eob_run += stbi__jpeg_get_bits(j, r);
						--j->eob_run;
						break;
					}
					k += 16;
				}
				else {
					k += r;
					zig = stbi__jpeg_dezigzag[k++];
					data[zig] = (short)(stbi__extend_receive(j, s) << shift);
				}
			}
		} while (k <= j->spec_end);
	}
	else {
		// refinement scan for these AC coefficients

		short bit = (short)(1 << j->succ_low);

		if (j->eob_run) {
			--j->eob_run;
			for (k = j->spec_start; k <= j->spec_end; ++k) {
				short *p = &data[stbi__jpeg_dezigzag[k]];
				if (*p != 0)
					if (stbi__jpeg_get_bit(j))
						if ((*p & bit) == 0) {
							if (*p > 0)
								*p += bit;
							else
								*p -= bit;
						}
			}
		}
		else {
			k = j->spec_start;
			do {
				int r, s;
				int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
				s = rs & 15;
				r = rs >> 4;
				if (s == 0) {
					if (r < 15) {
						j->eob_run = (1 << r) - 1;
						if (r)
							j->eob_run += stbi__jpeg_get_bits(j, r);
						r = 64; // force end of block
					}
					else {
						// r=15 s=0 should write 16 0s, so we just do
						// a run of 15 0s and then write s (which is 0),
						// so we don't have to do anything special here
					}
				}
				else {
					if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
					// sign bit
					if (stbi__jpeg_get_bit(j))
						s = bit;
					else
						s = -bit;
				}

				// advance by r
				while (k <= j->spec_end) {
					short *p = &data[stbi__jpeg_dezigzag[k++]];
					if (*p != 0) {
						if (stbi__jpeg_get_bit(j))
							if ((*p & bit) == 0) {
								if (*p > 0)
									*p += bit;
								else
									*p -= bit;
							}
					}
					else {
						if (r == 0) {
							*p = (short)s;
							break;
						}
						--r;
					}
				}
			} while (k <= j->spec_end);
		}
	}
	return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
	// trick to use a single test to catch both cases
	if ((unsigned int)x > 255) {
		if (x < 0) return 0;
		if (x > 255) return 255;
	}
	return (stbi_uc)x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
	int i, val[64], *v = val;
	stbi_uc *o;
	short *d = data;

	// columns
	for (i = 0; i < 8; ++i, ++d, ++v) {
		// if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
		if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0
			&& d[40] == 0 && d[48] == 0 && d[56] == 0) {
			//    no shortcut                 0     seconds
			//    (1|2|3|4|5|6|7)==0          0     seconds
			//    all separate               -0.047 seconds
			//    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
			int dcterm = d[0] * 4;
			v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
		}
		else {
			STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])
				// constants scaled things up by 1<<12; let's bring them back
				// down, but keep 2 extra bits of precision
				x0 += 512; x1 += 512; x2 += 512; x3 += 512;
			v[0] = (x0 + t3) >> 10;
			v[56] = (x0 - t3) >> 10;
			v[8] = (x1 + t2) >> 10;
			v[48] = (x1 - t2) >> 10;
			v[16] = (x2 + t1) >> 10;
			v[40] = (x2 - t1) >> 10;
			v[24] = (x3 + t0) >> 10;
			v[32] = (x3 - t0) >> 10;
		}
	}

	for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {
		// no fast case since the first 1D IDCT spread components out
		STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
			// constants scaled things up by 1<<12, plus we had 1<<2 from first
			// loop, plus horizontal and vertical each scale by sqrt(8) so together
			// we've got an extra 1<<3, so 1<<17 total we need to remove.
			// so we want to round that, which means adding 0.5 * 1<<17,
			// aka 65536. Also, we'll end up with -128 to 127 that we want
			// to encode as 0..255 by adding 128, so we'll add that before the shift
			x0 += 65536 + (128 << 17);
		x1 += 65536 + (128 << 17);
		x2 += 65536 + (128 << 17);
		x3 += 65536 + (128 << 17);
		// tried computing the shifts into temps, or'ing the temps to see
		// if any were out of range, but that was slower
		o[0] = stbi__clamp((x0 + t3) >> 17);
		o[7] = stbi__clamp((x0 - t3) >> 17);
		o[1] = stbi__clamp((x1 + t2) >> 17);
		o[6] = stbi__clamp((x1 - t2) >> 17);
		o[2] = stbi__clamp((x2 + t1) >> 17);
		o[5] = stbi__clamp((x2 - t1) >> 17);
		o[3] = stbi__clamp((x3 + t0) >> 17);
		o[4] = stbi__clamp((x3 - t0) >> 17);
	}
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
	// This is constructed to match our regular (generic) integer IDCT exactly.
	__m128i row0, row1, row2, row3, row4, row5, row6, row7;
	__m128i tmp;

	// dot product constant: even elems=x, odd elems=y
#define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

// out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
// out(1) = c1[even]*x + c1[odd]*y
#define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
#define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
#define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
#define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
#define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
#define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
#define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

#define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

	__m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
	__m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f(0.765366865f), stbi__f2f(0.5411961f));
	__m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
	__m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
	__m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f(0.298631336f), stbi__f2f(-1.961570560f));
	__m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f(3.072711026f));
	__m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f(2.053119869f), stbi__f2f(-0.390180644f));
	__m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f(1.501321110f));

	// rounding biases in column/row passes, see stbi__idct_block for explanation.
	__m128i bias_0 = _mm_set1_epi32(512);
	__m128i bias_1 = _mm_set1_epi32(65536 + (128 << 17));

	// load
	row0 = _mm_load_si128((const __m128i *) (data + 0 * 8));
	row1 = _mm_load_si128((const __m128i *) (data + 1 * 8));
	row2 = _mm_load_si128((const __m128i *) (data + 2 * 8));
	row3 = _mm_load_si128((const __m128i *) (data + 3 * 8));
	row4 = _mm_load_si128((const __m128i *) (data + 4 * 8));
	row5 = _mm_load_si128((const __m128i *) (data + 5 * 8));
	row6 = _mm_load_si128((const __m128i *) (data + 6 * 8));
	row7 = _mm_load_si128((const __m128i *) (data + 7 * 8));

	// column pass
	dct_pass(bias_0, 10);

	{
		// 16bit 8x8 transpose pass 1
		dct_interleave16(row0, row4);
		dct_interleave16(row1, row5);
		dct_interleave16(row2, row6);
		dct_interleave16(row3, row7);

		// transpose pass 2
		dct_interleave16(row0, row2);
		dct_interleave16(row1, row3);
		dct_interleave16(row4, row6);
		dct_interleave16(row5, row7);

		// transpose pass 3
		dct_interleave16(row0, row1);
		dct_interleave16(row2, row3);
		dct_interleave16(row4, row5);
		dct_interleave16(row6, row7);
	}

	// row pass
	dct_pass(bias_1, 17);

	{
		// pack
		__m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
		__m128i p1 = _mm_packus_epi16(row2, row3);
		__m128i p2 = _mm_packus_epi16(row4, row5);
		__m128i p3 = _mm_packus_epi16(row6, row7);

		// 8bit 8x8 transpose pass 1
		dct_interleave8(p0, p2); // a0e0a1e1...
		dct_interleave8(p1, p3); // c0g0c1g1...

		// transpose pass 2
		dct_interleave8(p0, p1); // a0c0e0g0...
		dct_interleave8(p2, p3); // b0d0f0h0...

		// transpose pass 3
		dct_interleave8(p0, p2); // a0b0c0d0...
		dct_interleave8(p1, p3); // a4b4c4d4...

		// store
		_mm_storel_epi64((__m128i *) out, p0); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
		_mm_storel_epi64((__m128i *) out, p2); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
		_mm_storel_epi64((__m128i *) out, p1); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
		_mm_storel_epi64((__m128i *) out, p3); out += out_stride;
		_mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
	}

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
	int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

	int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
	int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
	int16x4_t rot0_2 = vdup_n_s16(stbi__f2f(0.765366865f));
	int16x4_t rot1_0 = vdup_n_s16(stbi__f2f(1.175875602f));
	int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
	int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
	int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
	int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
	int16x4_t rot3_0 = vdup_n_s16(stbi__f2f(0.298631336f));
	int16x4_t rot3_1 = vdup_n_s16(stbi__f2f(2.053119869f));
	int16x4_t rot3_2 = vdup_n_s16(stbi__f2f(3.072711026f));
	int16x4_t rot3_3 = vdup_n_s16(stbi__f2f(1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

	// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
	row0 = vld1q_s16(data + 0 * 8);
	row1 = vld1q_s16(data + 1 * 8);
	row2 = vld1q_s16(data + 2 * 8);
	row3 = vld1q_s16(data + 3 * 8);
	row4 = vld1q_s16(data + 4 * 8);
	row5 = vld1q_s16(data + 5 * 8);
	row6 = vld1q_s16(data + 6 * 8);
	row7 = vld1q_s16(data + 7 * 8);

	// add DC bias
	row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

	// column pass
	dct_pass(vrshrn_n_s32, 10);

	// 16bit 8x8 transpose
	{
		// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
		// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

	  // pass 1
		dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
		dct_trn16(row2, row3);
		dct_trn16(row4, row5);
		dct_trn16(row6, row7);

		// pass 2
		dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
		dct_trn32(row1, row3);
		dct_trn32(row4, row6);
		dct_trn32(row5, row7);

		// pass 3
		dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
		dct_trn64(row1, row5);
		dct_trn64(row2, row6);
		dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
	}

	// row pass
	// vrshrn_n_s32 only supports shifts up to 16, we need
	// 17. so do a non-rounding shift of 16 first then follow
	// up with a rounding shift by 1.
	dct_pass(vshrn_n_s32, 16);

	{
		// pack and round
		uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
		uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
		uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
		uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
		uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
		uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
		uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
		uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

		// again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

	  // sadly can't use interleaved stores here since we only write
	  // 8 bytes to each scan line!

	  // 8x8 8-bit transpose pass 1
		dct_trn8_8(p0, p1);
		dct_trn8_8(p2, p3);
		dct_trn8_8(p4, p5);
		dct_trn8_8(p6, p7);

		// pass 2
		dct_trn8_16(p0, p2);
		dct_trn8_16(p1, p3);
		dct_trn8_16(p4, p6);
		dct_trn8_16(p5, p7);

		// pass 3
		dct_trn8_32(p0, p4);
		dct_trn8_32(p1, p5);
		dct_trn8_32(p2, p6);
		dct_trn8_32(p3, p7);

		// store
		vst1_u8(out, p0); out += out_stride;
		vst1_u8(out, p1); out += out_stride;
		vst1_u8(out, p2); out += out_stride;
		vst1_u8(out, p3); out += out_stride;
		vst1_u8(out, p4); out += out_stride;
		vst1_u8(out, p5); out += out_stride;
		vst1_u8(out, p6); out += out_stride;
		vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
	}

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
	stbi_uc x;
	if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
	x = stbi__get8(j->s);
	if (x != 0xff) return STBI__MARKER_none;
	while (x == 0xff)
		x = stbi__get8(j->s); // consume repeated 0xff fill bytes
	return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
	j->code_bits = 0;
	j->code_buffer = 0;
	j->nomore = 0;
	j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
	j->marker = STBI__MARKER_none;
	j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
	j->eob_run = 0;
	// no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
	// since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
	stbi__jpeg_reset(z);
	if (!z->progressive) {
		if (z->scan_n == 1) {
			int i, j;
			STBI_SIMD_ALIGN(short, data[64]);
			int n = z->order[0];
			// non-interleaved data, we just need to process one block at a time,
			// in trivial scanline order
			// number of blocks to do just depends on how many actual "pixels" this
			// component has, independent of interleaved MCU blocking and such
			int w = (z->img_comp[n].x + 7) >> 3;
			int h = (z->img_comp[n].y + 7) >> 3;
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					int ha = z->img_comp[n].ha;
					if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2*j * 8 + i * 8, z->img_comp[n].w2, data);
					// every data block is an MCU, so countdown the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						// if it's NOT a restart, then just bail, so we get corrupt data
						// rather than no data
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
		else { // interleaved
			int i, j, k, x, y;
			STBI_SIMD_ALIGN(short, data[64]);
			for (j = 0; j < z->img_mcu_y; ++j) {
				for (i = 0; i < z->img_mcu_x; ++i) {
					// scan an interleaved mcu... process scan_n components in order
					for (k = 0; k < z->scan_n; ++k) {
						int n = z->order[k];
						// scan out an mcu's worth of this component; that's just determined
						// by the basic H and V specified for the component
						for (y = 0; y < z->img_comp[n].v; ++y) {
							for (x = 0; x < z->img_comp[n].h; ++x) {
								int x2 = (i*z->img_comp[n].h + x) * 8;
								int y2 = (j*z->img_comp[n].v + y) * 8;
								int ha = z->img_comp[n].ha;
								if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
								z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2*y2 + x2, z->img_comp[n].w2, data);
							}
						}
					}
					// after all interleaved components, that's an interleaved MCU,
					// so now count down the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
	}
	else {
		if (z->scan_n == 1) {
			int i, j;
			int n = z->order[0];
			// non-interleaved data, we just need to process one block at a time,
			// in trivial scanline order
			// number of blocks to do just depends on how many actual "pixels" this
			// component has, independent of interleaved MCU blocking and such
			int w = (z->img_comp[n].x + 7) >> 3;
			int h = (z->img_comp[n].y + 7) >> 3;
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
					if (z->spec_start == 0) {
						if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
							return 0;
					}
					else {
						int ha = z->img_comp[n].ha;
						if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
							return 0;
					}
					// every data block is an MCU, so countdown the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
		else { // interleaved
			int i, j, k, x, y;
			for (j = 0; j < z->img_mcu_y; ++j) {
				for (i = 0; i < z->img_mcu_x; ++i) {
					// scan an interleaved mcu... process scan_n components in order
					for (k = 0; k < z->scan_n; ++k) {
						int n = z->order[k];
						// scan out an mcu's worth of this component; that's just determined
						// by the basic H and V specified for the component
						for (y = 0; y < z->img_comp[n].v; ++y) {
							for (x = 0; x < z->img_comp[n].h; ++x) {
								int x2 = (i*z->img_comp[n].h + x);
								int y2 = (j*z->img_comp[n].v + y);
								short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
								if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
									return 0;
							}
						}
					}
					// after all interleaved components, that's an interleaved MCU,
					// so now count down the restart interval
					if (--z->todo <= 0) {
						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
						if (!STBI__RESTART(z->marker)) return 1;
						stbi__jpeg_reset(z);
					}
				}
			}
			return 1;
		}
	}
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
	int i;
	for (i = 0; i < 64; ++i)
		data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
	if (z->progressive) {
		// dequantize and idct the data
		int i, j, n;
		for (n = 0; n < z->s->img_n; ++n) {
			int w = (z->img_comp[n].x + 7) >> 3;
			int h = (z->img_comp[n].y + 7) >> 3;
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
					stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2*j * 8 + i * 8, z->img_comp[n].w2, data);
				}
			}
		}
	}
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
	int L;
	switch (m) {
	case STBI__MARKER_none: // no marker found
		return stbi__err("expected marker", "Corrupt JPEG");

	case 0xDD: // DRI - specify restart interval
		if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len", "Corrupt JPEG");
		z->restart_interval = stbi__get16be(z->s);
		return 1;

	case 0xDB: // DQT - define quantization table
		L = stbi__get16be(z->s) - 2;
		while (L > 0) {
			int q = stbi__get8(z->s);
			int p = q >> 4, sixteen = (p != 0);
			int t = q & 15, i;
			if (p != 0 && p != 1) return stbi__err("bad DQT type", "Corrupt JPEG");
			if (t > 3) return stbi__err("bad DQT table", "Corrupt JPEG");

			for (i = 0; i < 64; ++i)
				z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
			L -= (sixteen ? 129 : 65);
		}
		return L == 0;

	case 0xC4: // DHT - define huffman table
		L = stbi__get16be(z->s) - 2;
		while (L > 0) {
			stbi_uc *v;
			int sizes[16], i, n = 0;
			int q = stbi__get8(z->s);
			int tc = q >> 4;
			int th = q & 15;
			if (tc > 1 || th > 3) return stbi__err("bad DHT header", "Corrupt JPEG");
			for (i = 0; i < 16; ++i) {
				sizes[i] = stbi__get8(z->s);
				n += sizes[i];
			}
			L -= 17;
			if (tc == 0) {
				if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;
				v = z->huff_dc[th].values;
			}
			else {
				if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;
				v = z->huff_ac[th].values;
			}
			for (i = 0; i < n; ++i)
				v[i] = stbi__get8(z->s);
			if (tc != 0)
				stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
			L -= n;
		}
		return L == 0;
	}

	// check for comment block or APP blocks
	if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
		L = stbi__get16be(z->s);
		if (L < 2) {
			if (m == 0xFE)
				return stbi__err("bad COM len", "Corrupt JPEG");
			else
				return stbi__err("bad APP len", "Corrupt JPEG");
		}
		L -= 2;

		if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
			static const unsigned char tag[5] = { 'J','F','I','F','\0' };
			int ok = 1;
			int i;
			for (i = 0; i < 5; ++i)
				if (stbi__get8(z->s) != tag[i])
					ok = 0;
			L -= 5;
			if (ok)
				z->jfif = 1;
		}
		else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
			static const unsigned char tag[6] = { 'A','d','o','b','e','\0' };
			int ok = 1;
			int i;
			for (i = 0; i < 6; ++i)
				if (stbi__get8(z->s) != tag[i])
					ok = 0;
			L -= 6;
			if (ok) {
				stbi__get8(z->s); // version
				stbi__get16be(z->s); // flags0
				stbi__get16be(z->s); // flags1
				z->app14_color_transform = stbi__get8(z->s); // color transform
				L -= 6;
			}
		}

		stbi__skip(z->s, L);
		return 1;
	}

	return stbi__err("unknown marker", "Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
	int i;
	int Ls = stbi__get16be(z->s);
	z->scan_n = stbi__get8(z->s);
	if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err("bad SOS component count", "Corrupt JPEG");
	if (Ls != 6 + 2 * z->scan_n) return stbi__err("bad SOS len", "Corrupt JPEG");
	for (i = 0; i < z->scan_n; ++i) {
		int id = stbi__get8(z->s), which;
		int q = stbi__get8(z->s);
		for (which = 0; which < z->s->img_n; ++which)
			if (z->img_comp[which].id == id)
				break;
		if (which == z->s->img_n) return 0; // no match
		z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff", "Corrupt JPEG");
		z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff", "Corrupt JPEG");
		z->order[i] = which;
	}

	{
		int aa;
		z->spec_start = stbi__get8(z->s);
		z->spec_end = stbi__get8(z->s); // should be 63, but might be 0
		aa = stbi__get8(z->s);
		z->succ_high = (aa >> 4);
		z->succ_low = (aa & 15);
		if (z->progressive) {
			if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
				return stbi__err("bad SOS", "Corrupt JPEG");
		}
		else {
			if (z->spec_start != 0) return stbi__err("bad SOS", "Corrupt JPEG");
			if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS", "Corrupt JPEG");
			z->spec_end = 63;
		}
	}

	return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
	int i;
	for (i = 0; i < ncomp; ++i) {
		if (z->img_comp[i].raw_data) {
			STBI_FREE(z->img_comp[i].raw_data);
			z->img_comp[i].raw_data = NULL;
			z->img_comp[i].data = NULL;
		}
		if (z->img_comp[i].raw_coeff) {
			STBI_FREE(z->img_comp[i].raw_coeff);
			z->img_comp[i].raw_coeff = 0;
			z->img_comp[i].coeff = 0;
		}
		if (z->img_comp[i].linebuf) {
			STBI_FREE(z->img_comp[i].linebuf);
			z->img_comp[i].linebuf = NULL;
		}
	}
	return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
	stbi__context *s = z->s;
	int Lf, p, i, q, h_max = 1, v_max = 1, c;
	Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len", "Corrupt JPEG"); // JPEG
	p = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit", "JPEG format not supported: 8-bit only"); // JPEG baseline
	s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
	s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width", "Corrupt JPEG"); // JPEG requires
	c = stbi__get8(s);
	if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count", "Corrupt JPEG");
	s->img_n = c;
	for (i = 0; i < c; ++i) {
		z->img_comp[i].data = NULL;
		z->img_comp[i].linebuf = NULL;
	}

	if (Lf != 8 + 3 * s->img_n) return stbi__err("bad SOF len", "Corrupt JPEG");

	z->rgb = 0;
	for (i = 0; i < s->img_n; ++i) {
		static const unsigned char rgb[3] = { 'R', 'G', 'B' };
		z->img_comp[i].id = stbi__get8(s);
		if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
			++z->rgb;
		q = stbi__get8(s);
		z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H", "Corrupt JPEG");
		z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V", "Corrupt JPEG");
		z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ", "Corrupt JPEG");
	}

	if (scan != STBI__SCAN_load) return 1;

	if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

	for (i = 0; i < s->img_n; ++i) {
		if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
		if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
	}

	// compute interleaved mcu info
	z->img_h_max = h_max;
	z->img_v_max = v_max;
	z->img_mcu_w = h_max * 8;
	z->img_mcu_h = v_max * 8;
	// these sizes can't be more than 17 bits
	z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;
	z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;

	for (i = 0; i < s->img_n; ++i) {
		// number of effective pixels (e.g. for non-interleaved MCU)
		z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;
		z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;
		// to simplify generation, we'll allocate enough memory to decode
		// the bogus oversized data from using interleaved MCUs and their
		// big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
		// discard the extra data until colorspace conversion
		//
		// img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
		// so these muls can't overflow with 32-bit ints (which we require)
		z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
		z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
		z->img_comp[i].coeff = 0;
		z->img_comp[i].raw_coeff = 0;
		z->img_comp[i].linebuf = NULL;
		z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
		if (z->img_comp[i].raw_data == NULL)
			return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));
		// align blocks for idct using mmx/sse
		z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);
		if (z->progressive) {
			// w2, h2 are multiples of 8 (see above)
			z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
			z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
			z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
			if (z->img_comp[i].raw_coeff == NULL)
				return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));
			z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);
		}
	}

	return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
	int m;
	z->jfif = 0;
	z->app14_color_transform = -1; // valid values are 0,1,2
	z->marker = STBI__MARKER_none; // initialize cached marker to empty
	m = stbi__get_marker(z);
	if (!stbi__SOI(m)) return stbi__err("no SOI", "Corrupt JPEG");
	if (scan == STBI__SCAN_type) return 1;
	m = stbi__get_marker(z);
	while (!stbi__SOF(m)) {
		if (!stbi__process_marker(z, m)) return 0;
		m = stbi__get_marker(z);
		while (m == STBI__MARKER_none) {
			// some files have extra padding after their blocks, so ok, we'll scan
			if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
			m = stbi__get_marker(z);
		}
	}
	z->progressive = stbi__SOF_progressive(m);
	if (!stbi__process_frame_header(z, scan)) return 0;
	return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
	int m;
	for (m = 0; m < 4; m++) {
		j->img_comp[m].raw_data = NULL;
		j->img_comp[m].raw_coeff = NULL;
	}
	j->restart_interval = 0;
	if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
	m = stbi__get_marker(j);
	while (!stbi__EOI(m)) {
		if (stbi__SOS(m)) {
			if (!stbi__process_scan_header(j)) return 0;
			if (!stbi__parse_entropy_coded_data(j)) return 0;
			if (j->marker == STBI__MARKER_none) {
				// handle 0s at the end of image data from IP Kamera 9060
				while (!stbi__at_eof(j->s)) {
					int x = stbi__get8(j->s);
					if (x == 255) {
						j->marker = stbi__get8(j->s);
						break;
					}
				}
				// if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
			}
		}
		else if (stbi__DNL(m)) {
			int Ld = stbi__get16be(j->s);
			stbi__uint32 NL = stbi__get16be(j->s);
			if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
			if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
		}
		else {
			if (!stbi__process_marker(j, m)) return 0;
		}
		m = stbi__get_marker(j);
	}
	if (j->progressive)
		stbi__jpeg_finish(j);
	return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
	int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	STBI_NOTUSED(out);
	STBI_NOTUSED(in_far);
	STBI_NOTUSED(w);
	STBI_NOTUSED(hs);
	return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate two samples vertically for every one in input
	int i;
	STBI_NOTUSED(hs);
	for (i = 0; i < w; ++i)
		out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);
	return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate two samples horizontally for every one in input
	int i;
	stbi_uc *input = in_near;

	if (w == 1) {
		// if only one sample, can't do any interpolation
		out[0] = out[1] = input[0];
		return out;
	}

	out[0] = input[0];
	out[1] = stbi__div4(input[0] * 3 + input[1] + 2);
	for (i = 1; i < w - 1; ++i) {
		int n = 3 * input[i] + 2;
		out[i * 2 + 0] = stbi__div4(n + input[i - 1]);
		out[i * 2 + 1] = stbi__div4(n + input[i + 1]);
	}
	out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);
	out[i * 2 + 1] = input[w - 1];

	STBI_NOTUSED(in_far);
	STBI_NOTUSED(hs);

	return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate 2x2 samples for every one in input
	int i, t0, t1;
	if (w == 1) {
		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);
		return out;
	}

	t1 = 3 * in_near[0] + in_far[0];
	out[0] = stbi__div4(t1 + 2);
	for (i = 1; i < w; ++i) {
		t0 = t1;
		t1 = 3 * in_near[i] + in_far[i];
		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);
		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);
	}
	out[w * 2 - 1] = stbi__div4(t1 + 2);

	STBI_NOTUSED(hs);

	return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// need to generate 2x2 samples for every one in input
	int i = 0, t0, t1;

	if (w == 1) {
		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);
		return out;
	}

	t1 = 3 * in_near[0] + in_far[0];
	// process groups of 8 pixels for as long as we can.
	// note we can't handle the last pixel in a row in this loop
	// because we need to handle the filter boundary conditions.
	for (; i < ((w - 1) & ~7); i += 8) {
#if defined(STBI_SSE2)
		// load and perform the vertical filtering pass
		// this uses 3*x + y = 4*x + (y - x)
		__m128i zero = _mm_setzero_si128();
		__m128i farb = _mm_loadl_epi64((__m128i *) (in_far + i));
		__m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
		__m128i farw = _mm_unpacklo_epi8(farb, zero);
		__m128i nearw = _mm_unpacklo_epi8(nearb, zero);
		__m128i diff = _mm_sub_epi16(farw, nearw);
		__m128i nears = _mm_slli_epi16(nearw, 2);
		__m128i curr = _mm_add_epi16(nears, diff); // current row

		// horizontal filter works the same based on shifted vers of current
		// row. "prev" is current row shifted right by 1 pixel; we need to
		// insert the previous pixel value (from t1).
		// "next" is current row shifted left by 1 pixel, with first pixel
		// of next block of 8 pixels added in.
		__m128i prv0 = _mm_slli_si128(curr, 2);
		__m128i nxt0 = _mm_srli_si128(curr, 2);
		__m128i prev = _mm_insert_epi16(prv0, t1, 0);
		__m128i next = _mm_insert_epi16(nxt0, 3 * in_near[i + 8] + in_far[i + 8], 7);

		// horizontal filter, polyphase implementation since it's convenient:
		// even pixels = 3*cur + prev = cur*4 + (prev - cur)
		// odd  pixels = 3*cur + next = cur*4 + (next - cur)
		// note the shared term.
		__m128i bias = _mm_set1_epi16(8);
		__m128i curs = _mm_slli_epi16(curr, 2);
		__m128i prvd = _mm_sub_epi16(prev, curr);
		__m128i nxtd = _mm_sub_epi16(next, curr);
		__m128i curb = _mm_add_epi16(curs, bias);
		__m128i even = _mm_add_epi16(prvd, curb);
		__m128i odd = _mm_add_epi16(nxtd, curb);

		// interleave even and odd pixels, then undo scaling.
		__m128i int0 = _mm_unpacklo_epi16(even, odd);
		__m128i int1 = _mm_unpackhi_epi16(even, odd);
		__m128i de0 = _mm_srli_epi16(int0, 4);
		__m128i de1 = _mm_srli_epi16(int1, 4);

		// pack and write output
		__m128i outv = _mm_packus_epi16(de0, de1);
		_mm_storeu_si128((__m128i *) (out + i * 2), outv);
#elif defined(STBI_NEON)
		// load and perform the vertical filtering pass
		// this uses 3*x + y = 4*x + (y - x)
		uint8x8_t farb = vld1_u8(in_far + i);
		uint8x8_t nearb = vld1_u8(in_near + i);
		int16x8_t diff = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
		int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
		int16x8_t curr = vaddq_s16(nears, diff); // current row

		// horizontal filter works the same based on shifted vers of current
		// row. "prev" is current row shifted right by 1 pixel; we need to
		// insert the previous pixel value (from t1).
		// "next" is current row shifted left by 1 pixel, with first pixel
		// of next block of 8 pixels added in.
		int16x8_t prv0 = vextq_s16(curr, curr, 7);
		int16x8_t nxt0 = vextq_s16(curr, curr, 1);
		int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
		int16x8_t next = vsetq_lane_s16(3 * in_near[i + 8] + in_far[i + 8], nxt0, 7);

		// horizontal filter, polyphase implementation since it's convenient:
		// even pixels = 3*cur + prev = cur*4 + (prev - cur)
		// odd  pixels = 3*cur + next = cur*4 + (next - cur)
		// note the shared term.
		int16x8_t curs = vshlq_n_s16(curr, 2);
		int16x8_t prvd = vsubq_s16(prev, curr);
		int16x8_t nxtd = vsubq_s16(next, curr);
		int16x8_t even = vaddq_s16(curs, prvd);
		int16x8_t odd = vaddq_s16(curs, nxtd);

		// undo scaling and round, then store with even/odd phases interleaved
		uint8x8x2_t o;
		o.val[0] = vqrshrun_n_s16(even, 4);
		o.val[1] = vqrshrun_n_s16(odd, 4);
		vst2_u8(out + i * 2, o);
#endif

		// "previous" value for next iter
		t1 = 3 * in_near[i + 7] + in_far[i + 7];
	}

	t0 = t1;
	t1 = 3 * in_near[i] + in_far[i];
	out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

	for (++i; i < w; ++i) {
		t0 = t1;
		t1 = 3 * in_near[i] + in_far[i];
		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);
		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);
	}
	out[w * 2 - 1] = stbi__div4(t1 + 2);

	STBI_NOTUSED(hs);

	return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
	// resample with nearest-neighbor
	int i, j;
	STBI_NOTUSED(in_far);
	for (i = 0; i < w; ++i)
		for (j = 0; j < hs; ++j)
			out[i*hs + j] = in_near[i];
	return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
	int i;
	for (i = 0; i < count; ++i) {
		int y_fixed = (y[i] << 20) + (1 << 19); // rounding
		int r, g, b;
		int cr = pcr[i] - 128;
		int cb = pcb[i] - 128;
		r = y_fixed + cr * stbi__float2fixed(1.40200f);
		g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
		b = y_fixed + cb * stbi__float2fixed(1.77200f);
		r >>= 20;
		g >>= 20;
		b >>= 20;
		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
		out[0] = (stbi_uc)r;
		out[1] = (stbi_uc)g;
		out[2] = (stbi_uc)b;
		out[3] = 255;
		out += step;
	}
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
	int i = 0;

#ifdef STBI_SSE2
	// step == 3 is pretty ugly on the final interleave, and i'm not convinced
	// it's useful in practice (you wouldn't use it for textures, for example).
	// so just accelerate step == 4 case.
	if (step == 4) {
		// this is a fairly straightforward implementation and not super-optimized.
		__m128i signflip = _mm_set1_epi8(-0x80);
		__m128i cr_const0 = _mm_set1_epi16((short)(1.40200f*4096.0f + 0.5f));
		__m128i cr_const1 = _mm_set1_epi16(-(short)(0.71414f*4096.0f + 0.5f));
		__m128i cb_const0 = _mm_set1_epi16(-(short)(0.34414f*4096.0f + 0.5f));
		__m128i cb_const1 = _mm_set1_epi16((short)(1.77200f*4096.0f + 0.5f));
		__m128i y_bias = _mm_set1_epi8((char)(unsigned char)128);
		__m128i xw = _mm_set1_epi16(255); // alpha channel

		for (; i + 7 < count; i += 8) {
			// load
			__m128i y_bytes = _mm_loadl_epi64((__m128i *) (y + i));
			__m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr + i));
			__m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb + i));
			__m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
			__m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

			// unpack to short (and left-shift cr, cb by 8)
			__m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);
			__m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
			__m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

			// color transform
			__m128i yws = _mm_srli_epi16(yw, 4);
			__m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
			__m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
			__m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
			__m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
			__m128i rws = _mm_add_epi16(cr0, yws);
			__m128i gwt = _mm_add_epi16(cb0, yws);
			__m128i bws = _mm_add_epi16(yws, cb1);
			__m128i gws = _mm_add_epi16(gwt, cr1);

			// descale
			__m128i rw = _mm_srai_epi16(rws, 4);
			__m128i bw = _mm_srai_epi16(bws, 4);
			__m128i gw = _mm_srai_epi16(gws, 4);

			// back to byte, set up for transpose
			__m128i brb = _mm_packus_epi16(rw, bw);
			__m128i gxb = _mm_packus_epi16(gw, xw);

			// transpose to interleave channels
			__m128i t0 = _mm_unpacklo_epi8(brb, gxb);
			__m128i t1 = _mm_unpackhi_epi8(brb, gxb);
			__m128i o0 = _mm_unpacklo_epi16(t0, t1);
			__m128i o1 = _mm_unpackhi_epi16(t0, t1);

			// store
			_mm_storeu_si128((__m128i *) (out + 0), o0);
			_mm_storeu_si128((__m128i *) (out + 16), o1);
			out += 32;
		}
	}
#endif

#ifdef STBI_NEON
	// in this version, step=3 support would be easy to add. but is there demand?
	if (step == 4) {
		// this is a fairly straightforward implementation and not super-optimized.
		uint8x8_t signflip = vdup_n_u8(0x80);
		int16x8_t cr_const0 = vdupq_n_s16((short)(1.40200f*4096.0f + 0.5f));
		int16x8_t cr_const1 = vdupq_n_s16(-(short)(0.71414f*4096.0f + 0.5f));
		int16x8_t cb_const0 = vdupq_n_s16(-(short)(0.34414f*4096.0f + 0.5f));
		int16x8_t cb_const1 = vdupq_n_s16((short)(1.77200f*4096.0f + 0.5f));

		for (; i + 7 < count; i += 8) {
			// load
			uint8x8_t y_bytes = vld1_u8(y + i);
			uint8x8_t cr_bytes = vld1_u8(pcr + i);
			uint8x8_t cb_bytes = vld1_u8(pcb + i);
			int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
			int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

			// expand to s16
			int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
			int16x8_t crw = vshll_n_s8(cr_biased, 7);
			int16x8_t cbw = vshll_n_s8(cb_biased, 7);

			// color transform
			int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
			int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
			int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
			int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
			int16x8_t rws = vaddq_s16(yws, cr0);
			int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
			int16x8_t bws = vaddq_s16(yws, cb1);

			// undo scaling, round, convert to byte
			uint8x8x4_t o;
			o.val[0] = vqrshrun_n_s16(rws, 4);
			o.val[1] = vqrshrun_n_s16(gws, 4);
			o.val[2] = vqrshrun_n_s16(bws, 4);
			o.val[3] = vdup_n_u8(255);

			// store, interleaving r/g/b/a
			vst4_u8(out, o);
			out += 8 * 4;
		}
	}
#endif

	for (; i < count; ++i) {
		int y_fixed = (y[i] << 20) + (1 << 19); // rounding
		int r, g, b;
		int cr = pcr[i] - 128;
		int cb = pcb[i] - 128;
		r = y_fixed + cr * stbi__float2fixed(1.40200f);
		g = y_fixed + cr * -stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
		b = y_fixed + cb * stbi__float2fixed(1.77200f);
		r >>= 20;
		g >>= 20;
		b >>= 20;
		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
		out[0] = (stbi_uc)r;
		out[1] = (stbi_uc)g;
		out[2] = (stbi_uc)b;
		out[3] = 255;
		out += step;
	}
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
	j->idct_block_kernel = stbi__idct_block;
	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
	if (stbi__sse2_available()) {
		j->idct_block_kernel = stbi__idct_simd;
		j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
		j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
	}
#endif

#ifdef STBI_NEON
	j->idct_block_kernel = stbi__idct_simd;
	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
	stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
	resample_row_func resample;
	stbi_uc *line0, *line1;
	int hs, vs;   // expansion factor in each axis
	int w_lores; // horizontal pixels pre-expansion
	int ystep;   // how far through vertical expansion we are
	int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
	unsigned int t = x * y + 128;
	return (stbi_uc)((t + (t >> 8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
	int n, decode_n, is_rgb;
	z->s->img_n = 0; // make stbi__cleanup_jpeg safe

	// validate req_comp
	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	// load a jpeg image from whichever source, but leave in YCbCr format
	if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

	// determine actual number of components to generate
	n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

	is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

	if (z->s->img_n == 3 && n < 3 && !is_rgb)
		decode_n = 1;
	else
		decode_n = z->s->img_n;

	// resample and color-convert
	{
		int k;
		unsigned int i, j;
		stbi_uc *output;
		stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

		stbi__resample res_comp[4];

		for (k = 0; k < decode_n; ++k) {
			stbi__resample *r = &res_comp[k];

			// allocate line buffer big enough for upsampling off the edges
			// with upsample factor of 4
			z->img_comp[k].linebuf = (stbi_uc *)stbi__malloc(z->s->img_x + 3);
			if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

			r->hs = z->img_h_max / z->img_comp[k].h;
			r->vs = z->img_v_max / z->img_comp[k].v;
			r->ystep = r->vs >> 1;
			r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;
			r->ypos = 0;
			r->line0 = r->line1 = z->img_comp[k].data;

			if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
			else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
			else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
			else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
			else                               r->resample = stbi__resample_row_generic;
		}

		// can't error after this so, this is safe
		output = (stbi_uc *)stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
		if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

		// now go ahead and resample
		for (j = 0; j < z->s->img_y; ++j) {
			stbi_uc *out = output + n * z->s->img_x * j;
			for (k = 0; k < decode_n; ++k) {
				stbi__resample *r = &res_comp[k];
				int y_bot = r->ystep >= (r->vs >> 1);
				coutput[k] = r->resample(z->img_comp[k].linebuf,
					y_bot ? r->line1 : r->line0,
					y_bot ? r->line0 : r->line1,
					r->w_lores, r->hs);
				if (++r->ystep >= r->vs) {
					r->ystep = 0;
					r->line0 = r->line1;
					if (++r->ypos < z->img_comp[k].y)
						r->line1 += z->img_comp[k].w2;
				}
			}
			if (n >= 3) {
				stbi_uc *y = coutput[0];
				if (z->s->img_n == 3) {
					if (is_rgb) {
						for (i = 0; i < z->s->img_x; ++i) {
							out[0] = y[i];
							out[1] = coutput[1][i];
							out[2] = coutput[2][i];
							out[3] = 255;
							out += n;
						}
					}
					else {
						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
					}
				}
				else if (z->s->img_n == 4) {
					if (z->app14_color_transform == 0) { // CMYK
						for (i = 0; i < z->s->img_x; ++i) {
							stbi_uc m = coutput[3][i];
							out[0] = stbi__blinn_8x8(coutput[0][i], m);
							out[1] = stbi__blinn_8x8(coutput[1][i], m);
							out[2] = stbi__blinn_8x8(coutput[2][i], m);
							out[3] = 255;
							out += n;
						}
					}
					else if (z->app14_color_transform == 2) { // YCCK
						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
						for (i = 0; i < z->s->img_x; ++i) {
							stbi_uc m = coutput[3][i];
							out[0] = stbi__blinn_8x8(255 - out[0], m);
							out[1] = stbi__blinn_8x8(255 - out[1], m);
							out[2] = stbi__blinn_8x8(255 - out[2], m);
							out += n;
						}
					}
					else { // YCbCr + alpha?  Ignore the fourth channel for now
						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
					}
				}
				else
					for (i = 0; i < z->s->img_x; ++i) {
						out[0] = out[1] = out[2] = y[i];
						out[3] = 255; // not used if n==3
						out += n;
					}
			}
			else {
				if (is_rgb) {
					if (n == 1)
						for (i = 0; i < z->s->img_x; ++i)
							*out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
					else {
						for (i = 0; i < z->s->img_x; ++i, out += 2) {
							out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
							out[1] = 255;
						}
					}
				}
				else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
					for (i = 0; i < z->s->img_x; ++i) {
						stbi_uc m = coutput[3][i];
						stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
						stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
						stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
						out[0] = stbi__compute_y(r, g, b);
						out[1] = 255;
						out += n;
					}
				}
				else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
					for (i = 0; i < z->s->img_x; ++i) {
						out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
						out[1] = 255;
						out += n;
					}
				}
				else {
					stbi_uc *y = coutput[0];
					if (n == 1)
						for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];
					else
						for (i = 0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
				}
			}
		}
		stbi__cleanup_jpeg(z);
		*out_x = z->s->img_x;
		*out_y = z->s->img_y;
		if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
		return output;
	}
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	unsigned char* result;
	stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
	STBI_NOTUSED(ri);
	j->s = s;
	stbi__setup_jpeg(j);
	result = load_jpeg_image(j, x, y, comp, req_comp);
	STBI_FREE(j);
	return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
	int r;
	stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
	j->s = s;
	stbi__setup_jpeg(j);
	r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
	stbi__rewind(s);
	STBI_FREE(j);
	return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
	if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
		stbi__rewind(j->s);
		return 0;
	}
	if (x) *x = j->s->img_x;
	if (y) *y = j->s->img_y;
	if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
	return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
	int result;
	stbi__jpeg* j = (stbi__jpeg*)(stbi__malloc(sizeof(stbi__jpeg)));
	j->s = s;
	result = stbi__jpeg_info_raw(j, x, y, comp);
	STBI_FREE(j);
	return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
	stbi__uint16 fast[1 << STBI__ZFAST_BITS];
	stbi__uint16 firstcode[16];
	int maxcode[17];
	stbi__uint16 firstsymbol[16];
	stbi_uc  size[288];
	stbi__uint16 value[288];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
	n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);
	n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);
	n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);
	n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);
	return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
	STBI_ASSERT(bits <= 16);
	// to bit reverse n bits, reverse 16 and shift
	// e.g. 11 bits, bit reverse and shift away 5
	return stbi__bitreverse16(v) >> (16 - bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
	int i, k = 0;
	int code, next_code[16], sizes[17];

	// DEFLATE spec for generating codes
	memset(sizes, 0, sizeof(sizes));
	memset(z->fast, 0, sizeof(z->fast));
	for (i = 0; i < num; ++i)
		++sizes[sizelist[i]];
	sizes[0] = 0;
	for (i = 1; i < 16; ++i)
		if (sizes[i] > (1 << i))
			return stbi__err("bad sizes", "Corrupt PNG");
	code = 0;
	for (i = 1; i < 16; ++i) {
		next_code[i] = code;
		z->firstcode[i] = (stbi__uint16)code;
		z->firstsymbol[i] = (stbi__uint16)k;
		code = (code + sizes[i]);
		if (sizes[i])
			if (code - 1 >= (1 << i)) return stbi__err("bad codelengths", "Corrupt PNG");
		z->maxcode[i] = code << (16 - i); // preshift for inner loop
		code <<= 1;
		k += sizes[i];
	}
	z->maxcode[16] = 0x10000; // sentinel
	for (i = 0; i < num; ++i) {
		int s = sizelist[i];
		if (s) {
			int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
			stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);
			z->size[c] = (stbi_uc)s;
			z->value[c] = (stbi__uint16)i;
			if (s <= STBI__ZFAST_BITS) {
				int j = stbi__bit_reverse(next_code[s], s);
				while (j < (1 << STBI__ZFAST_BITS)) {
					z->fast[j] = fastv;
					j += (1 << s);
				}
			}
			++next_code[s];
		}
	}
	return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
	stbi_uc *zbuffer, *zbuffer_end;
	int num_bits;
	stbi__uint32 code_buffer;

	char *zout;
	char *zout_start;
	char *zout_end;
	int   z_expandable;

	stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
	if (z->zbuffer >= z->zbuffer_end) return 0;
	return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
	do {
		STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
		z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;
		z->num_bits += 8;
	} while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
	unsigned int k;
	if (z->num_bits < n) stbi__fill_bits(z);
	k = z->code_buffer & ((1 << n) - 1);
	z->code_buffer >>= n;
	z->num_bits -= n;
	return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
	int b, s, k;
	// not resolved by fast table, so compute it the slow way
	// use jpeg approach, which requires MSbits at top
	k = stbi__bit_reverse(a->code_buffer, 16);
	for (s = STBI__ZFAST_BITS + 1; ; ++s)
		if (k < z->maxcode[s])
			break;
	if (s == 16) return -1; // invalid code!
	// code size is s, so:
	b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];
	STBI_ASSERT(z->size[b] == s);
	a->code_buffer >>= s;
	a->num_bits -= s;
	return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
	int b, s;
	if (a->num_bits < 16) stbi__fill_bits(a);
	b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
	if (b) {
		s = b >> 9;
		a->code_buffer >>= s;
		a->num_bits -= s;
		return b & 511;
	}
	return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
	char *q;
	int cur, limit, old_limit;
	z->zout = zout;
	if (!z->z_expandable) return stbi__err("output buffer limit", "Corrupt PNG");
	cur = (int)(z->zout - z->zout_start);
	limit = old_limit = (int)(z->zout_end - z->zout_start);
	while (cur + n > limit)
		limit *= 2;
	q = (char *)STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
	STBI_NOTUSED(old_limit);
	if (q == NULL) return stbi__err("outofmem", "Out of memory");
	z->zout_start = q;
	z->zout = q + cur;
	z->zout_end = q + limit;
	return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31] =
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0 };

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
	char *zout = a->zout;
	for (;;) {
		int z = stbi__zhuffman_decode(a, &a->z_length);
		if (z < 256) {
			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG"); // error in huffman codes
			if (zout >= a->zout_end) {
				if (!stbi__zexpand(a, zout, 1)) return 0;
				zout = a->zout;
			}
			*zout++ = (char)z;
		}
		else {
			stbi_uc *p;
			int len, dist;
			if (z == 256) {
				a->zout = zout;
				return 1;
			}
			z -= 257;
			len = stbi__zlength_base[z];
			if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
			z = stbi__zhuffman_decode(a, &a->z_distance);
			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG");
			dist = stbi__zdist_base[z];
			if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
			if (zout - a->zout_start < dist) return stbi__err("bad dist", "Corrupt PNG");
			if (zout + len > a->zout_end) {
				if (!stbi__zexpand(a, zout, len)) return 0;
				zout = a->zout;
			}
			p = (stbi_uc *)(zout - dist);
			if (dist == 1) { // run of one byte; common in images.
				stbi_uc v = *p;
				if (len) { do *zout++ = v; while (--len); }
			}
			else {
				if (len) { do *zout++ = *p++; while (--len); }
			}
		}
	}
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
	static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
	stbi__zhuffman z_codelength;
	stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op
	stbi_uc codelength_sizes[19];
	int i, n;

	int hlit = stbi__zreceive(a, 5) + 257;
	int hdist = stbi__zreceive(a, 5) + 1;
	int hclen = stbi__zreceive(a, 4) + 4;
	int ntot = hlit + hdist;

	memset(codelength_sizes, 0, sizeof(codelength_sizes));
	for (i = 0; i < hclen; ++i) {
		int s = stbi__zreceive(a, 3);
		codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;
	}
	if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

	n = 0;
	while (n < ntot) {
		int c = stbi__zhuffman_decode(a, &z_codelength);
		if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
		if (c < 16)
			lencodes[n++] = (stbi_uc)c;
		else {
			stbi_uc fill = 0;
			if (c == 16) {
				c = stbi__zreceive(a, 2) + 3;
				if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
				fill = lencodes[n - 1];
			}
			else if (c == 17)
				c = stbi__zreceive(a, 3) + 3;
			else {
				STBI_ASSERT(c == 18);
				c = stbi__zreceive(a, 7) + 11;
			}
			if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
			memset(lencodes + n, fill, c);
			n += c;
		}
	}
	if (n != ntot) return stbi__err("bad codelengths", "Corrupt PNG");
	if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
	if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;
	return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
	stbi_uc header[4];
	int len, nlen, k;
	if (a->num_bits & 7)
		stbi__zreceive(a, a->num_bits & 7); // discard
	 // drain the bit-packed data into header
	k = 0;
	while (a->num_bits > 0) {
		header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check
		a->code_buffer >>= 8;
		a->num_bits -= 8;
	}
	STBI_ASSERT(a->num_bits == 0);
	// now fill header the normal way
	while (k < 4)
		header[k++] = stbi__zget8(a);
	len = header[1] * 256 + header[0];
	nlen = header[3] * 256 + header[2];
	if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt", "Corrupt PNG");
	if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer", "Corrupt PNG");
	if (a->zout + len > a->zout_end)
		if (!stbi__zexpand(a, a->zout, len)) return 0;
	memcpy(a->zout, a->zbuffer, len);
	a->zbuffer += len;
	a->zout += len;
	return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
	int cmf = stbi__zget8(a);
	int cm = cmf & 15;
	/* int cinfo = cmf >> 4; */
	int flg = stbi__zget8(a);
	if ((cmf * 256 + flg) % 31 != 0) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec
	if (flg & 32) return stbi__err("no preset dict", "Corrupt PNG"); // preset dictionary not allowed in png
	if (cm != 8) return stbi__err("bad compression", "Corrupt PNG"); // DEFLATE required for png
	// window = 1 << (8 + cinfo)... but who cares, we fully buffer output
	return 1;
}

static const stbi_uc stbi__zdefault_length[288] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
	int final, type;
	if (parse_header)
		if (!stbi__parse_zlib_header(a)) return 0;
	a->num_bits = 0;
	a->code_buffer = 0;
	do {
		final = stbi__zreceive(a, 1);
		type = stbi__zreceive(a, 2);
		if (type == 0) {
			if (!stbi__parse_uncompressed_block(a)) return 0;
		}
		else if (type == 3) {
			return 0;
		}
		else {
			if (type == 1) {
				// use fixed code lengths
				if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, 288)) return 0;
				if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;
			}
			else {
				if (!stbi__compute_huffman_codes(a)) return 0;
			}
			if (!stbi__parse_huffman_block(a)) return 0;
		}
	} while (!final);
	return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
	a->zout_start = obuf;
	a->zout = obuf;
	a->zout_end = obuf + olen;
	a->z_expandable = exp;

	return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
	stbi__zbuf a;
	char *p = (char *)stbi__malloc(initial_size);
	if (p == NULL) return NULL;
	a.zbuffer = (stbi_uc *)buffer;
	a.zbuffer_end = (stbi_uc *)buffer + len;
	if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
		if (outlen) *outlen = (int)(a.zout - a.zout_start);
		return a.zout_start;
	}
	else {
		STBI_FREE(a.zout_start);
		return NULL;
	}
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
	return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
	stbi__zbuf a;
	char *p = (char *)stbi__malloc(initial_size);
	if (p == NULL) return NULL;
	a.zbuffer = (stbi_uc *)buffer;
	a.zbuffer_end = (stbi_uc *)buffer + len;
	if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
		if (outlen) *outlen = (int)(a.zout - a.zout_start);
		return a.zout_start;
	}
	else {
		STBI_FREE(a.zout_start);
		return NULL;
	}
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
	stbi__zbuf a;
	a.zbuffer = (stbi_uc *)ibuffer;
	a.zbuffer_end = (stbi_uc *)ibuffer + ilen;
	if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
		return (int)(a.zout - a.zout_start);
	else
		return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
	stbi__zbuf a;
	char *p = (char *)stbi__malloc(16384);
	if (p == NULL) return NULL;
	a.zbuffer = (stbi_uc *)buffer;
	a.zbuffer_end = (stbi_uc *)buffer + len;
	if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
		if (outlen) *outlen = (int)(a.zout - a.zout_start);
		return a.zout_start;
	}
	else {
		STBI_FREE(a.zout_start);
		return NULL;
	}
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
	stbi__zbuf a;
	a.zbuffer = (stbi_uc *)ibuffer;
	a.zbuffer_end = (stbi_uc *)ibuffer + ilen;
	if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
		return (int)(a.zout - a.zout_start);
	else
		return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
	stbi__uint32 length;
	stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
	stbi__pngchunk c;
	c.length = stbi__get32be(s);
	c.type = stbi__get32be(s);
	return c;
}

static int stbi__check_png_header(stbi__context *s)
{
	static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
	int i;
	for (i = 0; i < 8; ++i)
		if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig", "Not a PNG");
	return 1;
}

typedef struct
{
	stbi__context *s;
	stbi_uc *idata, *expanded, *out;
	int depth;
} stbi__png;


enum {
	STBI__F_none = 0,
	STBI__F_sub = 1,
	STBI__F_up = 2,
	STBI__F_avg = 3,
	STBI__F_paeth = 4,
	// synthetic filters used for first scanline to avoid needing a dummy row of 0s
	STBI__F_avg_first,
	STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
	int p = a + b - c;
	int pa = abs(p - a);
	int pb = abs(p - b);
	int pc = abs(p - c);
	if (pa <= pb && pa <= pc) return a;
	if (pb <= pc) return b;
	return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
	int bytes = (depth == 16 ? 2 : 1);
	stbi__context *s = a->s;
	stbi__uint32 i, j, stride = x * out_n*bytes;
	stbi__uint32 img_len, img_width_bytes;
	int k;
	int img_n = s->img_n; // copy it into a local for later

	int output_bytes = out_n * bytes;
	int filter_bytes = img_n * bytes;
	int width = x;

	STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);
	a->out = (stbi_uc *)stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
	if (!a->out) return stbi__err("outofmem", "Out of memory");

	if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
	img_width_bytes = (((img_n * x * depth) + 7) >> 3);
	img_len = (img_width_bytes + 1) * y;

	// we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
	// but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
	// so just check for raw_len < img_len always.
	if (raw_len < img_len) return stbi__err("not enough pixels", "Corrupt PNG");

	for (j = 0; j < y; ++j) {
		stbi_uc *cur = a->out + stride * j;
		stbi_uc *prior;
		int filter = *raw++;

		if (filter > 4)
			return stbi__err("invalid filter", "Corrupt PNG");

		if (depth < 8) {
			STBI_ASSERT(img_width_bytes <= x);
			cur += x * out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
			filter_bytes = 1;
			width = img_width_bytes;
		}
		prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

		// if first row, use special filter that doesn't sample previous row
		if (j == 0) filter = first_row_filter[filter];

		// handle first byte explicitly
		for (k = 0; k < filter_bytes; ++k) {
			switch (filter) {
			case STBI__F_none: cur[k] = raw[k]; break;
			case STBI__F_sub: cur[k] = raw[k]; break;
			case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
			case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;
			case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;
			case STBI__F_avg_first: cur[k] = raw[k]; break;
			case STBI__F_paeth_first: cur[k] = raw[k]; break;
			}
		}

		if (depth == 8) {
			if (img_n != out_n)
				cur[img_n] = 255; // first pixel
			raw += img_n;
			cur += out_n;
			prior += out_n;
		}
		else if (depth == 16) {
			if (img_n != out_n) {
				cur[filter_bytes] = 255; // first pixel top byte
				cur[filter_bytes + 1] = 255; // first pixel bottom byte
			}
			raw += filter_bytes;
			cur += output_bytes;
			prior += output_bytes;
		}
		else {
			raw += 1;
			cur += 1;
			prior += 1;
		}

		// this is a little gross, so that we don't switch per-pixel or per-component
		if (depth < 8 || img_n == out_n) {
			int nk = (width - 1)*filter_bytes;
#define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
			switch (filter) {
				// "none" filter turns into a memcpy here; make that explicit.
			case STBI__F_none:         memcpy(cur, raw, nk); break;
				STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); } break;
				STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
				STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); } break;
				STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); } break;
				STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); } break;
				STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); } break;
			}
#undef STBI__CASE
			raw += nk;
		}
		else {
			STBI_ASSERT(img_n + 1 == out_n);
#define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
			switch (filter) {
				STBI__CASE(STBI__F_none) { cur[k] = raw[k]; } break;
				STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - output_bytes]); } break;
				STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
				STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)); } break;
				STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes])); } break;
				STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - output_bytes] >> 1)); } break;
				STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0)); } break;
			}
#undef STBI__CASE

			// the loop above sets the high byte of the pixels' alpha, but for
			// 16 bit png files we also need the low byte set. we'll do that here.
			if (depth == 16) {
				cur = a->out + stride * j; // start at the beginning of the row again
				for (i = 0; i < x; ++i, cur += output_bytes) {
					cur[filter_bytes + 1] = 255;
				}
			}
		}
	}

	// we make a separate pass to expand bits to pixels; for performance,
	// this could run two scanlines behind the above code, so it won't
	// intefere with filtering but will still be in the cache.
	if (depth < 8) {
		for (j = 0; j < y; ++j) {
			stbi_uc *cur = a->out + stride * j;
			stbi_uc *in = a->out + stride * j + x * out_n - img_width_bytes;
			// unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
			// png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
			stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

			// note that the final byte might overshoot and write more data than desired.
			// we can allocate enough data that this never writes out of memory, but it
			// could also overwrite the next scanline. can it overwrite non-empty data
			// on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
			// so we need to explicitly clamp the final ones

			if (depth == 4) {
				for (k = x * img_n; k >= 2; k -= 2, ++in) {
					*cur++ = scale * ((*in >> 4));
					*cur++ = scale * ((*in) & 0x0f);
				}
				if (k > 0) *cur++ = scale * ((*in >> 4));
			}
			else if (depth == 2) {
				for (k = x * img_n; k >= 4; k -= 4, ++in) {
					*cur++ = scale * ((*in >> 6));
					*cur++ = scale * ((*in >> 4) & 0x03);
					*cur++ = scale * ((*in >> 2) & 0x03);
					*cur++ = scale * ((*in) & 0x03);
				}
				if (k > 0) *cur++ = scale * ((*in >> 6));
				if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
				if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
			}
			else if (depth == 1) {
				for (k = x * img_n; k >= 8; k -= 8, ++in) {
					*cur++ = scale * ((*in >> 7));
					*cur++ = scale * ((*in >> 6) & 0x01);
					*cur++ = scale * ((*in >> 5) & 0x01);
					*cur++ = scale * ((*in >> 4) & 0x01);
					*cur++ = scale * ((*in >> 3) & 0x01);
					*cur++ = scale * ((*in >> 2) & 0x01);
					*cur++ = scale * ((*in >> 1) & 0x01);
					*cur++ = scale * ((*in) & 0x01);
				}
				if (k > 0) *cur++ = scale * ((*in >> 7));
				if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
				if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
				if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
				if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
				if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
				if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
			}
			if (img_n != out_n) {
				int q;
				// insert alpha = 255
				cur = a->out + stride * j;
				if (img_n == 1) {
					for (q = x - 1; q >= 0; --q) {
						cur[q * 2 + 1] = 255;
						cur[q * 2 + 0] = cur[q];
					}
				}
				else {
					STBI_ASSERT(img_n == 3);
					for (q = x - 1; q >= 0; --q) {
						cur[q * 4 + 3] = 255;
						cur[q * 4 + 2] = cur[q * 3 + 2];
						cur[q * 4 + 1] = cur[q * 3 + 1];
						cur[q * 4 + 0] = cur[q * 3 + 0];
					}
				}
			}
		}
	}
	else if (depth == 16) {
		// force the image data from big-endian to platform-native.
		// this is done in a separate pass due to the decoding relying
		// on the data being untouched, but could probably be done
		// per-line during decode if care is taken.
		stbi_uc *cur = a->out;
		stbi__uint16 *cur16 = (stbi__uint16*)cur;

		for (i = 0; i < x*y*out_n; ++i, cur16++, cur += 2) {
			*cur16 = (cur[0] << 8) | cur[1];
		}
	}

	return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
	int bytes = (depth == 16 ? 2 : 1);
	int out_bytes = out_n * bytes;
	stbi_uc *final;
	int p;
	if (!interlaced)
		return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

	// de-interlacing
	final = (stbi_uc *)stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
	for (p = 0; p < 7; ++p) {
		int xorig[] = { 0,4,0,2,0,1,0 };
		int yorig[] = { 0,0,4,0,2,0,1 };
		int xspc[] = { 8,8,4,4,2,2,1 };
		int yspc[] = { 8,8,8,4,4,2,2 };
		int i, j, x, y;
		// pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
		x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];
		y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];
		if (x && y) {
			stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
			if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
				STBI_FREE(final);
				return 0;
			}
			for (j = 0; j < y; ++j) {
				for (i = 0; i < x; ++i) {
					int out_y = j * yspc[p] + yorig[p];
					int out_x = i * xspc[p] + xorig[p];
					memcpy(final + out_y * a->s->img_x*out_bytes + out_x * out_bytes,
						a->out + (j*x + i)*out_bytes, out_bytes);
				}
			}
			STBI_FREE(a->out);
			image_data += img_len;
			image_data_len -= img_len;
		}
	}
	a->out = final;

	return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
	stbi__context *s = z->s;
	stbi__uint32 i, pixel_count = s->img_x * s->img_y;
	stbi_uc *p = z->out;

	// compute color-based transparency, assuming we've
	// already got 255 as the alpha value in the output
	STBI_ASSERT(out_n == 2 || out_n == 4);

	if (out_n == 2) {
		for (i = 0; i < pixel_count; ++i) {
			p[1] = (p[0] == tc[0] ? 0 : 255);
			p += 2;
		}
	}
	else {
		for (i = 0; i < pixel_count; ++i) {
			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
				p[3] = 0;
			p += 4;
		}
	}
	return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
	stbi__context *s = z->s;
	stbi__uint32 i, pixel_count = s->img_x * s->img_y;
	stbi__uint16 *p = (stbi__uint16*)z->out;

	// compute color-based transparency, assuming we've
	// already got 65535 as the alpha value in the output
	STBI_ASSERT(out_n == 2 || out_n == 4);

	if (out_n == 2) {
		for (i = 0; i < pixel_count; ++i) {
			p[1] = (p[0] == tc[0] ? 0 : 65535);
			p += 2;
		}
	}
	else {
		for (i = 0; i < pixel_count; ++i) {
			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
				p[3] = 0;
			p += 4;
		}
	}
	return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
	stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
	stbi_uc *p, *temp_out, *orig = a->out;

	p = (stbi_uc *)stbi__malloc_mad2(pixel_count, pal_img_n, 0);
	if (p == NULL) return stbi__err("outofmem", "Out of memory");

	// between here and free(out) below, exitting would leak
	temp_out = p;

	if (pal_img_n == 3) {
		for (i = 0; i < pixel_count; ++i) {
			int n = orig[i] * 4;
			p[0] = palette[n];
			p[1] = palette[n + 1];
			p[2] = palette[n + 2];
			p += 3;
		}
	}
	else {
		for (i = 0; i < pixel_count; ++i) {
			int n = orig[i] * 4;
			p[0] = palette[n];
			p[1] = palette[n + 1];
			p[2] = palette[n + 2];
			p[3] = palette[n + 3];
			p += 4;
		}
	}
	STBI_FREE(a->out);
	a->out = temp_out;

	STBI_NOTUSED(len);

	return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
	stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
	stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
	stbi__context *s = z->s;
	stbi__uint32 i, pixel_count = s->img_x * s->img_y;
	stbi_uc *p = z->out;

	if (s->img_out_n == 3) {  // convert bgr to rgb
		for (i = 0; i < pixel_count; ++i) {
			stbi_uc t = p[0];
			p[0] = p[2];
			p[2] = t;
			p += 3;
		}
	}
	else {
		STBI_ASSERT(s->img_out_n == 4);
		if (stbi__unpremultiply_on_load) {
			// convert bgr to rgb and unpremultiply
			for (i = 0; i < pixel_count; ++i) {
				stbi_uc a = p[3];
				stbi_uc t = p[0];
				if (a) {
					stbi_uc half = a / 2;
					p[0] = (p[2] * 255 + half) / a;
					p[1] = (p[1] * 255 + half) / a;
					p[2] = (t * 255 + half) / a;
				}
				else {
					p[0] = p[2];
					p[2] = t;
				}
				p += 4;
			}
		}
		else {
			// convert bgr to rgb
			for (i = 0; i < pixel_count; ++i) {
				stbi_uc t = p[0];
				p[0] = p[2];
				p[2] = t;
				p += 4;
			}
		}
	}
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
	stbi_uc palette[1024], pal_img_n = 0;
	stbi_uc has_trans = 0, tc[3] = { 0 };
	stbi__uint16 tc16[3];
	stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;
	int first = 1, k, interlace = 0, color = 0, is_iphone = 0;
	stbi__context *s = z->s;

	z->expanded = NULL;
	z->idata = NULL;
	z->out = NULL;

	if (!stbi__check_png_header(s)) return 0;

	if (scan == STBI__SCAN_type) return 1;

	for (;;) {
		stbi__pngchunk c = stbi__get_chunk_header(s);
		switch (c.type) {
		case STBI__PNG_TYPE('C', 'g', 'B', 'I'):
			is_iphone = 1;
			stbi__skip(s, c.length);
			break;
		case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {
			int comp, filter;
			if (!first) return stbi__err("multiple IHDR", "Corrupt PNG");
			first = 0;
			if (c.length != 13) return stbi__err("bad IHDR len", "Corrupt PNG");
			s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");
			s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");
			z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only", "PNG not supported: 1/2/4/8/16-bit only");
			color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype", "Corrupt PNG");
			if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype", "Corrupt PNG");
			if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype", "Corrupt PNG");
			comp = stbi__get8(s);  if (comp) return stbi__err("bad comp method", "Corrupt PNG");
			filter = stbi__get8(s);  if (filter) return stbi__err("bad filter method", "Corrupt PNG");
			interlace = stbi__get8(s); if (interlace > 1) return stbi__err("bad interlace method", "Corrupt PNG");
			if (!s->img_x || !s->img_y) return stbi__err("0-pixel image", "Corrupt PNG");
			if (!pal_img_n) {
				s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
				if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
				if (scan == STBI__SCAN_header) return 1;
			}
			else {
				// if paletted, then pal_n is our final components, and
				// img_n is # components to decompress/filter.
				s->img_n = 1;
				if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large", "Corrupt PNG");
				// if SCAN_header, have to scan to see if we have a tRNS
			}
			break;
		}

		case STBI__PNG_TYPE('P', 'L', 'T', 'E'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (c.length > 256 * 3) return stbi__err("invalid PLTE", "Corrupt PNG");
			pal_len = c.length / 3;
			if (pal_len * 3 != c.length) return stbi__err("invalid PLTE", "Corrupt PNG");
			for (i = 0; i < pal_len; ++i) {
				palette[i * 4 + 0] = stbi__get8(s);
				palette[i * 4 + 1] = stbi__get8(s);
				palette[i * 4 + 2] = stbi__get8(s);
				palette[i * 4 + 3] = 255;
			}
			break;
		}

		case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (z->idata) return stbi__err("tRNS after IDAT", "Corrupt PNG");
			if (pal_img_n) {
				if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
				if (pal_len == 0) return stbi__err("tRNS before PLTE", "Corrupt PNG");
				if (c.length > pal_len) return stbi__err("bad tRNS len", "Corrupt PNG");
				pal_img_n = 4;
				for (i = 0; i < c.length; ++i)
					palette[i * 4 + 3] = stbi__get8(s);
			}
			else {
				if (!(s->img_n & 1)) return stbi__err("tRNS with alpha", "Corrupt PNG");
				if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err("bad tRNS len", "Corrupt PNG");
				has_trans = 1;
				if (z->depth == 16) {
					for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
				}
				else {
					for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
				}
			}
			break;
		}

		case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (pal_img_n && !pal_len) return stbi__err("no PLTE", "Corrupt PNG");
			if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
			if ((int)(ioff + c.length) < (int)ioff) return 0;
			if (ioff + c.length > idata_limit) {
				stbi__uint32 idata_limit_old = idata_limit;
				stbi_uc *p;
				if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
				while (ioff + c.length > idata_limit)
					idata_limit *= 2;
				STBI_NOTUSED(idata_limit_old);
				p = (stbi_uc *)STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
				z->idata = p;
			}
			if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err("outofdata", "Corrupt PNG");
			ioff += c.length;
			break;
		}

		case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {
			stbi__uint32 raw_len, bpl;
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (scan != STBI__SCAN_load) return 1;
			if (z->idata == NULL) return stbi__err("no IDAT", "Corrupt PNG");
			// initial guess for decoded data size to avoid unnecessary reallocs
			bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
			raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
			z->expanded = (stbi_uc *)stbi_zlib_decode_malloc_guesssize_headerflag((char *)z->idata, ioff, raw_len, (int *)&raw_len, !is_iphone);
			if (z->expanded == NULL) return 0; // zlib should set error
			STBI_FREE(z->idata); z->idata = NULL;
			if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)
				s->img_out_n = s->img_n + 1;
			else
				s->img_out_n = s->img_n;
			if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
			if (has_trans) {
				if (z->depth == 16) {
					if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
				}
				else {
					if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
				}
			}
			if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
				stbi__de_iphone(z);
			if (pal_img_n) {
				// pal_img_n == 3 or 4
				s->img_n = pal_img_n; // record the actual colors we had
				s->img_out_n = pal_img_n;
				if (req_comp >= 3) s->img_out_n = req_comp;
				if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
					return 0;
			}
			else if (has_trans) {
				// non-paletted image with tRNS -> source image has (constant) alpha
				++s->img_n;
			}
			STBI_FREE(z->expanded); z->expanded = NULL;
			return 1;
		}

		default:
			// if critical, fail
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if ((c.type & (1 << 29)) == 0) {
#ifndef STBI_NO_FAILURE_STRINGS
				// not threadsafe
				static char invalid_chunk[] = "XXXX PNG chunk not known";
				invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
				invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
				invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);
				invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);
#endif
				return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
			}
			stbi__skip(s, c.length);
			break;
		}
		// end of PNG chunk, read and skip CRC
		stbi__get32be(s);
	}
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
	void *result = NULL;
	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
	if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
		if (p->depth < 8)
			ri->bits_per_channel = 8;
		else
			ri->bits_per_channel = p->depth;
		result = p->out;
		p->out = NULL;
		if (req_comp && req_comp != p->s->img_out_n) {
			if (ri->bits_per_channel == 8)
				result = stbi__convert_format((unsigned char *)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
			else
				result = stbi__convert_format16((stbi__uint16 *)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
			p->s->img_out_n = req_comp;
			if (result == NULL) return result;
		}
		*x = p->s->img_x;
		*y = p->s->img_y;
		if (n) *n = p->s->img_n;
	}
	STBI_FREE(p->out);      p->out = NULL;
	STBI_FREE(p->expanded); p->expanded = NULL;
	STBI_FREE(p->idata);    p->idata = NULL;

	return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	stbi__png p;
	p.s = s;
	return stbi__do_png(&p, x, y, comp, req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
	int r;
	r = stbi__check_png_header(s);
	stbi__rewind(s);
	return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
	if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
		stbi__rewind(p->s);
		return 0;
	}
	if (x) *x = p->s->img_x;
	if (y) *y = p->s->img_y;
	if (comp) *comp = p->s->img_n;
	return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
	stbi__png p;
	p.s = s;
	return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
	stbi__png p;
	p.s = s;
	if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
		return 0;
	if (p.depth != 16) {
		stbi__rewind(p.s);
		return 0;
	}
	return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
	int r;
	int sz;
	if (stbi__get8(s) != 'B') return 0;
	if (stbi__get8(s) != 'M') return 0;
	stbi__get32le(s); // discard filesize
	stbi__get16le(s); // discard reserved
	stbi__get16le(s); // discard reserved
	stbi__get32le(s); // discard data offset
	sz = stbi__get32le(s);
	r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
	return r;
}

static int stbi__bmp_test(stbi__context *s)
{
	int r = stbi__bmp_test_raw(s);
	stbi__rewind(s);
	return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
	int n = 0;
	if (z == 0) return -1;
	if (z >= 0x10000) { n += 16; z >>= 16; }
	if (z >= 0x00100) { n += 8; z >>= 8; }
	if (z >= 0x00010) { n += 4; z >>= 4; }
	if (z >= 0x00004) { n += 2; z >>= 2; }
	if (z >= 0x00002) { n += 1;/* >>=  1;*/ }
	return n;
}

static int stbi__bitcount(unsigned int a)
{
	a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2
	a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4
	a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
	a = (a + (a >> 8)); // max 16 per 8 bits
	a = (a + (a >> 16)); // max 32 per 8 bits
	return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
	static unsigned int mul_table[9] = {
	   0,
	   0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
	   0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
	};
	static unsigned int shift_table[9] = {
	   0, 0,0,1,0,2,4,6,0,
	};
	if (shift < 0)
		v <<= -shift;
	else
		v >>= shift;
	STBI_ASSERT(v >= 0 && v < 256);
	v >>= (8 - bits);
	STBI_ASSERT(bits >= 0 && bits <= 8);
	return (int)((unsigned)v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
	int bpp, offset, hsz;
	unsigned int mr, mg, mb, ma, all_a;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
	int hsz;
	if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
	stbi__get32le(s); // discard filesize
	stbi__get16le(s); // discard reserved
	stbi__get16le(s); // discard reserved
	info->offset = stbi__get32le(s);
	info->hsz = hsz = stbi__get32le(s);
	info->mr = info->mg = info->mb = info->ma = 0;

	if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
	if (hsz == 12) {
		s->img_x = stbi__get16le(s);
		s->img_y = stbi__get16le(s);
	}
	else {
		s->img_x = stbi__get32le(s);
		s->img_y = stbi__get32le(s);
	}
	if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
	info->bpp = stbi__get16le(s);
	if (hsz != 12) {
		int compress = stbi__get32le(s);
		if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
		stbi__get32le(s); // discard sizeof
		stbi__get32le(s); // discard hres
		stbi__get32le(s); // discard vres
		stbi__get32le(s); // discard colorsused
		stbi__get32le(s); // discard max important
		if (hsz == 40 || hsz == 56) {
			if (hsz == 56) {
				stbi__get32le(s);
				stbi__get32le(s);
				stbi__get32le(s);
				stbi__get32le(s);
			}
			if (info->bpp == 16 || info->bpp == 32) {
				if (compress == 0) {
					if (info->bpp == 32) {
						info->mr = 0xffu << 16;
						info->mg = 0xffu << 8;
						info->mb = 0xffu << 0;
						info->ma = 0xffu << 24;
						info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
					}
					else {
						info->mr = 31u << 10;
						info->mg = 31u << 5;
						info->mb = 31u << 0;
					}
				}
				else if (compress == 3) {
					info->mr = stbi__get32le(s);
					info->mg = stbi__get32le(s);
					info->mb = stbi__get32le(s);
					// not documented, but generated by photoshop and handled by mspaint
					if (info->mr == info->mg && info->mg == info->mb) {
						// ?!?!?
						return stbi__errpuc("bad BMP", "bad BMP");
					}
				}
				else
					return stbi__errpuc("bad BMP", "bad BMP");
			}
		}
		else {
			int i;
			if (hsz != 108 && hsz != 124)
				return stbi__errpuc("bad BMP", "bad BMP");
			info->mr = stbi__get32le(s);
			info->mg = stbi__get32le(s);
			info->mb = stbi__get32le(s);
			info->ma = stbi__get32le(s);
			stbi__get32le(s); // discard color space
			for (i = 0; i < 12; ++i)
				stbi__get32le(s); // discard color space parameters
			if (hsz == 124) {
				stbi__get32le(s); // discard rendering intent
				stbi__get32le(s); // discard offset of profile data
				stbi__get32le(s); // discard size of profile data
				stbi__get32le(s); // discard reserved
			}
		}
	}
	return (void *)1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	stbi_uc *out;
	unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a;
	stbi_uc pal[256][4];
	int psize = 0, i, j, width;
	int flip_vertically, pad, target;
	stbi__bmp_data info;
	STBI_NOTUSED(ri);

	info.all_a = 255;
	if (stbi__bmp_parse_header(s, &info) == NULL)
		return NULL; // error code already set

	flip_vertically = ((int)s->img_y) > 0;
	s->img_y = abs((int)s->img_y);

	mr = info.mr;
	mg = info.mg;
	mb = info.mb;
	ma = info.ma;
	all_a = info.all_a;

	if (info.hsz == 12) {
		if (info.bpp < 24)
			psize = (info.offset - 14 - 24) / 3;
	}
	else {
		if (info.bpp < 16)
			psize = (info.offset - 14 - info.hsz) >> 2;
	}

	if (info.bpp == 24 && ma == 0xff000000)
		s->img_n = 3;
	else
		s->img_n = ma ? 4 : 3;
	if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
		target = req_comp;
	else
		target = s->img_n; // if they want monochrome, we'll post-convert

	 // sanity-check size
	if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
		return stbi__errpuc("too large", "Corrupt BMP");

	out = (stbi_uc *)stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
	if (!out) return stbi__errpuc("outofmem", "Out of memory");
	if (info.bpp < 16) {
		int z = 0;
		if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
		for (i = 0; i < psize; ++i) {
			pal[i][2] = stbi__get8(s);
			pal[i][1] = stbi__get8(s);
			pal[i][0] = stbi__get8(s);
			if (info.hsz != 12) stbi__get8(s);
			pal[i][3] = 255;
		}
		stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
		if (info.bpp == 1) width = (s->img_x + 7) >> 3;
		else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
		else if (info.bpp == 8) width = s->img_x;
		else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
		pad = (-width) & 3;
		if (info.bpp == 1) {
			for (j = 0; j < (int)s->img_y; ++j) {
				int bit_offset = 7, v = stbi__get8(s);
				for (i = 0; i < (int)s->img_x; ++i) {
					int color = (v >> bit_offset) & 0x1;
					out[z++] = pal[color][0];
					out[z++] = pal[color][1];
					out[z++] = pal[color][2];
					if (target == 4) out[z++] = 255;
					if (i + 1 == (int)s->img_x) break;
					if ((--bit_offset) < 0) {
						bit_offset = 7;
						v = stbi__get8(s);
					}
				}
				stbi__skip(s, pad);
			}
		}
		else {
			for (j = 0; j < (int)s->img_y; ++j) {
				for (i = 0; i < (int)s->img_x; i += 2) {
					int v = stbi__get8(s), v2 = 0;
					if (info.bpp == 4) {
						v2 = v & 15;
						v >>= 4;
					}
					out[z++] = pal[v][0];
					out[z++] = pal[v][1];
					out[z++] = pal[v][2];
					if (target == 4) out[z++] = 255;
					if (i + 1 == (int)s->img_x) break;
					v = (info.bpp == 8) ? stbi__get8(s) : v2;
					out[z++] = pal[v][0];
					out[z++] = pal[v][1];
					out[z++] = pal[v][2];
					if (target == 4) out[z++] = 255;
				}
				stbi__skip(s, pad);
			}
		}
	}
	else {
		int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;
		int z = 0;
		int easy = 0;
		stbi__skip(s, info.offset - 14 - info.hsz);
		if (info.bpp == 24) width = 3 * s->img_x;
		else if (info.bpp == 16) width = 2 * s->img_x;
		else /* bpp = 32 and pad = 0 */ width = 0;
		pad = (-width) & 3;
		if (info.bpp == 24) {
			easy = 1;
		}
		else if (info.bpp == 32) {
			if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
				easy = 2;
		}
		if (!easy) {
			if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
			// right shift amt to put high bit in position #7
			rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);
			gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);
			bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);
			ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);
		}
		for (j = 0; j < (int)s->img_y; ++j) {
			if (easy) {
				for (i = 0; i < (int)s->img_x; ++i) {
					unsigned char a;
					out[z + 2] = stbi__get8(s);
					out[z + 1] = stbi__get8(s);
					out[z + 0] = stbi__get8(s);
					z += 3;
					a = (easy == 2 ? stbi__get8(s) : 255);
					all_a |= a;
					if (target == 4) out[z++] = a;
				}
			}
			else {
				int bpp = info.bpp;
				for (i = 0; i < (int)s->img_x; ++i) {
					stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));
					unsigned int a;
					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
					a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
					all_a |= a;
					if (target == 4) out[z++] = STBI__BYTECAST(a);
				}
			}
			stbi__skip(s, pad);
		}
	}

	// if alpha channel is all 0s, replace with all 255s
	if (target == 4 && all_a == 0)
		for (i = 4 * s->img_x*s->img_y - 1; i >= 0; i -= 4)
			out[i] = 255;

	if (flip_vertically) {
		stbi_uc t;
		for (j = 0; j < (int)s->img_y >> 1; ++j) {
			stbi_uc *p1 = out + j * s->img_x*target;
			stbi_uc *p2 = out + (s->img_y - 1 - j)*s->img_x*target;
			for (i = 0; i < (int)s->img_x*target; ++i) {
				t = p1[i]; p1[i] = p2[i]; p2[i] = t;
			}
		}
	}

	if (req_comp && req_comp != target) {
		out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
		if (out == NULL) return out; // stbi__convert_format frees input on failure
	}

	*x = s->img_x;
	*y = s->img_y;
	if (comp) *comp = s->img_n;
	return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
	// only RGB or RGBA (incl. 16bit) or grey allowed
	if (is_rgb16) *is_rgb16 = 0;
	switch (bits_per_pixel) {
	case 8:  return STBI_grey;
	case 16: if (is_grey) return STBI_grey_alpha;
		// fallthrough
	case 15: if (is_rgb16) *is_rgb16 = 1;
		return STBI_rgb;
	case 24: // fallthrough
	case 32: return bits_per_pixel / 8;
	default: return 0;
	}
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
	int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
	int sz, tga_colormap_type;
	stbi__get8(s);                   // discard Offset
	tga_colormap_type = stbi__get8(s); // colormap type
	if (tga_colormap_type > 1) {
		stbi__rewind(s);
		return 0;      // only RGB or indexed allowed
	}
	tga_image_type = stbi__get8(s); // image type
	if (tga_colormap_type == 1) { // colormapped (paletted) image
		if (tga_image_type != 1 && tga_image_type != 9) {
			stbi__rewind(s);
			return 0;
		}
		stbi__skip(s, 4);       // skip index of first colormap entry and number of entries
		sz = stbi__get8(s);    //   check bits per palette color entry
		if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) {
			stbi__rewind(s);
			return 0;
		}
		stbi__skip(s, 4);       // skip image x and y origin
		tga_colormap_bpp = sz;
	}
	else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
		if ((tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11)) {
			stbi__rewind(s);
			return 0; // only RGB or grey allowed, +/- RLE
		}
		stbi__skip(s, 9); // skip colormap specification and image x/y origin
		tga_colormap_bpp = 0;
	}
	tga_w = stbi__get16le(s);
	if (tga_w < 1) {
		stbi__rewind(s);
		return 0;   // test width
	}
	tga_h = stbi__get16le(s);
	if (tga_h < 1) {
		stbi__rewind(s);
		return 0;   // test height
	}
	tga_bits_per_pixel = stbi__get8(s); // bits per pixel
	stbi__get8(s); // ignore alpha bits
	if (tga_colormap_bpp != 0) {
		if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
			// when using a colormap, tga_bits_per_pixel is the size of the indexes
			// I don't think anything but 8 or 16bit indexes makes sense
			stbi__rewind(s);
			return 0;
		}
		tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
	}
	else {
		tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
	}
	if (!tga_comp) {
		stbi__rewind(s);
		return 0;
	}
	if (x) *x = tga_w;
	if (y) *y = tga_h;
	if (comp) *comp = tga_comp;
	return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
	int res = 0;
	int sz, tga_color_type;
	stbi__get8(s);      //   discard Offset
	tga_color_type = stbi__get8(s);   //   color type
	if (tga_color_type > 1) goto errorEnd;   //   only RGB or indexed allowed
	sz = stbi__get8(s);   //   image type
	if (tga_color_type == 1) { // colormapped (paletted) image
		if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
		stbi__skip(s, 4);       // skip index of first colormap entry and number of entries
		sz = stbi__get8(s);    //   check bits per palette color entry
		if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;
		stbi__skip(s, 4);       // skip image x and y origin
	}
	else { // "normal" image w/o colormap
		if ((sz != 2) && (sz != 3) && (sz != 10) && (sz != 11)) goto errorEnd; // only RGB or grey allowed, +/- RLE
		stbi__skip(s, 9); // skip colormap specification and image x/y origin
	}
	if (stbi__get16le(s) < 1) goto errorEnd;      //   test width
	if (stbi__get16le(s) < 1) goto errorEnd;      //   test height
	sz = stbi__get8(s);   //   bits per pixel
	if ((tga_color_type == 1) && (sz != 8) && (sz != 16)) goto errorEnd; // for colormapped images, bpp is size of an index
	if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

	res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
	stbi__rewind(s);
	return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
	stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
	stbi__uint16 fiveBitMask = 31;
	// we have 3 channels with 5bits each
	int r = (px >> 10) & fiveBitMask;
	int g = (px >> 5) & fiveBitMask;
	int b = px & fiveBitMask;
	// Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
	out[0] = (stbi_uc)((r * 255) / 31);
	out[1] = (stbi_uc)((g * 255) / 31);
	out[2] = (stbi_uc)((b * 255) / 31);

	// some people claim that the most significant bit might be used for alpha
	// (possibly if an alpha-bit is set in the "image descriptor byte")
	// but that only made 16bit test images completely translucent..
	// so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	//   read in the TGA header stuff
	int tga_offset = stbi__get8(s);
	int tga_indexed = stbi__get8(s);
	int tga_image_type = stbi__get8(s);
	int tga_is_RLE = 0;
	int tga_palette_start = stbi__get16le(s);
	int tga_palette_len = stbi__get16le(s);
	int tga_palette_bits = stbi__get8(s);
	int tga_x_origin = stbi__get16le(s);
	int tga_y_origin = stbi__get16le(s);
	int tga_width = stbi__get16le(s);
	int tga_height = stbi__get16le(s);
	int tga_bits_per_pixel = stbi__get8(s);
	int tga_comp, tga_rgb16 = 0;
	int tga_inverted = stbi__get8(s);
	// int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
	//   image data
	unsigned char *tga_data;
	unsigned char *tga_palette = NULL;
	int i, j;
	unsigned char raw_data[4] = { 0 };
	int RLE_count = 0;
	int RLE_repeating = 0;
	int read_next_pixel = 1;
	STBI_NOTUSED(ri);
	STBI_NOTUSED(tga_x_origin); // @TODO
	STBI_NOTUSED(tga_y_origin); // @TODO

	//   do a tiny bit of precessing
	if (tga_image_type >= 8)
	{
		tga_image_type -= 8;
		tga_is_RLE = 1;
	}
	tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	//   If I'm paletted, then I'll use the number of bits from the palette
	if (tga_indexed) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
	else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

	if (!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
		return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

	//   tga info
	*x = tga_width;
	*y = tga_height;
	if (comp) *comp = tga_comp;

	if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
		return stbi__errpuc("too large", "Corrupt TGA");

	tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
	if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

	// skip to the data's starting position (offset usually = 0)
	stbi__skip(s, tga_offset);

	if (!tga_indexed && !tga_is_RLE && !tga_rgb16) {
		for (i = 0; i < tga_height; ++i) {
			int row = tga_inverted ? tga_height - i - 1 : i;
			stbi_uc *tga_row = tga_data + row * tga_width*tga_comp;
			stbi__getn(s, tga_row, tga_width * tga_comp);
		}
	}
	else {
		//   do I need to load a palette?
		if (tga_indexed)
		{
			//   any data to skip? (offset usually = 0)
			stbi__skip(s, tga_palette_start);
			//   load the palette
			tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
			if (!tga_palette) {
				STBI_FREE(tga_data);
				return stbi__errpuc("outofmem", "Out of memory");
			}
			if (tga_rgb16) {
				stbi_uc *pal_entry = tga_palette;
				STBI_ASSERT(tga_comp == STBI_rgb);
				for (i = 0; i < tga_palette_len; ++i) {
					stbi__tga_read_rgb16(s, pal_entry);
					pal_entry += tga_comp;
				}
			}
			else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
				STBI_FREE(tga_data);
				STBI_FREE(tga_palette);
				return stbi__errpuc("bad palette", "Corrupt TGA");
			}
		}
		//   load the data
		for (i = 0; i < tga_width * tga_height; ++i)
		{
			//   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
			if (tga_is_RLE)
			{
				if (RLE_count == 0)
				{
					//   yep, get the next byte as a RLE command
					int RLE_cmd = stbi__get8(s);
					RLE_count = 1 + (RLE_cmd & 127);
					RLE_repeating = RLE_cmd >> 7;
					read_next_pixel = 1;
				}
				else if (!RLE_repeating)
				{
					read_next_pixel = 1;
				}
			}
			else
			{
				read_next_pixel = 1;
			}
			//   OK, if I need to read a pixel, do it now
			if (read_next_pixel)
			{
				//   load however much data we did have
				if (tga_indexed)
				{
					// read in index, then perform the lookup
					int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
					if (pal_idx >= tga_palette_len) {
						// invalid index
						pal_idx = 0;
					}
					pal_idx *= tga_comp;
					for (j = 0; j < tga_comp; ++j) {
						raw_data[j] = tga_palette[pal_idx + j];
					}
				}
				else if (tga_rgb16) {
					STBI_ASSERT(tga_comp == STBI_rgb);
					stbi__tga_read_rgb16(s, raw_data);
				}
				else {
					//   read in the data raw
					for (j = 0; j < tga_comp; ++j) {
						raw_data[j] = stbi__get8(s);
					}
				}
				//   clear the reading flag for the next pixel
				read_next_pixel = 0;
			} // end of reading a pixel

			// copy data
			for (j = 0; j < tga_comp; ++j)
				tga_data[i*tga_comp + j] = raw_data[j];

			//   in case we're in RLE mode, keep counting down
			--RLE_count;
		}
		//   do I need to invert the image?
		if (tga_inverted)
		{
			for (j = 0; j * 2 < tga_height; ++j)
			{
				int index1 = j * tga_width * tga_comp;
				int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
				for (i = tga_width * tga_comp; i > 0; --i)
				{
					unsigned char temp = tga_data[index1];
					tga_data[index1] = tga_data[index2];
					tga_data[index2] = temp;
					++index1;
					++index2;
				}
			}
		}
		//   clear my palette, if I had one
		if (tga_palette != NULL)
		{
			STBI_FREE(tga_palette);
		}
	}

	// swap RGB - if the source data was RGB16, it already is in the right order
	if (tga_comp >= 3 && !tga_rgb16)
	{
		unsigned char* tga_pixel = tga_data;
		for (i = 0; i < tga_width * tga_height; ++i)
		{
			unsigned char temp = tga_pixel[0];
			tga_pixel[0] = tga_pixel[2];
			tga_pixel[2] = temp;
			tga_pixel += tga_comp;
		}
	}

	// convert to target component count
	if (req_comp && req_comp != tga_comp)
		tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

	//   the things I do to get rid of an error message, and yet keep
	//   Microsoft's C compilers happy... [8^(
	tga_palette_start = tga_palette_len = tga_palette_bits =
		tga_x_origin = tga_y_origin = 0;
	STBI_NOTUSED(tga_palette_start);
	//   OK, done
	return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
	int r = (stbi__get32be(s) == 0x38425053);
	stbi__rewind(s);
	return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
	int count, nleft, len;

	count = 0;
	while ((nleft = pixelCount - count) > 0) {
		len = stbi__get8(s);
		if (len == 128) {
			// No-op.
		}
		else if (len < 128) {
			// Copy next len+1 bytes literally.
			len++;
			if (len > nleft) return 0; // corrupt data
			count += len;
			while (len) {
				*p = stbi__get8(s);
				p += 4;
				len--;
			}
		}
		else if (len > 128) {
			stbi_uc   val;
			// Next -len+1 bytes in the dest are replicated from next source byte.
			// (Interpret len as a negative 8-bit int.)
			len = 257 - len;
			if (len > nleft) return 0; // corrupt data
			val = stbi__get8(s);
			count += len;
			while (len) {
				*p = val;
				p += 4;
				len--;
			}
		}
	}

	return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
	int pixelCount;
	int channelCount, compression;
	int channel, i;
	int bitdepth;
	int w, h;
	stbi_uc *out;
	STBI_NOTUSED(ri);

	// Check identifier
	if (stbi__get32be(s) != 0x38425053)   // "8BPS"
		return stbi__errpuc("not PSD", "Corrupt PSD image");

	// Check file type version.
	if (stbi__get16be(s) != 1)
		return stbi__errpuc("wrong version", "Unsupported version of PSD image");

	// Skip 6 reserved bytes.
	stbi__skip(s, 6);

	// Read the number of channels (R, G, B, A, etc).
	channelCount = stbi__get16be(s);
	if (channelCount < 0 || channelCount > 16)
		return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

	// Read the rows and columns of the image.
	h = stbi__get32be(s);
	w = stbi__get32be(s);

	// Make sure the depth is 8 bits.
	bitdepth = stbi__get16be(s);
	if (bitdepth != 8 && bitdepth != 16)
		return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

	// Make sure the color mode is RGB.
	// Valid options are:
	//   0: Bitmap
	//   1: Grayscale
	//   2: Indexed color
	//   3: RGB color
	//   4: CMYK color
	//   7: Multichannel
	//   8: Duotone
	//   9: Lab color
	if (stbi__get16be(s) != 3)
		return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

	// Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
	stbi__skip(s, stbi__get32be(s));

	// Skip the image resources.  (resolution, pen tool paths, etc)
	stbi__skip(s, stbi__get32be(s));

	// Skip the reserved data.
	stbi__skip(s, stbi__get32be(s));

	// Find out if the data is compressed.
	// Known values:
	//   0: no compression
	//   1: RLE compressed
	compression = stbi__get16be(s);
	if (compression > 1)
		return stbi__errpuc("bad compression", "PSD has an unknown compression format");

	// Check size
	if (!stbi__mad3sizes_valid(4, w, h, 0))
		return stbi__errpuc("too large", "Corrupt PSD");

	// Create the destination image.

	if (!compression && bitdepth == 16 && bpc == 16) {
		out = (stbi_uc *)stbi__malloc_mad3(8, w, h, 0);
		ri->bits_per_channel = 16;
	}
	else
		out = (stbi_uc *)stbi__malloc(4 * w*h);

	if (!out) return stbi__errpuc("outofmem", "Out of memory");
	pixelCount = w * h;

	// Initialize the data to zero.
	//memset( out, 0, pixelCount * 4 );

	// Finally, the image data.
	if (compression) {
		// RLE as used by .PSD and .TIFF
		// Loop until you get the number of unpacked bytes you are expecting:
		//     Read the next source byte into n.
		//     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
		//     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
		//     Else if n is 128, noop.
		// Endloop

		// The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
		// which we're going to just skip.
		stbi__skip(s, h * channelCount * 2);

		// Read the RLE data by channel.
		for (channel = 0; channel < 4; channel++) {
			stbi_uc *p;

			p = out + channel;
			if (channel >= channelCount) {
				// Fill this channel with default data.
				for (i = 0; i < pixelCount; i++, p += 4)
					*p = (channel == 3 ? 255 : 0);
			}
			else {
				// Read the RLE data.
				if (!stbi__psd_decode_rle(s, p, pixelCount)) {
					STBI_FREE(out);
					return stbi__errpuc("corrupt", "bad RLE data");
				}
			}
		}

	}
	else {
		// We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
		// where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

		// Read the data by channel.
		for (channel = 0; channel < 4; channel++) {
			if (channel >= channelCount) {
				// Fill this channel with default data.
				if (bitdepth == 16 && bpc == 16) {
					stbi__uint16 *q = ((stbi__uint16 *)out) + channel;
					stbi__uint16 val = channel == 3 ? 65535 : 0;
					for (i = 0; i < pixelCount; i++, q += 4)
						*q = val;
				}
				else {
					stbi_uc *p = out + channel;
					stbi_uc val = channel == 3 ? 255 : 0;
					for (i = 0; i < pixelCount; i++, p += 4)
						*p = val;
				}
			}
			else {
				if (ri->bits_per_channel == 16) {    // output bpc
					stbi__uint16 *q = ((stbi__uint16 *)out) + channel;
					for (i = 0; i < pixelCount; i++, q += 4)
						*q = (stbi__uint16)stbi__get16be(s);
				}
				else {
					stbi_uc *p = out + channel;
					if (bitdepth == 16) {  // input bpc
						for (i = 0; i < pixelCount; i++, p += 4)
							*p = (stbi_uc)(stbi__get16be(s) >> 8);
					}
					else {
						for (i = 0; i < pixelCount; i++, p += 4)
							*p = stbi__get8(s);
					}
				}
			}
		}
	}

	// remove weird white matte from PSD
	if (channelCount >= 4) {
		if (ri->bits_per_channel == 16) {
			for (i = 0; i < w*h; ++i) {
				stbi__uint16 *pixel = (stbi__uint16 *)out + 4 * i;
				if (pixel[3] != 0 && pixel[3] != 65535) {
					float a = pixel[3] / 65535.0f;
					float ra = 1.0f / a;
					float inv_a = 65535.0f * (1 - ra);
					pixel[0] = (stbi__uint16)(pixel[0] * ra + inv_a);
					pixel[1] = (stbi__uint16)(pixel[1] * ra + inv_a);
					pixel[2] = (stbi__uint16)(pixel[2] * ra + inv_a);
				}
			}
		}
		else {
			for (i = 0; i < w*h; ++i) {
				unsigned char *pixel = out + 4 * i;
				if (pixel[3] != 0 && pixel[3] != 255) {
					float a = pixel[3] / 255.0f;
					float ra = 1.0f / a;
					float inv_a = 255.0f * (1 - ra);
					pixel[0] = (unsigned char)(pixel[0] * ra + inv_a);
					pixel[1] = (unsigned char)(pixel[1] * ra + inv_a);
					pixel[2] = (unsigned char)(pixel[2] * ra + inv_a);
				}
			}
		}
	}

	// convert to desired output format
	if (req_comp && req_comp != 4) {
		if (ri->bits_per_channel == 16)
			out = (stbi_uc *)stbi__convert_format16((stbi__uint16 *)out, 4, req_comp, w, h);
		else
			out = stbi__convert_format(out, 4, req_comp, w, h);
		if (out == NULL) return out; // stbi__convert_format frees input on failure
	}

	if (comp) *comp = 4;
	*y = h;
	*x = w;

	return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s, const char *str)
{
	int i;
	for (i = 0; i < 4; ++i)
		if (stbi__get8(s) != (stbi_uc)str[i])
			return 0;

	return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
	int i;

	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34"))
		return 0;

	for (i = 0; i < 84; ++i)
		stbi__get8(s);

	if (!stbi__pic_is4(s, "PICT"))
		return 0;

	return 1;
}

typedef struct
{
	stbi_uc size, type, channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
	int mask = 0x80, i;

	for (i = 0; i < 4; ++i, mask >>= 1) {
		if (channel & mask) {
			if (stbi__at_eof(s)) return stbi__errpuc("bad file", "PIC file too short");
			dest[i] = stbi__get8(s);
		}
	}

	return dest;
}

static void stbi__copyval(int channel, stbi_uc *dest, const stbi_uc *src)
{
	int mask = 0x80, i;

	for (i = 0; i < 4; ++i, mask >>= 1)
		if (channel&mask)
			dest[i] = src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s, int width, int height, int *comp, stbi_uc *result)
{
	int act_comp = 0, num_packets = 0, y, chained;
	stbi__pic_packet packets[10];

	// this will (should...) cater for even some bizarre stuff like having data
	 // for the same channel in multiple packets.
	do {
		stbi__pic_packet *packet;

		if (num_packets == sizeof(packets) / sizeof(packets[0]))
			return stbi__errpuc("bad format", "too many packets");

		packet = &packets[num_packets++];

		chained = stbi__get8(s);
		packet->size = stbi__get8(s);
		packet->type = stbi__get8(s);
		packet->channel = stbi__get8(s);

		act_comp |= packet->channel;

		if (stbi__at_eof(s))          return stbi__errpuc("bad file", "file too short (reading packets)");
		if (packet->size != 8)  return stbi__errpuc("bad format", "packet isn't 8bpp");
	} while (chained);

	*comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

	for (y = 0; y < height; ++y) {
		int packet_idx;

		for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {
			stbi__pic_packet *packet = &packets[packet_idx];
			stbi_uc *dest = result + y * width * 4;

			switch (packet->type) {
			default:
				return stbi__errpuc("bad format", "packet has bad compression type");

			case 0: {//uncompressed
				int x;

				for (x = 0; x < width; ++x, dest += 4)
					if (!stbi__readval(s, packet->channel, dest))
						return 0;
				break;
			}

			case 1://Pure RLE
			{
				int left = width, i;

				while (left > 0) {
					stbi_uc count, value[4];

					count = stbi__get8(s);
					if (stbi__at_eof(s))   return stbi__errpuc("bad file", "file too short (pure read count)");

					if (count > left)
						count = (stbi_uc)left;

					if (!stbi__readval(s, packet->channel, value))  return 0;

					for (i = 0; i < count; ++i, dest += 4)
						stbi__copyval(packet->channel, dest, value);
					left -= count;
				}
			}
			break;

			case 2: {//Mixed RLE
				int left = width;
				while (left > 0) {
					int count = stbi__get8(s), i;
					if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (mixed read count)");

					if (count >= 128) { // Repeated
						stbi_uc value[4];

						if (count == 128)
							count = stbi__get16be(s);
						else
							count -= 127;
						if (count > left)
							return stbi__errpuc("bad file", "scanline overrun");

						if (!stbi__readval(s, packet->channel, value))
							return 0;

						for (i = 0; i < count; ++i, dest += 4)
							stbi__copyval(packet->channel, dest, value);
					}
					else { // Raw
						++count;
						if (count > left) return stbi__errpuc("bad file", "scanline overrun");

						for (i = 0; i < count; ++i, dest += 4)
							if (!stbi__readval(s, packet->channel, dest))
								return 0;
					}
					left -= count;
				}
				break;
			}
			}
		}
	}

	return result;
}

static void *stbi__pic_load(stbi__context *s, int *px, int *py, int *comp, int req_comp, stbi__result_info *ri)
{
	stbi_uc *result;
	int i, x, y, internal_comp;
	STBI_NOTUSED(ri);

	if (!comp) comp = &internal_comp;

	for (i = 0; i < 92; ++i)
		stbi__get8(s);

	x = stbi__get16be(s);
	y = stbi__get16be(s);
	if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (pic header)");
	if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

	stbi__get32be(s); //skip `ratio'
	stbi__get16be(s); //skip `fields'
	stbi__get16be(s); //skip `pad'

	// intermediate buffer is RGBA
	result = (stbi_uc *)stbi__malloc_mad3(x, y, 4, 0);
	memset(result, 0xff, x*y * 4);

	if (!stbi__pic_load_core(s, x, y, comp, result)) {
		STBI_FREE(result);
		result = 0;
	}
	*px = x;
	*py = y;
	if (req_comp == 0) req_comp = *comp;
	result = stbi__convert_format(result, 4, req_comp, x, y);

	return result;
}

static int stbi__pic_test(stbi__context *s)
{
	int r = stbi__pic_test_core(s);
	stbi__rewind(s);
	return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
	stbi__int16 prefix;
	stbi_uc first;
	stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
	int w, h;
	stbi_uc *out;                 // output buffer (always 4 components)
	stbi_uc *background;          // The current "background" as far as a gif is concerned
	stbi_uc *history;
	int flags, bgindex, ratio, transparent, eflags;
	stbi_uc  pal[256][4];
	stbi_uc lpal[256][4];
	stbi__gif_lzw codes[8192];
	stbi_uc *color_table;
	int parse, step;
	int lflags;
	int start_x, start_y;
	int max_x, max_y;
	int cur_x, cur_y;
	int line_size;
	int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
	int sz;
	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
	sz = stbi__get8(s);
	if (sz != '9' && sz != '7') return 0;
	if (stbi__get8(s) != 'a') return 0;
	return 1;
}

static int stbi__gif_test(stbi__context *s)
{
	int r = stbi__gif_test_raw(s);
	stbi__rewind(s);
	return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
	int i;
	for (i = 0; i < num_entries; ++i) {
		pal[i][2] = stbi__get8(s);
		pal[i][1] = stbi__get8(s);
		pal[i][0] = stbi__get8(s);
		pal[i][3] = transp == i ? 0 : 255;
	}
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
	stbi_uc version;
	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
		return stbi__err("not GIF", "Corrupt GIF");

	version = stbi__get8(s);
	if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
	if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

	stbi__g_failure_reason = "";
	g->w = stbi__get16le(s);
	g->h = stbi__get16le(s);
	g->flags = stbi__get8(s);
	g->bgindex = stbi__get8(s);
	g->ratio = stbi__get8(s);
	g->transparent = -1;

	if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

	if (is_info) return 1;

	if (g->flags & 0x80)
		stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);

	return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
	stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));
	if (!stbi__gif_header(s, g, comp, 1)) {
		STBI_FREE(g);
		stbi__rewind(s);
		return 0;
	}
	if (x) *x = g->w;
	if (y) *y = g->h;
	STBI_FREE(g);
	return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
	stbi_uc *p, *c;
	int idx;

	// recurse to decode the prefixes, since the linked-list is backwards,
	// and working backwards through an interleaved image would be nasty
	if (g->codes[code].prefix >= 0)
		stbi__out_gif_code(g, g->codes[code].prefix);

	if (g->cur_y >= g->max_y) return;

	idx = g->cur_x + g->cur_y;
	p = &g->out[idx];
	g->history[idx / 4] = 1;

	c = &g->color_table[g->codes[code].suffix * 4];
	if (c[3] > 128) { // don't render transparent pixels; 
		p[0] = c[2];
		p[1] = c[1];
		p[2] = c[0];
		p[3] = c[3];
	}
	g->cur_x += 4;

	if (g->cur_x >= g->max_x) {
		g->cur_x = g->start_x;
		g->cur_y += g->step;

		while (g->cur_y >= g->max_y && g->parse > 0) {
			g->step = (1 << g->parse) * g->line_size;
			g->cur_y = g->start_y + (g->step >> 1);
			--g->parse;
		}
	}
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
	stbi_uc lzw_cs;
	stbi__int32 len, init_code;
	stbi__uint32 first;
	stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
	stbi__gif_lzw *p;

	lzw_cs = stbi__get8(s);
	if (lzw_cs > 12) return NULL;
	clear = 1 << lzw_cs;
	first = 1;
	codesize = lzw_cs + 1;
	codemask = (1 << codesize) - 1;
	bits = 0;
	valid_bits = 0;
	for (init_code = 0; init_code < clear; init_code++) {
		g->codes[init_code].prefix = -1;
		g->codes[init_code].first = (stbi_uc)init_code;
		g->codes[init_code].suffix = (stbi_uc)init_code;
	}

	// support no starting clear code
	avail = clear + 2;
	oldcode = -1;

	len = 0;
	for (;;) {
		if (valid_bits < codesize) {
			if (len == 0) {
				len = stbi__get8(s); // start new block
				if (len == 0)
					return g->out;
			}
			--len;
			bits |= (stbi__int32)stbi__get8(s) << valid_bits;
			valid_bits += 8;
		}
		else {
			stbi__int32 code = bits & codemask;
			bits >>= codesize;
			valid_bits -= codesize;
			// @OPTIMIZE: is there some way we can accelerate the non-clear path?
			if (code == clear) {  // clear code
				codesize = lzw_cs + 1;
				codemask = (1 << codesize) - 1;
				avail = clear + 2;
				oldcode = -1;
				first = 0;
			}
			else if (code == clear + 1) { // end of stream code
				stbi__skip(s, len);
				while ((len = stbi__get8(s)) > 0)
					stbi__skip(s, len);
				return g->out;
			}
			else if (code <= avail) {
				if (first) {
					return stbi__errpuc("no clear code", "Corrupt GIF");
				}

				if (oldcode >= 0) {
					p = &g->codes[avail++];
					if (avail > 8192) {
						return stbi__errpuc("too many codes", "Corrupt GIF");
					}

					p->prefix = (stbi__int16)oldcode;
					p->first = g->codes[oldcode].first;
					p->suffix = (code == avail) ? p->first : g->codes[code].first;
				}
				else if (code == avail)
					return stbi__errpuc("illegal code in raster", "Corrupt GIF");

				stbi__out_gif_code(g, (stbi__uint16)code);

				if ((avail & codemask) == 0 && avail <= 0x0FFF) {
					codesize++;
					codemask = (1 << codesize) - 1;
				}

				oldcode = code;
			}
			else {
				return stbi__errpuc("illegal code in raster", "Corrupt GIF");
			}
		}
	}
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
	int dispose;
	int first_frame;
	int pi;
	int pcount;
	STBI_NOTUSED(req_comp);

	// on first frame, any non-written pixels get the background colour (non-transparent)
	first_frame = 0;
	if (g->out == 0) {
		if (!stbi__gif_header(s, g, comp, 0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
		if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
			return stbi__errpuc("too large", "GIF image is too large");
		pcount = g->w * g->h;
		g->out = (stbi_uc *)stbi__malloc(4 * pcount);
		g->background = (stbi_uc *)stbi__malloc(4 * pcount);
		g->history = (stbi_uc *)stbi__malloc(pcount);
		if (!g->out || !g->background || !g->history)
			return stbi__errpuc("outofmem", "Out of memory");

		// image is treated as "transparent" at the start - ie, nothing overwrites the current background; 
		// background colour is only used for pixels that are not rendered first frame, after that "background"
		// color refers to the color that was there the previous frame. 
		memset(g->out, 0x00, 4 * pcount);
		memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
		memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
		first_frame = 1;
	}
	else {
		// second frame - how do we dispoase of the previous one?
		dispose = (g->eflags & 0x1C) >> 2;
		pcount = g->w * g->h;

		if ((dispose == 3) && (two_back == 0)) {
			dispose = 2; // if I don't have an image to revert back to, default to the old background
		}

		if (dispose == 3) { // use previous graphic
			for (pi = 0; pi < pcount; ++pi) {
				if (g->history[pi]) {
					memcpy(&g->out[pi * 4], &two_back[pi * 4], 4);
				}
			}
		}
		else if (dispose == 2) {
			// restore what was changed last frame to background before that frame; 
			for (pi = 0; pi < pcount; ++pi) {
				if (g->history[pi]) {
					memcpy(&g->out[pi * 4], &g->background[pi * 4], 4);
				}
			}
		}
		else {
			// This is a non-disposal case eithe way, so just 
			// leave the pixels as is, and they will become the new background
			// 1: do not dispose
			// 0:  not specified.
		}

		// background is what out is after the undoing of the previou frame; 
		memcpy(g->background, g->out, 4 * g->w * g->h);
	}

	// clear my history; 
	memset(g->history, 0x00, g->w * g->h);        // pixels that were affected previous frame

	for (;;) {
		int tag = stbi__get8(s);
		switch (tag) {
		case 0x2C: /* Image Descriptor */
		{
			stbi__int32 x, y, w, h;
			stbi_uc *o;

			x = stbi__get16le(s);
			y = stbi__get16le(s);
			w = stbi__get16le(s);
			h = stbi__get16le(s);
			if (((x + w) > (g->w)) || ((y + h) > (g->h)))
				return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

			g->line_size = g->w * 4;
			g->start_x = x * 4;
			g->start_y = y * g->line_size;
			g->max_x = g->start_x + w * 4;
			g->max_y = g->start_y + h * g->line_size;
			g->cur_x = g->start_x;
			g->cur_y = g->start_y;

			// if the width of the specified rectangle is 0, that means
			// we may not see *any* pixels or the image is malformed;
			// to make sure this is caught, move the current y down to
			// max_y (which is what out_gif_code checks).
			if (w == 0)
				g->cur_y = g->max_y;

			g->lflags = stbi__get8(s);

			if (g->lflags & 0x40) {
				g->step = 8 * g->line_size; // first interlaced spacing
				g->parse = 3;
			}
			else {
				g->step = g->line_size;
				g->parse = 0;
			}

			if (g->lflags & 0x80) {
				stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
				g->color_table = (stbi_uc *)g->lpal;
			}
			else if (g->flags & 0x80) {
				g->color_table = (stbi_uc *)g->pal;
			}
			else
				return stbi__errpuc("missing color table", "Corrupt GIF");

			o = stbi__process_gif_raster(s, g);
			if (!o) return NULL;

			// if this was the first frame, 
			pcount = g->w * g->h;
			if (first_frame && (g->bgindex > 0)) {
				// if first frame, any pixel not drawn to gets the background color
				for (pi = 0; pi < pcount; ++pi) {
					if (g->history[pi] == 0) {
						g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be; 
						memcpy(&g->out[pi * 4], &g->pal[g->bgindex], 4);
					}
				}
			}

			return o;
		}

		case 0x21: // Comment Extension.
		{
			int len;
			int ext = stbi__get8(s);
			if (ext == 0xF9) { // Graphic Control Extension.
				len = stbi__get8(s);
				if (len == 4) {
					g->eflags = stbi__get8(s);
					g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

					// unset old transparent
					if (g->transparent >= 0) {
						g->pal[g->transparent][3] = 255;
					}
					if (g->eflags & 0x01) {
						g->transparent = stbi__get8(s);
						if (g->transparent >= 0) {
							g->pal[g->transparent][3] = 0;
						}
					}
					else {
						// don't need transparent
						stbi__skip(s, 1);
						g->transparent = -1;
					}
				}
				else {
					stbi__skip(s, len);
					break;
				}
			}
			while ((len = stbi__get8(s)) != 0) {
				stbi__skip(s, len);
			}
			break;
		}

		case 0x3B: // gif stream termination code
			return (stbi_uc *)s; // using '1' causes warning on some compilers

		default:
			return stbi__errpuc("unknown code", "Corrupt GIF");
		}
	}
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
	if (stbi__gif_test(s)) {
		int layers = 0;
		stbi_uc *u = 0;
		stbi_uc *out = 0;
		stbi_uc *two_back = 0;
		stbi__gif g;
		int stride;
		memset(&g, 0, sizeof(g));
		if (delays) {
			*delays = 0;
		}

		do {
			u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
			if (u == (stbi_uc *)s) u = 0;  // end of animated gif marker

			if (u) {
				*x = g.w;
				*y = g.h;
				++layers;
				stride = g.w * g.h * 4;

				if (out) {
					out = (stbi_uc*)STBI_REALLOC(out, layers * stride);
					if (delays) {
						*delays = (int*)STBI_REALLOC(*delays, sizeof(int) * layers);
					}
				}
				else {
					out = (stbi_uc*)stbi__malloc(layers * stride);
					if (delays) {
						*delays = (int*)stbi__malloc(layers * sizeof(int));
					}
				}
				memcpy(out + ((layers - 1) * stride), u, stride);
				if (layers >= 2) {
					two_back = out - 2 * stride;
				}

				if (delays) {
					(*delays)[layers - 1U] = g.delay;
				}
			}
		} while (u != 0);

		// free temp buffer; 
		STBI_FREE(g.out);
		STBI_FREE(g.history);
		STBI_FREE(g.background);

		// do the final conversion after loading everything; 
		if (req_comp && req_comp != 4)
			out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

		*z = layers;
		return out;
	}
	else {
		return stbi__errpuc("not GIF", "Image was not as a gif type.");
	}
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	stbi_uc *u = 0;
	stbi__gif g;
	memset(&g, 0, sizeof(g));
	STBI_NOTUSED(ri);

	u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
	if (u == (stbi_uc *)s) u = 0;  // end of animated gif marker
	if (u) {
		*x = g.w;
		*y = g.h;

		// moved conversion to after successful load so that the same
		// can be done for multiple frames. 
		if (req_comp && req_comp != 4)
			u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
	}
	else if (g.out) {
		// if there was an error and we allocated an image buffer, free it!
		STBI_FREE(g.out);
	}

	// free buffers needed for multiple frame loading; 
	STBI_FREE(g.history);
	STBI_FREE(g.background);

	return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
	return stbi__gif_info_raw(s, x, y, comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
	int i;
	for (i = 0; signature[i]; ++i)
		if (stbi__get8(s) != signature[i])
			return 0;
	stbi__rewind(s);
	return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
	int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
	stbi__rewind(s);
	if (!r) {
		r = stbi__hdr_test_core(s, "#?RGBE\n");
		stbi__rewind(s);
	}
	return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
	int len = 0;
	char c = '\0';

	c = (char)stbi__get8(z);

	while (!stbi__at_eof(z) && c != '\n') {
		buffer[len++] = c;
		if (len == STBI__HDR_BUFLEN - 1) {
			// flush to end of line
			while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
				;
			break;
		}
		c = (char)stbi__get8(z);
	}

	buffer[len] = 0;
	return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
	if (input[3] != 0) {
		float f1;
		// Exponent
		f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));
		if (req_comp <= 2)
			output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
		else {
			output[0] = input[0] * f1;
			output[1] = input[1] * f1;
			output[2] = input[2] * f1;
		}
		if (req_comp == 2) output[1] = 1;
		if (req_comp == 4) output[3] = 1;
	}
	else {
		switch (req_comp) {
		case 4: output[3] = 1; /* fallthrough */
		case 3: output[0] = output[1] = output[2] = 0;
			break;
		case 2: output[1] = 1; /* fallthrough */
		case 1: output[0] = 0;
			break;
		}
	}
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	char buffer[STBI__HDR_BUFLEN];
	char *token;
	int valid = 0;
	int width, height;
	stbi_uc *scanline;
	float *hdr_data;
	int len;
	unsigned char count, value;
	int i, j, k, c1, c2, z;
	const char *headerToken;
	STBI_NOTUSED(ri);

	// Check identifier
	headerToken = stbi__hdr_gettoken(s, buffer);
	if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
		return stbi__errpf("not HDR", "Corrupt HDR image");

	// Parse header
	for (;;) {
		token = stbi__hdr_gettoken(s, buffer);
		if (token[0] == 0) break;
		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
	}

	if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

	// Parse width and height
	// can't use sscanf() if we're not using stdio!
	token = stbi__hdr_gettoken(s, buffer);
	if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
	token += 3;
	height = (int)strtol(token, &token, 10);
	while (*token == ' ') ++token;
	if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
	token += 3;
	width = (int)strtol(token, NULL, 10);

	*x = width;
	*y = height;

	if (comp) *comp = 3;
	if (req_comp == 0) req_comp = 3;

	if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
		return stbi__errpf("too large", "HDR image is too large");

	// Read data
	hdr_data = (float *)stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
	if (!hdr_data)
		return stbi__errpf("outofmem", "Out of memory");

	// Load image data
	// image data is stored as some number of sca
	if (width < 8 || width >= 32768) {
		// Read flat data
		for (j = 0; j < height; ++j) {
			for (i = 0; i < width; ++i) {
				stbi_uc rgbe[4];
			main_decode_loop:
				stbi__getn(s, rgbe, 4);
				stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
			}
		}
	}
	else {
		// Read RLE-encoded data
		scanline = NULL;

		for (j = 0; j < height; ++j) {
			c1 = stbi__get8(s);
			c2 = stbi__get8(s);
			len = stbi__get8(s);
			if (c1 != 2 || c2 != 2 || (len & 0x80)) {
				// not run-length encoded, so we have to actually use THIS data as a decoded
				// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
				stbi_uc rgbe[4];
				rgbe[0] = (stbi_uc)c1;
				rgbe[1] = (stbi_uc)c2;
				rgbe[2] = (stbi_uc)len;
				rgbe[3] = (stbi_uc)stbi__get8(s);
				stbi__hdr_convert(hdr_data, rgbe, req_comp);
				i = 1;
				j = 0;
				STBI_FREE(scanline);
				goto main_decode_loop; // yes, this makes no sense
			}
			len <<= 8;
			len |= stbi__get8(s);
			if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
			if (scanline == NULL) {
				scanline = (stbi_uc *)stbi__malloc_mad2(width, 4, 0);
				if (!scanline) {
					STBI_FREE(hdr_data);
					return stbi__errpf("outofmem", "Out of memory");
				}
			}

			for (k = 0; k < 4; ++k) {
				int nleft;
				i = 0;
				while ((nleft = width - i) > 0) {
					count = stbi__get8(s);
					if (count > 128) {
						// Run
						value = stbi__get8(s);
						count -= 128;
						if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = value;
					}
					else {
						// Dump
						if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
						for (z = 0; z < count; ++z)
							scanline[i++ * 4 + k] = stbi__get8(s);
					}
				}
			}
			for (i = 0; i < width; ++i)
				stbi__hdr_convert(hdr_data + (j*width + i)*req_comp, scanline + i * 4, req_comp);
		}
		if (scanline)
			STBI_FREE(scanline);
	}

	return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
	char buffer[STBI__HDR_BUFLEN];
	char *token;
	int valid = 0;
	int dummy;

	if (!x) x = &dummy;
	if (!y) y = &dummy;
	if (!comp) comp = &dummy;

	if (stbi__hdr_test(s) == 0) {
		stbi__rewind(s);
		return 0;
	}

	for (;;) {
		token = stbi__hdr_gettoken(s, buffer);
		if (token[0] == 0) break;
		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
	}

	if (!valid) {
		stbi__rewind(s);
		return 0;
	}
	token = stbi__hdr_gettoken(s, buffer);
	if (strncmp(token, "-Y ", 3)) {
		stbi__rewind(s);
		return 0;
	}
	token += 3;
	*y = (int)strtol(token, &token, 10);
	while (*token == ' ') ++token;
	if (strncmp(token, "+X ", 3)) {
		stbi__rewind(s);
		return 0;
	}
	token += 3;
	*x = (int)strtol(token, NULL, 10);
	*comp = 3;
	return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
	void *p;
	stbi__bmp_data info;

	info.all_a = 255;
	p = stbi__bmp_parse_header(s, &info);
	stbi__rewind(s);
	if (p == NULL)
		return 0;
	if (x) *x = s->img_x;
	if (y) *y = s->img_y;
	if (comp) {
		if (info.bpp == 24 && info.ma == 0xff000000)
			*comp = 3;
		else
			*comp = info.ma ? 4 : 3;
	}
	return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
	int channelCount, dummy, depth;
	if (!x) x = &dummy;
	if (!y) y = &dummy;
	if (!comp) comp = &dummy;
	if (stbi__get32be(s) != 0x38425053) {
		stbi__rewind(s);
		return 0;
	}
	if (stbi__get16be(s) != 1) {
		stbi__rewind(s);
		return 0;
	}
	stbi__skip(s, 6);
	channelCount = stbi__get16be(s);
	if (channelCount < 0 || channelCount > 16) {
		stbi__rewind(s);
		return 0;
	}
	*y = stbi__get32be(s);
	*x = stbi__get32be(s);
	depth = stbi__get16be(s);
	if (depth != 8 && depth != 16) {
		stbi__rewind(s);
		return 0;
	}
	if (stbi__get16be(s) != 3) {
		stbi__rewind(s);
		return 0;
	}
	*comp = 4;
	return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
	int channelCount, depth;
	if (stbi__get32be(s) != 0x38425053) {
		stbi__rewind(s);
		return 0;
	}
	if (stbi__get16be(s) != 1) {
		stbi__rewind(s);
		return 0;
	}
	stbi__skip(s, 6);
	channelCount = stbi__get16be(s);
	if (channelCount < 0 || channelCount > 16) {
		stbi__rewind(s);
		return 0;
	}
	(void)stbi__get32be(s);
	(void)stbi__get32be(s);
	depth = stbi__get16be(s);
	if (depth != 16) {
		stbi__rewind(s);
		return 0;
	}
	return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
	int act_comp = 0, num_packets = 0, chained, dummy;
	stbi__pic_packet packets[10];

	if (!x) x = &dummy;
	if (!y) y = &dummy;
	if (!comp) comp = &dummy;

	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34")) {
		stbi__rewind(s);
		return 0;
	}

	stbi__skip(s, 88);

	*x = stbi__get16be(s);
	*y = stbi__get16be(s);
	if (stbi__at_eof(s)) {
		stbi__rewind(s);
		return 0;
	}
	if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {
		stbi__rewind(s);
		return 0;
	}

	stbi__skip(s, 8);

	do {
		stbi__pic_packet *packet;

		if (num_packets == sizeof(packets) / sizeof(packets[0]))
			return 0;

		packet = &packets[num_packets++];
		chained = stbi__get8(s);
		packet->size = stbi__get8(s);
		packet->type = stbi__get8(s);
		packet->channel = stbi__get8(s);
		act_comp |= packet->channel;

		if (stbi__at_eof(s)) {
			stbi__rewind(s);
			return 0;
		}
		if (packet->size != 8) {
			stbi__rewind(s);
			return 0;
		}
	} while (chained);

	*comp = (act_comp & 0x10 ? 4 : 3);

	return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)
//    Does not support 16-bit-per-channel

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
	char p, t;
	p = (char)stbi__get8(s);
	t = (char)stbi__get8(s);
	if (p != 'P' || (t != '5' && t != '6')) {
		stbi__rewind(s);
		return 0;
	}
	return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
	stbi_uc *out;
	STBI_NOTUSED(ri);

	if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
		return 0;

	*x = s->img_x;
	*y = s->img_y;
	if (comp) *comp = s->img_n;

	if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
		return stbi__errpuc("too large", "PNM too large");

	out = (stbi_uc *)stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
	if (!out) return stbi__errpuc("outofmem", "Out of memory");
	stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

	if (req_comp && req_comp != s->img_n) {
		out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
		if (out == NULL) return out; // stbi__convert_format frees input on failure
	}
	return out;
}

static int      stbi__pnm_isspace(char c)
{
	return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
	for (;;) {
		while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
			*c = (char)stbi__get8(s);

		if (stbi__at_eof(s) || *c != '#')
			break;

		while (!stbi__at_eof(s) && *c != '\n' && *c != '\r')
			*c = (char)stbi__get8(s);
	}
}

static int      stbi__pnm_isdigit(char c)
{
	return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
	int value = 0;

	while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
		value = value * 10 + (*c - '0');
		*c = (char)stbi__get8(s);
	}

	return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
	int maxv, dummy;
	char c, p, t;

	if (!x) x = &dummy;
	if (!y) y = &dummy;
	if (!comp) comp = &dummy;

	stbi__rewind(s);

	// Get identifier
	p = (char)stbi__get8(s);
	t = (char)stbi__get8(s);
	if (p != 'P' || (t != '5' && t != '6')) {
		stbi__rewind(s);
		return 0;
	}

	*comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

	c = (char)stbi__get8(s);
	stbi__pnm_skip_whitespace(s, &c);

	*x = stbi__pnm_getinteger(s, &c); // read width
	stbi__pnm_skip_whitespace(s, &c);

	*y = stbi__pnm_getinteger(s, &c); // read height
	stbi__pnm_skip_whitespace(s, &c);

	maxv = stbi__pnm_getinteger(s, &c);  // read max value

	if (maxv > 255)
		return stbi__err("max value > 255", "PPM image not 8-bit");
	else
		return 1;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
#ifndef STBI_NO_JPEG
	if (stbi__jpeg_info(s, x, y, comp)) return 1;
#endif

#ifndef STBI_NO_PNG
	if (stbi__png_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_GIF
	if (stbi__gif_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_BMP
	if (stbi__bmp_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PSD
	if (stbi__psd_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PIC
	if (stbi__pic_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PNM
	if (stbi__pnm_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_HDR
	if (stbi__hdr_info(s, x, y, comp))  return 1;
#endif

	// test tga last because it's a crappy test!
#ifndef STBI_NO_TGA
	if (stbi__tga_info(s, x, y, comp))
		return 1;
#endif
	return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
#ifndef STBI_NO_PNG
	if (stbi__png_is16(s))  return 1;
#endif

#ifndef STBI_NO_PSD
	if (stbi__psd_is16(s))  return 1;
#endif

	return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result;
	if (!f) return stbi__err("can't fopen", "Unable to open file");
	result = stbi_info_from_file(f, x, y, comp);
	fclose(f);
	return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
	int r;
	stbi__context s;
	long pos = ftell(f);
	stbi__start_file(&s, f);
	r = stbi__info_main(&s, x, y, comp);
	fseek(f, pos, SEEK_SET);
	return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result;
	if (!f) return stbi__err("can't fopen", "Unable to open file");
	result = stbi_is_16_bit_from_file(f);
	fclose(f);
	return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
	int r;
	stbi__context s;
	long pos = ftell(f);
	stbi__start_file(&s, f);
	r = stbi__is_16_main(&s);
	fseek(f, pos, SEEK_SET);
	return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__info_main(&s, x, y, comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)c, user);
	return stbi__info_main(&s, x, y, comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
	stbi__context s;
	stbi__start_mem(&s, buffer, len);
	return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *)c, user);
	return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
	  2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
	  2.19  (2018-02-11) fix warning
	  2.18  (2018-01-30) fix warnings
	  2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
						 1-bit BMP
						 *_is_16_bit api
						 avoid warnings
	  2.16  (2017-07-23) all functions have 16-bit variants;
						 STBI_NO_STDIO works again;
						 compilation fixes;
						 fix rounding in unpremultiply;
						 optimize vertical flip;
						 disable raw_len validation;
						 documentation fixes
	  2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
						 warning fixes; disable run-time SSE detection on gcc;
						 uniform handling of optional "return" values;
						 thread-safe initialization of zlib tables
	  2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
	  2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
	  2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
	  2.11  (2016-04-02) allocate large structures on the stack
						 remove white matting for transparent PSD
						 fix reported channel count for PNG & BMP
						 re-enable SSE2 in non-gcc 64-bit
						 support RGB-formatted JPEG
						 read 16-bit PNGs (only as 8-bit)
	  2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
	  2.09  (2016-01-16) allow comments in PNM files
						 16-bit-per-pixel TGA (not bit-per-component)
						 info() for TGA could break due to .hdr handling
						 info() for BMP to shares code instead of sloppy parse
						 can use STBI_REALLOC_SIZED if allocator doesn't support realloc
						 code cleanup
	  2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
	  2.07  (2015-09-13) fix compiler warnings
						 partial animated GIF support
						 limited 16-bpc PSD support
						 #ifdef unused functions
						 bug with < 92 byte PIC,PNM,HDR,TGA
	  2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
	  2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
	  2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
	  2.03  (2015-04-12) extra corruption checking (mmozeiko)
						 stbi_set_flip_vertically_on_load (nguillemot)
						 fix NEON support; fix mingw support
	  2.02  (2015-01-19) fix incorrect assert, fix warning
	  2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
	  2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
	  2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
						 progressive JPEG (stb)
						 PGM/PPM support (Ken Miller)
						 STBI_MALLOC,STBI_REALLOC,STBI_FREE
						 GIF bugfix -- seemingly never worked
						 STBI_NO_*, STBI_ONLY_*
	  1.48  (2014-12-14) fix incorrectly-named assert()
	  1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
						 optimize PNG (ryg)
						 fix bug in interlaced PNG with user-specified channel count (stb)
	  1.46  (2014-08-26)
			  fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
	  1.45  (2014-08-16)
			  fix MSVC-ARM internal compiler error by wrapping malloc
	  1.44  (2014-08-07)
			  various warning fixes from Ronny Chevalier
	  1.43  (2014-07-15)
			  fix MSVC-only compiler problem in code changed in 1.42
	  1.42  (2014-07-09)
			  don't define _CRT_SECURE_NO_WARNINGS (affects user code)
			  fixes to stbi__cleanup_jpeg path
			  added STBI_ASSERT to avoid requiring assert.h
	  1.41  (2014-06-25)
			  fix search&replace from 1.36 that messed up comments/error messages
	  1.40  (2014-06-22)
			  fix gcc struct-initialization warning
	  1.39  (2014-06-15)
			  fix to TGA optimization when req_comp != number of components in TGA;
			  fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
			  add support for BMP version 5 (more ignored fields)
	  1.38  (2014-06-06)
			  suppress MSVC warnings on integer casts truncating values
			  fix accidental rename of 'skip' field of I/O
	  1.37  (2014-06-04)
			  remove duplicate typedef
	  1.36  (2014-06-03)
			  convert to header file single-file library
			  if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
	  1.35  (2014-05-27)
			  various warnings
			  fix broken STBI_SIMD path
			  fix bug where stbi_load_from_file no longer left file pointer in correct place
			  fix broken non-easy path for 32-bit BMP (possibly never used)
			  TGA optimization by Arseny Kapoulkine
	  1.34  (unknown)
			  use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
	  1.33  (2011-07-14)
			  make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
	  1.32  (2011-07-13)
			  support for "info" function for all supported filetypes (SpartanJ)
	  1.31  (2011-06-20)
			  a few more leak fixes, bug in PNG handling (SpartanJ)
	  1.30  (2011-06-11)
			  added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
			  removed deprecated format-specific test/load functions
			  removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
			  error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
			  fix inefficiency in decoding 32-bit BMP (David Woo)
	  1.29  (2010-08-16)
			  various warning fixes from Aurelien Pocheville
	  1.28  (2010-08-01)
			  fix bug in GIF palette transparency (SpartanJ)
	  1.27  (2010-08-01)
			  cast-to-stbi_uc to fix warnings
	  1.26  (2010-07-24)
			  fix bug in file buffering for PNG reported by SpartanJ
	  1.25  (2010-07-17)
			  refix trans_data warning (Won Chun)
	  1.24  (2010-07-12)
			  perf improvements reading from files on platforms with lock-heavy fgetc()
			  minor perf improvements for jpeg
			  deprecated type-specific functions so we'll get feedback if they're needed
			  attempt to fix trans_data warning (Won Chun)
	  1.23    fixed bug in iPhone support
	  1.22  (2010-07-10)
			  removed image *writing* support
			  stbi_info support from Jetro Lauha
			  GIF support from Jean-Marc Lienher
			  iPhone PNG-extensions from James Brown
			  warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
	  1.21    fix use of 'stbi_uc' in header (reported by jon blow)
	  1.20    added support for Softimage PIC, by Tom Seddon
	  1.19    bug in interlaced PNG corruption check (found by ryg)
	  1.18  (2008-08-02)
			  fix a threading bug (local mutable static)
	  1.17    support interlaced PNG
	  1.16    major bugfix - stbi__convert_format converted one too many pixels
	  1.15    initialize some fields for thread safety
	  1.14    fix threadsafe conversion bug
			  header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
	  1.13    threadsafe
	  1.12    const qualifiers in the API
	  1.11    Support installable IDCT, colorspace conversion routines
	  1.10    Fixes for 64-bit (don't use "unsigned long")
			  optimized upsampling by Fabian "ryg" Giesen
	  1.09    Fix format-conversion for PSD code (bad global variables!)
	  1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
	  1.07    attempt to fix C++ warning/errors again
	  1.06    attempt to fix C++ warning/errors again
	  1.05    fix TGA loading to return correct *comp and use good luminance calc
	  1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
	  1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
	  1.02    support for (subset of) HDR files, float interface for preferred access to them
	  1.01    fix bug: possible bug in handling right-side up bmps... not sure
			  fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
	  1.00    interface to zlib that skips zlib header
	  0.99    correct handling of alpha in palette
	  0.98    TGA loader by lonesock; dynamically add loaders (untested)
	  0.97    jpeg errors on too large a file; also catch another malloc failure
	  0.96    fix detection of invalid v value - particleman@mollyrocket forum
	  0.95    during header scan, seek to markers in case of padding
	  0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
	  0.93    handle jpegtran output; verbose errors
	  0.92    read 4,8,16,24,32-bit BMP files of several formats
	  0.91    output 24-bit Windows 3.0 BMP files
	  0.90    fix a few more warnings; bump version number to approach 1.0
	  0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
	  0.60    fix compiling as c++
	  0.59    fix warnings: merge Dave Moore's -Wall fixes
	  0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
	  0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
	  0.56    fix bug: zlib uncompressed mode len vs. nlen
	  0.55    fix bug: restart_interval not initialized to 0
	  0.54    allow NULL for 'int *comp'
	  0.53    fix bug in png 3->4; speedup png decoding
	  0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
	  0.51    obey req_comp requests, 1-component jpegs return as 1-component,
			  on 'test' only check type, not whether we support this variant
	  0.50  (2006-11-19)
			  first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
```

`Hazelnut/SandboxProject/Assets/Scenes/3DExample.hazel`:

```hazel
Scene: Untitled
Entities:
  - Entity: 9335076965011521498
    TagComponent:
      Tag: Camera B
    TransformComponent:
      Translation: [0.899999976, 0, 6]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    CameraComponent:
      Camera:
        ProjectionType: 0
        PerspectiveFOV: 0.785398185
        PerspectiveNear: 0.00999999978
        PerspectiveFar: 1000
        OrthographicSize: 10
        OrthographicNear: -1
        OrthographicFar: 1
      Primary: true
      FixedAspectRatio: false
  - Entity: 3480369648141931921
    TagComponent:
      Tag: Camera A
    TransformComponent:
      Translation: [0, 0, 0]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    CameraComponent:
      Camera:
        ProjectionType: 1
        PerspectiveFOV: 0.785398185
        PerspectiveNear: 0.00999999978
        PerspectiveFar: 1000
        OrthographicSize: 10
        OrthographicNear: -1
        OrthographicFar: 1
      Primary: false
      FixedAspectRatio: false
  - Entity: 4212786185008784347
    TagComponent:
      Tag: Red Square
    TransformComponent:
      Translation: [0, 1.10000002, 0]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    SpriteRendererComponent:
      Color: [1, 0, 0, 1]
  - Entity: 6902904111259729925
    TagComponent:
      Tag: Green Square
    TransformComponent:
      Translation: [2.4000001, 0, -4.80000019]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    SpriteRendererComponent:
      Color: [0, 1, 0, 1]
```

`Hazelnut/SandboxProject/Assets/Scenes/Example.hazel`:

```hazel
Scene: Untitled
Entities:
  - Entity: 3263328598497060330
    TagComponent:
      Tag: Camera B
    TransformComponent:
      Translation: [0, 0, 0]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    CameraComponent:
      Camera:
        ProjectionType: 1
        PerspectiveFOV: 0.785398185
        PerspectiveNear: 0.00999999978
        PerspectiveFar: 1000
        OrthographicSize: 10
        OrthographicNear: -1
        OrthographicFar: 1
      Primary: false
      FixedAspectRatio: false
  - Entity: 3503638098362915787
    TagComponent:
      Tag: Camera A
    TransformComponent:
      Translation: [0, 0, 0]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    CameraComponent:
      Camera:
        ProjectionType: 1
        PerspectiveFOV: 0.785398185
        PerspectiveNear: 0.00999999978
        PerspectiveFar: 1000
        OrthographicSize: 10
        OrthographicNear: -1
        OrthographicFar: 1
      Primary: true
      FixedAspectRatio: false
  - Entity: 17154294327283940743
    TagComponent:
      Tag: Cherno Square
    TransformComponent:
      Translation: [-1.09518838, 1.10000002, 0]
      Rotation: [0, 0, 0]
      Scale: [4.40999985, 4.40999985, 4.40999985]
    SpriteRendererComponent:
      Color: [1, 0.999989986, 0.999989986, 1]
      TexturePath: Textures\ChernoLogo.png
      TilingFactor: 1
  - Entity: 6645248621277955267
    TagComponent:
      Tag: CheckerboardBG
    TransformComponent:
      Translation: [2.4000001, 0, -12.255374]
      Rotation: [0, 0, 0]
      Scale: [20, 20, 20]
    SpriteRendererComponent:
      Color: [0.999989986, 1, 0.999989986, 1]
      TexturePath: Textures\Checkerboard.png
      TilingFactor: 10

```

`Hazelnut/SandboxProject/Assets/Scenes/Physics2D.hazel`:

```hazel
Scene: Untitled
Entities:
  - Entity: 16672940118998907085
    TagComponent:
      Tag: Floor
    TransformComponent:
      Translation: [-0.883175671, -1.09447932, 0]
      Rotation: [0, 0, -0.638996005]
      Scale: [6.74196768, 0.46067813, 1]
    SpriteRendererComponent:
      Color: [0.949806929, 0.455301404, 0.0660097376, 1]
      TilingFactor: 1
    Rigidbody2DComponent:
      BodyType: Static
      FixedRotation: false
    BoxCollider2DComponent:
      Offset: [0, 0]
      Size: [0.5, 0.5]
      Density: 1
      Friction: 0.5
      Restitution: 0
      RestitutionThreshold: 0.5
  - Entity: 4793924497264767156
    TagComponent:
      Tag: Camera
    TransformComponent:
      Translation: [0, 0, 4.99711323]
      Rotation: [0, 0, 0]
      Scale: [1, 1, 1]
    CameraComponent:
      Camera:
        ProjectionType: 0
        PerspectiveFOV: 0.785398185
        PerspectiveNear: 0.00999999978
        PerspectiveFar: 1000
        OrthographicSize: 10
        OrthographicNear: -1
        OrthographicFar: 1
      Primary: true
      FixedAspectRatio: false
    ScriptComponent:
      ClassName: Sandbox.Camera
      ScriptFields:
        - Name: DistanceFromPlayer
          Type: Float
          Data: 5
  - Entity: 15045535320033348975
    TagComponent:
      Tag: Block
    TransformComponent:
      Translation: [-0.560881913, 0.980064034, 0.0225147791]
      Rotation: [0, 0, 0]
      Scale: [0.361159712, 0.375572056, 0.848135769]
    SpriteRendererComponent:
      Color: [0.277992249, 0.277989477, 0.277989477, 1]
      TilingFactor: 1
    Rigidbody2DComponent:
      BodyType: Dynamic
      FixedRotation: false
    BoxCollider2DComponent:
      Offset: [0, 0]
      Size: [0.5, 0.5]
      Density: 0.879999995
      Friction: 0.100000001
      Restitution: 0.819999993
      RestitutionThreshold: 0.5
  - Entity: 5134011587522944740
    TagComponent:
      Tag: Floor
    TransformComponent:
      Translation: [2.3506453, -1.84539962, 0]
      Rotation: [0, 0, 0.603692532]
      Scale: [6.74196959, 0.46067816, 1]
    SpriteRendererComponent:
      Color: [0.949806929, 0.455301404, 0.0660097376, 1]
      TilingFactor: 1
    Rigidbody2DComponent:
      BodyType: Static
      FixedRotation: false
    BoxCollider2DComponent:
      Offset: [0, 0]
      Size: [0.5, 0.5]
      Density: 1
      Friction: 0.5
      Restitution: 0
      RestitutionThreshold: 0.5
  - Entity: 8804479042241551551
    TagComponent:
      Tag: Circle
    TransformComponent:
      Translation: [1.02738881, -1.70331478, 0]
      Rotation: [0, 0, 0]
      Scale: [2.15999985, 2.15999985, 2.15999985]
    CircleRendererComponent:
      Color: [0.934362948, 0.362345755, 0.057721246, 1]
      Thickness: 0.100000001
      Fade: 0.00499999989
    Rigidbody2DComponent:
      BodyType: Static
      FixedRotation: false
    CircleCollider2DComponent:
      Offset: [0, 0]
      Radius: 0.5
      Density: 1
      Friction: 0.5
      Restitution: 0
      RestitutionThreshold: 0.5
  - Entity: 8254140920860137284
    TagComponent:
      Tag: Player
    TransformComponent:
      Translation: [0.0495706201, 0.271503896, 0.0225147791]
      Rotation: [0, 0, -0.235084534]
      Scale: [0.361159712, 0.375572056, 0.848135769]
    ScriptComponent:
      ClassName: Sandbox.Player
      ScriptFields:
        - Name: Speed
          Type: Float
          Data: 1.25
    SpriteRendererComponent:
      Color: [1, 1, 1, 1]
      TilingFactor: 1
    Rigidbody2DComponent:
      BodyType: Dynamic
      FixedRotation: false
    BoxCollider2DComponent:
      Offset: [0, 0]
      Size: [0.5, 0.5]
      Density: 0.879999995
      Friction: 0.100000001
      Restitution: 0.819999993
      RestitutionThreshold: 0.5
```

`Hazelnut/SandboxProject/Assets/Scenes/PinkCube.hazel`:

```hazel
Scene: Untitled
Entities:
  - Entity: 8244940659429586525
    TagComponent:
      Tag: Left
    TransformComponent:
      Translation: [-0.354999989, 0, 0.349999994]
      Rotation: [0, -0.785398185, 0]
      Scale: [1, 1, 1]
    SpriteRendererComponent:
      Color: [1, 0, 0.949807167, 1]
  - Entity: 2335431429201735937
    TagComponent:
      Tag: Right
    TransformComponent:
      Translation: [0.351999998, 0, 0.349999994]
      Rotation: [0, 0.785398185, 0]
      Scale: [1, 1, 1]
    SpriteRendererComponent:
      Color: [0.54842025, 0, 0.586872578, 1]
  - Entity: 15355018394736438603
    TagComponent:
      Tag: Camera
    TransformComponent:
      Translation: [0, 1.70000005, 4]
      Rotation: [-0.404916406, 0, 0]
      Scale: [1, 1, 1]
    CameraComponent:
      Camera:
        ProjectionType: 0
        PerspectiveFOV: 0.52359879
        PerspectiveNear: 0.00999999978
        PerspectiveFar: 1000
        OrthographicSize: 10
        OrthographicNear: -1
        OrthographicFar: 1
      Primary: true
      FixedAspectRatio: false
  - Entity: 9235617827118161440
    TagComponent:
      Tag: Top
    TransformComponent:
      Translation: [0, 0.5, 0]
      Rotation: [1.57079637, 0.785398185, 0]
      Scale: [1, 1, 1]
    SpriteRendererComponent:
      Color: [0.876447856, 0, 0.834712803, 1]
```

`Hazelnut/SandboxProject/Assets/Scripts/Source/Camera.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Hazel;

namespace Sandbox
{
	public class Camera : Entity
	{
		public Entity OtherEntity;

		public float DistanceFromPlayer = 5.0f;

		private Entity m_Player;

		void OnCreate()
		{
			m_Player = FindEntityByName("Player");
		}

		void OnUpdate(float ts)
		{
			if (m_Player != null)
				Translation = new Vector3(m_Player.Translation.XY, DistanceFromPlayer);

			float speed = 1.0f;
			Vector3 velocity = Vector3.Zero;

			if (Input.IsKeyDown(KeyCode.Up))
				velocity.Y = 1.0f;
			else if (Input.IsKeyDown(KeyCode.Down))
				velocity.Y = -1.0f;

			if (Input.IsKeyDown(KeyCode.Left))
				velocity.X = -1.0f;
			else if (Input.IsKeyDown(KeyCode.Right))
				velocity.X = 1.0f;

			velocity *= speed;

			Vector3 translation = Translation;
			translation += velocity * ts;
			Translation = translation;
		}

	}
}

```

`Hazelnut/SandboxProject/Assets/Scripts/Source/Player.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Hazel;

namespace Sandbox
{
	public class Player : Entity
	{
		private TransformComponent m_Transform;
		private Rigidbody2DComponent m_Rigidbody;

		public float Speed;
		public float Time = 0.0f;

		void OnCreate()
		{
			Console.WriteLine($"Player.OnCreate - {ID}");

			m_Transform = GetComponent<TransformComponent>();
			m_Rigidbody = GetComponent<Rigidbody2DComponent>();
		}

		void OnUpdate(float ts)
		{
			Time += ts;
			// Console.WriteLine($"Player.OnUpdate: {ts}");

			float speed = Speed;
			Vector3 velocity = Vector3.Zero;

			if (Input.IsKeyDown(KeyCode.W))
				velocity.Y = 1.0f;
			else if (Input.IsKeyDown(KeyCode.S))
				velocity.Y = -1.0f;

			if (Input.IsKeyDown(KeyCode.A))
				velocity.X = -1.0f;
			else if (Input.IsKeyDown(KeyCode.D))
				velocity.X = 1.0f;

			Entity cameraEntity = FindEntityByName("Camera");
			if (cameraEntity != null)
			{
				Camera camera = cameraEntity.As<Camera>();

				if (Input.IsKeyDown(KeyCode.Q))
					camera.DistanceFromPlayer += speed * 2.0f * ts;
				else if (Input.IsKeyDown(KeyCode.E))
					camera.DistanceFromPlayer -= speed * 2.0f * ts;
			}

			velocity *= speed * ts;

			m_Rigidbody.ApplyLinearImpulse(velocity.XY, true);

			//Vector3 translation = m_Transform.Translation;
			//translation += velocity * ts;
			//m_Transform.Translation = translation;
		}

	}
}

```

`Hazelnut/SandboxProject/Assets/Scripts/Win-GenProjects.bat`:

```bat
@echo off
call ..\..\..\..\vendor\premake\bin\premake5.exe vs2022
PAUSE

```

`Hazelnut/SandboxProject/Assets/Scripts/premake5.lua`:

```lua
local HazelRootDir = '../../../..'
include (HazelRootDir .. "/vendor/premake/premake_customization/solution_items.lua")

workspace "Sandbox"
	architecture "x86_64"
	startproject "Sandbox"

	configurations
	{
		"Debug",
		"Release",
		"Dist"
	}

	flags
	{
		"MultiProcessorCompile"
	}

outputdir = "%{cfg.buildcfg}-%{cfg.system}-%{cfg.architecture}"

project "Sandbox"
	kind "SharedLib"
	language "C#"
	dotnetframework "4.7.2"

	targetdir ("Binaries")
	objdir ("Intermediates")

	files 
	{
		"Source/**.cs",
		"Properties/**.cs"
	}

	links
	{
		"Hazel-ScriptCore"
	}
	
	filter "configurations:Debug"
		optimize "Off"
		symbols "Default"

	filter "configurations:Release"
		optimize "On"
		symbols "Default"

	filter "configurations:Dist"
		optimize "Full"
		symbols "Off"

group "Hazel"
	include (HazelRootDir .. "/Hazel-ScriptCore")
group ""

```

`Hazelnut/SandboxProject/Sandbox.hproj`:

```hproj
Project:
  Name: Sandbox
  StartScene: "Scenes/Physics2D.hazel"
  AssetDirectory: "Assets"
  ScriptModulePath: "Scripts/Binaries/Sandbox.dll"

```

`Hazelnut/assets/fonts/opensans/LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`Hazelnut/assets/shaders/FlatColor.glsl`:

```glsl
// Flat Color Shader

#type vertex
#version 330 core

layout(location = 0) in vec3 a_Position;

uniform mat4 u_ViewProjection;
uniform mat4 u_Transform;

void main()
{
	gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);
}

#type fragment
#version 330 core

layout(location = 0) out vec4 color;

uniform vec4 u_Color;

void main()
{
	color = u_Color;
}
```

`Hazelnut/assets/shaders/Renderer2D_Circle.glsl`:

```glsl
//--------------------------
// - Hazel 2D -
// Renderer2D Circle Shader
// --------------------------

#type vertex
#version 450 core

layout(location = 0) in vec3 a_WorldPosition;
layout(location = 1) in vec3 a_LocalPosition;
layout(location = 2) in vec4 a_Color;
layout(location = 3) in float a_Thickness;
layout(location = 4) in float a_Fade;
layout(location = 5) in int a_EntityID;

layout(std140, binding = 0) uniform Camera
{
	mat4 u_ViewProjection;
};

struct VertexOutput
{
	vec3 LocalPosition;
	vec4 Color;
	float Thickness;
	float Fade;
};

layout (location = 0) out VertexOutput Output;
layout (location = 4) out flat int v_EntityID;

void main()
{
	Output.LocalPosition = a_LocalPosition;
	Output.Color = a_Color;
	Output.Thickness = a_Thickness;
	Output.Fade = a_Fade;

	v_EntityID = a_EntityID;

	gl_Position = u_ViewProjection * vec4(a_WorldPosition, 1.0);
}

#type fragment
#version 450 core

layout(location = 0) out vec4 o_Color;
layout(location = 1) out int o_EntityID;

struct VertexOutput
{
	vec3 LocalPosition;
	vec4 Color;
	float Thickness;
	float Fade;
};

layout (location = 0) in VertexOutput Input;
layout (location = 4) in flat int v_EntityID;

void main()
{
    // Calculate distance and fill circle with white
    float distance = 1.0 - length(Input.LocalPosition);
    float circle = smoothstep(0.0, Input.Fade, distance);
    circle *= smoothstep(Input.Thickness + Input.Fade, Input.Thickness, distance);

	if (circle == 0.0)
		discard;

    // Set output color
    o_Color = Input.Color;
	o_Color.a *= circle;

	o_EntityID = v_EntityID;
}

```

`Hazelnut/assets/shaders/Renderer2D_Line.glsl`:

```glsl
//--------------------------
// - Hazel 2D -
// Renderer2D Line Shader
// --------------------------

#type vertex
#version 450 core

layout(location = 0) in vec3 a_Position;
layout(location = 1) in vec4 a_Color;
layout(location = 2) in int a_EntityID;

layout(std140, binding = 0) uniform Camera
{
	mat4 u_ViewProjection;
};

struct VertexOutput
{
	vec4 Color;
};

layout (location = 0) out VertexOutput Output;
layout (location = 1) out flat int v_EntityID;

void main()
{
	Output.Color = a_Color;
	v_EntityID = a_EntityID;

	gl_Position = u_ViewProjection * vec4(a_Position, 1.0);
}

#type fragment
#version 450 core

layout(location = 0) out vec4 o_Color;
layout(location = 1) out int o_EntityID;

struct VertexOutput
{
	vec4 Color;
};

layout (location = 0) in VertexOutput Input;
layout (location = 1) in flat int v_EntityID;

void main()
{
	o_Color = Input.Color;
	o_EntityID = v_EntityID;
}

```

`Hazelnut/assets/shaders/Renderer2D_Quad.glsl`:

```glsl
// Basic Texture Shader

#type vertex
#version 450 core

layout(location = 0) in vec3 a_Position;
layout(location = 1) in vec4 a_Color;
layout(location = 2) in vec2 a_TexCoord;
layout(location = 3) in float a_TexIndex;
layout(location = 4) in float a_TilingFactor;
layout(location = 5) in int a_EntityID;

layout(std140, binding = 0) uniform Camera
{
	mat4 u_ViewProjection;
};

struct VertexOutput
{
	vec4 Color;
	vec2 TexCoord;
	float TilingFactor;
};

layout (location = 0) out VertexOutput Output;
layout (location = 3) out flat float v_TexIndex;
layout (location = 4) out flat int v_EntityID;

void main()
{
	Output.Color = a_Color;
	Output.TexCoord = a_TexCoord;
	Output.TilingFactor = a_TilingFactor;
	v_TexIndex = a_TexIndex;
	v_EntityID = a_EntityID;

	gl_Position = u_ViewProjection * vec4(a_Position, 1.0);
}

#type fragment
#version 450 core

layout(location = 0) out vec4 o_Color;
layout(location = 1) out int o_EntityID;

struct VertexOutput
{
	vec4 Color;
	vec2 TexCoord;
	float TilingFactor;
};

layout (location = 0) in VertexOutput Input;
layout (location = 3) in flat float v_TexIndex;
layout (location = 4) in flat int v_EntityID;

layout (binding = 0) uniform sampler2D u_Textures[32];

void main()
{
	vec4 texColor = Input.Color;

	switch(int(v_TexIndex))
	{
		case  0: texColor *= texture(u_Textures[ 0], Input.TexCoord * Input.TilingFactor); break;
		case  1: texColor *= texture(u_Textures[ 1], Input.TexCoord * Input.TilingFactor); break;
		case  2: texColor *= texture(u_Textures[ 2], Input.TexCoord * Input.TilingFactor); break;
		case  3: texColor *= texture(u_Textures[ 3], Input.TexCoord * Input.TilingFactor); break;
		case  4: texColor *= texture(u_Textures[ 4], Input.TexCoord * Input.TilingFactor); break;
		case  5: texColor *= texture(u_Textures[ 5], Input.TexCoord * Input.TilingFactor); break;
		case  6: texColor *= texture(u_Textures[ 6], Input.TexCoord * Input.TilingFactor); break;
		case  7: texColor *= texture(u_Textures[ 7], Input.TexCoord * Input.TilingFactor); break;
		case  8: texColor *= texture(u_Textures[ 8], Input.TexCoord * Input.TilingFactor); break;
		case  9: texColor *= texture(u_Textures[ 9], Input.TexCoord * Input.TilingFactor); break;
		case 10: texColor *= texture(u_Textures[10], Input.TexCoord * Input.TilingFactor); break;
		case 11: texColor *= texture(u_Textures[11], Input.TexCoord * Input.TilingFactor); break;
		case 12: texColor *= texture(u_Textures[12], Input.TexCoord * Input.TilingFactor); break;
		case 13: texColor *= texture(u_Textures[13], Input.TexCoord * Input.TilingFactor); break;
		case 14: texColor *= texture(u_Textures[14], Input.TexCoord * Input.TilingFactor); break;
		case 15: texColor *= texture(u_Textures[15], Input.TexCoord * Input.TilingFactor); break;
		case 16: texColor *= texture(u_Textures[16], Input.TexCoord * Input.TilingFactor); break;
		case 17: texColor *= texture(u_Textures[17], Input.TexCoord * Input.TilingFactor); break;
		case 18: texColor *= texture(u_Textures[18], Input.TexCoord * Input.TilingFactor); break;
		case 19: texColor *= texture(u_Textures[19], Input.TexCoord * Input.TilingFactor); break;
		case 20: texColor *= texture(u_Textures[20], Input.TexCoord * Input.TilingFactor); break;
		case 21: texColor *= texture(u_Textures[21], Input.TexCoord * Input.TilingFactor); break;
		case 22: texColor *= texture(u_Textures[22], Input.TexCoord * Input.TilingFactor); break;
		case 23: texColor *= texture(u_Textures[23], Input.TexCoord * Input.TilingFactor); break;
		case 24: texColor *= texture(u_Textures[24], Input.TexCoord * Input.TilingFactor); break;
		case 25: texColor *= texture(u_Textures[25], Input.TexCoord * Input.TilingFactor); break;
		case 26: texColor *= texture(u_Textures[26], Input.TexCoord * Input.TilingFactor); break;
		case 27: texColor *= texture(u_Textures[27], Input.TexCoord * Input.TilingFactor); break;
		case 28: texColor *= texture(u_Textures[28], Input.TexCoord * Input.TilingFactor); break;
		case 29: texColor *= texture(u_Textures[29], Input.TexCoord * Input.TilingFactor); break;
		case 30: texColor *= texture(u_Textures[30], Input.TexCoord * Input.TilingFactor); break;
		case 31: texColor *= texture(u_Textures[31], Input.TexCoord * Input.TilingFactor); break;
	}

	if (texColor.a == 0.0)
		discard;

	o_Color = texColor;
	o_EntityID = v_EntityID;
}

```

`Hazelnut/assets/shaders/Renderer2D_Text.glsl`:

```glsl
// MSDF text shader

#type vertex
#version 450 core

layout(location = 0) in vec3 a_Position;
layout(location = 1) in vec4 a_Color;
layout(location = 2) in vec2 a_TexCoord;
layout(location = 3) in int a_EntityID;

layout(std140, binding = 0) uniform Camera
{
	mat4 u_ViewProjection;
};

struct VertexOutput
{
	vec4 Color;
	vec2 TexCoord;
};

layout (location = 0) out VertexOutput Output;
layout (location = 2) out flat int v_EntityID;

void main()
{
	Output.Color = a_Color;
	Output.TexCoord = a_TexCoord;
	v_EntityID = a_EntityID;

	gl_Position = u_ViewProjection * vec4(a_Position, 1.0);
}

#type fragment
#version 450 core

layout(location = 0) out vec4 o_Color;
layout(location = 1) out int o_EntityID;

struct VertexOutput
{
	vec4 Color;
	vec2 TexCoord;
};

layout (location = 0) in VertexOutput Input;
layout (location = 2) in flat int v_EntityID;

layout (binding = 0) uniform sampler2D u_FontAtlas;

float screenPxRange() {
	const float pxRange = 2.0; // set to distance field's pixel range
    vec2 unitRange = vec2(pxRange)/vec2(textureSize(u_FontAtlas, 0));
    vec2 screenTexSize = vec2(1.0)/fwidth(Input.TexCoord);
    return max(0.5*dot(unitRange, screenTexSize), 1.0);
}

float median(float r, float g, float b) {
    return max(min(r, g), min(max(r, g), b));
}

void main()
{
	vec4 texColor = Input.Color * texture(u_FontAtlas, Input.TexCoord);

	vec3 msd = texture(u_FontAtlas, Input.TexCoord).rgb;
    float sd = median(msd.r, msd.g, msd.b);
    float screenPxDistance = screenPxRange()*(sd - 0.5);
    float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	if (opacity == 0.0)
		discard;

	vec4 bgColor = vec4(0.0);
    o_Color = mix(bgColor, Input.Color, opacity);
	if (o_Color.a == 0.0)
		discard;
	
	o_EntityID = v_EntityID;
}

```

`Hazelnut/imgui.ini`:

```ini
[Window][DockSpace Demo]
Pos=0,0
Size=1600,900
Collapsed=0

[Window][Debug##Default]
ViewportPos=1180,1184
ViewportId=0x9F5F46A1
Size=400,400
Collapsed=0

[Window][Settings]
Pos=1264,465
Size=336,435
Collapsed=0
DockId=0x00000004,0

[Window][Viewport]
Pos=372,69
Size=890,614
Collapsed=0
DockId=0x0000000C,0

[Window][Scene Hierarchy]
Pos=0,24
Size=370,435
Collapsed=0
DockId=0x00000005,0

[Window][Dear ImGui Demo]
ViewportPos=336,212
ViewportId=0xE927CF2F
Size=1421,1027
Collapsed=0

[Window][Properties]
Pos=0,461
Size=370,439
Collapsed=0
DockId=0x00000006,0

[Window][Stats]
Pos=1264,24
Size=336,439
Collapsed=0
DockId=0x00000003,0

[Window][Content Browser]
Pos=372,685
Size=890,215
Collapsed=0
DockId=0x0000000A,0

[Window][##toolbar]
Pos=372,24
Size=890,43
Collapsed=0
DockId=0x0000000B,0

[Docking][Data]
DockSpace         ID=0x3BC79352 Window=0x4647B76E Pos=307,336 Size=1600,876 Split=X Selected=0x995B0CF8
  DockNode        ID=0x00000008 Parent=0x3BC79352 SizeRef=1262,876 Split=X
    DockNode      ID=0x00000001 Parent=0x00000008 SizeRef=370,696 Split=Y Selected=0xC89E3217
      DockNode    ID=0x00000005 Parent=0x00000001 SizeRef=370,435 Selected=0x9A68760C
      DockNode    ID=0x00000006 Parent=0x00000001 SizeRef=370,439 Selected=0xC89E3217
    DockNode      ID=0x00000002 Parent=0x00000008 SizeRef=890,696 Split=Y
      DockNode    ID=0x00000009 Parent=0x00000002 SizeRef=856,659 Split=Y Selected=0x995B0CF8
        DockNode  ID=0x0000000B Parent=0x00000009 SizeRef=856,43 HiddenTabBar=1 Selected=0x28257B55
        DockNode  ID=0x0000000C Parent=0x00000009 SizeRef=856,725 CentralNode=1 HiddenTabBar=1 Selected=0x995B0CF8
      DockNode    ID=0x0000000A Parent=0x00000002 SizeRef=856,215 Selected=0x371352B7
  DockNode        ID=0x00000007 Parent=0x3BC79352 SizeRef=336,876 Split=Y Selected=0x968648AE
    DockNode      ID=0x00000003 Parent=0x00000007 SizeRef=336,439 Selected=0x968648AE
    DockNode      ID=0x00000004 Parent=0x00000007 SizeRef=336,435 Selected=0x1C33C293


```

`Hazelnut/mono/lib/mono/4.5/MSBuild/Microsoft.Build.CommonTypes.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://schemas.microsoft.com/developer/msbuild/2003" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003"
elementFormDefault="qualified">

    <!-- =================== INCLUDE COMMON SCHEMA =========================== -->
    <xs:include schemaLocation="Microsoft.Build.Core.xsd"/>

    <!-- ======================== ITEMS =====================================-->
    <!-- Possible Types include SimpleItemType (no meta-data subelements), GenericItemType (any meta-data), or something more specific.-->
    <xs:element name="Reference" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Reference to an assembly</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="HintPath">
                                <xs:annotation>
                                    <xs:documentation>Relative or absolute path to the assembly (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Name">
                                <xs:annotation>
                                    <xs:documentation>Friendly display name (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="FusionName">
                                <xs:annotation>
                                    <xs:documentation>Fusion name of the assembly (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="SpecificVersion">
                                <xs:annotation>
                                    <xs:documentation>Whether only the version in the fusion name should be referenced (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Aliases">
                                <xs:annotation>
                                    <xs:documentation>Aliases for the reference (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Private">
                                <xs:annotation>
                                    <xs:documentation>Whether the reference should be copied to the output folder (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Assembly name or filename</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="COMReference" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Reference to a COM component</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="Name">
                                <xs:annotation>
                                    <xs:documentation>Friendly display name (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Guid">
                                <xs:annotation>
                                    <xs:documentation>GUID in the form {00000000-0000-0000-0000-000000000000}</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="VersionMajor">
                                <xs:annotation>
                                    <xs:documentation>Major part of the version number</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="VersionMinor">
                                <xs:annotation>
                                    <xs:documentation>Minor part of the version number</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Lcid">
                                <xs:annotation>
                                    <xs:documentation>Locale ID</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="WrapperTool">
                                <xs:annotation>
                                    <xs:documentation>Wrapper tool, such as tlbimp</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Isolated">
                                <xs:annotation>
                                    <xs:documentation>Is it isolated (boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>COM component name</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="COMFileReference" substitutionGroup="msb:Item">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="WrapperTool"/>
                        </xs:choice>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="NativeReference" substitutionGroup="msb:Item">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="Name"/>
                            <xs:element name="HintPath"/>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Path to native reference</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ProjectReference" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Reference to another project</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="Name">
                                <xs:annotation>
                                    <xs:documentation>Friendly display name (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Project">
                                <xs:annotation>
                                    <xs:documentation>Project GUID, in the form {00000000-0000-0000-0000-000000000000}</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Package"/>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Path to project file</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Compile" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Source files for compiler</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="SubType"/>
                            <xs:element name="DependentUpon"/>
                            <xs:element name="AutoGen">
                                <xs:annotation>
                                    <xs:documentation>Whether file was generated from another file (boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="DesignTime"/>
                            <xs:element name="Link">
                                <xs:annotation>
                                    <xs:documentation>Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="DesignTimeSharedInput"/>
                            <xs:element name="InProject">
                                <xs:annotation>
                                    <xs:documentation>Display in user interface (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Semi-colon separated list of source files (wildcards are allowed)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="EmbeddedResource" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Resources to be embedded in the generated assembly</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="DependentUpon"/>
                            <xs:element name="Generator">
                                <xs:annotation>
                                    <xs:documentation>Name of any file generator that is run on this item</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="LastGenOutput">
                                <xs:annotation>
                                    <xs:documentation>File that was created by any file generator that was run on this item</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="CustomToolNamespace">
                                <xs:annotation>
                                    <xs:documentation>Namespace into which any file generator that is run on this item should create code</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Link">
                                <xs:annotation>
                                    <xs:documentation>Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="InProject">
                                <xs:annotation>
                                    <xs:documentation>Display in user interface (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="SubType"/>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Semi-colon separated list of resource files (wildcards are allowed)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Content" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Files that are not compiled, but may be embedded or published</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="DependentUpon"/>
                            <xs:element name="Generator">
                                <xs:annotation>
                                    <xs:documentation>Name of any file generator that is run on this item</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="LastGenOutput"/>
                            <xs:element name="CustomToolNamespace"/>
                            <xs:element name="Link">
                                <xs:annotation>
                                    <xs:documentation>Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Group"/>
                            <xs:element name="PublishState">
                            <xs:annotation>
                                <xs:documentation>Default, Included, Excluded, DataFile, or Prerequisite</xs:documentation>
                            </xs:annotation>
                            </xs:element>
                            <xs:element name="IsAssembly"/>
                            <xs:element name="InProject">
                                <xs:annotation>
                                    <xs:documentation>Display in user interface (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="SubType"/>
                            <xs:element name="CopyToOutputDirectory">
                                <xs:annotation>
                                    <xs:documentation>Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                    <!-- redefine Include just to give a specific description -->
                    <xs:attribute name="Include" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Semi-colon separated list of content files (wildcards are allowed)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="None" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Files that should have no role in the build process</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <!-- UNDONE. Remove all but Link when #318721 is fixed-->
                            <xs:element name="DependentUpon"/>
                            <xs:element name="Generator">
                                <xs:annotation>
                                    <xs:documentation>Name of any file generator that is run on this item</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="LastGenOutput"/>
                            <xs:element name="CustomToolNamespace"/>
                            <xs:element name="Link">
                                <xs:annotation>
                                    <xs:documentation>Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="InProject">
                                <xs:annotation>
                                    <xs:documentation>Display in user interface (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Folder" type="msb:SimpleItemType" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Folder on disk</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Import" type="msb:SimpleItemType" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Assemblies whose namespaces should be imported by the Visual Basic compiler</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Service" type="msb:SimpleItemType" substitutionGroup="msb:Item"/>
    <xs:element name="WebReferences" type="msb:SimpleItemType" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Name of Web References folder to display in user interface</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="WebReferenceUrl" substitutionGroup="msb:Item">
        <xs:annotation>
            <xs:documentation>Represents a reference to a web service</xs:documentation>
        </xs:annotation>
            <xs:complexType>
                <xs:complexContent>
                    <xs:extension base="msb:SimpleItemType">
                        <xs:sequence minOccurs="0" maxOccurs="unbounded">
                            <xs:choice>
                                <xs:element name="UrlBehavior"/>
                                <xs:element name="RelPath"/>
                                <xs:element name="UpdateFromURL"/>
                                <xs:element name="ServiceLocationURL"/>
                                <xs:element name="CachedDynamicPropName"/>
                                <xs:element name="CachedAppSettingsObjectName"/>
                                <xs:element name="CachedSettingsPropName"/>
                            </xs:choice>
                        </xs:sequence>
                        <!-- redefine Include just to give a specific description -->
                        <xs:attribute name="Include" type="xs:string" use="required">
                            <xs:annotation>
                                <xs:documentation>URL to web service</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:extension>
                </xs:complexContent>
            </xs:complexType>
    </xs:element>
    <xs:element name="BootstrapperFile" substitutionGroup="msb:Item">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="InProject">
                                <xs:annotation>
                                    <xs:documentation>Display in user interface (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="ProductName"/>
                            <xs:element name="Install"/>
                        </xs:choice>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="PublishFile" substitutionGroup="msb:Item">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:choice>
                            <xs:element name="InProject">
                                <xs:annotation>
                                    <xs:documentation>Display in user interface (optional, boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="Group"/>
                            <xs:element name="IsAssembly">
                                <xs:annotation>
                                    <xs:documentation>(boolean)</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="PublishState">
                                <xs:annotation>
                                    <xs:documentation>Default, Included, Excluded, DataFile, or Prerequisite</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ======================== PROPERTIES =====================================-->
    <!-- Possible Types include StringPropertyType (text with no subelements), GenericPropertyType (any content), or something more specific.-->
    <xs:element name="AllowUnsafeBlocks" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ApplicationIcon" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ApplicationRevision" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>integer</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="ApplicationVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Matches the expression "\d\.\d\.\d\.(\d|\*)"</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="AppDesignerFolder" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Name of folder for Application Designer</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="AssemblyKeyContainerName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="AssemblyKeyProviderName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="AssemblyName" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Name of output assembly</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="AssemblyOriginatorKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="AssemblyOriginatorKeyFileType" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="AssemblyOriginatorKeyMode" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="AssemblyType" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="AutorunEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="BaseAddress" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="BootstrapperComponentsLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>HomeSite, Relative, or Absolute</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="BootstrapperComponentsUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="BootstrapperEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="CheckForOverflowUnderflow" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="CodePage" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="Configuration" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ConfigurationOverrideFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="CreateWebPageOnPublish" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="DebugSecurityZoneURL" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DebugSymbols" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Whether to emit symbols (boolean)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="DebugType" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>none, pdbonly, or full</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="DefaultClientScript" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DefaultHTMLPageLayout" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DefaultTargetSchema" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DefineConstants" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DefineDebug" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Whether DEBUG is defined (boolean)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="DefineTrace" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Whether TRACE is defined (boolean)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="DelaySign" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DisableLangXtns" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DisallowUrlActiviation" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="DeployDirSuffix" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="DocumentationFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="EnableASPDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="EnableASPXDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="EnableSQLServerDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="EnableSecurityDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="EnableUnmanagedDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ErrorReport" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ExcludedPermissions" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FallbackCulture" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FileAlignment" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FileUpgradeFlags" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FormFactorID" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FxCopLogFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FxCopProjectFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="FxCopRules" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="GenerateManifests" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="GenerateSerializationAssemblies" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="Install" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="InstallFrom" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Web, Unc, or Disk</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="LangVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="MapFileExtensions" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="MinimumRequiredVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Matches the expression "\d\.\d\.\d\.\d"</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="MyType" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="NoConfig" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="NoStandardLibraries" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="NoStdLib" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Whether standard libraries (such as mscorlib) should be referenced automatically (boolean)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="NoWarn" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Comma separated list of disabled warnings</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="OpenBrowserOnPublish" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Optimize" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Should compiler optimize output (boolean)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="OptionCompare" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Option Compare setting (Text or Binary)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="OptionExplicit" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Should Option Explicit be set (On or Off)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="OptionStrict" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Should Option Strict be set (On or Off)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="OSVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="OutputPath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Path to output folder, with trailing slash</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="OutputType" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Type of output to generate (WinExe, Exe, or Library)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Platform" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="PlatformFamilyName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="PlatformID" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="PlatformTarget" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="PostBuildEvent" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Command line to be run at the end of build</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="PreBuildEvent" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Command line to be run at the start of build</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="ProductName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ProductVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ProjectGuid" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ProjectType" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ProjectTypeGuids" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="PublisherName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="PublishUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RecursePath" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ReferencePath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Semi-colon separated list of folders to search during reference resolution</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="RegisterForComInterop" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RemoteDebugEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RemoteDebugMachine" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RemoveIntegerChecks" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="ResponseFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RootNamespace" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RunFxCop" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="RunPostBuildEvent" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="SchemaVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="SecureScoping" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="SignAssembly" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="SignManifests" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartAction" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartArguments" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartPage" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartProgram" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartURL" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartWithIE" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartWorkingDirectory" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="StartupObject" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Type that contains the main entry point</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="SupportUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="TargetCulture" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="TargetZone" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="TreatWarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="TrustUrlParameters" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="TypeComplianceDiagnostics" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="UpdateEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="UpdateInterval" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="UpdateIntervalUnits" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Hours, Days, or Weeks</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="UpdateMode" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Foreground or Background</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="UpdatePeriodically" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="UpdateRequired" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>boolean</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="UpdateUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="UTF8OutPut" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="UseVSHostingProcess" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="VSTO_TrustAssembliesLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="WarningLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>integer between 0 and 4 inclusive</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="WarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property">
        <xs:annotation>
            <xs:documentation>Comma separated list of warning numbers to treat as errors</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="WebPage" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <xs:element name="Win32ResourceFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
    <!-- ======================== TASKS =====================================-->
    <xs:element name="AL" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="OutputAssembly" use="required" />
                    <xs:attribute name="AlgorithmId" />
                    <xs:attribute name="BaseAddress" />
                    <xs:attribute name="CompanyName" />
                    <xs:attribute name="Configuration" />
                    <xs:attribute name="Copyright" />
                    <xs:attribute name="Culture" />
                    <xs:attribute name="DelaySign" />
                    <xs:attribute name="Description" />
                    <xs:attribute name="EmbedResources" />
                    <xs:attribute name="EvidenceFile" />
                    <xs:attribute name="FileVersion" />
                    <xs:attribute name="Flags" />
                    <xs:attribute name="GenerateFullPaths" />
                    <xs:attribute name="KeyContainer" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="LinkResources" />
                    <xs:attribute name="MainEntryPoint" />
                    <xs:attribute name="Platform" />
                    <xs:attribute name="ProductName" />
                    <xs:attribute name="ProductVersion" />
                    <xs:attribute name="ResponseFiles" />
                    <xs:attribute name="SourceModules" />
                    <xs:attribute name="TargetType" />
                    <xs:attribute name="TemplateFile" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="Title" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="Trademark" />
                    <xs:attribute name="Version" />
                    <xs:attribute name="Win32Icon" />
                    <xs:attribute name="Win32Resource" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="AspNetCompiler" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Clean" />
                    <xs:attribute name="Debug" />
                    <xs:attribute name="Force" />
                    <xs:attribute name="MetabasePath" />
                    <xs:attribute name="PhysicalPath" />
                    <xs:attribute name="TargetPath" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="Updateable" />
                    <xs:attribute name="VirtualPath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="AssignCulture" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Files" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="AssignTargetPath" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="RootFolder" use="required" />
                    <xs:attribute name="Files" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Copy" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="DestinationFiles" />
                    <xs:attribute name="DestinationFolder" />
                    <xs:attribute name="SkipUnchangedFiles" />
                    <xs:attribute name="SourceFiles" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="CreateCSharpManifestResourceName" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="ResourceFiles" use="required" />
                    <xs:attribute name="RootNamespace" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="CreateItem" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AdditionalMetadata" />
                    <xs:attribute name="Exclude" />
                    <xs:attribute name="Include" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="CreateJSharpManifestResourceName" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="ResourceFiles" use="required" />
                    <xs:attribute name="RootNamespace" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="CreateProperty" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Value" />
                    <xs:attribute name="ValueSetByTask" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="CreateVisualBasicManifestResourceName" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="ResourceFiles" use="required" />
                    <xs:attribute name="RootNamespace" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Csc" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AdditionalLibPaths" />
                    <xs:attribute name="AddModules" />
                    <xs:attribute name="AllowUnsafeBlocks" />
                    <xs:attribute name="BaseAddress" />
                    <xs:attribute name="CheckForOverflowUnderflow" />
                    <xs:attribute name="CodePage" />
                    <xs:attribute name="DebugType" />
                    <xs:attribute name="DefineConstants" />
                    <xs:attribute name="DelaySign" />
                    <xs:attribute name="DisabledWarnings" />
                    <xs:attribute name="DocumentationFile" />
                    <xs:attribute name="EmitDebugInformation" />
                    <xs:attribute name="ErrorReport" />
                    <xs:attribute name="FileAlignment" />
                    <xs:attribute name="GenerateFullPaths" />
                    <xs:attribute name="KeyContainer" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="LangVersion" />
                    <xs:attribute name="LinkResources" />
                    <xs:attribute name="MainEntryPoint" />
                    <xs:attribute name="NoConfig" />
                    <xs:attribute name="NoLogo" />
                    <xs:attribute name="NoStandardLib" />
                    <xs:attribute name="Optimize" />
                    <xs:attribute name="OutputAssembly" />
                    <xs:attribute name="Platform" />
                    <xs:attribute name="References" />
                    <xs:attribute name="Resources" />
                    <xs:attribute name="ResponseFiles" />
                    <xs:attribute name="Sources" />
                    <xs:attribute name="TargetType" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="TreatWarningsAsErrors" />
                    <xs:attribute name="UseHostCompilerIfAvailable" />
                    <xs:attribute name="Utf8Output" />
                    <xs:attribute name="WarningLevel" />
                    <xs:attribute name="WarningsAsErrors" />
                    <xs:attribute name="WarningsNotAsErrors" />
                    <xs:attribute name="Win32Icon" />
                    <xs:attribute name="Win32Resource" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Delete" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Files" use="required" />
                    <xs:attribute name="DeletedFiles" />
                    <xs:attribute name="TreatErrorsAsWarnings" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Error" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Text" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Exec" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Command" use="required" />
                    <xs:attribute name="IgnoreExitCode" />
                    <xs:attribute name="Outputs" />
                    <xs:attribute name="StandardErrorEncoding" />
                    <xs:attribute name="StandardOutputEncoding" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="WorkingDirectory" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="FindUnderPath" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Path" use="required" />
                    <xs:attribute name="Files" />
                    <xs:attribute name="InPath" />
                    <xs:attribute name="OutOfPath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="FormatUrl" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="InputUrl" />
                    <xs:attribute name="OutputUrl" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="FormatVersion" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="FormatType" />
                    <xs:attribute name="OutputVersion" />
                    <xs:attribute name="Revision" />
                    <xs:attribute name="Version" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="FxCop" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="ApplyLogFileXsl" />
                    <xs:attribute name="Assemblies" />
                    <xs:attribute name="ConsoleXsl" />
                    <xs:attribute name="DependentAssemblyPaths" />
                    <xs:attribute name="Imports" />
                    <xs:attribute name="LogFile" />
                    <xs:attribute name="LogFileXsl" />
                    <xs:attribute name="OutputToConsole" />
                    <xs:attribute name="PlatformPath" />
                    <xs:attribute name="Project" />
                    <xs:attribute name="RuleAssemblies" />
                    <xs:attribute name="Rules" />
                    <xs:attribute name="Summary" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="UpdateProjectFile" />
                    <xs:attribute name="Verbose" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GenerateApplicationManifest" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AssemblyName" />
                    <xs:attribute name="AssemblyVersion" />
                    <xs:attribute name="ClrVersion" />
                    <xs:attribute name="ConfigFile" />
                    <xs:attribute name="Dependencies" />
                    <xs:attribute name="Description" />
                    <xs:attribute name="EntryPoint" />
                    <xs:attribute name="Files" />
                    <xs:attribute name="IconFile" />
                    <xs:attribute name="InputManifest" />
                    <xs:attribute name="IsolatedComReferences" />
                    <xs:attribute name="ManifestType" />
                    <xs:attribute name="MaxTargetPath" />
                    <xs:attribute name="OSVersion" />
                    <xs:attribute name="OutputManifest" />
                    <xs:attribute name="Platform" />
                    <xs:attribute name="TargetCulture" />
                    <xs:attribute name="TrustInfoFile" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GenerateBootstrapper" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="ApplicationFile" />
                    <xs:attribute name="ApplicationName" />
                    <xs:attribute name="ApplicationUrl" />
                    <xs:attribute name="BootstrapperComponentFiles" />
                    <xs:attribute name="BootstrapperItems" />
                    <xs:attribute name="BootstrapperKeyFile" />
                    <xs:attribute name="ComponentsLocation" />
                    <xs:attribute name="ComponentsUrl" />
                    <xs:attribute name="CopyComponents" />
                    <xs:attribute name="Culture" />
                    <xs:attribute name="FallbackCulture" />
                    <xs:attribute name="OutputPath" />
                    <xs:attribute name="Path" />
                    <xs:attribute name="SupportUrl" />
                    <xs:attribute name="Validate" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GenerateDeploymentManifest" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AssemblyName" />
                    <xs:attribute name="AssemblyVersion" />
                    <xs:attribute name="DeploymentUrl" />
                    <xs:attribute name="Description" />
                    <xs:attribute name="DisallowUrlActivation" />
                    <xs:attribute name="EntryPoint" />
                    <xs:attribute name="InputManifest" />
                    <xs:attribute name="Install" />
                    <xs:attribute name="MaxTargetPath" />
                    <xs:attribute name="MapFileExtensions" />
                    <xs:attribute name="MinimumRequiredVersion" />
                    <xs:attribute name="OutputManifest" />
                    <xs:attribute name="Platform" />
                    <xs:attribute name="Product" />
                    <xs:attribute name="Publisher" />
                    <xs:attribute name="SupportUrl" />
                    <xs:attribute name="TargetCulture" />
                    <xs:attribute name="TrustUrlParameters" />
                    <xs:attribute name="UpdateEnabled" />
                    <xs:attribute name="UpdateInterval" />
                    <xs:attribute name="UpdateMode" />
                    <xs:attribute name="UpdateUnit" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GenerateResource" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Sources" use="required" />
                    <xs:attribute name="FilesWritten" />
                    <xs:attribute name="NeverLockTypeAssemblies" />
                    <xs:attribute name="OutputResources" />
	            <xs:attribute name="References" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="UseSourcePath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GetAssemblyIdentity" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AssemblyFiles" use="required" />
                    <xs:attribute name="Assemblies" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GetFrameworkPath" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Path" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GetFrameworkSdkPath" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Path" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GetLinkedFilesFromResX" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Sources" use="required" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="UseSourcePath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="LC" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="LicenseTarget" use="required" />
                    <xs:attribute name="Sources" use="required" />
                    <xs:attribute name="NoLogo" />
                    <xs:attribute name="OutputDirectory" />
                    <xs:attribute name="OutputLicense" />
                    <xs:attribute name="ReferencedAssemblies" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="MakeDir" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Directories" use="required" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Message" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Importance" />
                    <xs:attribute name="Text" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="MSBuild" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Projects" use="required" />
                    <xs:attribute name="RebaseOutputs" />
                    <xs:attribute name="StopOnFirstFailure" />
                    <xs:attribute name="RunEachTargetSeparately" />
                    <xs:attribute name="Targets" />
                    <xs:attribute name="Properties" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ReadLinesFromFile" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="File" use="required" />
                    <xs:attribute name="Lines" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="RegisterAssembly" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Assemblies" use="required" />
                    <xs:attribute name="CreateCodeBase" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="TypeLibFiles" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="RemoveDir" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Directories" use="required" />
                    <xs:attribute name="RemovedDirectories" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="RemoveDuplicates" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Filtered" />
                    <xs:attribute name="Inputs" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResGen" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Sources" use="required" />
                    <xs:attribute name="FilesWritten" />
                    <xs:attribute name="OutputResources" />
                    <xs:attribute name="References" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="UseSourcePath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResolveAssemblyReference" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="SearchPaths" use="required" />
                    <xs:attribute name="AppConfigFile" />
                    <xs:attribute name="Assemblies" />
                    <xs:attribute name="AssemblyFiles" />
                    <xs:attribute name="AutoUnify" />
                    <xs:attribute name="CandidateAssemblyFiles" />
                    <xs:attribute name="FilesWritten" />
                    <xs:attribute name="FindDependencies" />
                    <xs:attribute name="FindRelatedFiles" />
                    <xs:attribute name="FindSatellites" />
                    <xs:attribute name="InstalledAssemblyTables" />
                    <xs:attribute name="Silent" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="TargetFrameworkDirectory" />
                    <xs:attribute name="TargetProcessorArchitecture" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResolveComReference" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="DelaySign" />
                    <xs:attribute name="KeyContainer" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="NoClassMembers" />
                    <xs:attribute name="ResolvedAssemblyReferences" />
                    <xs:attribute name="ResolvedFiles" />
                    <xs:attribute name="ResolvedModules" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="TypeLibFiles" />
                    <xs:attribute name="TypeLibNames" />
                    <xs:attribute name="WrapperOutputDirectory" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResolveKeySource" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AutoClosePasswordPromptShow" />
                    <xs:attribute name="AutoClosePasswordPromptTimeout" />
                    <xs:attribute name="CertificateFile" />
                    <xs:attribute name="CertificateThumbprint" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="ResolvedKeyContainer" />
                    <xs:attribute name="ResolvedKeyFile" />
                    <xs:attribute name="ResolvedThumbprint" />
                    <xs:attribute name="SuppressAutoClosePasswordPrompt" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="GenerateTrustInfo" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="BaseManifest" />
                    <xs:attribute name="ExcludedPermissions" />
                    <xs:attribute name="TargetZone" use="required" />
                    <xs:attribute name="TrustInfoFile" use="required" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResolveManifestFiles" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="EntryPoint" />
                    <xs:attribute name="TrustInfoFile" />
                    <xs:attribute name="Dependencies" /> <!-- obsolete -->
                    <xs:attribute name="ExtraFiles" />
                    <xs:attribute name="Files" />
                    <xs:attribute name="ManagedAssemblies" />
                    <xs:attribute name="NativeAssemblies" />
                    <xs:attribute name="OutputAssemblies" />
                    <xs:attribute name="OutputDependencies" /> <!-- obsolete -->
                    <xs:attribute name="OutputFiles" />
                    <xs:attribute name="OutputPrerequisites" /> <!-- obsolete -->
                    <xs:attribute name="OutputSatellites" /> <!-- obsolete -->
                    <xs:attribute name="PublishFiles" />
                    <xs:attribute name="Satellites" /> <!-- obsolete -->
                    <xs:attribute name="SatelliteAssemblies" />
                    <xs:attribute name="TargetCulture" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResolveNativeReference" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="NativeReferences" use="required" />
                    <xs:attribute name="ContainedComComponents" />
                    <xs:attribute name="ContainedLooseEtcFiles" />
                    <xs:attribute name="ContainedLooseTlbFiles" />
                    <xs:attribute name="ContainedNetAssemblies" />
                    <xs:attribute name="ContainedTypeLibraries" />
                    <xs:attribute name="ContainingReferenceFiles" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="ResolveVCProjectOutput" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="ProjectReferences" use="required" />
                    <xs:attribute name="Configuration" />
                    <xs:attribute name="PreresolvedVCOutputs" />
                    <xs:attribute name="ResolvedOutputPaths" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="SGen" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="BuildAssemblyName" use="required" />
                    <xs:attribute name="BuildAssemblyPath" use="required" />
                    <xs:attribute name="ShouldGenerateSerializer" use="required" />
                    <xs:attribute name="DelaySign" />
                    <xs:attribute name="KeyContainer" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="References" />
                    <xs:attribute name="SerializationAssembly" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="SignFile" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="CertificateThumbprint" use="required" />
                    <xs:attribute name="SigningTarget" use="required" />
                    <xs:attribute name="TimestampUrl" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Touch" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Files" use="required" />
                    <xs:attribute name="AlwaysCreate" />
                    <xs:attribute name="ForceTouch" />
                    <xs:attribute name="Time" />
                    <xs:attribute name="TouchedFiles" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="UnregisterAssembly" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Assemblies" />
                    <xs:attribute name="StateFile" />
                    <xs:attribute name="TypeLibFiles" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="UpdateManifest" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="InputManifest" use="required" />
                    <xs:attribute name="ApplicationManifest" />
                    <xs:attribute name="ApplicationPath" />
                    <xs:attribute name="OutputManifest" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Vbc" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AdditionalLibPaths" />
                    <xs:attribute name="AddModules" />
                    <xs:attribute name="BaseAddress" />
                    <xs:attribute name="CodePage" />
                    <xs:attribute name="DebugType" />
                    <xs:attribute name="DefineConstants" />
                    <xs:attribute name="DelaySign" />
                    <xs:attribute name="DisabledWarnings" />
                    <xs:attribute name="DocumentationFile" />
                    <xs:attribute name="EmitDebugInformation" />
                    <xs:attribute name="ErrorReport" />
                    <xs:attribute name="FileAlignment" />
                    <xs:attribute name="GenerateDocumentation" />
                    <xs:attribute name="Imports" />
                    <xs:attribute name="KeyContainer" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="LinkResources" />
                    <xs:attribute name="MainEntryPoint" />
                    <xs:attribute name="NoConfig" />
                    <xs:attribute name="NoLogo" />
                    <xs:attribute name="NoStandardLib" />
                    <xs:attribute name="NoWarnings" />
                    <xs:attribute name="Optimize" />
                    <xs:attribute name="OptionCompare" />
                    <xs:attribute name="OptionExplicit" />
                    <xs:attribute name="OptionStrict" />
                    <xs:attribute name="OutputAssembly" />
                    <xs:attribute name="Platform" />
                    <xs:attribute name="References" />
                    <xs:attribute name="RemoveIntegerChecks" />
                    <xs:attribute name="Resources" />
                    <xs:attribute name="ResponseFiles" />
                    <xs:attribute name="RootNamespace" />
                    <xs:attribute name="SdkPath" />
                    <xs:attribute name="Sources" />
                    <xs:attribute name="TargetCompactFramework" />
                    <xs:attribute name="TargetType" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="TreatWarningsAsErrors" />
                    <xs:attribute name="UseHostCompilerIfAvailable" />
                    <xs:attribute name="Utf8Output" />
                    <xs:attribute name="Verbosity" />
                    <xs:attribute name="WarningsAsErrors" />
                    <xs:attribute name="WarningsNotAsErrors" />
                    <xs:attribute name="Win32Icon" />
                    <xs:attribute name="Win32Resource" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="VCBuild" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Projects" use="required" />
                    <xs:attribute name="Clean" />
                    <xs:attribute name="Configuration" />
                    <xs:attribute name="Override" />
                    <xs:attribute name="Rebuild" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Vjc" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="AdditionalLibPaths" />
                    <xs:attribute name="AddModules" />
                    <xs:attribute name="BaseAddress" />
                    <xs:attribute name="CodePage" />
                    <xs:attribute name="DebugType" />
                    <xs:attribute name="DefineConstants" />
                    <xs:attribute name="DelaySign" />
                    <xs:attribute name="DisabledWarnings" />
                    <xs:attribute name="DisableExtensions" />
                    <xs:attribute name="DocumentationFile" />
                    <xs:attribute name="EmitDebugInformation" />
                    <xs:attribute name="FileAlignment" />
                    <xs:attribute name="Jcpa" />
                    <xs:attribute name="KeyContainer" />
                    <xs:attribute name="KeyFile" />
                    <xs:attribute name="LinkResources" />
                    <xs:attribute name="MainEntryPoint" />
                    <xs:attribute name="NoConfig" />
                    <xs:attribute name="NoLogo" />
                    <xs:attribute name="Optimize" />
                    <xs:attribute name="OutputAssembly" />
                    <xs:attribute name="References" />
                    <xs:attribute name="Resources" />
                    <xs:attribute name="ResponseFiles" />
                    <xs:attribute name="SecureScoping" />
                    <xs:attribute name="Sources" />
                    <xs:attribute name="TargetType" />
                    <xs:attribute name="Timeout" />
                    <xs:attribute name="ToolPath" />
                    <xs:attribute name="TreatWarningsAsErrors" />
                    <xs:attribute name="Utf8Output" />
                    <xs:attribute name="WarningLevel" />
                    <xs:attribute name="Win32Icon" />
                    <xs:attribute name="Win32Resource" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="VjsResGen" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Sources" use="required" />
                    <xs:attribute name="OutputResx" />
                    <xs:attribute name="WildCards" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Warning" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="Text" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="WriteLinesToFile" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="File" use="required" />
                    <xs:attribute name="Lines" />
                    <xs:attribute name="Overwrite" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
</xs:schema>

```

`Hazelnut/mono/lib/mono/4.5/MSBuild/Microsoft.Build.Core.xsd`:

```xsd
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://schemas.microsoft.com/developer/msbuild/2003" xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
    <!-- ======================================================================================= -->
    <xs:element name="Project">
        <xs:complexType>
            <xs:sequence>
                <xs:group ref="msb:ProjectLevelTagExceptTargetOrImportType" minOccurs="0" maxOccurs="unbounded"/>
                <!-- must be at least one Target or Import tag-->
                <xs:group ref="msb:TargetOrImportType"/>
                <xs:group ref="msb:ProjectLevelTagType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="DefaultTargets" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:documentation>Optional semi-colon separated list of one or more targets that will be built if no targets are otherwise specified</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <!-- ======================================================================================= -->
    <xs:group name="ProjectLevelTagExceptTargetOrImportType">
        <xs:choice>
            <xs:element name="PropertyGroup" type="msb:PropertyGroupType"/>
            <xs:element name="ItemGroup" type="msb:ItemGroupType"/>
            <xs:element name="Choose" type="msb:ChooseType"/>
            <xs:element name="Error" type="msb:WarningErrorOutsideTargetType">
                <xs:annotation>
                    <xs:documentation>Logs an Error event</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="Warning" type="msb:WarningErrorOutsideTargetType">
                <xs:annotation>
                    <xs:documentation>Logs a Warning event</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="Message" type="msb:MessageOutsideTargetType"/>
            <xs:element name="UsingTask" type="msb:UsingTaskType"/>
            <xs:element name="ProjectExtensions" type="msb:ProjectExtensionsType"/>
        </xs:choice>
    </xs:group>
    <!-- ======================================================================================= -->
    <xs:group name="ProjectLevelTagType">
        <xs:choice>
            <xs:element name="PropertyGroup" type="msb:PropertyGroupType"/>
            <xs:element name="ItemGroup" type="msb:ItemGroupType"/>
            <xs:element name="Choose" type="msb:ChooseType"/>
            <xs:element name="Error" type="msb:WarningErrorOutsideTargetType">
                <xs:annotation>
                    <xs:documentation>Logs an Error event</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="Warning" type="msb:WarningErrorOutsideTargetType">
                <xs:annotation>
                    <xs:documentation>Logs a Warning event</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="Message" type="msb:MessageOutsideTargetType"/>
            <xs:element name="UsingTask" type="msb:UsingTaskType"/>
            <xs:element name="Target" type="msb:TargetType"/>
            <xs:element name="Import" type="msb:ImportType"/>
            <xs:element name="ProjectExtensions" type="msb:ProjectExtensionsType"/>
        </xs:choice>
    </xs:group>
    <!-- ======================================================================================= -->
    <xs:group name="TargetOrImportType">
        <xs:choice>
            <xs:element name="Target" type="msb:TargetType"/>
            <xs:element name="Import" type="msb:ImportType"/>
        </xs:choice>
    </xs:group>
    <!-- ======================================================================================= -->
    <xs:complexType name="TargetType">
        <xs:annotation>
            <xs:documentation>Groups tasks into a section of the build process</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="msb:Task"/>
            </xs:choice>
            <xs:element name="OnError" type="msb:OnErrorType" minOccurs="0" maxOccurs="unbounded"/>
            <!-- no elements are allowed under Target after an OnError element-->
        </xs:sequence>
        <xs:attribute name="Name" type="msb:non_empty_string" use="required">
            <xs:annotation>
                <xs:documentation>Name of the target</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="DependsOnTargets" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional semi-colon separated list of targets that should be run before this target</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Inputs" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional semi-colon separated list of files that form inputs into this target. Their timestamps will be compared with the timestamps of files in Outputs to determine whether the Target is up to date</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Outputs" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional semi-colon separated list of files that form outputs into this target. Their timestamps will be compared with the timestamps of files in Inputs to determine whether the Target is up to date</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the Target and the targets it depends on should be run</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="PropertyGroupType">
        <xs:annotation>
            <xs:documentation>Groups property definitions</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="msb:Property"/>
        </xs:sequence>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the PropertyGroup should be used</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="ItemGroupType">
        <xs:annotation>
            <xs:documentation>Groups item list definitions</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="msb:Item"/>
        </xs:sequence>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the ItemGroup should be used</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="ChooseType">
        <xs:annotation>
            <xs:documentation>Groups When and Otherwise elements</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="When" type="msb:WhenType" maxOccurs="unbounded"/>
            <xs:element name="Otherwise" type="msb:OtherwiseType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="WhenType">
        <xs:annotation>
            <xs:documentation>Groups PropertyGroup and/or ItemGroup elements</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:choice>
                <xs:element name="PropertyGroup" type="msb:PropertyGroupType"/>
                <xs:element name="ItemGroup" type="msb:ItemGroupType"/>
                <xs:element name="Choose" type="msb:ChooseType"/>
            </xs:choice>
        </xs:sequence>
        <xs:attribute name="Condition" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the child PropertyGroups and/or ItemGroups should be used</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="OtherwiseType">
        <xs:annotation>
            <xs:documentation>Groups PropertyGroup and/or ItemGroup elements that are used if no Conditions on sibling When elements evaluate to true</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:choice>
                <xs:element name="PropertyGroup" type="msb:PropertyGroupType"/>
                <xs:element name="ItemGroup" type="msb:ItemGroupType"/>
                <xs:element name="Choose" type="msb:ChooseType"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="OnErrorType">
        <xs:annotation>
            <xs:documentation>Specifies targets to execute in the event of a recoverable error</xs:documentation>
        </xs:annotation>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the targets should be executed</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ExecuteTargets" type="msb:non_empty_string" use="required">
            <xs:annotation>
                <xs:documentation>Semi-colon separated list of targets to execute</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="MessageOutsideTargetType">
        <xs:annotation>
            <xs:documentation>Logs an informational Message event, with an optional Importance</xs:documentation>
        </xs:annotation>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the Message should be logged</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Importance" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional priority level. Allowed values are Low, Normal (default), and High</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Text" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Text to log</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="WarningErrorOutsideTargetType">
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the text should be logged</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Text" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Text to log</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="UsingTaskType">
        <xs:annotation>
            <xs:documentation>Declares where to load a task that will be used in the project</xs:documentation>
        </xs:annotation>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the declaration should be evaluated</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="AssemblyName" type="msb:non_empty_string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional name of assembly containing the task. Either AssemblyName or AssemblyFile must be used</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="AssemblyFile" type="msb:non_empty_string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional path to assembly containing the task. Either AssemblyName or AssemblyFile must be used</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="TaskName" type="msb:non_empty_string" use="required">
            <xs:annotation>
                <xs:documentation>Name of task class in the assembly</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="ImportType">
        <xs:annotation>
            <xs:documentation>Declares that the contents of another project file should be inserted at this location</xs:documentation>
        </xs:annotation>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the import should occur</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Project" type="msb:non_empty_string" use="required">
            <xs:annotation>
                <xs:documentation>Project file to import</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:complexType name="ProjectExtensionsType" mixed="true">
        <xs:annotation>
            <xs:documentation>Optional section used by MSBuild hosts, that may contain arbitrary XML content that is ignored by MSBuild itself</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:any processContents="skip"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:element name="Item" type="msb:SimpleItemType" abstract="true"/>
    <!-- ======================================================================================= -->
    <!-- convenience type for items that have no meta-data-->
    <xs:complexType name="SimpleItemType">
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the items should be evaluated</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Include" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Semi-colon separated list of files (wildcards are allowed) or other item names to include in this item list</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Exclude" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Semi-colon separated list of files (wildcards are allowed) or other item names to exclude from the Include list</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <!-- general utility type allowing an item type to be defined but not its child meta-data-->
    <xs:complexType name="GenericItemType">
        <xs:complexContent>
            <xs:extension base="msb:SimpleItemType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:any namespace="##any" processContents="skip"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <!-- no type declared on this abstract element, so either a simple or complex type can be substituted for it.-->
    <xs:element name="Property" abstract="true"/>
    <!-- ======================================================================================= -->
    <!-- convenience type for properties that just want to allow text and no elements in them-->
    <xs:complexType name="StringPropertyType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="Condition" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:documentation>Optional expression evaluated to determine whether the property should be evaluated</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <!-- general utility type allowing text and/or elements inside-->
    <xs:complexType name="GenericPropertyType" mixed="true">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:any namespace="##any" processContents="skip"/>
        </xs:sequence>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the property should be evaluated</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <!-- ======================================================================================= -->
    <xs:element name="Task" type="msb:TaskType" abstract="true"/>
    <!-- ======================================================================================= -->
    <xs:complexType name="TaskType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="Output">
                <xs:annotation>
                    <xs:documentation>Optional element specifying a specific task output to be gathered</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="TaskParameter" type="msb:non_empty_string" use="required">
                        <xs:annotation>
                            <xs:documentation>Task parameter to gather. Matches the name of a .NET Property on the task class that has an [Output] attribute</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="ItemName" type="msb:non_empty_string" use="optional">
                        <xs:annotation>
                            <xs:documentation>Optional name of an item list to put the gathered outputs into. Either ItemName or PropertyName must be specified</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="PropertyName" type="msb:non_empty_string" use="optional">
                        <xs:annotation>
                            <xs:documentation>Optional name of a property to put the gathered output into. Either PropertyName or ItemName must be specified</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="Condition" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:documentation>Optional expression evaluated to determine whether the output should be gathered</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="Condition" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional expression evaluated to determine whether the task should be executed</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ContinueOnError" type="msb:non_empty_string" use="optional">
            <xs:annotation>
                <xs:documentation>Optional boolean indicating whether a recoverable task error should be ignored. Default false</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!-- We don't need the anyAttribute here because other types deriving from this type will add the right attributes.-->
    </xs:complexType>
    <!-- ======================================================================================= -->
    <!-- XSD considers an empty-valued attribute to satisfy use="required", but we want it to have a non-empty value in most cases, hence this utility type. -->
    <xs:simpleType name="non_empty_string">
        <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>

```

`Hazelnut/mono/lib/mono/4.5/Microsoft.Build.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://schemas.microsoft.com/developer/msbuild/2003"
xmlns:xs="http://www.w3.org/2001/XMLSchema"
xmlns:msb="http://schemas.microsoft.com/developer/msbuild/2003"
elementFormDefault="qualified">

    <!-- =================== IMPORT COMMON SCHEMA =========================== -->
    <xs:include schemaLocation="MSBuild/Microsoft.Build.CommonTypes.xsd"/>

    <!-- ========= ADD CUSTOM ITEMS, PROPERTIES, AND TASKS BELOW ======= -->
    <!-- Note that these will be in the msbuild namespace. A future version of
        msbuild may require that custom itemtypes, properties, and tasks be in a
        custom namespace, but currently msbuild only supports the msbuild namespace. -->

    <!-- example custom itemtype with particular meta-data required-->
    <!--<xs:element name="MyItem" substitutionGroup="msb:Item">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:SimpleItemType">
                    <xs:sequence maxOccurs="1">
                        <xs:choice>
                            <xs:element name="MyMetaData" type="xs:string"/>
                        </xs:choice>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>-->

    <!-- Example custom itemtype with NO meta-data -->
    <!--<xs:element name="MySimpleItem" type="msb:SimpleItemType" substitutionGroup="msb:Item"/>-->

    <!-- Example custom itemtype with ANY meta-data -->
    <!--<xs:element name="MyFlexibleItem" type="msb:GenericItemType" substitutionGroup="msb:Item"/>-->

    <!-- example custom property that allows string content only-->
    <!--<xs:element name="MySimpleProperty" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>-->

    <!-- example custom task with single required parameter-->
    <!--<xs:element name="MyTask" substitutionGroup="msb:Task">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="msb:TaskType">
                    <xs:attribute name="MyParameter" type="xs:boolean" use="required"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>-->

</xs:schema>

```

`Hazelnut/mono/lib/mono/4.5/Microsoft.CSharp.targets`:

```targets
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<DefaultLanguageSourceExtension>.cs</DefaultLanguageSourceExtension>
		<Language>C#</Language>
	</PropertyGroup>

	<PropertyGroup>
		<DebugSymbols Condition=" '$(DebugType)' == 'none' ">false</DebugSymbols>
		<DebugType    Condition=" '$(DebugType)' == 'none' "></DebugType>
	</PropertyGroup>

	<PropertyGroup>
		<CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
		<CoreCompileDependsOn></CoreCompileDependsOn>

		<MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildToolsPath)\Microsoft.CSharp.targets</MSBuildAllProjects>
	</PropertyGroup>

	<PropertyGroup>
		<NoCompilerStandardLib Condition="'$(NoCompilerStandardLib)'==''">true</NoCompilerStandardLib>
	</PropertyGroup>

	<ItemGroup>
		<DocFileItem Include="$(DocumentationFile)" Condition="'$(DocumentationFile)' != ''"/>
	</ItemGroup>

	<Target Name="_AddCorlibReference" DependsOnTargets="GetReferenceAssemblyPaths">
		<!--
		HACK: We don't yet support property functions, so can't calculate FrameworkPathOverride
		by calling ToolLocationHelper.GetPathToStandardLibraries. Instead, we search the framework
		directories for mscorlib.dll by constructing a filtered item set, and assume it only has
		one item.
		-->
		<ItemGroup Condition="'$(MonoUseMicrosoftBuildDll)' != 'True'">
			<_ExplicitReference Include="@(_TargetFrameworkDirectories->'%(FullPath)\mscorlib.dll')" Condition="Exists('%(FullPath)\mscorlib.dll')">
				<Private>false</Private>
			</_ExplicitReference>
		</ItemGroup>
		<PropertyGroup Condition="'$(MonoUseMicrosoftBuildDll)' == 'True'">
			<_ExplicitMSCorlibPath>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToStandardLibraries ('$(TargetFrameworkIdentifier)', '$(TargetFrameworkVersion)', '$(TargetFrameworkProfile)'))\mscorlib.dll</_ExplicitMSCorlibPath>
		</PropertyGroup>
		<ItemGroup Condition="'$(MonoUseMicrosoftBuildDll)' == 'True'">
			<_ExplicitReference Include="@(_TargetFrameworkDirectories->'%(FullPath)\mscorlib.dll')" Condition="Exists('%(FullPath)\mscorlib.dll')">
				<Private>false</Private>
			</_ExplicitReference>
		</ItemGroup>
		<ItemGroup Condition="'$(MonoUseMicrosoftBuildDll)' == 'True'">
			<_ExplicitReference Include="$(_ExplicitMSCorlibPath)" Condition="Exists('$(_ExplicitMSCorlibPath)')">
				<Private>false</Private>
			</_ExplicitReference>
		</ItemGroup>
	</Target>

	<Target
		Name="CoreCompile"
		Inputs="$(MSBuildAllProjects);@(Compile);@(ManifestResourceWithNoCulture);@(ManifestNonResxWithNoCultureOnDisk);@(CompiledLicenseFile);
			$(KeyOriginatorFile);@(ReferencePath);$(ApplicationIcon);$(Win32Resource)"
		Outputs="@(DocFileItem);@(IntermediateAssembly)"
		DependsOnTargets="$(CoreCompileDependsOn)"
	>
		<Csc
			AdditionalLibPaths="$(AdditionalLibPaths)"
			AddModules="@(AddModules)"
			AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
			BaseAddress="$(BaseAddress)"
			CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
			CodePage="$(CodePage)"
			DebugType="$(DebugType)"
			DefineConstants="$(DefineConstants)"
			DelaySign="$(DelaySign)"
			DisabledWarnings="$(NoWarn)"
			DocumentationFile="@(DocFileItem)"
			EmitDebugInformation="$(DebugSymbols)"
			ErrorReport="$(ErrorReport)"
			FileAlignment="$(FileAlignment)"
			GenerateFullPaths="$(GenerateFullPaths)"
			KeyContainer="$(KeyContainerName)"
			KeyFile="$(KeyOriginatorFile)"
			LangVersion="$(LangVersion)"
			MainEntryPoint="$(StartupObject)"
			ModuleAssemblyName="$(ModuleAssemblyName)"
			NoConfig="true"
			NoLogo="$(NoLogo)"
			NoStandardLib="$(NoCompilerStandardLib)"
			Optimize="$(Optimize)"
			OutputAssembly="@(IntermediateAssembly)"
			PdbFile="$(PdbFile)"
			Platform="$(PlatformTarget)"
			References="@(ReferencePath)"
			ResponseFiles="$(CompilerResponseFile)"
			Sources="@(Compile)"
			TargetType="$(OutputType)"
			TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
			UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)"
			Utf8Output="$(Utf8Output)"
			WarningLevel="$(WarningLevel)"
			WarningsAsErrors="$(WarningsAsErrors)"
			WarningsNotAsErrors="$(WarningsNotAsErrors)"
			Win32Icon="$(ApplicationIcon)"
			Win32Resource="$(Win32Resource)"
			Resources="@(ManifestResourceWithNoCulture);@(ManifestNonResxWithNoCultureOnDisk);@(CompiledLicenseFile)"
			ToolExe="$(CscToolExe)"
			ToolPath="$(CscToolPath)" />

	</Target>

	<Target Name="CreateManifestResourceNames">
		<CreateCSharpManifestResourceName Condition="'@(ResxWithNoCulture)' != ''"
			ResourceFiles="@(ResxWithNoCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestResourceWithNoCultureName" />
		</CreateCSharpManifestResourceName>

		<CreateCSharpManifestResourceName Condition="'@(NonResxWithNoCulture)' != ''"
			ResourceFiles="@(NonResxWithNoCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestNonResxWithNoCulture" />
		</CreateCSharpManifestResourceName>

		<CreateCSharpManifestResourceName Condition="'@(ResxWithCulture)' != ''"
			ResourceFiles="@(ResxWithCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestResourceWithCultureName" />
		</CreateCSharpManifestResourceName>

		<CreateCSharpManifestResourceName Condition="'@(NonResxWithCulture)' != ''"
			ResourceFiles="@(NonResxWithCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestNonResxWithCulture" />
		</CreateCSharpManifestResourceName>
	</Target>

	<Import Project="Microsoft.Common.targets" />

	<PropertyGroup Condition="'$(NoCompilerStandardLib)'=='true' and '$(NoStdLib)'!='true'">
		<ResolveAssemblyReferencesDependsOn>$(ResolveAssemblyReferencesDependsOn);_AddCorlibReference</ResolveAssemblyReferencesDependsOn>
	</PropertyGroup>

	<PropertyGroup>
		<TargetFrameworkMonikerAssemblyAttributeText Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">
// &lt;autogenerated /&gt;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(&quot;$(TargetFrameworkMoniker)&quot;, FrameworkDisplayName = &quot;$(TargetFrameworkMonikerDisplayName)&quot;)]
		</TargetFrameworkMonikerAssemblyAttributeText>
	</PropertyGroup>

</Project>

```

`Hazelnut/mono/lib/mono/4.5/Microsoft.Common.targets`:

```targets
<Project DefaultTargets="Build" InitialTargets="_CheckForInvalidConfigurationAndPlatform" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<ImportByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonTargets>
		<ImportByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonTargets>
	</PropertyGroup>

	<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportBefore\*"
		Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportBefore')"/>

	<Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>

	<PropertyGroup>
		<OutputType Condition="'$(OutputType)' == ''">Exe</OutputType>
		<TargetExt Condition="'$(OutputType)' == 'Winexe'">.exe</TargetExt>
		<TargetExt Condition="'$(OutputType)' == 'Exe'">.exe</TargetExt>
		<TargetExt Condition="'$(OutputType)' == 'Library'">.dll</TargetExt>
		<TargetExt Condition="'$(OutputType)' == 'Netmodule'">.netmodule</TargetExt>
	</PropertyGroup>

	<PropertyGroup>
		<ProjectDir Condition="'$(ProjectDir)' == ''">$(MSBuildProjectDirectory)\</ProjectDir>
	</PropertyGroup>

	<!-- MSBuild defines this even outside of VS, and F# projects depend on it -->
	<PropertyGroup>
		<VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">11.0</VisualStudioVersion>
	</PropertyGroup>

	<PropertyGroup>
		<AssemblyName Condition="'$(AssemblyName)' == ''">$(MSBuildProjectName)</AssemblyName>
		<OutputPath Condition="'$(OutputPath)' != '' and !HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
		<OutputPath Condition=" '$(Platform)'=='' and '$(Configuration)'=='' and '$(OutputPath)'=='' ">bin\Debug\</OutputPath>

		<TargetFrameworkIdentifier Condition="'$(TargetFrameworkIdentifier)' == ''">.NETFramework</TargetFrameworkIdentifier>
		<TargetFrameworkVersion Condition="'$(TargetFrameworkVersion)' == ''">v4.0</TargetFrameworkVersion>

		<TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == '' and '$(TargetFrameworkProfile)' != ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion),Profile=$(TargetFrameworkProfile)</TargetFrameworkMoniker>
	        <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
	</PropertyGroup>

	<PropertyGroup>
		<OutDir Condition="'$(OutDir)' == ''">$(OutputPath)</OutDir>
		<OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>

		<_OriginalConfiguration>$(Configuration)</_OriginalConfiguration>
		<Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
		<ConfigurationName Condition="'$(ConfigurationName)' == ''">$(Configuration)</ConfigurationName>

		<_OriginalPlatform>$(Platform)</_OriginalPlatform>
		<Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
		<PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
	</PropertyGroup>

	<!-- in MSBuild, these properties are set in a separate file that is only imported for .NETFramework -->
	<PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
		<AddAdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == ''">true</AddAdditionalExplicitAssemblyReferences>
		<AdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == 'true' and '$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0'">System.Core;$(AdditionalExplicitAssemblyReferences)</AdditionalExplicitAssemblyReferences>
	</PropertyGroup>

	<PropertyGroup>
		<SkipCopyUnchangedFiles Condition="'$(SkipCopyUnchangedFiles)' == ''">true</SkipCopyUnchangedFiles>
	</PropertyGroup>

	<PropertyGroup>
		<BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
		<BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' != '' and !HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
		<CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FilesWrittenAbsolute.txt</CleanFile>
	</PropertyGroup>

	<PropertyGroup Condition="'$(IntermediateOutputPath)' == ''">
		<IntermediateOutputPath Condition=" '$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
		<IntermediateOutputPath Condition=" '$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<PropertyGroup>
		<IntermediateOutputPath Condition="'$(IntermediateOutputPath)' != '' and !HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<IntermediateAssembly Include="$(IntermediateOutputPath)$(AssemblyName)$(TargetExt)" />

		<!-- creating this as a item to use FullPath on it, to build TargetPath -->
		<_OutDirItem Include="$(OutDir)"/>
	</ItemGroup>

	<PropertyGroup>
		<TargetName Condition="'$(TargetName)' == '' ">$(AssemblyName)</TargetName>
		<TargetFileName Condition="'$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>
		<TargetDir Condition=" '$(TargetDir)' == '' ">@(_OutDirItem->'%(FullPath)')</TargetDir>
		<TargetPath Condition=" '$(TargetPath)' == '' ">@(_OutDirItem->'%(FullPath)\$(TargetFileName)')</TargetPath>
		<MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildProjectFullPath);$(MSBuildToolsPath)\Microsoft.Common.targets</MSBuildAllProjects>
		<KeyOriginatorFile Condition=" '$(SignAssembly)' == 'true' ">$(AssemblyOriginatorKeyFile)</KeyOriginatorFile>
		<TargetingClr2Framework Condition="('$(TargetFrameworkIdentifier)' == '.NETFramework') and ('$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5')">true</TargetingClr2Framework>
	</PropertyGroup>

	<Target Name="_CheckForInvalidConfigurationAndPlatform">
		<Error Condition=" '$(OutputPath)' == '' and '$(SkipInvalidConfigurations)' != 'true'"
			Text="'OutputPath' property is not set for this project. Usually this is caused by invalid Configuration/Platform combination. Original values: Configuration: $(_OriginalConfiguration) Platform: $(_OriginalPlatform)."/>

		<Warning Condition=" '$(OutputPath)' == '' and '$(SkipInvalidConfigurations)' == 'true'"
			Text="'OutputPath' property is not set for this project. Usually this is caused by invalid Configuration/Platform combination. Original values: Configuration: $(_OriginalConfiguration) Platform: $(_OriginalPlatform)."/>

		<!-- If OutDir is specified via the command line, then the earlier check
		     to add a trailing slash won't have any affect, so error here. -->
		<Error
			Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')"
			Text="OutDir property must end with a slash."/>
	</Target>

	<PropertyGroup>
		<PrepareForBuildDependsOn>AssignLinkMetadata</PrepareForBuildDependsOn>
	</PropertyGroup>
	<Target Name="PrepareForBuild" DependsOnTargets="$(PrepareForBuildDependsOn)">
		<Message Importance="High" Text="Configuration: $(Configuration) Platform: $(Platform)"/>

		<!-- Look for app.config, if $(AppConfig) is specified, then use that. Else look in
		     @(None) and @(Content) -->
		<CreateItem Include="$(AppConfig)" Condition="'$(AppConfig)' != ''"
			AdditionalMetadata="TargetPath=$(TargetFileName).config">
			<Output TaskParameter="Include" ItemName="AppConfigWithTargetPath" />
		</CreateItem>

		<FindAppConfigFile PrimaryList="@(None)" SecondaryList="@(Content)" TargetPath="$(TargetFileName).config"
			Condition="'$(AppConfig)' == ''">
			<Output TaskParameter="AppConfigFile" ItemName="AppConfigWithTargetPath"/>
		</FindAppConfigFile>

		<MakeDir
			Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)')"
		/>
	</Target>

	<Target Name="AssignLinkMetadata">
	    <AssignLinkMetadata Items="@(EmbeddedResource)" Condition="'@(EmbeddedResource)' != '' and '%(EmbeddedResource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
	      <Output TaskParameter="OutputItems" ItemName="_EmbeddedResourceWithLinkAssigned" />
	    </AssignLinkMetadata>

	    <ItemGroup>
			<EmbeddedResource Remove="@(_EmbeddedResourceWithLinkAssigned)" />
			<EmbeddedResource Include="@(_EmbeddedResourceWithLinkAssigned)" />
			<_EmbeddedResourceWithLinkAssigned Remove="@(_EmbeddedResourceWithLinkAssigned)" />
	    </ItemGroup>
	</Target>

	<PropertyGroup>
		<GetFrameworkPathsDependsOn />
	</PropertyGroup>
	<Target Name="GetFrameworkPaths"
		Condition="'$(TargetFrameworkIdentifier)' == '' or '$(TargetFrameworkIdentifier)' == '.NETFramework'"
		DependsOnTargets="$(GetFrameworkPathsDependsOn)">
		<GetFrameworkPath>
			<Output Condition="'$(TargetFrameworkVersion)' == 'v4.5'"
				TaskParameter="FrameworkVersion45Path"
				ItemName="_CombinedTargetFrameworkDirectoriesItem"/>
			<Output Condition="'$(TargetFrameworkVersion)' == 'v4.0'"
				TaskParameter="FrameworkVersion40Path"
				ItemName="_CombinedTargetFrameworkDirectoriesItem"/>
			<Output Condition="'$(TargetFrameworkVersion)' == 'v3.5'"
				TaskParameter="FrameworkVersion35Path"
				ItemName="_CombinedTargetFrameworkDirectoriesItem"/>
			<Output Condition="'$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'"
				TaskParameter="FrameworkVersion30Path"
				ItemName="_CombinedTargetFrameworkDirectoriesItem"/>
			<Output Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'"
				TaskParameter="FrameworkVersion20Path"
				ItemName="_CombinedTargetFrameworkDirectoriesItem"/>
		</GetFrameworkPath>
		<CreateProperty Value="@(_CombinedTargetFrameworkDirectoriesItem)">
			<Output TaskParameter="Value" PropertyName="TargetFrameworkDirectory"/>
		</CreateProperty>

		<Warning Text="TargetFrameworkVersion '$(TargetFrameworkVersion)' not supported by this toolset (ToolsVersion: $(MSBuildToolsVersion))."
			Condition="'$(TargetFrameworkVersion)' != 'v4.5' and '$(TargetFrameworkVersion)' != 'v4.0' and '$(TargetFrameworkVersion)' != 'v3.5' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v2.0'"/>
	</Target>

	<PropertyGroup>
		<GetReferenceAssemblyPathsDependsOn />
	</PropertyGroup>
	<Target Name="GetReferenceAssemblyPaths" DependsOnTargets="$(GetReferenceAssemblyPathsDependsOn)">
		<!-- in case of .NETFramework, $(TargetFrameworkDirectory) would have been set by
		GetFrameworkPaths, if it hasn't been changed, then clear it, to avoid duplicates -->
		<CreateProperty Value="" Condition="'@(_CombinedTargetFrameworkDirectoriesItem)' == '$(TargetFrameworkDirectory)'">
			<Output TaskParameter="Value" PropertyName="TargetFrameworkDirectory"/>
		</CreateProperty>

		<GetReferenceAssemblyPaths
			Condition="'$(TargetFrameworkMoniker)' != '' and '$(_TargetFrameworkDirectories)' == ''"
			TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
			RootPath="$(TargetFrameworkRootPath)">

			<Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories"/>
			<Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths"/>
			<Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName"/>
		</GetReferenceAssemblyPaths>


		<!-- Remove duplicates. -->
		<ItemGroup>
			<_TargetFrameworkDirectories Include="$(_TargetFrameworkDirectories);$(TargetFrameworkDirectory)" KeepDuplicates="false" />
		</ItemGroup>
		<PropertyGroup>
			<TargetFrameworkDirectory>@(_TargetFrameworkDirectories)</TargetFrameworkDirectory>
		</PropertyGroup>

		<ItemGroup Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'">
			<DesignTimeFacadeDirectoryRoots Include="$(TargetFrameworkDirectory)" />
			<DesignTimeFacadeDirectories Include="%(DesignTimeFacadeDirectoryRoots.Identity)\Facades\" Condition="Exists('%(DesignTimeFacadeDirectoryRoots.Identity)\Facades\')" />
			<_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)\*.dll"/>
		</ItemGroup>

		<PropertyGroup Condition="'@(DesignTimeFacadeDirectories)' != ''">
			<TargetFrameworkDirectory>$(TargetFrameworkDirectory);@(DesignTimeFacadeDirectories)</TargetFrameworkDirectory>
		</PropertyGroup>

	</Target>

	<PropertyGroup>
		<AllowedReferenceAssemblyFileExtensions Condition=" '$(AllowedReferenceAssemblyFileExtensions)' == '' ">
			.exe;
			.dll
		</AllowedReferenceAssemblyFileExtensions>

		<AllowedReferenceRelatedFileExtensions Condition=" '$(AllowedReferenceRelatedFileExtensions)' == '' ">
			.exe.mdb;
			.dll.mdb;
			.pdb;
			.xml
		</AllowedReferenceRelatedFileExtensions>

		<AssemblySearchPaths Condition="'$(AssemblySearchPaths)' == ''">
			{CandidateAssemblyFiles};
			$(ReferencePath);
			@(AdditionalReferencePath);
			{HintPathFromItem};
			{TargetFrameworkDirectory};
			{PkgConfig};
			{GAC};
			{RawFileName};
			$(OutDir)
		</AssemblySearchPaths>

		<ResolveReferencesDependsOn>
			BeforeResolveReferences;
			ResolveProjectReferences;
			ResolveAssemblyReferences;
			AfterResolveReferences
		</ResolveReferencesDependsOn>

		<ResolveAssemblyReferencesDependsOn>
			GetFrameworkPaths;
			GetReferenceAssemblyPaths;
			PrepareForBuild
		</ResolveAssemblyReferencesDependsOn>
	</PropertyGroup>

	<PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''">
		<TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$(IntermediateOutputPath)$(TargetFrameworkMoniker).AssemblyAttribute$(DefaultLanguageSourceExtension)</TargetFrameworkMonikerAssemblyAttributesPath>
		<GenerateTargetFrameworkAttribute Condition="'$(GenerateTargetFrameworkAttribute)' == '' and '$(TargetFrameworkMoniker)'
	!= '' and '$(TargetingClr2Framework)' != 'true'">true</GenerateTargetFrameworkAttribute>
	</PropertyGroup>

	<ItemGroup Condition="'$(GenerateTargetFrameworkAttribute)' == 'true'">
		<FileWrites Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
	</ItemGroup>

	<Target Name="_GenerateTargetFrameworkMonikerAttribute"
		DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths"
		Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets"
		Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)">

		<WriteLinesToFile
			File="$(TargetFrameworkMonikerAssemblyAttributesPath)"
			Lines="$(TargetFrameworkMonikerAssemblyAttributeText)"
			Overwrite="true"
			ContinueOnError="true"
			Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''"
		/>
	</Target>

	<Target Name="GenerateTargetFrameworkMonikerAttribute"
		DependsOnTargets="_GenerateTargetFrameworkMonikerAttribute"
		Condition="'$(GenerateTargetFrameworkAttribute)' == 'true'">

		<ItemGroup Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''">
			<Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)"/>
		</ItemGroup>
	</Target>

	<Target Name="ResolveReferences" DependsOnTargets="$(ResolveReferencesDependsOn)"/>

	<Target Name="BeforeResolveReferences" />
	<Target Name="AfterResolveReferences" />

	<Target Name="ResolveAssemblyReferences" DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)">
		<CreateItem Include="@(Reference)" Exclude="$(AdditionalExplicitAssemblyReferences)">
			<Output TaskParameter="Include" ItemName="_Reference"/>
		</CreateItem>

		<CreateItem Include="$(AdditionalExplicitAssemblyReferences)">
			<Output TaskParameter="Include" ItemName="_Reference"/>
		</CreateItem>

		<ResolveAssemblyReference
			Assemblies="@(_Reference)"
			AssemblyFiles="@(ChildProjectReferences);@(_ExplicitReference)"
			SearchPaths="$(AssemblySearchPaths)"
			CandidateAssemblyFiles="@(Content);@(None)"
			TargetFrameworkDirectories="$(TargetFrameworkDirectory)"
			AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)"
			AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)"
			FindDependencies="true"
			FindSatellites="true"
			FindRelatedFiles="true"
			TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
			TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)"
			TargetFrameworkVersion="$(TargetFrameworkVersion)"
		>
			<Output TaskParameter="ResolvedFiles" ItemName="ResolvedFiles"/>
			<Output TaskParameter="ResolvedFiles" ItemName="ReferencePath"/>
			<Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths"/>
			<Output TaskParameter="RelatedFiles" ItemName="_ReferenceRelatedPaths"/>
			<Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths"/>
			<Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths"/>

			<!-- FIXME: backwards compatibility -->
			<Output TaskParameter="ResolvedDependencyFiles" ItemName="_ResolvedDependencyFiles"/>
		</ResolveAssemblyReference>
	</Target>

	<Target
		Name="AssignProjectConfiguration"
		Condition="'@(ProjectReference)' != ''">

		<!-- assign configs if building a solution file -->
		<AssignProjectConfiguration
			ProjectReferences = "@(ProjectReference)"
			SolutionConfigurationContents = "$(CurrentSolutionConfigurationContents)"
			Condition="$(CurrentSolutionConfigurationContents) != '' and ('$(BuildingSolutionFile)' == 'true' or '$(BuildingInsideVisualStudio)' == 'true')">

			<Output TaskParameter = "AssignedProjects" ItemName = "ProjectReferenceWithConfiguration"/>
		</AssignProjectConfiguration>

		<!-- Else, just -->
		<CreateItem Include="@(ProjectReference)" Condition="$(CurrentSolutionConfigurationContents) == '' or ('$(BuildingSolutionFile)' != 'true' and '$(BuildingInsideVisualStudio)' != 'true')">
			<Output TaskParameter="Include" ItemName="ProjectReferenceWithConfiguration"/>
		</CreateItem>

	</Target>

	<!-- Split projects into 2 lists
		ProjectReferenceWithConfigurationExistent: Projects existent on disk
		ProjectReferenceWithConfigurationNonExistent: Projects non-existent on disk -->

	<Target Name="SplitProjectReferencesByExistent"
		DependsOnTargets="AssignProjectConfiguration">

		<CreateItem Include="@(ProjectReferenceWithConfiguration)" Condition="'@(ProjectReferenceWithConfiguration)' != ''">
			<Output TaskParameter="Include" ItemName="ProjectReferenceWithConfigurationExistent"
				Condition="Exists ('%(ProjectReferenceWithConfiguration.Identity)')"/>

			<Output TaskParameter="Include" ItemName="ProjectReferenceWithConfigurationNonExistent"
				Condition="!Exists ('%(ProjectReferenceWithConfiguration.Identity)')"/>
		</CreateItem>
	</Target>

	<Target
		Name="ResolveProjectReferences"
		DependsOnTargets="SplitProjectReferencesByExistent"
	>
		<!-- If building from a .sln.proj or from IDE, then referenced projects have already
		     been built, so just get the target paths -->
		<MSBuild
			Projects="@(ProjectReferenceWithConfigurationExistent)"
			Targets="GetTargetPath"
			Properties="%(ProjectReferenceWithConfigurationExistent.SetConfiguration); %(ProjectReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(ProjectReferenceWithConfigurationExistent)' != '' and ('$(BuildingSolutionFile)' == 'true' or '$(BuildingInsideVisualStudio)' == 'true')">

			<Output TaskParameter="TargetOutputs" ItemName="ChildProjectReferences" Condition="'%(ProjectReferenceWithConfigurationExistent.ReferenceOutputAssembly)' != 'false'"/>
		</MSBuild>

		<!-- Building a project directly, build the referenced the projects also -->
		<MSBuild
			Projects="@(ProjectReferenceWithConfigurationExistent)"
			Properties="%(ProjectReferenceWithConfigurationExistent.SetConfiguration); %(ProjectReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(ProjectReferenceWithConfigurationExistent)' != '' and '$(BuildingSolutionFile)' != 'true' and '$(BuildingInsideVisualStudio)' != 'true' ">

			<Output TaskParameter="TargetOutputs" ItemName="ChildProjectReferences" Condition="'%(ProjectReferenceWithConfigurationExistent.ReferenceOutputAssembly)' != 'false'"/>
		</MSBuild>

		<Warning Text="Referenced Project %(ProjectReferenceWithConfigurationNonExistent.Identity) not found, ignoring."
			 Condition="'@(ProjectReferenceWithConfigurationNonExistent)' != ''"/>
	</Target>

	<Target Name = "CopyFilesMarkedCopyLocal">
		<Copy
			SourceFiles="@(ReferenceCopyLocalPaths)"
			DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)%(Filename)%(Extension)')"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
			<Output TaskParameter = "DestinationFiles" ItemName = "FileWritesShareable"/>
		</Copy>
	</Target>

	<Target Name="_ComputeNonExistentFileProperty" Condition='false'>
		<CreateProperty Value="__NonExistentSubDir__\__NonExistentFile__">
			<Output TaskParameter="Value" PropertyName="NonExistentFile"/>
		</CreateProperty>
	</Target>

	<PropertyGroup>
		<BuildDependsOn>
			BuildOnlySettings;
			BeforeBuild;
			CoreBuild;
			AfterBuild
		</BuildDependsOn>
	</PropertyGroup>

	<Target Name="BuildOnlySettings"/>
	<Target Name="BeforeBuild"/>
	<Target Name="AfterBuild"/>

	<Target Name="Build" DependsOnTargets="$(BuildDependsOn)" Outputs="$(TargetPath)"/>

	<PropertyGroup>
		<CoreBuildDependsOn>
			PrepareForBuild;
			GetFrameworkPaths;
			GetReferenceAssemblyPaths;
			PreBuildEvent;
			ResolveReferences;
			CopyFilesMarkedCopyLocal;
			PrepareResources;
			Compile;
			PrepareForRun;
			DeployOutputFiles;
			_RecordCleanFile;
			PostBuildEvent
		</CoreBuildDependsOn>
	</PropertyGroup>

	<Target
		Name="CoreBuild"
		DependsOnTargets="$(CoreBuildDependsOn)"
		Outputs="$(OutDir)$(AssemblyName)$(TargetExt)">

		<OnError ExecuteTargets="_TimestampAfterCompile;PostBuildEvent"
			Condition=" '$(RunPostBuildEvent)' == 'Always' or '$(RunPostBuildEvent)' == 'OnOutputUpdated'"/>

		<OnError ExecuteTargets="_RecordCleanFile" />
	</Target>

	<PropertyGroup>
		<CompileDependsOn>
			ResolveReferences;
			GenerateTargetFrameworkMonikerAttribute;
			BeforeCompile;
			_TimestampBeforeCompile;
			CoreCompile;
			_TimestampAfterCompile;
			AfterCompile
		</CompileDependsOn>
	</PropertyGroup>

	<Target Name="BeforeCompile" />
	<Target Name="AfterCompile" />

	<Target Name="Compile" DependsOnTargets="$(CompileDependsOn)"/>

	<PropertyGroup>
		<PrepareForRunDependsOn>
			DeployOutputFiles
		</PrepareForRunDependsOn>
	</PropertyGroup>
	<Target Name="PrepareForRun" DependsOnTargets="$(PrepareForRunDependsOn)"/>

	<PropertyGroup>
		<PrepareResourcesDependsOn>
			AssignTargetPaths;
			SplitResourcesByCulture;
			CreateManifestResourceNames;
			CopyNonResxEmbeddedResources;
			GenerateResources;
			GenerateSatelliteAssemblies;
			CompileLicxFiles
		</PrepareResourcesDependsOn>
	</PropertyGroup>
	<Target Name="PrepareResources" DependsOnTargets="$(PrepareResourcesDependsOn)" />

	<Target Name="SplitResourcesByCulture" DependsOnTargets="AssignTargetPaths">
		<!-- Extract .licx files into @(LicxFiles) -->
		<CreateItem Include="@(EmbeddedResourceWithTargetPath)" Condition="'%(Extension)' == '.licx'">
			<Output TaskParameter="Include" ItemName="LicxFiles"/>
		</CreateItem>

		<!-- Split *remaining* resource files into various groups.. -->
		<AssignCulture Files="@(EmbeddedResourceWithTargetPath)" Condition="'%(Extension)' != '.licx'">
			<Output TaskParameter="AssignedFilesWithNoCulture" ItemName="ResourcesWithNoCulture"/>
			<Output TaskParameter="AssignedFilesWithCulture" ItemName="ResourcesWithCulture"/>
		</AssignCulture>

		<CreateItem Include="@(ResourcesWithNoCulture)" Condition="'%(Extension)' == '.resx'">
			<Output TaskParameter="Include" ItemName="ResxWithNoCulture"/>
		</CreateItem>

		<CreateItem Include="@(ResourcesWithNoCulture)" Condition="'%(Extension)' != '.resx'">
			<Output TaskParameter="Include" ItemName="NonResxWithNoCulture"/>
		</CreateItem>

		<CreateItem Include="@(ResourcesWithCulture)" Condition="'%(Extension)' == '.resx'">
			<Output TaskParameter="Include" ItemName="ResxWithCulture"/>
		</CreateItem>

		<CreateItem Include="@(ResourcesWithCulture)" Condition="'%(Extension)' != '.resx'">
			<Output TaskParameter="Include" ItemName="NonResxWithCulture"/>
		</CreateItem>
	</Target>

	<!-- Copy non-resx resources to their manifest resource names, this is what the compiler expects -->
	<Target Name = "CopyNonResxEmbeddedResources"
		Condition = "'@(NonResxWithCulture)' != '' or '@(NonResxWithNoCulture)' != '' or '@(ManifestNonResxWithCulture)' != '' or '@(ManifestNonResxWithNoCulture)' != ''">

		<MakeDir Directories="$(IntermediateOutputPath)%(ManifestNonResxWithCulture.Culture)"/>
		<Copy SourceFiles = "@(NonResxWithCulture)"
			DestinationFiles = "@(ManifestNonResxWithCulture->'$(IntermediateOutputPath)%(Identity)')"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
			<Output TaskParameter = "DestinationFiles" ItemName = "ManifestNonResxWithCultureOnDisk"/>
			<Output TaskParameter = "DestinationFiles" ItemName = "FileWrites"/>
		</Copy>

		<Copy SourceFiles = "@(NonResxWithNoCulture)"
			DestinationFiles = "@(ManifestNonResxWithNoCulture->'$(IntermediateOutputPath)%(Identity)')"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
			<Output TaskParameter = "DestinationFiles" ItemName = "ManifestNonResxWithNoCultureOnDisk"/>
			<Output TaskParameter = "DestinationFiles" ItemName = "FileWrites"/>
		</Copy>
	</Target>

	<Target Name = "GenerateResources">
		<GenerateResource
			Sources = "@(ResxWithNoCulture)"
			UseSourcePath = "true"
			OutputResources = "@(ManifestResourceWithNoCultureName->'$(IntermediateOutputPath)%(Identity).resources')"
			Condition = "'@(ResxWithNoCulture)' != '' ">

			<Output TaskParameter = "OutputResources" ItemName = "ManifestResourceWithNoCulture"/>
			<Output TaskParameter = "FilesWritten" ItemName = "FileWrites"/>
		</GenerateResource>

		<GenerateResource
			Sources = "@(ResxWithCulture)"
			UseSourcePath = "true"
			OutputResources = "@(ManifestResourceWithCultureName->'$(IntermediateOutputPath)%(Identity).resources')"
			Condition = "'@(ResxWithCulture)' != '' ">

			<Output TaskParameter = "OutputResources" ItemName = "ManifestResourceWithCulture"/>
			<Output TaskParameter = "FilesWritten" ItemName = "FileWrites"/>
		</GenerateResource>
	</Target>

	<Target Name="GenerateSatelliteAssemblies"
		Inputs="@(ManifestResourceWithCulture);@(ManifestNonResxWithCultureOnDisk)"
		Outputs="$(IntermediateOutputPath)%(Culture)\$(AssemblyName).resources.dll" >
		<!-- @(NonResxWithCulture) - rename files to ManifestNon.. and then use for AL -->
		<MakeDir Directories = "$(IntermediateOutputPath)%(ManifestResourceWithCulture.Culture)" Condition = "'@(ManifestResourceWithCulture)' != ''" />
		<MakeDir Directories = "$(IntermediateOutputPath)%(ManifestNonResxWithCultureOnDisk.Culture)" Condition = "'@(ManifestNonResxWithCultureOnDisk)' != ''" />

		<AL
			Culture = "%(Culture)"
			DelaySign="$(DelaySign)"
			EmbedResources = "@(ManifestResourceWithCulture);@(ManifestNonResxWithCultureOnDisk)"
			KeyFile="$(KeyOriginatorFile)"
			ToolExe="$(AlToolExe)"
			ToolPath="$(AlToolPath)"
			OutputAssembly = "$(IntermediateOutputPath)%(Culture)\$(AssemblyName).resources.dll" >
			<Output TaskParameter="OutputAssembly" ItemName="FileWrites"/>
		</AL>


		<CreateItem
			Include = "$(IntermediateOutputPath)%(Culture)\$(AssemblyName).resources.dll"
			AdditionalMetadata = "Culture=%(Culture)"
			Condition = "'@(ManifestResourceWithCulture)' != '' or '@(ManifestNonResxWithCultureOnDisk)' != ''">
			<Output TaskParameter = "Include" ItemName = "IntermediateSatelliteAssemblies" />
		</CreateItem>
	</Target>

	<PropertyGroup>
		<CompileLicxFilesDependsOn></CompileLicxFilesDependsOn>
	</PropertyGroup>

	<Target Name = "CompileLicxFiles"
		Condition = "'@(LicxFiles)' != ''"
		DependsOnTargets = "$(CompileLicxFilesDependsOn)"
		Outputs = "$(IntermediateOutputPath)$(TargetFileName).licenses">
		<LC
			Sources = "@(LicxFiles)"
			LicenseTarget = "$(TargetFileName)"
			OutputDirectory = "$(IntermediateOutputPath)"
			OutputLicense = "$(IntermediateOutputPath)$(TargetFileName).licenses"
			ReferencedAssemblies = "@(ReferencePath);@(ReferenceDependencyPaths)"
			ToolPath = "$(LCToolPath)"
			ToolExe = "$(LCToolExe)">

			<Output TaskParameter="OutputLicense" ItemName="CompiledLicenseFile"/>
			<Output TaskParameter="OutputLicense" ItemName="FileWrites"/>
		</LC>
	</Target>

	<!-- Assign target paths to files that will need to be copied along with the project -->
	<Target Name = "AssignTargetPaths">
		<AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
			<Output TaskParameter="AssignedFiles" ItemName="NoneWithTargetPath"/>
		</AssignTargetPath>

		<AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
			<Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath"/>
		</AssignTargetPath>

		<AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
			<Output TaskParameter="AssignedFiles" ItemName="EmbeddedResourceWithTargetPath"/>
		</AssignTargetPath>
	</Target>

	<Target Name="DeployOutputFiles"
		DependsOnTargets="PrepareResources;CoreCompile;_CopyDeployFilesToOutputDirectory;_CopyAppConfigFile">

		<Copy
			SourceFiles="$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb"
			Condition="'$(OutDir)' != '' and Exists('$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb')"
			DestinationFolder="$(OutDir)"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" >
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>

		<Copy
			SourceFiles="$(IntermediateOutputPath)$(AssemblyName).pdb"
			Condition="'$(OutDir)' != '' and Exists('$(IntermediateOutputPath)$(AssemblyName).pdb')"
			DestinationFolder="$(OutDir)"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" >
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>

		<Copy SourceFiles="@(IntermediateAssembly)" Condition="'$(OutDir)' != '' and Exists ('@(IntermediateAssembly)')" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>

		<Copy
			SourceFiles = "@(IntermediateSatelliteAssemblies)"
			DestinationFiles = "@(IntermediateSatelliteAssemblies->'$(OutDir)\%(Culture)\$(AssemblyName).resources.dll')"
			Condition = "'@(IntermediateSatelliteAssemblies)' != ''"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>
	</Target>

	<Target Name="_CopyDeployFilesToOutputDirectory"
		DependsOnTargets="GetCopyToOutputDirectoryItems;
			_CopyDeployFilesToOutputDirectoryAlways;
			_CopyDeployFilesToOutputDirectoryPreserveNewest"/>

	<Target Name="_CopyDeployFilesToOutputDirectoryPreserveNewest"
		Condition="'@(ItemsToCopyToOutputDirectoryPreserveNewest)' != ''"
		Inputs="@(ItemsToCopyToOutputDirectoryPreserveNewest)"
		Outputs="@(ItemsToCopyToOutputDirectoryPreserveNewest->'$(OutDir)%(TargetPath)')">

		<Copy SourceFiles="@(ItemsToCopyToOutputDirectoryPreserveNewest)"
			DestinationFiles="@(ItemsToCopyToOutputDirectoryPreserveNewest->'$(OutDir)%(TargetPath)')"
			SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>
	</Target>

	<!-- Copy if newer -->
	<Target Name="_CopyDeployFilesToOutputDirectoryAlways"
		Condition="'@(ItemsToCopyToOutputDirectoryAlways)' != ''">

		<Copy SourceFiles="@(ItemsToCopyToOutputDirectoryAlways)"
			DestinationFiles="@(ItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')">
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>
	</Target>


	<Target Name="_CopyAppConfigFile" Condition="'@(AppConfigWithTargetPath)' != ''"
		Inputs="@(AppConfigWithTargetPath)"
		Outputs="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')">

		<Copy SourceFiles="@(AppConfigWithTargetPath)"
			DestinationFiles="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')">
			<Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
		</Copy>
	</Target>

	<Target Name="GetTargetPath" Outputs="$(TargetPath)"/>

	<Target Name="GetCopyToOutputDirectoryItems"
		Outputs="@(AllItemsFullPathWithTargetPath)"
		DependsOnTargets="AssignTargetPaths;SplitProjectReferencesByExistent">

		<!-- FIXME: handle .vcproj
		     FIXME: Private ProjectReferences are honored only in 3.5
		-->
		<MSBuild
			Projects="@(ProjectReferenceWithConfigurationExistent)"
			Targets="GetCopyToOutputDirectoryItems"
			Condition="'@(ProjectReferenceWithConfigurationExistent)' != '' and '%(ProjectReferenceWithConfigurationExistent.Private)' != 'false'">

			<Output TaskParameter="TargetOutputs" ItemName="AllChildProjectItemsWithTargetPath"/>
		</MSBuild>

		<!-- Process items from child project. The outputs need to have full path
		     as they'll be used from other projects -->

		<CreateItem
			Include="@(AllChildProjectItemsWithTargetPath->'%(FullPath)')"
			Condition="'%(AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)' == 'Always' or '%(AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)' == 'PreserveNewest'">

			<Output TaskParameter="Include" ItemName="AllItemsFullPathWithTargetPath"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryAlways"
				Condition="'%(AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryPreserveNewest"
				Condition="'%(AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>

		</CreateItem>

		<!-- Process _this_ project's items -->

		<CreateItem
			Include="@(NoneWithTargetPath->'%(FullPath)')"
			Condition="'%(NoneWithTargetPath.CopyToOutputDirectory)' == 'Always' or '%(NoneWithTargetPath.CopyToOutputDirectory)' == 'PreserveNewest'">
			<Output TaskParameter="Include" ItemName="AllItemsFullPathWithTargetPath"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryAlways"
				Condition="'%(NoneWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryPreserveNewest"
				Condition="'%(NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
		</CreateItem>

		<CreateItem
			Include="@(ContentWithTargetPath->'%(FullPath)')"
			Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)' == 'Always' or '%(ContentWithTargetPath.CopyToOutputDirectory)' == 'PreserveNewest'">
			<Output TaskParameter="Include" ItemName="AllItemsFullPathWithTargetPath"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryAlways"
				Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryPreserveNewest"
				Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
		</CreateItem>

		<CreateItem
			Include="@(EmbeddedResourceWithTargetPath->'%(FullPath)')"
			Condition="'%(EmbeddedResourceWithTargetPath.CopyToOutputDirectory)' == 'Always' or '%(EmbeddedResourceWithTargetPath.CopyToOutputDirectory)' == 'PreserveNewest'">
			<Output TaskParameter="Include" ItemName="AllItemsFullPathWithTargetPath"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryAlways"
				Condition="'%(EmbeddedResourceWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
			<Output TaskParameter="Include" ItemName="ItemsToCopyToOutputDirectoryPreserveNewest"
				Condition="'%(EmbeddedResourceWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
		</CreateItem>

	</Target>

	<!-- Pre/Post BuildEvents -->
	<PropertyGroup>
		<PreBuildEventDependsOn />
	</PropertyGroup>

	<Target Name="PreBuildEvent"
		Condition="'$(PreBuildEvent)' != ''"
		DependsOnTargets="$(PreBuildEventDependsOn)">

		<Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
	</Target>

	<!-- PostBuildEvent depends on $(RunPostBuildEvent)

		Default: OnBuildSuccess
		OnBuildSuccess: Run after a successful build
		OnOutputUpdated: Run only if the output assembly got updates
		Always: Run always
	-->
	<PropertyGroup>
		<PostBuildEventDependsOn />
	</PropertyGroup>

	<!-- this gets invoked in two cases, from CoreBuildDependsOn, if the build completes
	     successfully, OR from OnError in CoreBuild, if the build failed and $(RunPostBuildEvent)
	     is 'Always' or 'OnOutputUpdated'. Invoke $(PostBuildEvent) if its either Empty (== OnBuildSuccess)
	     or OnBuildSuccess or Always OR (OnOutputUpdated and output assembly got updated) -->
	<Target Name="PostBuildEvent"
		Condition="'$(PostBuildEvent)' != '' and
			('$(RunPostBuildEvent)' != 'OnOutputUpdated' or
			  '$(_AssemblyModifiedTimeBeforeCompile)' != '$(_AssemblyModifiedTimeAfterCompile)')"
		DependsOnTargets="$(PostBuildEventDependsOn)">

		<Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />
	</Target>

	<!-- Timestamp the output assemblies, required for PostBuildEvent -->
	<Target Name="_TimestampBeforeCompile" Condition="'$(RunPostBuildEvent)' == 'OnOutputUpdated'">
		<CreateItem Include="%(IntermediateAssembly.ModifiedTime)">
			<Output TaskParameter="Include" PropertyName="_AssemblyModifiedTimeBeforeCompile" />
		</CreateItem>
	</Target>
	<Target Name="_TimestampAfterCompile" Condition="'$(RunPostBuildEvent)' == 'OnOutputUpdated'">
		<CreateItem Include="%(IntermediateAssembly.ModifiedTime)">
			<Output TaskParameter="Include" PropertyName="_AssemblyModifiedTimeAfterCompile" />
		</CreateItem>
	</Target>

	<!-- Rebuild -->
	<PropertyGroup>
		<RebuildDependsOn>
			BeforeRebuild;
			Clean;
			$(MSBuildProjectDefaultTargets);
			AfterRebuild;
		</RebuildDependsOn>

		<RebuildDependsOn Condition="'$(MSBuildProjectDefaultTargets)' == 'Rebuild'">
			BeforeRebuild;
			Clean;
			Build;
			AfterRebuild;
		</RebuildDependsOn>
	</PropertyGroup>

	<Target Name="BeforeRebuild" />
	<Target Name="AfterRebuild" />

	<Target Name="Rebuild"
		DependsOnTargets="$(RebuildDependsOn)"
		Outputs="$(TargetPath)"/>

	<!-- Clean -->
	<Target Name="_RecordCleanFile"
		DependsOnTargets="_GetCompileOutputsForClean">

		<!-- add to list of previous writes for this platform/config -->

		<ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
			<Output TaskParameter="Lines" ItemName="PreviousFileWrites"/>
		</ReadLinesFromFile>

		<!-- CopyLocal files: In case all the projects build to common output
		     directory, then other projects might depend on some of these
		     CopyLocal files, so delete only the ones under *this* project
		     directory -->
		<FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)">
			<Output TaskParameter="InPath" ItemName="FileWrites"/>
		</FindUnderPath>

		<RemoveDuplicates Inputs="@(PreviousFileWrites);@(FileWrites->'%(FullPath)')">
			<Output TaskParameter="Filtered" ItemName="CombinedFileWrites"/>
		</RemoveDuplicates>

		<WriteLinesToFile
			File="$(IntermediateOutputPath)$(CleanFile)"
			Lines="@(CombinedFileWrites)"
			Overwrite="true"/>
	</Target>

	<PropertyGroup>
		<CleanDependsOn>
			BeforeClean;
			CleanReferencedProjects;
			CoreClean;
			AfterClean
		</CleanDependsOn>
	</PropertyGroup>

	<Target Name="_GetCompileOutputsForClean">
		<!-- assembly and debug file in the *intermediate output path* -->
		<CreateItem Include="@(IntermediateAssembly)" Condition="Exists('@(IntermediateAssembly)')">
			<Output TaskParameter="Include" ItemName="FileWrites"/>
		</CreateItem>

		<CreateItem Include="$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb"
			Condition="Exists('$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb')">
			<Output TaskParameter="Include" ItemName="FileWrites"/>
		</CreateItem>

		<CreateItem Include="$(IntermediateOutputPath)$(AssemblyName).pdb"
			Condition="Exists('$(IntermediateOutputPath)$(AssemblyName).pdb')">
			<Output TaskParameter="Include" ItemName="FileWrites"/>
		</CreateItem>
	</Target>

	<!-- Get the list of files written, for clean -->
	<Target Name="_GetCleanFileWrites"
		DependsOnTargets="_GetCompileOutputsForClean">
		<ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
			<Output TaskParameter="Lines" ItemName="PreviousFileWrites"/>
		</ReadLinesFromFile>
	</Target>

	<Target Name="CleanReferencedProjects"
		DependsOnTargets="AssignProjectConfiguration">

		<!-- If building from .sln.proj or from IDE, clean will get handled by them,
		     else we are building a project directly, from the command line, so
		     clean the referenced projects -->
		<MSBuild Projects="@(ProjectReferenceWithConfigurationExistent)"
			Targets="Clean"
			Condition=" '$(BuildingSolutionFile)' != 'true' and '$(BuildingInsideVisualStudio)' != 'true' and '@(ProjectReferenceWithConfigurationExistent)' != ''" />

	</Target>

	<Target Name="Clean" DependsOnTargets="$(CleanDependsOn)"/>

	<!-- Override in project to run before/after clean tasks -->
	<Target Name="BeforeClean" />
	<Target Name="AfterClean" />

	<Target Name="CoreClean" DependsOnTargets="_GetCleanFileWrites">
		<Delete Files="@(PreviousFileWrites);@(FileWrites)" TreatErrorsAsWarnings="true"/>

		<!-- all previous files written for this platform/config have been deleted,
		     we can safely remove the file list now -->
		<Delete Files="$(IntermediateOutputPath)$(CleanFile)" TreatErrorsAsWarnings="true" />
	</Target>

	<PropertyGroup>
		<ImplicitlyExpandDesignTimeFacades>true</ImplicitlyExpandDesignTimeFacades>

		<ResolveReferencesDependsOn>
			$(ResolveReferencesDependsOn);
			ImplicitlyExpandDesignTimeFacades
		</ResolveReferencesDependsOn>

		<ImplicitlyExpandDesignTimeFacadesDependsOn>
			$(ImplicitlyExpandDesignTimeFacadesDependsOn);
			GetReferenceAssemblyPaths
		</ImplicitlyExpandDesignTimeFacadesDependsOn>
	</PropertyGroup>

	<Target Name="ImplicitlyExpandDesignTimeFacades" Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'" DependsOnTargets="$(ImplicitlyExpandDesignTimeFacadesDependsOn)">

		<PropertyGroup>
			<_HasReferenceToSystemRuntime Condition="'%(_ResolvedDependencyFiles.Filename)' == 'System.Runtime'">true</_HasReferenceToSystemRuntime>
		</PropertyGroup>

		<ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true'">
			<!-- If the user has manually referenced these assemblies, remove them so we don't end up with duplicates -->
			<ReferencePath Remove="@(_DesignTimeFacadeAssemblies)"/>
			<ReferencePath Include="%(_DesignTimeFacadeAssemblies.Identity)">
				<WinMDFile>false</WinMDFile>
				<CopyLocal>false</CopyLocal>
				<ResolvedFrom>ImplicitlyExpandDesignTimeFacades</ResolvedFrom>
			</ReferencePath>
			<_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
		</ItemGroup>

		<Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />

	</Target>

	<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportAfter\*"
		Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportAfter')"/>
</Project>

```

`Hazelnut/mono/lib/mono/4.5/Microsoft.Common.tasks`:

```tasks
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" >
	<UsingTask TaskName="Microsoft.Build.Tasks.AL"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignLinkMetadata"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignProjectConfiguration"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Copy"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateProperty"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Csc"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Delete"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Error"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Exec"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.LC"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Message"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.SignFile"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Touch"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Vbc"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Warning"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
</Project>

```

`Hazelnut/mono/lib/mono/4.5/Microsoft.VisualBasic.targets`:

```targets
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<DefaultLanguageSourceExtension>.vb</DefaultLanguageSourceExtension>
		<Language>VB</Language>
	</PropertyGroup>

	<PropertyGroup>
		<CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
	</PropertyGroup>

	<PropertyGroup>
		<FinalDefineConstants>CONFIG=&quot;$(Configuration)&quot;</FinalDefineConstants>
		<FinalDefineConstants Condition=" '$(DefineDebug)' == 'true' ">$(FinalDefineConstants),DEBUG=-1</FinalDefineConstants>
		<FinalDefineConstants Condition=" '$(DefineTrace)' == 'true' ">$(FinalDefineConstants),TRACE=-1</FinalDefineConstants>
		<FinalDefineConstants Condition=" '$(MyType)' != '' ">$(FinalDefineConstants),_MyType=&quot;$(MyType)&quot;</FinalDefineConstants>
		<FinalDefineConstants Condition=" '$(Platform)' != '' ">$(FinalDefineConstants),PLATFORM=&quot;$(Platform)&quot;</FinalDefineConstants>
		<FinalDefineConstants Condition=" '$(Platform)' == '' ">$(FinalDefineConstants),PLATFORM=&quot;AnyCPU&quot;</FinalDefineConstants>
		<FinalDefineConstants Condition=" '$(DefineConstants)' != '' ">$(FinalDefineConstants),$(DefineConstants)</FinalDefineConstants>

		<_NoWarnings Condition=" '$(WarningLevel)' == '0' ">true</_NoWarnings>
		<_NoWarnings Condition=" '$(WarningLevel)' == '1' ">false</_NoWarnings>

		<DebugSymbols Condition=" '$(DebugType)' == 'none' ">false</DebugSymbols>
		<DebugType    Condition=" '$(DebugType)' == 'none' "></DebugType>

		<CoreCompileDependsOn></CoreCompileDependsOn>
	</PropertyGroup>

	<ItemGroup>
		<DocFileItem Include="$(DocumentationFile)"  Condition="'$(DocumentationFile)'!=''"/>
	</ItemGroup>

	<Target
		Name="CoreCompile"
		Inputs="$(MSBuildAllProjects);@(Compile);@(ManifestResourceWithNoCulture);@(ManifestNonResxWithNoCultureOnDisk);@(CompiledLicenseFile);@(DocFileItem);
			$(KeyOriginatorFile);@(ReferencePath);$(Win32Icon);$(Win32Resource)"
		Outputs="@(IntermediateAssembly)"
		DependsOnTargets="$(CoreCompileDependsOn)"
	>
		<Vbc
			AdditionalLibPaths="$(AdditionalLibPaths)"
			AddModules="@(AddModules)"
			BaseAddress="$(BaseAddress)"
			CodePage="$(CodePage)"
			DebugType="$(DebugType)"
			DefineConstants="$(FinalDefineConstants)"
			DelaySign="$(DelaySign)"
			DisabledWarnings="$(NoWarn)"
			DocumentationFile="@(DocFileItem)"
			EmitDebugInformation="$(DebugSymbols)"
			ErrorReport="$(ErrorReport)"
			FileAlignment="$(FileAlignment)"
			GenerateDocumentation="$(GenerateDocumentation)"
			Imports="@(Import)"
			KeyContainer="$(KeyContainerName)"
			KeyFile="$(KeyOriginatorFile)"
			MainEntryPoint="$(StartupObject)"
			NoConfig="true"
			NoLogo="$(NoLogo)"
			NoStandardLib="$(NoStdLib)"
			NoWarnings="$(_NoWarnings)"
			Optimize="$(Optimize)"
			OptionCompare="$(OptionCompare)"
			OptionExplicit="$(OptionExplicit)"
			OptionStrict="$(OptionStrict)"
			OptionStrictType="$(OptionStrictType)"
			OptionInfer="$(OptionInfer)"
			OutputAssembly="@(IntermediateAssembly)"
			Platform="$(PlatformTarget)"
			References="@(ReferencePath)"
			RemoveIntegerChecks="$(RemoveIntegerChecks)"
			Resources="@(ManifestResourceWithNoCulture);@(ManifestNonResxWithNoCultureOnDisk);@(CompiledLicenseFile)"
			ResponseFiles="$(CompilerResponseFile)"
			RootNamespace="$(RootNamespace)"
			Sources="@(Compile)"
			TargetType="$(OutputType)"
			TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
			UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)"
			Utf8Output="$(Utf8Output)"
			VBRuntime="$(VBRuntime)"
			Verbosity="$(VbcVerbosity)"
			WarningsAsErrors="$(WarningsAsErrors)"
			WarningsNotAsErrors="$(WarningsNotAsErrors)"
			Win32Icon="$(Win32Icon)"
			Win32Resource="$(Win32Resource)"
			ToolExe="$(VbcToolExe)"
			ToolPath="$(VbcToolPath)"
			/>

	</Target>

	<Target Name="CreateManifestResourceNames">
		<CreateVisualBasicManifestResourceName Condition="'@(ResxWithNoCulture)' != ''"
			ResourceFiles="@(ResxWithNoCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestResourceWithNoCultureName" />
		</CreateVisualBasicManifestResourceName>

		<CreateVisualBasicManifestResourceName Condition="'@(NonResxWithNoCulture)' != ''"
			ResourceFiles="@(NonResxWithNoCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestNonResxWithNoCulture" />
		</CreateVisualBasicManifestResourceName>

		<CreateVisualBasicManifestResourceName Condition="'@(ResxWithCulture)' != ''"
			ResourceFiles="@(ResxWithCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestResourceWithCultureName" />
		</CreateVisualBasicManifestResourceName>

		<CreateVisualBasicManifestResourceName Condition="'@(NonResxWithCulture)' != ''"
			ResourceFiles="@(NonResxWithCulture)" RootNamespace="$(RootNamespace)">
			<Output TaskParameter = "ManifestResourceNames" ItemName = "ManifestNonResxWithCulture" />
		</CreateVisualBasicManifestResourceName>
	</Target>

	<Import Project="Microsoft.Common.targets" />

	<PropertyGroup>
		<VbcToolExe Condition="'$(VbcToolExe)' == ''">vbnc.exe</VbcToolExe>
	</PropertyGroup>

</Project>

```

`Hazelnut/mono/lib/mono/4.5/VBCSCompiler.exe.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
  </startup>
  <runtime>
    <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
    <gcServer enabled="true" />
    <gcConcurrent enabled="false" />
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.CSharp" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.VisualBasic" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Encoding.CodePages" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.0" newVersion="4.1.1.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
  <appSettings>
    <!-- Number of seconds with no activity before the server times out and closes. 
         Set to -1 to never shut down the server. -->
    <add key="keepalive" value="600" />
  </appSettings>
</configuration>
```

`Hazelnut/mono/lib/mono/4.5/csc.exe.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
  </startup>
  <runtime>
    <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
    <gcServer enabled="true" />
    <gcConcurrent enabled="false" />
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.CSharp" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Encoding.CodePages" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.0" newVersion="4.1.1.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`Hazelnut/mono/lib/mono/4.5/csc.rsp`:

```rsp
# Licensed to the .NET Foundation under one or more agreements.
# The .NET Foundation licenses this file to you under the MIT license.
# See the LICENSE file in the project root for more information.

# This file contains command-line options that the C#
# command line compiler (CSC) will process as part
# of every compilation, unless the "/noconfig" option
# is specified. 

# Reference the common Framework libraries
/r:Accessibility.dll
/r:Microsoft.CSharp.dll
/r:System.Configuration.dll
/r:System.Configuration.Install.dll
/r:System.Core.dll
/r:System.Data.dll
/r:System.Data.DataSetExtensions.dll
/r:System.Data.Linq.dll
/r:System.Data.OracleClient.dll
/r:System.Deployment.dll
/r:System.Design.dll
/r:System.DirectoryServices.dll
/r:System.dll
/r:System.Drawing.Design.dll
/r:System.Drawing.dll
/r:System.EnterpriseServices.dll
/r:System.Management.dll
/r:System.Messaging.dll
/r:System.Runtime.Remoting.dll
/r:System.Runtime.Serialization.dll
/r:System.Runtime.Serialization.Formatters.Soap.dll
/r:System.Security.dll
/r:System.ServiceModel.dll
/r:System.ServiceModel.Web.dll
/r:System.ServiceProcess.dll
/r:System.Transactions.dll
/r:System.Web.dll
/r:System.Web.Extensions.Design.dll
/r:System.Web.Extensions.dll
/r:System.Web.Mobile.dll
/r:System.Web.RegularExpressions.dll
/r:System.Web.Services.dll
/r:System.Windows.Forms.dll
/r:System.Workflow.Activities.dll
/r:System.Workflow.ComponentModel.dll
/r:System.Workflow.Runtime.dll
/r:System.Xml.dll
/r:System.Xml.Linq.dll

```

`Hazelnut/mono/lib/mono/4.5/csi.exe.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
  </startup>
  <runtime>
    <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.CSharp" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.CSharp.Scripting" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.Scripting" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Encoding.CodePages" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.0" newVersion="4.1.1.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`Hazelnut/mono/lib/mono/4.5/csi.rsp`:

```rsp
/r:System.dll
/r:System.Core.dll
/r:Microsoft.CSharp.dll
/r:Facades/System.Runtime.dll
/r:Facades/netstandard.dll
/u:System
/u:System.IO
/u:System.Collections.Generic
/u:System.Console
/u:System.Diagnostics
/u:System.Dynamic
/u:System.Linq
/u:System.Linq.Expressions
/u:System.Text
/u:System.Threading.Tasks
```

`Hazelnut/mono/lib/mono/4.5/mono-shlib-cop.exe.config`:

```config
<configuration>
	<dllmap dll="libgmodule-2.0.so" target="libgmodule-2.0.so.0"/>
	<dllmap dll="libglib-2.0.so" target="libglib-2.0.so.0"/>
</configuration>

```

`Hazelnut/mono/lib/mono/4.5/sqlmetal.exe.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <section name="providers" type="DbMetal.Configuration.ProvidersSection, sqlmetal" />
  </configSections>
  <connectionStrings>
    <add name="DbMetal.Properties.Settings.TempOneConnectionString"
      connectionString="Data Source=.\sqlexpress;Initial Catalog=TempOne;Integrated Security=True"
      providerName="System.Data.SqlClient" />
  </connectionStrings>
  <appSettings>
    <add key="ClientSettingsProvider.ServiceUri" value="" />
  </appSettings>
  <providers>
    <providers>
      <provider name="MySQL" dbLinqSchemaLoader="DbLinq.MySql.MySqlSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="ByteFX.Data.MySqlClient.MySqlConnection, ByteFX.Data" />
      <provider name="Oracle" dbLinqSchemaLoader="DbLinq.Oracle.OracleSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="System.Data.OracleClient.OracleConnection, System.Data.OracleClient" />
      <provider name="OracleODP" dbLinqSchemaLoader="DbLinq.Oracle.OracleSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="Oracle.DataAccess.Client.OracleConnection, Oracle.DataAccess" />
      <provider name="PostgreSQL" dbLinqSchemaLoader="DbLinq.PostgreSql.PgsqlSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="Npgsql.NpgsqlConnection, Npgsql" />
      <provider name="SQLite" dbLinqSchemaLoader="DbLinq.Sqlite.SqliteSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="Mono.Data.Sqlite.SqliteConnection, Mono.Data.Sqlite" />
      <provider name="SqlServer" dbLinqSchemaLoader="DbLinq.SqlServer.SqlServerSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="System.Data.SqlClient.SqlConnection, System.Data" />
      <provider name="Ingres" dbLinqSchemaLoader="DbLinq.Ingres.IngresSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="Ingres.Client.IngresConnection, Ingres.Client" />
      <provider name="Firebird" dbLinqSchemaLoader="DbLinq.Firebird.FirebirdSchemaLoader, System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" databaseConnection="FirebirdSql.Data.FirebirdClient.FbConnection, FirebirdSql.Data.FirebirdClient" />
    </providers>
  </providers>
  <system.web>
    <membership defaultProvider="ClientAuthenticationMembershipProvider">
      <providers>
        <add name="ClientAuthenticationMembershipProvider" type="System.Web.ClientServices.Providers.ClientFormsAuthenticationMembershipProvider, System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" serviceUri="" />
      </providers>
    </membership>
    <roleManager defaultProvider="ClientRoleProvider" enabled="true">
      <providers>
        <add name="ClientRoleProvider" type="System.Web.ClientServices.Providers.ClientRoleProvider, System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" serviceUri="" cacheTimeout="86400" />
      </providers>
    </roleManager>
  </system.web>
</configuration>

```

`Hazelnut/mono/lib/mono/4.5/vbc.exe.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
  </startup>
  <runtime>
    <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
    <gcServer enabled="true" />
    <gcConcurrent enabled="false" />
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.CodeAnalysis.VisualBasic" publicKeyToken="31bf3856ad364e35" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-3.9.0.0" newVersion="3.9.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Encoding.CodePages" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.0" newVersion="4.1.1.0" />
      </dependentAssembly>
    </assemblyBinding>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`Hazelnut/mono/lib/mono/4.5/vbc.rsp`:

```rsp
# Licensed to the .NET Foundation under one or more agreements.
# The .NET Foundation licenses this file to you under the MIT license.
# See the LICENSE file in the project root for more information.

# This file contains command-line options that the VB
# command line compiler (VBC) will process as part
# of every compilation, unless the "/noconfig" option
# is specified. 

# Reference the common Framework libraries
/r:Accessibility.dll
/r:System.Configuration.dll
/r:System.Configuration.Install.dll
/r:System.Data.dll
/r:System.Data.OracleClient.dll
/r:System.Deployment.dll
/r:System.Design.dll
/r:System.DirectoryServices.dll
/r:System.dll
/r:System.Drawing.Design.dll
/r:System.Drawing.dll
/r:System.EnterpriseServices.dll
/r:System.Management.dll
/r:System.Messaging.dll
/r:System.Runtime.Remoting.dll
/r:System.Runtime.Serialization.Formatters.Soap.dll
/r:System.Security.dll
/r:System.ServiceProcess.dll
/r:System.Transactions.dll
/r:System.Web.dll
/r:System.Web.Mobile.dll
/r:System.Web.RegularExpressions.dll
/r:System.Web.Services.dll
/r:System.Windows.Forms.dll
/r:System.Xml.dll

/r:System.Workflow.Activities.dll
/r:System.Workflow.ComponentModel.dll
/r:System.Workflow.Runtime.dll
/r:System.Runtime.Serialization.dll
/r:System.ServiceModel.dll

/r:System.Core.dll
/r:System.Xml.Linq.dll
/r:System.Data.Linq.dll
/r:System.Data.DataSetExtensions.dll
/r:System.Web.Extensions.dll
/r:System.Web.Extensions.Design.dll
/r:System.ServiceModel.Web.dll

# Import System and Microsoft.VisualBasic
/imports:System
/imports:Microsoft.VisualBasic
/imports:System.Linq
/imports:System.Xml.Linq

/optioninfer+

```

`Hazelnut/mono/lib/mono/4.5/vbnc.rsp`:

```rsp
-r:Accessibility.dll
-r:System.Configuration.dll
-r:System.Data.dll
-r:System.Design.dll
-r:System.dll
-r:System.Drawing.Design.dll
-r:System.Drawing.dll
-r:System.Web.dll
-r:System.Web.Services.dll
-r:System.Windows.Forms.dll
-r:System.Xml.dll

-imports:System
-imports:Microsoft.VisualBasic

```

`Hazelnut/mono/lib/mono/4.5/xbuild.exe.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<runtime>
		<generatePublisherEvidence enabled="false" />
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="Microsoft.Build.Framework" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-100.0.0.0" newVersion="4.0.0.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="Microsoft.Build.Engine" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-100.0.0.0" newVersion="4.0.0.0" />
			</dependentAssembly>
		</assemblyBinding>
	</runtime>
</configuration>

```

`Hazelnut/mono/lib/mono/4.5/xbuild.rsp`:

```rsp
# xbuild command line options specified here will be used
# by xbuild on every build, unless /noautoresponse is passed
# on the command line.

```

`Hazelnut/premake5.lua`:

```lua
project "Hazelnut"
	kind "ConsoleApp"
	language "C++"
	cppdialect "C++17"
	staticruntime "off"

	targetdir ("%{wks.location}/bin/" .. outputdir .. "/%{prj.name}")
	objdir ("%{wks.location}/bin-int/" .. outputdir .. "/%{prj.name}")

	files
	{
		"src/**.h",
		"src/**.cpp"
	}

	includedirs
	{
		"%{wks.location}/Hazel/vendor/spdlog/include",
		"%{wks.location}/Hazel/src",
		"%{wks.location}/Hazel/vendor",
		"%{IncludeDir.entt}",
		"%{IncludeDir.filewatch}",
		"%{IncludeDir.glm}",
		"%{IncludeDir.ImGuizmo}"
	}

	links
	{
		"Hazel"
	}

	filter "system:windows"
		systemversion "latest"

	filter "configurations:Debug"
		defines "HZ_DEBUG"
		runtime "Debug"
		symbols "on"

	filter "configurations:Release"
		defines "HZ_RELEASE"
		runtime "Release"
		optimize "on"

	filter "configurations:Dist"
		defines "HZ_DIST"
		runtime "Release"
		optimize "on"

```

`Hazelnut/src/EditorLayer.cpp`:

```cpp
#include "EditorLayer.h"
#include "Hazel/Scene/SceneSerializer.h"
#include "Hazel/Utils/PlatformUtils.h"
#include "Hazel/Math/Math.h"
#include "Hazel/Scripting/ScriptEngine.h"
#include "Hazel/Renderer/Font.h"

#include <imgui/imgui.h>

#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "ImGuizmo.h"

namespace Hazel {

	static Ref<Font> s_Font;

	EditorLayer::EditorLayer()
		: Layer("EditorLayer"), m_CameraController(1280.0f / 720.0f), m_SquareColor({ 0.2f, 0.3f, 0.8f, 1.0f })
	{
		s_Font = Font::GetDefault();
	}

	void EditorLayer::OnAttach()
	{
		HZ_PROFILE_FUNCTION();

		m_CheckerboardTexture = Texture2D::Create("assets/textures/Checkerboard.png");
		m_IconPlay = Texture2D::Create("Resources/Icons/PlayButton.png");
		m_IconPause = Texture2D::Create("Resources/Icons/PauseButton.png");
		m_IconSimulate = Texture2D::Create("Resources/Icons/SimulateButton.png");
		m_IconStep = Texture2D::Create("Resources/Icons/StepButton.png");
		m_IconStop = Texture2D::Create("Resources/Icons/StopButton.png");

		FramebufferSpecification fbSpec;
		fbSpec.Attachments = { FramebufferTextureFormat::RGBA8, FramebufferTextureFormat::RED_INTEGER, FramebufferTextureFormat::Depth };
		fbSpec.Width = 1280;
		fbSpec.Height = 720;
		m_Framebuffer = Framebuffer::Create(fbSpec);

		m_EditorScene = CreateRef<Scene>();
		m_ActiveScene = m_EditorScene;

		auto commandLineArgs = Application::Get().GetSpecification().CommandLineArgs;
		if (commandLineArgs.Count > 1)
		{
			auto projectFilePath = commandLineArgs[1];
			OpenProject(projectFilePath);
		}
		else
		{
			// TODO(Yan): prompt the user to select a directory
			// NewProject();

			// If no project is opened, close Hazelnut
			// NOTE: this is while we don't have a new project path
			if (!OpenProject())
				Application::Get().Close();

		}

		m_EditorCamera = EditorCamera(30.0f, 1.778f, 0.1f, 1000.0f);
		Renderer2D::SetLineWidth(4.0f);
	}

	void EditorLayer::OnDetach()
	{
		HZ_PROFILE_FUNCTION();
	}

	void EditorLayer::OnUpdate(Timestep ts)
	{
		HZ_PROFILE_FUNCTION();

		m_ActiveScene->OnViewportResize((uint32_t)m_ViewportSize.x, (uint32_t)m_ViewportSize.y);

		// Resize
		if (FramebufferSpecification spec = m_Framebuffer->GetSpecification();
			m_ViewportSize.x > 0.0f && m_ViewportSize.y > 0.0f && // zero sized framebuffer is invalid
			(spec.Width != m_ViewportSize.x || spec.Height != m_ViewportSize.y))
		{
			m_Framebuffer->Resize((uint32_t)m_ViewportSize.x, (uint32_t)m_ViewportSize.y);
			m_CameraController.OnResize(m_ViewportSize.x, m_ViewportSize.y);
			m_EditorCamera.SetViewportSize(m_ViewportSize.x, m_ViewportSize.y);
		}

		// Render
		Renderer2D::ResetStats();
		m_Framebuffer->Bind();
		RenderCommand::SetClearColor({ 0.1f, 0.1f, 0.1f, 1 });
		RenderCommand::Clear();

		// Clear our entity ID attachment to -1
		m_Framebuffer->ClearAttachment(1, -1);

		switch (m_SceneState)
		{
			case SceneState::Edit:
			{
				if (m_ViewportFocused)
					m_CameraController.OnUpdate(ts);

				m_EditorCamera.OnUpdate(ts);

				m_ActiveScene->OnUpdateEditor(ts, m_EditorCamera);
				break;
			}
			case SceneState::Simulate:
			{
				m_EditorCamera.OnUpdate(ts);

				m_ActiveScene->OnUpdateSimulation(ts, m_EditorCamera);
				break;
			}
			case SceneState::Play:
			{
				m_ActiveScene->OnUpdateRuntime(ts);
				break;
			}
		}

		auto[mx, my] = ImGui::GetMousePos();
		mx -= m_ViewportBounds[0].x;
		my -= m_ViewportBounds[0].y;
		glm::vec2 viewportSize = m_ViewportBounds[1] - m_ViewportBounds[0];
		my = viewportSize.y - my;
		int mouseX = (int)mx;
		int mouseY = (int)my;

		if (mouseX >= 0 && mouseY >= 0 && mouseX < (int)viewportSize.x && mouseY < (int)viewportSize.y)
		{
			int pixelData = m_Framebuffer->ReadPixel(1, mouseX, mouseY);
			m_HoveredEntity = pixelData == -1 ? Entity() : Entity((entt::entity)pixelData, m_ActiveScene.get());
		}

		OnOverlayRender();

		m_Framebuffer->Unbind();
	}

	void EditorLayer::OnImGuiRender()
	{
		HZ_PROFILE_FUNCTION();

		// Note: Switch this to true to enable dockspace
		static bool dockspaceOpen = true;
		static bool opt_fullscreen_persistant = true;
		bool opt_fullscreen = opt_fullscreen_persistant;
		static ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_None;

		// We are using the ImGuiWindowFlags_NoDocking flag to make the parent window not dockable into,
		// because it would be confusing to have two docking targets within each others.
		ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
		if (opt_fullscreen)
		{
			ImGuiViewport* viewport = ImGui::GetMainViewport();
			ImGui::SetNextWindowPos(viewport->Pos);
			ImGui::SetNextWindowSize(viewport->Size);
			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
			ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
			window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
			window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
		}

		// When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background and handle the pass-thru hole, so we ask Begin() to not render a background.
		if (dockspace_flags & ImGuiDockNodeFlags_PassthruCentralNode)
			window_flags |= ImGuiWindowFlags_NoBackground;

		// Important: note that we proceed even if Begin() returns false (aka window is collapsed).
		// This is because we want to keep our DockSpace() active. If a DockSpace() is inactive, 
		// all active windows docked into it will lose their parent and become undocked.
		// We cannot preserve the docking relationship between an active window and an inactive docking, otherwise 
		// any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.
		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
		ImGui::Begin("DockSpace Demo", &dockspaceOpen, window_flags);
		ImGui::PopStyleVar();

		if (opt_fullscreen)
			ImGui::PopStyleVar(2);

		// DockSpace
		ImGuiIO& io = ImGui::GetIO();
		ImGuiStyle& style = ImGui::GetStyle();
		float minWinSizeX = style.WindowMinSize.x;
		style.WindowMinSize.x = 370.0f;
		if (io.ConfigFlags & ImGuiConfigFlags_DockingEnable)
		{
			ImGuiID dockspace_id = ImGui::GetID("MyDockSpace");
			ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);
		}

		style.WindowMinSize.x = minWinSizeX;

		if (ImGui::BeginMenuBar())
		{
			if (ImGui::BeginMenu("File"))
			{
				if (ImGui::MenuItem("Open Project...", "Ctrl+O"))
					OpenProject();

				ImGui::Separator();

				if (ImGui::MenuItem("New Scene", "Ctrl+N"))
					NewScene();

				if (ImGui::MenuItem("Save Scene", "Ctrl+S"))
					SaveScene();

				if (ImGui::MenuItem("Save Scene As...", "Ctrl+Shift+S"))
					SaveSceneAs();

				ImGui::Separator();

				if (ImGui::MenuItem("Exit"))
					Application::Get().Close();
				
				ImGui::EndMenu();
			}

			if (ImGui::BeginMenu("Script"))
			{
				if (ImGui::MenuItem("Reload assembly", "Ctrl+R"))
					ScriptEngine::ReloadAssembly();
				
				ImGui::EndMenu();
			}

			ImGui::EndMenuBar();
		}

		m_SceneHierarchyPanel.OnImGuiRender();
		m_ContentBrowserPanel->OnImGuiRender();

		ImGui::Begin("Stats");

#if 0
		std::string name = "None";
		if (m_HoveredEntity)
			name = m_HoveredEntity.GetComponent<TagComponent>().Tag;
		ImGui::Text("Hovered Entity: %s", name.c_str());
#endif

		auto stats = Renderer2D::GetStats();
		ImGui::Text("Renderer2D Stats:");
		ImGui::Text("Draw Calls: %d", stats.DrawCalls);
		ImGui::Text("Quads: %d", stats.QuadCount);
		ImGui::Text("Vertices: %d", stats.GetTotalVertexCount());
		ImGui::Text("Indices: %d", stats.GetTotalIndexCount());

		ImGui::End();

		ImGui::Begin("Settings");
		ImGui::Checkbox("Show physics colliders", &m_ShowPhysicsColliders);

		ImGui::Image((ImTextureID)s_Font->GetAtlasTexture()->GetRendererID(), { 512,512 }, {0, 1}, {1, 0});


		ImGui::End();

		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2{ 0, 0 });
		ImGui::Begin("Viewport");
		auto viewportMinRegion = ImGui::GetWindowContentRegionMin();
		auto viewportMaxRegion = ImGui::GetWindowContentRegionMax();
		auto viewportOffset = ImGui::GetWindowPos();
		m_ViewportBounds[0] = { viewportMinRegion.x + viewportOffset.x, viewportMinRegion.y + viewportOffset.y };
		m_ViewportBounds[1] = { viewportMaxRegion.x + viewportOffset.x, viewportMaxRegion.y + viewportOffset.y };

		m_ViewportFocused = ImGui::IsWindowFocused();
		m_ViewportHovered = ImGui::IsWindowHovered();

		Application::Get().GetImGuiLayer()->BlockEvents(!m_ViewportHovered);

		ImVec2 viewportPanelSize = ImGui::GetContentRegionAvail();
		m_ViewportSize = { viewportPanelSize.x, viewportPanelSize.y };

		uint64_t textureID = m_Framebuffer->GetColorAttachmentRendererID();
		ImGui::Image(reinterpret_cast<void*>(textureID), ImVec2{ m_ViewportSize.x, m_ViewportSize.y }, ImVec2{ 0, 1 }, ImVec2{ 1, 0 });

		if (ImGui::BeginDragDropTarget())
		{
			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("CONTENT_BROWSER_ITEM"))
			{
				const wchar_t* path = (const wchar_t*)payload->Data;
				OpenScene(path);
			}
			ImGui::EndDragDropTarget();
		}

		// Gizmos
		Entity selectedEntity = m_SceneHierarchyPanel.GetSelectedEntity();
		if (selectedEntity && m_GizmoType != -1)
		{
			ImGuizmo::SetOrthographic(false);
			ImGuizmo::SetDrawlist();

			ImGuizmo::SetRect(m_ViewportBounds[0].x, m_ViewportBounds[0].y, m_ViewportBounds[1].x - m_ViewportBounds[0].x, m_ViewportBounds[1].y - m_ViewportBounds[0].y);

			// Camera
			
			// Runtime camera from entity
			// auto cameraEntity = m_ActiveScene->GetPrimaryCameraEntity();
			// const auto& camera = cameraEntity.GetComponent<CameraComponent>().Camera;
			// const glm::mat4& cameraProjection = camera.GetProjection();
			// glm::mat4 cameraView = glm::inverse(cameraEntity.GetComponent<TransformComponent>().GetTransform());

			// Editor camera
			const glm::mat4& cameraProjection = m_EditorCamera.GetProjection();
			glm::mat4 cameraView = m_EditorCamera.GetViewMatrix();

			// Entity transform
			auto& tc = selectedEntity.GetComponent<TransformComponent>();
			glm::mat4 transform = tc.GetTransform();

			// Snapping
			bool snap = Input::IsKeyPressed(Key::LeftControl);
			float snapValue = 0.5f; // Snap to 0.5m for translation/scale
			// Snap to 45 degrees for rotation
			if (m_GizmoType == ImGuizmo::OPERATION::ROTATE)
				snapValue = 45.0f;

			float snapValues[3] = { snapValue, snapValue, snapValue };

			ImGuizmo::Manipulate(glm::value_ptr(cameraView), glm::value_ptr(cameraProjection),
				(ImGuizmo::OPERATION)m_GizmoType, ImGuizmo::LOCAL, glm::value_ptr(transform),
				nullptr, snap ? snapValues : nullptr);

			if (ImGuizmo::IsUsing())
			{
				glm::vec3 translation, rotation, scale;
				Math::DecomposeTransform(transform, translation, rotation, scale);

				glm::vec3 deltaRotation = rotation - tc.Rotation;
				tc.Translation = translation;
				tc.Rotation += deltaRotation;
				tc.Scale = scale;
			}
		}


		ImGui::End();
		ImGui::PopStyleVar();

		UI_Toolbar();

		ImGui::End();
	}

	void EditorLayer::UI_Toolbar()
	{
		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 2));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemInnerSpacing, ImVec2(0, 0));
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
		auto& colors = ImGui::GetStyle().Colors;
		const auto& buttonHovered = colors[ImGuiCol_ButtonHovered];
		ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(buttonHovered.x, buttonHovered.y, buttonHovered.z, 0.5f));
		const auto& buttonActive = colors[ImGuiCol_ButtonActive];
		ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(buttonActive.x, buttonActive.y, buttonActive.z, 0.5f));

		ImGui::Begin("##toolbar", nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);

		bool toolbarEnabled = (bool)m_ActiveScene;

		ImVec4 tintColor = ImVec4(1, 1, 1, 1);
		if (!toolbarEnabled)
			tintColor.w = 0.5f;

		float size = ImGui::GetWindowHeight() - 4.0f;
		ImGui::SetCursorPosX((ImGui::GetWindowContentRegionMax().x * 0.5f) - (size * 0.5f));

		bool hasPlayButton = m_SceneState == SceneState::Edit || m_SceneState == SceneState::Play;
		bool hasSimulateButton = m_SceneState == SceneState::Edit || m_SceneState == SceneState::Simulate;
		bool hasPauseButton = m_SceneState != SceneState::Edit;

		if (hasPlayButton)
		{
			Ref<Texture2D> icon = (m_SceneState == SceneState::Edit || m_SceneState == SceneState::Simulate) ? m_IconPlay : m_IconStop;
			if (ImGui::ImageButton((ImTextureID)(uint64_t)icon->GetRendererID(), ImVec2(size, size), ImVec2(0, 0), ImVec2(1, 1), 0, ImVec4(0.0f, 0.0f, 0.0f, 0.0f), tintColor) && toolbarEnabled)
			{
				if (m_SceneState == SceneState::Edit || m_SceneState == SceneState::Simulate)
					OnScenePlay();
				else if (m_SceneState == SceneState::Play)
					OnSceneStop();
			}
		}

		if (hasSimulateButton)
		{
			if (hasPlayButton)
				ImGui::SameLine();

			Ref<Texture2D> icon = (m_SceneState == SceneState::Edit || m_SceneState == SceneState::Play) ? m_IconSimulate : m_IconStop;
			if (ImGui::ImageButton((ImTextureID)(uint64_t)icon->GetRendererID(), ImVec2(size, size), ImVec2(0, 0), ImVec2(1, 1), 0, ImVec4(0.0f, 0.0f, 0.0f, 0.0f), tintColor) && toolbarEnabled)
			{
				if (m_SceneState == SceneState::Edit || m_SceneState == SceneState::Play)
					OnSceneSimulate();
				else if (m_SceneState == SceneState::Simulate)
					OnSceneStop();
			}
		}
		if (hasPauseButton)
		{
			bool isPaused = m_ActiveScene->IsPaused();
			ImGui::SameLine();
			{
				Ref<Texture2D> icon = m_IconPause;
				if (ImGui::ImageButton((ImTextureID)(uint64_t)icon->GetRendererID(), ImVec2(size, size), ImVec2(0, 0), ImVec2(1, 1), 0, ImVec4(0.0f, 0.0f, 0.0f, 0.0f), tintColor) && toolbarEnabled)
				{
					m_ActiveScene->SetPaused(!isPaused);
				}
			}

			// Step button
			if (isPaused)
			{
				ImGui::SameLine();
				{
					Ref<Texture2D> icon = m_IconStep;
					bool isPaused = m_ActiveScene->IsPaused();
					if (ImGui::ImageButton((ImTextureID)(uint64_t)icon->GetRendererID(), ImVec2(size, size), ImVec2(0, 0), ImVec2(1, 1), 0, ImVec4(0.0f, 0.0f, 0.0f, 0.0f), tintColor) && toolbarEnabled)
					{
						m_ActiveScene->Step();
					}
				}
			}
		}
		ImGui::PopStyleVar(2);
		ImGui::PopStyleColor(3);
		ImGui::End();
	}

	void EditorLayer::OnEvent(Event& e)
	{
		m_CameraController.OnEvent(e);
		if (m_SceneState == SceneState::Edit)
		{
			m_EditorCamera.OnEvent(e);
		}

		EventDispatcher dispatcher(e);
		dispatcher.Dispatch<KeyPressedEvent>(HZ_BIND_EVENT_FN(EditorLayer::OnKeyPressed));
		dispatcher.Dispatch<MouseButtonPressedEvent>(HZ_BIND_EVENT_FN(EditorLayer::OnMouseButtonPressed));
	}

	bool EditorLayer::OnKeyPressed(KeyPressedEvent& e)
	{
		// Shortcuts
		if (e.IsRepeat())
			return false;

		bool control = Input::IsKeyPressed(Key::LeftControl) || Input::IsKeyPressed(Key::RightControl);
		bool shift = Input::IsKeyPressed(Key::LeftShift) || Input::IsKeyPressed(Key::RightShift);

		switch (e.GetKeyCode())
		{
			case Key::N:
			{
				if (control)
					NewScene();

				break;
			}
			case Key::O:
			{
				if (control)
					OpenProject();

				break;
			}
			case Key::S:
			{
				if (control)
				{
					if (shift)
						SaveSceneAs();
					else
						SaveScene();
				}

				break;
			}

			// Scene Commands
			case Key::D:
			{
				if (control)
					OnDuplicateEntity();

				break;
			}

			// Gizmos
			case Key::Q:
			{
				if (!ImGuizmo::IsUsing())
					m_GizmoType = -1;
				break;
			}
			case Key::W:
			{
				if (!ImGuizmo::IsUsing())
					m_GizmoType = ImGuizmo::OPERATION::TRANSLATE;
				break;
			}
			case Key::E:
			{
				if (!ImGuizmo::IsUsing())
					m_GizmoType = ImGuizmo::OPERATION::ROTATE;
				break;
			}
			case Key::R:
			{
				if (control)
				{
					ScriptEngine::ReloadAssembly();
				}
				else
				{
					if (!ImGuizmo::IsUsing())
						m_GizmoType = ImGuizmo::OPERATION::SCALE;
				}
				break;
			}
			case Key::Delete:
			{
				if (Application::Get().GetImGuiLayer()->GetActiveWidgetID() == 0)
				{
					Entity selectedEntity = m_SceneHierarchyPanel.GetSelectedEntity();
					if (selectedEntity)
					{
						m_SceneHierarchyPanel.SetSelectedEntity({});
						m_ActiveScene->DestroyEntity(selectedEntity);
					}
				}
				break;
			}
		}

		return false;
	}

	bool EditorLayer::OnMouseButtonPressed(MouseButtonPressedEvent& e)
	{
		if (e.GetMouseButton() == Mouse::ButtonLeft)
		{
			if (m_ViewportHovered && !ImGuizmo::IsOver() && !Input::IsKeyPressed(Key::LeftAlt))
				m_SceneHierarchyPanel.SetSelectedEntity(m_HoveredEntity);
		}
		return false;
	}

	void EditorLayer::OnOverlayRender()
	{
		if (m_SceneState == SceneState::Play)
		{
			Entity camera = m_ActiveScene->GetPrimaryCameraEntity();
			if (!camera)
				return;
			
			Renderer2D::BeginScene(camera.GetComponent<CameraComponent>().Camera, camera.GetComponent<TransformComponent>().GetTransform());
		}
		else
		{
			Renderer2D::BeginScene(m_EditorCamera);
		}

		if (m_ShowPhysicsColliders)
		{
			// Box Colliders
			{
				auto view = m_ActiveScene->GetAllEntitiesWith<TransformComponent, BoxCollider2DComponent>();
				for (auto entity : view)
				{
					auto [tc, bc2d] = view.get<TransformComponent, BoxCollider2DComponent>(entity);

					glm::vec3 translation = tc.Translation + glm::vec3(bc2d.Offset, 0.001f);
					glm::vec3 scale = tc.Scale * glm::vec3(bc2d.Size * 2.0f, 1.0f);

					glm::mat4 transform = glm::translate(glm::mat4(1.0f), tc.Translation)
						* glm::rotate(glm::mat4(1.0f), tc.Rotation.z, glm::vec3(0.0f, 0.0f, 1.0f))
						* glm::translate(glm::mat4(1.0f), glm::vec3(bc2d.Offset, 0.001f))
						* glm::scale(glm::mat4(1.0f), scale);
				
					Renderer2D::DrawRect(transform, glm::vec4(0, 1, 0, 1));
				}
			}

			// Circle Colliders
			{
				auto view = m_ActiveScene->GetAllEntitiesWith<TransformComponent, CircleCollider2DComponent>();
				for (auto entity : view)
				{
					auto [tc, cc2d] = view.get<TransformComponent, CircleCollider2DComponent>(entity);

					glm::vec3 translation = tc.Translation + glm::vec3(cc2d.Offset, 0.001f);
					glm::vec3 scale = tc.Scale * glm::vec3(cc2d.Radius * 2.0f);

					glm::mat4 transform = glm::translate(glm::mat4(1.0f), translation)
						* glm::scale(glm::mat4(1.0f), scale);

					Renderer2D::DrawCircle(transform, glm::vec4(0, 1, 0, 1), 0.01f);
				}
			}
		}

		// Draw selected entity outline 
		if (Entity selectedEntity = m_SceneHierarchyPanel.GetSelectedEntity())
		{
			const TransformComponent& transform = selectedEntity.GetComponent<TransformComponent>();
			Renderer2D::DrawRect(transform.GetTransform(), glm::vec4(1.0f, 0.5f, 0.0f, 1.0f));
		}

		Renderer2D::EndScene();
	}

	void EditorLayer::NewProject()
	{
		Project::New();
	}

	void EditorLayer::OpenProject(const std::filesystem::path& path)
	{
		if (Project::Load(path))
		{
			ScriptEngine::Init();

			auto startScenePath = Project::GetAssetFileSystemPath(Project::GetActive()->GetConfig().StartScene);
			OpenScene(startScenePath);
			m_ContentBrowserPanel = CreateScope<ContentBrowserPanel>();
			 
		}
	}

	bool EditorLayer::OpenProject()
	{
		std::string filepath = FileDialogs::OpenFile("Hazel Project (*.hproj)\0*.hproj\0");
		if (filepath.empty())
			return false;

		OpenProject(filepath);
		return true;
	}

	void EditorLayer::SaveProject()
	{
		// Project::SaveActive();
	}

	void EditorLayer::NewScene()
	{
		m_ActiveScene = CreateRef<Scene>();
		m_SceneHierarchyPanel.SetContext(m_ActiveScene);
		
		m_EditorScenePath = std::filesystem::path();
	}

	void EditorLayer::OpenScene()
	{
		std::string filepath = FileDialogs::OpenFile("Hazel Scene (*.hazel)\0*.hazel\0");
		if (!filepath.empty())
			OpenScene(filepath);
	}

	void EditorLayer::OpenScene(const std::filesystem::path& path)
	{
		if (m_SceneState != SceneState::Edit)
			OnSceneStop();

		if (path.extension().string() != ".hazel")
		{
			HZ_WARN("Could not load {0} - not a scene file", path.filename().string());
			return;
		}
		
		Ref<Scene> newScene = CreateRef<Scene>();
		SceneSerializer serializer(newScene);
		if (serializer.Deserialize(path.string()))
		{
			m_EditorScene = newScene;
			m_SceneHierarchyPanel.SetContext(m_EditorScene);

			m_ActiveScene = m_EditorScene;
			m_EditorScenePath = path;
		}
	}

	void EditorLayer::SaveScene()
	{
		if (!m_EditorScenePath.empty())
			SerializeScene(m_ActiveScene, m_EditorScenePath);
		else
			SaveSceneAs();
	}

	void EditorLayer::SaveSceneAs()
	{
		std::string filepath = FileDialogs::SaveFile("Hazel Scene (*.hazel)\0*.hazel\0");
		if (!filepath.empty())
		{
			SerializeScene(m_ActiveScene, filepath);
			m_EditorScenePath = filepath;
		}
	}

	void EditorLayer::SerializeScene(Ref<Scene> scene, const std::filesystem::path& path)
	{
		SceneSerializer serializer(scene);
		serializer.Serialize(path.string());
	}

	void EditorLayer::OnScenePlay()
	{
		if (m_SceneState == SceneState::Simulate)
			OnSceneStop();

		m_SceneState = SceneState::Play;

		m_ActiveScene = Scene::Copy(m_EditorScene);
		m_ActiveScene->OnRuntimeStart();

		m_SceneHierarchyPanel.SetContext(m_ActiveScene);
	}

	void EditorLayer::OnSceneSimulate()
	{
		if (m_SceneState == SceneState::Play)
			OnSceneStop();

		m_SceneState = SceneState::Simulate;

		m_ActiveScene = Scene::Copy(m_EditorScene);
		m_ActiveScene->OnSimulationStart();

		m_SceneHierarchyPanel.SetContext(m_ActiveScene);
	}

	void EditorLayer::OnSceneStop()
	{
		HZ_CORE_ASSERT(m_SceneState == SceneState::Play || m_SceneState == SceneState::Simulate);

		if (m_SceneState == SceneState::Play)
			m_ActiveScene->OnRuntimeStop();
		else if (m_SceneState == SceneState::Simulate)
			m_ActiveScene->OnSimulationStop();

		m_SceneState = SceneState::Edit;

		m_ActiveScene = m_EditorScene;

		m_SceneHierarchyPanel.SetContext(m_ActiveScene);
	}

	void EditorLayer::OnScenePause()
	{
		if (m_SceneState == SceneState::Edit)
			return;

		m_ActiveScene->SetPaused(true);
	}

	void EditorLayer::OnDuplicateEntity()
	{
		if (m_SceneState != SceneState::Edit)
			return;

		Entity selectedEntity = m_SceneHierarchyPanel.GetSelectedEntity();
		if (selectedEntity)
		{
			Entity newEntity = m_EditorScene->DuplicateEntity(selectedEntity);
			m_SceneHierarchyPanel.SetSelectedEntity(newEntity);
		}
	}

}

```

`Hazelnut/src/EditorLayer.h`:

```h
#pragma once

#include "Hazel.h"
#include "Panels/SceneHierarchyPanel.h"
#include "Panels/ContentBrowserPanel.h"

#include "Hazel/Renderer/EditorCamera.h"

namespace Hazel {

	class EditorLayer : public Layer
	{
	public:
		EditorLayer();
		virtual ~EditorLayer() = default;

		virtual void OnAttach() override;
		virtual void OnDetach() override;

		void OnUpdate(Timestep ts) override;
		virtual void OnImGuiRender() override;
		void OnEvent(Event& e) override;
	private:
		bool OnKeyPressed(KeyPressedEvent& e);
		bool OnMouseButtonPressed(MouseButtonPressedEvent& e);
		
		void OnOverlayRender();

		void NewProject();
		bool OpenProject();
		void OpenProject(const std::filesystem::path& path);
		void SaveProject();

		void NewScene();
		void OpenScene();
		void OpenScene(const std::filesystem::path& path);
		void SaveScene();
		void SaveSceneAs();

		void SerializeScene(Ref<Scene> scene, const std::filesystem::path& path);

		void OnScenePlay();
		void OnSceneSimulate();
		void OnSceneStop();
		void OnScenePause();

		void OnDuplicateEntity();

		// UI Panels
		void UI_Toolbar();
	private:
		Hazel::OrthographicCameraController m_CameraController;

		// Temp
		Ref<VertexArray> m_SquareVA;
		Ref<Shader> m_FlatColorShader;
		Ref<Framebuffer> m_Framebuffer;

		Ref<Scene> m_ActiveScene;
		Ref<Scene> m_EditorScene;
		std::filesystem::path m_EditorScenePath;
		Entity m_SquareEntity;
		Entity m_CameraEntity;
		Entity m_SecondCamera;
		
		Entity m_HoveredEntity;

		bool m_PrimaryCamera = true;

		EditorCamera m_EditorCamera;

		Ref<Texture2D> m_CheckerboardTexture;

		bool m_ViewportFocused = false, m_ViewportHovered = false;
		glm::vec2 m_ViewportSize = { 0.0f, 0.0f };
		glm::vec2 m_ViewportBounds[2];

		glm::vec4 m_SquareColor = { 0.2f, 0.3f, 0.8f, 1.0f };

		int m_GizmoType = -1;

		bool m_ShowPhysicsColliders = false;

		enum class SceneState
		{
			Edit = 0, Play = 1, Simulate = 2
		};
		SceneState m_SceneState = SceneState::Edit;

		// Panels
		SceneHierarchyPanel m_SceneHierarchyPanel;
		Scope<ContentBrowserPanel> m_ContentBrowserPanel;

		// Editor resources
		Ref<Texture2D> m_IconPlay, m_IconPause, m_IconStep, m_IconSimulate, m_IconStop;
	};

}

```

`Hazelnut/src/HazelnutApp.cpp`:

```cpp
#include <Hazel.h>
#include <Hazel/Core/EntryPoint.h>

#include "EditorLayer.h"

namespace Hazel {

	class Hazelnut : public Application
	{
	public:
		Hazelnut(const ApplicationSpecification& spec)
			: Application(spec)
		{
			PushLayer(new EditorLayer());
		}
	};

	Application* CreateApplication(ApplicationCommandLineArgs args)
	{
		ApplicationSpecification spec;
		spec.Name = "Hazelnut";
		spec.CommandLineArgs = args;

		return new Hazelnut(spec);
	}

}

```

`Hazelnut/src/Panels/ContentBrowserPanel.cpp`:

```cpp
#include "hzpch.h"
#include "ContentBrowserPanel.h"

#include "Hazel/Project/Project.h"

#include <imgui/imgui.h>

namespace Hazel {

	ContentBrowserPanel::ContentBrowserPanel()
		: m_BaseDirectory(Project::GetAssetDirectory()), m_CurrentDirectory(m_BaseDirectory)
	{
		m_DirectoryIcon = Texture2D::Create("Resources/Icons/ContentBrowser/DirectoryIcon.png");
		m_FileIcon = Texture2D::Create("Resources/Icons/ContentBrowser/FileIcon.png");
	}

	void ContentBrowserPanel::OnImGuiRender()
	{
		ImGui::Begin("Content Browser");

		if (m_CurrentDirectory != std::filesystem::path(m_BaseDirectory))
		{
			if (ImGui::Button("<-"))
			{
				m_CurrentDirectory = m_CurrentDirectory.parent_path();
			}
		}

		static float padding = 16.0f;
		static float thumbnailSize = 128.0f;
		float cellSize = thumbnailSize + padding;

		float panelWidth = ImGui::GetContentRegionAvail().x;
		int columnCount = (int)(panelWidth / cellSize);
		if (columnCount < 1)
			columnCount = 1;

		ImGui::Columns(columnCount, 0, false);

		for (auto& directoryEntry : std::filesystem::directory_iterator(m_CurrentDirectory))
		{
			const auto& path = directoryEntry.path();
			std::string filenameString = path.filename().string();
			
			ImGui::PushID(filenameString.c_str());
			Ref<Texture2D> icon = directoryEntry.is_directory() ? m_DirectoryIcon : m_FileIcon;
			ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
			ImGui::ImageButton((ImTextureID)icon->GetRendererID(), { thumbnailSize, thumbnailSize }, { 0, 1 }, { 1, 0 });

			if (ImGui::BeginDragDropSource())
			{
				std::filesystem::path relativePath(path);
				const wchar_t* itemPath = relativePath.c_str();
				ImGui::SetDragDropPayload("CONTENT_BROWSER_ITEM", itemPath, (wcslen(itemPath) + 1) * sizeof(wchar_t));
				ImGui::EndDragDropSource();
			}

			ImGui::PopStyleColor();
			if (ImGui::IsItemHovered() && ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left))
			{
				if (directoryEntry.is_directory())
					m_CurrentDirectory /= path.filename();

			}
			ImGui::TextWrapped(filenameString.c_str());

			ImGui::NextColumn();

			ImGui::PopID();
		}

		ImGui::Columns(1);

		ImGui::SliderFloat("Thumbnail Size", &thumbnailSize, 16, 512);
		ImGui::SliderFloat("Padding", &padding, 0, 32);

		// TODO: status bar
		ImGui::End();
	}

}

```

`Hazelnut/src/Panels/ContentBrowserPanel.h`:

```h
#pragma once

#include "Hazel/Renderer/Texture.h"

#include <filesystem>

namespace Hazel {

	class ContentBrowserPanel
	{
	public:
		ContentBrowserPanel();

		void OnImGuiRender();
	private:
		std::filesystem::path m_BaseDirectory;
		std::filesystem::path m_CurrentDirectory;
		
		Ref<Texture2D> m_DirectoryIcon;
		Ref<Texture2D> m_FileIcon;
	};

}

```

`Hazelnut/src/Panels/SceneHierarchyPanel.cpp`:

```cpp
#include "SceneHierarchyPanel.h"
#include "Hazel/Scene/Components.h"

#include "Hazel/Scripting/ScriptEngine.h"
#include "Hazel/UI/UI.h"

#include <imgui/imgui.h>
#include <imgui/imgui_internal.h>
#include <imgui/misc/cpp/imgui_stdlib.h>

#include <glm/gtc/type_ptr.hpp>

#include <cstring>

/* The Microsoft C++ compiler is non-compliant with the C++ standard and needs
 * the following definition to disable a security warning on std::strncpy().
 */
#ifdef _MSVC_LANG
  #define _CRT_SECURE_NO_WARNINGS
#endif

namespace Hazel {

	SceneHierarchyPanel::SceneHierarchyPanel(const Ref<Scene>& context)
	{
		SetContext(context);
	}

	void SceneHierarchyPanel::SetContext(const Ref<Scene>& context)
	{
		m_Context = context;
		m_SelectionContext = {};
	}

	void SceneHierarchyPanel::OnImGuiRender()
	{
		ImGui::Begin("Scene Hierarchy");

		if (m_Context)
		{
			m_Context->m_Registry.each([&](auto entityID)
				{
					Entity entity{ entityID , m_Context.get() };
					DrawEntityNode(entity);
				});

			if (ImGui::IsMouseDown(0) && ImGui::IsWindowHovered())
				m_SelectionContext = {};

			// Right-click on blank space
			if (ImGui::BeginPopupContextWindow(0, 1, false))
			{
				if (ImGui::MenuItem("Create Empty Entity"))
					m_Context->CreateEntity("Empty Entity");

				ImGui::EndPopup();
			}

		}
		ImGui::End();

		ImGui::Begin("Properties");
		if (m_SelectionContext)
		{
			DrawComponents(m_SelectionContext);
		}

		ImGui::End();
	}

	void SceneHierarchyPanel::SetSelectedEntity(Entity entity)
	{
		m_SelectionContext = entity;
	}

	void SceneHierarchyPanel::DrawEntityNode(Entity entity)
	{
		auto& tag = entity.GetComponent<TagComponent>().Tag;
		
		ImGuiTreeNodeFlags flags = ((m_SelectionContext == entity) ? ImGuiTreeNodeFlags_Selected : 0) | ImGuiTreeNodeFlags_OpenOnArrow;
		flags |= ImGuiTreeNodeFlags_SpanAvailWidth;
		bool opened = ImGui::TreeNodeEx((void*)(uint64_t)(uint32_t)entity, flags, tag.c_str());
		if (ImGui::IsItemClicked())
		{
			m_SelectionContext = entity;
		}

		bool entityDeleted = false;
		if (ImGui::BeginPopupContextItem())
		{
			if (ImGui::MenuItem("Delete Entity"))
				entityDeleted = true;

			ImGui::EndPopup();
		}

		if (opened)
		{
			ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_SpanAvailWidth;
			bool opened = ImGui::TreeNodeEx((void*)9817239, flags, tag.c_str());
			if (opened)
				ImGui::TreePop();
			ImGui::TreePop();
		}

		if (entityDeleted)
		{
			m_Context->DestroyEntity(entity);
			if (m_SelectionContext == entity)
				m_SelectionContext = {};
		}
	}

	static void DrawVec3Control(const std::string& label, glm::vec3& values, float resetValue = 0.0f, float columnWidth = 100.0f)
	{
		ImGuiIO& io = ImGui::GetIO();
		auto boldFont = io.Fonts->Fonts[0];

		ImGui::PushID(label.c_str());

		ImGui::Columns(2);
		ImGui::SetColumnWidth(0, columnWidth);
		ImGui::Text(label.c_str());
		ImGui::NextColumn();

		ImGui::PushMultiItemsWidths(3, ImGui::CalcItemWidth());
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2{ 0, 0 });

		float lineHeight = GImGui->Font->FontSize + GImGui->Style.FramePadding.y * 2.0f;
		ImVec2 buttonSize = { lineHeight + 3.0f, lineHeight };

		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{ 0.8f, 0.1f, 0.15f, 1.0f });
		ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4{ 0.9f, 0.2f, 0.2f, 1.0f });
		ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4{ 0.8f, 0.1f, 0.15f, 1.0f });
		ImGui::PushFont(boldFont);
		if (ImGui::Button("X", buttonSize))
			values.x = resetValue;
		ImGui::PopFont();
		ImGui::PopStyleColor(3);

		ImGui::SameLine();
		ImGui::DragFloat("##X", &values.x, 0.1f, 0.0f, 0.0f, "%.2f");
		ImGui::PopItemWidth();
		ImGui::SameLine();

		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{ 0.2f, 0.7f, 0.2f, 1.0f });
		ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4{ 0.3f, 0.8f, 0.3f, 1.0f });
		ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4{ 0.2f, 0.7f, 0.2f, 1.0f });
		ImGui::PushFont(boldFont);
		if (ImGui::Button("Y", buttonSize))
			values.y = resetValue;
		ImGui::PopFont();
		ImGui::PopStyleColor(3);

		ImGui::SameLine();
		ImGui::DragFloat("##Y", &values.y, 0.1f, 0.0f, 0.0f, "%.2f");
		ImGui::PopItemWidth();
		ImGui::SameLine();

		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{ 0.1f, 0.25f, 0.8f, 1.0f });
		ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4{ 0.2f, 0.35f, 0.9f, 1.0f });
		ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4{ 0.1f, 0.25f, 0.8f, 1.0f });
		ImGui::PushFont(boldFont);
		if (ImGui::Button("Z", buttonSize))
			values.z = resetValue;
		ImGui::PopFont();
		ImGui::PopStyleColor(3);

		ImGui::SameLine();
		ImGui::DragFloat("##Z", &values.z, 0.1f, 0.0f, 0.0f, "%.2f");
		ImGui::PopItemWidth();

		ImGui::PopStyleVar();

		ImGui::Columns(1);

		ImGui::PopID();
	}
	
	template<typename T, typename UIFunction>
	static void DrawComponent(const std::string& name, Entity entity, UIFunction uiFunction)
	{
		const ImGuiTreeNodeFlags treeNodeFlags = ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_FramePadding;
		if (entity.HasComponent<T>())
		{
			auto& component = entity.GetComponent<T>();
			ImVec2 contentRegionAvailable = ImGui::GetContentRegionAvail();

			ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2{ 4, 4 });
			float lineHeight = GImGui->Font->FontSize + GImGui->Style.FramePadding.y * 2.0f;
			ImGui::Separator();
			bool open = ImGui::TreeNodeEx((void*)typeid(T).hash_code(), treeNodeFlags, name.c_str());
			ImGui::PopStyleVar(
			);
			ImGui::SameLine(contentRegionAvailable.x - lineHeight * 0.5f);
			if (ImGui::Button("+", ImVec2{ lineHeight, lineHeight }))
			{
				ImGui::OpenPopup("ComponentSettings");
			}

			bool removeComponent = false;
			if (ImGui::BeginPopup("ComponentSettings"))
			{
				if (ImGui::MenuItem("Remove component"))
					removeComponent = true;

				ImGui::EndPopup();
			}

			if (open)
			{
				uiFunction(component);
				ImGui::TreePop();
			}

			if (removeComponent)
				entity.RemoveComponent<T>();
		}
	}

	void SceneHierarchyPanel::DrawComponents(Entity entity)
	{
		if (entity.HasComponent<TagComponent>())
		{
			auto& tag = entity.GetComponent<TagComponent>().Tag;

			char buffer[256];
			memset(buffer, 0, sizeof(buffer));
			strncpy_s(buffer, sizeof(buffer), tag.c_str(), sizeof(buffer));
			if (ImGui::InputText("##Tag", buffer, sizeof(buffer)))
			{
				tag = std::string(buffer);
			}
		}

		ImGui::SameLine();
		ImGui::PushItemWidth(-1);

		if (ImGui::Button("Add Component"))
			ImGui::OpenPopup("AddComponent");

		if (ImGui::BeginPopup("AddComponent"))
		{
			DisplayAddComponentEntry<CameraComponent>("Camera");
			DisplayAddComponentEntry<ScriptComponent>("Script");
			DisplayAddComponentEntry<SpriteRendererComponent>("Sprite Renderer");
			DisplayAddComponentEntry<CircleRendererComponent>("Circle Renderer");
			DisplayAddComponentEntry<Rigidbody2DComponent>("Rigidbody 2D");
			DisplayAddComponentEntry<BoxCollider2DComponent>("Box Collider 2D");
			DisplayAddComponentEntry<CircleCollider2DComponent>("Circle Collider 2D");
			DisplayAddComponentEntry<TextComponent>("Text Component");

			ImGui::EndPopup();
		}

		ImGui::PopItemWidth();

		DrawComponent<TransformComponent>("Transform", entity, [](auto& component)
		{
			DrawVec3Control("Translation", component.Translation);
			glm::vec3 rotation = glm::degrees(component.Rotation);
			DrawVec3Control("Rotation", rotation);
			component.Rotation = glm::radians(rotation);
			DrawVec3Control("Scale", component.Scale, 1.0f);
		});

		DrawComponent<CameraComponent>("Camera", entity, [](auto& component)
		{
			auto& camera = component.Camera;

			ImGui::Checkbox("Primary", &component.Primary);

			const char* projectionTypeStrings[] = { "Perspective", "Orthographic" };
			const char* currentProjectionTypeString = projectionTypeStrings[(int)camera.GetProjectionType()];
			if (ImGui::BeginCombo("Projection", currentProjectionTypeString))
			{
				for (int i = 0; i < 2; i++)
				{
					bool isSelected = currentProjectionTypeString == projectionTypeStrings[i];
					if (ImGui::Selectable(projectionTypeStrings[i], isSelected))
					{
						currentProjectionTypeString = projectionTypeStrings[i];
						camera.SetProjectionType((SceneCamera::ProjectionType)i);
					}

					if (isSelected)
						ImGui::SetItemDefaultFocus();
				}

				ImGui::EndCombo();
			}

			if (camera.GetProjectionType() == SceneCamera::ProjectionType::Perspective)
			{
				float perspectiveVerticalFov = glm::degrees(camera.GetPerspectiveVerticalFOV());
				if (ImGui::DragFloat("Vertical FOV", &perspectiveVerticalFov))
					camera.SetPerspectiveVerticalFOV(glm::radians(perspectiveVerticalFov));

				float perspectiveNear = camera.GetPerspectiveNearClip();
				if (ImGui::DragFloat("Near", &perspectiveNear))
					camera.SetPerspectiveNearClip(perspectiveNear);

				float perspectiveFar = camera.GetPerspectiveFarClip();
				if (ImGui::DragFloat("Far", &perspectiveFar))
					camera.SetPerspectiveFarClip(perspectiveFar);
			}

			if (camera.GetProjectionType() == SceneCamera::ProjectionType::Orthographic)
			{
				float orthoSize = camera.GetOrthographicSize();
				if (ImGui::DragFloat("Size", &orthoSize))
					camera.SetOrthographicSize(orthoSize);

				float orthoNear = camera.GetOrthographicNearClip();
				if (ImGui::DragFloat("Near", &orthoNear))
					camera.SetOrthographicNearClip(orthoNear);

				float orthoFar = camera.GetOrthographicFarClip();
				if (ImGui::DragFloat("Far", &orthoFar))
					camera.SetOrthographicFarClip(orthoFar);

				ImGui::Checkbox("Fixed Aspect Ratio", &component.FixedAspectRatio);
			}
		});

		DrawComponent<ScriptComponent>("Script", entity, [entity, scene = m_Context](auto& component) mutable
		{
			bool scriptClassExists = ScriptEngine::EntityClassExists(component.ClassName);

			static char buffer[64];
			strcpy_s(buffer, sizeof(buffer), component.ClassName.c_str());

			UI::ScopedStyleColor textColor(ImGuiCol_Text, ImVec4(0.9f, 0.2f, 0.3f, 1.0f), !scriptClassExists);

			if (ImGui::InputText("Class", buffer, sizeof(buffer)))
			{
				component.ClassName = buffer;
				return;
			}

			// Fields
			bool sceneRunning = scene->IsRunning();
			if (sceneRunning)
			{
				Ref<ScriptInstance> scriptInstance = ScriptEngine::GetEntityScriptInstance(entity.GetUUID());
				if (scriptInstance)
				{
					const auto& fields = scriptInstance->GetScriptClass()->GetFields();
					for (const auto& [name, field] : fields)
					{
						if (field.Type == ScriptFieldType::Float)
						{
							float data = scriptInstance->GetFieldValue<float>(name);
							if (ImGui::DragFloat(name.c_str(), &data))
							{
								scriptInstance->SetFieldValue(name, data);
							}
						}
					}
				}
			}
			else
			{
				if (scriptClassExists)
				{
					Ref<ScriptClass> entityClass = ScriptEngine::GetEntityClass(component.ClassName);
					const auto& fields = entityClass->GetFields();

					auto& entityFields = ScriptEngine::GetScriptFieldMap(entity);
					for (const auto& [name, field] : fields)
					{
						// Field has been set in editor
						if (entityFields.find(name) != entityFields.end())
						{
							ScriptFieldInstance& scriptField = entityFields.at(name);

							// Display control to set it maybe
							if (field.Type == ScriptFieldType::Float)
							{
								float data = scriptField.GetValue<float>();
								if (ImGui::DragFloat(name.c_str(), &data))
									scriptField.SetValue(data);
							}
						}
						else
						{
							// Display control to set it maybe
							if (field.Type == ScriptFieldType::Float)
							{
								float data = 0.0f;
								if (ImGui::DragFloat(name.c_str(), &data))
								{
									ScriptFieldInstance& fieldInstance = entityFields[name];
									fieldInstance.Field = field;
									fieldInstance.SetValue(data);
								}
							}
						}
					}
				}
			}
		});

		DrawComponent<SpriteRendererComponent>("Sprite Renderer", entity, [](auto& component)
		{
			ImGui::ColorEdit4("Color", glm::value_ptr(component.Color));
			
			ImGui::Button("Texture", ImVec2(100.0f, 0.0f));
			if (ImGui::BeginDragDropTarget())
			{
				if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("CONTENT_BROWSER_ITEM"))
				{
					const wchar_t* path = (const wchar_t*)payload->Data;
					std::filesystem::path texturePath(path);
					Ref<Texture2D> texture = Texture2D::Create(texturePath.string());
					if (texture->IsLoaded())
						component.Texture = texture;
					else
						HZ_WARN("Could not load texture {0}", texturePath.filename().string());
				}
				ImGui::EndDragDropTarget();
			}

			ImGui::DragFloat("Tiling Factor", &component.TilingFactor, 0.1f, 0.0f, 100.0f);
		});

		DrawComponent<CircleRendererComponent>("Circle Renderer", entity, [](auto& component)
		{
			ImGui::ColorEdit4("Color", glm::value_ptr(component.Color));
			ImGui::DragFloat("Thickness", &component.Thickness, 0.025f, 0.0f, 1.0f);
			ImGui::DragFloat("Fade", &component.Fade, 0.00025f, 0.0f, 1.0f);
		});

		DrawComponent<Rigidbody2DComponent>("Rigidbody 2D", entity, [](auto& component)
		{
			const char* bodyTypeStrings[] = { "Static", "Dynamic", "Kinematic"};
			const char* currentBodyTypeString = bodyTypeStrings[(int)component.Type];
			if (ImGui::BeginCombo("Body Type", currentBodyTypeString))
			{
				for (int i = 0; i < 2; i++)
				{
					bool isSelected = currentBodyTypeString == bodyTypeStrings[i];
					if (ImGui::Selectable(bodyTypeStrings[i], isSelected))
					{
						currentBodyTypeString = bodyTypeStrings[i];
						component.Type = (Rigidbody2DComponent::BodyType)i;
					}

					if (isSelected)
						ImGui::SetItemDefaultFocus();
				}

				ImGui::EndCombo();
			}

			ImGui::Checkbox("Fixed Rotation", &component.FixedRotation);
		});

		DrawComponent<BoxCollider2DComponent>("Box Collider 2D", entity, [](auto& component)
		{
			ImGui::DragFloat2("Offset", glm::value_ptr(component.Offset));
			ImGui::DragFloat2("Size", glm::value_ptr(component.Size));
			ImGui::DragFloat("Density", &component.Density, 0.01f, 0.0f, 1.0f);
			ImGui::DragFloat("Friction", &component.Friction, 0.01f, 0.0f, 1.0f);
			ImGui::DragFloat("Restitution", &component.Restitution, 0.01f, 0.0f, 1.0f);
			ImGui::DragFloat("Restitution Threshold", &component.RestitutionThreshold, 0.01f, 0.0f);
		});

		DrawComponent<CircleCollider2DComponent>("Circle Collider 2D", entity, [](auto& component)
		{
			ImGui::DragFloat2("Offset", glm::value_ptr(component.Offset));
			ImGui::DragFloat("Radius", &component.Radius);
			ImGui::DragFloat("Density", &component.Density, 0.01f, 0.0f, 1.0f);
			ImGui::DragFloat("Friction", &component.Friction, 0.01f, 0.0f, 1.0f);
			ImGui::DragFloat("Restitution", &component.Restitution, 0.01f, 0.0f, 1.0f);
			ImGui::DragFloat("Restitution Threshold", &component.RestitutionThreshold, 0.01f, 0.0f);
		});

		DrawComponent<TextComponent>("Text Renderer", entity, [](auto& component)
		{
			ImGui::InputTextMultiline("Text String", &component.TextString);
			ImGui::ColorEdit4("Color", glm::value_ptr(component.Color));
			ImGui::DragFloat("Kerning", &component.Kerning, 0.025f);
			ImGui::DragFloat("Line Spacing", &component.LineSpacing, 0.025f);
		});

	}
	
	template<typename T>
	void SceneHierarchyPanel::DisplayAddComponentEntry(const std::string& entryName) {
		if (!m_SelectionContext.HasComponent<T>())
		{
			if (ImGui::MenuItem(entryName.c_str()))
			{
				m_SelectionContext.AddComponent<T>();
				ImGui::CloseCurrentPopup();
			}
		}
	}

}

```

`Hazelnut/src/Panels/SceneHierarchyPanel.h`:

```h
#pragma once

#include "Hazel/Core/Base.h"
#include "Hazel/Scene/Scene.h"
#include "Hazel/Scene/Entity.h"

namespace Hazel {

	class SceneHierarchyPanel
	{
	public:
		SceneHierarchyPanel() = default;
		SceneHierarchyPanel(const Ref<Scene>& scene);

		void SetContext(const Ref<Scene>& scene);

		void OnImGuiRender();

		Entity GetSelectedEntity() const { return m_SelectionContext; }
		void SetSelectedEntity(Entity entity);
	private:
		template<typename T>
		void DisplayAddComponentEntry(const std::string& entryName);
	
		void DrawEntityNode(Entity entity);
		void DrawComponents(Entity entity);
	private:
		Ref<Scene> m_Context;
		Entity m_SelectionContext;
	};

}

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# Hazel [![License](https://img.shields.io/github/license/TheCherno/Hazel.svg)](https://github.com/TheCherno/Hazel/blob/master/LICENSE)

![Hazel](/Resources/Branding/Hazel_Logo_Text_Light_Square.png?raw=true "Hazel")

Hazel is primarily an early-stage interactive application and rendering engine for Windows. Currently not much is implemented, however (almost) everything inside this repository is being created within YouTube videos, found at [thecherno.com/engine](https://thecherno.com/engine). 

***

## Getting Started
Visual Studio 2017 or 2019 is recommended, Hazel is officially untested on other development environments whilst we focus on a Windows build.

<ins>**1. Downloading the repository:**</ins>

Start by cloning the repository with `git clone --recursive https://github.com/TheCherno/Hazel`.

If the repository was cloned non-recursively previously, use `git submodule update --init` to clone the necessary submodules.

<ins>**2. Configuring the dependencies:**</ins>

1. Run the [Setup.bat](https://github.com/TheCherno/Hazel/blob/master/scripts/Setup.bat) file found in `scripts` folder. This will download the required prerequisites for the project if they are not present yet.
2. One prerequisite is the Vulkan SDK. If it is not installed, the script will execute the `VulkanSDK.exe` file, and will prompt the user to install the SDK.
3. After installation, run the [Setup.bat](https://github.com/TheCherno/Hazel/blob/master/scripts/Setup.bat) file again. If the Vulkan SDK is installed properly, it will then download the Vulkan SDK Debug libraries. (This may take a longer amount of time)
4. After downloading and unzipping the files, the [Win-GenProjects.bat](https://github.com/TheCherno/Hazel/blob/master/scripts/Win-GenProjects.bat) script file will get executed automatically, which will then generate a Visual Studio solution file for user's usage.

If changes are made, or if you want to regenerate project files, rerun the [Win-GenProjects.bat](https://github.com/TheCherno/Hazel/blob/master/scripts/Win-GenProjects.bat) script file found in `scripts` folder.

***

## The Plan
The plan for Hazel is two-fold: to create a powerful 3D engine, but also to serve as an education tool for teaching game engine design and architecture. Because of this the development inside this repository is rather slow, since everything has to be taught and implemented on-camera. There is a much more advanced version of the engine in a private repository called `Hazel-dev`, accessible to supporters on [Patreon](https://patreon.com/thecherno). The plan for this project is to mostly take already implemented code from the `Hazel-dev` repository and integrate it into this one, done within videos and supported by explanations.

### Main features to come:
- Fast 2D rendering (UI, particles, sprites, etc.)
- High-fidelity Physically-Based 3D rendering (this will be expanded later, 2D to come first)
- Support for Mac, Linux, Android and iOS
    - Native rendering API support (DirectX, Vulkan, Metal)
- Fully featured viewer and editor applications
- Fully scripted interaction and behavior
- Integrated 3rd party 2D and 3D physics engine
- Procedural terrain and world generation
- Artificial Intelligence
- Audio system


## Short term goals :
*Note: this is subject to change at any time! Follow the roadmap over at [hazelengine.com/roadmap](http://hazelengine.com/roadmap).*

By the end 2020, we want to make a game using the Hazel game engine. Not like the time I made a game in one hour using the engine, but this time by using the proper tools that would be required to make a game with Hazel. This means we need to add a full 2D workflow:

- Design the game scene by using Hazelnut, the Hazel editor,
- Test the game inside Hazelnut, including the ability to save/load the created game,
- Load and play the game inside Sandbox.

We want everyone to be able to play the game on all desktop platforms (Windows, Mac and Linux). When this is implemented, another attempt at the "Creating a game in one hour using Hazel" will be made to see how far the engine has become.

[![Twitter](https://img.shields.io/badge/%40thecherno--blue.svg?style=social&logo=Twitter)](https://twitter.com/thecherno)
[![Instagram](https://img.shields.io/badge/thecherno--red.svg?style=social&logo=Instagram)](https://www.instagram.com/thecherno)
[![Youtube](https://img.shields.io/badge/TheChernoProject--red.svg?style=social&logo=youtube)](https://www.youtube.com/user/TheChernoProject)
[![Discord](https://img.shields.io/badge/TheCherno%20Server--blue.svg?style=social&logo=Discord)](https://discord.gg/K2eSyQA)
[![Patreon](https://img.shields.io/badge/%40thecherno--green.svg?style=social&logo=Patreon)](https://patreon.com/thecherno)

```

`Sandbox/assets/fonts/opensans/LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`Sandbox/assets/shaders/FlatColor.glsl`:

```glsl
// Flat Color Shader

#type vertex
#version 330 core

layout(location = 0) in vec3 a_Position;

uniform mat4 u_ViewProjection;
uniform mat4 u_Transform;

void main()
{
	gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);
}

#type fragment
#version 330 core

layout(location = 0) out vec4 color;

uniform vec4 u_Color;

void main()
{
	color = u_Color;
}
```

`Sandbox/assets/shaders/Texture.glsl`:

```glsl
// Basic Texture Shader

#type vertex
#version 450 core

layout(location = 0) in vec3 a_Position;
layout(location = 1) in vec4 a_Color;
layout(location = 2) in vec2 a_TexCoord;
layout(location = 3) in float a_TexIndex;
layout(location = 4) in float a_TilingFactor;
layout(location = 5) in int a_EntityID;

layout(std140, binding = 0) uniform Camera
{
	mat4 u_ViewProjection;
};

struct VertexOutput
{
	vec4 Color;
	vec2 TexCoord;
	float TexIndex;
	float TilingFactor;
};

layout (location = 0) out VertexOutput Output;
layout (location = 4) out flat int v_EntityID;

void main()
{
	Output.Color = a_Color;
	Output.TexCoord = a_TexCoord;
	Output.TexIndex = a_TexIndex;
	Output.TilingFactor = a_TilingFactor;
	v_EntityID = a_EntityID;

	gl_Position = u_ViewProjection * vec4(a_Position, 1.0);
}

#type fragment
#version 450 core

layout(location = 0) out vec4 color;
layout(location = 1) out int color2;

struct VertexOutput
{
	vec4 Color;
	vec2 TexCoord;
	float TexIndex;
	float TilingFactor;
};

layout (location = 0) in VertexOutput Input;
layout (location = 4) in flat int v_EntityID;

layout (binding = 0) uniform sampler2D u_Textures[32];

void main()
{
	vec4 texColor = Input.Color;

	switch(int(Input.TexIndex))
	{
		case  0: texColor *= texture(u_Textures[ 0], Input.TexCoord * Input.TilingFactor); break;
		case  1: texColor *= texture(u_Textures[ 1], Input.TexCoord * Input.TilingFactor); break;
		case  2: texColor *= texture(u_Textures[ 2], Input.TexCoord * Input.TilingFactor); break;
		case  3: texColor *= texture(u_Textures[ 3], Input.TexCoord * Input.TilingFactor); break;
		case  4: texColor *= texture(u_Textures[ 4], Input.TexCoord * Input.TilingFactor); break;
		case  5: texColor *= texture(u_Textures[ 5], Input.TexCoord * Input.TilingFactor); break;
		case  6: texColor *= texture(u_Textures[ 6], Input.TexCoord * Input.TilingFactor); break;
		case  7: texColor *= texture(u_Textures[ 7], Input.TexCoord * Input.TilingFactor); break;
		case  8: texColor *= texture(u_Textures[ 8], Input.TexCoord * Input.TilingFactor); break;
		case  9: texColor *= texture(u_Textures[ 9], Input.TexCoord * Input.TilingFactor); break;
		case 10: texColor *= texture(u_Textures[10], Input.TexCoord * Input.TilingFactor); break;
		case 11: texColor *= texture(u_Textures[11], Input.TexCoord * Input.TilingFactor); break;
		case 12: texColor *= texture(u_Textures[12], Input.TexCoord * Input.TilingFactor); break;
		case 13: texColor *= texture(u_Textures[13], Input.TexCoord * Input.TilingFactor); break;
		case 14: texColor *= texture(u_Textures[14], Input.TexCoord * Input.TilingFactor); break;
		case 15: texColor *= texture(u_Textures[15], Input.TexCoord * Input.TilingFactor); break;
		case 16: texColor *= texture(u_Textures[16], Input.TexCoord * Input.TilingFactor); break;
		case 17: texColor *= texture(u_Textures[17], Input.TexCoord * Input.TilingFactor); break;
		case 18: texColor *= texture(u_Textures[18], Input.TexCoord * Input.TilingFactor); break;
		case 19: texColor *= texture(u_Textures[19], Input.TexCoord * Input.TilingFactor); break;
		case 20: texColor *= texture(u_Textures[20], Input.TexCoord * Input.TilingFactor); break;
		case 21: texColor *= texture(u_Textures[21], Input.TexCoord * Input.TilingFactor); break;
		case 22: texColor *= texture(u_Textures[22], Input.TexCoord * Input.TilingFactor); break;
		case 23: texColor *= texture(u_Textures[23], Input.TexCoord * Input.TilingFactor); break;
		case 24: texColor *= texture(u_Textures[24], Input.TexCoord * Input.TilingFactor); break;
		case 25: texColor *= texture(u_Textures[25], Input.TexCoord * Input.TilingFactor); break;
		case 26: texColor *= texture(u_Textures[26], Input.TexCoord * Input.TilingFactor); break;
		case 27: texColor *= texture(u_Textures[27], Input.TexCoord * Input.TilingFactor); break;
		case 28: texColor *= texture(u_Textures[28], Input.TexCoord * Input.TilingFactor); break;
		case 29: texColor *= texture(u_Textures[29], Input.TexCoord * Input.TilingFactor); break;
		case 30: texColor *= texture(u_Textures[30], Input.TexCoord * Input.TilingFactor); break;
		case 31: texColor *= texture(u_Textures[31], Input.TexCoord * Input.TilingFactor); break;
	}
	color = texColor;

	color2 = v_EntityID;
}

```

`Sandbox/imgui.ini`:

```ini
[Window][Debug##Default]
Pos=60,60
Size=400,400
Collapsed=0

[Window][Test]
Pos=60,60
Size=92,48
Collapsed=0

[Window][ImGui Demo]
ViewportPos=1404,134
ViewportId=0x080FC883
Size=550,680
Collapsed=0

[Window][Settings]
ViewportPos=1214,617
ViewportId=0x1C33C293
Size=432,366
Collapsed=0

[Window][DockSpace Demo]
Size=1280,720
Collapsed=0

[Docking][Data]


```

`Sandbox/premake5.lua`:

```lua
project "Sandbox"
	kind "ConsoleApp"
	language "C++"
	cppdialect "C++17"
	staticruntime "off"

	targetdir ("%{wks.location}/bin/" .. outputdir .. "/%{prj.name}")
	objdir ("%{wks.location}/bin-int/" .. outputdir .. "/%{prj.name}")

	files
	{
		"src/**.h",
		"src/**.cpp"
	}

	includedirs
	{
		"%{wks.location}/Hazel/vendor/spdlog/include",
		"%{wks.location}/Hazel/src",
		"%{wks.location}/Hazel/vendor",
		"%{IncludeDir.glm}",
		"%{IncludeDir.entt}"
	}

	links
	{
		"Hazel"
	}

	filter "system:windows"
		systemversion "latest"

	filter "configurations:Debug"
		defines "HZ_DEBUG"
		runtime "Debug"
		symbols "on"

	filter "configurations:Release"
		defines "HZ_RELEASE"
		runtime "Release"
		optimize "on"

	filter "configurations:Dist"
		defines "HZ_DIST"
		runtime "Release"
		optimize "on"

```

`Sandbox/src/ExampleLayer.cpp`:

```cpp
#include "ExampleLayer.h"

#include "imgui/imgui.h"

#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

ExampleLayer::ExampleLayer() 
	: Layer("ExampleLayer"), m_CameraController(1280.0f / 720.0f)
{
	m_VertexArray = Hazel::VertexArray::Create();

	float vertices[3 * 7] = {
		-0.5f, -0.5f, 0.0f, 0.8f, 0.2f, 0.8f, 1.0f,
		 0.5f, -0.5f, 0.0f, 0.2f, 0.3f, 0.8f, 1.0f,
		 0.0f,  0.5f, 0.0f, 0.8f, 0.8f, 0.2f, 1.0f
	};

	Hazel::Ref<Hazel::VertexBuffer> vertexBuffer = Hazel::VertexBuffer::Create(vertices, sizeof(vertices));
	Hazel::BufferLayout layout = {
		{ Hazel::ShaderDataType::Float3, "a_Position" },
		{ Hazel::ShaderDataType::Float4, "a_Color" }
	};
	vertexBuffer->SetLayout(layout);
	m_VertexArray->AddVertexBuffer(vertexBuffer);

	uint32_t indices[3] = { 0, 1, 2 };
	Hazel::Ref<Hazel::IndexBuffer> indexBuffer = Hazel::IndexBuffer::Create(indices, sizeof(indices) / sizeof(uint32_t));
	m_VertexArray->SetIndexBuffer(indexBuffer);

	m_SquareVA = Hazel::VertexArray::Create();

	float squareVertices[5 * 4] = {
		-0.5f, -0.5f, 0.0f, 0.0f, 0.0f,
		 0.5f, -0.5f, 0.0f, 1.0f, 0.0f,
		 0.5f,  0.5f, 0.0f, 1.0f, 1.0f,
		-0.5f,  0.5f, 0.0f, 0.0f, 1.0f
	};

	Hazel::Ref<Hazel::VertexBuffer> squareVB = Hazel::VertexBuffer::Create(squareVertices, sizeof(squareVertices));
	squareVB->SetLayout({
		{ Hazel::ShaderDataType::Float3, "a_Position" },
		{ Hazel::ShaderDataType::Float2, "a_TexCoord" }
		});
	m_SquareVA->AddVertexBuffer(squareVB);

	uint32_t squareIndices[6] = { 0, 1, 2, 2, 3, 0 };
	Hazel::Ref<Hazel::IndexBuffer> squareIB = Hazel::IndexBuffer::Create(squareIndices, sizeof(squareIndices) / sizeof(uint32_t));
	m_SquareVA->SetIndexBuffer(squareIB);

	std::string vertexSrc = R"(
			#version 330 core
			
			layout(location = 0) in vec3 a_Position;
			layout(location = 1) in vec4 a_Color;

			uniform mat4 u_ViewProjection;
			uniform mat4 u_Transform;

			out vec3 v_Position;
			out vec4 v_Color;

			void main()
			{
				v_Position = a_Position;
				v_Color = a_Color;
				gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);	
			}
		)";

	std::string fragmentSrc = R"(
			#version 330 core
			
			layout(location = 0) out vec4 color;

			in vec3 v_Position;
			in vec4 v_Color;

			void main()
			{
				color = vec4(v_Position * 0.5 + 0.5, 1.0);
				color = v_Color;
			}
		)";

	m_Shader = Hazel::Shader::Create("VertexPosColor", vertexSrc, fragmentSrc);

	std::string flatColorShaderVertexSrc = R"(
			#version 330 core
			
			layout(location = 0) in vec3 a_Position;

			uniform mat4 u_ViewProjection;
			uniform mat4 u_Transform;

			out vec3 v_Position;

			void main()
			{
				v_Position = a_Position;
				gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);	
			}
		)";

	std::string flatColorShaderFragmentSrc = R"(
			#version 330 core
			
			layout(location = 0) out vec4 color;

			in vec3 v_Position;
			
			uniform vec3 u_Color;

			void main()
			{
				color = vec4(u_Color, 1.0);
			}
		)";

	m_FlatColorShader = Hazel::Shader::Create("FlatColor", flatColorShaderVertexSrc, flatColorShaderFragmentSrc);

	auto textureShader = m_ShaderLibrary.Load("assets/shaders/Texture.glsl");

	m_Texture = Hazel::Texture2D::Create("assets/textures/Checkerboard.png");
	m_ChernoLogoTexture = Hazel::Texture2D::Create("assets/textures/ChernoLogo.png");

	textureShader->Bind();
	textureShader->SetInt("u_Texture", 0);
}

void ExampleLayer::OnAttach()
{
}

void ExampleLayer::OnDetach()
{
}

void ExampleLayer::OnUpdate(Hazel::Timestep ts) 
{
	// Update
	m_CameraController.OnUpdate(ts);

	// Render
	Hazel::RenderCommand::SetClearColor({ 0.1f, 0.1f, 0.1f, 1 });
	Hazel::RenderCommand::Clear();

	Hazel::Renderer::BeginScene(m_CameraController.GetCamera());

	glm::mat4 scale = glm::scale(glm::mat4(1.0f), glm::vec3(0.1f));

	m_FlatColorShader->Bind();
	m_FlatColorShader->SetFloat3("u_Color", m_SquareColor);

	for (int y = 0; y < 20; y++)
	{
		for (int x = 0; x < 20; x++)
		{
			glm::vec3 pos(x * 0.11f, y * 0.11f, 0.0f);
			glm::mat4 transform = glm::translate(glm::mat4(1.0f), pos) * scale;
			Hazel::Renderer::Submit(m_FlatColorShader, m_SquareVA, transform);
		}
	}

	auto textureShader = m_ShaderLibrary.Get("Texture");

	m_Texture->Bind();
	Hazel::Renderer::Submit(textureShader, m_SquareVA, glm::scale(glm::mat4(1.0f), glm::vec3(1.5f)));
	m_ChernoLogoTexture->Bind();
	Hazel::Renderer::Submit(textureShader, m_SquareVA, glm::scale(glm::mat4(1.0f), glm::vec3(1.5f)));

	// Triangle
	// Hazel::Renderer::Submit(m_Shader, m_VertexArray);

	Hazel::Renderer::EndScene();
}

void ExampleLayer::OnImGuiRender() 
{
	ImGui::Begin("Settings");
	ImGui::ColorEdit3("Square Color", glm::value_ptr(m_SquareColor));
	ImGui::End();
}

void ExampleLayer::OnEvent(Hazel::Event& e) 
{
	m_CameraController.OnEvent(e);
}

```

`Sandbox/src/ExampleLayer.h`:

```h
#pragma once

#include "Hazel.h"

class ExampleLayer : public Hazel::Layer
{
public:
	ExampleLayer();
	virtual ~ExampleLayer() = default;

	virtual void OnAttach() override;
	virtual void OnDetach() override;

	void OnUpdate(Hazel::Timestep ts) override;
	virtual void OnImGuiRender() override;
	void OnEvent(Hazel::Event& e) override;
private:
	Hazel::ShaderLibrary m_ShaderLibrary;
	Hazel::Ref<Hazel::Shader> m_Shader;
	Hazel::Ref<Hazel::VertexArray> m_VertexArray;

	Hazel::Ref<Hazel::Shader> m_FlatColorShader;
	Hazel::Ref<Hazel::VertexArray> m_SquareVA;

	Hazel::Ref<Hazel::Texture2D> m_Texture, m_ChernoLogoTexture;

	Hazel::OrthographicCameraController m_CameraController;
	glm::vec3 m_SquareColor = { 0.2f, 0.3f, 0.8f };
};


```

`Sandbox/src/Sandbox2D.cpp`:

```cpp
#include "Sandbox2D.h"
#include <imgui/imgui.h>

#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

Sandbox2D::Sandbox2D()
	: Layer("Sandbox2D"), m_CameraController(1280.0f / 720.0f), m_SquareColor({ 0.2f, 0.3f, 0.8f, 1.0f })
{
}

void Sandbox2D::OnAttach()
{
	HZ_PROFILE_FUNCTION();

	m_CheckerboardTexture = Hazel::Texture2D::Create("assets/textures/Checkerboard.png");
}

void Sandbox2D::OnDetach()
{
	HZ_PROFILE_FUNCTION();
}

void Sandbox2D::OnUpdate(Hazel::Timestep ts)
{
	HZ_PROFILE_FUNCTION();

	// Update
	m_CameraController.OnUpdate(ts);

	// Render
	Hazel::Renderer2D::ResetStats();
	{
		HZ_PROFILE_SCOPE("Renderer Prep");
		Hazel::RenderCommand::SetClearColor({ 0.1f, 0.1f, 0.1f, 1 });
		Hazel::RenderCommand::Clear();
	}

	{
		static float rotation = 0.0f;
		rotation += ts * 50.0f;

		HZ_PROFILE_SCOPE("Renderer Draw");
		Hazel::Renderer2D::BeginScene(m_CameraController.GetCamera());
		Hazel::Renderer2D::DrawRotatedQuad({ 1.0f, 0.0f }, { 0.8f, 0.8f }, -45.0f, { 0.8f, 0.2f, 0.3f, 1.0f });
		Hazel::Renderer2D::DrawQuad({ -1.0f, 0.0f }, { 0.8f, 0.8f }, { 0.8f, 0.2f, 0.3f, 1.0f });
		Hazel::Renderer2D::DrawQuad({ 0.5f, -0.5f }, { 0.5f, 0.75f }, m_SquareColor);
		Hazel::Renderer2D::DrawQuad({ 0.0f, 0.0f, -0.1f }, { 20.0f, 20.0f }, m_CheckerboardTexture, 10.0f);
		Hazel::Renderer2D::DrawRotatedQuad({ -2.0f, 0.0f, 0.0f }, { 1.0f, 1.0f }, rotation, m_CheckerboardTexture, 20.0f);
		Hazel::Renderer2D::EndScene();

		Hazel::Renderer2D::BeginScene(m_CameraController.GetCamera());
		for (float y = -5.0f; y < 5.0f; y += 0.5f)
		{
			for (float x = -5.0f; x < 5.0f; x += 0.5f)
			{
				glm::vec4 color = { (x + 5.0f) / 10.0f, 0.4f, (y + 5.0f) / 10.0f, 0.7f };
				Hazel::Renderer2D::DrawQuad({ x, y }, { 0.45f, 0.45f }, color);
			}
		}
		Hazel::Renderer2D::EndScene();
	}
}

void Sandbox2D::OnImGuiRender()
{
	HZ_PROFILE_FUNCTION();

	ImGui::Begin("Settings");

	auto stats = Hazel::Renderer2D::GetStats();
	ImGui::Text("Renderer2D Stats:");
	ImGui::Text("Draw Calls: %d", stats.DrawCalls);
	ImGui::Text("Quads: %d", stats.QuadCount);
	ImGui::Text("Vertices: %d", stats.GetTotalVertexCount());
	ImGui::Text("Indices: %d", stats.GetTotalIndexCount());

	ImGui::ColorEdit4("Square Color", glm::value_ptr(m_SquareColor));
	ImGui::End();
}

void Sandbox2D::OnEvent(Hazel::Event& e)
{
	m_CameraController.OnEvent(e);
}

```

`Sandbox/src/Sandbox2D.h`:

```h
#pragma once

#include "Hazel.h"

class Sandbox2D : public Hazel::Layer
{
public:
	Sandbox2D();
	virtual ~Sandbox2D() = default;

	virtual void OnAttach() override;
	virtual void OnDetach() override;

	void OnUpdate(Hazel::Timestep ts) override;
	virtual void OnImGuiRender() override;
	void OnEvent(Hazel::Event& e) override;
private:
	Hazel::OrthographicCameraController m_CameraController;
	
	// Temp
	Hazel::Ref<Hazel::VertexArray> m_SquareVA;
	Hazel::Ref<Hazel::Shader> m_FlatColorShader;

	Hazel::Ref<Hazel::Texture2D> m_CheckerboardTexture;

	glm::vec4 m_SquareColor = { 0.2f, 0.3f, 0.8f, 1.0f };
};
```

`Sandbox/src/SandboxApp.cpp`:

```cpp
#include <Hazel.h>
#include <Hazel/Core/EntryPoint.h>

#include "Sandbox2D.h"
#include "ExampleLayer.h"

class Sandbox : public Hazel::Application
{
public:
	Sandbox(const Hazel::ApplicationSpecification& specification)
		: Hazel::Application(specification)
	{
		// PushLayer(new ExampleLayer());
		PushLayer(new Sandbox2D());
	}

	~Sandbox()
	{
	}
};

Hazel::Application* Hazel::CreateApplication(Hazel::ApplicationCommandLineArgs args)
{
	ApplicationSpecification spec;
	spec.Name = "Sandbox";
	spec.WorkingDirectory = "../Hazelnut";
	spec.CommandLineArgs = args;

	return new Sandbox(spec);
}

```

`premake5.lua`:

```lua
include "./vendor/premake/premake_customization/solution_items.lua"
include "Dependencies.lua"

workspace "Hazel"
	architecture "x86_64"
	startproject "Hazelnut"

	configurations
	{
		"Debug",
		"Release",
		"Dist"
	}

	solution_items
	{
		".editorconfig"
	}

	flags
	{
		"MultiProcessorCompile"
	}

outputdir = "%{cfg.buildcfg}-%{cfg.system}-%{cfg.architecture}"

group "Dependencies"
	include "vendor/premake"
	include "Hazel/vendor/Box2D"
	include "Hazel/vendor/GLFW"
	include "Hazel/vendor/Glad"
	include "Hazel/vendor/msdf-atlas-gen"
	include "Hazel/vendor/imgui"
	include "Hazel/vendor/yaml-cpp"
group ""

group "Core"
	include "Hazel"
	include "Hazel-ScriptCore"
group ""

group "Tools"
	include "Hazelnut"
group ""

group "Misc"
	include "Sandbox"
group ""

```

`scripts/Setup.bat`:

```bat
@echo off
python Setup.py
PAUSE
```

`scripts/Setup.py`:

```py

import os
import subprocess
import platform

from SetupPython import PythonConfiguration as PythonRequirements

# Make sure everything we need for the setup is installed
PythonRequirements.Validate()

from SetupPremake import PremakeConfiguration as PremakeRequirements
from SetupVulkan import VulkanConfiguration as VulkanRequirements
os.chdir('./../') # Change from devtools/scripts directory to root

premakeInstalled = PremakeRequirements.Validate()
VulkanRequirements.Validate()

print("\nUpdating submodules...")
subprocess.call(["git", "submodule", "update", "--init", "--recursive"])

if (premakeInstalled):
    if platform.system() == "Windows":
        print("\nRunning premake...")
        subprocess.call([os.path.abspath("./scripts/Win-GenProjects.bat"), "nopause"])

    print("\nSetup completed!")
else:
    print("Hazel requires Premake to generate project files.")


```

`scripts/SetupPremake.py`:

```py
import sys
import os
from pathlib import Path

import Utils

class PremakeConfiguration:
    premakeVersion = "5.0.0-beta1"
    premakeZipUrls = f"https://github.com/premake/premake-core/releases/download/v{premakeVersion}/premake-{premakeVersion}-windows.zip"
    premakeLicenseUrl = "https://raw.githubusercontent.com/premake/premake-core/master/LICENSE.txt"
    premakeDirectory = "./vendor/premake/bin"

    @classmethod
    def Validate(cls):
        if (not cls.CheckIfPremakeInstalled()):
            print("Premake is not installed.")
            return False

        print(f"Correct Premake located at {os.path.abspath(cls.premakeDirectory)}")
        return True

    @classmethod
    def CheckIfPremakeInstalled(cls):
        premakeExe = Path(f"{cls.premakeDirectory}/premake5.exe");
        if (not premakeExe.exists()):
            return cls.InstallPremake()

        return True

    @classmethod
    def InstallPremake(cls):
        permissionGranted = False
        while not permissionGranted:
            reply = str(input("Premake not found. Would you like to download Premake {0:s}? [Y/N]: ".format(cls.premakeVersion))).lower().strip()[:1]
            if reply == 'n':
                return False
            permissionGranted = (reply == 'y')

        premakePath = f"{cls.premakeDirectory}/premake-{cls.premakeVersion}-windows.zip"
        print("Downloading {0:s} to {1:s}".format(cls.premakeZipUrls, premakePath))
        Utils.DownloadFile(cls.premakeZipUrls, premakePath)
        print("Extracting", premakePath)
        Utils.UnzipFile(premakePath, deleteZipFile=True)
        print(f"Premake {cls.premakeVersion} has been downloaded to '{cls.premakeDirectory}'")

        premakeLicensePath = f"{cls.premakeDirectory}/LICENSE.txt"
        print("Downloading {0:s} to {1:s}".format(cls.premakeLicenseUrl, premakeLicensePath))
        Utils.DownloadFile(cls.premakeLicenseUrl, premakeLicensePath)
        print(f"Premake License file has been downloaded to '{cls.premakeDirectory}'")

        return True

```

`scripts/SetupPython.py`:

```py
import sys
import subprocess
import importlib.util as importlib_util

class PythonConfiguration:
    @classmethod
    def Validate(cls):
        if not cls.__ValidatePython():
            return # cannot validate further

        for packageName in ["requests"]:
            if not cls.__ValidatePackage(packageName):
                return # cannot validate further

    @classmethod
    def __ValidatePython(cls, versionMajor = 3, versionMinor = 3):
        if sys.version is not None:
            print("Python version {0:d}.{1:d}.{2:d} detected.".format( \
                sys.version_info.major, sys.version_info.minor, sys.version_info.micro))
            if sys.version_info.major < versionMajor or (sys.version_info.major == versionMajor and sys.version_info.minor < versionMinor):
                print("Python version too low, expected version {0:d}.{1:d} or higher.".format( \
                    versionMajor, versionMinor))
                return False
            return True

    @classmethod
    def __ValidatePackage(cls, packageName):
        if importlib_util.find_spec(packageName) is None:
            return cls.__InstallPackage(packageName)
        return True

    @classmethod
    def __InstallPackage(cls, packageName):
        permissionGranted = False
        while not permissionGranted:
            reply = str(input("Would you like to install Python package '{0:s}'? [Y/N]: ".format(packageName))).lower().strip()[:1]
            if reply == 'n':
                return False
            permissionGranted = (reply == 'y')
        
        print(f"Installing {packageName} module...")
        subprocess.check_call(['python', '-m', 'pip', 'install', packageName])

        return cls.__ValidatePackage(packageName)

if __name__ == "__main__":
    PythonConfiguration.Validate()

```

`scripts/SetupVulkan.py`:

```py
import os
import sys
import subprocess
from pathlib import Path

import Utils

from io import BytesIO
from urllib.request import urlopen

class VulkanConfiguration:
    requiredVulkanVersion = "1.3."
    installVulkanVersion = "1.3.216.0"
    vulkanDirectory = "./Hazel/vendor/VulkanSDK"

    @classmethod
    def Validate(cls):
        if (not cls.CheckVulkanSDK()):
            print("Vulkan SDK not installed correctly.")
            return
            
        if (not cls.CheckVulkanSDKDebugLibs()):
            print("\nNo Vulkan SDK debug libs found. Install Vulkan SDK with debug libs.")
            print("(see docs.hazelengine.com/GettingStarted for more info).")
            print("Debug configuration disabled.")

    @classmethod
    def CheckVulkanSDK(cls):
        vulkanSDK = os.environ.get("VULKAN_SDK")
        if (vulkanSDK is None):
            print("\nYou don't have the Vulkan SDK installed!")
            cls.__InstallVulkanSDK()
            return False
        else:
            print(f"\nLocated Vulkan SDK at {vulkanSDK}")

        if (cls.requiredVulkanVersion not in vulkanSDK):
            print(f"You don't have the correct Vulkan SDK version! (Engine requires {cls.requiredVulkanVersion})")
            cls.__InstallVulkanSDK()
            return False
    
        print(f"Correct Vulkan SDK located at {vulkanSDK}")
        return True

    @classmethod
    def __InstallVulkanSDK(cls):
        permissionGranted = False
        while not permissionGranted:
            reply = str(input("Would you like to install VulkanSDK {0:s}? [Y/N]: ".format(cls.installVulkanVersion))).lower().strip()[:1]
            if reply == 'n':
                return
            permissionGranted = (reply == 'y')

        vulkanInstallURL = f"https://sdk.lunarg.com/sdk/download/{cls.installVulkanVersion}/windows/VulkanSDK-{cls.installVulkanVersion}-Installer.exe"
        vulkanPath = f"{cls.vulkanDirectory}/VulkanSDK-{cls.installVulkanVersion}-Installer.exe"
        print("Downloading {0:s} to {1:s}".format(vulkanInstallURL, vulkanPath))
        Utils.DownloadFile(vulkanInstallURL, vulkanPath)
        print("Running Vulkan SDK installer...")
        os.startfile(os.path.abspath(vulkanPath))
        print("Re-run this script after installation!")
        quit()

    @classmethod
    def CheckVulkanSDKDebugLibs(cls):
        vulkanSDK = os.environ.get("VULKAN_SDK")
        shadercdLib = Path(f"{vulkanSDK}/Lib/shaderc_sharedd.lib")
        
        return shadercdLib.exists()

if __name__ == "__main__":
    VulkanConfiguration.Validate()

```

`scripts/Utils.py`:

```py
import sys
import os
import winreg

import requests
import time
import urllib

from zipfile import ZipFile

def GetSystemEnvironmentVariable(name):
    key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, r"System\CurrentControlSet\Control\Session Manager\Environment")
    try:
        return winreg.QueryValueEx(key, name)[0]
    except:
        return None

def GetUserEnvironmentVariable(name):
    key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, r"Environment")
    try:
        return winreg.QueryValueEx(key, name)[0]
    except:
        return None

def DownloadFile(url, filepath):
    path = filepath
    filepath = os.path.abspath(filepath)
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
    if (type(url) is list):
        for url_option in url:
            print("Downloading", url_option)
            try:
                DownloadFile(url_option, filepath)
                return
            except urllib.error.URLError as e:
                print(f"URL Error encountered: {e.reason}. Proceeding with backup...\n\n")
                os.remove(filepath)
                pass
            except urllib.error.HTTPError as e:
                print(f"HTTP Error  encountered: {e.code}. Proceeding with backup...\n\n")
                os.remove(filepath)
                pass
            except:
                print(f"Something went wrong. Proceeding with backup...\n\n")
                os.remove(filepath)
                pass
        raise ValueError(f"Failed to download {filepath}")
    if not(type(url) is str):
        raise TypeError("Argument 'url' must be of type list or string")

    with open(filepath, 'wb') as f:
        headers = {'User-Agent': "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36"}
        response = requests.get(url, headers=headers, stream=True)
        total = response.headers.get('content-length')

        if total is None:
            f.write(response.content)
        else:
            downloaded = 0
            total = int(total)
            startTime = time.time()
            for data in response.iter_content(chunk_size=max(int(total/1000), 1024*1024)):
                downloaded += len(data)
                f.write(data)
                
                try:
                    done = int(50*downloaded/total) if downloaded < total else 50
                    percentage = (downloaded / total) * 100 if downloaded < total else 100
                except ZeroDivisionError:
                    done = 50
                    percentage = 100
                elapsedTime = time.time() - startTime
                try:
                    avgKBPerSecond = (downloaded / 1024) / elapsedTime
                except ZeroDivisionError:
                    avgKBPerSecond = 0.0

                avgSpeedString = '{:.2f} KB/s'.format(avgKBPerSecond)
                if (avgKBPerSecond > 1024):
                    avgMBPerSecond = avgKBPerSecond / 1024
                    avgSpeedString = '{:.2f} MB/s'.format(avgMBPerSecond)
                sys.stdout.write('\r[{}{}] {:.2f}% ({})     '.format('█' * done, '.' * (50-done), percentage, avgSpeedString))
                sys.stdout.flush()
    sys.stdout.write('\n')

def UnzipFile(filepath, deleteZipFile=True):
    zipFilePath = os.path.abspath(filepath) # get full path of files
    zipFileLocation = os.path.dirname(zipFilePath)

    zipFileContent = dict()
    zipFileContentSize = 0
    with ZipFile(zipFilePath, 'r') as zipFileFolder:
        for name in zipFileFolder.namelist():
            zipFileContent[name] = zipFileFolder.getinfo(name).file_size
        zipFileContentSize = sum(zipFileContent.values())
        extractedContentSize = 0
        startTime = time.time()
        for zippedFileName, zippedFileSize in zipFileContent.items():
            UnzippedFilePath = os.path.abspath(f"{zipFileLocation}/{zippedFileName}")
            os.makedirs(os.path.dirname(UnzippedFilePath), exist_ok=True)
            if os.path.isfile(UnzippedFilePath):
                zipFileContentSize -= zippedFileSize
            else:
                zipFileFolder.extract(zippedFileName, path=zipFileLocation, pwd=None)
                extractedContentSize += zippedFileSize
            try:
                done = int(50*extractedContentSize/zipFileContentSize)
                percentage = (extractedContentSize / zipFileContentSize) * 100
            except ZeroDivisionError:
                done = 50
                percentage = 100
            elapsedTime = time.time() - startTime
            try:
                avgKBPerSecond = (extractedContentSize / 1024) / elapsedTime
            except ZeroDivisionError:
                avgKBPerSecond = 0.0
            avgSpeedString = '{:.2f} KB/s'.format(avgKBPerSecond)
            if (avgKBPerSecond > 1024):
                avgMBPerSecond = avgKBPerSecond / 1024
                avgSpeedString = '{:.2f} MB/s'.format(avgMBPerSecond)
            sys.stdout.write('\r[{}{}] {:.2f}% ({})     '.format('█' * done, '.' * (50-done), percentage, avgSpeedString))
            sys.stdout.flush()
    sys.stdout.write('\n')

    if deleteZipFile:
        os.remove(zipFilePath) # delete zip file
```

`scripts/Win-GenProjects.bat`:

```bat
@echo off
pushd %~dp0\..\
call vendor\premake\bin\premake5.exe vs2022
popd
PAUSE

```

`vendor/premake/premake5.lua`:

```lua
project "Premake"
	kind "Utility"

	targetdir ("%{wks.location}/bin/" .. outputdir .. "/%{prj.name}")
	objdir ("%{wks.location}/bin-int/" .. outputdir .. "/%{prj.name}")

	files
	{
		"%{wks.location}/**premake5.lua"
	}

	postbuildmessage "Regenerating project files with Premake5!"
	postbuildcommands
	{
		"\"%{prj.location}bin/premake5\" %{_ACTION} --file=\"%{wks.location}premake5.lua\""
	}

```

`vendor/premake/premake_customization/solution_items.lua`:

```lua
-- Implement the solution_items command for solution-scope files
require('vstudio')

premake.api.register {
	name = "solution_items",
	scope = "workspace",
	kind = "list:string",
}

premake.override(premake.vstudio.sln2005, "projects", function(base, wks)
	if wks.solution_items and #wks.solution_items > 0 then
		local solution_folder_GUID = "{2150E333-8FDC-42A3-9474-1A3956D46DE8}" -- See https://www.codeproject.com/Reference/720512/List-of-Visual-Studio-Project-Type-GUIDs
		premake.push("Project(\"" .. solution_folder_GUID .. "\") = \"Solution Items\", \"Solution Items\", \"{" .. os.uuid("Solution Items:" .. wks.name) .. "}\"")
		premake.push("ProjectSection(SolutionItems) = preProject")

		for _, path in ipairs(wks.solution_items) do
			premake.w(path .. " = " .. path)
		end

		premake.pop("EndProjectSection")
		premake.pop("EndProject")
	end
	base(wks)
end)

```