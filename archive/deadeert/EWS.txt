Project Path: arc_deadeert_EWS_08gwywwq

Source Tree:

```txt
arc_deadeert_EWS_08gwywwq
├── EWS
│   ├── asm
│   │   └── assembler.py
│   ├── doc
│   │   ├── TODO.md
│   │   ├── features.md
│   │   ├── img
│   │   │   ├── EWS_basic_usage.mov
│   │   │   ├── EWS_basic_usage.srt
│   │   │   ├── Logo_EWS.png
│   │   │   ├── Logo_EWS.svg
│   │   │   └── debugger_view.jpg
│   │   └── install
│   │       ├── install.md
│   │       └── requirements.txt
│   ├── emu
│   │   ├── emubase.py
│   │   └── unicorn
│   │       ├── aarch64.py
│   │       ├── arm32.py
│   │       ├── generic.py
│   │       ├── mipsl32.py
│   │       ├── x64.py
│   │       └── x86.py
│   ├── stubs
│   │   ├── ELF
│   │   │   ├── ELF.py
│   │   │   ├── conf.py
│   │   │   └── utils.py
│   │   ├── PE
│   │   │   └── PE.py
│   │   ├── allocators
│   │   │   └── allocator.py
│   │   ├── emu
│   │   │   └── unicorn
│   │   │       └── sea.py
│   │   └── generic.py
│   ├── ui
│   │   ├── Olds
│   │   │   ├── aarch64.py
│   │   │   ├── aarch64_simplified.py
│   │   │   ├── arm32.py
│   │   │   ├── arm32_simplified.py
│   │   │   ├── mipsl32.py
│   │   │   ├── x64.py
│   │   │   ├── x64_simplified.py
│   │   │   ├── x86.py
│   │   │   └── x86_simplified.py
│   │   ├── debug_view.py
│   │   ├── display_mem.py
│   │   ├── generic.py
│   │   ├── mem_edit.py
│   │   ├── mem_operations.py
│   │   ├── regedit.py
│   │   ├── stub_configuration.py
│   │   ├── tag_func_ui.py
│   │   └── watchpoint.py
│   └── utils
│       ├── call_tree.py
│       ├── configuration.py
│       ├── consts_aarch64.py
│       ├── consts_arm.py
│       ├── consts_ida.py
│       ├── consts_mips.py
│       ├── consts_x64.py
│       ├── consts_x86.py
│       ├── exec_trace.py
│       ├── registers.py
│       ├── utils.py
│       └── utils_ui.py
├── EWSPLugin.py
└── README.md

```

`EWS/asm/assembler.py`:

```py
from keystone import *
from keystone.arm_const import *
from unicorn import *
from unicorn.arm_const import *
from EWS.utils.utils import *


assemblers = dict() # {'arch': [ asm object, ... ]}

class Asm():

    def __init__(self,name,arch):

        self.name = name
        self.arch = arch
        if not arch in assemblers.keys():
            assemblers[arch] = []

    def __call__(self,cls):
        obj = cls(self.name)
        assemblers[self.arch].append(obj)
        return cls



class Assembler():

    def __init__(self,name):
        self.name = name

    def assemble(self,
                 asm: str,
                 addr:int) -> bytes:
        """
        this function take a synthax string and retruns the corresponding
        bytecode
        """
        pass


class KsAssembler(Assembler):

    def __init__(self,
                 name:str,
                 arch:int,
                 mode:int):

        try:
            self.ks = Ks(arch,mode)
        except KsError as e:
            pass

    def assemble(self,
                 asm:str,
                 addr:int):

        return self.ks.asm(asm,
                           addr=addr,
                           as_bytes=True)[0]


@Asm(arch='arm', name='KsArm')
class KsAssemblerArm(KsAssembler):

    def __init__(self,name):
        super().__init__(name,UC_ARCH_ARM,UC_MODE_ARM)

@Asm(arch='armt',name='KsArmThumb')
class KsAssemblerArmThumb(KsAssembler):

    def __init__(self,name):
        super().__init__(name,UC_ARCH_ARM,UC_MODE_THUMB)


@Asm(arch='aarch64',name='KsAarch64')
class KsAssemblerAarch64(KsAssembler):

    def __init__(self,name):
        super().__init__(name,UC_ARCH_ARM64,UC_MODE_ARM)

@Asm(arch='x86',name='Ksx86')
class KsAssemblerx86(KsAssembler):

    def __init__(self,name):
        super().__init__(name,UC_ARCH_X86,UC_MODE_32)

@Asm(arch='x64',name='Ksx64')
class KsAssemblerx64(KsAssembler):

    def __init__(self,name):
        super().__init__(name,UC_ARCH_X86,UC_MODE_64)








```

`EWS/doc/TODO.md`:

```md
# TODOs

## UI

-Add a console windows to query the emulator. 
-Better UI, anyone ? 

## Standalone Script 

-Make a standalone version of the plugin (running outside IDA),
configuration could be exported from the plugin then imported in 
the script. Evaluate how precious it'll be versus how many time it will take.


## Configuration Lifecycle 

Emulator already instancied: 
 - If the user edit the conf --> extract the conf from the emulator.
 - Need to declare a method for generic.py to query the state of the emulator, 
 for the values that can be modified when the emulator is created: 
   - Registers 
   - Memory Mapping 
   - stub
   - patch data
   - .. 

add a TAG and a PATCH, MAPPING, NSTUB list to generic to keep track these two elements for extract_current_Function 
breakpoint are already included.

This configuration object is then used for configuration edition. 
The emulator is reseted (clean) the view (before doing it ask the user y/n, in case he/she hits the button unintentionnaly. 
Open the edit config view, alert her/him she/he needs to reinstanciate the module.

Emulator not instancied: just edit the current conf object.


!! The config should not be modified at anytime during the execution !! 

## Config Serial / Unserial (not working well)

Now use extract_current_configuration if extracted when the configuration was created.


## libc_start_main for arm / aarch64


```

`EWS/doc/features.md`:

```md
# Available Features 

The plugin uses basically two objects, are an emulator wrapper, which must
implement the features exposed by Emulator interface (see `emu/emubase.py`) and
a configuration object which specifies anything required to configure the emulator
environment and settings.

Currently, only Unicorn emulator solution is supported. 

## Load Contextual Menu 

To load contextual menu, available in the assembly view, 
you can either load manually the plugin on "Edit/Plugins" or use
the shortcut **Ctrl+Alt+E**. 

## Configuration 

### You first configuration

The easiest way to generate a configuration object, is either to :

- select on the UI disasembly view the segment you want to execute and
  use shortcut **Ctrl+Alt+S** 
- go on a function and use shortcut **Ctrl+Alt+F**. 
- a ELF file benefits from the feature that allows to execute 
  the binary from the begining.  

If you want to create a configuration manually, you can use the contextual 
menu "EWS/init/" 

From here the emulator can be instancied, using shortcut **Ctrl+Alt+I**. 

At the stage, emulation can be launched using shortcut **Shift+Alt+C**.

### Import / Export 

Configuration file can be created (exported) and imported inside
the plugin. This will (de)serialize the configuration object. 

### Edit 


If the emulator is already instancied, editing the configuration 
will reset it and generate a Configuration object based on the 
**current** state of the emulator. 




## Debugging

### Execution control 

Like any debugger you can run the following command: 

- **Continue/Run** (`Alt+Shift+C`)
- **Step-in** (`Alt+Shift+I`)
- **Step-over** (`Alt+Shift+O`)

Take into account that Step-Over is not covering 100% of 
the situation, so use it wisely (or do a PR :) ). 


### Breakpoint

Breakpoint can be set using the IDA Pro shortcut (default is `F2`). 
The emulation will stop **before** executing the command.

### Watchpoint

You can use watchpoint to various memory area, there is no limit (one of the few advantages of emulation).
Like common CPU you can activate it either in read and/or write access fashion. 

The shortcut to activate the feature is `Alt+Shift+W`

## Memory

### MemoryExport

You can export some part of the memory. 

### MemoryImport:

You can import memory from **already** mapped area.
To map a new memory area use the feature to add a new mapping (shortcut is `Ctrl+Alt+A`). 
The UI is weird. You need to first select the file and click "add content file" to select the file. Then you need to click "Add Mapping" to create the mapping and add the content file.
If you don't want to init memory, just click on "Add Mapping" button.

### Memory Display 

There is few features to display memory: 

- Specified address 
- Stack
- Memory Segment (use IDA segment information). 

### Patch Memory 

The emulator uses the binary file to initialize the memory of the emulator. 
As a consequence, any patch done on the IDB won't be considered when the emulator is 
initialized. 

Once the emulator is initialized, you can patch the memory in two seperate way: 

- **Data Patch** (or raw patch): the user provides the bytes in bin hex ascii representation,
each byte being separated by a whitespace. Ex: DE AD BE EF. (`Ctrl+Alt+M`) 
- **Instruction Patch:** the user can directly enter assembly. The engine benefits from a `keystone-engine` 
backend.(`Ctrl+Alt+P`)  

Another feature allows to import a json file with a record of addresses and their corresponding assembly. 


## Stubs Mechanism 

### Implementation Information 
Each supported architecture benefits from a stub mechanism. 
The current design allows to only write a generic stub which will 
be available for each architecture. 

Further improvements could be achieved to also support several calling convention,
but this is not planned. 

To add a stub, the user should reach either `stubs/ELF/ELF.py` or `stubs/PE/PE.py` file 
according to the environment. 

*Note*: Even if the binary is not using a loader, the stub mechanism is still available, 
which limited features (it does not automatically patch symbols table). 

The stub receive a `helper` object which primitives that allow to access the arguments. 
This is where the architecture abstraction occurs. 

By default the stub engine will use LIEF to figure out where are the symbols table (either 
the got.plt table or the IAT according to the arch). 

Note: Windows support is very experimental, do not hesitate to PR if you would give an hand. 
I'll not handle Windows related issues, sorry... 

From here; it will either stub the symbols if it is available. Otherwise, the engine will 
put a null-stub (a direct return). 

The stub strategy depends on the architecture, please refer to the stub related functions in `emu/<engine>/<arch.py>` 
file if you are curious.

There is few available features from the stub engine: 

- **null-stub**: you can ask the engine to null-stub a function (even-if it's defined). 
This is useful for example when you know that the function is reading a memory area related to 
a missing peripheral. 
- **tag-function** you can tell the engine that this address correspond to a specific function. 
For example you might find that a function is actually doing allocation. You can tell the engine that
this function is actually `<malloc>/<realloc>`... 

### Allocator 

Yes, there is a dumb allocator available as well...



```

`EWS/doc/img/EWS_basic_usage.srt`:

```srt
1
00:00:01,000 --> 00:00:02,500
CTRL + ALT + E 

2
00:00:02,600 --> 00:00:05,500
CTRL + ALT + S

3
00:00:06,600 --> 00:00:16,000
CTRL + ALT + C 

4
00:00:16,100 --> 00:00:20,000
CTRL + ALT + R

5
00:00:20,100 --> 00:00:23,000
CTRL + ALT + I

6
00:00:23,100 --> 00:00:26,000
CTRL + SHIFT + C









```

`EWS/doc/img/Logo_EWS.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Calque_2" data-name="Calque 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1110 420.02">
  <defs>
    <style>
      .cls-1 {
        fill-rule: evenodd;
      }
    </style>
  </defs>
  <g id="Calque_3" data-name="Calque 3">
    <path class="cls-1" d="M910,90.02h190c5.52,0,10-4.48,10-10V10.02c0-5.52-4.48-10-10-10h-256v-.02h-146V.02h-.9c-4.72,0-8.8,3.31-9.78,7.93l-47.63,224.78c-.58,2.72-4.4,2.87-5.19,.21l-32.34-105.84c-1.28-4.21-5.17-7.08-9.56-7.08h-75.14c-4.43,0-8.33,2.91-9.59,7.16l-24.34,82.05c-2.95,9.94-17.22,9.38-19.37-.77L421.68,7.95c-.98-4.62-5.06-7.93-9.78-7.93h-36.9v-.02H211V.02H10C4.48,.02,0,4.5,0,10.02V410.02c0,5.52,4.48,10,10,10H503.54c4.43,0,8.33-2.91,9.59-7.16l32.79-110.53c2.83-9.54,16.34-9.54,19.17,0l32.79,110.53c1.26,4.24,5.16,7.16,9.59,7.16h492.54c5.52,0,10-4.48,10-10V175.02c0-5.52-4.48-10-10-10h-190c-5.52,0-10-4.48-10-10v-55c0-5.52,4.48-10,10-10ZM387.59,330.02H100c-5.52,0-10-4.48-10-10v-55c0-5.52,4.48-10,10-10h188c5.52,0,10-4.48,10-10v-70c0-5.52-4.48-10-10-10H100c-5.52,0-10-4.48-10-10v-55c0-5.52,4.48-10,10-10h190c.13,0,.26-.01,.39-.02h50.58c4.72,0,8.8,3.31,9.78,7.93l46.62,220.02c1.32,6.22-3.43,12.07-9.78,12.07Zm622.41-75c5.52,0,10,4.48,10,10v55c0,5.52-4.48,10-10,10h-288.59c-6.36,0-11.1-5.85-9.78-12.07l46.62-220.02c.98-4.62,5.06-7.93,9.78-7.93h31.96c5.52,0,10,4.48,10,10V245.02c0,5.52,4.48,10,10,10h190Z"/>
  </g>
</svg>
```

`EWS/doc/install/install.md`:

```md
# Installation 

## Dependencies

Please install manually the following python packages: 

- hexdump   
- dateutil 
- lief

Please install the following python bindings: 

- unicorn engine (install python bindings `bindings/python/setup.py install`)
- capstone engine (install python bindings `bindings/python/setup.py install`)
- keystone engine (install python bindings `bindings/python/setup.py install`)

If you are lazy, you can directly install them: 

```sh 
pip install -r requirements.txt
```

## IDA Plugin

Copy folder `EWS` and `EWSPLugin.py` in your `$IDA_HOME/plugin` (generally corresponding to `$HOME/.idapro`).

## Smoke test

In the default graph view, execute the key combination `CTRL+ALT+E` to get the `ews` menu when you trigger
rigth click. 
You should be ready to go. 
Otherwise, check the console, something mysterious might have happened...



```

`EWS/doc/install/requirements.txt`:

```txt
hexdump
dateutils 
lief
unicorn
capstone
keystone-engine

```

`EWS/emu/emubase.py`:

```py
from EWS.utils.utils import * 
import ida_idaapi





class Emulator(object):

  """ Base class for all engine emulator
      all these methods must be implemented 
      and respect the argument to ensure compatibility 
      with stubs mechanism. 
  """


  def __init__(self,
               conf):

    """ 
    !Init object
    
    @param conf: configuration derivated from utils.Configuration

    """
    self.conf = conf
    self.color_map = dict()
    self.user_breakpoints = list()
    self.ida_breakpoints = list()
    self.reloc_map = dict()
    self.last_pc = None
    self.is_running = False
    self.stubbed_bytes = dict() # records of {ea : original instruction
    for ea in self.conf.breakpoints:
      self.add_breakpoint(ea)
    

    
  def start(self):

    """ 
    !Method responsive for execution launch
 
    """
    pass

  @staticmethod 
  def do_required_mapping(emu,
                          s_ea:int,
                          e_ea:int,
                          p_size:int,
                          perms:int):


    """ 
    !performs the required mapping. 
    must be called when consecutive areas maller than 
    p_size are required. These area must benefit from 
    the same permission. 

    @param s_ea:   beginning of the mapping.
    @param e_ea:   end of the mapping
    @param p_size: page size
    @param perms:  permission to set on mapping

    """ 
    pass

  def add_mapping(self,
                  addr:int,
                  mem:bytes,
                  perms:int):
    """ 
    ! Add mapping

    @param addr: Effective Address. 
    @param mem: Bytes. 
    @param perms: Permissions

    """
    pass

  @staticmethod
  def reg_convert(r_id):
    """ 
    !Maps generic register id r_id to the one 
    used by emulator solution 
    
    @param r_id: generic register id 

    """
    pass

  @staticmethod
  def mem_read(emu,addr,size):
    """ 
    !Returns memory data 
    from the emulator
    
    @param emu :   pointer to the emulator engine 
    @param addr:   addr to read from 
    @param size:   size of the read operation

    """
    pass
  
  @staticmethod
  def mem_write(emu,
                addr:int,
                data:bytes):
    """ 
    !Write data to emulator' memory

    @param emu :   pointer to the emulator engine 
    @param addr:   addr to write to 
    @param data:   data to write to emulator memory 

    """
    pass
  
  @staticmethod
  def reg_read(emu,
               r_id):
    """ 
    !Return emulator' register value corresponding 
        to generic register id r_id
    @param emu :   pointer to the emulator engine 
    @param r_id:   generic id of register to read from
    """
    pass

  @staticmethod
  def reg_write(emu,
                r_id,
                data:int):
      
    """ 

    !Write data to emulator ' register value 
        corresponding to generic register id r_id
    @param emu :   pointer to the emulator engine 
    @param r_id:   generic id of register to write to
    @param data:   data to write to register 
    
    """
    pass


  def get_alu_info(self,flags):

    """ 
    !Returns  of ALU flags

    """
    pass

  @staticmethod
  def check_mapping(conf):

    """ 
    !Check specified memory mapping in configration against
    the smallest and biggest Effective Addresses registred inside the 
    IDB.

    @param conf: Configuration object.
    
    """
    inf = ida_idaapi.get_inf_structure()
    return conf.mapping_eaddr <= inf.max_ea and conf.mapping_saddr >= inf.min_ea and conf.mapping_saddr < conf.mapping_eaddr 

  def restore_graph_color(self,purge_db=False):

    """ 
    !Restore default color of executed insn. 
    purge_db will empty the insn database.

    @Deprecated 

    """ 
    restore_graph_color(self.color_map,purge_db)


  def add_null_stub(self,ea,fname=None):
    """ stub function for direct return (cdecl only)
    """
    pass

  def remove_null_stub(self,ea):
    """ remove a null stub
    """
    pass


  def add_custom_stub(self,
                      ea:int,
                      func):

    """ 
    !add a custom stub 

    @param ea: Effective Address to apply the stub on. 
    @param func: Python Code describing the stub. 

    """
    pass

  def remove_custom_stub(self,
                         ea:int):

    """ 
    !inverse of add_custom_stub

    @param ea: Effective Address to remove the stub from. 

    """
    pass

  def tag_function(self,
                   ea:int,
                   stub_name:str):
    """ 
    !tag a function with an already implemented
        stub. 

    @param ea: Effective Address to apply the stub on. 
    @param stub_name: Symbol Name for the stub.

    """

    pass

  def remove_tag(self,ea):

    """ 
    !reciproque of tag_function

    @param ea: Effective Address to remove the stub from. 

    """
    pass

  def display_allocations(self):

    """ 
    !display allocator "chuncks" 

    """
    for c in self.helper.allocator.allocs:
        logger.console(LogType.INFO,"================")
        logger.console(LogType.INFO,"[+] Chunck(%x,%d)"%(c.addr,c.size))
        self.display_range(c.addr,c.addr+c.size)
        logger.console(LogType.INFO,"================")


  def step_in(self):
    """ 
    !exec one insn   

    """
    pass 

  def step_n(self,n:int):

    """ 
    !exec n insntructions 

    @param n: Number of instructions

    """ 
    pass

  def add_breakpoint(self,
                   ea:int):
    """ 
    !setup a breakpoint for insn x 

    @param ea: Effective Address to aaply the breakpoint on.

    """
    self.user_breakpoints.append(ea)
    self.conf.add_breakpoint(ea)
    logger.console(LogType.INFO,'Breakpoint added to %x'%ea)
    
      

  def del_breakpoint(self,
                     ea:int):
     
    """
    !Delete breakpoint at specified address.

    @param ea: Effective Address of the breakpoint.

    """

    try:
      self.user_breakpoints.remove(ea)
      
    except ValueError:
      logger.console(LogType.WARN,'no breakpoint at specified address %x'%ea)

  def list_breakpoints(self):
      """ 
      !List all registred breakpoints. 

      """

      for ea in self.user_breakpoints:
        logger.console(LogType.INFO,"bp at %x"%ea)

  def del_breakpoints(self):

      """
      !Delete all registred breakpoints 

      """ 

      for ea in self.user_breakpoints:
          self.del_breakpoint(ea)
      logger.console(LogType.INFO,"All breakpoint were removed")
        
  def step_over(self):

    """ 
    !Stop at next function return: 
    Works also with conditionnal jump  

    """
    pass 

  def save_config(self,
                  filepath:str=None):
    """ 
    !Save the current configuration in selected file. 

    @param filepath: path of the selected file. 

    """

    saveconfig(self.conf,filepath) 


  def get_relocs(self,
                 fpath:str):

      """ 
      !get the relocs for GOT entries (JMP_SLOT)
          for stub purpose
      
      @param fpath: Filepath of the ELF file. 

      """
      pass

  def add_watchpoint(self,base_addr, rang, mode=0x3):
      """
      !add watchpoint for [base_addr:base_addr+range]
      mode & 0x1 : read
      mode >> 1 & 0x1: write

      @param base_addr: Effective Address to apply the watchpoint on.
      @apram rang: size of the data to monitor. 
      @param mod: 1 read, 2 write, 3 both


      """
      pass

  def patch_mem(self,
                addr:int,
                bytecode:bytes):

      self.mem_write(addr,bytecode)
      self.patches[addr] = bytecode











```

`EWS/emu/unicorn/aarch64.py`:

```py
import ida_segregs
from EWS.emu.unicorn.generic import * 
import string
from EWS.utils.utils import * 
from EWS.utils import consts_aarch64
from EWS.stubs.allocators.allocator import *
from EWS.stubs.ELF import ELF
from EWS.stubs.emu.unicorn.sea import UnicornAarch64SEA
import struct
import lief
from EWS.utils.configuration import *
from EWS.utils.registers import *
from EWS.asm.assembler import *

class Aarch64Corn(Emucorn):

    def __init__(self,conf):

        super().__init__(conf)

        # Init engine 
        self.uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)

        self.pointer_size = 8

        
        # Map pages 
        d,r = divmod(self.conf.p_size,0x1000)
        if r:
          logger.console(LogType.WARN,'[+] invalid page size, using default')
          self.conf.p_size = uc.query(UC_QUERY_PAGE_SIZE)
        Emucorn.do_mapping(self.uc,self.conf)

        # Init capstone engine
        if conf.useCapstone:
            from capstone import Cs, CS_ARCH_ARM64,  CS_MODE_ARM
            self.cs=Cs(CS_ARCH_ARM64, CS_MODE_ARM)
            self.cs.detail=True

        # Setup regs 
        self.setup_regs(self.conf.registers)
        self.pcid = UC_ARM64_REG_PC 


        # Init stubs engine
        if self.conf.s_conf.activate_stub_mechanism:
            self.setup_stub_mechanism()

        self.install_hooks()
     
        for k,v in self.conf.memory_init.mappings.items():
            self.uc.mem_write(k,v)

        self.assembler = assemblers['aarch64'][0]


        for k,v in self.conf.patches.items():
            self.patch_mem(k,v)

        for k,v in self.conf.watchpoints.items():
            self.add_watchpoint(k, v&0xff,mode=v>>24)


    def install_hooks(self):

        self.uc.hook_add(UC_HOOK_CODE,
                         self.hook_code,
                         user_data=self.conf)
        self.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED,
                         Emucorn.unmp_read,
                         user_data=self)

        self.uc.hook_add(UC_HOOK_MEM_WRITE_UNMAPPED,
                         Emucorn.unmp_write,
                         user_data=self)

        if self.conf.showMemAccess:
          self.uc.hook_add(UC_HOOK_MEM_WRITE,
                    Emucorn.hk_write,
                    self)

          self.uc.hook_add(UC_HOOK_MEM_READ,
                           Emucorn.hk_read,
                           self)

    def setup_stub_mechanism(self):

        Emucorn.do_required_mappng(self.uc,
                                   consts_aarch64.ALLOC_BA,
                                   consts_aarch64.ALLOC_BA+self.conf.p_size*consts_aarch64.ALLOC_PAGES,
                                   self.conf.p_size,
                                   UC_PROT_READ | UC_PROT_WRITE,
                                   True,
                                   f"Warning map heap in already mapped area {consts_aarch64.ALLOC_BA:x}, edit utils/const_aarch64.py to modify this area")


        self.helper = UnicornAarch64SEA(emu=self,
                                          allocator=DumpAllocator(consts_aarch64.ALLOC_BA,
                                                                  consts_aarch64.ALLOC_PAGES*self.conf.p_size),
                                          wsize=4)
        self.nstub_obj = ELF.NullStub()
        self.nstub_obj.set_helper(self.helper) 

        if verify_valid_elf(self.conf.s_conf.orig_filepath):
          self.reloc_map = get_relocs(self.conf.s_conf.orig_filepath,
                                      lief.ELF.RELOCATION_AARCH64.JUMP_SLOT)
          self.stubs = ELF.libc_stubs 
          self.libc_start_main_trampoline = consts_aarch64.LIBCSTARTSTUBADDR
          self.stub_PLT()


        for k,v in self.conf.s_conf.tags.items():
            self.tag_func(k,v)


    

    def nop_insn(self,insn):

        # use self.assembler() now we added an assembler :) TODO
        self.uc.mem_write(insn.ea,
                          struct.pack('<I',consts_aarch64.nop))
    

    def get_retn_insn(self,ea):

        # same
        return struct.pack('>I',
                           consts_aarch64.ret)

    def get_new_stub(self,
                     stub_func,
                     stub_type:StubType,
                     name:str=''):

        stub = ELF.Stub(self.helper,
                        stub_type=stub_type,
                        name=name)
        stub.do_it = stub_func
        return stub



    """  Register specific functions 
    """


    def setup_regs(self,regs):

        """ 
        Setup Emulator's registers using Register object. 

        @param regs: Register object.

        """





        for k,v in consts_aarch64.reg_map_unicorn.items():

            self.uc.reg_write(v,getattr(regs,k)) 

    def get_regs(self):


            """ 
            Returns a Register object instancied with 
            the current emulator register values. 

            @return Register Object.
            """

            regs = Aarch64Registers.create() 
            for k,v in consts_aarch64.reg_map_unicorn.items():
                setattr(regs,k,self.uc.reg_read(v))
            return regs




    def reset_regs(self):

        """ 
        Reset the Emulator' registers.
        """


        for k,v in consts_aarch64.reg_map_unicorn.items():
            self.uc.reg_write(v,0)
        

    @staticmethod
    def reg_convert(reg_id):

        if type(reg_id) == type(str()):

          return Aarch64Corn.str2reg(reg_id)

        elif type(reg_id) == type(int()):

          return Aarch64Corn.int2reg(reg_id)

        else:

          raise Exception('[reg_convert] unhandled conversion for type %s'%type(reg_id))

    def reg_convert_ns(self,reg_id):

        if type(reg_id) == type(str()):

          return Aarch64Corn.str2reg(reg_id)

        else:
          raise Exception('[reg_convert] unhandled conversion for type %s'%type(reg_id))



    @staticmethod
    def int2reg(reg_id):
        if reg_id == 31:
          return UC_ARM64_REG_SP
        elif reg_id == 29:
          return UC_ARM64_REG_FP
        elif reg_id == 30: 
          return UC_ARM64_REG_LR
        elif reg_id == 260:
          return UC_ARM64_REG_PC
        else: 
            return UC_ARM64_REG_X0 + reg_id

    @staticmethod           
    def str2reg(r_str):

        return consts_aarch64.reg_map_unicorn[r_str] 
        
    def get_alu_info(self): 
        return aarch64CPSR.create(self.uc.reg_read(UC_ARM_REG_CPSR))



    def print_registers(self):

        strout = 'Registers:\n'
        for k,v in consts_aarch64.reg_map_unicorn.items():
            strout += f"{k}={self.uc.reg_read(v):x}" 
         
        return strout


        
    @staticmethod
    def generate_default_config(
                                 path: str = None,
                                 arch: str = None,
                                 emulator: str = None,
                                 p_size: int = None,
                                 stk_ba: int = None,
                                 stk_size: int = None,
                                 autoMap: bool = None,
                                 showRegisters: bool = None,
                                 exec_saddr: int =None,
                                 exec_eaddr: int =None,
                                 mapping_saddr: int =None,
                                 mapping_eaddr: int =None,
                                 segms: list =None,
                                 map_with_segs: bool = None,
                                 use_seg_perms: bool =None,
                                 useCapstone: bool = None,
                                 registers: Registers = None,
                                 showMemAccess: bool =None,
                                 s_conf: StubConfiguration = None,
                                 amap_conf: AdditionnalMapping = None,
                                 memory_init: AdditionnalMapping =None,
                                 color_graph: bool =None,
                                 breakpoints: list =None,
                                 watchpoints: dict =None) -> Configuration:
      """this method get called by:
            - ui **emulate_function**
            - ui **emulate_selection**
      """

      if not registers: 

        if stk_ba and stk_size: 
            x31 =  stk_ba + stk_size - consts_aarch64.initial_stack_offset 
        elif stk_ba and not stk_size: 
            x31 =  stk_ba +  consts_aarch64.STACK_SIZE - consts_aarch64.initial_stack_offset 
        elif stk_size and not stk_ba: 
            x31 = consts_aarch64.STACK_BASEADDR + stk_size - consts_aarch64.initial_stack_offset 
        else:
            sp = consts_aarch64.STACK_BASEADDR+consts_aarch64.STACK_SIZE-\
                                 consts_aarch64.initial_stack_offset
        registers = Aarch64Registers.get_default_object(LR=exec_eaddr, # LR
                                         SP=sp,
                                         PC=exec_saddr)
      return Configuration.generate_default_config(stk_ba=stk_ba if stk_ba\
                                                    else consts_aarch64.STACK_BASEADDR,
                                                    stk_size=stk_size if stk_size\
                                                    else consts_aarch64.STACK_SIZE,
                                                    registers=registers,
                                                    exec_saddr=exec_saddr,
                                                    exec_eaddr=exec_eaddr, 
                                                   arch='aarch64')


```

`EWS/emu/unicorn/arm32.py`:

```py
import ida_segregs
from EWS.emu.unicorn.generic import * 
import string
from EWS.utils.utils import * 
from EWS.utils import consts_arm
from EWS.stubs.allocators.allocator import *

from EWS.stubs.ELF import ELF
from EWS.stubs.emu.unicorn.sea import UnicornArmSEA
from EWS.utils.configuration import *
from EWS.utils.registers import *
from EWS.asm.assembler import *
import struct




class ArmCorn(Emucorn): 

    def __init__(self,conf):

        super().__init__(conf) 

        # Init engine 
        pinf = proc_inf('arm',conf.exec_saddr)
        self.pinf = pinf
        if pinf['endianness'] == 'little':    
            if pinf['proc_mode'] == 16:
                self.uc = Uc(UC_ARCH_ARM, UC_MODE_THUMB) 
                self.conf.exec_saddr = self.conf.exec_saddr | 1
            elif pinf['proc_mode'] == 32:
                self.uc = Uc(UC_ARCH_ARM, UC_MODE_ARM) 
        elif pinf['endianness'] == 'big':
            if pinf['proc_mode'] == 16:
                self.uc = Uc(UC_ARCH_ARM, UC_MODE_THUMB + UC_MODE_BIG_ENDIAN) 
                self.conf.exec_saddr = self.conf.exec_saddr | 1
            elif pinf['proc_mode'] == 32:
                self.uc = Uc(UC_ARCH_ARM, UC_MODE_ARM + UC_MODE_BIG_ENDIAN) 

        self.endns = pinf['endianness']
        self.pointer_size = 4 

        # Map pages 
        d,r = divmod(self.conf.p_size,0x400) 
        if r: 
            logger.console(LogType.WARN,'[+] invalid page size, using default')
            self.conf.p_size = uc.query(UC_QUERY_PAGE_SIZE)
        Emucorn.do_mapping(self.uc,self.conf)

        
        # Init capstone engine
        if conf.useCapstone:
            from capstone import Cs, CS_ARCH_ARM, CS_MODE_THUMB, CS_MODE_ARM, CS_MODE_LITTLE_ENDIAN, CS_MODE_BIG_ENDIAN
            if pinf['proc_mode'] == 16:
                self.cs=Cs(CS_ARCH_ARM, CS_MODE_THUMB + CS_MODE_LITTLE_ENDIAN if pinf['endianness'] else CS_MODE_THUMB + CS_MODE_BIG_ENDIAN)

            elif pinf['proc_mode'] == 32:
                self.cs=Cs(CS_ARCH_ARM, CS_MODE_ARM + CS_MODE_LITTLE_ENDIAN if pinf['endianness'] else CS_MODE_ARM + CS_MODE_BIG_ENDIAN)
            self.cs.detail=True

        # Setup regs 
        self.setup_regs(self.conf.registers)
        self.pcid = UC_ARM_REG_PC 

        # Init stubs engine 
        if self.conf.s_conf.activate_stub_mechanism:
                self.setup_stub_mechanism()

        self.install_hooks()


        for k,v in self.conf.memory_init.mappings.items():
                self.uc.mem_write(k,v)


        # TODO handle CPU working on two mode
        # TODO handle endianess as well? 
        if pinf['proc_mode'] == 16:
                self.assembler = assemblers['armt'][0]
        elif pinf['proc_mode'] == 32:
                self.assembler = assemblers['arm'][0]

        for k,v in self.conf.patches.items():
            self.patch_mem(k,v) 


        for k,v in self.conf.watchpoints.items():
            self.add_watchpoint(k, v&0xFF,mode=v>>24)



    def install_hooks(self):

        self.uc.hook_add(UC_HOOK_CODE,
                                         self.hook_code,
                                         user_data=self)
        self.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED,
                                         Emucorn.unmp_read,
                                         user_data=self)

        self.uc.hook_add(UC_HOOK_MEM_WRITE_UNMAPPED,
                                         Emucorn.unmp_write,
                                         user_data=self)

        if self.conf.showMemAccess:
            self.uc.hook_add(UC_HOOK_MEM_WRITE,
                                Emucorn.hk_write,
                                self)
            self.uc.hook_add(UC_HOOK_MEM_READ,
                                             Emucorn.hk_read,
                                             self)
    def setup_stub_mechanism(self):

            Emucorn.do_required_mappng(self.uc,
                                   consts_arm.ALLOC_BA,
                                   consts_arm.ALLOC_BA+self.conf.p_size*consts_arm.ALLOC_PAGES,
                                   self.conf.p_size,
                                   UC_PROT_READ | UC_PROT_WRITE,
                                   True,
                                   f"Warning map heap in already mapped area {consts_arm.ALLOC_BA:x}, edit utils/const_arm.py to modify this area")





            self.helper = UnicornArmSEA(emu=self,
                                        allocator=DumpAllocator(consts_arm.ALLOC_BA,
                                        consts_arm.ALLOC_PAGES*self.conf.p_size),
                                        wsize=4)
            self.nstub_obj = ELF.NullStub()
            self.nstub_obj.set_helper(self.helper)
 
            self.stubs = ELF.libc_stubs
            if verify_valid_elf(self.conf.s_conf.orig_filepath):
                        self.reloc_map = get_relocs(self.conf.s_conf.orig_filepath,
                                                    lief.ELF.RELOCATION_ARM.JUMP_SLOT)
                        self.libc_start_main_trampoline = consts_arm.LIBCSTARTSTUBADDR
                        self.stub_PLT()


            for k,v in self.conf.s_conf.tags.items(): 
                        self.tag_func(k, v)


    def nop_insn(self,insn):

        i = get_insn_at(insn.ea) 
        if i.size == 2:
                #TODO add new assembler method instead of const
            if self.endns == 'little':
                self.uc.mem_write(insn.ea,struct.pack('<H',consts_arm.nop_thumb))
            else:
                self.uc.mem_write(insn.ea,struct.pack('>H',consts_arm.nop_thumb))
        elif i.size == 4: 
            if self.endns == 'little':
                self.uc.mem_write(insn.ea,struct.pack('<I',consts_arm.nop))
            else:
                self.uc.mem_write(insn.ea,struct.pack('>I',consts_arm.nop))
        else:
            logger.console(LogType.ERRR,'Invalid insn size')


    def get_retn_insn(self,ea):
        f = ida_funcs.get_func(ea)
        if f == None:
            logger.console(LogType.WARN,'cannot decode function at specified address %x'%ea)
            return 
        i = get_insn_at(f.start_ea) 
        if ida_segregs.get_sreg(f.start_ea,ida_idp.str2reg('T')):
            if self.endns == 'little':
                #TODO: use new assembler feature
                retn = struct.pack('<H',consts_arm.mov_pc_lr_thumb)
            else:
                retn = struct.pack('>H',consts_arm.mov_pc_lr_thumb)
        else:
            if self.endns == 'little':
                retn = struct.pack('<I',consts_arm.mov_pc_lr)
            else:
                retn = struct.pack('>I',consts_arm.mov_pc_lr)
        return retn

    def get_new_stub(self,
                                     stub_func,
                                     stub_type: StubType,
                                     name:str=''):
        stub = ELF.Stub(self.helper,
                                        stub_type=stub_type,
                                        name=name)
        stub.do_it = stub_func
        return stub

    def setup_regs(self,regs):
        """ 
        Setup Emulator's registers using Register object. 

        @param regs: Register object.

        """

        for k,v in consts_arm.reg_map_unicorn.items():

            self.uc.reg_write(v,getattr(regs,k)) 

    def get_regs(self):

            """ 
            Returns a Register object instancied with 
            the current emulator register values. 

            @return Register Object.
            """

            regs = ArmRegisters.create() 
            for k,v in consts_arm.reg_map_unicorn.items():
                setattr(regs,k,self.uc.reg_read(v))
            return regs

    def reset_regs(self):

        """ 
        Reset the Emulator' registers.
        """


        for k,v in consts_arm.reg_map_unicorn.items():
            self.uc.reg_write(v,0)
        

    def isThumb(self) -> bool:

            """ 
            !Indicate if the emulator is currently either in thumb mode or not.

            @return True/False

            """

            # somehow unicorn does not query properly
            # BUG FIXME ?
            return self.pinf['proc_mode'] == 16 or self.uc.query(UC_QUERY_MODE) == 16



    @staticmethod
    def reg_convert(reg_id) -> int:
        """ 
        !Convert register identifier according its type 

        @return the corresponding id 

        """

        if type(reg_id) is str:
            return ArmCorn.str2reg(reg_id)

        elif type(reg_id) is int:
            return ArmCorn.int2reg(reg_id)

        else:
            raise Exception('[reg_convert] unhandled conversion for type %s'%type(reg_id))

    def reg_convert_ns(self,
                       reg_id:int) -> int:

        """ 
        !Class method that converts register identifier according its type 

        @return the corresponding id 

        """


        if type(reg_id) is str:
            return self.str2reg(reg_id)

        elif type(reg_id) is int:
            return self.int2reg(reg_id)

        else:
            raise Exception('[reg_convert] unhandled conversion for type %s'%type(reg_id))

    @staticmethod
    def int2reg(reg_id:int) -> int:

        """ 
        ! Convert the integer register Arm notation to the Unicorn Arm register notation

        @param reg_id The integer notation 

        @return The Unicorn Arm Notation

        """

        if reg_id == 13:
            return UC_ARM_REG_SP

        elif reg_id == 14:
            return UC_ARM_REG_LR

        elif reg_id == 15:
            return UC_ARM_REG_PC

        return UC_ARM_REG_R0 + reg_id



    @staticmethod
    def str2reg(r_str:str) -> int:

        """
        !Convert string notation to Unicorn notation.

        @param str string identifier

        @param unicorn notation

        @param str string identifier

        @param unicorn notation


        """

        return consts_arm.reg_map_unicorn[r_str] 
        

    def get_alu_info(self) -> arm32CPSR : 
        """ 
        !return the CPSR flags 

        @return Arm32CPSR object

        """
        return arm32CPSR.create(self.uc.reg_read(UC_ARM_REG_CPSR))




    def print_registers(self) -> str:

        """ 
        ! build a string with the current register values 
        
        @return a string with the current register values 

        """

        strout = 'Registers:\n'
        for k,v in consts_arm.reg_map_unicorn.items():
            strout += f"{k}={self.uc.reg_read(v):x}" 
         
        return strout



    @staticmethod
    def generate_default_config(
                                                                 path: str = None,
                                                                 arch: str = None,
                                                                 emulator: str = None,
                                                                 p_size: int = None,
                                                                 stk_ba: int = None,
                                                                 stk_size: int = None,
                                                                 autoMap: bool = None,
                                                                 showRegisters: bool = None,
                                                                 exec_saddr: int =None,
                                                                 exec_eaddr: int =None,
                                                                 mapping_saddr: int =None,
                                                                 mapping_eaddr: int =None,
                                                                 segms: list =None,
                                                                 map_with_segs: bool = None,
                                                                 use_seg_perms: bool =None,
                                                                 useCapstone: bool = None,
                                                                 registers: Registers = None,
                                                                 showMemAccess: bool =None,
                                                                 s_conf: StubConfiguration = None,
                                                                 amap_conf: AdditionnalMapping = None,
                                                                 memory_init: AdditionnalMapping =None,
                                                                 color_graph: bool =None,
                                                                 breakpoints: list =None,
                                                                 watchpoints: dict =None) -> Configuration:
            """this method get called by:
                        - ui **emulate_function**
                        - ui **emulate_selection**
            """

            if not registers: 
                if stk_ba and stk_size: 
                        r13 = stk_ba + stk_size - consts_arm.initial_stack_offset 
                elif stk_ba and not stk_size: 
                        r13 = stk_ba +    consts_arm.STACK_SIZE - consts_arm.initial_stack_offset 
                elif stk_size and not stk_ba: 
                        r13 = consts_arm.STACK_BASEADDR + stk_size - consts_arm.initial_stack_offset 
                else:
                        r13 = consts_arm.STACK_BASEADDR+consts_arm.STACK_SIZE-\
                                                                 consts_arm.initial_stack_offset
                registers = ArmRegisters.get_default_object(r13=r13,
                                                                                                            r14=exec_eaddr,
                                                                                                            r15=exec_saddr)

            return Configuration.generate_default_config(arch='arm',stk_ba=stk_ba if stk_ba\
                                                        else consts_arm.STACK_BASEADDR,
                                                        stk_size=stk_size if stk_size\
                                                        else consts_arm.STACK_SIZE,
                                                        registers=registers,
                                                        exec_saddr=exec_saddr,
                                                        exec_eaddr=exec_eaddr)







```

`EWS/emu/unicorn/generic.py`:

```py
import ida_segment
import ida_ua
import idaapi
import ida_idaapi
import ida_funcs
import ida_bytes
import ida_segregs
import ida_idp
import ida_name
import idautils
import ida_dbg
import ida_xref
import ida_kernwin
import idc
import os
import string
from unicorn import * 
from unicorn.arm_const import * 
from unicorn.mips_const import * 
from unicorn.arm64_const import * 
import struct
import hexdump
import math

from EWS.utils.utils import *
from EWS.utils.configuration import Configuration, StubConfiguration
from EWS.emu.emubase import Emulator
from EWS.utils.exec_trace import *
from EWS.utils.configuration import AdditionnalMapping

from EWS.ui.debug_view import *

MAX_INSN_SIZE=8
MAX_EXEC= 0x10000 # max number of executed insn 
FOLLOW_PC= False  #TODO move it to the configuration option

class Emucorn(Emulator):

    def __init__(self,conf):


        super().__init__(conf)

        self.nb_insn=0
        self.running_stubs = dict()

        self.exec_trace = Exec_Trace(self.conf.arch,content=None)
        self.exec_trace.content = {}
    
        self.call_tree = Call_Tree() 
        self.call_tree.content = {}
        self.call_tree_depth = 0

        self.debug_view = None # todo create the reference in EWS_Plugin object

        self.filetype = ida_loader.get_file_type_name()

        self.assembler = None

        # Debugger Variables
        self.stop = False
        self.ignore_end_addr = False

        self.amap = dict()
        self.patches = dict()

        self.watchpoints = dict()

        self.tags = dict()




#---------------------------------------------------------------------------------------------
#
#   EMULATOR Mapping functions
#
#---------------------------------------------------------------------------------------------
    @staticmethod
    def do_required_mappng(uc: Uc,
                           s_ea: int,
                           e_ea:int,
                           p_size:int,
                           perms:int,
                           warn:bool=False,
                           warn_msg:str=''):

        """ !Use this function to avoid page mappings
                that already exist. 
                Usefull when mapping user provided ranges,
                or for small sections that will share pages.    

            @param uc Unicorn Engine 
            @param s_ea Effective Start Address 
            @param e_ea Effective Stop Address
            @param p_size Page Size
            @param perms Permissions on the Page 
            @param warn Alert in case of already existing mapping
            @param warm_msg Message to display in console

        """ 


        b_page = s_ea & ~(p_size -1)

        finally_mem_map = False

        while b_page < e_ea:    

            alrdy_map = False

            for rsta,rsto,rpriv in uc.mem_regions():

                if b_page == rsta:

                    alrdy_map = True
                    break

            if not alrdy_map: 

                logger.console(LogType.INFO,f'Map page {b_page:x}')
                nb_pages, r = divmod(e_ea-b_page,p_size) 
                if r: nb_pages+=1  
                uc.mem_map(b_page,nb_pages*p_size,perms)
                finally_mem_map = True


            b_page += rsto +1  

            if not finally_mem_map and warn:
                logger.console(LogType.WARN,warn_msg)


    def flush(self):

        """ 
        !flush the trace list instructions. Somehow there is a cache issue/leak. 
        this function is executed from the UI when plugin is reset. 

        """

        for i in range(len(self.exec_trace.content.keys())-1):
            try:
                self.exec_trace.addr.pop()
            except:
                pass

    def add_mapping(self,
                    addr:int,
                    mem:bytes,
                    perms:int=UC_PROT_ALL) -> int :
        """ 
            !Create and Write into memory mapping.
             

            @params addr: base address
            @param  mem: content of the mapping
            @params perms : permissions

            @return 0 for Success -1 for Fail
        """

        for rsta,rsto,rpriv in self.uc.mem_regions():

            if addr in range(rsta,rsto):

                logger.console(LogType.WARN,f'Address 0x{addr:x} is already mapped.')
                return -1

        Emucorn.do_required_mappng(self.uc,addr,addr+len(mem),self.conf.p_size,perms)

        self.uc.mem_write(addr,mem) 

        logger.console(LogType.INFO,f'Created new mapping starting at 0x{addr:x}') 

        self.amap[addr] = mem
        
        return 0

    @staticmethod
    def do_mapping(uc: Uc,
                   conf:Configuration):

        """
            !Do required mapping according the 
            configuration object.
                
            @param uc Unicorn Engine reference
            @param conf Configuration Object Reference
            
            
        """

        inf = ida_idaapi.get_inf_structure()
        last_vb = None

        # Maps program segment
        if conf.map_with_segs:

            for seg in conf.segms:

                vbase = Emucorn.do_required_mappng(uc,seg.start_ea, seg.end_ea, conf.p_size, UC_PROT_ALL if not conf.use_seg_perms else seg.perm) 
                uc.mem_write(seg.start_ea,ida_bytes.get_bytes(seg.start_ea,seg.end_ea-seg.start_ea))
                logger.logfile(LogType.INFO,f'Map seg {ida_segment.get_segm_name(seg)}')

        else:

            for seg in get_seg_list():



                vbase=seg.start_ea&~(conf.p_size-1)

                if last_vb == None:

                    nb_pages, r = divmod(seg.end_ea- vbase,conf.p_size) 
                    if nb_pages == 0: 
                        nb_pages = 1
                    elif nb_pages > 0 and r > 0: 
                        nb_pages +=1 

                    try:

                        uc.mem_map(vbase,nb_pages*conf.p_size)
                    except Exception as e:

                        logger.console(LogType.ERRR,f"Map at {vbase:x}  for {nb_pages} returns : {str(e)}")


                    last_vb = vbase + (nb_pages)*conf.p_size

                else:

                    if seg.end_ea > (last_vb):

                        if vbase <= last_vb:
                            vbase = last_vb


                        nb_pages, r = divmod(seg.end_ea- vbase,conf.p_size) 
                        if nb_pages == 0: 
                            nb_pages = 1
                        elif nb_pages > 0 and r > 0: 
                            nb_pages +=1 


                        try:
                            uc.mem_map(vbase,nb_pages*conf.p_size)
                        except Exception as e:
                            logger.console(LogType.ERRR,"mapping at %x  for %d returns : %s"%(vbase,nb_pages,str(e)))


                        last_vb = vbase + (nb_pages)*conf.p_size 

                logger.console(LogType.INFO,'Mapped segment %s [%x:%x]'%(ida_segment.get_segm_name(seg),
                                                                         seg.start_ea,
                                                                         seg.end_ea))
                
                # If segment is tagged as unitialized, skip it 
                if ida_segment.segtype(seg.start_ea) == ida_segment.SEG_BSS:
                    continue 

                try:

                    size = seg.size()


                    # get_bytes API does not allow to get more than 0xffffffff bytes. 
                    # nonetheless such mapping should be discarded ?

                    if seg.size() > (math.pow(2,32) -1):     
                        logger.console(LogType.WARN,f"Segment size is too big: {size:x}, restraining to 4GB")
                        size =  int(math.pow(2,32) - 1) & 0xffffffff

                    uc.mem_write(seg.start_ea,ida_bytes.get_bytes(seg.start_ea,size))
                    
                except Exception as e:

                    logger.console(LogType.ERRR,"writing segment %x to %x content returns : %s"%(seg.start_ea,seg.end_ea,str(e)))


        #Map user provided areas 
        for m_ea,content in conf.amap_conf.mappings.items():

            idaapi.show_wait_box("Mapping user content")

            Emucorn.do_required_mappng(uc,m_ea,m_ea+len(content),conf.p_size,UC_PROT_ALL)
            uc.mem_write(m_ea,content) 

            logger.console(LogType.INFO,'[%s] Additionnal mapping for data at %8X'%('Emucorn',m_ea)) 

            idaapi.hide_wait_box()

        idaapi.show_wait_box("Map stack") 
        stk_p,r = divmod(conf.stk_size,conf.p_size)

        if r: stk_p+=1 

        #uc.mem_map(conf.stk_ba,stk_p*conf.p_size)
        Emucorn.do_required_mappng(uc,
                                   conf.stk_ba,
                                   conf.stk_ba+stk_p*conf.p_size,
                                   conf.p_size,
                                   UC_PROT_READ | UC_PROT_WRITE,
                                   True,
                                   f"Warning map stack in already mapped area {conf.stk_ba}, edit consts file for corresponding architecture")
    




        logger.console(LogType.INFO,' [%s] mapped stack at 0x%.8X '%('Emucorn',conf.stk_ba))
        
        idaapi.hide_wait_box()

        logger.console(LogType.INFO, "All IDB segment has been successfully mapped in emulator")


#---------------------------------------------------------------------------------------------
#
#Emulator reg/mem accesses 
#
#---------------------------------------------------------------------------------------------


    def mem_read(self,
                 addr:int,
                 size:int) -> bytes:

        """
        !mem_read

        @param addr Address to read from
        @param size Size to read

        @return bytes with memory content
    
        """

        return self.uc.mem_read(addr,size)

    def mem_write(self,
                  addr:int,
                  data:bytes) -> None:

        """
        !mem_write

        @param addr Address to write to
        @param size Size of the data to write 

        @return bytes with memory content
        """

        self.uc.mem_write(addr,data)

    def reg_read(self,
                 r_id) -> int: 

        """
        !reg_read

        @param r_id (string/int) register identifier 
        
        @return register value

        """

        return self.uc.reg_read(r_id)

    def reg_write(self,
                  r_id,
                  value:int) -> None:

        """ 

        !reg_write

        @param r_id (string/int) register identifier
        @param value register value 


        """

        self.uc.reg_write(r_id,value)


#---------------------------------------------------------------------------------------------
#
#   Hooking events functions 
#
#---------------------------------------------------------------------------------------------
    @staticmethod
    def unmp_read(uc:Uc,
                  access: int,
                  addr: int,
                  value:int,
                  size:int,
                  user_data) -> None:
        """
        ! unmp_read Unicorn Hook Declaration for unmapped address. 

        @param Unicorn Egine
        @param access Access Fashion
        @param addr address which raised the Fault
        @param value ignore_end_addr
        @param size size of the read operation 
        @param user_data Reference to the object


        """

        _self = user_data
        
        logger.console(LogType.WARN,'[!] Read Access Exception',
                       'Cannot read 0x%.8X'%addr,
                       'for size %d (reason: unmapped page)'%size)
        logger.console(LogType.WARN,'[!] Fault instruction at %x'%_self.helper.get_pc())

        conf = _self.conf

        if conf.autoMap:

            base_addr = addr & ~(conf.p_size-1)
            
            uc.mem_map(base_addr,conf.p_size)
            uc.mem_write(base_addr,b'\xff'*conf.p_size)

            logger.console(LogType.INFO,'[*] Automap: added page 0x%.8X'%base_addr)

            return True

        logger.console(LogType.ERRR,'Automap is not enabled. Aborting()')
        return False


    @staticmethod
    def unmp_write(uc:Uc,
                   access:int,
                   addr:int,
                   size:int,
                   value:int,
                   user_data):

        """
        ! unmp_write Unicorn Hook Declaration for unmapped address. 

        @param Unicorn Egine
        @param access Access Fashion
        @param addr address which raised the Fault
        @param value ignore_end_addr
        @param size size of the write operation 
        @param user_data Reference to the object


        """
   
        _self = user_data

        logger.console(LogType.WARN,
                       '[!] Write Access Excpetion:'
                       'cannot write value 0x%.8X at address 0x%.8X'%(value,addr),
                       '(reason: unmapped page)')

        logger.console(LogType.WARN,'[!] Fault instruction at %x'%_self.helper.get_pc())

        conf = _self.conf

        if conf.autoMap:

            base_addr = addr & ~(conf.p_size-1)

            try:
                uc.mem_map(base_addr,conf.p_size)
            except UcError:
                logger.console(LogType.WARN,'[*] Automap not supported for this arch')
                return False
            
            logger.console(LogType.INFO,'[*] Automap: added page 0x%.8X'%base_addr)

            return True


        logger.console(LogType.ERRR,'Automap is not enabled. Aborting()')

        return False


    @staticmethod
    def hk_read(uc:Uc,
                access:int,
                addr:int,
                size:int,
                value:int,
                user_data):
        """
        ! hk_read Unicorn Hook Declaration for memory access. 

        @param Unicorn Egine
        @param access Access Fashion
        @param addr address which is accessed
        @param value ignore_end_addor
        @param size size of the read operation 
        @param user_data Reference to the object


        """


        _self= user_data

        out= ': [read]  '
        out +='with size: %d '%size
        out +=hexdump.hexdump(uc.mem_read(addr,size),result='return').replace('00000000','')

        _self.exec_trace.add_instruction(addr=addr,
                                        assembly=out,
                                        regs=_self.get_regs(),
                                        color=get_insn_color(addr),
                                        tainted=False)

        logger.logfile(LogType.INFO,out) 



    @staticmethod
    def hk_write(uc:Uc,
                 access:int,
                 addr:int,
                 size:int,
                 value:int,
                 user_data):
        """
        ! hk_read Unicorn Hook Declaration for memory access. 

        @param Unicorn Egine
        @param access Access Fashion
        @param addr address which is accessed
        @param value ignore_end_addor
        @param size size of the read operation 
        @param user_data Reference to the object

        """

        _self = user_data


        out = ': [write] '
        out += f'with size {size} '
        out += hexdump.hexdump(int_to_bytes(value,size),
                               result='return').replace('00000000','')

        _self.exec_trace.add_instruction(addr=addr,
                                        assembly=out,
                                        regs=_self.get_regs(),
                                        color=get_insn_color(addr),
                                        tainted=False)

        logger.logfile(LogType.INFO,out) 


    def hook_code(self,uc:Uc,
                  addr:int,
                  size:int,
                  user_data): 

        """
        ! hook_code Unicorn Hook Declaration for memory access. 

        @param uc Unicorn Egine
        @param addr address which is accessed
        @param size size of the read operation 
        @param user_data Reference to the object

        """
        asm = ''

        if self.stop: 

            uc.emu_stop()

            logger.console(LogType.INFO,f'Breakpoint at 0x{addr:x} reached.',
            f'{self.nb_insn} instruction(s) executed.')

            self.nb_insn = 0

            return False

            

        elif addr in self.running_stubs.keys():
            
            try:

                self.running_stubs[addr].do_it()

                s_name = self.running_stubs[addr].name
                
                asm = log = f'0x{addr}:\t{s_name}'



            except Exception as e:
                
                logger.console(LogType.WARN,'Error in stub, aborting')

                uc.emu_stop()

                logger.console(LogType.ERRR,'backtrace:\n',e.__str__())

                return False
        
        elif addr in self.user_breakpoints or ida_dbg.exist_bpt(addr):

            self.stop = True

                        
        self.color_map[addr] = get_insn_color(addr)


        if asm == '':
                        

                asm = get_captsone_repr(self,addr)
                log = build_insn_repr(self,addr)
    
        trace_id = self.exec_trace.add_instruction(addr=addr,
                                            assembly=asm,
                                            regs=self.get_regs(),
                                            color=get_insn_color(addr),
                                            tainted=False)


         
        """
        TODO: 

        if is_call_insn(addr) or is_ret_addr(addr): 
            if is_call_insn(addr):
                self.calltree_depth +=1 
            else:
                self.call_tree_depth -=1 

            self.calltree[self.nb_insn] = {}
            self.calltree[self.nb_insn]['addr'] = addr




        """
       


        logger.logfile(LogType.INFO,log)


        self.last_pc = self.helper.get_pc()

        if FOLLOW_PC:
            
            ida_kernwin.jumpto(self.last_pc)
        
        if self.nb_insn >= self.conf.max_insn:

            logger.console(LogType.WARN,
                          f"Execution reach the max number of insn {self.conf.max_insn}")

            self.stop = True

            self.nb_insn = 0

            return True

        self.nb_insn+=1
        return True


#---------------------------------------------------------------------------------------------
#  STUB MECHANISM
#---------------------------------------------------------------------------------------------

    def stub_ELF_sym(self,
                     ea: int,
                     stub_func,
                     name:str=''):

        """
            !stub_elf_sym stub the function given a effective address.  

            @param ea Effective Address in the .plt
            @param stub Stub Object 
            @param name Symbol of the function
        """

        self.stub_func_addr(ea,
                            stub_func,
                            stub_type=StubType.BUILTIN,
                            name=name)
        
        logger.logfile(LogType.INFO,f"{name} is now stubbed at {ea:x}")


    def stub_PE_sym(self,
                    ea:int,
                    stub_func,
                    name: str = ''):

        """
            !stub_elf_sym stub the function given a effective address.  

            @param ea Effective Address in the .plt
            @param stub Stub Object 
            @param name Symbol of the function
        """



        stub =    self.get_new_stub(stub_func,
                                    stub_type=StubType.BUILTIN,
                                    name=name)
        self.running_stubs[ea] = stub
        self.nop_insn(ea)
        self.stubbed_bytes[ea] = get_insn_bytecode(ea)

        logger.logfile(LogType.INFO,f"{name} is now stubbed at {ea:x}")



    def stub_sym(self,
                 ea: int,
                 stub_func,
                 name: str = ''):

        """
            !stub the right way according the architecture.

            @param ea Effective Address in the .plt
            @param stub Stub Object 
            @param name Symbol of the function
        """

        if hasattr(self,'loader_type'):
            if self.loader_type == LoaderType.PE:
                self.stub_PE_sym(ea,stub_func,name)
                return

        # default behavior is based on ELF format. 
        self.stub_ELF_sym(ea,
                          stub_func,
                          name)




    def stub_func_addr(self,
                       ea:int,
                       stub_func,
                       stub_type:StubType,
                       name:str=''):

        """
            stub a function by it address.
            a return instruction will replace
            the first instruction of the targeted 
            function.
            It creates a new stub object recorded 
            in running_stubs list.

            @param ea Effective Address in the .plt
            @param stub Stub Object 
            @param stub_type Stub Type
            @param name Symbol of the function
        """

        if not ida_funcs.get_func(ea):
            logger.logfile(LogType.WARN,"%s %x not a function"%\
                           (sys._getframe().f_code.co_name,
                            ea))
            return

        if stub_type == StubType.NULL: 
            ea = ida_funcs.get_func(ea).start_ea

        stub =    self.get_new_stub(stub_func,
                                    stub_type=stub_type,
                                    name=name)
        self.running_stubs[ea] = stub
        self.uc.mem_write(ea,self.get_retn_insn(ea))

        self.stubbed_bytes[ea] = get_insn_bytecode(ea)




    def unstub_func_addr(self,
                         ea: int):

        """
            !unstub_func_addr sunstubbing consists in :
                conf cleaning
                removing stub object from stub list
                repatching memory with original bytecode

            @param ea



        """

        if ea in self.running_stubs.keys():

            """
            if self.running_stubs[ea].stub_type == StubType.TAG:
                self.conf.remove_tag(ea)
            elif self.running_stubs[ea].stub_type == StubType.NULL:
                self.conf.remove_null_stub(ea)
            """

            del self.running_stubs[ea]

            self.helper.mem_write(ea,self.stubbed_bytes[ea])

            del self.stubbed_bytes[ea]


    def unstub_all(self):

        """
            !unstub_all remove all stubs for symbols and user defined stubs

        """

        for ea, v in self.running_stubs.items():
            if clean_configuration:
                if v.stub_type == StubType.TAG:
                    self.conf.remove_tag(ea)
                elif v.stub_type == StubType.NULL:
                    self.conf.remove_null_stub(ea)


            del self.running_stubs[ea]
            del self.stubbed_bytes[ea]


    def stub_PLT(self):

        """
            stubs PLT
        """

        for k,v in self.reloc_map.items():

            # TODO change by ida_xref.get_first_dref_to(v) ? 
            xref_g = idautils.XrefsTo(v)

            try:

             while True:

                xref = next(xref_g)

                if k in self.stubs.keys():

                    self.stubs[k].set_helper(self.helper)
                    self.stub_ELF_sym(xref.frm,self.stubs[k].do_it,k)

                elif k == '__libc_start_main':

                        logger.logfile(LogType.INFO,'libc_start_main stubbed!')
                        self.uc.mem_write(v,
                                        int.to_bytes(self.libc_start_main_trampoline,
                                        8 if idc.__EA64__ else 4,
                                     'little'))

                else:

                     if self.conf.s_conf.auto_null_stub:

                            self.add_null_stub(xref.frm)

            except StopIteration:

                pass

        for s_ea in self.conf.s_conf.nstubs.keys():
                self.add_null_stub(s_ea)

        for k,v in self.conf.s_conf.tags.items():
            self.tag_func(k,v)



    def stub_PE(self):

        """
            stubs PE
        """

        for k,v in self.reloc_map.items():

            # TODO change by ida_xref.get_first_dref_to(v) ? 
            xref_g = idautils.XrefsTo(v)

            try:

             while True:

                xref = next(xref_g)

                if k in self.stubs.keys():

                    self.stubs[k].set_helper(self.helper)
                    self.stub_PE_sym(xref.frm,self.stubs[k].do_it,k)


                else:

                     if self.conf.s_conf.auto_null_stub:
                         self.nop_insn(xref.frm)

            except StopIteration:

                pass

        for s_ea in self.conf.s_conf.nstubs.keys():
                self.add_null_stub(s_ea)

        for k,v in self.conf.s_conf.tags.items():
            self.tag_func(k,v)





    def add_null_stub(self,
                      ea:int):

        """
            Null stubs allow to directly bypass
            a function call.

            @param Function Address to Stub with a direct return sequence
        """

        if ea in self.running_stubs.keys():
            self.unstub_func_addr(ea)

        self.stub_func_addr(ea,
                            self.nstub_obj.do_it,
                            stub_type=StubType.NULL)

    def remove_null_stub(self,
                         ea:int):

        """ 
        !remove_null_stub remove a null stub given its address.

        @param ea Address where the stub was registred.
        """

        self.unstub_func_addr(ea)
        

    def add_custom_stub(self,
                        ea: int,
                        func,
                        name:str='user stub'):

        """
            !add_custom_stub Custom stub allows the user to define a function
            that will be called instead a stubbed address / symbols.
        
            @param Address of the function 
            @param function function declaration (in python) 
            @param name associated Name

        """

        stub = self.get_new_stub(func,StubType.USER,name=name)
        if ea in self.running_stubs.keys():
            logger.console(LogType.WARN,"Function at %x is already stubbed."
                           "Overwritting stub with new tag"%ea)
            self.unstub_func_addr(ea)

        self.stub_func_addr(ea,stub.do_it,stub_type=StubType.USER)
        logger.console(LogType.INFO,'[+] %s is now stubbed'%get_func_name(ea))


    def remove_custom_stub(self,
                           ea:int):

        """ 
        !remove_custom_stub remove a user provided stub given its address

        @param ea Effectiva Address where the stub was registred.
        """

        self.unstub_func_addr(ea)


    def tag_func(self,
                 ea: int,
                 stub_name: str):

        """
            !tag_func Function tagging consists in associating
            a function to a stub. If you find a memcpy like
            function, you can tag it with the internal memcpy
            stub. You will then be able to track its argument.

            @param ea Effective Address of the target function 
            @param stub_name User provided name  


        """

        if not stub_name in self.stubs.keys():
            logger.console(LogType.WARN,'[!] %s is not among available stubs. '%stub_name,
                           'Please refers to list_stubs command to get the list of available stubs')
            return

        if ea in self.running_stubs.keys():
            logger.console(LogType.WARN,f"Function at {ea:x} is already stubbed. ",
                               f'Overwritting stub with new tag {stub_name}')
            self.unstub_func_addr(ea)

        else:
                self.stubs[stub_name].set_helper(self.helper)

        self.stub_func_addr(ea,self.stubs[stub_name].do_it,stub_type=StubType.TAG,name=stub_name)

        logger.console(LogType.INFO,'[+] %x is now stubbed with %s function'%(ea,stub_name))




    def remove_tag(self,
                   ea:int):
        

        """ 
        !remove_tag remove a tag association given its Effective Address

        @param ea Address 

        """

        self.unstub_func_addr(ea)






#---------------------------------------------------------------------------------------------
#
# DEBUGGING FUNCTION
#
#---------------------------------------------------------------------------------------------


    def start(self,
              cnt: int = 0,
              saddr: int = -1):
        """
            !This function launch unicorn **start** function. 
            It will run a limited instructions from the start address.

            @param cnt Maximum instruction to be executed. 
            @param saddr Address of the first instruction to be executed.
        """

        self.nb_insn = 0

        if saddr == -1:
            saddr = self.conf.exec_saddr


        if self.isThumb():

            saddr |= 1
        
        if self.ignore_end_addr:

            end_addr = 0xffffffffffffffff

        else: 

            end_addr = self.conf.exec_eaddr

        try:

            idaapi.show_wait_box("Running...")

            self.uc.emu_start(saddr,end_addr,timeout=0,count=cnt)
            self.is_running = True

        except UcError as e:

            logger.console(LogType.ERRR,'Error in unicorn engine')
            raise e

        except Exception as e:

            logger.console(LogType.WARN,
                          '[!] Exception in program : %s' % e.__str__())
        finally:

            idaapi.hide_wait_box()

        # For testing purpose
        """ 
        # DUMP HERE

        with open("/tmp/exec_trace_serial.txt",'w+') as fout: 
            json.dump(self.exec_trace,fp=fout,cls=Exec_Trace_Serializer)
        """
       

        




    def step_n(self,
               n:int) -> None:

        """ 
        !step_n 

        @param n Number of instructions to be executed. 

        """

        if self.stop: 

            insn = get_insn_at(self.helper.get_pc())
            pc = self.helper.get_pc() + insn.size
            self.stop = False

        else: 

            pc = self.helper.get_pc()

        pc = self.helper.get_pc()

        if pc >= self.conf.exec_eaddr and not self.ignore_end_addr: 

            uret = ida_kernwin.ask_yn(True,
            f"Execution reached the limit address specified in configuration {self.conf.exec_eaddr:x}"\
                    ", do you want to continue?")   
            if uret == ida_kernwin.ASKBTN_YES: 
                self.ignore_end_addr = True

        self.start(cnt=n,saddr=pc)


    def step_in(self):

        """
        !step_in executes a single instruction 

        """

        self.step_n(1)

    def continuee(self):

        """ 
        !continue 

        """

        self.step_n(0)



    def step_over(self):

        """
        !step_over Try to detect the target using IDA API.
        Use IDA breakpoint to notify the user that breakpoint are added (there is no wizard)
        It will then have to remove it if he/she restarts the program.
        It handles call, direct jump, and jump tables


        """

        insn = get_insn_at(self.helper.get_pc())
        bp_addr = []

        if ida_idp.is_call_insn(insn) or ida_idp.has_insn_feature(insn.itype,ida_idp.CF_STOP):
            self.uc.emu_start(insn.ea,insn.ea+insn.size,0,0)
        elif ida_idp.is_indirect_jump_insn(insn):
            logger.console(LogType.WARN,
                           "Indirect jump incompatible with step_over feature.",
                           "Please do it manually")
        else:
            self.step_in()

    def add_watchpoint(self,base_addr, rang, mode=0x3):

        """ 
        !add_watchpoint Enable a watchpoint to track data during execution.
        
        @param base_addr address of the first byte of the data to be tracked.
        @param rang size of the data to be tracked.
        @param mode READ, WRITE or BOTH

        """

        def hk_read_wp(uc,access,addr,size,value,user_data):
            if addr >= base_addr and addr < base_addr + rang:
                logger.console(LogType.INFO,"[Watchpoint] read access for addr " 
                               "%x reached at pc %x"% (addr,self.helper.get_pc()))

        def hk_write_wp(uc,access,addr,size,value,user_data):

            if addr >= base_addr and addr < base_addr + rang:
                logger.console(LogType.INFO,"[Watchpoint] write access for addr " 
                               "%x reached at pc %x"% (addr,self.helper.get_pc()))

        if mode & 0x1:

            self.uc.hook_add(UC_HOOK_MEM_READ,
                       hk_read_wp,
                       self)
            logger.console(LogType.INFO,"Add read watchpoint "
                           "for [%x: %x]"%(base_addr,(base_addr+rang)))
        if (mode >> 1) & 0x1:
            self.uc.hook_add(UC_HOOK_MEM_WRITE,
                       hk_write_wp,
                       self)

            logger.console(LogType.INFO,"Add write watchpoint "
                           "for [%x: %x]"%(base_addr,(base_addr+rang)))

        self.watchpoints[base_addr]= mode << 24 | rang 

    def reset_color_graph(self):
        pass



    def patch_insn(self,
                   addr:int,
                   asm:bytes) -> None:


        """ 
        !patch_insn Patch instruction(s) with the bytecode

        @param addr Effective Address to apply the patch from 
        @param asm  compiled assebmly. 
         
        """


        bytecode = self.assembler.assemble(asm,addr)
        self.uc.mem_write(addr,bytecode)
        logger.console(LogType.INFO,f"Instruction(s) at {addr:x} patched")
        self.patches[addr] = bytecode

        # This handles use case where new bytecode is bigger than 
        # the original one. Stop address might not be detected
        # causing execution drift.
        if addr >= self.conf.exec_saddr: 
            if addr + len(bytecode) > self.conf.exec_eaddr: 
                self.conf.exec_eaddr = addr + len(bytecode) 


    def isThumb(self) -> bool:

        """ 
        ! necessary for arm32 architecture.
        """

        return False


    def extract_current_configuration(self) -> Configuration:


        cur_nstubs = dict()
        cur_tagstub = dict() 

        for ea,s in self.running_stubs.items(): 
            if s.stub_type == StubType.TAG: 
                cur_tagstub[ea] = s.name 
            elif s.stub_type == StubType.NULL:
                cur_nstubs[ea] = s 

            


        return Configuration(
                 path=self.conf.path,
                 arch=self.conf.arch,
                 emulator=self.conf.emulator,
                 p_size=self.conf.p_size,
                 stk_ba=self.conf.stk_ba,
                 stk_size=self.conf.stk_size,
                 autoMap=self.conf.autoMap,
                 showRegisters=self.conf.showRegisters,
                 exec_saddr=self.conf.exec_saddr,
                 exec_eaddr=self.conf.exec_eaddr,
                 mapping_saddr=self.conf.mapping_saddr,
                 mapping_eaddr=self.conf.mapping_eaddr,
                 segms=self.conf.segms,
                 map_with_segs=self.conf.map_with_segs,
                 use_seg_perms=self.conf.use_seg_perms,
                 useCapstone=self.conf.useCapstone,
                 registers=self.get_regs(),
                 showMemAccess=self.conf.showMemAccess,
                 s_conf=StubConfiguration(nstubs={**self.conf.s_conf.nstubs, **cur_nstubs},
                                            tag_func_tab = self.conf.s_conf.tag_func_tab,
                                            activate_stub_mechanism=self.conf.s_conf.activate_stub_mechanism,
                                            orig_filepath=self.conf.s_conf.orig_filepath,
                                            custom_stubs_file=self.conf.s_conf.custom_stubs_file,
                                            auto_null_stub=self.conf.s_conf.auto_null_stub,
                                            tags={**self.conf.s_conf.tags,**cur_tagstub}),
                 amap_conf=AdditionnalMapping({**self.conf.amap_conf.mappings ,**self.amap}),
                 memory_init=self.conf.memory_init,
                 color_graph=self.conf.color_graph,
                 breakpoints=self.user_breakpoints,
                 watchpoints=self.watchpoints, #TODO
                 patches= {**self.patches, ** self.conf.patches}, #TODO
                 max_insn=0x10000)





```

`EWS/emu/unicorn/mipsl32.py`:

```py
from EWS.emu.unicorn.generic import * 
import string
from EWS.utils.utils import * 
# from unicorn.mips_const import * 
from EWS.stubs.allocators.allocator import *
from EWS.stubs.ELF import ELF
import EWS.stubs.emu.unicorn.sea 
import ida_ua
import struct


import idautils

class MipsCorn(Emucorn): 

  def __init__(self,conf):

    self.conf = conf 
    pinf=proc_inf('mips',conf.exec_saddr)
    if pinf['proc_mode'] == 16:
      logger.console(LogType.ERRR,'[!] MIPS on unicorn does not support 16bit mode') 
      raise ConfigExcption('Invalid Proc Mode')
    if  pinf['endianness'] == 'little':
      self.uc = Uc(UC_ARCH_MIPS,UC_MODE_MIPS32+UC_MODE_LITTLE_ENDIAN)  
    elif pinf['endianness'] == 'big':
      self.uc = Uc(UC_ARCH_MIPS,UC_MODE_MIPS32+UC_MODE_BIG_ENDIAN)  
    self.endns = pinf['endianness']
    self.pointer_size = 4 


    r,d = divmod(self.conf.p_size,0x1000)
    if d:
      logger.console(LogType.WARN,'[!] MIPS module requires page aligned with 0x1000')
      self.conf.p_size = uc.query(UC_QUERY_PAGE_SIZE)
    stk_p = Emucorn.do_mapping(self.uc,self.conf)

    if conf.useCapstone:
      from capstone import Cs, CS_ARCH_MIPS, CS_MODE_MIPS32, CS_MODE_LITTLE_ENDIAN, CS_MODE_BIG_ENDIAN
      if pinf['endianness'] == 'little':
        self.cs=Cs(CS_ARCH_MIPS, CS_MODE_MIPS32 + CS_MODE_LITTLE_ENDIAN)
      elif pinf['endianness'] == 'big': 
        self.cs=Cs(CS_ARCH_MIPS, CS_MODE_MIPS32 + CS_MODE_BIG_ENDIAN)
      self.cs.detail=True

    self.setup_regs(stk_p)
    self.pcid = UC_MIPS_REG_PC

    for s_ea in conf.s_conf.nstubs.keys():
      self.add_nullstub(s_ea)
      
    if self.conf.s_conf.use_user_stubs or self.conf.s_conf.stub_pltgot_entries: 
      self.uc.mem_map(consts_mips.ALLOC_BA,conf.p_size*consts_mips.ALLOC_PAGES,UC_PROT_READ | UC_PROT_WRITE)
      if pinf['endianness'] == 'little':
        self.helper = stubs.emu.unicorn.sea.UnicornMipslSEA(uc=self.uc,
                                    allocator=DumpAllocator(consts_mips.ALLOC_BA,consts_mips.ALLOC_PAGES*conf.p_size),
                                    wsize=4)
      else:
        self.helper = stubs.emu.unicorn.sea.UnicornMipsbSEA(uc=self.uc,
                                    allocator=DumpAllocator(consts_mips.ALLOC_BA,consts_mips.ALLOC_PAGES*conf.p_size),
                                    wsize=4)
                                  
      logger.console(LogType.INFO,'[%s] fake allocator ready to use.'%'MipsCorn') 
       
        

    self.breakpoints= dict()
    self.custom_stubs = dict()

    if self.conf.s_conf.stub_pltgot_entries: 
      if pinf['endianness'] == 'little':      
        self.stubs = ELF.libc_stubs_mipsl
      else:
        self.stubs = ELF.libc_stubs_mipsb
      self.stubbit()
  
    self.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED,
                     Emucorn.unmp_read,
                     user_data=self.conf)


    self.uc.hook_add(UC_HOOK_CODE,
                     self.hook_code,
                     user_data=self.conf)
        
    self.uc.hook_add(UC_HOOK_MEM_WRITE_UNMAPPED,
                     Emucorn.unmp_write,
                     user_data=self.conf)

    if self.conf.showMemAccess:
      self.uc.hook_add(UC_HOOK_MEM_WRITE,
                self.hk_write,
                self.conf)
      self.uc.hook_add(UC_HOOK_MEM_READ,
                       self.hk_read,
                       self.conf)


  def stubbit(self):
    """ The choice here is to stub all xref 
        of the symbols that belong to extern section 
        plus that are used through call type insn.
        Other choice, could be to directly load trampoline
        addr to the extern section, but this requires to 
        properly set $gp register. (Canonical value for this
        register can be found using readelf -A command.
    """

    s = ida_segment.get_segm_by_name('extern') 
    if s == None:
      print('[!] extern section not found, stubs mechanism not compatible with such binary')
      return
    fstubbednb = 0
    f = ida_funcs.get_next_func(s.start_ea)
    insn = ida_ua.insn_t()
    while f.start_ea < s.end_ea:
      fname = ida_name.get_ea_name(f.start_ea)
      if fname in self.stubs.keys():
        fstubbednb += 1
        # Assign Helper
        self.stubs[fname].set_helper(self.helper)
        xref_g = idautils.XrefsTo(f.start_ea)
        try:
          while True:
            xref = next(xref_g)
            ida_ua.decode_insn(insn,xref.frm)
            if ida_idp.is_call_insn(insn): 
              self.uc.mem_write(xref.frm,struct.pack('>I',consts_mips.nop))
              self.breakpoints[xref.frm] = fname 
              logger.console(LogType.INFO,'[+] %s is not stubbed at %8X'%(fname,xref.frm))
        except StopIteration: 
          pass
      f = ida_funcs.get_next_func(f.start_ea)
      if f == None: 
        break

    return fstubbednb 
 
 

  def setup_regs(self,stk_p):
    self.uc.reg_write(UC_MIPS_REG_AT, self.conf.registers.at)
    #arguments)
    self.uc.reg_write(UC_MIPS_REG_A0, self.conf.registers.a0)
    self.uc.reg_write(UC_MIPS_REG_A1, self.conf.registers.a1)
    self.uc.reg_write(UC_MIPS_REG_A2, self.conf.registers.a2)
    self.uc.reg_write(UC_MIPS_REG_A3, self.conf.registers.a3)
    # saved)
    self.uc.reg_write(UC_MIPS_REG_S0, self.conf.registers.s0)
    self.uc.reg_write(UC_MIPS_REG_S1, self.conf.registers.s1)
    self.uc.reg_write(UC_MIPS_REG_S2, self.conf.registers.s2)
    self.uc.reg_write(UC_MIPS_REG_S3, self.conf.registers.s3)
    self.uc.reg_write(UC_MIPS_REG_S4, self.conf.registers.s4)
    self.uc.reg_write(UC_MIPS_REG_S5, self.conf.registers.s5)
    self.uc.reg_write(UC_MIPS_REG_S6, self.conf.registers.s6)
    self.uc.reg_write(UC_MIPS_REG_S7, self.conf.registers.s7)
    # temporary)
    self.uc.reg_write(UC_MIPS_REG_T0, self.conf.registers.t0)
    self.uc.reg_write(UC_MIPS_REG_T1, self.conf.registers.t1)
    self.uc.reg_write(UC_MIPS_REG_T2, self.conf.registers.t2)
    self.uc.reg_write(UC_MIPS_REG_T3, self.conf.registers.t3)
    self.uc.reg_write(UC_MIPS_REG_T4, self.conf.registers.t4)
    self.uc.reg_write(UC_MIPS_REG_T5, self.conf.registers.t5)
    self.uc.reg_write(UC_MIPS_REG_T6, self.conf.registers.t6)
    self.uc.reg_write(UC_MIPS_REG_T7, self.conf.registers.t7)
    self.uc.reg_write(UC_MIPS_REG_T7, self.conf.registers.t8)
    self.uc.reg_write(UC_MIPS_REG_T7, self.conf.registers.t9)
    # division )
    self.uc.reg_write(UC_MIPS_REG_HI, self.conf.registers.hi)
    self.uc.reg_write(UC_MIPS_REG_LO, self.conf.registers.lo)
    # return values)
    self.uc.reg_write(UC_MIPS_REG_V0, self.conf.registers.v0)
    self.uc.reg_write(UC_MIPS_REG_V1, self.conf.registers.v1)
    # exec )
    self.uc.reg_write(UC_MIPS_REG_GP, self.conf.registers.gp)
    self.uc.reg_write(UC_MIPS_REG_FP, self.conf.registers.fp)
    if self.conf.registers.sp in range(self.conf.stk_ba,self.conf.stk_ba+stk_p*self.conf.p_size):
      self.uc.reg_write(UC_MIPS_REG_SP,self.conf.registers.sp)
    else:
      warn = '[%s] SP value does not belong to the stack'%'MipsCorn'
      warn += 'using default address : %8X'%(self.conf.stk_ba+stk_p*self.conf.p_size-4)
      logger.console(LogType.WARN,warn)
      self.uc.reg_write(UC_MIPS_REG_SP,self.conf.stk_ba+stk_p*self.conf.p_size-4)
    self.uc.reg_write(UC_MIPS_REG_RA, self.conf.registers.ra)
    # misc (kernel)
    self.uc.reg_write(UC_MIPS_REG_K0, self.conf.registers.k0)
    self.uc.reg_write(UC_MIPS_REG_K1, self.conf.registers.k1)




  def reset_regs(self):
    self.uc.reg_write(UC_MIPS_REG_AT, 0)
    #arguments)
    self.uc.reg_write(UC_MIPS_REG_A0, 0)
    self.uc.reg_write(UC_MIPS_REG_A1, 0)
    self.uc.reg_write(UC_MIPS_REG_A2, 0)
    self.uc.reg_write(UC_MIPS_REG_A3, 0)
    # saved)
    self.uc.reg_write(UC_MIPS_REG_S0, 0)
    self.uc.reg_write(UC_MIPS_REG_S1, 0)
    self.uc.reg_write(UC_MIPS_REG_S2, 0)
    self.uc.reg_write(UC_MIPS_REG_S3, 0)
    self.uc.reg_write(UC_MIPS_REG_S4, 0)
    self.uc.reg_write(UC_MIPS_REG_S5, 0)
    self.uc.reg_write(UC_MIPS_REG_S6, 0)
    self.uc.reg_write(UC_MIPS_REG_S7, 0)
    # temporary)
    self.uc.reg_write(UC_MIPS_REG_T0, 0)
    self.uc.reg_write(UC_MIPS_REG_T1, 0)
    self.uc.reg_write(UC_MIPS_REG_T2, 0)
    self.uc.reg_write(UC_MIPS_REG_T3, 0)
    self.uc.reg_write(UC_MIPS_REG_T4, 0)
    self.uc.reg_write(UC_MIPS_REG_T5, 0)
    self.uc.reg_write(UC_MIPS_REG_T6, 0)
    self.uc.reg_write(UC_MIPS_REG_T7, 0)
    # division )
    self.uc.reg_write(UC_MIPS_REG_HI, 0)
    self.uc.reg_write(UC_MIPS_REG_LO, 0)
    # return values)
    self.uc.reg_write(UC_MIPS_REG_V0, 0)
    self.uc.reg_write(UC_MIPS_REG_V1, 0)
    # exec )
    self.uc.reg_write(UC_MIPS_REG_GP, 0)
    self.uc.reg_write(UC_MIPS_REG_FP, 0)
    self.uc.reg_write(UC_MIPS_REG_RA, 0)
    self.uc.reg_write(UC_MIPS_REG_SP, 0)
    self.uc.reg_write(UC_MIPS_REG_SP, 0)
    self.uc.reg_write(UC_MIPS_REG_PC, 0)
  

    self.uc.reg_write(UC_MIPS_REG_K0, 0)
    self.uc.reg_write(UC_MIPS_REG_K1, 0)

   


    


  @staticmethod
  def reg_convert(reg_id):
    if type(reg_id) == type(str()):
      return MipsCorn.str2reg(reg_id)
    elif type(reg_id) == type(int()):
      return MipsCorn.int2reg(reg_id)
    else:
      raise Exception('[reg_convert] unhandled conversion for type %s'%type(reg_id))

  @staticmethod
  def int2reg(reg_id):
    raise NotImplemented

  @staticmethod           
  def str2reg(r_str):

    if r_str == '0':
      return UC_MIPS_REG_0
    elif r_str == 'at':
      return UC_MIPS_REG_AT
    elif r_str == 'a0':
      return UC_MIPS_REG_A0  
    elif r_str == 'a1':
      return UC_MIPS_REG_A1 
    elif r_str == 'a2':
      return UC_MIPS_REG_A2
    elif r_str == 'a3':
      return UC_MIPS_REG_A3  
    elif r_str == 's0':
      return UC_MIPS_REG_S0  
    elif r_str == 's1':
      return UC_MIPS_REG_S1 
    elif r_str == 's2':
      return UC_MIPS_REG_S2
    elif r_str == 's3':
      return UC_MIPS_REG_S3  
    elif r_str == 's4':
      return UC_MIPS_REG_S4  
    elif r_str == 's5':
      return UC_MIPS_REG_S5 
    elif r_str == 's6':
      return UC_MIPS_REG_S6
    elif r_str == 's7':
      return UC_MIPS_REG_S7  
    elif r_str == 't0':
      return UC_MIPS_REG_T0  
    elif r_str == 't1':
      return UC_MIPS_REG_T1 
    elif r_str == 't2':
      return UC_MIPS_REG_T2
    elif r_str == 't3':
      return UC_MIPS_REG_T3  
    elif r_str == 't4':
      return UC_MIPS_REG_T4  
    elif r_str == 't5':
      return UC_MIPS_REG_T5 
    elif r_str == 't6':
      return UC_MIPS_REG_T6
    elif r_str == 't7':
      return UC_MIPS_REG_T7  
    elif r_str == 'v0':
      return UC_MIPS_REG_V0
    elif r_str == 'v1':
      return UC_MIPS_REG_V1
    elif r_str == 'k0':
      return UC_MIPS_REG_K0
    elif r_str == 'k1':
      return UC_MIPS_REG_K1
    elif r_str == 'hi':
      return UC_MIPS_REG_HI
    elif r_str == 'LO':
      return UC_MIPS_REG_LO
    elif r_str == 'ra':
      return UC_MIPS_REG_RA
    elif r_str == 'fp':
      return UC_MIPS_REG_FP
    elif r_str == 'gp':
      return UC_MIPS_REG_GP
    elif r_str == 'sp':
      return UC_MIPS_REG_SP
    elif r_str == 'pc':
      return UC_MIPS_REG_PC


  @staticmethod
  def skip_intr(uc,intno,user_data):
    return True

    
    

  
  def print_registers(self):
    strout   = 'Registrs:\n' 
    strout  += '[at = %8X] [a0 = %8X] [a1 = %8X] [a2 = %8X] [a3 = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_AT),
                                                                        self.uc.reg_read(UC_MIPS_REG_A0),
                                                                        self.uc.reg_read(UC_MIPS_REG_A1),
                                                                        self.uc.reg_read(UC_MIPS_REG_A2),
                                                                        self.uc.reg_read(UC_MIPS_REG_A3))

    strout  += '[s0 = %8X] [s1 = %8X] [s2 = %8X] [s3 = %8X] [s4 = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_S0),
                                                                        self.uc.reg_read(UC_MIPS_REG_S1),
                                                                        self.uc.reg_read(UC_MIPS_REG_S2),
                                                                        self.uc.reg_read(UC_MIPS_REG_S3),
                                                                        self.uc.reg_read(UC_MIPS_REG_S4))

    strout  += '[s5 = %8X] [s6 = %8X] [s7 = %8X] [s8 = %8X] [hi = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_S5),
                                                                        self.uc.reg_read(UC_MIPS_REG_S6),
                                                                        self.uc.reg_read(UC_MIPS_REG_S7),
                                                                        self.uc.reg_read(UC_MIPS_REG_S8),
                                                                        self.uc.reg_read(UC_MIPS_REG_HI))

    strout  += '[t0 = %8X] [t1 = %8X] [t2 = %8X] [t3 = %8X] [lo = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_T0),
                                                                        self.uc.reg_read(UC_MIPS_REG_T1),
                                                                        self.uc.reg_read(UC_MIPS_REG_T2),
                                                                        self.uc.reg_read(UC_MIPS_REG_T3),
                                                                        self.uc.reg_read(UC_MIPS_REG_LO))

    strout  += '[t4 = %8X] [t5 = %8X] [t6 = %8X] [t7 = %8X] [t8 = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_T4),
                                                                        self.uc.reg_read(UC_MIPS_REG_T5),
                                                                        self.uc.reg_read(UC_MIPS_REG_T6),
                                                                        self.uc.reg_read(UC_MIPS_REG_T7),
                                                                        self.uc.reg_read(UC_MIPS_REG_T8))

    strout  += '[v0 = %8X] [v1 = %8X] [k0 = %8X] [k1 = %8X] [ra = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_V0),
                                                                        self.uc.reg_read(UC_MIPS_REG_V1),
                                                                        self.uc.reg_read(UC_MIPS_REG_K0),
                                                                        self.uc.reg_read(UC_MIPS_REG_K1),
                                                                        self.uc.reg_read(UC_MIPS_REG_RA))

    strout  += '[t9 = %8X] [gp = %8X] [fp = %8X] [sp = %8X] [pc = %8X]\n'%(self.uc.reg_read(UC_MIPS_REG_T9),
                                                                        self.uc.reg_read(UC_MIPS_REG_GP),
                                                                        self.uc.reg_read(UC_MIPS_REG_FP),
                                                                        self.uc.reg_read(UC_MIPS_REG_SP),
                                                                        self.uc.reg_read(UC_MIPS_REG_PC))
    logger.console(LogType.INFO,strout)


  @staticmethod
  def unmp_read(uc,access,addr,value,size,user_data):

    unimips = user_data
    pc = uc.reg_read(UC_MIPS_REG_PC)
    if unimips.conf.s_conf.stub_pltgot_entries: 
      if pc in range(consts_mips.TRAMPOLINE_ADDR, consts_mips.TRAMPOLINE_ADDR+unimips.trampoline_size):
        index = (pc -0x1000) // consts_mips.TRAMPOLINE_SIZE 
        try:
          if unimips.pinf['endianness'] == 'little':
#             stubs.Arm.libc_stubs_mipsl[index].do_it(unimips.helper)
            ELF.libc_stubs_mipsl[index].do_it()
          else: 
#             stubs.Arm.libc_stubs_mipsb[index].do_it(unimips.helper)
            ELF.libc_stubs_mipsb[index].do_it(unimips.helper)
          uc.mem_map(0,unimips.conf.p_size)
          uc.mem_write(0,'trap'.encode('utf-8')*(unimips.conf.p_size//4))
          return True
        except Exception as e: 
          logger.console(LogType.ERRR,'[intr_handler] error in stubs code')
          raise e
       

    Emucorn.unmp_read(uc,access,addr,value,size,unimips.conf) 
    
    


  @staticmethod
  def read_after(uc,access,addr,value,size,user_data):
    p_size = user_data
    print('[!] Read After addr: %x, size: %d'%(addr,size))
    if addr == 0:
      try:
        uc.mem_unmap(0,p_size)
      except:
        print('error unmmap')
    return True
    
    logger.console(LogType.WARN,'[!] Read Access Exception: cannot read 0x%.8X for size %d (reason: unmapped page)'%(addr,size))
    conf = user_data
    if conf.autoMap:
      base_addr = addr & ~(conf.p_size-1)
      uc.mem_map(base_addr,conf.p_size)
      uc.mem_write(base_addr,b'\xff'*conf.p_size)
      logger.console(LogType.INFO,'[*] Automap: added page 0x%.8X'%base_addr)
      return True
    logger.console(LogType.ERRR,'Automap is not enabled. Aborting()')
    return False




# if __name__ == '__main__':

    #""" PCSX SSTIC Challenge """ 
#   conf=                    Configuration(p_size=0x100,
#                            stk_ba=0x80040000,
#                            stk_size=0x1000,
#                            autoMap=True,
#                            showRegisters=True,
#                            exec_saddr=0x8001A2A4,
#                            exec_eaddr=0x8001A2C4,
#                            mapping_saddr=0x8001A2A4,
#                            mapping_eaddr=0x8001B000,
#                            segms=[],
#                            map_with_segs=False,
#                            use_seg_perms=True,
#                            useCapstone=True,
#                            registers=MipslRegisters(at=0,a0=0,a1=0,a2=0,a3=0,s0=0,s1=0,s2=0,s3=0,s4=0,s5=0,s6=0,s7=0,k0=0,k1=0,
#                                                     t0=0,t1=0,t2=0,t3=0,t4=0,t5=0,t6=0,t7=0,v0=0,v1=0,hi=0,lo=0,sp=0,fp=0,gp=0,ra=0),
#                            showMemAccess=True,
#                            s_conf=StubConfiguration({},False,False),
#                            amap_conf=AdditionnalMapping({}))
# 
#   conf=                    Configuration(p_size=0x1000,
#                            stk_ba=0x80000000,
#                            stk_size=0x1000,
#                            autoMap=True,
#                            showRegisters=True,
#                            exec_saddr=402500,
#                            exec_eaddr=402530,
#                            mapping_saddr=0x400000,
#                            mapping_eaddr=0x42A600,
#                            segms=[],
#                            map_with_segs=False,
#                            use_seg_perms=True,
#                            useCapstone=True,
#                            registers=MipslRegisters(at=0,a0=0,a1=0,a2=0,a3=0,s0=0,s1=0,s2=0,s3=0,s4=0,s5=0,s6=0,s7=0,k0=0,k1=0,t9=0,
#                                                     t0=0,t1=0,t2=0,t3=0,t4=0,t5=0,t6=0,t7=0,v0=0,v1=0,hi=0,lo=0,sp=0,fp=0,gp=0,ra=0),
#                            showMemAccess=True,
#                            s_conf=StubConfiguration({},False,False),
#                            amap_conf=AdditionnalMapping({}))
# 
#   emu = MipsCorn(conf)
#   
# 
#   emu.start()

```

`EWS/emu/unicorn/x64.py`:

```py
import ida_segregs
from EWS.emu.unicorn.generic import *
import string
from EWS.utils.utils import *
import ida_loader
import idc
import ida_ua
import ida_funcs
import idautils
from EWS.stubs.emu.unicorn.sea import UnicornX64SEA, UnicornX64MSVCSEA
import struct
from unicorn.x86_const import * 
from keystone import * 
from capstone import *
from EWS.utils import consts_x64 
from keystone import * 
from EWS.emu.unicorn.x86 import x86Corn
from EWS.stubs.allocators.allocator import *
from EWS.stubs.ELF import ELF
from EWS.stubs.PE import PE
from EWS.utils.configuration import *
from EWS.utils.registers import *
from EWS.asm.assembler import *





class x64Corn(Emucorn): 

    def __init__(self,conf):

        super().__init__(conf) 

        self.uc = Uc(UC_ARCH_X86,UC_MODE_64)

        if self.conf.p_size != self.uc.query(UC_QUERY_PAGE_SIZE):

            logger.logfile(LogType.WARN,' invalid page size, using default')
            self.conf.p_size = self.uc.query(UC_QUERY_PAGE_SIZE)

        Emucorn.do_mapping(self.uc,self.conf)


        # init capstone engine
        if conf.useCapstone:
            self.cs=Cs(CS_ARCH_X86, CS_MODE_64)

        # init keystone engine
        self.ks = Ks(KS_ARCH_X86,KS_MODE_64)
        self.pointer_size = 8

        # setup regs 
        self.setup_regs(self.conf.registers)
        self.pcid = UC_X86_REG_RIP

        # init stubs engine 
        if self.conf.s_conf.activate_stub_mechanism:
                self.setub_stub_mechanism()

        # install hooks
        self.install_hooks()


        self.assembler = assemblers['x64'][0]


        for k,v in self.conf.patches.items():
            self.patch_mem(k,v) 

        for k,v in self.conf.watchpoints:
            self.add_watchpoint(k, rang&0xff,mode=rang>>24)
        
        # TODO move it to the do_mapping
        for k,v in self.conf.memory_init.mappings.items():
                self.uc.mem_write(k,v)

    def setub_stub_mechanism(self):

        """
            install stubs mechanism.
        """

        # map allocator
        Emucorn.do_required_mappng(self.uc,
                                   consts_x64.ALLOC_BA,
                                   consts_x64.ALLOC_BA+self.conf.p_size*consts_x64.ALLOC_PAGES,
                                   self.conf.p_size,
                                   UC_PROT_READ | UC_PROT_WRITE,
                                   True,
                                   f"Warning map heap in already mapped area {consts_aarch64.ALLOC_BA:x}, edit utils/const_x64.py to modify this area")




    
        if '(PE)' in self.filetype:
             self.helper = UnicornX64MSVCSEA(emu=self,
                                             allocator=DumpAllocator(consts_x64.ALLOC_BA,
                                                                     consts_x64.ALLOC_PAGES*\
                                                                     self.conf.p_size),
                                             wsize=8)
        else:
            self.helper = UnicornX64SEA(emu=self,
                                        allocator=DumpAllocator(consts_x64.ALLOC_BA,
                                                                consts_x64.ALLOC_PAGES*\
                                                                self.conf.p_size),
                                        wsize=8)
        if self.conf.s_conf.activate_stub_mechanism:

            if '(PE)' in self.filetype:

                self.stubs = PE.windows_stubs
                self.nstub_obj = PE.NullStub()
                self.loader_type = LoaderType.PE
                self.nstub_obj.set_helper(self.helper)
                if verify_valid_PE(self.conf.s_conf.orig_filepath):
                        self.reloc_map = get_imports(self.conf.s_conf.orig_filepath)
                        self.stub_PE()


            elif 'ELF' in self.filetype:

                self.stubs = ELF.libc_stubs
                self.nstub_obj = ELF.NullStub()
                self.loader_type = LoaderType.ELF
                self.nstub_obj.set_helper(self.helper)

                if verify_valid_elf(self.conf.s_conf.orig_filepath):
                    self.reloc_map = get_relocs(self.conf.s_conf.orig_filepath,
                                                lief.ELF.RELOCATION_X86_64.JUMP_SLOT)

                    self.libc_start_main_trampoline = consts_x64.LIBCSTARTSTUBADDR
                    self.stub_PLT()


            for k,v in self.conf.s_conf.tags.items(): 
                self.tag_func(k, v)



    def install_hooks(self):

        """
            intall unicorn hooks
        """

        self.uc.hook_add(UC_HOOK_CODE,
                         self.hook_code,
                         user_data=self)

        self.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED,
                         Emucorn.unmp_read,
                         user_data=self)

        self.uc.hook_add(UC_HOOK_MEM_WRITE_UNMAPPED,
                         Emucorn.unmp_write,
                         user_data=self)

        if self.conf.showMemAccess:

            self.uc.hook_add(UC_HOOK_MEM_WRITE,
                             Emucorn.hk_write,
                             self)
            self.uc.hook_add(UC_HOOK_MEM_READ,
                             Emucorn.hk_read,
                             self)



    def get_retn_insn(self,
                      ea: int) -> bytes:

        f = ida_funcs.get_func(ea)
        retn = bytes()

        if f == None:

                logger.logfile(LogType.ERRR,
                                             "%s: %x not in a function"%(sys._getframe().f_code.co_name,
                                                                                                     ea))

                raise Exception('Error in %s for ea %x'%(sys._getframe().f_code.co_name,ea))

#                insn    = get_insn_at(ea)
#                retn = self.ks.asm('nop',as_bytes=True)[0]*insn.size

        else:
                n = x86Corn.tail_retn(f.start_ea)
                if n > 0:
                    try:
                        retn = self.ks.asm('ret %d'%n,as_bytes=True)[0]

                    except:
                        logger.console(LogType.WARN,'could not compile retn insn')

                elif n == 0:
                    retn = self.ks.asm('ret',as_bytes=True)[0]

        return retn

    def get_new_stub(self,
                     stub_func,
                     stub_type: StubType,
                     name:str=''):

        """
            Stub factory
        """


        if 'ELF' in self.filetype:
            stub = ELF.Stub(self.helper,
                            stub_type=stub_type,
                            name=name)
            stub.do_it = stub_func

        elif 'PE' in self.filetype:
            stub = PE.Stub(self.helper,
                           stub_type=stub_type,
                           name=name)
            stub.do_it = stub_func

        return stub


    def nop_insn(self,
                 ea: int):

        """
            nop instructation at address *ea*
        """
        insn    = get_insn_at(ea)
        nops = self.ks.asm('nop',as_bytes=True)[0]*insn.size
        self.uc.mem_write(ea,nops)




        # DEPRECATED use reset() function from the plugin

#    def repatch(self):
#        if not self.conf.s_conf.activate_stub_mechanism:
#            return 
#        # need to remap according to the arch settings 
#        self.uc.mem_map(consts_x64.ALLOC_BA,
#                                            self.conf.p_size*consts_x64.ALLOC_PAGES,
#                                            UC_PROT_READ | UC_PROT_WRITE)
#        self.stubbit()
#



    def setup_regs(self,
                   regs: x64Registers):

        """
            initiate emulator' registers given
            *regs* arguemnt.
        """


        self.uc.reg_write(UC_X86_REG_RAX,regs.RAX)

        self.uc.reg_write(UC_X86_REG_RBX,regs.RBX)

        self.uc.reg_write(UC_X86_REG_RCX,regs.RCX)

        self.uc.reg_write(UC_X86_REG_RDX,regs.RDX)

        self.uc.reg_write(UC_X86_REG_RDI,regs.RDI)

        self.uc.reg_write(UC_X86_REG_RSI,regs.RSI)

        self.uc.reg_write(UC_X86_REG_RSP,regs.RSP)

        self.uc.reg_write(UC_X86_REG_RBP,regs.RBP)

        self.uc.reg_write(UC_X86_REG_R8,regs.R8)

        self.uc.reg_write(UC_X86_REG_R9,regs.R9)

        self.uc.reg_write(UC_X86_REG_R10,regs.R10)

        self.uc.reg_write(UC_X86_REG_R11,regs.R11)

        self.uc.reg_write(UC_X86_REG_R12,regs.R12)

        self.uc.reg_write(UC_X86_REG_R13,regs.R13)

        self.uc.reg_write(UC_X86_REG_R14,regs.R14)

        self.uc.reg_write(UC_X86_REG_R15,regs.R15)

        self.uc.reg_write(UC_X86_REG_RIP,regs.RIP)

    def get_regs(self) -> x64Registers:

        """
            return a register snapshot
        """

        return x64Registers(RAX=self.uc.reg_read(UC_X86_REG_RAX),
                            RBX=self.uc.reg_read(UC_X86_REG_RBX),
                            RCX=self.uc.reg_read(UC_X86_REG_RCX),
                            RDX=self.uc.reg_read(UC_X86_REG_RDX),
                            RDI=self.uc.reg_read(UC_X86_REG_RDI),
                            RSI=self.uc.reg_read(UC_X86_REG_RSI),
                            RSP=self.uc.reg_read(UC_X86_REG_RSP),
                            RBP=self.uc.reg_read(UC_X86_REG_RBP),
                            R8=self.uc.reg_read(UC_X86_REG_R8),
                            R9=self.uc.reg_read(UC_X86_REG_R9),
                            R10=self.uc.reg_read(UC_X86_REG_R10),
                            R11=self.uc.reg_read(UC_X86_REG_R11),
                            R12=self.uc.reg_read(UC_X86_REG_R12),
                            R13=self.uc.reg_read(UC_X86_REG_R13),
                            R14=self.uc.reg_read(UC_X86_REG_R14),
                            R15=self.uc.reg_read(UC_X86_REG_R15),
                            RIP=self.uc.reg_read(UC_X86_REG_RIP))


    def reset_regs(self):

        """
            reset the emulator registers
        """

        self.uc.reg_write(UC_X86_REG_RAX,0)

        self.uc.reg_write(UC_X86_REG_RBX,0)

        self.uc.reg_write(UC_X86_REG_RCX,0)

        self.uc.reg_write(UC_X86_REG_RDX,0)

        self.uc.reg_write(UC_X86_REG_RDI,0)

        self.uc.reg_write(UC_X86_REG_RSI,0)

        self.uc.reg_write(UC_X86_REG_RSP,0)

        self.uc.reg_write(UC_X86_REG_RBP,0)

        self.uc.reg_write(UC_X86_REG_RIP,0)

        self.uc.reg_write(UC_X86_REG_R8,0)

        self.uc.reg_write(UC_X86_REG_R9,0)

        self.uc.reg_write(UC_X86_REG_R10,0)

        self.uc.reg_write(UC_X86_REG_R11,0)

        self.uc.reg_write(UC_X86_REG_R12,0)

        self.uc.reg_write(UC_X86_REG_R13,0)

        self.uc.reg_write(UC_X86_REG_R14,0)

        self.uc.reg_write(UC_X86_REG_R15,0)

        self.uc.reg_write(UC_X86_REG_RIP,0)




    @staticmethod
    def reg_convert(r_id: str) -> int:

        """
            convert register accronym to its corresponding
            value in unicorn world.
        """

        if r_id.lower() == 'rax':
            return UC_X86_REG_RAX

        elif r_id.lower() == 'rbx':
            return UC_X86_REG_RBX

        elif r_id.lower() == 'rcx':
            return UC_X86_REG_RCX

        elif r_id.lower() == 'rdx':
            return UC_X86_REG_RDX

        elif r_id.lower() == 'rdi':
            return UC_X86_REG_RDI

        elif r_id.lower() == 'rsi':
            return UC_X86_REG_RSI

        elif r_id.lower() == 'rsp':
            return UC_X86_REG_RSP

        elif r_id.lower() == 'rbp':
            return UC_X86_REG_RBP

        elif r_id.lower() == 'rip':
            return UC_X86_REG_RIP

        elif r_id.lower() == 'r8':
            return UC_X86_REG_R8

        elif r_id.lower() == 'r9':
            return UC_X86_REG_R9

        elif r_id.lower() == 'r10':
            return UC_X86_REG_R10

        elif r_id.lower() == 'r11':
            return UC_X86_REG_R11

        elif r_id.lower() == 'r12':
            return UC_X86_REG_R12

        elif r_id.lower() == 'r13':
            return UC_X86_REG_R13

        elif r_id.lower() == 'r14':
            return UC_X86_REG_R14

        elif r_id.lower() == 'r15':
            return UC_X86_REG_R15



    def reg_convert_ns(self,
                       r_id: str) -> int:

        """
            convert register accronym to its corresponding
            value in unicorn world.
            class method
        """

        if r_id.lower() == 'rax':
            return UC_X86_REG_RAX

        elif r_id.lower() == 'rbx':
            return UC_X86_REG_RBX

        elif r_id.lower() == 'rcx':
            return UC_X86_REG_RCX

        elif r_id.lower() == 'rdx':
            return UC_X86_REG_RDX

        elif r_id.lower() == 'rdi':
            return UC_X86_REG_RDI

        elif r_id.lower() == 'rsi':
            return UC_X86_REG_RSI

        elif r_id.lower() == 'rsp':
            return UC_X86_REG_RSP

        elif r_id.lower() == 'rbp':
            return UC_X86_REG_RBP

        elif r_id.lower() == 'rip':
            return UC_X86_REG_RIP

        elif r_id.lower() == 'r8':
            return UC_X86_REG_R8

        elif r_id.lower() == 'r9':
            return UC_X86_REG_R9

        elif r_id.lower() == 'r10':
            return UC_X86_REG_R10

        elif r_id.lower() == 'r11':
            return UC_X86_REG_R11

        elif r_id.lower() == 'r12':
            return UC_X86_REG_R12

        elif r_id.lower() == 'r13':
            return UC_X86_REG_R13

        elif r_id.lower() == 'r14':
            return UC_X86_REG_R14

        elif r_id.lower() == 'r15':
            return UC_X86_REG_R15


    def print_registers(self) -> str:

        """
            log register' values to console.
        """

        strout =    '[RAX=%.8X] [RBX=%.8X] [RCX=%.8X] [RDX=%.8X]\n'%\
            (self.uc.reg_read(UC_X86_REG_RAX),
             self.uc.reg_read(UC_X86_REG_RBX),
             self.uc.reg_read(UC_X86_REG_RCX),
             self.uc.reg_read(UC_X86_REG_RDX))
        strout += '[RDI=%.8X] [RSI=%.8X] [RBP=%.8X] [RSP=%.8X]\n'%\
            (self.uc.reg_read(UC_X86_REG_RDI),
             self.uc.reg_read(UC_X86_REG_RSI),
             self.uc.reg_read(UC_X86_REG_RBP),
             self.uc.reg_read(UC_X86_REG_RSP))
        strout += '[R8=%.8X] [R9=%.8X] [R10=%.8X] [R11=%.8X]\n'%\
            (self.uc.reg_read(UC_X86_REG_R8),
            self.uc.reg_read(UC_X86_REG_R9),
            self.uc.reg_read(UC_X86_REG_R10),
            self.uc.reg_read(UC_X86_REG_R11))
        strout += '[R12=%.8X] [R13=%.8X] [R14=%.8X] [R15=%.8X]\n'%\
            (self.uc.reg_read(UC_X86_REG_R12),
             self.uc.reg_read(UC_X86_REG_R13),
             self.uc.reg_read(UC_X86_REG_R14),
             self.uc.reg_read(UC_X86_REG_R15))

        return strout


    def get_alu_info(self):

        """
            return the RFlags
        """

        return x64RFLAGS.create(self.uc.reg_read(UC_X86_REG_EFLAGS))


    @staticmethod
    def generate_default_config(
                                 path: str = None,
                                 arch: str = None,
                                 emulator: str = None,
                                 p_size: int = None,
                                 stk_ba: int = None,
                                 stk_size: int = None,
                                 autoMap: bool = None,
                                 showRegisters: bool = None,
                                 exec_saddr: int =None,
                                 exec_eaddr: int =None,
                                 mapping_saddr: int =None,
                                 mapping_eaddr: int =None,
                                 segms: list =None,
                                 map_with_segs: bool = None,
                                 use_seg_perms: bool =None,
                                 useCapstone: bool = None,
                                 registers: Registers = None,
                                 showMemAccess: bool =None,
                                 s_conf: StubConfiguration = None,
                                 amap_conf: AdditionnalMapping = None,
                                 memory_init: AdditionnalMapping =None,
                                 color_graph: bool =None,
                                 breakpoints: list =None,
                                 watchpoints: dict =None) -> Configuration:
      """this method get called by:
            - ui **emulate_function**
            - ui **emulate_selection**
      """

      if not registers: 
        if stk_ba and stk_size: 
            RBP = RSP =  stk_ba + stk_size - consts_x64.initial_stack_offset 
        elif stk_ba and not stk_size: 
            RBP = RSP =  stk_ba +  consts_x64.STACK_SIZE - consts_x64.initial_stack_offset 
        elif stk_size and not stk_ba: 
            RBP = RSP = consts_x64.STACK_BASEADDR + stk_size - consts_x64.initial_stack_offset 
        else:
            RBP = RSP = consts_x64.STACK_BASEADDR+consts_x64.STACK_SIZE-\
                                 consts_x64.initial_stack_offset
        registers = x64Registers.get_default_object(RBP=RBP,RSP=RSP,RIP=exec_saddr)



      return Configuration.generate_default_config(stk_ba=stk_ba if stk_ba\
                                                    else consts_x64.STACK_BASEADDR,
                                                    stk_size=stk_size if stk_size\
                                                    else consts_x64.STACK_SIZE,
                                                    registers=registers,
                                                    exec_saddr=exec_saddr,
                                                    exec_eaddr=exec_eaddr,
                                                   arch='x64')




#    @staticmethod
#    def generate_default_config(path=None,
#                                arch=None,
#                                emulator=None,
#                                p_size=None,
#                                stk_ba=None,
#                                stk_size=None,
#                                autoMap=None,
#                                showRegisters=None,
#                                exec_saddr=None,
#                                exec_eaddr=None,
#                                mapping_saddr=None,
#                                mapping_eaddr=None,
#                                segms=None,
#                                map_with_segs=None,
#                                use_seg_perms=None,
#                                useCapstone=None,
#                                registers=None,
#                                showMemAccess=None,
#                                s_conf=None,
#                                amap_conf=None,
#                                memory_init=None,
#                                color_graph=None,
#                                breakpoints=None) -> Configuration:
#
#        """
#            generate a default configuration object.
#            TODO: these function should use a XML file.
#        """
#
#
#        if registers == None:
#                registers = x64Registers(RAX=0,
#                                         RBX=1,
#                                         RCX=2,
#                                         RDX=3,
#                                         RDI=4,
#                                         RSI=5,
#                                         R8=6,
#                                         R9=7,
#                                         R10=8,
#                                         R11=9,
#                                         R12=10,
#                                         R13=11,
#                                         R14=12,
#                                         R15=13,
#                                         RBP=consts_x64.STACK_BASEADDR+consts_x64.STACK_SIZE-\
#                                         consts_x64.initial_stack_offset,
#                                         RSP=consts_x64.STACK_BASEADDR+consts_x64.STACK_SIZE-\
#                                         consts_x64.initial_stack_offset,
#                                         RIP=exec_saddr)
#        else:
#                registers = regs
#
#        if s_conf == None:
#
#                exec_path = search_executable()
#                stub_conf = StubConfiguration(nstubs=dict(),
#                                              activate_stub_mechanism=True if exec_path != "" else False,
#                                              orig_filepath=exec_path,
#                                              custom_stubs_file=None,
#                                              auto_null_stub=True if exec_path != "" else False,
#                                              tags=dict())
#        else:
#                stub_conf = s_conf
#
#        if amap_conf == None:
#                addmap_conf = AdditionnalMapping.create()
#
#        else:
#                addmap_conf = amap_conf
#
#
#        if memory_init == None:
#                meminit = AdditionnalMapping.create()
#
#        else:
#                meminit = memory_init
#
#
#        return Configuration(path=path if path else '',
#                             arch='x86_64',
#                             emulator='unicorn',
#                             p_size=p_size if p_size else consts_x64.PSIZE,
#                             stk_ba=stk_ba if stk_ba else consts_x64.STACK_BASEADDR,
#                             stk_size=stk_size if stk_size else consts_x64.STACK_SIZE,autoMap=autoMap if autoMap else False,
#                             showRegisters=showRegisters if showRegisters else True,
#                             exec_saddr=exec_saddr if exec_saddr else 0,
#                             exec_eaddr=exec_eaddr if exec_eaddr else 0xFFFFFFFF,
#                             mapping_saddr=get_min_ea_idb() if not mapping_saddr else mapping_saddr,
#                             mapping_eaddr=get_max_ea_idb() if not mapping_eaddr else mapping_eaddr,
#                             segms=segms if segms else [],
#                             map_with_segs=map_with_segs if map_with_segs else False,
#                             use_seg_perms=use_seg_perms if use_seg_perms else False,
#                             useCapstone=useCapstone if useCapstone else True,
#                             registers=registers,
#                             showMemAccess=showMemAccess if showMemAccess else True,
#                             s_conf=stub_conf,
#                             amap_conf=addmap_conf,
#                             memory_init=meminit,
#                             color_graph=False,
#                             breakpoints=breakpoints if breakpoints else [])
#
#
#


```

`EWS/emu/unicorn/x86.py`:

```py
import ida_segregs
from EWS.emu.unicorn.generic import * 
import string
from EWS.utils.utils import * 
from EWS.utils import consts_x86
from EWS.stubs.allocators.allocator import *
import ida_loader
import idc
import ida_ua
import ida_funcs
import idautils
from EWS. stubs.emu.unicorn.sea import UnicornX86SEA
import struct
from unicorn.x86_const import * 
from keystone import * 
from EWS. stubs.ELF import ELF
from EWS. stubs import PE
from EWS.utils.configuration import *
from EWS.utils.registers import *
from EWS.asm.assembler import *

class x86Corn(Emucorn): 

  def __init__(self,conf):

    super().__init__(conf) 

    self.uc = Uc(UC_ARCH_X86,UC_MODE_32)

    if self.conf.p_size != self.uc.query(UC_QUERY_PAGE_SIZE):
      logger.console(LogType.WARN,' invalid page size, using default')
      self.conf.p_size = self.uc.query(UC_QUERY_PAGE_SIZE)

    stk_p = Emucorn.do_mapping(self.uc,self.conf)

    if conf.useCapstone:
      from capstone import Cs, CS_ARCH_X86, CS_MODE_32
      self.cs=Cs(CS_ARCH_X86, CS_MODE_32)

    self.ks = Ks(KS_ARCH_X86,KS_MODE_32) 

    self.ida_jmp_itype = consts_x86.ida_jmp_itype 
    self.pointer_size = 4 

    # Setup regs 
    self.setup_regs(self.conf.registers)

    self.pcid = UC_X86_REG_EIP

    # Init stubs engine 
    if self.conf.s_conf.activate_stub_mechanism:
        self.setup_stub_mechanism()

    self.install_hooks()

    for k,v in self.conf.memory_init.mappings.items():
        self.uc.mem_write(k,v)


    self.assembler = assemblers['x86'][0]

    for k,v in self.conf.patches.items():
            self.patch_mem(k,v) 


    for k,v in self.conf.watchpoints.items():
            self.add_watchpoint(k, v&0xff,mode=v>>24)





  def install_hooks(self):


    self.uc.hook_add(UC_HOOK_CODE,
                     self.hook_code,
                     user_data=self)

    self.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED,
                     Emucorn.unmp_read,
                     user_data=self)

    self.uc.hook_add(UC_HOOK_MEM_WRITE_UNMAPPED,
                     Emucorn.unmp_write,
                     user_data=self)

    if self.conf.showMemAccess:
      self.uc.hook_add(UC_HOOK_MEM_WRITE,
                Emucorn.hk_write,
                self)
      self.uc.hook_add(UC_HOOK_MEM_READ,
                       Emucorn.hk_read,
                       self)


  def setup_stub_mechanism(self):


        Emucorn.do_required_mappng(self.uc,
                                   consts_x86.ALLOC_BA,
                                   consts_x86.ALLOC_BA+self.conf.p_size*consts_x86.ALLOC_PAGES,
                                   self.conf.p_size,
                                   UC_PROT_READ | UC_PROT_WRITE,
                                   True,
                                   f"Warning map heap in already mapped area {consts_x86.ALLOC_BA:x}, edit utils/const_arm.py to modify this area")



        self.helper = UnicornX86SEA(emu=self,
                                      allocator=DumpAllocator(consts_x86.ALLOC_BA,
                                                              consts_x86.ALLOC_PAGES*self.conf.p_size),
                                      wsize=4)
          

        
        if self.conf.s_conf.activate_stub_mechanism:

          if '(PE)' in self.filetype:
            self.stubs = PE.winx86_stubs
            self.nstub_obj = PE.NullStub()
            self.loader_type = LoaderType.PE
            self.nstub_obj.set_helper(self.helper)
          elif 'ELF' in self.filetype:
            self.stubs = ELF.libc_stubs
            self.nstub_obj = ELF.NullStub()
            self.loader_type = LoaderType.ELF
            self.nstub_obj.set_helper(self.helper)
            if verify_valid_elf(self.conf.s_conf.orig_filepath):
              self.reloc_map = get_relocs(self.conf.s_conf.orig_filepath,
                                          lief.ELF.RELOCATION_X86_64.JUMP_SLOT)
              # Stub __libc_start_main (experimental)
              self.libc_start_main_trampoline = consts_x86.LIBCSTARTSTUBADDR
              self.uc.mem_map(consts_x86.LIBCSTARTSTUBADDR,consts_x86.PSIZE, UC_PROT_ALL)
              self.uc.mem_write(consts_x86.LIBCSTARTSTUBADDR,consts_x86.LIBCSTARTSTUBCODE) 
              self.stub_PLT()



          for k,v in self.conf.s_conf.tags.items(): 
            self.tag_func(k, v)


  def nop_insn(self,
               insn):

    """ 
    ! nop the instruction 
  
    @param instruction repr by IDA
    """
    for of in range(0,insn.size):
      #self.uc.mem_write(insn.ea+of,struct.pack('B',consts_x86.nop))
      bc,sz = self.ks.asm("nop;"*size,as_bytes=True,addr=insn.ea)
      self.uc.mem_write(insn.ea,bc)


    

  @staticmethod
  def tail_retn(ea):

    """ returns operand of retn <op>
        this is heuristic, should be used carefully.
        
        @param ea Address to start the research 
    """

    f = ida_funcs.get_func(ea)
    insn = get_insn_at(f.end_ea)# somehow end_ea does not point to the last insn...

    if insn.itype == consts_x86.ida_retn_itype: # or use ida_idp.is_ret_insn...

      if not len(insn.__get_ops__()) > 0:

        return 0 

      else:

        return idc.get_operand_value(insn.ea,0)

    # in case, last insn of the funcs is not a retn X, we need
    # to decode insn one by one until find the "good one" 
    else:

      ea = f.start_ea 
      while ea < f.end_ea:
         insn = get_insn_at(ea)
         if insn.itype == consts_x86.ida_retn_itype:  
          if idc.get_operand_type(ea,0) == idc.o_void:  
            return idc.o_void 
          else:
            return idc.get_operand_value(insn.ea,0)
         elif insn.itype in consts_x86.ida_jmp_itype: 
            return idc.o_void
         ea += insn.size
          
    return -1 
   
  def get_retn_insn(self,
                    ea:int):

    f = ida_funcs.get_func(ea)
    n = x86Corn.tail_retn(f.start_ea)

    if n > 0: 
      try: retn = self.ks.asm('ret %d'%n,as_bytes=True)[0]
      except: logger.console(LogType.WARN,'could not compile retn insn'); return -1
    elif n == 0: 
      retn,sz = self.ks.asm("ret;",as_bytes=True)
      #retn = struct.pack('B',consts_x86.ret)

    return retn


  def get_new_stub(self,
                   stub_func,
                   stub_type,
                   name:str=''):

    if 'ELF' in self.filetype:
      stub = ELF.Stub(self.helper,stub_type=stub_type,name=name)
      stub.do_it = stub_func
    elif 'PE' in self.filetype:
      stub = PE.Stub(self.helper,stub_type=stub_type)
      stub.do_it = stub_func
    return stub


  def get_alu_info(self):
    
    return x86EFLAGS.create(self.uc.reg_read(UC_X86_REG_EFLAGS))

  def setup_regs(self,regs):

    for k,v in consts_x86.reg_map_unicorn.items():
            self.uc.reg_write(v,getattr(regs,k.upper())) 

  def get_regs(self):

    regs =x86Registers.create() 

    for k,v in consts_x86.reg_map_unicorn.items():
        setattr(regs,k.upper(),self.uc.reg_read(v))
    return regs
    
  def reset_regs(self):

        for k,v in consts_x86.reg_map_unicorn.items():
            self.uc.reg_write(v,0)
 

  @staticmethod
  def reg_convert(r_id:str):
    return consts_x86.reg_map_unicorn[r_id]
   
  def reg_convert_ns(self,r_id):
    return consts_x86.reg_map_unicorn[r_id]

    
    
  def print_registers(self):
    strout  = 'Registers:\n'
    strout +=  '[EAX=%.8X] [EBX=%.8X] [ECX=%.8X] [EDX=%.8X]\n'%(self.uc.reg_read(UC_X86_REG_EAX),
     self.uc.reg_read(UC_X86_REG_EBX),
     self.uc.reg_read(UC_X86_REG_ECX),
     self.uc.reg_read(UC_X86_REG_EDX))
    strout += '[EDI=%.8X] [ESI=%.8X] [EBP=%.8X] [ESP=%.8X]\n'%(self.uc.reg_read(UC_X86_REG_EDI),
     self.uc.reg_read(UC_X86_REG_ESI),
     self.uc.reg_read(UC_X86_REG_EBP),
     self.uc.reg_read(UC_X86_REG_ESP))
    return strout



  @staticmethod
  def generate_default_config(
                                 path: str = None,
                                 arch: str = None,
                                 emulator: str = None,
                                 p_size: int = None,
                                 stk_ba: int = None,
                                 stk_size: int = None,
                                 autoMap: bool = None,
                                 showRegisters: bool = None,
                                 exec_saddr: int =None,
                                 exec_eaddr: int =None,
                                 mapping_saddr: int =None,
                                 mapping_eaddr: int =None,
                                 segms: list =None,
                                 map_with_segs: bool = None,
                                 use_seg_perms: bool =None,
                                 useCapstone: bool = None,
                                 registers: Registers = None,
                                 showMemAccess: bool =None,
                                 s_conf: StubConfiguration = None,
                                 amap_conf: AdditionnalMapping = None,
                                 memory_init: AdditionnalMapping =None,
                                 color_graph: bool =None,
                                 breakpoints: list =None,
                                 watchpoints: dict =None) -> Configuration:
      """this method get called by:
            - ui **emulate_function**
            - ui **emulate_selection**
      """

      if not registers: 
        if stk_ba and stk_size: 
            EBP = ESP =  stk_ba + stk_size - consts_x86.initial_stack_offset 
        elif stk_ba and not stk_size: 
            EBP = ESP =  stk_ba +  consts_x86.STACK_SIZE - consts_x86.initial_stack_offset 
        elif stk_size and not stk_ba: 
            EBP = ESP = consts_x86.STACK_BASEADDR + stk_size - consts_x86.initial_stack_offset 
        else:
            EBP = ESP = consts_x86.STACK_BASEADDR+consts_x86.STACK_SIZE-\
                                 consts_x86.initial_stack_offset
        registers = x86Registers.get_default_object(EBP=EBP,ESP=ESP,EIP=exec_saddr)
      return Configuration.generate_default_config(arch='x86',stk_ba=stk_ba if stk_ba\
                                                    else consts_x86.STACK_BASEADDR,
                                                    stk_size=stk_size if stk_size\
                                                    else consts_x86.STACK_SIZE,
                                                    registers=registers,
                                                    exec_saddr=exec_saddr,
                                                    exec_eaddr=exec_eaddr)









```

`EWS/stubs/ELF/ELF.py`:

```py
import ida_kernwin
from EWS.stubs.ELF import conf
from EWS.stubs.ELF.utils import *
from EWS.utils.utils import *
import codecs
import re
from enum import Enum
import os
from os import path
import tempfile
import struct




byte_l = lambda x: x & 0xFF
byte_2l = lambda x: x & 0xFFFF
byte_h = lambda x: (x >> 16) & 0xFF
byte_2h = lambda x: (x >> 16) & 0xFFFF

# -----------------------------------------------------------------------------
"""                 """
"     STUB OBJECTS    "
"""                 """
# -----------------------------------------------------------------------------
class Stub(object):
  def __init__(self,
               helper=None,
               stub_type=StubType.BUILTIN,
               name: str = 'undef stub'):

    self.helper = helper
    self.stub_type = stub_type
    self.name = name

  def set_helper(self,helper):
    self.helper = helper

  def check_watchpoint(self,base_addr,size,mode='read'):
    for k,v in self.helper.emu.watchpoints.items():
            for x in range(base_addr,base_addr+size):
                if x in range(k,k+(v&0xFF)):
                    logger.console(LogType.INFO,
                                   f"[watchpoint] [{mode}] [pc={self.helper.get_pc():x}] memory access at 0x{x:x}")
         


libc_stubs = dict()

class LibcStub():
    def __init__(self,name):
        assert name not in libc_stubs
        self.name = name

    def __call__(self,cls):
        obj = cls()
        libc_stubs[self.name] = obj
        return cls



class NullStub(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[stubs] null stub is called')
        self.helper.set_return(0)
        return True


# -----------------------------------------------------------------------------
"""                   """
"   STUBBED FUNCTIONS   "
"""                   """
# -----------------------------------------------------------------------------

@LibcStub('memset')
@LibcStub('.memset')
class memset(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        dst = self.helper.get_arg(0)
        data = byte_l (self.helper.get_arg(1)) 
        ln = self.helper.get_arg(2)
        logger.console(LogType.INFO,' memset(%8X, %2X, %X)'%(dst,data,ln))
        self.helper.mem_write(dst,bytes(data*ln))
        self.check_watchpoint(dst, ln,mode='write')
        self.check_watchpoint(data, 1)
        return True


# -----------------------------------------------------------------------------
@LibcStub('malloc')
class malloc(Stub):

    def __init__(self):
        super().__init__()


    def do_it(self,*args):
#         if not fromStub:
          req_size = self.helper.get_arg(0)
          addr = self.helper.malloc(req_size)
          self.helper.set_return(addr)
          logger.console(LogType.INFO,' malloc(%X) = %8X'%(req_size,addr))
          return True

# -----------------------------------------------------------------------------
@LibcStub('free')
class free(Stub):

    def __init__(self):
        super().__init__()


    def do_it(self,*args):
        addr = self.helper.get_arg(0)
        self.helper.free(addr)
        logger.console(LogType.INFO,' free(%8X)'%addr)
        return True

# -----------------------------------------------------------------------------
@LibcStub('calloc')
class calloc(Stub):

    def __init__(self):
        super().__init__()


    def do_it(self,*args):
        req_size = self.helper.get_arg(0)
        addr = self.helper.malloc(req_size)
        self.helper.mem_write(addr,b'\x00'*req_size)
        self.helper.set_return(addr)
        logger.console(LogType.INFO,' malloc(%X) = %8X'%(req_size,addr))
        return True

# -----------------------------------------------------------------------------
#@LibcStub('__libc_start_main')
#class libc_start_main(Stub):
#
#    def __init__(self):
#        super().__init__()
#        
#
#    def do_it(self,*args):
#        logger.console(LogType.INFO,'[__libc_start_main] called at %.8X'%self.helper.get_pc())
#        arg0 = self.helper.get_arg(0)
#        logger.console(LogType.INFO,'[__libc_start_main] main => %.8X'%(arg0))
#        self.helper.reg_write(14, arg0)
#        return True
#
#
# -----------------------------------------------------------------------------
@LibcStub('puts')
class puts(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[puts] called at 0x%.8X'%self.helper.get_pc())
        arg0 = self.helper.get_arg(0)
        s = deref_until(self.helper,arg0,b'\0').decode('utf-8')
        self.helper.set_return( 0)
        return True
# -----------------------------------------------------------------------------
@LibcStub('strncpy')
class strncpy(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[strncpy] called at 0x%.8X'%self.helper.get_pc())
        dst=self.helper.get_arg(0)
        src=self.helper.get_arg(1)
        ln=self.helper.get_arg(2)
        data=self.helper.mem_read(src,ln)
        nc = data.find(b'\x00')
        if nc != -1:
            data=data[0:nc]
        self.helper.mem_write(dst,bytes(data))
        logger.console(LogType.INFO,'[strncpy] dst = %.8X src = %.8X ln = %d'%(dst,src,ln),
                  '\n\tCopying string : ',data)

        self.check_watchpoint(dst_addr, len(data),mode='write')
        self.check_watchpoint(src_addr, len(data))
        return True

# -----------------------------------------------------------------------------
@LibcStub('strcpy')
class strcpy(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[strcpy] called at 0x%.8X'%self.helper.get_pc())
        dst_addr=self.helper.get_arg(0)
        src_addr=self.helper.get_arg(1)
        src = deref_string(self.helper,src_addr)
        self.helper.mem_write(dst_addr,src)
        self.check_watchpoint(dst_addr, len(src),mode='write')
        self.check_watchpoint(src_addr, len(src))
        return True

# -----------------------------------------------------------------------------
@LibcStub('printf')
class printf(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        format_addr = self.helper.get_arg(0)
        try:
            fmt = deref_until(self.helper,format_addr,b'\0')
        except UnicodeDecodeError as e:
            logger.console(LogType.INFO,'[printf] Cannot decode format :',fmt)
            raise StubExcept('[printf] error decoding format')
        fmt,l = codecs.escape_encode(fmt)
        pc = self.helper.get_pc()
        logger.console(LogType.INFO,'[printf] Call at 0x%.8X with format %s'%(pc,fmt))
        p  = re.compile('%+[l]{0,1}[dpsx]+') # 08/11/2020: ajout du + 
        p2  = re.compile('(%+[dpsx]+)') # 08/11/2020:  ajout du + 
        chain_addr = self.helper.get_arg(0)
        chain = deref_string(self.helper,chain_addr)
        reformat = [i for i in p.findall(chain.strip().decode('utf-8')) if i != '']
        deref_list = deref_format(self.helper,reformat,1) 
        deref_list.reverse()
        out = build_chain(self.helper,
                    p2.split(chain.strip().decode('utf-8')),
                    deref_list)

        logger.console(LogType.INFO,'[printf] outputs:',out)
        return True

# -----------------------------------------------------------------------------
@LibcStub('memcpy')
@LibcStub('__aeabi_memcpy')
class memcpy(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[memcpy] called at 0x%.8X'%self.helper.get_pc())
        dst=self.helper.get_arg(0)
        src=self.helper.get_arg(1)
        ln=self.helper.get_arg(2)
        data=self.helper.mem_read(src,ln)
        logger.console(LogType.INFO,'Writting from %x data:'%src,data,' at addr %x'%dst,' for len %d'%ln)
        self.helper.mem_write(dst,bytes(data))
        self.helper.set_return(ln)
        self.check_watchpoint(dst, ln,mode='write')
        self.check_watchpoint(src, ln)
        
        return True

# -----------------------------------------------------------------------------
@LibcStub('strlen')
@LibcStub('_strlen')
@LibcStub(".strlen")
class strlen(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        str_addr = self.helper.get_arg(0)
        logger.console(LogType.INFO,'[strlen] str_addr: 0x%.8X'%str_addr)
        size=len(deref_until(self.helper,str_addr,b'\0'))
        logger.console(LogType.INFO,'[strlen] returns %d'%size)
        self.helper.set_return(size)
        self.check_watchpoint(str_addr, size)
        return True

# -----------------------------------------------------------------------------
@LibcStub('fopen')
@LibcStub('.fopen')
class fopen(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):

        fname_addr = self.helper.get_arg(0)
        mode_addr = self.helper.get_arg(1)

        try:

            filename = deref_until(self.helper,fname_addr,b'\0')

        except SyntaxError:
            raise StubPythonException('[fopen] non utf-8 filename')

        mode = deref_string(self.helper,mode_addr).decode('utf-8')
        logger.console(LogType.INFO,'[fopen] filename: ',filename,' mode:%s'%mode)

        if '+' in mode: mode=mode.split('+')[0]+'b'+mode.split('+')[1]
        else: mode +='b'

        fd = open(filename,mode)
        fd_list[fd.fileno()] = FILE(fd,mode)

        logger.console(LogType.INFO,'[fopen] returning fd %d'%fd.fileno())
        self.helper.set_return(fd.fileno())

        return True
# -----------------------------------------------------------------------------
@LibcStub('fwrite')
class fwrite(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fwrite] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                                self.helper.get_arg(3)))
        fd = self.helper.get_arg(3)
        buf_addr = self.helper.get_arg(0)
        size = self.helper.get_arg(1)
        nmenb = self.helper.get_arg(2)
        if fd not in fd_list:
            raise StubExcept('[fwrite] file descriptor not in the list')
        data=deref_size(self.helper,buf_addr,nmenb*size)
        try:
            fd_list[fd].write(data)
        except Exception as e:
            raise StubExcept('[fwrite] error writing file: %s'%e.__str__())
        self.helper.set_return(nmemb*size)
        return True

# -----------------------------------------------------------------------------
@LibcStub('fclose')
class fclose(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fclose] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                                self.helper.get_arg(0)))
        fd = self.helper.get_arg(0)
        if fd not in fd_list:
            raise StubExcept('[fclose] file descriptor not in the list')
        try:
            fd_list[fd].close()
            return True
        except:
            raise StubExcept('[fclose] error closing file with fd %d'%fd)

# -----------------------------------------------------------------------------
@LibcStub('fread')
class fread(Stub):
    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fread] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                               self.helper.get_arg(3)))
        fd = self.helper.get_arg(3)
        buf_addr = self.helper.get_arg(0)
        size = self.helper.get_arg(1)
        nmenb = self.helper.get_arg(2)
        if fd not in fd_list:
            raise StubExcept('[fread] file descriptor not in the list')
        i = 0
        while(i < (nmenb*size)):
            try:
                self.helper.mem_write(buf_addr+i,fd_list[fd].read(nmenb))
            except Exception as e:
                raise StubExcept('[fread] error reading file: %s'%e.__str__())
            i+=nmenb
        self.helper.set_return(nmenb*size)
        return True

# -----------------------------------------------------------------------------
@LibcStub('fflush')
class fflush(Stub):
    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fflush] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                                self.helper.get_arg(0)))
        fd = self.helper.get_arg(0)
        if not fd in fd_list:
            raise(Exception('[fflush] file descriptor not in the list'))
        fd_list[fd].fflush()
        self.helper.set_return(0)
        return True

# -----------------------------------------------------------------------------
@LibcStub('fseek')
class fseek(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fseek] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                               self.helper.get_arg(0)))
        fd = self.helper.get_arg(0)
        offset = self.helper.get_arg(1)
        whence = self.helper.get_arg(2)
        if not fd in fd_list:
            raise(Exception('[fseek] file descriptor not in the list'))
        try:
            fd_list[fd].fseek(offset,whence)
        except Exception as e :
            raise(Exception('[fseek] error fseek'))
        self.helper.set_return(0)
        return True

# -----------------------------------------------------------------------------
@LibcStub('fgetc')
class fgetc(Stub):
    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fgetc] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                               self.helper.get_arg(0)))
        fd = self.helper.get_arg(0)
        if fd == STDIN:
          self.helper.set_return(conf.default_stdin[:1].encode('utf-8'))
          return    
        if not fd in fd_list:
            raise(Exception('[fgetc] file descriptor not in the list'))
        self.helper.set_return(fd_list[fd].read(1))
        return True

# -----------------------------------------------------------------------------
@LibcStub('fgets')
class fgets(Stub):
    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        fd = self.helper.get_arg(2)
        size = self.helper.get_arg(1)
        addr = self.helper.get_arg(0)
        logger.console(LogType.INFO,'[fgets] called at 0x%.8X, fd : %d,dst=0x%.8X,size=%d'%(self.helper.get_pc(),
                                                                      fd,
                                                                      addr,
                                                                      size))
        if not fd in fd_list and not fd == STDIN:
            raise(Exception('[fgets] file descriptor not in the list'))
        # according to man, read size-1 chars maximum to let room for '\0' terminating char
        if fd == STDIN: line = conf.default_stdin.encode('utf-8')
        else:           line= fd_list[fd].readline()
        if len(line)>size:
            logger.console(LogType.INFO,'[fgets] warning line is longer than the limit size. Rewinding is not implemented, unpredictable behiavor may occur')
            line=line[:size]
        # Can trigger OOB Read
        if line != b'' and line != b'\x0A' and line != b'\x0a\x0d' and line !=b'\x0d\x0a':
            if b'\x0A' in line:
                line=line.split(b'\x0A')[0]
            elif b'\x0D\x0A' in line:
                line=line.split(b'\x0D')[0]
            elif b'\x0A\x0D' in line:
                line=line.split(b'\x0A')[0]
            logger.console(LogType.INFO,'[fgets] returns %s'%line)
            self.helper.mem_write(addr,line)
            self.helper.mem_write(addr+len(line),b'\x00')
        else:
            logger.console(LogType.INFO,'[fgets] returns NULL (no more line)')
            self.helper.set_return(0)    #fgets returns the addr of the buffer (R0 not modified)
        return True

# -----------------------------------------------------------------------------
#CAUTION : Does not handle space between format
@LibcStub('_fprintf')
@LibcStub('fprintf')
class fprintf(Stub):
    """ Should create a fake rootfs
    """

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[fprintf] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                                 self.helper.get_arg(0)))
        fd = self.helper.get_arg(0)
        if not fd in fd_list and fd > 2:
#            raise Exception('[fprintf] file descriptor not found')
             logger.console(LogType.WARN,"File descriptor does not belongs to standard IO nor ",
                            "opened files")
        chain_addr = self.helper.get_arg(1)
        chain = deref_string(self.helper,chain_addr)
        p  = re.compile('%+[l]{0,1}[dpsx]')
        p2  = re.compile('(%+[l]{0,1}[dpsx])')
        reformat = [i for i in p.findall(chain.strip().decode('utf-8')) if i != '']
        deref_list = deref_format(self.helper,reformat,2)
        deref_list.reverse()
        out = build_chain(self.helper,
                    p2.split(chain.strip().decode('utf-8')),
                    deref_list)
        ln = 0
        write_to_fd(fd,fd_list,out)

        self.helper.set_return(ln)
        return True


@LibcStub("_fprintf_chk")
class _fprintf_chk(Stub):
    """ Should create a fake rootfs
    """

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[__fprintf_chk] called at 0x%.8X, fd : %d'%(self.helper.get_pc(),
                                                 self.helper.get_arg(0)))
        fd = self.helper.get_arg(0)
        if not fd in fd_list and fd > 2:
#            raise Exception('[fprintf] file descriptor not found')
             logger.console(LogType.WARN,"File descriptor does not belongs to standard IO nor ",
                            "opened files")
        flag = self.helper.get_arg(1)
        chain_addr = self.helper.get_arg(2)
        chain = deref_string(self.helper,chain_addr)
        p  = re.compile('%+[l]{0,1}[dpsx]')
        p2  = re.compile('(%+[l]{0,1}[dpsx])')
        reformat = [i for i in p.findall(chain.strip().decode('utf-8')) if i != '']
        deref_list = deref_format(self.helper,reformat,3)
        deref_list.reverse()
        out = build_chain(self.helper,
                    p2.split(chain.strip().decode('utf-8')),
                    deref_list)
        ln = 0
        write_to_fd(fd,fd_list,out)

        self.helper.set_return(ln)
        return True




# -----------------------------------------------------------------------------
@LibcStub('snprintf')
class snprintf(Stub):
    """
    To reflect as maximum as possible C implmentation, we use byte representation of string.
    Hence it is not possible to use Python' string functions self.helper
    """
    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[snprintf]')
        buf_addr = self.helper.get_arg(0)
        size = self.helper.get_arg(1)
        format_addr = self.helper.get_arg(2)
        chain = deref_string(self.helper,format_addr)
        logger.console(LogType.INFO,'[snprintf] dst: 0x%.8X size : %d format : %s'%(buf_addr,size,chain))
        p  = re.compile('%+[l]{0,1}[dpsx]')
        p2  = re.compile('(%+[l]{0,1}[dpsx])')
        reformat = [i for i in p.findall(chain.strip().decode('utf-8')) if i != '']
        deref_list = deref_format(self.helper,reformat,3)
        deref_list.reverse()
        out = build_chain(self.helper,
                    p2.split(chain.strip().decode('utf-8')),
                    deref_list)
        if len(out) > size:
            logger.console(LogType.INFO,'[snprintf] truncating output')
            self.helper.mem_write(buf_addr,bytes(out)[0:size])
            self.helper.mem_write(buf_addr+len(bytes(out)[0:size])-1,b'\x00')
            self.helper.set_return(size)
            logger.console(LogType.INFO,'[snprintf] outputs :',out[0:size])
        else:
            self.helper.mem_write(buf_addr,bytes(out)[0:len(out)])
            self.helper.mem_write(buf_addr+len(bytes(out)[0:len(out)]),b'\x00')
            self.helper.set_return(len(out))
            logger.console(LogType.INFO,'[snprintf] outputs :',out)

        return True

# -----------------------------------------------------------------------------
@LibcStub('strcmp')
class strcmp(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        logger.console(LogType.INFO,'[strcmp] called at 0x%.8X'%(self.helper.get_pc()))
        s1_addr = self.helper.get_arg(0)
        s2_addr = self.helper.get_arg(1)
        ret=0
        s1=deref_until(self.helper,s1_addr,b'\0')
        s2=deref_until(self.helper,s2_addr,b'\0')
        logger.console(LogType.INFO,'comparing string\n%s\nvs\n%s'%(s1,s2))
        mlen = min(len(s1),len(s2))
        if mlen == 0 and len(s1)==0:
            for e in s2: ret+=e
        elif mlen == 0 and len(s2)==0:
            for e in s1: ret+=e
        else:
            for x in range(0,mlen):
                if s1[x] != s2[x]:
                    ret= s1[x] - s2[x]
                    break
        logger.console(LogType.INFO,'[strcmp] returns %d'%ret)
        self.helper.set_return(ret)
        return True

# -----------------------------------------------------------------------------
@LibcStub('strncmp')
class strncmp(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        """
        LIBC implementation breaks when first mismatch is found and returns distance between the two current chars.
        """
        logger.console(LogType.INFO,'[strncmp] called at 0x%.8X'%(self.helper.get_pc()))
        s1_addr = self.helper.get_arg(0)
        s2_addr = self.helper.get_arg(1)
        cmp_len = self.helper.get_arg(2)

        s1=deref_size(self.helper,s1_addr,cmp_len,delem=b'\x00')
        s2=deref_size(self.helper,s2_addr,cmp_len,delem=b'\x00')
        logger.console(LogType.INFO,'[strncmp] comparing strings\n %s\n vs\n %s\nfor len:%d'%(s1,s2,cmp_len))
        ret=0
        mlen = min(len(s1),len(s2))
        if mlen < cmp_len:
            cmp_len = mlen
        if mlen == 0 and len(s1)==0:
            for e in s2: ret+=e
        elif mlen == 0 and len(s2)==0:
            for e in s1: ret+=e
        else:
            for x in range(0,cmp_len):
                if s1[x] != s2[x]:
                    ret= s1[x] - s2[x]
                    break
        logger.console(LogType.INFO,'[strncmp] returns %d'%ret)
        self.helper.set_return(ret)
        return True

# -----------------------------------------------------------------------------
@LibcStub('strcat')
class strncat(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        dst_addr = self.helper.get_arg(0)
        src_addr = self.helper.get_arg(1)
        beg = deref_until(self.helper,dst_addr,delem=b'\0')
        end = deref_until(self.helper,src_addr,delem=b'\0')
        logger.console(LogType.INFO,'[strcat] happening: ',end,'(0x%.8X) to: '%src_addr,beg,'(0x%.8X) '%dst_addr)
        self.helper.mem_write(dst_addr+len(beg),end)
        self.helper.mem_write(dst_addr+len(beg)+len(end),b'\0')
        self.helper.set_return(dst_addr)
        return True

# -----------------------------------------------------------------------------

@LibcStub('strncat')
class strncat(Stub):

    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        dst_addr = self.helper.get_arg(0)
        src_addr = self.helper.get_arg(1)
        size = self.helper.get_arg(2)
        beg = deref_until(self.helper,dst_addr,delem=b'\0')
        end = deref_size(self.helper,src_addr,size,delem=b'\0')
        logger.console(LogType.INFO,'[strncat] happening: ',end,'(0x%.8X) to: '%src_addr,beg,'(0x%.8X) for size %d.'%(dst_addr,size))
        self.helper.mem_write(dst_addr+len(beg),end)
        self.helper.mem_write(dst_addr+len(beg)+len(end),b'\0')
        logger.console(LogType.INFO,'[strncat] out:',self.helper.mem_read(dst_addr,len(beg)+len(end)+1))
        self.helper.set_return(dst_addr)
        return True

# -----------------------------------------------------------------------------
@LibcStub('scandir')
class scandir(Stub):
    
    def __init__(self):
        super().__init__()
        

    def do_it(self,*args):
        path_addr = self.helper.get_arg(0)
        dirent_addr = self.helper.get_arg(1)
        search_func_addr = self.helper.get_arg(2) # TODO launch into other exec thread
        search_filter_addr = self.helper.get_arg(3) #TODO launch into other exec thread  
  
#         logger.console(LogType.INFO,'R0 = %x R1 = %x R2 = %x R3 = %x'%(path_addr,dirent_addr,search_func_addr,search_filter_addr))
        path=deref_until(self.helper,path_addr,b'\0')
        logger.console(LogType.INFO,'[scandir] path: ',path)
        entries = [e.name for e in os.path.os.scandir(path.decode('utf-8'))] #Python does not handle non utf-8 dir name
#         dirent_ret = libc_stubs['malloc'].do_it(self.helper,fromStub=True,size=len(entries)*4)
        dirent_ret = self.helper.malloc(len(entries)*4)
        nb_entry = 0
        dirent_struct_len = conf.dirent_struct_len
        for entry in entries:
            #TODO launch search & filter functions 
#             e_addr = libc_stubs['malloc'].do_it(self.helper,fromStub=True,size=(dirent_struct_len+len(entry)+1))
            e_addr = self.helper.malloc(dirent_struct_len+len(entry)+1)
            self.helper.mem_write(dirent_ret+nb_entry*4,int.to_bytes(e_addr,4,'little',signed=False))
            self.helper.mem_write(e_addr+dirent_struct_len,bytes(entry,'utf-8'))
            self.helper.mem_write(e_addr+dirent_struct_len+len(bytes(entry,'utf-8')),b'\x00')
            nb_entry+=1
        self.helper.mem_write(dirent_addr,int.to_bytes(dirent_ret,4,'little',signed=False))
        logger.console(LogType.INFO,'[scandir] returning %d'%nb_entry)
        self.helper.set_return(nb_entry)
        return True
        


# -----------------------------------------------------------------------------
@LibcStub('getpid')
class getpid(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[getpid]    returning %X'%conf.pid)
        self.helper.set_return(conf.pid) 
        return True

# -----------------------------------------------------------------------------
@LibcStub('__errno_location')
class __errno_location(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[__errno_location] returning : %x'%conf.errno_location)
        self.helper.set_return(confs.errno_location)
        return True

# -----------------------------------------------------------------------------
strtok_tokens = []
strtok_acu = 0
@LibcStub('strtok')
class strtok(Stub):
    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        """
        strtok uses the string allocation and replaces the delimiter with null char.
        it returns at each call the next location (between two '\0')
        """
        global strtok_tokens
        global strtok_acu
        logger.console(LogType.INFO,'[stubs] strtok called')
        str_addr=self.helper.get_arg(0)
        delem_addr=self.helper.get_arg(1)
        if delem_addr == 0:
            logger.console(LogType.INFO,'[strtok] : null delimiter')
            # useless, just for reader comprehension, if token is not find, str ptr is returned.
            self.helper.set_return(str_addr)
            return
        else:
            delem=deref_size(self.helper,delem_addr,1)
        if str_addr != 0:
            logger.console(LogType.INFO,'[strtok] first call, deleminator is : %s'%delem)
            strtok_acu = 0 # reinit. Warning: not reentrant code
            str=deref_until(self.helper,str_addr,b'\0')
            if str.find(delem) == -1:
                self.helper.set_return(str_addr) # useless, just for reader comprehension, if the token is not find, str ptr is returned.
                return
            else:
                strtok_tokens=str.split(delem)
                strtok_tokens.reverse() # for pop() purpose
        try:
            offset = len(strtok_tokens.pop())
            self.helper.mem_write(str_addr+offset+strtok_acu,b'\x00')
            self.helper.set_return(str_addr+strtok_acu)
            strtok_acu+=offset+str_addr+1 # add one to skip '\0'
        except IndexError:
            self.helper.set_return(0)
        return True



# -----------------------------------------------------------------------------
@LibcStub('index')
class index(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):

        s_addr=self.helper.get_arg(0)
        c=self.helper.get_arg(1)
        s=deref_until(self.helper,s_addr,b'\0') 

        idx = s.find(c)

        if idx < 0: self.helper.set_return(0)
        else:       self.helper.set_return(s_addr+idx)
          
        logger.console(LogType.INFO,'[index] search ',c,' in ',s,
                                    'idx: %d'%idx)
        return True
        
                                          
# -----------------------------------------------------------------------------

@LibcStub('strchr')
class strchr(Stub):

  def __init__(self):
    super().__init__()
  def do_it(self,*args):
    s_addr = self.helper.get_arg(0)
    c_in = self.helper.get_arg(1)

    haystack = deref_string(s_addr)
    idx = haystack.find(c_in)
    
    if idx < 0: self.helper.set_return(0)
    else:       self.helper.set_return(s_addr+idx)

    logger.console(LogType.INFO,'[strchr] needle: ',c_in,' haystack: ',haystack,
                                 'returns idx: %d'%idx)
    return True
    
    
# -----------------------------------------------------------------------------

@LibcStub('strstr')
class strstr(Stub):

  def __init__(self):

    super().__init__()
  def do_it(self,*args):
    haystack_addr = self.helper.get_arg(0)
    needle_addr = self.helper.get_arg(1)

    # according to glibc, it is always unsafely deref until
    # '\0' is found.
    needle = deref_string(self.helper,needle_addr)
    hs = deref_string(self.helper,haystack_addr)
    
    idx = hs.find(needle) 
    if idx < 0:  self.helper.set_return(0)
    else:        self.helper.set_return(haystack_addr+idx)


    logger.console(LogType.INFO,'[strstr] ','needle: ',needle,' haystack: ',
                                 hs,' idx: %d'%idx)
    return True

# -----------------------------------------------------------------------------

@LibcStub('strfry')
class strfry(Stub):

  def __init__(self):
    super().__init__()
  def do_it(self,*args):
    s = self.helper.get_arg(0)
    hs = deref_string(self.helper,s).decode('utf-8')

    swap = ''.join([random.choice(hs) for x in range(0,len(hs))])
    self.helper.mem_write(s,swap.encode('utf-8'))
    return True
    
      
# -----------------------------------------------------------------------------

@LibcStub('strdup')
@LibcStub('_strdup')
@LibcStub('__strdup')
class strdup(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        str_addr=self.helper.get_arg(0)
        logger.console(LogType.INFO,'[strdup] string addr is: %.8X'%str_addr)
        str=deref_until(self.helper,str_addr,b'\x00')
#         cpy_addr = libc_stubs['malloc'].do_it(self.helper,fromStub=True,size=(len(str)+1)) # add one for '\0'
        cpy_addr = self.helper.malloc(len(str)+1)
        if cpy_addr == 0:
          self.helper.set_return(0) 
        self.helper.mem_write(cpy_addr,str)
        self.helper.mem_write(cpy_addr+len(str),b'\x00')
        self.helper.set_return(cpy_addr)
        logger.console(LogType.INFO,'[strdup] returning string:',str)
        return True
       

# -----------------------------------------------------------------------------
@LibcStub('strndup')
@LibcStub('_strndup')
@LibcStub('__strndup')
class strdup(Stub):
    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        str_addr=self.helper.get_arg(0)
        size=self.helper.get_arg(1)
        logger.console(LogType.INFO,'[strndup] string addr is: %.8X size : %d'%(str_addr,size))
        str=deref_size(self.helper,str_addr,size,delem=b'\x00')
#         cpy_addr = libc_stubs['malloc'].do_it(self.helper,fromStub=True,size=(len(str)+1)) # add one for '\0'
        cpy_addr = self.helper.malloc(len(str)+1) 
        if cpy_addr == 0: 
          self.helper.set_return(0) 
        self.helper.mem_write(cpy_addr,str)
        self.helper.mem_write(cpy_addr+len(str),b'\x00')
        self.helper.set_return(cpy_addr)
        logger.console(LogType.INFO,'[strdup] returning string:',str)

        return True
# -----------------------------------------------------------------------------
@LibcStub('strtol')
class strtol(Stub):
    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        nptr = self.helper.get_arg(0)
        endptr = self.helper.get_arg(1)
        base = self.helper.get_arg(2)
        logger.console(LogType.INFO,'[strtol] nptr = 0x%.8X endptr = 0x%.8X base = %d'%(nptr,endptr,base))
        if base > 36 or base < 2:
            raise Exception('[strtol] invalid base')
        negative=False
        cur_c = 0
        str_num = b''
        c = self.helper.mem_read(nptr,1)
        logger.console(LogType.INFO,'[strtol]',c)
        if c == b'-':
            negative=True
        elif c == b'+': pass
        elif c == b'0': # handle 0x or 0X format. Attention not handling -0x,-0X,+0x+0X
            c = chr(int.from_bytes(self.helper.mem_read(nptr,1),'big'))
            cur_c+=1
            c = chr(int.from_bytes(self.helper.mem_read(nptr,1),'big'))
            if c.lower() == b'x':
                base=16
        else:
            str_num+=c
        while c != b'\0':
            cur_c+=1
            c = self.helper.mem_read(nptr+cur_c,1)
            try:
                if c != b'\0':
                    tot = int((str_num+c).decode('utf-8'),base)
                    str_num+=c
                else:
                     break
            except Exception as e:
                logger.console(LogType.INFO,e.__str__())
                logger.console(LogType.INFO,'[strtol] bad char detected : %d'%ord(c))
                break
        if tot > 0xFFFFFFFF:
            raise Exception('[strtol] str is to long')
            #TODO: see libc implem. Use two registers to return > 4 bytes results ?
        if cur_c == 0:
            self.helper.set_return(0)
            self.helper.mem_write(endptr,0)
        else:
            if negative: tot=-tot
            logger.console(LogType.INFO,'[strtol] returns %d'%tot)
            self.helper.set_return(tot)
            self.helper.mem_write(endptr,int.to_bytes(nptr+cur_c,4,'little',signed=False))
        return True



# -----------------------------------------------------------------------------
@LibcStub('socket')
class socket(Stub):

  def __init__(self):
        super().__init__()


  def do_it(self,*args):
    """ ignores all parameters, use only TCP Net """
    sock=NWSock()
    nsock_list[sock.fd] = sock
    self.helper.set_return(sock.fd)
    return True
    

# -----------------------------------------------------------------------------
@LibcStub('recv')
class recv(Stub):

    def __init__(self):
        super().__init__()


    def do_it(self,*args):
      sock_fd  = self.helper.get_arg(0)
      buf_addr = self.helper.get_arg(1)
      len_t    = self.helper.get_arg(2)
      flags    = self.helper.get_arg(3) 

      logger.console(LogType.INFO,'[recv] sock_fd: %d'%sock_fd,
                                  '       buf_addr: %x'%buf_addr,
                                  '       len: %d'%len_t,
                                  '       flags :%x'%flags)

#       data = nsock_list[sock_fd].recv_broker(len)
      data = NWSock.recv_broker(len_t,sock_fd)
      logger.console(LogType.INFO,'[recv] received:\n',data)
      if len(data): self.helper.mem_write(buf_addr,data)
      self.helper.set_return(len(data))
      return True


# -----------------------------------------------------------------------------
@LibcStub('send')
class send(Stub):

    def __init__(self):
        super().__init__()


    def do_it(self,*args):
      sock_fd  = self.helper.get_arg(0)
      buf_addr = self.helper.get_arg(1)
      len_t    = self.helper.get_arg(2)
      flags    = self.helper.get_arg(3) 

      
      logger.console(LogType.INFO,'[send] sock_fd: %d'%sock_fd,
                                  '       buf_addr: %x'%buf_addr,
                                  '       len: %d'%len,
                                  '       flags :%x'%flags)
      
      data = self.helper.mem_read(buf_addr,len_t)
#       size = nsock_list[sock_fd].send(data)
      size=NWSock.send(data,sock_fd)
      logger.console(LogType.INFO,'[send] returns: %d\n',size)
      self.helper.set_return(size)
      return True




# -----------------------------------------------------------------------------
#TODO : remove specific content
#FOR ATL LIB
#result is expected to be writted back in addr hold by R2
@LibcStub('g_file_get_contents')
class g_file_get_contents(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[g_file_get_contents] called, returning 0x34')
        self.helper.mem_write(self.helper.get_arg(2),b'\x34')
        self.helper.set_return(0x34) # returns 0
        return True

# -----------------------------------------------------------------------------
@LibcStub('strerror')
class strerror(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        r0 = self.helper.get_arg(0)
        logger.console(LogType.INFO,'[strerror] 0x%2X'%r0)
        self.helper.set_return(conf.errno_location)
        return True

@LibcStub('_scanf')
@LibcStub('scanf')
class scanf(Stub):

    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        format_addr = self.helper.get_arg(0)

        format = deref_string(self.helper,
                              format_addr).decode('utf-8')

        patt=re.compile('%[sd]')
        fmts = patt.findall(format)
        if not fmts:
            logger.console(LogType.WARN,
                           "[stub] scanf unsupported format: %s"%format)
            return True

        fmt_vals = list()
        target_addr = self.helper.get_arg(1)
        for i,f in enumerate(fmts):
            
            if f == '%d':
                val = ida_kernwin.ask_str('0xFFFFFFFF',False,'scanf("%d")=')
                fmt_vals.append(('%d',struct.pack('>I',int(val,16))))
            elif f == '%s':
                val = ida_kernwin.ask_str('scanf string',False,'scanf("%s")=')
                fmt_vals.append(('%s',val))

        outter = patt.split(format)
        out_chain = b''
        fmt_vals.reverse()
        for i,f in enumerate(outter):
            if f == '':
                try:
                    k,v = fmt_vals.pop()
                except:
                    break

                if k == '%d':
                    out_chain += v
                elif k == '%s':
                    out_chain += v.encode('utf-8')

            else:
                out_chain += f.encode('utf-8')
        logger.console(LogType.INFO,"[stub] scanf(%s) write %s at %x"%(format,
                                                                out_chain.decode('utf-8'),
                                                                target_addr))

        return True

       
      


```

`EWS/stubs/ELF/conf.py`:

```py
dirent_struct_len = 0xB
pid = 0x666
errno_location = 0x10000 
scanf_string = 'scanf_string_yolo'

```

`EWS/stubs/ELF/utils.py`:

```py
import socket

from EWS.utils.utils import *
from EWS.utils.utils import LogType
import struct

#-------------------------------------------------------------
# FILE manipulation helper
#-------------------------------------------------------------
STDIN=0
STDOUT=1
STDERR=2


fd_list = {}

class FILE(object):

    def __init__(self,fd,mode):
        self.fd=fd
        self.mode=mode

    def write(self,data):
        if 'wb' in self.mode:
            self.fd.write(bytes(data))
        else:
            for c in data:
                self.fd.write(chr(c))

    def read(self,size):
        return self.fd.read(size)

    def close(self):
        self.fd.close()

    def fflush(self):
        self.fd.flush()

    def fseek(self,offset,whence):
        self.fd.seek(offset,whence)

    def readline(self):
        return self.fd.readline()

#-------------------------------------------------------------
# Network Socket 
#-------------------------------------------------------------


nsock_list = {} 
sssss = None 
class NWSock(object):
  
  def __init__(self,mode=SockMode.UKN):
    
    self.fd = len(nsock_list) + 1
    self.mode = mode
    


  def bind(self):
    self.mode=SockMode.READ 

  @staticmethod
  def recv_broker(len,fd=0):
    """ mode broker: to get the data, this function connects
                     to localhost:6666
    """ 

    if sssss == None:
      s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
      try:
        s.connect(('localhost',6666))
      except ConnectionRefusedError:
        logger.console(LogType.WARN,'[!] Could not connect to localhost:6666 to receive data\n',
                                    'Make sure that a server is ready to send data (ex: nc -l -p 6666 < data_file)')
        return b''  
    return s.recv(len)

  @staticmethod
  def send(msg,fd=0):
    """ mode broker: to get the data, this function connects
                     to localhost:6666
    """ 

    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
      s.connect(('localhost',6667))
    except ConnectionRefusedError:
      logger.console(LogType.WARN,'[!] Could not connect to localhost:6667.\n',
                                  'Make sure that a server is ready to receive data (ex: nc -l -p 6666 < data_file)')
      return -1  
    return s.send(msg)



    






#-------------------------------------------------------------
# String deref and manipulation helpers
#-------------------------------------------------------------


def deref_string(helper,addr):
    return deref_until(helper,addr,b'\x00')

def deref_until(helper,addr,delem):
    out=b''
    i=0
    while True:
        c=helper.mem_read(addr+i,1)
        if c == delem or c == b'\0':
            break
        out+=bytes(c)
        i+=1
    return out

def deref_size(helper,addr,size,delem=None):
    out=b''
    i=0
    while i<size:
        c=helper.mem_read(addr+i,1)
        if delem != None and c == delem:
            break
        out+=bytes(c)
        i+=1
    return out


def deref_format(helper,format,arg_num):
  """ argnum is the number of the first argument to be used 
  """

  deref_list = [] 
  for r in format:
    cur_arg = helper.get_arg(arg_num)
    logger.console(LogType.INFO,'cur arg = %x'%cur_arg)
    if r.strip() == '%s':
      deref_list.append(deref_until(helper,cur_arg,b'\0'))
    elif r.strip() in [ '%d', '%ld', '%x', '%p']: 
      dword = struct.pack('<I',helper.mem_read(helper,cur_arg))
    else :
      logger.console(LogType.WARN,'%s format unsupported')
    arg_num+=1 
  return deref_list


def build_chain(helper,format_l,values):

    out = b''
    for f in format_l:
        if  f == '%s' : out+=values.pop()
        elif f == '%d' : out+=bytes('%d'%values.pop(),'utf-8')
        elif f == '%ld': out+=bytes('%ld'%values.pop(),'utf-8')
        elif f == '%x' : out+=bytes('%x'%values.pop(),'utf-8')
        elif f == '%p' : out+=bytes('%x'%values.pop(),'utf-8')
        elif f != ''   : out+=bytes(f,'utf-8')  # case its encapsulated 
                                                #basic string ( %x basic string %s )

    return out

def write_to_fd(fdnum,fdesc_l,out):

    ln = 0 
    if fdnum > 2 and fdnum in fdesc_l:
          ln = fdesc_l[fdnum].write(bytes(out))
          logger.console(LogType.INFO,'[fprintf] on fd %d outputs: '%fd,out)
          return ln 
    elif fdnum == 2:
          logger.console(LogType.INFO,'[fprintf@strderr] outputs:', out)
    elif fdnum == 1: 
          logger.console(LogType.INFO,'[fprintf@stdout] outputs:', out)
    else:
          logger.console(LogType.INFO,'[fprintf@stdin] outputs:', out)
    return len(out)







```

`EWS/stubs/PE/PE.py`:

```py
# from stubs import stubs_conf
# from stubs.stubs_helper import *    
from EWS. utils.utils import *
import codecs
import re
from enum import Enum
import os
from os import path 
import tempfile
import struct
import random
import struct
from EWS.stubs.ELF.utils import * 



# -----------------------------------------------------------------------------
"""                                 """
"         STUB OBJECTS        "
"""                                 """
# -----------------------------------------------------------------------------

 
class Stub(object):
    """
    stub object
    """

    def __init__(self,helper=None,
                 stub_type=StubType.BUILTIN,
                 name:str='undef stub'):
        """
        constructor of Stub object
        param:
            helper: abstraction of all emulator operations
        """
        self.helper = helper
        self.stub_type = stub_type
        self.name = name

    def set_helper(self,helper):
        """
        setter of stub object
        param:
            helper: abstraction of all emulator operations
        """
        self.helper = helper

windows_stubs = dict()

class WinStub():
    """
    WinStub:
    decorator to populate windows stub
    """
    def __init__(self,name):
        """
        constructor of WinStub decorator object
        """
        assert name not in windows_stubs
        self.name = name

    def __call__(self,cls):
        """
        populate windows_stubs list with instances of stubs object
        param:
            class object corresponding to the decorated object
        """
        obj = cls()
        windows_stubs[self.name] = obj
        return cls



class NullStub(Stub):

    """
    NullStub is used to hook with minimal artefact the call
    to a method.
    Inherits from this object to stub a symbol.
    """
    def __init__(self,helper=None):
        """
        constructor of NullStub object
        """
        super().__init__(helper)

    def do_it(self,*args):

        """
        code definition of NullStub
        Basically just returns 0 using set_return method.
        Warning, this could create artifact.
        """
        logger.console(LogType.INFO,'[stubs] null stub is called')
        self.helper.set_return(0)
        return True



# -----------------------------------------------------------------------------
"""                                     """
"     STUBBED FUNCTIONS     "
"""                                     """
# -----------------------------------------------------------------------------

@WinStub('lstrlenA')
class lstrlenA(Stub):
    def __init__(self):
        super().__init__()

    def do_it(self,*args):
        str_addr = self.helper.get_arg(0)
        str_ = deref_string(self.helper,str_addr)
        self.helper.set_return(len(str_))

        return True

        

@WinStub('RegEnumKeyExW')
class RegEnumKeyExW(Stub):
    def __init__(self):
        super().__init__()



    def do_it(self,*args):
        logger.console(LogType.INFO,'[stubs] RegEnumKeyExW')
        hkey = self.helper.get_arg(0)
        dwIndex = self.helper.get_arg(1)
        lpName = self.helper.get_arg(2)
        lpcchName = self.helper.get_arg(3)
        lpReserved = self.helper.get_arg(4)
        lpClass = self.helper.get_arg(5)
        lpcchClass = self.helper.get_arg(6)
        lpftLastWriteTime = self.helper.get_arg(7) 

        logger.console(LogType.INFO,'args :',hkey,dwIndex,lpName,lpcchName)

        return True

@WinStub('malloc')
class malloc(Stub):
    def __init__(self,):
        super().__init__()



    def do_it(self,*args):
        logger.console(LogType.INFO,'[stubs] malloc')
        alloc_size = self.helper.get_arg(0)
        addr = self.helper.malloc(alloc_size)
        self.helper.set_return(addr)
        logger.console(LogType.INFO,'[stubs] malloc returns addr 0x%x'%addr)
        return True

@WinStub('rand')
class rand(Stub):

    def __init__(self,):
        super().__init__()

    def do_it(self,*args):
        logger.console(LogType.INFO,'[stubs] rand')
        r = random.randint(0,0xFFFFFFFF)
        self.helper.set_return(r)
        logger.console(LogType.INFO,'[stubs] rand returns %x'%r)
        return True


```

`EWS/stubs/allocators/allocator.py`:

```py
from EWS.utils.utils import *


class Allocator(object):
    pass



class DumpAllocator(Allocator):

  """ 
  !keep tracks of allocation 
  """

  class Chunck():



      """ 
      !create a memory chunk

      @param addr effective address of the allocation
      @param size size of the chunk

      """ 

      def __init__(self,addr,size):
        self.addr = addr 
        self.size = size
   
   
  def __init__(self,base_addr,max_size):

    """ 
    !create a memory chunk

    @param addr effective address of the allocation
    @param size size of the chunk

    """ 


    self.max_addr = base_addr + max_size
    self.last_alloc = base_addr
    self.base_addr = base_addr
    self.allocs = list()
    self.freelist = list() 

  def malloc(self,size):

    """ 
    !perform malloc ops

    @param size requested size 

    @return Effective Address of the new allocated chunk
    
    """



    idx = 0 
    for c in self.freelist:
      if c.size >= size: 
        addr = c.addr 
        self.allocs.append(c)
        del self.freelist[idx]
        return addr  
      idx+=1
    addr = self.last_alloc 
    assert addr + size < self.max_addr
    self.last_alloc += size 
    self.allocs.append(DumpAllocator.Chunck(addr,size))
    return addr

  def free(self,addr):


    """ 
    !free op 

    @param addr Effective Address of the allocated chunk to be freed

    """


    if addr in [ x.addr for x in self.freelist ]:
      raise Exception('[free] attempting to free a free chunck') 

    if addr not in [ x.addr for x in self.allocs ] : 
      raise Exception('[free] attempting to free unbased chunck addr') 

    idx = 0 

    for c in self.allocs:
      if c.addr == addr: 
        self.freelist.append(c)
        del self.allocs[idx]
        break 
      idx +=1 
    
  def find_adj(self,addr):
    """ 
    !find_adj find adjacent block given addr 

    @param addr Effective Address
    """

    l_k = -1
    for k in self.allocs.keys():
      if k > addr:
        l_k = k 
      if k == addr:
        return k 
    return l_k

  def __str__(self) -> str:

    """
    !str() method implementation 

    """ 


    for c in self.allocs:
      logger.console(LogType.INFO,'[+]Chunck at 0x%x with size %d'%(c.addr,c.size))
    return ''

  def reset(self):

    """ 
    !resets the allocator structure. Caution: it does not clean the emualor memory.

    """

    self.allocs = list()
    self.freelist = list()
    self.last_allocs = self.base_addr
 


if __name__ == '__main__':
  alloc = DumpAllocator(0x80000000,0x2000)
  addr= alloc.malloc(100)
  addr2 = alloc.malloc(200)
  alloc.free(addr)
  addr3 = alloc.malloc(100)
  addr4 = alloc.malloc(240)
  


```

`EWS/stubs/emu/unicorn/sea.py`:

```py
from EWS.stubs.generic import StubEngineAbstractor  
#from EWS.stubs.emu.generic import StubEngineAbstractor  
from EWS.emu.unicorn.generic import Emucorn
import EWS.emu.unicorn.arm32 
import EWS.emu.unicorn.mipsl32
import EWS.emu.unicorn.generic 
import struct 


class UnicornSEA(StubEngineAbstractor):
  
  def __init__(self,emu,allocator,wsize):

    super().__init__(emu,allocator,wsize)

  def mem_read(self,
               addr:int,
               size:int)->bytes:

    return self.emu.mem_read(addr,size)

  def mem_write(self,addr:int,
              data:bytes):

    self.emu.mem_write(addr,data)

  def reg_read(self,
               reg_id) -> int:

    return self.emu.reg_read(self.reg_conv(reg_id))


  def reg_write(self,
                reg_id,
                data:int):

    self.emu.reg_write(self.reg_conv(reg_id),data)


  def reg_conv(self,
               reg_id):

    raise NotImplemented

  def get_arg(self,
              arg_num:int) -> int:

    #NOTE: must return an integer, not bytes   

    raise NotImplemented 

  def push(self,
           sp_id,
           value:int,
           endianness='little'):
      
    sp = self.reg_read(sp_id)
    sp -= self.wsize
    self.mem_write(sp,int.to_bytes(value,self.wsize,endianness,signed=False))
    self.reg_write(sp_id,sp)

  def pop(self,
          sp_id,
          reg_return,
          endianness='little'):


    # use reg_return == -1 to not pop value to a register  
    sp = self.reg_read(self.reg_conv(sp_id))
    value = self.mem_read(sp,self.wsize)
    sp += self.wsize
    self.reg_write(sp_id,sp)
    if reg_return == -1:
      return value  
    self.reg_write(reg_return,int.from_bytes(value,endianness,signed=False))
    
"""          """
"     ARM      "
"""          """


class UnicornArmSEA(UnicornSEA):

  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)


  def reg_conv(self,r_id):
    return EWS.emu.unicorn.arm32.ArmCorn.reg_convert(r_id)
   

  def get_arg(self,arg_num):
    if arg_num == 0:
      return self.reg_read(0)
    elif arg_num == 1:
      return self.reg_read(1)
    elif arg_num == 2: 
      return self.reg_read(2)
    elif arg_num == 3:
      return self.reg_read(3)
    else:
      return self.pop(13,-1) 

  def set_return(self,value):
    self.reg_write(0,value)
  
  def get_pc(self):
    return self.reg_read(15)

  def get_sp(self):
    return self.reg_read(13)

"""             """
"     AARCH64     "
"""             """

class UnicornAarch64SEA(UnicornSEA):

  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)


  def reg_conv(self,r_id):
    return EWS.emu.unicorn.aarch64.Aarch64Corn.reg_convert(r_id)
   
  def get_arg(self,arg_num):
    if arg_num == 0:
      return self.reg_read(0)
    elif arg_num == 1:
      return self.reg_read(1)
    elif arg_num == 2: 
      return self.reg_read(2)
    elif arg_num == 3:
      return self.reg_read(3)
    elif arg_num == 4:
      return self.reg_read(4)
    elif arg_num == 5:
      return self.reg_read(5)
    elif arg_num == 6:
      return self.reg_read(6)
    elif arg_num == 7:
      return self.reg_read(7)
    elif arg_num == 8:
      return self.reg_read(8)
    else:
      return self.pop(31,-1) 

  def set_return(self,value):
    self.reg_write(0,value)
  
  def get_pc(self):
    return self.reg_read(260) # pc

  def get_sp(self):
    return self.reg_read(31)



"""          """
"     MIPS     "
"""          """


class UnicornMipslSEA(UnicornSEA):
  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)


  def reg_conv(self,r_id):
    return EWS.emu.unicorn.mipsl32.MipsCorn.reg_convert(r_id)

  
  def get_arg(self,arg_num):
    if arg_num == 0:
      return self.reg_read('a0')
    elif arg_num == 1:
      return self.reg_read('a1')
    elif arg_num == 2: 
      return self.reg_read('a2')
    elif arg_num == 3:
      return self.reg_read('a3')
    else:
      return self.pop('sp',-1,'little') 

  def set_return(self,value):
    self.reg_write('v0',value)

  def get_pc(self):
    return self.reg_read('pc')

  def get_sp(self):
    return self.reg_read('sp')
  


class UnicornMipsbSEA(UnicornSEA):
  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)


  def reg_conv(self,r_id):
    return EWS.emu.unicorn.mipsl32.MipsCorn.reg_convert(r_id)
  
  
  def get_arg(self,arg_num):
    if arg_num == 0:
      return self.reg_read('a0')
    elif arg_num == 1:
      return self.reg_read('a1')
    elif arg_num == 2: 
      return self.reg_read('a2')
    elif arg_num == 3:
      return self.reg_read('a3')
    else:
      return self.pop('sp',-1,'big') 

  def set_return(self,value):
    self.reg_write('v0',value)

  def get_pc(self):
    return self.reg_read('pc')

  def get_sp(self):
    return self.reg_read('sp')



"""          """
"     X86      "
"""          """


  
class UnicornX86SEA(UnicornSEA):

  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)


  def reg_conv(self,r_id):
    return EWS.emu.unicorn.x86.x86Corn.reg_convert(r_id)

 
  def get_arg(self,arg_num):
    esp = self.reg_read('esp')
    # TODO may add heuristic to detect compiler/linker 
    # Warning: May change accordingly to the compiler/linker. 
    # here it correspond to a plt that perform jmp [got_addr] 
    # if call [got_addr] is used, this is invalid 
    return struct.unpack('<I',self.mem_read(esp+arg_num*self.wsize+self.wsize,
                                            self.wsize))[0] 

  def set_return(self,value):
    self.reg_write('eax',value)
  
  def get_pc(self):
    return self.reg_read('eip')

  def get_sp(self):
    return self.reg_read('esp')

"""             """
"     X86_64      "
"""             """


#TODO create other instance for GCC compiler
class UnicornX64SEA(UnicornSEA):

  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)

  def reg_conv(self,r_id):
    return EWS.emu.unicorn.x64.x64Corn.reg_convert(r_id)


  def get_arg(self,arg_num):
    if arg_num == 0:
      return self.reg_read('rdi')
    elif arg_num == 1:
      return self.reg_read('rsi')
    elif arg_num == 2:
      return self.reg_read('rdx')
    elif arg_num == 3:
      return self.reg_read('rcx')
    elif arg_num == 4:
      return self.reg_read('r8')
    elif arg_num == 5:
      return self.reg_read('r9')
    else:
      rsp = self.reg_read('rsp')
      # PLT stubbed, so when the call is performed
      # at call pomoent looks like:
      # ret @ <---- rsp
      # arg(6)
      return struct.unpack('<Q',self.mem_read(rsp+(arg_num-5)*self.wsize,self.wsize)) 
  def set_return(self,value):
    self.reg_write('rax',value)
  
  def get_pc(self):
    return self.reg_read('rip')

  def get_sp(self):
    return self.reg_read('rsp')

class UnicornX64MSVCSEA(UnicornSEA):
  def __init__(self,emu,allocator,wsize):
    super().__init__(emu,allocator,wsize)

  def reg_conv(self,r_id):
    return EWS.emu.unicorn.x64.x64Corn.reg_convert(r_id)


  def get_arg(self,arg_num):
    if arg_num == 0:
      return self.reg_read('rcx')
    elif arg_num == 1:
      return self.reg_read('rdx')
    elif arg_num == 2:
      return self.reg_read('r8')
    elif arg_num == 3:
      return self.reg_read('r9')
    else:
      rsp = self.reg_read('rsp')
      # call insn is nopped hence ret @ is not pushed on the stack
      return struct.unpack('<Q',self.mem_read(rsp+(arg_num-4)*self.wsize,self.wsize)) 

  def set_return(self,value):
    self.reg_write('rax',value)
  
  def get_pc(self):
    return self.reg_read('rip')

  def get_sp(self):
    return self.reg_read('rsp')




```

`EWS/stubs/generic.py`:

```py
from EWS.stubs.allocators.allocator import Allocator
from EWS.emu.emubase import Emulator


class StubEngineAbstractor(object):
  
  """ 
  !Mother class for all operation exposed to the stubs
      It also define the calling convention th. get_arm()
      and set_return() functions. 
      This interface defines: 
        - emu : a reference to the emu object 
        - allocator : a reference to the alloc mechanism
        - wsize : 16/32/64 bit value for pop/push ops.  

  """ 

  def __init__(self,
               emu: Emulator,
               allocator:Allocator,
               wsize:int):

    """ 
    !Constructor of the Stub Engine Abstractor class. 

    @param emu Reference to the current emulator solution
    @param allocator Reference to the allocator 
    @param wsize Word Size  

    @return New helper 

    """

    self.emu = emu
    self.allocator = allocator
    self.wsize = wsize

  def mem_read(self,
               addr:int,
               size:int) -> bytes:

    """ 
    !returns value from emulator memory 
    
    @param addr Effective Address to read from
    @param size Size of the read operation 

    @return read bytes

    """

    pass


  def mem_write(self,
                addr:int,
                value:bytes) -> None: 
    """ 
    !write value to emulator memory 

    @param addr Effective Address of the write operation
    @param value Data to be written 


    """ 

    pass


  def reg_read(self,
               reg_id) -> int: 

    """ 
    !Returns register value from reg_id (int) 
    
    @param reg_id Register identified in the emulator solution (either string or int)

    @retun content value of the register 

    """

    pass


  def reg_write(self,
                reg_id,
                value:int) -> None:

    """ 
    !Write value to reg_id register 

    @param reg_id Register identified in the emulator solution (either string or int)
    @param value Register to write inside to the register 

    
    """ 

    pass


  def get_arg(self,
              arg_num:int) -> int:

    """ 
    !returns the value of the number arg_num register
        according to the calling convention. 

    @param arg_num argument number to unpack 

    @return value of the argument 

    """

    raise NotImplemented

  def set_return(self,
                 value:int) -> None:

    """ 
    !Set the return value according
        to the calling convention.

    @param value Return value 

    """ 
    raise NotImplemented

  def cleanstuff(self,
                 nbytes:int) -> None:

    """ 
    !for cdecl functions 
      nbytes: int number of bytes to add to SP clean

    @param nbytes Number of byte to clean from the stack

    """

    raise NotImplemented


  def malloc(self,
             size:int):
    """ 
    !Do an allocation within the allocator memory. 

    @param size Size of the allocation to be performed. 

    """


    return self.allocator.malloc(size)



  def free(self,
           addr:int) -> None:

      """ 
      ! Call free method of the allocator 

      @param addr Effective Address of the first byte of the allocator.
      """
      
      self.allocator.free(addr) 

  def push(self,
           sp_id,
           value:int) -> None:
      """ 
      !Push operation 

      @param sp_id Identifier of the Stack Pointer within the emulator solution 
      @param value Value to be pushed onto the stack 

      """
      pass

  def pop(self,
          sp_id,
          reg_return) -> None:
    """ 
    !Pop Value from the stack 

    @param sp_id Identifier of the Stack Pointer within the emulator solution 
    @param reg_return identifier of the register receiving the data

    """

    pass


  def get_pc(self):

    """ 
    !returns program counter value

    """
    raise NotImplemented


  def get_sp(self):

    """ 
    !returns the stack pointer value

    """ 

    raise NotImplemented


 

 



```

`EWS/ui/Olds/aarch64.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

FormDesc = r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS ARML32
{cbCallback}
Mapping Configuration
<## Page size  :{iPageSize}> | <## Stack base address: {iStkBA}> | <## Stack size: {iStkSize}>
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
<##Start Mapping (ea in IDB):{sMapping}> | <##End Mapping (ea in IDB):{eMapping}>   
<## Map using segments## No:{sNo}> <Yes:{sYes}>{cCSeg}> | <## Use segment perms ## No:{spNo}> <Yes:{spYes}>{spCSeg}>
<Segment: {cSegChooser}>
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
<##X0:{X0}>  |<##X1:{X1}>  |<##X2:{X2}>  |<##X3:{X3}> |<##X4:{X4}>
<##X5:{X5}>  |<##X6:{X6}>  |<##X7:{X7}>  |<##X8:{X8}> |<##X9:{X9}>
<##X10:{X10}> |<##X11:{X11}>| <##X12:{X12}>|<##SP:{X13}>
<##X14:{X14}> |<##X15:{X15}>|<##X16:{X16}>|<##X17:{X17}>
<##X18:{X18}> |<##X19:{X19}>|<##X20:{X20}>|<##X21:{X21}>
<##X22:{X22}> |<##X23:{X23}>|<##X24:{X24}>|<##X25:{X25}>
<##X26:{X26}> |<##X27:{X27}>|<##X28:{X28}>|<##FP:{FP}>
<##LR:{LR}>  |<##SP:{SP}>|<##PC:{PC}>
Display Configuration
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
"""

class Aarch64Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    self.memory_init = AdditionnalMapping({}) 
    if self.conf == None:
        Form.__init__(self, FormDesc ,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'cCSeg': Form.RadGroupControl(("sNo","sYes")),
            'spCSeg': Form.RadGroupControl(("spNo","spYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'X0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X2': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X3': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X4': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X5': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X6': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X7': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X8': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X10': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X11': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X12': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X13': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X14': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X15': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X16': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X17': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X18': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X19': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X20': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X21': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X22': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X23': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X24': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X25': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X26': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X27': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X28': Form.NumericInput(tp=Form.FT_RAWHEX),
            'FP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'LR': Form.NumericInput(tp=Form.FT_RAWHEX),
            'SP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'PC': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})
    else:
        Form.__init__(self, FormDesc ,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX, 
                                           value=self.conf.p_size), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX,
                                        value=self.conf.stk_ba),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX,
                                          value=self.conf.stk_size),
            'cAGrp': Form.RadGroupControl(("aNo","aYes"),
                                          value=1 if self.conf.autoMap else 0),
            'cRGrp': Form.RadGroupControl(("rNo","rYes"),
                                          value=1 if self.conf.showRegisters else 0),
            'cCGrp': Form.RadGroupControl(("cNo","cYes"),
                                          value=1 if self.conf.useCapstone else 0),
            'cCSeg': Form.RadGroupControl(("sNo","sYes"),
                                          value=1 if self.conf.map_with_segs else 0),
            'spCSeg': Form.RadGroupControl(("spNo","spYes"),
                                           value=1 if self.conf.use_seg_perms else 0),
            'maGrp': Form.RadGroupControl(("maNo","maYes"),
                                          value=1 if self.conf.showMemAccess else 0),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes"),
                                          value=1 if self.conf.color_graph else 0),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_saddr),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_eaddr),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_saddr),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_eaddr),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'X0': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X0),
            'X1': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X1),
            'X2': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X2),
            'X3': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X3),
            'X4': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X4),
            'X5': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X5),
            'X6': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X6),
            'X7': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X7),
            'X8': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X8),
            'X9': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X9),
            'X10': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X10),
            'X11': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X11),
            'X12': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X12),
            'X13': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X13),
            'X14': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X14),
            'X15': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X15),
            'X16': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X16),
            'X17': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X17),
            'X18': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X18),
            'X19': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X19),
            'X20': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X20),
            'X21': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X21),
            'X22': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X22),
            'X23': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X23),
            'X24': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X24),
            'X25': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X25),
            'X26': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X26),
            'X27': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X27),
            'X28': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X28),
            'FP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X29),
            'LR': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X30),
            'SP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.X31),
            'PC': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.PC),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})


        self.s_conf = conf.s_conf
        self.amap_conf = conf.amap_conf
        self.memory_init = conf.memory_init



  def onSaveButton(self,code):
    conf = Configuration(     path='',
                              arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=self.GetControlValue(self.iPageSize),
                              stk_ba=self.GetControlValue(self.iStkBA),
                              stk_size=self.GetControlValue(self.iStkSize),
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=self.GetControlValue(self.sMapping),
                              mapping_eaddr=self.GetControlValue(self.eMapping),
                              segms=self.segs,
                              map_with_segs=self.GetControlValue(self.cCSeg),
                              use_seg_perms=self.GetControlValue(self.spCSeg),
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=Aarch64Registers(self.GetControlValue(self.X0),
                                                      self.GetControlValue(self.X1),
                                                      self.GetControlValue(self.X2),
                                                      self.GetControlValue(self.X3),
                                                      self.GetControlValue(self.X4),
                                                      self.GetControlValue(self.X5),
                                                      self.GetControlValue(self.X6),
                                                      self.GetControlValue(self.X7),
                                                      self.GetControlValue(self.X8),
                                                      self.GetControlValue(self.X9),
                                                      self.GetControlValue(self.X10),
                                                      self.GetControlValue(self.X11),
                                                      self.GetControlValue(self.X12),
                                                      self.GetControlValue(self.X13),
                                                      self.GetControlValue(self.X14),
                                                      self.GetControlValue(self.X15),
                                                      self.GetControlValue(self.X16),
                                                      self.GetControlValue(self.X17),
                                                      self.GetControlValue(self.X18),
                                                      self.GetControlValue(self.X19),
                                                      self.GetControlValue(self.X20),
                                                      self.GetControlValue(self.X21),
                                                      self.GetControlValue(self.X22),
                                                      self.GetControlValue(self.X23),
                                                      self.GetControlValue(self.X24),
                                                      self.GetControlValue(self.X25),
                                                      self.GetControlValue(self.X26),
                                                      self.GetControlValue(self.X27),
                                                      self.GetControlValue(self.X28),
                                                      self.GetControlValue(self.FP),
                                                      self.GetControlValue(self.LR),
                                                      self.GetControlValue(self.SP),
                                                      self.GetControlValue(self.PC)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              memory_init=self.memory_init,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints= self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)

      if not conf.map_with_segs: self.EnableField(self.cSegChooser,False)
      else: 
          self.EnableField(self.sMapping, False)
          self.EnableField(self.eMapping, False)
          self.EnableField(self.cSegChooser,True)


      segms = get_seg_list()
      s_chooser = [] 
      
      i=0 
      for x in segms:
        if x in conf.segms:
          s_chooser.append(i)
        i+=1
    
      self.SetControlValue(self.cSegChooser,s_chooser)

      self.SetControlValue(self.iPageSize,conf.p_size)
      self.SetControlValue(self.iStkBA,conf.stk_ba)
      self.SetControlValue(self.iStkSize,conf.stk_size)
      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.sMapping,conf.mapping_saddr)
      self.SetControlValue(self.eMapping,conf.mapping_eaddr)
      self.segs = conf.segms
      self.SetControlValue(self.cCSeg,conf.map_with_segs)
      self.SetControlValue(self.spCSeg,conf.use_seg_perms)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.X0,conf.registers.X0)
      self.SetControlValue(self.X1,conf.registers.X1)
      self.SetControlValue(self.X2,conf.registers.X2)
      self.SetControlValue(self.X3,conf.registers.X3)
      self.SetControlValue(self.X4,conf.registers.X4)
      self.SetControlValue(self.X5,conf.registers.X5)
      self.SetControlValue(self.X6,conf.registers.X6)
      self.SetControlValue(self.X7,conf.registers.X7)
      self.SetControlValue(self.X8,conf.registers.X8)
      self.SetControlValue(self.X9,conf.registers.X9)
      self.SetControlValue(self.X10,conf.registers.X10)
      self.SetControlValue(self.X11,conf.registers.X11)
      self.SetControlValue(self.X12,conf.registers.X12)
      self.SetControlValue(self.X13,conf.registers.X13)
      self.SetControlValue(self.X14,conf.registers.X14)
      self.SetControlValue(self.X15,conf.registers.X15)
      self.SetControlValue(self.X16,conf.registers.X16)
      self.SetControlValue(self.X17,conf.registers.X17)
      self.SetControlValue(self.X18,conf.registers.X18)
      self.SetControlValue(self.X19,conf.registers.X19)
      self.SetControlValue(self.X20,conf.registers.X20)
      self.SetControlValue(self.X21,conf.registers.X21)
      self.SetControlValue(self.X22,conf.registers.X22)
      self.SetControlValue(self.X23,conf.registers.X23)
      self.SetControlValue(self.X24,conf.registers.X24)
      self.SetControlValue(self.X25,conf.registers.X25)
      self.SetControlValue(self.X26,conf.registers.X26)
      self.SetControlValue(self.X27,conf.registers.X27)
      self.SetControlValue(self.X28,conf.registers.X28)
      self.SetControlValue(self.FP,conf.registers.FP)
      self.SetControlValue(self.LR,conf.registers.LR)
      self.SetControlValue(self.SP,conf.registers.SP)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.memory_init = conf.memory_init
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    if fid == self.sAddr.id:
          self.SetControlValue(self.PC,self.GetControlValue(self.sAddr))
    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = Aarch64Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
      
          ret = Configuration(path=f.conf_path,arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=f.iPageSize.value,
                              stk_ba=f.iStkBA.value,
                              stk_size=f.iStkSize.value,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=f.sMapping.value,
                              mapping_eaddr=f.eMapping.value,
                              segms=f.segs,
                              map_with_segs=f.cCSeg.value,
                              use_seg_perms=f.spCSeg.value,
                              useCapstone=f.cCGrp.value,
                              registers=Aarch64Registers(f.X0.value,
                                                     f.X1.value,
                                                     f.X2.value,
                                                     f.X3.value,
                                                     f.X4.value,
                                                     f.X5.value,
                                                     f.X6.value,
                                                     f.X7.value,
                                                     f.X8.value,
                                                     f.X9.value,
                                                     f.X10.value,
                                                     f.X11.value,
                                                     f.X12.value,
                                                     f.X13.value,
                                                     f.X14.value,
                                                     f.X15.value,
                                                     f.X16.value,
                                                     f.X17.value,
                                                     f.X18.value,
                                                     f.X19.value,
                                                     f.X20.value,
                                                     f.X21.value,
                                                     f.X22.value,
                                                     f.X23.value,
                                                     f.X24.value,
                                                     f.X25.value,
                                                     f.X26.value,
                                                     f.X27.value,
                                                     f.X28.value,
                                                     f.FP.value,
                                                     f.LR.value,
                                                     f.SP.value,
                                                     f.PC.value),
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              memory_init=f.memory_init,
                              color_graph=f.cgGrp.value,
                              breakpoints = f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/aarch64_simplified.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

class Aarch64Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS AARCH64
{cbCallback}
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
<##X0:{X0}>  |<##X1:{X1}>  |<##X2:{X2}>  |<##X3:{X3}> |<##X4:{X4}>
<##X5:{X5}>  |<##X6:{X6}>  |<##X7:{X7}>  |<##X8:{X8}> |<##X9:{X9}>
<##X10:{X10}> |<##X11:{X11}>| <##X12:{X12}>|<##SP:{X13}>
<##X14:{X14}> |<##X15:{X15}>|<##X16:{X16}>|<##X17:{X17}>
<##X18:{X18}> |<##X19:{X19}>|<##X20:{X20}>|<##X21:{X21}>
<##X22:{X22}> |<##X23:{X23}>|<##X24:{X24}>|<##X25:{X25}>
<##X26:{X26}> |<##X27:{X27}>|<##X28:{X28}>|<##FP:{FP}>
<##LR:{LR}>  |<##SP:{SP}>|<##PC:{PC}>
Display Configuration
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
""",{
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'X0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X2': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X3': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X4': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X5': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X6': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X7': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X8': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X10': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X11': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X12': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X13': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X14': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X15': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X16': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X17': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X18': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X19': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X20': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X21': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X22': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X23': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X24': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X25': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X26': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X27': Form.NumericInput(tp=Form.FT_RAWHEX),
            'X28': Form.NumericInput(tp=Form.FT_RAWHEX),
            'FP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'LR': Form.NumericInput(tp=Form.FT_RAWHEX),
            'SP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'PC': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})



  def onSaveButton(self,code):
    conf = Configuration(     path='',
                              arch='aarch64',
                              emulator='unicorn',
                              p_size=consts_aarch64.PSIZE,
                              stk_ba=consts_aarch64.STACK_BASEADDR,
                              stk_size=consts_aarch64.STACK_SIZE,
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=Aarch64Registers(self.GetControlValue(self.X0),
                                                      self.GetControlValue(self.X1),
                                                      self.GetControlValue(self.X2),
                                                      self.GetControlValue(self.X3),
                                                      self.GetControlValue(self.X4),
                                                      self.GetControlValue(self.X5),
                                                      self.GetControlValue(self.X6),
                                                      self.GetControlValue(self.X7),
                                                      self.GetControlValue(self.X8),
                                                      self.GetControlValue(self.X9),
                                                      self.GetControlValue(self.X10),
                                                      self.GetControlValue(self.X11),
                                                      self.GetControlValue(self.X12),
                                                      self.GetControlValue(self.X13),
                                                      self.GetControlValue(self.X14),
                                                      self.GetControlValue(self.X15),
                                                      self.GetControlValue(self.X16),
                                                      self.GetControlValue(self.X17),
                                                      self.GetControlValue(self.X18),
                                                      self.GetControlValue(self.X19),
                                                      self.GetControlValue(self.X20),
                                                      self.GetControlValue(self.X21),
                                                      self.GetControlValue(self.X22),
                                                      self.GetControlValue(self.X23),
                                                      self.GetControlValue(self.X24),
                                                      self.GetControlValue(self.X25),
                                                      self.GetControlValue(self.X26),
                                                      self.GetControlValue(self.X27),
                                                      self.GetControlValue(self.X28),
                                                      self.GetControlValue(self.FP),
                                                      self.GetControlValue(self.LR),
                                                      self.GetControlValue(self.SP),
                                                      self.GetControlValue(self.PC)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints= self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)

      
    

      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.X0,conf.registers.X0)
      self.SetControlValue(self.X1,conf.registers.X1)
      self.SetControlValue(self.X2,conf.registers.X2)
      self.SetControlValue(self.X3,conf.registers.X3)
      self.SetControlValue(self.X4,conf.registers.X4)
      self.SetControlValue(self.X5,conf.registers.X5)
      self.SetControlValue(self.X6,conf.registers.X6)
      self.SetControlValue(self.X7,conf.registers.X7)
      self.SetControlValue(self.X8,conf.registers.X8)
      self.SetControlValue(self.X9,conf.registers.X9)
      self.SetControlValue(self.X10,conf.registers.X10)
      self.SetControlValue(self.X11,conf.registers.X11)
      self.SetControlValue(self.X12,conf.registers.X12)
      self.SetControlValue(self.X13,conf.registers.X13)
      self.SetControlValue(self.X14,conf.registers.X14)
      self.SetControlValue(self.X15,conf.registers.X15)
      self.SetControlValue(self.X16,conf.registers.X16)
      self.SetControlValue(self.X17,conf.registers.X17)
      self.SetControlValue(self.X18,conf.registers.X18)
      self.SetControlValue(self.X19,conf.registers.X19)
      self.SetControlValue(self.X20,conf.registers.X20)
      self.SetControlValue(self.X21,conf.registers.X21)
      self.SetControlValue(self.X22,conf.registers.X22)
      self.SetControlValue(self.X23,conf.registers.X23)
      self.SetControlValue(self.X24,conf.registers.X24)
      self.SetControlValue(self.X25,conf.registers.X25)
      self.SetControlValue(self.X26,conf.registers.X26)
      self.SetControlValue(self.X27,conf.registers.X27)
      self.SetControlValue(self.X28,conf.registers.X28)
      self.SetControlValue(self.FP,conf.registers.FP)
      self.SetControlValue(self.LR,conf.registers.LR)
      self.SetControlValue(self.SP,conf.registers.SP)
      self.SetControlValue(self.PC,conf.registers.PC)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    if fid == self.sAddr.id:
          self.SetControlValue(self.PC,self.GetControlValue(self.sAddr))
    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = Aarch64Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
      
          ret = Configuration(path=f.conf_path,arch='aarch64',
                              emulator='unicorn',
                              p_size=consts_aarch64.PSIZE,
                              stk_ba=consts_aarch64.STACK_BASEADDR,
                              stk_size=consts_aarch64.STACK_SIZE,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=f.cCGrp.value,
                              registers=Aarch64Registers(f.X0.value,
                                                     f.X1.value,
                                                     f.X2.value,
                                                     f.X3.value,
                                                     f.X4.value,
                                                     f.X5.value,
                                                     f.X6.value,
                                                     f.X7.value,
                                                     f.X8.value,
                                                     f.X9.value,
                                                     f.X10.value,
                                                     f.X11.value,
                                                     f.X12.value,
                                                     f.X13.value,
                                                     f.X14.value,
                                                     f.X15.value,
                                                     f.X16.value,
                                                     f.X17.value,
                                                     f.X18.value,
                                                     f.X19.value,
                                                     f.X20.value,
                                                     f.X21.value,
                                                     f.X22.value,
                                                     f.X23.value,
                                                     f.X24.value,
                                                     f.X25.value,
                                                     f.X26.value,
                                                     f.X27.value,
                                                     f.X28.value,
                                                     f.FP.value,
                                                     f.LR.value,
                                                     f.SP.value,
                                                     f.PC.value),
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              color_graph=f.cgGrp.value,
                              breakpoints = f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/arm32.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

FormDesc = r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS ARML32
{cbCallback}
Mapping Configuration
<## Page size  :{iPageSize}> | <## Stack base address: {iStkBA}> | <## Stack size: {iStkSize}>
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
<##Start Mapping (ea in IDB):{sMapping}> | <##End Mapping (ea in IDB):{eMapping}>   
<## Use segment perms ## No:{spNo}> <Yes:{spYes}>{spCSeg}>
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
 <##R0:{R0}>  |<##R1:{R1}>  |<##R2:{R2}>  |<##R3:{R3}> |<##R4:{R4}>
 <##R5:{R5}>  |<##R6:{R6}>  |<##R7:{R7}>  |<##R8:{R8}> |<##R9:{R9}>
<##R10:{R10}> |<##R11:{R11}>| <##R12:{R12}>|<##SP:{R13}>
<##LR:{R14}>  |<##PC:{R15}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
<## Refresh values: {refreshButton}>
"""





class Arm32Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    self.memory_init = AdditionnalMapping({}) 
    if self.conf == None:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'cCSeg': Form.RadGroupControl(("sNo","sYes")),
            'spCSeg': Form.RadGroupControl(("spNo","spYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'R0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R2': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R3': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R4': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R5': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R6': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R7': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton),
            'refreshButton': Form.ButtonInput(self.onRefreshButton)
})
    else:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX, 
                                           value=self.conf.p_size), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX,
                                        value=self.conf.stk_ba),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX,
                                          value=self.conf.stk_size),
            'cAGrp': Form.RadGroupControl(("aNo","aYes"),
                                          value=1 if self.conf.autoMap else 0),
            'cRGrp': Form.RadGroupControl(("rNo","rYes"),
                                          value=1 if self.conf.showRegisters else 0),
            'cCGrp': Form.RadGroupControl(("cNo","cYes"),
                                          value=1 if self.conf.useCapstone else 0),
            'cCSeg': Form.RadGroupControl(("sNo","sYes"),
                                          value=1 if self.conf.map_with_segs else 0),
            'spCSeg': Form.RadGroupControl(("spNo","spYes"),
                                           value=1 if self.conf.use_seg_perms else 0),
            'maGrp': Form.RadGroupControl(("maNo","maYes"),
                                          value=1 if self.conf.showMemAccess else 0),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes"),
                                          value=1 if self.conf.color_graph else 0),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_saddr),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_eaddr),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_saddr),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_eaddr),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'R0': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R0),
            'R1': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R1),
            'R2': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R2),
            'R3': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R3),
            'R4': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R4),
            'R5': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R5),
            'R6': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R6),
            'R7': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R7),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R8),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R9),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R10),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R11),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R12),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R13),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R14),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R15),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton),
            'refreshButton': Form.ButtonInput(self.onRefreshButton)
})


        self.s_conf = conf.s_conf
        self.amap_conf = conf.amap_conf
        self.memory_init = conf.memory_init


  def onSaveButton(self,code):
    conf = Configuration(     path='',
                              arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=self.GetControlValue(self.iPageSize),
                              stk_ba=self.GetControlValue(self.iStkBA),
                              stk_size=self.GetControlValue(self.iStkSize),
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=self.GetControlValue(self.sMapping),
                              mapping_eaddr=self.GetControlValue(self.eMapping),
                              segms=self.segs,
                              map_with_segs=self.GetControlValue(self.cCSeg),
                              use_seg_perms=self.GetControlValue(self.spCSeg),
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=ArmRegisters(self.GetControlValue(self.R0),
                                                      self.GetControlValue(self.R1),
                                                      self.GetControlValue(self.R2),
                                                      self.GetControlValue(self.R3),
                                                      self.GetControlValue(self.R4),
                                                      self.GetControlValue(self.R5),
                                                      self.GetControlValue(self.R6),
                                                      self.GetControlValue(self.R7),
                                                      self.GetControlValue(self.R8),
                                                      self.GetControlValue(self.R9),
                                                      self.GetControlValue(self.R10),
                                                      self.GetControlValue(self.R11),
                                                      self.GetControlValue(self.R12),
                                                      self.GetControlValue(self.R13),
                                                      self.GetControlValue(self.R14),
                                                      self.GetControlValue(self.R15)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              memory_init=self.memory_init,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints= self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code):


      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path):
        logger.console(2,' [Configuration Load] Invalid file path')
        return
      try: 
        conf = loadconfig(f_path)
      except: 
        logger.console(2,'Error loading conf. Exiting...')
        return
      if conf:
          self.conf = conf
          self.update_with_conf(conf)


  def onRefreshButton(self,code):
      if self.conf == None:
          return
      else:
          self.update_with_conf(self.conf)


  def update_with_conf(self,conf):
      if not conf.map_with_segs: self.EnableField(self.cSegChooser,False)
      else:
          self.EnableField(self.sMapping, False)
          self.EnableField(self.eMapping, False)
          self.EnableField(self.cSegChooser,True)


      segms = get_seg_list()
      s_chooser = []

      i=0
      for x in segms:
        if x in conf.segms:
          s_chooser.append(i)
        i+=1

      self.SetControlValue(self.cSegChooser,s_chooser)

      self.SetControlValue(self.iPageSize,conf.p_size)
      self.SetControlValue(self.iStkBA,conf.stk_ba)
      self.SetControlValue(self.iStkSize,conf.stk_size)
      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.sMapping,conf.mapping_saddr)
      self.SetControlValue(self.eMapping,conf.mapping_eaddr)
      self.segs = conf.segms
      self.SetControlValue(self.cCSeg,conf.map_with_segs)
      self.SetControlValue(self.spCSeg,conf.use_seg_perms)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.R0,conf.registers.R0)
      self.SetControlValue(self.R1,conf.registers.R1)
      self.SetControlValue(self.R2,conf.registers.R2)
      self.SetControlValue(self.R3,conf.registers.R3)
      self.SetControlValue(self.R4,conf.registers.R4)
      self.SetControlValue(self.R5,conf.registers.R5)
      self.SetControlValue(self.R6,conf.registers.R6)
      self.SetControlValue(self.R7,conf.registers.R7)
      self.SetControlValue(self.R8,conf.registers.R8)
      self.SetControlValue(self.R9,conf.registers.R9)
      self.SetControlValue(self.R10,conf.registers.R10)
      self.SetControlValue(self.R11,conf.registers.R11)
      self.SetControlValue(self.R12,conf.registers.R12)
      self.SetControlValue(self.R13,conf.registers.R13)
      self.SetControlValue(self.R13,conf.registers.R14)
      self.SetControlValue(self.R13,conf.registers.R15)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.memory_init = conf.memory_init
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    if fid == self.cSegChooser.id:
        if not self.GetControlValue(self.cCSeg): 
          self.EnableField(self.cSegChooser,False)
        self.segs = []  
        for x in self.GetControlValue(self.cSegChooser):
          self.segs.append(get_seg_list()[x])
    elif fid == self.cCSeg.id:
          self.EnableField(self.sMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.eMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.cSegChooser,self.GetControlValue(self.cCSeg))
    elif fid == self.sAddr.id:
          self.SetControlValue(self.R15,self.GetControlValue(self.sAddr))
    elif fid == self.iStkSize.id or fid == self.iStkBA.id:
          sp = self.GetControlValue(self.iStkSize) + self.GetControlValue(self.iStkBA) 
          self.SetControlValue(self.R13,sp)

    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = Arm32Pannel(conf)
      f.Compile()

      ok = f.Execute()
      if ok:
 
          ret = Configuration(path=f.conf_path,arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=f.iPageSize.value,
                              stk_ba=f.iStkBA.value,
                              stk_size=f.iStkSize.value,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=f.sMapping.value,
                              mapping_eaddr=f.eMapping.value,
                              segms=f.segs,
                              map_with_segs=f.cCSeg.value,
                              use_seg_perms=f.spCSeg.value,
                              useCapstone=f.cCGrp.value,
                              registers=ArmRegisters(f.R0.value,f.R1.value,f.R2.value,f.R3.value,
                                           f.R4.value,f.R5.value,f.R6.value,f.R7.value,
                                           f.R8.value,f.R9.value,f.R10.value,f.R11.value,
                                           f.R12.value,f.R13.value,f.R14.value,f.R15.value),
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              memory_init=f.memory_init,
                              color_graph=f.cgGrp.value,
                              breakpoints = f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/arm32_simplified.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.consts_arm import STACK_BASEADDR, STACK_SIZE 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

class Arm32Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS ARML32
{cbCallback}
Mapping Configuration
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
<##Start address:{sAddr}> | <##End address:{eAddr}>
Execution Configuration
 <##R0:{R0}>  |<##R1:{R1}>  |<##R2:{R2}>  |<##R3:{R3}> |<##R4:{R4}>
 <##R5:{R5}>  |<##R6:{R6}>  |<##R7:{R7}>  |<##R8:{R8}> |<##R9:{R9}>
<##R10:{R10}> |<##R11:{R11}>| <##R12:{R12}>|<##SP:{R13}>
<##LR:{R14}>  |<##PC:{R15}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
""",{
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'R0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R2': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R3': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R4': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R5': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R6': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R7': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})



  def onSaveButton(self,code):
    conf = Configuration(     path='',
                              arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=0x400,
                              stk_ba=STACK_BASEADDR,
                              stk_size=STACK_SIZE,
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=ArmRegisters(self.GetControlValue(self.R0),
                                                      self.GetControlValue(self.R1),
                                                      self.GetControlValue(self.R2),
                                                      self.GetControlValue(self.R3),
                                                      self.GetControlValue(self.R4),
                                                      self.GetControlValue(self.R5),
                                                      self.GetControlValue(self.R6),
                                                      self.GetControlValue(self.R7),
                                                      self.GetControlValue(self.R8),
                                                      self.GetControlValue(self.R9),
                                                      self.GetControlValue(self.R10),
                                                      self.GetControlValue(self.R11),
                                                      self.GetControlValue(self.R12),
                                                      self.GetControlValue(self.R13),
                                                      self.GetControlValue(self.R14),
                                                      self.GetControlValue(self.R15)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints= self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)


      segms = get_seg_list()
      s_chooser = [] 
      
      i=0 
      for x in segms:
        if x in conf.segms:
          s_chooser.append(i)
        i+=1
    
      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.R0,conf.registers.R0)
      self.SetControlValue(self.R1,conf.registers.R1)
      self.SetControlValue(self.R2,conf.registers.R2)
      self.SetControlValue(self.R3,conf.registers.R3)
      self.SetControlValue(self.R4,conf.registers.R4)
      self.SetControlValue(self.R5,conf.registers.R5)
      self.SetControlValue(self.R6,conf.registers.R6)
      self.SetControlValue(self.R7,conf.registers.R7)
      self.SetControlValue(self.R8,conf.registers.R8)
      self.SetControlValue(self.R9,conf.registers.R9)
      self.SetControlValue(self.R10,conf.registers.R10)
      self.SetControlValue(self.R11,conf.registers.R11)
      self.SetControlValue(self.R12,conf.registers.R12)
      self.SetControlValue(self.R13,conf.registers.R13)
      self.SetControlValue(self.R13,conf.registers.R14)
      self.SetControlValue(self.R13,conf.registers.R15)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = Arm32Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
      
          ret = Configuration(path=f.conf_path,arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=0x400,
                              stk_ba=STACK_BASEADDR,
                              stk_size=STACK_SIZE,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=f.cCGrp.value,
                              registers=ArmRegisters(f.R0.value,f.R1.value,f.R2.value,f.R3.value,
                                           f.R4.value,f.R5.value,f.R6.value,f.R7.value,
                                           f.R8.value,f.R9.value,f.R10.value,f.R11.value,
                                           f.R12.value,f.R13.value,f.R14.value,f.R15.value),
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              color_graph=f.cgGrp.value,
                              breakpoints = f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/mipsl32.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.utils import *

"""                   """
"         MIPS          "
"""                   """
class Mipsl32Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    Form.__init__(self, r"""STARTITEM 
BUTTON YES Run
BUTTON NO No
BUTTON CANCEL* Cancel
EWS MIPSL32
{cbCallback}
Mapping Configuration
<## Page size  :{iPageSize}> | <## Stack base address: {iStkBA}> | <## Stack size: {iStkSize}>
<##Start Mapping (ea in IDB):{sMapping}> | <##End Mapping (ea in IDB):{eMapping}>   
<## Map using segments## No:{sNo}> <Yes:{sYes}>{cCSeg}> | <## Use segment perms ## No:{spNo}> <Yes:{spYes}>{spCSeg}>
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}>
<Segment: {cSegChooser}>
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
<##at:{at}>|<##a0:{a0}>|<##a1:{a1}>|<##a2:{a2}>|<##a3:{a3}>
<##s0:{s0}>|<##s1:{s1}>|<##s2:{s2}>|<##s3:{s3}>|<##s4:{s4}>
<##s5:{s5}>|<##s6:{s6}>|<##s7:{s7}>|<##hi:{hi}>|<##lo:{lo}>
<##t0:{t0}>|<##t1:{t1}>|<##t2:{t2}>|<##t3:{t3}>|<##t4:{t4}>
<##t5:{t5}>|<##t6:{t6}>|<##t7:{t7}>|<##t8:{t8}>|<##t9:{t9}>
<##gp:{gp}>|<##fp:{fp}>|<##ra:{ra}>|<##sp:{sp}>|<##pc:{pc}>
<##v0:{v0}>|<##v1:{v1}>|<##k0:{k0}>|<##k1:{k1}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
""",{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'cCSeg': Form.RadGroupControl(("sNo","sYes")),
            'spCSeg': Form.RadGroupControl(("spNo","spYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'at': Form.NumericInput(tp=Form.FT_RAWHEX),
            'a0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'a1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'a2': Form.NumericInput(tp=Form.FT_RAWHEX),
            'a3': Form.NumericInput(tp=Form.FT_RAWHEX),
            's0': Form.NumericInput(tp=Form.FT_RAWHEX),
            's1': Form.NumericInput(tp=Form.FT_RAWHEX),
            's2': Form.NumericInput(tp=Form.FT_RAWHEX),
            's3': Form.NumericInput(tp=Form.FT_RAWHEX),
            's4': Form.NumericInput(tp=Form.FT_RAWHEX),
            's5': Form.NumericInput(tp=Form.FT_RAWHEX),
            's6': Form.NumericInput(tp=Form.FT_RAWHEX),
            's7': Form.NumericInput(tp=Form.FT_RAWHEX),
            't0': Form.NumericInput(tp=Form.FT_RAWHEX),
            't1': Form.NumericInput(tp=Form.FT_RAWHEX),
            't2': Form.NumericInput(tp=Form.FT_RAWHEX),
            't3': Form.NumericInput(tp=Form.FT_RAWHEX),
            't4': Form.NumericInput(tp=Form.FT_RAWHEX),
            't5': Form.NumericInput(tp=Form.FT_RAWHEX),
            't6': Form.NumericInput(tp=Form.FT_RAWHEX),
            't7': Form.NumericInput(tp=Form.FT_RAWHEX),
            't8': Form.NumericInput(tp=Form.FT_RAWHEX),
            't9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'v0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'v1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'k0': Form.NumericInput(tp=Form.FT_RAWHEX),
            'k1': Form.NumericInput(tp=Form.FT_RAWHEX),
            'hi': Form.NumericInput(tp=Form.FT_RAWHEX),
            'lo': Form.NumericInput(tp=Form.FT_RAWHEX),
            'gp': Form.NumericInput(tp=Form.FT_RAWHEX),
            'fp': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ra': Form.NumericInput(tp=Form.FT_RAWHEX),
            'sp': Form.NumericInput(tp=Form.FT_RAWHEX),
            'pc': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})



  def onSaveButton(self,code):
    conf = Configuration(path= '', arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=self.GetControlValue(self.iPageSize),
                              stk_ba=self.GetControlValue(self.iStkBA),
                              stk_size=self.GetControlValue(self.iStkSize),
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=self.GetControlValue(self.sMapping),
                              mapping_eaddr=self.GetControlValue(self.eMapping),
                              segms=self.segs,
                              map_with_segs=self.GetControlValue(self.cCSeg),
                              use_seg_perms=self.GetControlValue(self.spCSeg),
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=MipslRegisters(at=self.GetControlValue(self.at),
                                            a0=self.GetControlValue(self.a0),
                                            a1=self.GetControlValue(self.a1),
                                            a2=self.GetControlValue(self.a2),
                                            a3=self.GetControlValue(self.a3),
                                            s0=self.GetControlValue(self.s0),
                                            s1=self.GetControlValue(self.s1),
                                            s2=self.GetControlValue(self.s2),
                                            s3=self.GetControlValue(self.s3),
                                            s4=self.GetControlValue(self.s4),
                                            s5=self.GetControlValue(self.s5),
                                            s6=self.GetControlValue(self.s6),
                                            s7=self.GetControlValue(self.s7),
                                            t0=self.GetControlValue(self.t0),
                                            t1=self.GetControlValue(self.t1),
                                            t2=self.GetControlValue(self.t2),
                                            t3=self.GetControlValue(self.t3),
                                            t4=self.GetControlValue(self.t4),
                                            t5=self.GetControlValue(self.t5),
                                            t6=self.GetControlValue(self.t6),
                                            t7=self.GetControlValue(self.t7),
                                            t8=self.GetControlValue(self.t8),
                                            t9=self.GetControlValue(self.t9),
                                            v0=self.GetControlValue(self.v0),
                                            v1=self.GetControlValue(self.v1),
                                            hi=self.GetControlValue(self.hi),
                                            lo=self.GetControlValue(self.lo),
                                            k0=self.GetControlValue(self.k0),
                                            k1=self.GetControlValue(self.k1),
                                            gp=self.GetControlValue(self.gp),
                                            fp=self.GetControlValue(self.fp),
                                            ra=self.GetControlValue(self.ra),
                                            sp=self.GetControlValue(self.sp),
                                            pc=self.GetControlValue(self.pc)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              breakpoints= self.breakpoints,
                              color_graph=self.GetControlValue(self.cgGrp))


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)

      if not conf.map_with_segs: self.EnableField(self.cSegChooser,False)
      else: 
          self.EnableField(self.sMapping, False)
          self.EnableField(self.eMapping, False)
          self.EnableField(self.cSegChooser,True)


      segms = get_seg_list()
      s_chooser = [] 
      
      i=0 
      for x in segms:
        if x in conf.segms:
          s_chooser.append(i)
        i+=1
    
      self.SetControlValue(self.cSegChooser,s_chooser)
      self.SetControlValue(self.iPageSize,conf.p_size)
      self.SetControlValue(self.iStkBA,conf.stk_ba)
      self.SetControlValue(self.iStkSize,conf.stk_size)
      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.sMapping,conf.mapping_saddr)
      self.SetControlValue(self.eMapping,conf.mapping_eaddr)
      self.segs = conf.segms
      self.SetControlValue(self.cCSeg,conf.map_with_segs)
      self.SetControlValue(self.spCSeg,conf.use_seg_perms)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.at,conf.registers.at)
      self.SetControlValue(self.a0,conf.registers.a0)
      self.SetControlValue(self.a1,conf.registers.a1)
      self.SetControlValue(self.a2,conf.registers.a2)
      self.SetControlValue(self.a3,conf.registers.a3)
      self.SetControlValue(self.s0,conf.registers.s0)
      self.SetControlValue(self.s1,conf.registers.s1)
      self.SetControlValue(self.s2,conf.registers.s2)
      self.SetControlValue(self.s3,conf.registers.s3)
      self.SetControlValue(self.s4,conf.registers.s4)
      self.SetControlValue(self.s5,conf.registers.s5)
      self.SetControlValue(self.s6,conf.registers.s6)
      self.SetControlValue(self.s7,conf.registers.s7)
      self.SetControlValue(self.t0,conf.registers.t0)
      self.SetControlValue(self.t1,conf.registers.t1)
      self.SetControlValue(self.t2,conf.registers.t2)
      self.SetControlValue(self.t3,conf.registers.t3)
      self.SetControlValue(self.t4,conf.registers.t4)
      self.SetControlValue(self.t5,conf.registers.t5)
      self.SetControlValue(self.t6,conf.registers.t6)
      self.SetControlValue(self.t7,conf.registers.t7)
      self.SetControlValue(self.t8,conf.registers.t8)
      self.SetControlValue(self.t9,conf.registers.t9)
      self.SetControlValue(self.hi,conf.registers.hi)
      self.SetControlValue(self.lo,conf.registers.lo)
      self.SetControlValue(self.k0,conf.registers.k0)
      self.SetControlValue(self.k1,conf.registers.k1)
      self.SetControlValue(self.gp,conf.registers.gp)
      self.SetControlValue(self.fp,conf.registers.fp)
      self.SetControlValue(self.ra,conf.registers.ra)
      self.SetControlValue(self.sp,conf.registers.sp)
      self.SetControlValue(self.pc,conf.registers.pc)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)


  def cb_callback(self,fid):
    if fid == self.cSegChooser.id:
        if not self.GetControlValue(self.cCSeg): 
          self.EnableField(self.cSegChooser,False)
        self.segs = []  
        for x in self.GetControlValue(self.cSegChooser):
          self.segs.append(get_seg_list()[x])
    elif fid == self.cCSeg.id:
          self.EnableField(self.sMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.eMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.cSegChooser,self.GetControlValue(self.cCSeg))
    elif fid == self.sAddr.id:
          self.SetControlValue(self.pc,self.GetControlValue(self.sAddr))
    elif fid == self.iStkSize.id or fid == self.iStkBA.id:
          sp = self.GetControlValue(self.iStkSize) + self.GetControlValue(self.iStkBA) 
          self.SetControlValue(self.sp,sp)
    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = Mipsl32Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
      
          ret = Configuration(path=f.conf_path,arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=f.iPageSize.value,
                              stk_ba=f.iStkBA.value,
                              stk_size=f.iStkSize.value,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=f.sMapping.value,
                              mapping_eaddr=f.eMapping.value,
                              segms=f.segs,
                              map_with_segs=f.cCSeg.value,
                              use_seg_perms=f.spCSeg.value,
                              useCapstone=f.cCGrp.value,
                              registers=MipslRegisters(at=f.at.value,
                                            a0=f.a0.value,
                                            a1=f.a1.value,
                                            a2=f.a2.value,
                                            a3=f.a3.value,
                                            s0=f.s0.value,
                                            s1=f.s1.value,
                                            s2=f.s2.value,
                                            s3=f.s3.value,
                                            s4=f.s4.value,
                                            s5=f.s5.value,
                                            s6=f.s6.value,
                                            s7=f.s7.value,
                                            t0=f.t0.value,
                                            t1=f.t1.value,
                                            t2=f.t2.value,
                                            t3=f.t3.value,
                                            t4=f.t4.value,
                                            t5=f.t5.value,
                                            t6=f.t6.value,
                                            t7=f.t7.value,
                                            t8=f.t8.value,
                                            t9=f.t9.value,
                                            v0=f.v0.value,
                                            v1=f.v1.value,
                                            hi=f.hi.value,
                                            lo=f.lo.value,
                                            k0=f.k0.value,
                                            k1=f.k1.value,
                                            gp=f.gp.value,
                                            fp=f.fp.value,
                                            ra=f.ra.value,
                                            sp=f.sp.value,
                                            pc=f.sp.value),
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              color_graph=f.cgGrp.value,
                              breakpoints=f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret
  
 


```

`EWS/ui/Olds/x64.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

FormDesc=r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS x64
{cbCallback}
Mapping Configuration
<## Page size  :{iPageSize}> | <## Stack base address: {iStkBA}> | <## Stack size: {iStkSize}>
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
<##Start Mapping (ea in IDB):{sMapping}> | <##End Mapping (ea in IDB):{eMapping}>   
<## Map using segments## No:{sNo}> <Yes:{sYes}>{cCSeg}> | <## Use segment perms ## No:{spNo}> <Yes:{spYes}>{spCSeg}>
<Segment: {cSegChooser}>
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
 <##RAX:{RAX}>  |<##RBX:{RBX}>  |<##RCX:{RCX}>  |<##RDX:{RDX}> 
 <##RDI:{RDI}>  |<##RSI:{RSI}>  |<##RBP:{RBP}>  |<##RSP:{RSP}> 
 <##R8:{R8}>    |<##R9:{R9}>    |<##R10:{R10}>  |<##R11:{R11}>
 <##R12:{R12}>  |<##R13:{R13}>  |<##R14:{R14}>  |<##R15:{R15}>
 <##RIP:{RIP}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
"""



class x64Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    self.memory_init = AdditionnalMapping({}) 
    self.conf = conf
    if conf == None :
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'cCSeg': Form.RadGroupControl(("sNo","sYes")),
            'spCSeg': Form.RadGroupControl(("spNo","spYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'RAX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RBX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RCX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RDX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RDI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RSI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RBP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RSP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RIP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})
    else:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX, 
                                           value=self.conf.p_size), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX,
                                        value=self.conf.stk_ba),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX,
                                          value=self.conf.stk_size),
            'cAGrp': Form.RadGroupControl(("aNo","aYes"),
                                          value=1 if self.conf.autoMap else 0),
            'cRGrp': Form.RadGroupControl(("rNo","rYes"),
                                          value=1 if self.conf.showRegisters else 0),
            'cCGrp': Form.RadGroupControl(("cNo","cYes"),
                                          value=1 if self.conf.useCapstone else 0),
            'cCSeg': Form.RadGroupControl(("sNo","sYes"),
                                          value=1 if self.conf.map_with_segs else 0),
            'spCSeg': Form.RadGroupControl(("spNo","spYes"),
                                           value=1 if self.conf.use_seg_perms else 0),
            'maGrp': Form.RadGroupControl(("maNo","maYes"),
                                          value=1 if self.conf.showMemAccess else 0),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes"),
                                          value=1 if self.conf.color_graph else 0),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_saddr),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_eaddr),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_saddr),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_eaddr),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'RAX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RAX),
            'RBX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RBX),
            'RCX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RCX),
            'RDX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RDX),
            'RDI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RDI),
            'RSI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RSI),
            'RBP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RBP),
            'RSP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RSP),
            'RIP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.RIP),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R8),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R9),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R10),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R11),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R12),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R13),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R14),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.R15),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})

        self.s_conf = conf.s_conf
        self.amap_conf = conf.amap_conf
        self.memory_init = conf.memory_init


  def onSaveButton(self,code):
    conf = Configuration(path='',arch='x64',
                              emulator='unicorn',
                              p_size=self.GetControlValue(self.iPageSize),
                              stk_ba=self.GetControlValue(self.iStkBA),
                              stk_size=self.GetControlValue(self.iStkSize),
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=self.GetControlValue(self.sMapping),
                              mapping_eaddr=self.GetControlValue(self.eMapping),
                              segms=self.segs,
                              map_with_segs=self.GetControlValue(self.cCSeg),
                              use_seg_perms=self.GetControlValue(self.spCSeg),
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=x64Registers(self.GetControlValue(self.RAX),
                                                      self.GetControlValue(self.RBX),
                                                      self.GetControlValue(self.RCX),
                                                      self.GetControlValue(self.RDX),
                                                      self.GetControlValue(self.RDI),
                                                      self.GetControlValue(self.RSI),
                                                      self.GetControlValue(self.RBP),
                                                      self.GetControlValue(self.RSP),
                                                      self.GetControlValue(self.RIP),
                                                      self.GetControlValue(self.R8),
                                                      self.GetControlValue(self.R9),
                                                      self.GetControlValue(self.R10),
                                                      self.GetControlValue(self.R11),
                                                      self.GetControlValue(self.R12),
                                                      self.GetControlValue(self.R13),
                                                      self.GetControlValue(self.R14),
                                                      self.GetControlValue(self.R15)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              memory_init=self.memory_init,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints=self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)

      if not conf.map_with_segs: self.EnableField(self.cSegChooser,False)
      else: 
          self.EnableField(self.sMapping, False)
          self.EnableField(self.eMapping, False)
          self.EnableField(self.cSegChooser,True)


      segms = get_seg_list()
      s_chooser = [] 
      
      i=0 
      for x in segms:
        if x in conf.segms:
          s_chooser.append(i)
        i+=1
    
      self.SetControlValue(self.cSegChooser,s_chooser)

      self.SetControlValue(self.iPageSize,conf.p_size)
      self.SetControlValue(self.iStkBA,conf.stk_ba)
      self.SetControlValue(self.iStkSize,conf.stk_size)
      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.sMapping,conf.mapping_saddr)
      self.SetControlValue(self.eMapping,conf.mapping_eaddr)
      self.segs = conf.segms
      self.SetControlValue(self.cCSeg,conf.map_with_segs)
      self.SetControlValue(self.spCSeg,conf.use_seg_perms)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.RAX,conf.registers.RAX)
      self.SetControlValue(self.RBX,conf.registers.RBX)
      self.SetControlValue(self.RCX,conf.registers.RCX)
      self.SetControlValue(self.RDX,conf.registers.RDX)
      self.SetControlValue(self.RDI,conf.registers.RDI)
      self.SetControlValue(self.RSI,conf.registers.RSI)
      self.SetControlValue(self.RBP,conf.registers.RBP)
      self.SetControlValue(self.RSP,conf.registers.RSP)
      self.SetControlValue(self.RIP,conf.registers.RIP)
      self.SetControlValue(self.R8,conf.registers.R8)
      self.SetControlValue(self.R9,conf.registers.R9)
      self.SetControlValue(self.R10,conf.registers.R10)
      self.SetControlValue(self.R11,conf.registers.R11)
      self.SetControlValue(self.R12,conf.registers.R12)
      self.SetControlValue(self.R13,conf.registers.R13)
      self.SetControlValue(self.R14,conf.registers.R14)
      self.SetControlValue(self.R15,conf.registers.R15)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.memory_init = conf.memory_init
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    if fid == self.cSegChooser.id:
        if not self.GetControlValue(self.cCSeg): 
          self.EnableField(self.cSegChooser,False)
        self.segs = []  
        for x in self.GetControlValue(self.cSegChooser):
          self.segs.append(get_seg_list()[x])
    elif fid == self.cCSeg.id:
          self.EnableField(self.sMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.eMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.cSegChooser,self.GetControlValue(self.cCSeg))
    elif fid == self.sAddr.id:
          self.SetControlValue(self.RIP,self.GetControlValue(self.sAddr))
    elif fid == self.iStkSize.id or fid == self.iStkBA.id:
          sp = self.GetControlValue(self.iStkSize) + self.GetControlValue(self.iStkBA) 
          self.SetControlValue(self.RSP,sp)

    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = x64Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
      
          ret = Configuration(path=f.conf_path, arch='x64',
                              emulator='unicorn',
                              p_size=f.iPageSize.value,
                              stk_ba=f.iStkBA.value,
                              stk_size=f.iStkSize.value,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=f.sMapping.value,
                              mapping_eaddr=f.eMapping.value,
                              segms=f.segs,
                              map_with_segs=f.cCSeg.value,
                              use_seg_perms=f.spCSeg.value,
                              useCapstone=f.cCGrp.value,
                              registers=x64Registers(RAX=f.RAX.value,
                                                        RBX=f.RBX.value,
                                                        RCX=f.RCX.value,
                                                        RDX=f.RDX.value,
                                                        RDI=f.RDI.value,
                                                        RSI=f.RSI.value,
                                                        R8=f.R8.value,
                                                        R9=f.R9.value,
                                                        R10=f.R10.value,
                                                        R11=f.R11.value,
                                                        R12=f.R12.value,
                                                        R13=f.R13.value,
                                                        R14=f.R14.value,
                                                        R15=f.R15.value,
                                                        RBP=f.RBP.value,
                                                        RSP=f.RSP.value,
                                                        RIP=f.RIP.value),

                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              memory_init=f.memory_init,
                              color_graph=f.cgGrp.value,
                              breakpoints=f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/x64_simplified.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.configuration import *
from EWS.utils.registers import * 
from EWS.utils import consts_x64

class x64Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS x64
{cbCallback}
Mapping Configuration
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
 <##RAX:{RAX}>  |<##RBX:{RBX}>  |<##RCX:{RCX}>  |<##RDX:{RDX}> 
 <##RDI:{RDI}>  |<##RSI:{RSI}>  |<##RBP:{RBP}>  |<##RSP:{RSP}> 
 <##R8:{R8}>    |<##R9:{R9}>    |<##R10:{R10}>  |<##R11:{R11}>
 <##R12:{R12}>  |<##R13:{R13}>  |<##R14:{R14}>  |<##R15:{R15}>
 <##RIP:{RIP}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
""",{
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'RAX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RBX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RCX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RDX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RDI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RSI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RBP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RSP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'RIP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})



  def onSaveButton(self,code):
    conf = Configuration(path='',arch='x64',
                              emulator='unicorn',
                              p_size=consts_x64.PSIZE,
                              stk_ba=consts_x64.STACK_BASEADDR,
                              stk_size=consts_x64.STACK_SIZE,
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=x64Registers(self.GetControlValue(self.RAX),
                                                      self.GetControlValue(self.RBX),
                                                      self.GetControlValue(self.RCX),
                                                      self.GetControlValue(self.RDX),
                                                      self.GetControlValue(self.RDI),
                                                      self.GetControlValue(self.RSI),
                                                      self.GetControlValue(self.RBP),
                                                      self.GetControlValue(self.RSP),
                                                      self.GetControlValue(self.RIP),
                                                      self.GetControlValue(self.R8),
                                                      self.GetControlValue(self.R9),
                                                      self.GetControlValue(self.R10),
                                                      self.GetControlValue(self.R11),
                                                      self.GetControlValue(self.R12),
                                                      self.GetControlValue(self.R13),
                                                      self.GetControlValue(self.R14),
                                                      self.GetControlValue(self.R15)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints=self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)




      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.RAX,conf.registers.RAX)
      self.SetControlValue(self.RBX,conf.registers.RBX)
      self.SetControlValue(self.RCX,conf.registers.RCX)
      self.SetControlValue(self.RDX,conf.registers.RDX)
      self.SetControlValue(self.RDI,conf.registers.RDI)
      self.SetControlValue(self.RSI,conf.registers.RSI)
      self.SetControlValue(self.RBP,conf.registers.RBP)
      self.SetControlValue(self.RSP,conf.registers.RSP)
      self.SetControlValue(self.RIP,conf.registers.RIP)
      self.SetControlValue(self.R8,conf.registers.R8)
      self.SetControlValue(self.R9,conf.registers.R9)
      self.SetControlValue(self.R10,conf.registers.R10)
      self.SetControlValue(self.R11,conf.registers.R11)
      self.SetControlValue(self.R12,conf.registers.R12)
      self.SetControlValue(self.R13,conf.registers.R13)
      self.SetControlValue(self.R14,conf.registers.R14)
      self.SetControlValue(self.R15,conf.registers.R15)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    if fid == self.sAddr.id:
          self.SetControlValue(self.RIP,self.GetControlValue(self.sAddr))

    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = x64Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
      
          ret = Configuration(path=f.conf_path, arch='x64',
                              emulator='unicorn',
                              p_size=consts_x64.PSIZE,
                              stk_ba=consts_x64.STACK_BASEADDR,
                              stk_size=consts_x64.STACK_SIZE,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=f.cCGrp.value,
                              registers=x64Registers(RAX=f.RAX.value,
                                                        RBX=f.RBX.value,
                                                        RCX=f.RCX.value,
                                                        RDX=f.RDX.value,
                                                        RSI=f.RSI.value,
                                                        RDI=f.RDI.value,
                                                        R8=f.R8.value,
                                                        R9=f.R9.value,
                                                        R10=f.R10.value,
                                                        R11=f.R11.value,
                                                        R12=f.R12.value,
                                                        R13=f.R13.value,
                                                        R14=f.R14.value,
                                                        R15=f.R15.value,
                                                        RBP=f.RBP.value,
                                                        RSP=f.RSP.value,
                                                        RIP=f.RIP.value),

                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              color_graph=f.cgGrp.value,
                              breakpoints=f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/x86.py`:

```py
from EWS.ui.generic import * 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

FormDesc=r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS x86
{cbCallback}
Mapping Configuration
<## Page size  :{iPageSize}> | <## Stack base address: {iStkBA}> | <## Stack size: {iStkSize}>
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
<##Start Mapping (ea in IDB):{sMapping}> | <##End Mapping (ea in IDB):{eMapping}>   
<## Map using segments## No:{sNo}> <Yes:{sYes}>{cCSeg}> | <## Use segment perms ## No:{spNo}> <Yes:{spYes}>{spCSeg}>
<Segment: {cSegChooser}>
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
 <##EAX:{EAX}>  |<##EBX:{EBX}>  |<##ECX:{ECX}>  |<##EDX:{EDX}> 
 <##EDI:{EDI}>  |<##ESI:{ESI}>  |<##EBP:{EBP}>  |<##ESP:{ESP}> 
 <##EIP:{EIP}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}> 
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
"""

class x86Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    self.memory_init = AdditionnalMapping({}) 
    if self.conf == None:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'cCSeg': Form.RadGroupControl(("sNo","sYes")),
            'spCSeg': Form.RadGroupControl(("spNo","spYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'EAX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EBX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ECX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EDX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EDI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ESI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EBP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ESP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EIP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})
    else:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX, 
                                           value=self.conf.p_size), 
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX,
                                        value=self.conf.stk_ba),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX,
                                          value=self.conf.stk_size),
            'cAGrp': Form.RadGroupControl(("aNo","aYes"),
                                          value=1 if self.conf.autoMap else 0),
            'cRGrp': Form.RadGroupControl(("rNo","rYes"),
                                          value=1 if self.conf.showRegisters else 0),
            'cCGrp': Form.RadGroupControl(("cNo","cYes"),
                                          value=1 if self.conf.useCapstone else 0),
            'cCSeg': Form.RadGroupControl(("sNo","sYes"),
                                          value=1 if self.conf.map_with_segs else 0),
            'spCSeg': Form.RadGroupControl(("spNo","spYes"),
                                           value=1 if self.conf.use_seg_perms else 0),
            'maGrp': Form.RadGroupControl(("maNo","maYes"),
                                          value=1 if self.conf.showMemAccess else 0),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes"),
                                          value=1 if self.conf.color_graph else 0),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_saddr),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_eaddr),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_saddr),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_eaddr),
            'cSegChooser': Form.EmbeddedChooserControl(Pannel.segment_chooser("Segmentname")),
            'EAX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.EAX),
            'EBX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.EBX),
            'ECX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.ECX),
            'EDX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.EDX),
            'EDI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.EDI),
            'ESI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.ESI),
            'EBP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.EBP),
            'ESP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.ESP),
            'EIP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.conf.registers.EIP),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
        })


        self.s_conf = conf.s_conf
        self.amap_conf = conf.amap_conf
        self.memory_init = conf.memory_init


  

  def onSaveButton(self,code):
    conf = Configuration(     path='',
                              arch='x86',
                              emulator='unicorn',
                              p_size=self.GetControlValue(self.iPageSize),
                              stk_ba=self.GetControlValue(self.iStkBA),
                              stk_size=self.GetControlValue(self.iStkSize),
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=self.GetControlValue(self.sMapping),
                              mapping_eaddr=self.GetControlValue(self.eMapping),
                              segms=self.segs,
                              map_with_segs=self.GetControlValue(self.cCSeg),
                              use_seg_perms=self.GetControlValue(self.spCSeg),
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=x86Registers(self.GetControlValue(self.EAX),
                                                      self.GetControlValue(self.EBX),
                                                      self.GetControlValue(self.ECX),
                                                      self.GetControlValue(self.EDX),
                                                      self.GetControlValue(self.EDI),
                                                      self.GetControlValue(self.ESI),
                                                      self.GetControlValue(self.EBP),
                                                      self.GetControlValue(self.ESP),
                                                      self.GetControlValue(self.EIP)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              memory_mapping=self.memory_mapping,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints=self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)

      if not conf.map_with_segs: self.EnableField(self.cSegChooser,False)
      else: 
          self.EnableField(self.sMapping, False)
          self.EnableField(self.eMapping, False)
          self.EnableField(self.cSegChooser,True)


      segms = get_seg_list()
      s_chooser = [] 
      
      i=0 
      for x in segms:
        if x in conf.segms:
          s_chooser.append(i)
        i+=1

      self.conf_path = conf.path
    
      self.SetControlValue(self.cSegChooser,s_chooser)

      self.SetControlValue(self.iPageSize,conf.p_size)
      self.SetControlValue(self.iStkBA,conf.stk_ba)
      self.SetControlValue(self.iStkSize,conf.stk_size)
      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.sMapping,conf.mapping_saddr)
      self.SetControlValue(self.eMapping,conf.mapping_eaddr)
      self.segs = conf.segms
      self.SetControlValue(self.cCSeg,conf.map_with_segs)
      self.SetControlValue(self.spCSeg,conf.use_seg_perms)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.EAX,conf.registers.EAX)
      self.SetControlValue(self.EBX,conf.registers.EBX)
      self.SetControlValue(self.ECX,conf.registers.ECX)
      self.SetControlValue(self.EDX,conf.registers.EDX)
      self.SetControlValue(self.EDI,conf.registers.EDI)
      self.SetControlValue(self.ESI,conf.registers.ESI)
      self.SetControlValue(self.EBP,conf.registers.EBP)
      self.SetControlValue(self.ESP,conf.registers.ESP)
      self.SetControlValue(self.EIP,conf.registers.EIP)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.memory_init = conf.memory_init
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):
    if fid == self.cSegChooser.id:
        if not self.GetControlValue(self.cCSeg): 
          self.EnableField(self.cSegChooser,False)
        self.segs = []  
        for x in self.GetControlValue(self.cSegChooser):
          self.segs.append(get_seg_list()[x])
    elif fid == self.cCSeg.id:
          self.EnableField(self.sMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.eMapping,not self.GetControlValue(self.cCSeg))
          self.EnableField(self.cSegChooser,self.GetControlValue(self.cCSeg))
    elif fid == self.sAddr.id:
          self.SetControlValue(self.EIP,self.GetControlValue(self.sAddr))
    elif fid == self.iStkSize.id or fid == self.iStkBA.id:
          sp = self.GetControlValue(self.iStkSize) + self.GetControlValue(self.iStkBA) 
          self.SetControlValue(self.ESP,sp)

    return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = x86Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
          ret = Configuration(path=f.conf_path,arch='x86',
                              emulator='unicorn',
                              p_size=f.iPageSize.value,
                              stk_ba=f.iStkBA.value,
                              stk_size=f.iStkSize.value,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=f.sMapping.value,
                              mapping_eaddr=f.eMapping.value,
                              segms=f.segs,
                              map_with_segs=f.cCSeg.value,
                              use_seg_perms=f.spCSeg.value,
                              useCapstone=f.cCGrp.value,
                              registers=x86Registers(f.EAX.value,f.EBX.value,f.ECX.value,f.EDX.value,
                                           f.EDI.value,f.ESI.value,f.EBP.value,f.ESP.value,f.EIP.value),
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              memory_init = f.memory_init,
                              color_graph=f.cgGrp.value,
                              breakpoints=f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/Olds/x86_simplified.py`:

```py
from EWS.ui.generic import * 
from EWS.utils import consts_x86 
from EWS.utils.configuration import *
from EWS.utils.registers import * 

class x86Pannel(Pannel):

  def __init__(self,conf):
    super().__init__(conf)
    self.invert = False
    self.segs = [] 
    self.s_conf = StubConfiguration.create() 
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS x86
{cbCallback}
Mapping Configuration
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
Execution Configuration
<##Start address:{sAddr}> | <##End address:{eAddr}>
 <##EAX:{EAX}>  |<##EBX:{EBX}>  |<##ECX:{ECX}>
 <##EDX:{EDX}>  |<##EDI:{EDI}>  |<##ESI:{ESI}>
 <##EBP:{EBP}>  |<##ESP:{ESP}>  |<##EIP:{EIP}>
Display Configuration 
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}>
<## Add mapping: {amapButton}> (arguments or missing segms in IDB)
<## Save Configration: {saveButton}> | <## Load Configuration: {loadButton} > 
""",{
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'EAX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EBX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ECX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EDX': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EDI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ESI': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EBP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'ESP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'EIP': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cbCallback': Form.FormChangeCb(self.cb_callback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'saveButton': Form.ButtonInput(self.onSaveButton),
            'loadButton': Form.ButtonInput(self.onLoadButton)
})




  def onSaveButton(self,code):
    conf = Configuration(     path='',
                              arch='x86',
                              emulator='unicorn',
                              p_size=consts_x86.PSIZE,
                              stk_ba=consts_x86.STACK_BASEADDR,
                              stk_size=consts_x86.STACK_SIZE,
                              autoMap=self.GetControlValue(self.cAGrp),
                              showRegisters=self.GetControlValue(self.cRGrp),
                              exec_saddr=self.GetControlValue(self.sAddr),
                              exec_eaddr=self.GetControlValue(self.eAddr),
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=self.GetControlValue(self.cCGrp),
                              registers=x86Registers(self.GetControlValue(self.EAX),
                                                      self.GetControlValue(self.EBX),
                                                      self.GetControlValue(self.ECX),
                                                      self.GetControlValue(self.EDX),
                                                      self.GetControlValue(self.EDI),
                                                      self.GetControlValue(self.ESI),
                                                      self.GetControlValue(self.EBP),
                                                      self.GetControlValue(self.ESP),
                                                      self.GetControlValue(self.EIP)),
                              showMemAccess=self.GetControlValue(self.maGrp),
                              s_conf=self.s_conf,
                              amap_conf=self.amap_conf,
                              color_graph=self.GetControlValue(self.cgGrp),
                              breakpoints=self.breakpoints)


    f_path = FileSelector.fillconfig()
    if f_path.strip() == '':
      f_path = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      logger.console(0,'[Config Save] invalid filepath , use default: %s'%f_path)
    conf.path = f_path
    saveconfig(conf,f_path)


  def onLoadButton(self,code): 
    

      f_path = FileSelector.fillconfig()
      if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Configuration Load] Invalid file path')
        return 
#     conf_apath = '/tmp/idaemu_conf_'+time.ctime().replace(' ','_')
      conf = loadconfig(f_path)


      self.SetControlValue(self.cAGrp,conf.autoMap)
      self.SetControlValue(self.cRGrp,conf.showRegisters)
      self.SetControlValue(self.sAddr,conf.exec_saddr)
      self.SetControlValue(self.eAddr,conf.exec_eaddr)
      self.SetControlValue(self.cCGrp,conf.useCapstone)
      self.SetControlValue(self.EAX,conf.registers.EAX)
      self.SetControlValue(self.EBX,conf.registers.EBX)
      self.SetControlValue(self.ECX,conf.registers.ECX)
      self.SetControlValue(self.EDX,conf.registers.EDX)
      self.SetControlValue(self.EDI,conf.registers.EDI)
      self.SetControlValue(self.ESI,conf.registers.ESI)
      self.SetControlValue(self.EBP,conf.registers.EBP)
      self.SetControlValue(self.ESP,conf.registers.ESP)
      self.SetControlValue(self.EIP,conf.registers.EIP)
      self.SetControlValue(self.maGrp,conf.showMemAccess)
      self.s_conf = conf.s_conf 
      self.amap_conf = conf.amap_conf 
      self.breakpoints = conf.breakpoints
      self.SetControlValue(self.cgGrp,conf.color_graph)



  def cb_callback(self,fid):

   if fid == self.sAddr.id:
          self.SetControlValue(self.EIP,self.GetControlValue(self.sAddr))
   return 1 

  @staticmethod
  def fillconfig(conf=None):
      f = x86Pannel(conf)
      f.Compile()
      
      ok = f.Execute()
      if ok:
          ret = Configuration(path=f.conf_path,
                              arch='x86',
                              emulator='unicorn',
                              p_size=consts_x86.PSIZE,
                              stk_ba=consts_x86.STACK_BASEADDR,
                              stk_size=consts_x86.STACK_SIZE,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=get_min_ea_idb(),
                              mapping_eaddr=get_max_ea_idb(),
                              segms=[],
                              map_with_segs=False,
                              use_seg_perms=False,
                              useCapstone=f.cCGrp.value,
                              registers=x86Registers(f.EAX.value,
                                                    f.EBX.value,
                                                    f.ECX.value,
                                                    f.EDX.value,
                                                    f.EDI.value,
                                                    f.ESI.value,
                                                    f.EBP.value,
                                                    f.ESP.value,
                                                    f.EIP.value),

                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              color_graph=f.cgGrp.value,
                              breakpoints=f.breakpoints)
    
      else:
        logger.console(2,'[Form.execute()] error, aborting...\n please contact maintainer')
        return None
      f.Free()

      return ret



```

`EWS/ui/debug_view.py`:

```py
from ida_kernwin import *
import ida_funcs
from EWS.utils.registers import x64Registers
from EWS.utils.exec_trace import *
from EWS.utils.call_tree import *
import idaapi

class Debug_View_Registers(idaapi.Choose):

    def __init__(self,
                 title : str,
                 emu,
                 flags: int = CH_CAN_REFRESH|CH_CAN_EDIT|CH_NO_STATUS_BAR,
                 width: int = None,
                 height:int = None,
                 embedded:bool = False,
                 modal:bool= False):

        idaapi.Choose.__init__(self,
                               title,
                               [
                                   ["Register", idaapi.Choose.CHCOL_HEX|8],
                                   ["Value", idaapi.Choose.CHCOL_PLAIN|20],
                               ],
                               flags=flags,
                               width=width,
                               height=height,
                               embedded=embedded)

        self.emu = emu

        self.items = self.emu.get_regs().get_register_values_l()

        self.selcount = 0

        self.n = len(self.items)

    def OnClose(self):
            return

    def OnGetLine(self,n):
        res = self.items[n]
        res = [ res[0], res[1] ]
        return res

    def OnSelectLine(self,n):
        self.selcount+=1
        val = ask_str(self.items[n][1],
                                  False,
                                  self.items[n][0])
        if val is None:
            return
        self.items[n][1] = val
         
        #TODO update emu value with self.emu.reg_write(val)/
        self.emu.reg_write(self.emu.reg_convert_ns(self.items[n][0]),
                           int(val,16))

        self.Refresh()

    def OnGetSize(self):
        n = len(self.items)
        return n

    def refresh(self):
        """
        it could be confusing. 
        but this method allow to directly update
        registers value on the form from the internal
        emulator pointer 
        """
        # empty the list but keep the reference of 
        # the internal object

        for n,x in enumerate(self.emu.get_regs().get_register_values_l()):
            self.items[n] = x
        self.Refresh()

    def update_with_regs(self,regs):

        for n,x in enumerate(regs.get_register_values_l()):
            self.items[n] = x

        self.Refresh()

    def insert_value(self,value:list):
        self.items.append(value)
        self.Refresh()

    def test(self,extra=None):
        pass

    def OnPopup(self,form, popup_handle):
        actname = "test:%s" % self.title
        desc = action_desc_t(actname, "Test: %s" % self.title, self.test)
        attach_dynamic_action_to_popup(form, popup_handle, desc,'ews_action/')

    def show(self):
        return self.Show() >= 0

class Debug_View_Trace(idaapi.Choose):

    def __init__(self,
                 title,
                 emu,
                 register_view, 
                 flags=CH_NO_STATUS_BAR|CH_CAN_REFRESH|CH_CAN_EDIT, # must be able to insert
                 width=None,
                 height=None,
                 embedded=False,
                 modal=False):

        idaapi.Choose.__init__(self,
                               title,
                               [
                                   ["Address", idaapi.Choose.CHCOL_HEX|8],
                                   ["Operation", idaapi.Choose.CHCOL_PLAIN|20],
                               ],
                               flags=flags,
                               width=width,
                               height=height,
                               embedded=embedded)
        
        self.emu = emu
        self.items = []

        for k,v in self.emu.exec_trace.content.items():

            
            addr = int()
            self.items.append( [ f"0x{v['addr']:x}",
                                ''.join(v['assembly'].split(':')[1:]) ])
        self.selcount = 0
        self.n = len(self.items)
        self.register_view = register_view

    def OnClose(self):

            return

    def OnGetLine(self,n):

        res = self.items[n]
        res = [ res[0], res[1] ]

        return res

    def OnSelectLine(self,n):

        self.selcount+=1

        element = list(self.emu.exec_trace.content.values())[n]
        

        regs = element['regs']
        self.register_view.update_with_regs(regs)

        addr = self.emu.exec_trace.content[n]['addr']

        jumpto(addr)



    def OnGetSize(self):
        n = len(self.items)
        return n


    def refresh(self):

        """
            call this function everytime exec_trace has
            been modified
        """

        n = 0
        last_size = len(self.items)

        for k,v in self.emu.exec_trace.content.items():
            if k >= last_size:
                addr = v['addr']
                self.items.append( [ '0x%x'%addr,
                                    ''.join(v['assembly'].split(':')[1:]) ])
            n+=1
            # no need to update last instructions
#            else:
#                self.items[n] = [ v['assembly'] ]

        self.Refresh()

    def insert_value(self,value:list):

        self.items.append(value)
        self.Refresh() # no need to update n value? 

    def test(self,extra=None):
        pass

    def OnPopup(self,form, popup_handle):

        actname = "test:%s" % self.title
        desc = action_desc_t(actname, "Test: %s" % self.title, self.test)

        attach_dynamic_action_to_popup(form, popup_handle, desc,'ews_action/')


    def flush(self):

        self.items = []
        self.n = 0
        self.refresh()

    def show(self):

        return self.Show() >= 0

class CallTree_View(idaapi.Choose):

    def __init__(self,
                 title,
                 emu,
                 register_view, 
                 flags=CH_NO_STATUS_BAR|CH_CAN_REFRESH|CH_CAN_EDIT, # must be able to insert
                 width=None,
                 height=None,
                 embedded=False,
                 modal=False):

        idaapi.Choose.__init__(self,
                               title,
                               [
                                   ["Address", idaapi.Choose.CHCOL_HEX|8],
                                   ["Operation", idaapi.Choose.CHCOL_PLAIN|20],
                               ],
                               flags=flags,
                               width=width,
                               height=height,
                               embedded=embedded)
        
        self.emu = emu
        self.items = []

        for k,v in self.emu.call_tree.content.items():
            self.add_entry(k,v)

        self.selcount = 0
        self.n = len(self.items)
        self.register_view = register_view


    def add_entry(self,k,v):

        if CTT(v['type']) == CTT.CALL:

            f_name = ida_funcs.get_func_name(v['target'])
            if not f_name:
                f_name = '0x%x'%v['target']


            line = '  '*v['depth'] + f_name  

            self.items.append([ f"0x{v['addr']:x}",
                            line ])



    def OnClose(self):

            return

    def OnGetLine(self,n):

        res = self.items[n]
        res = [ res[0], res[1] ]

        return res

    def OnSelectLine(self,n):

        # TODO: deplace tmp_dict calculation in refresh() 
        i = 0
        tmp_dict = {}
        for k,v in self.emu.call_tree.content.items():
            if CTT(v['type']) == CTT.CALL:
                tmp_dict[i] = {}
                tmp_dict[i]['trace_id'] = v['trace_id']
                tmp_dict[i]['addr'] = v['addr']
                tmp_dict[i]['depth'] = v['depth']
                tmp_dict[i]['type'] = v['type']
                tmp_dict[i]['target'] = v['target']
                tmp_dict[i]['info'] = v['info']
                i+=1




        #e = self.emu.call_tree.content[n]
        e = tmp_dict[n]
    
        

        print(e['type']," ","%x"%e['addr'],e['trace_id'])

        trace_value = list(self.emu.exec_trace.content.values())[e['trace_id']]
        regs = trace_value['regs']

        self.register_view.update_with_regs(regs)

        #addr = self.emu.exec_trace.content[n]['addr']

        if CTT(e['type']) == CTT.CALL:
            jumpto(e['addr'])



    def OnGetSize(self):
        n = len(self.items)
        return n


    def refresh(self):

        """
            call this function everytime exec_trace has
            been modified
        """

        n = 0
        last_size = len(self.items)

        for k,v in self.emu.exec_trace.content.items():
            if k >= last_size:
               self.add_entry(k,v) 
            n+=1

        self.Refresh()

    def insert_value(self,value:list):

        self.items.append(value)
        self.Refresh() # no need to update n value? 

    def test(self,extra=None):
        pass

    def OnPopup(self,form, popup_handle):

        actname = "test:%s" % self.title
        desc = action_desc_t(actname, "Test: %s" % self.title, self.test)

        attach_dynamic_action_to_popup(form, popup_handle, desc,'ews_action/')


    def flush(self):

        self.items = []
        self.n = 0
        self.refresh()

    def show(self):

        return self.Show() >= 0
     

```

`EWS/ui/display_mem.py`:

```py
import idaapi
import binascii
import ida_kernwin
import ida_segment
from EWS.utils.utils import *
from EWS.utils.utils_ui import * 

class SelectSegment(ida_kernwin.Form):

  class segment_chooser(ida_kernwin.Choose):
        """
        A simple chooser to be used as an embedded chooser
        """
        def __init__(self, title, nb=5, flags=ida_kernwin.Choose.CH_MODAL):
            ida_kernwin.Choose.__init__(
                self,
                title,
                [
                    ["Seg Name", 30]
                ],
                flags=flags,
                embedded=True,
                width=10,
                height=6)
            self.items = [ [ida_segment.get_segm_name(x)] for x in get_seg_list() ]
            self.icon = 0
            self.ret = 0

        def OnGetLine(self, n):
            self.ret = self.items[n]
            return self.items[n]

        def OnGetSize(self):
            n = len(self.items)
            return n


  def __init__(self):
    self.segname =None 
    ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS ARML32
{cbCallback}
Select Segment
<Segment: {cSegChooser}>""",
{
            'cSegChooser': ida_kernwin.Form.EmbeddedChooserControl(SelectSegment.segment_chooser("Segment Name")),
            'cbCallback': ida_kernwin.Form.FormChangeCb(self.cb_callback)
})


  def cb_callback(self,fid):
    if fid == self.cSegChooser.id:
        x = self.GetControlValue(self.cSegChooser)
        self.segname = get_seg_list()[x[0]]

    return 1 

  @staticmethod
  def fillconfig():
      f = SelectSegment()
      f.Compile()
      ok = f.Execute()
      if ok == ida_kernwin.ASKBTN_YES:
         return f.segname


class AddrNBPages(ida_kernwin.Form): 


    def __init__(self):
        ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Show Memory
<Address : {iAddr}> <Number of Pages : {iValue}>
""",{

   'iAddr': ida_kernwin.Form.NumericInput(ida_kernwin.Form.FT_ADDR),
  'iValue': ida_kernwin.Form.NumericInput(ida_kernwin.Form.FT_RAWHEX)
})



    @staticmethod
    def fillconfig():
      f = AddrNBPages()
      f.Compile()
      ok = f.Execute()
      if ok == ida_kernwin.ASKBTN_YES:
         return f.iAddr.value,f.iValue.value







 
class MemDisplayer(idaapi.Choose):

    def __init__(self,
                 title,
                 items,
                 emu,
                 flags=ida_kernwin.CH_CAN_REFRESH,
                 width=None,
                 height=None,
                 embedded=False,
                 modal=False):

        idaapi.Choose.__init__(self,
                               title,
                               [
                                   ["Address", idaapi.Choose.CHCOL_HEX|8],
                                   ["Hex", idaapi.Choose.CHCOL_PLAIN|20],
                                   ["ASCII", idaapi.Choose.CHCOL_PLAIN|20]
                               ],
                               flags=flags,
                               width=width,
                               height=height,
                               embedded=embedded)
        self.emu = emu
        self.items = items
        self.selcount = 0
        self.n = len(items)

    def OnClose(self):
            return



    def OnGetLine(self,n):
        res = self.items[n]
        res = [ res[0], res[1], res[2] ]
        return res

    def OnSelectLine(self,n):
        self.selcount+=1
        val = ida_kernwin.ask_str(self.items[n][1],
                                  False,
                                  self.items[n][0])
        if val!= None:
            hexx=binascii.a2b_hex(val.replace(' ',''))
            self.emu.mem_write(int(self.items[n][0],16),hexx)
            row = space(binascii.b2a_hex(hexx).decode('utf-8'))

        
        


    def OnGetSize(self):
        n = len(self.items)
        return n

    def test(self,extra=None):
        pass

    def OnPopup(self,form, popup_handle):
        actname = "test:%s" % self.title
        desc = ida_kernwin.action_desc_t(actname, "Test: %s" % self.title, self.test)
        ida_kernwin.attach_dynamic_action_to_popup(form, popup_handle, desc,'ews_action/')

    def show(self):
        return self.Show() >= 0




import string 
def asciify(val):
    out = []
    for v in val:
        if v in [ord(x) for x in string.ascii_letters]:
          out.append(chr(v))
        else:
          out.append('.')
    return ''.join(out)


def space(chain):
    out = []
    for i,c in enumerate(chain):
        if i % 2 == 1:
            out.append('%s '%c)
        else:
            out.append(c)
    return ''.join(out)




if __name__ == '__main__':

    
    addr,nbpages = AddrNBPages.fillconfig()


#    values = []
#    v1 = b'\x11\x12\x13\x14\x52\x12\xFF\x41'
#    values.append(['0x%x'%0x83450340,
#                   space(binascii.b2a_hex(v1).decode('utf-8')), 
#                   asciify(v1)])
#    v2 = b'\x33\x24\x67\x12\x98\x80\x80\x7F'
#    values.append(['%x'%0x83450348,
#                   space(binascii.b2a_hex(v2).decode('utf-8')),
#                   asciify(v2)])
#    md = MemDisplayer("Test",values)
#    md.show()
#


```

`EWS/ui/generic.py`:

```py
import ida_kernwin 
from ida_kernwin import * 
import ida_segment
import ida_idaapi
import idaapi
import ida_funcs
import ida_idp
import time
import os 
from EWS.utils.utils import *
from EWS.utils.configuration import *
from EWS.ui.stub_configuration import *
from EWS.utils.registers import Registers
from EWS.utils.configuration import Configuration

FormDesc = r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS ARML32
Mapping Configuration
<## Page size  :{iPageSize}> | <## Stack base address: {iStkBA}> | <## Stack size: {iStkSize}>
<## AutoMap missing regions## No:{aNo}> <Yes:{aYes}>{cAGrp}> 
<##Start Mapping (ea in IDB):{sMapping}> | <##End Mapping (ea in IDB):{eMapping}>   
<##Start address:{sAddr}> | <##End address:{eAddr}>
<##Max executed instruction:{maxInsn}>
Display Configuration
<## Show register values## No:{rNo}> <Yes:{rYes}>{cRGrp}> | <## Use Capstone## No:{cNo}> <Yes:{cYes}>{cCGrp}>
<## Show Mem Access## No:{maNo}> <Yes:{maYes}>{maGrp}> | <## Color graph## No:{cgNo}> <Yes:{cgYes}>{cgGrp}>
<## Configure Stub: {stubButton}>
<## Add mapping: {amapButton}>
<## Configure Registers: {registerButton}>
"""


class Pannel(ida_kernwin.Form):


  def __init__(self,
               register_ui_class,
               default_regs_values : Registers,
               arch_name : str  = '',
               emulator_solution: str = '',
               conf : Configuration = None):
    self.breakpoints = []
    self.watchpoints = {}
    self.patches = {}
    self.conf_path = ''
    self.conf = conf # For refresh purpose. When the windows is re-opened after the first time,
                     # value might be refreshed using the conf object 
    self.segs = []
    self.s_conf = StubConfiguration.create()
    self.amap_conf = AdditionnalMapping({})#AdditionnalMapping.create()
    self.memory_init = AdditionnalMapping({})
    self.register_ui_class = register_ui_class
    self.registers = default_regs_values
    self.arch_name = arch_name
    self.emulator_solution = emulator_solution
    self.config_present = False
    if self.conf == None:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX),
            'cAGrp': Form.RadGroupControl(("aNo","aYes")),
            'cRGrp': Form.RadGroupControl(("rNo","rYes")),
            'cCGrp': Form.RadGroupControl(("cNo","cYes")),
            'spCSeg': Form.RadGroupControl(("spNo","spYes")),
            'maGrp': Form.RadGroupControl(("maNo","maYes")),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes")),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR),
            'registerButton': Form.ButtonInput(self.registerCallback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'maxInsn': Form.NumericInput(tp=Form.FT_ADDR),

})
    else:
        Form.__init__(self, FormDesc,{
            'iPageSize': Form.NumericInput(tp=Form.FT_RAWHEX,
                                           value=self.conf.p_size),
            'iStkBA': Form.NumericInput(tp=Form.FT_RAWHEX,
                                        value=self.conf.stk_ba),
            'iStkSize': Form.NumericInput(tp=Form.FT_RAWHEX,
                                          value=self.conf.stk_size),
            'cAGrp': Form.RadGroupControl(("aNo","aYes"),
                                          value=1 if self.conf.autoMap else 0),
            'cRGrp': Form.RadGroupControl(("rNo","rYes"),
                                          value=1 if self.conf.showRegisters else 0),
            'cCGrp': Form.RadGroupControl(("cNo","cYes"),
                                          value=1 if self.conf.useCapstone else 0),
            'spCSeg': Form.RadGroupControl(("spNo","spYes"),
                                           value=1 if self.conf.use_seg_perms else 0),
            'maGrp': Form.RadGroupControl(("maNo","maYes"),
                                          value=1 if self.conf.showMemAccess else 0),
            'cgGrp': Form.RadGroupControl(("cgNo","cgYes"),
                                          value=1 if self.conf.color_graph else 0),
            'sAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_saddr),
            'eAddr': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.exec_eaddr),
            'sMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_saddr),
            'eMapping': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.mapping_eaddr),
            'registerButton': Form.ButtonInput(self.registerCallback),
            'stubButton': Form.ButtonInput(self.onStubButton),
            'amapButton': Form.ButtonInput(self.onaMapButton),
            'maxInsn': Form.NumericInput(tp=Form.FT_ADDR,value=self.conf.max_insn),
})


        self.s_conf = conf.s_conf
        self.amap_conf = conf.amap_conf
        self.memory_init = conf.memory_init
        self.registers = conf.registers
        self.breakpoints = conf.breakpoints
        self.watchpoints = conf.watchpoints
        self.patches = conf.patches
        self.config_present = True


  def cb_callback(self,code):
      pass

  def onStubButton(self,code):

    s_conf = StubForm.fillconfig(self.conf)
    self.s_conf += s_conf

  def onaMapButton(self,code):

    amap_conf = AddMapping.fillconfig()
    self.amap_conf += amap_conf

  def registerCallback(self,code):


    if self.config_present:
        self.registers = self.register_ui_class(self.registers)

    else:
        #TODO Add PC, SP information (if available)
        # maybe add method in registers class fix_pc fix_sp fix_link_reg
        #self.getControlControlledValue(self.sAddr) self.getControlControlledValue(self.iStkBA)
        self.registers = self.register_ui_class()
        self.config_present = True # handle case where the user clicks several time the button
   

  @staticmethod
  def fillconfig(register_ui_class,
               default_regs_values : Registers,
               arch_name : str  = '',
               emulator_solution: str = '',
            conf : Configuration = None) -> Configuration:



      f = Pannel(register_ui_class,
                 default_regs_values,
                 arch_name,
                 emulator_solution,
                 conf)

      f.Compile()


      ok = f.Execute()


      if ok == ida_kernwin.ASKBTN_YES: 

          ret = Configuration(path=f.conf_path,arch=ida_idp.get_idp_name(),
                              emulator='unicorn',
                              p_size=f.iPageSize.value,
                              stk_ba=f.iStkBA.value,
                              stk_size=f.iStkSize.value,
                              autoMap=f.cAGrp.value,
                              showRegisters=f.cRGrp.value,
                              exec_saddr=f.sAddr.value,
                              exec_eaddr=f.eAddr.value,
                              mapping_saddr=f.sMapping.value,
                              mapping_eaddr=f.eMapping.value,
                              segms=f.segs, # deprecated to be removed from conf
                              map_with_segs=False, # deprecated to be removed from conf
                              use_seg_perms=f.spCSeg.value,
                              useCapstone=f.cCGrp.value,
                              registers=f.registers,
                              showMemAccess=f.maGrp.value,
                              s_conf=f.s_conf,
                              amap_conf=f.amap_conf,
                              memory_init=f.memory_init,
                              color_graph=f.cgGrp.value,
                              breakpoints = f.breakpoints,
                              watchpoints = f.watchpoints,
                              patches = f.patches,
                              max_insn = f.maxInsn.value)

      else:
        raise Exception("Could not create configuration object")
        return None

      f.Free()

      return ret



#----------------------------------------------------------------------------------------------

FileDesc=r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Select a file
{cbCallback}
<## Path: {iFile}>
"""
class FileSelector(ida_kernwin.Form):
  def __init__(self):
    self.invert = False
    self.f_path = ''
    Form.__init__(self,FileDesc ,{
            'iFile': ida_kernwin.Form.FileInput(open=True,save=False),
            'cbCallback': ida_kernwin.Form.FormChangeCb(self.cb_callback),
})

  def cb_callback(self,fid):
      if fid == self.iFile.id:
          self.f_path = self.GetControlValue(self.iFile)
      return 1


  @staticmethod
  def fillconfig():
      f = FileSelector()
      f.Compile()

      ok = f.Execute()
      f.Free()

      return f.f_path

#----------------------------------------------------------------------------------------------

class AddMapping(ida_kernwin.Form):
  def __init__(self):
    self.invert = False
    self.mappings = dict()
    self.cur_value = b'' 
    self.clicked = False
    Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Additionnal Mapping
<##Address: {iAddr}>
<## Path: {iFile}> |  <##Add content file: {bFile}>
<##Hex dword: {iString}>
<##Add mapping: {bAdd}>
""",{

            'iAddr': Form.NumericInput(tp=Form.FT_ADDR), 
            'iFile': Form.FileInput(open=True,save=False),
            'bFile': Form.ButtonInput(self.OnbFile),
            'iString': Form.NumericInput(tp=Form.FT_RAWHEX), 
            'bAdd': Form.ButtonInput(self.OnbAdd)
})



  def OnbAdd(self,code):
    self.mappings[self.GetControlValue(self.iAddr)] = self.cur_value if self.cur_value != b'' else self.GetControlValue(self.iString).to_bytes(4,'big',signed=False)
    self.cur_value = b''
    self.clicked = True

  def OnbFile(self,code):
    f_path = self.GetControlValue(self.iFile)
    if os.path.exists(f_path) and not os.path.isdir(f_path):
      try:
        with open(f_path,'rb') as f: self.cur_value = f.read()
      except Exception as e : logger.console(2,e.__str__())


  @staticmethod
  def fillconfig() -> AdditionnalMapping:

      f = AddMapping()
      f.Compile()

      ret = AdditionnalMapping.create()
      op = f.Execute()

      if op != 0 and op != idaapi.BADADDR:
          if not f.clicked:
            logger.console(1,' [Additionnal Mapping Form] no content added, please use Add Mapping button to add selected content')
          ret = AdditionnalMapping(f.mappings)
      f.Free()

      return ret


```

`EWS/ui/mem_edit.py`:

```py
import ida_kernwin
import binascii


class MemEdit(ida_kernwin.Form):
    def __init__(self,emu=None):
        self.emu = emu
        self.ok = False
        ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Edit memory
{callback}
<## Addr: {iAddr}>
<## Value: {iValue}>
""",{
  'iAddr': ida_kernwin.Form.StringInput(ida_kernwin.Form.FT_ASCII),
  'iValue': ida_kernwin.Form.StringInput(ida_kernwin.Form.FT_ASCII),
  'callback': ida_kernwin.Form.FormChangeCb(self.callback),
})

    def callback(self,fid):
      if self.iAddr.id == fid:

        try:
            addr = int(self.GetControlValue(self.iAddr),16)
        except:
            if self.emu != None:
                try:
                    r_id= self.emu.reg_convert_ns(self.GetControlValue(self.iAddr))
                    addr = self.emu.reg_read(r_id)
                    self.SetControlValue(self.iAddr,'0x%x'%addr)
                except:
                    return
            else:
                return


        if self.emu != None:
            try:

                val = self.emu.mem_read(addr,8)
                self.ok = True
            except:
                val=b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF'
                self.ok = False
        else:
            val = b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF'
            self.ok = False
        try:

            self.SetControlValue(self.iValue,binascii.b2a_hex(val).decode('utf-8'))
        except Exception as e:
            print(e)
            print('Incorrect format, please enter a hex string such as AABBCCDD')
      return 1


    @staticmethod
    def fillconfig(emu=None):
        f= MemEdit(emu)
        f.Compile()
        ok = f.Execute()
        ret = (False,0,0)
        if ok:
          ret =  (f.ok,f.iAddr.value,f.iValue.value)
        f.Free()
        return ret












```

`EWS/ui/mem_operations.py`:

```py
import ida_kernwin

class ExportMemory(ida_kernwin.Form): 


    def __init__(self):
        self.f_path = None
        ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Export Memory
<Address : {iAddr}> <Export Size : {iSize}>
<## Path: {iFile}>
""",{

   'iAddr': ida_kernwin.Form.NumericInput(ida_kernwin.Form.FT_ADDR),
  'iSize': ida_kernwin.Form.NumericInput(ida_kernwin.Form.FT_RAWHEX),
  'iFile': ida_kernwin.Form.FileInput(open=True,save=False),
})



    @staticmethod
    def fillconfig():
      f = ExportMemory()
      f.Compile()
      ok = f.Execute()
      if ok:
         return f.iAddr.value,f.iSize.value,f.iFile.value
      else:
          raise Exception('[ExportMem]Invalid input parameters.')

class ImportMemory(ida_kernwin.Form): 


    def __init__(self):
        self.f_path = None
        ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Import Memory
<Address : {iAddr}>
<## Path: {iFile}>
""",{

   'iAddr': ida_kernwin.Form.NumericInput(ida_kernwin.Form.FT_ADDR),
  'iFile': ida_kernwin.Form.FileInput(open=True,save=False)
})


    @staticmethod
    def fillconfig():
      f = ImportMemory()
      f.Compile()
      ok = f.Execute()
      if ok:
         return f.iAddr.value,f.iFile.value



```

`EWS/ui/regedit.py`:

```py
import ida_kernwin
from ida_kernwin import Form
from EWS.utils.utils import * 
from EWS.utils.registers import *

DescFormARM = r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
EWS ARML32
{cbCallback}
Edit Registers
<##R0:{R0}>  |<##R1:{R1}>  |<##R2:{R2}>  |<##R3:{R3}>
<##R4:{R4}>  |<##R5:{R5}>  |<##R6:{R6}>  |<##R7:{R7}>
<##R8:{R8}> |<##R9:{R9}>   |<##R10:{R10}> |<##R11:{R11}>
<##R12:{R12}>|<##SP:{R13}> |<##LR:{R14}>  |<##PC:{R15}>
"""


class RegArm32Edit(ida_kernwin.Form):


    def __init__(self,regs):
        self.regs = regs
        if self.regs == None:
            self.regs = ArmRegisters.get_default_object()

        Form.__init__(self, DescFormARM,{
            'R0': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R0),
            'R1': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R1),
            'R2': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R2),
            'R3': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R3),
            'R4': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R4),
            'R5': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R5),
            'R6': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R6),
            'R7': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R7),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R8),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R9),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R10),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R11),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R12),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R13),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R14),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R15),
            'cbCallback': Form.FormChangeCb(self.onCallback)})

    def onCallback(self,fid):
        return True


    @staticmethod
    def create(regs=None):
        if regs == None: 
            regs = ArmRegisters.get_default_object()
        regform = RegArm32Edit(regs)
        regform.Compile()
        ok = regform.Execute()
        if not ok == ida_kernwin.ASKBTN_YES:
            return regs
        else:
            return ArmRegisters(R0=regform.R0.value,
                  R1=regform.R1.value,
                  R2=regform.R2.value,
                  R3=regform.R3.value,
                  R4=regform.R4.value,
                  R5=regform.R5.value,
                  R6=regform.R6.value,
                  R7=regform.R7.value,
                  R8=regform.R8.value,
                  R9=regform.R9.value,
                  R10=regform.R10.value,
                  R11=regform.R11.value,
                  R12=regform.R12.value,
                  R13=regform.R13.value,
                  R14=regform.R14.value,
                  R15=regform.R15.value)


DescFormAarch64 =  r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Reg Edit AARCH64
{cbCallback}
<##X0:{X0}>  |<##X1:{X1}>  |<##X2:{X2}>  |<##X3:{X3}> |<##X4:{X4}>
<##X5:{X5}>  |<##X6:{X6}>  |<##X7:{X7}>  |<##X8:{X8}> |<##X9:{X9}>
<##X10:{X10}> |<##X11:{X11}>| <##X12:{X12}>|<##SP:{X13}>
<##X14:{X14}> |<##X15:{X15}>|<##X16:{X16}>|<##X17:{X17}>
<##X18:{X18}> |<##X19:{X19}>|<##X20:{X20}>|<##X21:{X21}>
<##X22:{X22}> |<##X23:{X23}>|<##X24:{X24}>|<##X25:{X25}>
<##X26:{X26}> |<##X27:{X27}>|<##X28:{X28}>|<##FP:{FP}>
<##LR:{LR}>  |<##SP:{SP}>|<##PC:{PC}>
"""



class RegArm64Edit(ida_kernwin.Form):


    def __init__(self,regs):
        self.regs = regs
        if regs == None: 
            self.regs = Aarch64Registers.get_default_object()
        Form.__init__(self,DescFormAarch64,{
                'X0': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X0),
                'X1': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X1),
                'X2': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X2),
                'X3': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X3),
                'X4': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X4),
                'X5': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X5),
                'X6': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X6),
                'X7': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X7),
                'X8': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X8),
                'X9': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X9),
                'X10': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X10),
                'X11': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X11),
                'X12': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X12),
                'X13': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X13),
                'X14': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X14),
                'X15': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X15),
                'X16': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X16),
                'X17': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X17),
                'X18': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X18),
                'X19': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X19),
                'X20': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X20),
                'X21': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X21),
                'X22': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X22),
                'X23': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X23),
                'X24': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X24),
                'X25': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X25),
                'X26': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X26),
                'X27': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X27),
                'X28': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.X28),
                'FP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.FP),
                'LR': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.LR),
                'SP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.SP),
                'PC': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.PC),
                'cbCallback': Form.FormChangeCb(self.onCallback)})





    def onCallback(self,fid):
        return True



    @staticmethod
    def create(regs=None):

      if regs == None: 
            regs = Aarch64Registers.get_default_object()
      regform = RegArm64Edit(regs)
      regform.Compile()
      ok = regform.Execute()
      if not ok == ida_kernwin.ASKBTN_YES:
          return regs
      else:
          return Aarch64Registers(regform.X0.value,
                                                     regform.X1.value,
                                                     regform.X2.value,
                                                     regform.X3.value,
                                                     regform.X4.value,
                                                     regform.X5.value,
                                                     regform.X6.value,
                                                     regform.X7.value,
                                                     regform.X8.value,
                                                     regform.X9.value,
                                                     regform.X10.value,
                                                     regform.X11.value,
                                                     regform.X12.value,
                                                     regform.X13.value,
                                                     regform.X14.value,
                                                     regform.X15.value,
                                                     regform.X16.value,
                                                     regform.X17.value,
                                                     regform.X18.value,
                                                     regform.X19.value,
                                                     regform.X20.value,
                                                     regform.X21.value,
                                                     regform.X22.value,
                                                     regform.X23.value,
                                                     regform.X24.value,
                                                     regform.X25.value,
                                                     regform.X26.value,
                                                     regform.X27.value,
                                                     regform.X28.value,
                                                     regform.FP.value,
                                                     regform.LR.value,
                                                     regform.SP.value,
                                                     regform.PC.value)


DescFormx64 = r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
x64 Reg Edit
{cbCallback}
Edit Registers
 <##RAX:{RAX}>  |<##RBX:{RBX}>  |<##RCX:{RCX}>  |<##RDX:{RDX}> 
 <##RDI:{RDI}>  |<##RSI:{RSI}>  |<##RBP:{RBP}>  |<##RSP:{RSP}> 
 <##R8:{R8}>    |<##R9:{R9}>    |<##R10:{R10}>  |<##R11:{R11}>
 <##R12:{R12}>  |<##R13:{R13}>  |<##R14:{R14}>  |<##R15:{R15}>
 <##RIP:{RIP}>
"""


class Regx64Edit(ida_kernwin.Form):

    def __init__(self,regs):
        self.regs = regs
        if self.regs == None:
            self.regs= x64Registers.get_default_object()
            
        Form.__init__(self, DescFormx64 ,{

            'RAX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RAX),
            'RBX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RBX),
            'RCX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RCX),
            'RDX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RDX),
            'RDI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RDI),
            'RSI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RSI),
            'RBP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RBP),
            'RSP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RSP),
            'RIP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.RIP),
            'R8': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R8),
            'R9': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R9),
            'R10': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R10),
            'R11': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R11),
            'R12': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R12),
            'R13': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R13),
            'R14': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R14),
            'R15': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.R15),
            'cbCallback': Form.FormChangeCb(self.onCallback)})



    def onCallback(self,fid):
        return True


    @staticmethod
    def create(regs=None):
      if regs == None: 
          regs = x64Registers.get_default_object()
      regform = Regx64Edit(regs)
      regform.Compile()
      ok = regform.Execute()
      if not ok == ida_kernwin.ASKBTN_YES:
          return regs 
      else:
          return x64Registers(RAX=regform.RAX.value,
                            RBX=regform.RBX.value,
                            RCX=regform.RCX.value,
                            RDX=regform.RDX.value,
                            RDI=regform.RDI.value,
                            RSI=regform.RSI.value,
                            R8=regform.R8.value,
                            R9=regform.R9.value,
                            R10=regform.R10.value,
                            R11=regform.R11.value,
                            R12=regform.R12.value,
                            R13=regform.R13.value,
                            R14=regform.R14.value,
                            R15=regform.R15.value,
                            RBP=regform.RBP.value,
                            RSP=regform.RSP.value,
                            RIP=regform.RIP.value)


DescFormx86 = r"""STARTITEM
x86 Reg Edit
{cbCallback}
 <##EAX:{EAX}>  |<##EBX:{EBX}>  |<##ECX:{ECX}>
 <##EDX:{EDX}>  |<##EDI:{EDI}>  |<##ESI:{ESI}>
 <##EBP:{EBP}>  |<##ESP:{ESP}>  |<##EIP:{EIP}>
"""

class Regx86Edit(ida_kernwin.Form):

    def __init__(self,regs):
        self.regs = regs
        if self.regs == None :
            x86Registers.get_default_object()
        else:
            Form.__init__(self, DescFormx86,{
            'EAX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.EAX),
            'EBX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.EBX),
            'ECX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.ECX),
            'EDX': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.EDX),
            'EDI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.EDI),
            'ESI': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.ESI),
            'EBP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.EBP),
            'ESP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.ESP),
            'EIP': Form.NumericInput(tp=Form.FT_RAWHEX,value=self.regs.EIP),
            'cbCallback': Form.FormChangeCb(self.onCallback)})

    def onCallback(self,fid):
        return True


    @staticmethod
    def create(regs=None):
      if regs == None :
            regs = x86Registers.get_default_object()
      regform = Regx86Edit(regs)
      regform.Compile()
      ok = regform.Execute()
      if not ok == ida_kernwin.ASKBTN_YES:
          return regs
      else: 
            return x86Registers(regform.EAX.value,
                                                    regform.EBX.value,
                                                    regform.ECX.value,
                                                    regform.EDX.value,
                                                    regform.EDI.value,
                                                    regform.ESI.value,
                                                    regform.EBP.value,
                                                    regform.ESP.value,
                                                    regform.EIP.value)



```

`EWS/ui/stub_configuration.py`:

```py
import ida_kernwin
import ida_funcs
from EWS.utils.configuration import *
from EWS.utils.utils import *



class StubForm(ida_kernwin.Form):

  class function_chooser(ida_kernwin.Choose):
        def __init__(self, title, nb=5, flags=ida_kernwin.Choose.CH_MULTI):
            ida_kernwin.Choose.__init__(
                self,
                title,
                [
                    ["Address", 10],
                    ["Func Name", 30]
                ],
                flags=flags,
                embedded=True,
                width=30,
                height=6)
            self.items = [ ['%.8X' % x.start_ea, '%s' % ida_funcs.get_func_name(x.start_ea)]
                          for x in get_func_list() ]
            self.icon = 0
            self.ret = 0

        def OnGetLine(self, n):
            self.ret = self.items[n]
            return self.items[n]

        def OnGetSize(self):
            n = len(self.items)
            return n


  def __init__(self, conf=None):
    self.invert = False
    self.clicked_ns = False
    self.clicked_ds = False
    self.nstub=dict()
    self.custom_stubs_file = None
    self.tags = dict()
    self.orig_fpath = ""
    if conf == None:
        Form.__init__(self, r"""STARTITEM 
    BUTTON YES Yeah
    BUTTON NO Nope
    BUTTON CANCEL* Nevermind
    Stubbing confiugration
    {cbCallback}
    <##Activate stub mechanism (allow tagging/stubbing) No : {esNo} <Yes: <{esYes}>{esC}>
    <##Stub dynamic func tabble (ELF/PE) No:      {sfNo}> <Yes:{sfYes}>{sfC}>
    <##Original filepath:{origFpath}>
    <##Auto null stub missing symbols: {asNo}>< Yes:{asYes}>{saC}>
    <##Add custom stubs file: {customStubFile}>
    """,{
                'esC': Form.RadGroupControl(('esNon','esYes')),
                'sfC': Form.RadGroupControl(("sfNo","sfYes")),
                'customStubFile': Form.ButtonInput(self.CustomStubFile),
                'origFpath': Form.FileInput(open=True,save=False),
                'saC': Form.RadGroupControl(("asNo","asYes")),
                'cbCallback': Form.FormChangeCb(self.cb_callback)
    })
    else:
        Form.__init__(self, r"""STARTITEM 
        BUTTON YES Yeah
        BUTTON NO Nope
        BUTTON CANCEL* Nevermind
        Stubbing confiugration
        {cbCallback}
        <##Stub dynamic func tab No:      {sfNo}> <Yes:{sfYes}>{sfC}>
        <##Original filepath:{origFpath}>
        <##Auto null stub missing symbols: {asNo}>< Yes:{asYes}>{saC}>
        <##Add custom stubs file: {customStubFile}>
        """,{

                    'esC': Form.RadGroupControl(('esNon','esYes'),
                                                value=1 if conf.s_conf.activate_stub_mechanism else 0),
                    'sfC': Form.RadGroupControl(("sfNo","sfYes"),
                                                value=1 if conf.tag_func_tab else 0),
                    'customStubFile': Form.ButtonInput(self.CustomStubFile),
                    'origFpath': Form.FileInput(open=True,save=False,
                                                value=conf.s_conf.orig_filepath),
                    'saC': Form.RadGroupControl(("asNo","asYes"),
                                                value=1 if conf.s_conf.auto_null_stub else 0),
                    'cbCallback': Form.FormChangeCb(self.cb_callback)
        })


  def cb_callback(self,fid):
    if fid == self.sfC.id:
        logger.console(LogType.INFO,'Possible file path: %s'%search_executable())
        self.orig_fpath = search_executable()
        logger.console(LogType.INFO,'Found potential matching binary path:%s'%self.orig_fpath)
        self.SetControlValue(self.origFpath,self.orig_fpath)
    if fid == self.origFpath.id:
      self.orig_fpath = self.GetControlValue(self.origFpath)
    return 1


  def CustomStubFile(self,code):

    f_path =  FileSelector.fillconfig()
    if f_path == '' or not os.path.exists(f_path) or os.path.isdir(f_path): 
        logger.console(2,' [Custom Stub File] Invalid file path')
        return
    self.custom_stubs_file = f_path
    return

  def AddButton(self,code):
        for x in self.GetControlValue(self.cFuncChooser):
          f = get_func_list()[x]
          self.nstub[f.start_ea] = ida_funcs.get_func_name(f.start_ea)
        self.clicked_ns = True

  @staticmethod
  def fillconfig(config=None):
      f = StubForm(config)
      f.Compile()

      ok = f.Execute()
      if ok:


          if not verify_valid_elf(f.orig_fpath):
              logger.console(LogType.WARN,"Specified original filepath invalid, stubs won't work")
          ret = StubConfiguration(nstubs=f.nstub,
                                stub_dynamic_func_tab=f.sfC.value,
                                orig_filepath=f.orig_fpath,
                                custom_stubs_file=f.custom_stubs_file,
                                auto_null_stub=f.saC.value,
                                tags=f.tags)
#          print('orign fpath = %s'%ret.orig_filepath)
#          print('custon stub file = ',ret.custom_stubs_file)
#          print('stub dyn func tab = ',ret.stub_dynamic_func_tab)
      f.Free()
      return ret





```

`EWS/ui/tag_func_ui.py`:

```py
import ida_kernwin

class TagForm(ida_kernwin.Form):

  class tag_chooser(ida_kernwin.Choose):
        def __init__(self, title, tag_list, nb=5):
            ida_kernwin.Choose.__init__(
                self,
                title,
                [
                    ["Tag Name", 30]
                ],
                deflt=0,
                flags=ida_kernwin.CH_MODAL,
                embedded=True,
                width=10,
                height=6)
            self.items = [[tag_name] for tag_name in tag_list]
            self.icon = 0
            self.ret = 0

        def OnGetLine(self, n):
            self.ret = self.items[n]
            return self.items[n]

        def OnGetSize(self):
            n = len(self.items)
            return n

  def __init__(self,tag_list):
        self.tag_list = tag_list 
        self.tag_name = None # final value returned
        ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Tag Func
{cbCallback}
Available Tags
<Select tag: {cSegChooser}>
""",{
            'cSegChooser': ida_kernwin.Form.EmbeddedChooserControl(TagForm.tag_chooser("Available Tags",tag_list)),
            'cbCallback': ida_kernwin.Form.FormChangeCb(self.cb_callback)})


  def cb_callback(self,fid):
        if fid == self.cSegChooser.id:
            print('changing tag')
            self.tag_name = self.GetControlValue(self.cSegChooser)
        return 1

  @staticmethod
  def create(tag_list):
      f  = TagForm(tag_list) 
      f.Compile()
      ok = f.Execute()
      if ok:
          return f.tag_name.pop()












```

`EWS/ui/watchpoint.py`:

```py
import ida_kernwin
import binascii


class WatchPoint(ida_kernwin.Form):
    def __init__(self):
        self.ok = False
        ida_kernwin.Form.__init__(self, r"""STARTITEM 
BUTTON YES Yeah
BUTTON NO Nope
BUTTON CANCEL* Nevermind
Edit memory
<## Base Addr: {iAddr}>
<## Rang : {iValue}>
""",{
  'iAddr': ida_kernwin.Form.StringInput(ida_kernwin.Form.FT_ASCII),
  'iValue': ida_kernwin.Form.StringInput(ida_kernwin.Form.FT_ASCII)
})


    @staticmethod
    def fillconfig(emu=None):
        ret = False
        f= WatchPoint()
        f.Compile()
        f.Execute()
        if f.iAddr.value!= None and f.iValue.value != None:
            ba = int(f.iAddr.value,16)
            rg = int(f.iValue.value,16)
            if emu!=None:
                emu.add_watchpoint(ba,rg,mode=0x3)
                ret = True
        f.Free()
        return ret












```

`EWS/utils/call_tree.py`:

```py
from enum import Enum
import json

class CTT(Enum):

    CALL=0
    RET=1
    INFO=2



class Call_Tree():


    count = 0
    content = dict()

    def __init__(self):

        pass

    def add_entry(self,
                  trace_id:int,
                  addr:int,
                    depth:int,
                    typ:CTT,
                    target:int=0,
                    info:str=''):

        self.content[self.count] = {}
        self.content[self.count]['trace_id'] = trace_id
        self.content[self.count]['addr'] = addr
        self.content[self.count]['depth'] = depth
        self.content[self.count]['type'] = typ.value
        self.content[self.count]['target'] = target
        self.content[self.count]['info'] = info

        self.count+=1 




        
class Call_Tree_Serializer(json.JSONEncoder):

    def default(self,call_tree:Call_Tree):
        out = dict()
        out['count'] = dict()
        for k,v in call_tree.content.items():
            out['count'][k]=dict()

            out['count'][k] = { 'trace_id':'trace_id',
                               'addr':v['addr'],
                               'depth':v['depth'], 
                               'type': v['type'].value,
                                'target':v['target'],
                                 'info':v['info']}
        return out

    @staticmethod
    def dump_to_file(call_tree:Call_Tree,
                     filepath:str):
        try:
            with open(filepath,'w+') as fout:
                fout.write(json.dumps(call_tree,cls=Call_Tree_Serializer))
        except Exception as e:
            print('[!] errror serialization exec_trace object')
            print(e.__str__())


class Call_Tree_Deserializer(json.JSONDecoder):

    def decode(self,json_txt):

        jdict = json.loads(json_txt)

        trace = jdict['count'] 

        call_tree = Call_Tree()

        for k,v in trace.items():

            i_cnt = int(k,10)

            trace_id = v['trace_id']
            addr = v['addr'] 
            depth = v['depth']
            typ = v['type']
            target = v['target']
            info = v['info']

            call_tree.add_entry(trace_id,
                                addr,
                                depth,
                                CTT(typ),
                                target,
                                info)

        return call_tree



        











```

`EWS/utils/configuration.py`:

```py
from EWS.utils.registers import *
from EWS.utils.utils import *
import json



class AdditionnalMapping():

    @staticmethod
    def create():

        return AdditionnalMapping(mappings={})

    def __init__(self,mappings):

        """ 
        !class constructor 

        @param mappings is a record of {addr: bytes}

        """

        self.mappings = mappings

    def __str__(self):

        return '\n'.join(['{}: {}'.format(x,self.__dict__[x])
                          for x in self.__dict__])

    def __add__(self,addm):

        ret = {**self.mappings, **addm.mappings}
        return AdditionnalMapping(ret)

 
class StubConfiguration():

    @staticmethod #should move to classmethod see https://www.geeksforgeeks.org/classmethod-in-python/
    def create():
        cls = StubConfiguration(nstubs={},
                                activate_stub_mechanism=True,
                                tag_func_tab=True,
                                orig_filepath=None,
                                custom_stubs_file=None,
                                auto_null_stub=False,
                                tags={})
        return cls

    def __init__(self,nstubs,
                 activate_stub_mechanism: bool,
                 tag_func_tab: bool,
                 orig_filepath: str,
                 custom_stubs_file: str =None,
                 auto_null_stub: bool=False,
                 tags: dict = None):
        """
        !

        @param activate_stub_mechanism: create helper for stubs
        @param tag_func_tab:            stub ELF(GOT)/PE(IAT) table (when available)
        @param orig_filepath:           name of the original binary
        @param custom_stubs_file:       file that specify special behavior for certain function
        @param autonull stub:           null stubs symbols that are not currently supported
        @param tags :                   dict {ea:stub_name}
        @param nstubs                   null stub dictionnary
        """

        self.tag_func_tab = tag_func_tab
        self.activate_stub_mechanism = activate_stub_mechanism
        self.orig_filepath = orig_filepath
        self.custom_stubs_file = custom_stubs_file
        self.auto_null_stub = auto_null_stub
        self.nstubs = nstubs
        if tags == None:
            self.tags = dict()
        else: self.tags = tags

    def __str__(self):
        return '\n'.join(['{}: {}'.format(x,self.__dict__[x]) for x in self.__dict__])


    def __add__(self,sconf):
        nstubs = {**self.nstubs, **sconf.nstubs}
        tags = {**self.tags, **sconf.tags}
        return StubConfiguration(nstubs=nstubs,
                                 activate_stub_mechanism=sconf.activate_stub_mechanism,
                                 tag_func_tab=sconf.tag_func_tab,
                                 orig_filepath=sconf.orig_filepath,
                                 custom_stubs_file=sconf.custom_stubs_file,
                                 auto_null_stub=sconf.auto_null_stub,
                                 tags=tags)



class Configuration():
    """ Configuration as follow
            arch:                     str             idp name 
            emulator                str             emulation solution name 
            stk_ba:                 int             for stack base address 
            stk_size:             int             for stack size (curved with p_size)    
            autoMap:                boolean     if true when a insn hit unmapped page, the page will be mapped by the engine(if available)    
            showRegisters:    boolean     if true registers value will be displayed on the console and/or file 
            exec_saddr:         int             start address of the execution
            exec_eaddr:         int             stop address of the execution
            mapping_saddr     int             offset in binary where the mapping starts 
            mapping_eaddr     int             offset in binary where the mapping ends
            map_with_segs     boolean     allow selecting segm. to map among list (disable two previous options)
            use_seg_perms     boolean     use segment permission(s) of the file format (if available)
            useCapstone         boolean     use capstone to generate insn disassembly output
            registers:            [int]         init values of regsiters
            s_conf:
            showMemAccess     boolean     when activated display all memory accesses on logger
            amap_conf:            [mapping] allow addit. mappings (not belonging to the binary) 
                                                                usefull for arguments mapping etc... 
            memory_init         [mapping] allow to store memory initialization
            filepath:             str             path of the origianl executable (for stubs)
            breakpoint:         list of breakpoints
            watchpoints:         dict of {watchpoint_addr: size} #  it does not record fashion access (read/write)
            patches:            dict of {addr: asm}

    """
    
    def __init__(self,
                 path: str = None,
                 arch: str = None,
                 emulator: str = None,
                 p_size: int = None,
                 stk_ba: int = None,
                 stk_size: int = None,
                 autoMap: bool = None,
                 showRegisters: bool = None,
                 exec_saddr: int =None,
                 exec_eaddr: int =None,
                 mapping_saddr: int =None,
                 mapping_eaddr: int =None,
                 segms: list =None,
                 map_with_segs: bool = None,
                 use_seg_perms: bool =None,
                 useCapstone: bool = None,
                 registers: Registers = None,
                 showMemAccess: bool =None,
                 s_conf: StubConfiguration = None,
                 amap_conf: AdditionnalMapping = None,
                 memory_init: dict =None,
                 color_graph: bool =None,
                 breakpoints: list =None,
                 watchpoints: dict =None,
                 patches: dict = None,
                 max_insn: int = 0x10000):

        self.path = path 
        self.arch = arch
        self.emulator = emulator
        self.p_size = p_size 
        self.stk_ba = stk_ba
        self.stk_size = stk_size
        self.autoMap = True if autoMap else False
        self.showRegisters = True if showRegisters else False
        self.useCapstone = True if useCapstone else False
        self.exec_saddr = exec_saddr 
        self.exec_eaddr = exec_eaddr
        self.mapping_saddr = mapping_saddr
        self.mapping_eaddr = mapping_eaddr
        self.segms = segms
        self.map_with_segs = map_with_segs
        self.registers=registers
        self.showMemAccess=showMemAccess
        self.use_seg_perms=use_seg_perms
        self.s_conf = s_conf
        self.amap_conf = amap_conf
        self.memory_init = memory_init
        self.color_graph = color_graph
        self.breakpoints = breakpoints
        self.watchpoints = watchpoints
        self.patches = patches
        self.max_insn = max_insn


    @classmethod
    def generate_default_config(cls,
                                 path: str = None,
                                 arch: str = None,
                                 emulator: str = None,
                                 p_size: int = None,
                                 stk_ba: int = None,
                                 stk_size: int = None,
                                 autoMap: bool = None,
                                 showRegisters: bool = None,
                                 exec_saddr: int =None,
                                 exec_eaddr: int =None,
                                 mapping_saddr: int =None,
                                 mapping_eaddr: int =None,
                                 segms: list =None,
                                 map_with_segs: bool = None,
                                 use_seg_perms: bool =None,
                                 useCapstone: bool = None,
                                 registers: Registers = None,
                                 showMemAccess: bool =None,
                                 s_conf: StubConfiguration = None,
                                 amap_conf: AdditionnalMapping = None,
                                 memory_init: AdditionnalMapping =None,
                                 color_graph: bool =None,
                                 breakpoints: list =None,
                                watchpoints: dict =None,
                                patches: dict = None,
                                max_insn: int = 0x10000):



        """
        !generate_default_config 

        @param arch:                     str             idp name 
        @param emulator                str             emulation solution name 
        @param stk_ba:                 int             for stack base address 
        @param stk_size:             int             for stack size (curved with p_size)    
        @param autoMap:                boolean     if true when a insn hit unmapped page, the page will be mapped by the engine(if available)    
        @param showRegisters:    boolean     if true registers value will be displayed on the console and/or file 
        @param exec_saddr:         int             start address of the execution
        @param exec_eaddr:         int             stop address of the execution
        @param mapping_saddr     int             offset in binary where the mapping starts 
        @param mapping_eaddr     int             offset in binary where the mapping ends
        @param map_with_segs     boolean     allow selecting segm. to map among list (disable two previous options)
        @param use_seg_perms     boolean     use segment permission(s) of the file format (if available)
        @param useCapstone         boolean     use capstone to generate insn disassembly output
        @param registers:            [int]         init values of regsiters
        @param s_conf:
        @param showMemAccess     boolean     when activated display all memory accesses on logger
        @param amap_conf:            [mapping] allow addit. mappings (not belonging to the binary) 
                                                             usefull for arguments mapping etc... 
        @param memory_init         [mapping] allow to store memory initialization
        @param filepath:             str             path of the origianl executable (for stubs)
        @param breakpoint:         list of breakpoints
        @param watchpoints:         dict of {watchpoint_addr: size} #  it does not record fashion access (read/write)
        @param patches:            dict of {addr: asm}

        @return Configuration Object
        """

        if registers == None:
            raise Exception('Registers object must be created when using generate_default_config function')

        if s_conf == None:
            exec_path = search_executable()
            stub_conf = StubConfiguration(nstubs=dict(),
                                            tag_func_tab = True,
                                            activate_stub_mechanism=True,
                                            orig_filepath=exec_path,
                                            custom_stubs_file=None,
                                            auto_null_stub=True if exec_path != "" else False,
                                            tags=dict())
        else:
            stub_conf = s_conf

        if amap_conf == None:
            addmap_conf = AdditionnalMapping.create()
        else:
            addmap_conf = amap_conf

        if memory_init == None:
            meminit = AdditionnalMapping.create()
        else:
            meminit = memory_init


        return Configuration( path=path if path else '',
                              arch=arch,
                              emulator='unicorn',
                              p_size=p_size if p_size else 0x1000,
                              stk_ba=stk_ba if stk_ba else 0x7FFFFFFF,
                              stk_size=stk_size if stk_size else 0x10000,
                              autoMap=autoMap if autoMap else False,
                              showRegisters=showRegisters if showRegisters else True,
                              exec_saddr=exec_saddr if exec_saddr else 0,
                              exec_eaddr=exec_eaddr if exec_eaddr else 0xFFFFFFFF,
                              mapping_saddr=get_min_ea_idb() if not mapping_saddr else mapping_saddr,
                              mapping_eaddr=get_max_ea_idb() if not mapping_eaddr else mapping_eaddr,
                              segms=segms if segms else [],
                              map_with_segs=map_with_segs if map_with_segs else False,
                              use_seg_perms=use_seg_perms if use_seg_perms else False,
                              useCapstone=useCapstone if useCapstone else True,
                              registers=registers,
                              showMemAccess=showMemAccess if showMemAccess else True,
                              s_conf=stub_conf,
                              amap_conf=addmap_conf,
                              memory_init=meminit,
                              color_graph=False,
                              breakpoints=breakpoints if breakpoints else [],
                             watchpoints = watchpoints if watchpoints else {},
                             patches = patches if patches else {},
                             max_insn = max_insn)



    def __str__(self):
        return '\n'.join(['{}: {}'.format(x,self.__dict__[x]) for x in self.__dict__])


    def show_user_mapping(self,displayContent=False):
        for k,v in self.amap_conf.mappings.items():
            logger.console(LogType.INFO,'[%x:%x]'%(k,k+len(v)))
            if displayContent:
                display_mem(v)


    def show_nullstubs(self):

        """ 
        !show_nullstubs 
        """

        for k,v in self.s_conf.nstubs.items():
            logger.console(LogType.INFO,'%s at %x'%(v,k))


    def add_null_stub(self,
                      ea:int) -> None:

        """ 
        !add_null_stub
        """

        self.s_conf.nstubs[ea] = ida_funcs.get_func_name(ea)

    def remove_null_stub(self,
                         ea:int)-> None:

        """ 
        !remove_null_stub
        """

        if ea in self.s_conf.nstubs.keys():
                del self.s_conf.nstubs[ea]
        else:
                logger.console(LogType.WARN,"Could not remove null-stub",
                               "No null-stub registred at this address (%x)"%ea)


    def add_tag(self,
                ea:int,
                stub_name:str) -> None:
        
        """ 
        !add_tag

        @param ea Effective Address of the function
        @param stub_name The name of the tag used to stub the function  


        """

        if ea in self.s_conf.tags.keys():
                logger.console(LogType.WARN,'Tag already registred at this ea (%x). Overwritting the value'%ea)
        self.s_conf.tags[ea] = stub_name

    def remove_tag(self,
                   ea:int)->None:

        """ 
        !remove_tag 

        @param ea Effective Address where the tag was registred

        """


        if ea in self.s_conf.nstubs.keys():
            
                del self.s_conf.nstubs[ea]

        else:
                logger.console(LogType.WARN,"Could not remove tag. No tag registred at this address (%x)"%ea)

    def show_tags(self)-> None:

        """
        !show_tags
        """

        for k,v in self.s_conf.tags.items():
            logger.console(LogType.INFO,'%x : %s'%(k,v))
    
    def save(self,
             path:str)-> None:

        saveconfig(self,path)

    def add_breakpoint(self,
                       ea:int) -> None:

        """
        !add_breakpoint

        @param ea Effective Address for the breakpoint

        """ 
        
        self.breakpoints.append(ea)

    def add_watchpoint(self,
                       base_addr:int,
                       size:int) -> None :

        """ 
        !add_watchpoint

        @param base_addr Effective Address of the data
        @param size Size to consider.
        """

        self.watchpoints[base_addr] = size
        
    def remove_breakpoint(self,
                          ea:int) -> None:

        """ 
        !remove_breakpoint 

        @param ea Effective Address where the breakpoint was registred 
        """


        self.breakpoints.remove(ea)

    def show_breakpoints(self) -> None:

        """ 
        !show_breakpoints 


        """

        for k in self.breakpoints:
            logger.console(LogType.INFO,'%x'%k)

    def add_patch(self,
                    addr: int,
                    asm: str) -> None:

        """
        !add_patch 

        @param addr Effective Address for the patch 
        @param asm Assembly text to be compiled


        """


        self.patches[addr] = asm

    def remove_patch(self,
                     addr: int) -> None:
        """
        !remove_patch 

        @param addr Effective Address where the patch was registred

        """
    
        del self.patches[addr]



class ConfigSerializer(json.JSONEncoder):

    def default(self,
                conf):
       
        """ 
        This class is used for serialization. 

        @param config Configuration Object to be serialized

        """

        if isinstance(conf, Configuration):

            segs = [ seg.start_ea for seg in conf.segms ] 
            funcs = conf.s_conf.nstubs

            f_amap = dict()
            for k,v in conf.amap_conf.mappings.items():
                il = [ b for b in bytearray(v) ]    
                f_amap[k] = il 

            f_meminit = dict()
            for k,v in conf.memory_init.mappings.items():
                il = [ b for b in bytearray(v) ]    
                f_meminit[k] = il 



   
            
            p = dict() 
            for addr,bytecode in conf.patches.items():
                p[addr] = [b for b in bytearray(bytecode)]


            
            return {'path':conf.path, 
                            'arch': conf.arch,
                            'emulator':conf.emulator, 
                            'p_size' : conf.p_size, 
                            'stk_ba': conf.stk_ba, 
                            'stk_size' : conf.stk_size, 
                            'autoMap' : conf.autoMap, 
                            'showRegisters': conf.showRegisters, 
                            'useCapstone': conf.useCapstone, 
                            'exec_saddr' : conf.exec_saddr, 
                            'exec_eaddr' : conf.exec_eaddr, 
                            'mapping_saddr' : conf.mapping_saddr, 
                            'mapping_eaddr' : conf.mapping_eaddr,
                            'segms': segs, 'registers': conf.registers.__dict__, 
                            'map_with_segs' : conf.map_with_segs,
                            'showMemAccess': conf.showMemAccess, 
                            'use_seg_perms': conf.use_seg_perms, 
                            's_conf': {'nstubs' : funcs, 
                                                 'tag_func_tab': conf.s_conf.tag_func_tab,
                                                 'activate_stub_mechanism': conf.s_conf.activate_stub_mechanism, 
                                                 'orig_filepath' : conf.s_conf.orig_filepath, 
                                                 'auto_null_stub': conf.s_conf.auto_null_stub,
                                                 'custom_stubs_file' : conf.s_conf.custom_stubs_file,
                                                 'tags':conf.s_conf.tags}, 
                         'amap_conf': f_amap, 'color_graph': conf.color_graph,
                         'memory_init': f_meminit,
                         'breakpoints':conf.breakpoints,
                         'watchpoints': conf.watchpoints,
                         'patches': p,
                         'max_insn': conf.max_insn}


class ConfigDeserializer(json.JSONDecoder): #PASS ClassType for register parsing ? 
    
        def decode(self,json_txt):
        

            jdict = json.loads(json_txt)
            nstubs = dict()


            for ea,fname in jdict['s_conf']['nstubs'].items(): nstubs[int(ea,10)] = fname
     
                                                    
            amap_dict = dict()
            for k,v in jdict['amap_conf'].items(): 
                amap_dict[int(k,10)] = bytes(v)
       
            meminit_dict = dict()
            for k,v in jdict['memory_init'].items(): 
                meminit_dict[int(k,10)] = bytes(v) 
    
            tags_dict = dict()
            for k,v in jdict['s_conf']['tags'].items():
                tags_dict[int(k,10)] = v 

            watchpoints = dict()
            for k,v in jdict['watchpoints'].items():
                watchpoints[int(k,10)] = v
        
            if jdict['arch'] == 'arm':
                regs=ArmRegisters(**jdict['registers'])
            elif jdict['arch'] == 'mips':
                regs=MipslRegisters(**jdict['registers'])
            elif jdict['arch'] == 'x86' or (jdict['arch'] == 'pc' and not idc.__EA64__):
                regs=x86Registers(**jdict['registers']) 
            elif jdict['arch'] == 'x64':
                regs=x64Registers(**jdict['registers'])
            elif jdict['arch'] == 'aarch64':
                regs=Aarch64Registers(**jdict['registers'])


            patches = dict()
            for addr,intb in jdict['patches'].items():
                patches[int(addr,10)] = bytes(bytearray(intb))
                

            conf = Configuration(path=jdict['path'],
                                 arch=jdict['arch'],
                                 emulator=jdict['emulator'],
                                 p_size=jdict['p_size'],
                                 stk_ba=jdict['stk_ba'],
                                 stk_size=jdict['stk_size'],
                                 autoMap=jdict['autoMap'],
                                 showRegisters=jdict['showRegisters'],
                                 exec_saddr=jdict['exec_saddr'],
                                 exec_eaddr=jdict['exec_eaddr'],
                                 mapping_saddr=jdict['mapping_saddr'],
                                 mapping_eaddr=jdict['mapping_eaddr'],
                                 segms=[ ida_segment.getseg(segea) for segea in jdict['segms'] ],
                                 map_with_segs=jdict['map_with_segs'],
                                 use_seg_perms=jdict['use_seg_perms'],
                                 useCapstone=jdict['useCapstone'],
                                 registers=regs,
                                 showMemAccess=jdict['showMemAccess'],
                                 s_conf=StubConfiguration(nstubs=nstubs,
                                                          tag_func_tab=jdict['s_conf']['tag_func_tab'],
                                                          activate_stub_mechanism=jdict['s_conf']['activate_stub_mechanism'],
                                                           orig_filepath=jdict['s_conf']['orig_filepath'],
                                                           custom_stubs_file=jdict['s_conf']['custom_stubs_file'],
                                                            auto_null_stub=jdict['s_conf']['auto_null_stub'],
                                                            tags=tags_dict),
                                amap_conf=AdditionnalMapping(amap_dict),
                                 memory_init=AdditionnalMapping(meminit_dict),
                                 color_graph=jdict['color_graph'],
                                 breakpoints=jdict['breakpoints'],
                                 watchpoints=watchpoints,
                                 patches=patches,
                                 max_insn=jdict['max_insn'])

            return conf
             
def saveconfig(conf,
               conf_apath:str=''): 

    """ 
    !saveconfig 

    @param conf_apath: Path of the file for Configuration serialization

    """

    if conf_apath == '': 
        conf_apath=conf.path
   
    with open(conf_apath,'w+') as fout: 
        json.dump(conf,fp=fout,cls=ConfigSerializer)
    

def loadconfig(conf_apath:str) -> Configuration : 

    """ 
    !loadconfig 

    @param conf_apath: Path of the Configuration to be deserialized.

    """

    with open(conf_apath, 'r') as fin:

        return json.loads(fin.read(),cls=ConfigDeserializer)




```

`EWS/utils/consts_aarch64.py`:

```py
nop=0x1f2003d5
ALLOC_BA = 0x80000000
ALLOC_PAGES = 0x10
ret=0xc0035fd6
STACK_BASEADDR = 0x7FFFFFFF00000000
STACK_SIZE = 0x10000
PSIZE=0x1000
LIBCSTARTSTUBADDR=STACK_BASEADDR-PSIZE
initial_stack_offset = 0x20

from unicorn.arm64_const import *

reg_map_unicorn = {}

reg_map_unicorn['X0']=UC_ARM64_REG_X0
reg_map_unicorn['X1']=UC_ARM64_REG_X1
reg_map_unicorn['X2']=UC_ARM64_REG_X2
reg_map_unicorn['X3']=UC_ARM64_REG_X3
reg_map_unicorn['X4']=UC_ARM64_REG_X4
reg_map_unicorn['X5']=UC_ARM64_REG_X5
reg_map_unicorn['X6']=UC_ARM64_REG_X6
reg_map_unicorn['X7']=UC_ARM64_REG_X7
reg_map_unicorn['X8']=UC_ARM64_REG_X8
reg_map_unicorn['X9']=UC_ARM64_REG_X9
reg_map_unicorn['X10']=UC_ARM64_REG_X10
reg_map_unicorn['X11']=UC_ARM64_REG_X11
reg_map_unicorn['X12']=UC_ARM64_REG_X12
reg_map_unicorn['X13']=UC_ARM64_REG_X13
reg_map_unicorn['X14']=UC_ARM64_REG_X14
reg_map_unicorn['X15']=UC_ARM64_REG_X15
reg_map_unicorn['X16']=UC_ARM64_REG_X16
reg_map_unicorn['X17']=UC_ARM64_REG_X17
reg_map_unicorn['X18']=UC_ARM64_REG_X18
reg_map_unicorn['X19']=UC_ARM64_REG_X19
reg_map_unicorn['X20']=UC_ARM64_REG_X20
reg_map_unicorn['X21']=UC_ARM64_REG_X21
reg_map_unicorn['X22']=UC_ARM64_REG_X22
reg_map_unicorn['X23']=UC_ARM64_REG_X23
reg_map_unicorn['X24']=UC_ARM64_REG_X24
reg_map_unicorn['X25']=UC_ARM64_REG_X25
reg_map_unicorn['X26']=UC_ARM64_REG_X26
reg_map_unicorn['X27']=UC_ARM64_REG_X27
reg_map_unicorn['X28']=UC_ARM64_REG_X28
reg_map_unicorn['FP']=UC_ARM64_REG_X29
reg_map_unicorn['LR']=UC_ARM64_REG_X30
reg_map_unicorn['SP']=UC_ARM64_REG_SP
reg_map_unicorn['PC']=UC_ARM64_REG_PC

```

`EWS/utils/consts_arm.py`:

```py
### ARM SPECIFICS #######
TRAP_PAGE_BA = 0xFFFFE000
SVC_INSN_ARM   = 0xEF000000
TRAP_INS_SIZE  = 2
TRAP_INX_SIZE  = 2
ALLOC_BA = 0x80000000
ALLOC_PAGES = 0x10
mov_pc_lr = 0xe1a0f00e # big end. 
mov_pc_lr_thumb = 0x46f7  # big end. 
nop_thumb = 0xBF00
nop=0x00000000
STACK_BASEADDR = 0x7FF00000
STACK_SIZE = 0x10000
PSIZE=0x400

initial_stack_offset=0x10

LIBCSTARTSTUBADDR=STACK_BASEADDR-PSIZE

### END ARM SPECIFICS ####

from unicorn.arm_const import *

reg_map_unicorn = {}
reg_map_unicorn['R0']=UC_ARM_REG_R0
reg_map_unicorn['R1']=UC_ARM_REG_R1
reg_map_unicorn['R2']=UC_ARM_REG_R2
reg_map_unicorn['R3']=UC_ARM_REG_R3
reg_map_unicorn['R4']=UC_ARM_REG_R4
reg_map_unicorn['R5']=UC_ARM_REG_R5
reg_map_unicorn['R6']=UC_ARM_REG_R6
reg_map_unicorn['R7']=UC_ARM_REG_R7
reg_map_unicorn['R8']=UC_ARM_REG_R8
reg_map_unicorn['R9']=UC_ARM_REG_R9
reg_map_unicorn['R10']=UC_ARM_REG_R10
reg_map_unicorn['R11']=UC_ARM_REG_R11
reg_map_unicorn['R12']=UC_ARM_REG_R12
reg_map_unicorn['R13']=UC_ARM_REG_R13
reg_map_unicorn['R14']=UC_ARM_REG_R14
reg_map_unicorn['R15']=UC_ARM_REG_R15

```

`EWS/utils/consts_ida.py`:

```py
PLUGNAME="ews"
EMULLAUNCHER=PLUGNAME+":defaultlauncher"
EMULF=PLUGNAME+":emulfunc"
EMULSELECT=PLUGNAME+":emulselection"
EMULINIT=PLUGNAME+":emulinit"
RESET=PLUGNAME+":reset"
EDITREG=PLUGNAME+":regedit"
EDITCONF=PLUGNAME+":editconf"
SAVECONF=PLUGNAME+":saveconf"
EDITSTUBCONF=PLUGNAME+"stubconfedit"
NSTUB=PLUGNAME+":nullstubfunc"
TAGFUNC=PLUGNAME+":tagfunc"
LOADCONF=PLUGNAME+":loadconf"
EXECFROMSTART=PLUGNAME+":execfrmstart"
PATCHMEM=PLUGNAME+":patchmem"
DISPLAYMEM=PLUGNAME+":displaymem"
DISPLAYSTK=PLUGNAME+":displaystack"
DISPLAYADDR=PLUGNAME+":displayaddr"
EXPORTMEM=PLUGNAME+":exportmem"
IMPORTMEM=PLUGNAME+":importmem"
STEPIN=PLUGNAME+":stepin"
STEPOVER=PLUGNAME+":stepover"
CONTINUE=PLUGNAME+":continue"
RESTART=PLUGNAME+":restart"
ADDMAPPNG=PLUGNAME+":addmapping"
WATCHPOINT=PLUGNAME+":watchpoint"
PATCH=PLUGNAME+":patchinsn"
PATCHFILE=PLUGNAME+":patchfile"
LOADTRACE=PLUGNAME+":loadtrace"

   

```

`EWS/utils/consts_mips.py`:

```py
###
BREAK_INSN_MIPS = 0xD # 001101
ALLOC_BA = 0x50000000
ALLOC_PAGES = 0x10
TRAMPOLINE_ADDR=0x1000
TRAMPOLINE_SIZE=0xC
TRAMPOLINE_INSNS=0x8C01000003E0000800000000 # lw $at, ($zero); jr $ar ; nop;
jr_ra_nop = 0x03E0000800000000
nop=0x00000000
###


```

`EWS/utils/consts_x64.py`:

```py
ALLOC_BA = 0x80000000
ALLOC_PAGES = 0x10
STACK_BASEADDR = 0x7FFFFFFF00000000
STACK_SIZE = 0x10000
PSIZE=0x1000
LIBCSTARTSTUBADDR=STACK_BASEADDR-PSIZE
initial_stack_offset=0x20

```

`EWS/utils/consts_x86.py`:

```py
nop = 0x90
ida_retn_itype = 0x9F
ida_jmp_itype = [ 0x56, 0x58]
ida_jmp_conditional_itype = 0x55
ret = 0xC3
ALLOC_BA = 0x80000000
ALLOC_PAGES = 0x10
STACK_BASEADDR = 0x7FF00000
STACK_SIZE = 0x10000
PSIZE=0x1000
LIBCSTARTSTUBADDR=STACK_BASEADDR-PSIZE
"""
STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **
					 MAIN_AUXVEC_DECL),
			    int argc,
			    char **argv,
#ifdef LIBC_START_MAIN_AUXVEC_ARG
			    ElfW(auxv_t) *auxvec,
#endif
			    __typeof (main) init,
			    void (*fini) (void),
			    void (*rtld_fini) (void),
			    void *stack_end)
     __attribute__ ((noreturn));
"""
# without calling init function  
"""
mov eax, [esp+4] ;ptr_main 
push [esp+8] ;ptr argc
push [esp+0xC] ; ptr argv
push [esp+0x10] ; ptr init 
call eax 
"""
#LIBCSTARTSTUBCODE=b"\x8b\x44\x24\x04\xff\x74\x24\x08\xff\x74\x24\x0c\xff\x74\x24\x10\xff\xd0"
# calling init function (warning: no check on ptr init.)
"""
mov ebx, [esp+0x10]  ; ptr_init
push [esp+8] ; ptr argc
push [esp+0xC]  : ptr argv
call ebx 
mov eax, [esp+12] ; ptr_main
call eax 
"""
LIBCSTARTSTUBCODE=b"\x8b\x5c\x24\x10\xff\x74\x24\x08\xff\x74\x24\x0c\xff\xd3\x8b\x44\x24\x0c\xff\xd0"

initial_stack_offset=0x10 # in case of pop instructions when starting emulation. 

from unicorn.x86_const import *

reg_map_unicorn = {}
reg_map_unicorn['eax']=UC_X86_REG_EAX
reg_map_unicorn['ebx']=UC_X86_REG_EBX
reg_map_unicorn['ecx']=UC_X86_REG_ECX
reg_map_unicorn['edx']=UC_X86_REG_EDX
reg_map_unicorn['edi']=UC_X86_REG_EDI
reg_map_unicorn['esi']=UC_X86_REG_ESI
reg_map_unicorn['esp']=UC_X86_REG_ESP
reg_map_unicorn['ebp']=UC_X86_REG_EBP
reg_map_unicorn['eip']=UC_X86_REG_EIP
reg_map_unicorn['EAX']=UC_X86_REG_EAX
reg_map_unicorn['EBX']=UC_X86_REG_EBX
reg_map_unicorn['ECX']=UC_X86_REG_ECX
reg_map_unicorn['EDX']=UC_X86_REG_EDX
reg_map_unicorn['EDI']=UC_X86_REG_EDI
reg_map_unicorn['ESI']=UC_X86_REG_ESI
reg_map_unicorn['ESP']=UC_X86_REG_ESP
reg_map_unicorn['EBP']=UC_X86_REG_EBP
reg_map_unicorn['EIP']=UC_X86_REG_EIP




```

`EWS/utils/exec_trace.py`:

```py
from EWS.utils.registers import *
import json



class Exec_Trace(object):

    arch = ''
    content = dict()

    def __init__(self,arch,content=None):
        self.arch = arch
        self.count = 0
        if content:
            self.content=content


    def add_instruction(self,
                        addr:int,
                        assembly:str,
                        regs:Registers,
                        color:int,
                        tainted:bool):


        self.content[self.count] = { 'addr': addr,
                                 'assembly': assembly,
                            'regs': regs,
                            'color': color,
                            'tainted': tainted
                           }
        self.count += 1
        return self.count-1

    def get_color_map(self) -> dict:

        """
            returns entries {'addr1':'color1', ...}
        """
        
        color_map = dict()

        for k,v in self.content.items():
            color_map[k]=v['color']

        return color_map

    def generate_color_map(self,
                           color:int=0x00000000) -> dict:

        """
            return a color map indexed by all executed address.
            used to print the trace on the graph.
        """


        color_map = dict()

        for k in self.content.keys():
            color_map[k] = color

        return color_map



class Exec_Trace_Serializer(json.JSONEncoder):

    def default(self,exec_trace:Exec_Trace):
        out = dict()
        out['arch'] =  exec_trace.arch,
        out['count'] = dict()
        for k,v in exec_trace.content.items():
            out['count'][k]=dict()

            out['count'][k] = { 'addr':v['addr'], 'assembly':v['assembly'], 
                                  'regs': v['regs'].__dict__,
                                  'color':v['color'],
                                 'tainted':v['tainted']
                                   }
        return out

    @staticmethod
    def dump_to_file(exec_trace:Exec_Trace,
                     filepath:str):
        try:
            with open(filepath,'w+') as fout:
                fout.write(json.dumps(exec_trace,cls=Exec_Trace_Serializer))
        except Exception as e:
            print('[!] errror serialization exec_trace object')
            print(e.__str__())


class Exec_Trace_Deserializer(json.JSONDecoder):

    def decode(self,json_txt):

        jdict = json.loads(json_txt)
        arch= jdict['arch']

        if type(arch) is type([]):
            arch = arch[0]
        elif type(arch) is type(""):
            pass

        trace = jdict['count'] 

        exec_trace = Exec_Trace(arch)

        for k,v in trace.items():

            i_cnt = int(k,10)

            addr = v['addr'] 
            asm = v['assembly']
            registers= v['regs']
            tainted = v['tainted']
            color = v['color']

            if jdict['arch'] == 'arm':
                regs=ArmRegisters(**registers)
            elif jdict['arch'] == 'mips':
                regs=MipslRegisters(**registers)
            elif jdict['arch'] == 'x86' or (jdict['arch'] == 'pc' and not idc.__EA64__):
                regs=x86Registers(**registers) 
            elif jdict['arch'] == 'x64':
                regs=x64Registers(**registers)
            elif jdict['arch'] == 'aarch64':
                regs=Aarch64Registers(**registers)

            exec_trace.add_instruction(addr,
                                       asm,
                                       regs,
                                       color,
                                       tainted)

        return exec_trace


```

`EWS/utils/registers.py`:

```py
from EWS.utils import consts_arm
from EWS.utils import consts_aarch64
from EWS.utils import consts_x86
from EWS.utils import consts_x64

class Registers(object):

  def __init__(self):
    pass
  def __str__(self):
    return '\n'.join(['{}: {}'.format(x,self.__dict__[x]) for x in self.__dict__])
  def get_program_counter(self):
    pass

  def get_register_values_l(self) -> list:
    """
    return a list containing current register values
    of the emulator. Used for the debug_panel.
    [ ['reg1', 'value'], [...], ['regn', 'value'] ]
    """
    pass



class ArmRegisters(Registers):
 
  def __init__(self,R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15):
    self.R0=R0
    self.R1=R1
    self.R2=R2
    self.R3=R3
    self.R4=R4
    self.R5=R5
    self.R6=R6
    self.R7=R7
    self.R8=R8
    self.R9=R9
    self.R10=R10
    self.R11=R11
    self.R12=R12
    self.R13=R13
    self.R14=R14
    self.R15=R15


  @classmethod
  def create(cls):
      return ArmRegisters(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)

  def get_program_counter(self):
      return self.R15

  def get_register_values_l(self) -> list:

      out = list()

      out.append(['R0', hex(self.R0)])
      out.append(['R1', hex(self.R1)])
      out.append(['R2', hex(self.R2)])
      out.append(['R3', hex(self.R3)])
      out.append(['R4', hex(self.R4)])
      out.append(['R5', hex(self.R5)])
      out.append(['R6', hex(self.R6)])
      out.append(['R7', hex(self.R7)])
      out.append(['R8', hex(self.R8)])
      out.append(['R9', hex(self.R9)])
      out.append(['R10', hex(self.R10)])
      out.append(['R11', hex(self.R11)])
      out.append(['R12', hex(self.R12)])
      out.append(['SP', hex(self.R13)])
      out.append(['LR', hex(self.R14)])
      out.append(['PC', hex(self.R15)])

      return out

  @classmethod
  def get_default_object(cls,
                         r13=0,
                         r14=0,
                         r15=0):
        return ArmRegisters(  0x0,
                              0x1,
                              0x2,
                              0x3,
                              0x4,
                              0x5,
                              0x6,
                              0x7,
                              0x8,
                              0x9,
                              0xA,
                              0xB,
                              0xC,
                              consts_arm.STACK_BASEADDR+\
                              consts_arm.STACK_SIZE-\
                              consts_arm.initial_stack_offset if r13 ==0\
                            else r13,
                              r14,
                              r15)


class arm32CPSR(Registers):
  def __init__(self,N,Z,C,V,I,F):
    self.N = N 
    self.Z = Z
    self.C = C 
    self.V = V 
    self.I = I 
    self.F = F


  @classmethod 
  def create(cls,cpsr):
    return arm32CPSR(N=(cpsr&0x80000000)>>31,
                     Z=(cpsr&0x40000000)>>30,
                     C=(cpsr&0x20000000)>>29,
                     V=(cpsr&0x10000000)>>28,
                     I=(cpsr&0x8000000)>>27,
                     F=(cpsr&0x400000)>>26)

  def __str__(self):
    out = '[N=%d Z=%d C=%d V=%d I=%d F=%d] '%(self.N,self.Z,self.C,self.V,self.I,self.F)
    return out



class Aarch64Registers(Registers):
 
  def __init__(self,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,
                    X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,
                    X20,X21,X22,X23,X24,X25,X26,X27,X28,FP,LR,SP,PC):
    self.X0=X0
    self.X1=X1
    self.X2=X2
    self.X3=X3
    self.X4=X4
    self.X5=X5
    self.X6=X6
    self.X7=X7
    self.X8=X8
    self.X9=X9
    self.X10=X10
    self.X11=X11
    self.X12=X12
    self.X13=X13
    self.X14=X14
    self.X15=X15
    self.X16=X16
    self.X17=X17
    self.X18=X18
    self.X19=X19
    self.X20=X20
    self.X21=X21
    self.X22=X22
    self.X23=X23
    self.X24=X24
    self.X25=X25
    self.X26=X26
    self.X27=X27
    self.X28=X28
    self.FP=FP
    self.LR=LR
    self.SP=SP
    self.PC=PC

  def get_program_counter(self):
      return self.PC

  @classmethod
  def create(cls):
      return Aarch64Registers(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)

  @classmethod
  def get_default_object(cls,X0=0,X1=0,X2=0,X3=0,X4=0,X5=0,X6=0,X7=0,X8=0,X9=0,
                    X10=0,X11=0,X12=0,X13=0,X14=0,X15=0,X16=0,X17=0,X18=0,X19=0,
                    X20=0,X21=0,X22=0,X23=0,X24=0,X25=0,X26=0,X27=0,X28=0,FP=0,
                         LR=0,SP=0,PC=0):
      return Aarch64Registers(   X0,
                                 X1,
                                 X2,
                                 X3,
                                 X4,
                                 X5,
                                 X6,
                                 X7,
                                 X8,
                                 X9,
                                 X10,
                                 X11,
                                 X12,
                                 X13,
                                 X14,
                                 X15,
                                 X16,
                                 X17,
                                 X18,
                                 X19,
                                 X20,
                                 X21,
                                 X22,
                                 X23,
                                 X24,
                                 X25,
                                 X26,
                                 X27,
                                 X28,
                                 FP, # FP
                                 LR, # LR
                                 consts_aarch64.STACK_BASEADDR+\
                                 consts_aarch64.STACK_SIZE-\
                                 consts_aarch64.initial_stack_offset if SP==0 else SP,
                                 PC)


  def get_register_values_l(self) -> list:

      out = list()

      out.append(['X0', hex(self.X0)])
      out.append(['X1', hex(self.X1)])
      out.append(['X2', hex(self.X2)])
      out.append(['X3', hex(self.X3)])
      out.append(['X4', hex(self.X4)])
      out.append(['X5', hex(self.X5)])
      out.append(['X6', hex(self.X6)])
      out.append(['X7', hex(self.X7)])
      out.append(['X8', hex(self.X8)])
      out.append(['X9', hex(self.X9)])
      out.append(['X10', hex(self.X10)])
      out.append(['X11', hex(self.X11)])
      out.append(['X12', hex(self.X12)])
      out.append(['X13', hex(self.X13)])
      out.append(['X14', hex(self.X14)])
      out.append(['X15', hex(self.X15)])
      out.append(['X16', hex(self.X16)])
      out.append(['X17', hex(self.X17)])
      out.append(['X18', hex(self.X18)])
      out.append(['X19', hex(self.X19)])
      out.append(['X20', hex(self.X20)])
      out.append(['X21', hex(self.X21)])
      out.append(['X22', hex(self.X22)])
      out.append(['X23', hex(self.X23)])
      out.append(['X24', hex(self.X24)])
      out.append(['X25', hex(self.X25)])
      out.append(['X26', hex(self.X26)])
      out.append(['X27', hex(self.X27)])
      out.append(['X28', hex(self.X28)])
      out.append(['SP', hex(self.SP)])
      out.append(['LR', hex(self.LR)])
      out.append(['FP', hex(self.FP)])
      out.append(['PC', hex(self.PC)])

      return out



class aarch64CPSR(Registers):
  def __init__(self,N,Z,C,V,I,F):
    self.N = N 
    self.Z = Z
    self.C = C 
    self.V = V 
    self.I = I 
    self.F = F


  @classmethod 
  def create(cls,cpsr):
    return aarch64CPSR(N=(cpsr&0x80000000)>>31,
                     Z=(cpsr&0x40000000)>>30,
                     C=(cpsr&0x20000000)>>29,
                     V=(cpsr&0x10000000)>>28,
                     I=(cpsr&0x8000000)>>27,
                     F=(cpsr&0x400000)>>26)

  def __str__(self):
    out = '[N=%d Z=%d C=%d V=%d I=%d F=%d] '%(self.N,self.Z,self.C,self.V,self.I,self.F)
    return out




class MipslRegisters(Registers): 
  """ Based on https://en.wikibooks.org/wiki/MIPS_Assembly/Register_File
  """
  def __init__(self,at,a0,a1,a2,a3,s0,s1,s2,s3,s4,s5,s6,s7,k0,k1,pc,
                   t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,v0,v1,hi,lo,sp,fp,gp,ra):
    self.at = at
    #arguments
    self.a0 = a0
    self.a1 = a1 
    self.a2 = a2
    self.a3 = a3
    # saved
    self.s0 = s0
    self.s1 = s1 
    self.s2 = s2 
    self.s3 = s3
    self.s4 = s4
    self.s5 = s5 
    self.s6 = s6
    self.s7 = s7
    # temporary
    self.t0 = t0
    self.t1 = t1 
    self.t2 = t2 
    self.t3 = t3
    self.t4 = t4
    self.t5 = t5 
    self.t6 = t6
    self.t7 = t7
    self.t8 = t8
    self.t9 = t9
    # division 
    self.hi = hi
    self.lo = lo 
    # return values
    self.v0 = v0
    self.v1 = v1
    # exec 
    self.gp = gp
    self.fp = fp
    self.sp = sp
    self.ra = ra
    self.pc = pc
    # misc (kernel)
    self.k0 = k0
    self.k1 = k1 

  def get_program_counter(self):
      return self.pc
 

    
class x86Registers(Registers):

  def __init__(self,EAX,EBX,ECX,EDX,EDI,ESI,EBP,ESP,EIP):

    self.EAX = EAX
    self.EBX = EBX 
    self.ECX = ECX
    self.EDX = EDX
    self.EDI = EDI
    self.ESI = ESI 
    self.ESP = ESP
    self.EBP = EBP
    self.EIP = EIP

  @classmethod
  def create(cls):

      return x86Registers(0,0,0,0,0,0,0,0,0)

  def get_program_counter(self):
      return self.EIP


  def get_register_values_l(self) -> list:

    out = list()
    out.append(['EAX', hex(self.EAX)])
    out.append(['EBX', hex(self.EBX)])
    out.append(['ECX', hex(self.ECX)])
    out.append(['EDX', hex(self.EDX)])
    out.append(['EDI', hex(self.EDI)])
    out.append(['ESI', hex(self.ESI)])
    out.append(['EBP', hex(self.EBP)])
    out.append(['ESP', hex(self.ESP)])
    out.append(['EIP', hex(self.EIP)])


    return out

  @classmethod
  def get_default_object(cls,EAX=0,
                            EBX=1,
                            ECX=2,
                            EDX=3,
                            EDI=4,
                            ESI=5,
                            EBP=consts_x86.STACK_BASEADDR+consts_x86.STACK_SIZE-\
                             consts_x86.initial_stack_offset,
                            ESP=consts_x86.STACK_BASEADDR+consts_x86.STACK_SIZE-\
                             consts_x86.initial_stack_offset,
                            EIP=0):
      return x86Registers(EAX,EBX,ECX,EDX,EDI,ESI,EBP,ESP,EIP)

class x86EFLAGS(Registers):
  def __init__(self,CF,PF,AF,ZF,SF,TF,EIF,DF,OF):
    self.CF = CF
    self.PF = PF 
    self.AF = AF
    self.ZF = ZF
    self.SF = SF
    self.TF = TF
    self.EIF = EIF
    self.DF = DF 
    self.OF = OF 

  @classmethod 
  def create(cls,eflags):
    return x86EFLAGS(CF=(eflags)&0x1,
                     PF=(eflags&0x4)>>2,
                     AF=(eflags&0x10)>>4,
                     ZF=(eflags&0x40)>>6,
                     SF=(eflags&0x80)>>7,
                     TF=(eflags&0x100)>>8,
                     EIF=(eflags&0x200)>>9,
                     DF=(eflags&0x400)>>10,
                     OF=(eflags&0x800)>>11)

  def __str__(self):
    out = '[ZF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d EIF=%d DF=%d OF=%d]'%(self.CF,
                                                                      self.PF,
                                                                      self.AF,
                                                                      self.ZF,
                                                                      self.SF,
                                                                      self.TF,
                                                                      self.EIF,
                                                                      self.DF,
                                                                      self.OF)
    return out


  
class x64Registers(Registers):
  
  def __init__(self,RAX,RBX,RCX,RDX,RDI,RSI,R8,R9,R10,R11,R12,R13,R14,R15,RBP,RSP,RIP):
    self.RAX = RAX
    self.RBX = RBX
    self.RCX = RCX
    self.RDX = RDX
    self.RDI = RDI 
    self.RSI = RSI
    self.R8 = R8
    self.R9 = R9
    self.R10 = R10
    self.R11 = R11
    self.R12 = R12
    self.R13 = R13
    self.R14 = R14
    self.R15 = R15
    self.RBP = RBP 
    self.RSP = RSP 
    self.RIP = RIP 

  def __str__(self) -> str:

    strout =  '[RAX=%.8X] [RBX=%.8X] [RCX=%.8X] [RDX=%.8X]\n'%(self.RAX,
                                                         self.RBX,
                                                         self.RCX,
                                                         self.RDX)
    strout += '[RDI=%.8X] [RSI=%.8X] [RBP=%.8X] [RSP=%.8X]\n'%(self.RDI,
                                                         self.RSI,
                                                         self.RBP,
                                                         self.RSP)
    strout += '[R8=%.8X] [R9=%.8X] [R10=%.8X] [R11=%.8X]\n'%(self.R8,
                                                            self.R9,
                                                            self.R10,
                                                            self.R11)
    strout += '[R12=%.8X] [R13=%.8X] [R14=%.8X] [R15=%.8X]\n'%(self.R12,
                                                            self.R13,
                                                            self.R14,
                                                            self.R15)
    return strout

  def get_program_counter(self):
      return self.RIP
 
  def get_register_values_l(self) -> list:

      out = list()
      out.append(['RAX', hex(self.RAX)])
      out.append(['RBX', hex(self.RBX)])
      out.append(['RCX', hex(self.RCX)])
      out.append(['RDX', hex(self.RDX)])
      out.append(['RDI', hex(self.RDI)])
      out.append(['RSI', hex(self.RSI)])
      out.append(['RBP', hex(self.RBP)])
      out.append(['RSP', hex(self.RSP)])
      out.append(['RIP', hex(self.RIP)])
      out.append(['R8', hex(self.R8)])
      out.append(['R9', hex(self.R9)])
      out.append(['R10', hex(self.R10)])
      out.append(['R11', hex(self.R11)])
      out.append(['R12', hex(self.R12)])
      out.append(['R13', hex(self.R13)])
      out.append(['R14', hex(self.R14)])
      out.append(['R15', hex(self.R15)])

      return out

  @classmethod
  def get_default_object(cls,RAX=0,
                             RBX=1,
                             RCX=2,
                             RDX=3,
                             RDI=4,
                             RSI=5,
                             R8=6,
                             R9=7,
                             R10=8,
                             R11=9,
                             R12=10,
                             R13=11,
                             R14=12,
                             R15=13,
                             RBP=consts_x64.STACK_BASEADDR+consts_x64.STACK_SIZE-\
                             consts_x64.initial_stack_offset,
                             RSP=consts_x64.STACK_BASEADDR+consts_x64.STACK_SIZE-\
                             consts_x64.initial_stack_offset,
                             RIP=0):
      return x64Registers(RAX,RBX,RCX,RDX,RDI,RSI,R8,R9,R10,R11,R12,R13,R14,R15,RBP,RSP,RIP)




class x64RFLAGS(Registers):
  def __init__(self,CF,PF,AF,ZF,SF,TF,EIF,DF,OF):
    self.CF = CF
    self.PF = PF 
    self.AF = AF
    self.ZF = ZF
    self.SF = SF
    self.TF = TF
    self.EIF = EIF
    self.DF = DF 
    self.OF = OF 

  @classmethod 
  def create(cls,eflags):
    return x64RFLAGS(CF=(eflags)&0x1,
                     PF=(eflags&0x4)>>2,
                     AF=(eflags&0x10)>>4,
                     ZF=(eflags&0x40)>>6,
                     SF=(eflags&0x80)>>7,
                     TF=(eflags&0x100)>>8,
                     EIF=(eflags&0x200)>>9,
                     DF=(eflags&0x400)>>10,
                     OF=(eflags&0x800)>>11)

  def __str__(self):
    out = '[ZF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d EIF=%d DF=%d OF=%d]'%(self.CF,
                                                                      self.PF,
                                                                      self.AF,
                                                                      self.ZF,
                                                                      self.SF,
                                                                      self.TF,
                                                                      self.EIF,
                                                                      self.DF,
                                                                      self.OF)
    return out




```

`EWS/utils/utils.py`:

```py
import ida_idaapi
import ida_bytes
import ida_funcs
import ida_segment
import ida_segregs
import ida_ida
import ida_idp
import ida_ua
import ida_loader
import idc 
import string
import ida_nalt
import os
import lief
import struct
from enum import Enum
from re import compile
import ida_kernwin
import EWS.emu.emubase

# based on x64
MAX_INSN_SIZE=15


class plug_mode(Enum):

    DEFAULT=0
    TRACEVIEWER=1
 

def get_seg_list() -> list:

    """
    !get_seg_list returns the list of available segments
    in IDB.

    @return A list of registred segments in IDB.

    """

    info = ida_idaapi.get_inf_structure()
    seg_l = []
    s = ida_segment.getseg(info.min_ea)
    if s == None:
        print('[!] Please make sure that all the memory belongs to a segment')
        exit(1)
    seg_l.append(s)
    while True:
        s = ida_segment.get_next_seg(s.end_ea-1)
        if s == None:
            break
        seg_l.append(s)
    return seg_l


def get_func_list() -> list:

    """
    !get_func_list return the list of available functions
        in IDB.

    @return List of functions registred inside the IDB.

    """

    info = ida_idaapi.get_inf_structure()
    fun_l = []
    f = ida_funcs.get_next_func(info.min_ea)

    if f == None:
        return fun_l
    fun_l.append(f)
    while True:
        f = ida_funcs.get_next_func(f.start_ea)
        if f == None:
            break
        fun_l.append(f)
    return fun_l




def proc_inf(arch: str,
             addr: int) -> dict:

    """
    !proc_inf returns a dictionnary containing information
    regarding processor' address size and endianess.

    @param arch: The current binary architecture. 
    @param addr: The current address. 

    @return A dictionnary with processor mode, endianness, ...

    """

    ret = dict()

    if arch == 'arm':

            if ida_segregs.get_sreg(addr,ida_idp.str2reg('T')):
                logger.console(LogType.INFO,"Thumb mode detected")
                ret['proc_mode']=16
            else:
                ret['proc_mode']=32
            if ida_ida.inf_get_procname() == 'armb':
                ret['endianness'] = 'big'
            else :
                ret['endianness'] = 'little'

    if arch == 'mips':
        if ida_segregs.get_sreg(addr,ida_idp.str2reg('mips16')):
                ret['proc_mode']=16
        else:
                ret['proc_mode']=32
        if ida_ida.inf_get_procname() == 'mipsb':
                ret['endianness'] = 'big'
        else : #"mipsl" 
                ret['endianness'] = 'little'

    return ret



class SockMode(Enum):

    """
    !SockMode is used in stub mechanism for
    socket related functions.
    """

    UKN=2
    READ=0
    WRITE=1


class LogType(Enum):

    """
    !LogType indicate the verbose level
    of a logging information.
    """

    INFO = 0
    WARN = 1
    ERRR = 2

class LoaderType(Enum):

    """
    LoaderType indicated which kind of
    file is currently handled
    """

    ELF = 0
    PE    = 1
    UNDEF = 2

class StubType(Enum):

    """
    StubType indicates which stubbing mechanism
    is referenced inside a Stub object.
    """

    BUILTIN = 0
    TAG = 1
    USER = 2
    NULL = 3



class Logger():

    """
    !Logger intend to logs the different event, with different verbose
    mode.
    It can either log information on the console, or directly on the file.
    """

    def __init__(self,VERBOSE:int,
                 fpath=''):

        """
            int value VERBOSE indicate the verbose of the plugin (0 : none to X: a lot)
        """

        self.VERBOSE = VERBOSE


        if fpath == '':

            from dateutil import utils as utilsdate

            d=utilsdate.today()
            dt=d.now()

            from tempfile import NamedTemporaryFile
            if not os.path.exists("/tmp/EWS"): 
                os.mkdir("/tmp/EWS")
            

            self.fpath = NamedTemporaryFile(dir="/tmp/EWS/",delete=False,mode='w+',
                                        prefix='EWS',
                                        suffix='%d-%d-%d-%d-%d-%d'%(dt.year,
                                                                    dt.month,
                                                                    dt.day,
                                                                    dt.hour,
                                                                    dt.minute,
                                                                    dt.second))

            self.console(LogType.WARN,
                         'No log file provided, ',
                         'logs will be written to %s file.'%self.fpath.name)


    def console(self,
                type : LogType,
                *msg : list):

        """
        !Log event to the console

        @param type: The log type. 
        @param msg: list of print arguments.

        """

        if type == LogType.INFO and self.VERBOSE > 1:
            print('[INFO] ',*msg)

        if type == LogType.WARN and self.VERBOSE > 0:
            print('[WARN] ',*msg)

        if type == LogType.ERRR:
            print('[ERRR] ',*msg)

    def logfile(self,
                type: LogType,
                *msg: list):

        """
            log event to logfile.
        """

        msg = ' '.join(msg)

        if type == LogType.INFO :
            self.fpath.write('[INFO] %s\n'%msg)
            self.fpath.flush()

        if type == LogType.WARN :
            self.fpath.write('[WARN] %s\n'%msg)
            self.fpath.flush()

        if type == LogType.ERRR:
            self.fpath.write('[ERRR] %s\n'%msg)
            self.fpath.flush()



logger = Logger(2)


class ConfigExcption(Exception):

    def __init__(self,str):
        super().__init__(str)


def get_insn_color(eaddr: int):

    """
    !get_insn_color returns the color associated to the instruction
    at address eaddr.

    @param eaddr: Effective Address to extract the insn color from.

    """

    return idc.get_color(eaddr,idc.CIC_ITEM)

def colorate_graph(color_map:dict):

    """
    colorate_graph takes a dictionnary referencing addresses and
    their associated color. It paints the graph according these information.

    @DEPRECATED
    """

    for addr in color_map.keys():

        try:
            idc.set_color(addr,idc.CIC_ITEM,0xAAAAAA)

        except:
            logger.logfile(LogType.WARN,'Could not colorate the graph at %x'%addr)


def restore_graph_color(color_map: dict,
                        purge_db=False):

    """
    !restore_graph_color restores the color of the referenced instructions.
    There are provided by a dictionnary referencing addresses and their original
    color.

    @DEPRECATED
    """

    for addr,color in color_map.items():
        try:
            if color != 0xFFFFFF and color != 0xAAAAAA: 
                idc.set_color(addr,idc.CIC_ITEM,color)
            else:
                idc.set_color(addr,idc.CIC_ITEM,0x242424) # TODO: get default color from idc ? 
        except:
            pass

    if purge_db:
        color_map = dict()


def is_thumb(addr:int) -> bool:

    """
    !is_thumb indicates if the current address recorded in IDB
    reference thumb instruction.

    @param addr: Effective Address to get the Thumb flag from.

    @return Thumb or not Thumb

    """

    return True if ida_segregs.get_sreg(addr,
                                        ida_idp.str2reg('T')) == 1 else False


def get_insn_at(ea: int) -> ida_ua.insn_t:

    """
    !Returns an instruction object given the address *ea*

    @param ea: Effective Address to get the insn object from.

    @return a insn object.

    """


    insn = ida_ua.insn_t()
    ida_ua.decode_insn(insn,ea)

    return insn

def get_insn_bytecode(ea: int,
                      helper= None) -> bytes :
    """
    Return the bytecode at address *ea*.

    @param ea: Effective Address to extract the bytecode from.
    @param helper: SEA object to read memory from.

    @return The bytecode.

    """

    insn = get_insn_at(ea)

    if not helper:
            return ida_bytes.get_bytes(ea,insn.size)

    else:
            return helper.mem_read(ea,insn.size)


def get_captsone_repr(emu:EWS.emu.emubase.Emulator,
                      addr: int) -> str:

    """
    !get_captsone_repr uses captsone engine to return 
    the syntax associated to the bytecode referenced 
    at address *addr*.

    @param emu: Emulator Object 
    @param addr: Effective Address of the code.  
    
    @return capstone representation.

    """

    try:
        opline = emu.mem_read(addr,MAX_INSN_SIZE)
        insn_cpst=next(emu.cs.disasm(opline,addr,count=1))
        insn_str="0x%x:\t%s\t%s" %(insn_cpst.address,
                                     insn_cpst.mnemonic,
                                     insn_cpst.op_str)

    except Exception as e:
        logger.console(LogType.ERRR,
                                     "Capstone cannot decode bytecode:",
                                     opline, 'at ea %x'%addr)
        return ''

    return insn_str


def build_insn_repr(emu:EWS.emu.emubase.Emulator,
                    addr: int) -> str:

    """
    !build_insn_repr return the syntax associated to the instruction
    referenced at address *addr*.
    It is involved in trace outputing mechanism.

    @param emu: Pointer to Emulator object
    @param addr: Effective Addres of the instruction. 

    @param string repr of the instruction. 

    """

    strout=''

    if emu.conf.useCapstone:
            insn_str = get_captsone_repr(emu,addr)

    if emu.conf.showRegisters:
            strout+= emu.print_registers()
            strout+= str(emu.get_alu_info())
            strout+= '\n'
            strout+= '------------------------\n'

    # This becomes incorrect if assembly has been patched. BUG
    bytecode= emu.mem_read(addr,get_insn_at(addr).size)

    strout+= '[opcode=%X] '% int.from_bytes(bytecode,'big',signed=False)
    strout += '[PC=%.8X]  '%  addr
    strout+= insn_str

    return strout


def build_func_name(ea: int) -> str:

    """
    !build_func_name returns the name of the function 
    recorded in IDB for address *addr*. If no function
    is associated to the address, a name is built.

    @param ea: Effective Address

    @return function name
    """

    fn = ida_funcs.get_func_name(ea)

    if fn == None: 
        fn = 'func_%x'%ea

    return fn


def get_min_ea_idb() -> int:

    """
        !get_min_ea_idb returns the minimal Effective Address recorded in the IDB.

        @return int value of min ea
    """

    return ida_idaapi.get_inf_structure().min_ea


def get_max_ea_idb() -> int:

    """
        !get_min_ea_idb returns the biggest Effective Address 
        recorded in the IDB.

        @return max ea value
    """

    return ida_idaapi.get_inf_structure().max_ea



def make_idb_backup(): 

    ida_path = os.path.basename(ida_loader.get_path(ida_loader.PATH_TYPE_CMD))
    ida_path = ida_path.replace(".i64","").replace("idb","")
    from dateutil import utils as utilsdate

    d=utilsdate.today()
    dt=d.now()

    from tempfile import NamedTemporaryFile
    if not os.path.exists("/tmp/EWS"): 
        os.mkdir("/tmp/EWS")
    
    suffix = '%d-%d-%d-%d-%d-%d'%(dt.year,
                                                            dt.month,
                                                            dt.day,
                                                            dt.hour,
                                                            dt.minute,
                                                            dt.second)
    suffix +=  '.i64' if idc.__EA64__ else '.idb'

    backup_file = NamedTemporaryFile(dir="/tmp/EWS/",delete=False,mode='w+',
                                prefix=ida_path,
                                suffix=suffix)



    ida_loader.save_database(backup_file.name,ida_loader.DBFL_BAK)


    logger.console(f"Database backup available {backup_file.name}")






def search_executable() -> str:

        """ 

            !search_executable tries to locate the binary corresponding to the IDB
            in order to parse dynamic information.

            @return filepath 
        """

        idb_path = ida_loader.get_path(ida_loader.PATH_TYPE_CMD)
        if idc.__EA64__: 
            pat = compile("(.*)(.i64)$")
        else:
            pat = compile("(.*)(.idb)$")
        f_pat = pat.search(idb_path) 
        if not f_pat is None:

            if idc.__EA64__: 
                return f_pat.group(0).replace('.i64','')
            else:
                return f_pat.group(0).replace('.idb','')
        else: 

                ida_kernwin.warning("Could not find executable file, please enter its location")
                file = ida_kernwin.ask_file(1,"","Please locate original executable")
                if file != "": 
                    return file
                else:
                    ida_kernwin.warning("Could not locate original executable file, so mechanism won't work") 
                    return ""
            

def does_file_exist(f_path: str) -> bool:

    """
    does_file_exist indicate if the specified file in path f_path does exist.
  
    @return Indicate if the file exists.

    """

    
    return f_path != None and os.path.exists(f_path) and not os.path.isdir(f_path)




def verify_valid_elf(candidate: str) -> bool:
    """
    !verify_valid_elf indicate if the file specified in *f_path* is a valid
    ELF.

    @param candidate: Path of the ELF file. 

    @return Indicate if LIEF managed to parse the file.

    """

    try:
        
        return candidate != None and\
            does_file_exist(candidate) and\
            lief.ELF.parse(candidate)

    except AttributeError:
        return False



def verify_valid_PE(candidate: str) -> bool:

    """
    !Verify_valid_PE indicate if the file specified in *f_path* is a valid
    PE.

    @param candidate: Path of the ELF file. 

    @return Indicate if LIEF managed to parse the file.
    """


    try: 
        return does_file_exist(candidate) and lief.PE.parse(candidate) != None
    except AttributeError:
        return False


def get_next_pc(insn: ida_ua.insn_t) -> int:

    """
    get_next_pc uses metainformation provided by instruction object
    *insn* to determinate potential future program counter value.
    TODO: returns a list of potential values.

    @return Next PC address.

    """

    if ida_idp.is_call_insn(insn) or ida_idp.has_insn_feature(insn.itype,ida_idp.CF_STOP):

        xf_ea = ida_xref.get_first_cref_from(insn.ea)
        xf_ea = ida_xref.get_next_cref_from(insn.ea,xf_ea)

        if xf_ea != idaapi.BADADDR:
                    return xf_ea

        else:
                    raise Exception('[+] Could not determine target of the call/jmp insn')

    elif ida_idp.is_indirect_jump_insn(insn):

            #see ev_calc_next_insn and ev_calc_step_over
            raise Exception('NotImplemented')
    # TODO 
    # elif as_feature CF_JF CF_JN pour les sauts conditionnels
    else:
            return insn.ea + insn.size


def breakpoints_all_insn_target(insn: ida_ua.insn_t):

        """
        This function will add breakpoint to all potential target ea. 
        Usefull for jump table. 

        @param insn: Instruction to use.
        """

        xf_ea = ida_xref.get_first_cref_from(insn.ea)
        while (xf_ea != idaapi.BADADDR):
                bp_addr.append(xf_ea)
                xf_ea = ida_xref.get_next_cref_from(insn.ea,xf_ea)
        for bp_ea in bp_addr:
                ida_dbg.add_bpt(bp_ea,0,idc.BPT_SOFT)


def get_imports(fpath: str) -> dict:

    """
    get_imports returns a dictionnary object referencing
    the symbol' address resolutions.
    It is associated to PE object.

    @param File path

    @return PE imports 

    """

    reloc_map = dict()
    info = ida_idaapi.get_inf_structure()

    PE_obj = lief.PE.parse(fpath)

    if str(PE_obj) != 'None':

            for f in PE_obj.imported_functions:
                    reloc_map[f.name] = f.address + ida_nalt.get_imagebase()

    return reloc_map

def get_relocs(fpath: str,
               RTYPE_ID: int) -> dict:

    """
    get_relocs returns a dictionnary providing
    information concerning symbols and their address given
    the expected kind of relocation RTYPE_ID.
    It is associated to ELF object.

    @param ELF path.
    @param Type of RELOC

    @return The relocations 


    """

    reloc_map = dict()

    elf_l = lief.ELF.parse(fpath)

    if str(elf_l) != 'None':

        relocs = elf_l.relocations

        for r in relocs:

                if r.type == int(RTYPE_ID):
                    reloc_map[r.symbol.name] = r.address


    return reloc_map





def int_to_bytes(value:int,
                size: int)-> bytes:

    """ 
    !Various integer/bytes converter

    @param the int value
    @param the size object in return 

    @return the bytes. 

    """

    value = abs(value) 
    if size == 1:
        return struct.pack('B',value&0xFF)
    elif size == 2:
        return struct.pack('<H',value&0xFFFF)
    elif size == 4:
        return struct.pack('<I',value&0xFFFFFFFF)
    elif size == 8:
        return struct.pack('<Q',value&0xFFFFFFFFFFFFFFFF)

```

`EWS/utils/utils_ui.py`:

```py
import idaapi
import idc
import ida_funcs
import ida_idp
import ida_ua
import ida_segment
import ida_kernwin
import ida_bytes
from EWS.ui.generic import Pannel
from EWS.ui.regedit import RegArm32Edit, RegArm64Edit, Regx86Edit, Regx64Edit
from EWS.ui.mem_edit import MemEdit
from EWS.ui.mem_operations import ExportMemory, ImportMemory 
from EWS.ui.tag_func_ui import TagForm
from EWS.ui.display_mem import SelectSegment, MemDisplayer, asciify, space, AddrNBPages
from EWS.ui.watchpoint import WatchPoint
import EWS.ui
import binascii
import json
from unicorn import UcError
from EWS.emu.unicorn.arm32 import ArmCorn
from EWS.emu.unicorn.aarch64 import Aarch64Corn
from EWS.emu.unicorn.mipsl32 import MipsCorn
from EWS.emu.unicorn.x86 import x86Corn
from EWS.emu.unicorn.x64 import x64Corn
from EWS.utils.configuration import *
from typing import Tuple,Dict,List

from EWS.utils.utils import *
import os.path


def get_user_select() -> Tuple:

    """ 
    !Extract the user selection from the current UI. 

    @return User Selected Range. 

    """ 

    p0 = idaapi.twinpos_t()
    p1 = idaapi.twinpos_t()
    view = idaapi.get_current_viewer()
    if not idaapi.read_selection(view, p0, p1):
        return (idaapi.BADADDR,idaapi.BADADDR)

    return (p0.at.toea(),p1.at.toea())


def get_func_boundaries() -> Tuple:

    """ 

    !Extract the function boundaries.

    @return The function boundaries.

    Note that this function does not handle function chunks.
    It only determines and returns the smallest and biggest 
    instruction addresses. 
    """

    ea = idc.get_screen_ea()
    f = ida_funcs.get_func(ea)
    # IDA func boundaries must be threated like [start_ea:end_ea[ 
    # otherwise there is artifact when emulated function call underlying
    # function (it stops on its first instruction). Dirty hack is to decrease
    # by one the value. 
    return (f.start_ea,f.end_ea-1)




def get_conf_for_area(s_ea:int,
                      e_ea:int) :

  """  
  !Generate a default configuration from a starting and ending address.

  @param s_ea: Effective Address of the first instruction to be executed. 
  @param e_ea: Effective Address of the last instruction to be executed.

  @return Configuration object.

  """

  procname = idaapi.get_idp_name()
  if procname == 'arm':
    if idc.__EA64__:
        return Aarch64Corn.generate_default_config(exec_saddr=s_ea,
                                                   exec_eaddr=e_ea)
    else:
        return ArmCorn.generate_default_config(exec_saddr=s_ea,
                                                   exec_eaddr=e_ea)

  elif procname == 'pc':
      if idc.__EA64__:
          return x64Corn.generate_default_config(exec_saddr=s_ea,
                                                 exec_eaddr=e_ea)
      else:
        return x86Corn.generate_default_config(exec_saddr=s_ea,
                                               exec_eaddr=e_ea)
  else:
    logger.console(LogType.ERRR,"Sorry %s is not currently supported at this stage" % procname)

  return emu

def get_emul_from_conf(conf) -> EWS.emu.emubase.Emulator:

  """
  !This function initialize the engine from a configuration object.
  In case several options are available, this function must ask the user 
  to choose among the candidates.

  @param Configuration object

  @param Emulator wrapper.

  """


  procname = idaapi.get_idp_name()
  if procname == 'arm':
    if idc.__EA64__:
        return Aarch64Corn(conf)
    else:
        return ArmCorn(conf)

  elif procname == 'pc':
      if idc.__EA64__:
          return x64Corn(conf)
      else:
          return x86Corn(conf)



def get_emul_conf(simplified : bool = True,
                  conf: EWS.utils.configuration.Configuration = None):

  """ 
  ! This function helps to edit configuration. 
  """

  emu = None
  procname = idaapi.get_idp_name()
  if procname == 'arm':
      #TODO MODIF HERE PANNEL
    if idc.__EA64__: # TODO it checks if the instance of IDA is ida64 or ida. 
                     # in case a 32bit arch is opened with ida64 this will 
                     # bug. FIXME find another way to probe the arch. 
        return Pannel.fillconfig(register_ui_class=RegArm64Edit.create,
                          default_regs_values=Aarch64Registers.get_default_object(),
                                 conf=conf if conf else None)
    else:
        return Pannel.fillconfig(register_ui_class=RegArm32Edit.create,
                          default_regs_values=ArmRegisters.get_default_object(),
                                 conf=conf if conf else None)
  elif procname == 'pc':
   if idc.__EA64__: # assess if ida is running in 64bits
        return Pannel.fillconfig(register_ui_class=Regx64Edit.create,
                          default_regs_values=x64Registers.get_default_object(),
                                 conf=conf if conf else None)
   else:

        return Pannel.fillconfig(register_ui_class=Regx86Edit.create,
                          default_regs_values=x64Registers.get_default_object(),
                                 conf=conf if conf else None)
  else:
      logger.console(LogType.ERRR,"Current architecture not yet supported")
      return None



def get_regedit_func():

    """ 
    !Return the right function to edit the register according the binary architecture
    @return The function pointer to edit registers.

    """
    procname = idaapi.get_idp_name()
    if procname == 'arm':
        if idc.__EA64__:
            return RegArm64Edit.create
        else:
            return RegArm32Edit.create

    elif procname == 'pc':
       if idc.__EA64__: # assess if ida is running in 64bits
            return Regx64Edit.create
       else:

            return Regx86Edit.create
    else:
        logger.console(LogType.ERRR,"Current architecture not yet supported")

def get_tag_name(tag_list:List[str])->str:

    """ 
    !Allow the user to choose a tag when using tag_func feature. 

    @param tag_list: List of available tags.

    @return User selected tag.
    """
    


    ea = idc.get_screen_ea()
    i = ida_ua.insn_t()
    ida_ua.decode_insn(i,ea)
    if ida_idp.is_call_insn(i):
        idx = TagForm.create(tag_list)
        return tag_list[idx]
    else:
        logger.console(LogType.ERRR,'Selected address does not represent a function')
        logger.console(LogType.ERRR,'Please use a CALL insn to tag a function')




def loadconfig() :

    """ 
    !Load config from user select file.

    @return The configuration deserialized. 

    """

    conf_path = EWS.ui.generic.FileSelector.fillconfig()
    if does_file_exist(conf_path):
        return  EWS.utils.configuration.loadconfig(conf_path)

    else:
        raise Exception("Config loading error")

def saveconfig(config):

    """
    !Dump the specified config object in a file.

    @param config: Configurtation obj.
    """

    conf_path = EWS.ui.generic.FileSelector.fillconfig()
    if does_file_exist(conf_path):
        if (not ida_kernwin.ask_yn(False,'%s already exists. Replace?'%conf_path)):
            return
    try:
        EWS.utils.configuration.saveconfig(config,conf_path) 
    except Exception as e:
        ida_kernwin.warning('Could not save config: %s'%str(e))



def patch_mem(emu:EWS.emu.emubase.Emulator):

    """ 
    !Patch memory 

    @param emu: Pointer to a emu.emubase instance.

    """

    ok,addr,bytesvalstr = MemEdit.fillconfig(emu)
    if ok:
        try:
            import binascii
            bytesval = binascii.a2b_hex(bytesvalstr)
            emu.patch_mem(int(addr,16),bytes(bytesval))
        except:
            ok=False
    return ok



def displaymem(emu:EWS.emu.emubase.Emulator,
               content:bytes,
               name:str,
               base_addr:int):

    """ 
    !Display content memory by opening MemDisplayer widget. 

    @param emu: Pointer to a emu.emubase instance.
    @param content: Bytes to display.
    @param name: Name of the section*. 
    @param base_addr: Effective Address of the first byte. 

    """

    values = []
    for i in range(0,len(content),16):
        values.append(['0x%x'%(base_addr+i),
                      space(binascii.b2a_hex(content[i:i+16]).decode('utf-8')),
                      asciify(content[i:i+16])])

    md = MemDisplayer("%s Memory"%name,
                      values,
                      emu)
    #view_to_dock_with = idaapi.get_widget_title(idaapi.get_current_viewer())
    md.show()
    #idaapi.set_dock_pos('%s Memory'%name,view_to_dock_with,idaapi.DP_RIGHT)



def display_section(emu:EWS.emu.emubase.Emulator):

    """ 
    !Display a specific memory section taken from the IDB. 

    @param emu: Pointer to a emu.emubase instance.

    """
    seg = SelectSegment.fillconfig()
    if seg == None:
        return False
    p_base = seg.start_ea & ~(emu.conf.p_size -1)
    seg_size = seg.end_ea - p_base
    d,r = divmod(seg_size,emu.conf.p_size)
    if r:
        logger.console(LogType.WARN,'Weird segment size to display, should be aligned')
        d+=1

    # todo: replace with emu.helper.mem_read
    content = emu.mem_read(p_base,d*emu.conf.p_size)
    displaymem(emu,
               content,
               ida_segment.get_segm_name(seg),
               p_base)

def display_exec_trace():
    """
    view_to_dock_with idaapi.get_widget_title(idaapi.get_current_viewer())
    # create dock object (exec_trace XXXX)
    Python>widt=idaapi.find_widget('exec_trace XXXX')
    #idview=idaapi.find_widget('IDA View-A')
    Python>idaapi.set_dock_pos('exec_trace XXXX',view_to_dock_with,idaapi.DP_RIGHT)
    True
    """
    pass


def display_addr(emu:EWS.emu.emubase.Emulator):

    try:
        addr,nbpages = AddrNBPages.fillconfig()
    except: 
        return 
    p_base = addr & ~ (emu.conf.p_size -1)
    try:
        # todo: replace with emu.helper.mem_read
        content = emu.mem_read(p_base,nbpages*emu.conf.p_size)
    except Exception as e:
        logger.console(LogType.ERRR,"Invalid parameters for addr displaying.")
        return
    displaymem(emu,
               content,
               "%x Memory"%p_base,
               p_base)


def get_add_mappings():

    """ 
    !Get a pointer to UI pannel AddMapping

    @return UI pannel ref.

    """

    return EWS.ui.generic.AddMapping.fillconfig()

def add_mapping(emu:EWS.emu.emubase.Emulator,
                addmap):

    """ 
    !Map a page and init its content 

    @param emu: Pointer to Emulator object.
    @param addmap: Additional Mapping items
    """

    for k,v in addmap.mappings.items():
        emu.add_mapping(k,v)


def display_stack(emu:EWS.emu.emubase.Emulator):
    """ 
    !Display the stack

    @param emu: Pointer to an emulator object.

    """

    content = emu.mem_read(emu.conf.stk_ba,
                           emu.conf.stk_size)
    displaymem(emu,
               content,
               "Stack",
               emu.conf.stk_ba)

def export_mem(emu:EWS.emu.emubase.Emulator):
    """ 
    !Dump memory to a file from user specified content

    @param emu: Pointer to Emulator object. 

    """

    try:
        (addr,size,f_path) = ExportMemory.fillconfig()
    except Exception as e:
        print(e)
        return
    try:
        with open(f_path,'wb+') as fout:
            fout.write(emu.mem_read(addr,size))
        logger.console(LogType.INFO,'[+] exported %x (size: %d) to file %s '%(addr,size,f_path))
    except UcError:
        logger.console(LogType.ERRR,"Error accessing memory for range [%x : %x]"%(addr,
                                                                                  addr+size))
    except Exception as e:
        logger.console(LogType.ERRR,"Error opening file: %s"%str(e))


def import_mem(emu:EWS.emu.emubase.Emulator):

    """ 
    !Import memory from a file

    @param emu: Emulator pointer.
    """
    try: 
        (addr,f_path) = ImportMemory.fillconfig()
    except:
        ida_kernwin.warning("Could not import invalid params")
        return 
    content_b = None
    if not does_file_exist(f_path) : 
        logger.console(LogType.ERRR,"Could not import: file %s not found"%f_path)
        return
    try:
        with open(f_path,'rb') as fin:
            content_b = fin.read()
    except:
        logger.console(LogType.ERRR,"Could not import %s: check permissions ?"%f_path)
        return 
    try:
        emu.mem_read(addr,len(content_b))
    except:
        ida_kernwin.warning("Could not write file content into memory, are you sure the page is mapped ?")
        return
    try:
        emu.mem_write(addr,content_b)
    except:
        logger.console(LogType.ERRR,"Could not import %s: unproper permission?",f_path)
        return
    logger.console(LogType.INFO,"File %s imported into [%x %x]"%(f_path,addr,addr+len(content_b)))

    emu.conf.memory_init += AdditionnalMapping({addr:content_b})


def watchpoint(emu:EWS.emu.emubase.Emulator):

    """ 
    !Returns the watchpoint pannel

    @return pointer
    """
    return WatchPoint.fillconfig(emu)


def add_insn_patch(emu:EWS.emu.emubase.Emulator):

    """ 
    !Patch the insn 

    @param emu: Emulator Pointer 

    """
    addr = idc.get_screen_ea()
    #TODO add check to verify that addr is on a code area ? 
    try:
        asm = ida_kernwin.ask_str('Insn Patch',False,"Please enter the assembly to replace insn at %x"%addr)
        emu.patch_insn(addr,asm)
    except Exception as e:
        ida_kernwin.warning("Could not patch insn at %x.Reason: %s"%(addr,str(e)))

def is_arch_supported()->bool:
    """ 
    !Return either or not arch is supported by EWS. 
    
    @return The support 
    """

    return idaapi.get_idp_name() in ['pc', 'arm']


def is_code(ea:int) -> bool:
    """ 
    !Return True if the ea is flagged as code in IDB.

    @param ea: Effective Address of the supposed code.

    @return The answer.

    """
    return ida_bytes.is_code(ida_bytes.get_flags(ea))

def add_patch_file(engine:EWS.emu.emubase.Emulator):

    """ 
    !Load a json file containing records {"addr":"assembly text"}.

    @param engine: Pointer to a Emulator instance. 

    """

    f_path = EWS.ui.generic.FileSelector.fillconfig()

    if not does_file_exist(f_path):

        ida_kernwin.warning('File %s does not exist.'%f_path)
        return

    update_conf = ida_kernwin.ask_yn(False,"Do you want to update the conf?")

    with open(f_path, 'r') as fpatch:
        patches = json.load(fpatch)

    for addr,insn in dict(patches).items():
        addr = int(addr,16)
        engine.patch_insn(addr,insn)




```

`EWSPLugin.py`:

```py
#-----------------------------------
# EWS [ Emulation Wrapper System ]
#------------------------------------
import idaapi
import ida_kernwin
import idautils
import ida_idaapi
import ida_name
from EWS.utils import utils_ui 
from EWS.utils.configuration import *
from EWS.ui import *
from EWS.ui.debug_view import *
from EWS.utils.utils import *
from EWS.utils.utils import logger,LogType, plug_mode
from EWS.utils.consts_ida import *
from EWS.ui.generic import FileSelector
from EWS.utils.configuration import saveconfig
from unicorn import UcError


def mode_default(func):

    def check_mode(_s): 
        if _s.plug.mode == plug_mode.DEFAULT:
            return func(_s)
        ida_kernwin.warning("Feature not available in trace viewer mode.")
        return 

    return check_mode
      

class menu_action_handler_t(idaapi.action_handler_t):
    """
    Action handler for menu actions
    """

    def __init__(self, action,plug):
        idaapi.action_handler_t.__init__(self)
        self.action = action
        self.plug = plug

    def activate(self, ctx):
        if self.action == EMULLAUNCHER:
            self.emul_launcher()
        elif self.action == EMULF:
            self.emul_func()
        elif self.action == EMULSELECT:
            self.emul_selection()
        elif self.action == EMULINIT:
            self.emul_init()
        elif self.action == RESET:
            self.reset()
        elif self.action == EDITREG:
            self.edit_registers()
        elif self.action == TAGFUNC:
            self.tag_func()
        elif self.action == LOADCONF:
            self.loadconf()
        elif self.action == EDITCONF:
            self.editconf()
        elif self.action == SAVECONF:
            self.saveconf()
        elif self.action == PATCHFILE:
            self.patch_file()
        elif self.action == PATCHMEM:
            self.patchmem()
        elif self.action == DISPLAYMEM:
            self.displaymem()
        elif self.action == DISPLAYSTK:
            self.displaystack()
        elif self.action == DISPLAYADDR:
            self.displayaddr()
        elif self.action == IMPORTMEM: 
            self.mem_import()
        elif self.action == EXPORTMEM:
            self.mem_export()
        elif self.action == STEPIN:
            self.stepin()
        elif self.action == STEPOVER:
            self.stepover()
        elif self.action == CONTINUE:
            self.continuee()
        elif self.action == ADDMAPPNG:
            self.add_mapping()
        elif self.action == WATCHPOINT:
            self.watchpoint()
        elif self.action == NSTUB:
            self.add_nstub()
        elif self.action == PATCH:
            self.patch_insn()
        elif self.action == LOADTRACE:
            self.load_trace()
        else:
            logger.console(LogType.ERRR,"Function not yet implemented")
            return 0
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


    def reset(self):

        if self.plug.emulator_initialized :
            self.plug.emu.flush() ##FIXME is that necessary?
            self.plug.emu.reset_color_graph()
            self.plug.reset()
        elif self.plug.config_initialized:
            self.plug.config = None
            self.plug.config_initialized = False
           
        if self.plug.view_enabled:
            self.plug.reset_view()

        self.plug.mode = plug_mode.DEFAULT

        logger.console(LogType.INFO,"Plugin was properly reset")

    @mode_default
    def emul_func(self):

        """
        ! Emulate current function 

        """ 


        if self.plug.config_initialized:

            ida_kernwin.warning("Configuration Object already exist, please reset the plugin before using this function.")
            return 

        s_ea, e_ea = utils_ui.get_func_boundaries()
        self.plug.conf = utils_ui.get_conf_for_area(s_ea,e_ea) 

        logger.console(LogType.INFO, "Configuration generated for area [0x%x 0x%x] "%
                       (self.plug.conf.exec_saddr,self.plug.conf.exec_eaddr))

        self.plug.config_initialized = True

    @mode_default
    def emul_selection(self):

        """
        ! Emulate the current selected assembly in UI_Hooks

        """


        if self.plug.config_initialized:

            ida_kernwin.warning("Configuration Object already exist, please reset the plugin before using this function.")
            return 


        s_ea, e_ea = utils_ui.get_user_select()
        self.plug.conf = utils_ui.get_conf_for_area(s_ea,e_ea)
        logger.console(LogType.INFO, "Configuration generated for area [0x%x 0x%x] "%
                       (s_ea,e_ea))

        self.plug.config_initialized = True

    @mode_default
    def emul_init(self):


        """ 
        ! Initialise the emulator and the debug views. 

        """



        if not self.plug.config_initialized:
            logger.console(LogType.WARN,"Please init a configuration")
            return

        if self.plug.emulator_initialized: 
            ida_kernwin.warning('Emulator is already initialized. Please reset to load a new configuration')
            return

        try:
            self.plug.emu = utils_ui.get_emul_from_conf(self.plug.conf)
        except Exception as e:
           logger.console(LogType.ERRR,"An error occured while initializing the emulator",
                           "\nReason is : %s"%str(e))
           return

        self.plug.emulator_initialized = True

        if not self.plug.view_intialized:
            self.plug.init_view()
        if not self.plug.view_enabled:
            self.plug.enable_view()

        logger.console(LogType.INFO,"Emulator ready to run (Alt+Shift+{C,I})")
    
    @mode_default
    def emul_launcher(self):


        """ 
        ! Create a configuration from scratch.

        """

        if self.plug.config_initialized == True:
            ida_kernwin.warning("A configuration object is already instancied.\n\
                                Please use edit feature to edit the current config")
            return

        if self.plug.emulator_initialized  == True:
            ida_kernwin.warning("Emulator is already initialized.\n\
                                Please reset the emulator before using this feature")
            return

        try:
            self.plug.conf = utils_ui.get_emul_conf()
            self.config_initialized = True
        except:
            logger.console(LogType.ERRR,"Error occured while creating configuration object")

    @mode_default
    def edit_registers(self):

        """ 
        ! Edit registers. 
        
        """

        if not self.plug.config_initialized:
            logger.console(LogType.WARN,"Please init the configuration before using this function")
            return


        regedit_func  = utils_ui.get_regedit_func()

        if not self.plug.emulator_initialized:
            new_regs = regedit_func(self.plug.conf.registers)
            self.plug.conf.registers = new_regs
        else:
            new_regs = regedit_func(self.plug.emu.get_regs())
            if not new_regs is None:  
                self.plug.emu.setup_regs(new_regs)

    @mode_default
    def tag_func(self):

        """
        !Tag a function when cursor is on call type insn (call/br 0x...) 

        """

        if not self.plug.emulator_initialized:
            logger.console(LogType.ERRR,
                           "Please initiate an self.plug.emulator before using this function (Alt+Ctrl+I)")
            return

        tag_list = [ k for k in self.plug.emu.stubs.keys() ]
        tag_name = utils_ui.get_tag_name(tag_list)
        if tag_name == None:
            logger.console(LogType.ERRR,'Invalid tag name')
        # get the target of the call insn
        # somehow, it does not work using insn.Op1 
        try:
            ea=next(idautils.CodeRefsFrom(idc.get_screen_ea(),False))
        except StopIteration:
            logger.console(LogType.ERRR,
                           'Could not find valid function to tag')
            return

        if ea != None  and ea != idaapi.BADADDR:
            self.plug.emu.tag_func(ea,tag_name)
            logger.console(LogType.INFO,
                           'Function at %x now tagger with %s'%(ea,tag_name))

    @mode_default
    def loadconf(self):

        """ 
        ! Load configuration from file. 

        """ 

        if self.plug.emulator_initialized or self.plug.config_initialized:
            ida_kernwin.warning("Please reset plugin to load new configuration")
            return

        try: 
            self.plug.conf = utils_ui.loadconfig()
        except:
             ida_kernwin.warning('Config file does not exist')
             return 


        self.plug.config_initialized = True

        ida_kernwin.info("Config file has been loaded")

    @mode_default
    def saveconf(self):
        
        """
        ! saveconf 


        """

        if not self.plug.config_initialized:

            ida_kernwin.warning('No configuration object available')
            return

        if self.plug.emulator_initialized:

            conf_path =FileSelector.fillconfig()
            config = self.plug.emu.extract_current_configuration()


            saveconfig(config,conf_path) 

                    
        else:

            utils_ui.saveconfig(self.plug.conf)

    @mode_default
    def editconf(self):


        """ 
        !editconf 

        
        """
        
        if self.plug.emulator_initialized:
            ida_kernwin.warning("Configuration cannot be edited when emulator is initalized"
                                +"Advise: store current config (if necessary) and reset the plugin.")

            uret = ida_kernwin.ask_yn(False,"Emulator being already instancied,"
            +"editing configuration will extract current emulator state in a new"
            +"configuration object and allow you to edit it. Is that what you want")
            
            if uret == ida_kernwin.ASKBTN_YES: 
                conf = self.plug.emu.extract_current_configuration() 
            else:
                return
            
        elif not self.plug.config_initialized:
            ida_kernwin.warning("Please create/load a configuration before using this function")
            return

        try:
            new_conf = utils_ui.get_emul_conf(simplified=False,
                                         conf=self.plug.conf)
            self.plug.conf = new_conf
        except Exception as e:
            ida_kernwin("Something wrong happened while loading the config, please reset the plug and retry")
            

    @mode_default 
    def patchmem(self):

        """ 
        ! Patch memory

        """
        
        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Please init the emulator before using this function")

        if not utils_ui.patch_mem(self.plug.emu):
            pass

    @mode_default
    def displaymem(self):
        
        """ 
        ! Display memory 
        """

        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Nothing to display, init the emulator before using this function.")
            return

        utils_ui.display_section(self.plug.emu)

    @mode_default
    def displaystack(self):

        """ 
        !Display the stack

        """
        
        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Nothing to display, init the emulator before using this function.")
            return


        utils_ui.display_stack(self.plug.emu)


    @mode_default
    def displayaddr(self):

        """
        ! Display a specific address.

        """

        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Nothing to display, init the emulator before using this function.")
            return
        
        utils_ui.display_addr(self.plug.emu) 

    @mode_default
    def mem_import(self):

        """ 
        ! Import memory to emulator
        """
        

        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Init an emulator before using this function")
            return

        utils_ui.import_mem(self.plug.emu)

        
    @mode_default
    def mem_export(self):
        

        """ 
        ! Dump emulator memory in a file. 
        """

        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Init an emulator before using this function")
            return

        utils_ui.export_mem(self.plug.emu)


    @mode_default
    def stepin(self):

        """
        ! Step in function
        """
        
        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Please initiate an self.plug.emulator before using this function")
            return
        try:
            self.plug.emu.step_in()
        except UcError as e:
            ida_kernwin.warning('An error occured during the step. Reason: %s'%str(e))
        finally:
            self.plug.refresh_view()

        
    @mode_default
    def stepover(self):
        
        """ 
        ! Step over function
        """
        
        if not self.plug.emulator_initialized: 
            logger.console(LogType.ERRR,
                           "Please initiate an self.plug.emulator before using this function (Alt+Ctrl+I)")
            return

        if self.plug.emu.is_running:
            self.plug.emu.step_over()
            self.refresh_view()

    @mode_default 
    def continuee(self):

        """ 
        ! Run / Continue
        """
        if not self.plug.config_initialized: 
            ida_kernwin.warning("A configuration is required to use this command")
        
        if not self.plug.emulator_initialized: 
            self.plug.emu = utils_ui.get_emul_from_conf(self.plug.conf)
            self.plug.emulator_initialized = True

        if not self.plug.view_intialized:
            self.plug.init_view()
        if not self.plug.view_enabled:
            self.plug.enable_view()

        if self.plug.emu.is_running:

            logger.console(LogType.INFO,"Exec continues")
            try:
                self.plug.emu.continuee()
            except Exception as e:
                logger.console(LogType.ERRR,"Execution run out of control.",
                               "Reason: %s"%e.__str__())
            finally:
                self.plug.refresh_view()
        else:
            logger.console(LogType.INFO,"Exec starts")
            try:
                self.plug.emu.start()
            except Exception as e:
                logger.console(LogType.ERRR,"Execution run out of control.",
                               "Reason: %s"%e.__str__())
            finally:
                self.plug.refresh_view()


    @mode_default
    def add_mapping(self):

        """ 
        ! Add a mapping and optionally init memory

        """
        

        if not self.plug.emulator_initialized: 

            ida_kernwin.warning("Require the emulator to be init")
            return 

        new_mappings = utils_ui.get_add_mappings()
        self.plug.conf.amap_conf+= new_mappings

        if self.plug.emu != idaapi.BADADDR:

            idaapi.show_wait_box("Adding mapping, could take time")
            utils_ui.add_mapping(self.plug.emu,new_mappings)
            idaapi.hide_wait_box()

    @mode_default
    def watchpoint(self):

        """
        ! Add read/write watchpoint.
        
        """
        
        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Could not set breakpoint. Require the emulator to be init")
            return


        utils_ui.watchpoint(self.plug.emu)

    @mode_default
    def add_nstub(self):

        """ 
        ! Add a null stub.

        """

        if not self.plug.emulator_initialized: 
            ida_kernwin.warning("Stubing require emulator init")
            return

        if not self.plug.emu.conf.s_conf.activate_stub_mechanism:
            ida_kernwin.warning("Current config does not allow stubbing.")
            return

        cur_ea = ida_kernwin.get_screen_ea()
        if (ida_kernwin.ask_yn(False,"Null-stub function %x"%cur_ea)):
            self.plug.emu.add_null_stub(cur_ea)
        logger.console(LogType.INFO,"Null stub added to function %s"%ida_name.get_name(cur_ea),
                       "at addr %x"%cur_ea)

    @mode_default
    def patch_insn(self):

        """ 
        ! Patch instructions 

        """

        if not self.plug.emulator_initialized:
            ida_kernwin.warning('Please init the emulator before using this function')
            return

        utils_ui.add_insn_patch(self.plug.emu)

    @mode_default
    def patch_file(self):

        """ 
        ! Patch file

        """

        if not self.plug.emulator_initialized:
            ida_kernwin.warning('Please init the emulator before using this function')
            return

        utils_ui.add_patch_file(self.plug.emu)

    def load_trace(self):

        make_idb_backup()

        if self.plug.emulator_initialized or self.plug.config_initialized:
            ida_kernwin.warning("Please reset the plugin before using this feature.")
            return 


        #f_trace = ida_kernwin.ask_file(False,"/tmp","Trace File")
        f_trace="/tmp/EWS_trace.txt"

        with open(f_trace, 'r') as fin:

            exec_trace = json.loads(fin.read(),cls=Exec_Trace_Deserializer)

        #f_ct = ida_kernwin.ask_file(False,"/tmp","Call Tree")
        f_ct = "/tmp/EWS_calltree.txt"

        with open(f_ct, 'r') as fin:

            call_tree = json.loads(fin.read(),cls=Call_Tree_Deserializer)



        self.plug.conf = utils_ui.get_conf_for_area(exec_trace.content[0]['addr'],
                                                    exec_trace.content[exec_trace.count-1]['addr'])

        self.plug.emu = utils_ui.get_emul_from_conf(self.plug.conf)

        self.plug.emu.exec_trace = exec_trace
        self.plug.emu.call_tree = call_tree



        if not self.plug.view_intialized:
            self.plug.init_view()
        if not self.plug.view_enabled:
            self.plug.enable_view()

        self.plug.mode = plug_mode.TRACEVIEWER



  
    

               


class EWS_Plugin(idaapi.plugin_t, idaapi.UI_Hooks):

    """
    Load EWS Plugin

    """
    comment="Emulator Wrapper System"
    help="Emulate code using your favorite emulator"
    wanted_name="EWS"
    wanted_hotkey="Ctrl-Alt+E"
    flags= idaapi.PLUGIN_KEEP



    def __init__(self):

        self.emu=idaapi.BADADDR
        self.conf=idaapi.BADADDR
        self.debug_panel_regs = idaapi.BADADDR
        self.trace_panel = idaapi.BADADDR
        self.ct_panel = idaapi.BADADDR
        self.emulator_initialized = False
        self.config_initialized = False
        self.view_intialized = False
        self.view_enabled = False
        self.mode = plug_mode.DEFAULT 

        idaapi.UI_Hooks.__init__(self)


        self.menu_actions = [

            idaapi.action_desc_t(EMULLAUNCHER, "Configure Emulation",
                                 menu_action_handler_t(EMULLAUNCHER,self), 'Alt+Ctrl+L',
                                 "S", 8),
            idaapi.action_desc_t(LOADCONF, "Load Config",
                                 menu_action_handler_t(LOADCONF,self), 'Alt+Shift+L',
                                 "T", 12),
            idaapi.action_desc_t(EDITCONF, "Edit Config",
                                 menu_action_handler_t(EDITCONF,self), 'Alt+Ctrl+C',
                                 "T", 12),
            idaapi.action_desc_t(SAVECONF, "Save Config",
                                 menu_action_handler_t(SAVECONF,self), 'Alt+Shift+D',
                                 "T", 12),
            idaapi.action_desc_t(EMULF, "Emulate Function",
                                 menu_action_handler_t(EMULF,self), 'Alt+Ctrl+F',
                                 "S", 9),
            idaapi.action_desc_t(EMULSELECT, "Emulate Selection",
                                 menu_action_handler_t(EMULSELECT,self), 'Alt+Ctrl+S',
                                 "T", 10),
            ##########################################################################
            idaapi.action_desc_t(EMULINIT, "Init Emulator",
                                 menu_action_handler_t(EMULINIT,self), 'Alt+Ctrl+I',
                                 "T", 10),
            idaapi.action_desc_t(RESET, "Reset",
                                 menu_action_handler_t(RESET,self), 'Alt+Shift+R',
                                 "T", 10),
            ##########################################################################
            idaapi.action_desc_t(EDITREG, "Edit registers",
                                 menu_action_handler_t(EDITREG,self), 'Alt+Ctrl+R',
                                 "T", 11),
            idaapi.action_desc_t(NSTUB, "Null Stub function",
                                 menu_action_handler_t(NSTUB,self), 'Alt+Shift+N',
                                 "T", 12),
            idaapi.action_desc_t(TAGFUNC, "Tag function",
                                 menu_action_handler_t(TAGFUNC,self), 'Alt+Shift+T',
                                 "T", 12),
            idaapi.action_desc_t(PATCHMEM, "Patch Mem",
                                 menu_action_handler_t(PATCHMEM,self), 'Alt+Ctrl+M',
                                 "T", 12),
            idaapi.action_desc_t(PATCHFILE, "Add Patch File",
                                 menu_action_handler_t(PATCHFILE,self), '',
                                 "T", 12),
            idaapi.action_desc_t(DISPLAYMEM, "Display Segment",
                                 menu_action_handler_t(DISPLAYMEM,self), 'Alt+Ctrl+D',
                                 "T", 12),
            idaapi.action_desc_t(DISPLAYSTK, "Display Stack",
                                 menu_action_handler_t(DISPLAYSTK,self), 'Alt+Shift+S',
                                 "T", 12),
            idaapi.action_desc_t(DISPLAYADDR, "Display Addr",
                                 menu_action_handler_t(DISPLAYADDR,self), 'Alt+Shift+M',
                                 "T", 12),
            idaapi.action_desc_t(IMPORTMEM, "Import Memory From File",
                                 menu_action_handler_t(IMPORTMEM,self), 'Ctrl+Shift+I',
                                 "T", 12),
            idaapi.action_desc_t(EXPORTMEM, "Export Memory To File",
                                 menu_action_handler_t(EXPORTMEM,self), 'Ctrl+Shift+E',
                                 "T", 12),
            idaapi.action_desc_t(STEPIN, "Start / Step IN",
                                 menu_action_handler_t(STEPIN,self), 'Alt+Shift+I',
                                 "T", 12),
            idaapi.action_desc_t(STEPOVER, "Step OVER",
                                 menu_action_handler_t(STEPOVER,self), 'Alt+Shift+O',
                                 "T", 12),
            idaapi.action_desc_t(CONTINUE, "Run/Continue",
                                 menu_action_handler_t(CONTINUE,self), 'Alt+Shift+C',
                                 "T", 12),
            idaapi.action_desc_t(ADDMAPPNG, "Add Mapping",
                                 menu_action_handler_t(ADDMAPPNG,self), 'Alt+Ctrl+A',
                                 "T", 12),
            idaapi.action_desc_t(WATCHPOINT, "Watchpoint",
                                 menu_action_handler_t(WATCHPOINT,self), 'Alt+Ctrl+W',
                                 "T", 12),
            idaapi.action_desc_t(PATCH, "Patch Instruction",
                                 menu_action_handler_t(PATCH,self), 'Alt+Ctrl+P',
                                 "T", 12),
            idaapi.action_desc_t(LOADTRACE, "Load Trace",
                                 menu_action_handler_t(LOADTRACE,self), 'Alt+Ctrl+9',
                                 "T", 12)
            ]

    def init(self):
        if not utils_ui.is_arch_supported():
            return idaapi.PLUGIN_SKIP

        for action in self.menu_actions:
            idaapi.register_action(action)

        ida_kernwin.UI_Hooks.hook(self)

        return ida_idaapi.PLUGIN_OK

    def run(self,arg):
        logger.console(LogType.INFO,'[+] EWS Plugin Launched')

    def term(self):
        """
        TODO
        here should be removed all plugin artefacts (color, ...)
        """
        ida_kernwin.UI_Hooks.unhook(self)
        
    def finish_populating_widget_popup(self, form, popup):

        form_type = idaapi.get_widget_type(form)
        if form_type == idaapi.BWN_DISASM or form_type == idaapi.BWN_DUMP:

                # Configuration & Launch
                idaapi.attach_action_to_popup(form, popup, EMULLAUNCHER,'%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, EMULF, '%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, EMULSELECT, '%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, EMULINIT, '%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, RESET, '%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, EXPORTMEM, '%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, IMPORTMEM, '%s/init/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, ADDMAPPNG, '%s/init/'%PLUGNAME)

                # Configuration 
                idaapi.attach_action_to_popup(form, popup, LOADCONF, '%s/config/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, EDITCONF, '%s/config/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, SAVECONF, '%s/config/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, LOADTRACE, '%s/config/'%PLUGNAME)



                # Debugging 
                idaapi.attach_action_to_popup(form, popup, CONTINUE, '%s/debug/'%PLUGNAME)
#                idaapi.attach_action_to_popup(form, popup, RESTART, '%s/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, STEPIN, '%s/debug/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, STEPOVER, '%s/debug/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, WATCHPOINT, '%s/debug/'%PLUGNAME)

                # Memory 
                idaapi.attach_action_to_popup(form, popup, EDITREG, '%s/memory/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, PATCHMEM, '%s/memory/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, PATCH, '%s/memory/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, DISPLAYMEM, '%s/memory/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, DISPLAYSTK, '%s/memory/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, DISPLAYADDR, '%s/memory/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, PATCHFILE, '%s/memory/'%PLUGNAME)

                # Stubs
                idaapi.attach_action_to_popup(form, popup, EDITSTUBCONF, '%s/stubs/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, NSTUB, '%s/stubs/'%PLUGNAME)
                idaapi.attach_action_to_popup(form, popup, TAGFUNC, '%s/stubs/'%PLUGNAME)


    def init_view(self):

        self.debug_panel_regs = Debug_View_Registers("Registers",
                                                     self.emu,
                                                     width=50,
                                                     height=50)
        self.trace_panel = Debug_View_Trace("Trace",
                                            self.emu,
                                            self.debug_panel_regs, 
                                                     width=50,
                                                     height=50)
        self.ct_panel= CallTree_View("Call Tree",
                                            self.emu,
                                            self.debug_panel_regs, 
                                                     width=50,
                                                     height=50)


        self.view_intialized = True

    def enable_view(self):

        if not self.view_intialized:
            return

        view_to_dock_with = idaapi.get_widget_title(idaapi.get_current_viewer())
        self.debug_panel_regs.show()
        idaapi.set_dock_pos('Registers',view_to_dock_with,idaapi.DP_RIGHT)
        self.trace_panel.show()
        idaapi.set_dock_pos('Trace','Registers',idaapi.DP_BOTTOM)
        self.ct_panel.show()
        idaapi.set_dock_pos('Call Tree','Trace',idaapi.DP_RIGHT)

        self.view_enabled = True

    def refresh_view(self):
        self.debug_panel_regs.refresh()
        self.trace_panel.refresh()
        self.ct_panel.refresh()

    def reset_view(self):

        ida_kernwin.close_widget(idaapi.find_widget('Registers'),0)
        ida_kernwin.close_widget(idaapi.find_widget('Trace'),0)
        ida_kernwin.close_widget(idaapi.find_widget('Call Tree'),0)
        self.trace_panel.Close()
        self.trace_panel.flush() # FIXME is that necessary IDTS
        self.debug_panel_regs = None
        self.trace_panel = None
        self.view_intialized = False
        self.view_enabled = False


    def reset(self):
        self.emu = None
        self.conf = None
        self.emulator_initialized = False
        self.config_initialized = False

def PLUGIN_ENTRY():
    return EWS_Plugin()


```

`README.md`:

```md


<p align="center" >
     <br><br>
<img width="60%" src="EWS/doc/img/Logo_EWS.png"/> <br>
 </p>
 
 # About
 
EWS (*Emulator Wrapper Solution*)  is a IDA PRO plugin that aims to integrate emulation features (such as debugger) 
from various emulators (currently unicorn, but you can add more). 

Writting such plugin was motivated by reversing on x64 machine various embedded binaries from Android native libs to
automotive firmwares. "Click ready" trace generator and basic explorer is a gain of time.  

Key features are: 

1. Support Raw and ELF file. PE is experimental, no support for Mach-O. 
2. Automatically loads binary inside the emulator based on IDB information.  
3. Debugger view with registers' values for each executed instruction. 
4. Debugger capacities such as watchpoints, run / steps the code. 
5. Stub mechanism to emulate imported functions. 

# Getting Started

- [Demonstration](#demo)
- [Features](#features)
- [Installation](#installation)
- [Shortcuts](#shortcuts)
- [Documentation](EWS/doc/features.md) 
- [Extend-me](#extendme) 
- [Contact](#contact)

# Demo  

https://user-images.githubusercontent.com/6783156/212289883-31b8a3b5-0c7d-451d-9569-d661a64a5f25.mp4


# Features

## Debug

This example shows how to recover original strings from encrypted payload using emulator. 

https://user-images.githubusercontent.com/6783156/212301420-5dc397ca-dc65-4408-ad77-82e035386622.mp4

This example demonstrates watchpoint feature. The feature is also available when data is manipulated inside 
a stub.

https://user-images.githubusercontent.com/6783156/212301575-b6e1c417-75cf-4fc7-a825-078fad76ecb0.mp4

IDA Pro breakpoint marker is directly integrated in the plugin.

https://user-images.githubusercontent.com/6783156/212301728-fc99f02a-eef8-40e8-a1dd-4c0601519f60.mp4

Memory can be imported and exported. In this example memory range corresponding to the string is exported. 

https://user-images.githubusercontent.com/6783156/212303397-af887b75-6555-489c-aca0-b502b2644974.mp4

## Stubs Mechanisms   

Some functions from the libc are directly emulated by the stub mechanisms. Stub can be added by using decorator `@LibcStub` 
in files `stubs/ELF/ELF.py`.

https://user-images.githubusercontent.com/6783156/212301041-0a86ba45-4e25-4389-8d49-f190f6a8c4a7.mp4

This example shows how to attribute a tag to a function. `strlen` is applied to the example function. 

https://user-images.githubusercontent.com/6783156/212301210-c9a8b7df-7ebd-4fce-aced-4b7cfced0744.mp4


## Configuration 

Configuration can be edited, stored, loaded. This allows to share with other reversers findings. 

https://user-images.githubusercontent.com/6783156/212310072-520313d1-667a-401b-b26b-cff97838512e.mp4

## More

You can find an exhaustive list of features. 
[Features](EWS/doc/features.md) 


# Shortcuts 

1. Load Context Menu `Ctrl+Alt+E`
2. Reset Plugin `Alt+Shift+R`
3. Generate Configuration from Selection `Ctrl+Alt+S`
4. Generate Configuration for current Function `Ctrl+Alt+F`
5. Edit Configuration `Ctrl+Alt+C`
6. Load Configuration `Shift+Alt+L`
7. Store Configuration `Shift+Alt+D`
8. Run / Continue `Alt+Shift+C`
9. Step-In `Alt+Shift+I`
10. Step-Over `Alt+Shift+O`

# Installation 

## Dependencies

Please install manually the following python packages: 

- hexdump   
- dateutil 
- lief

Please install the following python bindings: 

- unicorn engine (install python bindings `bindings/python/setup.py install`)
- capstone engine (install python bindings `bindings/python/setup.py install`)
- keystone engine (install python bindings `bindings/python/setup.py install`)

If you are lazy, you can directly install them: 

```sh 
pip install -r doc/install/requirements.txt
```

## IDA Plugin

Copy folder `EWS` and `EWSPLugin.py` in your `$IDA_HOME/plugin` (generally corresponding to `$HOME/.idapro`).

## Smoke test

In the default graph view, execute the key combination `CTRL+ALT+E` to get the `ews` menu when you trigger
rigth click. 
You should be ready to go. 
Otherwise, check the console, something mysterious might have happened...


# WIP 

**Code is currently in refactoring, please stay tuned for a stable release**. 

Code refactoring is okay for: 

- x86
- arm32
- aarch64

x64 has not be refactored neither tested, so use it at your own risk.


# Submit an Issue (bug) 

Before submitting an issue, keep in mind that: 

- I'm not actively working on the project, depending the bug you could be faster than me to find the solution :]
- I need to reproduce the bug, so be kind an provide a configuration file and the binary that you was working on when finding out the bug (if possible). Otherwise, it will be a nightmare. 

# Extend Me

- **Offline trace explorer**: Allow to load trace generated outside the plugin. Support is currently planned. 
- ![Avatar2](https://github.com/avatartwo/avatar2): Integrate new emulator Qemu wrapper would help in supporting new architecture.  
- Integrate offline ghidra debugger when it will be available to extend supported architectures.

# Contact 

![@deadeert](https://twitter.com/DeadEert)

```