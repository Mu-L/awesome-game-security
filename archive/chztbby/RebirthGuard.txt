Project Path: arc_chztbby_RebirthGuard_9hfhwkh_

Source Tree:

```txt
arc_chztbby_RebirthGuard_9hfhwkh_
├── LICENSE
├── RebirthGuard
│   ├── RebirthGuard
│   │   ├── RGString.h
│   │   ├── RebirthGuard.cpp
│   │   ├── RebirthGuard.h
│   │   ├── RebirthGuard.vcxproj
│   │   ├── RebirthGuard.vcxproj.filters
│   │   ├── RebirthGuard.vcxproj.user
│   │   ├── RebirthGuardSDK.h
│   │   ├── callback.cpp
│   │   ├── crypto.cpp
│   │   ├── log.cpp
│   │   ├── mapping.cpp
│   │   ├── ntstruct.h
│   │   ├── options.h
│   │   ├── string.cpp
│   │   ├── util.cpp
│   │   └── verifying.cpp
│   ├── RebirthGuard.sln
│   ├── SampleDLL
│   │   ├── SampleDLL.vcxproj
│   │   ├── SampleDLL.vcxproj.filters
│   │   ├── SampleDLL.vcxproj.user
│   │   └── main.cpp
│   └── SampleEXE
│       ├── SampleEXE.vcxproj
│       ├── SampleEXE.vcxproj.filters
│       ├── SampleEXE.vcxproj.user
│       └── main.cpp
└── readme.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 chztbby (psh9331@naver.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`RebirthGuard/RebirthGuard.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30320.27
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RebirthGuard", "RebirthGuard\RebirthGuard.vcxproj", "{4D594C03-40A6-4F9E-86B3-8AAAC329F33A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SampleEXE", "SampleEXE\SampleEXE.vcxproj", "{36574BD3-F3EB-4359-97FF-3C80F2106257}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SampleDLL", "SampleDLL\SampleDLL.vcxproj", "{72588E16-75AB-485C-A5FF-A3162CECEF8C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4D594C03-40A6-4F9E-86B3-8AAAC329F33A}.Release|Win32.ActiveCfg = Release|Win32
		{4D594C03-40A6-4F9E-86B3-8AAAC329F33A}.Release|Win32.Build.0 = Release|Win32
		{4D594C03-40A6-4F9E-86B3-8AAAC329F33A}.Release|x64.ActiveCfg = Release|x64
		{4D594C03-40A6-4F9E-86B3-8AAAC329F33A}.Release|x64.Build.0 = Release|x64
		{36574BD3-F3EB-4359-97FF-3C80F2106257}.Release|Win32.ActiveCfg = Release|Win32
		{36574BD3-F3EB-4359-97FF-3C80F2106257}.Release|Win32.Build.0 = Release|Win32
		{36574BD3-F3EB-4359-97FF-3C80F2106257}.Release|x64.ActiveCfg = Release|x64
		{36574BD3-F3EB-4359-97FF-3C80F2106257}.Release|x64.Build.0 = Release|x64
		{72588E16-75AB-485C-A5FF-A3162CECEF8C}.Release|Win32.ActiveCfg = Release|Win32
		{72588E16-75AB-485C-A5FF-A3162CECEF8C}.Release|Win32.Build.0 = Release|Win32
		{72588E16-75AB-485C-A5FF-A3162CECEF8C}.Release|x64.ActiveCfg = Release|x64
		{72588E16-75AB-485C-A5FF-A3162CECEF8C}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5303A034-0AEB-4F9C-9DFD-8D1D0E14D78F}
	EndGlobalSection
EndGlobal

```

`RebirthGuard/RebirthGuard/RGString.h`:

```h

/*
    chztbby::RebirthGuard/RGString.h
*/

#ifndef RGSTRING_H
#define RGSTRING_H

#if __cplusplus >= 201703
#include <array>

template <typename T, SIZE_T N, SIZE_T K>
class RGString
{
private:
    std::array<T, N> str_;

    __forceinline constexpr T Xor(T c) const
    {
        return (T)(c ^ K);
    }

public:
    template <SIZE_T... IS>
    __forceinline constexpr RGString(const T* str, std::index_sequence<IS...>) : str_{ Xor(str[IS])... } {};

    template <SIZE_T... IS>
    __forceinline const T* Get(std::index_sequence<IS...>)
    {
        str_ = { Xor(str_[IS])... };

        return str_.data();
    }
};

#define MIS(s) (std::make_index_sequence<ARRAYSIZE(s)>())
#define RGS(s) ([]{ constexpr RGString<std::decay<decltype(*s)>::type, ARRAYSIZE(s), __LINE__> t(s, MIS(s)); return t; }().Get(MIS(s)))
#else
#define MIS(s) (s)
#define RGS(s) (s)
#endif

#endif
```

`RebirthGuard/RebirthGuard/RebirthGuard.cpp`:

```cpp

/*
	chztbby::RebirthGuard/RebirthGuard.cpp
*/

#include "RebirthGuard.h"


PRG_DATA rgdata;

VOID RG_Initialze(PVOID hmodule)
{
	if (IsRebirthed(hmodule))
		return;

	Rebirth(hmodule);
}

PRG_DATA RG_GetGlobalData()
{
	PRG_DATA rgdata = NULL;

	for (PVOID ptr = 0; ptr < (PVOID)MEMORY_END;)
	{
		MEMORY_BASIC_INFORMATION mbi;
		RG_QueryMemory(ptr, &mbi, sizeof(mbi), MemoryBasicInformation);

		if (mbi.Type == MEM_PRIVATE && mbi.Protect == PAGE_READWRITE && mbi.RegionSize == RG_DATA_SIZE)
		{
			PRG_DATA t = (PRG_DATA)ptr;
			if(t->magic[0] == RG_MAGIC_0 && t->magic[1] == RG_MAGIC_1 && t->magic[2] == RG_MAGIC_2)
			{
				rgdata = t;
				break;
			}
		}

		ptr = GetPtr(ptr, mbi.RegionSize);
    }

	if (!rgdata)
	{
		rgdata = (PRG_DATA)RG_AllocMemory(NULL, RG_DATA_SIZE, PAGE_READWRITE);
		rgdata->magic[0] = RG_MAGIC_0;
		rgdata->magic[1] = RG_MAGIC_1;
		rgdata->magic[2] = RG_MAGIC_2;
	}

	return rgdata;
}

VOID Rebirth(PVOID hmodule)
{
	rgdata = RG_GetGlobalData();

#if IS_ENABLED(RG_OPT_COMPAT_THEMIDA) || IS_ENABLED(RG_OPT_COMPAT_VMPROTECT)
	PIMAGE_NT_HEADERS nt = GetNtHeader(hmodule);
	PVOID mapped_module = RG_AllocMemory(NULL, nt->OptionalHeader.SizeOfImage, PAGE_EXECUTE_READWRITE);
	CopyPeData(mapped_module, hmodule, PE_TYPE_IMAGE);
#else
	PVOID mapped_module = ManualMap(hmodule);
	*(PRG_DATA*)GetPtr(mapped_module, GetOffset(hmodule, &rgdata)) = rgdata;
#endif
	auto pRebirthModule = decltype (&RebirthModule)GetPtr(mapped_module, GetOffset(hmodule, RebirthModule));
	pRebirthModule(hmodule, hmodule);
	RG_FreeMemory(mapped_module);

	RebirthModules(hmodule);

	RG_SetCallbacks();

	CheckMemory();

	CheckCRC();

#if IS_ENABLED(RG_OPT_SET_PROCESS_POLICY)
	if (IsExe(hmodule) && !CheckProcessPolicy())
		RestartProcess();
#endif
}

VOID RebirthModules(PVOID hmodule)
{
#ifdef _WIN64 // unstable in x86 yet.
#if IS_ENABLED(RG_OPT_REBIRTH_SYSTEM_MODULES)
	WCHAR system_modules[11][20];
	RG_wcscpy(system_modules[0], RGS(L"ntdll.dll"));
	RG_wcscpy(system_modules[1], RGS(L"kernel32.dll"));
	RG_wcscpy(system_modules[2], RGS(L"kernelbase.dll"));
	RG_wcscpy(system_modules[3], RGS(L"gdi32.dll"));
	RG_wcscpy(system_modules[4], RGS(L"win32u.dll"));
	RG_wcscpy(system_modules[5], RGS(L"gdi32full.dll"));
	RG_wcscpy(system_modules[6], RGS(L"user32.dll"));
	RG_wcscpy(system_modules[7], RGS(L"ws2_32.dll"));
	RG_wcscpy(system_modules[8], RGS(L"d3d9.dll"));
	RG_wcscpy(system_modules[9], RGS(L"d3d11.dll"));
	RG_wcscpy(system_modules[10], RGS(L"dxgi.dll"));

	for (LPCWSTR mod : system_modules)
	{
		if (!RG_GetModuleHandleW(mod))
			APICALL(LoadLibraryW)(mod);

		RebirthModule(hmodule, RG_GetModuleHandleW(mod));
	}
#endif

#if IS_ENABLED(RG_OPT_REBIRTH_ALL_MODULES)
	LDR_MODULE module_info = { 0, };
	while (RG_GetNextModule(&module_info))
	{
		if (!IsRebirthed(module_info.BaseAddress))
			RebirthModule(hmodule, module_info.BaseAddress);
	}
#endif
#endif
}

#if IS_ENABLED(RG_OPT_SET_PROCESS_POLICY)
BOOL CheckProcessPolicy()
{
	if (RG_PROCESS_POLICY & PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON)
	{
		PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY shcp;
		APICALL(GetProcessMitigationPolicy)(CURRENT_PROCESS, ProcessStrictHandleCheckPolicy, &shcp, sizeof(shcp));

		if (!shcp.Flags)
			return FALSE;
	}

	/*
		...
	*/

	return TRUE;
}

VOID RestartProcess()
{
	SIZE_T size = 0;
	APICALL(InitializeProcThreadAttributeList)(NULL, 1, 0, &size);

	LPPROC_THREAD_ATTRIBUTE_LIST attr = (LPPROC_THREAD_ATTRIBUTE_LIST)RG_AllocMemory(NULL, size, PAGE_READWRITE);
	APICALL(InitializeProcThreadAttributeList)(attr, 1, 0, &size);

	DWORD64 policy = RG_PROCESS_POLICY;
	APICALL(UpdateProcThreadAttribute)(attr, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &policy, sizeof(policy), NULL, NULL);

	PROCESS_INFORMATION pi;
	STARTUPINFOEX si = { sizeof(si) };
	si.StartupInfo.cb = sizeof(si);
	si.lpAttributeList = attr;
	APICALL(CreateProcessW)(NULL, APICALL(GetCommandLineW)(), NULL, NULL, NULL, EXTENDED_STARTUPINFO_PRESENT | CREATE_SUSPENDED, NULL, NULL, &si.StartupInfo, &pi);
	RG_FreeMemory(attr);

	HANDLE thread = RG_CreateThread(pi.hProcess, APICALL(Sleep), 0);
	APICALL(WaitForSingleObject)(thread, INFINITE);
	APICALL(NtResumeProcess)(pi.hProcess);

	APICALL(NtTerminateProcess)(CURRENT_PROCESS, 0);
}
#endif
```

`RebirthGuard/RebirthGuard/RebirthGuard.h`:

```h

/*
	chztbby::RebirthGuard/RebirthGuard.h
*/

#ifndef REBIRTHGUARD_H
#define REBIRTHGUARD_H

#include <windows.h>
#include <psapi.h>
#include <time.h>
#include <stdio.h>
#include "ntstruct.h"
#include "RGString.h"
#include "options.h"

#define RG_MAGIC_0 0x20170408
#define RG_MAGIC_1 0x12345678
#define RG_MAGIC_2 0x87654321
#define RG_DATA_SIZE 0x10000
#define MODULE_FIRST 0
#define MODULE_EXE 0
#define MODULE_NTDLL 1
#define MODULE_KERNEL32 2
#define MODULE_KERNELBASE 3
#define MODULE_LAST 3
#define PADDING(p, size) ((SIZE_T)((SIZE_T)(p) / (SIZE_T)(size) * (SIZE_T)(size) + ((SIZE_T)(p) % (SIZE_T)(size) ? (SIZE_T)(size) : 0)))
#define GetPtr(base, offset) ((PVOID)((SIZE_T)(base) + (SIZE_T)(offset)))
#define GetOffset(src, dst) ((SIZE_T)((SIZE_T)(dst) - (SIZE_T)(src)))
#define GetNtHeader(base) ((PIMAGE_NT_HEADERS)((SIZE_T)(base) + (SIZE_T)((PIMAGE_DOS_HEADER)(base))->e_lfanew))
#define TO_STRING(param) #param
#define APICALL(api_name) ((decltype(&api_name))RG_GetApi(RGS(TO_STRING(api_name))))
#define APICALL_FROM_MODULE(index, api_name) ((decltype(&api_name))RG_GetApi(RGS(TO_STRING(api_name)), index))
#define IS_ENABLED(OPTION) (OPTION & RG_ENABLE)
#define PAGE_SIZE 0x1000
#define ALLOCATION_GRANULARITY 0x10000
#define CURRENT_PROCESS ((HANDLE)-1)
#define CURRENT_THREAD ((HANDLE)-2)
#ifdef _WIN64
#define MEMORY_END 0x7FFFFFFF0000
#else
#define MEMORY_END 0x7FFF0000
#endif

typedef struct _REBIRTHED_MODULE_INFO
{
	PVOID module_base;
	HANDLE section;
} REBIRTHED_MODULE_INFO, *PREBIRTHED_MODULE_INFO;

typedef struct _RG_DATA
{
	SIZE_T magic[3];
	REBIRTHED_MODULE_INFO rmi[RG_DATA_SIZE - sizeof(SIZE_T)*3];
} RG_DATA, *PRG_DATA;

extern PRG_DATA rgdata;

typedef struct _MAP_INFO
{
	decltype(&NtMapViewOfSection) pNtMapViewOfSection;
	decltype(&NtLockVirtualMemory) pNtLockVirtualMemory;
	decltype(&NtQueryInformationProcess) pNtQueryInformationProcess;
	decltype(&RtlAcquirePrivilege) pRtlAcquirePrivilege;
	decltype(&NtSetInformationProcess) pNtSetInformationProcess;
	decltype(&RtlReleasePrivilege) pRtlReleasePrivilege;

	PVOID base;
	HANDLE hsection;
	PIMAGE_NT_HEADERS nt;

	SIZE_T chunk_offset;
	SIZE_T chunk_size;
	DWORD chunk_Characteristics;
} MAP_INFO, * PMAP_INFO;

enum RG_REPORT_CODE
{
	REPORT_UNKNOWN,
	REPORT_THREAD_START_ADDRESS,
	REPORT_THREAD_PROTECTION,
	REPORT_DLL_INJECTION_KERNEL32_LoadLibraryA,
	REPORT_DLL_INJECTION_KERNEL32_LoadLibraryW,
	REPORT_DLL_INJECTION_KERNEL32_LoadLibraryExA,
	REPORT_DLL_INJECTION_KERNEL32_LoadLibraryExW,
	REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryA,
	REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryW,
	REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryExA,
	REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryExW,
	REPORT_DLL_INJECTION_NTDLL_LdrLoadDll,
	REPORT_MEMORY_SUSPICIOUS,
	REPORT_MEMORY_UNLOCKED,
	REPORT_INTEGRITY_SECTION_CHECK,
	REPORT_INTEGRITY_CRC64_CHECK,
	REPORT_INVALID_APICALL,
	REPORT_DEBUG_HW_BREAKPOINT_0,
	REPORT_DEBUG_HW_BREAKPOINT_1,
	REPORT_DEBUG_HW_BREAKPOINT_2,
	REPORT_DEBUG_HW_BREAKPOINT_3,
	REPORT_DEBUG_SW_BREAKPOINT,
	REPORT_DEBUG_SINGLE_STEP,
	REPORT_DEBUG_PAGE_GUARD,
};

enum PE_TYPE
{
	PE_TYPE_FILE,
	PE_TYPE_IMAGE
};

enum THREAD_CHECK
{
	TC_TlsCallback,
	TC_ThreadCallback,
	TC_DllCallback
};

enum PTR_CHECK
{
	PC_EXECUTABLE,
	PC_IMAGE_SIZE
};

// RebirthGuard.cpp
VOID RG_Initialze(PVOID hmodule);
PRG_DATA RG_GetGlobalData();
VOID Rebirth(PVOID hmodule);
VOID RebirthModules(PVOID hmodule);
BOOL CheckProcessPolicy();
VOID RestartProcess();

// util.cpp
LPWSTR RG_GetModulePath(DWORD module_index);
LPCWSTR RG_GetModulePath(PVOID hmodule);
PVOID RG_GetNextModule(PLDR_MODULE pmodule_info);
VOID RG_HideModule(PVOID hmodule);
PVOID RG_GetApi(LPCSTR api_name, DWORD module_index = 0);
HMODULE RG_GetModuleHandleW(LPCWSTR module_path);
PVOID RG_GetProcAddress(HMODULE hmodule, LPCSTR proc_name);
HANDLE RG_CreateThread(HANDLE process, PVOID entry, PVOID param);
PVOID RG_AllocMemory(PVOID ptr, SIZE_T size, DWORD protect);
VOID RG_FreeMemory(PVOID ptr);
DWORD RG_ProtectMemory(PVOID ptr, SIZE_T size, DWORD protect);
NTSTATUS RG_QueryMemory(PVOID ptr, PVOID buffer, SIZE_T buffer_size, MEMORY_INFORMATION_CLASS type);
LONG WINAPI RG_ExceptionHandler(PEXCEPTION_POINTERS e);
VOID RG_SetCallbacks();
BOOL IsExe(PVOID hmodule);
PVOID GetCurrentThreadStartAddress();
VOID CopyPeData(PVOID dst, PVOID src, PE_TYPE src_type);

// log.cpp
VOID RG_DebugLog(LPCWSTR format, ...);
VOID RG_Report(DWORD flag, RG_REPORT_CODE code, PVOID data1, PVOID data2);

// mapping.cpp
VOID RebirthModule(PVOID hmodule, PVOID module_base);
PVOID LoadFile(PVOID module_base);
PVOID ManualMap(PVOID module_base);
VOID ExtendWorkingSet(PMAP_INFO info);
VOID AddRebirthedModule(PVOID module_base, HANDLE section);
VOID MapAllSections(PMAP_INFO info);
VOID MapChunk(PMAP_INFO info, SIZE_T offset, SIZE_T size, DWORD chr);
DWORD GetProtection(DWORD chr);
DWORD GetNoChange(DWORD chr);

// verifying.cpp
BOOL IsRebirthed(PVOID module_base);
PVOID GetModuleBaseFromPtr(PVOID ptr, PTR_CHECK type);
BOOL IsSameFunction(PVOID f1, PVOID f2);
VOID CheckThread(PVOID start_address, THREAD_CHECK type);
VOID CheckMemory();
VOID CheckCRC();

// callback.cpp
VOID WINAPI RG_TlsCallback(PVOID dllhandle, DWORD reason, PVOID reserved);
VOID WINAPI ThreadCallback(PTHREAD_START_ROUTINE proc, PVOID param);
VOID DebugCallback(PEXCEPTION_POINTERS e);
VOID CALLBACK DllCallback(ULONG notification_reason, PLDR_DLL_NOTIFICATION_DATA notification_data, PVOID context);

// crypto.cpp
DWORD64 CRC64(PVOID module_base);

// string.cpp
INT RG_strcmp(LPCSTR p1, LPCSTR p2);
LPSTR RG_strcat(LPSTR s1, LPCSTR s2);
LPCWSTR RG_wcsistr(LPCWSTR s1, LPCWSTR s2);
LPWSTR RG_wcscpy(LPWSTR s1, LPCWSTR s2);
LPWSTR RG_wcscat(LPWSTR s1, LPCWSTR s2);

#endif
```

`RebirthGuard/RebirthGuard/RebirthGuard.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="callback.cpp" />
    <ClCompile Include="crypto.cpp" />
    <ClCompile Include="util.cpp" />
    <ClCompile Include="log.cpp" />
    <ClCompile Include="RebirthGuard.cpp" />
    <ClCompile Include="mapping.cpp" />
    <ClCompile Include="verifying.cpp" />
    <ClCompile Include="string.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntstruct.h" />
    <ClInclude Include="RebirthGuard.h" />
    <ClInclude Include="options.h" />
    <ClInclude Include="RebirthGuardSDK.h" />
    <ClInclude Include="RGString.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{4D594C03-40A6-4F9E-86B3-8AAAC329F33A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>RebirthGuard</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)$(Platform)\$(Configuration)\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)$(Platform)\$(Configuration)\;$(LibraryPath)</LibraryPath>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <ErrorReporting>None</ErrorReporting>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalOptions>/Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <ErrorReporting>None</ErrorReporting>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalOptions>/Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`RebirthGuard/RebirthGuard/RebirthGuard.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="callback.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="crypto.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="verifying.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="string.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RebirthGuard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="options.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RebirthGuardSDK.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RebirthGuard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RGString.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntstruct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`RebirthGuard/RebirthGuard/RebirthGuard.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`RebirthGuard/RebirthGuard/RebirthGuardSDK.h`:

```h

/*
	chztbby::RebirthGuard/RebirthGuardSDK.h
*/

#ifndef REBIRTHGUARD_SDK_H
#define REBIRTHGUARD_SDK_H

#include <Windows.h>
#include "RGString.h"

#pragma comment(linker, "/ALIGN:0x10000")
#pragma check_stack(off)

VOID WINAPI RG_TlsCallback(PVOID, DWORD, PVOID);

#ifdef _WIN64
#pragma comment (linker, "/INCLUDE:_tls_used")
#pragma comment (linker, "/INCLUDE:_tls_callback")
#else
#pragma comment (linker, "/INCLUDE:__tls_used")
#pragma comment (linker, "/INCLUDE:__tls_callback")
#endif
EXTERN_C
#ifdef _WIN64
#pragma const_seg (".CRT$XLB")
const
#else
#pragma data_seg (".CRT$XLB")
#endif

PIMAGE_TLS_CALLBACK _tls_callback = RG_TlsCallback;
#pragma data_seg ()
#pragma const_seg ()

#endif
```

`RebirthGuard/RebirthGuard/callback.cpp`:

```cpp

/*
	chztbby::RebirthGuard/callback.cpp
*/

#include "RebirthGuard.h"


VOID WINAPI RG_TlsCallback(PVOID hmodule, DWORD reason, PVOID reserved)
{
	PVOID entry = GetCurrentThreadStartAddress();

#if IS_ENABLED(RG_OPT_THREAD_CHECK)
	CheckThread(entry, TC_TlsCallback);
#endif

	if (reason == DLL_PROCESS_ATTACH && entry != APICALL(Sleep))
		RG_Initialze(hmodule);

	if (reason == DLL_THREAD_DETACH && entry == APICALL(Sleep))
		RG_Initialze(hmodule);
}

VOID WINAPI ThreadCallback(PTHREAD_START_ROUTINE proc, PVOID param)
{
	CheckThread(proc, TC_ThreadCallback);

	APICALL(NtTerminateThread)(CURRENT_THREAD, proc(param));
}

VOID DebugCallback(PEXCEPTION_POINTERS e)
{
	if (e->ContextRecord->Dr0)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_HW_BREAKPOINT_0, (PVOID)e->ContextRecord->Dr0, (PVOID)e->ContextRecord->Dr7);
	else if (e->ContextRecord->Dr1)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_HW_BREAKPOINT_1, (PVOID)e->ContextRecord->Dr1, (PVOID)e->ContextRecord->Dr7);
	else if (e->ContextRecord->Dr2)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_HW_BREAKPOINT_2, (PVOID)e->ContextRecord->Dr2, (PVOID)e->ContextRecord->Dr7);
	else if (e->ContextRecord->Dr3)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_HW_BREAKPOINT_3, (PVOID)e->ContextRecord->Dr3, (PVOID)e->ContextRecord->Dr7);

	else if (e->ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_SW_BREAKPOINT, (PVOID)e->ExceptionRecord->ExceptionAddress, (PVOID)e->ExceptionRecord->ExceptionInformation[1]);

	else if (e->ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_SINGLE_STEP, (PVOID)e->ExceptionRecord->ExceptionAddress, (PVOID)e->ExceptionRecord->ExceptionInformation[1]);

	else if (e->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION)
		RG_Report(RG_OPT_ANTI_DEBUGGING, REPORT_DEBUG_PAGE_GUARD, (PVOID)e->ExceptionRecord->ExceptionAddress, (PVOID)e->ExceptionRecord->ExceptionInformation[1]);
}

VOID CALLBACK DllCallback(ULONG reason, PLDR_DLL_NOTIFICATION_DATA data, PVOID context)
{
	if (reason == LDR_DLL_NOTIFICATION_REASON_LOADED)
	{
		CheckThread(GetCurrentThreadStartAddress(), TC_DllCallback);

#if IS_ENABLED(RG_OPT_REBIRTH_ALL_MODULES)
#ifdef _WIN64 // unstable in x86 yet.
		BOOL packed = FALSE;
		PIMAGE_NT_HEADERS nt = GetNtHeader(data->Loaded.DllBase);
		PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(nt);
		for (DWORD i = 0; !packed && i < nt->FileHeader.NumberOfSections; ++i)
			if (strstr((CHAR*)sec[i].Name, RGS("themida")) || strstr((CHAR*)sec[i].Name, RGS("vmp")))
				packed = TRUE;

		if (!packed)
			RebirthModule(NULL, data->Loaded.DllBase);
#endif
#endif
	}
	return;
}

```

`RebirthGuard/RebirthGuard/crypto.cpp`:

```cpp

/*
	chztbby::RebirthGuard/crypto.cpp
*/

#include "RebirthGuard.h"

CONST DWORD64 crc64_table[256]
{
	0x0000000000000000, 0x7ad870c830358979,
	0xf5b0e190606b12f2, 0x8f689158505e9b8b,
	0xc038e5739841b68f, 0xbae095bba8743ff6,
	0x358804e3f82aa47d, 0x4f50742bc81f2d04,
	0xab28ecb46814fe75, 0xd1f09c7c5821770c,
	0x5e980d24087fec87, 0x24407dec384a65fe,
	0x6b1009c7f05548fa, 0x11c8790fc060c183,
	0x9ea0e857903e5a08, 0xe478989fa00bd371,
	0x7d08ff3b88be6f81, 0x07d08ff3b88be6f8,
	0x88b81eabe8d57d73, 0xf2606e63d8e0f40a,
	0xbd301a4810ffd90e, 0xc7e86a8020ca5077,
	0x4880fbd87094cbfc, 0x32588b1040a14285,
	0xd620138fe0aa91f4, 0xacf86347d09f188d,
	0x2390f21f80c18306, 0x594882d7b0f40a7f,
	0x1618f6fc78eb277b, 0x6cc0863448deae02,
	0xe3a8176c18803589, 0x997067a428b5bcf0,
	0xfa11fe77117cdf02, 0x80c98ebf2149567b,
	0x0fa11fe77117cdf0, 0x75796f2f41224489,
	0x3a291b04893d698d, 0x40f16bccb908e0f4,
	0xcf99fa94e9567b7f, 0xb5418a5cd963f206,
	0x513912c379682177, 0x2be1620b495da80e,
	0xa489f35319033385, 0xde51839b2936bafc,
	0x9101f7b0e12997f8, 0xebd98778d11c1e81,
	0x64b116208142850a, 0x1e6966e8b1770c73,
	0x8719014c99c2b083, 0xfdc17184a9f739fa,
	0x72a9e0dcf9a9a271, 0x08719014c99c2b08,
	0x4721e43f0183060c, 0x3df994f731b68f75,
	0xb29105af61e814fe, 0xc849756751dd9d87,
	0x2c31edf8f1d64ef6, 0x56e99d30c1e3c78f,
	0xd9810c6891bd5c04, 0xa3597ca0a188d57d,
	0xec09088b6997f879, 0x96d1784359a27100,
	0x19b9e91b09fcea8b, 0x636199d339c963f2,
	0xdf7adabd7a6e2d6f, 0xa5a2aa754a5ba416,
	0x2aca3b2d1a053f9d, 0x50124be52a30b6e4,
	0x1f423fcee22f9be0, 0x659a4f06d21a1299,
	0xeaf2de5e82448912, 0x902aae96b271006b,
	0x74523609127ad31a, 0x0e8a46c1224f5a63,
	0x81e2d7997211c1e8, 0xfb3aa75142244891,
	0xb46ad37a8a3b6595, 0xceb2a3b2ba0eecec,
	0x41da32eaea507767, 0x3b024222da65fe1e,
	0xa2722586f2d042ee, 0xd8aa554ec2e5cb97,
	0x57c2c41692bb501c, 0x2d1ab4dea28ed965,
	0x624ac0f56a91f461, 0x1892b03d5aa47d18,
	0x97fa21650afae693, 0xed2251ad3acf6fea,
	0x095ac9329ac4bc9b, 0x7382b9faaaf135e2,
	0xfcea28a2faafae69, 0x8632586aca9a2710,
	0xc9622c4102850a14, 0xb3ba5c8932b0836d,
	0x3cd2cdd162ee18e6, 0x460abd1952db919f,
	0x256b24ca6b12f26d, 0x5fb354025b277b14,
	0xd0dbc55a0b79e09f, 0xaa03b5923b4c69e6,
	0xe553c1b9f35344e2, 0x9f8bb171c366cd9b,
	0x10e3202993385610, 0x6a3b50e1a30ddf69,
	0x8e43c87e03060c18, 0xf49bb8b633338561,
	0x7bf329ee636d1eea, 0x012b592653589793,
	0x4e7b2d0d9b47ba97, 0x34a35dc5ab7233ee,
	0xbbcbcc9dfb2ca865, 0xc113bc55cb19211c,
	0x5863dbf1e3ac9dec, 0x22bbab39d3991495,
	0xadd33a6183c78f1e, 0xd70b4aa9b3f20667,
	0x985b3e827bed2b63, 0xe2834e4a4bd8a21a,
	0x6debdf121b863991, 0x1733afda2bb3b0e8,
	0xf34b37458bb86399, 0x8993478dbb8deae0,
	0x06fbd6d5ebd3716b, 0x7c23a61ddbe6f812,
	0x3373d23613f9d516, 0x49aba2fe23cc5c6f,
	0xc6c333a67392c7e4, 0xbc1b436e43a74e9d,
	0x95ac9329ac4bc9b5, 0xef74e3e19c7e40cc,
	0x601c72b9cc20db47, 0x1ac40271fc15523e,
	0x5594765a340a7f3a, 0x2f4c0692043ff643,
	0xa02497ca54616dc8, 0xdafce7026454e4b1,
	0x3e847f9dc45f37c0, 0x445c0f55f46abeb9,
	0xcb349e0da4342532, 0xb1eceec59401ac4b,
	0xfebc9aee5c1e814f, 0x8464ea266c2b0836,
	0x0b0c7b7e3c7593bd, 0x71d40bb60c401ac4,
	0xe8a46c1224f5a634, 0x927c1cda14c02f4d,
	0x1d148d82449eb4c6, 0x67ccfd4a74ab3dbf,
	0x289c8961bcb410bb, 0x5244f9a98c8199c2,
	0xdd2c68f1dcdf0249, 0xa7f41839ecea8b30,
	0x438c80a64ce15841, 0x3954f06e7cd4d138,
	0xb63c61362c8a4ab3, 0xcce411fe1cbfc3ca,
	0x83b465d5d4a0eece, 0xf96c151de49567b7,
	0x76048445b4cbfc3c, 0x0cdcf48d84fe7545,
	0x6fbd6d5ebd3716b7, 0x15651d968d029fce,
	0x9a0d8ccedd5c0445, 0xe0d5fc06ed698d3c,
	0xaf85882d2576a038, 0xd55df8e515432941,
	0x5a3569bd451db2ca, 0x20ed197575283bb3,
	0xc49581ead523e8c2, 0xbe4df122e51661bb,
	0x3125607ab548fa30, 0x4bfd10b2857d7349,
	0x04ad64994d625e4d, 0x7e7514517d57d734,
	0xf11d85092d094cbf, 0x8bc5f5c11d3cc5c6,
	0x12b5926535897936, 0x686de2ad05bcf04f,
	0xe70573f555e26bc4, 0x9ddd033d65d7e2bd,
	0xd28d7716adc8cfb9, 0xa85507de9dfd46c0,
	0x273d9686cda3dd4b, 0x5de5e64efd965432,
	0xb99d7ed15d9d8743, 0xc3450e196da80e3a,
	0x4c2d9f413df695b1, 0x36f5ef890dc31cc8,
	0x79a59ba2c5dc31cc, 0x037deb6af5e9b8b5,
	0x8c157a32a5b7233e, 0xf6cd0afa9582aa47,
	0x4ad64994d625e4da, 0x300e395ce6106da3,
	0xbf66a804b64ef628, 0xc5bed8cc867b7f51,
	0x8aeeace74e645255, 0xf036dc2f7e51db2c,
	0x7f5e4d772e0f40a7, 0x05863dbf1e3ac9de,
	0xe1fea520be311aaf, 0x9b26d5e88e0493d6,
	0x144e44b0de5a085d, 0x6e963478ee6f8124,
	0x21c640532670ac20, 0x5b1e309b16452559,
	0xd476a1c3461bbed2, 0xaeaed10b762e37ab,
	0x37deb6af5e9b8b5b, 0x4d06c6676eae0222,
	0xc26e573f3ef099a9, 0xb8b627f70ec510d0,
	0xf7e653dcc6da3dd4, 0x8d3e2314f6efb4ad,
	0x0256b24ca6b12f26, 0x788ec2849684a65f,
	0x9cf65a1b368f752e, 0xe62e2ad306bafc57,
	0x6946bb8b56e467dc, 0x139ecb4366d1eea5,
	0x5ccebf68aecec3a1, 0x2616cfa09efb4ad8,
	0xa97e5ef8cea5d153, 0xd3a62e30fe90582a,
	0xb0c7b7e3c7593bd8, 0xca1fc72bf76cb2a1,
	0x45775673a732292a, 0x3faf26bb9707a053,
	0x70ff52905f188d57, 0x0a2722586f2d042e,
	0x854fb3003f739fa5, 0xff97c3c80f4616dc,
	0x1bef5b57af4dc5ad, 0x61372b9f9f784cd4,
	0xee5fbac7cf26d75f, 0x9487ca0fff135e26,
	0xdbd7be24370c7322, 0xa10fceec0739fa5b,
	0x2e675fb4576761d0, 0x54bf2f7c6752e8a9,
	0xcdcf48d84fe75459, 0xb71738107fd2dd20,
	0x387fa9482f8c46ab, 0x42a7d9801fb9cfd2,
	0x0df7adabd7a6e2d6, 0x772fdd63e7936baf,
	0xf8474c3bb7cdf024, 0x829f3cf387f8795d,
	0x66e7a46c27f3aa2c, 0x1c3fd4a417c62355,
	0x935745fc4798b8de, 0xe98f353477ad31a7,
	0xa6df411fbfb21ca3, 0xdc0731d78f8795da,
	0x536fa08fdfd90e51, 0x29b7d047efec8728
};

DWORD64 CRC64(PVOID module_base)
{
	DWORD check_size = 0;
	PIMAGE_NT_HEADERS nt = GetNtHeader(module_base);
	PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(nt);

	for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; i++)
	{
		if (sec[i].Characteristics & IMAGE_SCN_MEM_WRITE)
		{
			check_size = sec[i].VirtualAddress;
			break;
		}
	}

	DWORD64 result = 0;

	for (DWORD i = 0; i < check_size; i++)
		result = crc64_table[(BYTE)result ^ ((BYTE*)module_base)[i]] ^ (result >> 8);

	return result;
}
```

`RebirthGuard/RebirthGuard/log.cpp`:

```cpp

/*
	chztbby::RebirthGuard/log.cpp
*/

#include "RebirthGuard.h"


VOID RG_DebugLog(LPCWSTR format, ...)
{
#if RG_OPT_DEBUG_LOG & RG_ENABLE

#endif
}

VOID RG_Report(DWORD flag, RG_REPORT_CODE code, PVOID data1, PVOID data2)
{
	WCHAR module_name1[MAX_PATH] = L"";
	WCHAR module_name2[MAX_PATH] = L"";
	WCHAR module_path1[MAX_PATH] = L"";
	WCHAR module_path2[MAX_PATH] = L"";

	time_t t = time(NULL);
	tm tm;
	localtime_s(&tm, &t);

	PVOID module_base1 = GetModuleBaseFromPtr(data1, PC_IMAGE_SIZE);
	PVOID module_base2 = GetModuleBaseFromPtr(data2, PC_IMAGE_SIZE);

	LDR_MODULE module_info = { 0, };
	for (DWORD i = 0; RG_GetNextModule(&module_info); ++i)
	{
		if (module_base1 == module_info.BaseAddress)
		{
			RG_wcscpy(module_name1, module_info.BaseDllName.Buffer);
			RG_wcscat(module_name1, L" +");
			RG_wcscpy(module_path1, module_info.FullDllName.Buffer);
		}
		if (module_base2 == module_info.BaseAddress)
		{
			RG_wcscpy(module_name2, module_info.BaseDllName.Buffer);
			RG_wcscat(module_name2, L" +");
			RG_wcscpy(module_path2, module_info.FullDllName.Buffer);
		}
	}

	if (flag & RG_ENABLE_LOG)
	{
		FILE* log = NULL;
		fopen_s(&log, "RebirthGuard.log", "a+");
		fprintf(log,
			"[%04d-%02d-%02d %02d:%02d:%02d] Pid : %d / Code : 0x%08X / %S 0x%p / %S 0x%p\n",
			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec,
			GetCurrentProcessId(),
			code,
			module_name1, (PVOID)GetOffset(RG_GetModuleHandleW(module_path1), data1),
			module_name2, (PVOID)GetOffset(RG_GetModuleHandleW(module_path2), data2));
		fclose(log);
	}

	if (flag & RG_ENABLE_POPUP)
	{
		CHAR scriptpath[MAX_PATH];
		APICALL(GetCurrentDirectoryA)(MAX_PATH, scriptpath);
		RG_strcat(scriptpath, "\\RebirthGuard.vbs");

		FILE* log = NULL;
		fopen_s(&log, "RebirthGuard.vbs", "w+");
		fprintf(log,
			"Dim obj, file\n"
			"Set obj = CreateObject(\"Scripting.FileSystemObject\")\n"
			"Set file = obj.GetFile(\"%s\")\n"
			"file.Delete\n"
			"msgbox \"[ %04d-%02d-%02d %02d:%02d:%02d ]\" & Chr(13) & Chr(13) &"
			"\"Pid\t:  %d\" & Chr(13) & "
			"\"Code\t:  0x%08X\" & Chr(13) & Chr(13) &"
			"\"%S 0x%p\" & Chr(13) &"
			"\"%S 0x%p\", 0 + 48, \"RebirthGuard\""
			, scriptpath,
			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec,
			GetCurrentProcessId(),
			code,
			module_name1, (PVOID)GetOffset(RG_GetModuleHandleW(module_path1), data1),
			module_name2, (PVOID)GetOffset(RG_GetModuleHandleW(module_path2), data2));
		fclose(log);

		CHAR path[MAX_PATH] = "wscript.exe \"";
		RG_strcat(path, scriptpath);
		RG_strcat(path, "\"");

		APICALL(WinExec)(path, SW_SHOW);
	}

	if (flag & RG_ENABLE_DEALLOC)
		RG_FreeMemory(data1);

	if (flag & RG_ENABLE_KILL)
		APICALL(NtTerminateProcess)(CURRENT_PROCESS, 0);
}
```

`RebirthGuard/RebirthGuard/mapping.cpp`:

```cpp

/*
	chztbby::RebirthGuard/mapping.cpp
*/

#include "RebirthGuard.h"


VOID RebirthModule(PVOID hmodule, PVOID module_base)
{
	if (IsRebirthed(module_base))
		return;

	PVOID original_ntdll = RG_GetModuleHandleW(RG_GetModulePath(MODULE_NTDLL));
	PVOID mapped_ntdll = NULL;

	decltype(&NtCreateSection) pNtCreateSection = APICALL(NtCreateSection);
	decltype(&NtMapViewOfSection) pNtMapViewOfSection = APICALL(NtMapViewOfSection);
	decltype(&NtUnmapViewOfSection) pNtUnmapViewOfSection = APICALL(NtUnmapViewOfSection);
	decltype(&NtLockVirtualMemory) pNtLockVirtualMemory = APICALL(NtLockVirtualMemory);
	decltype(&NtQueryInformationProcess) pNtQueryInformationProcess = APICALL(NtQueryInformationProcess);
	decltype(&RtlAcquirePrivilege) pRtlAcquirePrivilege = APICALL(RtlAcquirePrivilege);
	decltype(&NtSetInformationProcess) pNtSetInformationProcess = APICALL(NtSetInformationProcess);
	decltype(&RtlReleasePrivilege) pRtlReleasePrivilege = APICALL(RtlReleasePrivilege);

	if (!IsRebirthed(original_ntdll))
	{
		mapped_ntdll = ManualMap(original_ntdll);
		pNtCreateSection = (decltype(pNtCreateSection))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pNtCreateSection));
		pNtMapViewOfSection = (decltype(pNtMapViewOfSection))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pNtMapViewOfSection));
		pNtUnmapViewOfSection = (decltype(pNtUnmapViewOfSection))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pNtUnmapViewOfSection));
		pNtLockVirtualMemory = (decltype(pNtLockVirtualMemory))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pNtLockVirtualMemory));
		pNtQueryInformationProcess = (decltype(pNtQueryInformationProcess))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pNtQueryInformationProcess));
		pRtlAcquirePrivilege = (decltype(pRtlAcquirePrivilege))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pRtlAcquirePrivilege));
		pNtSetInformationProcess = (decltype(pNtSetInformationProcess))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pNtSetInformationProcess));
		pRtlReleasePrivilege = (decltype(pRtlReleasePrivilege))GetPtr(mapped_ntdll, GetOffset(original_ntdll, pRtlReleasePrivilege));
	}

	PVOID file_buffer = LoadFile(module_base);
	PIMAGE_NT_HEADERS nt = GetNtHeader(file_buffer);
	PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(nt);
	HANDLE section = NULL;
	LARGE_INTEGER section_size;
	section_size.QuadPart = nt->OptionalHeader.SizeOfImage;
	pNtCreateSection(&section, SECTION_ALL_ACCESS, NULL, &section_size, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);

	PVOID view_base = NULL;
	SIZE_T view_size = NULL;
	pNtMapViewOfSection(section, CURRENT_PROCESS, &view_base, NULL, NULL, NULL, &view_size, ViewUnmap, NULL, PAGE_READWRITE);

	PVOID src_module;
#if IS_ENABLED(RG_OPT_COMPAT_THEMIDA) || IS_ENABLED(RG_OPT_COMPAT_VMPROTECT)
	if (hmodule == module_base)
		src_module = module_base;
	else
#endif
		src_module = ManualMap(module_base);

	CopyPeData(view_base, src_module, PE_TYPE_IMAGE);

	for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; i++)
		for (DWORD j = 0; j < sec[i].Misc.VirtualSize; j += sizeof(PVOID))
			if ((sec[i].Characteristics & IMAGE_SCN_MEM_WRITE))
				*(PVOID*)GetPtr(view_base, (SIZE_T)sec[i].VirtualAddress + j) = *(PVOID*)GetPtr(module_base, (SIZE_T)sec[i].VirtualAddress + j);

#if IS_ENABLED(RG_OPT_COMPAT_THEMIDA) || IS_ENABLED(RG_OPT_COMPAT_VMPROTECT)
	if (hmodule != module_base)
#endif
		RG_FreeMemory(src_module);

#if IS_ENABLED(RG_OPT_THREAD_CHECK)
#ifdef _WIN64
	if (module_base == original_ntdll)
	{
		SIZE_T offset = GetOffset(original_ntdll, APICALL(RtlUserThreadStart));
		BYTE jmp_myRtlUserThreadStart[14] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, };
		*(PVOID*)(jmp_myRtlUserThreadStart + 6) = ThreadCallback;
		memcpy(GetPtr(view_base, offset), jmp_myRtlUserThreadStart, sizeof(jmp_myRtlUserThreadStart));
	}
#else
	// x86
#endif
#endif
	pNtUnmapViewOfSection(CURRENT_PROCESS, view_base);

	pNtUnmapViewOfSection(CURRENT_PROCESS, module_base);

	MAP_INFO mapinfo;
	mapinfo.pNtMapViewOfSection = pNtMapViewOfSection;
	mapinfo.pNtLockVirtualMemory = pNtLockVirtualMemory;
	mapinfo.pNtQueryInformationProcess = pNtQueryInformationProcess;
	mapinfo.pNtSetInformationProcess = pNtSetInformationProcess;
	mapinfo.pRtlAcquirePrivilege = pRtlAcquirePrivilege;
	mapinfo.pRtlReleasePrivilege = pRtlReleasePrivilege;
	mapinfo.base = module_base;
	mapinfo.hsection = section;
	mapinfo.nt = nt;
	mapinfo.chunk_offset = 0;
	mapinfo.chunk_size = PADDING(nt->OptionalHeader.SizeOfHeaders, nt->OptionalHeader.SectionAlignment);
	mapinfo.chunk_Characteristics = IMAGE_SCN_MEM_READ;
	MapAllSections(&mapinfo);

	if (mapinfo.chunk_size)
		MapChunk(&mapinfo, mapinfo.chunk_offset, mapinfo.chunk_size, mapinfo.chunk_Characteristics);

	RG_ProtectMemory(module_base, PADDING(nt->OptionalHeader.SizeOfHeaders, nt->OptionalHeader.SectionAlignment), PAGE_READONLY);
	for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; ++i)
		RG_ProtectMemory(GetPtr(module_base, sec[i].VirtualAddress), PADDING(sec[i].Misc.VirtualSize, nt->OptionalHeader.SectionAlignment), GetProtection(sec[i].Characteristics));

	AddRebirthedModule(module_base, section);

	RG_FreeMemory(file_buffer);

	if (mapped_ntdll)
		RG_FreeMemory(mapped_ntdll);

	RG_HideModule(module_base);
}

PVOID LoadFile(PVOID module_base)
{
	HANDLE file = APICALL(CreateFileW)(RG_GetModulePath(module_base), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	DWORD file_size = APICALL(GetFileSize)(file, NULL);
	PVOID file_base = RG_AllocMemory(NULL, file_size, PAGE_READWRITE);
	APICALL(ReadFile)(file, file_base, file_size, 0, 0);
	APICALL(NtClose)(file);

	return file_base;
}

PVOID ManualMap(PVOID module_base)
{
	PVOID file_buffer = LoadFile(module_base);
	PIMAGE_NT_HEADERS nt = GetNtHeader(file_buffer);

	PVOID image_base = RG_AllocMemory(NULL, nt->OptionalHeader.SizeOfImage, PAGE_EXECUTE_READWRITE);
	CopyPeData(image_base, file_buffer, PE_TYPE_FILE);
	RG_FreeMemory(file_buffer);

	nt = GetNtHeader(image_base);

	HMODULE ntdll = RG_GetModuleHandleW(RG_GetModulePath(MODULE_NTDLL));
	HMODULE kernel32 = RG_GetModuleHandleW(RG_GetModulePath(MODULE_KERNEL32));
	HMODULE kernelbase = RG_GetModuleHandleW(RG_GetModulePath(MODULE_KERNELBASE));

	PIMAGE_BASE_RELOCATION base_reloc = (PIMAGE_BASE_RELOCATION)GetPtr(image_base, nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	SIZE_T delta = GetOffset(nt->OptionalHeader.ImageBase, module_base);

	while (base_reloc->VirtualAddress)
	{
		if (base_reloc->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))
		{
			DWORD count = (base_reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			WORD* list = (PWORD)(base_reloc + 1);

			for (DWORD i = 0; i < count; i++)
			{
				if (list[i])
				{
					PVOID ptr = ((LPBYTE)image_base + (base_reloc->VirtualAddress + (list[i] & 0xFFF)));
					*(SIZE_T*)ptr += delta;
				}
			}
		}

		base_reloc = (PIMAGE_BASE_RELOCATION)((LPBYTE)base_reloc + base_reloc->SizeOfBlock);
	}

	PIMAGE_IMPORT_DESCRIPTOR import = (PIMAGE_IMPORT_DESCRIPTOR)GetPtr(image_base, nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	while (import->Characteristics)
	{
		PIMAGE_THUNK_DATA oft = (PIMAGE_THUNK_DATA)GetPtr(image_base, import->OriginalFirstThunk);
		PIMAGE_THUNK_DATA ft = (PIMAGE_THUNK_DATA)GetPtr(image_base, import->FirstThunk);

		WCHAR import_module_path[MAX_PATH];
		LPCSTR str = (CHAR*)GetPtr(image_base, import->Name);
		for (DWORD i = 0; str[i] != 0; i++)
		{
			import_module_path[i] = str[i];
			import_module_path[i + 1] = 0;
		}

		HMODULE hmodule = APICALL(LoadLibraryW)(import_module_path);
		if (!hmodule)
			break;

		while (oft->u1.AddressOfData)
		{
			PVOID func = NULL;

			if (oft->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				func = RG_GetProcAddress(hmodule, (LPCSTR)(oft->u1.Ordinal & 0xFFFF));
				if (!func)
					break;
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME ibn = (PIMAGE_IMPORT_BY_NAME)GetPtr(image_base, oft->u1.AddressOfData);
				
				PVOID redirect;
				if (module_base == kernel32)
				{
					if (redirect = APICALL(GetProcAddress)(ntdll, (LPCSTR)ibn->Name))
						func = redirect;

					else if (redirect = APICALL(GetProcAddress)(kernelbase, (LPCSTR)ibn->Name))
						func = redirect;
				}
				else
				{
					func = APICALL(GetProcAddress)(hmodule, (LPCSTR)ibn->Name);
				}

				if (!func)
					break;
			}

			*(PVOID*)ft = func;

			oft++;
			ft++;
		}

		import++;
	}

	nt->OptionalHeader.ImageBase = (SIZE_T)module_base;

	return image_base;
}

VOID ExtendWorkingSet(PMAP_INFO info)
{
	QUOTA_LIMITS ql;
	info->pNtQueryInformationProcess(CURRENT_PROCESS, (PROCESSINFOCLASS)ProcessQuotaLimits, &ql, sizeof(ql), NULL);

	ql.MinimumWorkingSetSize += PAGE_SIZE;
	if (ql.MaximumWorkingSetSize < ql.MinimumWorkingSetSize)
		ql.MaximumWorkingSetSize = ql.MinimumWorkingSetSize;

	PVOID privilege_state = NULL;
	DWORD privilege_value = SE_AUDIT_PRIVILEGE;
	info->pRtlAcquirePrivilege(&privilege_value, 1, 0, &privilege_state);

	info->pNtSetInformationProcess(CURRENT_PROCESS, ProcessQuotaLimits, &ql, sizeof(ql));
	info->pRtlReleasePrivilege(privilege_state);
}

VOID AddRebirthedModule(PVOID module_base, HANDLE section)
{
    for (DWORD i = 0; i < ARRAYSIZE(rgdata->rmi); i++)
    {
        if (rgdata->rmi[i].module_base == module_base)
            return;

        if (!rgdata->rmi[i].module_base)
        {
			rgdata->rmi[i].module_base = module_base;
#if IS_ENABLED(RG_OPT_INTEGRITY_CHECK_HIDE_FROM_DEBUGGER)
            rebirthed_module_list[i].section = section;
#else
			APICALL(NtClose)(section);
#endif
			return;
        }
    }
}

VOID MapAllSections(PMAP_INFO info)
{
	if (info->nt->OptionalHeader.SectionAlignment % ALLOCATION_GRANULARITY == 0)
	{
		PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(info->nt);

		for (DWORD i = 0; i < info->nt->FileHeader.NumberOfSections; ++i)
		{
			DWORD chr = sec[i].Characteristics;

#if IS_ENABLED(RG_OPT_COMPAT_THEMIDA)
			if (sec[i].Name[1] == 't' && sec[i].Name[2] == 'h' && sec[i].Name[3] == 'e' && sec[i].Name[4] == 'm' && sec[i].Name[5] == 'i' && sec[i].Name[6] == 'd' && sec[i].Name[7] == 'a')
				chr = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
#endif
#if IS_ENABLED(RG_OPT_COMPAT_VMPROTECT)
			if (sec[i].Name[1] == 'v' && sec[i].Name[2] == 'm' && sec[i].Name[3] == 'p')
				chr = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
#endif

			MapChunk(info, sec[i].VirtualAddress, (SIZE_T)PADDING(sec[i].Misc.VirtualSize, info->nt->OptionalHeader.SectionAlignment), chr);
		}
	}
	else
	{
		PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(info->nt);

		for (DWORD i = 0; i < info->nt->FileHeader.NumberOfSections; ++i)
		{
			SIZE_T sec_size = (SIZE_T)PADDING(sec[i].Misc.VirtualSize, info->nt->OptionalHeader.SectionAlignment);
			SIZE_T full_chunk_size = info->chunk_size + sec_size;

			if (full_chunk_size < ALLOCATION_GRANULARITY || (!(sec[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && !(info->chunk_Characteristics & IMAGE_SCN_MEM_EXECUTE)))
			{
				if (info->chunk_size)
				{
					info->chunk_Characteristics |= sec[i].Characteristics;
				}
				else
				{
					info->chunk_offset = sec[i].VirtualAddress;
					info->chunk_Characteristics = sec[i].Characteristics;
				}

				info->chunk_size = full_chunk_size;
			}
			else
			{
				if (info->chunk_size)
				{
					MapChunk(info, info->chunk_offset, ALLOCATION_GRANULARITY, (info->chunk_Characteristics | sec[i].Characteristics));
					full_chunk_size -= ALLOCATION_GRANULARITY;
					info->chunk_offset += ALLOCATION_GRANULARITY;
					info->chunk_size = full_chunk_size;
					info->chunk_Characteristics = sec[i].Characteristics;
				}
				else
				{
					info->chunk_offset = sec[i].VirtualAddress;
				}

				SIZE_T chunk_size = full_chunk_size / ALLOCATION_GRANULARITY * ALLOCATION_GRANULARITY;
				if (chunk_size)
					MapChunk(info, info->chunk_offset, chunk_size, sec[i].Characteristics);

				if (full_chunk_size > chunk_size)
				{
					info->chunk_offset += chunk_size;
					info->chunk_size = full_chunk_size - chunk_size;
					info->chunk_Characteristics = sec[i].Characteristics;
				}
				else
				{
					info->chunk_offset = 0;
					info->chunk_size = 0;
					info->chunk_Characteristics = NULL;
				}
			}
		}
	}
}

VOID MapChunk(PMAP_INFO info, SIZE_T offset, SIZE_T size, DWORD chr)
{
	DWORD nochange = GetNoChange(chr);
	DWORD protect = GetProtection(chr);

	PVOID view_base = GetPtr(info->base, offset);
	LARGE_INTEGER view_offset;
	view_offset.QuadPart = offset;

	info->pNtMapViewOfSection(info->hsection, CURRENT_PROCESS, &view_base, NULL, NULL, &view_offset, &size, ViewUnmap, nochange, protect);

	SIZE_T lock_size = PAGE_SIZE;
	while (info->pNtLockVirtualMemory(CURRENT_PROCESS, &view_base, &lock_size, VM_LOCK_1) == STATUS_WORKING_SET_QUOTA)
		ExtendWorkingSet(info);
}

DWORD GetProtection(DWORD chr)
{
	DWORD protect = NULL;

	if (chr & IMAGE_SCN_MEM_EXECUTE)
	{
		if (chr & IMAGE_SCN_MEM_WRITE)
			protect = PAGE_EXECUTE_READWRITE;
		else
			protect = PAGE_EXECUTE_READ;
	}
	else
	{
		if (chr & IMAGE_SCN_MEM_WRITE)
			protect = PAGE_READWRITE;
		else
			protect = PAGE_READONLY;
	}

	return protect;
}

DWORD GetNoChange(DWORD chr)
{
	if (GetProtection(chr) == PAGE_EXECUTE_READ)
		return SEC_NO_CHANGE;

	return NULL;
}
```

`RebirthGuard/RebirthGuard/ntstruct.h`:

```h

/*
	chztbby::RebirthGuard/ntstruct.h
*/

#ifndef NTSTRUCT_H
#define NTSTRUCT_H

#include <windows.h>

#define SEC_NO_CHANGE 0x00400000
#define STATUS_INVALID_PAGE_PROTECTION 0xC0000045
#define STATUS_WORKING_SET_QUOTA 0xC00000A1
#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define SE_AUDIT_PRIVILEGE 0x21
#define VM_LOCK_1 0x0001

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

typedef enum _SECTION_INHERIT
{
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, *PSECTION_INHERIT;

typedef enum _MEMORY_INFORMATION_CLASS
{
    MemoryBasicInformation,
    MemoryWorkingSetInformation,
    MemoryMappedFilenameInformation,
    MemoryRegionInformation,
    MemoryWorkingSetExInformation,
    //...
} MEMORY_INFORMATION_CLASS;

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation,
	ProcessQuotaLimits,
	//...
} PROCESSINFOCLASS, *PPROCESSINFOCLASS;

typedef enum _THREADINFOCLASS
{
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger
} THREADINFOCLASS, *PTHREADINFOCLASS;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
{
	ULONG Flags;
	PCUNICODE_STRING FullDllName;
	PCUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA
{
	ULONG Flags;
	PCUNICODE_STRING FullDllName;
	PCUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA
{
	LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
	LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_MODULE
{
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	HMODULE BaseAddress;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	// ...
} LDR_MODULE, *PLDR_MODULE;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	BOOLEAN Spare;
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA LoaderData;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID FastPebLockRoutine;
	PVOID FastPebUnlockRoutine;
	ULONG EnvironmentUpdateCount;
	PVOID KernelCallbackTable;
	PVOID EventLogSection;
	PVOID EventLog;
	PVOID FreeList;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[0x2];
	PVOID ReadOnlySharedMemoryBase;
	PVOID ReadOnlySharedMemoryHeap;
	PVOID* ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	BYTE Spare2[0x4];
	LARGE_INTEGER CriticalSectionTimeout;
	ULONG HeapSegmentReserve;
	ULONG HeapSegmentCommit;
	ULONG HeapDeCommitTotalFreeThreshold;
	ULONG HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID* ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	PVOID GdiDCAttributeList;
	PVOID LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	ULONG OSBuildNumber;
	ULONG OSPlatformId;
	ULONG ImageSubSystem;
	ULONG ImageSubSystemMajorVersion;
	ULONG ImageSubSystemMinorVersion;
	ULONG GdiHandleBuffer[0x22];
	ULONG PostProcessInitRoutine;
	ULONG TlsExpansionBitmap;
	BYTE TlsExpansionBitmapBits[0x80];
	ULONG SessionId;
} PEB, *PPEB;

typedef struct _TEB
{
	NT_TIB Tib;
	PVOID EnvironmentPointer;
	CLIENT_ID Cid;
	PVOID ActiveRpcInfo;
	PVOID ThreadLocalStoragePointer;
	PPEB Peb;
	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;
	ULONG Win32ClientInfo[0x1F];
	PVOID WOW32Reserved;
	ULONG CurrentLocale;
	ULONG FpSoftwareStatusRegister;
	PVOID SystemReserved1[0x36];
	PVOID Spare1;
	ULONG ExceptionCode;
	ULONG SpareBytes1[0x28];
	PVOID SystemReserved2[0xA];
	ULONG GdiRgn;
	ULONG GdiPen;
	ULONG GdiBrush;
	CLIENT_ID RealClientId;
	PVOID GdiCachedProcessHandle;
	ULONG GdiClientPID;
	ULONG GdiClientTID;
	PVOID GdiThreadLocaleInfo;
	PVOID UserReserved[5];
	PVOID GlDispatchTable[0x118];
	ULONG GlReserved1[0x1A];
	PVOID GlReserved2;
	PVOID GlSectionInfo;
	PVOID GlSection;
	PVOID GlTable;
	PVOID GlCurrentRC;
	PVOID GlContext;
	NTSTATUS LastStatusValue;
	UNICODE_STRING StaticUnicodeString;
	WCHAR StaticUnicodeBuffer[0x105];
	PVOID DeallocationStack;
	PVOID TlsSlots[0x40];
	LIST_ENTRY TlsLinks;
	PVOID Vdm;
	PVOID ReservedForNtRpc;
	PVOID DbgSsReserved[0x2];
	ULONG HardErrorDisabled;
	PVOID Instrumentation[0x10];
	PVOID WinSockData;
	ULONG GdiBatchCount;
	ULONG Spare2;
	ULONG Spare3;
	ULONG Spare4;
	PVOID ReservedForOle;
	ULONG WaitingOnLoaderLock;
	PVOID StackCommit;
	PVOID StackCommitMax;
	PVOID StackReserved;
} TEB, *PTEB;

NTSTATUS NTAPI NtCreateSection(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PLARGE_INTEGER, ULONG, ULONG, HANDLE);
NTSTATUS NTAPI NtMapViewOfSection(HANDLE, HANDLE, PVOID*, ULONG_PTR, SIZE_T, PLARGE_INTEGER, PSIZE_T, SECTION_INHERIT, ULONG, ULONG);
NTSTATUS NTAPI NtUnmapViewOfSection(HANDLE, PVOID);
NTSTATUS NTAPI NtProtectVirtualMemory(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG);
NTSTATUS NTAPI NtQueryVirtualMemory(HANDLE, PVOID, MEMORY_INFORMATION_CLASS, PVOID, SIZE_T, PSIZE_T);
NTSTATUS NTAPI NtLockVirtualMemory(HANDLE, PVOID, PSIZE_T, ULONG);
NTSTATUS NTAPI NtReadVirtualMemory(HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T);
NTSTATUS NTAPI NtWriteVirtualMemory(HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T);
NTSTATUS NTAPI NtAllocateVirtualMemory(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
NTSTATUS NTAPI NtFreeVirtualMemory(HANDLE, PVOID*, PSIZE_T, ULONG);
NTSTATUS NTAPI NtResumeProcess(HANDLE);
NTSTATUS NTAPI NtQueryInformationProcess(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
NTSTATUS NTAPI NtQueryInformationThread(HANDLE, THREADINFOCLASS, PVOID, ULONG, PULONG);
NTSTATUS NTAPI NtSetInformationProcess(HANDLE, PROCESSINFOCLASS, PVOID, ULONG);
NTSTATUS NTAPI NtSetInformationThread(HANDLE, THREADINFOCLASS, PVOID, ULONG);
NTSTATUS NTAPI RtlAcquirePrivilege(PULONG, ULONG, ULONG, PVOID*);
NTSTATUS NTAPI RtlReleasePrivilege(PVOID);
NTSTATUS NTAPI RtlUserThreadStart(PTHREAD_START_ROUTINE, PVOID);
NTSTATUS NTAPI NtCreateThreadEx(PHANDLE, ACCESS_MASK, PVOID, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PVOID);
NTSTATUS NTAPI NtTerminateProcess(HANDLE, NTSTATUS);
NTSTATUS NTAPI NtTerminateThread(HANDLE, NTSTATUS);
NTSTATUS NTAPI NtClose(HANDLE);
NTSTATUS NTAPI RtlAddVectoredExceptionHandler(ULONG, PVECTORED_EXCEPTION_HANDLER);
NTSTATUS NTAPI LdrRegisterDllNotification(ULONG, PVOID, PVOID, PVOID);
NTSTATUS NTAPI LdrLoadDll(PWCHAR, ULONG, PUNICODE_STRING, PHANDLE);

#endif
```

`RebirthGuard/RebirthGuard/options.h`:

```h

/*
	chztbby::RebirthGuard/options.h
*/

#ifndef REBIRTHGUARD_OPTION_H
#define REBIRTHGUARD_OPTION_H

#define RG_DISABLE			0x00000000
#define RG_ENABLE			0x00000001
#define RG_ENABLE_LOG		0x00000002	
#define RG_ENABLE_POPUP		0x00000004
#define RG_ENABLE_KILL		0x00000008
#define RG_ENABLE_DEALLOC	0x00000010

// Set your options.
//#define RG_OPT_DEBUG_LOG							(RG_DISABLE)

#define RG_OPT_COMPAT_THEMIDA						(RG_DISABLE)
#define RG_OPT_COMPAT_VMPROTECT						(RG_DISABLE)

#define RG_OPT_HIDE_MODULE							(RG_DISABLE)
#define RG_OPT_REBIRTH_SYSTEM_MODULES				(RG_DISABLE & !RG_OPT_COMPAT_VMPROTECT)
#define RG_OPT_REBIRTH_ALL_MODULES					(RG_DISABLE & !RG_OPT_COMPAT_VMPROTECT)
#if __cplusplus >= 201703
#define RG_OPT_SET_PROCESS_POLICY					(RG_DISABLE & !RG_OPT_COMPAT_VMPROTECT & !RG_OPT_COMPAT_THEMIDA)	// EXE only
#endif
#define RG_OPT_ANTI_DLL_INJECTION					(RG_DISABLE | RG_ENABLE_LOG | RG_ENABLE_POPUP | RG_ENABLE_KILL)
#define RG_OPT_ANTI_DEBUGGING						(RG_DISABLE | RG_ENABLE_LOG | RG_ENABLE_POPUP | RG_ENABLE_KILL)
#define RG_OPT_THREAD_CHECK							(RG_DISABLE | RG_ENABLE_LOG | RG_ENABLE_POPUP | RG_ENABLE_KILL)
#define RG_OPT_MEMORY_CHECK							(RG_DISABLE | RG_ENABLE_LOG | RG_ENABLE_POPUP | RG_ENABLE_KILL | RG_ENABLE_DEALLOC)

#define RG_OPT_INTEGRITY_CHECK						(RG_DISABLE) // fix..
#define RG_OPT_INTEGRITY_CHECK_HIDE_FROM_DEBUGGER	(RG_DISABLE) // fix..

#define IS_ENABLED(OPTION) (OPTION & RG_ENABLE)
#if IS_ENABLED(RG_OPT_SET_PROCESS_POLICY)
#define	RG_PROCESS_POLICY (PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE\
							| PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE\
							| PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE\
							| PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS\
							| PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_ALWAYS_ON\
							| PROCESS_CREATION_MITIGATION_POLICY2_STRICT_CONTROL_FLOW_GUARD_ALWAYS_ON)
#endif

#endif
```

`RebirthGuard/RebirthGuard/string.cpp`:

```cpp

/*
	chztbby::RebirthGuard/string.cpp
*/

#include "RebirthGuard.h"

INT RG_strcmp(LPCSTR p1, LPCSTR p2)
{
	LPCSTR s1 = p1;
	LPCSTR s2 = p2;
	CHAR c1, c2;
	do
	{
		c1 = *s1++;
		c2 = *s2++;
		if (c1 == '\0')
			return c1 - c2;
	} while (c1 == c2);
	return c1 - c2;
}

LPSTR RG_strcat(LPSTR s1, LPCSTR s2)
{
	LPSTR cp = s1;
	while (*cp != '\0')
		cp++;
	while ((*cp++ = *s2++) != '\0');

	return (s1);
}

LPCWSTR RG_wcsistr(LPCWSTR s1, LPCWSTR s2)
{
	if (s1 && s2)
	{
		LPCWSTR s;
		LPCWSTR sub;
		for (; *s1; s1++)
		{
			for (sub = s2, s = s1; *sub && *s; sub++, s++)
			{
				WCHAR ms, msub;
				if (*s >= 'a' && *s <= 'z')	ms = *s - 0x20;
				else						ms = *s;
				if (*sub >= 'a' && *sub <= 'z') msub = *sub - 0x20;
				else							msub = *sub;
				if (ms != msub) break;
			}

			if (!*sub)
				return s1;
		}
	}
	return NULL;
}

LPWSTR RG_wcscpy(LPWSTR s1, LPCWSTR s2)
{
	LPWSTR cp = s1;
	while ((*cp++ = *s2++) != L'\0');

	return (s1);
}

LPWSTR RG_wcscat(LPWSTR s1, LPCWSTR s2)
{
	LPWSTR cp = s1;
	while (*cp != L'\0')
		cp++;
	while ((*cp++ = *s2++) != L'\0');

	return (s1);
}
```

`RebirthGuard/RebirthGuard/util.cpp`:

```cpp

/*
	chztbby::RebirthGuard/util.cpp
*/

#include "RebirthGuard.h"

LPWSTR RG_GetModulePath(DWORD module_index)
{
	static WCHAR module_path[MODULE_LAST + 1][MAX_PATH] = { 0, };

	if (!module_path[module_index][0])
	{
		LDR_MODULE module_info = { 0, };
		for (DWORD i = MODULE_FIRST; i <= module_index; i++)
			RG_GetNextModule(&module_info);

		RG_wcscpy(module_path[module_index], module_info.FullDllName.Buffer);
	}

	return module_path[module_index];
}

LPCWSTR RG_GetModulePath(PVOID hmodule)
{
	LDR_MODULE module_info = { 0, };
	while (RG_GetNextModule(&module_info))
	{
		if (hmodule == module_info.BaseAddress)
			return module_info.FullDllName.Buffer;
	}

	return NULL;
}

PVOID RG_GetNextModule(PLDR_MODULE pmodule_info)
{
	PLDR_MODULE flink;
	if (!pmodule_info->BaseAddress)
	{
#ifdef _WIN64
		PTEB teb = (PTEB)__readgsqword(0x30);		
#else
		PTEB teb = (PTEB)__readfsdword(0x18);
#endif
		flink = (PLDR_MODULE)teb->Peb->LoaderData->InMemoryOrderModuleList.Flink;
		
	}
	else
	{
		flink = (PLDR_MODULE)pmodule_info->InMemoryOrderModuleList.Flink;
	}

	PLDR_MODULE base = (PLDR_MODULE)GetPtr(flink, GetOffset(&flink->InMemoryOrderModuleList, flink));
	*pmodule_info = *base;

	return pmodule_info->BaseAddress;
}

VOID RG_HideModule(PVOID hmodule)
{
#if IS_ENABLED(RG_OPT_HIDE_MODULE)
#ifdef _WIN64
	PTEB teb = (PTEB)__readgsqword(0x30);
#else
	PTEB teb = (PTEB)__readfsdword(0x18);
#endif
	for (PLIST_ENTRY node = teb->Peb->LoaderData->InLoadOrderModuleList.Flink; node; node = node->Flink)
	{
		if (((PLDR_MODULE)node)->BaseAddress == hmodule)
		{
			node->Blink->Flink = node->Flink;
			node->Flink->Blink = node->Blink;
			break;
		}
	}
#endif
}

PVOID RG_GetApi(LPCSTR api_name, DWORD module_index)
{
    if (module_index)
        return RG_GetProcAddress(RG_GetModuleHandleW(RG_GetModulePath(module_index)), api_name);

    PVOID api = RG_GetProcAddress(RG_GetModuleHandleW(RG_GetModulePath(MODULE_NTDLL)), api_name);
    if (!api)
        api = RG_GetProcAddress(RG_GetModuleHandleW(RG_GetModulePath(MODULE_KERNELBASE)), api_name);
    if (!api)
        api = RG_GetProcAddress(RG_GetModuleHandleW(RG_GetModulePath(MODULE_KERNEL32)), api_name);

    return api;
}

HMODULE RG_GetModuleHandleW(LPCWSTR module_path)
{
	LDR_MODULE module_info = { 0, };
	while (RG_GetNextModule(&module_info))
	{
		if (!module_path)
			return module_info.BaseAddress;

		if (RG_wcsistr(module_path, module_info.BaseDllName.Buffer))
			return module_info.BaseAddress;
	}

	return NULL;
}

PVOID RG_GetProcAddress(HMODULE hmodule, LPCSTR proc_name)
{
	PIMAGE_NT_HEADERS pnh = GetNtHeader(hmodule);
	PIMAGE_DATA_DIRECTORY pdd = &pnh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	PIMAGE_EXPORT_DIRECTORY ped = (PIMAGE_EXPORT_DIRECTORY)GetPtr(hmodule, pdd->VirtualAddress);

	PDWORD func_table = (PDWORD)GetPtr(hmodule, ped->AddressOfFunctions);
	PWORD ordinal_table = (PWORD)GetPtr(hmodule, ped->AddressOfNameOrdinals);

	if ((DWORD_PTR)proc_name <= 0xFFFF)
	{
		WORD ordinal = (WORD)IMAGE_ORDINAL((DWORD_PTR)proc_name);
		ordinal -= (WORD)ped->Base;
		if (ordinal < ped->NumberOfFunctions)
			return GetPtr(hmodule, func_table[ordinal]);
	}
	else
	{
		PDWORD func_name_table = (PDWORD)GetPtr(hmodule, ped->AddressOfNames);
		for (DWORD i = 0; i < ped->NumberOfNames; ++i)
			if (!RG_strcmp(proc_name, (LPCSTR)GetPtr(hmodule, func_name_table[i])))
				return GetPtr(hmodule, func_table[ordinal_table[i]]);
	}
	return NULL;
}

HANDLE RG_CreateThread(HANDLE process, PVOID entry, PVOID param)
{
	HANDLE thread = NULL;
	APICALL(NtCreateThreadEx)(&thread, MAXIMUM_ALLOWED, NULL, process, entry, param, NULL, NULL, NULL, NULL, NULL);
	return thread;
}

PVOID RG_AllocMemory(PVOID ptr, SIZE_T size, DWORD protect)
{
	APICALL(NtAllocateVirtualMemory)(CURRENT_PROCESS, &ptr, NULL, &size, MEM_COMMIT | MEM_RESERVE, protect);
	return ptr;
}

VOID RG_FreeMemory(PVOID ptr)
{
	MEMORY_BASIC_INFORMATION mbi;
	RG_QueryMemory(ptr, &mbi, sizeof(mbi), MemoryBasicInformation);

	if (mbi.Type == MEM_PRIVATE)
		APICALL(NtFreeVirtualMemory)(CURRENT_PROCESS, &mbi.AllocationBase, &mbi.RegionSize, MEM_RELEASE);
	else
		APICALL(NtUnmapViewOfSection)(CURRENT_PROCESS, mbi.AllocationBase);
}

DWORD RG_ProtectMemory(PVOID ptr, SIZE_T size, DWORD protect)
{
	DWORD old = NULL;
	APICALL(NtProtectVirtualMemory)(CURRENT_PROCESS, &ptr, &size, protect, &old);
	return old;
}

NTSTATUS RG_QueryMemory(PVOID ptr, PVOID buffer, SIZE_T buffer_size, MEMORY_INFORMATION_CLASS type)
{
	return APICALL(NtQueryVirtualMemory)(CURRENT_PROCESS, ptr, type, buffer, buffer_size, NULL);
}

LONG WINAPI RG_ExceptionHandler(PEXCEPTION_POINTERS e)
{
#if IS_ENABLED(RG_OPT_ANTI_DEBUGGING)
	DebugCallback(e);
#endif
	return EXCEPTION_CONTINUE_SEARCH;
}

VOID RG_SetCallbacks()
{
	APICALL(RtlAddVectoredExceptionHandler)(1, RG_ExceptionHandler);

	PVOID cookie = NULL;
	APICALL(LdrRegisterDllNotification)(NULL, DllCallback, NULL, &cookie);
	cookie = NULL;
}

BOOL IsExe(PVOID hmodule)
{
	return !(GetNtHeader(hmodule)->FileHeader.Characteristics & IMAGE_FILE_DLL);
}

PVOID GetCurrentThreadStartAddress()
{
	PVOID start_address = NULL;
	APICALL(NtQueryInformationThread)(CURRENT_THREAD, (THREADINFOCLASS)ThreadQuerySetWin32StartAddress, &start_address, sizeof(start_address), 0);

	return start_address;
}

VOID CopyPeData(PVOID dst, PVOID src, PE_TYPE src_type)
{
	PIMAGE_NT_HEADERS nt = GetNtHeader(src);
	PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(nt);

	memcpy(dst, src, nt->OptionalHeader.SizeOfHeaders);

	for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; i++)
	{
		if (src_type == PE_TYPE_IMAGE)
			memcpy(GetPtr(dst, sec[i].VirtualAddress), GetPtr(src, sec[i].VirtualAddress), sec[i].Misc.VirtualSize);

		if (src_type == PE_TYPE_FILE)
			memcpy(GetPtr(dst, sec[i].VirtualAddress), GetPtr(src, sec[i].PointerToRawData), sec[i].SizeOfRawData);
	}
}
```

`RebirthGuard/RebirthGuard/verifying.cpp`:

```cpp

/*
	chztbby::RebirthGuard/verifying.cpp
*/

#include "RebirthGuard.h"


BOOL IsRebirthed(PVOID module_base)
{
	PIMAGE_NT_HEADERS nt = GetNtHeader(module_base);
	PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(nt);

    for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; ++i)
    {
        MEMORY_BASIC_INFORMATION mbi;
        RG_QueryMemory(GetPtr(module_base, sec[i].VirtualAddress), &mbi, sizeof(mbi), MemoryBasicInformation);

        PSAPI_WORKING_SET_EX_INFORMATION wsi;
        wsi.VirtualAddress = mbi.AllocationBase;
        RG_QueryMemory(nullptr, &wsi, sizeof(wsi), MemoryWorkingSetExInformation);

        if (!wsi.VirtualAttributes.Locked)
            return FALSE;
    }

	return TRUE;
}

PVOID GetModuleBaseFromPtr(PVOID ptr, PTR_CHECK type)
{
	LDR_MODULE module_info = { 0, };
	for (DWORD i = 0; RG_GetNextModule(&module_info); ++i)
	{
		PVOID module_base = module_info.BaseAddress;
		PIMAGE_NT_HEADERS nt = GetNtHeader(module_base);
		PVOID sptr;
		PVOID eptr;

		if (type == PC_EXECUTABLE)
		{
			PIMAGE_SECTION_HEADER sec = IMAGE_FIRST_SECTION(nt);
			for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; ++i)
			{
                if (sec[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
                {
					sptr = GetPtr(module_base, sec[i].VirtualAddress);
					eptr = GetPtr(sptr, sec[i].Misc.VirtualSize);
                    if (sptr <= ptr && ptr < eptr)
                        return module_base;
				}
			}
		}

		if (type == PC_IMAGE_SIZE)
		{
			sptr = module_base;
			eptr = GetPtr(sptr, nt->OptionalHeader.SizeOfImage);
			if (sptr <= ptr && ptr < eptr)
				return module_base;
		}
	}

	return nullptr;
}

BOOL IsSameFunction(PVOID f1, PVOID f2)
{
	DWORD count = 0, i = 0;

	for (; *((BYTE*)f1 + i) != 0xCC; i++)
		if (*((BYTE*)f1 + i) == *((BYTE*)f2 + i))
			count++;

	return count == i;
}

VOID CheckThread(PVOID start_address, THREAD_CHECK type)
{
#if IS_ENABLED(RG_OPT_ANTI_DEBUGGING)
	APICALL(NtSetInformationThread)(CURRENT_THREAD, ThreadHideFromDebugger, NULL, NULL);
#endif

	if (IS_ENABLED(RG_OPT_THREAD_CHECK) || (type == TC_DllCallback && IS_ENABLED(RG_OPT_ANTI_DLL_INJECTION)))
	{
		if (!GetModuleBaseFromPtr(start_address, PC_EXECUTABLE))
			RG_Report(type == TC_DllCallback ? RG_OPT_ANTI_DLL_INJECTION : RG_OPT_THREAD_CHECK, REPORT_THREAD_START_ADDRESS, start_address, (PVOID)(SIZE_T)type);

		MEMORY_BASIC_INFORMATION mbi;
		RG_QueryMemory(start_address, &mbi, sizeof(mbi), MemoryBasicInformation);

		if (mbi.Protect == PAGE_EXECUTE_READWRITE || mbi.Protect == PAGE_EXECUTE_WRITECOPY)
			RG_Report(type == TC_DllCallback ? RG_OPT_ANTI_DLL_INJECTION : RG_OPT_THREAD_CHECK, REPORT_THREAD_PROTECTION, start_address, (PVOID)(SIZE_T)type);
	}

#if IS_ENABLED(RG_OPT_ANTI_DLL_INJECTION)
	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNEL32, LoadLibraryA), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNEL32_LoadLibraryA, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNEL32, LoadLibraryW), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNEL32_LoadLibraryW, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNEL32, LoadLibraryExA), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNEL32_LoadLibraryExA, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNEL32, LoadLibraryExW), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNEL32_LoadLibraryExW, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNELBASE, LoadLibraryA), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryA, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNELBASE, LoadLibraryW), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryW, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNELBASE, LoadLibraryExA), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryExA, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_KERNELBASE, LoadLibraryExW), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_KERNELBASE_LoadLibraryExW, start_address, (PVOID)(SIZE_T)type);

	if (IsSameFunction(APICALL_FROM_MODULE(MODULE_NTDLL, LdrLoadDll), start_address))
		RG_Report(RG_OPT_ANTI_DLL_INJECTION, REPORT_DLL_INJECTION_NTDLL_LdrLoadDll, start_address, (PVOID)(SIZE_T)type);
#endif
}

VOID CheckMemory()
{
#if IS_ENABLED(RG_OPT_MEMORY_CHECK)
	for (PVOID ptr = 0; ptr < (PVOID)MEMORY_END;)
	{
		MEMORY_BASIC_INFORMATION mbi;
		RG_QueryMemory(ptr, &mbi, sizeof(mbi), MemoryBasicInformation);

		if (mbi.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY) && !GetModuleBaseFromPtr(ptr, PC_IMAGE_SIZE))
        {
            BYTE buffer[PAGE_SIZE] = { 0, };
            NTSTATUS ns = RG_QueryMemory(ptr, buffer, sizeof(buffer), MemoryMappedFilenameInformation);
			if (!NT_SUCCESS(ns))
				RG_Report(RG_OPT_MEMORY_CHECK, REPORT_MEMORY_SUSPICIOUS, ptr, (PVOID)(SIZE_T)mbi.Protect);
        }

		ptr = GetPtr(ptr, mbi.RegionSize);
	}

	for (DWORD i = 0; rgdata->rmi[i].module_base; i++)
	{
        PVOID module_base = rgdata->rmi[i].module_base;
		if (!IsRebirthed(module_base))
			RG_Report(RG_OPT_MEMORY_CHECK, REPORT_MEMORY_UNLOCKED, module_base, 0);
	}
#endif
}

VOID CheckCRC()
{
#if IS_ENABLED(RG_OPT_INTEGRITY_CHECK)
	LDR_MODULE module_info = { 0, };

	for (DWORD i = 0; RG_GetNextModule(&module_info); i++)
	{
		PVOID module_base = module_info.BaseAddress;
		LPWSTR module_path = module_info.FullDllName.Buffer;

		MEMORY_BASIC_INFORMATION mbi;
		RG_QueryMemory(module_base, &mbi, sizeof(mbi), MemoryBasicInformation);

		if (!(mbi.Protect & PAGE_WRITECOPY))
		{
#if IS_ENABLED(RG_OPT_INTEGRITY_CHECK_HIDE_FROM_DEBUGGER)
			for (int i = 0;; i++)
			{
				if (!rgdata->rmi[i].module_base)
					RG_Report(RG_OPT_INTEGRITY_CHECK, REPORT_INTEGRITY_SECTION_CHECK, module_base, 0);

				if (rgdata->rmi[i].module_base == module_base)
				{
					LARGE_INTEGER section_offset;
					section_offset.QuadPart = NULL;
					PIMAGE_NT_HEADERS nt = GetNtHeader(module_base);
					SIZE_T view_size = nt->OptionalHeader.SizeOfImage;

					module_base = NULL;
					while (!module_base)
					{
						module_base = NULL;
						APICALL(NtMapViewOfSection)(rgdata->rmi[i].section, CURRENT_PROCESS, &module_base, NULL, NULL, &section_offset, &view_size, ViewUnmap, SEC_NO_CHANGE, PAGE_READONLY);
					}

					break;
				}
			}
#endif
			PVOID mapped_module = ManualMap(module_path);
#ifdef _WIN64
#if IS_ENABLED(RG_OPT_THREAD_CHECK)
			if (i == MODULE_NTDLL)
			{
				SIZE_T RtlUserThreadStart_offset = GetOffset(RG_GetModuleHandleW(RG_GetModulePath(MODULE_NTDLL)), APICALL(RtlUserThreadStart));
				BYTE jmp_myRtlUserThreadStart[14] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, };
				*(PVOID*)(jmp_myRtlUserThreadStart + 6) = ThreadCallback;
				for (DWORD i = 0; i < 14; i++)
					*(BYTE*)GetPtr(mapped_module, RtlUserThreadStart_offset + i) = jmp_myRtlUserThreadStart[i];
			}
#endif
#else
#if IS_ENABLED(RG_OPT_THREAD_CHECK)

#endif
#endif
			(GetNtHeader(mapped_module))->OptionalHeader.ImageBase = (SIZE_T)RG_GetModuleHandleW(module_path);

			if (CRC64(module_base) != CRC64(mapped_module))
				RG_Report(RG_OPT_INTEGRITY_CHECK, REPORT_INTEGRITY_CRC64_CHECK, module_base, 0);

#if IS_ENABLED(RG_OPT_INTEGRITY_CHECK_HIDE_FROM_DEBUGGER)
			APICALL(NtUnmapViewOfSection)(CURRENT_PROCESS, module_base);
#endif

			RG_FreeMemory(mapped_module);
		}
	}
#endif
}
```

`RebirthGuard/SampleDLL/SampleDLL.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{72588e16-75ab-485c-a5ff-a3162cecef8c}</ProjectGuid>
    <RootNamespace>SampleDLL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <LibraryPath>$(SolutionDir)$(Platform)\$(Configuration)\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)$(Platform)\$(Configuration)\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`RebirthGuard/SampleDLL/SampleDLL.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`RebirthGuard/SampleDLL/SampleDLL.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`RebirthGuard/SampleDLL/main.cpp`:

```cpp

#include <Windows.h>
#include <stdio.h>
#include "../RebirthGuard/RebirthGuardSDK.h"
#pragma comment (lib, "RebirthGuard.lib")

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		printf(RGS("Hello RebirthGuard SampleDLL!\n"));
		break;

	case DLL_THREAD_ATTACH:
		break;

	case DLL_THREAD_DETACH:
		break;

	case DLL_PROCESS_DETACH:
		break;
	}

    return TRUE;
}
```

`RebirthGuard/SampleEXE/SampleEXE.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{36574BD3-F3EB-4359-97FF-3C80F2106257}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>SampleEXE</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>SampleEXE</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)$(Platform)\$(Configuration)\;$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)$(Platform)\$(Configuration)\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)$(Platform)\$(Configuration)\;$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)$(Platform)\$(Configuration)\;$(LibraryPath)</LibraryPath>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`RebirthGuard/SampleEXE/SampleEXE.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`RebirthGuard/SampleEXE/SampleEXE.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`RebirthGuard/SampleEXE/main.cpp`:

```cpp

#include <Windows.h>
#include <stdio.h>
#include "../RebirthGuard/RebirthGuardSDK.h"
#pragma comment (lib, "RebirthGuard.lib")

int main(void)
{
	printf(RGS("Hello RebirthGuard SampleEXE!\n"));

	LoadLibraryA(RGS("SampleDLL.dll"));

	getchar();

	return 0;
}
```

`readme.md`:

```md
# RebirthGuard

### Anti-cheat library for Windows C++

## :page_facing_up: Features
* __Module remapping__
* __Thread filtering__
* __Module hiding__
* __Memory check__
* __Integrity check__
* __Anti-DLL Injection__
* __Anti-Debugging__
* __Process policy__
* __Literal string obfuscation__
* __Compatibility with Themida/VMProtect__

## :heavy_check_mark: Dependencies
* Windows 7~11
* Visual Studio 2019

## :wrench: How to use
1. Set options in `options.h` and build *RebirthGuard*.
2. Include `RebirthGuardSDK.h` and link `RebirthGuard.lib` in your project.
3. Build your project.

## :memo: Example
```CPP
#include <Windows.h>
#include <stdio.h>
#include "../RebirthGuard/RebirthGuardSDK.h"
#pragma comment (lib, "RebirthGuard.lib")

int main(void)
{
	printf(RGS("Hello RebirthGuard SampleEXE!\n"));

	LoadLibraryA(RGS("SampleDLL.dll"));

	getchar();

	return 0;
}
```

## :mag: References
* [Self-Remapping-Code](https://github.com/changeofpace/Self-Remapping-Code)
* [Manual-DLL-Injection](http://www.rohitab.com/discuss/topic/40761-manual-dll-injection/)
```