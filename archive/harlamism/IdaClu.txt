Project Path: arc_harlamism_IdaClu_7nunnza5

Source Tree:

```txt
arc_harlamism_IdaClu_7nunnza5
├── LICENSE
├── README.md
├── idaclu
│   ├── __init__.py
│   ├── assets
│   │   ├── __init__.py
│   │   ├── arrow_32.png
│   │   ├── i18n
│   │   │   ├── tr.pro
│   │   │   ├── tr_zh.qm
│   │   │   └── tr_zh.ts
│   │   ├── icon_64.png
│   │   ├── resource.py
│   │   ├── resource.qrc
│   │   ├── save_0_64.png
│   │   ├── save_1_64.png
│   │   └── style.qss
│   ├── ida_shims.py
│   ├── ida_utils.py
│   ├── idaclu.ui
│   ├── idaclu_gui.py
│   ├── models.py
│   ├── plg_utils.py
│   ├── plugins
│   │   ├── group_1
│   │   │   ├── __init__.py
│   │   │   ├── plugin_1.py
│   │   │   ├── plugin_2.py
│   │   │   └── plugin_3.py
│   │   ├── group_2
│   │   │   ├── __init__.py
│   │   │   ├── plugin_1.py
│   │   │   ├── plugin_2.py
│   │   │   ├── plugin_3.py
│   │   │   ├── plugin_4.py
│   │   │   ├── plugin_5.py
│   │   │   ├── plugin_6.py
│   │   │   ├── plugin_7.py
│   │   │   ├── winapi_malware.json
│   │   │   └── winapi_semantics.json
│   │   ├── group_3
│   │   │   ├── __init__.py
│   │   │   ├── plugin_1.py
│   │   │   └── plugin_2.py
│   │   ├── group_4
│   │   │   ├── __init__.py
│   │   │   ├── drcov.py
│   │   │   └── plugin_1.py
│   │   ├── group_5
│   │   │   ├── __init__.py
│   │   │   ├── plugin_1.py
│   │   │   └── plugin_2.py
│   │   ├── group_6
│   │   │   ├── __init__.py
│   │   │   ├── plugin_1.py
│   │   │   ├── plugin_2.py
│   │   │   ├── plugin_3.py
│   │   │   ├── plugin_4.py
│   │   │   ├── plugin_5.py
│   │   │   └── plugin_6.py
│   │   ├── group_7
│   │   │   ├── __init__.py
│   │   │   ├── plugin_1.py
│   │   │   ├── plugin_2.py
│   │   │   ├── plugin_3.py
│   │   │   └── plugin_4.py
│   │   ├── group_8
│   │   │   ├── __init__.py
│   │   │   ├── helpers.py
│   │   │   ├── ngrams.py
│   │   │   ├── plugin_1.py
│   │   │   ├── plugin_2.py
│   │   │   ├── plugin_3.py
│   │   │   ├── plugin_4.py
│   │   │   ├── plugin_5.py
│   │   │   ├── plugin_6.py
│   │   │   └── plugin_7.py
│   │   └── group_9
│   │       ├── __init__.py
│   │       └── plugin_1.py
│   ├── qt_shims.py
│   ├── qt_utils.py
│   ├── qt_widgets.py
│   └── ui_idaclu.py
├── idaclu.py
└── img
    ├── miss.png
    ├── shot.png
    └── ui.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Sergejs Harlamovs

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IdaClu

***IdaClu*** is an ***IDA Pro*** plugin with a straightforward 3-step loop pipeline:

1. Find similarities in functions;
2. Label grouped functions in bulk;
3. Repeat step 1 for labeled functions.

The distinctive feature of the plugin lies in ***"how"*** of search and labeling.

***IdaClu*** won ***1st*** place in [***the Hex-Rays Plugin Contest 2023***](https://hex-rays.com/contests_details/contest2023/) !

![shot](./img/shot.png)

## The Purpose

In addition to the plugin ecosystem, the ***IDA*** user community creates a wealth of incredible scripts, varying in complexity. Some could greatly benefit from standardized input/output data format and *GUI*-interface. However, due to time constraints, the relative complexity of learning ***PyQt/PySide***, and the challenge of navigating several backward-incompatible versions of the ***IDAPython API*** many community members are unable to support these efforts. As a result, even the best of us sometimes resort to parsing custom data formats from text files or *output window* of ***IDA***.

***IdaClu*** serves as a ***tree/table view*** for ***IDAPython*** scripts.  
Providing the following features:

- labeling the functions with any combination of *prefix-folder-color*
- filtering the input/output
- using the progress bar indicator
- using the output of other scripts
- providing the output to other scripts

***IDAPython***-scripts serve as *sub-plugins* for ***IdaClu*** if they follow several conventions of how the script should be structured. One core intention is to minimize this impact.

*The plugin* comes with a set of *x18* simplistic and handy scripts available out of the box. They form the basis and make ***IdaClu*** useful as a standalone tool. So support of the community is not a "must".

## Standard Scripts

Scripts are grouped, and while most names are self-explanatory, some may need explanations:

- **Xref Analysis**
  - **Xref Count** - *group by code-xref count*
  - **Xref Source** - *groups: leaf functions, functions with only explicit calls, functions with virtual calls*
  - **Xref Destination** - *groups: independent functions, VFT-functions, library called functions*
- **Constant Analysis**
  - **Common Constants** - *group by constants being referenced*
  - **String Refs** - *group by string refs*
  - **Global Variable Analysis** - *group by refs of defined names*
  - **Lib Usage Analysis** - *group by library function calls*
  - **API Usage Analysis** - *group by API-function calls*
- **Control Flow**
  - **Control Flow Analysis** - *groups: loop-containing funcs, switch-case funcs, recursive funcs*
  - **Pseudocode Size** - *group by pseudocode line count*
- **Code Coverage**
  - **DynamoRIO Functions** - *groups: touched/untouched functions*
- **Function Similarity**
  - **SSDEEP Similarity** - *groups: similar function clusters with **ssdeep***
  - **TLSH Similarity** - *groups: similar function clusters with **tlsh***
- **Virtual Functions**
  - **Explicit Calls** - *group by function call with arguments shown in comments*
  - **Implicit Calls** - *group by VFT-function call with arguments shown in comments*
- **Filter Analysis**
  - **Distinct Folders** - *group by folder path*
  - **Distinct Prefixes** - *group by prefix name*
  - **Distinct Colors** - *group by highlight color*

## User Interface

![ui](./img/ui.png)
The user interface intentionally follows [***Miller's Law***](https://en.wikipedia.org/wiki/Miller%27s_law) in *UX* - "The immediate memory span of people is limited to approximately seven items, plus or minus two."  
Here's the breakdown of the main widgets:

1. ***Toolkit*** - scrollable area with buttons for recognized ***IDAPython*** scripts
2. ***View*** - table-based view for script output, function selection, and rendering current labels
3. ***Filters*** - input controls to refine the chosen script's focus
4. ***Labels*** - name of *prefix* or *folder* for selected functions
   - ***R*** - toggle button for recursive mode
   - ***PREFIX*** - interactive label to switch between *FOLDER* and *PREFIX* labeling modes
   - ***ADD*** - button that applies labeling settings
   - ***CLEAR*** - button that clears labeling settings
5. ***Palette*** - a set of 5 mutually exclusive color highlighting buttons

### Tips

1. ***IdaClu*** aims to incorporate new features from new ***IDA***-versions while maintaining *version-agnostic* approach. The solution is *graceful degradation*. So the *UI* will adapt to older ***IDA*** versions, excluding unsupported features.
2. Double-clicking any row in the tree view navigates to the corresponding function in ***IDA***
3. The ***filter*** widget toggles collapse with a header click.
4. The ***toolkit*** widget header click swaps ***tree-view*** and ***sidebar*** with places.
5. ***Rename*** context-menu allows to make custom changes in the selected function name.

## Setup

***IdaClu*** is an ***IDAPython*** plugin without external package dependencies. No building is required. It can be installed by downloading the repository and copying file ***idaclu.py*** and folder ***idaclu*** to your ***IDA Pro*** plugin directory *(either-or)*:

- *C:\Program Files\IDA Pro \<IDA_VERSION\>\plugins*
- *C:\Users\\<USER_NAME\>\AppData\Roaming\Hex-Rays\IDA Pro\plugins*

While the plugin itself doesn't need external packages, some *sub-plugin scripts* might. This won't prevent the plugin from running, but it will gray out the corresponding buttons with an informative tooltip - what's missing.

![miss](./img/miss.png)

Follow these instructions if you need these *sub-plugin scripts*:

- ***py-tlsh***

    ```bash
    > pip install py-tlsh
    ```

- ***ssdeep***

    ```bash
    # DO NOT: pip install ssdeep
    > git clone https://github.com/MacDue/ssdeep-windows-32_64
    > cd ssdeep-windows-32_64-master
    > python setup.py install
    ```

- ***yara-python***

    ```bash
    # IDA >v7.x
    > pip install yara-python
    # IDA v6.x
    > pip install yara-python==3.11.0
    ```

### Hint

For continuous updates, clone the repository with ***Git*** and create a ***symlink*** in the ***IDA*** plugin folder:

#### Windows

```sh
:: C:\Users\<username>\AppData\Roaming\Hex-Rays\IDA Pro\plugins\idaclu.py
> mklink "C:\Program Files\IDA Pro X.X\plugins\idaclu.py" <plugin_path>\idaclu.py

:: C:\Users\<username>\AppData\Roaming\Hex-Rays\IDA Pro\plugins\idaclu
> mklink /d "C:\Program Files\IDA Pro X.X\plugins\idaclu" <plugin_path>\idaclu
```

#### Mac

```sh
% ln -s <plugin_path>\idaclu.py /Users/<username>/.idapro/plugins/idaclu.py
% ln -s <plugin_path>\idaclu /Users/<username>/.idapro/plugins/idaclu
```

## Script Ecosystem

The plugin serves as a *GUI* for scripts without one. By following scripting conventions, you can make them compatible with ***IdaClu***. When done correctly, a corresponding button will appear in the ***sidebar***.

### Script Description

The following block is mandatory and is used to register the script in ***IdaClu***:

```python
SCRIPT_NAME = 'Xref Count'  # arbitrary name that will appear on the corresponding button
SCRIPT_TYPE = 'func'  # 'func' or 'custom' depending on whether the script iterates on functions or some other data structures to produce the output
SCRIPT_VIEW = 'tree'  # 'tree' is the only currently supported view, 'table' is to be added
SCRIPT_ARGS = []  # experimental feature, supports tuples of the form ('<control_name>', '<control_type>', '<control_placeholder>')
```

### Main Function

In addition to this, each script must define a single `get_data()` function.  
Currently there are *x2* possible prototypes:

```python
# Case #1: SCRIPT_TYPE == 'func':
def get_data(func_gen=None, env_desc=None, plug_params=None):
    # 1. Iterate over pre-filtered functions via func_gen() generator
    # 2. Progress bar values are calculated automatically
```

```python
# Case #2: SCRIPT_TYPE == 'custom':
def get_data(progress_callback=None, env_desc=None, plug_params=None):
    # 1. Iterate over custom data structures
    # 2. Use `progress_callback(<current_index>, <total_count>)` to report current progress
```

### Execution Environment

If the script logic depends on a specific IDA configuration, the ***IdaClu*** plugin can offer the following properties in the ***env_desc*** object:

```text
- feat_bookmarks
- feat_cpp_oop
- feat_folders
- feat_golang
- feat_ida6
- feat_ioi64
- feat_lumina
- feat_microcode
- feat_microcode_new
- feat_python3
- feat_undo
  ...
```

Before script execution, these fields are guaranteed to be initialized.  
You can refer to the full list in the ***output window*** of ***IDA***. Right under the ***banner*** there will be ***ENVIRONMENT*** section with the dump of current values.

### Custom Input

As an experimental feature, *the plugin* supports custom input for each script.
When defined, the following code will render the input field under the script button upon the first click:

```python
SCRIPT_ARGS = [('file_path', 'file', 'input the file path')]
```

The second click sends this data to the target script, accessible via the ***plug_params*** parameter of the ***get_data()*** function:

```python
plug_params['<control_name>']
```

### Return Value

For hierarchical output data, the script should return ***dictionary of lists***.  
*Keys* of this dictionary are function group names - collapsible elements of *tree view*.  
*Vals* of this dictionary are *either-or*:

- list of function addresses (simple case)
- list of tuples `(<function_address>, <comment>)` (advanced case)

### Remarks

However the rest is up to the author of the certain script,
there are several optional tips:

1. Each script should be assigned to a certain script group. A script group is essentially a folder - ***plugins/idaclu/plugins/\<plugin_group_folder\>/*** containing an ***\_\_init\_\_.py*** file with a single string:

    ```python
    PLUGIN_GROUP_NAME = '<arbitrary_name>'
    ```

2. For ***IDAPython*** cross-compatibility consider using bundled shims module:

    ```python
    from idaclu import ida_shims
    ```

3. If the script utilizes ***func-generator*** consider employing the following code for debugging and running the script even outside the ***IdaClu*** environment:

    ```python
    def debug():
        data_obj = get_data(func_gen=idautils.Functions)
        ida_shims.msg(json.dumps(data_obj, indent=4))

    if __name__ == '__main__':
        debug()
    ```

In case anything is left uncovered in this ***README***, refer to example scripts or contact the ***IdaClu*** author.

## Compatibility

**Recommended specs:** *IDA Pro v8.2+* with *Python v3.x*.  
**Minimum specs:** *IDA Pro v6.7+* with *Python v2.7+*.  

**Test environment:**

  1. *IDA Pro v6.7 + Windows 7*
  2. *IDA Pro v7.7 + Windows 10*
  3. *IDA Pro v8.2 + Windows 11*
  4. *IDA Pro v7.0, MacOS High Sierra v10.13.6*
  5. *IDA Pro v7.6, MacOS Ventura v13.2.1*

Other ***IDA*** versions can be added as test environments upon request.  
To be cross-compatible ***IdaClu*** relies on ***PyQt*** and ***IdaPython*** shims.  
Scripts bundled with ***IdaClu*** currently are ***PE-first*** and ***Intel x86/x64-first*** due to the author's work specifics.

## Upcoming Changes

- table view for the scripts that output non-hierarchical data
- several types of controls to provide input to scripts
- lots of code optimizations
- sort data in columns by clicking the column headers for tree/table view
- a more flexible API for the scripts
- more detailed IDA environment detection
- helper context menus for native IDA widgets
- filter refresh if changes to .idb were made outside the plugin
- grayed out narrow folder filters if they are subsumed by broader ones
- "save to file" option for the current view
- time estimation for large binaries
- caption of the processing phase in *UI*
- breakpoint setting feature
- count of functions currently selected
- folder labels with hierarchy
- button to clear all labels at once

Feel free to come up with your ideas/proposals.  
They will be carefully considered and their implementation is highly likely to be included in upcoming plugin releases.

## Known bugs

- Minor issues with cross-compatibility
- Comment column remains unhidden with empty comments
- Some bundled plugins produce quite dirty output:
  - *Global Variable Analysis*
- Some scripts and their corresponding groups do not match
- Experimental "Code Coverage" plugin fails to load
- Explicit folder filtering with `"/"` as a parameter does not work as expected
- Labels are still present in filters after being removed from .idb
- In recursive mode, the function can be prefixed multiple times
- Recursive mode is not considered while highlighting with color

## Acknowledgements

- [***Caroline 'By0ute' Beyne***](https://github.com/By0ute) for the simplistic [***PoC of collapsible PyQt widget***](https://github.com/By0ute/pyqt-collapsible-widget)
- [***Markus 'gaasedelen' Gaasedelen***](https://github.com/gaasedelen) for [***DrCov file format parser***](https://github.com/gaasedelen/lighthouse/blob/develop/plugins/lighthouse/reader/parsers/drcov.py)
- [***Willi Ballenthin***](https://gist.github.com/williballenthin) of *Mandiant* for [***PoC of PyQt-shim script***](https://gist.github.com/williballenthin/277eedca569043ef0984) to support both ***PySide (IDA <v6.9)*** and ***PyQt (IDA >=v6.9)***
- Guys from [***Gray Hat Academy***](https://github.com/grayhatacademy) for [***PoC of IDAPython-shim script***](https://github.com/grayhatacademy/ida/blob/master/plugins/shims/ida_shims.py) to support ***v6.x-v7.x*** versions of ***IDAPython API***
- [***mr.d0x***](https://github.com/mrd0x) for the original idea of ***Windows API*** classification demonstrated on [***MalAPI.io***](https://malapi.io/)

## Version History

- ***2024-04-2x*** - ChatGPT sub-plugins *(UPCOMING)*
- ***2024-03-2x*** - V-Table/RTTI related sub-plugins *(UPCOMING)*
- ***2024-03-09*** - Release of upgraded *v1.1*
- ***2023-12-09*** - Obfuscation detection sub-plugins
- ***2023-12-01*** - Release of more stable *v1.0*
- ***2023-09-14*** - The original release of ***IdaClu*** *v0.9*!
```

`idaclu.py`:

```py
#!/usr/bin/python
###############################################################
# Copyright (c) 2023
# Sergejs 'HRLM' Harlamovs <harlamism<at>gmail<dot>com>
# Licensed under the MIT License. All rights reserved.
###############################################################

import collections
import json
import os
import sys

lib_qt = None
try:
    from PyQt5 import QtCore, QtGui, QtWidgets
    lib_qt = "pyqt5"
except ImportError:
    try:
        from PySide import QtCore, QtGui
        from PySide import QtGui as QtWidgets
        lib_qt = "pyside"
    except ImportError:
        pass


# make sub-plugins discoverable
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
for i, path in enumerate(sys.path):
    if "IDA" in path and os.path.basename(path) == 'plugins':
        sys.path.insert(i, SCRIPT_DIR)
        break


is_ida = True
try:  # almost version-agnostic imports
    import idc
    import idaapi
    from idaapi import plugin_t, PluginForm
    from idaclu import ida_shims
except ImportError:
    is_ida = False

    # standalone-run caps
    class plugin_t:
        pass
    class PluginForm:
        pass

from idaclu.qt_shims import (
    QCoreApplication,
    QIcon,
    QMessageBox,
    QTranslator
)
from idaclu import idaclu_gui
from idaclu.assets import resource



class ScriptEnv():
    def __init__(self, is_ida, lib_qt):
        # generic environment
        self.is_ida = is_ida
        self.lib_qt = lib_qt
        self.run_mode = 'script'
        self.dir_script = SCRIPT_DIR
        self.ver_py = sys.version_info[0]
        # ida-specific environment
        self.detectEnv()

    def __repr__(self):
        return self.get_dump(is_banner=True)

    def dump(self, is_banner=False):
        d_text = self.get_dump(is_banner=is_banner)
        if self.is_ida:
            ida_shims.msg(d_text)
        else:
            print(d_text)

    def get_dump(self, is_banner=False):
        env_repr = []
        if is_banner:
            env_repr.append(self.get_banner())

        env_repr.append('ENVIRONMENT\n')
        for prop in collections.OrderedDict(sorted(self.__dict__.items())):
            value = getattr(self, prop)
            if isinstance(value, list):
                for i, v in enumerate(value):
                    dots = '.' * (80 - (len(prop) + len(str(v))) + 4)
                    prop = " " * len(prop) if i > 0 else prop
                    env_repr.append("{} {} {}".format(prop, dots, v))
            else:
                dots = '.' * (80 - (len(prop) + len(str(value))) + 4)
                env_repr.append("{} {} {}".format(prop, dots, value))
        env_repr.append('\n')
        return "\n".join(env_repr)

    def get_banner(self):
        banner = "                                      \n" \
               + "     ____    __      ________         \n" \
               + "    /  _/___/ /___ _/ ____/ /_  __    \n" \
               + "    / // __  / __ `/ /   / / / / /    \n" \
               + "  _/ // /_/ / /_/ / /___/ / /_/ /     \n" \
               + " /___/\__,_/\__,_/\____/_/\__,_/      \n" \
               + "         by Sergejs Harlamovs         \n" \
               + "                                      \n"
        return banner

    def get_script_mode(self):  # in case of certainty of IDA environment
        mode = 'script'
        if idaapi.IDA_SDK_VERSION >= 720:
            if __name__ == "__main__":
                mode = "script"
            elif __name__.startswith('__plugins__'):
                # __plugins__<plugin_script_name>, ex.: __plugins__idaclu
                mode = "plugin"
        else:
            # maybe even more preferrable way of determining
            # if the plugin was run "as a plugin" or "as a script" -
            # location in one of default plugin directories
            plugin_dirs = ida_shims.get_ida_subdirs('plugins')
            if SCRIPT_DIR in plugin_dirs:
                mode = 'plugin'
            else:
                mode = 'script'
        return mode

    def get_plugin_ort(self):
        plg_dst = None
        plg_scope = 'None'
        g_plg_path = os.path.join(self.dir_plugin[0], 'idaclu')
        l_plg_path = os.path.join(self.dir_plugin[1], 'idaclu')
        if os.path.isdir(g_plg_path):
            plg_dst = self.dir_plugin[0]
            plg_scope = 'global'
        elif os.path.isdir(l_plg_path):
            plg_dst = self.dir_plugin[1]
            plg_scope = 'local'
        plg_src = os.path.dirname(os.path.realpath(os.path.join(plg_dst, 'idaclu')))
        plg_type = 'copy' if plg_dst == plg_src else 'link'
        return (plg_dst, plg_src, plg_scope, plg_type)

    def detectEnv(self):
        if self.is_ida:
            self.ver_sdk = idaapi.IDA_SDK_VERSION
            self.ida_sample = ida_shims.get_input_file_path()
            ##
            self.dir_plugin = ida_shims.get_ida_subdirs("plugins")
            # self.dir_script
            self.feat_bookmarks = self.ver_sdk >= 760
            self.feat_cpp_oop = self.ver_sdk >= 720
            # C++ class hierarchy and virtual function recognition
            self.feat_folders = self.ver_sdk >= 750
            self.feat_golang = self.ver_sdk >= 760
            self.feat_ida6 = self.ver_sdk < 740
            # Point at which IDA v6.95 compatibility APIs was off
            self.feat_ioi64 = self.ver_sdk >= 820
            # "IdaOnIda64" - decompiling of 32-bit files in IDA64
            self.feat_lumina = self.ver_sdk >= 720
            self.feat_microcode = self.ver_sdk >= 710
            self.feat_microcode_new = self.ver_sdk >= 720
            # Microcode feature was introduced in v7.1, improved in v7.2
            self.feat_python3 = self.ver_sdk >= 740
            self.feat_undo = self.ver_sdk >= 730
            self.ida_arch = "x64" if idc.__EA64__ else "x86"
            self.ida_exe = sys.executable
            self.ida_kernel = idaapi.get_kernel_version()
            self.ida_module = os.path.basename(self.ida_sample) if self.ida_sample else None
            self.idb_path = ida_shims.get_idb_path()
            self.is_dbg = idaapi.is_debugger_on()
            # self.is_ida
            self.lib_qt = self.lib_qt = "pyside" if self.ver_sdk < 690 else "pyqt5"
            self.platform = sys.platform
            plg_dst, plg_src, plg_scope, plg_type = self.get_plugin_ort()
            self.plg_dst = plg_dst
            self.plg_src = plg_src
            self.plg_scope = plg_scope
            self.plg_type = plg_type
            self.run_mode = self.get_script_mode()
            self.ver_hexrays = idaapi.get_hexrays_version() if idaapi.init_hexrays_plugin() else None
            # self.ver_py

def common_init():
    env_desc = ScriptEnv(is_ida, lib_qt)
    return env_desc


__AUTHOR__ = "Sergejs 'HRLM' Harlamovs"

PLUGIN_NAME = "IdaClu"
PLUGIN_HOTKEY = 'Ctrl+Alt+O'
PLUGIN_VERSION = '1.1'
PLUGIN_TITLE = '{0} v{1}'.format(PLUGIN_NAME, PLUGIN_VERSION)
PLUGIN_URL = "https://github.com/harlamism/IdaClu"
PLUGIN_INFO = 'For usage see: <a href="{0}">{0}</a>'.format(PLUGIN_URL)

class IdaCluForm(PluginForm):
    def __init__(self, env_desc):
        super(IdaCluForm, self).__init__()
        self.env_desc = env_desc
        self.icon = QIcon(':/idaclu/icon_64.png')
        self.qss = os.path.join(SCRIPT_DIR, 'idaclu', 'assets', 'style.qss')

    def OnCreate(self, form):
        self.env_desc.dump(True)

        app = QCoreApplication
        translator = QTranslator()
        translator.load('idaclu/assets/i18n/tr_cn', os.path.dirname(__file__))
        app.installTranslator(translator)

        if self.env_desc.lib_qt == 'pyqt5':
            self.parent = self.FormToPyQtWidget(form)
        elif self.env_desc.lib_qt == 'pyside':
            self.parent = self.FormToPySideWidget(form)
        self.parent.setWindowTitle(PLUGIN_TITLE)
        self.parent.setWindowIcon(self.icon)
        self.dialog = idaclu_gui.IdaCluDialog(self.env_desc)
        # environment footprint is passed deeper
        self.dialog.setStyleSheet(open(self.qss).read())
        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.dialog)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        self.parent.setLayout(layout)

    def OnClose(self, form):
        pass


def open_form(env_desc):
    if env_desc.is_ida:
        f = IdaCluForm(env_desc)
        f.Show('IdaClu')

def PLUGIN_ENTRY():
    return IdaCluPlugin()

class IdaCluPlugin(plugin_t):
    flags = idaapi.PLUGIN_UNL
    comment = "Function Clusterization Tool"
    help = "Edit->Plugin->IdaClu or {}.".format(PLUGIN_HOTKEY)
    wanted_name = PLUGIN_NAME
    wanted_hotkey = PLUGIN_HOTKEY

    def init(self):
        super(IdaCluPlugin, self).__init__()
        self.icon_id = 0
        ida_shims.msg("%s %s loaded\n" % (self.wanted_name, PLUGIN_VERSION))
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        env_desc = common_init()
        open_form(env_desc)
        return

    def term(self):
        pass


def main(env_desc):
    env_desc.dump(True)
    if env_desc.is_ida:
        open_form(env_desc)
    else:
        app = QtWidgets.QApplication(sys.argv) if not is_ida else None
        if app:
            sys.exit(app.exec_())

if __name__ == "__main__":
    env_desc = common_init()
    if env_desc.run_mode == 'script':
        if not ida_shims.get_input_file_path():
            QMessageBox.information(None, "File Missing", "Please load a file in IDA first, then run script again.")
        else:
            main(env_desc)

    if not is_ida:
        main(env_desc)

```

`idaclu/assets/i18n/tr.pro`:

```pro
SOURCES += ../../qt_widgets.py \
../../ui_idaclu.py \
../../plugins/group_1/__init__.py \
../../plugins/group_1/plugin_1.py \
../../plugins/group_1/plugin_2.py \
../../plugins/group_1/plugin_3.py \
../../plugins/group_2/__init__.py \
../../plugins/group_2/plugin_1.py \
../../plugins/group_2/plugin_2.py \
../../plugins/group_2/plugin_3.py \
../../plugins/group_2/plugin_4.py \
../../plugins/group_2/plugin_5.py \
../../plugins/group_2/plugin_6.py \
../../plugins/group_2/plugin_7.py \
../../plugins/group_3/__init__.py \
../../plugins/group_3/plugin_1.py \
../../plugins/group_3/plugin_2.py \
../../plugins/group_4/__init__.py \
../../plugins/group_4/plugin_1.py \
../../plugins/group_5/__init__.py \
../../plugins/group_5/plugin_1.py \
../../plugins/group_5/plugin_2.py \
../../plugins/group_6/__init__.py \
../../plugins/group_6/plugin_1.py \
../../plugins/group_6/plugin_2.py \
../../plugins/group_6/plugin_3.py \
../../plugins/group_7/__init__.py \
../../plugins/group_7/plugin_1.py \
../../plugins/group_7/plugin_2.py \
../../plugins/group_7/plugin_3.py \
../../plugins/group_7/plugin_4.py \
../../plugins/group_8/__init__.py \
../../plugins/group_8/plugin_1.py \
../../plugins/group_8/plugin_2.py \
../../plugins/group_8/plugin_3.py \
../../plugins/group_8/plugin_4.py \
../../plugins/group_8/plugin_5.py \
../../plugins/group_8/plugin_6.py \
../../plugins/group_8/plugin_7.py \
../../plugins/group_9/__init__.py \
../../plugins/group_9/plugin_1.py
TRANSLATIONS = tr_zh.ts
```

`idaclu/assets/i18n/tr_zh.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="zh_CN">
<context>
    <name>PluginDialog</name>
    <message>
        <location filename="../../plugins/group_1/__init__.py" line="4"/>
        <source>Xref Analysis</source>
        <translation type="unfinished">交叉引用分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_1/plugin_1.py" line="13"/>
        <source>Xref Count</source>
        <translation type="unfinished">交叉引用计数</translation>
    </message>
    <message>
        <location filename="../../plugins/group_1/plugin_2.py" line="13"/>
        <source>Xref Source</source>
        <translation type="unfinished">交叉引用来源</translation>
    </message>
    <message>
        <location filename="../../plugins/group_1/plugin_3.py" line="13"/>
        <source>Xref Destination</source>
        <translation type="unfinished">交叉引用目标</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/__init__.py" line="4"/>
        <source>Constant Analysis</source>
        <translation type="unfinished">常量分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_1.py" line="14"/>
        <source>Common Constants</source>
        <translation type="unfinished">常用常量</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_2.py" line="13"/>
        <source>字符串引用</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_3.py" line="12"/>
        <source>Global Variable Analysis</source>
        <translation type="unfinished">全局变量分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_4.py" line="12"/>
        <source>Lib Usage Analysis</source>
        <translation type="unfinished">库使用分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_5.py" line="12"/>
        <source>API Usage Analysis</source>
        <translation type="unfinished">API 使用分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_6.py" line="15"/>
        <source>Windows API Semantics</source>
        <translation type="unfinished">Windows API 语义分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_2/plugin_7.py" line="15"/>
        <source>Windows API / Malware</source>
        <translation type="unfinished">Windows API / 恶意软件分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_3/__init__.py" line="4"/>
        <source>Control Flow</source>
        <translation type="unfinished">控制流程</translation>
    </message>
    <message>
        <location filename="../../plugins/group_3/plugin_1.py" line="12"/>
        <source>Control Flow Analysis</source>
        <translation type="unfinished">控制流程分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_3/plugin_2.py" line="13"/>
        <source>Pseudocode Size</source>
        <translation type="unfinished">伪代码大小</translation>
    </message>
    <message>
        <location filename="../../plugins/group_4/__init__.py" line="4"/>
        <source>Code Coverage</source>
        <translation type="unfinished">代码覆盖率</translation>
    </message>
    <message>
        <location filename="../../plugins/group_4/plugin_1.py" line="16"/>
        <source>Covered Functions</source>
        <translation type="unfinished">已覆盖的函数</translation>
    </message>
    <message>
        <location filename="../../plugins/group_5/__init__.py" line="4"/>
        <source>Function Similarity</source>
        <translation type="unfinished">函数相似性</translation>
    </message>
    <message>
        <location filename="../../plugins/group_5/plugin_1.py" line="14"/>
        <source>SSDEEP Similarity</source>
        <translation type="unfinished">SSDEEP 相似性</translation>
    </message>
    <message>
        <location filename="../../plugins/group_5/plugin_2.py" line="14"/>
        <source>TLSH Similarity</source>
        <translation type="unfinished">TLSH 相似性</translation>
    </message>
    <message>
        <location filename="../../plugins/group_6/__init__.py" line="4"/>
        <source>Virtual Functions</source>
        <translation type="unfinished">虚拟函数</translation>
    </message>
    <message>
        <location filename="../../plugins/group_6/plugin_1.py" line="13"/>
        <source>Explicit Calls</source>
        <translation type="unfinished">显式调用</translation>
    </message>
    <message>
        <location filename="../../plugins/group_6/plugin_2.py" line="13"/>
        <source>Implicit Calls</source>
        <translation type="unfinished">隐式调用</translation>
    </message>
    <message>
        <location filename="../../plugins/group_6/plugin_3.py" line="14"/>
        <source>Virtual Funtion Tables (MSVC)</source>
        <translation type="unfinished">虚拟函数表（MSVC）</translation>
    </message>
    <message>
        <location filename="../../plugins/group_7/__init__.py" line="4"/>
        <source>Filter Analysis</source>
        <translation type="unfinished">过滤器分析</translation>
    </message>
    <message>
        <location filename="../../plugins/group_7/plugin_1.py" line="14"/>
        <source>Distinct Folders</source>
        <translation type="unfinished">不同的文件夹</translation>
    </message>
    <message>
        <location filename="../../plugins/group_7/plugin_2.py" line="14"/>
        <source>Distinct Prefixes (IdaClu)</source>
        <translation type="unfinished">不同前缀（IdaClu）</translation>
    </message>
    <message>
        <location filename="../../plugins/group_7/plugin_3.py" line="15"/>
        <source>Distinct Colors</source>
        <translation type="unfinished">不同颜色</translation>
    </message>
    <message>
        <location filename="../../plugins/group_7/plugin_4.py" line="14"/>
        <source>Distinct Prefixes</source>
        <translation type="unfinished">不同前缀</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/__init__.py" line="5"/>
        <source>Obfuscation Detection</source>
        <translation type="unfinished">混淆检测</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_1.py" line="15"/>
        <source>Flattened Functions</source>
        <translation type="unfinished">扁平化函数</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_2.py" line="15"/>
        <source>Complex Functions</source>
        <translation type="unfinished">复杂函数</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_3.py" line="15"/>
        <source>Orphan Blocks</source>
        <translation type="unfinished">孤立块</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_4.py" line="15"/>
        <source>Large Basic Blocks</source>
        <translation type="unfinished">大型基本块</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_5.py" line="15"/>
        <source>Uncommon Instruction Sequences</source>
        <translation type="unfinished">不常见指令序列</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_6.py" line="15"/>
        <source>XOR Const Decryption Loops</source>
        <translation type="unfinished">XOR 常量解密循环</translation>
    </message>
    <message>
        <location filename="../../plugins/group_8/plugin_7.py" line="15"/>
        <source>Complex Arithmetic Expressions</source>
        <translation type="unfinished">复杂算术表达式</translation>
    </message>
    <message>
        <location filename="../../plugins/group_9/__init__.py" line="4"/>
        <source>Yara Rules</source>
        <translation type="unfinished">YARA 规则</translation>
    </message>
    <message>
        <location filename="../../plugins/group_9/plugin_1.py" line="16"/>
        <source>Rule Match</source>
        <translation type="unfinished">规则匹配</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="46"/>
        <location filename="../../qt_widgets.py" line="156"/>
        <source>PREFIX</source>
        <translation type="unfinished">前缀</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="46"/>
        <location filename="../../qt_widgets.py" line="49"/>
        <source>Insert name</source>
        <translation type="unfinished">"插入名称</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="47"/>
        <source>FOLDER</source>
        <translation type="unfinished">文件夹</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="104"/>
        <source>Insert prefix</source>
        <translation type="unfinished">插入前缀</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="155"/>
        <source>R</source>
        <translation type="unfinished">递归</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="157"/>
        <source>ADD</source>
        <translation type="unfinished">添加</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="158"/>
        <source>CLEAR</source>
        <translation type="unfinished">清除</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="159"/>
        <source>Toggle recursive mode on/off</source>
        <translation type="unfinished">切换递归模式 开/关</translation>
    </message>
    <message>
        <location filename="../../qt_widgets.py" line="160"/>
        <source>Switch between Prefix/Folder modes</source>
        <translation type="unfinished">在前缀/文件夹模式之间切换</translation>
    </message>
    <message>
        <location filename="../../ui_idaclu.py" line="145"/>
        <source>FOLDERS</source>
        <translation type="unfinished">文件夹</translation>
    </message>
    <message>
        <location filename="../../ui_idaclu.py" line="145"/>
        <source>Pick folders...</source>
        <translation type="unfinished">选择文件夹...</translation>
    </message>
    <message>
        <location filename="../../ui_idaclu.py" line="169"/>
        <source>PREFIXES</source>
        <translation type="unfinished">前缀</translation>
    </message>
    <message>
        <location filename="../../ui_idaclu.py" line="169"/>
        <source>Pick prefixes...</source>
        <translation type="unfinished">选择前缀...</translation>
    </message>
    <message>
        <location filename="../../ui_idaclu.py" line="318"/>
        <source>TOOLSET</source>
        <translation type="unfinished">工具集</translation>
    </message>
    <message>
        <location filename="../../ui_idaclu.py" line="319"/>
        <source>FILTERS</source>
        <translation type="unfinished">过滤器</translation>
    </message>
    <message>
        <location filename="../../idaclu_gui.py" line="476"/>
        <source>Rename</source>
        <translation type="unfinished">重命名</translation>
    </message>
</context>
</TS>

```

`idaclu/assets/resource.py`:

```py
# -*- coding: utf-8 -*-

# Resource object code
#
# Created by: The Resource Compiler for PyQt5 (Qt v5.15.2)
#
# WARNING! All changes made in this file will be lost!

from idaclu.qt_shims import (
    QtCore
) 

qt_resource_data = b"\
\x00\x00\x13\x90\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x40\x00\x00\x00\x40\x08\x06\x00\x00\x00\xaa\x69\x71\xde\
\x00\x00\x00\xc5\x7a\x54\x58\x74\x52\x61\x77\x20\x70\x72\x6f\x66\
\x69\x6c\x65\x20\x74\x79\x70\x65\x20\x65\x78\x69\x66\x00\x00\x78\
\xda\x6d\x50\xdb\x0d\xc3\x30\x08\xfc\x67\x8a\x8e\xc0\xcb\x0e\x1e\
\xc7\x69\x53\xa9\x1b\x74\xfc\x62\x43\xa2\xa4\xed\x49\x3e\x03\x67\
\x1d\x18\xd8\xde\xaf\x27\xdc\x06\x98\x14\xb4\x2c\x56\x5b\xad\xe8\
\xd0\xa6\x8d\xbb\x07\x86\x81\x3e\x99\x50\x27\x4f\x68\x4a\x9e\x5f\
\xea\x70\x08\xec\x25\xf1\x5b\x22\xb5\x9a\xef\xf7\x3a\x1d\x06\x71\
\x75\x8f\xca\xc9\xc8\xee\x29\xac\x57\xa1\x65\x07\xb6\x2f\xa3\x6c\
\x24\x63\x22\xf6\xe0\x91\x46\x2d\x8d\x84\x43\xa0\x34\xe8\xf1\x2d\
\xac\xcd\x96\xf3\x17\xd6\x0d\xaf\xb0\x38\x30\x68\x4d\xd7\x39\x11\
\xfe\xe6\xba\xf8\xf6\x1e\xc5\xfb\x08\xf3\x26\x24\xe8\x2c\xa2\x31\
\x80\x8c\xa3\x20\xdd\x05\x72\x46\x29\xfe\x90\xc4\x66\x65\x70\x11\
\xca\x49\x7c\x21\xff\xf6\xb4\x03\x3e\x3e\xc8\x59\xd0\xac\xa2\xd4\
\x2b\x00\x00\x01\x85\x69\x43\x43\x50\x49\x43\x43\x20\x70\x72\x6f\
\x66\x69\x6c\x65\x00\x00\x78\x9c\x7d\x91\x3d\x48\xc3\x40\x18\x86\
\xdf\xa6\x16\x45\x2b\x22\x76\x10\x71\xc8\x50\x9d\xac\x83\x8a\x38\
\x96\x2a\x16\xc1\x42\x69\x2b\xb4\xea\x60\x72\xe9\x1f\x34\x69\x48\
\x52\x5c\x1c\x05\xd7\x82\x83\x3f\x8b\x55\x07\x17\x67\x5d\x1d\x5c\
\x05\x41\xf0\x07\xc4\xd9\xc1\x49\xd1\x45\x4a\xfc\x2e\x29\xb4\x88\
\xf1\x8e\xe3\x1e\xde\xfb\xde\x97\xbb\xef\x00\xa1\x51\x61\xaa\xd9\
\x15\x05\x54\xcd\x32\x52\xf1\x98\x98\xcd\xad\x8a\xdd\xaf\xe8\x43\
\x00\x83\x34\x27\x25\x66\xea\x89\xf4\x62\x06\x9e\xe3\xeb\x1e\x3e\
\xbe\xdf\x45\x78\x96\x77\xdd\x9f\xa3\x5f\xc9\x9b\x0c\xf0\x89\xc4\
\x51\xa6\x1b\x16\xf1\x06\xf1\xec\xa6\xa5\x73\xde\x27\x0e\xb1\x92\
\xa4\x10\x9f\x13\x4f\x18\x74\x41\xe2\x47\xae\xcb\x2e\xbf\x71\x2e\
\x3a\x2c\xf0\xcc\x90\x91\x49\xcd\x13\x87\x88\xc5\x62\x07\xcb\x1d\
\xcc\x4a\x86\x4a\x3c\x43\x1c\x56\x54\x8d\xf2\x85\xac\xcb\x0a\xe7\
\x2d\xce\x6a\xa5\xc6\x5a\xf7\xe4\x2f\x0c\xe6\xb5\x95\x34\xd7\x69\
\x8d\x22\x8e\x25\x24\x90\x84\x08\x19\x35\x94\x51\x81\x85\x08\xed\
\x1a\x29\x26\x52\x74\x1e\xf3\xf0\x8f\x38\xfe\x24\xb9\x64\x72\x95\
\xc1\xc8\xb1\x80\x2a\x54\x48\x8e\x1f\xfc\x0f\x7e\xf7\xd6\x2c\x4c\
\x4f\xb9\x49\xc1\x18\x10\x78\xb1\xed\x8f\x31\xa0\x7b\x17\x68\xd6\
\x6d\xfb\xfb\xd8\xb6\x9b\x27\x80\xff\x19\xb8\xd2\xda\xfe\x6a\x03\
\x98\xfb\x24\xbd\xde\xd6\xc2\x47\xc0\xc0\x36\x70\x71\xdd\xd6\xe4\
\x3d\xe0\x72\x07\x18\x7e\xd2\x25\x43\x72\x24\x3f\x2d\xa1\x50\x00\
\xde\xcf\xe8\x9b\x72\xc0\xd0\x2d\xd0\xbb\xe6\xf6\xad\x75\x8e\xd3\
\x07\x20\x43\xbd\x5a\xbe\x01\x0e\x0e\x81\xf1\x22\x65\xaf\x7b\xbc\
\xbb\xa7\xb3\x6f\xff\xd6\xb4\xfa\xf7\x03\xad\x78\x72\xbe\xbd\x02\
\xc6\x7b\x00\x00\x0d\x76\x69\x54\x58\x74\x58\x4d\x4c\x3a\x63\x6f\
\x6d\x2e\x61\x64\x6f\x62\x65\x2e\x78\x6d\x70\x00\x00\x00\x00\x00\
\x3c\x3f\x78\x70\x61\x63\x6b\x65\x74\x20\x62\x65\x67\x69\x6e\x3d\
\x22\xef\xbb\xbf\x22\x20\x69\x64\x3d\x22\x57\x35\x4d\x30\x4d\x70\
\x43\x65\x68\x69\x48\x7a\x72\x65\x53\x7a\x4e\x54\x63\x7a\x6b\x63\
\x39\x64\x22\x3f\x3e\x0a\x3c\x78\x3a\x78\x6d\x70\x6d\x65\x74\x61\
\x20\x78\x6d\x6c\x6e\x73\x3a\x78\x3d\x22\x61\x64\x6f\x62\x65\x3a\
\x6e\x73\x3a\x6d\x65\x74\x61\x2f\x22\x20\x78\x3a\x78\x6d\x70\x74\
\x6b\x3d\x22\x58\x4d\x50\x20\x43\x6f\x72\x65\x20\x34\x2e\x34\x2e\
\x30\x2d\x45\x78\x69\x76\x32\x22\x3e\x0a\x20\x3c\x72\x64\x66\x3a\
\x52\x44\x46\x20\x78\x6d\x6c\x6e\x73\x3a\x72\x64\x66\x3d\x22\x68\
\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\x77\x33\x2e\x6f\x72\x67\
\x2f\x31\x39\x39\x39\x2f\x30\x32\x2f\x32\x32\x2d\x72\x64\x66\x2d\
\x73\x79\x6e\x74\x61\x78\x2d\x6e\x73\x23\x22\x3e\x0a\x20\x20\x3c\
\x72\x64\x66\x3a\x44\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x20\
\x72\x64\x66\x3a\x61\x62\x6f\x75\x74\x3d\x22\x22\x0a\x20\x20\x20\
\x20\x78\x6d\x6c\x6e\x73\x3a\x78\x6d\x70\x4d\x4d\x3d\x22\x68\x74\
\x74\x70\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\x6f\
\x6d\x2f\x78\x61\x70\x2f\x31\x2e\x30\x2f\x6d\x6d\x2f\x22\x0a\x20\
\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x73\x74\x45\x76\x74\x3d\x22\
\x68\x74\x74\x70\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\
\x63\x6f\x6d\x2f\x78\x61\x70\x2f\x31\x2e\x30\x2f\x73\x54\x79\x70\
\x65\x2f\x52\x65\x73\x6f\x75\x72\x63\x65\x45\x76\x65\x6e\x74\x23\
\x22\x0a\x20\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x64\x63\x3d\x22\
\x68\x74\x74\x70\x3a\x2f\x2f\x70\x75\x72\x6c\x2e\x6f\x72\x67\x2f\
\x64\x63\x2f\x65\x6c\x65\x6d\x65\x6e\x74\x73\x2f\x31\x2e\x31\x2f\
\x22\x0a\x20\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x47\x49\x4d\x50\
\x3d\x22\x68\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\x67\x69\x6d\
\x70\x2e\x6f\x72\x67\x2f\x78\x6d\x70\x2f\x22\x0a\x20\x20\x20\x20\
\x78\x6d\x6c\x6e\x73\x3a\x74\x69\x66\x66\x3d\x22\x68\x74\x74\x70\
\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\x6f\x6d\x2f\
\x74\x69\x66\x66\x2f\x31\x2e\x30\x2f\x22\x0a\x20\x20\x20\x20\x78\
\x6d\x6c\x6e\x73\x3a\x78\x6d\x70\x3d\x22\x68\x74\x74\x70\x3a\x2f\
\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\x6f\x6d\x2f\x78\x61\
\x70\x2f\x31\x2e\x30\x2f\x22\x0a\x20\x20\x20\x78\x6d\x70\x4d\x4d\
\x3a\x44\x6f\x63\x75\x6d\x65\x6e\x74\x49\x44\x3d\x22\x67\x69\x6d\
\x70\x3a\x64\x6f\x63\x69\x64\x3a\x67\x69\x6d\x70\x3a\x66\x35\x65\
\x38\x36\x33\x30\x34\x2d\x62\x38\x33\x35\x2d\x34\x37\x65\x32\x2d\
\x39\x30\x66\x31\x2d\x65\x66\x36\x66\x30\x63\x61\x66\x37\x31\x33\
\x38\x22\x0a\x20\x20\x20\x78\x6d\x70\x4d\x4d\x3a\x49\x6e\x73\x74\
\x61\x6e\x63\x65\x49\x44\x3d\x22\x78\x6d\x70\x2e\x69\x69\x64\x3a\
\x30\x35\x31\x62\x34\x62\x36\x31\x2d\x62\x35\x36\x63\x2d\x34\x30\
\x66\x30\x2d\x62\x66\x34\x30\x2d\x66\x38\x37\x30\x34\x36\x33\x39\
\x36\x37\x33\x39\x22\x0a\x20\x20\x20\x78\x6d\x70\x4d\x4d\x3a\x4f\
\x72\x69\x67\x69\x6e\x61\x6c\x44\x6f\x63\x75\x6d\x65\x6e\x74\x49\
\x44\x3d\x22\x78\x6d\x70\x2e\x64\x69\x64\x3a\x39\x39\x39\x38\x38\
\x31\x36\x37\x2d\x36\x39\x37\x30\x2d\x34\x30\x66\x30\x2d\x39\x36\
\x38\x35\x2d\x36\x65\x63\x34\x62\x30\x64\x64\x32\x33\x38\x61\x22\
\x0a\x20\x20\x20\x64\x63\x3a\x46\x6f\x72\x6d\x61\x74\x3d\x22\x69\
\x6d\x61\x67\x65\x2f\x70\x6e\x67\x22\x0a\x20\x20\x20\x47\x49\x4d\
\x50\x3a\x41\x50\x49\x3d\x22\x32\x2e\x30\x22\x0a\x20\x20\x20\x47\
\x49\x4d\x50\x3a\x50\x6c\x61\x74\x66\x6f\x72\x6d\x3d\x22\x57\x69\
\x6e\x64\x6f\x77\x73\x22\x0a\x20\x20\x20\x47\x49\x4d\x50\x3a\x54\
\x69\x6d\x65\x53\x74\x61\x6d\x70\x3d\x22\x31\x37\x33\x30\x38\x32\
\x37\x31\x33\x31\x35\x34\x35\x33\x33\x37\x22\x0a\x20\x20\x20\x47\
\x49\x4d\x50\x3a\x56\x65\x72\x73\x69\x6f\x6e\x3d\x22\x32\x2e\x31\
\x30\x2e\x33\x34\x22\x0a\x20\x20\x20\x74\x69\x66\x66\x3a\x4f\x72\
\x69\x65\x6e\x74\x61\x74\x69\x6f\x6e\x3d\x22\x31\x22\x0a\x20\x20\
\x20\x78\x6d\x70\x3a\x43\x72\x65\x61\x74\x6f\x72\x54\x6f\x6f\x6c\
\x3d\x22\x47\x49\x4d\x50\x20\x32\x2e\x31\x30\x22\x0a\x20\x20\x20\
\x78\x6d\x70\x3a\x4d\x65\x74\x61\x64\x61\x74\x61\x44\x61\x74\x65\
\x3d\x22\x32\x30\x32\x34\x3a\x31\x31\x3a\x30\x35\x54\x31\x38\x3a\
\x31\x38\x3a\x35\x31\x2b\x30\x31\x3a\x30\x30\x22\x0a\x20\x20\x20\
\x78\x6d\x70\x3a\x4d\x6f\x64\x69\x66\x79\x44\x61\x74\x65\x3d\x22\
\x32\x30\x32\x34\x3a\x31\x31\x3a\x30\x35\x54\x31\x38\x3a\x31\x38\
\x3a\x35\x31\x2b\x30\x31\x3a\x30\x30\x22\x3e\x0a\x20\x20\x20\x3c\
\x78\x6d\x70\x4d\x4d\x3a\x48\x69\x73\x74\x6f\x72\x79\x3e\x0a\x20\
\x20\x20\x20\x3c\x72\x64\x66\x3a\x53\x65\x71\x3e\x0a\x20\x20\x20\
\x20\x20\x3c\x72\x64\x66\x3a\x6c\x69\x0a\x20\x20\x20\x20\x20\x20\
\x73\x74\x45\x76\x74\x3a\x61\x63\x74\x69\x6f\x6e\x3d\x22\x73\x61\
\x76\x65\x64\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\
\x3a\x63\x68\x61\x6e\x67\x65\x64\x3d\x22\x2f\x22\x0a\x20\x20\x20\
\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x69\x6e\x73\x74\x61\x6e\x63\
\x65\x49\x44\x3d\x22\x78\x6d\x70\x2e\x69\x69\x64\x3a\x32\x62\x65\
\x31\x38\x36\x33\x35\x2d\x65\x32\x61\x32\x2d\x34\x62\x61\x33\x2d\
\x61\x36\x32\x38\x2d\x32\x61\x39\x32\x31\x64\x33\x37\x33\x37\x65\
\x65\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x73\
\x6f\x66\x74\x77\x61\x72\x65\x41\x67\x65\x6e\x74\x3d\x22\x47\x69\
\x6d\x70\x20\x32\x2e\x31\x30\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\
\x29\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x77\
\x68\x65\x6e\x3d\x22\x32\x30\x32\x34\x2d\x31\x31\x2d\x30\x35\x54\
\x31\x38\x3a\x31\x38\x3a\x35\x31\x22\x2f\x3e\x0a\x20\x20\x20\x20\
\x3c\x2f\x72\x64\x66\x3a\x53\x65\x71\x3e\x0a\x20\x20\x20\x3c\x2f\
\x78\x6d\x70\x4d\x4d\x3a\x48\x69\x73\x74\x6f\x72\x79\x3e\x0a\x20\
\x20\x3c\x2f\x72\x64\x66\x3a\x44\x65\x73\x63\x72\x69\x70\x74\x69\
\x6f\x6e\x3e\x0a\x20\x3c\x2f\x72\x64\x66\x3a\x52\x44\x46\x3e\x0a\
\x3c\x2f\x78\x3a\x78\x6d\x70\x6d\x65\x74\x61\x3e\x0a\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x3c\x3f\x78\
\x70\x61\x63\x6b\x65\x74\x20\x65\x6e\x64\x3d\x22\x77\x22\x3f\x3e\
\x03\xd4\x80\x81\x00\x00\x00\x06\x62\x4b\x47\x44\x00\xff\x00\xff\
\x00\xff\xa0\xbd\xa7\x93\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\
\x0e\xc4\x00\x00\x0e\xc4\x01\x95\x2b\x0e\x1b\x00\x00\x00\x07\x74\
\x49\x4d\x45\x07\xe8\x0b\x05\x11\x12\x33\xac\x0d\x2a\xee\x00\x00\
\x03\x39\x49\x44\x41\x54\x78\xda\xed\xdb\x4b\x4c\x13\x41\x18\x07\
\xf0\xff\x6e\xdf\xf4\x5d\x4a\x81\x06\x4b\x21\x94\x37\x24\x1a\x83\
\x17\x8f\x9c\xf4\x68\x8c\x27\x0f\xc6\x78\xd0\x93\x7a\xf6\xe6\xd1\
\xc4\xa3\x89\xf1\x60\x62\x8c\x46\x30\xa2\x24\x90\x28\x07\x62\x7a\
\xaa\x31\x8a\x22\x18\x69\x42\xc1\xd6\x96\x77\xdb\x6c\xb7\x2d\xb4\
\x74\x3c\x51\xb2\x80\xd2\xf2\x6a\x61\xbf\xef\x36\x5f\x66\x93\x99\
\xdf\x74\x66\x67\x66\x53\x2e\x14\x8f\x32\x5f\x28\x80\x42\x22\x18\
\x8f\x22\x2c\xc4\x50\xae\x61\xd6\xea\xd0\x6a\xaf\x01\x00\x5c\xea\
\x38\xc3\x15\xf2\x8c\xd2\x17\x0a\xe0\x6a\xff\x53\x9c\xb4\xb8\x3b\
\xdc\xcf\x1e\x5e\xb8\xbc\x2b\x02\x8f\x13\x1a\x8f\x3f\x79\xf1\xde\
\x3f\xc1\x64\x0b\xc0\xc0\x70\x6b\xf0\x25\x56\x92\x62\xef\x7f\xa7\
\xc0\xd6\x84\x56\xa3\x82\xc5\x68\xd8\xb1\xb2\x20\xa6\x20\xa6\xd2\
\xf9\xb2\xc7\x52\x85\x06\xb3\xad\x64\x9d\x4c\x65\xd7\xe0\xfd\xb3\
\xb9\x7e\xa9\x55\x4a\x64\x32\x59\x6c\x0c\x7b\x44\x88\xe3\xce\x70\
\xdf\x08\x00\xae\x60\x00\x8b\xd1\x80\xee\x76\xf7\x8e\x95\xa7\x02\
\x61\x88\xc1\x4d\x80\x8b\x8d\x6d\xb8\xd6\xd9\x53\x32\x80\x90\x10\
\x87\x77\xe0\x49\xbe\x6c\x30\xe8\x60\xd4\xeb\x30\x1b\x5a\xc8\xe7\
\xfa\x7f\x7c\xc1\xab\xf1\xcf\xec\x4a\xd7\x59\x4e\x16\x53\xc0\xd3\
\xe0\x84\x51\xaf\x93\xe4\x6e\x0f\xf5\xe1\x77\x6c\x85\xc9\x02\x80\
\xe7\x38\x74\xb7\xd5\x43\xc1\x6f\x76\x2d\x9e\x4e\xe1\xe6\xe0\x0b\
\xf9\x2c\x82\xfa\x0a\x1d\x9a\xdc\xb5\x92\xdc\xe8\xf4\x2f\x3c\xf2\
\x7d\x64\xb2\x79\x0b\xb8\xea\x1c\xb0\x59\x8c\x92\xdc\xbd\x91\x77\
\x98\x98\x0f\x33\x59\x00\x70\x00\xba\x5a\xeb\xa1\x52\x2a\xf2\xb9\
\x74\x36\x83\x1b\x6f\x9f\xcb\xe3\x17\x00\x00\x1a\xb5\x0a\xed\xcd\
\x2e\x49\x6e\x2c\x12\xc4\xfd\xd1\x21\x26\x0b\x00\x00\xa8\xb6\x5b\
\x50\x5b\x65\x95\xe4\x1e\x78\x3f\xc0\x17\x0c\x30\x59\x00\x00\x40\
\x5b\xf3\x29\x68\x35\xea\x7c\x39\x9b\xcb\xe1\xfa\x9b\x67\x90\x0d\
\x80\x52\xa1\x40\x67\x8b\x4b\xb2\x1d\x9c\x8e\x2e\x61\x60\xf2\x2b\
\x93\x05\x00\x00\xd8\x2c\x46\xd8\x6d\x26\x49\x2e\xc7\x18\x64\x03\
\x00\x00\x0a\x5e\x21\x9f\xd3\x60\xc1\x3b\x47\x02\x28\x6a\x31\x91\
\x56\x8f\x88\x42\x49\x1b\x1f\x16\xe3\xd2\xf6\xf1\xc5\x8f\xa7\xb2\
\x98\xca\x86\x2d\xa7\xac\xd7\x53\xdf\xc0\x18\x83\xd3\x60\x3a\xfa\
\xbb\x80\xf5\x0c\x06\xfc\xe3\xd2\x33\xc0\x96\xf6\x1d\x38\x40\xa5\
\xd5\x08\x8d\x5a\x85\xd5\xb5\x0c\x00\x60\x9d\xe5\xd0\x37\x35\x56\
\x26\x5b\x5f\x0e\x4e\x87\xed\x70\xa7\x80\x82\xe7\xd1\xd1\xec\x02\
\x07\xae\xec\xe6\xb2\xdb\x55\x0d\x7d\x85\xe6\xf0\x17\x41\xbb\xcd\
\x84\xd3\x5d\x8d\xd0\xa8\x55\x65\xf2\x6a\xe3\xd1\xe4\x76\xc2\x53\
\x5f\xb3\xb7\x4d\xd2\x5e\x1e\xb2\x5b\x4d\x38\xdf\xd3\x8e\xe5\xa8\
\x00\x21\x91\xc2\x7a\x2e\x57\x92\x8b\x0f\x9d\x56\x0d\xbb\xcd\xb4\
\xaf\xc1\x50\xee\x47\xde\x51\x69\x86\xa3\xd2\x4c\xfb\x00\x02\x20\
\x00\x02\x20\x80\x63\x7b\x57\x50\x4c\xe5\xb8\x90\x84\x90\x48\x95\
\x6d\x67\xb4\x1a\xd5\xb6\x33\xff\x81\x02\xcc\x2f\xc5\x30\x13\x9c\
\x3f\x56\x97\x1e\x34\x05\x08\xe0\x90\x76\x82\x00\xd0\x69\xaf\x45\
\x8b\xb5\xaa\x64\x8d\x5f\x48\x0a\x92\xcf\xe3\x47\x0e\xd0\xeb\xf2\
\x94\xf4\xf3\xb8\x2f\x32\xbb\x6f\x00\x5a\x03\x08\x80\x00\x08\x80\
\x00\x08\x80\x00\x08\x80\x00\x08\x80\x00\x08\x80\x00\x08\x80\x00\
\x08\x80\x00\x08\x80\x00\x08\x80\x00\xe4\x14\xdb\xae\xc5\x63\x42\
\x02\xdf\x27\x67\x76\xac\x2c\x88\xd2\xef\x82\x43\xd3\x3f\x31\xb1\
\x3c\x57\xb2\xc6\xaf\xa4\x93\x92\x72\x42\x4c\xfd\xb3\xed\x1b\x7d\
\xdb\x15\x20\xbd\x9a\xc1\xdc\x6a\xb4\xa0\x06\xf8\x63\x8b\xf0\xc7\
\x16\xcb\x66\x34\xd7\x32\x59\xcc\x2d\x45\x69\x0a\x10\x40\x11\xc1\
\x9d\xd4\xbf\xcf\x17\x12\xe7\xea\x1a\xf0\x17\x50\x8f\xf9\x38\x72\
\xd4\x16\xd4\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x06\xc2\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x40\x00\x00\x00\x40\x08\x06\x00\x00\x00\xaa\x69\x71\xde\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x01\xd8\x00\x00\x01\xd8\
\x01\xfa\x5c\xa6\x72\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x06\x3f\x49\x44\
\x41\x54\x78\x9c\xed\x9b\x79\x6c\x14\x55\x18\xc0\x7f\xb3\xb3\x47\
\xb7\xb4\xee\xb6\xf4\x00\x4a\x29\xb7\x50\x08\x8a\x48\x94\xc8\x0d\
\x8d\x28\x60\x90\x10\x8f\x20\x12\x12\x14\x8c\x82\x46\x22\x0a\x48\
\x02\x98\x40\x8c\x8a\x89\x41\x62\x13\x45\x89\x04\x43\xc0\x83\x80\
\x48\x44\x10\x28\xa4\x41\xb0\x18\x40\xae\x02\x16\x28\x81\x1e\x94\
\x6d\xb7\xdb\xee\xd1\x99\xf1\x8f\xdd\x2e\x2d\xec\x6c\xcb\x76\x67\
\x67\xd1\xfd\x25\x9b\x9d\x79\xe7\xf7\x7d\xf3\xde\xf7\xde\x7c\x33\
\x03\x09\x12\x24\x48\xf0\x3f\x46\x68\x23\x7f\x1c\xb0\x0a\xe8\x01\
\x18\x34\xe8\x3f\x35\xf0\xef\xd4\xa0\x6d\x19\xb8\x02\xbc\x0f\x1c\
\x88\xa4\x81\x4f\x01\xe5\x3f\xf2\x5b\xab\xa6\xa4\xda\x08\x18\x07\
\xec\x03\x18\x92\x6c\xa7\xc0\xde\x05\xb3\x10\xdd\x01\xe0\x92\x9b\
\xf8\xec\xfa\x79\x00\x1e\x7c\xa9\x00\x53\x8a\x35\xaa\xed\x4b\x5e\
\x1f\xd7\x0f\x9f\xc2\x71\xee\x6a\x73\xd2\x18\xe0\xe0\x9d\xe5\xd4\
\x0c\x50\x04\x8c\x1c\x92\x6c\x67\xfb\x80\xd1\x18\x85\xb6\x66\xca\
\xbd\x53\xed\xf3\x30\xf4\xc4\x6e\x00\x9e\xda\xb6\x12\x6b\x76\x5a\
\xd4\xfb\x50\x24\x99\xdf\xe7\x7d\xd2\x6c\x84\x83\xf8\x8d\xd0\x0a\
\xb5\xcb\x9a\x0b\x30\xd1\xde\x45\x13\xe5\x63\x85\x20\x1a\xe8\xfa\
\xc4\xe0\xe6\xd3\xbc\x50\x65\xd4\x0c\x20\x02\x58\xa2\x3c\xec\xf5\
\x40\x34\x9b\x82\x87\xa1\xf2\xef\x7f\x0d\x3b\x48\xc2\x00\x7a\x0b\
\xa0\x37\x46\xbd\x05\x00\xb8\xf0\xfd\x01\x9c\x65\x15\x48\x1e\x2f\
\xf6\x01\xb9\x0c\x9c\x3d\x09\x63\x72\x52\x4c\xfa\x8e\x0b\x03\x94\
\x7e\xb7\x2f\x78\x5c\x55\x52\xca\x85\x2d\xfb\x19\xf6\xde\x4c\x7a\
\x4c\x1a\xae\x79\xdf\xba\x4d\x81\x24\x83\x88\x18\x58\x62\xd3\x8c\
\x66\xc6\xd9\xb2\x99\x9c\xd6\x0d\x9b\x68\x42\x91\x64\x8e\xad\xde\
\x44\xcd\xe9\xcb\x9a\xcb\xa1\xdb\x08\x48\x11\x8d\x6c\xea\x37\x82\
\x46\x49\x62\xac\x2d\x0b\x53\x60\xc9\xad\xf6\x79\x98\x71\xfe\x10\
\x17\xdd\xf5\x94\x7c\xb8\x99\x89\x1b\x97\x68\x2a\x87\xae\x4e\x70\
\x64\x6a\x26\x05\xf6\x2e\x41\xe5\x01\x32\x4c\x16\x16\x76\xed\x0f\
\x40\xfd\x95\x4a\xcd\x65\x88\xcb\x55\xa0\xb3\xd1\x02\x80\x22\x2b\
\x9a\xf7\xa5\xab\x01\xd4\xd4\xdb\x5e\x73\x0d\x00\x53\x6a\x74\x6f\
\x90\x42\xa1\x9b\x0f\x90\x14\x85\x27\xcf\xec\xc7\xd1\xe4\x65\x5a\
\x7a\x77\x1e\x4b\xe9\x8c\x55\x14\xf9\xf1\x66\x39\x5b\x6f\x5e\x01\
\xa0\xf7\xb4\x91\x9a\xcb\xa1\x9b\x01\x6a\x25\x1f\xe7\x1a\xeb\x00\
\x28\xac\xb8\x40\x61\xc5\x85\x56\xf9\x69\x03\xf3\xc8\x9f\x3b\x59\
\x73\x39\xe2\x62\x1f\x60\xb1\xa7\xe0\x75\x36\x80\xa2\x60\x4a\xb1\
\xd2\x6b\xda\x48\x06\xbd\x32\x25\x26\x7d\x77\xd8\x00\xe5\xde\x06\
\xd6\xdf\x28\xe5\x50\x5d\x15\x0d\xb2\xc4\x00\xeb\x03\xcc\xc9\xea\
\xcd\x04\x5b\x76\xbb\xdb\x18\xff\xe5\x3b\x9a\xc4\x03\xda\x43\x87\
\x0c\x50\xe2\xba\xc5\xac\xd2\x62\xea\x24\x5f\x30\xad\xc2\xe7\xe6\
\x40\x5d\x25\x6f\x74\xe9\xc7\xbb\x39\xf9\x1d\x16\x50\x6b\x22\x5e\
\x05\xdc\xb2\xc4\xfc\x4b\x47\xa9\x93\x7c\x08\x46\x0b\xe9\x05\xf3\
\xc9\x7a\x7e\x15\xe6\xec\xde\x00\xac\xbb\x51\xca\xde\xda\x8a\xa8\
\x09\xaa\x15\x11\x8f\x80\x5f\x1d\x37\xb8\xee\x6d\x04\xc1\x40\x9f\
\x35\x47\xb0\x74\xed\x07\x40\xe6\xd4\x45\x94\x2e\x1a\x82\xb7\xe2\
\x22\xdf\x54\x5e\xba\xa7\xa9\xa0\x07\x11\x8f\x80\x73\x6e\xbf\x07\
\x37\xa5\x77\x0b\x2a\xdf\x8c\x7d\xcc\xac\x40\x19\x2d\xa2\xdd\xd1\
\x25\x62\x03\x24\x09\xfe\x08\x93\xd2\xe4\xbd\x2b\x4f\x6e\xa8\x0b\
\x94\x89\xcb\x8d\x66\x2b\xc2\x4e\x01\xb7\x2c\x51\xdb\xc2\xc1\xb5\
\x24\xd7\x92\x0c\x40\x53\x5d\x35\xb2\xc7\x85\xc1\xd2\x29\x98\xe7\
\x3a\xb5\x17\x80\x3e\x49\xa9\xaa\xf5\x5b\x3a\x4e\xaf\xab\x11\xa3\
\xd3\x12\x56\x50\x53\x8a\x15\xee\x08\xd0\x4a\x5e\x1f\xb2\x27\x74\
\xfb\xc1\x32\x6d\xe4\xab\x85\x7c\x1d\x80\x2d\x6c\xcd\x16\x64\x4d\
\x5f\x46\xe6\xf4\xa5\xfe\x13\x59\xe6\xef\xd9\x36\x50\xe4\xf6\x56\
\x6f\x17\xb6\xbe\x39\x4c\xd8\xb0\x38\x68\x84\x9b\x27\x2e\x51\xf4\
\xd6\x3a\x64\x5f\x53\x7b\x9b\x70\x03\x77\xed\xad\xa3\x32\x46\xc5\
\xd4\x8c\x16\x67\x0a\x82\xd1\xa4\x5a\x36\x52\xdc\xd5\xb5\xad\xce\
\x7d\xf5\x0d\xf7\xa2\xbc\x2a\x6a\x53\xc0\x09\xd8\x32\xa6\xbe\x4d\
\xda\xf8\xb9\x61\x1b\x10\x93\x6d\x88\x9d\xec\xb7\x13\x0c\x22\xf9\
\x5f\x55\xe2\xbd\x79\x2d\x6c\x3d\xb9\xa1\x96\x8b\xcb\x46\x00\xb0\
\xe7\x6b\x91\x1e\xdd\x42\x97\x1b\xf5\xa2\x44\x65\x0d\x74\x9f\xf0\
\x48\xab\x29\x90\x35\x7c\x20\x16\x7b\x0a\x1e\x47\x3d\xaf\xcf\x14\
\x58\xf8\x72\xe8\x6b\x39\x77\x99\x4c\xd1\x31\x05\xa0\x3a\x54\x7e\
\x58\x1f\x20\x26\xa7\x61\xce\x0c\xf9\x3c\x21\x3c\x06\x63\x9b\xf5\
\x24\x97\x23\x78\x9c\x93\x0d\x3d\x73\x42\x97\xbb\xe5\xf7\xa7\x64\
\x3c\xdc\xb7\x75\x17\x26\x91\xf4\x41\x3d\xb9\x7e\xf8\x14\xe7\xcb\
\xd4\xeb\xb7\x15\x5a\x8c\x7b\x37\x2d\x07\x5c\x89\xd1\x7a\xb7\x93\
\x14\x93\xcc\x00\x34\xba\x23\x8f\x1b\xc4\xbd\x01\xec\x01\x57\x5c\
\xbe\xef\x78\xab\x74\x6f\xad\x8b\xaa\x3f\xfd\x0f\x57\x87\x0d\x8a\
\xfc\xf1\x5d\x5c\xdc\x0d\x86\xe3\xd5\xe7\x04\xd6\x14\x2a\x5c\xfe\
\xe5\x08\x82\x41\x20\xb7\xe0\x51\x3c\x8e\x7a\xce\x6e\xdc\x8d\xc7\
\x51\x8f\x51\x84\xa5\xaf\x45\x7e\x1d\xe3\xde\x00\x2b\x16\x18\xd8\
\x5b\x2c\xf1\xc7\x09\x85\xb2\x9d\xc5\x94\xed\x2c\x0e\xe6\x09\x02\
\xac\x5f\x69\xc0\x9e\x1a\xa6\x81\x36\x88\xfb\x29\x00\x50\xb4\x59\
\x64\xc9\x3c\x81\x74\x3b\x18\x0c\x60\x32\x42\x7e\x5f\x7f\xfa\xec\
\x69\x1d\x7b\x7a\x1d\xb3\x11\xe0\x2c\xd9\x45\xcd\x9e\x2f\x70\x97\
\x9f\xc6\x60\xb6\x62\x09\x44\x7e\xdb\xcb\x8a\x05\x06\x56\x2c\x88\
\xbe\x5c\x31\x31\x40\xc5\x96\xe5\x54\xef\x68\xfd\x96\x8a\xb7\xe2\
\x52\x2c\xba\x6e\x13\xcd\x0d\xe0\x2c\xd9\x15\x54\xbe\x7f\x2f\x98\
\xf3\xac\x80\xc3\x09\x7b\x0e\x2b\xfc\x75\x16\xcc\x26\xc8\x53\xd9\
\x04\xc5\x02\xcd\x0d\x50\xf3\x5b\x21\xe0\x57\xfe\xe4\x8e\xdb\xef\
\x28\xac\x7a\xd3\xff\x2f\xcb\xfe\x79\xad\x17\x9a\x77\xed\xb9\x7a\
\x1a\x40\xd5\x59\xe9\xa9\x3c\xc4\xc0\x00\x42\xe0\x36\xb9\x3c\x4e\
\xa3\x63\x9a\x1b\x20\x65\xf0\x58\x00\x36\x6c\x53\x38\xf7\xcf\xed\
\x74\xa7\x0b\x56\xae\x93\x59\xf7\xad\xf6\x8f\xbf\xc2\xa1\xb9\x0f\
\xc8\x98\xba\x88\xda\xe2\xad\x78\x5c\x0e\x1e\x7a\x46\x22\x27\x1b\
\x3c\x5e\xa8\xbe\x05\x8a\x02\xa0\xf0\xc2\x14\x91\x0c\x7d\xa2\xe2\
\xda\x8f\x00\x53\xe7\x5c\xf2\x16\xff\x84\xa9\x73\x2e\x8a\x02\xe5\
\x37\xa0\xaa\xa6\x59\x79\x3f\xb7\x6a\xd5\xeb\x6b\x4d\x4c\xf6\x01\
\xd6\x3e\xc3\xe9\xfb\xd1\x71\x9c\x25\x3f\xe3\x29\x3f\x83\x60\x4e\
\xc2\x9c\x99\x47\xf9\xe7\x73\x62\xd1\x7d\x58\x62\xb6\x13\x34\x98\
\xad\xd8\x1e\x9f\x11\x3c\x6f\x19\x0f\xd0\x93\xfb\xe2\x5e\x40\x4b\
\x12\x06\xd0\x5b\x00\xbd\x51\x33\x80\x0c\xa0\xf8\xdc\x31\x14\x45\
\x1b\xdc\x9e\xe0\xa1\x14\x2a\x5f\xcd\x00\x97\x01\x9c\xc7\x77\xa1\
\x48\x1d\x0f\x3d\xeb\x85\xdb\x0b\x47\x4f\x06\xd7\xdb\xb2\x50\x65\
\xd4\xa2\x09\x63\x80\xfd\x00\xd6\x5e\x43\x49\x1d\xfa\x34\x82\x29\
\xba\x6f\x6e\xca\xbe\x46\xaa\x7e\x58\x0d\xc0\xa8\x61\x02\xc9\x51\
\x7e\x1d\xc8\xed\xf1\x2b\xdf\x70\x7b\x10\x8f\xc6\xff\x1d\x44\xbb\
\x59\x8b\xfe\x9f\xba\x44\xeb\xf7\xb1\x9a\x92\x6d\xc5\x93\x46\x03\
\x1f\xe0\xff\xd8\x20\xe4\xfb\xf6\x1d\x44\xcb\x8f\xa6\x24\xfc\x53\
\x79\x39\x21\x3e\x95\x49\x90\x20\x41\x82\x04\xc0\xbf\xde\x42\x3d\
\x3c\xe9\x84\xaf\xf0\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\
\x82\
\x00\x00\x01\x4e\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7a\x7a\xf4\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc4\x00\x00\x0e\xc4\
\x01\x95\x2b\x0e\x1b\x00\x00\x01\x00\x49\x44\x41\x54\x58\x85\xed\
\x94\x41\x0a\xc2\x30\x10\x45\x1f\x9e\x40\x8a\x14\x11\x8f\x23\x2e\
\x8a\x0b\x6f\x26\x22\x22\x22\x45\xc4\xa3\x88\x4b\x11\x11\x29\xe2\
\x41\x8a\xab\xba\x49\x60\x94\x9a\x34\xb1\xb5\x9b\x7c\x98\x4d\x33\
\xf9\xef\x51\x68\x21\x24\x24\xe4\x3d\x53\xe0\x08\x44\x0d\x74\x77\
\x81\x03\x30\x31\xc1\x9f\x40\x01\x9c\x81\x5e\x8d\xf0\x08\x38\xa9\
\xee\x1c\x48\x3e\x17\x12\x01\xd7\x73\xa9\x49\xa2\xa7\xba\x64\x77\
\x0e\x8c\xf5\xc2\x58\x3d\x28\x4a\xe6\x0a\xc4\x3f\xc0\xe3\x12\xb8\
\x94\x18\x01\xac\xbf\x2c\x48\x89\xbe\x27\xfc\x6a\xe9\xde\x00\x74\
\x80\x9d\x65\xf1\xe6\x28\xd1\x57\x77\x4c\x9d\x7b\xc5\xa6\xaa\x44\
\x56\x51\xa2\x0a\x7c\x27\xe1\xae\x12\x03\x0b\x3c\xf3\x81\x4b\x89\
\xbd\xa5\xe0\xfe\x45\x62\xa0\xce\x4c\x77\xb7\x26\xb8\x94\xb0\xbd\
\x89\x3b\x30\x74\x84\xa7\x55\xe0\x3e\x12\xc3\xba\xe1\x52\x62\x6b\
\x29\x7e\xa8\xb1\x7d\x6a\xce\x70\x17\x89\xc6\xe0\x52\x22\xf5\x80\
\xaf\xeb\x80\x4b\x89\x4d\x5b\x70\x29\x61\xfb\x6d\x17\xc0\xaa\x09\
\xb8\x94\x58\xb5\x05\x97\x59\xb4\x09\xd7\x99\x0b\xf8\xf2\xdf\x70\
\x9d\x99\x82\x87\x84\x84\x78\xe7\x05\xa5\x72\xea\xe1\x7e\x85\x89\
\x6e\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\x22\
\x00\
\x00\x08\x42\x78\x9c\xb5\x54\x5d\x6f\x9b\x40\x10\x7c\x0e\x12\xff\
\x61\xfb\x94\xda\x02\x9b\xe3\x43\x09\x44\xea\x43\xa2\x56\xa9\xe4\
\x4a\x4d\x22\xb5\xcf\xc0\x6d\x80\xfa\xcc\xa1\xe3\x48\x62\x45\xf9\
\xef\x3d\x30\xae\x49\x02\x18\x55\xad\xa5\x95\xac\x65\x6f\x66\x76\
\xf6\xf6\x96\x73\xf8\x4a\xc3\x2b\x56\xc1\x9d\xdc\x32\x2c\x53\x44\
\x09\xd1\x16\xee\x50\x24\xf8\xab\x84\xd3\xeb\xdb\xd5\xb7\x53\xb8\
\x0e\x05\x0b\x37\xfc\xa1\x84\xf9\x52\xd7\x96\x73\xf8\x81\xa2\xcc\
\x78\x0e\xd6\xc2\x57\xb5\x05\x10\xd7\x00\xdb\xb2\x9d\xe6\xbb\xae\
\xdd\x7c\xaf\xca\xf4\xb2\x92\x92\xe7\x8b\x14\x43\x0a\xcf\xba\x06\
\xea\x17\x71\x41\x51\x98\x31\x67\x5c\x04\x22\x89\x3e\x92\x33\xc7\
\x68\x63\x76\xa1\x6b\x27\x6d\x41\x59\x8b\x09\xa0\xe4\x2c\xa3\x9d\
\xf4\x63\x46\x65\x1a\x00\x29\x9e\xea\xa4\x92\xd1\xe6\x23\xae\x98\
\x36\x01\x58\x17\x0d\xff\x49\x14\xc6\xeb\x44\xf0\x2a\xa7\x2d\x15\
\xd4\x5c\xb6\x6d\x19\x6d\xcc\x74\xed\x45\xa9\xfc\x99\xd1\x04\xe5\
\xe2\x5e\x84\x1b\x84\x4f\x70\xf3\xa5\xf9\xf3\xfc\x87\x30\x50\x4c\
\x3b\x11\x0d\x80\x4b\x0c\xd8\x45\xad\x75\x18\xa0\x0f\xc9\x6a\x34\
\x8f\x9e\x59\x85\x11\xb2\xfe\x33\x1d\x3b\x4b\x64\x18\x4b\xf3\xbf\
\xb9\xda\x26\x45\x96\xa4\xb2\x76\xf4\x90\xea\x58\x49\x1c\xcb\x20\
\x8e\x67\x10\xd7\xdd\x11\x4c\x34\xbc\xd3\x47\xc1\xa4\x19\xc9\xbc\
\xd3\xef\xe4\x06\x78\x25\x4b\x94\x43\x1d\xf4\xf3\x04\x71\x8a\xf1\
\x1a\x69\x3f\x9f\x65\xc0\xb9\xba\xc1\xc4\x73\x66\x83\x08\xe6\x16\
\x19\xe3\x8f\x3b\x80\xfe\x7e\x3d\xcf\x68\xc2\xb6\x8f\xc2\xbc\xd6\
\x33\x0a\x47\x7c\x32\x02\x17\xb1\x0a\xc7\x40\xd4\xa4\x5a\xa0\x23\
\x20\x13\x14\x11\xdf\x9f\x00\x96\x08\xc4\x7c\x4c\x92\x6d\x4f\xb0\
\xa9\x41\x99\xa4\x89\x4c\x70\xa9\xc8\xf2\xf5\x31\xab\x6b\x59\xee\
\xd9\x11\x90\x89\x73\x6b\x54\x39\x7e\x0f\x98\xe4\x9c\xed\x2f\xfe\
\xbf\x5f\xde\x01\xc3\xeb\xee\x9a\x18\x11\x64\xa6\xfc\x21\x50\x81\
\x62\x50\x9a\x5a\xfa\x7a\x9d\x89\x37\xba\xf4\xea\x8e\xb8\xf5\x4c\
\xfa\xe6\xb1\x27\xeb\xda\x38\x40\xa5\x16\xb2\xdd\xc7\x21\x26\xcb\
\x55\x2d\x9d\x0f\x0c\x0d\x69\x76\x78\x25\x7b\x5e\xb5\xba\x7c\x95\
\xe5\xf8\x59\xd5\xed\x55\x14\x21\xa5\x59\x9e\x98\x0c\xef\x55\x95\
\xdb\x78\x3a\x65\x46\x9d\x9a\x37\x63\xea\x7c\x79\xf7\x48\x5d\xf1\
\x4d\xc4\x2f\xf9\x53\x80\x79\x18\xb1\x83\x17\x7d\x2a\x5e\xd5\x7f\
\x18\x3d\x60\xbd\x3b\x30\xf5\xaa\xfd\x55\x1b\xbf\x01\xfe\xa1\x7f\
\xc8\
\x00\x00\x12\x96\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x40\x00\x00\x00\x40\x08\x04\x00\x00\x00\x00\x60\xb9\x55\
\x00\x00\x00\xc6\x7a\x54\x58\x74\x52\x61\x77\x20\x70\x72\x6f\x66\
\x69\x6c\x65\x20\x74\x79\x70\x65\x20\x65\x78\x69\x66\x00\x00\x78\
\xda\x6d\x50\xdb\x0d\xc3\x30\x08\xfc\xf7\x14\x1d\x01\x03\x76\xf0\
\x38\x4e\x9b\x4a\xdd\xa0\xe3\xf7\x6c\x48\x94\xb4\x3d\xc9\x18\x38\
\x74\x3c\xd2\xf6\x7e\x3d\xd3\x6d\x80\xb3\x26\x2d\x8b\xd5\x56\x2b\
\x01\xda\xb4\x71\x87\x63\xe4\xe8\xd3\x66\xd2\x69\x27\x34\x28\xc4\
\x97\x7c\x3a\x08\x46\x4a\xf0\x8b\x87\x56\xa3\x7e\xcf\xe7\x43\xc0\
\xbf\x0e\xaf\x9c\x84\xec\x1e\xc4\x7a\x25\x5a\x74\x60\xfb\x12\x8a\
\x46\x32\x26\x62\x38\x8f\x10\x6a\x21\x24\xec\x44\x0e\x81\xee\x6b\
\x51\x6d\xb6\x9c\x57\x58\x37\xba\xc2\xfc\xa5\x61\xd6\x50\x9d\x13\
\xd1\x6f\xac\x0b\xae\xf7\x28\xe8\x23\xcc\x9b\x64\x21\x58\x11\xf5\
\x01\x64\x3c\x4d\xd2\x41\x64\x58\x92\x82\xc2\x2c\x06\x9f\x51\x36\
\xec\xbe\x2a\x0e\xf2\xef\x4e\x3b\xd2\x07\x3e\x34\x59\xcd\x3d\xc3\
\xe7\x61\x00\x00\x01\x24\x69\x43\x43\x50\x49\x43\x43\x20\x70\x72\
\x6f\x66\x69\x6c\x65\x00\x00\x78\x9c\x9d\x90\x3d\x4b\xc3\x50\x14\
\x86\x9f\xd6\x4f\xfc\x18\xa4\xa2\x20\x0e\x19\x5c\x3b\x9a\xc9\xc1\
\x2f\x1a\x1c\x0a\xb5\x8d\x60\x75\x4a\x6f\x5a\x2c\x26\x31\x24\x29\
\xc5\x7f\xe0\x3f\xd1\x1f\xd3\x41\x10\xfc\x0d\xce\x0a\xce\xbe\x37\
\x3a\x38\x98\xc5\x0b\x87\xf7\xe1\x70\xce\xfb\xde\x7b\xa1\xee\x44\
\x26\xce\xe7\x0f\x21\x4e\x8a\xcc\xeb\x1e\xf5\x2f\xfb\x57\xce\xd2\
\x1b\xab\x2c\xb0\xc1\x36\x8d\xc0\xe4\x69\xbb\xd7\xf2\xa9\x3c\x9f\
\xaf\xd4\xac\xbe\x34\xad\x57\xf5\xdc\x9f\x67\x31\x1c\xe6\x46\x3a\
\x53\x25\x26\xcd\x0a\xa8\x1d\x88\xdd\x69\x91\x5a\x56\xb1\x79\xeb\
\x77\x4f\xc4\x0f\x62\x27\x8c\x93\x50\xfc\x24\xde\x0b\xe3\xd0\xb2\
\xdd\xed\xc6\xd1\xc4\xfc\x78\xda\xdb\xac\x0d\x93\x8b\x9e\xed\xab\
\x76\xf1\x38\xa3\x4d\x07\x87\x01\x13\xc6\x44\x14\x34\xa5\x89\x3a\
\xa7\xb8\xec\x4b\x3d\x32\x02\xee\xc9\x31\xd2\x88\xa1\x7a\x53\xcd\
\x14\xdc\x88\x72\x39\x79\x1c\x8b\x7c\x91\x6e\x53\x91\xb7\x53\xe6\
\x75\x94\x32\x90\xc7\x58\x5e\x36\xe1\x8e\x58\x9e\x36\x0f\xfb\xbf\
\xdf\x6b\x1f\xe7\xe5\x66\x6d\x6b\x96\x06\x59\x50\xb6\xe6\x54\xf5\
\xd1\x08\xde\x1f\x61\xbd\x0f\x8d\x67\x58\xb9\xae\xc8\x5a\xfe\xfd\
\xb6\x8a\x19\xb7\x9c\xf9\xe7\x1b\xbf\x00\xff\xe9\x50\x70\x5e\xbc\
\x40\x96\x00\x00\x0e\x55\x69\x54\x58\x74\x58\x4d\x4c\x3a\x63\x6f\
\x6d\x2e\x61\x64\x6f\x62\x65\x2e\x78\x6d\x70\x00\x00\x00\x00\x00\
\x3c\x3f\x78\x70\x61\x63\x6b\x65\x74\x20\x62\x65\x67\x69\x6e\x3d\
\x22\xef\xbb\xbf\x22\x20\x69\x64\x3d\x22\x57\x35\x4d\x30\x4d\x70\
\x43\x65\x68\x69\x48\x7a\x72\x65\x53\x7a\x4e\x54\x63\x7a\x6b\x63\
\x39\x64\x22\x3f\x3e\x0a\x3c\x78\x3a\x78\x6d\x70\x6d\x65\x74\x61\
\x20\x78\x6d\x6c\x6e\x73\x3a\x78\x3d\x22\x61\x64\x6f\x62\x65\x3a\
\x6e\x73\x3a\x6d\x65\x74\x61\x2f\x22\x20\x78\x3a\x78\x6d\x70\x74\
\x6b\x3d\x22\x58\x4d\x50\x20\x43\x6f\x72\x65\x20\x34\x2e\x34\x2e\
\x30\x2d\x45\x78\x69\x76\x32\x22\x3e\x0a\x20\x3c\x72\x64\x66\x3a\
\x52\x44\x46\x20\x78\x6d\x6c\x6e\x73\x3a\x72\x64\x66\x3d\x22\x68\
\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\x77\x33\x2e\x6f\x72\x67\
\x2f\x31\x39\x39\x39\x2f\x30\x32\x2f\x32\x32\x2d\x72\x64\x66\x2d\
\x73\x79\x6e\x74\x61\x78\x2d\x6e\x73\x23\x22\x3e\x0a\x20\x20\x3c\
\x72\x64\x66\x3a\x44\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x20\
\x72\x64\x66\x3a\x61\x62\x6f\x75\x74\x3d\x22\x22\x0a\x20\x20\x20\
\x20\x78\x6d\x6c\x6e\x73\x3a\x78\x6d\x70\x4d\x4d\x3d\x22\x68\x74\
\x74\x70\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\x6f\
\x6d\x2f\x78\x61\x70\x2f\x31\x2e\x30\x2f\x6d\x6d\x2f\x22\x0a\x20\
\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x73\x74\x45\x76\x74\x3d\x22\
\x68\x74\x74\x70\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\
\x63\x6f\x6d\x2f\x78\x61\x70\x2f\x31\x2e\x30\x2f\x73\x54\x79\x70\
\x65\x2f\x52\x65\x73\x6f\x75\x72\x63\x65\x45\x76\x65\x6e\x74\x23\
\x22\x0a\x20\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x64\x63\x3d\x22\
\x68\x74\x74\x70\x3a\x2f\x2f\x70\x75\x72\x6c\x2e\x6f\x72\x67\x2f\
\x64\x63\x2f\x65\x6c\x65\x6d\x65\x6e\x74\x73\x2f\x31\x2e\x31\x2f\
\x22\x0a\x20\x20\x20\x20\x78\x6d\x6c\x6e\x73\x3a\x47\x49\x4d\x50\
\x3d\x22\x68\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\x67\x69\x6d\
\x70\x2e\x6f\x72\x67\x2f\x78\x6d\x70\x2f\x22\x0a\x20\x20\x20\x20\
\x78\x6d\x6c\x6e\x73\x3a\x74\x69\x66\x66\x3d\x22\x68\x74\x74\x70\
\x3a\x2f\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\x6f\x6d\x2f\
\x74\x69\x66\x66\x2f\x31\x2e\x30\x2f\x22\x0a\x20\x20\x20\x20\x78\
\x6d\x6c\x6e\x73\x3a\x78\x6d\x70\x3d\x22\x68\x74\x74\x70\x3a\x2f\
\x2f\x6e\x73\x2e\x61\x64\x6f\x62\x65\x2e\x63\x6f\x6d\x2f\x78\x61\
\x70\x2f\x31\x2e\x30\x2f\x22\x0a\x20\x20\x20\x78\x6d\x70\x4d\x4d\
\x3a\x44\x6f\x63\x75\x6d\x65\x6e\x74\x49\x44\x3d\x22\x67\x69\x6d\
\x70\x3a\x64\x6f\x63\x69\x64\x3a\x67\x69\x6d\x70\x3a\x66\x35\x65\
\x38\x36\x33\x30\x34\x2d\x62\x38\x33\x35\x2d\x34\x37\x65\x32\x2d\
\x39\x30\x66\x31\x2d\x65\x66\x36\x66\x30\x63\x61\x66\x37\x31\x33\
\x38\x22\x0a\x20\x20\x20\x78\x6d\x70\x4d\x4d\x3a\x49\x6e\x73\x74\
\x61\x6e\x63\x65\x49\x44\x3d\x22\x78\x6d\x70\x2e\x69\x69\x64\x3a\
\x64\x31\x30\x63\x61\x63\x62\x65\x2d\x30\x65\x62\x61\x2d\x34\x61\
\x38\x36\x2d\x38\x31\x31\x61\x2d\x38\x37\x30\x33\x65\x63\x62\x36\
\x64\x64\x32\x37\x22\x0a\x20\x20\x20\x78\x6d\x70\x4d\x4d\x3a\x4f\
\x72\x69\x67\x69\x6e\x61\x6c\x44\x6f\x63\x75\x6d\x65\x6e\x74\x49\
\x44\x3d\x22\x78\x6d\x70\x2e\x64\x69\x64\x3a\x39\x39\x39\x38\x38\
\x31\x36\x37\x2d\x36\x39\x37\x30\x2d\x34\x30\x66\x30\x2d\x39\x36\
\x38\x35\x2d\x36\x65\x63\x34\x62\x30\x64\x64\x32\x33\x38\x61\x22\
\x0a\x20\x20\x20\x64\x63\x3a\x46\x6f\x72\x6d\x61\x74\x3d\x22\x69\
\x6d\x61\x67\x65\x2f\x70\x6e\x67\x22\x0a\x20\x20\x20\x47\x49\x4d\
\x50\x3a\x41\x50\x49\x3d\x22\x32\x2e\x30\x22\x0a\x20\x20\x20\x47\
\x49\x4d\x50\x3a\x50\x6c\x61\x74\x66\x6f\x72\x6d\x3d\x22\x57\x69\
\x6e\x64\x6f\x77\x73\x22\x0a\x20\x20\x20\x47\x49\x4d\x50\x3a\x54\
\x69\x6d\x65\x53\x74\x61\x6d\x70\x3d\x22\x31\x37\x33\x30\x38\x32\
\x37\x34\x30\x35\x37\x38\x32\x33\x38\x30\x22\x0a\x20\x20\x20\x47\
\x49\x4d\x50\x3a\x56\x65\x72\x73\x69\x6f\x6e\x3d\x22\x32\x2e\x31\
\x30\x2e\x33\x34\x22\x0a\x20\x20\x20\x74\x69\x66\x66\x3a\x4f\x72\
\x69\x65\x6e\x74\x61\x74\x69\x6f\x6e\x3d\x22\x31\x22\x0a\x20\x20\
\x20\x78\x6d\x70\x3a\x43\x72\x65\x61\x74\x6f\x72\x54\x6f\x6f\x6c\
\x3d\x22\x47\x49\x4d\x50\x20\x32\x2e\x31\x30\x22\x0a\x20\x20\x20\
\x78\x6d\x70\x3a\x4d\x65\x74\x61\x64\x61\x74\x61\x44\x61\x74\x65\
\x3d\x22\x32\x30\x32\x34\x3a\x31\x31\x3a\x30\x35\x54\x31\x38\x3a\
\x32\x33\x3a\x32\x35\x2b\x30\x31\x3a\x30\x30\x22\x0a\x20\x20\x20\
\x78\x6d\x70\x3a\x4d\x6f\x64\x69\x66\x79\x44\x61\x74\x65\x3d\x22\
\x32\x30\x32\x34\x3a\x31\x31\x3a\x30\x35\x54\x31\x38\x3a\x32\x33\
\x3a\x32\x35\x2b\x30\x31\x3a\x30\x30\x22\x3e\x0a\x20\x20\x20\x3c\
\x78\x6d\x70\x4d\x4d\x3a\x48\x69\x73\x74\x6f\x72\x79\x3e\x0a\x20\
\x20\x20\x20\x3c\x72\x64\x66\x3a\x53\x65\x71\x3e\x0a\x20\x20\x20\
\x20\x20\x3c\x72\x64\x66\x3a\x6c\x69\x0a\x20\x20\x20\x20\x20\x20\
\x73\x74\x45\x76\x74\x3a\x61\x63\x74\x69\x6f\x6e\x3d\x22\x73\x61\
\x76\x65\x64\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\
\x3a\x63\x68\x61\x6e\x67\x65\x64\x3d\x22\x2f\x22\x0a\x20\x20\x20\
\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x69\x6e\x73\x74\x61\x6e\x63\
\x65\x49\x44\x3d\x22\x78\x6d\x70\x2e\x69\x69\x64\x3a\x32\x62\x65\
\x31\x38\x36\x33\x35\x2d\x65\x32\x61\x32\x2d\x34\x62\x61\x33\x2d\
\x61\x36\x32\x38\x2d\x32\x61\x39\x32\x31\x64\x33\x37\x33\x37\x65\
\x65\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x73\
\x6f\x66\x74\x77\x61\x72\x65\x41\x67\x65\x6e\x74\x3d\x22\x47\x69\
\x6d\x70\x20\x32\x2e\x31\x30\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\
\x29\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x77\
\x68\x65\x6e\x3d\x22\x32\x30\x32\x34\x2d\x31\x31\x2d\x30\x35\x54\
\x31\x38\x3a\x31\x38\x3a\x35\x31\x22\x2f\x3e\x0a\x20\x20\x20\x20\
\x20\x3c\x72\x64\x66\x3a\x6c\x69\x0a\x20\x20\x20\x20\x20\x20\x73\
\x74\x45\x76\x74\x3a\x61\x63\x74\x69\x6f\x6e\x3d\x22\x73\x61\x76\
\x65\x64\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\
\x63\x68\x61\x6e\x67\x65\x64\x3d\x22\x2f\x22\x0a\x20\x20\x20\x20\
\x20\x20\x73\x74\x45\x76\x74\x3a\x69\x6e\x73\x74\x61\x6e\x63\x65\
\x49\x44\x3d\x22\x78\x6d\x70\x2e\x69\x69\x64\x3a\x39\x63\x64\x64\
\x61\x35\x63\x32\x2d\x63\x39\x32\x66\x2d\x34\x66\x36\x63\x2d\x62\
\x35\x34\x66\x2d\x65\x31\x65\x39\x39\x62\x37\x65\x32\x37\x38\x30\
\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x73\x6f\
\x66\x74\x77\x61\x72\x65\x41\x67\x65\x6e\x74\x3d\x22\x47\x69\x6d\
\x70\x20\x32\x2e\x31\x30\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x29\
\x22\x0a\x20\x20\x20\x20\x20\x20\x73\x74\x45\x76\x74\x3a\x77\x68\
\x65\x6e\x3d\x22\x32\x30\x32\x34\x2d\x31\x31\x2d\x30\x35\x54\x31\
\x38\x3a\x32\x33\x3a\x32\x35\x22\x2f\x3e\x0a\x20\x20\x20\x20\x3c\
\x2f\x72\x64\x66\x3a\x53\x65\x71\x3e\x0a\x20\x20\x20\x3c\x2f\x78\
\x6d\x70\x4d\x4d\x3a\x48\x69\x73\x74\x6f\x72\x79\x3e\x0a\x20\x20\
\x3c\x2f\x72\x64\x66\x3a\x44\x65\x73\x63\x72\x69\x70\x74\x69\x6f\
\x6e\x3e\x0a\x20\x3c\x2f\x72\x64\x66\x3a\x52\x44\x46\x3e\x0a\x3c\
\x2f\x78\x3a\x78\x6d\x70\x6d\x65\x74\x61\x3e\x0a\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x3c\x3f\x78\x70\
\x61\x63\x6b\x65\x74\x20\x65\x6e\x64\x3d\x22\x77\x22\x3f\x3e\x5a\
\xb2\x3e\x60\x00\x00\x00\x02\x62\x4b\x47\x44\x00\xff\x87\x8f\xcc\
\xbf\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc4\x00\x00\x0e\
\xc4\x01\x95\x2b\x0e\x1b\x00\x00\x00\x07\x74\x49\x4d\x45\x07\xe8\
\x0b\x05\x11\x17\x19\x0a\xc1\x17\x7d\x00\x00\x01\xc4\x49\x44\x41\
\x54\x68\xde\xed\x99\x4b\x4b\x02\x51\x14\x80\xbf\x31\x1f\xf8\x20\
\x5f\x05\x41\x2f\x2a\x95\x68\x2b\x54\x3f\xa0\xff\xd0\x1f\xcc\x16\
\x6e\x5a\x04\x6d\x5a\xd4\x32\x82\xda\xd4\x42\x82\x5e\x90\x05\x81\
\x66\xf9\x48\x4a\xbc\x2d\xbc\x4e\xe6\x18\xa6\x33\x78\x03\xef\xd9\
\xdc\xc3\x19\x38\xf7\x9b\x39\xe7\x9e\x39\x67\xc6\x28\x8a\x5b\xac\
\x52\xe4\x15\x27\xc5\xcf\x0c\x90\x36\xac\x57\x8c\x33\xb1\xc3\xa8\
\x64\x93\x6d\x0b\x82\x8b\x11\xca\x09\x97\x42\x29\x00\x64\xa9\x6c\
\xfd\xb4\xb8\xdb\x8a\x97\x50\x87\xb9\x46\x1d\x80\x08\x11\x5b\x1b\
\x36\x78\x90\xdb\x34\x00\x28\x93\x3d\xc4\xe8\x09\x10\x62\xb5\xc3\
\x7c\x4f\x1e\x80\x14\x1b\xb6\x00\x5e\x68\x65\x58\x90\x20\x8f\x00\
\x5c\x70\x2a\xd6\x0d\x05\x21\x58\x24\x20\xb5\x3d\x0a\x42\x01\x80\
\x41\x4a\x6e\x56\x67\x57\x4d\x12\x06\x98\x97\xda\x0d\x47\x42\xc9\
\x29\x98\x25\x2c\xb5\x03\xf2\x42\xc9\x31\x4c\xca\xac\x6f\x90\x51\
\x53\x07\xbc\xac\x48\xed\x89\x7d\xa1\x00\x00\xe2\xc4\xa5\x76\xcc\
\xb5\x50\x00\x00\x09\xbc\x00\x34\xc9\xa0\x04\x60\x82\xa4\x59\xa6\
\xce\x85\x02\x00\x08\x9b\x05\x5e\xa0\x04\xa0\xf3\xc1\x2b\x02\xe0\
\xdf\x03\xb4\xcd\x65\x9b\xee\xdf\xfa\xde\xa7\xbb\xb7\x39\x28\xd7\
\x1c\x82\x49\x1b\xdd\x40\xae\xcb\xdf\x9f\x01\x22\x78\xf8\x04\x84\
\xe9\xc2\x9e\x4c\x0f\x1e\x82\x84\x83\x71\x9e\xc3\x3f\x78\x12\x46\
\x59\xc3\xe3\x48\x92\x2d\x98\xaf\xe1\x01\x42\xd0\x0a\x43\x9a\x12\
\x55\x9a\x36\x9a\x10\x1f\x51\x59\x78\x87\x00\x00\x17\x31\x62\x63\
\x5a\x07\x34\xc0\x18\x01\xfc\x72\x0a\x2a\x54\x1c\xdd\xc6\x47\x74\
\x30\x80\x82\x1c\xcd\x9c\x6b\x41\xa2\x3a\x07\x86\xa9\x84\x30\x65\
\x36\xd1\xc3\x49\x55\x8e\xe7\x43\x03\x2c\xdb\x1c\xcf\xef\xfa\x02\
\xe8\x1c\xd0\x00\x1a\x40\x03\x68\x00\x0d\xa0\x01\x34\x80\x06\xd0\
\x00\x1a\xc0\xfd\x3d\x0d\x76\x7e\x0f\xab\xc9\xf5\x8a\x67\x5b\xee\
\xdf\xcd\xf9\x20\xd7\x35\x7b\x5a\x00\x3e\x28\xf6\x70\x50\xa2\xe4\
\xc8\x7d\x36\x7a\x7a\xd7\x39\x00\x60\x8c\xf2\xf7\xbd\x55\x96\xf8\
\x02\x95\x9a\x5b\x29\x0d\xd3\x15\x36\x00\x00\x00\x00\x49\x45\x4e\
\x44\xae\x42\x60\x82\
"

qt_resource_name = b"\
\x00\x06\
\x06\xfa\x7a\x35\
\x00\x69\
\x00\x64\x00\x61\x00\x63\x00\x6c\x00\x75\
\x00\x0d\
\x01\x8e\x32\x47\
\x00\x73\
\x00\x61\x00\x76\x00\x65\x00\x5f\x00\x31\x00\x5f\x00\x36\x00\x34\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0b\
\x02\x48\x1b\xc7\
\x00\x69\
\x00\x63\x00\x6f\x00\x6e\x00\x5f\x00\x36\x00\x34\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0c\
\x0f\x76\x7a\xe7\
\x00\x61\
\x00\x72\x00\x72\x00\x6f\x00\x77\x00\x5f\x00\x33\x00\x32\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x09\
\x00\x28\xad\x23\
\x00\x73\
\x00\x74\x00\x79\x00\x6c\x00\x65\x00\x2e\x00\x71\x00\x73\x00\x73\
\x00\x0d\
\x01\x8e\x32\xe7\
\x00\x73\
\x00\x61\x00\x76\x00\x65\x00\x5f\x00\x30\x00\x5f\x00\x36\x00\x34\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

qt_resource_struct_v1 = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x02\
\x00\x00\x00\x6c\x00\x01\x00\x00\x00\x01\x00\x00\x1b\xac\
\x00\x00\x00\x12\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x00\x84\x00\x00\x00\x00\x00\x01\x00\x00\x1d\xd2\
\x00\x00\x00\x32\x00\x00\x00\x00\x00\x01\x00\x00\x13\x94\
\x00\x00\x00\x4e\x00\x00\x00\x00\x00\x01\x00\x00\x1a\x5a\
"

qt_resource_struct_v2 = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x02\
\x00\x00\x00\x00\x00\x00\x00\x00\
\x00\x00\x00\x6c\x00\x01\x00\x00\x00\x01\x00\x00\x1b\xac\
\x00\x00\x01\x8c\x58\xee\x7c\x38\
\x00\x00\x00\x12\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x01\x92\xfd\x56\x1a\xa2\
\x00\x00\x00\x84\x00\x00\x00\x00\x00\x01\x00\x00\x1d\xd2\
\x00\x00\x01\x92\xfd\x5a\x49\xe6\
\x00\x00\x00\x32\x00\x00\x00\x00\x00\x01\x00\x00\x13\x94\
\x00\x00\x01\x92\xbe\x6d\xd6\x76\
\x00\x00\x00\x4e\x00\x00\x00\x00\x00\x01\x00\x00\x1a\x5a\
\x00\x00\x01\x8c\x58\xee\x7c\x10\
"

qt_version = [int(v) for v in QtCore.qVersion().split('.')]
if qt_version < [5, 8, 0]:
    rcc_version = 1
    qt_resource_struct = qt_resource_struct_v1
else:
    rcc_version = 2
    qt_resource_struct = qt_resource_struct_v2

def qInitResources():
    QtCore.qRegisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)

def qCleanupResources():
    QtCore.qUnregisterResourceData(rcc_version, qt_resource_struct, qt_resource_name, qt_resource_data)

qInitResources()

```

`idaclu/assets/resource.qrc`:

```qrc
<!DOCTYPE RCC>
<RCC version="1.0">
	<qresource prefix="/idaclu">
		<file>icon_64.png</file>
		<file>save_0_64.png</file>
		<file>save_1_64.png</file>
		<file>arrow_32.png</file>
		<file>style.qss</file>
	</qresource>
</RCC>

```

`idaclu/assets/style.qss`:

```qss
/* IdaClu Stylesheet by Sergejs 'HRLM' Harlamovs */
/* Version 0.9 Sep 14, 2023 */

QPushButton.head {
    border-color:rgb(173,173,173);
	border-style: solid;
	border-width: 1px;
	/* border-bottom: 0; */
	background-color: rgb(220,220,220)
}
QWidget.frame > QFrame {
	border:1px solid rgb(41, 41, 41);
}
QWidget.frame > QFrame > QFrame {
	border:0px;
}
QWidget.frame > QFrame > QLabel {
	border:0px;
}
QPushButton.select-head {
    border-color:rgb(173,173,173);
	border-style: solid;
	border-width: 1px;
	border-right: 0;
	border-color: rgb(130,135,144);
	background-color: rgb(220,220,220)
}
QPushButton.plt-btn {
	border-color:rgb(173,173,173);
	border-style: outset;
	border-width: 1px;
}
QPushButton.plt-btn:checked {
	border-color:rgb(0, 84, 153);
}
QPushButton.plt-btn-yellow {
	background-color: rgb(255,255,222);
}
QPushButton.plt-btn-yellow:checked {
	background-color: rgb(255,255,191);
}
QPushButton.plt-btn-blue {
	background-color: rgb(230,255,255);
}
QPushButton.plt-btn-blue:checked {
	background-color: rgb(199,255,255);
}
QPushButton.plt-btn-green {
	background-color: rgb(222,255,222);
}
QPushButton.plt-btn-green:checked {
	background-color: rgb(191,255,191);
}
QPushButton.plt-btn-pink {
	background-color: rgb(255,222,247);
}
QPushButton.plt-btn-pink:checked {
	background-color: rgb(255,191,239);
}
QPushButton.tool-btn {
    border-color:rgb(173,173,173);
	border-style: solid;
	border-width: 1px;
	background-color: rgb(225,225,225);
}
QPushButton.tool-btn-hov:hover {
    border-color:rgb(0,120,215);
	background-color: rgb(229,241,251);
}
QPushButton.tool-btn:checked {
    border-color:rgb(0,84,153);
	background-color: rgb(204,228,247);
}
QPushButton.edit-head {
	border-right: 0;
}
QLineEdit {
    padding-left: 4px;
    border-color:rgb(173,173,173);
    border-style: solid;
    border-width: 1px;
}
QComboBox:enabled {
    padding-left: 4px;
}
QComboBox:!enabled {
    padding-left: 0px;
}
QComboBox {
    border-color:rgb(173,173,173);
    border-style: solid;
    border-width: 1px;
}

```

`idaclu/ida_shims.py`:

```py
# Shim file to support IDA 6.x-8.x
# Documentation provided by Hex-Rays:
# https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide/
# https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml

import os
import sys
import idc
import idaapi
import idautils


try:
    import ida_bytes
except ImportError:
    ida_bytes = None

try:
    import ida_name
except ImportError:
    ida_name = None

try:
    import ida_kernwin
except ImportError:
    ida_kernwin = None

try:
    import ida_nalt
except ImportError:
    ida_nalt = None

try:
    import ida_ua
except ImportError:
    ida_ua = None

try:
    import ida_funcs
except ImportError:
    ida_funcs = None

try:
    import ida_search
except ImportError:
    ida_search = None
    
try:
    import ida_ida
except ImportError:
    ida_ida = None


def _get_fn_by_version(lib, curr_fn, archive_fn, archive_lib=None):
    '''
    Determine which function should be called based on the version of IDA.

    :param curr_fn: 7.X version of the function.

    :param archive_fn: 6.X version of the function.

    :param archive_lib: If the archive lib is different than the current lib,
                        set it here.

    :return: Function based on the version of IDA.
    '''
    if idaapi.IDA_SDK_VERSION >= 700:
        try:
            return getattr(lib, curr_fn)
        except AttributeError:
            raise Exception('%s is not a valid function in %s' % (curr_fn, lib))
    use_lib = lib if archive_lib is None else archive_lib
    try:
        return getattr(use_lib, archive_fn)
    except AttributeError:
        raise Exception('%s is not a valid function in %s' % (archive_fn, use_lib))


def print_insn_mnem(ea):
    '''
    Get instruction mnemonics.

    :param ea: Linear address of the instruction.
    :type ea: int

    :return: Instruction mnemonic. "" if not instruction is found.

    :note: *Heavy breath* This function may not return exactly the same
    mnemonics as you see on the screen.
    '''
    fn = _get_fn_by_version(idc, 'print_insn_mnem', 'GetMnem')
    return fn(ea)


def print_operand(ea, n):
    '''
    Get operand of an instruction or data.

    :param ea: Linear address of the item.
    :type ea: int

    :param n: Number of operand: 0 - the first operand 1 - the second operand.
    :type n: int

    :return: The current text representation of operand or "".
    '''
    fn = _get_fn_by_version(idc, 'print_operand', 'GetOpnd')
    return fn(ea, n)


def get_switch_info(ea):
    fn = _get_fn_by_version(idaapi, 'get_switch_info', 'get_switch_info_ex', idaapi)
    return fn(ea)

def get_operand_type(head, opnd_index):
    '''
    '''
    fn = _get_fn_by_version(idc, 'get_operand_type', 'GetOpType')
    return fn(head, opnd_index)

def define_local_var(start, end, location, name):
    '''
    Create a local variable.

    :param start: Start address range for the local variable.
    :type start: int

    :param end: End of address range for the local variable.
    :type end: int

    :param location: The variable location in the "[bp+xx]" form where xx is
                     a number. The location can also be specified as a
                     register name.
    :type location: str

    :param name: Name of the local variable.
    :type name: str

    :return: 1-ok, 0-failure
    '''
    fn = _get_fn_by_version(idc, 'define_local_var', 'MakeLocal')
    return fn(start, end, location, name)


def find_func_end(ea):
    '''
    Determine a new function boundaries.

    :param ea: Start address of the new function.
    :type ea: int

    :return: If a function already exists, then return its end address. If a
    function end cannot be determine, the return BADADDR otherwise return the
    end address of the new function.
    '''
    fn = _get_fn_by_version(idc, 'find_func_end', 'FindFuncEnd')
    return fn(ea)


def is_code(flag):
    '''
    Does flag denote start of an instruction.
    :param flag: Flag for an instruction.
    :type flag: int

    :return: True if flags indicate code, False otherwise.
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_code', 'isCode', idaapi)
    return fn(flag)


def is_data(flag):
    '''
    Does flag denote start of an instruction.
    :param flag: Flag for an instruction.
    :type flag: int

    :return: True if flags indicate code, False otherwise.
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_code', 'isData', idaapi)
    return fn(flag)


def is_dword(flag):
    '''
    Does flag denote start of an instruction.
    :param flag: Flag for an instruction.
    :type flag: int

    :return: True if flags indicate code, False otherwise.
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_dword', 'isDwrd', idaapi)
    return fn(flag)


def is_qword(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_qword', 'isQwrd', idaapi)
    return fn(flag)

def is_word(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_word', 'isWord', idaapi)
    return fn(flag)


def is_struct(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_struct', 'isStruct', idaapi)
    return fn(flag)

def is_float(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_float', 'isFloat', idaapi)
    return fn(flag)


def is_double(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_double', 'isDouble', idaapi)
    return fn(flag)


def is_enum0(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_enum0', 'isEnum0', idaapi)
    return fn(flag)


def is_off0(flag):
    '''
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_off0', 'isOff0', idaapi)
    return fn(flag)

def is_loaded(ea):
    fn = _get_fn_by_version(ida_bytes, 'is_loaded', 'isLoaded', idc)
    return fn(ea)

def has_xref(ea):
    fn = _get_fn_by_version(ida_bytes, 'has_xref', 'hasRef', idaapi)
    return fn(ea)

def get_flags(ea):
    '''
    Get flags value for address 'ea'

    :param ea: Linear address.
    :type ea: int

    :return: 0 if flags not present in the program
    '''
    fn = _get_fn_by_version(ida_bytes, 'get_flags', 'get_flags_novalue')
    return fn(ea)


def get_full_flags(ea):
    '''
    Get flags value for address 'ea'

    :param ea: Linear address.
    :type ea: int

    :return: 0 if flags not present in the program
    '''
    fn = _get_fn_by_version(ida_bytes, 'get_full_flags', 'getFlags', idaapi)
    return fn(ea)


def get_idb_path():
    '''
    '''
    fn = _get_fn_by_version(idc, 'get_idb_path', 'GetIdbPath', idc)
    return fn()


def ua_mnem(ea):
    '''
    '''
    fn = _get_fn_by_version(ida_ua, 'ua_mnem', 'GetMnem', idc)
    return fn(ea)


def get_operand_value(ea, idx):
    '''
    '''
    fn = _get_fn_by_version(idc, 'get_operand_value', 'GetOperandValue', idc)
    return fn(ea, idx)


def get_bytes(func_addr, func_size):
    '''
    '''
    fn = _get_fn_by_version(idc, 'get_bytes', 'GetManyBytes', idc)
    return fn(func_addr, func_size)


def get_name(ea):
    '''
    Get name at the specified address.

    :param ea: Linear address
    :type ea: int

    :return: "" - byte has no name.
    '''
    fn = _get_fn_by_version(idc, 'get_name', 'Name')

    if idaapi.IDA_SDK_VERSION > 700:
        return fn(ea, ida_name.GN_VISIBLE)
    return fn(ea)


def generate_disasm_line(ea, flags):
    fn = _get_fn_by_version(idc, 'generate_disasm_line', 'GetDisasmEx')
    return fn(ea, flags)


def get_func_off_str(ea):
    '''
    Convert address to 'funcname+offset' string.

    :param ea: Address to convert.
    :type ea: int

    :return: If the address belongs to a function then return a string formed as
    'name+offset' where 'name' is a function name, 'offset' is offset within
    the function else return null string.
    '''
    fn = _get_fn_by_version(idc, 'get_func_off_str', 'GetFuncOffset')
    return fn(ea)


def jumpto(ea, opnum=-1, uijmp_flags=0x0001):
    '''
    Jump to the specified address.

    :param ea: Destination
    :type ea: int

    :param opnum: -1: don't change the x coord.
    :type opnum: int

    :param uijmp_flags: Jump flags.
    :type uijmp_flags: int

    :return: success
    '''
    fn = _get_fn_by_version(ida_kernwin, 'jumpto', 'Jump', idc)
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, opnum, uijmp_flags)
    return fn(ea)


def ask_yn(default, format_str):
    '''
    Display a dialog box and get choice from "Yes", "No", "Cancel".

    :param default: Default choice: one of Button IDs
    :type default: int

    :param format_str: The question in printf() style format.
    :type format_str: str

    :return: The selected button (one of Button IDs).
    '''
    fn = _get_fn_by_version(ida_kernwin, 'ask_yn', 'AskYN', idc)
    return fn(default, format_str)


def ask_file(for_saving, default, dialog):
    '''
    Get file from user.

    :param for_saving: File is for saving.
    :type for_saving: int

    :param default: File extension.
    :type default: str

    :param dialog: Dialog box to display to the user.
    :type dialog: str

    :return: file path.
    '''
    fn = _get_fn_by_version(ida_kernwin, 'ask_file', 'AskFile', idc)
    return fn(for_saving, default, dialog)


def get_func_attr(ea, attr):
    '''
    Get a function attribute.

    :param ea: Any address belonging to the function.
    :type ea: int

    :param attr: One of FUNCATTR_... constants

    :return: BADADDR - error otherwise returns the attribute value.
    '''
    fn = _get_fn_by_version(idc, 'get_func_attr', 'GetFunctionAttr')
    return fn(ea, attr)


def get_name_ea_simple(name):
    '''
    Get linear address of a name.

    :param name: Name of program byte.
    :type name: str

    :return: Address of the name or BADADDR - No such name.
    '''
    fn = _get_fn_by_version(idc, 'get_name_ea_simple', 'LocByName')
    return fn(name)


def get_name_ea(afrom, fname):
    '''
    '''
    fn = _get_fn_by_version(idaapi, 'get_name_ea', 'LocByNameEx', idc)
    return fn(afrom, fname)


def next_head(ea, maxea=4294967295):
    '''
    Get next defined item (instruction or data) in the program.

    :param ea: Linear address to start search from.
    :type ea: int

    :param maxea: The search will stop at the address maxea. maxea is not
                  included in the search range
    :type maxea: int

    :return: BADADDR - no (more) defined items
    '''
    fn = _get_fn_by_version(idc, 'next_head', 'NextHead')
    return fn(ea, maxea)


def find_text(ea, y, x, searchstr, flag):
    fn = _get_fn_by_version(ida_search, 'find_text', 'FindText', idc)
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, y, x, searchstr, flag)
    return fn(ea, flag, y, x, searchstr)

def get_screen_ea():
    '''
    Return the linear address of the current screen location.

    :return: Address of screen focus.
    '''
    fn = _get_fn_by_version(idc, 'get_screen_ea', 'ScreenEA')
    return fn()


def choose_func(title):
    '''
    Ask the user to select a function.

    :param title: Title of the dialog box.
    :type title: str

    :return: -1 user refused to select a function, otherwise function start addr
    '''
    fn = _get_fn_by_version(idc, 'choose_func', 'ChooseFunction')
    return fn(title)


def ask_ident(default, prompt):
    '''
    Ask for a long text.
    :param default: The default value.
    :type default: str

    :param prompt: The prompt value.
    :type prompt: str

    :return: None or the entered string.
    '''
    fn = _get_fn_by_version(ida_kernwin, 'ask_str', 'AskIdent', idc)
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(default, ida_kernwin.HIST_IDENT, prompt)
    return fn(default, prompt)


def set_name(ea, name, flags):
    '''
    Rename an address.

    :param ea: Linear address.
    :type ea: int

    :param name: New name of address. If name == "" then delete old name.
    :type name: str

    :return: 1-ok, 0-failure
    '''
    fn = _get_fn_by_version(idc, 'set_name', 'MakeName')
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, name, flags)
    return fn(ea, name)


def get_wide_dword(ea):
    '''
    Get one wide word of the program at 'ea'
    :param ea: linear address.
    :type ea: int

    :return: uint64
    '''
    fn = _get_fn_by_version(idc, 'get_wide_dword', 'Dword')
    return fn(ea)


def get_strlit_contents(str_obj):
    '''
    Get string contents.

    :param ea: Linear address.
    :type ea: int

    :return: String contents or empty string.
    '''
    fn = _get_fn_by_version(ida_bytes, 'get_strlit_contents', 'GetString', idc)
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(str_obj.ea, str_obj.length, str_obj.strtype)
    return fn(str_obj.ea)


def get_func_name(ea):
    '''
    Retrieve function name.

    :param ea: Any address belonging to the function.
    :type ea: int

    :return: Null string if not found, otherwise the functions name.
    '''
    fn = _get_fn_by_version(idc, 'get_func_name', 'GetFunctionName')
    return fn(ea)


def get_first_seg():
    '''
    Get first segment.

    :return: Address of the start of the first segment or BADADDR if no
    segments found.
    '''
    fn = _get_fn_by_version(idc, 'get_first_seg', 'FirstSeg')
    return fn()


def get_segm_attr(segea, attr):
    '''
    Get segment attribute.

    :param segea: Any address within the segment.
    :type segea: int

    :param attr: One of SEGATTR_... constants.
    :type attr: int

    :return: Segment attributes.
    '''
    fn = _get_fn_by_version(idc, 'get_segm_attr', 'GetSegmentAttr')
    return fn(segea, attr)


def get_next_seg(ea):
    '''
    Get next segment.

    :param ea: Linear address.
    :type ea: int

    :return: Start of the next segment or BADADDR
    '''
    fn = _get_fn_by_version(idc, 'get_next_seg', 'NextSeg')
    return fn(ea)


def is_strlit(flags):
    '''
    Do flags indicate a string.

    :param flags: Flags for address.
    :type flags: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_strlit', 'isASCII', idc)
    return fn(flags)


def create_strlit(start, length):
    '''
    Convert to string literal and give a meaningful name.

    :param start: Start ea.
    :type start: int

    :param length: Length of string, or 0 to determine dynamically.
    :type length: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_bytes, 'create_strlit', 'MakeStr', idc)
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(start, length, ida_nalt.STRTYPE_C)
    return fn(start, idc.BADADDR)


def is_unknown(flags):
    '''
    Do flags indicate an unknown type.

    :param flags: Flags for address.
    :type flags: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_unknown', 'isUnknown', idc)
    return fn(flags)


def refresh_idaview_anyway():
    '''
    '''
    fn = _get_fn_by_version(idaapi, 'refresh_idaview_anyway', 'Refresh', idc)
    return fn()

def get_current_widget():
    '''
    '''
    fn = _get_fn_by_version(idaapi, 'get_current_widget', 'get_current_tform', idaapi)
    return fn()


def get_widget_vdui(form_widget_ref):
    '''
    '''
    fn = _get_fn_by_version(idaapi, 'get_widget_vdui', 'get_tform_vdui', idaapi)
    return fn(form_widget_ref)


def is_byte(flags):
    '''
    Do flags indicate a byte type.

    :param flags: Flags for address.
    :type flags: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_byte', 'isByte', idc)
    return fn(flags)

def is_char0(flags):
    '''
    Do flags indicate a byte type.

    :param flags: Flags for address.
    :type flags: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_bytes, 'is_char0', 'isChar0', idc)
    return fn(flags)


def create_dword(ea):
    '''
    Convert to data.

    :param ea: Linear address .
    :type ea: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_bytes, 'create_data', 'MakeDword', idc)
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, ida_bytes.FF_DWORD, 4, idaapi.BADADDR)
    return fn(ea)


def op_plain_offset(ea, n, base):
    '''
    Convert operand to an offset.

    :param ea: Linear address.
    :type ea: int

    :param n: Number of operands.
    :type n: int

    :param base: Base of the offset.
    :type base: int

    :return:
    '''
    fn = _get_fn_by_version(idc, 'op_plain_offset', 'OpOff')
    return fn(ea, n, base)


def next_addr(ea):
    '''
    Get next address in the program.

    :param ea: Linear address.
    :type ea: int

    :return: Next address or BADADDR
    '''
    fn = _get_fn_by_version(ida_bytes, 'next_addr', 'NextAddr', idc)
    return fn(ea)


def can_decode(ea):
    '''
    Can the bytes at ea be decoded as an instruction?

    :param ea: Linear address
    :type ea: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_ua, 'can_decode', 'decode_insn', idaapi)
    return fn(ea)


def get_operands(insn):
    '''
    Get operands for the current address.

    :return:
    '''
    if idaapi.IDA_SDK_VERSION >= 700:
        return insn.ops
    return idaapi.cmd.Operands


def get_canon_feature(insn):
    '''
    Get operands for the provided instruction.

    :return:
    '''
    if idaapi.IDA_SDK_VERSION >= 700:
        return insn.get_canon_feature()
    return idaapi.cmd.get_canon_feature()


def get_segm_name(ea):
    '''
    Get name of a segment.

    :param ea: Any address within the segment.
    :type ea: int

    :return: Segement name.
    '''
    fn = _get_fn_by_version(idc, 'get_segm_name', 'SegName')
    return fn(ea)


def add_func(ea):
    '''
    Add a new function.

    :param ea: Start address.
    :type ea: int

    :return: bool
    '''
    fn = _get_fn_by_version(ida_funcs, 'add_func', 'MakeFunction', idc)
    return fn(ea)


def create_insn(ea):
    '''
    Create instruction.

    :param ea: Linear address
    :type ea: int

    :return: bool
    '''
    fn = _get_fn_by_version(idc, 'create_insn', 'MakeCode')
    return fn(ea)


def get_segm_end(ea):
    '''
    Get end address of a segment.

    :param ea: Linear address
    :type ea: int

    :return: Address
    '''
    fn = _get_fn_by_version(idc, 'get_segm_end', 'SegEnd')
    return fn(ea)


def get_segm_start(ea):
    '''
    Get start address of a segment.

    :param ea: Linear address
    :type ea: int

    :return: Address
    '''
    fn = _get_fn_by_version(idc, 'get_segm_start', 'SegStart')
    return fn(ea)


def insn_t():
    prop = _get_fn_by_version(idaapi, 'insn_t', 'cmd', idaapi)
    if idaapi.IDA_SDK_VERSION >= 700:
        return prop()
    else:
        return prop


def decode_insn(ea):
    """
    Decode instruction.
    :param ea: Linear address.
    :type ea: int

    :return: Instruction at ea.
    """
    fn = _get_fn_by_version(ida_ua, 'decode_insn', 'decode_insn', idaapi)
    if idaapi.IDA_SDK_VERSION >= 700:
        insn = ida_ua.insn_t()
        fn(insn, ea)
        return insn
    fn(ea)
    return idaapi.cmd


def get_bookmark(index):
    """
    Get bookmark

    :param index: Index of bookmark
    :type index: int

    :return: Address of bookmark
    """
    fn = _get_fn_by_version(idc, 'get_bookmark', 'GetMarkedPos')
    return fn(index)


def get_bookmark_desc(index):
    """
    Get bookmark description.

    :param index: Index of bookmark
    :type index: int

    :return:
    """
    fn = _get_fn_by_version(idc, 'get_bookmark_desc', 'GetMarkComment')
    return fn(index)


def set_color(ea, what, color):
    """
    Set item color.

    :param ea: Linear address.
    :type ea: int

    :param what: Type of the item, one of CIC_... contstants
    :type what: int

    :param color: New color code in RGB.
    :type color: int

    :return: bool
    """
    fn = _get_fn_by_version(idc, 'set_color', 'SetColor')
    return fn(ea, what, color)


def get_color(ea, what):
    """
    """
    fn = _get_fn_by_version(idc, 'get_color', 'GetColor')
    return fn(ea, what) & 0xFFFFFF


def msg(message):
    """
    Display a UTF-8 string in the message window.

    :param message: Message to print.
    :type message: str

    :return: PyObject * (what?)
    """
    fn = _get_fn_by_version(ida_kernwin, 'msg', 'Message', idc)
    return fn(message)


def get_highlighted_identifier():
    """
    Get currently highlighted text.

    :return: Highlighted text or ""
    """
    fn = _get_fn_by_version(ida_kernwin, 'get_highlight',
                            'get_highlighted_identifier', idaapi)

    if idaapi.IDA_SDK_VERSION >= 700:
        viewer = ida_kernwin.get_current_viewer()
        highlight = fn(viewer)
        if highlight and highlight[1]:
            return highlight[0]
    return fn()


def user_cancelled():
    fn = _get_fn_by_version(idaapi, 'user_cancelled', 'wasBreak', idaapi)
    return fn()


def start_ea(obj):
    """
    Return start ea for supplied object.

    :param obj: Object to retrieve start ea.

    :return: start ea.
    """
    if not obj:
        return None

    try:
        return obj.startEA
    except AttributeError:
        return obj.start_ea


def end_ea(obj):
    """
    Return end ea for supplied object.

    :param obj: Object to retrieve end ea.

    :return: end ea.
    """
    if not obj:
        return None

    try:
        return obj.endEA
    except AttributeError:
        return obj.end_ea


def set_func_flags(ea, flags):
    """
    Change function flags.

    :param ea: Any address belonging to the function.
    :type ea: int

    :param flags: Flags to set.
    :type flags: int

    :return: 0 - ok
    """
    fn = _get_fn_by_version(idc, 'set_func_attr', 'SetFunctionFlags')
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, idc.FUNCATTR_FLAGS, flags)
    return fn(ea, flags)


def set_func_attr(ea, flags, value):
    """
    """
    fn = _get_fn_by_version(idc, 'set_func_attr', 'SetFunctionFlags')
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, 36, value)
    return fn(ea, 36, value)


def get_func_flags(ea):
    """
    Get function flags.

    :param ea: Any address belonging to the function.
    :type ea: int

    :return: Flags
    """
    fn = _get_fn_by_version(idc, 'get_func_attr', 'GetFunctionFlags')
    if idaapi.IDA_SDK_VERSION >= 700:
        return fn(ea, idc.FUNCATTR_FLAGS)
    return fn(ea)


def get_input_file_path():
    fn = _get_fn_by_version(idaapi, 'get_input_file_path', 'GetInputFilePath', idc)
    return fn()


def get_ida_subdirs(sub_folder):
    if idaapi.IDA_SDK_VERSION > 700:
        return idaapi.get_ida_subdirs("plugins")
    else:
        USR_PLUGIN_PATH = os.path.join(idaapi.get_user_idadir(), sub_folder)
        SYS_PLUGIN_PATH = os.path.join(idaapi.idadir(idaapi.PLG_SUBDIR))
        return [USR_PLUGIN_PATH, SYS_PLUGIN_PATH]

def get_chunk_eas(func_addr):
    """
    Check if a function is divided into chunks.
    """
    # logger.debug('is_func_chunked {}'.format(func_addr))
    # Idea for this code is from:
    # http://code.google.com/p/idapython/source/browse/trunk/python/idautils.py?r=344

    func_iter = idaapi.func_tail_iterator_t(idaapi.get_func(func_addr))
    status = func_iter.main()
    while status:
        chunk = func_iter.chunk()
        yield (start_ea(chunk), end_ea(chunk))
        status = func_iter.next()

def _is_func_chunked(func_addr):
    for eas in get_chunk_eas(func_addr):
        return True
    return False

def calc_func_size(func_desc):
    if idaapi.IDA_SDK_VERSION >= 720:
        return ida_funcs.calc_func_size(func_desc)
    else:
        beg_addr = start_ea(func_desc)
        if _is_func_chunked(beg_addr):
            func_size = 0
            for beg, end in idautils.Chunks(beg_addr):
                func_size += end - beg
            return func_size
        else:
            end_addr = end_ea(func_desc)
            if end_addr > beg_addr:
                return end_addr - beg_addr
            else:
                return 0

def inf_get_cc_id():
    if idaapi.IDA_SDK_VERSION >= 900:
        return ida_ida.inf_get_cc_id()
    else:
        inf = idaapi.get_inf_structure()
        return inf.cc.id

```

`idaclu/ida_utils.py`:

```py
import collections
import re
#
import idc
import idaapi
import idautils
import ida_hexrays

# new backward-incompatible modules
try:
    import ida_dirtree
    from ssdeep import (
        hash as ssdeep_hash,
        compare as ssdeep_compare
    )
    from tlsh import (
        hash as tlsh_hash,
        diff as tlsh_diff
    )
except ImportError:
    pass

from idaclu import ida_shims


def manage_dir(dir_name, operation, is_abs):
    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    dir_ops = {
        'mkdir': False,
        'rmdir': True,
        'chdir': True
    }
    if is_abs:
        func_dir.chdir('/')
    is_dir = func_dir.isdir(dir_name)
    if is_dir if dir_ops[operation] else not is_dir:
        if operation in dir_ops.keys():
            getattr(func_dir, operation)(dir_name)
        else:
            raise Exception('%s - invalid ida_dirtree operation' % (operation))
        return True
    return False

def create_dir(dir_name, is_abs=True):
    return manage_dir(dir_name, 'mkdir', is_abs)
    
def remove_dir(dir_name, is_abs=True):
    return manage_dir(dir_name, 'rmdir', is_abs)
    
def change_dir(dir_name, is_abs=True):
    return manage_dir(dir_name, 'chdir', is_abs)

# logic / prefixes '%' and '_' are the opposites:
# 1. '%' - has always single occurence, '_' - not;
# 2. '%' cannot appear at the very beginning of a function name, '_' - can;
# 3. '%' is purely internal prefix representation, '_' - human representation;
# 4. '%' are the prefixes added automatically, '_' - manually

def is_pfx_valid(pfx):
    a_facts = ['@', '$', '?', '-', '+']
    is_complex = any(a in pfx for a in a_facts)
    is_numeric = re.match('^[0-9]+', pfx)
    is_blanked = pfx == ''
    return not (is_complex or is_numeric or is_blanked)

def get_func_prefs(func_name, is_dummy=True):
    if ((func_name.startswith('?') and '@' in func_name) or
        func_name.startswith('_')):
        return []
    pfx_dummy = 'sub_'
    prefs = []
    pfx = ''

    idx = 0
    func_name = func_name.rstrip('_%:')
    while idx < len(func_name):
        char = func_name[idx]
        if char in ['%', ':', '_']:
            pfx_len = 1 
            while (idx+pfx_len) < len(func_name) and func_name[idx+pfx_len] in ['_', ':']:
                pfx_len += 1

            if idx != 0:
                # uncomment, if underscore tail in pfx is needed
                # pfx += func_name[idx:idx+pfx_len]
                if is_pfx_valid(pfx):
                    prefs.append(pfx)
                pfx = ''
                
            idx += pfx_len-1
        else:
            pfx += char

        idx += 1

    if not is_dummy and pfx_dummy in prefs:
        prefs.remove(pfx_dummy)
    return prefs

def get_cleaned_funcname(func_name, is_diff=False):
    bad_part = ''
    for char in func_name:
        if not char.isalpha():
            bad_part += char
        else:
            break

    if is_diff:
        return bad_part
    else:
        return func_name[len(bad_part):]

def refresh_ui():
    ida_shims.refresh_idaview_anyway()
    widget = ida_shims.get_current_widget()
    widget_vdui = ida_shims.get_widget_vdui(widget)
    if widget_vdui:
        widget_vdui.refresh_ctext()

def graph_down(ea, path=set()):
    path.add(ea)
    call_instructions = []
    for address in idautils.FuncItems(ea):
        if not ida_shims.decode_insn(address):
            continue
        if not idaapi.is_call_insn(address):
            continue
        call_instructions.append(address)

    for x in call_instructions:
        for r in idautils.XrefsFrom(x, idaapi.XREF_FAR):
            if not r.iscode:
                continue
            func = idaapi.get_func(r.to)
            if not func:
                continue
            if (func.flags & (idaapi.FUNC_THUNK | idaapi.FUNC_LIB)) != 0:
                continue
            if r.to not in path:
                graph_down(r.to, path)
    return path

def recursive_prefix(addr):
    func_addr = ida_shims.get_name_ea(idaapi.BADADDR, ida_shims.get_func_name(addr))
    if func_addr == idaapi.BADADDR:
        ida_shims.msg("ERROR: function is not defined at 0x%08X\n" % addr)
        return
    nodes_xref_down = graph_down(func_addr, path=set([]))
    return nodes_xref_down

def get_nodes_edges(func_addr):
    func = idaapi.get_func(func_addr)
    g = idaapi.FlowChart(func)

    node_count = len(list(g))
    edge_count = 0
    for x in g:
        succ_count = len(list(x.succs()))
        pred_count = len(list(x.preds()))
        edge_count += (succ_count + pred_count)
    return (node_count, edge_count)

def get_func_ea_by_ref(func_ref):
    if isinstance(func_ref, int):
        return func_ref
    elif isinstance(func_ref, str):
        return idc.get_name_ea_simple(func_ref)
    elif isinstance(func_ref, func_t):
        return func_ref.start_ea

def get_func_item_eas(func_ref):
    func_ea = get_func_ea_by_ref(func_ref)
    for item_ea in list(idautils.FuncItems(func_ea)):
        if idaapi.is_code(ida_shims.get_full_flags(func_ea)):
            yield item_ea

def get_func_item_eas_once(func_ref):
    item_eas = []
    for ea in get_func_item_eas(func_ref):
        item_eas.append(ea)
    return item_eas

def get_func_set_attrs(fn_start=['sub_'], is_fn_start=True, attrs=['indx','addr','name', 'size', 'attr']):
    for func_idx, func_addr in enumerate(idautils.Functions()):
        func_name = ida_shims.get_func_name(func_addr)
        func_attr = idc.get_func_attr(func_addr, idc.FUNCATTR_FLAGS)
        func_desc = idaapi.get_func(func_addr)
        func_size = ida_shims.calc_func_size(func_desc)
        if any(func_name.startswith(pat) == is_fn_start for pat in fn_start):  # all ??
            attr_set = ()
            if 'indx' in attrs:
                attr_set += (func_idx,)
            if 'addr' in attrs:
                attr_set += (func_addr,)
            if 'name' in attrs:
                attr_set += (func_name,)
            if 'size' in attrs:
                attr_set += (func_size,)
            if 'attr' in attrs:
                attr_set += (func_attr,)
            yield attr_set


def is_function_solved(func_ref):
    EXPL_CALL_ARTS = [
        'call sub_',
        'call _',
        'call ds:',
        'call nullsub_',
        'call loc_',
        'call off_',
        'call j_j__',
        'call ??',
        ';',
        'jmp',
        'jz short sub_'
    ]

    func_ea = get_func_ea_by_ref(func_ref)
    item_eas = get_func_item_eas_once(func_ea)
    for item_idx, item_ea in enumerate(item_eas):
        if ida_shims.ua_mnem(item_ea) == 'call':
            item_dasm = idc.generate_disasm_line(item_ea, idaapi.GENDSM_FORCE_CODE)
            item_dasm_norm = ' '.join(item_dasm.split())
            if not any(item_dasm_norm.startswith(art) for art in EXPL_CALL_ARTS) and ' ; ' not in item_dasm:
                return False
    else:
        return True


def is_function_leaf(func_ref):
    func_ea = get_func_ea_by_ref(func_ref)
    item_eas = [item_ea for item_ea in get_func_item_eas(func_ea)]
    for item_ea in item_eas:
        if ida_shims.ua_mnem(item_ea) == 'call':
            return False
    else:
        if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':
            return False
        else:
            return True  # until some "calling activity" is discovered inside,
                         # each function is considered as a "leaf"-function

def get_dir_metrics(root_dir):
    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    ite = ida_dirtree.dirtree_iterator_t()

    s_folders = [root_dir]
    u_folders = collections.defaultdict(int)

    while len(s_folders):
        curr_path = s_folders.pop()
        func_dir.chdir(curr_path)
        status = func_dir.findfirst(ite, "*")

        while status:
            entry_name = func_dir.get_entry_name(func_dir.resolve_cursor(ite.cursor))
            cursor_abspath = func_dir.get_abspath(ite.cursor)
            if func_dir.isdir(cursor_abspath):
                current_dir_new = '{}/{}'.format('' if curr_path == '/' else curr_path, entry_name)
                s_folders.append(current_dir_new)
            elif func_dir.isfile(cursor_abspath):
                func_addr = idaapi.get_name_ea(0, entry_name)
                u_folders[curr_path] += 1   
            status = func_dir.findnext(ite)

    return list(u_folders.items())

def get_func_dirs(root_dir):
    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    ite = ida_dirtree.dirtree_iterator_t()

    s_folders = [root_dir]
    u_folders = [root_dir]

    while len(s_folders):
        curr_path = s_folders.pop()
        func_dir.chdir(curr_path)
        status = func_dir.findfirst(ite, "*")

        while status:
            entry_name = func_dir.get_entry_name(func_dir.resolve_cursor(ite.cursor))
            if func_dir.isdir(func_dir.get_abspath(ite.cursor)):
                current_dir_new = '{}/{}'.format('' if curr_path == '/' else curr_path, entry_name)
                s_folders.append(current_dir_new)
                if not current_dir_new in u_folders:
                    u_folders.append(current_dir_new)
            status = func_dir.findnext(ite)

    return u_folders

def get_dir_funcs(folders, is_root=True):
    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    ite = ida_dirtree.dirtree_iterator_t()
    idx = 0

    funcs = {}
    while idx < len(folders):
        curr_path = folders[idx]
        func_dir.chdir(curr_path)
        status = func_dir.findfirst(ite, "*")

        while status:
            entry_name = func_dir.get_entry_name(func_dir.resolve_cursor(ite.cursor))
            func_addr = ida_shims.get_name_ea(0, entry_name)
            if func_dir.isfile(func_dir.get_abspath(ite.cursor)):
                if is_root == False and curr_path == '/':
                    # if only the functions with non-standard dir are needed
                    pass
                else:
                    funcs[func_addr] = curr_path
            status = func_dir.findnext(ite)
        idx += 1

    return funcs

def get_func_name(func_ref):
    func_name = None
    if isinstance(func_ref, str):
        func_name = func_ref
    elif isinstance(func_ref, int):
        func_name = ida_shims.get_func_name(func_ref)
    else:
        raise ValueError("Invalid func reference")
    return func_name

def get_folder_norm(folder):
    return '' if folder == '/' else folder

def set_func_folder(func_ref, folder_src, folder_dst):
    func_name = get_func_name(func_ref)
    func_src = '{}/{}'.format(get_folder_norm(folder_src), func_name)
    func_dst = '{}/{}'.format(get_folder_norm(folder_dst), func_name)

    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    func_dir.chdir('/')
    func_dir.rename(func_src, func_dst)

def is_in_interval(addr, func_ivals, is_strict):
    if is_strict:
        return any(beg < addr < end for beg, end in func_ivals)
    else:
        return any(beg <= addr <= end for beg, end in func_ivals)

def get_func_ivals(func_addr):
    return [(func_beg, func_end) for func_beg, func_end in ida_shims.get_chunk_eas(func_addr)]

def get_chunk_count(func_addr):
    num_chunks = len(get_func_ivals(func_addr))
    return num_chunks

def is_addr_func(addr, func_addr, is_chunks, is_strict):
    func_ivals = None
    if is_chunks:
        func_ivals = get_func_ivals(func_addr)
    else:
        func_beg = func_addr
        func_end = idc.get_func_attr(func_addr, idc.FUNCATTR_END)
        func_ivals = [(func_beg, func_end)]

    return is_in_interval(addr, func_ivals, is_strict)

def is_func_wrapper(func_addr, is_precise=True):
    """
    Wrapper functions are typically short.
    x86_64 instructions can be up to 15 bytes in length, at average - 4/5;
    The defined frame is 64b, then a very rough approximation is as follows:
        15 bytes/instr ->  4 instr/func ->  1- 2 statements (min)
         5 bytes/instr -> 12 instr/func ->  4- 6 statements
         4 bytes/instr -> 16 instr/func ->  5- 8 statements
         2 bytes/instr -> 32 instr/func -> 10-11 statements (max)
    It is not sufficient to look up solely for function size,
    important to have instruction count boundary as well,
    because of the function chunks e.g. func_size=14 bytes, inst_count=99;
    Small function with many instructions is either "super slim" function,
    or it has unaccounted chunks.
    """

    flags = ida_shims.get_func_flags(func_addr)
    func_items = list(idautils.FuncItems(func_addr))

    api_pairs = [
        ('EnterCriticalSection', 'LeaveCriticalSection'),
        ('__SEH_prolog', '__SEH_epilog'),
        ('__lock', '__unlock'),
        ('__lockexit', '__unlockexit'),
        ('__lock_fhandle', '__unlock_fhandle'),
        ('__lock_file', '__unlock_file'),
        ('__lock_file2', '__unlock_file2'),
        ('_malloc', '_free'),
        ('_calloc', '_free'),
        ('_realloc', '_free'),
        ('___initstdio', '___endstdio'),
        ('__Init_thread_header', '__Init_thread_footer'),
        ('_fopen', '_fclose'),
        ('CreateMutexA', 'ReleaseMutex'),
        ('CreateMutexW', 'ReleaseMutex'),
        ('CreateSemaphoreA', 'ReleaseSemaphore'),
        ('CreateSemaphoreW', 'ReleaseSemaphore'),
        ('CreateThread', 'ExitThread'),
        ('AcquireSRWLockExclusive ', 'ReleaseSRWLockExclusive'),
        ('InitializeSRWLock  ', 'DeleteSRWLock'),
        ('CreateFileA', 'CloseHandle'),
        ('CreateFileW', 'CloseHandle'),
        ('VirtualProtect', 'VirtualFree'),
        ('HeapAlloc', 'HeapFree'),
        ('HeapReAlloc', 'HeapFree'),
        ('HeapCreate', 'HeapDestroy'),
        ('RegOpenKeyA', 'RegCloseKey'),
        ('RegOpenKeyW', 'RegCloseKey'),
        ('TlsAlloc', 'TlsFree'),
        ('GlobalLock', 'GlobalUnlock'),
        ('BeginPaint', 'EndPaint'),
        ('OpenProcess', 'ExitProcess'),
        ('CreateWindowExA', 'DestroyWindow'),
        ('CreateWindowExW', 'DestroyWindow'),
        ('___sbh_alloc_block', '___sbh_free_block')
    ]
    api_pair_beg = [p[0] for p in api_pairs]
    api_pair_end = [p[1] for p in api_pairs]

    func_beg = func_addr
    func_end = ida_shims.get_func_attr(func_addr, idc.FUNCATTR_END)

    call_num = 0
    pair_unm = []
    call_reg = set()
    func_nam = ida_shims.get_name(func_addr)
    func_mod = set()
    func_res = False
    # exclude recursive calls
    call_reg.add(func_nam)
    for inst_addr in idautils.FuncItems(func_addr):
        if is_precise:
            mnem = ida_shims.print_insn_mnem(inst_addr)
            oprd_val = ida_shims.get_operand_value(inst_addr, 0)
            oprd_typ = ida_shims.get_operand_type(inst_addr, 0)
            if (mnem == 'jmp' and 
                not is_addr_func(oprd_val, func_addr, is_precise, True)):
                call_nam = ida_shims.get_name(oprd_val)
                # exclude jump tables;
                # consider the case when there is more than one jmp/call inst.
                # pointing to the same function: call x, call x, jmp x
                if not call_nam.startswith('loc_') and not call_nam in call_reg:
                    call_num += 1
                    call_reg.add(call_nam)

            if mnem == 'call':
                if oprd_typ in [idc.o_mem, idc.o_far, idc.o_near]:
                    call_dst = list(idautils.CodeRefsFrom(inst_addr, 0))
                    if len(call_dst):
                        call_nam = ida_shims.get_name(call_dst[0])
                        if call_nam in api_pair_beg:
                            pair_unm.append(api_pair_beg.index(call_nam))
                        elif call_nam in api_pair_end:
                            elem_idx = api_pair_end.index(call_nam)
                            if elem_idx in pair_unm:
                                # there are numerous pair APIs of the form:
                                # alloc/free, open/close, create/destroy;
                                # consider the impact of a wrapping pair as - 0
                                pair_unm.remove(elem_idx)
                            else:
                                pair_unm.append(elem_idx)
                        else:
                            if not call_nam in call_reg and not call_nam in ['j__free']:
                                call_num += 1
                                call_reg.add(call_nam)
                elif is_precise and (oprd_typ in [idc.o_displ]):
                    dasm_line = ida_shims.generate_disasm_line(inst_addr, idaapi.GENDSM_FORCE_CODE)
                    call_vft = ' '.join(' '.join(dasm_line.split()).split()[1:])
                    if not call_vft in call_reg:
                        func_mod.add("ptr")
                        call_num += 1
                        call_reg.add(call_vft)

    if (call_num + len(pair_unm)) == 1:
        func_res = True
        if ((func_end - func_addr) > 0 and (func_end - func_addr) < 64) and len(func_items) <= 32:
            func_mod.add("small")
        else:
            # an attempt to collect wrapper functions that
            # otherwise will be missed due to too strict size constraint;
            # they are not that simple, have some additional logic
            # that probably should be considered separately
            func_mod.add("large")

    return (func_res, list(func_mod))

def is_func_thunk(func_addr):
    func_flags = ida_shims.get_func_flags(func_addr)
    return func_flags & idaapi.FUNC_THUNK

def get_code_refs_to(addr):
    return set([cref for cref in idautils.CodeRefsTo(addr, 0)])

def get_data_refs_to(addr):
    return set([dref for dref in idautils.DataRefsTo(addr)])

def get_refs_to(addr):
    return iter(get_code_refs_to(addr).union(get_data_refs_to(addr)))

def is_arch64():
    return bool(idaapi.getseg(ida_shims.get_first_seg()).bitness == 2)

def get_ptr_type():
    return [FF_DWORD, FF_QWORD][is_arch64()]

def get_ref_off():
    return [REF_OFF32, REF_OFF64][is_arch64()]

def get_ptr_size():
    return [4, 8][is_arch64()]

def get_ptr(addr):
    return [idaapi.get_32bit, idaapi.get_64bit][is_arch64()](addr)

def is_GCC_auto():
    if get_compiler_name() == 'GNU C++':
        return True
    return False

def is_GCC_manual():
    gcc_rtti_artifacts = [
        "St9type_info",
        "N10__cxxabiv117__class_type_infoE",
        "N10__cxxabiv120__si_class_type_infoE",
        "N10__cxxabiv121__vmi_class_type_infoE"
    ]

    flag = idaapi.SEARCH_CASE|idaapi.SEARCH_DOWN
    for art in gcc_rtti_artifacts:
        gcc_info = ida_shims.find_text(0x0, 0, 0, art, flag)
        if gcc_info != idaapi.BADADDR:
            return True
    return False

def is_vtable(addr):
    if addr and has_xref(addr):
        func_ea = get_ptr(addr)
        if func_ea and idaapi.getseg(func_ea):
            if ida_shims.get_segm_attr(func_ea, idc.SEGATTR_TYPE) == idc.SEG_CODE:
                func_desc = idaapi.get_func(func_ea)
                if func_desc and func_ea == ida_shims.start_ea(func_desc):
                    return True
    return False

def has_xref(addr):
    return ida_shims.has_xref(ida_shims.get_full_flags(addr))

def get_compiler_name():
    inf_cc_id = ida_shims.inf_get_cc_id()
    return idaapi.get_compiler_name(inf_cc_id)

def get_func_params(func_addr):
    params = []
    tif = idaapi.tinfo_t()
    if idaapi.get_tinfo(tif, func_addr):
        func_type_data = idaapi.func_type_data_t()
        if tif.get_func_details(func_type_data):
            for i, arg in enumerate(func_type_data):
                arg_name = arg.name if arg.name else 'a{}'.format(i+1)
                params.append({
                    "name": arg_name,
                    "type": arg.type.dstr()
                })
    return params

def check_type(type_name, type_list):
    for t in type_list:
        if type_name == t or f' {t}' in type_name or f'{t} ' in type_name:
            return True
    return False

def is_std_type(type_name):
    TYPES = [
        'void',
        'bool',
        'int',
        'short',
        'long',
        'float',
        'double',
        'char',
        'char16_t',
        'char32_t',
        'wchar_t',
        '__int8',
        '__int16',
        '__int32',
        '__int64',
        '__int128',
        '__m64',
        '__m128',
        '__m128d',
        '__m128i',
        'size_t',
        'FILE'
    ]
    return check_type(type_name, TYPES)

def is_win_type(type_name):
    TYPES = [
        'APIENTRY',
        'ATOM',
        'BOOL',
        'BOOLEAN',
        'BYTE',
        'CALLBACK',
        'CCHAR',
        'CHAR',
        'COLORREF',
        'CONST',
        'DWORD',
        'DWORDLONG',
        'DWORD_PTR',
        'DWORD32',
        'DWORD64',
        'FLOAT',
        'HACCEL',
        'HALF_PTR',
        'HANDLE',
        'HBITMAP',
        'HBRUSH',
        'HCOLORSPACE',
        'HCONV',
        'HCONVLIST',
        'HCURSOR',
        'HDC',
        'HDDEDATA',
        'HDESK',
        'HDROP',
        'HDWP',
        'HENHMETAFILE',
        'HFILE',
        'HFONT',
        'HGDIOBJ',
        'HGLOBAL',
        'HHOOK',
        'HICON',
        'HINSTANCE',
        'HKEY',
        'HKL',
        'HLOCAL',
        'HMENU',
        'HMETAFILE',
        'HMODULE',
        'HMONITOR',
        'HPALETTE',
        'HPEN',
        'HRESULT',
        'HRGN',
        'HRSRC',
        'HSZ',
        'HWINSTA',
        'HWND',
        'INT',
        'INT_PTR',
        'INT8',
        'INT16',
        'INT32',
        'INT64',
        'LANGID',
        'LCID',
        'LCTYPE',
        'LGRPID',
        'LONG',
        'LONGLONG',
        'LONG_PTR',
        'LONG32',
        'LONG64',
        'LPARAM',
        'LPBOOL',
        'LPBYTE',
        'LPCOLORREF',
        'LPCSTR',
        'LPCTSTR',
        'LPCVOID',
        'LPCWSTR',
        'LPDWORD',
        'LPHANDLE',
        'LPINT',
        'LPLONG',
        'LPSTR',
        'LPTSTR',
        'LPVOID',
        'LPWORD',
        'LPWSTR',
        'LRESULT',
        'PBOOL',
        'PBOOLEAN',
        'PBYTE',
        'PCHAR',
        'PCSTR',
        'PCTSTR',
        'PCWSTR',
        'PDWORD',
        'PDWORDLONG',
        'PDWORD_PTR',
        'PDWORD32',
        'PDWORD64',
        'PFLOAT',
        'PHALF_PTR',
        'PHANDLE',
        'PHKEY',
        'PINT',
        'PINT_PTR',
        'PINT8',
        'PINT16',
        'PINT32',
        'PINT64',
        'PLCID',
        'PLONG',
        'PLONGLONG',
        'PLONG_PTR',
        'PLONG32',
        'PLONG64',
        'POINTER_32',
        'POINTER_64',
        'POINTER_SIGNED',
        'POINTER_UNSIGNED',
        'PSHORT',
        'PSIZE_T',
        'PSSIZE_T',
        'PSTR',
        'PTBYTE',
        'PTCHAR',
        'PTSTR',
        'PUCHAR',
        'PUHALF_PTR',
        'PUINT',
        'PUINT_PTR',
        'PUINT8',
        'PUINT16',
        'PUINT32',
        'PUINT64',
        'PULONG',
        'PULONGLONG',
        'PULONG_PTR',
        'PULONG32',
        'PULONG64',
        'PUSHORT',
        'PVOID',
        'PWCHAR',
        'PWORD',
        'PWSTR',
        'QWORD',
        'SC_HANDLE',
        'SC_LOCK',
        'SERVICE_STATUS_HANDLE',
        'SHORT',
        'SIZE_T',
        'SSIZE_T',
        'TBYTE',
        'TCHAR',
        'UCHAR',
        'UHALF_PTR',
        'UINT',
        'UINT_PTR',
        'UINT8',
        'UINT16',
        'UINT32',
        'UINT64',
        'ULONG',
        'ULONGLONG',
        'ULONG_PTR',
        'ULONG32',
        'ULONG64',
        'UNICODE_STRING',
        'USHORT',
        'USN',
        'VOID',
        'WCHAR',
        'WINAPI',
        'WORD',
        'WPARAM'
    ]
    return check_type(type_name, TYPES)

def is_directx_type(type_name):
    TYPES = [
        'D3DBLEND',
        'D3DBRANCH',
        'D3DCMPFUNC',
        'D3DCOLOR',
        'D3DCOLORMODEL',
        'D3DCOLORVALUE',
        'D3DCULL',
        'D3DDEVICEDESC',
        'D3DEXECUTEBUFFERDESC',
        'D3DEXECUTEDATA',
        'D3DFILLMODE',
        'D3DFINDDEVICERESULT',
        'D3DFINDDEVICESEARCH',
        'D3DFIXED',
        'D3DFOGMODE',
        'D3DHVERTEX',
        'D3DINSTRUCTION',
        'D3DLIGHT',
        'D3DLIGHTDATA',
        'D3DLIGHTINGCAPS',
        'D3DLIGHTINGELEMENT',
        'D3DLIGHTSTATETYPE',
        'D3DLIGHTTYPE',
        'D3DLINE',
        'D3DLINEPATTERN',
        'D3DLVERTEX',
        'D3DMATERIAL',
        'D3DMATERIALHANDLE',
        'D3DMATRIX',
        'D3DMATRIXHANDLE',
        'D3DMATRIXLOAD',
        'D3DMATRIXMULTIPLY',
        'D3DOPCODE',
        'D3DPICKRECORD',
        'D3DPOINT',
        'D3DPRIMCAPS',
        'D3DPROCESSVERTICES',
        'D3DRECT',
        'D3DRENDERSTATETYPE',
        'D3DRMANIMATIONOPTIONS',
        'D3DRMBOX',
        'D3DRMCOLORMODEL',
        'D3DRMCOLORSOURCE',
        'D3DRMCOMBINETYPE',
        'D3DRMDEVICEPALETTECALLBACK',
        'D3DRMFILLMODE',
        'D3DRMFOGMODE',
        'D3DRMFRAMECONSTRAINT',
        'D3DRMFRAMEMOVECALLBACK',
        'D3DRMGROUPINDEX',
        'D3DRMIMAGE',
        'D3DRMLIGHTMODE',
        'D3DRMLIGHTTYPE',
        'D3DRMLOADCALLBACK',
        'D3DRMLOADMEMORY',
        'D3DRMLOADOPTIONS',
        'D3DRMLOADRESOURCE',
        'D3DRMLOADTEXTURECALLBACK',
        'D3DRMMAPPING',
        'D3DRMMAPPINGFLAG',
        'D3DRMMATERIALMODE',
        'D3DRMMATRIX4D',
        'D3DRMOBJECTCALLBACK',
        'D3DRMPALETTEENTRY',
        'D3DRMPALETTEFLAGS',
        'D3DRMPICKDESC',
        'D3DRMPROJECTIONTYPE',
        'D3DRMQUATERNION',
        'D3DRMRENDERQUALITY',
        'D3DRMSAVEOPTIONS',
        'D3DRMSHADEMODE',
        'D3DRMSORTMODE',
        'D3DRMTEXTUREQUALITY',
        'D3DRMUPDATECALLBACK',
        'D3DRMUSERVISUALCALLBACK',
        'D3DRMUSERVISUALREASON',
        'D3DRMVECTOR4D',
        'D3DRMVERTEX',
        'D3DRMWRAPCALLBACK',
        'D3DRMWRAPTYPE',
        'D3DRMXOFFORMAT',
        'D3DRMZBUFFERMODE',
        'D3DSHADEMODE',
        'D3DSPAN',
        'D3DSTATE',
        'D3DSTATS',
        'D3DSTATUS',
        'D3DTEXTUREADDRESS',
        'D3DTEXTUREBLEND',
        'D3DTEXTUREFILTER',
        'D3DTEXTUREHANDLE',
        'D3DTEXTURELOAD',
        'D3DTLVERTEX',
        'D3DTRANSFORMCAPS',
        'D3DTRANSFORMDATA',
        'D3DTRANSFORMSTATETYPE',
        'D3DTRIANGLE',
        'D3DVALUE',
        'D3DVECTOR',
        'D3DVERTEX',
        'D3DVIEWPORT',
        'DDBLTBATCH',
        'DDBLTFX',
        'DDCAPS',
        'DDCOLORKEY',
        'DDOVERLAYFX',
        'DDPIXELFORMAT',
        'DDSCAPS',
        'DDSURFACEDESC',
        'DIDATAFORMAT',
        'DIDEVCAPS',
        'DIDEVICEINSTANCE',
        'DIDEVICEINSTANCE',
        'DIDEVICEINSTANCEA',
        'DIDEVICEINSTANCEW',
        'DIDEVICEOBJECTDATA',
        'DIDEVICEOBJECTINSTANCE',
        'DIDEVICEOBJECTINSTANCE',
        'DIDEVICEOBJECTINSTANCEA',
        'DIDEVICEOBJECTINSTANCEW',
        'DIMOUSESTATE',
        'DIOBJECTDATAFORMAT',
        'DIPROPDWORD',
        'DIPROPHEADER',
        'DIPROPRANGE',
        'DIRECTXREGISTERAPP',
        'DIRECTXREGISTERAPP',
        'DIRECTXREGISTERAPPA',
        'DIRECTXREGISTERAPPW',
        'DPADDRESS',
        'DPCAPS',
        'DPCOMPORTADDRESS',
        'DPID',
        'DPLAPPINFO',
        'DPLCONNECTION',
        'DPLMSG_GENERIC',
        'DPMSG_ADDGROUP',
        'DPMSG_ADDPLAYER',
        'DPMSG_ADDPLAYERTOGROUP',
        'DPMSG_CREATEPLAYERORGROUP',
        'DPMSG_DELETEPLAYER',
        'DPMSG_DELETEPLAYERFROMGROUP',
        'DPMSG_DESTROYPLAYERORGROUP',
        'DPMSG_GENERIC',
        'DPMSG_GROUPADD',
        'DPMSG_GROUPDELETE',
        'DPMSG_HOST',
        'DPMSG_SESSIONLOST',
        'DPMSG_SETPLAYERORGROUPDATA',
        'DPMSG_SETPLAYERORGROUPNAME',
        'DPNAME',
        'DPSESSIONDESC',
        'DPSESSIONDESC2',
        'DS3DBUFFER',
        'DS3DLISTENER',
        'DSBCAPS',
        'DSBUFFERDESC',
        'DSCAPS',
        'HFASTFILE',
        'HRESULT',
        'IDirectPlay2A',
        'IDirectPlayLobbyA',
        'LPCDIDATAFORMAT',
        'LPCDIDEVICEINSTANCE',
        'LPCDIDEVICEINSTANCEA',
        'LPCDIDEVICEINSTANCEW',
        'LPCDIDEVICEOBJECTINSTANCE',
        'LPCDIDEVICEOBJECTINSTANCEA',
        'LPCDIDEVICEOBJECTINSTANCEW',
        'LPCDIOBJECTDATAFORMAT',
        'LPCDIPROPDWORD',
        'LPCDIPROPHEADER',
        'LPCDIPROPRANGE',
        'LPCDPLAPPINFO',
        'LPCDPLCONNECTION',
        'LPCDPNAME',
        'LPCDPSESSIONDESC2',
        'LPCLIPPERCALLBACK',
        'LPD3DBRANCH',
        'LPD3DCOLOR',
        'LPD3DDEVICEDESC',
        'LPD3DENUMDEVICESCALLBACK',
        'LPD3DENUMTEXTUREFORMATSCALLBACK',
        'LPD3DEXECUTEBUFFERDESC',
        'LPD3DEXECUTEDATA',
        'LPD3DFINDDEVICERESULT',
        'LPD3DFINDDEVICESEARCH',
        'LPD3DHVERTEX',
        'LPD3DINSTRUCTION',
        'LPD3DLIGHT',
        'LPD3DLIGHTDATA',
        'LPD3DLIGHTINGCAPS',
        'LPD3DLIGHTINGELEMENT',
        'LPD3DLINE',
        'LPD3DLVERTEX',
        'LPD3DMATERIAL',
        'LPD3DMATERIALHANDLE',
        'LPD3DMATRIX',
        'LPD3DMATRIXHANDLE',
        'LPD3DMATRIXLOAD',
        'LPD3DMATRIXMULTIPLY',
        'LPD3DPICKRECORD',
        'LPD3DPOINT',
        'LPD3DPRIMCAPS',
        'LPD3DPROCESSVERTICES',
        'LPD3DRECT',
        'LPD3DRMBOX',
        'LPD3DRMCOLORMODEL',
        'LPD3DRMCOLORSOURCE',
        'LPD3DRMCOMBINETYPE',
        'LPD3DRMFILLMODE',
        'LPD3DRMFOGMODE',
        'LPD3DRMFRAMECONSTRAINT',
        'LPD3DRMIMAGE',
        'LPD3DRMLIGHTMODE',
        'LPD3DRMLIGHTTYPE',
        'LPD3DRMLOADMEMORY',
        'LPD3DRMLOADRESOURCE',
        'LPD3DRMMAPPING',
        'LPD3DRMMATERIALMODE',
        'LPD3DRMPALETTEENTRY',
        'LPD3DRMPALETTEFLAGS',
        'LPD3DRMPICKDESC',
        'LPD3DRMPROJECTIONTYPE',
        'LPD3DRMQUATERNION',
        'LPD3DRMRENDERQUALITY',
        'LPD3DRMSHADEMODE',
        'LPD3DRMSORTMODE',
        'LPD3DRMTEXTUREQUALITY',
        'LPD3DRMUSERVISUALREASON',
        'LPD3DRMVECTOR4D',
        'LPD3DRMVERTEX',
        'LPD3DRMWRAPTYPE',
        'LPD3DRMXOFFORMAT',
        'LPD3DRMZBUFFERMODE',
        'LPD3DSPAN',
        'LPD3DSTATE',
        'LPD3DSTATS',
        'LPD3DSTATUS',
        'LPD3DTEXTUREHANDLE',
        'LPD3DTEXTURELOAD',
        'LPD3DTLVERTEX',
        'LPD3DTRANSFORMCAPS',
        'LPD3DTRANSFORMDATA',
        'LPD3DTRIANGLE',
        'LPD3DVALIDATECALLBACK',
        'LPD3DVALUE',
        'LPD3DVECTOR',
        'LPD3DVERTEX',
        'LPD3DVIEWPORT',
        'LPDDBLTBATCH',
        'LPDDBLTFX',
        'LPDDCAPS',
        'LPDDCOLORKEY',
        'LPDDENUMCALLBACK',
        'LPDDENUMCALLBACK',
        'LPDDENUMCALLBACKA',
        'LPDDENUMCALLBACKW',
        'LPDDENUMMODESCALLBACK',
        'LPDDENUMSURFACESCALLBACK',
        'LPDDFXROP',
        'LPDDOVERLAYFX',
        'LPDDPIXELFORMAT',
        'LPDDSCAPS',
        'LPDDSURFACEDESC',
        'LPDIDATAFORMAT',
        'LPDIDEVCAPS',
        'LPDIDEVICEINSTANCE',
        'LPDIDEVICEINSTANCE',
        'LPDIDEVICEINSTANCEA',
        'LPDIDEVICEINSTANCEW',
        'LPDIDEVICEOBJECTDATA',
        'LPDIDEVICEOBJECTINSTANCE',
        'LPDIDEVICEOBJECTINSTANCE',
        'LPDIDEVICEOBJECTINSTANCEA',
        'LPDIDEVICEOBJECTINSTANCEW',
        'LPDIENUMDEVICEOBJECTSCALLBACKA',
        'LPDIENUMDEVICEOBJECTSCALLBACKW',
        'LPDIENUMDEVICESCALLBACKA',
        'LPDIENUMDEVICESCALLBACKW',
        'LPDIMOUSESTATE',
        'LPDIOBJECTDATAFORMAT',
        'LPDIPROPDWORD',
        'LPDIPROPHEADER',
        'LPDIPROPRANGE',
        'LPDIRECT3D',
        'LPDIRECT3D',
        'LPDIRECT3DDEVICE',
        'LPDIRECT3DDEVICE',
        'LPDIRECT3DEXECUTEBUFFER',
        'LPDIRECT3DEXECUTEBUFFER',
        'LPDIRECT3DLIGHT',
        'LPDIRECT3DLIGHT',
        'LPDIRECT3DMATERIAL',
        'LPDIRECT3DMATERIAL',
        'LPDIRECT3DTEXTURE',
        'LPDIRECT3DTEXTURE',
        'LPDIRECT3DVIEWPORT',
        'LPDIRECT3DVIEWPORT',
        'LPDIRECTDRAW',
        'LPDIRECTDRAW2',
        'LPDIRECTDRAWCLIPPER',
        'LPDIRECTDRAWPALETTE',
        'LPDIRECTDRAWSURFACE',
        'LPDIRECTDRAWSURFACE2',
        'LPDIRECTINPUT',
        'LPDIRECTINPUTA',
        'LPDIRECTINPUTDEVICE',
        'LPDIRECTINPUTDEVICEA',
        'LPDIRECTINPUTDEVICEW',
        'LPDIRECTINPUTW',
        'LPDIRECTPLAY',
        'LPDIRECTPLAY',
        'LPDIRECTPLAY2',
        'LPDIRECTPLAY2A',
        'LPDIRECTPLAYLOBBY',
        'LPDIRECTPLAYLOBBYA',
        'LPDIRECTSOUND',
        'LPDIRECTSOUND3DBUFFER',
        'LPDIRECTSOUND3DLISTENER',
        'LPDIRECTSOUNDBUFFER',
        'LPDIRECTXDEVICEDRIVERSETUP',
        'LPDIRECTXDEVICEDRIVERSETUP',
        'LPDIRECTXREGISTERAPP',
        'LPDIRECTXREGISTERAPP',
        'LPDIRECTXREGISTERAPPA',
        'LPDIRECTXREGISTERAPPLICATION',
        'LPDIRECTXREGISTERAPPLICATION',
        'LPDIRECTXREGISTERAPPW',
        'LPDIRECTXSETUP',
        'LPDIRECTXSETUP',
        'LPDIRECTXSETUPISJAPAN',
        'LPDIRECTXSETUPISJAPANNEC',
        'LPDPADDRESS',
        'LPDPCAPS',
        'LPDPCOMPORTADDRESS',
        'LPDPENUMADDRESSCALLBACK',
        'LPDPENUMDPCALLBACK',
        'LPDPENUMDPCALLBACKA',
        'LPDPENUMPLAYERSCALLBACK',
        'LPDPENUMPLAYERSCALLBACK2',
        'LPDPENUMSESSIONSCALLBACK',
        'LPDPENUMSESSIONSCALLBACK2',
        'LPDPID',
        'LPDPLAPPINFO',
        'LPDPLCONNECTION',
        'LPDPLENUMADDRESSTYPESCALLBACK',
        'LPDPLENUMLOCALAPPLICATIONSCALLBACK',
        'LPDPLMSG_GENERIC',
        'LPDPMSG_ADDPLAYERTOGROUP',
        'LPDPMSG_CREATEPLAYERORGROUP',
        'LPDPMSG_DELETEPLAYERFROMGROUP',
        'LPDPMSG_DESTROYPLAYERORGROUP',
        'LPDPMSG_GENERIC',
        'LPDPMSG_HOST',
        'LPDPMSG_SESSIONLOST',
        'LPDPMSG_SETPLAYERORGROUPDATA',
        'LPDPMSG_SETPLAYERORGROUPNAME',
        'LPDPNAME',
        'LPDPSESSIONDESC',
        'LPDPSESSIONDESC2',
        'LPDS3DBUFFER',
        'LPDS3DLISTENER',
        'LPDSBCAPS',
        'LPDSBUFFERDESC',
        'LPDSCAPS',
        'LPDSENUMCALLBACKA',
        'LPDSENUMCALLBACKW',
        'LPLPDIRECTSOUNDBUFFER',
        'LPLPVOID',
        'LPSURFACESTREAMINGCALLBACK',
        'PDIRECTXREGISTERAPP',
        'PDIRECTXREGISTERAPP',
        'PDIRECTXREGISTERAPPA',
        'PDIRECTXREGISTERAPPW',
        '_D3DBRANCH',
        '_D3DCOLORVALUE',
        '_D3DDeviceDesc',
        '_D3DExecuteBufferDesc',
        '_D3DEXECUTEDATA',
        '_D3DFINDDEVICERESULT',
        '_D3DFINDDEVICESEARCH',
        '_D3DHVERTEX',
        '_D3DINSTRUCTION',
        '_D3DLIGHT',
        '_D3DLIGHTDATA',
        '_D3DLIGHTINGCAPS',
        '_D3DLIGHTINGELEMENT',
        '_D3DLINE',
        '_D3DLINEPATTERN',
        '_D3DLVERTEX',
        '_D3DMATERIAL',
        '_D3DMATRIX',
        '_D3DMATRIXLOAD',
        '_D3DMATRIXMULTIPLY',
        '_D3DPICKRECORD',
        '_D3DPOINT',
        '_D3DPrimCaps',
        '_D3DPROCESSVERTICES',
        '_D3DRECT',
        '_D3DRMBOX',
        '_D3DRMIMAGE',
        '_D3DRMLOADMEMORY',
        '_D3DRMLOADRESOURCE',
        '_D3DRMPALETTEENTRY',
        '_D3DRMPICKDESC',
        '_D3DRMQUATERNION',
        '_D3DRMVECTOR4D',
        '_D3DRMVERTEX',
        '_D3DSPAN',
        '_D3DSTATE',
        '_D3DSTATS',
        '_D3DSTATUS',
        '_D3DTEXTURELOAD',
        '_D3DTLVERTEX',
        '_D3DTRANSFORMCAPS',
        '_D3DTRANSFORMDATA',
        '_D3DTRIANGLE',
        '_D3DVECTOR',
        '_D3DVERTEX',
        '_D3DVIEWPORT',
        '_DDBLTBATCH',
        '_DDBLTFX',
        '_DDCAPS',
        '_DDCOLORKEY',
        '_DDOVERLAYFX',
        '_DDPIXELFORMAT',
        '_DDSCAPS',
        '_DDSURFACEDESC',
        '_DIDATAFORMAT',
        '_DIDEVCAPS',
        '_DIMOUSESTATE',
        '_DIOBJECTDATAFORMAT',
        '_DIRECTXREGISTERAPPA',
        '_DIRECTXREGISTERAPPW',
        '_DPADDRESS',
        '_DPCOMPORTADDRESS',
        '_DS3DBUFFER',
        '_DS3DLISTENER',
        '_DSBCAPS',
        '_DSBUFFERDESC',
        '_DSCAPS',
        'DIDEVICEINSTANCEA',
        'DIDEVICEINSTANCEW',
        'DIDEVICEOBJECTDATA',
        'DIDEVICEOBJECTINSTANCEA',
        'DIDEVICEOBJECTINSTANCEW',
        'DIPROPDWORD',
        'DIPROPHEADER',
        'DIPROPRANGE',
        'DPLAPPINFO',
        'DPLCONNECTION',
        'DPLMSG_GENERIC'
    ]
    return check_type(type_name, TYPES)

def is_unk_type(type_name):
    # Example: `const #1641 *`
    return '#' in type_name

def get_dt_type(type_name):
    if is_std_type(type_name):
        return "std"
    elif is_win_type(type_name):
        return "win"
    elif is_directx_type(type_name):
        return "ddx"
    elif is_unk_type(type_name):
        return "unk"
    else:
        return "usr"
        
def is_fn_typ_type(type_name):
    TYPES = [
        'BYTE1',
        'BYTE2',
        'BYTE3',
        'BYTE4',
        'BYTE5',
        'BYTE6',
        'BYTE7',
        'BYTE8',
        'BYTE9',
        'BYTE10',
        'BYTE11',
        'BYTE12',
        'BYTE13',
        'BYTE14',
        'BYTE15',
        'WORD1',
        'WORD2',
        'WORD3',
        'WORD4',
        'WORD5',
        'WORD6',
        'WORD7',
        'LOBYTE',
        'LOWORD',
        'LODWORD',
        'HIBYTE',
        'HIWORD',
        'HIDWORD',
        'SBYTE1',
        'SBYTE2',
        'SBYTE3',
        'SBYTE4',
        'SBYTE5',
        'SBYTE6',
        'SBYTE7',
        'SBYTE8',
        'SBYTE9',
        'SBYTE10',
        'SBYTE11',
        'SBYTE12',
        'SBYTE13',
        'SBYTE14',
        'SBYTE15',
        'SWORD1',
        'SWORD2',
        'SWORD3',
        'SWORD4',
        'SWORD5',
        'SWORD6',
        'SWORD7',
        'SLOBYTE',
        'SLOWORD',
        'SLODWORD',
        'SHIBYTE',
        'SHIWORD',
        'SHIDWORD',
        'COERCE_FLOAT',
        'COERCE_DOUBLE',
        'COERCE__INT64',
        'COERCE_UNSIGNED_INT',
        'COERCE_UNSIGNED_INT64'
    ]
    return type_name in TYPES

def is_fn_std_type(type_name):
    TYPES = [
        'abort',
        'abs',
        'acos',
        'asctime',
        'asin',
        'assert',
        'atan',
        'atan2',
        'atexit',
        'atof',
        'atoi',
        'atol',
        'bsearch',
        'calloc',
        'ceil',
        'clearerr',
        'clock',
        'cos',
        'cosh',
        'ctime',
        'difftime',
        'div',
        'exit',
        'exp',
        'fabs',
        'fclose',
        'feof',
        'ferror',
        'fflush',
        'fgetc',
        'fgetpos',
        'fgets',
        'floor',
        'fmod',
        'fopen',
        'fprintf',
        'fputc',
        'fputs',
        'fread',
        'free',
        'freopen',
        'frexp',
        'fscanf',
        'fseek',
        'fsetpos',
        'ftell',
        'fwrite',
        'getc',
        'getchar',
        'getenv',
        'gets',
        'gmtime',
        'isalnum',
        'isalpha',
        'iscntrl',
        'isdigit',
        'isgraph',
        'islower',
        'isprint',
        'ispunct',
        'isspace',
        'isupper',
        'isxdigit',
        'labs',
        'ldexp',
        'ldiv',
        'localeconv',
        'localtime',
        'log',
        'log10',
        'longjmp',
        'malloc',
        'mblen',
        'mbstowcs',
        'mbtowc',
        'memchr',
        'memcmp',
        'memcpy',
        'memmove',
        'memset',
        'mktime',
        'modf',
        'perror',
        'pow',
        'printf',
        'putc',
        'putchar',
        'puts',
        'qsort',
        'raise',
        'rand',
        'realloc',
        'remove',
        'rename',
        'rewind',
        'scanf',
        'setbuf',
        'setjmp',
        'setlocale',
        'setvbuf',
        'signal',
        'sin',
        'sinh',
        'sprintf',
        'sqrt',
        'srand',
        'sscanf',
        'strcat',
        'strchr',
        'strcmp',
        'strcoll',
        'strcpy',
        'strcspn',
        'strerror',
        'strftime',
        'strlen',
        'strncat',
        'strncmp',
        'strncpy',
        'strpbrk',
        'strrchr',
        'strspn',
        'strstr',
        'strtod',
        'strtok',
        'strtol',
        'strtoul',
        'strxfrm',
        'system',
        'tan',
        'tanh',
        'time',
        'tmpfile',
        'tmpnam',
        'tolower',
        'toupper',
        'ungetc',
        'va_arg',
        'va_end',
        'va_start',
        'vfprintf',
        'vprintf',
        'vsprintf',
        'wcstombs',
        'wctomb'
    ]
    return type_name in TYPES    

def is_fn_hlp_type(type_name):
    TYPES = [
        '__FYL2X__', 
        '__FSCALE__',
        '__F2XM1__',
        '__ROL1__',
        '__ROL2__',
        '__ROL4__',
        '__ROL8__',
        '__ROR1__',
        '__ROR2__',
        '__ROR4__',
        '__ROR8__',
        '__CS__',
        '__SS__',
        '__DS__',
        '__ES__',
        '__FS__',
        '__GS__',
        '__CFSHR__',
        '__CFSHL__',
        '__CFADD__',
        '__OFADD__',
        '__OFSUB__',
        '__SETP__',
        '__FSCALE__',
        'JUMPOUT',
        'BUG',
        '__halt',
        '__fastfail',
        '__debugbreak',
        '__rdtsc',
        '__readeflags',
        '__readfsdword',
        '__readgsdword',
        '__readfsqword',
        '__readgsqword',
        '__writeeflags',
        '__writefsdword',
        '__writegsdword',
        '__writefsqword',
        '__writegsqword'
    ]
    return type_name in TYPES    
 
def get_fn_type(type_name):
    if is_fn_typ_type(type_name):
        return "typ"
    elif is_fn_std_type(type_name):
        return "std"
    elif is_fn_hlp_type(type_name):
        return "hlp"
    else:
        return "usr"

def extract_calls_from_decompiled(func_ea):
    # Get statistics on calls originating from a single function.
    cfunc = ida_hexrays.decompile(func_ea)
    if not cfunc:
        return {}

    class CallVisitor(ida_hexrays.ctree_visitor_t):
        def __init__(self, cfunc):
            ida_hexrays.ctree_visitor_t.__init__(self, ida_hexrays.CV_FAST)
            self.calls = collections.defaultdict(dict)
            self.cfunc = cfunc

        def visit_expr(self, expr):
            # called by `apply_to()`
            if expr.op == ida_hexrays.cot_call:
                try:
                    callee_addr = expr.x.obj_ea
                except Exception:
                    callee_addr = -1

                args = []

                for arg in expr.a:
                    try:
                        arg_type = arg.type.dstr() if arg.type else "<unknown>"
                        arg_name = arg.print1(self.cfunc)
                    except Exception:
                        arg_type = "<unknown>"
                        arg_name = "<unknown>"

                    args.append({
                        "name": idaapi.tag_remove(arg_name),
                        "type": arg_type
                    })

                # The same function can be called from different locations within the given function, 
                # each with a unique set of parameters.
                self.calls[callee_addr][expr.ea] = args
            return 0

    visitor = CallVisitor(cfunc)
    visitor.apply_to(cfunc.body, None)

    return dict(visitor.calls)

```

`idaclu/idaclu.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>PluginDialog</class>
 <widget class="QDialog" name="PluginDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>960</width>
    <height>540</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>IdaClu v1.0</string>
  </property>
  <property name="windowIcon">
   <iconset resource="assets/resource.qrc">
    <normaloff>:/idaclu/icon_64.png</normaloff>:/idaclu/icon_64.png</iconset>
  </property>
  <layout class="QVBoxLayout" name="vlPluginDialog">
   <item>
    <widget class="QSplitter" name="DialogSplitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="childrenCollapsible">
      <bool>false</bool>
     </property>
     <widget class="QFrame" name="SidebarFrame">
      <layout class="QVBoxLayout" name="SidebarLayout">
       <property name="spacing">
        <number>0</number>
       </property>
       <property name="rightMargin">
        <number>1</number>
       </property>
       <item>
        <layout class="QVBoxLayout" name="ScriptsLayout">
         <property name="spacing">
          <number>0</number>
         </property>
         <item>
          <widget class="QPushButton" name="ScriptsHeader">
           <property name="minimumSize">
            <size>
             <width>200</width>
             <height>30</height>
            </size>
           </property>
           <property name="font">
            <font>
             <weight>75</weight>
             <bold>true</bold>
            </font>
           </property>
           <property name="cursor">
            <cursorShape>PointingHandCursor</cursorShape>
           </property>
           <property name="text">
            <string>TOOLSET</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QScrollArea" name="ScriptsArea">
           <property name="horizontalScrollBarPolicy">
            <enum>Qt::ScrollBarAlwaysOff</enum>
           </property>
           <property name="widgetResizable">
            <bool>true</bool>
           </property>
           <widget class="QWidget" name="wScriptsContents">
            <property name="geometry">
             <rect>
              <x>0</x>
              <y>0</y>
              <width>198</width>
              <height>284</height>
             </rect>
            </property>
           </widget>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <spacer name="sScriptsBottom">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeType">
          <enum>QSizePolicy::Fixed</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>10</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <layout class="QVBoxLayout" name="FiltersLayout">
         <property name="spacing">
          <number>0</number>
         </property>
         <item>
          <widget class="QPushButton" name="FiltersHeader">
           <property name="minimumSize">
            <size>
             <width>200</width>
             <height>30</height>
            </size>
           </property>
           <property name="font">
            <font>
             <weight>75</weight>
             <bold>true</bold>
            </font>
           </property>
           <property name="cursor">
            <cursorShape>PointingHandCursor</cursorShape>
           </property>
           <property name="text">
            <string>FILTERS</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QGroupBox" name="FiltersGroup">
           <layout class="QVBoxLayout" name="vlFiltersGroup">
            <property name="spacing">
             <number>0</number>
            </property>
            <property name="leftMargin">
             <number>0</number>
            </property>
            <property name="topMargin">
             <number>0</number>
            </property>
            <property name="rightMargin">
             <number>0</number>
            </property>
            <property name="bottomMargin">
             <number>0</number>
            </property>
            <item>
             <spacer name="sFilters1">
              <property name="orientation">
               <enum>Qt::Vertical</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Fixed</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>20</width>
                <height>15</height>
               </size>
              </property>
             </spacer>
            </item>
            <item>
             <layout class="QHBoxLayout" name="FolderFilterLayout">
              <item>
               <spacer name="sFolderFilterBeg">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
                <property name="sizeType">
                 <enum>QSizePolicy::Fixed</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>20</width>
                  <height>26</height>
                 </size>
                </property>
               </spacer>
              </item>
              <item>
               <widget class="FilterInputGroup" name="wFolderFilter" native="true">
                <property name="minimumSize">
                 <size>
                  <width>0</width>
                  <height>26</height>
                 </size>
                </property>
                <property name="maximumSize">
                 <size>
                  <width>16777215</width>
                  <height>26</height>
                 </size>
                </property>
               </widget>
              </item>
              <item>
               <spacer name="sFolderFilterEnd">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
                <property name="sizeType">
                 <enum>QSizePolicy::Fixed</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>20</width>
                  <height>26</height>
                 </size>
                </property>
               </spacer>
              </item>
             </layout>
            </item>
            <item>
             <spacer name="sFilters2">
              <property name="orientation">
               <enum>Qt::Vertical</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Fixed</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>20</width>
                <height>15</height>
               </size>
              </property>
             </spacer>
            </item>
            <item>
             <layout class="QHBoxLayout" name="PrefixFilterLayout">
              <item>
               <spacer name="sPrefixFilterBeg">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
                <property name="sizeType">
                 <enum>QSizePolicy::Fixed</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>20</width>
                  <height>26</height>
                 </size>
                </property>
               </spacer>
              </item>
              <item>
               <widget class="FilterInputGroup" name="wPrefixFilter" native="true">
                <property name="minimumSize">
                 <size>
                  <width>0</width>
                  <height>26</height>
                 </size>
                </property>
                <property name="maximumSize">
                 <size>
                  <width>16777215</width>
                  <height>26</height>
                 </size>
                </property>
               </widget>
              </item>
              <item>
               <spacer name="sPrefixFilterEnd">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
                <property name="sizeType">
                 <enum>QSizePolicy::Fixed</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>20</width>
                  <height>26</height>
                 </size>
                </property>
               </spacer>
              </item>
             </layout>
            </item>
            <item>
             <spacer name="sFilters3">
              <property name="orientation">
               <enum>Qt::Vertical</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Fixed</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>20</width>
                <height>15</height>
               </size>
              </property>
             </spacer>
            </item>
            <item>
             <layout class="QHBoxLayout" name="ColorFilterLayout">
              <item>
               <spacer name="sColorFilterBeg">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
                <property name="sizeType">
                 <enum>QSizePolicy::Fixed</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>40</width>
                  <height>26</height>
                 </size>
                </property>
               </spacer>
              </item>
              <item>
               <widget class="PaletteTool" name="wColorFilter" native="true">
                <property name="minimumSize">
                 <size>
                  <width>0</width>
                  <height>26</height>
                 </size>
                </property>
                <property name="maximumSize">
                 <size>
                  <width>16777215</width>
                  <height>26</height>
                 </size>
                </property>
               </widget>
              </item>
              <item>
               <spacer name="sColorFilterEnd">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
                <property name="sizeType">
                 <enum>QSizePolicy::Fixed</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>40</width>
                  <height>26</height>
                 </size>
                </property>
               </spacer>
              </item>
             </layout>
            </item>
            <item>
             <spacer name="sFilters4">
              <property name="orientation">
               <enum>Qt::Vertical</enum>
              </property>
              <property name="sizeType">
               <enum>QSizePolicy::Fixed</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>20</width>
                <height>15</height>
               </size>
              </property>
             </spacer>
            </item>
           </layout>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <spacer name="sFiltersBottom">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeType">
          <enum>QSizePolicy::Fixed</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>14</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
     <widget class="QFrame" name="MainFrame">
      <layout class="QVBoxLayout" name="MainLayout" stretch="0,8,1,0,1">
       <property name="spacing">
        <number>0</number>
       </property>
       <property name="leftMargin">
        <number>5</number>
       </property>
       <item>
        <widget class="ProgressIndicator" name="wProgressBar" native="true">
         <property name="minimumSize">
          <size>
           <width>0</width>
           <height>5</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>16777215</width>
           <height>5</height>
          </size>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QWidget" name="wResultsView" native="true">
         <layout class="QHBoxLayout" name="hlResultsView">
          <property name="leftMargin">
           <number>0</number>
          </property>
          <property name="topMargin">
           <number>0</number>
          </property>
          <property name="rightMargin">
           <number>0</number>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
          <item>
           <widget class="QTreeView" name="rvTable">
            <property name="contextMenuPolicy">
             <enum>Qt::CustomContextMenu</enum>
            </property>
            <property name="editTriggers">
             <set>QAbstractItemView::NoEditTriggers</set>
            </property>
            <property name="alternatingRowColors">
             <bool>true</bool>
            </property>
            <property name="selectionMode">
             <enum>QAbstractItemView::ExtendedSelection</enum>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <spacer name="sToolsTop">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeType">
          <enum>QSizePolicy::Fixed</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>10</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <layout class="QHBoxLayout" name="ToolsLayout">
         <item>
          <spacer name="sToolsBeg">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeType">
            <enum>QSizePolicy::Fixed</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>10</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="LabelTool" name="wLabelTool" native="true">
           <property name="minimumSize">
            <size>
             <width>320</width>
             <height>30</height>
            </size>
           </property>
           <property name="maximumSize">
            <size>
             <width>16777215</width>
             <height>30</height>
            </size>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="sToolsMid">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>80</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="PaletteTool" name="wColorTool" native="true">
           <property name="minimumSize">
            <size>
             <width>192</width>
             <height>30</height>
            </size>
           </property>
           <property name="maximumSize">
            <size>
             <width>16777215</width>
             <height>30</height>
            </size>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="sToolsEnd">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeType">
            <enum>QSizePolicy::Fixed</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>10</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item>
        <spacer name="sToolsBottom">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeType">
          <enum>QSizePolicy::Fixed</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>14</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>LabelTool</class>
   <extends>QWidget</extends>
   <header>qt_widgets</header>
   <container>1</container>
  </customwidget>
  <customwidget>
   <class>PaletteTool</class>
   <extends>QWidget</extends>
   <header>qt_widgets</header>
   <container>1</container>
  </customwidget>
  <customwidget>
   <class>ProgressIndicator</class>
   <extends>QWidget</extends>
   <header>qt_widgets</header>
   <container>1</container>
  </customwidget>
  <customwidget>
   <class>FilterInputGroup</class>
   <extends>QWidget</extends>
   <header>qt_widgets</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources>
  <include location="assets/resource.qrc"/>
 </resources>
 <connections/>
</ui>

```

`idaclu/idaclu_gui.py`:

```py
import collections
import json
import os
import re
import sys
import time
#
import idc
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_shims import (
    QCoreApplication,
    QCursor,
    Qt,
    QtCore,
    QFrame,
    QIcon,
    QLineEdit,
    QListView,
    QMenu,
    QPushButton,
    QSize,
    QSizePolicy,
    QSpacerItem,
    QStandardItem,
    QStandardItemModel,
    QStyledItemDelegate,
    QVBoxLayout,
    QWidget
)
from idaclu import ida_utils
from idaclu import plg_utils
from idaclu.ui_idaclu import Ui_PluginDialog
from idaclu.qt_utils import i18n
from idaclu.qt_widgets import FrameLayout
from idaclu.models import ResultModel, ResultNode
from idaclu.assets import resource

# new backward-incompatible modules
try:
    import ida_dirtree
except ImportError:
    pass


class InstrumentedCallback:
    """A wrapper class to count accesses to a callback."""

    def __init__(self, func, pass_count=0):
        self.func = func
        self.pass_count = pass_count
        self.call_count = 0

    def reset(self):
        self.call_count = 0

    def __call__(self, *args):
        self.call_count += 1

        if self.pass_count == 0:
            return self.func()
        else:
            return self.func(self.call_count, self.pass_count)

    def get_call_count(self):
        return self.call_count


class AppendTextEditDelegate(QStyledItemDelegate):
    def createEditor(self, parent, option, index):
        editor = QLineEdit(parent)
        return editor

    def setEditorData(self, editor, index):
        current_text = index.data()
        editor.setText(current_text)

    def setModelData(self, editor, model, index):
        current_text = index.data()
        new_text = editor.text()
        appended_text = "{}".format(new_text)
        model.setData(index, appended_text)
        func_addr = ida_shims.get_name_ea(0, current_text)
        ida_shims.set_name(func_addr, new_text, idaapi.SN_NOWARN)


class IdaCluDialog(QWidget):
    def __init__(self, env_desc):
        super(IdaCluDialog, self).__init__()
        self.env_desc = env_desc
        self.ui = Ui_PluginDialog(env_desc)
        self.ui.setupUi(self)

        self.ui.rvTable.setItemDelegate(AppendTextEditDelegate())

        self.is_sidebar_on_left = True
        self.is_filters_shown = True
        self.option_sender = None
        self.is_mode_recursion = False
        # values to initialize the corresponding filter

        self.clu_data = {}
        if self.env_desc.feat_folders:
            folders = ida_utils.get_func_dirs('/')
            self.clu_data['dirs'] = ida_utils.get_dir_funcs(folders)

        self.sel_dirs = []
        self.sel_prfx = []
        self.sel_colr = []

        sp_path = self.get_splg_root(self.env_desc.plg_src, 'idaclu')
        for frame in self.get_sp_controls(sp_path):
            self.ui.ScriptsContentsLayout.addWidget(frame)

        self.ui.wColorTool.setClickHandler(self.changeFuncColor)

        self.initFoldersFilter()
        self.initPrefixFilter()
        self.initColorFilter()
        self.bindUiElems()

    def toggleRecursion(self):
        self.is_mode_recursion = not self.is_mode_recursion

    def bindUiElems(self):
        self.bindClicks()
        self.ui.rvTable.doubleClicked.connect(self.treeDoubleClick)
        self.ui.rvTable.customContextMenuRequested.connect(self.showContextMenu)

    def bindClicks(self):
        feat_folders = self.env_desc.feat_folders
        bind_data = [
            (self.ui.ScriptsHeader, self.swapPosition, True),
            (self.ui.FiltersHeader, self.showFilters, True)
        ]
        for (elem, meth, cond) in bind_data:
            if cond:
                elem.clicked.connect(meth)
        self.ui.wLabelTool.setModeHandler(self.toggleRecursion)
        self.ui.wLabelTool.setSetHandler(self.addLabel)
        self.ui.wLabelTool.setClsHandler(self.clsLabel)

    def getFuncPrefs(self, is_dummy=False):
        pfx_afacts = ['%', '_']
        prefs = collections.defaultdict(int)
        for func_addr in idautils.Functions():
            func_name = ida_shims.get_func_name(func_addr)
            func_name = func_name.lstrip('_')
            if any(pa in func_name for pa in pfx_afacts):
                func_prefs = ida_utils.get_func_prefs(func_name, is_dummy)
                for pfx in func_prefs:
                    prefs[pfx] += 1
        return list(prefs.items())

    def getFuncColors(self):
        color_map = collections.defaultdict(int)
        for func_addr in idautils.Functions():
            func_colr = ida_shims.get_color(func_addr, idc.CIC_FUNC)
            color_map[func_colr] += 1

        colors = []
        for k,v in color_map.items():
            rgb = plg_utils.RgbColor(k)
            rgb.invert_color()
            colors.append((rgb.get_to_name(), v, rgb.get_to_tuple()))

        return colors

    def viewSelChanged(self):
        self.ui.wLabelTool.setEnabled(True)
        self.ui.wColorTool.setEnabled(True)

    def initPrefixFilter(self):
        prefixes = self.getFuncPrefs(is_dummy=True)
        self.ui.wPrefixFilter.addItems(prefixes, True)
        self.ui.wPrefixFilter.setText("")

    def initColorFilter(self):
        colors = self.getFuncColors()
        self.ui.wColorFilter.addItems(colors)
        self.ui.wColorFilter.setText("")

    def initFoldersFilter(self):
        if self.env_desc.feat_folders:
            folders = ida_utils.get_dir_metrics('/')
            self.ui.wFolderFilter.addItems(folders, True)
            self.ui.wFolderFilter.setText("")
        else:
            self.ui.wFolderFilter.removeSelf()
            self.ui.FolderFilterLayout.setParent(None)
            layout = self.ui.vlFiltersGroup
            item = layout.takeAt(0)
            if item:
                widget = item.widget()
                if widget:
                    widget.deleteLater()
                del item

    def sample_generator(self):
        if False:
            yield

    def has_parent_widget(self, sender_button, dropdown_class):
        parent_widget = sender_button.parent()
        for i in range(parent_widget.layout().count()):
            sub_item = parent_widget.layout().itemAt(i)
            sub_widget = sub_item.widget()
            if sub_widget and (isinstance(sub_widget, dropdown_class)):
                return True
        return False

    def get_plugin_data(self):
        self.ui.rvTable.setModelProxy(ResultModel(self.ui.rvTable.heads, [], self.env_desc))

        try:
            sender_button = self.sender()
            self.ui.rvTable.rec_indx.clear()

            full_spec_name = sender_button.objectName()
            elem, cat, plg = full_spec_name.split('#')

            root_folder = self.env_desc.plg_src
            module = None
            with plg_utils.PluginPath(os.path.join(root_folder, 'idaclu', 'plugins', cat)):
                module = __import__(plg)
                del sys.modules[plg]

            script_name = getattr(module, 'SCRIPT_NAME')
            script_type = getattr(module, 'SCRIPT_TYPE', 'custom')
            script_view = getattr(module, 'SCRIPT_VIEW', 'table')
            script_args = getattr(module, 'SCRIPT_ARGS', [])

            if not script_type in ['func', 'custom']:
                ida_shims.msg('ERROR: Unknown plugin type')
                return

            directory = os.path.dirname(self.env_desc.idb_path)
            json_filename = "{}_idaclu_{}.json".format(self.env_desc.ida_module, script_name.lower().replace(' ', '_'))
            cs_cache_file = os.path.join(directory, json_filename)

            cs_data = None
            is_pre_filter = script_type == 'func'
            func_filter = self.updatePbFunc if is_pre_filter else self.updatePb

            if self.ui.ConfigTool.is_save and os.path.isfile(cs_cache_file):
                with open(cs_cache_file, "r") as json_file:
                    cs_data = json.load(json_file)
                self.ui.wProgressBar.updateProgress(50, "Phase: loading")
            else:
                if os.path.isfile(cs_cache_file):
                    os.remove(cs_cache_file)

                plug_params = {}
                if self.option_sender != None:
                    widget = self.ui.ScriptsArea.findChild(QPushButton, self.option_sender)
                    parent_layout = widget.parent().layout()

                    if self.option_sender == full_spec_name:
                        for i in range(parent_layout.count()):
                            sub_item = parent_layout.itemAt(i)
                            if sub_item:
                                sub_widget = sub_item.widget()
                                if sub_widget and type(sub_widget) == QFrame:
                                    param_name = sub_widget.objectName().replace("{}__".format(full_spec_name), "")
                                    states = []
                                    for i in range(sub_widget.layout().count()):
                                        widget = sub_widget.layout().itemAt(i).widget()
                                        if isinstance(widget, QLineEdit):
                                            states.append(widget.text())  # .toPlainText()
                                    plug_params[param_name] = states
                                if sub_widget and type(sub_widget) == QListView:
                                    param_name = sub_widget.objectName().replace("{}__".format(full_spec_name), "")
                                    states = []
                                    for row in range(sub_widget.model().rowCount()):
                                        item = sub_widget.model().item(row)
                                        text = item.text()
                                        checked = item.checkState() == Qt.Checked
                                        states.append((text, checked))
                                    plug_params[param_name] = states

                    for i in range(parent_layout.count()):
                        sub_item = parent_layout.itemAt(i)
                        if sub_item:
                            # if isinstance(sub_item, QSpacerItem):
                            #     parent_layout.removeItem(sub_item)
                            #     continue
                            sub_widget = sub_item.widget()
                            if sub_widget and type(sub_widget) in [QFrame, QListView]:
                                parent_layout.removeWidget(sub_widget)
                                sub_widget.setParent(None)

                    self.option_sender = None

                elif self.option_sender == None and len(script_args) > 0:
                    parent_widget = sender_button.parent()
                    if parent_widget:
                        for i, (ctrl_name, var_name, ctrl_ctx) in enumerate(script_args):
                            if ctrl_name == "textedit":
                                if not self.has_parent_widget(sender_button, QFrame):
                                    content_widget = QFrame()
                                    vbox = QVBoxLayout(content_widget)
                                    parent_widget.layout().addWidget(content_widget)
                                    content_widget.setMaximumSize(QSize(16777215, 60))
                                    content_widget.setObjectName("{}__{}".format(full_spec_name, var_name))
                                    for text in ctrl_ctx:
                                        text_edit = QLineEdit()
                                        text_edit.setPlaceholderText(text)
                                        vbox.addWidget(text_edit)
                            if ctrl_name == "checkbox":
                                if not self.has_parent_widget(sender_button, QListView):
                                    list_view = QListView()
                                    parent_widget.layout().addWidget(list_view)
                                    parent_widget.setMaximumSize(QSize(16777215, 160))
                                    model = QStandardItemModel()
                                    list_view.setModel(model)
                                    list_view.setObjectName("{}__{}".format(full_spec_name, var_name))

                                    for text in ctrl_ctx:
                                        item = QStandardItem(text)
                                        item.setCheckable(True)
                                        item.setCheckState(False)  # Unchecked
                                        model.appendRow(item)

                        # spacer = QSpacerItem(20, 30, QSizePolicy.Fixed, QSizePolicy.MinimumExpanding)
                        # parent_widget.layout().addStretch(1)
                        self.option_sender = full_spec_name
                        return

                get_cs_data = getattr(module, 'get_data')

                gen = InstrumentedCallback(self.sample_generator)
                get_cs_data(gen, self.env_desc, plug_params)
                phase_count = gen.get_call_count()
                gen = InstrumentedCallback(func_filter, phase_count)
                cs_data = get_cs_data(gen, self.env_desc, plug_params)

                if self.ui.ConfigTool.is_save:
                    with open(cs_cache_file, "w") as json_file:
                        json.dump(cs_data, json_file, indent=4)

            self.items = []

            cp_data = collections.defaultdict(list)
            cs_func_count = sum(len(band_fns) for band_fns in cs_data.values())
            cs_func_idx = 0

            if (self.ui.ConfigTool.is_save or is_pre_filter == False):
                self.sel_dirs = self.ui.wFolderFilter.getData()
                self.sel_prfx = self.ui.wPrefixFilter.getData()
                self.sel_colr = self.ui.wColorFilter.getData()

            # Iterating over "rubber-banded hooks" where:
            #  - the "band" - is function cluster
            #  - the "hook" - is function address (with optional comment)
            # The aim to augment "hooks" with useful for analysis data
            # to be presented in main tree-table view of the plugin.
            for band_nam in cs_data:
                for hook_val in cs_data[band_nam]:
                    func_addr, func_cmnt = None, None
                    if isinstance(hook_val, int):
                        func_addr, func_cmnt = hook_val, ""
                    elif self.env_desc.ver_py == 2 and isinstance(hook_val, long):
                        func_addr, func_cmnt = int(hook_val), ""
                    elif isinstance(hook_val, tuple) or isinstance(hook_val, list):
                        func_addr = int(hook_val[0])  # long in IDA v6.x;
                        func_cmnt = str(hook_val[1])  # just in case

                    if (self.ui.ConfigTool.is_save or is_pre_filter == False) and self.isFuncRelevant(func_addr) == False:
                        continue

                    # Getting function info from function "hook".
                    func_inst = idaapi.get_func(func_addr)
                    func_name = ida_shims.get_func_name(func_addr)
                    func_colr = plg_utils.RgbColor(ida_shims.get_color(func_addr, idc.CIC_FUNC))
                    func_colr.invert_color()
                    func_path = None
                    func_node, func_edge = ida_utils.get_nodes_edges(func_addr)

                    # Storing function data.
                    func_desc = collections.OrderedDict()
                    func_desc['func_name'] = func_name

                    if self.env_desc.feat_folders:
                        dir_info = self.clu_data['dirs']
                        func_path = dir_info[func_addr] if func_addr in dir_info else '/'
                        func_desc['func_path'] = func_path

                    func_desc['func_addr'] = hex(func_addr)
                    func_desc['func_size'] = ida_shims.calc_func_size(func_inst)
                    func_desc['func_chnk'] = len(list(idautils.Chunks(func_addr)))
                    func_desc['func_node'] = func_node  # graph node count
                    func_desc['func_edge'] = func_edge  # graph edge count
                    func_desc['func_cmnt'] = func_cmnt
                    func_desc['func_colr'] = func_colr.get_to_str()

                    cp_data[band_nam].append(func_desc)
                    cs_func_idx += 1
                    # Augmenting function data is represented as 15% of progress.
                    cs_prog = plg_utils.get_prog_val(50, 15, cs_func_idx, cs_func_count)
                    self.ui.wProgressBar.updateProgress(cs_prog, "Phase: augmenting")

            # Constructing list of node trees.
            # The list contains only parent nodes, that internally have references to child nodes.
            cs_func_idx = 0
            for band_idx, (band_nam, func_dss) in enumerate(cp_data.items()):
                self.items.append(ResultNode("{} ({})".format(band_nam, len(func_dss))))
                for func_idx, func_dsc in enumerate(func_dss):
                    self.items[-1].addChild(ResultNode(list(func_dsc.values())))
                    cs_func_idx += 1
                    finished = plg_utils.get_prog_val(65, 30, cs_func_idx, cs_func_count)
                    self.ui.rvTable.rec_indx[int(func_dsc['func_addr'], 16)].append((band_idx, func_idx))
                    self.ui.wProgressBar.updateProgress(finished, "Phase: indexing")

            self.ui.rvTable.setModelProxy(ResultModel(self.ui.rvTable.heads, self.items, self.env_desc))
            self.ui.wProgressBar.updateProgress(100, "Phase: completing")
            self.prepareView()
        except plg_utils.UserCancelledError:
            return

    def prepareView(self):
        view = self.ui.rvTable
        rvTableSelModel = view.selectionModel()
        tree_header = view.header()

        view.setColumnHidden(self.ui.rvTable.heads.index('Color'), True)
        rvTableSelModel.selectionChanged.connect(self.viewSelChanged)
        tree_header.resizeSection(0, 240)
        tree_header.resizeSection(1, 96)
        tree_header.resizeSection(2, 96)
        tree_header.resizeSection(3, 96)

    def updatePb(self, curr_idx, total_count):
        finished = int(70 * (curr_idx / float(total_count)))
        finished_msg = "Phase: searching (steps {}/{})".format(curr_idx, total_count)
        try:
            self.ui.wProgressBar.updateProgress(finished, finished_msg)
        except plg_utils.UserCancelledError:
            raise plg_utils.UserCancelledError

    def updatePbFunc(self, pass_index=1, pass_count=1):
        self.sel_dirs = self.ui.wFolderFilter.getData()
        self.sel_prfx = self.ui.wPrefixFilter.getData()
        self.sel_colr = self.ui.wColorFilter.getData()

        func_desc = list(idautils.Functions())
        func_count = len(func_desc)
        for func_index, func_addr in enumerate(func_desc):

            if not self.isFuncRelevant(func_addr):
                continue

            progress = None
            finished = None

            if pass_count == 1:
                index = func_index + 1
                count = func_count
                name = "funcs"

                progress = func_index / float(func_count)
                finished = int(50 * progress)
            else:
                index = pass_index
                count = pass_count
                name = "steps"

                pass_contrib_one = 50 / pass_count
                pass_contrib_sum = pass_contrib_one * (pass_index - 1)
                progress = func_index / float(func_count)
                finished =int(pass_contrib_sum + pass_contrib_one * progress)

            finished_msg = "Phase: searching ({} {}/{})".format(name, index, count)
            try:
                self.ui.wProgressBar.updateProgress(finished, finished_msg)
            except plg_utils.UserCancelledError:
                raise plg_utils.UserCancelledError

            yield func_addr

    def isFuncRelevant(self, func_addr):
        # function directories
        if len(self.sel_dirs) and self.sel_dirs[0] != '':
            if not (func_addr in self.clu_data['dirs'] and
                self.clu_data['dirs'][func_addr] in self.sel_dirs):
                return False
        # function name prefixes
        func_name = ida_shims.get_func_name(func_addr)
        func_prfx = ida_utils.get_func_prefs(func_name, True)
        if len(self.sel_prfx) and self.sel_prfx[0] != '':
            if self.ui.wPrefixFilter.getState() == True:
                if len(func_prfx) != len(self.sel_prfx) or not all(p in self.sel_prfx for p in func_prfx):
                    return False
            else:
                if not any(p in self.sel_prfx for p in func_prfx):
                    return False
        # function highlight color
        func_colr = plg_utils.RgbColor(ida_shims.get_color(func_addr, idc.CIC_FUNC))
        func_colr.invert_color()

        if len(self.sel_colr) and self.sel_colr[0] != '':
            if not any(func_colr == plg_utils.RgbColor(cn) for cn in self.sel_colr):
                return False
        return True

    def treeDoubleClick(self, index):
        if not index.isValid():
            return None
        addr_index = index.sibling(index.row(), self.getFuncAddrCol())
        cell_data = addr_index.data()
        if cell_data and cell_data.startswith('0x'):
            idaapi.jumpto(plg_utils.from_hex(cell_data))

    def getLabelNorm(self, label_mode):
        label_name = None
        if label_mode == 'folder':
            label_name = self.ui.wLabelTool.getLabelName(prfx="/")
        elif label_mode == 'prefix':
            label_name = self.ui.wLabelTool.getLabelName(sufx="_")
        return label_name

    def updateFilters(self, label_mode, changelog):
        if label_mode == 'folder':
            fback = self.ui.wFolderFilter.chgItems(changelog, is_sorted=True)
            for fdir in fback:
                ida_utils.remove_dir(fdir)
        elif label_mode == 'prefix':
            self.ui.wPrefixFilter.chgItems(changelog, is_sorted=True)
        elif label_mode == 'color':
            self.ui.wColorFilter.chgItems(changelog, is_sorted=True)

    def isDataSelected(self):
        return self.ui.rvTable.selectionModel().hasSelection()

    def addLabel(self):
        if self.isDataSelected():
            label_mode = self.ui.wLabelTool.getLabelMode()
            label_norm = self.getLabelNorm(label_mode)

            if self.env_desc.feat_folders and label_mode == 'folder':
                ida_utils.create_dir(label_norm, is_abs=True)

            addr_queue = self.getLabelAddrSet()
            changelog = {
                'sub': collections.defaultdict(int),
                'add': collections.defaultdict(int),
            }

            model = self.ui.rvTable.model()
            name_col = self.ui.rvTable.heads.index('Name')
            fldr_col = self.ui.rvTable.heads.index('Folder')

            for func_addr in addr_queue:
                func_name = ida_shims.get_func_name(func_addr)
                for id_group, id_child in self.ui.rvTable.rec_indx[func_addr]:
                    if label_mode == 'prefix':
                        if not re.match("{0}%|{0}_".format(label_norm[:-1]), func_name):
                            func_name_new = plg_utils.add_prefix(func_name, label_norm, False)
                            ida_shims.set_name(func_addr, func_name_new, idaapi.SN_CHECK)
                            indx_child = model.index(id_child, name_col, model.index(id_group, 0))
                            model.layoutAboutToBeChanged.emit()
                            model.setData(indx_child, func_name_new)
                            model.layoutChanged.emit()
                            for tkn in label_norm.split('_'):
                                if tkn != '':
                                    changelog['add'][tkn] += 1
                    elif label_mode == 'folder':
                        folder_src = self.clu_data['dirs'].get(func_addr, '/')
                        if label_norm != folder_src:
                            self.clu_data['dirs'][func_addr] = label_norm
                            changelog['sub'][folder_src] += 1
                            changelog['add'][label_norm] += 1
                            ida_utils.set_func_folder(func_addr, folder_src, label_norm)
                            indx_child = model.index(id_child, fldr_col, model.index(id_group, 0))
                            model.layoutAboutToBeChanged.emit()
                            model.setData(indx_child, label_norm)
                            model.layoutChanged.emit()
                    else:
                        ida_shims.msg('ERROR: unknown label mode')
                        return

            if len(changelog['sub']) or len(changelog['add']):
                self.updateFilters(label_mode, changelog)
            if self.env_desc.ver_py > 2:
                ida_utils.refresh_ui()

    def clsLabel(self):
        if self.ui.rvTable.selectionModel().hasSelection():
            indexes = [index for index in self.ui.rvTable.selectionModel().selectedRows()]
            data = [index.sibling(index.row(), self.getFuncAddrCol()).data() for index in indexes]
            changelog = {
                'sub': collections.defaultdict(int),
                'add': collections.defaultdict(int),
            }

            model = self.ui.rvTable.model()
            name_col = self.ui.rvTable.heads.index('Name')
            fldr_col = self.ui.rvTable.heads.index('Folder')

            for idx, addr_field in enumerate(set(data)):
                func_addr = int(addr_field, base=16)
                func_name = ida_shims.get_func_name(func_addr)
                for id_group, id_child in self.ui.rvTable.rec_indx[func_addr]:
                    label_mode = self.ui.wLabelTool.getLabelMode()
                    if label_mode == 'prefix':
                        func_prefs = ida_utils.get_func_prefs(func_name, True)
                        last_pref = func_prefs[0]
                        if len(func_prefs) >= 1 and last_pref != 'sub':
                            func_name_new = re.sub('{0}%|{0}_'.format(last_pref), '', func_name, 1)
                            # cleanup in case of next bad prefix in front
                            func_name_new = ida_utils.get_cleaned_funcname(func_name_new)
                            ida_shims.set_name(func_addr, func_name_new, idaapi.SN_NOWARN)
                            indx_child = model.index(id_child, name_col, model.index(id_group, 0))
                            model.layoutAboutToBeChanged.emit()
                            model.setData(indx_child, func_name_new)
                            model.layoutChanged.emit()
                            changelog['sub'][last_pref] += 1
                    elif label_mode == 'folder':
                        func_fldr = self.clu_data['dirs'].get(func_addr, '/')
                        changelog['sub'][func_fldr] += 1
                        changelog['add']['/'] += 1
                        ida_utils.set_func_folder(func_addr, func_fldr, '/')
                        indx_child = model.index(id_child, fldr_col, model.index(id_group, 0))
                        model.layoutAboutToBeChanged.emit()
                        model.setData(indx_child, '/')
                        model.layoutChanged.emit()
                        self.clu_data['dirs'][func_addr] = '/'
                    else:
                        ida_shims.msg('ERROR: unknown label mode')
                        return
            self.updateFilters(label_mode, changelog)
            if self.env_desc.ver_py > 2:
                ida_utils.refresh_ui()

    def showContextMenu(self, point):
        ix = self.ui.rvTable.indexAt(point)
        if ix.column() == 0:
            menu = QMenu()
            renameAction = menu.addAction(QIcon(':/idaclu/icon_64.png'), i18n("Rename"))
            action = menu.exec_(self.ui.rvTable.mapToGlobal(point))
            if action == renameAction:
                self.ui.rvTable.edit(ix)

    def getFuncAddrCol(self):
        if self.env_desc.feat_folders:
            return 2
        else:
            return 1

    def changeFuncColor(self):
        if self.isDataSelected():
            sender_button = self.sender()
            btn_name = sender_button.objectName()
            color_set = None
            if btn_name == 'SetColorBlue':
                color_set = plg_utils.RgbColor((199,255,255), 'blue')
            elif btn_name == 'SetColorYellow':
                color_set = plg_utils.RgbColor((255,255,191), 'yellow')
            elif btn_name == 'SetColorGreen':
                color_set = plg_utils.RgbColor((191,255,191), 'green')
            elif btn_name == 'SetColorPink':
                color_set = plg_utils.RgbColor((255,191,239), 'pink')
            elif btn_name == 'SetColorNone':
                color_set = plg_utils.RgbColor((255,255,255), 'none')
            else:
                ida_shims.msg('ERROR: unknown palette button')

            addr_queue = self.getLabelAddrSet()

            changelog = {
                'sub': collections.defaultdict(int),
                'add': collections.defaultdict(int),
            }

            model = self.ui.rvTable.model()
            id_col = self.ui.rvTable.heads.index('Color')

            for func_addr in addr_queue:
                for id_group, id_child in self.ui.rvTable.rec_indx[func_addr]:
                    color_get = plg_utils.RgbColor(ida_shims.get_color(func_addr, idc.CIC_FUNC))
                    color_get.invert_color()
                    ida_shims.set_color(func_addr, idc.CIC_FUNC, color_set.get_to_int(True))
                    indx_child = model.index(id_child, id_col, model.index(id_group, 0))
                    model.layoutAboutToBeChanged.emit()
                    model.setData(indx_child, color_set.get_to_str())
                    model.layoutChanged.emit()

                    changelog['sub'][color_get.get_to_name()] += 1
                    changelog['add'][color_set.get_to_name()] += 1
            self.updateFilters('color', changelog)
            if self.env_desc.ver_py > 2:
                ida_utils.refresh_ui()

    def getLabelAddrSet(self):
        id_col = self.ui.rvTable.heads.index('Address')
        indexes = [idx for idx in self.ui.rvTable.selectionModel().selectedRows()]
        fields = [idx.sibling(idx.row(), id_col).data() for idx in indexes]

        addr_queue = set()
        for idx, field in enumerate(fields):
            func_addr = int(field, base=16)
            addr_queue.add(func_addr)

        addr_calees = set()
        if self.is_mode_recursion == True:
            for func_addr in addr_queue:
                addr_calees.update(ida_utils.recursive_prefix(func_addr))

        addr_queue.update(addr_calees)
        return addr_queue

    def swapPosition(self, reset=False):
        layout = self.ui.DialogSplitter

        layout_sizes = None
        if reset:
            layout_width = layout.width()
            l_size = int(layout_width * 0.3)
            r_size = int(layout_width * 0.7)
            layout_sizes = [l_size, r_size] if self.is_sidebar_on_left else [r_size, l_size]
        else:
            layout_sizes = layout.sizes()
            layout_sizes = layout_sizes[::-1]

        self.ui.SidebarFrame.setParent(None)
        self.ui.MainFrame.setParent(None)

        if self.is_sidebar_on_left:
            layout.insertWidget(0, self.ui.MainFrame)
            layout.insertWidget(1, self.ui.SidebarFrame)
        else:
            layout.insertWidget(0, self.ui.SidebarFrame)
            layout.insertWidget(1, self.ui.MainFrame)

        # layout.setCollapsible(0,False)
        # layout.setCollapsible(1,False)
        layout.setSizes(layout_sizes)

        self.is_sidebar_on_left = not self.is_sidebar_on_left

    def showFilters(self):
        if not self.is_filters_shown:
            self.ui.FiltersGroup.setMinimumSize(QSize(16777215, 16777215))
            self.ui.FiltersGroup.setMaximumSize(QSize(16777215, 16777215))
        else:
            self.ui.FiltersGroup.setMinimumSize(QSize(16777215, 1))
            self.ui.FiltersGroup.setMaximumSize(QSize(16777215, 1))

        self.is_filters_shown = not self.is_filters_shown

    def get_splg_root(self, plg_path, plg_fldr):
        splg_root = os.path.join(plg_path, plg_fldr, 'plugins')
        return splg_root

    def get_splg_tree(self, plg_splg_path):
        plg_tree = {}
        if os.path.exists(plg_splg_path):
            plg_tree = plg_utils.get_ordered_folder_tree(plg_splg_path)
        return plg_tree

    def is_sp_fname(self, sp_fname):
        return sp_fname.startswith('plugin_') and sp_fname.endswith('.py') and sp_fname != '__init__.py'

    def get_sp_controls(self, sp_path):
        sp_tree = self.get_splg_tree(sp_path)

        # depth of folder tree containing plugins is known
        for gdx, spg_ref in enumerate(sp_tree):
            if len(sp_tree[spg_ref]):
                spg_path = str(os.path.join(sp_path, spg_ref))
                spg_name = getattr(plg_utils.import_path(spg_path), 'PLUGIN_GROUP_NAME')
                spg_title = '{}. {}'.format(str(gdx+1), spg_name)

                spg_layout = FrameLayout(title=spg_title, env=self.env_desc)
                spg_layout.setProperty('class', 'frame')
                for sp_fname in sp_tree[spg_ref]:
                    plg_btn = None
                    if not self.is_sp_fname(sp_fname):
                        continue
                    sp_bname = sp_fname.replace('.py', '')
                    sp_name = sp_bname
                    # initial name is equal to file base name
                    # in case name will be not defined in plugin

                    sp_module = None
                    spe_msg = ""
                    # make sub-plugin discoverable in its group for importing
                    with plg_utils.PluginPath(os.path.join(sp_path, spg_ref)):
                        is_plug_ok = False
                        try:
                            sp_module = __import__(sp_bname)
                            del sys.modules[sp_bname]
                        except ImportError as err:
                            # in case some dependency is sub-plugin is missing
                            # the corresponding button will be disabled and
                            # tooltip will show this error
                            module_name = None
                            if self.env_desc.ver_py == 3:
                                module_name = err.name
                            else:
                                module_name = err.args[0].rsplit(' ',1)[-1]  # there is no .name attribute for Python2
                            spe_msg = "Module not found: {}".format(module_name)
                            # Attempt to open the module as a text file
                            # at least to recover sub-plugin name
                            try:
                                with open(os.path.join(sp_path, spg_ref, sp_fname), 'r') as file:
                                    for line in file:
                                        match = re.search(r'SCRIPT_NAME\s*=\s*["\']([^"\']+)', line)
                                        if match:
                                            sp_name = match.group(1)
                                            # self.log.debug("Recovered SCRIPT_NAME:", sp_name)
                                            break
                                    else:
                                        pass
                                        # self.log.debug("SCRIPT_NAME definition was not found")
                            except FileNotFoundError:
                                pass
                                # self.log.debug("Module file not found")
                        else:
                            is_plug_ok = True

                    # an attempt to load sub-plugin finished
                    # let's draw a corresponding button
                    sp_name = getattr(sp_module, 'SCRIPT_NAME', sp_name)
                    sp_layout = QVBoxLayout()
                    sp_frame = QFrame()
                    sp_frame.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
                    sp_frame.setObjectName('Frame#{}#{}'.format(spg_ref, sp_bname))

                    sp_button = QPushButton(sp_name)
                    if is_plug_ok:
                        sp_button.clicked.connect(self.get_plugin_data)
                    else:
                        sp_button.setEnabled(False)
                        sp_button.setToolTip(spe_msg)

                    sp_button.setObjectName('Button#{}#{}'.format(spg_ref, sp_bname))
                    sp_layout.addWidget(sp_button)
                    sp_frame.setLayout(sp_layout)
                    spg_layout.addWidget(sp_frame)
                yield spg_layout

```

`idaclu/models.py`:

```py
from re import split

from idaclu.qt_shims import (
    QAbstractItemModel,
    QBrush,
    QColor,
    QModelIndex,
    Qt,
    QtCore
)


class ResultNode(object):
    def __init__(self, data, parent=None):
        if isinstance(data, tuple):
            self._data = list(data)
        elif isinstance(data, str) or not hasattr(data, '__getitem__'):
            # data is not indexable
            self._data = [data]
        else:
            self._data = data

        self._col_count = len(self._data)
        self._children = []
        self._parent = parent

    def data(self, col):
        # len(self._data) - actual column count
        # self.columnCount() - column allocation for the node
        if 0 <= col < len(self._data):
            _data = self._data[col]
            return str(_data) if _data != None else ""

    def columnCount(self):
        return self._col_count

    def childCount(self):
        return len(self._children)

    def child(self, row):
        if 0 <= row < self.childCount():
            return self._children[row]

    def parent(self):
        return self._parent

    def row(self):
        return self.childCount()

    def addChild(self, child):
        child._parent = self
        self._children.append(child)
        self._col_count = max(child.columnCount(), self._col_count)

    def setData(self, col, val):
        if 0 <= col < len(self._data):
            self._data[col] = val
            return True
        return False

class ResultModel(QAbstractItemModel):

    def __init__(self, heads, nodes, env_desc):
        super(ResultModel, self).__init__()
        self.env = env_desc
        self.iroot = ResultNode([])
        self.heads = heads
        self.bg_col = heads.index('Color') if 'Color' in heads else None
        for node in nodes:
            self.iroot.addChild(node)

    def rowCount(self, parent_idx=QModelIndex()):
        parent_item = self.getItem(parent_idx)
        return parent_item.childCount()

    def addChild(self, data, parent_idx=QModelIndex()):
        parent_item = self.getItem(parent_idx)
        child_item = None
        is_obj = isinstance(data, ResultNode)
        child_item = data if is_obj else ResultNode(data, parent_item)
        parent_item.addChild(child_item)

    def index(self, row, col, _parent=QModelIndex()):
        parent = self.getItem(_parent)

        if not self.hasIndex(row, col, _parent):
            return QModelIndex()

        child = parent.child(row)
        if child:
            return self.createIndex(row, col, child)
        return QModelIndex()

    def parent(self, index):
        if index.isValid():
            child_item = self.getItem(index)
            parent_item = child_item.parent()
            if parent_item == self.iroot:
                return QModelIndex()
            return self.createIndex(parent_item.row(), 0, parent_item)
        # Return an invalid QModelIndex() to indicate "no parent."
        return QModelIndex()

    def columnCount(self, parent_idx=QModelIndex()):
        parent_item = self.getItem(parent_idx)
        return parent_item.columnCount()

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        node = self.getItem(index)

        if role == Qt.DisplayRole:
            col = index.column()
            data = node.data(col)
            return data.replace('%', '_') if self.heads[col] == 'Name' else data
        elif role == Qt.BackgroundRole:
            rgb_string = node.data(self.bg_col)
            if rgb_string and rgb_string != 'rgb(255,255,255)':
                r, g, b = map(int, rgb_string.removeprefix("rgb(").removesuffix(")").split(","))
                color = QColor(r, g, b)
                if self.env.lib_qt == 'pyqt5':
                    return color
                elif self.env.lib_qt == 'pyside':
                    brush = QBrush(color)
                    return brush
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.heads[section]
        return None

    def flags(self, index):
        return Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable

    def setData(self, index, value, role=Qt.EditRole):
        if not index.isValid() or role != Qt.EditRole:
            return False

        item = self.getItem(index)
        set_col = index.column()
        lib_qt = self.env.lib_qt

        if value.startswith('rgb'):
            beg_col = 0
            end_col = set_col if lib_qt == 'pyqt5' else None
            roles = [Qt.BackgroundRole]
        else:
            beg_col = set_col
            end_col = set_col + 1 if lib_qt == 'pyqt5' else None
            roles = [Qt.EditRole]

        item.setData(set_col, value)
        beg_idx = index.sibling(index.row(), beg_col)
        if lib_qt == 'pyqt5':
            end_idx = index.sibling(index.row(), end_col)
            self.dataChanged.emit(beg_idx, end_idx, roles)
        elif lib_qt == 'pyside':
            self.dataChanged.emit(beg_idx, roles)
        return True

    def getItem(self, index):
        if index and index.isValid():
            # Get the pointer to the item associated with the index.
            item = index.internalPointer()
            if item:
                return item
        # Return the root item if the index is invalid.
        return self.iroot

```

`idaclu/plg_utils.py`:

```py
import collections
import os
import re
import sys


class PluginPath():
    def __init__(self, path):
        self.path = path

    def __enter__(self):
        sys.path.insert(0, self.path)

    def __exit__(self, exc_type, exc_value, traceback):
        try:
            sys.path.remove(self.path)
        except ValueError:
            pass

class RgbColor:
    def __init__(self, color_ref, color_nam='unknown'):
        ver_py = sys.version_info.major
        self.palette_val = {
            13107199: 'blue',    # '#C7FFFF'
            16777151: 'yellow',  # '#FFFFBF'
            12582847: 'green',   # '#BFFFBF'
            16760815: 'pink',    # '#FFBFEF'
            16777215: 'none'     # '#FFFFFF'
        }
        self.palette_nam = {v: k for k, v in self.palette_val.items()}

        if (ver_py == 2 and
            any(isinstance(color_ref, t) for t in (int, long)) and
            color_ref <= 0xFFFFFFFF):
            self.r, self.g, self.b = self.get_from_tuple(int(color_ref))
        elif (ver_py == 3 and
            isinstance(color_ref, int) and
            color_ref <= 0xFFFFFFFF):
            self.r, self.g, self.b = self.get_from_tuple(color_ref)
        elif isinstance(color_ref, tuple) and len(color_ref) == 3:
            self.r, self.g, self.b = color_ref
        elif isinstance(color_ref, str) or isinstance(color_ref, unicode):
            self.r, self.g, self.b = self.get_from_str(color_ref)
        else:
            raise ValueError("Invalid init value: {}/{}".format(type(color_ref), color_ref))
        self.name = color_nam

    def invert_color(self):
        self.r, self.g, self.b = self.b, self.g, self.r

    def is_color_defined(self):
        return self.get_to_int() in self.palette_val

    def get_from_tuple(self, rgb_int):
        r = (rgb_int >> 16) & 255
        g = (rgb_int >> 8) & 255
        b = rgb_int & 255
        return (r, g, b)

    def get_to_tuple(self):
        return (self.r, self.g, self.b)

    def get_from_str(self, color_ref):
        rgb_pat = r'rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)'
        match = re.search(rgb_pat, color_ref)
        if match:
            r, g, b =  map(int, match.groups())
            if not all(0 <= c <= 255 for c in (r, g, b)):
                raise ValueError("Invalid color component values")
            return (r, g, b)
        elif color_ref in self.palette_nam:
            return self.get_from_tuple(self.palette_nam[color_ref])
        else:
            raise ValueError("Invalid 'rgb(r,g,b)' string format")

    def get_to_str(self):
        return "rgb({},{},{})".format(self.r, self.g, self.b)

    def get_to_int(self, reverse=False):
        return (
            (self.b << 16 | self.g << 8 | self.r) if reverse
            else (self.r << 16 | self.g << 8 | self.b)
        )

    def get_to_hash(self):
        hex_string = hex(self.get_to_int())[2:]
        hex_color = hex_string.rjust(6, '0')
        hex_color_code = '#' + hex_color.upper()
        return hex_color_code

    def get_to_name(self):
        col_int = self.get_to_int()
        return self.palette_val[col_int] if col_int in self.palette_val else self.get_to_hash()

    def __eq__(self, b):
        if isinstance(b, RgbColor):
            return self.r == b.r and self.g == b.g and self.b == b.b
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return self.get_to_str()

class UserCancelledError(Exception):
    pass


def from_hex(hex_sv):
    return int(hex_sv, base=16)

def invert_dict(original_dict):
    inverted_dict = {}
    for key, value in original_dict.items():
        if value not in inverted_dict:
            inverted_dict[value] = []
        inverted_dict[value].append(key)
    return inverted_dict

def add_prefix(func_name, func_pref, is_shadow=False):
    dlim_vars = ['%', '_']
    dlim_char = dlim_vars[int(is_shadow)]
    pref_norm = func_pref.strip('_')
    if is_shadow == False:
        dlim_anti = dlim_vars[int(not is_shadow)] 
        if dlim_anti in pref_norm:
            pref_norm = pref_norm.replace(dlim_anti, dlim_char)
    func_name_new = '{}{}{}'.format(pref_norm, dlim_char, func_name)
    return func_name_new

def get_folder_tree(root_folder):
    folder_structure = {}
    for folder_name in os.listdir(root_folder):
        folder_path = os.path.join(root_folder, folder_name)
        if os.path.isdir(folder_path):
            folder_structure[folder_name] = get_folder_tree(folder_path)
        else:
            folder_structure[folder_name] = "file"
    return folder_structure

def get_ordered_folder_tree(root_folder):
    return collections.OrderedDict(sorted(get_folder_tree(root_folder).items()))

def import_path(path):
    strpath = str(path)
    parent_path = os.path.dirname(os.path.abspath(path))
    sys.path.append(parent_path)
    module = __import__(os.path.basename(path))
    sys.path.pop()
    return module

def get_prog_val(base, range, part, whole):
    return base + int(range * (part / whole))

```

`idaclu/plugins/group_1/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Xref Analysis')

```

`idaclu/plugins/group_1/plugin_1.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Xref Count')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z\: ]+)(\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_xref_count = len(list(idautils.XrefsTo(func_addr)))

        xref_key = "xrefs: {}".format(func_xref_count)

        report['data'][xref_key].append(func_addr)
        report['stat'][xref_key] += 1

    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])
    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_1/plugin_2.py`:

```py
import collections
import json
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Xref Source')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_func_item_eas(func_addr):
    for item_ea in list(idautils.FuncItems(func_addr)):
        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):
            yield item_ea

def is_func_leaf(func_addr):
    item_eas = list(get_func_item_eas(func_addr))
    for item_ea in item_eas:
        if ida_shims.ua_mnem(item_ea) == 'call':
            return False
    else:
        if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':
            return False
        else:
            return True

def is_func_expl(func_addr):
    call_afacts = [
        'call sub_',
        'call _',
        'call ds:',
        'call nullsub_',
        'call loc_',
        'call off_',
        'call j_',
        'call ??',
        ';',
        'jmp',
        'jz short sub_'
    ]

    for item_addr in get_func_item_eas(func_addr):
        if ida_shims.ua_mnem(item_addr) == 'call':

            dasm_flag = idaapi.GENDSM_FORCE_CODE
            dasm_line = ida_shims.generate_disasm_line(item_addr, dasm_flag)
            dasm_norm = ' '.join(dasm_line.split())

            if (not any(dasm_norm.startswith(art) for art in call_afacts) and
                ' ; ' not in dasm_line):
                return False
    else:
        return True

def get_func_type_src(func_addr):
    if is_func_leaf(func_addr):
        return 'leaf'
    is_wrap, wrap_mod = ida_utils.is_func_wrapper(func_addr)
    if is_wrap:
        return "wrap_{}".format("_".join(sorted(wrap_mod)))
    if is_func_expl(func_addr):
        return 'expl'
    else:
        return 'impl'

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_type = get_func_type_src(func_addr)

        report['data'][func_type].append(func_addr)
        report['stat'][func_type] += 1

    report['data'] = collections.OrderedDict(sorted(report['data'].items()))
    report['stat'] = collections.OrderedDict(sorted(report['stat'].items()))
    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_1/plugin_3.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Xref Destination')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []

def is_fname_main(func_name):
    is_main = func_name.startswith('_') and 'main' in func_name.lower()
    return is_main

def is_func_lib(func_addr):
    func_name = ida_shims.get_func_name(func_addr)
    is_dummy = func_name.startswith('sub_')
    is_main = is_fname_main(func_name)
    func_flags = ida_shims.get_func_flags(func_addr)
    is_lib_flag = func_flags & idaapi.FUNC_LIB
    return is_lib_flag and not is_dummy and not is_main

def is_func_thunk(func_addr):
    func_flags = ida_shims.get_func_flags(func_addr)
    return func_flags & idaapi.FUNC_THUNK

def is_func_imp(func_addr):
    dasm_line = ida_shims.generate_disasm_line(func_addr, idaapi.GENDSM_FORCE_CODE)
    dasm_norm = ' '.join(dasm_line.split())
    return dasm_norm.startswith('jmp ds:__imp_')

def is_lib(func_addr):
    func_name = ida_shims.get_func_name(func_addr)
    if (is_func_lib(func_addr) or
        is_fname_lib(func_name, True) or
        ida_shims.get_segm_name(func_addr) == 'extern'):
        return True
    else:
        return False

def is_fname_lib(func_name, is_main=True):
    exclude_funcs = []
    if is_main == True:
        exclude_funcs.extend(['_main', '_wmain', '_WinMain@16'])

    if (not func_name in exclude_funcs) and \
        (
            func_name.startswith('_') or
            func_name.startswith('?') or
            func_name.startswith('unknown_libname_') or
            func_name.startswith('@_') or
            func_name.startswith('j_@_')
        ):
        return True
    else:
        return False

def is_fname_payload(func_name):
    lib_payload = [
        "`anonymous namespace'",
        "??1exception@boost@@MAE@XZ",
        "___std_parallel_algorithms_hw_threads@0",
        "?try_lock_for@stl_critical_section_concrt@details@Concurrency@@UAE_NI@Z",
        "?source_line@dbg_eng_data@?A0xbc047679@@QAEIQBX@Z"
    ]
    return any(func_name.startswith(x) for x in lib_payload)

def get_lib_prefixes():
    lib_prefix = [
        'lib_explicit_',
        'lib_implicit_',
        'j_lib_explicit_',
        'j_lib_implicit_'
    ]
    return lib_prefix

def is_fname_prefix(func_name):
    return any(func_name.startswith(p) for p in get_lib_prefixes())

def get_xref_addrs(func_addr):
    for xref in idautils.XrefsTo(func_addr):
        yield xref.frm

def get_cref_addrs(func_addr):
    for cref in idautils.CodeRefsTo(func_addr, 1):
        yield cref

def get_func_types_dst(func_addr):
    func_name = ida_shims.get_func_name(func_addr)
    func_type_dst = []

    for xref_addr in get_xref_addrs(func_addr):
        if ida_shims.is_code(ida_shims.get_full_flags(xref_addr)):
            xref_desc = idaapi.get_func(xref_addr)
            xref_name = ida_shims.get_func_name(xref_addr)

            if is_lib(xref_addr) and not is_fname_payload(xref_name):
                func_type_dst.append('lib_explicit')
            elif is_fname_prefix(xref_name):
                func_type_dst.append('lib_implicit')
            else:
                func_type_dst.append('payload')
        else:
            if ida_shims.get_segm_name(xref_addr) in ['.rdata', '.data']:
                func_type_dst.append('vftable')
            else:
                func_type_dst.append('unknown')

    return func_type_dst

def cleanup_lib_funcs(func_gen):
    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        if is_fname_prefix(func_name):
            lib_prefix = get_lib_prefixes()
            func_name = re.sub("|".join(lib_prefix), "", func_name)
            ida_shims.set_name(func_addr, func_name, idaapi.SN_NOWARN)

def discover_lib_funcs(func_gen):
    pass_count = 2

    for i in range(pass_count):
        for func_addr in func_gen():
            prefix = None
            func_name = ida_shims.get_func_name(func_addr)
            if is_fname_prefix(func_name):
                continue

            if is_lib(func_addr) or is_func_imp(func_addr) or is_fname_main(func_name):
                continue

            for xref_addr in get_cref_addrs(func_addr):
                xref_name = ida_shims.get_func_name(xref_addr)

                if is_fname_payload(xref_name):
                    continue

                if is_func_lib(xref_addr) or is_fname_lib(xref_name, True):
                    prefix = 'lib_explicit'
                    break
                elif any(xref_name.startswith(p) for p in get_lib_prefixes()):
                    prefix = 'lib_implicit'
                    break

            if prefix:
                ida_shims.set_name(func_addr, '{}_{}'.format(prefix, func_name), idaapi.SN_CHECK)

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    cleanup_lib_funcs(func_gen)
    discover_lib_funcs(func_gen)

    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        func_types_dst = []

        lib_prefix = get_lib_prefixes()
        func_name = re.sub("|".join(lib_prefix), "", func_name)
        if is_lib(func_addr) or is_func_imp(func_addr):
            continue

        func_types_dst = get_func_types_dst(func_addr)
        # unique types only
        func_types_dst = list(set(func_types_dst))

        func_type = None
        if len(func_types_dst) == 1:
            func_type = func_types_dst[0]
        else:

            if 'lib_explicit' in func_types_dst:
                func_type = 'lib_explicit'
            elif 'lib_implicit' in func_types_dst:
                func_type = 'lib_implicit'
            elif 'vftable' in func_types_dst:
                func_type = 'vftable'
            else:
                func_type = 'mix'

        report['data'][func_type].append(func_addr)
        report['stat'][func_type] += 1

    cleanup_lib_funcs(func_gen)
    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Constant Analysis')

```

`idaclu/plugins/group_2/plugin_1.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
import idc
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Common Constants')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z\: ]+)(\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_desc = idaapi.get_func(func_addr)
        for head in idautils.Heads(ida_shims.start_ea(func_desc), ida_shims.end_ea(func_desc)):
            for opnd_index in range(idaapi.UA_MAXOP):
                opnd_type = ida_shims.get_operand_type(head, opnd_index)
                if opnd_type in [idaapi.o_void]:
                    break
                if opnd_type in [idaapi.o_reg, idaapi.o_phrase]:
                    opnd_str = ida_shims.print_operand(head, opnd_index)
                    if opnd_str in ['rsp', 'esp', 'rbp', 'ebp']:
                        break
                if opnd_type == idc.o_imm:
                    opnd_val = ida_shims.get_operand_value(head, opnd_index)
                    if ida_shims.is_loaded(opnd_val):
                        continue

                    # avoiding values that can be interpreted as addresses
                    # within the current sample:
                    #   SEH-handlers, callback-arguments, string-offsets, etc.

                    dasm_flag = idaapi.GENDSM_FORCE_CODE
                    dasm_line = ida_shims.generate_disasm_line(head, dasm_flag)
                    dasm_norm = ' '.join(dasm_line.split())
                    func_comm = '{} / {}'.format(hex(head), dasm_norm)

                    opnd_key = "const: {} / {}".format(opnd_val, hex(opnd_val))
                    report['data'][opnd_key].append((func_addr, func_comm))
                    report['stat'][opnd_key] += 1

    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/plugin_2.py`:

```py
import collections
import json
#
import idaapi
import idautils
import idc
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('String Refs')
SCRIPT_TYPE = 'custom'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_data(progress_callback=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    strs = list(idautils.Strings())
    strs_count = len(strs)

    for i, tstr in enumerate(strs):
        str_raw = ida_shims.get_strlit_contents(tstr)
        str_dec = str_raw.decode('utf-8', errors='replace').encode('ascii', errors='replace').decode("utf-8")

        for xref in idautils.XrefsTo(tstr.ea):
            xref_addr = xref.frm
            func_desc = idaapi.get_func(xref_addr)

            if func_desc:
                report['data'][str_dec].append(ida_shims.start_ea(func_desc))
                report['stat'][str_dec] += 1

        if progress_callback:
            progress_callback(i, strs_count)

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data()
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/plugin_3.py`:

```py
import collections
import json
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Global Variable Analysis')
SCRIPT_TYPE = 'custom'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_global_type(name_addr):
    flags = ida_shims.get_full_flags(name_addr)
    types = [
        'dword',
        'strlit',
        'char0',
        'byte',
        'word',
        'unknown',
        'struct',
        'float',
        'double',
        'enum0',
        'qword',
        'off0'
    ]
    for dt in types:
        is_data_type = getattr(ida_shims, 'is_{}'.format(dt))
        if is_data_type(flags):
            return dt
    return None

def get_data(progress_callback=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    names = list(idautils.Names())
    names_count = len(names)

    for i, (name_addr, name_line) in enumerate(names):
        g_type = get_global_type(name_addr)
        if g_type:
            for xref in idautils.XrefsTo(name_addr):
                xref_addr = xref.frm
                func_desc = idaapi.get_func(xref_addr)
                if func_desc:
                    name = "{} / {}".format(g_type, name_line)
                    func_addr = ida_shims.start_ea(func_desc)
                    if not func_addr in report['data'][name]:
                        report['data'][name].append(func_addr)
                        report['stat'][name] += 1

        if progress_callback:
            progress_callback(i, names_count)

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data()
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/plugin_4.py`:

```py
import collections
import json
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Lib Usage Analysis')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def is_fname_main(func_name):
    is_main = func_name.startswith('_') and 'main' in func_name.lower()
    return is_main

def is_func_lib(func_addr):
    func_name = ida_shims.get_func_name(func_addr)
    is_dummy = func_name.startswith('sub_')
    is_main = is_fname_main(func_name)
    func_flags = ida_shims.get_func_flags(func_addr)
    is_lib_flag = func_flags & idaapi.FUNC_LIB
    return is_lib_flag and not is_dummy and not is_main

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        if is_func_lib(func_addr):
            func_name = ida_shims.get_func_name(func_addr)
            xrefs = idautils.XrefsTo(func_addr)
            for xref in xrefs:
                xref_addr = xref.frm
                xref_desc = idaapi.get_func(xref_addr)

                if xref_desc:
                    report['data'][func_name].append(ida_shims.start_ea(xref_desc))
                    report['stat'][func_name] += 1

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/plugin_5.py`:

```py
import collections
import json
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('API Usage Analysis')
SCRIPT_TYPE = 'custom'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_idata():
        imports = {}
        module = ""

        def callback(ea, name, ordinal):
            imports[module].append((ea, name, ordinal))
            return True

        nimps = idaapi.get_import_module_qty()
        for i in range(0, nimps):
            module = idaapi.get_import_module_name(i)
            imports[module] = []
            idaapi.enum_import_names(i, callback)

        for mod in imports:
            for addr, name, ordi in imports[mod]:
                yield addr, mod, name, ordi


def get_data(progress_callback=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    imps = list(get_idata())
    imps_count = len(imps)

    for i, (addr, module, name, ordi) in enumerate(imps):
        for xref in idautils.XrefsTo(addr):
            xref_addr = xref.frm
            func_desc = idaapi.get_func(xref_addr)

            if func_desc:
                key_name = "{}_{}".format(module, name)
                report['data'][key_name].append(ida_shims.start_ea(func_desc))
                report['stat'][key_name] += 1

        if progress_callback:
            progress_callback(i, imps_count)

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data()
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/plugin_6.py`:

```py
import collections
import json
import os
#
import idc
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Windows API Semantics')
SCRIPT_TYPE = 'custom'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_idata():
        imports = {}
        module = ""

        def callback(ea, name, ordinal):
            imports[module].append((ea, name, ordinal))
            return True

        nimps = idaapi.get_import_module_qty()
        for i in range(0, nimps):
            module = idaapi.get_import_module_name(i)
            imports[module] = []
            idaapi.enum_import_names(i, callback)

        for mod in imports:
            for addr, name, ordi in imports[mod]:
                yield addr, mod, name, ordi


def get_data(progress_callback=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    imps = list(get_idata())
    imps_count = len(imps)

    sem_cats = []
    plugin_path = os.path.abspath(os.path.dirname(__file__))
    with open(os.path.join(plugin_path, "winapi_semantics.json"), "r") as jh:
        def_data = json.load(jh)
        sem_cats = def_data['desc']

    func_reg = collections.defaultdict(set)
    for i, (addr, module, name, ordi) in enumerate(imps):
        for xref_addr in ida_utils.get_refs_to(addr):
            func_addr = ida_shims.get_func_attr(xref_addr, idc.FUNCATTR_START)
            if func_addr != idc.BADADDR and not ida_utils.is_func_thunk(func_addr):
                func_reg[func_addr].add(name)

    for idx, func_addr in enumerate(func_reg):
        cat_reg = collections.defaultdict(list)
        for imp_name in func_reg[func_addr]:
            key_name = None
            for cat_dsc in sem_cats:
                if imp_name in cat_dsc["api_names"]:
                    key_name = "{} / {}".format(cat_dsc['api_semantics'], cat_dsc['api_group'])
                    break
            else:
                key_name = "Unknown"
            cat_reg[key_name].append(imp_name)

        for cat in cat_reg:
            report['data'][cat].append((func_addr, ', '.join(cat_reg[cat])))
            report['stat'][cat] += 1

        if progress_callback:
            progress_callback(idx, len(func_reg))

    report['data'] = collections.OrderedDict(sorted(report['data'].items()))
    report['stat'] = collections.OrderedDict(sorted(report['stat'].items()))

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data()
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/plugin_7.py`:

```py
import collections
import json
import os
#
import idc
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Windows API / Malware')
SCRIPT_TYPE = 'custom'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_idata():
        imports = {}
        module = ""

        def callback(ea, name, ordinal):
            imports[module].append((ea, name, ordinal))
            return True

        nimps = idaapi.get_import_module_qty()
        for i in range(0, nimps):
            module = idaapi.get_import_module_name(i)
            imports[module] = []
            idaapi.enum_import_names(i, callback)

        for mod in imports:
            for addr, name, ordi in imports[mod]:
                yield addr, mod, name, ordi


def get_data(progress_callback=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    imps = list(get_idata())
    imps_count = len(imps)

    sem_cats = []
    plugin_path = os.path.abspath(os.path.dirname(__file__))
    with open(os.path.join(plugin_path, "winapi_malware.json"), "r") as jh:
        def_data = json.load(jh)
        sem_cats = def_data['desc']

    func_reg = collections.defaultdict(set)
    for i, (addr, module, name, ordi) in enumerate(imps):
        for xref_addr in ida_utils.get_refs_to(addr):
            func_addr = ida_shims.get_func_attr(xref_addr, idc.FUNCATTR_START)
            if func_addr != idc.BADADDR and not ida_utils.is_func_thunk(func_addr):
                func_reg[func_addr].add(name)

    for idx, func_addr in enumerate(func_reg):
        cat_reg = collections.defaultdict(list)
        for imp_name in func_reg[func_addr]:
            key_name = None
            for cat_dsc in sem_cats:
                if imp_name in cat_dsc["api_names"]:
                    key_name = cat_dsc['cat_name']
                    break
            else:
                key_name = "Unknown"
            cat_reg[key_name].append(imp_name)

        for cat in cat_reg:
            report['data'][cat].append((func_addr, ', '.join(cat_reg[cat])))
            report['stat'][cat] += 1

        if progress_callback:
            progress_callback(idx, len(func_reg))

    report['data'] = collections.OrderedDict(sorted(report['data'].items()))
    report['stat'] = collections.OrderedDict(sorted(report['stat'].items()))

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data()
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_2/winapi_malware.json`:

```json
{
   "desc":[
      {
         "cat_name":"Enumeration",
         "api_names":[
            "CreateToolhelp32Snapshot",
            "EnumDesktopWindows",
            "EnumDeviceDrivers",
            "EnumProcessModules",
            "EnumProcessModulesEx",
            "EnumProcesses",
            "EnumResourceTypesA",
            "EnumResourceTypesExA",
            "EnumResourceTypesExW",
            "EnumResourceTypesW",
            "EnumSystemLocalesA",
            "EnumSystemLocalesW",
            "EnumWindows",
            "FindFirstFileA",
            "FindFirstFileW",
            "FindFirstUrlCacheEntryA",
            "FindFirstUrlCacheEntryW",
            "FindNextFileA",
            "FindNextFileW",
            "FindNextUrlCacheEntryA",
            "FindNextUrlCacheEntryW",
            "GetAdaptersInfo",
            "GetComputerNameA",
            "GetComputerNameW",
            "GetCurrentHwProfileA",
            "GetCurrentHwProfileW",
            "GetCurrentProcess",
            "GetCurrentProcessId",
            "GetCurrentThread",
            "GetCurrentThreadId",
            "GetDriveTypeA",
            "GetDriveTypeW",
            "GetFileAttributesA",
            "GetFileAttributesW",
            "GetFileTime",
            "GetIpNetTable",
            "GetLogicalDrives",
            "GetLogicalProcessorInformation",
            "GetLogicalProcessorInformationEx",
            "GetModuleBaseNameA",
            "GetModuleBaseNameW",
            "GetNativeSystemInfo",
            "GetProcessId",
            "GetProcessIdOfThread",
            "GetSystemDefaultLangId",
            "GetSystemDirectoryA",
            "GetSystemDirectoryW",
            "GetSystemTime",
            "GetSystemTimeAsFileTime",
            "GetThreadId",
            "GetThreadInformation",
            "GetThreadLocale",
            "GetUserNameA",
            "GetUserNameW",
            "GetVersionExA",
            "GetVersionExW",
            "GetWindowsDirectoryA",
            "GetWindowsDirectoryW",
            "IsWoW64Process",
            "LookupAccountNameA",
            "LookupAccountNameW",
            "LookupPrivilegeValueA",
            "LookupPrivilegeValueW",
            "Module32First",
            "Module32Next",
            "NetShareCheck",
            "NetShareEnum",
            "NetShareGetInfo",
            "NtQueryDirectoryFile",
            "NtQueryInformationProcess",
            "NtQuerySystemEnvironmentValueEx",
            "PathFileExistsA",
            "PathFileExistsW",
            "Process32First",
            "Process32Next",
            "ReadFile",
            "ReadProcessMemory",
            "RegEnumKeyA",
            "RegEnumKeyExA",
            "RegEnumKeyExW",
            "RegEnumKeyW",
            "RegEnumValueA",
            "RegEnumValueW",
            "RegQueryInfoKeyA",
            "RegQueryInfoKeyW",
            "RegQueryMultipleValuesA",
            "RegQueryMultipleValuesW",
            "RegQueryValueExA",
            "RegQueryValueExW",
            "RtlGetVersion",
            "SearchPathA",
            "SearchPathW",
            "Thread32First",
            "Thread32Next",
            "VirtualQueryEx",
            "WNetAddConnection2A",
            "WNetAddConnection2W",
            "WNetAddConnectionA",
            "WNetAddConnectionW",
            "WNetCloseEnum",
            "WNetEnumResourceA",
            "WNetEnumResourceW"
         ]
      },
      {
         "cat_name":"Injection",
         "api_names":[
            "AdjustTokenPrivileges",
            "CreateFileMappingA",
            "CreateFileMappingW",
            "CreateProcessA",
            "CreateProcessAsUserA",
            "CreateProcessAsUserW",
            "CreateProcessInternal",
            "CreateProcessW",
            "CreateProcessWithTokenW",
            "CreateRemoteThread",
            "CreateRemoteThreadEx",
            "CreateThread",
            "DuplicateToken",
            "EnumSystemLocalesA",
            "EnumSystemLocalesW",
            "GetModuleHandleA",
            "GetModuleHandleW",
            "GetProcAddress",
            "GetProcessHeap",
            "GetProcessHeaps",
            "GetThreadContext",
            "GlobalAlloc",
            "HeapAlloc",
            "HeapCreate",
            "HeapReAlloc",
            "KeInsertQueueApc",
            "LdrLoadDll",
            "LoadLibraryA",
            "LoadLibraryExA",
            "LoadLibraryExW",
            "LoadLibraryW",
            "LocalAlloc",
            "MapViewOfFile",
            "MapViewOfFile2",
            "MapViewOfFile3",
            "MapViewOfFileEx",
            "NtAdjustPrivilegesToken",
            "NtAllocateVirtualMemory",
            "NtContinue",
            "NtCreateProcess",
            "NtCreateProcessEx",
            "NtCreateSection",
            "NtCreateThread",
            "NtCreateThreadEx",
            "NtCreateUserProcess",
            "NtDuplicateObject",
            "NtMapViewOfSection",
            "NtOpenProcess",
            "NtOpenThread",
            "NtProtectVirtualMemory",
            "NtQueueApcThread",
            "NtQueueApcThreadEx",
            "NtQueueApcThreadEx2",
            "NtReadVirtualMemory",
            "NtReadVirtualMemoryEx",
            "NtResumeProcess",
            "NtResumeThread",
            "NtSuspendProcess",
            "NtUnmapViewOfSection",
            "NtWaitForMultipleObjects",
            "NtWaitForSingleObject",
            "NtWriteVirtualMemory",
            "OpenFileMappingA",
            "OpenFileMappingW",
            "OpenProcess",
            "OpenProcessToken",
            "OpenThread",
            "Process32First",
            "Process32Next",
            "QueueUserAPC",
            "ReadProcessMemory",
            "ResumeThread",
            "RtlCopyMemory",
            "RtlCreateHeap",
            "RtlMoveMemory",
            "SetProcessDEPPolicy",
            "SetPropA",
            "SetPropW",
            "SetThreadContext",
            "SuspendThread",
            "Thread32First",
            "Thread32Next",
            "Toolhelp32ReadProcessMemory",
            "UuidFromStringA",
            "UuidFromStringW",
            "VirtualAlloc",
            "VirtualAlloc2",
            "VirtualAlloc2FromApp",
            "VirtualAllocEx",
            "VirtualAllocExNuma",
            "VirtualAllocFromApp",
            "VirtualProtect",
            "VirtualProtectEx",
            "VirtualProtectFromApp",
            "WaitForMultipleObjects",
            "WaitForMultipleObjectsEx",
            "WaitForSingleObject",
            "WaitForSingleObjectEx",
            "Wow64SetThreadContext",
            "WriteProcessMemory"
         ]
      },
      {
         "cat_name":"Evasion",
         "api_names":[
            "CreateFileMappingA",
            "CreateFileMappingW",
            "CreateProcessInternal",
            "CreateTimerQueueTimer",
            "CreateWaitableTimer",
            "CreateWindowExA",
            "CreateWindowExW",
            "CryptProtectData",
            "DeleteFileA",
            "DeleteFileW",
            "DuplicateToken",
            "EnumSystemLocalesA",
            "EnumSystemLocalesW",
            "GetModuleHandleA",
            "GetModuleHandleW",
            "GetProcAddress",
            "IcmpSendEcho",
            "ImpersonateLoggedOnUser",
            "LoadLibraryA",
            "LoadLibraryExA",
            "LoadLibraryExW",
            "LoadLibraryW",
            "LoadResource",
            "LockResource",
            "NtDelayExecution",
            "NtWaitForMultipleObjects",
            "NtWaitForSingleObject",
            "RegisterHotKey",
            "Select",
            "SetEnvironmentVariableA",
            "SetEnvironmentVariableW",
            "SetFileAttributesA",
            "SetFileAttributesW",
            "SetFileTime",
            "SetThreadToken",
            "SetTimer",
            "SetWaitableTimer",
            "SetWaitableTimer",
            "SizeOfResource",
            "Sleep",
            "SleepEx",
            "TimeGetTime",
            "UuidFromStringA",
            "UuidFromStringW",
            "WaitForMultipleObjects",
            "WaitForMultipleObjectsEx",
            "WaitForSingleObject",
            "WaitForSingleObjectEx",
            "timeSetEvent"
         ]
      },
      {
         "cat_name":"Spying",
         "api_names":[
            "AttachThreadInput",
            "BitBlt",
			"CallNextHook",
            "CallNextHookEx",
            "GetAsyncKeyState",
            "GetClipboardData",
            "GetDC",
            "GetDCEx",
			"GetAsyncKeyState",
            "GetForegroundWindow",
            "GetKeyState",
            "GetKeyboardState",
			"GetKeyboardType",
			"GetKeyboardLayoutList",
            "GetKeynameTextA",
            "GetKeynameTextW",
            "GetMessageA",
            "GetMessageW",
            "GetRawInputData",
            "GetWindowDC",
            "MapVirtualKeyA",
            "MapVirtualKeyExA",
            "MapVirtualKeyExW",
            "MapVirtualKeyW",
            "PeekMessageA",
            "PeekMessageW",
            "PostMessageA",
            "PostMessageW",
            "PostThreadMessageA",
            "PostThreadMessageW",
            "RegisterHotKey",
            "RegisterRawInputDevices",
            "SendMessageA",
            "SendMessageCallbackA",
            "SendMessageCallbackW",
            "SendMessageTimeoutA",
            "SendMessageTimeoutW",
            "SendMessageW",
            "SendNotifyMessageA",
            "SendNotifyMessageW",
            "SetWinEventHook",
            "SetWindowsHookExA",
            "SetWindowsHookExW",
            "StretchBlt",
            "VkKeyScanA",
            "VkKeyScanExA",
            "UnhookWindowsHookEx",
			"UnregisterHotKey"
         ]
      },
      {
         "cat_name":"Networking",
         "api_names":[
            "Accept",
            "Bind",
            "Closesocket",
            "Connect",
            "DnsQueryEx",
            "DnsQuery_A",
            "DnsQuery_W",
            "FindFirstUrlCacheEntryA",
            "FindFirstUrlCacheEntryW",
            "FindNextUrlCacheEntryA",
            "FindNextUrlCacheEntryW",
            "FtpPutFileA",
            "FtpPutFileW",
            "Gethostbyname",
            "Gethostname",
            "HttpAddRequestHeaders",
            "HttpOpenRequestA",
            "HttpOpenRequestW",
            "HttpSendRequestA",
            "HttpSendRequestExA",
            "HttpSendRequestExW",
            "HttpSendRequestW",
            "Inet_addr",
            "InternetCloseHandle",
            "InternetConnectA",
            "InternetConnectW",
            "InternetOpenA",
            "InternetOpenUrlA",
            "InternetOpenUrlW",
            "InternetOpenW",
            "InternetReadFile",
            "InternetReadFileExA",
            "InternetReadFileExW",
            "InternetSetOptionA",
            "InternetSetOptionW",
            "InternetWriteFile",
            "Listen",
            "Recv",
            "Send",
            "ShellExecuteA",
            "ShellExecuteExA",
            "ShellExecuteExW",
            "ShellExecuteW",
            "Socket",
            "URLDownloadToCacheFile",
            "URLDownloadToFile",
            "URLOpenBlockingStream",
            "URLOpenStream",
            "WNetOpenEnumA",
            "WNetOpenEnumW",
            "WSACleanup",
            "WSAIoctl",
            "WSASocketA",
            "WSASocketW",
            "WSAStartup",
            "WinExec",
            "ioctlsocket"
         ]
      },
      {
         "cat_name":"Anti-Debugging",
         "api_names":[
            "CheckRemoteDebuggerPresent",
            "CountClipboardFormats",
            "CreateToolhelp32Snapshot",
            "ExitWindowsEx",
            "FindWindowA",
            "FindWindowExA",
            "FindWindowExW",
            "FindWindowW",
            "GetComputerNameA",
            "GetComputerNameW",
            "GetForegroundWindow",
            "GetLogicalProcessorInformation",
            "GetLogicalProcessorInformationEx",
            "GetNativeSystemInfo",
            "GetSystemTime",
            "GetSystemTimeAsFileTime",
            "GetTickCount",
            "GetTickCount64",
            "GetUserNameA",
            "GetUserNameW",
            "IsDebuggerPresent",
            "NtQueryInformationProcess",
            "OutputDebugStringA",
            "OutputDebugStringW",
            "QueryPerformanceCounter",
            "QueryPerformanceFrequency",
            "RtlGetVersion",
            "Sleep",
            "SleepEx"
         ]
      },
      {
         "cat_name":"Encryption",
         "api_names":[
            "CryptAcquireContextA",
            "CryptAcquireContextW",
            "CryptBinaryToString",
            "CryptCreateHash",
            "CryptDecrypt",
            "CryptDeriveKey",
            "CryptDestroyHash",
            "CryptDestroyKey",
            "CryptEncrypt",
            "CryptGenRandom",
            "CryptGetHashParam",
            "CryptHashData",
            "CryptProtectData",
            "CryptReleaseContext",
            "CryptSetKeyParam",
            "CryptSetKeyParam",
            "CryptStringToBinary",
            "DecryptFileA",
            "DecryptFileW",
            "EncryptFileA",
            "EncryptFileW",
            "EnumSystemLocalesA",
            "EnumSystemLocalesW",
            "FlushEfsCache",
            "GetDriveTypeA",
            "GetDriveTypeW",
            "GetLogicalDrives"
         ]
      },
      {
         "cat_name":"Helper",
         "api_names":[
            "BringWindowToTop",
            "CallWindowProcA",
            "CallWindowProcW",
            "ConnectNamedPipe",
            "ControlService",
            "ControlServiceExA",
            "ControlServiceExW",
            "CopyFile2",
            "CopyFileA",
            "CopyFileExA",
            "CopyFileExW",
            "CopyFileW",
            "CreateFile2",
            "CreateFileA",
            "CreateFileW",
            "CreateMutexA",
            "CreateMutexExA",
            "CreateMutexExW",
            "CreateMutexW",
            "CreatePipe",
            "CreateServiceA",
            "CreateServiceW",
            "DeleteService",
            "DeviceIoControl",
            "DrawTextExA",
            "FindClose",
            "FindResourceA",
            "FindResourceExA",
            "FindResourceExW",
            "FindResourceW",
            "GetDesktopWindow",
            "GetDriveTypeA",
            "GetDriveTypeW",
            "GetIpNetTable",
            "GetLogicalDrives",
            "GetModuleBaseNameA",
            "GetModuleBaseNameW",
            "GetModuleFileNameA",
            "GetModuleFileNameExA",
            "GetModuleFileNameExW",
            "GetModuleFileNameW",
            "GetTempFileNameA",
            "GetTempFileNameW",
            "GetTempPathA",
            "GetTempPathW",
            "ImpersonateLoggedOnUser",
            "IsWoW64Process",
            "LockResource",
            "MoveFileA",
            "MoveFileExA",
            "MoveFileExW",
            "MoveFileW",
            "NetShareAdd",
            "NetShareSetInfo",
            "NtClose",
            "NtCreateFile",
            "NtDeleteKey",
            "NtDeleteValueKey",
            "NtMakeTemporaryObject",
            "NtQueryTimer",
            "NtResumeProcess",
            "NtSetContextThread",
            "NtSetInformationProcess",
            "NtSetInformationThread",
            "NtSetSystemEnvironmentValueEx",
            "NtSetValueKey",
            "NtShutdownSystem",
            "NtTerminateProcess",
            "NtTerminateThread",
            "OpenClipboard",
            "OpenSCManagerA",
            "OpenSCManagerW",
            "OpenServiceA",
            "OpenServiceW",
            "PeekNamedPipe",
            "RegCloseKey",
            "RegConnectRegistryA",
            "RegConnectRegistryW",
            "RegCopyTreeA",
            "RegCopyTreeW",
            "RegCreateKeyA",
            "RegCreateKeyExA",
            "RegCreateKeyExW",
            "RegCreateKeyTransactedA",
            "RegCreateKeyTransactedW",
            "RegCreateKeyW",
            "RegDeleteKeyA",
            "RegDeleteKeyExA",
            "RegDeleteKeyExW",
            "RegDeleteKeyTransactedA",
            "RegDeleteKeyTransactedW",
            "RegDeleteKeyValueA",
            "RegDeleteKeyValueW",
            "RegDeleteKeyW",
            "RegDeleteTreeA",
            "RegDeleteTreeW",
            "RegDeleteValueA",
            "RegDeleteValueA",
            "RegDeleteValueW",
            "RegDeleteValueW",
            "RegEnumKeyA",
            "RegEnumKeyExA",
            "RegEnumKeyExW",
            "RegEnumKeyW",
            "RegEnumValueA",
            "RegEnumValueW",
            "RegFlushKey",
            "RegGetKeySecurity",
            "RegGetValueA",
            "RegGetValueW",
            "RegLoadKeyA",
            "RegLoadKeyW",
            "RegLoadMUIStringA",
            "RegLoadMUIStringW",
            "RegOpenCurrentUser",
            "RegOpenKeyA",
            "RegOpenKeyExA",
            "RegOpenKeyExA",
            "RegOpenKeyExW",
            "RegOpenKeyExW",
            "RegOpenKeyTransactedA",
            "RegOpenKeyTransactedW",
            "RegOpenKeyW",
            "RegOpenUserClassesRoot",
            "RegOverridePredefKey",
            "RegReplaceKeyA",
            "RegReplaceKeyW",
            "RegRestoreKeyA",
            "RegRestoreKeyW",
            "RegSaveKeyA",
            "RegSaveKeyExA",
            "RegSaveKeyExW",
            "RegSaveKeyW",
            "RegSetKeySecurity",
            "RegSetKeyValueA",
            "RegSetKeyValueW",
            "RegSetValueExA",
            "RegSetValueExW",
            "RegUnLoadKeyA",
            "RegUnLoadKeyW",
            "RtlSetProcessIsCritical",
            "SetClipboardData",
            "SetCurrentDirectory",
            "SetFocus",
            "SetForegroundWindow",
            "SetThreadPriority",
            "SetThreadToken",
            "SetWindowLongA",
            "SetWindowLongPtrA",
            "SetWindowLongPtrW",
            "ShowWindow",
            "SizeOfResource",
            "StartServiceA",
            "StartServiceCtrlDispatcherA",
            "StartServiceCtrlDispatcherW",
            "StartServiceW",
            "TerminateProcess",
            "TerminateThread",
            "UnmapViewOfFile",
            "UuidFromStringA",
            "UuidFromStringW",
            "WNetAddConnection2A",
            "WNetAddConnection2W",
            "WNetEnumResourceA",
            "WNetEnumResourceW",
            "WNetOpenEnumA",
            "WNetOpenEnumW",
            "WriteFile",
            "lstrcatA",
            "lstrcatW"
         ]
      }
   ]
}

```

`idaclu/plugins/group_2/winapi_semantics.json`:

```json
{
   "desc":[
      {
         "api_group":"Security and Identity",
         "api_semantics":"Configuration",
         "api_names":[
            "AdjustTokenPrivileges",
            "CreateProcessWithTokenW",
            "DuplicateToken",
            "GetUserNameA",
            "GetUserNameW",
            "ImpersonateLoggedOnUser",
            "LookupAccountNameA",
            "LookupAccountNameW",
            "LookupPrivilegeValueA",
            "LookupPrivilegeValueW",
            "NtAdjustPrivilegesToken",
            "OpenProcessToken",
            "SetThreadToken",
            "SetThreadToken"
         ]
      },
      {
         "api_group":"Output",
         "api_semantics":"Debugging",
         "api_names":[
            "MessageBoxA",
            "MessageBoxW",
            "OutputDebugStringA",
            "OutputDebugStringW"
         ]
      },
      {
         "api_group":"General",
         "api_semantics":"Debugging",
         "api_names":[
            "CheckRemoteDebuggerPresent",
            "IsDebuggerPresent"
         ]
      },
      {
         "api_group":"Windows and Messages",
         "api_semantics":"Configuration",
         "api_names":[
            "BringWindowToTop",
            "CallNextHookEx",
            "CallWindowProcA",
            "CallWindowProcW",
            "CreateWindowExA",
            "CreateWindowExW",
            "EnumDesktopWindows",
            "EnumWindows",
            "FindWindowA",
            "FindWindowExA",
            "FindWindowExW",
            "FindWindowW",
            "GetDesktopWindow",
            "GetForegroundWindow",
            "GetMessageA",
            "GetMessageW",
            "PeekMessageA",
            "PeekMessageW",
            "PostMessageA",
            "PostMessageW",
            "PostThreadMessageA",
            "PostThreadMessageW",
            "SendMessageA",
            "SendMessageCallbackA",
            "SendMessageCallbackW",
            "SendMessageTimeoutA",
            "SendMessageTimeoutW",
            "SendMessageW",
            "SendNotifyMessageA",
            "SendNotifyMessageW",
            "SetFocus",
            "SetForegroundWindow",
            "SetPropA",
            "SetPropW",
            "SetWindowLongA",
            "SetWindowLongPtrA",
            "SetWindowLongPtrW",
            "SetWindowsHookExA",
            "SetWindowsHookExW",
            "ShowWindow",
            "UnhookWindowsHookEx"
         ]
      },
      {
         "api_group":"GDI",
         "api_semantics":"Configuration",
         "api_names":[
            "BitBlt",
            "DrawTextExA",
            "GDI",
            "GetDC",
            "GetDCEx",
            "GetWindowDC",
            "StretchBlt"
         ]
      },
      {
         "api_group":"Events",
         "api_semantics":"Execution",
         "api_names":[
            "CreateEventA",
            "CreateEventEx",
            "CreateEventW",
            "OpenEventA",
            "OpenEventW",
            "PulseEvent",
            "ResetEvent",
            "SetEvent",
            "SetWinEventHook"
         ]
      },
      {
         "api_group":"Registry",
         "api_semantics":"Configuration",
         "api_names":[
            "NtDeleteKey",
            "NtDeleteValueKey",
            "NtSetValueKey",
            "RegCloseKey",
            "RegConnectRegistryA",
            "RegConnectRegistryW",
            "RegCopyTreeA",
            "RegCopyTreeW",
            "RegCreateKeyA",
            "RegCreateKeyExA",
            "RegCreateKeyExW",
            "RegCreateKeyTransactedA",
            "RegCreateKeyTransactedW",
            "RegCreateKeyW",
            "RegDeleteKeyA",
            "RegDeleteKeyExA",
            "RegDeleteKeyExW",
            "RegDeleteKeyTransactedA",
            "RegDeleteKeyTransactedW",
            "RegDeleteKeyValueA",
            "RegDeleteKeyValueW",
            "RegDeleteKeyW",
            "RegDeleteTreeA",
            "RegDeleteTreeW",
            "RegDeleteValueA",
            "RegDeleteValueW",
            "RegDisablePredefinedCache",
            "RegDisablePredefinedCacheEx",
            "RegEnumKeyA",
            "RegEnumKeyExA",
            "RegEnumKeyExW",
            "RegEnumKeyW",
            "RegEnumValueA",
            "RegEnumValueW",
            "RegFlushKey",
            "RegGetKeySecurity",
            "RegGetValueA",
            "RegGetValueW",
            "RegLoadKeyA",
            "RegLoadKeyW",
            "RegLoadMUIStringA",
            "RegLoadMUIStringW",
            "RegNotifyChangeKeyValue",
            "RegOpenCurrentUser",
            "RegOpenKeyA",
            "RegOpenKeyExA",
            "RegOpenKeyExW",
            "RegOpenKeyTransactedA",
            "RegOpenKeyTransactedW",
            "RegOpenKeyW",
            "RegOpenUserClassesRoot",
            "RegOverridePredefKey",
            "RegQueryInfoKeyA",
            "RegQueryInfoKeyW",
            "RegQueryMultipleValuesA",
            "RegQueryMultipleValuesW",
            "RegQueryValueA",
            "RegQueryValueExA",
            "RegQueryValueExW",
            "RegQueryValueW",
            "RegReplaceKeyA",
            "RegReplaceKeyW",
            "RegRestoreKeyA",
            "RegRestoreKeyW",
            "RegSaveKeyA",
            "RegSaveKeyExA",
            "RegSaveKeyExW",
            "RegSaveKeyW",
            "RegSetKeySecurity",
            "RegSetKeyValueA",
            "RegSetKeyValueW",
            "RegSetValueA",
            "RegSetValueExA",
            "RegSetValueExW",
            "RegSetValueW",
            "RegUnLoadKeyA",
            "RegUnLoadKeyW",
            "SHDeleteEmptyKeyA",
            "SHDeleteEmptyKeyW",
            "SHDeleteKeyA",
            "SHDeleteKeyW",
            "SHDeleteOrphanKeyA",
            "SHDeleteOrphanKeyW",
            "SHDeleteValueA",
            "SHDeleteValueW",
            "SHEnumKeyExA",
            "SHEnumKeyExW",
            "SHEnumValueA",
            "SHEnumValueW",
            "SHGetValueA",
            "SHGetValueW",
            "SHOpenRegStream2A",
            "SHOpenRegStream2W",
            "SHOpenRegStreamA",
            "SHOpenRegStreamW",
            "SHQueryInfoKeyA",
            "SHQueryInfoKeyW",
            "SHQueryValueExA",
            "SHQueryValueExW",
            "SHRegCloseUSKey",
            "SHRegCreateUSKeyA",
            "SHRegCreateUSKeyW",
            "SHRegDeleteEmptyUSKeyA",
            "SHRegDeleteEmptyUSKeyW",
            "SHRegDeleteUSValueA",
            "SHRegDeleteUSValueW",
            "SHRegDuplicateHKey",
            "SHRegEnumUSKeyA",
            "SHRegEnumUSKeyW",
            "SHRegEnumUSValueA",
            "SHRegEnumUSValueW",
            "SHRegGetBoolUSValueA",
            "SHRegGetBoolUSValueW",
            "SHRegGetPathA",
            "SHRegGetPathW",
            "SHRegGetUSValueA",
            "SHRegGetUSValueW",
            "SHRegGetValueA",
            "SHRegGetValueW",
            "SHRegOpenUSKeyA",
            "SHRegOpenUSKeyW",
            "SHRegQueryInfoUSKeyA",
            "SHRegQueryInfoUSKeyW",
            "SHRegQueryUSValueA",
            "SHRegQueryUSValueW",
            "SHRegSetPathA",
            "SHRegSetPathW",
            "SHRegSetUSValueA",
            "SHRegSetUSValueW",
            "SHRegWriteUSValueA",
            "SHRegWriteUSValueW"
         ]
      },
      {
         "api_group":"WinSock",
         "api_semantics":"Network",
         "api_names":[
            "Accept",
            "Bind",
            "Closesocket",
            "Connect",
            "DnsQueryEx",
            "DnsQuery_A",
            "DnsQuery_W",
            "FreeAddrInfoW",
            "GetAddrInfoW",
            "GetNameInfoW",
            "Gethostbyname",
            "Gethostname",
            "Inet_addr",
            "Listen",
            "Recv",
            "Select",
            "Send",
            "Socket",
            "WEP",
            "WPUCompleteOverlappedRequest",
            "WSAAccept",
            "WSAAddressToStringA",
            "WSAAddressToStringW",
            "WSAAsyncGetHostByAddr",
            "WSAAsyncGetHostByName",
            "WSAAsyncGetProtoByName",
            "WSAAsyncGetProtoByNumber",
            "WSAAsyncGetServByName",
            "WSAAsyncGetServByPort",
            "WSAAsyncSelect",
            "WSACancelAsyncRequest",
            "WSACancelBlockingCall",
            "WSACleanup",
            "WSACloseEvent",
            "WSAConnect",
            "WSACreateEvent",
            "WSADuplicateSocketA",
            "WSADuplicateSocketW",
            "WSAEnumNameSpaceProvidersA",
            "WSAEnumNameSpaceProvidersW",
            "WSAEnumNetworkEvents",
            "WSAEnumProtocolsA",
            "WSAEnumProtocolsW",
            "WSAEventSelect",
            "WSAGetLastError",
            "WSAGetOverlappedResult",
            "WSAGetQOSByName",
            "WSAGetServiceClassInfoA",
            "WSAGetServiceClassInfoW",
            "WSAGetServiceClassNameByClassIdA",
            "WSAGetServiceClassNameByClassIdW",
            "WSAHtonl",
            "WSAHtons",
            "WSAInstallServiceClassA",
            "WSAInstallServiceClassW",
            "WSAIoctl",
            "WSAIsBlocking",
            "WSAJoinLeaf",
            "WSALookupServiceBeginA",
            "WSALookupServiceBeginW",
            "WSALookupServiceEnd",
            "WSALookupServiceNextA",
            "WSALookupServiceNextW",
            "WSANSPIoctl",
            "WSANtohl",
            "WSANtohs",
            "WSAProviderConfigChange",
            "WSARecv",
            "WSARecvDisconnect",
            "WSARecvFrom",
            "WSARemoveServiceClass",
            "WSAResetEvent",
            "WSASend",
            "WSASendDisconnect",
            "WSASendTo",
            "WSASetBlockingHook",
            "WSASetEvent",
            "WSASetLastError",
            "WSASetServiceA",
            "WSASetServiceW",
            "WSASocketA",
            "WSASocketW",
            "WSAStartup",
            "WSAStringToAddressA",
            "WSAStringToAddressW",
            "WSAUnhookBlockingHook",
            "WSAWaitForMultipleEvents",
            "WSApSetPostRoutine",
            "WSCDeinstallProvider",
            "WSCEnableNSProvider",
            "WSCEnumProtocols",
            "WSCGetProviderPath",
            "WSCInstallNameSpace",
            "WSCInstallProvider",
            "WSCUnInstallNameSpace",
            "WSCUpdateProvider",
            "WSCWriteNameSpaceOrder",
            "WSCWriteProviderOrder",
            "__WSAFDIsSet",
            "accept",
            "bind",
            "closesocket",
            "connect",
            "freeaddrinfo",
            "getaddrinfo",
            "gethostbyaddr",
            "gethostbyname",
            "gethostname",
            "getnameinfo",
            "getpeername",
            "getprotobyname",
            "getprotobynumber",
            "getservbyname",
            "getservbyport",
            "getsockname",
            "getsockopt",
            "htonl",
            "htons",
            "inet_addr",
            "inet_ntoa",
            "ioctlsocket",
            "listen",
            "ntohl",
            "ntohs",
            "recv",
            "recvfrom",
            "select",
            "send",
            "sendto",
            "setsockopt",
            "shutdown",
            "socket"
         ]
      },
      {
         "api_group":"Network Resources",
         "api_semantics":"Network",
         "api_names":[
            "NetShareAdd",
            "NetShareCheck",
            "NetShareEnum",
            "NetShareGetInfo",
            "NetShareSetInfo",
            "WNetAddConnection2A",
            "WNetAddConnection2W",
            "WNetAddConnectionA",
            "WNetAddConnectionW",
            "WNetCloseEnum",
            "WNetEnumResourceA",
            "WNetEnumResourceW",
            "WNetOpenEnumA",
            "WNetOpenEnumW"

         ]
      },
      {
         "api_group":"WinInet",
         "api_semantics":"Network",
         "api_names":[
            "CreateMD5SSOHash",
            "DetectAutoProxyUrl",
            "DllInstall",
            "ForceNexusLookup",
            "ForceNexusLookupExW",
            "InternetAlgIdToStringA",
            "InternetAlgIdToStringW",
            "InternetAttemptConnect",
            "InternetAutodial",
            "InternetAutodialCallback",
            "InternetAutodialHangup",
            "InternetCanonicalizeUrlA",
            "InternetCanonicalizeUrlW",
            "InternetCheckConnectionA",
            "InternetCheckConnectionW",
            "InternetClearAllPerSiteCookieDecisions",
            "InternetCloseHandle",
            "InternetCombineUrlA",
            "InternetCombineUrlW",
            "InternetConfirmZoneCrossing",
            "InternetConfirmZoneCrossingA",
            "InternetConfirmZoneCrossingW",
            "InternetConnectA",
            "InternetConnectW",
            "InternetCrackUrlA",
            "InternetCrackUrlW",
            "InternetCreateUrlA",
            "InternetCreateUrlW",
            "InternetDial",
            "InternetDialA",
            "InternetDialW",
            "InternetEnumPerSiteCookieDecisionA",
            "InternetEnumPerSiteCookieDecisionW",
            "InternetErrorDlg",
            "InternetFindNextFileA",
            "InternetFindNextFileW",
            "InternetFortezzaCommand",
            "InternetGetCertByURL",
            "InternetGetCertByURLA",
            "InternetGetConnectedState",
            "InternetGetConnectedStateEx",
            "InternetGetConnectedStateExA",
            "InternetGetConnectedStateExW",
            "InternetGetCookieA",
            "InternetGetCookieExA",
            "InternetGetCookieExW",
            "InternetGetCookieW",
            "InternetGetLastResponseInfoA",
            "InternetGetLastResponseInfoW",
            "InternetGetPerSiteCookieDecisionA",
            "InternetGetPerSiteCookieDecisionW",
            "InternetGoOnline",
            "InternetGoOnlineA",
            "InternetGoOnlineW",
            "InternetHangUp",
            "InternetInitializeAutoProxyDll",
            "InternetLockRequestFile",
            "InternetOpenA",
            "InternetOpenUrlA",
            "InternetOpenUrlW",
            "InternetOpenW",
            "InternetQueryDataAvailable",
            "InternetQueryFortezzaStatus",
            "InternetQueryOptionA",
            "InternetQueryOptionW",
            "InternetReadFile",
            "InternetReadFileExA",
            "InternetReadFileExW",
            "InternetSecurityProtocolToStringA",
            "InternetSecurityProtocolToStringW",
            "InternetSetCookieA",
            "InternetSetCookieExA",
            "InternetSetCookieExW",
            "InternetSetCookieW",
            "InternetSetDialState",
            "InternetSetDialStateA",
            "InternetSetDialStateW",
            "InternetSetFilePointer",
            "InternetSetOptionA",
            "InternetSetOptionExA",
            "InternetSetOptionExW",
            "InternetSetOptionW",
            "InternetSetPerSiteCookieDecisionA",
            "InternetSetPerSiteCookieDecisionW",
            "InternetSetStatusCallback",
            "InternetSetStatusCallbackA",
            "InternetSetStatusCallbackW",
            "InternetShowSecurityInfoByURL",
            "InternetShowSecurityInfoByURLA",
            "InternetShowSecurityInfoByURLW",
            "InternetTimeFromSystemTime",
            "InternetTimeFromSystemTimeA",
            "InternetTimeFromSystemTimeW",
            "InternetTimeToSystemTime",
            "InternetTimeToSystemTimeA",
            "InternetTimeToSystemTimeW",
            "InternetUnlockRequestFile",
            "InternetWriteFile",
            "InternetWriteFileExA",
            "InternetWriteFileExW",
            "IsHostInProxyBypassList",
            "ParseX509EncodedCertificateForListBoxEntry",
            "PrivacyGetZonePreferenceW",
            "PrivacySetZonePreferenceW",
            "ResumeSuspendedDownload",
            "ShowCertificate",
            "ShowClientAuthCerts",
            "ShowSecurityInfo",
            "ShowX509EncodedCertificate",
            "UrlZonesDetach",
            "_GetFileExtensionFromUrl"
         ]
      },
      {
         "api_group":"Cache",
         "api_semantics":"Network",
         "api_names":[
            "CommitUrlCacheEntryA",
            "CommitUrlCacheEntryW",
            "CreateUrlCacheContainerA",
            "CreateUrlCacheContainerW",
            "CreateUrlCacheEntryA",
            "CreateUrlCacheEntryW",
            "CreateUrlCacheGroup",
            "DeleteIE3Cache",
            "DeleteUrlCacheContainerA",
            "DeleteUrlCacheContainerW",
            "DeleteUrlCacheEntry",
            "DeleteUrlCacheEntryA",
            "DeleteUrlCacheEntryW",
            "DeleteUrlCacheGroup",
            "FindCloseUrlCache",
            "FindFirstUrlCacheContainerA",
            "FindFirstUrlCacheContainerW",
            "FindFirstUrlCacheEntryA",
            "FindFirstUrlCacheEntryExA",
            "FindFirstUrlCacheEntryExW",
            "FindFirstUrlCacheEntryW",
            "FindFirstUrlCacheGroup",
            "FindNextUrlCacheContainerA",
            "FindNextUrlCacheContainerW",
            "FindNextUrlCacheEntryA",
            "FindNextUrlCacheEntryExA",
            "FindNextUrlCacheEntryExW",
            "FindNextUrlCacheEntryW",
            "FindNextUrlCacheGroup",
            "FreeUrlCacheSpaceA",
            "FreeUrlCacheSpaceW",
            "GetUrlCacheConfigInfoA",
            "GetUrlCacheConfigInfoW",
            "GetUrlCacheEntryInfoA",
            "GetUrlCacheEntryInfoExA",
            "GetUrlCacheEntryInfoExW",
            "GetUrlCacheEntryInfoW",
            "GetUrlCacheGroupAttributeA",
            "GetUrlCacheGroupAttributeW",
            "GetUrlCacheHeaderData",
            "IncrementUrlCacheHeaderData",
            "IsUrlCacheEntryExpiredA",
            "IsUrlCacheEntryExpiredW",
            "LoadUrlCacheContent",
            "ReadUrlCacheEntryStream",
            "RegisterUrlCacheNotification",
            "RetrieveUrlCacheEntryFileA",
            "RetrieveUrlCacheEntryFileW",
            "RetrieveUrlCacheEntryStreamA",
            "RetrieveUrlCacheEntryStreamW",
            "RunOnceUrlCache",
            "SetUrlCacheConfigInfoA",
            "SetUrlCacheConfigInfoW",
            "SetUrlCacheEntryGroup",
            "SetUrlCacheEntryGroupA",
            "SetUrlCacheEntryGroupW",
            "SetUrlCacheEntryInfoA",
            "SetUrlCacheEntryInfoW",
            "SetUrlCacheGroupAttributeA",
            "SetUrlCacheGroupAttributeW",
            "SetUrlCacheHeaderData",
            "UnlockUrlCacheEntryFile",
            "UnlockUrlCacheEntryFileA",
            "UnlockUrlCacheEntryFileW",
            "UnlockUrlCacheEntryStream",
            "UpdateUrlCacheContentPath"
         ]
      },
      {
         "api_group":"FTP",
         "api_semantics":"Network",
         "api_names":[
            "FtpCommandA",
            "FtpCommandW",
            "FtpCreateDirectoryA",
            "FtpCreateDirectoryW",
            "FtpDeleteFileA",
            "FtpDeleteFileW",
            "FtpFindFirstFileA",
            "FtpFindFirstFileW",
            "FtpGetCurrentDirectoryA",
            "FtpGetCurrentDirectoryW",
            "FtpGetFileA",
            "FtpGetFileEx",
            "FtpGetFileSize",
            "FtpGetFileW",
            "FtpOpenFileA",
            "FtpOpenFileW",
            "FtpPutFileA",
            "FtpPutFileEx",
            "FtpPutFileW",
            "FtpRemoveDirectoryA",
            "FtpRemoveDirectoryW",
            "FtpRenameFileA",
            "FtpRenameFileW",
            "FtpSetCurrentDirectoryA",
            "FtpSetCurrentDirectoryW"
         ]
      },
      {
         "api_group":"IP",
         "api_semantics":"Network",
         "api_names":[
            "GetAdaptersInfo",
            "GetIpNetTable"
         ]
      },
      {
         "api_group":"Gopher",
         "api_semantics":"Network",
         "api_names":[
            "GopherCreateLocatorA",
            "GopherCreateLocatorW",
            "GopherFindFirstFileA",
            "GopherFindFirstFileW",
            "GopherGetAttributeA",
            "GopherGetAttributeW",
            "GopherGetLocatorTypeA",
            "GopherGetLocatorTypeW",
            "GopherOpenFileA",
            "GopherOpenFileW"
         ]
      },
      {
         "api_group":"URL",
         "api_semantics":"Network",
         "api_names":[
            "URLDownloadToCacheFile",
            "URLDownloadToFile",
            "URLOpenBlockingStream",
            "URLOpenStream",
            "UrlApplySchemeA",
            "UrlApplySchemeW",
            "UrlCanonicalizeA",
            "UrlCanonicalizeW",
            "UrlCombineA",
            "UrlCombineW",
            "UrlCompareA",
            "UrlCompareW",
            "UrlCreateFromPathA",
            "UrlCreateFromPathW",
            "UrlEscapeA",
            "UrlEscapeW",
            "UrlGetLocationA",
            "UrlGetLocationW",
            "UrlGetPartA",
            "UrlGetPartW",
            "UrlHashA",
            "UrlHashW",
            "UrlIsA",
            "UrlIsNoHistoryA",
            "UrlIsNoHistoryW",
            "UrlIsOpaqueA",
            "UrlIsOpaqueW",
            "UrlIsW",
            "UrlUnescapeA",
            "UrlUnescapeW"
         ]
      },
      {
         "api_group":"Directory",
         "api_semantics":"File System",
         "api_names":[
            "CreateDirectoryA",
            "CreateDirectoryExA",
            "CreateDirectoryExW",
            "CreateDirectoryW",
            "GetCurrentDirectoryA",
            "GetCurrentDirectoryW",
            "GetDllDirectoryA",
            "GetDllDirectoryW",
            "GetSystemDirectoryA",
            "GetSystemDirectoryW",
            "GetSystemWindowsDirectoryA",
            "GetSystemWindowsDirectoryW",
            "GetSystemWow64DirectoryA",
            "GetSystemWow64DirectoryW",
            "GetVDMCurrentDirectories",
            "GetWindowsDirectoryA",
            "GetWindowsDirectoryW",
            "ReadDirectoryChangesW",
            "RemoveDirectoryA",
            "RemoveDirectoryW",
            "SHCreateDirectory",
            "SHCreateDirectoryExA",
            "SHCreateDirectoryExW",
            "SetCurrentDirectory",
            "SetCurrentDirectoryA",
            "SetCurrentDirectoryW",
            "SetDllDirectoryA",
            "SetDllDirectoryW",
            "SetVDMCurrentDirectories"
         ]
      },
      {
         "api_group":"Mutex",
         "api_semantics":"Execution",
         "api_names":[
            "CreateMutexA",
            "CreateMutexExA",
            "CreateMutexExW",
			"OpenMutexA",
            "CreateMutexW",
            "OpenMutexW",
            "ReleaseMutex"
         ]
      },
      {
         "api_group":"Pipe",
         "api_semantics":"File System",
         "api_names":[
            "CallNamedPipeA",
            "CallNamedPipeW",
            "ConnectNamedPipe",
            "CreateNamedPipeA",
            "CreateNamedPipeW",
            "CreatePipe",
            "DisconnectNamedPipe",
            "GetNamedPipeHandleStateA",
            "GetNamedPipeHandleStateW",
            "GetNamedPipeInfo",
            "PeekNamedPipe",
            "SetNamedPipeHandleState",
            "TransactNamedPipe",
            "WaitNamedPipeA",
            "WaitNamedPipeW"
         ]
      },
      {
         "api_group":"HTTP",
         "api_semantics":"Network",
         "api_names":[
            "HttpAddRequestHeaders",
            "HttpAddRequestHeadersA",
            "HttpAddRequestHeadersW",
            "HttpCheckDavCompliance",
            "HttpEndRequestA",
            "HttpEndRequestW",
            "HttpOpenRequestA",
            "HttpOpenRequestW",
            "HttpQueryInfoA",
            "HttpQueryInfoW",
            "HttpSendRequestA",
            "HttpSendRequestExA",
            "HttpSendRequestExW",
            "HttpSendRequestW"
         ]
      },
      {
         "api_group":"Process/Thread Enumeration",
         "api_semantics":"Execution",
         "api_names":[
            "CreateToolhelp32Snapshot",
            "EnumProcessModules",
            "EnumProcessModulesEx",
            "EnumProcesses",
            "GetCurrentProcess",
            "GetCurrentProcessId",
            "GetCurrentThread",
            "GetCurrentThreadId",
            "GetProcessId",
            "GetProcessIdOfThread",
            "GetThreadId",
            "GetThreadInformation",
            "GetThreadLocale",
            "IsWoW64Process",
            "IsWoW64Process",
            "Module32First",
            "Module32Next",
            "NtQueryInformationProcess",
            "Process32First",
            "Process32FirstW",
            "Process32Next",
            "Process32NextW",
            "Thread32First",
            "Thread32Next"
         ]
      },
      {
         "api_group":"Hashing",
         "api_semantics":"Cryptography",
         "api_names":[
            "CryptCreateHash",
            "CryptDestroyHash",
            "CryptDuplicateHash",
            "CryptGetHashParam",
            "CryptHashData",
            "CryptHashSessionKey",
            "CryptSetHashParam",
            "CryptSignHashA",
            "CryptSignHashW",
            "FreeEncryptionCertificateHashList"
         ]
      },
      {
         "api_group":"General",
         "api_semantics":"Cryptography",
         "api_names":[
            "AddUsersToEncryptedFile",
            "ChainWlxLogoffEvent",
            "CloseEncryptedFileRaw",
            "CryptAcquireContextA",
            "CryptAcquireContextU",
            "CryptAcquireContextW",
            "CryptBinaryToString",
            "CryptBinaryToStringA",
            "CryptBinaryToStringW",
            "CryptCloseAsyncHandle",
            "CryptContextAddRef",
            "CryptCreateAsyncHandle",
            "CryptDecodeMessage",
            "CryptDecodeObject",
            "CryptDecodeObjectEx",
            "CryptDecrypt",
            "CryptDecryptAndVerifyMessageSignature",
            "CryptDecryptMessage",
            "CryptDeriveKey",
            "CryptDestroyKey",
            "CryptDuplicateKey",
            "CryptEncodeObject",
            "CryptEncodeObjectEx",
            "CryptEncrypt",
            "CryptEncryptMessage",
            "CryptEnumKeyIdentifierProperties",
            "CryptEnumOIDFunction",
            "CryptEnumOIDInfo",
            "CryptEnumProviderTypesA",
            "CryptEnumProviderTypesW",
            "CryptEnumProvidersA",
            "CryptEnumProvidersU",
            "CryptEnumProvidersW",
            "CryptExportKey",
            "CryptExportPKCS8",
            "CryptExportPublicKeyInfo",
            "CryptExportPublicKeyInfoEx",
            "CryptFindLocalizedName",
            "CryptFindOIDInfo",
            "CryptFormatObject",
            "CryptFreeOIDFunctionAddress",
            "CryptGenKey",
            "CryptGenRandom",
            "CryptGetAsyncParam",
            "CryptGetDefaultOIDDllList",
            "CryptGetDefaultOIDFunctionAddress",
            "CryptGetDefaultProviderA",
            "CryptGetDefaultProviderW",
            "CryptGetKeyIdentifierProperty",
            "CryptGetKeyParam",
            "CryptGetMessageCertificates",
            "CryptGetMessageSignerCount",
            "CryptGetOIDFunctionAddress",
            "CryptGetOIDFunctionValue",
            "CryptGetProvParam",
            "CryptGetUserKey",
            "CryptHashCertificate",
            "CryptHashMessage",
            "CryptHashPublicKeyInfo",
            "CryptHashToBeSigned",
            "CryptImportKey",
            "CryptImportPKCS8",
            "CryptImportPublicKeyInfo",
            "CryptImportPublicKeyInfoEx",
            "CryptInitOIDFunctionSet",
            "CryptInstallDefaultContext",
            "CryptInstallOIDFunctionAddress",
            "CryptLoadSip",
            "CryptMemAlloc",
            "CryptMemFree",
            "CryptMemRealloc",
            "CryptMsgCalculateEncodedLength",
            "CryptMsgClose",
            "CryptMsgControl",
            "CryptMsgCountersign",
            "CryptMsgCountersignEncoded",
            "CryptMsgDuplicate",
            "CryptMsgEncodeAndSignCTL",
            "CryptMsgGetAndVerifySigner",
            "CryptMsgGetParam",
            "CryptMsgOpenToDecode",
            "CryptMsgOpenToEncode",
            "CryptMsgSignCTL",
            "CryptMsgUpdate",
            "CryptMsgVerifyCountersignatureEncoded",
            "CryptMsgVerifyCountersignatureEncodedEx",
            "CryptProtectData",
            "CryptQueryObject",
            "CryptRegisterDefaultOIDFunction",
            "CryptRegisterOIDFunction",
            "CryptRegisterOIDInfo",
            "CryptReleaseContext",
            "CryptSIPAddProvider",
            "CryptSIPCreateIndirectData",
            "CryptSIPGetSignedDataMsg",
            "CryptSIPLoad",
            "CryptSIPPutSignedDataMsg",
            "CryptSIPRemoveProvider",
            "CryptSIPRemoveSignedDataMsg",
            "CryptSIPRetrieveSubjectGuid",
            "CryptSIPRetrieveSubjectGuidForCatalogFile",
            "CryptSIPVerifyIndirectData",
            "CryptSetAsyncParam",
            "CryptSetKeyIdentifierProperty",
            "CryptSetKeyParam",
            "CryptSetOIDFunctionValue",
            "CryptSetProvParam",
            "CryptSetProviderA",
            "CryptSetProviderExA",
            "CryptSetProviderExW",
            "CryptSetProviderU",
            "CryptSetProviderW",
            "CryptSignAndEncodeCertificate",
            "CryptSignAndEncryptMessage",
            "CryptSignCertificate",
            "CryptSignHashU",
            "CryptSignMessage",
            "CryptSignMessageWithKey",
            "CryptStringToBinary",
            "CryptStringToBinaryA",
            "CryptStringToBinaryW",
            "CryptUninstallDefaultContext",
            "CryptUnprotectData",
            "CryptUnregisterDefaultOIDFunction",
            "CryptUnregisterOIDFunction",
            "CryptUnregisterOIDInfo",
            "CryptVerifyCertificateSignature",
            "CryptVerifyCertificateSignatureEx",
            "CryptVerifyDetachedMessageHash",
            "CryptVerifyDetachedMessageSignature",
            "CryptVerifyMessageHash",
            "CryptVerifyMessageSignature",
            "CryptVerifyMessageSignatureWithKey",
            "CryptVerifySignatureA",
            "CryptVerifySignatureU",
            "CryptVerifySignatureW",
            "DecryptFileA",
            "DecryptFileW",
            "DuplicateEncryptionInfoFile",
            "EncryptFileA",
            "EncryptFileW",
            "EncryptedFileKeyInfo",
            "EncryptionDisable",
            "FileEncryptionStatusA",
            "FileEncryptionStatusW",
            "FlushEfsCache",
            "FreeEncryptedFileKeyInfo",
            "OpenEncryptedFileRawA",
            "OpenEncryptedFileRawW",
            "QueryRecoveryAgentsOnEncryptedFile",
            "QueryUsersOnEncryptedFile",
            "ReadEncryptedFileRaw",
            "RemoveUsersFromEncryptedFile",
            "SetUserFileEncryptionKey",
            "WriteEncryptedFileRaw"
         ]
      },
      {
         "api_group":"System Services",
         "api_semantics":"Execution",
         "api_names":[
            "ChangeServiceConfig2A",
            "ChangeServiceConfig2W",
            "ChangeServiceConfigA",
            "ChangeServiceConfigW",
            "CloseServiceHandle",
            "ControlService",
            "CreateServiceA",
            "CreateServiceW",
            "DeleteService",
            "EnumDependentServicesA",
            "EnumDependentServicesW",
            "EnumServiceGroupW",
            "EnumServicesStatusA",
            "EnumServicesStatusExA",
            "EnumServicesStatusExW",
            "EnumServicesStatusW",
            "GetServiceDisplayNameA",
            "GetServiceDisplayNameW",
            "GetServiceKeyNameA",
            "GetServiceKeyNameW",
            "I_ScPnPGetServiceName",
            "I_ScSetServiceBitsA",
            "I_ScSetServiceBitsW",
            "LockServiceDatabase",
            "OpenServiceA",
            "OpenServiceW",
            "PrivilegedServiceAuditAlarmA",
            "PrivilegedServiceAuditAlarmW",
            "QueryServiceConfig2A",
            "QueryServiceConfig2W",
            "QueryServiceConfigA",
            "QueryServiceConfigW",
            "QueryServiceLockStatusA",
            "QueryServiceLockStatusW",
            "QueryServiceObjectSecurity",
            "QueryServiceStatus",
            "QueryServiceStatusEx",
            "RegisterServiceCtrlHandlerA",
            "RegisterServiceCtrlHandlerExA",
            "RegisterServiceCtrlHandlerExW",
            "RegisterServiceCtrlHandlerW",
            "SetServiceBits",
            "SetServiceObjectSecurity",
            "SetServiceStatus",
            "StartServiceA",
            "StartServiceCtrlDispatcherA",
            "StartServiceCtrlDispatcherW",
            "StartServiceW",
            "UnlockServiceDatabase",
            "WdmWmiServiceMain"
         ]
      },
      {
         "api_group":"Files",
         "api_semantics":"File System",
         "api_names":[
            "CompareFileTime",
            "CopyFile2",
            "CopyFileA",
            "CopyFileExA",
            "CopyFileExW",
            "CopyFileW",
            "CopyLZFile",
            "CreateFile2",
            "CreateFileA",
            "CreateFileMappingA",
            "CreateFileMappingW",
            "CreateFileU",
            "CreateFileW",
            "DeleteFileA",
            "DeleteFileW",
            "DosDateTimeToFileTime",
            "FileTimeToDosDateTime",
            "FileTimeToLocalFileTime",
            "FileTimeToSystemTime",
            "FlushFileBuffers",
            "FlushViewOfFile",
            "GetCPFileNameFromRegistry",
            "GetCompressedFileSizeA",
            "GetCompressedFileSizeW",
            "GetFileAttributesA",
            "GetFileAttributesExA",
            "GetFileAttributesExW",
            "GetFileAttributesW",
            "GetFileInformationByHandle",
            "GetFileSecurityA",
            "GetFileSecurityW",
            "GetFileSize",
            "GetFileSizeEx",
            "GetFileTime",
            "GetFileType",
            "GetSystemTimeAsFileTime",
            "GetTempFileNameA",
            "GetTempFileNameW",
            "LZCloseFile",
            "LZCreateFileW",
            "LZOpenFileA",
            "LZOpenFileW",
            "LocalFileTimeToFileTime",
            "LockFile",
            "LockFileEx",
            "MapViewOfFile",
            "MapViewOfFileEx",
            "MoveFileA",
            "MoveFileExA",
            "MoveFileExW",
            "MoveFileW",
            "MoveFileWithProgressA",
            "MoveFileWithProgressW",
            "NtClose",
            "NtCreateFile",
            "OpenDataFile",
            "OpenFile",
            "OpenFileMappingA",
            "OpenFileMappingW",
            "OpenProfileUserMapping",
            "PathFileExistsA",
            "PathFileExistsW",
            "PrivCopyFileExW",
            "PrivMoveFileIdentityW",
            "ReadFile",
            "ReadFileEx",
            "ReplaceFile",
            "ReplaceFileA",
            "ReplaceFileW",
            "SearchPathA",
            "SearchPathW",
            "SetEndOfFile",
            "SetFileAttributesA",
            "SetFileAttributesW",
            "SetFilePointer",
            "SetFilePointerEx",
            "SetFileSecurityA",
            "SetFileSecurityW",
            "SetFileShortNameA",
            "SetFileShortNameW",
            "SetFileTime",
            "SetFileValidData",
            "SystemTimeToFileTime",
            "UnlockFile",
            "UnlockFileEx",
            "UnmapViewOfFile",
            "WriteFile",
            "WriteFileEx",
            "WriteFileGather"
         ]
      },
      {
         "api_group":"Binary Modules",
         "api_semantics":"File System",
         "api_names":[
            "EnumResourceTypesA",
            "EnumResourceTypesExA",
            "EnumResourceTypesExW",
            "EnumResourceTypesW",
            "FindResourceA",
            "FindResourceExA",
            "FindResourceExW",
            "FindResourceW",
            "GetModuleBaseNameA",
            "GetModuleBaseNameW",
            "GetModuleFileNameA",
            "GetModuleFileNameExA",
            "GetModuleFileNameExW",
            "GetModuleFileNameW",
            "GetModuleHandleA",
            "GetModuleHandleW",
            "GetProcAddress",
            "LdrLoadDll",
            "LoadLibraryA",
            "LoadLibraryExA",
            "LoadLibraryExW",
            "LoadLibraryW",
            "LoadResource",
            "LockResource",
            "MapViewOfFile2",
            "MapViewOfFile3",
            "NtCreateSection",
            "NtMapViewOfSection",
            "NtUnmapViewOfSection",
            "SizeOfResource",
            "SizeOfResource"
         ]
      },
      {
         "api_group":"Devices",
         "api_semantics":"Configuration",
         "api_names":[
            "DeviceIoControl",
            "GetLogicalDrives",
            "GetRawInputData",
            "RegisterRawInputDevices"
         ]
      },
      {
         "api_group":"System Information",
         "api_semantics":"Configuration",
         "api_names":[
            "CheckTokenMembership",
            "EnumDeviceDrivers",
            "EnumSystemLocalesA",
            "EnumSystemLocalesW",
            "ExitWindowsEx",
            "GetComputerNameA",
            "GetComputerNameExA",
            "GetComputerNameExW",
            "GetComputerNameW",
            "GetCurrentHwProfileA",
            "GetCurrentHwProfileW",
            "GetDiskFreeSpaceA",
            "GetDiskFreeSpaceExA",
            "GetDiskFreeSpaceExW",
            "GetDiskFreeSpaceW",
            "GetDriveTypeA",
            "GetDriveTypeW",
            "GetLogicalProcessorInformation",
            "GetLogicalProcessorInformationEx",
            "GetNativeSystemInfo",
            "GetSystemDefaultLangId",
            "GetSystemInfo",
            "GetSystemMetrics",
            "GetSystemTime",
            "GetVersion",
            "GetVersionExA",
            "GetVersionExW",
            "NtQuerySystemEnvironmentValueEx",
            "NtSetSystemEnvironmentValueEx",
            "NtShutdownSystem",
            "RtlGetVersion",
            "RtlGetVersion"
         ]
      },
      {
         "api_group":"Certificates",
         "api_semantics":"Cryptography",
         "api_names":[
            "CertAddCRLContextToStore",
            "CertAddCRLLinkToStore",
            "CertAddCTLContextToStore",
            "CertAddCTLLinkToStore",
            "CertAddCertificateContextToStore",
            "CertAddCertificateLinkToStore",
            "CertAddEncodedCRLToStore",
            "CertAddEncodedCertificateToStore",
            "CertAddEncodedCertificateToSystemStoreA",
            "CertAddEncodedCertificateToSystemStoreW",
            "CertAddEnhancedKeyUsageIdentifier",
            "CertAddSerializedElementToStore",
            "CertAddStoreToCollection",
            "CertAlgIdToOID",
            "CertCloseStore",
            "CertCompareCertificate",
            "CertCompareCertificateName",
            "CertCompareIntegerBlob",
            "CertComparePublicKeyInfo",
            "CertControlStore",
            "CertCreateCTLContext",
            "CertCreateCTLEntryFromCertificateContextProperties",
            "CertCreateCertificateChainEngine",
            "CertCreateCertificateContext",
            "CertCreateContext",
            "CertCreateSelfSignCertificate",
            "CertDeleteCTLFromStore",
            "CertDeleteCertificateFromStore",
            "CertDuplicateCTLContext",
            "CertDuplicateCertificateChain",
            "CertDuplicateCertificateContext",
            "CertDuplicateStore",
            "CertEnumCRLContextProperties",
            "CertEnumCRLsInStore",
            "CertEnumCTLContextProperties",
            "CertEnumCTLsInStore",
            "CertEnumCertificateContextProperties",
            "CertEnumCertificatesInStore",
            "CertEnumPhysicalStore",
            "CertEnumSubjectInSortedCTL",
            "CertEnumSystemStore",
            "CertEnumSystemStoreLocation",
            "CertFindAttribute",
            "CertFindCRLInStore",
            "CertFindCertificateInCRL",
            "CertFindCertificateInStore",
            "CertFindChainInStore",
            "CertFindExtension",
            "CertFindRDNAttr",
            "CertFindSubjectInCTL",
            "CertFindSubjectInSortedCTL",
            "CertFreeCRLContext",
            "CertFreeCertificateChain",
            "CertFreeCertificateChainEngine",
            "CertFreeCertificateContext",
            "CertGetCRLContextProperty",
            "CertGetCRLFromStore",
            "CertGetCTLContextProperty",
            "CertGetCertificateChain",
            "CertGetCertificateContextProperty",
            "CertGetEnhancedKeyUsage",
            "CertGetIssuerCertificateFromStore",
            "CertGetNameStringA",
            "CertGetNameStringW",
            "CertGetPublicKeyLength",
            "CertGetStoreProperty",
            "CertGetSubjectCertificateFromStore",
            "CertGetValidUsages",
            "CertIsRDNAttrsInCertificateName",
            "CertIsValidCRLForCertificate",
            "CertNameToStrA",
            "CertNameToStrW",
            "CertOIDToAlgId",
            "CertOpenStore",
            "CertOpenSystemStoreA",
            "CertOpenSystemStoreW",
            "CertRDNValueToStrA",
            "CertRDNValueToStrW",
            "CertRegisterPhysicalStore",
            "CertRegisterSystemStore",
            "CertRemoveEnhancedKeyUsageIdentifier",
            "CertRemoveStoreFromCollection",
            "CertResyncCertificateChainEngine",
            "CertSaveStore",
            "CertSerializeCRLStoreElement",
            "CertSerializeCertificateStoreElement",
            "CertSetCRLContextProperty",
            "CertSetCertificateContextPropertiesFromCTLEntry",
            "CertSetCertificateContextProperty",
            "CertSetEnhancedKeyUsage",
            "CertSetStoreProperty",
            "CertStrToNameA",
            "CertStrToNameW",
            "CertUnregisterPhysicalStore",
            "CertUnregisterSystemStore",
            "CertVerifyCRLRevocation",
            "CertVerifyCRLTimeValidity",
            "CertVerifyCTLUsage",
            "CertVerifyCertificateChainPolicy",
            "CertVerifyRevocation",
            "CertVerifySubjectCertificateContext",
            "CertVerifyTimeValidity",
            "CertVerifyValidityNesting",
            "CloseCertPerformanceData",
            "CollectCertPerformanceData",
            "CryptAcquireCertificatePrivateKey",
            "CryptFindCertificateKeyProvInfo",
            "CryptGetMessageCertificates",
            "CryptHashCertificate",
            "CryptSignAndEncodeCertificate",
            "CryptSignCertificate",
            "CryptVerifyCertificateSignature",
            "CryptVerifyCertificateSignatureEx",
            "OpenCertPerformanceData",
            "PFXExportCertStore",
            "PFXExportCertStoreEx",
            "PFXImportCertStore"
         ]
      },
      {
         "api_group":"File Search",
         "api_semantics":"File System",
         "api_names":[
            "FindClose",
            "FindFirstFileA",
            "FindFirstFileW",
            "FindNextFileA",
            "FindNextFileW",
            "GetTempPathA",
            "GetTempPathW",
            "NtQueryDirectoryFile"
         ]
      },
      {
         "api_group":"Virtual Memory",
         "api_semantics":"Memory",
         "api_names":[
            "GetProcessHeap",
            "GetProcessHeaps",
            "GlobalAlloc",
            "HeapAlloc",
            "HeapCreate",
            "HeapReAlloc",
            "LocalAlloc",
            "NtAllocateVirtualMemory",
            "NtProtectVirtualMemory",
            "NtReadVirtualMemory",
            "NtReadVirtualMemoryEx",
            "NtWriteVirtualMemory",
            "ReadProcessMemory",
            "RtlCopyMemory",
            "RtlCreateHeap",
            "RtlMoveMemory",
            "Toolhelp32ReadProcessMemory",
            "VirtualAlloc",
            "VirtualAlloc2",
            "VirtualAlloc2FromApp",
            "VirtualAllocEx",
            "VirtualAllocExNuma",
            "VirtualAllocFromApp",
            "VirtualBufferExceptionHandler",
            "VirtualFree",
            "VirtualFreeEx",
            "VirtualLock",
            "VirtualProtect",
            "VirtualProtectEx",
            "VirtualProtectFromApp",
            "VirtualQuery",
            "VirtualQueryEx",
            "VirtualUnlock",
            "WriteProcessMemory"
         ]
      },
      {
         "api_group":"Critical Section",
         "api_semantics":"Execution",
         "api_names":[
            "DeleteCriticalSection",
            "EnterCriticalSection",
            "InitializeCriticalSection",
            "InitializeCriticalSectionAndSpinCount",
            "LeaveCriticalSection",
            "SetCriticalSectionSpinCount",
            "TryEnterCriticalSection"
         ]
      },
      {
         "api_group":"Keyboard and Mouse Input",
         "api_semantics":"Data Exchange",
         "api_names":[
            "CountClipboardFormats",
            "GetAsyncKeyState",
            "GetClipboardData",
            "GetKeyState",
            "GetKeyboardState",
            "GetKeynameTextA",
            "GetKeynameTextW",
            "MapVirtualKeyA",
            "MapVirtualKeyExA",
            "MapVirtualKeyExW",
            "MapVirtualKeyW",
            "OpenClipboard",
            "RegisterHotKey",
            "SetClipboardData"
         ]
      },
      {
         "api_group":"Synchronization",
         "api_semantics":"Execution",
         "api_names":[
            "CreateTimerQueueTimer",
            "CreateWaitableTimer",
            "GetTickCount",
            "GetTickCount64",
            "NtQueryTimer",
            "NtWaitForMultipleObjects",
            "NtWaitForSingleObject",
            "QueryPerformanceCounter",
            "QueryPerformanceFrequency",
            "SetTimer",
            "SetWaitableTimer",
            "Sleep",
            "SleepEx",
            "TimeGetTime",
            "WaitForMultipleObjects",
            "WaitForMultipleObjectsEx",
            "WaitForSingleObjectEx",
            "timeSetEvent"
         ]
      },
      {
         "api_group":"Services",
         "api_semantics":"Execution",
         "api_names":[
            "ControlServiceExA",
            "ControlServiceExW",
            "OpenSCManagerA",
            "OpenSCManagerW"
         ]
      },
      {
         "api_group":"General",
         "api_semantics":"General",
         "api_names":[
            "NtMakeTemporaryObject",
            "UuidFromStringA",
            "UuidFromStringW"
         ]
      },
      {
         "api_group":"Process/Thread Lifecycle",
         "api_semantics":"Execution",
         "api_names":[
            "AttachThreadInput",
            "CreateProcessA",
            "CreateProcessAsUserA",
            "CreateProcessAsUserW",
            "CreateProcessInternal",
            "CreateProcessW",
            "CreateRemoteThread",
            "CreateRemoteThreadEx",
            "CreateThread",
            "GetThreadContext",
            "KeInsertQueueApc",
            "NtContinue",
            "NtCreateProcess",
            "NtCreateProcessEx",
            "NtCreateThread",
            "NtCreateThreadEx",
            "NtCreateUserProcess",
            "NtDelayExecution",
            "NtDuplicateObject",
            "NtOpenProcess",
            "NtOpenThread",
            "NtQueueApcThread",
            "NtQueueApcThreadEx",
            "NtQueueApcThreadEx2",
            "NtResumeProcess",
            "NtResumeThread",
            "NtSetInformationProcess",
            "NtSetInformationThread",
            "NtSuspendProcess",
            "NtTerminateProcess",
            "NtTerminateThread",
            "OpenProcess",
            "OpenThread",
            "QueueUserAPC",
            "ResumeThread",
            "RtlSetProcessIsCritical",
            "SetEnvironmentVariableA",
            "SetEnvironmentVariableW",
            "SetProcessDEPPolicy",
            "SetThreadContext",
            "SetThreadPriority",
            "ShellExecute",
            "ShellExecuteA",
            "ShellExecuteEx",
            "ShellExecuteExA",
            "ShellExecuteExW",
            "ShellExecuteW",
            "SuspendThread",
            "TerminateProcess",
            "TerminateThread",
            "WinExec",
            "Wow64SetThreadContext"
         ]
      },
      {
         "api_group":"Strings/Characters",
         "api_semantics":"Memory",
         "api_names":[
			"lstrcmpA",
			"lstrcmpW",
			"lstrcpyA",
			"lstrcpyW",
			"lstrcpynA",
			"lstrcpynW",
			"lstrlenA",
			"lstrlenW",
            "lstrcatA",
            "lstrcatW"
         ]
      }
   ]
}

```

`idaclu/plugins/group_3/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Control Flow')

```

`idaclu/plugins/group_3/plugin_1.py`:

```py
import collections
import json
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Control Flow Analysis')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_func_item_eas(func_addr):
    for item_ea in list(idautils.FuncItems(func_addr)):
        if ida_shims.is_code(ida_shims.get_full_flags(func_addr)):
            yield item_ea

def is_func_proxy(func_addr):
    item_eas = list(get_func_item_eas(func_addr))
    if ida_shims.ua_mnem(item_eas[-1]) == 'jmp':
        return True
    else:
        return False

def is_func_switch(func_addr):
    for (f_beg, f_end) in idautils.Chunks(func_addr):
        for head_ea in idautils.Heads(f_beg, f_end):
            if ida_shims.is_code(ida_shims.get_full_flags(head_ea)):
                si = ida_shims.get_switch_info(head_ea)
                if si == None:
                    continue
                results = idaapi.calc_switch_cases(head_ea, si)
                if results:
                    return True
                return False

def is_func_loop(func_desc):
    func_start_ea = ida_shims.start_ea(func_desc)

    blocks = [func_start_ea]
    for block in idaapi.FlowChart(func_desc):
        end_ea = ida_shims.end_ea(block)
        blocks.append(end_ea)

    for block in blocks:
        for xref in idautils.XrefsTo(block):
            xref_func = idaapi.get_func(xref.frm)
            xref_start_ea = ida_shims.start_ea(xref_func)

            if xref_func and xref_start_ea == func_start_ea:
                if xref.frm >= block:
                    return True
    return False


def is_func_simple_recursion(func_addr):
    for h in idautils.FuncItems(func_addr):
        for r in idautils.XrefsFrom(h, 0):
            if ((r.type == idaapi.fl_CF or r.type == idaapi.fl_CN) and
                r.to == func_addr):
                return True
    return False

stack = []
def is_func_recursion(func_addr):
    global stack
    if func_addr in stack:
        # print "This is recursive function", hex(func_addr), Name(func_addr)
        # for x in stack:
        #     print "\t", hex(x)
        # #insert your renaming here, it should be idc.MakeName
        return

    stack.append(func_addr)
    for h in idautils.FuncItems(func_addr):
        for r in idautils.XrefsFrom(h, 0):
            if ((r.type == idaapi.fl_CF or r.type == idaapi.fl_CN) and
                r.to != func_addr):
                is_func_recursion(r.to)
    stack = stack[:-1]

def is_func_condition(func_desc):
    bb_list = list(idaapi.FlowChart(func_desc))
    bb_num = len(bb_list)
    bb_conn_count = len(list(bb_list[0].succs()))
    if ((bb_num == 1 and bb_conn_count == 0) or
        (bb_num == 2 and bb_conn_count == 1 and is_func_proxy(ida_shims.start_ea(func_desc)))):
        return False
    return True

def get_data(func_gen=None, env_desc=None, plug_params=None):
    global stack

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_desc = idaapi.get_func(func_addr)
        func_groups = []
        if is_func_proxy(func_addr):
            func_groups.append('proxy')

        is_switch = False
        if is_func_switch(func_addr):
            func_groups.append('switch')
            is_switch = True

        is_loop = False
        if is_func_loop(func_desc):
            func_groups.append('loop')
            is_loop = True

        if is_switch == False and is_loop == False:
            if is_func_condition(func_desc):
                func_groups.append('conditions')
            else:
                func_groups.append('simple')

        stack = []
        if is_func_simple_recursion(func_addr):
            if func_addr in stack:
                func_groups.append('simple_recursion')

        for g_name in func_groups:
            report['data'][g_name].append(func_addr)
            report['stat'][g_name] += 1

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_3/plugin_2.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Pseudocode Size')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z\: ]+)(\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key))

def get_psdo_list(func_ea):
    func_pseudocode = []
    decomp_str = ""
    try:
       decomp_str = idaapi.decompile(func_ea)
    except idaapi.DecompilationFailure:
       return []
    for line in str(decomp_str).split('\n'):
        if '//' in line:
            code = line.split('//')[0]
            if code != '':
                func_pseudocode.append(code.lstrip())
        else:
            if line != '':
                func_pseudocode.append(line.lstrip())
    return func_pseudocode
    
def get_psdo_body(func_ea):
    psdo_list = get_psdo_list(func_ea)
    return psdo_list[2:-1]

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_psdo_size = len(get_psdo_body(func_addr))
        key_name = "size: {}".format(func_psdo_size)
        report['data'][key_name].append(func_addr)
        report['stat'][key_name] += 1

    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])
    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_4/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Code Coverage')

```

`idaclu/plugins/group_4/drcov.py`:

```py
#!/usr/bin/python
import os
import re
import sys
import mmap
import struct
import collections
from ctypes import *


#------------------------------------------------------------------------------
# DynamoRIO Drcov Log Parser
#------------------------------------------------------------------------------

class DrcovData(object):
    """
    A drcov log parser.
    """

    def __init__(self, filepath=None):
        self.filepath = filepath

        # drcov header attributes
        self.version = 0
        self.flavor = None

        # drcov module table
        self.module_table_count = 0
        self.module_table_version = 0
        self.modules = {}

        # drcov basic block data
        self.bbs = []
        self.bb_table_count = 0
        self.bb_table_is_binary = True

        # parse
        self._parse()

    #--------------------------------------------------------------------------
    # Public
    #--------------------------------------------------------------------------

    def get_offsets(self, module_name):
        """
        Return coverage data as basic block offsets for the named module.
        """
        modules = self.modules.get(module_name, [])
        if not modules:
            return []

        #
        # I don't know if this should ever actually trigger, but if it does,
        # it is a strange testcase to collect coverage against. It means that
        # maybe the target library/module was loaded, unloaded, and reloaded?
        #
        # if someone ever actally triggers this, we can look into it :S
        #

        if self.version > 2:
            assert all(module.containing_id == modules[0].id for module in modules)

        # extract the unique module ids that we need to collect blocks for
        mod_ids = [module.id for module in modules]

        # loop through the coverage data and filter out data for the target ids
        coverage_blocks = [bb.start for bb in self.bbs if bb.mod_id in mod_ids]

        # return the filtered coverage blocks
        return coverage_blocks

    def get_offset_blocks(self, module_name):
        """
        Return coverage data as basic blocks (offset, size) for the named module.
        """
        modules = self.modules.get(module_name, [])
        if not modules:
            return []

        # NOTE: see comment in get_offsets() for more info...
        if self.version > 2:
            assert all(module.containing_id == modules[0].id for module in modules)

        # extract the unique module ids that we need to collect blocks for
        mod_ids = [module.id for module in modules]

        # loop through the coverage data and filter out data for the target ids
        coverage_blocks = [(bb.start, bb.size) for bb in self.bbs if bb.mod_id in mod_ids]

        # return the filtered coverage blocks
        return coverage_blocks

    #--------------------------------------------------------------------------
    # Parsing Routines - Top Level
    #--------------------------------------------------------------------------

    def _parse(self):
        """
        Parse drcov coverage from the given log file.
        """
        with open(self.filepath, "rb") as f:
            self._parse_drcov_header(f)
            self._parse_module_table(f)
            self._parse_bb_table(f)

    #--------------------------------------------------------------------------
    # Parsing Routines - Internals
    #--------------------------------------------------------------------------

    def _parse_drcov_header(self, f):
        """
        Parse drcov log header from filestream.
        """

        # parse drcov version from log
        #   eg: DRCOV VERSION: 2
        version_line = f.readline().decode('utf-8').strip()
        self.version = int(version_line.split(":")[1])

        # parse drcov flavor from log
        #   eg: DRCOV FLAVOR: drcov
        flavor_line = f.readline().decode('utf-8').strip()
        self.flavor = flavor_line.split(":")[1]

        assert self.version == 2, "Only drcov version 2 log files supported"

    def _parse_module_table(self, f):
        """
        Parse drcov log module table from filestream.
        """
        self._parse_module_table_header(f)
        self._parse_module_table_columns(f)
        self._parse_module_table_modules(f)

    def _parse_module_table_header(self, f):
        """
        Parse drcov log module table header from filestream.

        -------------------------------------------------------------------

        Format used in DynamoRIO v6.1.1 through 6.2.0
           eg: 'Module Table: 11'

        Format used in DynamoRIO v7.0.0-RC1 (and hopefully above)
           eg: 'Module Table: version X, count 11'

        """

        # parse module table 'header'
        #   eg: Module Table: version 2, count 11
        header_line = f.readline().decode('utf-8').strip()
        field_name, field_data = header_line.split(": ")
        #assert field_name == "Module Table"

        #
        # NOTE/COMPAT:
        #
        #   DynamoRIO doesn't document their drcov log format, and it has
        #   changed its format at least once during its lifetime.
        #
        #   we just have to try parsing the table header one way to determine
        #   if its the old (say, a 'v1') table, or the new 'v2' table.
        #

        try:

            # seperate 'version X' and 'count Y' from each other ('v2')
            version_data, count_data = field_data.split(", ")

        # failure to unpack indicates this is an 'older, v1' drcov log
        except ValueError:
            self.module_table_count   = int(field_data)
            self.module_table_version = 1
            return

        # parse module table version out of 'version X'
        data_name, version = version_data.split(" ")
        #assert data_name == "version"
        self.module_table_version = int(version)
        if not self.module_table_version in [2, 3, 4, 5]:
            raise ValueError("Unsupported (new?) drcov log format...")

        # parse module count in table from 'count Y'
        data_name, count = count_data.split(" ")
        #assert data_name == "count"
        self.module_table_count = int(count)

    def _parse_module_table_columns(self, f):
        """
        Parse drcov log module table columns from filestream.

        -------------------------------------------------------------------

        DynamoRIO v6.1.1, table version 1:
           eg: (Not present)

        DynamoRIO v7.0.0-RC1, table version 2:
           Windows:
             'Columns: id, base, end, entry, checksum, timestamp, path'
           Mac/Linux:
             'Columns: id, base, end, entry, path'

        DynamoRIO v7.0.17594B, table version 3:
           Windows:
             'Columns: id, containing_id, start, end, entry, checksum, timestamp, path'
           Mac/Linux:
             'Columns: id, containing_id, start, end, entry, path'

        DynamoRIO v7.0.17640, table version 4:
           Windows:
             'Columns: id, containing_id, start, end, entry, offset, checksum, timestamp, path'
           Mac/Linux:
             'Columns: id, containing_id, start, end, entry, offset, path'

        """

        # NOTE/COMPAT: there is no 'Columns' line for the v1 table...
        if self.module_table_version == 1:
            return

        # parse module table 'columns'
        #   eg: Columns: id, base, end, entry, checksum, timestamp, path
        column_line = f.readline().decode('utf-8').strip()
        field_name, field_data = column_line.split(": ")
        #assert field_name == "Columns"

        # seperate column names
        #   Windows:   id, base, end, entry, checksum, timestamp, path
        #   Mac/Linux: id, base, end, entry, path
        columns = field_data.split(", ")

    def _parse_module_table_modules(self, f):
        """
        Parse drcov log modules in the module table from filestream.
        """
        modules = collections.defaultdict(list)

        # loop through each *expected* line in the module table and parse it
        for i in range(self.module_table_count):
            module = DrcovModule(f.readline().decode('utf-8').strip(), self.module_table_version)
            modules[module.filename].append(module)

        self.modules = modules

    def _parse_bb_table(self, f):
        """
        Parse dcov log basic block table from filestream.
        """
        self._parse_bb_table_header(f)
        self._parse_bb_table_entries(f)

    def _parse_bb_table_header(self, f):
        """
        Parse drcov log basic block table header from filestream.
        """

        # parse basic block table 'header'
        #   eg: BB Table: 2792 bbs
        header_line = f.readline().decode('utf-8').strip()
        field_name, field_data = header_line.split(": ")
        #assert field_name == "BB Table"

        # parse basic block count out of 'X bbs'
        count_data, data_name = field_data.split(" ")
        #assert data_name == "bbs"
        self.bb_table_count = int(count_data)

        # peek at the next few bytes to determine if this is a binary bb table.
        # An ascii bb table will have the line: 'module id, start, size:'
        token = b"module id"
        saved_position = f.tell()

        # is this an ascii table?
        if f.read(len(token)) == token:
            self.bb_table_is_binary = False

        # nope! binary table
        else:
            self.bb_table_is_binary = True

        # seek back to the start of the table
        f.seek(saved_position)

    def _parse_bb_table_entries(self, f):
        """
        Parse drcov log basic block table entries from filestream.
        """

        # allocate the ctypes structure array of basic blocks
        self.bbs = (DrcovBasicBlock * self.bb_table_count)()

        # read binary basic block entries directly into the newly allocated array
        if self.bb_table_is_binary:
            f.readinto(self.bbs)

        # parse the plaintext basic block entries one by one
        else:
            self._parse_bb_table_text_entries(f)

    def _parse_bb_table_text_entries(self, f):
        """
        Parse drcov log basic block table text entries from filestream.
        """
        table_header = f.readline().decode('utf-8').strip()

        if table_header != "module id, start, size:":
            raise ValueError("Invalid BB header: %r" % table_header)

        pattern = re.compile(r"^module\[\s*(?P<mod>[0-9]+)\]\:\s*(?P<start>0x[0-9a-fA-F]+)\,\s*(?P<size>[0-9]+)$")
        for i, bb in enumerate(self.bbs):
            text_entry = f.readline().decode('utf-8').strip()
            if not text_entry:
                continue

            match = pattern.match(text_entry)
            if not match:
                raise ValueError("Invalid BB entry: %r" % text_entry)

            bb.start = int(match.group("start"), 16)
            bb.size = int(match.group("size"), 10)
            bb.mod_id = int(match.group("mod"), 10)

#------------------------------------------------------------------------------
# drcov module parser
#------------------------------------------------------------------------------

class DrcovModule(object):
    """
    Parser & wrapper for module details as found in a drcov coverage log.

    A 'module' in this context is a .EXE, .DLL, ELF, MachO, etc.
    """
    def __init__(self, module_data, version):
        self.id    = 0
        self.base  = 0
        self.end   = 0
        self.size  = 0
        self.entry = 0
        self.checksum  = 0
        self.timestamp = 0
        self.path      = ""
        self.filename  = ""
        self.containing_id = 0

        # parse the module
        self._parse_module(module_data, version)

    @property
    def start(self):
        """
        Compatability alias for the module base.

        DrCov table version 2 --> 3 changed this paramter name base --> start.
        """
        return self.base

    def _parse_module(self, module_line, version):
        """
        Parse a module table entry.
        """
        data = module_line.split(", ")

        # NOTE/COMPAT
        if version == 1:
            self._parse_module_v1(data)
        elif version == 2:
            self._parse_module_v2(data)
        elif version == 3:
            self._parse_module_v3(data)
        elif version == 4:
            self._parse_module_v4(data)
        elif version == 5:
            self._parse_module_v5(data)
        else:
            raise ValueError("Unknown module format (v%u)" % version)

    def _parse_module_v1(self, data):
        """
        Parse a module table v1 entry.
        """
        self.id       = int(data[0])
        self.size     = int(data[1])
        self.path     = str(data[2])
        self.filename = os.path.basename(self.path.replace('\\', os.sep))

    def _parse_module_v2(self, data):
        """
        Parse a module table v2 entry.
        """
        self.id        = int(data[0])
        self.base      = int(data[1], 16)
        self.end       = int(data[2], 16)
        self.entry     = int(data[3], 16)
        if len(data) == 7: # Windows Only
            self.checksum  = int(data[4], 16)
            self.timestamp = int(data[5], 16)
        self.path      = str(data[-1])
        self.size      = self.end-self.base
        self.filename  = os.path.basename(self.path.replace('\\', os.sep))

    def _parse_module_v3(self, data):
        """
        Parse a module table v3 entry.
        """
        self.id            = int(data[0])
        self.containing_id = int(data[1])
        self.base          = int(data[2], 16)
        self.end           = int(data[3], 16)
        self.entry         = int(data[4], 16)
        if len(data) > 7: # Windows Only
            self.checksum  = int(data[5], 16)
            self.timestamp = int(data[6], 16)
        self.path          = str(data[-1])
        self.size          = self.end-self.base
        self.filename      = os.path.basename(self.path.replace('\\', os.sep))

    def _parse_module_v4(self, data):
        """
        Parse a module table v4 entry.
        """
        self.id            = int(data[0])
        self.containing_id = int(data[1])
        self.base          = int(data[2], 16)
        self.end           = int(data[3], 16)
        self.entry         = int(data[4], 16)
        self.offset        = int(data[5], 16)
        if len(data) > 8: # Windows Only
            self.checksum  = int(data[6], 16)
            self.timestamp = int(data[7], 16)
        self.path          = str(data[-1])
        self.size          = self.end-self.base
        self.filename      = os.path.basename(self.path.replace('\\', os.sep))

    def _parse_module_v5(self, data):
        """
        Parse a module table v5 entry.
        """
        self.id            = int(data[0])
        self.containing_id = int(data[1])
        self.base          = int(data[2], 16)
        self.end           = int(data[3], 16)
        self.entry         = int(data[4], 16)
        self.offset        = int(data[5], 16)
        self.preferred_base= int(data[6], 16)
        if len(data) > 8: # Windows Only
            self.checksum  = int(data[7], 16)
            self.timestamp = int(data[8], 16)
        self.path          = str(data[-1])
        self.size          = self.end-self.base
        self.filename      = os.path.basename(self.path.replace('\\', os.sep))


#------------------------------------------------------------------------------
# drcov basic block parser
#------------------------------------------------------------------------------

class DrcovBasicBlock(Structure):
    """
    Parser & wrapper for basic block details as found in a drcov coverage log.

    NOTE:

      Based off the C structure as used by drcov -

        /* Data structure for the coverage info itself */
        typedef struct _bb_entry_t {
            uint   start;      /* offset of bb start from the image base */
            ushort size;
            ushort mod_id;
        } bb_entry_t;

    """
    _pack_   = 1
    _fields_ = [
        ('start',  c_uint32),
        ('size',   c_uint16),
        ('mod_id', c_uint16)
    ]

```

`idaclu/plugins/group_4/plugin_1.py`:

```py
import bisect
import collections
import json
import os
#
import idautils
import idaapi
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import drcov


SCRIPT_NAME = i18n('Covered Functions')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = [('textedit', 'file_path', ['input the file path'])]


def find_function(block_start, function_ranges):
    index = bisect.bisect_right(function_ranges, (block_start, block_start))

    if index > 0 and block_start <= function_ranges[index - 1][1]:
        return function_ranges[index - 1]
    return None


def get_data(func_gen=None, env_desc=None, plug_params=None):
    REPORT = {
        'data': {},
        'stat': {},
        'tree': [
            {'unique_id': 1, 'parent_id': 0, 'Function': '', 'VA': ' ', 'Size': ' '}
        ]
    }
    raw_data = {}
    unseen_functions = []
    seen_functions = []

    function_ranges = []
    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        func_desc = idaapi.get_func(func_addr)
        func_size = ida_shims.calc_func_size(func_desc)
        function_ranges.append((func_addr, func_addr + func_size))
        unseen_functions.append(func_addr)

    x = None
    file_path = plug_params['file_path'][0]
    try:
        x = drcov.DrcovData(file_path)
    except IOError:
        ida_shims.msg("ERROR: Cannot open coverage file: {}".format(file_path))
        return REPORT['data']

    coverage_blocks = x.get_offset_blocks(env_desc.ida_module)
    imagebase = idaapi.get_imagebase()

    for bb in coverage_blocks:
        block_start = imagebase + bb[0]
        func_start = find_function(block_start, function_ranges)
        if func_start:
            if not func_start[0] in seen_functions:
                seen_functions.append(func_start[0])

    group_name = 'covered'
    if not group_name in raw_data:
        raw_data[group_name] = []
        REPORT['stat'][group_name] = 0

    for sf in seen_functions:
        raw_data[group_name].append(sf)
        REPORT['stat'][group_name] += 1

    unseen = list(set(unseen_functions) - set(seen_functions))
    group_name = 'uncovered'
    if not group_name in raw_data:
        raw_data[group_name] = []
        REPORT['stat'][group_name] = 0

    for uf in unseen:
        raw_data[group_name].append(uf)
        REPORT['stat'][group_name] += 1


    REPORT['data'] = collections.OrderedDict(sorted(raw_data.items()))
    return REPORT['data']


def debug():
    env_desc = lambda: None
    env_desc.ida_module = os.path.basename(ida_shims.get_input_file_path())

    log_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'drcov.proc.log')
    plug_params = { 'file_path': log_path }

    data_obj = get_data(func_gen=idautils.Functions, env_desc=env_desc, plug_params=plug_params)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_5/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Function Similarity')

```

`idaclu/plugins/group_5/plugin_1.py`:

```py
import collections
import json
#
import ssdeep
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('SSDEEP Similarity')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_items(func_ea):
    for item in idautils.FuncItems(func_ea):
        if ida_shims.is_code(ida_shims.get_full_flags(item)):
            yield item

def get_dasm_list(func_ea):
    func_instructs = []
    for item in get_items(func_ea):
        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)
        dasm_clean = dasm.split(';')[0]  # remove comments
        func_instructs.append(dasm_clean)
    return func_instructs

def get_mnem_list(func_ea):
    func_mnemonics = []
    for item in get_items(func_ea):
        mnem = ida_shims.print_insn_mnem(item)
        func_mnemonics.append(mnem)
    return func_mnemonics

def get_psdo_list(func_ea):
    func_pseudocode = []
    decomp_str = ""
    try:
        decomp_str = idaapi.decompile(func_ea)
    except idaapi.DecompilationFailure:
        return []
    for line in str(decomp_str).split('\n'):
        if '//' in line:
            code = line.split('//')[0]
            if code != '':
                func_pseudocode.append(code.lstrip())
        else:
            if line != '':
                func_pseudocode.append(line.lstrip())
    return func_pseudocode

def get_psdo_body(func_ea):
    psdo_list = get_psdo_list(func_ea)
    return psdo_list[2:-1]

def get_func_bytes(func_addr):
    func_bytes = b''
    for beg, end in idautils.Chunks(func_addr):
        fb = ida_shims.get_bytes(beg, end-beg)
        func_bytes += fb
    return func_bytes

def get_number_ratio(num1, num2):
    if num1 == num2:
        return 1
    if num1 > num2:
        return num2 / num1
    if num1 < num2:
        return num1 / num2

def get_func_descriptors(func_gen):
    func_dscs = []
    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        func_desc = idaapi.get_func(func_addr)

        func_inst = get_dasm_list(func_addr)
        func_mnem = get_mnem_list(func_addr)
        func_psdo = get_psdo_list(func_addr)
        func_size = ida_shims.calc_func_size(func_desc)

        func_byts_line = get_func_bytes(func_addr)    # get_bytes(func_addr, func_size)
        func_mnem_line = "@".join(func_mnem).encode('utf-8', errors='replace')
        func_inst_line = "@".join(func_inst).encode('utf-8', errors='replace')
        func_psdo_line = "@".join(func_psdo).encode('utf-8', errors='replace')

        func_byts_size = len(func_byts_line)
        func_mnem_size = len(func_mnem_line)
        func_inst_size = len(func_inst_line)
        func_psdo_size = len(func_psdo_line)

        ssdeep_byts = ssdeep.hash(func_byts_line)
        ssdeep_mnem = ssdeep.hash(func_mnem_line)
        ssdeep_inst = ssdeep.hash(func_inst_line)
        ssdeep_psdo = ssdeep.hash(func_psdo_line)

        func_dscs.append({
            # general
            'func_addr': func_addr,
            'func_name': func_name,
            # ssdeep
            'byts_hash': ssdeep_byts,
            'mnem_hash': ssdeep_mnem,
            'inst_hash': ssdeep_inst,
            'psdo_hash': ssdeep_psdo,
            # sizes
            'byts_size': func_byts_size,
            'mnem_size': func_mnem_size,
            'inst_size': func_inst_size,
            'psdo_size': func_psdo_size
        })

    return func_dscs

def get_func_clusters(func_descriptors):
    clusters = collections.defaultdict(list)
    data_type = [('byts', 48), ('mnem', 80), ('inst', 80), ('psdo', 80)]
    for idx, sup in enumerate(func_descriptors):
        for jdx, sub in enumerate(func_descriptors):
            if sup['func_addr'] != sub['func_addr']:

                byts_score = None

                for (dt, th) in data_type:
                    size_key = '{}_size'.format(dt)
                    hash_key = '{}_hash'.format(dt)
                    if get_number_ratio(sup[size_key], sub[size_key]) > 0.333:
                        score = ssdeep.compare(sup[hash_key], sub[hash_key])
                        # pairs only
                        if score and score > th:
                            clusters[dt].append({
                                'score': score, 
                                'func_1': sup['func_addr'], 
                                'func_2': sub['func_addr']}
                            )

                            cluster_id = -1  # there is no recipient cluster for a given pair
                            for i, clu in enumerate(clusters['aggregated']):  # enumerating already existing clusters
                                if sup['func_addr'] in clu or sub['func_addr'] in clu:
                                    cluster_id = i

                            if cluster_id != -1:  # was found, but need more details
                                if sup['func_addr'] not in clusters['aggregated'][cluster_id]:
                                    clusters['aggregated'][cluster_id].append(sup['func_addr'])
                                elif sub['func_addr'] not in clusters['aggregated'][cluster_id]:
                                    clusters['aggregated'][cluster_id].append(sub['func_addr'])
                                else:
                                    pass
                            else:  # nothing similar was found
                                clusters['aggregated'].append([sup['func_addr'], sub['func_addr']])
    return clusters

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    func_descriptors = get_func_descriptors(func_gen)
    func_clusters = get_func_clusters(func_descriptors)


    for idx, clu in enumerate(func_clusters['aggregated']):
        for addr in clu:
            key_name = "cluster: {}".format(idx)
            report['data'][key_name].append(addr)
            report['stat'][key_name] += 1


    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_5/plugin_2.py`:

```py
import collections
import json
#
import tlsh
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('TLSH Similarity')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_items(func_ea):
    for item in idautils.FuncItems(func_ea):
        if ida_shims.is_code(ida_shims.get_full_flags(item)):
            yield item

def get_dasm_list(func_ea):
    func_instructs = []
    for item in get_items(func_ea):
        dasm = ida_shims.generate_disasm_line(item, idaapi.GENDSM_FORCE_CODE)
        dasm_clean = dasm.split(';')[0]  # remove comments
        func_instructs.append(dasm_clean)
    return func_instructs

def get_mnem_list(func_ea):
    func_mnemonics = []
    for item in get_items(func_ea):
        mnem = ida_shims.print_insn_mnem(item)
        func_mnemonics.append(mnem)
    return func_mnemonics

def get_psdo_list(func_ea):
    func_pseudocode = []
    decomp_str = ""
    try:
        decomp_str = idaapi.decompile(func_ea)
    except idaapi.DecompilationFailure:
        return []
    for line in str(decomp_str).split('\n'):
        if '//' in line:
            code = line.split('//')[0]
            if code != '':
                func_pseudocode.append(code.lstrip())
        else:
            if line != '':
                func_pseudocode.append(line.lstrip())
    return func_pseudocode

def get_psdo_body(func_ea):
    psdo_list = get_psdo_list(func_ea)
    return psdo_list[2:-1]

def get_func_bytes(func_addr):
    func_bytes = b''
    for beg, end in idautils.Chunks(func_addr):
        fb = ida_shims.get_bytes(beg, end-beg)
        func_bytes += fb
    return func_bytes

def get_number_ratio(num1, num2):
    if num1 == num2:
        return 1
    if num1 > num2:
        return num2 / num1
    if num1 < num2:
        return num1 / num2

def get_func_descriptors(func_gen):
    func_dscs = []
    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        func_desc = idaapi.get_func(func_addr)

        func_inst = get_dasm_list(func_addr)
        func_mnem = get_mnem_list(func_addr)
        func_psdo = get_psdo_list(func_addr)
        func_size = ida_shims.calc_func_size(func_desc)

        func_byts_line = get_func_bytes(func_addr)    # get_bytes(func_addr, func_size)
        func_mnem_line = "@".join(func_mnem).encode('utf-8', errors='replace')
        func_inst_line = "@".join(func_inst).encode('utf-8', errors='replace')
        func_psdo_line = "@".join(func_psdo).encode('utf-8', errors='replace')

        func_byts_size = len(func_byts_line)
        func_mnem_size = len(func_mnem_line)
        func_inst_size = len(func_inst_line)
        func_psdo_size = len(func_psdo_line)

        tlsh_byts = tlsh.hash(func_byts_line)
        tlsh_mnem = tlsh.hash(func_mnem_line)
        tlsh_inst = tlsh.hash(func_inst_line)
        tlsh_psdo = tlsh.hash(func_psdo_line)

        func_dscs.append({
            # general
            'func_addr': func_addr,
            'func_name': func_name,
            # tlsh
            'byts_hash': tlsh_byts,
            'mnem_hash': tlsh_mnem,
            'inst_hash': tlsh_inst,
            'psdo_hash': tlsh_psdo,
            # sizes
            'byts_size': func_byts_size,
            'mnem_size': func_mnem_size,
            'inst_size': func_inst_size,
            'psdo_size': func_psdo_size
        })

    return func_dscs

def get_func_clusters(func_descriptors):
    clusters = collections.defaultdict(list)
    data_type = [('byts', 100), ('mnem', 60), ('inst', 60), ('psdo', 60)]
    for idx, sup in enumerate(func_descriptors):
        for jdx, sub in enumerate(func_descriptors):
            if sup['func_addr'] != sub['func_addr']:

                byts_score = None

                for (dt, th) in data_type:
                    size_key = '{}_size'.format(dt)
                    hash_key = '{}_hash'.format(dt)
                    if sup[hash_key] != "TNULL" and sub[hash_key] != "TNULL": 
                        score = tlsh.diff(sup[hash_key], sub[hash_key])
                        # pairs only
                        if score and score <= th:
                            clusters[dt].append({
                                'score': score, 
                                'func_1': sup['func_addr'], 
                                'func_2': sub['func_addr']}
                            )

                            cluster_id = -1  # there is no recipient cluster for a given pair
                            for i, clu in enumerate(clusters['aggregated']):  # enumerating already existing clusters
                                if sup['func_addr'] in clu or sub['func_addr'] in clu:
                                    cluster_id = i

                            if cluster_id != -1:  # was found, but need more details
                                if sup['func_addr'] not in clusters['aggregated'][cluster_id]:
                                    clusters['aggregated'][cluster_id].append(sup['func_addr'])
                                elif sub['func_addr'] not in clusters['aggregated'][cluster_id]:
                                    clusters['aggregated'][cluster_id].append(sub['func_addr'])
                                else:
                                    pass
                            else:  # nothing similar was found
                                clusters['aggregated'].append([sup['func_addr'], sub['func_addr']])
    return clusters

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    func_descriptors = get_func_descriptors(func_gen)
    func_clusters = get_func_clusters(func_descriptors)


    for idx, clu in enumerate(func_clusters['aggregated']):
        for addr in clu:
            key_name = "cluster: {}".format(idx)
            report['data'][key_name].append(addr)
            report['stat'][key_name] += 1


    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_6/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Virtual Functions')

```

`idaclu/plugins/group_6/plugin_1.py`:

```py
import collections
import json
import re
#
import idautils
import idaapi
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Explicit Calls')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = [(
    'checkbox', 'func_calls',
    [
        'Type Casting',
        'Helper Functions',
        'Standard Functions',
        'Custom Functions',
    ]
)]


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_psdo_list(func_ea):
    func_pseudocode = []
    decomp_str = ""
    try:
       decomp_str = idaapi.decompile(func_ea)
    except idaapi.DecompilationFailure:
       return []
    for line in str(decomp_str).split('\n'):
        if '//' in line:
            code = line.split('//')[0]
            if code != '':
                func_pseudocode.append(code.lstrip())
        else:
            if line != '':
                func_pseudocode.append(line.lstrip())
    return func_pseudocode
    
def get_psdo_body(func_ea):
    psdo_list = get_psdo_list(func_ea)
    return psdo_list[2:-1]
 
def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }
    
    is_typ_add = plug_params['func_calls'][0][1]
    is_hlp_add = plug_params['func_calls'][1][1]
    is_std_add = plug_params['func_calls'][2][1]
    is_usr_add = plug_params['func_calls'][3][1]

    for func_addr in func_gen():
        caller_name = idaapi.get_func_name(func_addr)
        caller_psdo = get_psdo_body(func_addr)

        for psdo_line in caller_psdo:
            is_func_matched = re.match('(?:(?:.*\s)?)([0-9a-zA-Z\_\:]+)\(.*\)(?:(?:.*)?)', psdo_line)  # (?:(?:.*\s)?)([0-9a-zA-Z\_\:]+)\(.*\)
            if is_func_matched:
                
                calee_name = is_func_matched.group(1)
                fn_type = ida_utils.get_fn_type(calee_name)
                if ((is_typ_add and fn_type == 'typ')
                    or (is_hlp_add and fn_type == 'hlp')
                    or (is_std_add and fn_type == 'std')
                    or (is_usr_add and fn_type == 'usr')
                   ):
                    report['data'][calee_name].append((func_addr, psdo_line))
                    report['stat'][calee_name] += 1

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_6/plugin_2.py`:

```py
import collections
import json
import re
#
import idautils
import idaapi
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Implicit Calls')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_psdo_list(func_ea):
    func_pseudocode = []
    decomp_str = ""
    try:
        decomp_str = idaapi.decompile(func_ea)
    except idaapi.DecompilationFailure:
        return []
    for line in str(decomp_str).split('\n'):
        if '//' in line:
            code = line.split('//')[0]
            if code != '':
                func_pseudocode.append(code.lstrip())
        else:
            if line != '':
                func_pseudocode.append(line.lstrip())
    return func_pseudocode

def get_psdo_body(func_ea):
    psdo_list = get_psdo_list(func_ea)
    return psdo_list[2:-1]

def remove_casts(call_str):
    call_res = call_str
    for m in re.finditer('\(\*(\([a-zA-Z0-9_\s\*\,\.\(\)]+\)\))\(', call_res):
        call_res = call_res.replace(m.group(1), '')
    call_res = re.sub(r"\(_.*\*\)", "", call_res)
    return call_res

def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        caller_name = idaapi.get_func_name(func_addr)
        caller_psdo = get_psdo_body(func_addr)

        psdo_size = len(caller_psdo)

        for i in range(psdo_size):
            psdo_line = caller_psdo[i]
            is_func_matched = re.match('(\(\*.*[A-Za-z0-9_]+\s\+\s[A-Za-z0-9_\s\*\)\+]+\)\))\(', psdo_line)
            if is_func_matched:
                call_raw = is_func_matched.group(1)
                call_fmt = remove_casts(call_raw)

                func_comm = psdo_line
                while ';' not in func_comm and i + 1 < psdo_size:
                    i += 1
                    if func_comm[-1] == ',':
                        func_comm += ' '
                    func_comm += caller_psdo[i]

                report['data'][call_fmt].append((func_addr, func_comm))
                report['stat'][call_fmt] += 1

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_6/plugin_3.py`:

```py
import collections
import json
#
import idaapi
import idautils
import idc
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Virtual Funtion Tables (MSVC)')
SCRIPT_TYPE = 'custom'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))


def get_data(progress_callback=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    if ida_utils.is_GCC_auto():
        pass
    else:
        PTR_SIZE = ida_utils.get_ptr_size()
        vf_tables = {}
        over_methods = {}
        vft_count = 0
        for seg_ea in idautils.Segments():
            if ida_shims.get_segm_attr(seg_ea, idc.SEGATTR_TYPE) != idc.SEG_CODE:
                seg = idaapi.getseg(seg_ea)
                seg_beg = ida_shims.start_ea(seg)
                seg_end = ida_shims.end_ea(seg)
                seg_size = seg_end - seg_beg
                for offset in range(0, seg_size - PTR_SIZE, PTR_SIZE):
                    scan_ea = seg_beg + offset
                    if ida_utils.is_vtable(scan_ea):
                        vft_count += 1
                        vf_name = 'vtable_{}_{}'.format(vft_count, hex(scan_ea))
                        vf_tables[vf_name] = {'addr': scan_ea, 'funcs': []}

        if progress_callback:
            progress_callback(30, 100)

        for i, vf_name in enumerate(vf_tables):
            vf_addr = vf_tables[vf_name]['addr']
            func_ea = ida_utils.get_ptr(vf_addr)
            func_desc = idaapi.get_func(func_ea)
            if func_desc:
                vf_tables[vf_name]['funcs'].append(func_ea)
                if not func_ea in over_methods:
                    over_methods[func_ea] = set()
                over_methods[func_ea].add(vf_name)
            vf_addr += PTR_SIZE

            while not ida_utils.has_xref(vf_addr):
                func_ea = ida_utils.get_ptr(vf_addr)
                func_desc = idaapi.get_func(func_ea)
                if func_desc:
                    vf_tables[vf_name]['funcs'].append(func_ea)
                    if not func_ea in over_methods:
                        over_methods[func_ea] = set()
                    over_methods[func_ea].add(vf_name)
                vf_addr += PTR_SIZE

            if progress_callback:
                progress_callback(30 + int((i / len(vf_tables) * 40)), 100)

        for i, vf_name in enumerate(vf_tables):
            for func_ea in vf_tables[vf_name]['funcs']:
                comment = ""
                func_refs = list(over_methods[func_ea])
                if len(func_refs) > 1:
                    comment += ", ".join(func_refs)
                report['data'][vf_name].append((func_ea, comment))
                report['stat'][vf_name] += 1

            if progress_callback:
                progress_callback(70 + int((i / len(vf_tables) * 30)), 100)

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data()
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_6/plugin_4.py`:

```py
import collections
import json
import re
#
import idautils
import idaapi
import idc
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Function Argument Consistency')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = [('checkbox', 'call_types', ['Inconsistent Prototypes', 'Consistent Prototypes'])]


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)
    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))


def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }
    
    is_x_add = plug_params['call_types'][0][1]
    is_v_add = plug_params['call_types'][1][1]

    merged_calls = collections.defaultdict(dict)
    for func_addr in func_gen():
        func_calls = ida_utils.extract_calls_from_decompiled(func_addr)
        for callee_addr, call_descs in func_calls.items():  # call_descs = [(pos, args)]
            if idaapi.get_func(callee_addr):
                merged_calls[callee_addr].update(call_descs)
        
    for callee_addr, call_descs in merged_calls.items():  # 18446744073709551615
        is_consistent = True
        temp = {}
        temp[callee_addr] = []

        def_args = ida_utils.get_func_params(callee_addr)
        for i, (call_pos, call_args) in enumerate(call_descs.items()):
            call_func = idaapi.get_func(call_pos)  # 18446744073709551615
            args_line = ', '.join("{} {}".format(arg['type'], arg['name']) for arg in call_args)
            temp[callee_addr].append((call_func.start_ea, args_line))
            
            if is_consistent == True:
                if len(def_args) == len(call_args):
                    for i in range(len(def_args)):
                        if def_args[i]['type'] != call_args[i]['type']:
                            is_consistent = False
                            break
                else:
                    is_consistent = False
         
        if ((is_x_add == True and is_v_add == True) or 
            (is_v_add == True and is_consistent == True) or 
            (is_x_add == True and is_consistent == False)):
            callee_name = idc.get_func_name(callee_addr)
            report['data'][callee_name].extend(temp[callee_addr])
            report['stat'][callee_name] += len(temp[callee_addr])

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_6/plugin_5.py`:

```py
import collections
import json
import re
#
import idautils
import idaapi
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Function Argument Types')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = [(
    'checkbox', 'data_types',
    [
        'C Fundamental Types',
        'Windows Data Types',
        'DirectX Data Types',
        'Custom Data Types',
        'Missing Data Types'
    ]
)]


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    is_std_add = plug_params['data_types'][0][1]
    is_win_add = plug_params['data_types'][1][1]
    is_ddx_add = plug_params['data_types'][2][1]
    is_usr_add = plug_params['data_types'][3][1]
    is_unk_add = plug_params['data_types'][4][1]

    for func_addr in func_gen():
        p_list = []
        proto = ida_utils.get_func_params(func_addr)
        for param in proto:
            p_type = param['type']
            p_name = param['name']

            if p_type in p_list:
                continue

            dt_type = ida_utils.get_dt_type(p_type)

            if ((is_std_add and dt_type == 'std')
                or (is_win_add and dt_type == 'win')
                or (is_ddx_add and dt_type == 'ddx')
                or (is_unk_add and dt_type == 'unk')
                or (is_usr_add and dt_type == 'usr')
               ):
                report['data'][p_type].append((func_addr, p_name))
                report['stat'][p_type] += 1
                p_list.append(p_type)

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_6/plugin_6.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Lost Mem in Restored Pseudocode')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_psdo_str(func_ea):
    try:
       return str(idaapi.decompile(func_ea))  # restored microcode/pseudocode from idb
    except idaapi.DecompilationFailure:
       return ""
    
def get_lost_mem(func_ea):
    psdo_str = get_psdo_str(func_ea)
    pattern = r"MEMORY\[0x[0-9A-Fa-f]+\]|[0-9A-Za-z]+\->\?"  
    # Find cases like: `MEMORY[0x0040105C]`, `entity3->?`
    return re.findall(pattern, psdo_str)

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        for lost_mem in get_lost_mem(func_addr):
            if not func_addr in report['data'][lost_mem]:
                report['data'][lost_mem].append(func_addr)
                report['stat'][lost_mem] += 1

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_7/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Filter Analysis')

```

`idaclu/plugins/group_7/plugin_1.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
import ida_dirtree
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Distinct Folders')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_dirs(root_dir):
    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    ite = ida_dirtree.dirtree_iterator_t()

    s_folders = [root_dir]
    u_folders = [root_dir]

    while len(s_folders):
        curr_path = s_folders.pop()
        func_dir.chdir(curr_path)
        status = func_dir.findfirst(ite, "*")

        while status:
            entry_name = func_dir.get_entry_name(func_dir.resolve_cursor(ite.cursor))
            if func_dir.isdir(func_dir.get_abspath(ite.cursor)):
                current_dir_new = '{}/{}'.format('' if curr_path == '/' else curr_path, entry_name)
                s_folders.append(current_dir_new)
                if not current_dir_new in u_folders:
                    u_folders.append(current_dir_new)
            status = func_dir.findnext(ite)

    return u_folders

def get_dir_funcs(folders):
    func_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    ite = ida_dirtree.dirtree_iterator_t()
    idx = 0

    funcs = {}
    while idx < len(folders):
        curr_path = folders[idx]
        func_dir.chdir(curr_path)
        status = func_dir.findfirst(ite, "*")

        while status:
            entry_name = func_dir.get_entry_name(func_dir.resolve_cursor(ite.cursor))
            func_addr = ida_shims.get_name_ea(0, entry_name)
            if func_dir.isfile(func_dir.get_abspath(ite.cursor)):
                if curr_path != '/':
                    funcs[func_addr] = curr_path
            status = func_dir.findnext(ite)
        idx += 1

    return funcs


def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    dirs = get_dirs('/')
    dir_funcs = get_dir_funcs(dirs)

    for func_addr in func_gen():
        if func_addr in dir_funcs:
            dir_name = dir_funcs[func_addr]
            report['data'][dir_name].append(func_addr)
            report['stat'][dir_name] += 1

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_7/plugin_2.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Distinct Prefixes (IdaClu)')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    sep_char = '%'
    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        prefs = set()

        if sep_char in func_name:
            func_prefs = ida_utils.get_func_prefs(func_name, False)
            prefs.update(func_prefs)
        for pfx in list(prefs):
            report['data'][pfx].append(func_addr)
            report['stat'][pfx] += 1

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_7/plugin_3.py`:

```py
import collections
import json
import re
import sys
#
import idc
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Distinct Colors')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


class RgbColor:
    def __init__(self, color_ref, color_nam='unknown'):
        ver_py = sys.version_info.major
        self.palette_val = {
            13107199: 'blue',    # '#C7FFFF'
            16777151: 'yellow',  # '#FFFFBF'
            12582847: 'green',   # '#BFFFBF'
            16760815: 'pink',    # '#FFBFEF'
            16777215: 'none'     # '#FFFFFF'
        }
        self.palette_nam = {v: k for k, v in self.palette_val.items()}

        if (ver_py == 2 and
            any(isinstance(color_ref, t) for t in (int, long)) and
            color_ref <= 0xFFFFFFFF):
            self.r, self.g, self.b = self.get_from_tuple(int(color_ref))
        elif (ver_py == 3 and
            isinstance(color_ref, int) and
            color_ref <= 0xFFFFFFFF):
            self.r, self.g, self.b = self.get_from_tuple(color_ref)
        elif isinstance(color_ref, tuple) and len(color_ref) == 3:
            self.r, self.g, self.b = color_ref
        elif isinstance(color_ref, str) or isinstance(color_ref, unicode):
            self.r, self.g, self.b = self.get_from_str(color_ref)
        else:
            raise ValueError("Invalid init value: {}/{}".format(type(color_ref), color_ref))
        self.name = color_nam

    def invert_color(self):
        self.r, self.g, self.b = self.b, self.g, self.r

    def is_color_defined(self):
        return self.get_to_int() in self.palette_val

    def get_from_tuple(self, rgb_int):
        r = (rgb_int >> 16) & 255
        g = (rgb_int >> 8) & 255
        b = rgb_int & 255
        return (r, g, b)

    def get_to_tuple(self):
        return (self.r, self.g, self.b)

    def get_from_str(self, color_ref):
        rgb_pat = r'rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)'
        match = re.search(rgb_pat, color_ref)
        if match:
            r, g, b =  map(int, match.groups())
            if not all(0 <= c <= 255 for c in (r, g, b)):
                raise ValueError("Invalid color component values")
            return (r, g, b)
        elif color_ref in self.palette_nam:
            return self.get_from_tuple(self.palette_nam[color_ref])
        else:
            raise ValueError("Invalid 'rgb(r,g,b)' string format")

    def get_to_str(self):
        return "rgb({},{},{})".format(self.r, self.g, self.b)

    def get_to_int(self, reverse=False):
        return (
            (self.b << 16 | self.g << 8 | self.r) if reverse
            else (self.r << 16 | self.g << 8 | self.b)
        )

    def get_to_hash(self):
        hex_string = hex(self.get_to_int())[2:]
        hex_color = hex_string.rjust(6, '0')
        hex_color_code = '#' + hex_color.upper()
        return hex_color_code

    def get_to_name(self):
        col_int = self.get_to_int()
        return self.palette_val[col_int] if col_int in self.palette_val else self.get_to_hash()

    def __eq__(self, b):
        if isinstance(b, RgbColor):
            return self.r == b.r and self.g == b.g and self.b == b.b
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return self.get_to_str()


def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_colr = ida_shims.get_color(func_addr, idc.CIC_FUNC)

        color = RgbColor(func_colr)
        color.invert_color()
        color_name = color.get_to_name()
        report['data'][color_name].append(func_addr)
        report['stat'][color_name] += 1

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_7/plugin_4.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu import ida_utils
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Distinct Prefixes')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(sorted(input_dict.items(), key=get_len, reverse=True))

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_name = ida_shims.get_func_name(func_addr)
        prefs = set()

        func_prefs = ida_utils.get_func_prefs(func_name, False)
        prefs.update(func_prefs)
        for pfx in list(prefs):
            report['data'][pfx].append(func_addr)
            report['stat'][pfx] += 1

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])
    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/__init__.py`:

```py
from idaclu.qt_utils import i18n

''' The code in this plugin group is adapted from Tim Blazytko's Binary Ninja plugin https://github.com/mrphrazer/obfuscation_detection'''
PLUGIN_GROUP_NAME = i18n('Obfuscation Detection')

```

`idaclu/plugins/group_8/helpers.py`:

```py
import collections
import math
#
import idc
import idaapi
import idautils
#
from idaclu import ida_shims
#
from ngrams import determine_ngram_database

ARITHMETIC_OPERATION = set([
    idaapi.cot_add,   # x + y
    idaapi.cot_lnot,  # !x
    idaapi.cot_sub,   # x - y
    idaapi.cot_mul,   # x * y
    idaapi.cot_fmul,  # x * y fp
    idaapi.cot_sdiv,  # x / y signed
    idaapi.cot_udiv,  # x / y unsigned
    idaapi.cot_fdiv,  # x / y fp
    idaapi.cot_smod,  # x % y signed
    idaapi.cot_umod   # x % y unsigned
])

ARITHMETIC_OPERATION_ASG = set([
    idaapi.cot_asgadd,   # x += y
    idaapi.cot_asgsub,   # x -= y
    idaapi.cot_asgmul,   # x *= y
    idaapi.cot_asgsdiv,  # x /= y signed
    idaapi.cot_asgudiv,  # x /= y unsigned
    idaapi.cot_asgsmod,  # x %= y signed
    idaapi.cot_asgumod   # x %= y unsigned
])

BOOLEAN_OPERATION = set([
    idaapi.cot_bnot,  # ~x
    idaapi.cot_band,  # x & y
    idaapi.cot_bor,   # x | y
    idaapi.cot_xor,   # x ^ y
    idaapi.cot_sshr,  # x >> y signed
    idaapi.cot_ushr,  # x >> y unsigned
    idaapi.cot_shl,   # x << y
])

BOOLEAN_OPERATION_ASG = set([
    idaapi.cot_asgbor,   # x |= y
    idaapi.cot_asgxor,   # x ^= y
    idaapi.cot_asgband,  # x &= y
    idaapi.cot_asgsshr,  # x >>= y signed
    idaapi.cot_asgushr,  # x >>= y unsigned
    idaapi.cot_asgshl,   # x <<= y
])


def calc_flattening_score(function):
    score = 0.0
    # 0: get the basic blocks of the function
    basic_blocks = idaapi.FlowChart(idaapi.get_func(function))
    # 1: walk over all basic blocks
    for block in basic_blocks:
        # 2: get all blocks that are dominated by the current block
        dominated = get_dominated_by(block)
        # 3: check for a back edge
        dominators = [d.start_ea for d in block.preds()]
        if not any((dominator in dominated for dominator in dominators)):
            continue
        # 4: calculate relation of dominated blocks to the blocks in the graph
        score = max(score, len(dominated) / basic_blocks.size)
    return score

def get_dominated_by(dominator):
    worked_on_eas = set()
    # 1: initialize worklist
    worklist = [dominator]
    # 2: perform a depth-first search on the dominator tree
    while worklist:
        # get next block
        block = worklist.pop(0)
        worked_on_eas.add(block.start_ea)
        for child in block.succs():
            if child.start_ea not in worked_on_eas:
                worked_on_eas.add(child.start_ea)
                worklist.append(child)
    return worked_on_eas

def calculate_entropy(data):
    # count byte occurrences and calculate total bytes
    byte_count = collections.Counter(data)
    total_bytes = len(data)

    # calculate entropy using the counted byte occurrences
    entropy = 0.0
    for count in byte_count.values():
        # calculate byte probability and update entropy
        probability = count / total_bytes
        entropy -= probability * math.log2(probability)

    return entropy

def get_top_10_functions(functions, scoring_function):
    # sort functions by scoring function
    sorted_functions = sorted(((f, scoring_function(f))
                               for f in functions), key=lambda x: x[1])
    # bound to locate the top 10%, but 10 minimum, 1k maximum
    bound = max(min(math.ceil(((len(functions) * 10) / 100)), 1000), 10)
    # yield top 10% (iterate in descending order)
    for function, score in list(reversed(sorted_functions))[:bound]:
        yield function, score

def sort_elements(iterator, scoring_function):
    # sort elements by scoring function
    sorted_elements = sorted(((elem, scoring_function(elem))
                              for elem in iterator), key=lambda x: x[1])
    # yield in descending order
    for element, score in list(reversed(sorted_elements)):
        yield element, score
    
def calc_cyclomatic_complexity(func_addr):
    # number of basic blocks
    child = set([])
    
    num_blocks = 0
    num_edges = 0
    basic_blocks = idaapi.FlowChart(idaapi.get_func(func_addr), flags=(idaapi.FC_PREDS | idaapi.FC_NOEXT))
    for block in basic_blocks:
        for succ_block in block.succs():
            child.add(succ_block.id)     
        for pred_block in block.preds():
            child.add(pred_block.id)
    for block in basic_blocks:
        if block.id in child or block.id == 0:
            num_blocks += 1
            num_edges += len([b for b in block.succs()])
            # number of edges in the graph
    return num_edges - num_blocks + 2

def calc_average_instructions_per_block(function):
    # number of basic blocks -- set to 1 if 0
    basic_blocks = idaapi.FlowChart(idaapi.get_func(function))
    num_blocks = max(1, basic_blocks.size)
    # number of instructions
    num_instructions = sum(
        (len([i for i in idautils.Heads(b.start_ea, b.end_ea)]) for b in basic_blocks))
    return num_instructions / num_blocks

def block_is_in_loop(block):
    # 0: get the blocks dominated by this block
    dominated = get_dominated_by(block)
    # 1: get the predecessors of this block
    dominators = [d.start_ea for d in block.preds()]
    # 2: check if any predecessor is also dominated by this block
    return any((p in dominated for p in dominators))

def computes_xor_const(insn):
    # check for a xor operation
    if insn.get_canon_mnem() == 'xor':
        # check if one operand is a constant
        ops = [op for op in insn.ops]
        if ops[1].type == idaapi.o_imm or ops[0].type == idaapi.o_imm:
            return True
    return False

def contains_xor_decryption_loop(function):
    # walk over all blocks which are part of a loop
    basic_blocks = idaapi.FlowChart(idaapi.get_func(function))
    for block in basic_blocks:
        if not block_is_in_loop(block):
            continue
        # walk over all instructions
        addr = block.start_ea
        while addr < block.end_ea:
            # get instruction
            insn = idaapi.insn_t()
            insn_len = idaapi.decode_insn(insn, addr)
            # check if it performs an xor with a constant
            if computes_xor_const(insn):
                return True
            # compute next address
            addr += insn_len
    return False

def sliding_window(l, window_size):
    # yields all sliding windows of size `window_size` for a given list
    for index in range(len(l) - window_size + 1):
        yield l[index:index + window_size]

def calc_ngrams(function, n):
    fn = idaapi.get_func(function)
    hi = [h for h in fn.head_items()]
    mnemonics_sorted = [idc.print_insn_mnem(ea) for ea in hi]

    # calculate all n-grams
    grams_n = collections.Counter(["".join(w) for w in sliding_window(mnemonics_sorted, n)])
    return grams_n

def calc_uncommon_instruction_sequences_score(function):
    # determine ngram database based on function's architecture
    bitness = idaapi.get_func_bitness(function)
    if bitness == 1:
        arch = "x86"
    elif bitness == 2:
        arch = "x86_64"
    else:
        arch = None
    use_llil, ngram_database = determine_ngram_database(arch)
    # calculate all 3-grams in the function
    function_ngrams = calc_ngrams(function, 3)
    # heuristic to avoid overfitting to small function stubs
    if sum(function_ngrams.values()) < 5:
        return 0.0
    # count the number of ngrams in the function which are not in MOST_COMMON_3GRAMS
    count = sum((value for gram, value in function_ngrams.items()
                 if gram not in ngram_database))
    # average relative to the amount of ngrams in the functions
    score = count / sum(function_ngrams.values())
    return score

def get_basic_blocks(func_addr, is_attached):
    'identfies basic blocks that do not have an entry point and are not the entry point of a function' 
    child = set([])

    # ignore external blocks referenced by the function!
    basic_blocks = idaapi.FlowChart(idaapi.get_func(func_addr), flags=(idaapi.FC_PREDS | idaapi.FC_NOEXT))  
    for block in basic_blocks:
        for succ_block in block.succs():
            child.add(succ_block.id)     
        for pred_block in block.preds():
            child.add(pred_block.id)
    for block in basic_blocks:
        if is_attached == False and block.id not in child and block.id != 0:
            yield block
        if is_attached == True and block.id in child or block.id == 0:
            yield block
            
def calc_cyclomatic_complexity(func_addr):
    num_blocks = 0
    num_edges = 0
    for bb in get_basic_blocks(func_addr, True):
        num_blocks += 1
        num_edges += len([b for b in bb.succs()])
        # number of edges in the graph
    return num_edges - num_blocks + 2

def get_orph_eas(func_addr):
    for bb in get_basic_blocks(func_addr, False):
        yield (bb.start_ea, bb.end_ea)

def get_orph_count(func_addr):
    orph_num = len(list(get_orph_eas(func_addr)))
    return orph_num

# ex- uses_mixed_boolean_arithmetic()
class MbaVisitor(idaapi.ctree_visitor_t):
    def __init__(self):
        idaapi.ctree_visitor_t.__init__(self, idaapi.CV_PARENTS)
        self.mba_eas = set([])
    def list_parents(self, op_found):
        for parent in self.parents:
            if (parent is not None):
                if op_found == 'b':
                    if (parent.op in ARITHMETIC_OPERATION or
                        parent.op in ARITHMETIC_OPERATION_ASG):
                        self.mba_eas.add(parent.ea)
                if op_found == 'a':
                    if (parent.op in BOOLEAN_OPERATION or
                        parent.op in BOOLEAN_OPERATION_ASG):
                        self.mba_eas.add(parent.ea)
    def visit_expr(self, e):
        if e.op in BOOLEAN_OPERATION:
            self.list_parents('b')
        elif e.op in ARITHMETIC_OPERATION:
            self.list_parents('a')
        return 0

def calculate_complex_arithmetic_expressions(function):  
    instr_mba = 0
    cfunc = idaapi.decompile(function)
    if cfunc:
        mba_visitor = MbaVisitor()
        mba_visitor.apply_to(cfunc.body, None)
        # if an expression has a boolean and an arithmetic operation, the expression has some arithmetic complexity
        if len(mba_visitor.mba_eas):
            instr_mba = len(mba_visitor.mba_eas)
    return instr_mba

```

`idaclu/plugins/group_8/ngrams.py`:

```py
def determine_ngram_database(arch):
    if arch == "x86_64":
        return False, MOST_COMMON_3GRAMS_X86_64
    elif arch == "x86":
        return False, MOST_COMMON_3GRAMS_X86_32
    elif arch == "aarch64":
        return False, MOST_COMMON_3GRAMS_AARCH64
    elif arch == "armv7":
        return False, MOST_COMMON_3GRAMS_ARM32
    else:
        return False, None


# 1k most common 3-grams for X86_64
MOST_COMMON_3GRAMS_X86_64 = {
    'addaddadd',
    'addaddcmp',
    'addaddmov',
    'addaddpop',
    'addcallcmp',
    'addcallmov',
    'addcalltest',
    'addcmpja',
    'addcmpjae',
    'addcmpjb',
    'addcmpjbe',
    'addcmpje',
    'addcmpjg',
    'addcmpjge',
    'addcmpjl',
    'addcmpjle',
    'addcmpjne',
    'addjmpcmp',
    'addjmplea',
    'addjmpmov',
    'addleacmp',
    'addlealea',
    'addleamov',
    'addmovadd',
    'addmovand',
    'addmovcall',
    'addmovcmp',
    'addmovjmp',
    'addmovlea',
    'addmovmov',
    'addmovmovzx',
    'addmovpop',
    'addmovror',
    'addmovsub',
    'addmovtest',
    'addmovxor',
    'addmovzxcmp',
    'addmovzxmov',
    'addmovzxmovzx',
    'addmovzxtest',
    'addpopmov',
    'addpoppop',
    'addpopretn',
    'addretncall',
    'addshladd',
    'addsubmov',
    'addtestje',
    'addtestjne',
    'addxormov',
    'addxorpop',
    'addxorxor',
    'andaddmov',
    'andcmpje',
    'andcmpjne',
    'andjecmp',
    'andjemov',
    'andmovmov',
    'andnpdcvtsi2sdmovapd',
    'andormov',
    'andpdsubsdorpd',
    'andpducomisdjbe',
    'andtestje',
    'andtestjne',
    'calladdadd',
    'calladdcmp',
    'calladdjmp',
    'calladdlea',
    'calladdmov',
    'calladdpop',
    'calladdretn',
    'calladdtest',
    'calladdxor',
    'callcalllea',
    'callcallmov',
    'callcallxor',
    'callcmpja',
    'callcmpje',
    'callcmpjg',
    'callcmpjle',
    'callcmpjne',
    'callcmpmov',
    'calljmpcall',
    'calljmpcmp',
    'calljmplea',
    'calljmpmov',
    'calljmptest',
    'calljmpxor',
    'callleacall',
    'calllealea',
    'callleamov',
    'callleaveretn',
    'callleaxor',
    'callmovadd',
    'callmovcall',
    'callmovcmp',
    'callmovdqamov',
    'callmovjmp',
    'callmovlea',
    'callmovmov',
    'callmovmovsd',
    'callmovmovsxd',
    'callmovmovzx',
    'callmovpop',
    'callmovpxor',
    'callmovsdmov',
    'callmovsdmovsd',
    'callmovsub',
    'callmovsxdmov',
    'callmovtest',
    'callmovxor',
    'callmovzxmov',
    'callnopmov',
    'callpopmov',
    'callpoppop',
    'callpopxor',
    'callpushlea',
    'callpushmov',
    'callpushxor',
    'callpxormov',
    'callpxorpxor',
    'callsubmov',
    'callsubmovdqa',
    'callsubxor',
    'calltestje',
    'calltestjne',
    'calltestjns',
    'calltestjs',
    'calltestmov',
    'callxoradd',
    'callxorcall',
    'callxorjmp',
    'callxorlea',
    'callxormov',
    'callxorpop',
    'callxortest',
    'callxorxor',
    'cmovemovcall',
    'cmovemovmov',
    'cmpjaadd',
    'cmpjacmp',
    'cmpjaecmp',
    'cmpjaelea',
    'cmpjaemov',
    'cmpjaetest',
    'cmpjalea',
    'cmpjamov',
    'cmpjbcmp',
    'cmpjbecmp',
    'cmpjbelea',
    'cmpjbemov',
    'cmpjbjmp',
    'cmpjbmov',
    'cmpjeadd',
    'cmpjecall',
    'cmpjecmp',
    'cmpjeja',
    'cmpjejg',
    'cmpjejmp',
    'cmpjelea',
    'cmpjemov',
    'cmpjemovzx',
    'cmpjenop',
    'cmpjesub',
    'cmpjetest',
    'cmpjexor',
    'cmpjgcmp',
    'cmpjgemov',
    'cmpjgmov',
    'cmpjlecmp',
    'cmpjlelea',
    'cmpjlemov',
    'cmpjlmov',
    'cmpjneadd',
    'cmpjnecall',
    'cmpjnecmp',
    'cmpjnejmp',
    'cmpjnelea',
    'cmpjnemov',
    'cmpjnemovzx',
    'cmpjnenop',
    'cmpjnesub',
    'cmpjnetest',
    'cmpjnexor',
    'cmplealea',
    'cmpmovje',
    'cmpmovjne',
    'cmpmovlea',
    'cmpmovmov',
    'cmpmovsete',
    'cmpsdandpdsubsd',
    'cmpsetecmp',
    'cvtsi2sdmovapdcmpsd',
    'cvttsd2sipxormovsd',
    'endbr64pushmov',
    'imulmovmov',
    'jacmpje',
    'jaeleamov',
    'jaemovmov',
    'jaleamov',
    'jaleamovsxd',
    'jaleamovzx',
    'jamovadd',
    'jamovlea',
    'jamovmov',
    'jbecmpje',
    'jbecmpjne',
    'jbecvttsd2sipxor',
    'jbemovadd',
    'jbemovlea',
    'jbemovmov',
    'jbmovcall',
    'jbmovmov',
    'jeaddcmp',
    'jeaddmov',
    'jeaddpop',
    'jecalladd',
    'jecallcmp',
    'jecalljmp',
    'jecalllea',
    'jecallmov',
    'jecalltest',
    'jecmpja',
    'jecmpjbe',
    'jecmpje',
    'jecmpjg',
    'jecmpjle',
    'jecmpjne',
    'jecmpmov',
    'jejacmp',
    'jejmpcmp',
    'jejmpmov',
    'jejmpretn',
    'jeleacall',
    'jeleacmp',
    'jeleajmp',
    'jelealea',
    'jeleamov',
    'jeleaxor',
    'jemovadd',
    'jemovand',
    'jemovcall',
    'jemovcmp',
    'jemovjmp',
    'jemovlea',
    'jemovmov',
    'jemovmovzx',
    'jemovnop',
    'jemovpop',
    'jemovretn',
    'jemovshl',
    'jemovsub',
    'jemovsxdmov',
    'jemovtest',
    'jemovxor',
    'jemovzxcmp',
    'jemovzxmov',
    'jemovzxtest',
    'jenopmov',
    'jepushmov',
    'jesubmov',
    'jetestje',
    'jetestjne',
    'jexorcmp',
    'jexorjmp',
    'jexorlea',
    'jexormov',
    'jexorxor',
    'jgcmpje',
    'jgemovmov',
    'jgmovmov',
    'jleleamov',
    'jlemovlea',
    'jlemovmov',
    'jlesubmov',
    'jmpaddcmp',
    'jmpaddlea',
    'jmpaddmov',
    'jmpaddpop',
    'jmpcalljmp',
    'jmpcalllea',
    'jmpcallmov',
    'jmpcmpja',
    'jmpcmpjbe',
    'jmpcmpje',
    'jmpcmpjne',
    'jmpcmpmov',
    'jmpleacall',
    'jmpleacmp',
    'jmpleajmp',
    'jmplealea',
    'jmpleamov',
    'jmpleaxor',
    'jmpmovadd',
    'jmpmovand',
    'jmpmovcall',
    'jmpmovcmp',
    'jmpmovjmp',
    'jmpmovlea',
    'jmpmovmov',
    'jmpmovmovzx',
    'jmpmovpop',
    'jmpmovsub',
    'jmpmovsxdmov',
    'jmpmovtest',
    'jmpmovxor',
    'jmpmovzxcmp',
    'jmpmovzxmov',
    'jmpnopjmp',
    'jmpnopmov',
    'jmporjmp',
    'jmppoppop',
    'jmpsubmov',
    'jmptestje',
    'jmptestjne',
    'jmpxorcmp',
    'jmpxorjmp',
    'jmpxorlea',
    'jmpxormov',
    'jmpxorxor',
    'jneaddadd',
    'jneaddcmp',
    'jneaddmov',
    'jneaddpop',
    'jneaddretn',
    'jneaddxor',
    'jnecallmov',
    'jnecmpjbe',
    'jnecmpje',
    'jnecmpjne',
    'jnecmpmov',
    'jnejmpadd',
    'jnejmpcall',
    'jnejmpcmp',
    'jnejmplea',
    'jnejmpmov',
    'jneleaadd',
    'jneleacall',
    'jneleacmp',
    'jneleajmp',
    'jnelealea',
    'jneleamov',
    'jnemovadd',
    'jnemovand',
    'jnemovcall',
    'jnemovcmp',
    'jnemovjmp',
    'jnemovlea',
    'jnemovmov',
    'jnemovmovzx',
    'jnemovpop',
    'jnemovsub',
    'jnemovtest',
    'jnemovxor',
    'jnemovzxcmp',
    'jnemovzxmov',
    'jnenopmov',
    'jnepoppop',
    'jnepopretn',
    'jnetestje',
    'jnetestjne',
    'jnexorjmp',
    'jnexormov',
    'jnexortest',
    'jnexorxor',
    'jnsmovmov',
    'jsmovmov',
    'leaaddlea',
    'leaaddmov',
    'leacalladd',
    'leacallcall',
    'leacallcmp',
    'leacalljmp',
    'leacalllea',
    'leacallmov',
    'leacallnop',
    'leacallpop',
    'leacalltest',
    'leacallxor',
    'leacmovemov',
    'leacmpja',
    'leacmpjae',
    'leacmpjbe',
    'leacmpje',
    'leacmpjne',
    'leacmpmov',
    'leajmpadd',
    'leajmpcmp',
    'leajmplea',
    'leajmpmov',
    'lealeacall',
    'lealeacmovne',
    'lealeacmp',
    'lealeajmp',
    'lealealea',
    'lealeamov',
    'lealeamovq',
    'lealeapop',
    'lealeapush',
    'lealeasub',
    'lealeaxor',
    'leamovadd',
    'leamovcall',
    'leamovcmp',
    'leamovjmp',
    'leamovlea',
    'leamovmov',
    'leamovmovsxd',
    'leamovmovzx',
    'leamovnop',
    'leamovpop',
    'leamovpush',
    'leamovqlea',
    'leamovqmov',
    'leamovqmovq',
    'leamovshl',
    'leamovsub',
    'leamovsxdadd',
    'leamovtest',
    'leamovxor',
    'leamovzxmov',
    'leamovzxmovsxd',
    'leanopmov',
    'leapopjmp',
    'leapoplea',
    'leapopmov',
    'leapoppop',
    'leapushcall',
    'leapushlea',
    'leapushmov',
    'leapushpush',
    'leapushxor',
    'leashladd',
    'leasubcall',
    'leasubmov',
    'leatestje',
    'leatestjne',
    'leaxorcall',
    'leaxorlea',
    'leaxormov',
    'leaxorpush',
    'leaxorxor',
    'movaddadd',
    'movaddcall',
    'movaddcmp',
    'movaddjmp',
    'movaddlea',
    'movaddmov',
    'movaddmovzx',
    'movaddpop',
    'movaddretn',
    'movaddsub',
    'movaddtest',
    'movaddxor',
    'movandand',
    'movandcmp',
    'movandmov',
    'movandshl',
    'movandtest',
    'movapdandpducomisd',
    'movapdcmpsdandpd',
    'movapdmovmov',
    'movapscallmov',
    'movapsmovapscall',
    'movapsmovapsmov',
    'movapsmovapsmovaps',
    'movapsmovdqumovaps',
    'movapsmovmov',
    'movapstestje',
    'movcalladd',
    'movcallcall',
    'movcallcmp',
    'movcalljmp',
    'movcalllea',
    'movcallleave',
    'movcallmov',
    'movcallmovdqa',
    'movcallmovdqu',
    'movcallmovsd',
    'movcallmovsxd',
    'movcallmovzx',
    'movcallnop',
    'movcallpop',
    'movcallpush',
    'movcallpxor',
    'movcallsub',
    'movcalltest',
    'movcallxor',
    'movcdqelea',
    'movcdqidiv',
    'movcmovemov',
    'movcmpcmova',
    'movcmpja',
    'movcmpjae',
    'movcmpjb',
    'movcmpjbe',
    'movcmpje',
    'movcmpjg',
    'movcmpjge',
    'movcmpjl',
    'movcmpjle',
    'movcmpjne',
    'movcmpmov',
    'movcmpsete',
    'movcmpsetne',
    'movdqamovapsmovdqa',
    'movdqamovdqamov',
    'movdqamovdqamovdqa',
    'movdqamovmov',
    'movdqamovmovups',
    'movdqamovupsmov',
    'movdqumovapsmovdqu',
    'movdqumovdqumov',
    'movdqumovdqumovdqu',
    'movdqumovmov',
    'movdqumovmovups',
    'movdqumovupsmov',
    'movdqumovupsmovdqu',
    'movimuladd',
    'movimulmov',
    'movjecmp',
    'movjemov',
    'movjmpadd',
    'movjmpcall',
    'movjmpcmp',
    'movjmplea',
    'movjmpmov',
    'movjmpmovsxd',
    'movjmpmovzx',
    'movjmpnop',
    'movjmpsub',
    'movjmptest',
    'movjmpxor',
    'movjnecmp',
    'movjnemov',
    'movleaadd',
    'movleacall',
    'movleacmp',
    'movleajmp',
    'movlealea',
    'movleamov',
    'movleamovq',
    'movleamovsxd',
    'movleanop',
    'movleapop',
    'movleapush',
    'movleashl',
    'movleasub',
    'movleatest',
    'movleaveretn',
    'movleaxor',
    'movmovadd',
    'movmovand',
    'movmovapscall',
    'movmovapsmov',
    'movmovapsmovaps',
    'movmovcall',
    'movmovcdqe',
    'movmovcmovne',
    'movmovcmp',
    'movmovdqamov',
    'movmovdqumov',
    'movmovimul',
    'movmovje',
    'movmovjmp',
    'movmovjne',
    'movmovlea',
    'movmovleave',
    'movmovmov',
    'movmovmovaps',
    'movmovmovdqa',
    'movmovmovdqu',
    'movmovmovq',
    'movmovmovsd',
    'movmovmovss',
    'movmovmovsxd',
    'movmovmovups',
    'movmovmovzx',
    'movmovnop',
    'movmovor',
    'movmovpop',
    'movmovpush',
    'movmovpxor',
    'movmovqcall',
    'movmovqmov',
    'movmovretn',
    'movmovrol',
    'movmovsar',
    'movmovsdcall',
    'movmovsdmov',
    'movmovsdmovsd',
    'movmovshl',
    'movmovshr',
    'movmovsub',
    'movmovsxcmp',
    'movmovsxdadd',
    'movmovsxdcall',
    'movmovsxdlea',
    'movmovsxdmov',
    'movmovtest',
    'movmovupscall',
    'movmovupsmov',
    'movmovupsmovups',
    'movmovupstest',
    'movmovxor',
    'movmovzxadd',
    'movmovzxand',
    'movmovzxcmp',
    'movmovzxjmp',
    'movmovzxlea',
    'movmovzxmov',
    'movmovzxmovzx',
    'movmovzxor',
    'movmovzxshl',
    'movmovzxtest',
    'movmovzxxor',
    'movnopcmp',
    'movnopmov',
    'movorjmp',
    'movormov',
    'movpopjmp',
    'movpoplea',
    'movpopmov',
    'movpoppop',
    'movpopretn',
    'movpopxor',
    'movpushcall',
    'movpushlea',
    'movpushmov',
    'movpushpush',
    'movpushsub',
    'movpushxor',
    'movpxorlea',
    'movpxormov',
    'movpxorpxor',
    'movqcallmov',
    'movqleamov',
    'movqleapunpcklqdq',
    'movqmovcall',
    'movqmovlea',
    'movqmovmov',
    'movqmovmovq',
    'movqmovqlea',
    'movqpunpcklqdqmovups',
    'movretnmov',
    'movretnpush',
    'movrolxor',
    'movsarmov',
    'movsdandnpdcvtsi2sd',
    'movsdcallmov',
    'movsdcallmovsd',
    'movsdjmpmov',
    'movsdmovapdmovapd',
    'movsdmovcall',
    'movsdmovlea',
    'movsdmovmov',
    'movsdmovmovsd',
    'movsdmovsdcall',
    'movsdmovsdmov',
    'movsdmovsdmovapd',
    'movsdmovsdmovsd',
    'movsdtestje',
    'movshladd',
    'movshllea',
    'movshlmov',
    'movshradd',
    'movshrand',
    'movshrmov',
    'movshrxor',
    'movssmovssmovss',
    'movsubadd',
    'movsubcall',
    'movsubcmp',
    'movsubjmp',
    'movsubjne',
    'movsublea',
    'movsubmov',
    'movsubsar',
    'movsubsub',
    'movsubtest',
    'movsxdaddjmp',
    'movsxdaddmov',
    'movsxdcallmov',
    'movsxdleamov',
    'movsxdmovadd',
    'movsxdmovcall',
    'movsxdmovlea',
    'movsxdmovmov',
    'movsxdmovxor',
    'movsxmovmov',
    'movtestje',
    'movtestjg',
    'movtestjle',
    'movtestjne',
    'movtestjns',
    'movtestjs',
    'movtestmov',
    'movupscallmov',
    'movupsmovcall',
    'movupsmovdqumovups',
    'movupsmovmov',
    'movupsmovupsmov',
    'movupsmovupsmovups',
    'movupsmovupstest',
    'movupstestje',
    'movxoradd',
    'movxorand',
    'movxorcall',
    'movxorcmp',
    'movxorjmp',
    'movxorlea',
    'movxormov',
    'movxormovdqa',
    'movxormovzx',
    'movxornop',
    'movxorpop',
    'movxorpush',
    'movxorsub',
    'movxortest',
    'movxorxor',
    'movzxaddcmp',
    'movzxaddmov',
    'movzxandcmp',
    'movzxandmov',
    'movzxandtest',
    'movzxcmpja',
    'movzxcmpje',
    'movzxcmpjne',
    'movzxjmpmov',
    'movzxleacmp',
    'movzxleamov',
    'movzxmovadd',
    'movzxmovand',
    'movzxmovcall',
    'movzxmovcmp',
    'movzxmovjmp',
    'movzxmovlea',
    'movzxmovmov',
    'movzxmovmovzx',
    'movzxmovsxdadd',
    'movzxmovtest',
    'movzxmovzxadd',
    'movzxmovzxand',
    'movzxmovzxmov',
    'movzxormov',
    'movzxshlor',
    'movzxtestje',
    'movzxtestjne',
    'movzxxortest',
    'mulsdmulsdaddsd',
    'nopcmpje',
    'nopcmpjne',
    'nopjmpnop',
    'nopleaveretn',
    'nopmovadd',
    'nopmovcall',
    'nopmovlea',
    'nopmovmov',
    'nopmovsub',
    'nopmovtest',
    'nopmovzxadd',
    'nopmovzxmov',
    'noptestje',
    'orjmpmov',
    'ormovjmp',
    'ormovmov',
    'popjmpadd',
    'popjmpcall',
    'popjmplea',
    'popjmpmov',
    'popjmppop',
    'popjmptest',
    'popjmpxor',
    'popleajmp',
    'poplealea',
    'popleapop',
    'popmovjmp',
    'popmovmov',
    'popmovpop',
    'popmovretn',
    'poppopjmp',
    'poppopmov',
    'poppoppop',
    'poppopretn',
    'poppoptest',
    'popretnadd',
    'popretncall',
    'popretncmp',
    'popretnlea',
    'popretnmov',
    'popretnretn',
    'popretntest',
    'popretnxor',
    'poptestje',
    'popxorpop',
    'pushcalladd',
    'pushcallmov',
    'pushleacall',
    'pushlealea',
    'pushleamov',
    'pushleapush',
    'pushleaxor',
    'pushmovadd',
    'pushmovcall',
    'pushmovlea',
    'pushmovmov',
    'pushmovpush',
    'pushmovsub',
    'pushmovtest',
    'pushmovxor',
    'pushpushcall',
    'pushpushlea',
    'pushpushmov',
    'pushpushpush',
    'pushpushsub',
    'pushpushtest',
    'pushpushxor',
    'pushsubcall',
    'pushsublea',
    'pushsubmov',
    'pushsubtest',
    'pushtestje',
    'pushxorlea',
    'pushxormov',
    'pushxorpush',
    'pushxorxor',
    'pxorleamov',
    'pxormovcvtsi2sd',
    'pxormovlea',
    'pxormovmov',
    'pxormovsdandnpd',
    'pxorpxorcvtsi2sd',
    'pxorpxormov',
    'repcmpsbsetasbb',
    'retncallmov',
    'retncmpje',
    'retncmpjne',
    'retnleacall',
    'retnlealea',
    'retnleamov',
    'retnmovadd',
    'retnmovcall',
    'retnmovcmp',
    'retnmovjmp',
    'retnmovlea',
    'retnmovmov',
    'retnmovtest',
    'retnmovxor',
    'retnpushlea',
    'retntestje',
    'retntestjne',
    'retnxormov',
    'rolxormov',
    'rorxormov',
    'setasbbtest',
    'shladdmov',
    'shlcallmov',
    'shlleamov',
    'shlmovcall',
    'shlmovmov',
    'shraddmov',
    'shraddsar',
    'shrmovmov',
    'subaddmov',
    'subcalladd',
    'subcalllea',
    'subcallmov',
    'subcalltest',
    'subcmpja',
    'subcmpjb',
    'subcmpjbe',
    'subcmpje',
    'subcmpjne',
    'subjemov',
    'subjmpmov',
    'subjneadd',
    'subjnelea',
    'subjnemov',
    'subleacall',
    'sublealea',
    'subleamov',
    'submovadd',
    'submovcall',
    'submovcmp',
    'submovdqamovdqa',
    'submovjmp',
    'submovlea',
    'submovmov',
    'submovpush',
    'submovshr',
    'submovsub',
    'submovtest',
    'submovxor',
    'subpushmov',
    'subsdorpdmovapd',
    'subsubcmp',
    'subsubmov',
    'subtestje',
    'subtestjne',
    'subxormov',
    'subxorxor',
    'testcmovemov',
    'testjeadd',
    'testjecall',
    'testjecmp',
    'testjejmp',
    'testjelea',
    'testjemov',
    'testjemovsd',
    'testjemovsxd',
    'testjemovzx',
    'testjenop',
    'testjepop',
    'testjepush',
    'testjepxor',
    'testjesub',
    'testjetest',
    'testjexor',
    'testjgmov',
    'testjlelea',
    'testjlemov',
    'testjlemovsxd',
    'testjlenop',
    'testjlesub',
    'testjneadd',
    'testjnecall',
    'testjnecmp',
    'testjnejmp',
    'testjnelea',
    'testjnemov',
    'testjnemovzx',
    'testjnenop',
    'testjnepop',
    'testjnesub',
    'testjnetest',
    'testjnexor',
    'testjnsmov',
    'testjscmp',
    'testjsmov',
    'testleacmove',
    'testmovje',
    'testmovmov',
    'ucomisdjbecvttsd2si',
    'xoraddmov',
    'xoraddpop',
    'xorandje',
    'xorcalladd',
    'xorcallcall',
    'xorcallcmp',
    'xorcalljmp',
    'xorcalllea',
    'xorcallmov',
    'xorcallnop',
    'xorcallpop',
    'xorcalltest',
    'xorcallxor',
    'xorcmpje',
    'xorcmpjne',
    'xorcmpsete',
    'xorjmpadd',
    'xorjmpcall',
    'xorjmpcmp',
    'xorjmplea',
    'xorjmpmov',
    'xorjmpxor',
    'xorleacall',
    'xorlealea',
    'xorleamov',
    'xorleapush',
    'xorleaxor',
    'xormovadd',
    'xormovcall',
    'xormovcmp',
    'xormovdqamov',
    'xormovjmp',
    'xormovlea',
    'xormovmov',
    'xormovpop',
    'xormovpush',
    'xormovrol',
    'xormovsub',
    'xormovtest',
    'xormovxor',
    'xormovzxmov',
    'xornopmov',
    'xorpopjmp',
    'xorpopmov',
    'xorpoppop',
    'xorpopretn',
    'xorpushlea',
    'xorpushmov',
    'xorpushpush',
    'xorpushxor',
    'xortestje',
    'xortestjne',
    'xorxorcall',
    'xorxorjmp',
    'xorxorlea',
    'xorxormov',
    'xorxorpush',
    'xorxorxor'
}

# 1k most common 3-grams for X86_32
MOST_COMMON_3GRAMS_X86_32 = {
    'adcmovmov',
    'addadcadd',
    'addadcmov',
    'addaddadd',
    'addaddcmp',
    'addaddjmp',
    'addaddmov',
    'addaddpop',
    'addaddpush',
    'addaddsub',
    'addaddtest',
    'addcalladd',
    'addcallmov',
    'addcallsub',
    'addcmpja',
    'addcmpjae',
    'addcmpjb',
    'addcmpjbe',
    'addcmpje',
    'addcmpjg',
    'addcmpjge',
    'addcmpjl',
    'addcmpjle',
    'addcmpjne',
    'addcmpmov',
    'addjmpadd',
    'addjmpcall',
    'addjmpcmp',
    'addjmplea',
    'addjmpmov',
    'addjmppush',
    'addjmpsub',
    'addjmptest',
    'addjmpxor',
    'addleacmp',
    'addlealea',
    'addleamov',
    'addleapop',
    'addleapush',
    'addleasub',
    'addleaveretn',
    'addmovadc',
    'addmovadd',
    'addmovand',
    'addmovcall',
    'addmovcmp',
    'addmovjmp',
    'addmovlea',
    'addmovleave',
    'addmovmov',
    'addmovmovzx',
    'addmovpop',
    'addmovpush',
    'addmovshl',
    'addmovsub',
    'addmovtest',
    'addmovxor',
    'addmovzxcmp',
    'addmovzxjmp',
    'addmovzxmov',
    'addmovzxmovzx',
    'addmovzxtest',
    'addpoppop',
    'addpopretn',
    'addpushcall',
    'addpushlea',
    'addpushmov',
    'addpushpush',
    'addpushsub',
    'addsubcall',
    'addsubcmp',
    'addsubfld',
    'addsublea',
    'addsubmov',
    'addsubpush',
    'addtestje',
    'addtestjle',
    'addtestjne',
    'addtestjns',
    'addtestjs',
    'addtestmov',
    'addtestsetne',
    'addxoradd',
    'addxorjmp',
    'addxormov',
    'addxorpop',
    'addxortest',
    'andaddmov',
    'andcmpje',
    'andcmpjne',
    'andjecmp',
    'andjemov',
    'andmovjmp',
    'andmovmov',
    'andmovsub',
    'andormov',
    'andpushpush',
    'andtestje',
    'andtestjne',
    'calladdadd',
    'calladdcall',
    'calladdcmp',
    'calladdfld',
    'calladdjmp',
    'calladdlea',
    'calladdleave',
    'calladdmov',
    'calladdmovzx',
    'calladdpop',
    'calladdpush',
    'calladdretn',
    'calladdsub',
    'calladdtest',
    'calladdxor',
    'callcalladd',
    'callcallmov',
    'callcallpop',
    'callcmpje',
    'callcmpjne',
    'callfldadd',
    'callfldmov',
    'callfstppop',
    'calljmpmov',
    'calljmpsub',
    'callleaadd',
    'calllealea',
    'callleamov',
    'callleapop',
    'callleapush',
    'callmovadd',
    'callmovcall',
    'callmovcmp',
    'callmovjmp',
    'callmovlea',
    'callmovmov',
    'callmovmovzx',
    'callmovpop',
    'callmovpush',
    'callmovsub',
    'callmovtest',
    'callmovxor',
    'callmovzxadd',
    'callmovzxmov',
    'callpoplea',
    'callpopmov',
    'callpoppop',
    'callpoppush',
    'callpushcall',
    'callpushlea',
    'callpushmov',
    'callpushpush',
    'callsublea',
    'callsubmov',
    'callsubpush',
    'calltestje',
    'calltestjne',
    'callxormov',
    'cdqpushpush',
    'cmovemovmov',
    'cmpjaadd',
    'cmpjacmp',
    'cmpjaecmp',
    'cmpjaelea',
    'cmpjaemov',
    'cmpjaesub',
    'cmpjaetest',
    'cmpjajmp',
    'cmpjalea',
    'cmpjamov',
    'cmpjamovzx',
    'cmpjasub',
    'cmpjbecmp',
    'cmpjbejmp',
    'cmpjbelea',
    'cmpjbemov',
    'cmpjbemovzx',
    'cmpjbesub',
    'cmpjbjmp',
    'cmpjbmov',
    'cmpjbsub',
    'cmpjeadd',
    'cmpjecall',
    'cmpjecmp',
    'cmpjeja',
    'cmpjejg',
    'cmpjejmp',
    'cmpjelea',
    'cmpjemov',
    'cmpjemovzx',
    'cmpjepush',
    'cmpjesub',
    'cmpjetest',
    'cmpjexor',
    'cmpjgcmp',
    'cmpjgemov',
    'cmpjglea',
    'cmpjgmov',
    'cmpjgsub',
    'cmpjlecmp',
    'cmpjlelea',
    'cmpjlemov',
    'cmpjlesub',
    'cmpjlmov',
    'cmpjneadd',
    'cmpjnecall',
    'cmpjnecmp',
    'cmpjnefstp',
    'cmpjnejmp',
    'cmpjnelea',
    'cmpjnemov',
    'cmpjnemovzx',
    'cmpjnepush',
    'cmpjnesub',
    'cmpjnetest',
    'cmpjnexor',
    'cmpleaje',
    'cmpmovje',
    'cmpmovjne',
    'cmpmovmov',
    'cmpmovsbb',
    'cmpmovsete',
    'cmpsetecmp',
    'cmpsetnecmp',
    'divmovmov',
    'fcomifstpjbe',
    'fcomipfstpjbe',
    'fildmovmov',
    'fistpfldcwfld',
    'fistpfldcwmov',
    'fldcwfistpfldcw',
    'fldcwfrndintfldcw',
    'fldcwmovmov',
    'fldfldfld',
    'fldfldfmul',
    'fldfmulfaddp',
    'fldfmulfld',
    'fldfmulfxch',
    'fldfstfstp',
    'fldfstpfld',
    'fldfstppush',
    'fldfxchfcomi',
    'fldmovfstp',
    'fldmovmov',
    'fldsubfst',
    'fldsubfstp',
    'fmulfldfmul',
    'fnstcwmovzxor',
    'fstfstfstp',
    'fstfstpfld',
    'fstfstppush',
    'fstpaddcmp',
    'fstpaddpop',
    'fstpaddpush',
    'fstpcalladd',
    'fstpcallfld',
    'fstpcallmov',
    'fstpfildfstp',
    'fstpfldfld',
    'fstpfldfmul',
    'fstpfldfst',
    'fstpfldfstp',
    'fstpfldmov',
    'fstpfstfstp',
    'fstpfstpcall',
    'fstpfstpfstp',
    'fstpfstpjmp',
    'fstpfstpmov',
    'fstpfstppush',
    'fstpfxchfstp',
    'fstpjmpfstp',
    'fstpmovmov',
    'fstppoppop',
    'fstppushcall',
    'fstppushlea',
    'fstppushmov',
    'fstppushpush',
    'fstpsubpush',
    'fstptestje',
    'fucomifstpjpe',
    'fxchfcomifstp',
    'fxchfcomipfstp',
    'fxchfstpfld',
    'fxchfstpfstp',
    'fxchfstpfxch',
    'fxchfxchfxch',
    'fxchfxchjmp',
    'fxchjmpfstp',
    'imuladdmov',
    'imulimuladd',
    'imulmovadd',
    'imulmovmov',
    'incmovmov',
    'jacmpja',
    'jacmpjbe',
    'jacmpje',
    'jaeleamov',
    'jaemovmov',
    'jaetestje',
    'jamovadd',
    'jamovcmp',
    'jamovmov',
    'jamovtest',
    'jasubpush',
    'jbecmpje',
    'jbecmpjne',
    'jbemovadd',
    'jbemovlea',
    'jbemovmov',
    'jbmovmov',
    'jbsubpush',
    'jeaddcmp',
    'jeaddmov',
    'jeaddpop',
    'jecallmov',
    'jecallsub',
    'jecmpja',
    'jecmpjbe',
    'jecmpje',
    'jecmpjg',
    'jecmpjne',
    'jecmpmov',
    'jejacmp',
    'jejmpcmp',
    'jejmpmov',
    'jejmpsub',
    'jeleacmp',
    'jelealea',
    'jeleamov',
    'jeleanop',
    'jeleapush',
    'jeleasub',
    'jemovadd',
    'jemovand',
    'jemovcall',
    'jemovcmp',
    'jemovjmp',
    'jemovlea',
    'jemovmov',
    'jemovmovzx',
    'jemovpush',
    'jemovsub',
    'jemovtest',
    'jemovxor',
    'jemovzxcmp',
    'jemovzxmov',
    'jemovzxtest',
    'jepushlea',
    'jepushmov',
    'jepushpush',
    'jesublea',
    'jesubmov',
    'jesubpush',
    'jetestje',
    'jetestjne',
    'jexorcmp',
    'jexorjmp',
    'jexormov',
    'jgcmpje',
    'jgemovmov',
    'jgmovmov',
    'jleleamov',
    'jlemovlea',
    'jlemovmov',
    'jlemovsub',
    'jlemovtest',
    'jlesubpush',
    'jlmovmov',
    'jmpaddcmp',
    'jmpaddmov',
    'jmpaddpop',
    'jmpcallmov',
    'jmpcallsub',
    'jmpcmpja',
    'jmpcmpjbe',
    'jmpcmpje',
    'jmpcmpjne',
    'jmpcmpmov',
    'jmpfstpfstp',
    'jmpfstpfxch',
    'jmpfstpjmp',
    'jmpfstpmov',
    'jmpleacmp',
    'jmpleajmp',
    'jmpleamov',
    'jmpleapush',
    'jmpleasub',
    'jmpmovadd',
    'jmpmovand',
    'jmpmovcall',
    'jmpmovcmp',
    'jmpmovjmp',
    'jmpmovlea',
    'jmpmovmov',
    'jmpmovmovzx',
    'jmpmovpush',
    'jmpmovsub',
    'jmpmovtest',
    'jmpmovxor',
    'jmpmovzxmov',
    'jmpnopjmp',
    'jmporjmp',
    'jmppushlea',
    'jmppushmov',
    'jmppushpush',
    'jmpsubcmp',
    'jmpsublea',
    'jmpsubmov',
    'jmpsubpush',
    'jmptestje',
    'jmptestjne',
    'jmpxorjmp',
    'jmpxormov',
    'jneaddcmp',
    'jneaddmov',
    'jneaddpop',
    'jnecallmov',
    'jnecallsub',
    'jnecmpjbe',
    'jnecmpje',
    'jnecmpjne',
    'jnecmpmov',
    'jnejmpcmp',
    'jnejmpmov',
    'jnejmpsub',
    'jneleacmp',
    'jnelealea',
    'jneleamov',
    'jneleanop',
    'jneleapop',
    'jneleapush',
    'jneleasub',
    'jnemovadd',
    'jnemovand',
    'jnemovcall',
    'jnemovcmp',
    'jnemovjmp',
    'jnemovlea',
    'jnemovmov',
    'jnemovmovzx',
    'jnemovpush',
    'jnemovsub',
    'jnemovtest',
    'jnemovxor',
    'jnemovzxand',
    'jnemovzxmov',
    'jnepoppop',
    'jnepushlea',
    'jnepushpush',
    'jnesublea',
    'jnesubmov',
    'jnesubpush',
    'jnetestje',
    'jnetestjne',
    'jnexorjmp',
    'jnexormov',
    'jsmovmov',
    'jssubpush',
    'leaaddcmp',
    'leaaddlea',
    'leaaddmov',
    'leaaddpush',
    'leacalladd',
    'leacallmov',
    'leacmovemov',
    'leacmpja',
    'leacmpjae',
    'leacmpjbe',
    'leacmpje',
    'leacmpjne',
    'leacmpmov',
    'leajmpcall',
    'leajmpcmp',
    'leajmplea',
    'leajmpmov',
    'leajmppush',
    'leajmpsub',
    'lealeaadd',
    'lealeacmp',
    'lealealea',
    'lealeamov',
    'lealeapush',
    'lealeasub',
    'leamovadd',
    'leamovcall',
    'leamovcmp',
    'leamovjmp',
    'leamovlea',
    'leamovmov',
    'leamovmovzx',
    'leamovpop',
    'leamovpush',
    'leamovshl',
    'leamovsub',
    'leamovtest',
    'leamovxor',
    'leamovzxadd',
    'leamovzxmov',
    'leanopcmp',
    'leanopmov',
    'leanopsub',
    'leapoppop',
    'leapoppush',
    'leapushcall',
    'leapushjmp',
    'leapushlea',
    'leapushmov',
    'leapushpush',
    'leapushsub',
    'leasublea',
    'leasubmov',
    'leasubpush',
    'leatestje',
    'leatestjne',
    'leaxormov',
    'leaxorpush',
    'movaddadc',
    'movaddadd',
    'movaddand',
    'movaddcall',
    'movaddcmp',
    'movaddjmp',
    'movaddlea',
    'movaddmov',
    'movaddmovzx',
    'movaddpop',
    'movaddpush',
    'movaddsub',
    'movaddtest',
    'movaddxor',
    'movandadd',
    'movandand',
    'movandcmp',
    'movandmov',
    'movandor',
    'movandpush',
    'movandshl',
    'movandshr',
    'movandtest',
    'movcalladd',
    'movcallcall',
    'movcallcmp',
    'movcallfstp',
    'movcalljmp',
    'movcalllea',
    'movcallmov',
    'movcallpop',
    'movcallpush',
    'movcallsub',
    'movcalltest',
    'movcallxor',
    'movcdqidiv',
    'movcmpja',
    'movcmpjae',
    'movcmpjb',
    'movcmpjbe',
    'movcmpje',
    'movcmpjg',
    'movcmpjge',
    'movcmpjl',
    'movcmpjle',
    'movcmpjne',
    'movcmpmov',
    'movcmpsbb',
    'movcmpsete',
    'movcmpsetne',
    'movdivmov',
    'movfildmov',
    'movfldcwfistp',
    'movfldfld',
    'movfldmov',
    'movfstpcall',
    'movfstpfld',
    'movfstpmov',
    'movimuladd',
    'movimulimul',
    'movimulmov',
    'movincmov',
    'movjecmp',
    'movjelea',
    'movjemov',
    'movjesub',
    'movjmpadd',
    'movjmpcall',
    'movjmpcmp',
    'movjmpfstp',
    'movjmplea',
    'movjmpmov',
    'movjmpmovzx',
    'movjmppush',
    'movjmpsub',
    'movjmptest',
    'movjmpxor',
    'movjnecmp',
    'movjnemov',
    'movjnesub',
    'movleaadd',
    'movleaand',
    'movleacall',
    'movleacmp',
    'movleajmp',
    'movlealea',
    'movleamov',
    'movleamovzx',
    'movleanop',
    'movleapop',
    'movleapush',
    'movleashl',
    'movleasub',
    'movleatest',
    'movleaveretn',
    'movleaxor',
    'movmovadd',
    'movmovand',
    'movmovcall',
    'movmovcdq',
    'movmovcmp',
    'movmovdiv',
    'movmovfild',
    'movmovfld',
    'movmovfstp',
    'movmovimul',
    'movmovinc',
    'movmovje',
    'movmovjmp',
    'movmovjne',
    'movmovlea',
    'movmovleave',
    'movmovmov',
    'movmovmovsx',
    'movmovmovzx',
    'movmovmul',
    'movmovnop',
    'movmovor',
    'movmovpop',
    'movmovpush',
    'movmovrepmovsd',
    'movmovrepstosd',
    'movmovretn',
    'movmovsar',
    'movmovsbb',
    'movmovshl',
    'movmovshr',
    'movmovsub',
    'movmovsxcmp',
    'movmovsxmov',
    'movmovtest',
    'movmovxor',
    'movmovzxadd',
    'movmovzxand',
    'movmovzxcmp',
    'movmovzxjmp',
    'movmovzxlea',
    'movmovzxmov',
    'movmovzxmovzx',
    'movmovzxor',
    'movmovzxtest',
    'movmulmov',
    'movnopmov',
    'movorje',
    'movorjne',
    'movormov',
    'movpoplea',
    'movpopmov',
    'movpoppop',
    'movpoppush',
    'movpopretn',
    'movpushadd',
    'movpushcall',
    'movpushlea',
    'movpushmov',
    'movpushpush',
    'movpushsub',
    'movpushxor',
    'movsarmov',
    'movsbbjb',
    'movsbbjge',
    'movsbbmov',
    'movshladd',
    'movshland',
    'movshlcmp',
    'movshlmov',
    'movshlor',
    'movshradd',
    'movshrand',
    'movshrmov',
    'movsubadd',
    'movsubcall',
    'movsubcmp',
    'movsubimul',
    'movsubjmp',
    'movsubjne',
    'movsublea',
    'movsubmov',
    'movsubpush',
    'movsubsar',
    'movsubsbb',
    'movsubsub',
    'movsubtest',
    'movtestje',
    'movtestjg',
    'movtestjle',
    'movtestjne',
    'movtestjns',
    'movtestjs',
    'movtestlea',
    'movtestmov',
    'movtestsete',
    'movtestsetne',
    'movxoradd',
    'movxorand',
    'movxorcall',
    'movxorcmp',
    'movxordiv',
    'movxorjmp',
    'movxorlea',
    'movxormov',
    'movxormovzx',
    'movxoror',
    'movxorpush',
    'movxorsub',
    'movxortest',
    'movxorxor',
    'movzxaddadd',
    'movzxaddcmp',
    'movzxaddjmp',
    'movzxaddmov',
    'movzxandcmp',
    'movzxandmov',
    'movzxandor',
    'movzxandtest',
    'movzxcmpje',
    'movzxcmpjne',
    'movzxjmpmov',
    'movzxleacmp',
    'movzxleamov',
    'movzxmovadd',
    'movzxmovand',
    'movzxmovcmp',
    'movzxmovjmp',
    'movzxmovlea',
    'movzxmovmov',
    'movzxmovmovzx',
    'movzxmovshr',
    'movzxmovsub',
    'movzxmovtest',
    'movzxmovxor',
    'movzxmovzxand',
    'movzxmovzxmov',
    'movzxormov',
    'movzxpushpush',
    'movzxtestje',
    'movzxtestjne',
    'mulmovmov',
    'negmovmov',
    'nopjmpnop',
    'nopmovmov',
    'nopmovsub',
    'nopmovtest',
    'nopsubpush',
    'notandmov',
    'orjemov',
    'orjmpmov',
    'orjnemov',
    'ormovfldcw',
    'ormovjmp',
    'ormovmov',
    'popjmpmov',
    'popjmpsub',
    'popleamov',
    'popleapop',
    'popleapush',
    'popmovmov',
    'popmovpop',
    'popmovpush',
    'poppopjmp',
    'poppoplea',
    'poppopmov',
    'poppoppop',
    'poppoppush',
    'poppopretn',
    'poppushcall',
    'poppushlea',
    'poppushmov',
    'poppushpush',
    'popretnadd',
    'popretncall',
    'popretncmp',
    'popretnfstp',
    'popretnlea',
    'popretnmov',
    'popretnpush',
    'popretnsub',
    'popretntest',
    'popretnxor',
    'popxorpop',
    'pushaddcall',
    'pushaddpush',
    'pushcalladd',
    'pushcallcall',
    'pushcallfld',
    'pushcalljmp',
    'pushcalllea',
    'pushcallmov',
    'pushcallmovzx',
    'pushcallpop',
    'pushcallpush',
    'pushcallsub',
    'pushcallxor',
    'pushfldsub',
    'pushjmpmov',
    'pushjmppush',
    'pushjmpsub',
    'pushleacall',
    'pushleajmp',
    'pushlealea',
    'pushleamov',
    'pushleapush',
    'pushmovadd',
    'pushmovcall',
    'pushmovlea',
    'pushmovmov',
    'pushmovpush',
    'pushmovsub',
    'pushmovxor',
    'pushmovzxpush',
    'pushpushadd',
    'pushpushcall',
    'pushpushfld',
    'pushpushjmp',
    'pushpushlea',
    'pushpushmov',
    'pushpushpush',
    'pushpushsub',
    'pushpushxor',
    'pushsubcall',
    'pushsubfst',
    'pushsubfstp',
    'pushsubmov',
    'pushsubpush',
    'pushxorcall',
    'pushxormov',
    'pushxorpush',
    'repcmpsbsetasbb',
    'retncallsub',
    'retncmpje',
    'retncmpjne',
    'retnleamov',
    'retnmovadd',
    'retnmovcall',
    'retnmovcmp',
    'retnmovjmp',
    'retnmovlea',
    'retnmovmov',
    'retnmovsub',
    'retnmovtest',
    'retnmovxor',
    'retnpushpush',
    'retnsublea',
    'retnsubmov',
    'retnsubpush',
    'retntestje',
    'retntestjne',
    'sarmovmov',
    'sbbjbmov',
    'sbbjgemov',
    'sbbmovmov',
    'setasbbtest',
    'shladdmov',
    'shlmovmov',
    'shlpushpush',
    'shraddmov',
    'shraddsar',
    'shrmovmov',
    'subaddmov',
    'subaddpush',
    'subcalladd',
    'subcallmov',
    'subcallsub',
    'subcmpja',
    'subcmpjb',
    'subcmpjbe',
    'subcmpje',
    'subcmpjne',
    'subcmpmov',
    'subfldmov',
    'subfstfstp',
    'subfstpfld',
    'subfstppush',
    'subjmpmov',
    'subjneadd',
    'subjnemov',
    'subjnesub',
    'subleajmp',
    'sublealea',
    'subleamov',
    'subleapush',
    'subleasub',
    'submovadd',
    'submovcall',
    'submovcmp',
    'submovjmp',
    'submovlea',
    'submovmov',
    'submovmovzx',
    'submovpush',
    'submovshl',
    'submovshr',
    'submovsub',
    'submovtest',
    'subpushadd',
    'subpushcall',
    'subpushjmp',
    'subpushlea',
    'subpushmov',
    'subpushpush',
    'subsbbmov',
    'subsubmov',
    'subsubpush',
    'subtestje',
    'subxormov',
    'subxorpush',
    'testjeadd',
    'testjecall',
    'testjecmp',
    'testjefld',
    'testjejmp',
    'testjelea',
    'testjemov',
    'testjemovzx',
    'testjepush',
    'testjesub',
    'testjetest',
    'testjexor',
    'testjgmov',
    'testjlelea',
    'testjlemov',
    'testjlesub',
    'testjneadd',
    'testjnecall',
    'testjnecmp',
    'testjnejmp',
    'testjnelea',
    'testjnemov',
    'testjnemovzx',
    'testjnepop',
    'testjnepush',
    'testjnesub',
    'testjnetest',
    'testjnexor',
    'testjnsmov',
    'testjscmp',
    'testjsmov',
    'testjssub',
    'testleacmove',
    'testmovje',
    'testmovjne',
    'testmovmov',
    'xoraddadc',
    'xoraddmov',
    'xoraddpop',
    'xorandje',
    'xorcalladd',
    'xorcallmov',
    'xorcallsub',
    'xorcmpje',
    'xorcmpjne',
    'xorcmpmov',
    'xordivmov',
    'xorjmpcall',
    'xorjmpcmp',
    'xorjmpmov',
    'xorjmppush',
    'xorjmpsub',
    'xorleamov',
    'xorleanop',
    'xorleapush',
    'xormovadd',
    'xormovcall',
    'xormovcmp',
    'xormovjmp',
    'xormovlea',
    'xormovmov',
    'xormovor',
    'xormovpush',
    'xormovsub',
    'xormovtest',
    'xormovxor',
    'xororje',
    'xororjne',
    'xorpopmov',
    'xorpoppop',
    'xorpushcall',
    'xorpushlea',
    'xorpushmov',
    'xorpushpush',
    'xortestje',
    'xortestjne',
    'xorxorjmp',
    'xorxormov',
    'xorxoror'
}

# 1k most common 3-grams for AARCH64
MOST_COMMON_3GRAMS_AARCH64 = {
    'addaddadd',
    'addaddadrp',
    'addaddb',
    'addaddbl',
    'addaddcmp',
    'addaddldar',
    'addaddldr',
    'addaddmov',
    'addaddstp',
    'addaddstr',
    'addadrpadd',
    'addadrpadrp',
    'addadrpb',
    'addadrpldp',
    'addadrpldr',
    'addadrpmov',
    'addbadd',
    'addbadrp',
    'addbbl',
    'addbcmp',
    'addbladd',
    'addbladrp',
    'addblb',
    'addblbl',
    'addblcbnz',
    'addblcbz',
    'addblcmp',
    'addbldp',
    'addbldr',
    'addblldp',
    'addblldr',
    'addblmov',
    'addblstr',
    'addbmov',
    'addcmpadd',
    'addcmpb.eq',
    'addcmpb.gt',
    'addcmpb.hi',
    'addcmpb.hs',
    'addcmpb.le',
    'addcmpb.ls',
    'addcmpb.ne',
    'addldarcbz',
    'addldpadd',
    'addldpadrp',
    'addldpldp',
    'addldpmov',
    'addldpstp',
    'addldradd',
    'addldradrp',
    'addldrb',
    'addldrbcbnz',
    'addldrbcmp',
    'addldrbl',
    'addldrblr',
    'addldrcbnz',
    'addldrcbz',
    'addldrcmp',
    'addldrldp',
    'addldrldr',
    'addldrmov',
    'addldrstp',
    'addldrstr',
    'addldrsub',
    'addlsladd',
    'addmovadd',
    'addmovadrp',
    'addmovb',
    'addmovbl',
    'addmovcmp',
    'addmovldp',
    'addmovldr',
    'addmovmov',
    'addmovstp',
    'addmovstr',
    'addretmov',
    'addstpadd',
    'addstpadrp',
    'addstpbl',
    'addstpmov',
    'addstpstp',
    'addstpstr',
    'addstradd',
    'addstradrp',
    'addstrb',
    'addstrbl',
    'addstrcbz',
    'addstrcmp',
    'addstrldp',
    'addstrldr',
    'addstrldrb',
    'addstrmov',
    'addstrstp',
    'addstrstr',
    'addsubadd',
    'addsubmov',
    'adraddbr',
    'adrpaddadd',
    'adrpaddadrp',
    'adrpaddb',
    'adrpaddbl',
    'adrpaddcmp',
    'adrpaddldr',
    'adrpaddmov',
    'adrpaddret',
    'adrpaddstp',
    'adrpaddstr',
    'adrpadrpadd',
    'adrpadrpadrp',
    'adrpadrpldr',
    'adrpadrpmov',
    'adrpbladd',
    'adrpldpadd',
    'adrpldradd',
    'adrpldradrp',
    'adrpldrbl',
    'adrpldrcbz',
    'adrpldrldr',
    'adrpldrmov',
    'adrpldrstp',
    'adrpldrstr',
    'adrpmovadd',
    'adrpmovadrp',
    'adrpmovldr',
    'adrpmovmov',
    'adrpmovstp',
    'adrpstpadd',
    'adrpstpldr',
    'adrpstpmov',
    'adrpstradd',
    'andandcmp',
    'andcmpb.eq',
    'andcmpb.hi',
    'andcmpb.ne',
    'andeorand',
    'andmovmov',
    'andstrldr',
    'b.eqaddadd',
    'b.eqaddmov',
    'b.eqaddstr',
    'b.eqadrpadd',
    'b.eqadrpldr',
    'b.eqb.hicmp',
    'b.eqb.lscmp',
    'b.eqblmov',
    'b.eqcmpb.eq',
    'b.eqcmpb.ne',
    'b.eqldradd',
    'b.eqldrbcmp',
    'b.eqldrbl',
    'b.eqldrcbz',
    'b.eqldrcmp',
    'b.eqldrldr',
    'b.eqldrldrb',
    'b.eqldrmov',
    'b.eqldrstr',
    'b.eqmovadrp',
    'b.eqmovb',
    'b.eqmovbl',
    'b.eqmovcmp',
    'b.eqmovldr',
    'b.eqmovmov',
    'b.eqmovstr',
    'b.hicmpb.eq',
    'b.hildrcmp',
    'b.himovmov',
    'b.hsaddadd',
    'b.leldrmov',
    'b.lemovmov',
    'b.lscmpb.eq',
    'b.lsmovstrb',
    'b.lsstrbadd',
    'b.neaddadd',
    'b.neaddmov',
    'b.neadrpadd',
    'b.neadrpldr',
    'b.nebldr',
    'b.neldpadrp',
    'b.neldpldp',
    'b.neldpldr',
    'b.neldpmov',
    'b.neldradd',
    'b.neldrand',
    'b.neldrbcbnz',
    'b.neldrbcmp',
    'b.neldrbl',
    'b.neldrcbz',
    'b.neldrcmp',
    'b.neldrldp',
    'b.neldrldr',
    'b.neldrmov',
    'b.neldrstr',
    'b.nemovadrp',
    'b.nemovb',
    'b.nemovbl',
    'b.nemovldp',
    'b.nemovldr',
    'b.nemovmov',
    'b.nemovstr',
    'baddadd',
    'baddcmp',
    'baddmov',
    'baddstr',
    'badrpadd',
    'badrpadrp',
    'badrpldr',
    'badrpmov',
    'bblldr',
    'bblmov',
    'bcmpb.eq',
    'bcmpb.ne',
    'bcmpmov',
    'bladdadd',
    'bladdadrp',
    'bladdbl',
    'bladdcmp',
    'bladdldr',
    'bladdmov',
    'bladrpadd',
    'bladrpadrp',
    'bladrpldr',
    'bladrpmov',
    'blandcmp',
    'blandeor',
    'blbadd',
    'blbadrp',
    'blbbl',
    'blbcmp',
    'blbladrp',
    'blblbl',
    'blblcbnz',
    'blblcbz',
    'blbldp',
    'blbldr',
    'blblfmov',
    'blblldr',
    'blblmov',
    'blblstr',
    'blbmov',
    'blcbnzadrp',
    'blcbnzldp',
    'blcbnzldr',
    'blcbnzmov',
    'blcbzadd',
    'blcbzadrp',
    'blcbzbl',
    'blcbzcbz',
    'blcbzldp',
    'blcbzldr',
    'blcbzmov',
    'blcmnb.eq',
    'blcmpb.eq',
    'blcmpb.le',
    'blcmpb.ne',
    'blcmpccmp',
    'blcmpcset',
    'blcmpmov',
    'bldpadrp',
    'bldpldp',
    'bldpldr',
    'bldpmov',
    'bldradd',
    'bldradrp',
    'bldrand',
    'bldrb',
    'bldrbcmp',
    'bldrbl',
    'bldrcbnz',
    'bldrcbz',
    'bldrcmp',
    'bldrldp',
    'bldrldr',
    'bldrldrb',
    'bldrmov',
    'bldrstr',
    'blfmovfmov',
    'blfmovmov',
    'blldpadd',
    'blldpb',
    'blldpldp',
    'blldpldr',
    'blldpmov',
    'blldpret',
    'blldpstr',
    'blldradd',
    'blldradrp',
    'blldrb',
    'blldrbl',
    'blldrcbnz',
    'blldrcbz',
    'blldrcmp',
    'blldrldp',
    'blldrldr',
    'blldrmov',
    'blldrstr',
    'blmovadd',
    'blmovadrp',
    'blmovb',
    'blmovbl',
    'blmovcbnz',
    'blmovcbz',
    'blmovcmp',
    'blmovifmov',
    'blmovldp',
    'blmovldr',
    'blmovmov',
    'blmovstr',
    'blrldrldr',
    'blrldrmov',
    'blrmovldr',
    'blrmovmov',
    'blstpmov',
    'blstradd',
    'blstradrp',
    'blstrb',
    'blstrbl',
    'blstrcbz',
    'blstrldp',
    'blstrldr',
    'blstrmov',
    'bltbnzldr',
    'bltstb.eq',
    'bltstb.ne',
    'bmovadd',
    'bmovadrp',
    'bmovb',
    'bmovbl',
    'bmovcbz',
    'bmovcmp',
    'bmovldp',
    'bmovldr',
    'bmovmov',
    'bmovstr',
    'bnopb',
    'bnopldr',
    'bstpbl',
    'bstpstp',
    'bstrb',
    'bstrbl',
    'cbnzaddmov',
    'cbnzadrpadd',
    'cbnzadrpldr',
    'cbnzbldr',
    'cbnzblmov',
    'cbnzbmov',
    'cbnzldpadrp',
    'cbnzldpldp',
    'cbnzldpmov',
    'cbnzldradd',
    'cbnzldradrp',
    'cbnzldrbl',
    'cbnzldrcbnz',
    'cbnzldrcbz',
    'cbnzldrcmp',
    'cbnzldrldr',
    'cbnzldrmov',
    'cbnzmovb',
    'cbnzmovbl',
    'cbnzmovmov',
    'cbzaddadd',
    'cbzaddbl',
    'cbzaddldr',
    'cbzaddmov',
    'cbzadrpadd',
    'cbzadrpldr',
    'cbzadrpmov',
    'cbzblldr',
    'cbzblmov',
    'cbzbmov',
    'cbzcbzbl',
    'cbzcbzldr',
    'cbzcmpb.eq',
    'cbzcmpb.ne',
    'cbzldpadd',
    'cbzldpldp',
    'cbzldpmov',
    'cbzldradd',
    'cbzldradrp',
    'cbzldrbcbz',
    'cbzldrbl',
    'cbzldrcbnz',
    'cbzldrcbz',
    'cbzldrcmp',
    'cbzldrldp',
    'cbzldrldr',
    'cbzldrmov',
    'cbzldrstr',
    'cbzldrsub',
    'cbzmovadd',
    'cbzmovadrp',
    'cbzmovb',
    'cbzmovbl',
    'cbzmovldr',
    'cbzmovmov',
    'cbzmovstr',
    'cbzstpmov',
    'cbzstrmov',
    'ccmpb.eqmov',
    'ccmpb.neldr',
    'ccmpb.nemov',
    'cmnb.eqldr',
    'cmnb.nemov',
    'cmpaddcsel',
    'cmpb.eqadd',
    'cmpb.eqadrp',
    'cmpb.eqb',
    'cmpb.eqb.hi',
    'cmpb.eqb.ls',
    'cmpb.eqbl',
    'cmpb.eqcbz',
    'cmpb.eqcmp',
    'cmpb.eqldp',
    'cmpb.eqldr',
    'cmpb.eqldrb',
    'cmpb.eqmov',
    'cmpb.eqnop',
    'cmpb.eqstr',
    'cmpb.eqsub',
    'cmpb.geldr',
    'cmpb.gtcmp',
    'cmpb.gtldr',
    'cmpb.gtmov',
    'cmpb.hiadd',
    'cmpb.hiadrp',
    'cmpb.hicmp',
    'cmpb.hildr',
    'cmpb.himov',
    'cmpb.hsadd',
    'cmpb.hsldr',
    'cmpb.leadd',
    'cmpb.leadrp',
    'cmpb.leldr',
    'cmpb.lemov',
    'cmpb.lesub',
    'cmpb.loldr',
    'cmpb.lomov',
    'cmpb.lsadd',
    'cmpb.lsldr',
    'cmpb.lsmov',
    'cmpb.lsstrb',
    'cmpb.ltldr',
    'cmpb.neadd',
    'cmpb.neadrp',
    'cmpb.neb',
    'cmpb.nebl',
    'cmpb.necbz',
    'cmpb.necmp',
    'cmpb.neldp',
    'cmpb.neldr',
    'cmpb.neldrb',
    'cmpb.nemov',
    'cmpb.nestr',
    'cmpccmpb.eq',
    'cmpccmpb.ne',
    'cmpcselcmp',
    'cmpcsetand',
    'cmpcsetb',
    'cmpcsetcmp',
    'cmpmovccmp',
    'cmpmovcsel',
    'cmpmovcset',
    'cmpmovmov',
    'csetcmpcset',
    'eorandcmp',
    'fmovadrpadd',
    'fmovblmov',
    'fmovfmovfmov',
    'fmovfmovmov',
    'fmovldrmov',
    'fmovmovbl',
    'fmovmovmov',
    'ldarcbzadd',
    'ldpaddadd',
    'ldpaddadrp',
    'ldpaddb',
    'ldpaddldp',
    'ldpaddldr',
    'ldpaddmov',
    'ldpaddret',
    'ldpaddstr',
    'ldpadrpadd',
    'ldpadrpadrp',
    'ldpadrpldp',
    'ldpadrpldr',
    'ldpbadrp',
    'ldpbbl',
    'ldpbldp',
    'ldpbldr',
    'ldpbmov',
    'ldpcmpb.eq',
    'ldpldpadd',
    'ldpldpadrp',
    'ldpldpb',
    'ldpldpldp',
    'ldpldpldr',
    'ldpldpret',
    'ldpldpstr',
    'ldpldradd',
    'ldpldradrp',
    'ldpldrb',
    'ldpldrbl',
    'ldpldrldp',
    'ldpldrldr',
    'ldpldrmov',
    'ldpldrstr',
    'ldpmovb',
    'ldpmovbl',
    'ldpmovldp',
    'ldpmovldr',
    'ldpmovmov',
    'ldpretadd',
    'ldpretadrp',
    'ldpretbl',
    'ldpretcbz',
    'ldpretcmp',
    'ldpretldp',
    'ldpretldr',
    'ldpretmov',
    'ldpretstr',
    'ldpstpadd',
    'ldpstpldp',
    'ldpstpldr',
    'ldpstpmov',
    'ldpstpstr',
    'ldpstrbmov',
    'ldpstrldp',
    'ldpstrldr',
    'ldpstrmov',
    'ldraddadd',
    'ldraddadrp',
    'ldraddb',
    'ldraddbl',
    'ldraddbr',
    'ldraddcmp',
    'ldraddldp',
    'ldraddldr',
    'ldraddldrb',
    'ldraddmov',
    'ldraddret',
    'ldraddstp',
    'ldraddstr',
    'ldraddsub',
    'ldradrpadd',
    'ldradrpadrp',
    'ldradrpldp',
    'ldradrpldr',
    'ldradrpmov',
    'ldrandcmp',
    'ldrandstr',
    'ldrbadd',
    'ldrbadrp',
    'ldrbandcmp',
    'ldrbbl',
    'ldrbcbnzldr',
    'ldrbcbnzldrb',
    'ldrbcbnzmov',
    'ldrbcbzldr',
    'ldrbcbzmov',
    'ldrbcmp',
    'ldrbcmpb.eq',
    'ldrbcmpb.ne',
    'ldrbladd',
    'ldrbladrp',
    'ldrbland',
    'ldrblb',
    'ldrblbl',
    'ldrblcbnz',
    'ldrblcbz',
    'ldrblcmp',
    'ldrbldp',
    'ldrbldr',
    'ldrblldp',
    'ldrblldr',
    'ldrblmov',
    'ldrblrb',
    'ldrblrldr',
    'ldrblrmov',
    'ldrblstp',
    'ldrblstr',
    'ldrbmov',
    'ldrborrstrb',
    'ldrbsuband',
    'ldrcbnzadrp',
    'ldrcbnzb',
    'ldrcbnzldp',
    'ldrcbnzldr',
    'ldrcbnzmov',
    'ldrcbzadd',
    'ldrcbzadrp',
    'ldrcbzb',
    'ldrcbzbl',
    'ldrcbzcmp',
    'ldrcbzldp',
    'ldrcbzldr',
    'ldrcbzldrb',
    'ldrcbzmov',
    'ldrcbzstr',
    'ldrcmnb.eq',
    'ldrcmpb.eq',
    'ldrcmpb.ge',
    'ldrcmpb.gt',
    'ldrcmpb.hi',
    'ldrcmpb.hs',
    'ldrcmpb.le',
    'ldrcmpb.lo',
    'ldrcmpb.ls',
    'ldrcmpb.lt',
    'ldrcmpb.ne',
    'ldrcmpccmp',
    'ldrcmpcsel',
    'ldrcmpcset',
    'ldrhadradd',
    'ldrldpb',
    'ldrldpcmp',
    'ldrldpldp',
    'ldrldpldr',
    'ldrldpret',
    'ldrldradd',
    'ldrldradrp',
    'ldrldrand',
    'ldrldrb',
    'ldrldrband',
    'ldrldrbcbz',
    'ldrldrbcmp',
    'ldrldrbl',
    'ldrldrblr',
    'ldrldrcbnz',
    'ldrldrcbz',
    'ldrldrcmp',
    'ldrldrldp',
    'ldrldrldr',
    'ldrldrldrb',
    'ldrldrlsl',
    'ldrldrmov',
    'ldrldrorr',
    'ldrldrsbcmp',
    'ldrldrstr',
    'ldrldrsub',
    'ldrldrsubs',
    'ldrlsladd',
    'ldrlslldr',
    'ldrmovadd',
    'ldrmovadrp',
    'ldrmovb',
    'ldrmovbl',
    'ldrmovbr',
    'ldrmovcbz',
    'ldrmovcmp',
    'ldrmovldp',
    'ldrmovldr',
    'ldrmovlsl',
    'ldrmovmov',
    'ldrmovmovk',
    'ldrmovstp',
    'ldrmovstr',
    'ldrmovstrb',
    'ldrmovsub',
    'ldrorrstr',
    'ldrstpadd',
    'ldrstpadrp',
    'ldrstpldr',
    'ldrstpmov',
    'ldrstpstp',
    'ldrstpstr',
    'ldrstradd',
    'ldrstradrp',
    'ldrstrb',
    'ldrstrbl',
    'ldrstrcbnz',
    'ldrstrcbz',
    'ldrstrcmp',
    'ldrstrldp',
    'ldrstrldr',
    'ldrstrmov',
    'ldrstrstp',
    'ldrstrstr',
    'ldrstrstrb',
    'ldrsubadd',
    'ldrsubbl',
    'ldrsubcmp',
    'ldrsubldr',
    'ldrsubmov',
    'ldrsubsmov',
    'ldrsubstr',
    'lsladdldr',
    'lsladdlsl',
    'lslldradd',
    'movaddadd',
    'movaddadrp',
    'movaddb',
    'movaddbl',
    'movaddcmp',
    'movaddldr',
    'movaddmov',
    'movaddstp',
    'movaddstr',
    'movadrpadd',
    'movadrpadrp',
    'movadrpbl',
    'movadrpldr',
    'movadrpmov',
    'movb.neldp',
    'movb.neldr',
    'movb.nemov',
    'movbadd',
    'movbadrp',
    'movbbl',
    'movbcmp',
    'movbladd',
    'movbladrp',
    'movblb',
    'movblbl',
    'movblcbnz',
    'movblcbz',
    'movblcmn',
    'movblcmp',
    'movbldp',
    'movbldr',
    'movbldrb',
    'movblfmov',
    'movblldp',
    'movblldr',
    'movblldrb',
    'movblmov',
    'movblmovi',
    'movblrldr',
    'movblrmov',
    'movblstr',
    'movblsub',
    'movbltbnz',
    'movbltst',
    'movbmov',
    'movcbnzb',
    'movcbnzldr',
    'movcbnzmov',
    'movcbzadrp',
    'movcbzb',
    'movcbzbl',
    'movcbzldr',
    'movcbzmov',
    'movcbzstp',
    'movcbzstr',
    'movcmpb.eq',
    'movcmpb.gt',
    'movcmpb.hi',
    'movcmpb.le',
    'movcmpb.ls',
    'movcmpb.ne',
    'movcmpccmp',
    'movcmpcset',
    'movfmovfmov',
    'movfmovmov',
    'movkcmpb.eq',
    'movkmovkmovk',
    'movldpadd',
    'movldpadrp',
    'movldpb',
    'movldpldp',
    'movldpldr',
    'movldpmov',
    'movldpret',
    'movldpstp',
    'movldpstr',
    'movldradd',
    'movldradrp',
    'movldrb',
    'movldrbcmp',
    'movldrbl',
    'movldrblr',
    'movldrcbnz',
    'movldrcbz',
    'movldrcmp',
    'movldrldp',
    'movldrldr',
    'movldrmov',
    'movldrstp',
    'movldrstr',
    'movldrsub',
    'movlsladd',
    'movmovadd',
    'movmovadrp',
    'movmovand',
    'movmovb',
    'movmovbl',
    'movmovblr',
    'movmovcbnz',
    'movmovcbz',
    'movmovcmp',
    'movmovfmov',
    'movmovkcmp',
    'movmovkfmov',
    'movmovkmov',
    'movmovldp',
    'movmovldr',
    'movmovldrb',
    'movmovmov',
    'movmovmovk',
    'movmovnop',
    'movmovstp',
    'movmovstr',
    'movmovstrb',
    'movmovsub',
    'movnopldr',
    'movstpadd',
    'movstpadrp',
    'movstpbl',
    'movstpcbz',
    'movstpldr',
    'movstpmov',
    'movstpstp',
    'movstpstr',
    'movstradd',
    'movstradrp',
    'movstrb',
    'movstrbadd',
    'movstrbb',
    'movstrbl',
    'movstrbldr',
    'movstrbmov',
    'movstrcbz',
    'movstrcmp',
    'movstrldp',
    'movstrldr',
    'movstrmov',
    'movstrstp',
    'movstrstr',
    'movsubbl',
    'movsubcmp',
    'movsubmov',
    'nopbnop',
    'nopldrldr',
    'nopldrmov',
    'nopmovmov',
    'nopnopmov',
    'nopnopnop',
    'nopnopstp',
    'nopstpadrp',
    'nopstpmov',
    'orrstrldr',
    'retaddmov',
    'retadrpadd',
    'retadrpldr',
    'retblbl',
    'retblmov',
    'retldpadrp',
    'retldpldp',
    'retldradrp',
    'retldrldr',
    'retldrmov',
    'retmovadrp',
    'retmovb',
    'retmovbl',
    'retmovmov',
    'retmovret',
    'stpaddadd',
    'stpaddldr',
    'stpaddmov',
    'stpaddstp',
    'stpaddstr',
    'stpadrpadd',
    'stpadrpadrp',
    'stpadrpldr',
    'stpadrpmov',
    'stpadrpstp',
    'stpbladrp',
    'stpblldr',
    'stpblmov',
    'stpcbzmov',
    'stpldpstp',
    'stpldrldr',
    'stpldrstp',
    'stpldrstr',
    'stpmovadd',
    'stpmovadrp',
    'stpmovbl',
    'stpmovcbz',
    'stpmovldp',
    'stpmovldr',
    'stpmovmov',
    'stpmovstp',
    'stpmovstr',
    'stpstpbl',
    'stpstpldr',
    'stpstpmov',
    'stpstpstp',
    'stpstpstr',
    'stpstrbl',
    'stpstrcmp',
    'stpstrldr',
    'stpstrstp',
    'stpstrstr',
    'straddadd',
    'straddbl',
    'straddcmp',
    'straddldr',
    'straddldrb',
    'straddmov',
    'straddstr',
    'stradrpadd',
    'stradrpldr',
    'stradrpstp',
    'stradrpstr',
    'strbadd',
    'strbaddcmp',
    'strbaddmov',
    'strbadrp',
    'strbbl',
    'strbbmov',
    'strbcmp',
    'strbcmpb.eq',
    'strbladd',
    'strbladrp',
    'strblb',
    'strblbl',
    'strblcbz',
    'strbldp',
    'strbldr',
    'strbldrb',
    'strbldrldr',
    'strblldp',
    'strblldr',
    'strblmov',
    'strblstr',
    'strbmov',
    'strbstr',
    'strbstrbstrb',
    'strcbnzldr',
    'strcbnzmov',
    'strcbzadd',
    'strcbzbl',
    'strcbzldr',
    'strcbzmov',
    'strcmpb.eq',
    'strcmpb.gt',
    'strcmpb.le',
    'strcmpb.ne',
    'strldpldp',
    'strldpldr',
    'strldpmov',
    'strldpret',
    'strldpstr',
    'strldradd',
    'strldrb',
    'strldrbcmp',
    'strldrbl',
    'strldrcbnz',
    'strldrcbz',
    'strldrcmp',
    'strldrldp',
    'strldrldr',
    'strldrldrb',
    'strldrmov',
    'strldrstp',
    'strldrstr',
    'strmovadd',
    'strmovadrp',
    'strmovb',
    'strmovbl',
    'strmovcbz',
    'strmovcmp',
    'strmovldp',
    'strmovldr',
    'strmovmov',
    'strmovstp',
    'strmovstr',
    'strmovstrb',
    'strstpbl',
    'strstpstp',
    'strstpstr',
    'strstradd',
    'strstrb',
    'strstrbl',
    'strstrbldr',
    'strstrcbz',
    'strstrcmp',
    'strstrldp',
    'strstrldr',
    'strstrmov',
    'strstrstp',
    'strstrstr',
    'strstrstrb',
    'subaddadd',
    'subaddmov',
    'subadrpldr',
    'subandcmp',
    'subblldr',
    'subcmpb.hi',
    'subcmpb.ls',
    'submovadd',
    'submovbl',
    'submovmov',
    'subsmovb.ne',
    'substpadd',
    'substrcmp',
    'substrldr',
    'substrstr',
    'tstb.eqldr',
    'tstb.eqmov',
    'tstb.neldr',
    'tstb.nemov'
}

# 1k most common 3-grams for ARM32
MOST_COMMON_3GRAMS_ARM32 = {
    'adc.sadcorr',
    'adcorr.sbiceq',
    'adcsubhscmp',
    'adctstsubeq',
    'add.sadccmp',
    'add.sadcorr.s',
    'add.sbgtadd',
    'add.sbleadd',
    'addaddadd',
    'addaddb',
    'addaddbl',
    'addaddcmp',
    'addaddldr',
    'addaddldrb',
    'addaddlsl',
    'addaddmov',
    'addaddpop',
    'addaddstr',
    'addaddsub',
    'addbbl',
    'addbcmp',
    'addbeqldr',
    'addbeqmov',
    'addbladd',
    'addblb',
    'addblbl',
    'addblcmp',
    'addbldr',
    'addblldr',
    'addblldrb',
    'addblmov',
    'addblstr',
    'addblsub.s',
    'addbmov',
    'addbneldr',
    'addcmpadd',
    'addcmpbeq',
    'addcmpbhi',
    'addcmpbhs',
    'addcmpbls',
    'addcmpbne',
    'addcmpldr',
    'addcmpmov',
    'addcmpmovhi',
    'addcmpstr',
    'addeqsubsub.s',
    'addgeorrgepopge',
    'addldmstm',
    'addldradd',
    'addldrb',
    'addldrbadd',
    'addldrbcmp',
    'addldrbeq',
    'addldrbl',
    'addldrbx',
    'addldrcmp',
    'addldrdmov',
    'addldrldr',
    'addldrmov',
    'addldrpop',
    'addldrstr',
    'addldrsub',
    'addlsbb',
    'addlsladd',
    'addlslmov',
    'addmovadd',
    'addmovb',
    'addmovbl',
    'addmovblx',
    'addmovcmp',
    'addmovldr',
    'addmovmov',
    'addmovstm',
    'addmovstr',
    'addmovstrb',
    'addmovstrd',
    'addmvnmov',
    'addpopadd',
    'addpopb',
    'addpopbl',
    'addpopbx',
    'addpopcmp',
    'addpopldr',
    'addpopmov',
    'addpushldr',
    'addrsblelsl',
    'addrsblsl',
    'addrsblsr',
    'addstmldm',
    'addstmldr',
    'addstmmov',
    'addstradd',
    'addstrb',
    'addstrbeq',
    'addstrbl',
    'addstrcmp',
    'addstrdldrd',
    'addstrldr',
    'addstrldrb',
    'addstrmov',
    'addstrpop',
    'addstrstr',
    'addsubadd',
    'addsubbl',
    'addsubcmp',
    'addsubldr',
    'addsubmov',
    'addsubstr',
    'adraddldr',
    'andandcmp',
    'andcmpbeq',
    'andcmpbne',
    'andeqandeqandeq',
    'andlsl.sadc',
    'andorrorr',
    'andstrldr',
    'baddadd',
    'baddcmp',
    'baddmov',
    'baddrsble',
    'bbb',
    'bblb',
    'bblbl',
    'bbldr',
    'bblldr',
    'bblmov',
    'bbmov',
    'bcmpbeq',
    'bcmpbne',
    'bcmpmov',
    'beqaddadd',
    'beqaddcmp',
    'beqaddldr',
    'beqaddmov',
    'beqaddpop',
    'beqaddstr',
    'beqblbl',
    'beqblcmp',
    'beqbldr',
    'beqblldr',
    'beqblmov',
    'beqbmov',
    'beqcmpbeq',
    'beqcmpbne',
    'beqcmpmov',
    'beqcmpmoveq',
    'beqcmpmovne',
    'beqldradd',
    'beqldrb',
    'beqldrbcmp',
    'beqldrbl',
    'beqldrcmp',
    'beqldrldr',
    'beqldrldrb',
    'beqldrmov',
    'beqldrstr',
    'beqldrsub',
    'beqmovadd',
    'beqmovb',
    'beqmovbl',
    'beqmovldr',
    'beqmovmov',
    'beqmovpop',
    'beqmovstr',
    'beqstrldr',
    'beqstrstr',
    'beqsubcmp',
    'beqsubmov',
    'bgeadd.sbgt',
    'bgeadd.sble',
    'bgeldradd',
    'bgeldrldr',
    'bgtaddrsb',
    'bgtldrldr',
    'bhicmpbeq',
    'bhildrcmp',
    'bhildrldr',
    'bhsaddadd',
    'bhsldrldr',
    'biccmpbne',
    'biceqpoprsb',
    'bladdadd',
    'bladdbl',
    'bladdcmp',
    'bladdldr',
    'bladdmov',
    'bladdpop',
    'bladdstr',
    'blbadd',
    'blbbl',
    'blbcmp',
    'blbladd',
    'blblb',
    'blblbl',
    'blblcmp',
    'blbldr',
    'blblldr',
    'blblmov',
    'blblstr',
    'blblstrd',
    'blblsub.s',
    'blbmov',
    'blcmnbeq',
    'blcmpadd',
    'blcmpbeq',
    'blcmpblt',
    'blcmpbne',
    'blcmpclz',
    'blcmpldr',
    'blcmpldrne',
    'blcmpmov',
    'blcmpmoveq',
    'blcmpmovne',
    'blcmppopeq',
    'blcmppopne',
    'blcmpstr',
    'bldradd',
    'bldrb',
    'bldrbcmp',
    'bldrbl',
    'bldrcmp',
    'bldrldr',
    'bldrldrb',
    'bldrlsl',
    'bldrmov',
    'bldrstr',
    'bldrsub',
    'bleaddrsb',
    'bleldradd',
    'bleldrldr',
    'bleldrmov',
    'blemovmov',
    'blldradd',
    'blldrb',
    'blldrbcmp',
    'blldrbl',
    'blldrcmp',
    'blldrdbl',
    'blldrdmov',
    'blldrdstrd',
    'blldrldr',
    'blldrldrb',
    'blldrmov',
    'blldrmvn',
    'blldrpop',
    'blldrstr',
    'blldrsub',
    'blmovadd',
    'blmovb',
    'blmovbl',
    'blmovcmp',
    'blmoveor',
    'blmovldr',
    'blmovmov',
    'blmovpop',
    'blmovstr',
    'blmovstrb',
    'blmovsub',
    'blmvnmov',
    'blpopb',
    'blsldradd',
    'blsldrcmp',
    'blsldrldr',
    'blstradd',
    'blstrb',
    'blstrbl',
    'blstrdldr',
    'blstrdmov',
    'blstrldr',
    'blstrmov',
    'blstrpop',
    'blstrstr',
    'blsub.sbeq',
    'blsub.sbne',
    'blsub.smovne',
    'blsub.sstr',
    'blsubmov',
    'bltldrldr',
    'blxbldr',
    'blxcmpbne',
    'blxldradd',
    'blxldrcmp',
    'blxldrldr',
    'blxldrmov',
    'blxmovmov',
    'bmovadd',
    'bmovb',
    'bmovbl',
    'bmovcmp',
    'bmovldr',
    'bmovmov',
    'bmovstr',
    'bneaddadd',
    'bneaddcmp',
    'bneaddldr',
    'bneaddmov',
    'bneaddpop',
    'bneaddstr',
    'bnebcmp',
    'bnebldr',
    'bneblldr',
    'bneblmov',
    'bnebmov',
    'bnecmpbeq',
    'bnecmpbne',
    'bneeorand',
    'bneldradd',
    'bneldrb',
    'bneldrbcmp',
    'bneldrbl',
    'bneldrcmp',
    'bneldrldr',
    'bneldrldrb',
    'bneldrmov',
    'bneldrstr',
    'bnemovadd',
    'bnemovb',
    'bnemovbl',
    'bnemovldr',
    'bnemovmov',
    'bnemovpop',
    'bnemovstr',
    'bneorr.sbne',
    'bstrldr',
    'bsubcmp',
    'bxeqpushmov',
    'bxldradd',
    'bxldrldr',
    'bxmovbx',
    'clzaddeqsub',
    'clzlsrmoveq',
    'cmnbeqcmp',
    'cmnbeqldr',
    'cmnbneldr',
    'cmpadcsubhs',
    'cmpaddadd',
    'cmpaddbeq',
    'cmpaddbne',
    'cmpaddldr',
    'cmpaddlsb',
    'cmpaddmov',
    'cmpaddstr',
    'cmpbeqadd',
    'cmpbeqb',
    'cmpbeqbl',
    'cmpbeqcmp',
    'cmpbeqldm',
    'cmpbeqldr',
    'cmpbeqldrb',
    'cmpbeqldrd',
    'cmpbeqmov',
    'cmpbeqstr',
    'cmpbeqsub',
    'cmpbgeldr',
    'cmpbgtcmp',
    'cmpbgtldr',
    'cmpbhicmp',
    'cmpbhildr',
    'cmpbhimov',
    'cmpbhsadd',
    'cmpbhsldr',
    'cmpbleldr',
    'cmpblemov',
    'cmpblocmp',
    'cmpbloldr',
    'cmpblscmp',
    'cmpblsldr',
    'cmpblsmov',
    'cmpbltcmp',
    'cmpbltldr',
    'cmpbltmov',
    'cmpbneadd',
    'cmpbneb',
    'cmpbnebl',
    'cmpbnecmp',
    'cmpbneldr',
    'cmpbneldrb',
    'cmpbneldrd',
    'cmpbnemov',
    'cmpbnepop',
    'cmpbnestr',
    'cmpbnesub',
    'cmpclzlsr',
    'cmpcmpeqbeq',
    'cmpcmpeqbne',
    'cmpcmpnebeq',
    'cmpcmpnebne',
    'cmpcmpnemov',
    'cmpcmpnemoveq',
    'cmpldradd',
    'cmpldrbeq',
    'cmpldrbne',
    'cmpldrldr',
    'cmpldrmov',
    'cmpldrnemov',
    'cmpldrstr',
    'cmplsr.seqadc.s',
    'cmpmovbeq',
    'cmpmovbne',
    'cmpmoveqandne',
    'cmpmoveqbeq',
    'cmpmoveqmoveq',
    'cmpmoveqmovne',
    'cmpmovhistrbhi',
    'cmpmovmov',
    'cmpmovneandeq',
    'cmpmovnebeq',
    'cmpmovnebne',
    'cmpmovnemoveq',
    'cmpmovnemovne',
    'cmpmovstr',
    'cmpnemoveqmovne',
    'cmppopeqbl',
    'cmppopeqldr',
    'cmppopeqmov',
    'cmppopneldr',
    'cmpstrbeq',
    'cmpstrbne',
    'cmpstrstr',
    'cmpstrstrb',
    'cmpsubbeq',
    'eor.smovbne',
    'eorandcmp',
    'eorandeor',
    'eoreoreor',
    'ldmaddmov',
    'ldmaddstm',
    'ldmldrbl',
    'ldmmovstm',
    'ldmmovstr',
    'ldmstmadd',
    'ldmstmldm',
    'ldmstmldr',
    'ldmstmmov',
    'ldradd.sadc',
    'ldraddadd',
    'ldraddb',
    'ldraddbl',
    'ldraddbx',
    'ldraddcmp',
    'ldraddldr',
    'ldraddldrb',
    'ldraddlsl',
    'ldraddmov',
    'ldraddpop',
    'ldraddpush',
    'ldraddstr',
    'ldraddsub',
    'ldrandcmp',
    'ldrandldr',
    'ldrbadd',
    'ldrbaddcmp',
    'ldrbandand',
    'ldrbandcmp',
    'ldrbbl',
    'ldrbcmp',
    'ldrbcmpbeq',
    'ldrbcmpbne',
    'ldrbcmpcmpne',
    'ldrbeqcmp',
    'ldrbeqldr',
    'ldrbladd',
    'ldrblb',
    'ldrblbl',
    'ldrblcmp',
    'ldrbldr',
    'ldrbldrborr',
    'ldrbldrcmp',
    'ldrblldr',
    'ldrblldrd',
    'ldrblmov',
    'ldrblstr',
    'ldrblsub.s',
    'ldrblxb',
    'ldrblxldr',
    'ldrblxmov',
    'ldrbmov',
    'ldrbmovcmp',
    'ldrbmovldr',
    'ldrborrldrb',
    'ldrbstrbldr',
    'ldrbsubcmp',
    'ldrbtstbne',
    'ldrcmnbeq',
    'ldrcmpadd',
    'ldrcmpbeq',
    'ldrcmpbge',
    'ldrcmpbgt',
    'ldrcmpbhi',
    'ldrcmpbhs',
    'ldrcmpble',
    'ldrcmpblo',
    'ldrcmpbls',
    'ldrcmpblt',
    'ldrcmpbne',
    'ldrcmpbxeq',
    'ldrcmpcmpeq',
    'ldrcmpcmpne',
    'ldrcmpldr',
    'ldrcmpldrne',
    'ldrcmpmov',
    'ldrcmpmoveq',
    'ldrcmpmovne',
    'ldrcmppopeq',
    'ldrcmpsbc.s',
    'ldrcmpstr',
    'ldrcmpsub',
    'ldrdaddstrd',
    'ldrdblbl',
    'ldrdblcmp',
    'ldrdblldr',
    'ldrdblldrd',
    'ldrdblmov',
    'ldrdldrdbl',
    'ldrdldrdmov',
    'ldrdldrmov',
    'ldrdldrstrd',
    'ldrdmovbl',
    'ldrdmovmov',
    'ldrdmovstrd',
    'ldrdstrdldr',
    'ldrdstrdldrd',
    'ldrdstrdmov',
    'ldreor.smov',
    'ldrldradd',
    'ldrldradd.s',
    'ldrldrand',
    'ldrldrb',
    'ldrldrband',
    'ldrldrbcmp',
    'ldrldrbeq',
    'ldrldrbic',
    'ldrldrbl',
    'ldrldrblx',
    'ldrldrbmov',
    'ldrldrcmp',
    'ldrldreor.s',
    'ldrldrldr',
    'ldrldrldrb',
    'ldrldrldrd',
    'ldrldrlsl',
    'ldrldrmov',
    'ldrldrmul',
    'ldrldrmvn',
    'ldrldrorr',
    'ldrldrpop',
    'ldrldrpush',
    'ldrldrsbcmp',
    'ldrldrstr',
    'ldrldrstrd',
    'ldrldrsub',
    'ldrldrsub.s',
    'ldrlsladd',
    'ldrlslldr',
    'ldrlsllsr',
    'ldrmovadd',
    'ldrmovb',
    'ldrmovbeq',
    'ldrmovbic',
    'ldrmovbl',
    'ldrmovblx',
    'ldrmovcmp',
    'ldrmovldr',
    'ldrmovldrb',
    'ldrmovldrd',
    'ldrmovlsl',
    'ldrmovmov',
    'ldrmovpop',
    'ldrmovstr',
    'ldrmovstrb',
    'ldrmovstrd',
    'ldrmovsub',
    'ldrmvnadd',
    'ldrnemovmov',
    'ldrorrldr',
    'ldrorrstr',
    'ldrpopadd',
    'ldrpopldr',
    'ldrpopmov',
    'ldrpushadd',
    'ldrpushcmp',
    'ldrpushldr',
    'ldrpushmov',
    'ldrstmldr',
    'ldrstmmov',
    'ldrstradd',
    'ldrstrb',
    'ldrstrbeq',
    'ldrstrbl',
    'ldrstrcmp',
    'ldrstrdldr',
    'ldrstrldr',
    'ldrstrmov',
    'ldrstrstr',
    'ldrstrsub',
    'ldrsub.smovne',
    'ldrsubadd',
    'ldrsubbl',
    'ldrsubcmp',
    'ldrsubldr',
    'ldrsubmov',
    'ldrsubstr',
    'ldrsubsub',
    'ldrsubsub.s',
    'ldrtstbeq',
    'ldrtstbne',
    'lsl.sadc.sadc',
    'lsl.sadctst',
    'lsladdadd',
    'lsladdldr',
    'lsladdlsl',
    'lslldradd',
    'lsllesub.saddge',
    'lsllsrb',
    'lsllsrcmp',
    'lsllsrldr',
    'lsllsrorr',
    'lslmovldr',
    'lslorrlelslle',
    'lslorrlsl',
    'lslstrldr',
    'lsr.seqadc.sadc',
    'lsrbadd',
    'lsrcmpbne',
    'lsrldradd',
    'lsrmoveqcmp',
    'lsrmovpop',
    'lsrorrand',
    'lsrorrlsr',
    'lsrorrmov',
    'lsrorrorr',
    'lsrstrldr',
    'movaddadd',
    'movaddb',
    'movaddbl',
    'movaddcmp',
    'movaddldr',
    'movaddmov',
    'movaddpop',
    'movaddstmib',
    'movaddstr',
    'movaddstrb',
    'movbadd',
    'movbbl',
    'movbcmp',
    'movbeqbl',
    'movbeqcmp',
    'movbeqldr',
    'movbeqmov',
    'movbladd',
    'movblb',
    'movblbl',
    'movblcmn',
    'movblcmp',
    'movbldr',
    'movbldrb',
    'movblldr',
    'movblldrb',
    'movblldrd',
    'movblmov',
    'movblmvn',
    'movblpop',
    'movblstr',
    'movblstrd',
    'movblsub',
    'movblsub.s',
    'movblxcmp',
    'movblxldr',
    'movblxmov',
    'movbmov',
    'movbneadd',
    'movbneldr',
    'movbnemov',
    'movbsub',
    'movcmpadd',
    'movcmpbeq',
    'movcmpbne',
    'movcmpldr',
    'movcmpldrne',
    'movcmpmov',
    'movcmpstr',
    'moveorand',
    'moveqandnecmp',
    'moveqbeqldr',
    'moveqbeqmov',
    'moveqclzaddeq',
    'moveqcmppopeq',
    'moveqmoveqclz',
    'movhistrbhiadd',
    'movldmadd',
    'movldradd',
    'movldrb',
    'movldrbcmp',
    'movldrbl',
    'movldrblx',
    'movldrcmp',
    'movldrdbl',
    'movldrdmov',
    'movldrldr',
    'movldrmov',
    'movldrstr',
    'movldrstrd',
    'movldrsub',
    'movlsladd',
    'movmovadd',
    'movmovb',
    'movmovbeq',
    'movmovbl',
    'movmovblx',
    'movmovbne',
    'movmovcmp',
    'movmovldm',
    'movmovldr',
    'movmovldrb',
    'movmovldrd',
    'movmovmov',
    'movmovpop',
    'movmovstm',
    'movmovstr',
    'movmovstrb',
    'movmovstrd',
    'movmovsub',
    'movmvnmov',
    'movmvnstr',
    'movneandeqcmp',
    'movpopb',
    'movpopbx',
    'movpopcmp',
    'movpopldr',
    'movpoplsr',
    'movpopmov',
    'movpoporr',
    'movstmbl',
    'movstmldm',
    'movstmldr',
    'movstmmov',
    'movstradd',
    'movstrb',
    'movstrbb',
    'movstrbblx',
    'movstrbeq',
    'movstrbl',
    'movstrbldr',
    'movstrbmov',
    'movstrbstrb',
    'movstrdbl',
    'movstrdldr',
    'movstrdldrd',
    'movstrdmov',
    'movstrdstr',
    'movstrdstrd',
    'movstrldm',
    'movstrldr',
    'movstrmov',
    'movstrpop',
    'movstrstm',
    'movstrstr',
    'movstrstrb',
    'movstrstrd',
    'movsubadd',
    'movsubbl',
    'movsubldr',
    'movsubmov',
    'movsubpop',
    'movsubstr',
    'mvnbldr',
    'mvnmovbl',
    'mvnmovmov',
    'mvnstrldr',
    'mvnstrstr',
    'mvnsub.sbge',
    'orr.sbiceqpop',
    'orrgepopgemvn',
    'orrldrborr',
    'orrldrstr',
    'orrlelsllesub.s',
    'orrmovpop',
    'orrorrlsl',
    'orrorrmov',
    'orrorrpop',
    'orrpoprsb',
    'orrstrldr',
    'popaddadd',
    'popaddbx',
    'popaddmov',
    'popandorr',
    'popbadd',
    'popbbl',
    'popblbl',
    'popbldr',
    'popblldr',
    'popblmov',
    'popbmov',
    'popbxldr',
    'popbxmov',
    'popcmpbeq',
    'popcmpbne',
    'popgemvnsub.s',
    'popldradd',
    'popldrcmp',
    'popldrldr',
    'popldrmov',
    'poplsrmov',
    'popmovb',
    'popmovbl',
    'popmovmov',
    'popmovpop',
    'poporrorr',
    'poprsbrsb',
    'pushaddldr',
    'pushaddsub',
    'pushldradd',
    'pushldrcmp',
    'pushldrldr',
    'pushldrmov',
    'pushldrsub',
    'pushmovbl',
    'pushmovldr',
    'pushmovmov',
    'pushmovsub',
    'pushsub.sbeq',
    'pushsub.ssub',
    'pushsubadd',
    'pushsubbl',
    'pushsubldr',
    'pushsubmov',
    'pushsubstr',
    'rsblelslorrle',
    'rsblsllsr',
    'rsblsrorr',
    'rsbrsblsr',
    'stmaddmov',
    'stmblldr',
    'stmldmadd',
    'stmldmmov',
    'stmldmstm',
    'stmldradd',
    'stmldrldr',
    'stmldrmov',
    'stmmovldr',
    'stmmovmov',
    'straddadd',
    'straddbl',
    'straddcmp',
    'straddldr',
    'straddmov',
    'straddpop',
    'straddstr',
    'straddsub',
    'strbadd',
    'strbbeqldr',
    'strbbl',
    'strbbldr',
    'strbblxldr',
    'strbbmov',
    'strbcmp',
    'strbeqadd',
    'strbeqbl',
    'strbeqcmp',
    'strbeqldr',
    'strbeqmov',
    'strbeqstr',
    'strbhiaddcmp',
    'strbladd',
    'strblb',
    'strblbl',
    'strblcmp',
    'strbldr',
    'strbldradd',
    'strbldrb',
    'strbldrcmp',
    'strbldrldr',
    'strbldrmov',
    'strblldr',
    'strblmov',
    'strblstr',
    'strblsub.s',
    'strbmov',
    'strbmovmov',
    'strbneldr',
    'strbnemov',
    'strbstrbbeq',
    'strbstrbstrb',
    'strcmpbeq',
    'strcmpbne',
    'strdbldr',
    'strdblldr',
    'strdblmov',
    'strdldrbl',
    'strdldrdbl',
    'strdldrdmov',
    'strdldrdstrd',
    'strdldrldr',
    'strdldrmov',
    'strdldrstr',
    'strdmovbl',
    'strdmovmov',
    'strdmovstr',
    'strdstrdbl',
    'strdstrdldr',
    'strdstrdmov',
    'strdstrdstrd',
    'strdstrmov',
    'strdstrstr',
    'strldmadd',
    'strldmstm',
    'strldradd',
    'strldrand',
    'strldrb',
    'strldrbcmp',
    'strldrbl',
    'strldrcmp',
    'strldrdmov',
    'strldrldr',
    'strldrldrb',
    'strldrlsl',
    'strldrmov',
    'strldrstr',
    'strldrsub',
    'strmovadd',
    'strmovb',
    'strmovbeq',
    'strmovbl',
    'strmovldr',
    'strmovmov',
    'strmovpop',
    'strmovstm',
    'strmovstr',
    'strmovstrb',
    'strpopldr',
    'strpopmov',
    'strstradd',
    'strstrb',
    'strstrbeq',
    'strstrbl',
    'strstrbldr',
    'strstrbne',
    'strstrbstr',
    'strstrbstrb',
    'strstrdbl',
    'strstrldm',
    'strstrldr',
    'strstrldrd',
    'strstrmov',
    'strstrpop',
    'strstrstr',
    'strstrstrb',
    'strstrstrd',
    'strsubstr',
    'sub.saddgeorrge',
    'sub.sbeqbl',
    'sub.sbeqcmp',
    'sub.sbeqldr',
    'sub.sbeqmov',
    'sub.sbgeadd.s',
    'sub.sbneldr',
    'sub.sbnemov',
    'sub.sldrstr',
    'sub.smovneb',
    'sub.smovnecmp',
    'sub.ssubbeq',
    'subaddadd',
    'subaddcmp',
    'subaddldr',
    'subaddmov',
    'subaddstr',
    'subbeqmov',
    'subblldr',
    'subblmov',
    'subclzlsr',
    'subcmpaddls',
    'subcmpbeq',
    'subcmpbhi',
    'subcmpbls',
    'subcmpldr',
    'subcmpmov',
    'subcmpstr',
    'subeqbeqorr',
    'subhscmpadc',
    'subldradd',
    'subldrldr',
    'subldrmov',
    'subldrstr',
    'submovadd',
    'submovbl',
    'submovldr',
    'submovmov',
    'submovstr',
    'substrldr',
    'substrmov',
    'substrstr',
    'subsub.sbge',
    'subsubcmp',
    'subsubldr',
    'subsubmov',
    'teqbneorr.s',
    'teqmoveqmoveq',
    'tstbeqldr',
    'tstbneldr',
    'tstsubeqbeq'
}

```

`idaclu/plugins/group_8/plugin_1.py`:

```py
import collections
import json
import math
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('Flattened Functions')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    flattened_funcs = []
    func_count = 0

    for func_addr in func_gen():
        func_score = helpers.calc_flattening_score(func_addr)
        flattened_funcs.append((func_addr, func_score))
        func_count += 1

    flattened_funcs = sorted(flattened_funcs, key=lambda x: x[1])

    bound = max(min(math.ceil(((func_count * 10) / 100)), 1000), 10)

    for func_addr, func_score in list(reversed(flattened_funcs))[:bound]:
        score_fmt = str(round(func_score, 2))
        report['data'][score_fmt].append(func_addr)
        report['stat'][score_fmt] += 1

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/plugin_2.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('Complex Functions')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z\: ]+)(-?\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))

def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        func_score = helpers.calc_cyclomatic_complexity(func_addr)
        
        xref_key = "score: {}".format(func_score)
        
        report['data'][xref_key].append(func_addr)
        report['stat'][xref_key] += 1
        
    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/plugin_3.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('Orphan Blocks')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z\: ]+)(-?\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))

def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        orphs_num = helpers.get_orph_count(func_addr)
        
        orph_key = "blocks: {}".format(orphs_num)
        
        report['data'][orph_key].append(func_addr)
        report['stat'][orph_key] += 1
        
    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/plugin_4.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('Large Basic Blocks')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = [] 


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z/\: ]+)(\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))

def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        instr_num = helpers.calc_average_instructions_per_block(func_addr)

        instr_key = "instr/block: {}".format(round(instr_num))
        
        report['data'][instr_key].append(func_addr)
        report['stat'][instr_key] += 1
        
    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/plugin_5.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('Uncommon Instruction Sequences')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, float(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z/\: ]+)(\d\.\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))

def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        unique_score = helpers.calc_uncommon_instruction_sequences_score(func_addr)

        unique_key = "score: {}".format(round(unique_score, 2))
        
        report['data'][unique_key].append(func_addr)
        report['stat'][unique_key] += 1
        
    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/plugin_6.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('XOR Const Decryption Loops')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        is_xor = helpers.contains_xor_decryption_loop(func_addr)
        if is_xor:
            report['data']['xor'].append(func_addr)
            report['stat']['xor'] += 1

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_8/plugin_7.py`:

```py
import collections
import json
import re
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n
#
import helpers


SCRIPT_NAME = i18n('Complex Arithmetic Expressions')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = []


def sort_nat(input_dict):
    def fun(k, v):
        return [k, int(v)]

    def cmp_key(t):
        return fun(*re.match(r'([a-zA-Z\: ]+)(\d+)', t[0]).groups())

    return collections.OrderedDict(sorted(input_dict.items(), key=cmp_key, reverse=True))


def get_data(func_gen=None, env_desc=None, plug_params=None):

    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    for func_addr in func_gen():
        compl_score = helpers.calculate_complex_arithmetic_expressions(func_addr)

        compl_key = "score: {}".format(compl_score)

        report['data'][compl_key].append(func_addr)
        report['stat'][compl_key] += 1

    report['data'] = sort_nat(report['data'])
    report['stat'] = sort_nat(report['stat'])

    return report if __name__ == '__main__' else report['data']


def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/plugins/group_9/__init__.py`:

```py
from idaclu.qt_utils import i18n

PLUGIN_GROUP_NAME = i18n('Yara Rules')

```

`idaclu/plugins/group_9/plugin_1.py`:

```py
import collections
import json
import os
import re
#
import yara
#
import idaapi
import idautils
#
from idaclu import ida_shims
from idaclu.qt_utils import i18n


SCRIPT_NAME = i18n('Rule Match')
SCRIPT_TYPE = 'func'
SCRIPT_VIEW = 'tree'
SCRIPT_ARGS = [('filePath', 'file_path', 'path to folder with .yar files')]


def get_func_bytes(func_addr):
    func_bytes = b''
    for beg, end in idautils.Chunks(func_addr):
        fb = ida_shims.get_bytes(beg, end-beg)
        func_bytes += fb
    return func_bytes
    
def order_item_len(input_dict):
    def get_len(val):
        fs = val[1]
        if isinstance(fs, int):
            return fs
        elif isinstance(fs, list):
            return len(fs)

    return collections.OrderedDict(
        sorted(input_dict.items(), key=get_len, reverse=True)
    )

def get_data(func_gen=None, env_desc=None, plug_params=None):
    report = {
        'data': collections.defaultdict(list),
        'stat': collections.defaultdict(int)
    }

    dist_path = plug_params['file_path']
    yar_paths = [
        os.path.join(dist_path, f) 
        for f in os.listdir(dist_path) 
        if os.path.isfile(os.path.join(dist_path, f)) and f.endswith('.yar')
    ]
    yara_rules = {}

    for p in yar_paths:
        try:
            n = os.path.basename(p)
            yara_rules[n] = yara.compile(filepath=p)
        except yara.Error as e:
            ida_shims.msg("Error compiling rule '{}': {}".format(n, e))

    for func_addr in func_gen():
        func_data = get_func_bytes(func_addr)
        for _, rule_data in yara_rules.items():
            match = rule_data.match(data=func_data)
            for rule_name in match:
                report['data'][rule_name].append(func_addr)
                report['stat'][rule_name] += 1

    report['data'] = order_item_len(report['data'])
    report['stat'] = order_item_len(report['stat'])

    return report if __name__ == '__main__' else report['data']

def debug():
    data_obj = get_data(func_gen=idautils.Functions)
    ida_shims.msg(json.dumps(data_obj, indent=4))

if __name__ == '__main__':
    debug()

```

`idaclu/qt_shims.py`:

```py
# Shim file to support PySide v1.x and PyQt v5.x
# Documentation provided by Qt and Riverbank Computing Ltd.:
#  - https://srinikom.github.io/pyside-docs/
#  - https://doc.qt.io/qtforpython-5/
# Inspired by the gist of Willi Ballenthin:
#  - https://gist.github.com/williballenthin/277eedca569043ef0984


is_ida = True
try:
    import idaapi
except ImportError:
    is_ida = False


def get_DescendingOrder():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.Qt.SortOrder.DescendingOrder
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.Qt.DescendingOrder

def get_Signal():
    if is_ida and is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.Signal
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.pyqtSignal

def get_QAbstractItemModel():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QAbstractItemModel
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QAbstractItemModel

def get_QAbstractItemView():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QAbstractItemView
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QAbstractItemView

def get_QAction():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QAction
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QAction

def get_QApplication():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QApplication
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QApplication

def get_QBrush():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QBrush
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QBrush

def get_QByteArray():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QByteArray
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QByteArray

def get_QCheckBox():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QCheckBox
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QCheckBox

def get_QColor():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QColor
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QColor

def get_QComboBox():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QComboBox
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QComboBox

def get_QCompleter():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QCompleter
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QCompleter

def get_QCoreApplication():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QCoreApplication
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QCoreApplication

def get_QCursor():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QCursor
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QCursor

def get_QDialog():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QDialog
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QDialog

def get_QEvent():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QEvent
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QEvent

def get_QFont():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QFont
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QFont

def get_QFrame():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QFrame
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QFrame

def get_QGroupBox():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QGroupBox
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QGroupBox

def get_QHeaderView():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QHeaderView
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QHeaderView

def get_QHBoxLayout():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QHBoxLayout
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QHBoxLayout

def get_QIcon():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QIcon
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QIcon

def get_QImage():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QImage
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QImage

def get_QLabel():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QLabel
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QLabel

def get_QListView():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QListView
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QListView

def get_QLineEdit():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QLineEdit
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QLineEdit


def get_QMainWindow():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QMainWindow
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QMainWindow

def get_QMenu():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QMenu
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QMenu

def get_QMessageBox():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QMessageBox
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QMessageBox

def get_QMetaObject():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QMetaObject
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QMetaObject

def get_QModelIndex():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QModelIndex
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QModelIndex

def get_QPainter():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QPainter
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QPainter

def get_QPixmap():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QPixmap
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QPixmap

def get_QPoint():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QPoint
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QPoint

def get_QPointF():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QPointF
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QPointF

def get_QProgressBar():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QProgressBar
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QProgressBar

def get_QPushButton():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QPushButton
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QPushButton

def get_QRadioButton():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QRadioButton
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QRadioButton

def get_QRect():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QRect
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QRect

def get_QScrollArea():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QScrollArea
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QScrollArea

def get_QSize():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QSize
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QSize

def get_QSizePolicy():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QSizePolicy
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QSizePolicy

def get_QSortFilterProxyModel():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QSortFilterProxyModel
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QSortFilterProxyModel

def get_QSlider():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QSlider
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QSlider

def get_QSpacerItem():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QSpacerItem
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QSpacerItem

def get_QSplitter():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QSplitter
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QSplitter

def get_QStandardItem():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStandardItem
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QStandardItem

def get_QStandardItemModel():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStandardItemModel
    else:
        import PyQt5.QtGui as QtGui
        return QtGui.QStandardItemModel    

def get_QStringListModel():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStringListModel
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QStringListModel

def get_QStyle():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStyle
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QStyle

def get_QStyledItemDelegate():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStyledItemDelegate
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QStyledItemDelegate

def get_QStyleFactory():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStyleFactory
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QStyleFactory

def get_QStyleOptionComboBox():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStyleOptionComboBox
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QStyleOptionComboBox

def get_QStyleOptionSlider():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QStyleOptionSlider
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QStyleOptionSlider

def get_Qt():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.Qt
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.Qt

def get_QTableWidget():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTableWidget
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTableWidget

def get_QTableWidgetItem():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTableWidgetItem
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTableWidgetItem

def get_QTabWidget():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTabWidget
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTabWidget

def get_QtCore():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore
    else:
        import PyQt5.QtCore as QtCore
        return QtCore

def get_QTextBrowser():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTextBrowser
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTextBrowser

def get_QTextEdit():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTextEdit
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTextEdit

def get_QtGui():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui
    else:
        import PyQt5.QtGui as QtGui
        return QtGui

def get_QThread():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QThread
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QThread

def get_QTranslator():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore
        return QtCore.QTranslator
    else:
        import PyQt5.QtCore as QtCore
        return QtCore.QTranslator

def get_QTreeView():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTreeView
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTreeView

def get_QTreeWidget():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTreeWidget
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTreeWidget

def get_QTreeWidgetItem():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QTreeWidgetItem
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QTreeWidgetItem

def get_QtWidgets():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        return None
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets

def get_QVBoxLayout():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QVBoxLayout
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QVBoxLayout

def get_QWidget():
    if is_ida and idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui
        return QtGui.QWidget
    else:
        import PyQt5.QtWidgets as QtWidgets
        return QtWidgets.QWidget


DescendingOrder = get_DescendingOrder()
Signal = get_Signal()

QAbstractItemModel = get_QAbstractItemModel()
QAbstractItemView = get_QAbstractItemView()
QAction = get_QAction()
QApplication = get_QApplication()
QBrush = get_QBrush()
QByteArray = get_QByteArray()
QCheckBox = get_QCheckBox()
QColor = get_QColor()
QComboBox = get_QComboBox()
QCompleter = get_QCompleter()
QCoreApplication = get_QCoreApplication()
QCursor = get_QCursor()
QDialog = get_QDialog()
QEvent = get_QEvent()
QFont = get_QFont()
QFrame = get_QFrame()
QGroupBox = get_QGroupBox()
QHeaderView = get_QHeaderView()
QHBoxLayout = get_QHBoxLayout()
QIcon = get_QIcon()
QImage = get_QImage()
QLabel = get_QLabel()
QListView = get_QListView()
QLineEdit = get_QLineEdit()
QMainWindow = get_QMainWindow()
QMenu = get_QMenu()
QMessageBox = get_QMessageBox()
QMetaObject = get_QMetaObject()
QModelIndex = get_QModelIndex()
QPainter = get_QPainter()
QPixmap = get_QPixmap()
QPoint = get_QPoint()
QPointF = get_QPointF()
QProgressBar = get_QProgressBar()
QPushButton = get_QPushButton()
QRadioButton = get_QRadioButton()
QRect = get_QRect()
QScrollArea = get_QScrollArea()
QSize = get_QSize()
QSizePolicy = get_QSizePolicy()
QSortFilterProxyModel = get_QSortFilterProxyModel()
QSlider = get_QSlider()
QSpacerItem = get_QSpacerItem()
QSplitter = get_QSplitter()
QStandardItem = get_QStandardItem()
QStandardItemModel = get_QStandardItemModel()
QStringListModel = get_QStringListModel()
QStyle = get_QStyle()
QStyledItemDelegate = get_QStyledItemDelegate()
QStyleFactory = get_QStyleFactory()
QStyleOptionComboBox = get_QStyleOptionComboBox()
QStyleOptionSlider = get_QStyleOptionSlider()
Qt = get_Qt()
QTableWidget = get_QTableWidget()
QTableWidgetItem = get_QTableWidgetItem()
QTabWidget = get_QTabWidget()
QtCore = get_QtCore()
QTextBrowser = get_QTextBrowser()
QTextEdit = get_QTextEdit()
QtGui = get_QtGui()
QThread = get_QThread()
QTranslator = get_QTranslator()
QTreeView = get_QTreeView()
QTreeWidget = get_QTreeWidget()
QTreeWidgetItem = get_QTreeWidgetItem()
QtWidgets = get_QtWidgets()
QVBoxLayout = get_QVBoxLayout()
QWidget = get_QWidget()

```

`idaclu/qt_utils.py`:

```py
from idaclu.qt_shims import (
    QCoreApplication,
)


def i18n(text, context="PluginDialog"):
    return QCoreApplication.translate(context, text)

```

`idaclu/qt_widgets.py`:

```py
# -*- coding: utf-8 -*-
from collections import defaultdict, OrderedDict
from functools import partial
from re import split

import idaapi

from idaclu.qt_shims import (
    QAbstractItemView,
    QComboBox,
    QColor,
    QCursor,
    QEvent,
    QFont,
    QFrame,
    QHeaderView,
    QHBoxLayout,
    QIcon,
    QLabel,
    QLineEdit,
    QPainter,
    QPoint,
    QPointF,
    QProgressBar,
    QPushButton,
    QSize,
    QSizePolicy,
    QSortFilterProxyModel,
    QStandardItem,
    QStyledItemDelegate,
    Qt,
    QtCore,
    QTreeView,
    QThread,
    QVBoxLayout,
    QWidget,
    Signal
)

from idaclu.qt_utils import i18n
from idaclu import ida_shims
from idaclu import plg_utils


class LabelTool(QWidget):
    PREFIX = 0
    FOLDER = 1

    def __init__(self, name, env_desc, parent=None):
        super(LabelTool, self).__init__(parent)

        self.env_desc = env_desc
        self.label_mode = LabelTool.PREFIX
        self.data = [
            {'caption': i18n('PREFIX'), 'pholder': i18n('Insert name')},
            {'caption': i18n('FOLDER'), 'pholder': i18n('Insert name')}
        ]
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.font = font
        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.initRecursionToggle(parent))
        layout.addLayout(self.initLabelEdit(parent))
        for actn in ['SetLabel', 'ClsLabel']:
            layout.addWidget(self.initActionButton(actn, parent))
        if self.env_desc.feat_folders:
            self._label.clicked.connect(self.toggleLabelMode)
        self.retranslateUi()
        self.setLayout(layout)
        self.decorateUi()


    def initActionButton(self, ref, parent):
        btn_name = "{}Button".format(ref)
        btn = QPushButton(parent)
        btn.setMinimumSize(QSize(75, 30))
        btn.setMaximumSize(QSize(75, 30))
        btn.setFont(self.font)
        btn.setEnabled(False)
        setattr(self, btn_name, btn)
        return btn

    def initRecursionToggle(self, parent):
        toggle = QPushButton(parent)
        toggle.setMinimumSize(QSize(30, 30))
        toggle.setMaximumSize(QSize(30, 30))
        toggle.setFont(self.font)
        toggle.setCheckable(True)
        toggle.setCursor(QCursor(Qt.PointingHandCursor))
        self._recur_toggle = toggle
        return toggle

    def initLabelEdit(self, parent):
        _PointingHandCursor = Qt.PointingHandCursor

        layout = QHBoxLayout()
        layout.setSpacing(0)

        label = QPushButton(parent)
        label.setCursor(QCursor(_PointingHandCursor))
        label.setMinimumSize(QSize(75, 30))
        label.setMaximumSize(QSize(75, 30))
        label.setFont(self.font)
        label.setCheckable(False)
        label.setAutoExclusive(False)
        self._label = label

        edit = QLineEdit(parent)
        edit.setMinimumSize(QSize(16777215, 30))
        edit.setMaximumSize(QSize(16777215, 30))
        edit.setPlaceholderText(i18n("Insert prefix"))
        self._edit = edit

        layout.addWidget(self._label)
        layout.addWidget(self._edit)
        layout.setStretch(0, 2)
        layout.setStretch(1, 5)
        return layout

    def toggleLabelMode(self):
        self.label_mode = not self.label_mode
        caption = str(self.data[self.label_mode]['caption']).upper()
        pholder = self.data[self.label_mode]['pholder']
        self._label.setText(i18n(caption))
        self._edit.setPlaceholderText(i18n(pholder))

    def setEnabled(self, state):
        self.SetLabelButton.setEnabled(state)
        self.ClsLabelButton.setEnabled(state)

    def getLabelName(self, prfx='', sufx=''):
        text = self._edit.text()
        if not text.startswith(prfx):
            text = "{}{}".format(prfx, text)
        if not text.endswith(sufx):
            text = "{}{}".format(text, sufx)
        return text

    def getLabelMode(self):
        return self.data[self.label_mode]['caption'].lower()

    def setModeHandler(self, handler):
        self._recur_toggle.clicked.connect(handler)

    def setSetHandler(self, handler):
        self.SetLabelButton.clicked.connect(handler)

    def setClsHandler(self, handler):
        self.ClsLabelButton.clicked.connect(handler)

    def decorateUi(self):
        self._recur_toggle.setProperty('class','tool-btn tool-btn-hov')
        if self.env_desc.feat_folders:
            self._label.setProperty('class','tool-btn tool-btn-hov edit-head')
        else:
            self._label.setProperty('class','tool-btn edit-head')
            self._label.setCursor(QCursor(Qt.ArrowCursor))
        self.SetLabelButton.setProperty('class','tool-btn tool-btn-hov')
        self.ClsLabelButton.setProperty('class','tool-btn tool-btn-hov')

    def retranslateUi(self):
        self._recur_toggle.setText(i18n("R"))
        self._label.setText(i18n("PREFIX"))
        self.SetLabelButton.setText(i18n("ADD"))
        self.ClsLabelButton.setText(i18n("CLEAR"))
        self._recur_toggle.setToolTip(i18n("Toggle recursive mode on/off"))
        self._label.setToolTip(i18n("Switch between Prefix/Folder modes"))


class ProgressIndicator(QWidget):
    def __init__(self, parent=None):
        super(ProgressIndicator, self).__init__(parent)
        layout = QVBoxLayout()
        layout.addWidget(self.initProgressBar(parent))
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        self._update_step = 2
        self.reset()
        self._worker = Worker()
        self._worker.updateProgress.connect(self.setProgress)

    def initProgressBar(self, parent):
        progress = QProgressBar(parent)
        progress.setMinimumSize(QSize(0, 5))
        progress.setMaximumSize(QSize(16777215, 5))
        progress.setTextVisible(False)
        self._progress = progress
        return progress

    def setProgress(self, progress):
        if progress % self._update_step == 0 and progress != self._progress.value():
            if progress == self._update_step:
                self.setVisible(True)
                self._progress.setValue(progress)
            elif progress == 100:
                self.reset()
            else:
                self.setVisible(True)
                self._progress.setValue(progress)

    def updateProgress(self, progress, msg=""):
        if progress % self._update_step == 0 and progress != self._progress.value():
            if progress == self._update_step:
                idaapi.show_wait_box("Processing...")
            elif progress == 100:
                idaapi.hide_wait_box()
            else:
                msg0 = "Progress: {}%".format(progress)
                idaapi.replace_wait_box(
                    "{}\n{}".format(msg0.ljust(40), msg.ljust(40))
                )
            if ida_shims.user_cancelled():
                idaapi.hide_wait_box()
                self.reset()
                raise plg_utils.UserCancelledError
            idaapi.execute_ui_requests([lambda: None,])
            self._worker.updateProgress.emit(progress)

    def reset(self):
        self._progress.reset()
        self.setVisible(False)

class ToolButton(QPushButton):
    def __init__(self, name=None, size=(30, 30), parent=None):
        QPushButton.__init__(self, parent=parent)
        if name:
            self.setObjectName(name)
        self.setMinimumSize(QSize(*size))
        self.setMaximumSize(QSize(*size))
        self.setCursor(QCursor(Qt.PointingHandCursor))


class ColorButton(ToolButton):
    def __init__(self, name, size=(30, 30), parent=None):
        ToolButton.__init__(self, name=name, parent=parent)
        self.setCheckable(True)


class Worker(QThread):
    updateProgress = Signal(int)

    def __init__(self):
        QThread.__init__(self)

    def run(self):
        for i in range(1, 101):
            self.updateProgress.emit(i)
            # time.sleep(0.01)


class PaletteTool(QWidget):
    COLOR_NAME = 0
    COLOR_VAL = 1

    def __init__(self, name, size, pref, is_enbl=True, is_excl=True, parent=None):
        super(PaletteTool, self).__init__(parent)
        self.colors = [
            ("yellow", (255,255,191)),
            ("blue", (199,255,255)),
            ("green", (191,255,191)),
            ("pink", (255,191,239)),
            ("none", (255,255,255))
        ]

        self.setObjectName(name)
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0)

        for name, _ in self.colors:
            btn_name = '{}{}'.format(pref, name.capitalize())
            btn_obj = ColorButton(u"{}".format(btn_name), size, parent)
            btn_obj.setProperty('class','plt-btn plt-btn-{}'.format(name))
            btn_obj.setText("")
            self.layout.addWidget(btn_obj)

        self.setEnabled(is_enbl)
        self.setAutoExclusive(is_excl)
        self.setLayout(self.layout)

    def setClickHandler(self, handler):
        for _, btn in self.enumButtons():
            btn.clicked.connect(handler)

    def setPrefix(self, pref):
        for _, btn in self.enumButtons():
            color = str(btn.objectName()).replace('SetColor', '').lower()
            btn.setToolTip("{} {}".format(pref, i18n(color)))

    def enumButtons(self):
        for i in range(self.layout.count()):
            widget = self.layout.itemAt(i).widget()
            if isinstance(widget, QPushButton):
                yield (i, widget)

    def setEnabled(self, state):
        for _, btn in self.enumButtons():
            btn.setEnabled(state)

    def setAutoExclusive(self, state):
        for _, btn in self.enumButtons():
            btn.setAutoExclusive(state)

    def getSelectedColors(self):
        colors = []
        for i, btn in self.enumButtons():
            if btn.isChecked():
                color_val = self.colors[i][PaletteTool.COLOR_VAL]
                colors.append(plg_utils.RgbColor(color_val))
        return colors


class FilterInputGroup(QWidget):
    def __init__(self, names, pholder, env_desc, parent=None):
        super(FilterInputGroup, self).__init__(parent)

        self._items = OrderedDict()

        self.env_desc = env_desc
        is_unicode = isinstance(names, basestring) if env_desc.ver_py == 2 else isinstance(names, str)
        if is_unicode:
            self._has_state = False
            names = [names]
        elif isinstance(names, list) and len(names) == 2:
            self._has_state = True
            self._names = names
            self._state = False

        self.name = names[0]
        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(self.initText(self.name, self))
        layout.addWidget(self.initSelect(self.name))
        layout.setStretch(0, 0)
        layout.setStretch(1, 5)
        layout.setStretch(2, 7)
        layout.setStretch(3, 0)
        self.setPlaceholder(pholder)
        self.setLayout(layout)

    def initText(self, name, parent=None):
        font = QFont()
        font.setBold(True)
        font.setWeight(75)

        label = QPushButton(parent)
        label.setText(name.upper())
        label.setFont(font)
        label.setMinimumSize(QSize(96, 26))
        label.setMaximumSize(QSize(96, 26))
        label.setProperty('class', 'select-head')
        self._label = label
        if self._has_state:
            self._label.setCursor(QCursor(Qt.PointingHandCursor))
            self._label.clicked.connect(self.toggleMode)
        return label

    def initSelect(self, name, parent=None):
        select = CheckableComboBox()
        select.setEnabled(True)
        select.setAutoFillBackground(False)
        select.setMinimumSize(QSize(16777215, 26))
        select.setMaximumSize(QSize(16777215, 26))
        select.lineEdit().setText("")
        self._select = select
        return select

    def setPlaceholder(self, pholder):
        self._select.lineEdit().setPlaceholderText(pholder)

    def addItems(self, items, is_sorted=False):
        for tpl in items:
            self.addItem(tpl, False)
        if len(items):
            self.setEnabled(True)
            if is_sorted:
                self.sortItems()
        else:
            self.setEnabled(False)

    def sortItems(self):
        self._items = OrderedDict(sorted(self._items.items()))
        self._select.sortItems()

    def addItem(self, item, is_sorted=False, is_unique=False):
        is_skip = False
        txt, num, col = None, None, None
        if isinstance(item, str):
            item = (item)
        for t in item:
            if isinstance(t, str):
                txt = t
            if isinstance(t, int):
                num = t
            if isinstance(t, tuple):
                col = t
        if txt in self._items:
            if not is_unique:
                self._items[txt] += num
            else:
                is_skip = True
        else:
            self._items[txt] = num
        if num:
            txt = '{} ({})'.format(txt, num)
        if not is_skip:
            self._select.addItem((txt, col), userData=None)
        if is_sorted:
            self.sortItems()

    def chgItems(self, changelog, is_sorted=False):
        rem_items = []
        for mod in changelog:
            for lbl, val in changelog[mod].items():
                idx = list(self._items.keys()).index(lbl) if lbl in self._items else -1
                if mod == 'sub':
                    self._items[lbl] -= val
                    if self._items[lbl] == 0:
                        self._items.pop(lbl)
                        sel_count = len(self.getData())
                        self._select.removeItem(idx)
                        if sel_count == 1:
                            self.setText('')
                        else:
                            self._select.updateLineEditField()
                        rem_items.append(lbl)
                        continue
                elif mod == 'add':
                    if lbl in self._items:
                        self._items[lbl] += val
                    else:
                        self._items[lbl] = val
                new_entry = '{} ({})'.format(lbl, self._items[lbl])
                if self.name == 'COLORS' and plg_utils.RgbColor(lbl).is_color_defined():
                    self._select.chgItem(idx, new_entry, plg_utils.RgbColor(lbl).get_to_tuple())
                else:
                    self._select.chgItem(idx, new_entry)

        if is_sorted:
            self.sortItems()
        return rem_items

    def setEnabled(self, state=False):
        self._select.setEnabled(state)

    def removeSelf(self):
        self._label.setParent(None)
        self._select.setParent(None)
        self.setParent(None)

    def setText(self, text):
        self._select.lineEdit().setText(text)

    def getData(self):
        entries = self._select.getData().split('; ')
        data = []
        for e in entries:
            data.append(e.split(' ')[0])
        return data

    def toggleMode(self):
        self._state = not self._state
        caption = self._names[int(self._state)].upper()
        self._label.setText(i18n(caption))

    def getState(self):
        return self._state


class CheckableComboBox(QComboBox):
    def __init__(self):
        super(CheckableComboBox, self).__init__()
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.closeOnLineEditClick = False
        self.lineEdit().installEventFilter(self)
        self.view().viewport().installEventFilter(self)
        self.model().dataChanged.connect(self.updateLineEditField)
        self.itemDelegate = QStyledItemDelegate(self)
        self.setItemDelegate(self.itemDelegate)

    def hidePopup(self):
        super(CheckableComboBox, self).hidePopup()
        self.startTimer(100)

    def addItem(self, entry, userData=None):
        text, colr = entry
        item = QStandardItem()
        item.setText(text)
        if not userData is None:
            item.setData(userData)
        if not colr is None:
            item.setBackground(QColor(*colr))
        item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable)
        item.setData(Qt.Unchecked, Qt.CheckStateRole)
        self.model().appendRow(item)

    def chgItem(self, row, text, color=None):
        if row == -1:
            self.addItem((text, color if color else None))
        else:
            item = self.model().item(row)
            item.setData(text, role=Qt.DisplayRole)

    def removeItem(self, row):
        self.model().removeRow(row)

    def sortItems(self):
        self.model().sort(0)

    def eventFilter(self, widget, event):
        if widget == self.lineEdit():
            if event.type() == QEvent.MouseButtonRelease:
                if self.closeOnLineEditClick:
                    self.hidePopup()
                else:
                    self.showPopup()
                return True
            return super(CheckableComboBox, self).eventFilter(widget, event)
        if widget == self.view().viewport():
            if event.type() == QEvent.MouseButtonRelease:
                indx = self.view().indexAt(event.pos())
                item = self.model().item(indx.row())

                if item.checkState() == Qt.Checked:
                    item.setCheckState(Qt.Unchecked)
                else:
                    item.setCheckState(Qt.Checked)
                return True
            return super(CheckableComboBox, self).eventFilter(widget, event)

    def updateLineEditField(self):
        text_container = []
        for i in range(self.model().rowCount()):
            if self.model().item(i).checkState() == Qt.Checked:
                text_container.append(self.model().item(i).text())
            text_string = '; '.join(text_container)
            self.lineEdit().setText(text_string)

    def getData(self):
        return self.lineEdit().text()

    def clearData(self):
        self.clear()


class FrameLayout(QWidget):
    def __init__(self, parent=None, title=None, env=None):
        self.env_desc = env
        QWidget.__init__(self, parent=parent)

        self._is_collasped = True
        self._title_frame = None
        self._content, self._content_layout = (None, None)

        title_frame = self.initTitleFrame(title, self._is_collasped)
        content_widget = self.initContent(self._is_collasped)

        self._main_v_layout = QVBoxLayout(self)
        self._main_v_layout.addWidget(title_frame)
        self._main_v_layout.addWidget(content_widget)

        self.initCollapsable()

    def initTitleFrame(self, title, collapsed):
        self._title_frame = self.TitleFrame(
            title=title,
            collapsed=collapsed,
            env=self.env_desc)
        return self._title_frame

    def initContent(self, collapsed):
        self._content = QWidget()
        self._content_layout = QVBoxLayout()

        self._content.setLayout(self._content_layout)
        self._content.setVisible(not collapsed)

        return self._content

    def addWidget(self, widget):
        self._content_layout.addWidget(widget)

    def initCollapsable(self):
        self._title_frame.clicked.connect(self.toggleCollapsed)

    def toggleCollapsed(self):
        self._content.setVisible(self._is_collasped)
        self._is_collasped = not self._is_collasped
        self._title_frame._arrow.setArrow(int(self._is_collasped))


    class TitleFrame(QFrame):

        clicked = Signal()
        def __init__(self, parent=None, title="", collapsed=False, env=None):
            QFrame.__init__(self, parent=parent)
            self.env_desc = env
            self.setMinimumHeight(24)
            self.move(QPoint(24, 0))

            self._hlayout = QHBoxLayout(self)
            self._hlayout.setContentsMargins(0, 0, 0, 0)
            self._hlayout.setSpacing(0)

            self._arrow = None
            self._title = None

            self._hlayout.addWidget(self.initArrow(collapsed))
            self._hlayout.addWidget(self.initTitle(title))

        def initArrow(self, collapsed):
            self._arrow = FrameLayout.Arrow(collapsed=collapsed, env=self.env_desc)
            return self._arrow

        def initTitle(self, title=None):
            self._title = QLabel(title)
            self._title.setMinimumHeight(24)
            self._title.move(QPoint(24, 0))

            return self._title

        def mousePressEvent(self, event):
            self.clicked.emit()
            return super(FrameLayout.TitleFrame, self).mousePressEvent(event)


    class Arrow(QFrame):
        def __init__(self, parent=None, collapsed=False, env=None):
            QFrame.__init__(self, parent=parent)
            self.env_desc = env
            self.setMaximumSize(24, 24)

            # horizontal == 0
            ha_point1 = QPointF(7.0, 8.0)
            ha_point2 = QPointF(17.0, 8.0)
            ha_point3 = QPointF(12.0, 13.0)
            self._arrow_horizontal = (ha_point1, ha_point2, ha_point3)
            # vertical == 1
            va_point1 = QPointF(8.0, 7.0)
            va_point2 = QPointF(13.0, 12.0)
            va_point3 = QPointF(8.0, 17.0)
            self._arrow_vertical = (va_point1, va_point2, va_point3)
            # arrow
            self._arrow = None
            self.setArrow(int(collapsed))

        def setArrow(self, arrow_dir):
            if arrow_dir:
                self._arrow = self._arrow_vertical
            else:
                self._arrow = self._arrow_horizontal

        def paintEvent(self, event):
            painter = QPainter()
            painter.begin(self)
            painter.setBrush(QColor(192, 192, 192))
            painter.setPen(QColor(64, 64, 64))
            if self.env_desc.lib_qt == 'pyqt5':
                painter.drawPolygon(*self._arrow)
            else:  # 'pyside'
                painter.drawPolygon(self._arrow)
            painter.end()


class FilterHeader(QHeaderView):
    filterChanged = Signal(int)

    def __init__(self, parent):
        super().__init__(Qt.Horizontal, parent)
        self._editors = []
        self._padding = 4
        self.filters_visible = False  # Initialize filters_visible
        self.setStretchLastSection(True)
        self.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self.setSortIndicatorShown(False)
        self.sectionResized.connect(self.adjustPositions)
        parent.header().sectionResized.connect(self.adjustPositions)
        parent.horizontalScrollBar().valueChanged.connect(self.adjustPositions)

    def setFilterBoxes(self, count):
        while self._editors:
            editor = self._editors.pop()
            editor.deleteLater()
        for index in range(count):
            editor = QLineEdit(self.parent())
            editor.setPlaceholderText('Filter')
            editor.textChanged.connect(partial(self.filterChanged.emit, index))  # Emit filterChanged on each keystroke
            editor.setVisible(self.filters_visible)  # Initial visibility state
            self._editors.append(editor)
        self.adjustPositions()

    def toggleFilterVisibility(self):
        """Toggle the visibility of the filter inputs."""
        self.filters_visible = not self.filters_visible
        for editor in self._editors:
            editor.setVisible(self.filters_visible)
        self.updateGeometries()
        self.adjustPositions()

    def sizeHint(self):
        size = super().sizeHint()
        if self._editors and self.filters_visible:
            height = self._editors[0].sizeHint().height()
            size.setHeight(size.height() + height + self._padding)
        return size

    def updateGeometries(self):
        if self._editors and self.filters_visible:
            height = self._editors[0].sizeHint().height()
            self.setViewportMargins(0, 0, 0, height + self._padding)
        else:
            self.setViewportMargins(0, 0, 0, 0)
        super().updateGeometries()
        self.adjustPositions()

    def adjustPositions(self):
        if not self.filters_visible:
            return
        for index, editor in enumerate(self._editors):
            height = editor.sizeHint().height()
            editor.move(self.sectionPosition(index) - self.offset() + 2, height + (self._padding // 2))
            editor.resize(self.sectionSize(index), height)

    def filterText(self, index):
        if 0 <= index < len(self._editors):
            return self._editors[index].text()
        return ''


class FilterProxyModel(QSortFilterProxyModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDynamicSortFilter(True)
        self.filter_texts = {}

    def setFilterText(self, index, text):
        self.filter_texts[index] = text.lower()
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        model = self.sourceModel()
        index = model.index(source_row, 0, source_parent)
        # Both parent-items and child-items are processed by this function.
        return self.hasMatch(index)

    def rowMatchesFilter(self, index):
        filters = self.filter_texts.items()

        # No filters defined, so preserve any row.
        if len(filters) == 0:
            return True

        for col, filter_text in filters:
            if filter_text:
                cell_data = self.sourceModel().data(index.sibling(index.row(), col))
                if filter_text not in cell_data.lower():
                    return False

        # Preserve row if no filter triggered reject in this row.
        return True

    def hasMatch(self, parent_index):
        model = self.sourceModel()
        row_count = model.rowCount(parent_index)

        for row in range(row_count):
            child_index = model.index(row, 0, parent_index)
            if self.rowMatchesFilter(child_index):
                return True

        return self.rowMatchesFilter(parent_index)

    def lessThan(self, left_index, right_index):
        # Fetch data for comparison
        left_data = left_index.data()
        right_data = right_index.data()

        # Apply natural sorting if both items are strings
        if isinstance(left_data, str) and isinstance(right_data, str):
            return self.natural_sort(left_data, right_data)

        # Otherwise, fall back to default comparison
        return left_data < right_data

    def natural_sort_key(self, s):
        return [int(text) if text.isdigit() else text.lower() for text in split('([0-9]+)', str(s))]

    def natural_sort(self, left, right):
        return self.natural_sort_key(left) > self.natural_sort_key(right)

    def sort(self, column, order, is_child_sort=-1):
        # Determine the source model for sorting
        source_model = self.sourceModel()
        # self.beginResetModel()
        self.layoutAboutToBeChanged.emit()

        if is_child_sort != -1:  # Sorting for the parent
            if is_child_sort:  # Sorting for children
                # Sort the children for each root item
                self.sort_child_items(source_model, column, order)
            else:
                # Sort the root level
                self.sort_root_items(source_model, column, order)

        # self.endResetModel()
        self.layoutChanged.emit()

    def sort_root_items(self, model, column, order):
        model.iroot._children.sort(key=lambda x: self.natural_sort_key(x.data(column)),
                                    reverse=(order == Qt.DescendingOrder))

    def sort_child_items(self, model, column, order):
        for i, child in enumerate(model.iroot._children):
            child._children.sort(key=lambda x: self.natural_sort_key(x.data(column)),
                                reverse=(order == Qt.DescendingOrder))


class CluTreeView(QTreeView):
    def __init__(self, env_desc, parent=None):
        QTreeView.__init__(self, parent=parent)
        self.setSortingEnabled(True)
        self.setAlternatingRowColors(True)
        self.setObjectName(u"rvTable")
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.expanded.connect(self.save_expanded_state)
        self.collapsed.connect(self.save_expanded_state)

        self.env = env_desc
        self.heads = ['Name', 'Address', 'Size', 'Chunks', 'Nodes', 'Edges', 'Comment', 'Color']
        if self.env.feat_folders:
            self.heads.insert(1, 'Folder')
        self.expanded_state = {}
        self.rec_indx = defaultdict(list)

        self._header = FilterHeader(self)
        self._header.filterChanged.connect(self.applyFilter)  # Connect signal for instant filtering
        self.setHeader(self._header)
        # Consider the order
        self.header().sectionClicked.connect(self.sortByColumn)

    def sortByColumn(self, logicalIndex):
        currentOrder = self.header().sortIndicatorOrder()
        isChildSort = bool(self.expanded_state) and any(value == True for value in self.expanded_state.values())
        model = self.model()
        model.sort(logicalIndex, currentOrder, int(isChildSort))
        self.indexRecords()

        root_idx = QtCore.QModelIndex()
        clu_count = model.rowCount(root_idx)
        for value, state in self.expanded_state.items():
            for r_num in range(clu_count):
                p_idx = model.index(r_num, 0, root_idx)
                if value == p_idx.data():
                    self.setExpanded(p_idx, state)
                    break

        self.model().invalidateFilter()
        self.indexRecords()

    def indexRecords(self):
        self.rec_indx.clear()
        model = self.model()
        id_col = self.heads.index('Address')
        root_idx = QtCore.QModelIndex()
        for r_num in range(model.rowCount(root_idx)):
            p_idx = model.index(r_num, 0, root_idx)
            for c_num in range(model.rowCount(p_idx)):
                index = model.index(c_num, id_col, p_idx)
                self.rec_indx[int(index.data(), 16)].append((r_num, c_num))

    def save_expanded_state(self, index):
        self.expanded_state[index.data()] = self.isExpanded(index)

    def setModelProxy(self, model):
        self.proxy_model = FilterProxyModel(self)
        self.proxy_model.setSourceModel(model)
        self.setModel(self.proxy_model)
        self.collapseAll()
        self._header.setFilterBoxes(self.model().columnCount())

    def keyPressEvent(self, event):
        # Toggle filter visibility on Ctrl+F
        if event.key() == Qt.Key_F and event.modifiers() & Qt.ControlModifier:
            self._header.toggleFilterVisibility()
        else:
            super().keyPressEvent(event)

    def applyFilter(self, index):
        filter_text = self._header.filterText(index)
        self.proxy_model.setFilterText(index, filter_text)
        self.indexRecords()


class ConfigTool(QWidget):
    def __init__(self, parent=None, env=None):
        QWidget.__init__(self, parent=parent)
        self.env = env
        self.is_save = False
        layout = self.genLayout()
        self.setLayout(layout)
        self.setMinimumSize(QSize(32, 30))
        self.setMaximumSize(QSize(16777215, 30))
        self._saveBtn.clicked.connect(self.toggleSave)
        self.loadIcon()

    def genLayout(self):
        layout = QHBoxLayout()
        self._saveBtn = ToolButton()
        layout.addWidget(self._saveBtn)
        layout.setContentsMargins(0, 0, 0, 0)
        return layout

    def loadIcon(self):
        saveIcon = QIcon(u":/idaclu/save_{}_64.png".format(int(self.is_save)))
        self._saveBtn.setIcon(saveIcon)

    def toggleSave(self):
        self.is_save = not self.is_save
        self.loadIcon()
        action = ["enable", "disable"][int(self.is_save)]
        self._saveBtn.setToolTip("{} result caching".format(action.capitalize()))
        return self.is_save

```

`idaclu/ui_idaclu.py`:

```py
# -*- coding: utf-8 -*-

################################################################################
## Form generated from reading UI file 'idacluaBebKo.ui'
##
## Created by: Qt User Interface Compiler version 5.15.2
##
## WARNING! All changes made in this file will be lost when recompiling UI file!
################################################################################

# from PySide2.QtCore import *
# from PySide2.QtGui import *
# from PySide2.QtWidgets import *
from idaclu.qt_shims import (
    Signal,
    QSizePolicy,
    QAbstractItemView,
    QComboBox,
    QCoreApplication,
    QCursor,
    QEvent,
    QFont,
    QFrame,
    QGroupBox,
    QHBoxLayout,
    QIcon,
    QLineEdit,
    QMetaObject,
    QProgressBar,
    QPushButton,
    QRect,
    QScrollArea,
    QSize,
    QSizePolicy,
    QSpacerItem,
    QSplitter,
    QStandardItem,
    QStyledItemDelegate,
    Qt,
    QThread,
    QVBoxLayout,
    QWidget
)
from idaclu.qt_utils import i18n

from idaclu.qt_widgets import (
    CluTreeView,
    ConfigTool,
    FilterInputGroup,
    LabelTool,
    PaletteTool,
    ProgressIndicator
)

class Ui_PluginDialog(object):
    def __init__(self, env_desc):
        self.env_desc = env_desc

    def setupUi(self, PluginDialog):
        if not PluginDialog.objectName():
            PluginDialog.setObjectName(u"PluginDialog")
        PluginDialog.resize(1024, 600)
        icon = QIcon()
        icon.addFile(u":/idaclu/icon_64.png", QSize(), QIcon.Normal, QIcon.Off)
        PluginDialog.setWindowIcon(icon)
        self.vlPluginDialog = QVBoxLayout(PluginDialog)
        self.vlPluginDialog.setObjectName(u"vlPluginDialog")
        self.DialogSplitter = QSplitter(PluginDialog)
        self.DialogSplitter.setObjectName(u"DialogSplitter")
        self.DialogSplitter.setOrientation(Qt.Horizontal)
        self.DialogSplitter.setChildrenCollapsible(False)
        self.SidebarFrame = QFrame(self.DialogSplitter)
        self.SidebarFrame.setObjectName(u"SidebarFrame")
        self.SidebarLayout = QVBoxLayout(self.SidebarFrame)
        self.SidebarLayout.setSpacing(0)
        self.SidebarLayout.setObjectName(u"SidebarLayout")
        self.SidebarLayout.setContentsMargins(0, 0, 0, 0)
        self.ScriptsLayout = QVBoxLayout()
        self.ScriptsLayout.setSpacing(0)
        self.ScriptsLayout.setObjectName(u"ScriptsLayout")
        self.ScriptsHeader = QPushButton(self.SidebarFrame)
        self.ScriptsHeader.setObjectName(u"ScriptsHeader")
        self.ScriptsHeader.setMinimumSize(QSize(200, 30))
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.ScriptsHeader.setFont(font)
        self.ScriptsHeader.setCursor(QCursor(Qt.PointingHandCursor))
        self.ScriptsHeader.setProperty("class", "head")
        self.ScriptsLayout.addWidget(self.ScriptsHeader)

        self.ScriptsArea = QScrollArea(self.SidebarFrame)
        self.ScriptsArea.setObjectName(u"ScriptsArea")
        self.ScriptsArea.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.ScriptsArea.setWidgetResizable(True)
        self.wScriptsContents = QWidget()
        self.wScriptsContents.setObjectName(u"wScriptsContents")
        self.wScriptsContents.setGeometry(QRect(0, 0, 235, 372))

        # custom layout
        self.ScriptsContentsLayout = QVBoxLayout(self.wScriptsContents)
        self.ScriptsContentsLayout.setSpacing(0)
        self.ScriptsContentsLayout.setAlignment(Qt.AlignTop)

        self.ScriptsArea.setWidget(self.wScriptsContents)

        self.ScriptsLayout.addWidget(self.ScriptsArea)


        self.SidebarLayout.addLayout(self.ScriptsLayout)

        self.sScriptsBottom = QSpacerItem(20, 10, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.SidebarLayout.addItem(self.sScriptsBottom)

        self.FiltersLayout = QVBoxLayout()
        self.FiltersLayout.setSpacing(0)
        self.FiltersLayout.setObjectName(u"FiltersLayout")
        self.FiltersHeader = QPushButton(self.SidebarFrame)
        self.FiltersHeader.setObjectName(u"FiltersHeader")
        self.FiltersHeader.setMinimumSize(QSize(200, 30))
        font1 = QFont()
        font1.setBold(True)
        font1.setWeight(75)
        self.FiltersHeader.setFont(font1)
        self.FiltersHeader.setCursor(QCursor(Qt.PointingHandCursor))
        self.FiltersHeader.setProperty("class", "head")
        self.FiltersLayout.addWidget(self.FiltersHeader)

        self.FiltersGroup = QGroupBox(self.SidebarFrame)
        self.FiltersGroup.setObjectName(u"FiltersGroup")
        self.vlFiltersGroup = QVBoxLayout(self.FiltersGroup)
        self.vlFiltersGroup.setSpacing(0)
        self.vlFiltersGroup.setObjectName(u"vlFiltersGroup")
        self.vlFiltersGroup.setContentsMargins(0, 0, 0, 0)
        self.sFilters1 = QSpacerItem(20, 15, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.vlFiltersGroup.addItem(self.sFilters1)

        self.FolderFilterLayout = QHBoxLayout()
        self.FolderFilterLayout.setObjectName(u"FolderFilterLayout")
        self.sFolderFilterBeg = QSpacerItem(20, 26, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.FolderFilterLayout.addItem(self.sFolderFilterBeg)

        self.wFolderFilter = FilterInputGroup(i18n("FOLDERS"), i18n("Pick folders..."), self.env_desc, self.FiltersGroup)
        self.wFolderFilter.setObjectName(u"wFolderFilter")
        self.wFolderFilter.setMinimumSize(QSize(0, 26))
        self.wFolderFilter.setMaximumSize(QSize(16777215, 26))

        self.FolderFilterLayout.addWidget(self.wFolderFilter)

        self.sFolderFilterEnd = QSpacerItem(20, 26, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.FolderFilterLayout.addItem(self.sFolderFilterEnd)


        self.vlFiltersGroup.addLayout(self.FolderFilterLayout)

        self.sFilters2 = QSpacerItem(20, 15, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.vlFiltersGroup.addItem(self.sFilters2)

        self.PrefixFilterLayout = QHBoxLayout()
        self.PrefixFilterLayout.setObjectName(u"PrefixFilterLayout")
        self.sPrefixFilterBeg = QSpacerItem(20, 26, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.PrefixFilterLayout.addItem(self.sPrefixFilterBeg)

        self.wPrefixFilter = FilterInputGroup([i18n("PREFIXES"), i18n("Pick prefixes...")], i18n("Pick prefixes..."), self.env_desc, self.FiltersGroup)
        self.wPrefixFilter.setObjectName(u"wPrefixFilter")
        self.wPrefixFilter.setMinimumSize(QSize(0, 26))
        self.wPrefixFilter.setMaximumSize(QSize(16777215, 26))

        self.PrefixFilterLayout.addWidget(self.wPrefixFilter)

        self.sPrefixFilterEnd = QSpacerItem(20, 26, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.PrefixFilterLayout.addItem(self.sPrefixFilterEnd)


        self.vlFiltersGroup.addLayout(self.PrefixFilterLayout)

        self.sFilters3 = QSpacerItem(20, 15, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.vlFiltersGroup.addItem(self.sFilters3)

        self.ColorFilterLayout = QHBoxLayout()
        self.ColorFilterLayout.setObjectName(u"ColorFilterLayout")
        self.sColorFilterBeg = QSpacerItem(20, 26, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.ColorFilterLayout.addItem(self.sColorFilterBeg)

        self.wColorFilter = FilterInputGroup([i18n("COLORS"), i18n("Pick colors...")], i18n("Pick colors..."), self.env_desc, self.FiltersGroup)
        self.wColorFilter.setObjectName(u"wColorFilter")
        self.wColorFilter.setMinimumSize(QSize(0, 26))
        self.wColorFilter.setMaximumSize(QSize(16777215, 26))

        self.ColorFilterLayout.addWidget(self.wColorFilter)

        self.sColorFilterEnd = QSpacerItem(20, 26, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.ColorFilterLayout.addItem(self.sColorFilterEnd)


        self.vlFiltersGroup.addLayout(self.ColorFilterLayout)

        self.sFilters4 = QSpacerItem(20, 15, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.vlFiltersGroup.addItem(self.sFilters4)


        self.FiltersLayout.addWidget(self.FiltersGroup)


        self.SidebarLayout.addLayout(self.FiltersLayout)

        self.sFiltersBottom = QSpacerItem(20, 14, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.SidebarLayout.addItem(self.sFiltersBottom)

        self.DialogSplitter.addWidget(self.SidebarFrame)
        self.MainFrame = QFrame(self.DialogSplitter)
        self.MainFrame.setObjectName(u"MainFrame")
        self.MainLayout = QVBoxLayout(self.MainFrame)
        self.MainLayout.setSpacing(0)
        self.MainLayout.setObjectName(u"MainLayout")
        self.MainLayout.setContentsMargins(5, 0, 0, 0)
        self.wProgressBar = ProgressIndicator(self.MainFrame)
        self.wProgressBar.setObjectName(u"wProgressBar")
        self.wProgressBar.setMinimumSize(QSize(0, 5))
        self.wProgressBar.setMaximumSize(QSize(16777215, 5))

        self.MainLayout.addWidget(self.wProgressBar)

        self.wResultsView = QWidget(self.MainFrame)
        self.wResultsView.setObjectName(u"wResultsView")
        self.hlResultsView = QHBoxLayout(self.wResultsView)
        self.hlResultsView.setObjectName(u"hlResultsView")
        self.hlResultsView.setContentsMargins(0, 0, 0, 0)
        self.rvTable = CluTreeView(self.env_desc, self.wResultsView)
        self.hlResultsView.addWidget(self.rvTable)


        self.MainLayout.addWidget(self.wResultsView)

        self.sToolsTop = QSpacerItem(20, 10, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.MainLayout.addItem(self.sToolsTop)

        self.ToolsLayout = QHBoxLayout()
        self.ToolsLayout.setObjectName(u"ToolsLayout")
        self.sToolsBeg = QSpacerItem(10, 20, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.ToolsLayout.addItem(self.sToolsBeg)

        self.wLabelTool = LabelTool(u"LabelTool", self.env_desc, self.MainFrame)
        self.wLabelTool.setObjectName(u"wLabelTool")
        self.wLabelTool.setMinimumSize(QSize(320, 30))
        self.wLabelTool.setMaximumSize(QSize(16777215, 30))

        self.ToolsLayout.addWidget(self.wLabelTool)

        self.sp1 = QSpacerItem(30, 20, QSizePolicy.Fixed, QSizePolicy.Minimum)
        self.ToolsLayout.addItem(self.sp1)

        self.vl = QFrame()
        self.vl.setFrameShape(QFrame.VLine)
        self.vl.setFrameShadow(QFrame.Sunken)
        self.ToolsLayout.addWidget(self.vl)

        self.sp2 = QSpacerItem(20, 20, QSizePolicy.Fixed, QSizePolicy.Minimum)
        self.ToolsLayout.addItem(self.sp2)

        self.wColorTool = PaletteTool(
            u"PaletteTool",
            (30, 30),
            u"SetColor",
            False,
            True,
            self.MainFrame)
        self.wColorTool.setObjectName(u"wColorTool")
        self.wColorTool.setMinimumSize(QSize(192, 30))
        self.wColorTool.setMaximumSize(QSize(16777215, 30))

        self.ToolsLayout.addWidget(self.wColorTool)

        self.sToolsMid = QSpacerItem(80, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
        self.ToolsLayout.addItem(self.sToolsMid)

        self.ConfigTool = ConfigTool(env=self.env_desc)
        self.ToolsLayout.addWidget(self.ConfigTool)
        self.sToolsEnd = QSpacerItem(10, 20, QSizePolicy.Fixed, QSizePolicy.Minimum)

        self.ToolsLayout.addItem(self.sToolsEnd)


        self.MainLayout.addLayout(self.ToolsLayout)

        self.sToolsBottom = QSpacerItem(20, 14, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.MainLayout.addItem(self.sToolsBottom)

        self.MainLayout.setStretch(1, 8)
        self.MainLayout.setStretch(2, 1)
        self.MainLayout.setStretch(4, 1)
        self.DialogSplitter.addWidget(self.MainFrame)

        self.vlPluginDialog.addWidget(self.DialogSplitter)


        self.retranslateUi(PluginDialog)

        QMetaObject.connectSlotsByName(PluginDialog)
    # setupUi

    def retranslateUi(self, PluginDialog):
        PluginDialog.setWindowTitle(i18n("IdaClu v1.1"))
        self.ScriptsHeader.setText(i18n("TOOLSET"))
        self.FiltersHeader.setText(i18n("FILTERS"))
    # retranslateUi

```