Project Path: arc_Kc57_iHide_w0fdf2gt

Source Tree:

```txt
arc_Kc57_iHide_w0fdf2gt
├── Makefile
├── README.md
├── Tweak.x
├── _docs
│   └── images
│       └── banner.png
├── control
├── ihide.plist
├── ihideprefs
│   ├── Makefile
│   ├── Resources
│   │   ├── Info.plist
│   │   ├── Root.plist
│   │   ├── icon.png
│   │   ├── icon@2x.png
│   │   └── icon@3x.png
│   ├── hidRootListController.h
│   ├── hidRootListController.m
│   └── layout
│       └── Library
│           └── PreferenceLoader
│               └── Preferences
│                   └── ihideprefs.plist
├── include
│   ├── cfuncs.h
│   ├── objcutils.h
│   └── utility.h
└── src
    ├── objcutils.m
    └── utility.c

```

`Makefile`:

```
FINALPACKAGE=1
ARCHS = armv7 arm64 arm64e
TARGET := iphone:clang:latest:7.0
INSTALL_TARGET_PROCESSES = SpringBoard


include $(THEOS)/makefiles/common.mk

TWEAK_NAME = ihide

ihide_FILES = Tweak.x src/utility.c src/objcutils.m
ihide_CFLAGS = -fobjc-arc

include $(THEOS_MAKE_PATH)/tweak.mk
SUBPROJECTS += ihideprefs
include $(THEOS_MAKE_PATH)/aggregate.mk

```

`README.md`:

```md
# iHide
A utility for hiding jailbreak from iOS applications

![iHide Banner](_docs/images/banner.png?raw=true)

## Description
Once installed, iHide will add a new entry in the iOS settings pane that can be used to enable/disable bypassing common jailbreak detection methods. Simply enable iHide, select any applications to enable it for, and iHide will attempt to bypass common jailbreak detection techniques.

## Easy Installation
You can install iHide by adding the repo [https://repo.kc57.com](https://repo.kc57.com) in Cydia or Sileo.

## Manual Installation
On iOS, iHide can be installed as a Cydia Subtrate tweak on a jailbroken device.

The following dependencies should be installed using Cydia:

* mobilesubstrate
* applist
* com.rpetrich.rocketbootstrap
* preferenceloader

Then, download the latest pre-compiled package available in the release tab of
the iHide GitHub page. Copy it to the device, install it and
respring the device:
```
dpkg -i <package>.deb
killall -HUP SpringBoard
```
There should be a new menu in the device's Settings where you can
enable the extension.

The tweak can later be uninstalled using:
```
dpkg -r com.kc57.ihide
```

## Feature Requests
If you run into an application that is not currently supported, please use the feature request template to request an update.

## Author
Rob Simon - [@_Kc57](https://twitter.com/_Kc57)

```

`Tweak.x`:

```x
//#include <Foundation/NSObjCRuntime.h>
//#include <Foundation/NSUserActivity.h>
//#include <Foundation/NSArray.h>
//#include <Foundation/NSURL.h>

// Use this in a hook for a stack trace
// NSLog(@"[iHide] %@",[NSThread callStackSymbols]);

#import <Foundation/Foundation.h>
#include <dirent.h>
#include <spawn.h>
#include "include/cfuncs.h"
#include "include/utility.h"
#import "include/objcutils.h"

#define _PLIST @"/var/mobile/Library/Preferences/com.kc57.ihideprefs.plist"
#define pref_getValue(key) [[NSDictionary dictionaryWithContentsOfFile:_PLIST] valueForKey:key]
#define pref_getBool(key) [pref_getValue(key) boolValue]

static bool isEnabled = NO;
static NSString *nsNotificationString = @"com.kc57.ihideprefs/settingschanged";

// jailbreak enabled/disabled group
%group GROUP_JAILBREAK_DETECTION_BYPASS


%hook UIApplication
- (BOOL)canOpenURL:(NSURL *)url {
  NSArray *url_schemes = @[
  @"cydia",
  @"sileo",
  @"undecimus"];
  for(NSString *str in url_schemes) {
    if ([[url scheme] isEqualToString:str]) {
      NSLog(@"[iHide] Hooked -[UIApplication canOpenURL:] -> %@", [url absoluteString]);
      NSLog(@"[iHide] Patching -[UIApplication canOpenURL:] return: NO");
      return NO;
    }
  }
  return %orig;
}
// -[UIApplication canOpenURL:]
%end


%hook NSURL
+ (instancetype)URLWithString:(NSString *)URLString {
  NSArray *url_schemes = @[
  @"cydia",
  @"sileo",
  @"undecimus"];
  for(NSString *str in url_schemes) {
    if ([URLString hasPrefix:str]) {
      NSLog(@"[iHide] Hooked +[NSURL URLWithString:] -> %@", URLString);
      NSLog(@"[iHide] Patching +[NSURL URLWithString:] return: nil");
      return nil;
    }
  }
  return %orig;
}
// +[NSURL URLWithString:]
%end

%hook NSString
- (BOOL)writeToFile:(NSString *)path
  atomically:(BOOL)useAuxiliaryFile
  encoding:(NSStringEncoding)enc
  error:(NSError * _Nullable *)error {
    NSArray *bad_paths = @[
    @"/private/"
    ];
    for(NSString *str in bad_paths) {
      if ([path hasPrefix:str]) {
        NSLog(@"[iHide] Hooked -[NSString writeToFile:atomically:encoding:error:] -> %@", path);
        NSLog(@"[iHide] Patching -[NSString writeToFile:atomically:encoding:error:] return: NO");
        *error = [[NSError alloc] initWithDomain:@"NSCocoaErrorDomain" code:NSFileWriteNoPermissionError userInfo:@{}];
        return NO;
      }
    }
    //NSLog(@"[iHide] Hooked -[NSString writeToFile:atomically:encoding:error:]\npath: %@ \nreturn: %@", path, retval ? @"Yes" : @"No");
    //NSLog(@"[iHide] -[NSString writeToFile:atomically:encoding:error:] return: %@", retval ? @"Yes" : @"No");
    //NSLog(@"[iHide] -[NSString writeToFile:atomically:encoding:error:] error: %@", [myError localizedDescription]);
    return %orig;
}
// -[NSString writeToFile:atomically:encoding:error:]
%end


%hook NSFileManager
- (BOOL)fileExistsAtPath:(NSString *)path {

  if (objc_isKnownBadPath(path)) {
    NSLog(@"[iHide] Hooked fileExistsAtPath -> %@", path);
    NSLog(@"[iHide] Patching fileExistsAtPath return: NO");
    return NO;
  }

  // If we didn't find any file checks we care about, return the original value
  return %orig;
}
// -[NSFileManager fileExistsAtPath:]
%end

// ============ System calls ============

%hookf(int, stat, const char *restrict path, struct stat *restrict buf) {
  if(isKnownBadPath(path))
  {
    NSLog(@"[iHide] hooking stat path: %s", path);
    return -1;
  }
  // Call the original implementation of this function
  return %orig;
}

%hookf(int, lstat, const char *restrict path, struct stat *restrict buf) {
  if(isKnownBadPath(path))
  {
    NSLog(@"[iHide] hooking lstat path: %s", path);
    return -1;
  }
  // Call the original implementation of this function
  return %orig;
}

%hookf(DIR *, opendir, const char *dirname) {
  if (isKnownBadPath(dirname))
  {
    NSLog(@"[iHide] hooking opendir dirname: %s", dirname);
    return NULL;
    //NSLog(@"[iHide] %@",[NSThread callStackSymbols]);
  }
  // Call the original implementation of this function
  return %orig;
}

%hookf(DIR *, fopen, const char *restrict filename, const char *restrict mode) {
  if (isKnownBadPath(filename))
  {
    NSLog(@"[iHide] hooking fopen filename: %s", filename);
    return NULL;
    //NSLog(@"[iHide] %@",[NSThread callStackSymbols]);
  }
  // Call the original implementation of this function
  return %orig;
}


%hookf(int, posix_spawn, pid_t *restrict pid, const char *restrict path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]) {
  if(isKnownSpawnPath(path))
  {
    NSLog(@"[iHide] hooking posix_spawn path: %s", path);
    return -1;
  }
  // Call the original implementation of this function
  return %orig;
}

%hookf(const char*, _dyld_get_image_name, uint32_t image_index) {
  // Call the original implementation of this function and store the return
  const char* retval = %orig;

  // Check the return for known files to hide
  if(isKnownDylib(retval))
  {
    NSLog(@"[iHide] hooking _dyld_get_image_name(%d): %s", image_index, retval);
    const char* newRetVal = "";
    return newRetVal;
  }
  return retval;
}

// end GROUP_JAILBREAK_DETECTION_BYPASS
%end

static void loadPrefs()
{
  NSLog(@"[iHide] loadPrefs called");
  isEnabled = pref_getBool(@"AwesomeSwitch1") ?: isEnabled;

  if(isEnabled)
  {
    NSLog(@"[iHide] isEnabled: YES");
  } else {
    NSLog(@"[iHide] isEnabled: NO");
  }

}

static void notificationCallback(CFNotificationCenterRef center, void *observer, CFStringRef name, const void *object, CFDictionaryRef userInfo) {
  NSLog(@"[iHide] notificationCallback called");
  loadPrefs();
}

%ctor {
    NSLog(@"[iHide] ctor enter...");
    loadPrefs();

    CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, notificationCallback, (CFStringRef)nsNotificationString, NULL, CFNotificationSuspensionBehaviorCoalesce);

    // If the tweak is not enabled then return
    if (!isEnabled) {
      NSLog(@"[iHide] not enabled, leaving...");
      return;
    }
    else {
      NSLog(@"[iHide] enabled!");
    }

    NSBundle* mainBundle = [NSBundle mainBundle];
    if (mainBundle) {
		    NSString* bundleIdentifier = mainBundle.bundleIdentifier;

        if (bundleIdentifier) {
          NSLog(@"[iHide] Checking if filter enabled for bundle: %@", bundleIdentifier);

          if (pref_getBool([@"EnabledApps-" stringByAppendingString:bundleIdentifier])) {
            NSLog(@"[iHide] Enabled for bundle: %@", bundleIdentifier);
            %init(GROUP_JAILBREAK_DETECTION_BYPASS);
          }
          else {
              NSLog(@"[iHide] Disabled for bundle: %@", bundleIdentifier);
          }

        }
      }

      NSLog(@"[iHide] ctor leave...");
}

```

`control`:

```
Package: com.kc57.ihide
Name: iHide
Version: 1.0.4
Architecture: iphoneos-arm
Description: Utility for hiding jailbreak from applications
Maintainer: Rob Simon (@_Kc57)
Author: Rob Simon (@_Kc57)
Section: Tweaks
Depends: mobilesubstrate (>= 0.9.5000), applist, firmware (>= 3.0), com.rpetrich.rocketbootstrap (>= 1.0.3), preferenceloader
Icon: file:///Library/PreferenceBundles/ihidePrefs.bundle/icon@2x.png
Depiction: https://repo.kc57.com/depiction/web/com.kc57.ihide.html

```

`ihide.plist`:

```plist
{ Filter = { Bundles = ( "com.apple.UIKit" ); }; }

```

`ihideprefs/Makefile`:

```
TARGET := iphone:11.2:10.0
ARCHS = armv7 arm64 arm64e

include $(THEOS)/makefiles/common.mk

BUNDLE_NAME = ihidePrefs

ihidePrefs_FILES = hidRootListController.m
ihidePrefs_FRAMEWORKS = UIKit
ihidePrefs_PRIVATE_FRAMEWORKS = Preferences
ihidePrefs_LIBRARIES = applist
ihidePrefs_INSTALL_PATH = /Library/PreferenceBundles
ihidePrefs_CFLAGS = -fobjc-arc

include $(THEOS_MAKE_PATH)/bundle.mk

```

`ihideprefs/Resources/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>ihidePrefs</string>
	<key>CFBundleIdentifier</key>
	<string>com.kc57.ihideprefs</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>BNDL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1.0</string>
	<key>NSPrincipalClass</key>
	<string>hidRootListController</string>
</dict>
</plist>

```

`ihideprefs/Resources/Root.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>Settings</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>default</key>
			<true/>
			<key>defaults</key>
			<string>com.kc57.ihideprefs</string>
			<key>key</key>
			<string>AwesomeSwitch1</string>
			<key>label</key>
			<string>Enable iHide</string>
			<key>PostNotification</key>
			<string>com.kc57.ihideprefs/settingschanged</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSLinkCell</string>
			<key>bundle</key>
			<string>AppList</string>
			<key>isController</key>
			<string>1</string>
			<key>label</key>
			<string>Disable Jailbreak Detection</string>
			<key>ALAllowsSelection</key>
			<string>1</string>
			<key>ALSingleEnabledMode</key>
			<string>0</string>
			<key>ALSettingsKeyPrefix</key>
			<string>EnabledApps-</string>
			<key>ALSettingsPath</key>
			<string>/var/mobile/Library/Preferences/com.kc57.ihideprefs.plist</string>
			<key>ALSectionDescriptors</key>
			<array>
				<!--
				<dict>
					<key>cell-class-name</key>
					<string>ALSwitchCell</string>
					<key>icon-size</key>
					<string>29</string>
					<key>predicate</key>
					<string>isSystemApplication = TRUE</string>
					<key>suppress-hidden-apps</key>
					<string>1</string>
					<key>title</key>
					<string>System Applications</string>
				</dict>
				-->
				<dict>
					<key>cell-class-name</key>
					<string>ALSwitchCell</string>
					<key>icon-size</key>
					<string>29</string>
					<key>predicate</key>
					<string>isSystemApplication = FALSE</string>
					<key>suppress-hidden-apps</key>
					<string>1</string>
					<key>title</key>
					<string>User Applications</string>
				</dict>
			</array>
		</dict>
	</array>
	<key>title</key>
	<string>iHide</string>
</dict>
</plist>

```

`ihideprefs/hidRootListController.h`:

```h
#import <Preferences/PSListController.h>

@interface hidRootListController : PSListController

@end

```

`ihideprefs/hidRootListController.m`:

```m
#include "hidRootListController.h"

@implementation hidRootListController

- (NSArray *)specifiers {
	if (!_specifiers) {
		_specifiers = [self loadSpecifiersFromPlistName:@"Root" target:self];
	}

	return _specifiers;
}

@end

```

`ihideprefs/layout/Library/PreferenceLoader/Preferences/ihideprefs.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>entry</key>
	<dict>
		<key>bundle</key>
		<string>ihidePrefs</string>
		<key>cell</key>
		<string>PSLinkCell</string>
		<key>detail</key>
		<string>hidRootListController</string>
		<key>icon</key>
		<string>icon.png</string>
		<key>isController</key>
		<true/>
		<key>label</key>
		<string>iHide</string>
	</dict>
</dict>
</plist>

```

`include/cfuncs.h`:

```h
#ifndef CFUNCS_H
#define CFUNCS_H

//#include <stdbool.h>
//#include <stddef.h>
//#include <string.h>
#include <sys/stat.h>

int stat(const char *restrict path, struct stat *restrict buf);
int lstat(const char *restrict path, struct stat *restrict buf);
DIR * opendir(const char *dirname);
int posix_spawn(pid_t *restrict pid, const char *restrict path,
  const posix_spawn_file_actions_t *file_actions,
  const posix_spawnattr_t *restrict attrp, char *const argv[restrict],
  char *const envp[restrict]);

FILE * fopen(const char *restrict filename, const char *restrict mode);

const char* _dyld_get_image_name(uint32_t image_index);

#endif

```

`include/objcutils.h`:

```h
#import <Foundation/Foundation.h>

bool objc_isKnownBadPath(NSString *path);

```

`include/utility.h`:

```h
#ifndef UTILITY_H
#define UTILITY_H

#include <stdbool.h>
#include <stddef.h>
#include <string.h>

bool isKnownBadPath(const char *path);
bool isKnownSpawnPath(const char *path);
bool isKnownDylib(const char *path);

#endif

```

`src/objcutils.m`:

```m
#import "../include/objcutils.h"

bool objc_isKnownBadPath(NSString *path) {
  NSArray *bad_paths = [NSArray arrayWithObjects:
  @"/.bootstrapped_electra",
  @"/.cydia_no_stash",
  @"/.installed_unc0ver",
  @"/Applications/blackra1n.app",
  @"/Applications/Cydia.app",
  @"/Applications/FakeCarrier.app",
  @"/Applications/Filza.app",
  @"/Applications/Icy.app",
  @"/Applications/IntelliScreen.app",
  @"/Applications/MxTube.app",
  @"/Applications/RockApp.app",
  @"/Applications/SBSettings.app",
  @"/Applications/SBSetttings.app",
  @"/Applications/Sileo.app",
  @"/Applications/Snoop-itConfig.app",
  @"/Applications/TrustMe.app",
  @"/Applications/WinterBoard.app",
  @"/bin/bash",
  @"/bin/sh",
  @"/etc/apt",
  @"/etc/apt/sources.list.d/electra.list",
  @"/etc/apt/sources.list.d/sileo.sources",
  @"/etc/apt/undecimus/undecimus.list",
  @"/etc/ssh/sshd_config",
  @"/jb/amfid_payload.dylib",
  @"/jb/jailbreakd.plist",
  @"/jb/libjailbreak.dylib",
  @"/jb/lzma",
  @"/jb/offsets.plist",
  @"/Library/MobileSubstrate/CydiaSubstrate.dylib",
  @"/Library/MobileSubstrate/DynamicLibraries/Liberty.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/Veency.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/zLiberty.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/zzLiberty.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/zzzLiberty.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/zzzzLiberty.plist",
  @"/Library/MobileSubstrate/DynamicLibraries/zzzzzLiberty.plist",
  @"/Library/MobileSubstrate/MobileSubstrate.dylib",
  @"/Library/PreferenceBundles/ABypassPrefs.bundle",
  @"/Library/PreferenceBundles/FlyJBPrefs.bundle",
  @"/Library/PreferenceBundles/LibertyPref.bundle",
  @"/Library/PreferenceBundles/ShadowPreferences.bundle",
  @"/private/etc/apt",
  @"/private/etc/dpkg/origins/debian",
  @"/private/etc/ssh/sshd_config",
  @"/private/var/cache/apt",
  @"/private/var/lib/apt",
  @"/private/var/lib/cydia",
  @"/private/var/log/syslog",
  @"/private/var/mobile/Library/SBSettings/Themes",
  @"/private/var/stash",
  @"/private/var/tmp/cydia.log",
  @"/private/var/Users",
  @"/System/Library/LaunchDaemons/com.ikey.bbot.plist",
  @"/System/Library/LaunchDaemons/com.saurik.Cy@dia.Startup.plist",
  @"/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist",
  @"/usr/bin/cycript",
  @"/usr/bin/ssh",
  @"/usr/bin/sshd",
  @"/usr/libexec/cydia",
  @"/usr/libexec/cydia/firmware.sh",
  @"/usr/libexec/sftp-server",
  @"/usr/libexec/ssh-keysign",
  @"/usr/lib/libcycript.dylib",
  @"/usr/lib/libhooker.dylib",
  @"/usr/lib/libjailbreak.dylib",
  @"/usr/lib/libsubstitute.dylib",
  @"/usr/lib/substrate",
  @"/usr/lib/TweakInject",
  @"/usr/local/bin/cycript",
  @"/usr/sbin/frida-server",
  @"/usr/sbin/sshd",
  @"/usr/share/jailbreak/injectme.plist",
  @"/var/binpack",
  @"/var/cache/apt",
  @"/var/checkra1n.dmg",
  @"/var/lib/apt",
  @"/var/lib/cydia",
  @"/var/lib/dpkg/info/mobilesubstrate.md5sums",
  @"/var/log/apt",
  @"/var/log/syslog",
  @"/var/tmp/cydia.log",
  nil];
  for(NSString *str in bad_paths) {
    NSString *strParam = path;
    if([strParam hasSuffix:@"/"]) {
      // Remove trailing '/'
      strParam = [strParam substringToIndex:[strParam length]-1];
    }
    // do a case insensitive comparison against the paths
    if( [str caseInsensitiveCompare:strParam] == NSOrderedSame ) {
      //NSLog(@"[iHide] Hooked fileExistsAtPath -> %@", str);
      //NSLog(@"[iHide] Patching fileExistsAtPath return: NO");
      return true;
    }
  }

  // default return if we don't match any paths
  return false;

}

```

`src/utility.c`:

```c
#include "../include/utility.h"

const char *statPaths[] = {
  "/Applications/Cydia.app",
  "/Applications/FakeCarrier.app",
  "/Applications/Icy.app",
  "/Applications/IntelliScreen.app",
  "/Applications/Loader.app",
  "/Applications/MxTube.app",
  "/Applications/RockApp.app",
  "/Applications/SBSettings.app",
  "/Applications/WinterBoard.app",
  "/Applications/blackra1n.app",
  "/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate",
  "/Library/Frameworks/CydiaSubstrate.framework/Libraries/SubstrateLoader.dylib",
  "/Library/LaunchDaemons/com.openssh.sshd.plist",
  "/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist",
  "/Library/MobileSubstrate",
  "/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist",
  "/Library/MobileSubstrate/DynamicLibraries/ProtectMyPrivacy.dylib",
  "/Library/MobileSubstrate/DynamicLibraries/Veency.plist",
  "/Library/MobileSubstrate/DynamicLibraries/WeeLoader.dylib",
  "/Library/MobileSubstrate/DynamicLibraries/xCon.dylib",
  "/Library/MobileSubstrate/MobileSubstrate.dylib",
  "/System/Library/LaunchDaemons/com.ikey.bbot.plist",
  "/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist",
  "/bin/bash",
  "/bin/mv",
  "/bin/sh",
  "/boot",
  "/dev",
  "/etc/apt",
  "/etc/ssh/sshd_config",
  "/private/var/lib/apt",
  "/private/var/lib/cydia",
  "/private/var/mobile/Library/SBSettings/Themes",
  "/private/var/mobileLibrary/SBSettingsThemes",
  "/private/var/stash",
  "/private/var/tmp/cydia.log",
  "/system/app/Superuser.apk",
  "/usr/bin/cycript",
  "/usr/bin/ssh",
  "/usr/bin/sshd",
  "/usr/binsshd",
  "/usr/lib/apt",
  "/usr/lib/libapt-inst.dylib",
  "/usr/lib/libcycript.dylib",
  "/usr/lib/tweakloader.dylib",
  "/usr/libexec/cydia",
  "/usr/libexec/sftp-server",
  "/usr/libexec/ssh-keysign",
  "/usr/local/bin/cycript",
  "/usr/sbin/frida-server",
  "/usr/sbin/sshd",
  "/usr/sbinsshd",
  "/var/cache/apt",
  "/var/lib/apt",
  "/var/lib/cydia",
  "/var/log/syslog",
  "/var/root",
  "/var/tmp/cydia.log"
};

const char *spawnPaths[] = {
  "/bin/df",
  "/bin/ps",
  "/usr/bin/taskinfo",
  "/usr/bin/vm_stat",
  "/usr/sbin/ipconfig",
  "/usr/sbin/syslogd",
  "/usr/sbin/mDNSResponder"
};

const char *dylibList[] = {
  "AppList",
  "CustomWidgetIcons",
  "CydiaSubstrate",
  "MobileSafety",
  "MobileSubstrate",
  "OpenSiri",
  "PreferenceLoader",
  "RocketBootstrap",
  "SSLKillSwitch",
  "SSLKillSwitch2",
  "SubstrateLoader",
  "WeeLoader",
  "cydia",
  "cynject",
  "libapt-inst",
  "libcycrypt",
  "libjailbreak",
  "libsubstrate",
  "patcyh",
  "substrate",
  "tweakloader"
};

bool isKnownBadPath(const char *path)
{
  size_t i = 0;
  for( i = 0; i < sizeof(statPaths) / sizeof(statPaths[0]); i++)
  {
    if (strcmp(path, statPaths[i]) == 0)
    {
      return true;
    }
  }
  return false;
}

bool isKnownSpawnPath(const char *path)
{
  size_t i = 0;
  for( i = 0; i < sizeof(spawnPaths) / sizeof(spawnPaths[0]); i++)
  {
    if (strcmp(path, spawnPaths[i]) == 0)
    {
      return true;
    }
  }
  return false;
}

bool isKnownDylib(const char *path)
{
  size_t i = 0;
  for( i = 0; i < sizeof(dylibList) / sizeof(dylibList[0]); i++)
  {
    if (strstr(path, dylibList[i]) != NULL)
    {
      return true;
    }
  }
  return false;
}

```