Project Path: arc_longpoxin_hideroot_ji3h5cfk

Source Tree:

```txt
arc_longpoxin_hideroot_ji3h5cfk
├── jni
│   ├── Android.mk
│   ├── Application.mk
│   ├── demo.c
│   ├── hideroot.c
│   ├── log.h
│   └── utils
│       ├── vector.c
│       └── vector.h
└── readme.md

```

`jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)  
  
include $(CLEAR_VARS)

LOCAL_MODULE := hideroot
LOCAL_SRC_FILES := hideroot.c utils/vector.c
  
LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog  

include $(BUILD_EXECUTABLE)


include $(CLEAR_VARS)

LOCAL_MODULE := demo
LOCAL_SRC_FILES := demo.c
  
LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog  

include $(BUILD_EXECUTABLE)
```

`jni/Application.mk`:

```mk
APP_ABI := armeabi-v7a
APP_PLATFORM := android-21
APP_STL := stlport_static
```

`jni/demo.c`:

```c
#include <stdio.h>
#include <unistd.h>

#include "log.h"

int main(int angc, char** argv) {
	while(1) {
		if (access("/sbin/su", F_OK) == 0) {
			DEBUG_PRINT("Can access /sbin/su!\n");
		}
		else {
			DEBUG_PRINT("Can not access /sbin/su!\nS");
		}
		sleep(3);
	}
}
```

`jni/hideroot.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <asm/ptrace.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <dlfcn.h>
#include <dirent.h>
#include <unistd.h>
#include <string.h>
#include <elf.h>
#include <android/log.h>
#include <sys/system_properties.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/mount.h>
#include <fcntl.h>
#include <sched.h>

#include "log.h"
#include "utils/vector.h"

int switch_mnt_ns(int pid) {
    char mnt[32];
    snprintf(mnt, sizeof(mnt), "/proc/%d/ns/mnt", pid);
    if(access(mnt, R_OK) == -1) {
        DEBUG_PRINT("[switch_mnt_ns] %s can't access!", mnt);
        return 1;
    }

    int fd, ret;
    fd = open(mnt, O_RDONLY);
    if (fd < 0) {
        DEBUG_PRINT("[switch_mnt_ns] open %s failed!", mnt);
        return 1;
    }
    ret = setns(fd, 0);
    close(fd);
    return ret;
}

ssize_t readline(char **lineptr, size_t *n, FILE *stream)
{
    int ch;
    char *line = *lineptr;
    size_t alloced = *n;
    size_t len = 0;

    do {
        ch = fgetc(stream);
        if (ch == EOF)
            break;
        if (len + 1 >= alloced) {
            alloced += alloced/4 + 64;
            line = realloc(line, alloced);
        }
        line[len++] = ch;
    } while (ch != '\n');

    if (len == 0)
        return -1;

    line[len] = '\0';
    *lineptr = line;
    *n = alloced;
    return len;
}

int file_to_vector(const char* filename, struct vector *v) {
    if (access(filename, R_OK) != 0)
        return 1;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;

    FILE *fp = fopen(filename, "r");
    if (fp == NULL)
        return 1;
    while ((read = readline(&line, &len, fp)) != -1) {
        // Remove end newline
        if (line[read - 1] == '\n')
            line[read - 1] = '\0';
        vec_push_back(v, line);
        line = NULL;
        len = 0;
    }
    fclose(fp);
    return 0;
}

static void lazy_unmount(const char* mountpoint) {
    if (umount2(mountpoint, MNT_DETACH) != -1) {
        LOGD("[lazy_unmount]: Unmounted (%s)\n", mountpoint);
    }
    else {
        LOGD("[lazy_unmount]: Unmount %s failed\n", mountpoint);
    }
}

int main(int argc, char** argv) {
    DEBUG_PRINT("hideroot start\n");
    if (argc < 2) {
        DEBUG_PRINT("usage: ./hideroot {pid}\n");
        return 1;
    }

    pid_t target_pid = atoi(argv[1]);
    DEBUG_PRINT("target pid is %d\n", target_pid);

    kill(target_pid, SIGSTOP);

    DEBUG_PRINT("hideroot switch_mnt_ns\n");
    if (switch_mnt_ns(target_pid)) {
        DEBUG_PRINT("");
        return 1;
    }

    DEBUG_PRINT("hideroot read mounts\n");
    char buffer[256];
    char* line = NULL;
    struct vector mount_list;
    snprintf(buffer, sizeof(buffer), "/proc/%d/mounts", target_pid);
    DEBUG_PRINT("hideroot init mount_list\n");
    vec_init(&mount_list);
    DEBUG_PRINT("hideroot read file\n");
    file_to_vector(buffer, &mount_list);

    DEBUG_PRINT("hideroot unmount dummy skeletons and /sbin links\n");
    // Unmount dummy skeletons and /sbin links
    vec_for_each(&mount_list, line) {
        if (strstr(line, "tmpfs /system/") || strstr(line, "tmpfs /vendor/") || strstr(line, "tmpfs /sbin")) {
            sscanf(line, "%*s %4096s", buffer);
            lazy_unmount(buffer);
        }
        free(line);
    }
    vec_destroy(&mount_list);

    // Re-read mount infos
    snprintf(buffer, sizeof(buffer), "/proc/%d/mounts", target_pid);
    vec_init(&mount_list);
    file_to_vector(buffer, &mount_list);

    DEBUG_PRINT("hideroot unmount everything under /system, /vendor\n");
    // Unmount everything under /system, /vendor, and loop mounts
    vec_for_each(&mount_list, line) {
        if (strstr(line, "/dev/block/loop") || strstr(line, " /system/") || strstr(line, " /vendor/")) {
            sscanf(line, "%*s %4096s", buffer);
            lazy_unmount(buffer);
        }
        free(line);
    }
    vec_destroy(&mount_list);
exit:
    // Send resume signal
    kill(target_pid, SIGCONT);
    sleep(100);
    return 0;
}
```

`jni/log.h`:

```h
#ifndef __MY_LOG_H__
#define __MY_LOG_H__

#include <android/log.h>

#define ENABLE_DEBUG 1

#if ENABLE_DEBUG
#define LOG_TAG "hideroot"
#define LOGD(fmt, args...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#define DEBUG_PRINT(format,args...) LOGD(format, ##args)
#else
#define DEBUG_PRINT(format,args...)
#endif

#endif // __MY_LOG_H__

```

`jni/utils/vector.c`:

```c
/* vector.c - A simple vector implementation in c
 */

#include <stdlib.h>
#include <string.h>

#include "vector.h"

void vec_init(struct vector *v) {
	if (v == NULL) return;
	vec_size(v) = 0;
	vec_cap(v) = 1;
	vec_entry(v) = malloc(sizeof(void*));
}

void vec_push_back(struct vector *v, void *p) {
	if (v == NULL) return;
	if (vec_size(v) == vec_cap(v)) {
		vec_cap(v) *= 2;
		vec_entry(v) = realloc(vec_entry(v), sizeof(void*) * vec_cap(v));
	}
	vec_entry(v)[vec_size(v)] = p;
	++vec_size(v);
}

void *vec_pop_back(struct vector *v) {
	void *ret = vec_entry(v)[vec_size(v) - 1];
	--vec_size(v);
	return ret;
}

static int (*cmp)(const void *, const void *);

static int vec_comp(const void *a, const void *b) {
	void *aa = *((void **)a), *bb = *((void **)b);
	if (aa == NULL && bb == NULL) return 0;
	else if (aa == NULL) return 1;
	else if (bb == NULL) return -1;
	else return cmp ? cmp(aa, bb) : 0;
}

void vec_sort(struct vector *v, int (*compar)(const void *, const void *)) {
	if (v == NULL) return;
	cmp = compar;
	qsort(vec_entry(v), vec_size(v), sizeof(void*), vec_comp);
	void *e;
	vec_for_each_r(v, e) {
		if (e) break;
		--vec_size(v);
	}
}

/* Will cleanup only the vector itself
 * use in cases when each element requires special cleanup 
 */
void vec_destroy(struct vector *v) {
	if (v == NULL) return;
	vec_size(v) = 0;
	vec_cap(v) = 0;
	free(vec_entry(v));
	vec_entry(v) = NULL; // Prevent double destroy segfault
}

/* Will cleanup each element AND the vector itself
 * Shall be the general case
 */
void vec_deep_destroy(struct vector *v) {
	if (v == NULL) return;
	void *e;
	vec_for_each(v, e) {
		free(e);
	}
	vec_destroy(v);
}

struct vector *vec_dup(struct vector *v) {
	struct vector *ret = malloc(sizeof(*ret));
	vec_size(ret) = vec_size(v);
	vec_cap(ret) = vec_cap(v);
	vec_entry(v) = malloc(sizeof(void*) * vec_cap(ret));
	memcpy(vec_entry(ret), vec_entry(v), sizeof(void*) * vec_cap(ret));
	return ret;
}

```

`jni/utils/vector.h`:

```h
/* vector.h - A simple vector implementation in c
 */

#ifndef _VECTOR_H_
#define _VECTOR_H_

#include <sys/types.h>

struct vector {
	unsigned size;
	unsigned cap;
	void **data;
};

void vec_init(struct vector *v);
void vec_push_back(struct vector *v, void *p);
void *vec_pop_back(struct vector *v);
void vec_sort(struct vector *v, int (*compar)(const void *, const void *));
void vec_destroy(struct vector *v);
void vec_deep_destroy(struct vector *v);
struct vector *vec_dup(struct vector *v);

#define vec_size(v) (v)->size
#define vec_cap(v) (v)->cap
#define vec_entry(v) (v)->data
/* Usage: vec_for_each(vector *v, void *e) */
#define vec_for_each(v, e) \
	e = v ? (v)->data[0] : NULL; \
	for (int _ = 0; v && _ < (v)->size; ++_, e = (v)->data[_])

#define vec_for_each_r(v, e) \
	e = (v && (v)->size > 0) ? (v)->data[(v)->size - 1] : NULL; \
	for (int _ = ((int) (v)->size) - 1; v && _ >= 0; --_, e = (v)->data[_])

#define vec_cur(v) vec_entry(v)[_]

#endif

```

`readme.md`:

```md
Magisk源码[地址](https://github.com/topjohnwu/Magisk)
隐藏root功能的代码位于工程的 Magisk/native/jni/magiskhide目录下
这里直接把功能实现核心代码抽离出来。完整代码见附件，以下是主要部分：

```c
int main(int argc, char** argv) {
    DEBUG_PRINT("hideroot start\n");
    if (argc < 2) {
        DEBUG_PRINT("usage: ./hideroot {pid}\n");
        return 1;
    }

    pid_t target_pid = atoi(argv[1]);
    DEBUG_PRINT("target pid is %d\n", target_pid);

    // 1. 暂停目标进程
    kill(target_pid, SIGSTOP);

    // 2. 关联到目标进程的mnt-namespace
    DEBUG_PRINT("hideroot switch_mnt_ns\n");
    if (switch_mnt_ns(target_pid)) {
        DEBUG_PRINT("");
        return 1;
    }

    // 3. 卸载相关文件系统
    DEBUG_PRINT("hideroot read mounts\n");
    char buffer[256];
    char* line = NULL;
    struct vector mount_list;
    snprintf(buffer, sizeof(buffer), "/proc/%d/mounts", target_pid);
    DEBUG_PRINT("hideroot init mount_list\n");
    vec_init(&mount_list);
    DEBUG_PRINT("hideroot read file\n");
    file_to_vector(buffer, &mount_list);

    DEBUG_PRINT("hideroot unmount dummy skeletons and /sbin links\n");
    // Unmount dummy skeletons and /sbin links
    vec_for_each(&mount_list, line) {
        if (strstr(line, "tmpfs /system/") || strstr(line, "tmpfs /vendor/") || strstr(line, "tmpfs /sbin")) {
            sscanf(line, "%*s %4096s", buffer);
            lazy_unmount(buffer);
        }
        free(line);
    }
    vec_destroy(&mount_list);

    // Re-read mount infos
    snprintf(buffer, sizeof(buffer), "/proc/%d/mounts", target_pid);
    vec_init(&mount_list);
    file_to_vector(buffer, &mount_list);

    DEBUG_PRINT("hideroot unmount everything under /system, /vendor\n");
    // Unmount everything under /system, /vendor, and loop mounts
    vec_for_each(&mount_list, line) {
        if (strstr(line, "/dev/block/loop") || strstr(line, " /system/") || strstr(line, " /vendor/")) {
            sscanf(line, "%*s %4096s", buffer);
            lazy_unmount(buffer);
        }
        free(line);
    }
    vec_destroy(&mount_list);

exit:
    // 4. 目标进程继续运行
    kill(target_pid, SIGCONT);

    sleep(100);

    return 0;
}
```

switch_mnt_ns的实现如下:

```c
int switch_mnt_ns(int pid) {
    char mnt[32];
    snprintf(mnt, sizeof(mnt), "/proc/%d/ns/mnt", pid);
    if(access(mnt, R_OK) == -1) {
        DEBUG_PRINT("[switch_mnt_ns] %s can't access!", mnt);
        return 1;
    }

    int fd, ret;
    fd = open(mnt, O_RDONLY);
    if (fd < 0) {
        DEBUG_PRINT("[switch_mnt_ns] open %s failed!", mnt);
        return 1;
    }

    // setns的详细解释见 http://man7.org/linux/man-pages/man2/setns.2.html
    ret = setns(fd, 0);
    close(fd);
    return ret;
}

```


```