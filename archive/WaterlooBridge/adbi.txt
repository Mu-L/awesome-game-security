Project Path: arc_WaterlooBridge_adbi_zch52zjz

Source Tree:

```txt
arc_WaterlooBridge_adbi_zch52zjz
├── README.md
├── build.sh
├── clean.sh
├── hijack
│   ├── hijack.c
│   └── jni
│       ├── Android.mk
│       └── Application.mk
└── instruments
    ├── base
    │   ├── base.c
    │   ├── base.h
    │   ├── hook.c
    │   ├── hook.h
    │   ├── jni
    │   │   ├── Android.mk
    │   │   └── Application.mk
    │   ├── util.c
    │   └── util.h
    ├── example
    │   ├── epoll.c
    │   ├── epoll_arm.c
    │   └── jni
    │       ├── Android.mk
    │       └── Application.mk
    ├── example2
    │   ├── demo
    │   │   ├── app
    │   │   │   ├── build.gradle
    │   │   │   ├── proguard-rules.pro
    │   │   │   └── src
    │   │   │       └── main
    │   │   │           ├── AndroidManifest.xml
    │   │   │           ├── java
    │   │   │           │   └── com
    │   │   │           │       └── zhenl
    │   │   │           │           └── demo
    │   │   │           │               └── Main.java
    │   │   │           └── res
    │   │   │               └── values
    │   │   │                   ├── colors.xml
    │   │   │                   └── strings.xml
    │   │   ├── build.gradle
    │   │   ├── epic
    │   │   ├── gradle
    │   │   │   └── wrapper
    │   │   │       ├── gradle-wrapper.jar
    │   │   │       └── gradle-wrapper.properties
    │   │   ├── gradle.properties
    │   │   ├── gradlew
    │   │   ├── gradlew.bat
    │   │   └── settings.gradle
    │   ├── dex_inject.c
    │   └── jni
    │       ├── Android.mk
    │       └── Application.mk
    └── example3
        ├── demo
        │   ├── app
        │   │   ├── build.gradle
        │   │   ├── proguard-rules.pro
        │   │   └── src
        │   │       └── main
        │   │           ├── AndroidManifest.xml
        │   │           ├── java
        │   │           │   └── com
        │   │           │       └── zhenl
        │   │           │           └── demo
        │   │           │               └── Main.java
        │   │           ├── res
        │   │           │   └── values
        │   │           │       ├── colors.xml
        │   │           │       └── strings.xml
        │   │           └── whale
        │   ├── build.gradle
        │   ├── gradle
        │   │   └── wrapper
        │   │       ├── gradle-wrapper.jar
        │   │       └── gradle-wrapper.properties
        │   ├── gradle.properties
        │   ├── gradlew
        │   ├── gradlew.bat
        │   └── settings.gradle
        ├── dex_inject.c
        └── jni
            ├── Android.mk
            └── Application.mk

```

`README.md`:

```md
adbi - The Android Dynamic Binary Instrumentation Toolkit  
=========================================================

Simple binary instrumentation toolkit for Android ARM + Thumb.

Instrumentation is based on library injection and hooking function entry 
points (in-line hooking).

The toolkit consists of two main components the hijack tool and the base 
library.

**hijack**

 The hijack tool provides the injection functionality. It supports a number of  modes for supporting older and newer Android devices. hijack provides help on the command line.
 
**libbase**

 The base library provides the hooking and unhooking functionality. The base library is compiled as a static library so it can be directly included in the
 actual instrumentation library. This is done so we can keep everything in /data/local/tmp. 

Below we provide and easy to follow step-by-step instructions for howto build and use adbi. The example instrument hijacks ffio_open_whitelist() and logs every call
to a file.

=== Prerequisites ===

Android SDK
Android NDK

=== How to Build ===

= build the hijack tool =
```
cd hijack
cd jni
ndk-build
cd ..
adb push libs/armeabi/hijack /data/local/tmp/
cd ..
```

= build the instrumentation base code =

```
cd instruments
cd base
cd jni
ndk-build
cd ..
cd ..
```

= build instrumentation example =

```
cd example
cd jni
ndk-build
cd ..
adb push libs/armeabi/libexample.so /data/local/tmp/
```

=== How to Run ===

```
adb shell
su
setenforce 0
cd /data/local/tmp
>/sdcard/adbi_example.log
# GET PID from tv.danmaku.bili
./hijack -d -p PID -l /data/local/tmp/libexample.so
cat /sdcard/adbi_example.log
```

output should look similar to:

```
started
hooking:   ffio_open_whitelist = 0xc9d7eead THUMB using 0xc8f21839
Sun Dec  9 13:36:00 2018
 ijkio:cache:ffio:ijkhttphook:http://124.14.12.185/upgcxcode/94/54/66295494/66295494-1-30280.m4s
Sun Dec  9 13:36:02 2018
 ijkio:cache:ffio:ijkhttphook:http://124.14.12.168/upgcxcode/94/54/66295494/66295494-1-30077.m4s
```

=== Extra ===

= build instrumentation example3 =

```
cd example3
cd jni
ndk-build
cd ..
adb push libs/armeabi/libexample3.so /data/local/tmp/
cd demo #open Android Studio to Build APK
cd app/build/outputs/apk/debug #unzip app-debug.apk
adb push classes.dex /sdcard/com.zhenl.demo/classes.dex
adb push lib/armeabi-v7a/libwhale.so /data/local/tmp/
```

=== How to Run ===

```
adb shell
su
setenforce 0
cd /data/local/tmp
# GET PID from com.tencent.mm
./hijack -d -p PID -l /data/local/tmp/libexample3.so
logcat
```

output should look similar to:

```
whale.hook: keep alive is running
rawQueryWithFactory: SELECT * FROM userinfo2 WHERE sid=?;:null
```

```

`build.sh`:

```sh
#!/bin/sh

cd hijack/jni
ndk-build
cd ../..

cd instruments
cd base/jni
ndk-build
cd ../..

cd example/jni
ndk-build
cd ../..

cd ..


```

`clean.sh`:

```sh
#!/bin/sh

rm -vrf ./hijack/libs ./hijack/obj ./instruments/base/obj ./instruments/example/libs ./instruments/example/obj

```

`hijack/hijack.c`:

```c
/* 
 * hijack.c - force a process to load a library
 *
 *  ARM / Android version by:
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *	(c) 2012,2013
 *
 *
 *  original x86 version by:
 *  Copyright (C) 2002 Victor Zandy <zandy[at]cs.wisc.edu>
 *
 *  License: LGPL 2.1
 *
 */

#define _XOPEN_SOURCE 500 /* include pread,pwrite */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include <elf.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>

int debug = 0;
int zygote = 0;
unsigned int stack_start;
unsigned int stack_end;

/* memory map for libraries */
#define MAX_NAME_LEN 256
#define MEMORY_ONLY "[memory]"
struct mm
{
	char name[MAX_NAME_LEN];
	unsigned long start, end;
};

typedef struct symtab *symtab_t;
struct symlist
{
	Elf32_Sym *sym; /* symbols */
	char *str;		/* symbol strings */
	unsigned num;   /* number of symbols */
};
struct symtab
{
	struct symlist *st;  /* "static" symbols */
	struct symlist *dyn; /* dynamic symbols */
};

static void *
xmalloc(size_t size)
{
	void *p;
	p = malloc(size);
	if (!p)
	{
		printf("Out of memory\n");
		exit(1);
	}
	return p;
}

static struct symlist *
get_syms(int fd, Elf32_Shdr *symh, Elf32_Shdr *strh)
{
	struct symlist *sl, *ret;
	int rv;

	ret = NULL;
	sl = (struct symlist *)xmalloc(sizeof(struct symlist));
	sl->str = NULL;
	sl->sym = NULL;

	/* sanity */
	if (symh->sh_size % sizeof(Elf32_Sym))
	{
		printf("elf_error\n");
		goto out;
	}

	/* symbol table */
	sl->num = symh->sh_size / sizeof(Elf32_Sym);
	sl->sym = (Elf32_Sym *)xmalloc(symh->sh_size);
	rv = pread(fd, sl->sym, symh->sh_size, symh->sh_offset);
	if (0 > rv)
	{
		//perror("read");
		goto out;
	}
	if (rv != symh->sh_size)
	{
		printf("elf error\n");
		goto out;
	}

	/* string table */
	sl->str = (char *)xmalloc(strh->sh_size);
	rv = pread(fd, sl->str, strh->sh_size, strh->sh_offset);
	if (0 > rv)
	{
		//perror("read");
		goto out;
	}
	if (rv != strh->sh_size)
	{
		printf("elf error");
		goto out;
	}

	ret = sl;
out:
	return ret;
}

static int
do_load(int fd, symtab_t symtab)
{
	int rv;
	size_t size;
	Elf32_Ehdr ehdr;
	Elf32_Shdr *shdr = NULL, *p;
	Elf32_Shdr *dynsymh, *dynstrh;
	Elf32_Shdr *symh, *strh;
	char *shstrtab = NULL;
	int i;
	int ret = -1;

	/* elf header */
	rv = read(fd, &ehdr, sizeof(ehdr));
	if (0 > rv)
	{
		//perror("read");
		goto out;
	}
	if (rv != sizeof(ehdr))
	{
		printf("elf error\n");
		goto out;
	}
	if (strncmp(ELFMAG, ehdr.e_ident, SELFMAG))
	{ /* sanity */
		printf("not an elf\n");
		goto out;
	}
	if (sizeof(Elf32_Shdr) != ehdr.e_shentsize)
	{ /* sanity */
		printf("elf error\n");
		goto out;
	}

	/* section header table */
	size = ehdr.e_shentsize * ehdr.e_shnum;
	shdr = (Elf32_Shdr *)xmalloc(size);
	rv = pread(fd, shdr, size, ehdr.e_shoff);
	if (0 > rv)
	{
		//perror("read");
		goto out;
	}
	if (rv != size)
	{
		printf("elf error");
		goto out;
	}

	/* section header string table */
	size = shdr[ehdr.e_shstrndx].sh_size;
	shstrtab = (char *)xmalloc(size);
	rv = pread(fd, shstrtab, size, shdr[ehdr.e_shstrndx].sh_offset);
	if (0 > rv)
	{
		//perror("read");
		goto out;
	}
	if (rv != size)
	{
		printf("elf error\n");
		goto out;
	}

	/* symbol table headers */
	symh = dynsymh = NULL;
	strh = dynstrh = NULL;
	for (i = 0, p = shdr; i < ehdr.e_shnum; i++, p++)
		if (SHT_SYMTAB == p->sh_type)
		{
			if (symh)
			{
				printf("too many symbol tables\n");
				goto out;
			}
			symh = p;
		}
		else if (SHT_DYNSYM == p->sh_type)
		{
			if (dynsymh)
			{
				printf("too many symbol tables\n");
				goto out;
			}
			dynsymh = p;
		}
		else if (SHT_STRTAB == p->sh_type && !strncmp(shstrtab + p->sh_name, ".strtab", 7))
		{
			if (strh)
			{
				printf("too many string tables\n");
				goto out;
			}
			strh = p;
		}
		else if (SHT_STRTAB == p->sh_type && !strncmp(shstrtab + p->sh_name, ".dynstr", 7))
		{
			if (dynstrh)
			{
				printf("too many string tables\n");
				goto out;
			}
			dynstrh = p;
		}
	/* sanity checks */
	if ((!dynsymh && dynstrh) || (dynsymh && !dynstrh))
	{
		printf("bad dynamic symbol table");
		goto out;
	}
	if ((!symh && strh) || (symh && !strh))
	{
		printf("bad symbol table");
		goto out;
	}
	if (!dynsymh && !symh)
	{
		printf("no symbol table");
		goto out;
	}

	/* symbol tables */
	if (dynsymh)
		symtab->dyn = get_syms(fd, dynsymh, dynstrh);
	if (symh)
		symtab->st = get_syms(fd, symh, strh);
	ret = 0;
out:
	free(shstrtab);
	free(shdr);
	return ret;
}

static symtab_t
load_symtab(char *filename)
{
	int fd;
	symtab_t symtab;

	symtab = (symtab_t)xmalloc(sizeof(*symtab));
	memset(symtab, 0, sizeof(*symtab));

	fd = open(filename, O_RDONLY);
	if (0 > fd)
	{
		//perror("open");
		return NULL;
	}
	if (0 > do_load(fd, symtab))
	{
		printf("Error ELF parsing %s\n", filename);
		free(symtab);
		symtab = NULL;
	}
	close(fd);
	return symtab;
}

static int
load_memmap(pid_t pid, struct mm *mm, int *nmmp)
{
	char raw[800000]; // this depends on the number of libraries an executable uses
	char name[MAX_NAME_LEN];
	char *p;
	unsigned long start, end;
	struct mm *m;
	int nmm = 0;
	int fd, rv;
	int i;

	sprintf(raw, "/proc/%d/maps", pid);
	fd = open(raw, O_RDONLY);
	if (0 > fd)
	{
		printf("Can't open %s for reading\n", raw);
		return -1;
	}

	/* Zero to ensure data is null terminated */
	memset(raw, 0, sizeof(raw));

	p = raw;
	while (1)
	{
		rv = read(fd, p, sizeof(raw) - (p - raw));
		if (0 > rv)
		{
			//perror("read");
			return -1;
		}
		if (0 == rv)
			break;
		p += rv;
		if (p - raw >= sizeof(raw))
		{
			printf("Too many memory mapping\n");
			return -1;
		}
	}
	close(fd);

	p = strtok(raw, "\n");
	m = mm;
	while (p)
	{
		/* parse current map line */
		rv = sscanf(p, "%08lx-%08lx %*s %*s %*s %*s %s\n",
					&start, &end, name);

		p = strtok(NULL, "\n");

		if (rv == 2)
		{
			m = &mm[nmm++];
			m->start = start;
			m->end = end;
			strcpy(m->name, MEMORY_ONLY);
			continue;
		}

		if (strstr(name, "stack") != 0)
		{
			stack_start = start;
			stack_end = end;
		}

		/* search backward for other mapping with same name */
		for (i = nmm - 1; i >= 0; i--)
		{
			m = &mm[i];
			if (!strcmp(m->name, name))
				break;
		}

		if (i >= 0)
		{
			if (start < m->start)
				m->start = start;
			if (end > m->end)
				m->end = end;
		}
		else
		{
			/* new entry */
			m = &mm[nmm++];
			m->start = start;
			m->end = end;
			strcpy(m->name, name);
		}
	}

	*nmmp = nmm;
	return 0;
}

/* Find libc in MM, storing no more than LEN-1 chars of
   its name in NAME and set START to its starting
   address.  If libc cannot be found return -1 and
   leave NAME and START untouched.  Otherwise return 0
   and null-terminated NAME. */
static int
find_libc(char *name, int len, unsigned long *start,
		  struct mm *mm, int nmm)
{
	int i;
	struct mm *m;
	char *p;
	for (i = 0, m = mm; i < nmm; i++, m++)
	{
		if (!strcmp(m->name, MEMORY_ONLY))
			continue;
		p = strrchr(m->name, '/');
		if (!p)
			continue;
		p++;
		if (strncmp("libc", p, 4))
			continue;
		p += 4;

		/* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */
		if (!strncmp(".so", p, 3) || (p[0] == '-' && isdigit(p[1])))
			break;
	}
	if (i >= nmm)
		/* not found */
		return -1;

	*start = m->start;
	strncpy(name, m->name, len);
	if (strlen(m->name) >= len)
		name[len - 1] = '\0';
	return 0;
}

static int
find_linker_mem(char *name, int len, unsigned long *start,
				struct mm *mm, int nmm)
{
	int i;
	struct mm *m;
	char *p;
	for (i = 0, m = mm; i < nmm; i++, m++)
	{
		//printf("name = %s\n", m->name);
		//printf("start = %x\n", m->start);
		if (!strcmp(m->name, MEMORY_ONLY))
			continue;
		p = strrchr(m->name, '/');
		if (!p)
			continue;
		p++;
		if (strncmp("linker", p, 6))
			continue;
		break; // <--- hack
		p += 4;

		/* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */
		if (!strncmp(".so", p, 3) || (p[0] == '-' && isdigit(p[1])))
			break;
	}
	if (i >= nmm)
		/* not found */
		return -1;

	*start = m->start;
	strncpy(name, m->name, len);
	if (strlen(m->name) >= len)
		name[len - 1] = '\0';
	return 0;
}

static int
lookup2(struct symlist *sl, unsigned char type,
		char *name, unsigned long *val)
{
	Elf32_Sym *p;
	int len;
	int i;

	len = strlen(name);
	for (i = 0, p = sl->sym; i < sl->num; i++, p++)
	{
		//printf("name: %s %x\n", sl->str+p->st_name, p->st_value);
		if (!strncmp(sl->str + p->st_name, name, len) && ELF32_ST_TYPE(p->st_info) == type)
		{
			//if (p->st_value != 0) {
			*val = p->st_value;
			return 0;
			//}
		}
	}
	return -1;
}

static int
lookup_sym(symtab_t s, unsigned char type,
		   char *name, unsigned long *val)
{
	if (s->dyn && !lookup2(s->dyn, type, name, val))
		return 0;
	if (s->st && !lookup2(s->st, type, name, val))
		return 0;
	return -1;
}

static int
lookup_func_sym(symtab_t s, char *name, unsigned long *val)
{
	return lookup_sym(s, STT_FUNC, name, val);
}

static int
find_name(pid_t pid, char *name, unsigned long *addr)
{
	struct mm mm[2000];
	unsigned long libcaddr;
	int nmm;
	char libc[256];
	symtab_t s;

	if (0 > load_memmap(pid, mm, &nmm))
	{
		printf("cannot read memory map\n");
		return -1;
	}
	if (0 > find_libc(libc, sizeof(libc), &libcaddr, mm, nmm))
	{
		printf("cannot find libc\n");
		return -1;
	}
	s = load_symtab(libc);
	if (!s)
	{
		printf("cannot read symbol table\n");
		return -1;
	}
	if (0 > lookup_func_sym(s, name, addr))
	{
		printf("cannot find %s\n", name);
		return -1;
	}
	*addr += libcaddr;
	return 0;
}

static int find_linker(pid_t pid, unsigned long *addr)
{
	struct mm mm[2000];
	unsigned long libcaddr;
	int nmm;
	char libc[256];
	symtab_t s;

	if (0 > load_memmap(pid, mm, &nmm))
	{
		printf("cannot read memory map\n");
		return -1;
	}
	if (0 > find_linker_mem(libc, sizeof(libc), &libcaddr, mm, nmm))
	{
		printf("cannot find libc\n");
		return -1;
	}

	*addr = libcaddr;

	return 1;
}

static int find_libname(const char *libn, char *name, int len, unsigned long *start,
						struct mm *mm, int nmm)
{
	int i;
	struct mm *m;
	char *p;
	for (i = 0, m = mm; i < nmm; i++, m++)
	{
		if (!strcmp(m->name, MEMORY_ONLY))
			continue;
		p = strrchr(m->name, '/');
		if (!p)
			continue;
		p++;
		if (strncmp(libn, p, strlen(libn)))
			continue;
		p += strlen(libn);

		/* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */
		if (!strncmp("so", p, 2) || 1) // || (p[0] == '-' && isdigit(p[1])))
			break;
	}
	if (i >= nmm)
		/* not found */
		return -1;

	*start = m->start;
	strncpy(name, m->name, len);
	if (strlen(m->name) >= len)
		name[len - 1] = '\0';

	mprotect((void *)m->start, m->end - m->start,
			 PROT_READ | PROT_WRITE | PROT_EXEC);
	return 0;
}

int find_symbol(pid_t pid, const char *name, const char *libn,
				unsigned long *addr)
{
	struct mm mm[2000] = {0};
	unsigned long libcaddr;
	int nmm;
	char libc[1024] = {0};
	symtab_t s;

	if (0 > load_memmap(pid, mm, &nmm))
	{
		printf("cannot read memory map\n");
		return -1;
	}
	if (0 > find_libname((char *)libn, (char *)libc, sizeof(libc),
						 &libcaddr, mm, nmm))
	{
		printf("cannot find lib: %s\n", libn);
		return -1;
	}
	//ALOGD("lib: >%s<\n", libc)
	s = load_symtab(libc);
	if (!s)
	{
		printf("cannot read symbol table\n");
		return -1;
	}
	if (0 > lookup_func_sym(s, (char *)name, addr))
	{
		printf("cannot find function: %s\n", name);
		return -1;
	}
	*addr += libcaddr;
	return 0;
}

unsigned long get_module_base(pid_t pid, const char *libn)
{
	struct mm mm[2000] = {0};
	unsigned long libcaddr = 0;
	int nmm;
	char libc[1024] = {0};

	if (0 > load_memmap(pid, mm, &nmm))
	{
		printf("cannot read memory map\n");
	}
	if (0 > find_libname((char *)libn, (char *)libc, sizeof(libc),
						 &libcaddr, mm, nmm))
	{
		printf("cannot find lib: %s\n", libn);
	}

	return libcaddr;
}

static int sdk_ver = 0;

static void init_sdk_ver()
{
	char value[32] = {0};

	int len = __system_property_get("ro.build.version.sdk", value);
	if (len <= 0)
	{
		printf("read ro.build.version.sdk error!");
		return;
	}

	sdk_ver = atoi(value);
	printf("ro.build.version.sdk: %d\n", sdk_ver);
}

/* Write NLONG 4 byte words from BUF into PID starting
   at address POS.  Calling process must be attached to PID. */
static int
write_mem(pid_t pid, unsigned long *buf, int nlong, unsigned long pos)
{
	unsigned long *p;
	int i;

	for (p = buf, i = 0; i < nlong; p++, i++)
		if (0 > ptrace(PTRACE_POKETEXT, pid, (void *)(pos + (i * 4)), (void *)*p))
			return -1;
	return 0;
}

static int
read_mem(pid_t pid, unsigned long *buf, int nlong, unsigned long pos)
{
	unsigned long *p;
	int i;

	for (p = buf, i = 0; i < nlong; p++, i++)
		if ((*p = ptrace(PTRACE_PEEKTEXT, pid, (void *)(pos + (i * 4)), (void *)*p)) < 0)
			return -1;
	return 0;
}

unsigned int sc_old[] = {
	// libname
	0xe59f0030, // ldr     r0, [pc, #48] | addr of "libname" in r0
	0xe3a01000, // mov     r1, #0        | r1 = 0 (flags=0)
	0xe1a0e00f, // mov     lr, pc        | populate lr
	0xe59ff028, // ldr     pc, [pc, #40] | call dlopen()
	0xe59fd01c, // ldr     sp, [pc, #28] | fix sp
	0xe59f0008, // ldr     r0, [pc, #12] | fix r0
	0xe59f1008, // ldr     r1, [pc, #12] | fix r1
	0xe59fe008, // ldr     lr, [pc, #12] | fix lr
	0xe59ff008, // ldr     pc, [pc, #12] | fix pc (continue process)
	0xe1a00000, // nop (mov r0,r0)       | r0
	0xe1a00000, // nop (mov r0,r0)       | r1
	0xe1a00000, // nop (mov r0,r0)       | lr
	0xe1a00000, // nop (mov r0,r0)       | pc
	0xe1a00000, // nop (mov r0,r0)       | sp
	0xe1a00000, // nop (mov r0,r0)       | addr of libname
	0xe1a00000  // nop (mov r0,r0)       | dlopen address
};

unsigned int sc[] = {
	0xe59f0040, //        ldr     r0, [pc, #64]   ; 48 <.text+0x48>
	0xe3a01000, //        mov     r1, #0  ; 0x0
	0xe1a0e00f, //        mov     lr, pc
	0xe59ff038, //        ldr     pc, [pc, #56]   ; 4c <.text+0x4c>
	0xe59fd02c, //        ldr     sp, [pc, #44]   ; 44 <.text+0x44>
	0xe59f0010, //        ldr     r0, [pc, #16]   ; 30 <.text+0x30>
	0xe59f1010, //        ldr     r1, [pc, #16]   ; 34 <.text+0x34>
	0xe59f2010, //        ldr     r2, [pc, #16]   ; 38 <.text+0x38>
	0xe59f3010, //        ldr     r3, [pc, #16]   ; 3c <.text+0x3c>
	0xe59fe010, //        ldr     lr, [pc, #16]   ; 40 <.text+0x40>
	0xe59ff010, //        ldr     pc, [pc, #16]   ; 44 <.text+0x44>
	0xe1a00000, //        nop                     r0
	0xe1a00000, //        nop                     r1
	0xe1a00000, //        nop                     r2
	0xe1a00000, //        nop                     r3
	0xe1a00000, //        nop                     lr
	0xe1a00000, //        nop                     pc
	0xe1a00000, //        nop                     sp
	0xe1a00000, //        nop                     addr of libname
	0xe1a00000, //        nop                     dlopenaddr
};

struct pt_regs2
{
	long uregs[18];
};

#define ARM_cpsr uregs[16]
#define ARM_pc uregs[15]
#define ARM_lr uregs[14]
#define ARM_sp uregs[13]
#define ARM_ip uregs[12]
#define ARM_fp uregs[11]
#define ARM_r10 uregs[10]
#define ARM_r9 uregs[9]
#define ARM_r8 uregs[8]
#define ARM_r7 uregs[7]
#define ARM_r6 uregs[6]
#define ARM_r5 uregs[5]
#define ARM_r4 uregs[4]
#define ARM_r3 uregs[3]
#define ARM_r2 uregs[2]
#define ARM_r1 uregs[1]
#define ARM_r0 uregs[0]
#define ARM_ORIG_r0 uregs[17]

#define CPSR_T_MASK (1u << 5)

#define HELPSTR "error usage: %s -p PID -l LIBNAME [-d (debug on)] [-z (zygote)] [-s (appname)] [-Z (trace count)] [-D (debug level)]\n"

int main(int argc, char *argv[])
{
	pid_t pid = 0;
	struct pt_regs2 regs, original_regs;
	unsigned long dlopenaddr, codeaddr, libaddr;
	unsigned long *p;
	int fd = 0;
	int n = 0;
	char buf[32];
	char *arg;
	int opt;
	char *appname = 0;

	while ((opt = getopt(argc, argv, "p:l:dzms:Z:D:")) != -1)
	{
		switch (opt)
		{
		case 'p':
			pid = strtol(optarg, NULL, 0);
			break;
		case 'Z':
			zygote = strtol(optarg, NULL, 0);
			break;
		case 'D':
			debug = strtol(optarg, NULL, 0);
			break;
		case 'l':
			n = strlen(optarg) + 1;
			n = n / 4 + (n % 4 ? 1 : 0);
			arg = malloc(n * sizeof(unsigned long));
			memcpy(arg, optarg, n * 4);
			break;
		case 'd':
			debug = 1;
			break;
		case 'z':
			zygote = 1;
			break;
		case 's':
			zygote = 1;
			appname = strdup(optarg);
			break;
		default:
			fprintf(stderr, HELPSTR, argv[0]);

			exit(0);
			break;
		}
	}

	if (pid == 0 || n == 0)
	{
		fprintf(stderr, HELPSTR, argv[0]);
		exit(0);
	}

	init_sdk_ver();
	if (sdk_ver == 24 || sdk_ver == 25)
		find_symbol(getpid(), "__dl__ZL10dlopen_extPKciPK17android_dlextinfoPv", "linker", &dlopenaddr);
	else if (sdk_ver == 26 || sdk_ver == 27)
		find_symbol(getpid(), "__dl__ZL10dlopen_extPKciPK17android_dlextinfoPKv", "linker", &dlopenaddr);
	else if (sdk_ver == 28)
		find_symbol(getpid(), "__dl___loader_android_dlopen_ext", "linker", &dlopenaddr);
	else
	{
		void *ldl = dlopen("libdl.so", RTLD_LAZY);
		if (ldl)
		{
			dlopenaddr = (unsigned long)dlsym(ldl, "dlopen");
			dlclose(ldl);
		}
	}
	unsigned long int lkaddr;
	unsigned long int lkaddr2;
	find_linker(getpid(), &lkaddr);
	find_linker(pid, &lkaddr2);
	if (debug)
	{
		printf("own linker: 0x%x\n", lkaddr);
		printf("offset %x\n", dlopenaddr - lkaddr);
		printf("tgt linker: %x\n", lkaddr2);
		printf("tgt dlopen : %x\n", lkaddr2 + (dlopenaddr - lkaddr));
	}
	dlopenaddr = lkaddr2 + (dlopenaddr - lkaddr);
	if (debug)
		printf("dlopen: 0x%lx\n", dlopenaddr);

	// Attach
	if (0 > ptrace(PTRACE_ATTACH, pid, 0, 0))
	{
		printf("cannot attach to %d, error!\n", pid);
		exit(1);
	}
	waitpid(pid, NULL, WUNTRACED);

	if (appname)
	{
		if (ptrace(PTRACE_SETOPTIONS, pid, (void *)1, (void *)(PTRACE_O_TRACEFORK)))
		{
			printf("FATAL ERROR: ptrace(PTRACE_SETOPTIONS, ...)");
			return -1;
		}
		ptrace(PTRACE_CONT, pid, (void *)1, 0);

		int t;
		int stat;
		int child_pid = 0;
		for (;;)
		{
			t = waitpid(-1, &stat, __WALL | WUNTRACED);

			if (t != 0 && t == child_pid)
			{
				if (debug > 1)
					printf(".");
				char fname[256];
				sprintf(fname, "/proc/%d/cmdline", child_pid);
				int fp = open(fname, O_RDONLY);
				if (fp < 0)
				{
					ptrace(PTRACE_SYSCALL, child_pid, 0, 0);
					continue;
				}
				read(fp, fname, sizeof(fname));
				close(fp);

				if (strcmp(fname, appname) == 0)
				{
					if (debug)
						printf("zygote -> %s\n", fname);

					// detach from zygote
					ptrace(PTRACE_DETACH, pid, 0, (void *)SIGCONT);

					// now perform on new process
					pid = child_pid;
					break;
				}
				else
				{
					ptrace(PTRACE_SYSCALL, child_pid, 0, 0);
					continue;
				}
			}

			if (WIFSTOPPED(stat) && (WSTOPSIG(stat) == SIGTRAP))
			{
				if ((stat >> 16) & PTRACE_EVENT_FORK)
				{
					if (debug > 1)
						printf("fork\n");
					int b = t; // save parent pid
					ptrace(PTRACE_GETEVENTMSG, t, 0, &child_pid);
					if (debug)
						printf("PID=%d  child=%d\n", t, child_pid);
					t = child_pid;

					if (debug > 1)
						printf("continue parent (zygote) PID=%d\n", b);
					ptrace(PTRACE_CONT, b, (void *)1, 0);

					ptrace(PTRACE_SYSCALL, child_pid, 0, 0);
				}
			}
		}
	}

	if (zygote)
	{
		int i = 0;
		for (i = 0; i < zygote; i++)
		{
			// -- zygote fix ---
			// we have to wait until the syscall is completed, IMPORTANT!
			ptrace(PTRACE_SYSCALL, pid, 0, 0);
			if (debug > 1)
				printf("/");
			waitpid(pid, NULL, 0);

			ptrace(PTRACE_GETREGS, pid, 0, &regs);
			if (regs.ARM_ip != 0)
			{
				if (debug > 1)
					printf("not a syscall entry, wait for entry\n");
				ptrace(PTRACE_SYSCALL, pid, 0, 0);
				waitpid(pid, NULL, 0);
			}

			//if (debug)
			//	printf("process mode: currently waiting in SYSCALL\n");
			ptrace(PTRACE_SYSCALL, pid, 0, 0);
			if (debug > 1)
				printf("\\");
			waitpid(pid, NULL, 0);
			//if (debug)
			//	printf("process mode: SYSCALL completed now inject\n");
			// ---- need to work with zygote --- end ---
		}
	}
	if (debug > 1)
		printf("\n");

	sprintf(buf, "/proc/%d/mem", pid);
	fd = open(buf, O_WRONLY);
	if (0 > fd)
	{
		printf("cannot open %s, error!\n", buf);
		exit(1);
	}
	ptrace(PTRACE_GETREGS, pid, 0, &regs);
	memcpy(&original_regs, &regs, sizeof(regs));

	// setup variables of the loading and fixup code
	/*
	sc[9] = regs.ARM_r0;
	sc[10] = regs.ARM_r1;
	sc[11] = regs.ARM_lr;
	sc[12] = regs.ARM_pc;
	sc[13] = regs.ARM_sp;
	sc[15] = dlopenaddr;
	*/

	sc[11] = regs.ARM_r0;
	sc[12] = regs.ARM_r1;
	sc[13] = regs.ARM_r2;
	sc[14] = regs.ARM_r3;
	sc[15] = regs.ARM_lr;
	sc[16] = regs.ARM_pc;
	sc[17] = regs.ARM_sp;
	sc[19] = dlopenaddr;

	if (debug)
	{
		printf("pc=%lx lr=%lx sp=%lx fp=%lx\n", regs.ARM_pc, regs.ARM_lr, regs.ARM_sp, regs.ARM_fp);
		printf("r0=%lx r1=%lx\n", regs.ARM_r0, regs.ARM_r1);
		printf("r2=%lx r3=%lx\n", regs.ARM_r2, regs.ARM_r3);
	}

	// push library name to stack
	libaddr = regs.ARM_sp - n * 4 - sizeof(sc);
	sc[18] = libaddr;
	//sc[14] = libaddr;
	//printf("libaddr: %x\n", libaddr);

	if (stack_start == 0)
	{
		stack_start = (unsigned long int)strtol(argv[3], NULL, 16);
		stack_start = stack_start << 12;
		stack_end = stack_start + strtol(argv[4], NULL, 0);
	}
	if (debug)
		printf("stack: 0x%x-0x%x leng = %d\n", stack_start, stack_end, stack_end - stack_start);

	// write library name to stack
	if (0 > write_mem(pid, (unsigned long *)arg, n, libaddr))
	{
		printf("cannot write library name (%s) to stack, error!\n", arg);
		exit(1);
	}

	// write code to stack
	codeaddr = regs.ARM_sp - sizeof(sc);
	if (0 > write_mem(pid, (unsigned long *)&sc, sizeof(sc) / sizeof(long), codeaddr))
	{
		printf("cannot write code, error!\n");
		exit(1);
	}

	if (debug)
		printf("executing injection code at 0x%lx\n", codeaddr);

	// calc stack pointer
	regs.ARM_sp = regs.ARM_sp - n * 4 - sizeof(sc);

	// call dlopen()
	regs.ARM_r0 = libaddr;
	regs.ARM_r1 = RTLD_NOW | RTLD_GLOBAL;
	regs.ARM_r2 = 0;
	unsigned long target_libart_base = get_module_base(pid, "libart");
	unsigned long target_caller_addr = target_libart_base + 0x2000;
	regs.ARM_r3 = target_caller_addr;

	regs.ARM_lr = 0;
	regs.ARM_pc = dlopenaddr;

	//进行指令集判断
	if (regs.ARM_pc & 1)
	{
		/* thumb */
		regs.ARM_pc &= (~1u);
		// #define CPSR_T_MASK  ( 1u << 5 )  CPSR为程序状态寄存器
		regs.ARM_cpsr |= CPSR_T_MASK;
	}
	else
	{
		/* arm */
		regs.ARM_cpsr &= ~CPSR_T_MASK;
	}

	if (ptrace(PTRACE_SETREGS, pid, 0, &regs) < 0 || ptrace(PTRACE_CONT, pid, NULL, 0) < 0)
	{
		printf("error\n");
		exit(1);
	}

	int stat = 0;
	waitpid(pid, &stat, WUNTRACED);
	while (stat != 0xb7f)
	{
		if (ptrace(PTRACE_CONT, pid, NULL, 0) < 0)
		{
			printf("while error\n");
			exit(1);
		}
		waitpid(pid, &stat, WUNTRACED);
	}
	// detach and continue
	ptrace(PTRACE_SETREGS, pid, 0, &original_regs);

	ptrace(PTRACE_DETACH, pid, 0, (void *)SIGCONT);

	if (debug)
		printf("library injection completed!\n");

	return 0;
}

```

`hijack/jni/Android.mk`:

```mk
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := hijack 
LOCAL_SRC_FILES := ../hijack.c
LOCAL_ARM_MODE := arm
LOCAL_CFLAGS := -g
LOCAL_CFLAGS += -pie -fPIE
LOCAL_LDFLAGS += -pie -fPIE

include $(BUILD_EXECUTABLE)

```

`hijack/jni/Application.mk`:

```mk
APP_PLATFORM := android-14
APP_ABI := armeabi-v7a

```

`instruments/base/base.c`:

```c
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/select.h>
#include <string.h>
#include <termios.h>
#include <pthread.h>
#include <sys/epoll.h>

#include <jni.h>

#include "util.h"
#include "hook.h"


//static void __attribute__ ((constructor)) base_my_init(void);

static char logfile[] = "/data/local/tmp/adbi.log";

static void logmsgtofile(char *msg)
{
	int fp = open(logfile, O_WRONLY|O_APPEND);
    if (fp != -1) {
	    write(fp, msg, strlen(msg));
	    close(fp);
    }
}

static void logmsgtostdout(char *msg)
{
	write(1, msg, strlen(msg));
}

void* set_logfunction(void *func)
{
	void *old = log_function;
	log_function = func;
	return old;
}

static void base_my_init(void)
{
	// set the log_function
	log_function = logmsgtofile;
}

```

`instruments/base/base.h`:

```h
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */

void* set_logfunction(void *func);

```

`instruments/base/hook.c`:

```c
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/select.h>
#include <string.h>
#include <termios.h>
#include <pthread.h>
#include <sys/epoll.h>

#include <jni.h>

#include "util.h"
#include "hook.h"

//void __attribute__ ((constructor)) my_init(void);

void inline hook_cacheflush(unsigned int begin, unsigned int end)
{	
	const int syscall = 0xf0002;
	__asm __volatile (
		"mov	 r0, %0\n"			
		"mov	 r1, %1\n"
		"mov	 r7, %2\n"
		"mov     r2, #0x0\n"
		"svc     0x00000000\n"
		:
		:	"r" (begin), "r" (end), "r" (syscall)
		:	"r0", "r1", "r7"
		);
}

int hook_direct(struct hook_t *h, unsigned int addr, void *hookf)
{
	int i;
	
	log("addr  = %x\n", addr)
	log("hookf = %lx\n", (unsigned long)hookf)

	if ((addr % 4 == 0 && (unsigned int)hookf % 4 != 0) || (addr % 4 != 0 && (unsigned int)hookf % 4 == 0))
		log("addr 0x%x and hook 0x%lx\n don't match!\n", addr, (unsigned long)hookf)
	
	//log("ARM\n")
	h->thumb = 0;
	h->patch = (unsigned int)hookf;
	h->orig = addr;
	log("orig = %x\n", h->orig)
	h->jump[0] = 0xe59ff000; // LDR pc, [pc, #0]
	h->jump[1] = h->patch;
	h->jump[2] = h->patch;
	for (i = 0; i < 3; i++)
		h->store[i] = ((int*)h->orig)[i];
	for (i = 0; i < 3; i++)
		((int*)h->orig)[i] = h->jump[i];
	
	hook_cacheflush((unsigned int)h->orig, (unsigned int)h->orig+sizeof(h->jumpt));
	return 1;
}

int hook(struct hook_t *h, int pid, char *libname, char *funcname, void *hook_arm, void *hook_thumb)
{
	unsigned long int addr;
	int i;

	if (find_name(pid, funcname, libname, &addr) < 0) {
		log("can't find: %s\n", funcname)
		return 0;
	}
	
	log("hooking:   %s = 0x%lx ", funcname, addr)
	strncpy(h->name, funcname, sizeof(h->name)-1);

	if (addr % 4 == 0) {
		log("ARM using 0x%lx\n", (unsigned long)hook_arm)
		h->thumb = 0;
		h->patch = (unsigned int)hook_arm;
		h->orig = addr;
		h->jump[0] = 0xe59ff000; // LDR pc, [pc, #0]
		h->jump[1] = h->patch;
		h->jump[2] = h->patch;
		for (i = 0; i < 3; i++)
			h->store[i] = ((int*)h->orig)[i];
		for (i = 0; i < 3; i++)
			((int*)h->orig)[i] = h->jump[i];
	}
	else {
		if ((unsigned long int)hook_thumb % 4 == 0)
			log("warning hook is not thumb 0x%lx\n", (unsigned long)hook_thumb)
		h->thumb = 1;
		log("THUMB using 0x%lx\n", (unsigned long)hook_thumb)
		h->patch = (unsigned int)hook_thumb;
		h->orig = addr;	
		h->jumpt[1] = 0xb4;
		h->jumpt[0] = 0x60; // push {r5,r6}
		h->jumpt[3] = 0xa5;
		h->jumpt[2] = 0x03; // add r5, pc, #12
		h->jumpt[5] = 0x68;
		h->jumpt[4] = 0x2d; // ldr r5, [r5]
		h->jumpt[7] = 0xb0;
		h->jumpt[6] = 0x02; // add sp,sp,#8
		h->jumpt[9] = 0xb4;
		h->jumpt[8] = 0x20; // push {r5}
		h->jumpt[11] = 0xb0;
		h->jumpt[10] = 0x81; // sub sp,sp,#4
		h->jumpt[13] = 0xbd;
		h->jumpt[12] = 0x20; // pop {r5, pc}
		if (addr % 4 == 3) {
			h->jumpt[3] = 0xa5;
			h->jumpt[2] = 0x02; // add r5, pc, #8
			memcpy(&h->jumpt[14], (unsigned char*)&h->patch, sizeof(unsigned int));
		} else {
			h->jumpt[15] = 0x46;
			h->jumpt[14] = 0xaf; // mov pc, r5 ; just to pad to 4 byte boundary
			memcpy(&h->jumpt[16], (unsigned char*)&h->patch, sizeof(unsigned int));
		}
		unsigned int orig = addr - 1; // sub 1 to get real address
		for (i = 0; i < 20; i++) {
			h->storet[i] = ((unsigned char*)orig)[i];
			//log("%0.2x ", h->storet[i])
		}
		//log("\n")
		for (i = 0; i < 20; i++) {
			((unsigned char*)orig)[i] = h->jumpt[i];
			//log("%0.2x ", ((unsigned char*)orig)[i])
		}
	}
	hook_cacheflush((unsigned int)h->orig, (unsigned int)h->orig+sizeof(h->jumpt));
	return 1;
}

void hook_precall(struct hook_t *h)
{
	int i;
	
	if (h->thumb) {
		unsigned int orig = h->orig - 1;
		for (i = 0; i < 20; i++) {
			((unsigned char*)orig)[i] = h->storet[i];
		}
	}
	else {
		for (i = 0; i < 3; i++)
			((int*)h->orig)[i] = h->store[i];
	}	
	hook_cacheflush((unsigned int)h->orig, (unsigned int)h->orig+sizeof(h->jumpt));
}

void hook_postcall(struct hook_t *h)
{
	int i;
	
	if (h->thumb) {
		unsigned int orig = h->orig - 1;
		for (i = 0; i < 20; i++)
			((unsigned char*)orig)[i] = h->jumpt[i];
	}
	else {
		for (i = 0; i < 3; i++)
			((int*)h->orig)[i] = h->jump[i];
	}
	hook_cacheflush((unsigned int)h->orig, (unsigned int)h->orig+sizeof(h->jumpt));	
}

void unhook(struct hook_t *h)
{
	log("unhooking %s = %x  hook = %x ", h->name, h->orig, h->patch)
	hook_precall(h);
}

/*
 *  workaround for blocked socket API when process does not have network
 *  permissions
 *
 *  this code simply opens a pseudo terminal (pty) which gives us a
 *  file descriptor. the pty then can be used by another process to
 *  communicate with our instrumentation code. an example program
 *  would be a simple socket-to-pty-bridge
 *  
 *  this function just creates and configures the pty
 *  communication (read, write, poll/select) has to be implemented by hand
 *
 */
int start_coms(int *coms, char *ptsn)
{
	if (!coms) {
		log("coms == null!\n")
		return 0;
	}

	*coms = open("/dev/ptmx", O_RDWR|O_NOCTTY);
	if (*coms <= 0) {
		log("posix_openpt failed\n")
		return 0;
	}
	//else
	//	log("pty created\n")
	if (unlockpt(*coms) < 0) {
		log("unlockpt failed\n")
		return 0;
	}

	if (ptsn)
		strcpy(ptsn, (char*)ptsname(*coms));

	struct termios  ios;
	tcgetattr(*coms, &ios);
	ios.c_lflag = 0;  // disable ECHO, ICANON, etc...
	tcsetattr(*coms, TCSANOW, &ios);

	return 1;
}

```

`instruments/base/hook.h`:

```h
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */

void (*log_function)(char *logmsg);

#define log(...) \
        {char __msg[1024] = {0};\
        snprintf(__msg, sizeof(__msg)-1, __VA_ARGS__);\
        log_function(__msg); }

struct hook_t {
	unsigned int jump[3];
	unsigned int store[3];
	unsigned char jumpt[20];
	unsigned char storet[20];
	unsigned int orig;
	unsigned int patch;
	unsigned char thumb;
	unsigned char name[128];
	void *data;
};

int start_coms(int *coms, char *ptsn);

void hook_cacheflush(unsigned int begin, unsigned int end);	
void hook_precall(struct hook_t *h);
void hook_postcall(struct hook_t *h);
int hook(struct hook_t *h, int pid, char *libname, char *funcname, void *hook_arm, void *hook_thumb);
void unhook(struct hook_t *h);

```

`instruments/base/jni/Android.mk`:

```mk
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := base
LOCAL_SRC_FILES := ../util.c ../hook.c ../base.c
LOCAL_ARM_MODE := arm

include $(BUILD_STATIC_LIBRARY)

```

`instruments/base/jni/Application.mk`:

```mk
APP_PLATFORM := android-14
APP_ABI := armeabi-v7a

```

`instruments/base/util.c`:

```c
/*
 * Elf parsing code taken from: hijack.c (for x86)
 * by Victor Zandy <zandy[at]cs.wisc.edu>
 *
 * Elf parsing code slightly modified for this project
 * (c) Collin Mulliner <collin[at]mulliner.org>
 *
 * License: LGPL v2.1
 *  
 * Termios code taken from glibc with slight modifications for this project
 * 
 */
#define _XOPEN_SOURCE 500
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include <elf.h>
#include <unistd.h>
#include <errno.h>       
#include <sys/mman.h>
#include <termios.h>
#include <sys/ioctl.h>

#include "hook.h"

/* memory map for libraries */
#define MAX_NAME_LEN 256
#define MEMORY_ONLY  "[memory]"
struct mm {
	char name[MAX_NAME_LEN];
	unsigned long start, end;
};

typedef struct symtab *symtab_t;
struct symlist {
	Elf32_Sym *sym;       /* symbols */
	char *str;            /* symbol strings */
	unsigned num;         /* number of symbols */
};
struct symtab {
	struct symlist *st;    /* "static" symbols */
	struct symlist *dyn;   /* dynamic symbols */
};

static void* xmalloc(size_t size)
{
	void *p;
	p = malloc(size);
	if (!p) {
		printf("Out of memory\n");
		exit(1);
	}
	return p;
}

static int my_pread(int fd, void *buf, size_t count, off_t offset)
{
	lseek(fd, offset, SEEK_SET);
	return read(fd, buf, count);
}

static struct symlist* get_syms(int fd, Elf32_Shdr *symh, Elf32_Shdr *strh)
{
	struct symlist *sl, *ret;
	int rv;

	ret = NULL;
	sl = (struct symlist *) xmalloc(sizeof(struct symlist));
	sl->str = NULL;
	sl->sym = NULL;

	/* sanity */
	if (symh->sh_size % sizeof(Elf32_Sym)) { 
		//printf("elf_error\n");
		goto out;
	}

	/* symbol table */
	sl->num = symh->sh_size / sizeof(Elf32_Sym);
	sl->sym = (Elf32_Sym *) xmalloc(symh->sh_size);
	rv = my_pread(fd, sl->sym, symh->sh_size, symh->sh_offset);
	if (0 > rv) {
		//perror("read");
		goto out;
	}
	if (rv != symh->sh_size) {
		//printf("elf error\n");
		goto out;
	}

	/* string table */
	sl->str = (char *) xmalloc(strh->sh_size);
	rv = my_pread(fd, sl->str, strh->sh_size, strh->sh_offset);
	if (0 > rv) {
		//perror("read");
		goto out;
	}
	if (rv != strh->sh_size) {
		//printf("elf error");
		goto out;
	}

	ret = sl;
out:
	return ret;
}

static int do_load(int fd, symtab_t symtab)
{
	int rv;
	size_t size;
	Elf32_Ehdr ehdr;
	Elf32_Shdr *shdr = NULL, *p;
	Elf32_Shdr *dynsymh, *dynstrh;
	Elf32_Shdr *symh, *strh;
	char *shstrtab = NULL;
	int i;
	int ret = -1;
	
	/* elf header */
	rv = read(fd, &ehdr, sizeof(ehdr));
	if (0 > rv) {
		log("read\n")
		goto out;
	}
	if (rv != sizeof(ehdr)) {
		log("elf error 1\n")
		goto out;
	}
	if (strncmp(ELFMAG, ehdr.e_ident, SELFMAG)) { /* sanity */
		log("not an elf\n")
		goto out;
	}
	if (sizeof(Elf32_Shdr) != ehdr.e_shentsize) { /* sanity */
		log("elf error 2\n")
		goto out;
	}

	/* section header table */
	size = ehdr.e_shentsize * ehdr.e_shnum;
	shdr = (Elf32_Shdr *) xmalloc(size);
	rv = my_pread(fd, shdr, size, ehdr.e_shoff);
	if (0 > rv) {
		log("read\n")
		goto out;
	}
	if (rv != size) {
		log("elf error 3 %d %d\n", rv, size)
		goto out;
	}
	
	/* section header string table */
	size = shdr[ehdr.e_shstrndx].sh_size;
	shstrtab = (char *) xmalloc(size);
	rv = my_pread(fd, shstrtab, size, shdr[ehdr.e_shstrndx].sh_offset);
	if (0 > rv) {
		log("read\n")
		goto out;
	}
	if (rv != size) {
		log("elf error 4 %d %d\n", rv, size)
		goto out;
	}

	/* symbol table headers */
	symh = dynsymh = NULL;
	strh = dynstrh = NULL;
	for (i = 0, p = shdr; i < ehdr.e_shnum; i++, p++)
		if (SHT_SYMTAB == p->sh_type) {
			if (symh) {
				log("too many symbol tables\n")
				goto out;
			}
			symh = p;
		} else if (SHT_DYNSYM == p->sh_type) {
			if (dynsymh) {
				log("too many symbol tables\n")
				goto out;
			}
			dynsymh = p;
		} else if (SHT_STRTAB == p->sh_type
			   && !strncmp(shstrtab+p->sh_name, ".strtab", 7)) {
			if (strh) {
				log("too many string tables\n")
				goto out;
			}
			strh = p;
		} else if (SHT_STRTAB == p->sh_type
			   && !strncmp(shstrtab+p->sh_name, ".dynstr", 7)) {
			if (dynstrh) {
				log("too many string tables\n")
				goto out;
			}
			dynstrh = p;
		}
	/* sanity checks */
	if ((!dynsymh && dynstrh) || (dynsymh && !dynstrh)) {
		log("bad dynamic symbol table\n")
		goto out;
	}
	if ((!symh && strh) || (symh && !strh)) {
		log("bad symbol table\n")
		goto out;
	}
	if (!dynsymh && !symh) {
		log("no symbol table\n")
		goto out;
	}

	/* symbol tables */
	if (dynsymh)
		symtab->dyn = get_syms(fd, dynsymh, dynstrh);
	if (symh)
		symtab->st = get_syms(fd, symh, strh);
	ret = 0;
out:
	free(shstrtab);
	free(shdr);
	return ret;
}

static symtab_t load_symtab(char *filename)
{
	int fd;
	symtab_t symtab;

	symtab = (symtab_t) xmalloc(sizeof(*symtab));
	memset(symtab, 0, sizeof(*symtab));

	fd = open(filename, O_RDONLY);
	if (0 > fd) {
		log("%s open\n", __func__);
		return NULL;
	}
	if (0 > do_load(fd, symtab)) {
		log("Error ELF parsing %s\n", filename)
		free(symtab);
		symtab = NULL;
	}
	close(fd);
	return symtab;
}

static int load_memmap(pid_t pid, struct mm *mm, int *nmmp)
{
	char raw[800000]; // increase this if needed for larger "maps"
	char name[MAX_NAME_LEN];
	char *p;
	unsigned long start, end;
	struct mm *m;
	int nmm = 0;
	int fd, rv;
	int i;

	sprintf(raw, "/proc/%d/maps", pid);
	fd = open(raw, O_RDONLY);
	if (0 > fd) {
		//printf("Can't open %s for reading\n", raw);
		return -1;
	}

	/* Zero to ensure data is null terminated */
	memset(raw, 0, sizeof(raw));

	p = raw;
	while (1) {
		rv = read(fd, p, sizeof(raw)-(p-raw));
		if (0 > rv) {
			//perror("read");
			return -1;
		}
		if (0 == rv)
			break;
		p += rv;
		if (p-raw >= sizeof(raw)) {
			//printf("Too many memory mapping\n");
			return -1;
		}
	}
	close(fd);

	p = strtok(raw, "\n");
	m = mm;
	while (p) {
		/* parse current map line */
		rv = sscanf(p, "%08lx-%08lx %*s %*s %*s %*s %s\n",
			    &start, &end, name);

		p = strtok(NULL, "\n");

		if (rv == 2) {
			m = &mm[nmm++];
			m->start = start;
			m->end = end;
			strcpy(m->name, MEMORY_ONLY);
			continue;
		}

		/* search backward for other mapping with same name */
		for (i = nmm-1; i >= 0; i--) {
			m = &mm[i];
			if (!strcmp(m->name, name))
				break;
		}

		if (i >= 0) {
			if (start < m->start)
				m->start = start;
			if (end > m->end)
				m->end = end;
		} else {
			/* new entry */
			m = &mm[nmm++];
			m->start = start;
			m->end = end;
			strcpy(m->name, name);
		}
	}

	*nmmp = nmm;
	return 0;
}

/* Find libc in MM, storing no more than LEN-1 chars of
   its name in NAME and set START to its starting
   address.  If libc cannot be found return -1 and
   leave NAME and START untouched.  Otherwise return 0
   and null-terminated NAME. */
static int find_libname(char *libn, char *name, int len, unsigned long *start, struct mm *mm, int nmm)
{
	int i;
	struct mm *m;
	char *p;
	for (i = 0, m = mm; i < nmm; i++, m++) {
		if (!strcmp(m->name, MEMORY_ONLY))
			continue;
		p = strrchr(m->name, '/');
		if (!p)
			continue;
		p++;
		if (strncmp(libn, p, strlen(libn)))
			continue;
		p += strlen(libn);

		/* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */
		if (!strncmp("so", p, 2) || 1) // || (p[0] == '-' && isdigit(p[1])))
			break;
	}
	if (i >= nmm)
		/* not found */
		return -1;

	*start = m->start;
	strncpy(name, m->name, len);
	if (strlen(m->name) >= len)
		name[len-1] = '\0';
		
	mprotect((void*)m->start, m->end - m->start, PROT_READ|PROT_WRITE|PROT_EXEC);
	return 0;
}

static int lookup2(struct symlist *sl, unsigned char type,
	char *name, unsigned long *val)
{
	Elf32_Sym *p;
	int len;
	int i;

	len = strlen(name);
	for (i = 0, p = sl->sym; i < sl->num; i++, p++) {
		//log("name: %s %x\n", sl->str+p->st_name, p->st_value)
		if (!strncmp(sl->str+p->st_name, name, len) && *(sl->str+p->st_name+len) == 0
		    && ELF32_ST_TYPE(p->st_info) == type) {
			//if (p->st_value != 0) {
			*val = p->st_value;
			return 0;
			//}
		}
	}
	return -1;
}

static int lookup_sym(symtab_t s, unsigned char type,
	   char *name, unsigned long *val)
{
	if (s->dyn && !lookup2(s->dyn, type, name, val))
		return 0;
	if (s->st && !lookup2(s->st, type, name, val))
		return 0;
	return -1;
}

static int lookup_func_sym(symtab_t s, char *name, unsigned long *val)
{
	return lookup_sym(s, STT_FUNC, name, val);
}

int find_name(pid_t pid, char *name, char *libn, unsigned long *addr)
{
	struct mm mm[1000];
	unsigned long libcaddr;
	int nmm;
	char libc[1024];
	symtab_t s;

	if (0 > load_memmap(pid, mm, &nmm)) {
		log("cannot read memory map\n")
		return -1;
	}
	if (0 > find_libname(libn, libc, sizeof(libc), &libcaddr, mm, nmm)) {
		log("cannot find lib: %s\n", libn)
		return -1;
	}
	//log("lib: >%s<\n", libc)
	s = load_symtab(libc);
	if (!s) {
		log("cannot read symbol table\n");
		return -1;
	}
	if (0 > lookup_func_sym(s, name, addr)) {
		log("cannot find function: %s\n", name);
		return -1;
	}
	*addr += libcaddr;
	return 0;
}

int find_libbase(pid_t pid, char *libn, unsigned long *addr)
{
	struct mm mm[1000];
	unsigned long libcaddr;
	int nmm;
	char libc[1024];
	symtab_t s;

	if (0 > load_memmap(pid, mm, &nmm)) {
		log("cannot read memory map\n")
		return -1;
	}
	if (0 > find_libname(libn, libc, sizeof(libc), &libcaddr, mm, nmm)) {
		log("cannot find lib\n");
		return -1;
	}
	*addr = libcaddr;
	return 0;
}

// --------------------------------------------------------------
#if 0

# define IBAUD0 0

/* Set *T to indicate raw mode. */
void cfmakeraw (struct termios *t)
	{
	  t->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
	  t->c_oflag &= ~OPOST;
	  t->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
	  t->c_cflag &= ~(CSIZE|PARENB);
	  t->c_cflag |= CS8;
	  t->c_cc[VMIN] = 1; /* read returns when one char is available. */
	  t->c_cc[VTIME] = 0;
	}
#define __KERNEL_NCCS 19
struct __kernel_termios
	{
	    tcflag_t c_iflag; /* input mode flags */
	    tcflag_t c_oflag; /* output mode flags */
	    tcflag_t c_cflag; /* control mode flags */
	    tcflag_t c_lflag; /* local mode flags */
	    cc_t c_line; /* line discipline */
    cc_t c_cc[__KERNEL_NCCS]; /* control characters */
	};


/* Set the state of FD to *TERMIOS_P. */
int tcsetattr (int fd, int optional_actions, const struct termios *termios_p)
	{
	    struct __kernel_termios k_termios;
	    unsigned long int cmd;
	    int retval;
	
	    switch (optional_actions)
	    {
	    case TCSANOW:
	        cmd = TCSETS;
	        break;
	    case TCSADRAIN:
	        cmd = TCSETSW;
	        break;
	    case TCSAFLUSH:
	        cmd = TCSETSF;
	        break;
	    default:
	        //__set_errno (EINVAL);
	        return -1;
	    }
	
	    k_termios.c_iflag = termios_p->c_iflag & ~IBAUD0;
	    k_termios.c_oflag = termios_p->c_oflag;
	    k_termios.c_cflag = termios_p->c_cflag;
	    k_termios.c_lflag = termios_p->c_lflag;
	    k_termios.c_line = termios_p->c_line;
	#ifdef _HAVE_C_ISPEED
    k_termios.c_ispeed = termios_p->c_ispeed;
	#endif
	#ifdef _HAVE_C_OSPEED
	    k_termios.c_ospeed = termios_p->c_ospeed;
	#endif
	    memcpy (&k_termios.c_cc[0], &termios_p->c_cc[0],
	        __KERNEL_NCCS * sizeof (cc_t));
	
	    retval = ioctl (fd, cmd, &k_termios);
	
	    if (retval == 0 && cmd == TCSETS)
	    {
	    /* The Linux kernel has a bug which silently ignore the invalid
	       c_cflag on pty. We have to check it here. */
	    int save = 0; //errno;
	    retval = ioctl (fd, TCGETS, &k_termios);
	    if (retval)
	    {
	        /* We cannot verify if the setting is ok. We don't return
	           an error (?). */
	        //__set_errno (save);
	        retval = 0;
	    }
	    else if ((termios_p->c_cflag & (PARENB | CREAD))
	        != (k_termios.c_cflag & (PARENB | CREAD))
	        || ((termios_p->c_cflag & CSIZE)
	            && ((termios_p->c_cflag & CSIZE)
	            != (k_termios.c_cflag & CSIZE))))
	    {
	        /* It looks like the Linux kernel silently changed the
	           PARENB/CREAD/CSIZE bits in c_cflag. Report it as an
	           error. */
	        //__set_errno (EINVAL);
	        retval = -1;
	    }
	    }
	
	    return retval;
}

int tcgetattr (int fd, struct termios *termios_p)
	{
	    struct __kernel_termios k_termios;
	    int retval;
	
	    retval = ioctl (fd, TCGETS, &k_termios);
	    if(retval == 0) {
	        termios_p->c_iflag = k_termios.c_iflag;
	        termios_p->c_oflag = k_termios.c_oflag;
	        termios_p->c_cflag = k_termios.c_cflag;
	        termios_p->c_lflag = k_termios.c_lflag;
	        termios_p->c_line = k_termios.c_line;
	#ifdef _HAVE_C_ISPEED
	        termios_p->c_ispeed = k_termios.c_ispeed;
	#endif
	#ifdef _HAVE_C_OSPEED
	        termios_p->c_ospeed = k_termios.c_ospeed;
	#endif
	
	
	        if (sizeof (cc_t) == 1 || _POSIX_VDISABLE == 0
	            || (unsigned char) _POSIX_VDISABLE == (unsigned char) -1)
	        {
			#if 0
	        memset (mempcpy (&termios_p->c_cc[0], &k_termios.c_cc[0],
	                __KERNEL_NCCS * sizeof (cc_t)),
	            _POSIX_VDISABLE, (NCCS - __KERNEL_NCCS) * sizeof (cc_t));
			#endif
	        memset ( (memcpy (&termios_p->c_cc[0], &k_termios.c_cc[0],
	                __KERNEL_NCCS * sizeof (cc_t)) + (__KERNEL_NCCS * sizeof (cc_t))) ,
	            _POSIX_VDISABLE, (NCCS - __KERNEL_NCCS) * sizeof (cc_t));
	
	        } else {
	        size_t cnt;
	
	        memcpy (&termios_p->c_cc[0], &k_termios.c_cc[0],
	            __KERNEL_NCCS * sizeof (cc_t));
	
	        for (cnt = __KERNEL_NCCS; cnt < NCCS; ++cnt)
	            termios_p->c_cc[cnt] = _POSIX_VDISABLE;
	        }
	    }
	
	    return retval;
	}
#endif

```

`instruments/base/util.h`:

```h
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */

#include <termios.h>

int find_name(pid_t pid, char *name, char *libn, unsigned long *addr);
int find_libbase(pid_t pid, char *libn, unsigned long *addr);



```

`instruments/example/epoll.c`:

```c
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/select.h>
#include <string.h>
#include <termios.h>
#include <pthread.h>
#include <sys/epoll.h>
#include <time.h>

#include <jni.h>
#include <stdlib.h>
#include <android/log.h>

#include "../base/hook.h"
#include "../base/base.h"

#undef log

#define log(...) \
        {FILE *fp = fopen("/sdcard/adbi_example.log", "a+"); if (fp) {\
        fprintf(fp, __VA_ARGS__);\
        fclose(fp);}}


// this file is going to be compiled into a thumb mode binary

void __attribute__ ((constructor)) my_init(void);

static struct hook_t eph;

// arm version of hook
extern int my_epoll_wait_arm(void *mp, char *url, int flags,
	void *p1, void *p2, void *p3, void *p4);

/*  
 *  log function to pass to the hooking library to implement central loggin
 *
 *  see: set_logfunction() in base.h
 */
static void my_log(char *msg)
{
	log("%s", msg)
}

int my_epoll_wait(void *mp, char *url, int flags,
	void *p1, void *p2, void *p3, void *p4)
{
	int (*orig_epoll_wait)(
	void *mp, char *url, int flags,
	void *p1, void *p2, void *p3, void *p4);
	orig_epoll_wait = (void*)eph.orig;

	hook_precall(&eph);
	int res = orig_epoll_wait(mp, url, flags, p1, p2, p3, p4);
	hook_postcall(&eph);
	time_t t;
	struct tm *timeinfo;  //结构体
	time(&t);
	timeinfo = localtime(&t);
	log("%s %s\n", asctime(timeinfo), url);
	__android_log_print(ANDROID_LOG_INFO, "JNITag", "url %s", url);
        
	return res;
}

void my_init(void)
{
	__android_log_print(ANDROID_LOG_INFO, "JNITag", "%s started\n", __FILE__);
	log("%s started\n", __FILE__);
 
	set_logfunction(my_log);

	hook(&eph, getpid(), "libijkffmpeg.", "ffio_open_whitelist", my_epoll_wait_arm, my_epoll_wait);
}


```

`instruments/example/epoll_arm.c`:

```c
/*
 *  Collin's Binary Instrumentation Tool/Framework for Android
 *  Collin Mulliner <collin[at]mulliner.org>
 *  http://www.mulliner.org/android/
 *
 *  (c) 2012,2013
 *
 *  License: LGPL v2.1
 *
 */

#include <sys/types.h>
#include <sys/epoll.h>
#include <jni.h>

extern int my_epoll_wait(void *mp, char *url, int flags,
	void *p1, void *p2, void *p3, void *p4);

int my_epoll_wait_arm(void *mp, char *url, int flags,
	void *p1, void *p2, void *p3, void *p4)
{
	return my_epoll_wait(mp, url, flags, p1, p2, p3, p4);
}

```

`instruments/example/jni/Android.mk`:

```mk
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := base
LOCAL_SRC_FILES := ../../base/obj/local/armeabi-v7a/libbase.a
LOCAL_EXPORT_C_INCLUDES := ../../base
include $(PREBUILT_STATIC_LIBRARY)


include $(CLEAR_VARS)
LOCAL_MODULE    := libexample
LOCAL_SRC_FILES := ../epoll.c  ../epoll_arm.c.arm
LOCAL_CFLAGS := -g
LOCAL_STATIC_LIBRARIES := base
LOCAL_LDLIBS+= -L$(SYSROOT)/usr/lib -llog
include $(BUILD_SHARED_LIBRARY)

```

`instruments/example/jni/Application.mk`:

```mk
APP_PLATFORM := android-14
APP_ABI := armeabi-v7a

```

`instruments/example2/demo/app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "com.zhenl.demo"
        minSdkVersion 15
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation project(':epic')
}

```

`instruments/example2/demo/app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

```

`instruments/example2/demo/app/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.zhenl.demo">

    <application
        android:allowBackup="true"
        android:label="@string/app_name"
        android:supportsRtl="true" />
</manifest>

```

`instruments/example2/demo/app/src/main/java/com/zhenl/demo/Main.java`:

```java
package com.zhenl.demo;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.webkit.WebView;

import com.taobao.android.dexposed.ClassUtils;
import com.taobao.android.dexposed.DexposedBridge;
import com.taobao.android.dexposed.XC_MethodHook;

public class Main {

    private static GCDetect detect;

    private static Handler handler = new Handler(Looper.getMainLooper()) {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case 0:
                    Log.e("epic.hook", "keep alive is running");
                    sendEmptyMessageDelayed(0, 10000);
                    break;
                case 1:
                    init();
                    break;
            }
        }
    };

    public static void init() {
        detect = new GCDetect();
        handler.removeMessages(0);
        handler.sendEmptyMessageDelayed(0, 10000);
        DexposedBridge.findAndHookMethod(WebView.class, "loadUrl", String.class, new XC_MethodHook() {
            @Override
            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                Log.e("epic.hook", "loadUrl:" + param.args[0]);
            }
        });
        String SQLiteDatabaseClass = "com.tencent.wcdb.database.SQLiteDatabase";
        try {
            Class cls = ClassUtils.getClass(SQLiteDatabaseClass);
            DexposedBridge.findAndHookMethod(cls, "rawQueryWithFactory",
                    SQLiteDatabaseClass + ".CursorFactory", String.class, Object[].class, String.class, "com.tencent.wcdb.support.CancellationSignal",
                    new XC_MethodHook() {
                        @Override
                        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                            Log.e("rawQueryWithFactory", param.args[1] + ":" + param.args[3]);
                        }
                    });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static class GCDetect {
        @Override
        protected void finalize() throws Throwable {
            Log.e("epic.hook", "Final redemption");
            handler.sendEmptyMessageDelayed(1, 1000);
            super.finalize();
        }
    }
}

```

`instruments/example2/demo/app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#008577</color>
    <color name="colorPrimaryDark">#00574B</color>
    <color name="colorAccent">#D81B60</color>
</resources>

```

`instruments/example2/demo/app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">demo</string>
</resources>

```

`instruments/example2/demo/build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
        

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`instruments/example2/demo/gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true



```

`instruments/example2/demo/gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`instruments/example2/demo/gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`instruments/example2/demo/gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`instruments/example2/demo/settings.gradle`:

```gradle
include ':app', ':epic'

```

`instruments/example2/dex_inject.c`:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dlfcn.h>

#include <jni.h>
#include <stdlib.h>
#include <android/log.h>

#define LOG_TAG "JNITag"
#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)

// this file is going to be compiled into a thumb mode binary

void __attribute__ ((constructor)) my_init(void);

jobject getApplication(JNIEnv *env) {
    jobject application = NULL;
    jclass activity_thread_clz = (*env)->FindClass(env, "android/app/ActivityThread");
    if (activity_thread_clz != NULL) {
        jmethodID get_Application = (*env)->GetStaticMethodID(env, activity_thread_clz,
                                                           "currentActivityThread",
                                                           "()Landroid/app/ActivityThread;");
        if (get_Application != NULL) {
            jobject currentActivityThread = (*env)->CallStaticObjectMethod(env, activity_thread_clz,
                                                                        get_Application);
            jmethodID getal = (*env)->GetMethodID(env, activity_thread_clz, "getApplication",
                                               "()Landroid/app/Application;");
            application = (*env)->CallObjectMethod(env, currentActivityThread, getal);
        }
        return application;
    }
    return application;
}


jstring getPackageName(JNIEnv *env) {
    jobject context = getApplication(env);
    if (context == NULL) {
        LOGE("context is null!");
        return NULL;
    }
    jclass activity = (*env)->GetObjectClass(env, context);
    jmethodID methodId_pack = (*env)->GetMethodID(env, activity, "getPackageName", "()Ljava/lang/String;");
    jstring name_str = (*env)->CallObjectMethod(env, context, methodId_pack);
    return name_str;
}

char* jstringToChar(JNIEnv* env, jstring jstr) {
    char* rtn = NULL;
    jclass clsstring = (*env)->FindClass(env, "java/lang/String");
    jstring strencode = (*env)->NewStringUTF(env, "utf-8");
    jmethodID mid = (*env)->GetMethodID(env,clsstring, "getBytes", "(Ljava/lang/String;)[B");
    jbyteArray barr = (jbyteArray) (*env)->CallObjectMethod(env, jstr, mid, strencode);
    jsize alen = (*env)->GetArrayLength(env, barr);
    jbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);
    if (alen > 0) {
        rtn = (char*) malloc(alen + 1);
        memcpy(rtn, ba, alen);
        rtn[alen] = 0;
    }
    (*env)->ReleaseByteArrayElements(env, barr, ba, 0);
    return rtn;
}

void my_init(void)
{
	LOGD("inject dex started\n");
    const char* dexPath;
    char* dexOptDir;
    const char* className;
    const char* methodName;
    const char* packageName;

    JNIEnv *(*getJNIEnv)();
    void *handle = dlopen( "system/lib/libandroid_runtime.so", RTLD_NOW );
    getJNIEnv = dlsym( handle, "_ZN7android14AndroidRuntime9getJNIEnvEv" );
    if ( !getJNIEnv ) {
        LOGE("can not find getJNIEnv!");
        return;
    }

    JNIEnv *env = getJNIEnv();

    jint ver;
    ver = (*env)->GetVersion( env );
    switch ( ver ) {
    
    case 0x00010001:
    LOGD("JNI version is JNI_VERSION_1_1");break;

    case 0x00010002:
    LOGD("JNI version is JNI_VERSION_1_2");break;

    case 0x00010004:
    LOGD("JNI version is JNI_VERSION_1_4");break;

    case 0x00010006:
    LOGD("JNI version is JNI_VERSION_1_6");break;

    default:
    LOGD("Unknown JNI_VERSION:0x%x",ver);break;
    }

    jclass stringClass, classLoaderClass, dexClassLoaderClass, targetClass;
    jmethodID getSystemClassLoaderMethod, dexClassLoaderContructor, loadClassMethod, targetMethod;
    jobject systemClassLoaderObject, dexClassLoaderObject;
    jstring dexPathString, dexOptDirString, classNameString, tmpString;    
    jobjectArray stringArray;

    LOGD("-------------- now begin dex injection --------------");

    /* set dex dir */
    LOGD("step1: setting dex dir and opt dir...");
    char* temp = "/data/data/%s/cache";
    packageName = jstringToChar(env, getPackageName(env));
    dexPath = "/sdcard/com.zhenl.demo/classes.dex";
    dexOptDir = (char*) malloc(strlen(temp) + strlen(packageName));
    sprintf(dexOptDir, temp, packageName);
    LOGD("dexOptDir: %s\n", dexOptDir);
    className = "com.zhenl.demo.Main";
    methodName = "init"; 
    LOGD("step1 finished!\n");


    /* Get SystemClasLoader */
    LOGD("step2: getting systemClassLoader method and invoke it to get systemClassLoader obeject...");
    stringClass = (*env)->FindClass(env, "java/lang/String");//获取String类
    classLoaderClass = (*env)->FindClass(env, "java/lang/ClassLoader");//获取classLoader类
    getSystemClassLoaderMethod = (*env)->GetStaticMethodID(env, classLoaderClass, "getSystemClassLoader", "()Ljava/lang/ClassLoader;");//获取classLoader中的getSystemClassLoader静态方法
    systemClassLoaderObject = (*env)->CallStaticObjectMethod(env, classLoaderClass, getSystemClassLoaderMethod);//调用getSystemClassLoader静态方法来获取所属对象systemClassLoaderObject
    if (! systemClassLoaderObject) {
        LOGE("Failed to call systemClassLoaderObject");
        return;
    }
    LOGD("step2 finished!\n");

    /* Create DexClassLoader */
    LOGD("step3: using dexClassLoader class to create dexClassLoader object...");
    dexClassLoaderClass = (*env)->FindClass(env, "dalvik/system/DexClassLoader");//获取dexClassLoader类
    dexClassLoaderContructor = (*env)->GetMethodID(env, dexClassLoaderClass, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V");//获取dexClassLoader的Contructor
    dexPathString = (*env)->NewStringUTF(env, dexPath);//将char*转换成jString
    dexOptDirString = (*env)->NewStringUTF(env, dexOptDir);//将char*转换成jString
    dexClassLoaderObject = (*env)->NewObject(env, dexClassLoaderClass, dexClassLoaderContructor, dexPathString, dexOptDirString, NULL, systemClassLoaderObject);//生成自定义的dexClassLoader对象
    LOGD("step3 finished!\n");

    /* Use DexClassLoader to load target class */
    LOGD("step4: using dexClassLoader class to find [loadClass] method and using dexClassLoader object created above to load target class:[%s]...", className);
    loadClassMethod = (*env)->GetMethodID(env, dexClassLoaderClass, "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;");//获取dexClassLoader类中的“loadClass”方法
    classNameString = (*env)->NewStringUTF(env, className);////将char*转换成jString
    targetClass = (jclass)(*env)->CallObjectMethod(env, dexClassLoaderObject, loadClassMethod, classNameString); //调用“loadClass”方法来获取目标类
    if (!targetClass) {
        LOGE("Failed to load target class [%s]", className);
        return;
    }
    LOGD("step4 finished!\n");

    /* Invoke target method */
    LOGD("step5: using [%s] class loaded above to find [%s] method and invoke it...", className, methodName);
    targetMethod = (*env)->GetStaticMethodID(env, targetClass, methodName, "()V");//获取目标类中的静态方法：methodToBeInvoked
    if (!targetMethod) {
        LOGE("Failed to load target method [%s]", methodName);
        return;
    }
    (*env)->CallStaticVoidMethod(env, targetClass, targetMethod);//调用目标静态方法
    LOGD("step5 finished, invoking [%s] method succeeded!", methodName);
}
```

`instruments/example2/jni/Android.mk`:

```mk
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE    := libexample2
LOCAL_SRC_FILES := ../dex_inject.c
LOCAL_CFLAGS := -g
LOCAL_LDLIBS+= -L$(SYSROOT)/usr/lib -llog
include $(BUILD_SHARED_LIBRARY)

```

`instruments/example2/jni/Application.mk`:

```mk
APP_PLATFORM := android-14
APP_ABI := armeabi-v7a

```

`instruments/example3/demo/app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "com.zhenl.demo"
        minSdkVersion 15
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
    }
    sourceSets {
        main {
            java.srcDirs = ['src/main/java', 'src/main/whale/java']
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    externalNativeBuild {
        cmake {
            path "src/main/whale/whale/CMakeLists.txt"
        }
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
}

```

`instruments/example3/demo/app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

```

`instruments/example3/demo/app/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.zhenl.demo">

    <application
        android:allowBackup="true"
        android:label="@string/app_name"
        android:supportsRtl="true" />
</manifest>

```

`instruments/example3/demo/app/src/main/java/com/zhenl/demo/Main.java`:

```java
package com.zhenl.demo;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.webkit.WebView;

import com.lody.whale.xposed.ClassUtils;
import com.lody.whale.xposed.XC_MethodHook;
import com.lody.whale.xposed.XposedBridge;
import com.lody.whale.xposed.XposedHelpers;

public class Main {

    private static GCDetect detect;

    private static Handler handler = new Handler(Looper.getMainLooper()) {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case 0:
                    Log.e("whale.hook", "keep alive is running");
                    sendEmptyMessageDelayed(0, 10000);
                    break;
                case 1:
                    init();
                    break;
            }
        }
    };

    public static void init() {
        detect = new GCDetect();
        handler.removeMessages(0);
        handler.sendEmptyMessageDelayed(0, 10000);
        XposedBridge.hookAllMethods(WebView.class, "loadUrl", new XC_MethodHook() {
            @Override
            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                Log.e("whale.hook", "loadUrl:" + param.args[0]);
            }
        });
        String SQLiteDatabaseClass = "com.tencent.wcdb.database.SQLiteDatabase";
        try {
            Class cls = ClassUtils.getClass(SQLiteDatabaseClass);
            XposedHelpers.findAndHookMethod(cls, "rawQueryWithFactory",
                    ClassUtils.getClass(SQLiteDatabaseClass + ".CursorFactory"), String.class, Object[].class, String.class, "com.tencent.wcdb.support.CancellationSignal",
                    new XC_MethodHook() {
                        @Override
                        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                            Log.e("rawQueryWithFactory", param.args[1] + ":" + param.args[3]);
                        }
                    });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static class GCDetect {
        @Override
        protected void finalize() throws Throwable {
            Log.e("whale.hook", "Final redemption");
            handler.sendEmptyMessageDelayed(1, 1000);
            super.finalize();
        }
    }
}

```

`instruments/example3/demo/app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#008577</color>
    <color name="colorPrimaryDark">#00574B</color>
    <color name="colorAccent">#D81B60</color>
</resources>

```

`instruments/example3/demo/app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">demo</string>
</resources>

```

`instruments/example3/demo/build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
        

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`instruments/example3/demo/gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true



```

`instruments/example3/demo/gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`instruments/example3/demo/gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`instruments/example3/demo/gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`instruments/example3/demo/settings.gradle`:

```gradle
include ':app'

```

`instruments/example3/dex_inject.c`:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dlfcn.h>

#include <jni.h>
#include <stdlib.h>
#include <android/log.h>

#define LOG_TAG "JNITag"
#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)

// this file is going to be compiled into a thumb mode binary

void __attribute__ ((constructor)) my_init(void);

jobject getApplication(JNIEnv *env) {
    jobject application = NULL;
    jclass activity_thread_clz = (*env)->FindClass(env, "android/app/ActivityThread");
    if (activity_thread_clz != NULL) {
        jmethodID get_Application = (*env)->GetStaticMethodID(env, activity_thread_clz,
                                                           "currentActivityThread",
                                                           "()Landroid/app/ActivityThread;");
        if (get_Application != NULL) {
            jobject currentActivityThread = (*env)->CallStaticObjectMethod(env, activity_thread_clz,
                                                                        get_Application);
            jmethodID getal = (*env)->GetMethodID(env, activity_thread_clz, "getApplication",
                                               "()Landroid/app/Application;");
            application = (*env)->CallObjectMethod(env, currentActivityThread, getal);
        }
        return application;
    }
    return application;
}


jstring getPackageName(JNIEnv *env) {
    jobject context = getApplication(env);
    if (context == NULL) {
        LOGE("context is null!");
        return NULL;
    }
    jclass activity = (*env)->GetObjectClass(env, context);
    jmethodID methodId_pack = (*env)->GetMethodID(env, activity, "getPackageName", "()Ljava/lang/String;");
    jstring name_str = (*env)->CallObjectMethod(env, context, methodId_pack);
    return name_str;
}

char* jstringToChar(JNIEnv* env, jstring jstr) {
    char* rtn = NULL;
    jclass clsstring = (*env)->FindClass(env, "java/lang/String");
    jstring strencode = (*env)->NewStringUTF(env, "utf-8");
    jmethodID mid = (*env)->GetMethodID(env,clsstring, "getBytes", "(Ljava/lang/String;)[B");
    jbyteArray barr = (jbyteArray) (*env)->CallObjectMethod(env, jstr, mid, strencode);
    jsize alen = (*env)->GetArrayLength(env, barr);
    jbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);
    if (alen > 0) {
        rtn = (char*) malloc(alen + 1);
        memcpy(rtn, ba, alen);
        rtn[alen] = 0;
    }
    (*env)->ReleaseByteArrayElements(env, barr, ba, 0);
    return rtn;
}

void my_init(void)
{
	LOGD("inject dex started\n");
    const char* dexPath;
    char* dexOptDir;
    const char* className;
    const char* methodName;
    const char* packageName;

    JNIEnv *(*getJNIEnv)();
    void *handle = dlopen( "system/lib/libandroid_runtime.so", RTLD_NOW );
    getJNIEnv = dlsym( handle, "_ZN7android14AndroidRuntime9getJNIEnvEv" );
    if ( !getJNIEnv ) {
        LOGE("can not find getJNIEnv!");
        return;
    }

    JNIEnv *env = getJNIEnv();

    jint ver;
    ver = (*env)->GetVersion( env );
    switch ( ver ) {
    
    case 0x00010001:
    LOGD("JNI version is JNI_VERSION_1_1");break;

    case 0x00010002:
    LOGD("JNI version is JNI_VERSION_1_2");break;

    case 0x00010004:
    LOGD("JNI version is JNI_VERSION_1_4");break;

    case 0x00010006:
    LOGD("JNI version is JNI_VERSION_1_6");break;

    default:
    LOGD("Unknown JNI_VERSION:0x%x",ver);break;
    }

    jclass stringClass, classLoaderClass, dexClassLoaderClass, targetClass;
    jmethodID getSystemClassLoaderMethod, dexClassLoaderContructor, loadClassMethod, targetMethod;
    jobject systemClassLoaderObject, dexClassLoaderObject;
    jstring dexPathString, dexOptDirString, classNameString, tmpString;    
    jobjectArray stringArray;

    LOGD("-------------- now begin dex injection --------------");

    /* set dex dir */
    LOGD("step1: setting dex dir and opt dir...");
    char* temp = "/data/data/%s/cache";
    packageName = jstringToChar(env, getPackageName(env));
    dexPath = "/sdcard/com.zhenl.demo/classes.dex";
    dexOptDir = (char*) malloc(strlen(temp) + strlen(packageName));
    sprintf(dexOptDir, temp, packageName);
    LOGD("dexOptDir: %s\n", dexOptDir);
    className = "com.zhenl.demo.Main";
    methodName = "init"; 
    LOGD("step1 finished!\n");


    /* Get SystemClasLoader */
    LOGD("step2: getting systemClassLoader method and invoke it to get systemClassLoader obeject...");
    stringClass = (*env)->FindClass(env, "java/lang/String");//获取String类
    classLoaderClass = (*env)->FindClass(env, "java/lang/ClassLoader");//获取classLoader类
    getSystemClassLoaderMethod = (*env)->GetStaticMethodID(env, classLoaderClass, "getSystemClassLoader", "()Ljava/lang/ClassLoader;");//获取classLoader中的getSystemClassLoader静态方法
    systemClassLoaderObject = (*env)->CallStaticObjectMethod(env, classLoaderClass, getSystemClassLoaderMethod);//调用getSystemClassLoader静态方法来获取所属对象systemClassLoaderObject
    if (! systemClassLoaderObject) {
        LOGE("Failed to call systemClassLoaderObject");
        return;
    }
    LOGD("step2 finished!\n");

    /* Create DexClassLoader */
    LOGD("step3: using dexClassLoader class to create dexClassLoader object...");
    dexClassLoaderClass = (*env)->FindClass(env, "dalvik/system/DexClassLoader");//获取dexClassLoader类
    dexClassLoaderContructor = (*env)->GetMethodID(env, dexClassLoaderClass, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V");//获取dexClassLoader的Contructor
    dexPathString = (*env)->NewStringUTF(env, dexPath);//将char*转换成jString
    dexOptDirString = (*env)->NewStringUTF(env, dexOptDir);//将char*转换成jString
    dexClassLoaderObject = (*env)->NewObject(env, dexClassLoaderClass, dexClassLoaderContructor, dexPathString, dexOptDirString, NULL, systemClassLoaderObject);//生成自定义的dexClassLoader对象
    LOGD("step3 finished!\n");

    /* Use DexClassLoader to load target class */
    LOGD("step4: using dexClassLoader class to find [loadClass] method and using dexClassLoader object created above to load target class:[%s]...", className);
    loadClassMethod = (*env)->GetMethodID(env, dexClassLoaderClass, "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;");//获取dexClassLoader类中的“loadClass”方法
    classNameString = (*env)->NewStringUTF(env, className);////将char*转换成jString
    targetClass = (jclass)(*env)->CallObjectMethod(env, dexClassLoaderObject, loadClassMethod, classNameString); //调用“loadClass”方法来获取目标类
    if (!targetClass) {
        LOGE("Failed to load target class [%s]", className);
        return;
    }
    LOGD("step4 finished!\n");

    /* Invoke target method */
    LOGD("step5: using [%s] class loaded above to find [%s] method and invoke it...", className, methodName);
    targetMethod = (*env)->GetStaticMethodID(env, targetClass, methodName, "()V");//获取目标类中的静态方法：methodToBeInvoked
    if (!targetMethod) {
        LOGE("Failed to load target method [%s]", methodName);
        return;
    }
    (*env)->CallStaticVoidMethod(env, targetClass, targetMethod);//调用目标静态方法
    LOGD("step5 finished, invoking [%s] method succeeded!", methodName);
}
```

`instruments/example3/jni/Android.mk`:

```mk
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE    := libexample3
LOCAL_SRC_FILES := ../dex_inject.c
LOCAL_CFLAGS := -g
LOCAL_LDLIBS+= -L$(SYSROOT)/usr/lib -llog
include $(BUILD_SHARED_LIBRARY)

```

`instruments/example3/jni/Application.mk`:

```mk
APP_PLATFORM := android-14
APP_ABI := armeabi-v7a

```