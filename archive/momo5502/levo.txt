Project Path: arc_momo5502_levo_s51bhiwm

Source Tree:

```txt
arc_momo5502_levo_s51bhiwm
‚îú‚îÄ‚îÄ CMake
‚îÇ   ‚îî‚îÄ‚îÄ FindLLVM-Wrapper.cmake
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ dependencies
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ XEDConfig.cmake.in
‚îÇ   ‚îú‚îÄ‚îÄ llvm.cmake
‚îÇ   ‚îú‚îÄ‚îÄ superbuild.cmake
‚îÇ   ‚îî‚îÄ‚îÄ xed.cmake
‚îú‚îÄ‚îÄ ghidra_cfg
‚îÇ   ‚îú‚îÄ‚îÄ ExportCFG.java
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ source
    ‚îú‚îÄ‚îÄ CMakeLists.txt
    ‚îú‚îÄ‚îÄ binary
    ‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
    ‚îÇ   ‚îî‚îÄ‚îÄ main.cpp
    ‚îú‚îÄ‚îÄ runtime
    ‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
    ‚îÇ   ‚îú‚îÄ‚îÄ calling_convention.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ ci_string.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ execution_manager.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ external.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ handler_repository.cpp
    ‚îÇ   ‚îú‚îÄ‚îÄ handler_repository.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ handler_utils.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ helpers.cpp
    ‚îÇ   ‚îú‚îÄ‚îÄ lib
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ kernel32.cpp
    ‚îÇ   ‚îú‚îÄ‚îÄ libs.hpp
    ‚îÇ   ‚îú‚îÄ‚îÄ main.cpp
    ‚îÇ   ‚îú‚îÄ‚îÄ memory.hpp
    ‚îÇ   ‚îî‚îÄ‚îÄ system.hpp
    ‚îî‚îÄ‚îÄ shared
        ‚îú‚îÄ‚îÄ CMakeLists.txt
        ‚îú‚îÄ‚îÄ finally.hpp
        ‚îú‚îÄ‚îÄ io.hpp
        ‚îú‚îÄ‚îÄ pe_mapper.cpp
        ‚îî‚îÄ‚îÄ pe_mapper.hpp

```

`CMake/FindLLVM-Wrapper.cmake`:

```cmake
# This is an INTERFACE target for LLVM, usage:
#   target_link_libraries(${PROJECT_NAME} <PRIVATE|PUBLIC|INTERFACE> LLVM-Wrapper)
# The include directories and compile definitions will be properly handled.

if(LLVM-Wrapper_FOUND OR TARGET LLVM-Wrapper)
    return()
endif()

set(CMAKE_FOLDER_LLVM "${CMAKE_FOLDER}")
if(CMAKE_FOLDER)
    set(CMAKE_FOLDER "${CMAKE_FOLDER}/LLVM")
else()
    set(CMAKE_FOLDER "LLVM")
endif()

# Extract the arguments passed to find_package
# Documentation: https://cmake.org/cmake/help/latest/manual/cmake-developer.7.html#find-modules
list(APPEND FIND_ARGS "${LLVM-Wrapper_FIND_VERSION}")
if(LLVM-Wrapper_FIND_QUIETLY)
    list(APPEND FIND_ARGS "QUIET")
endif()
if(LLVM-Wrapper_FIND_REQUIRED)
    list(APPEND FIND_ARGS "REQUIRED")
endif()

# Find LLVM
find_package(LLVM ${FIND_ARGS})

message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

# Split the definitions properly (https://weliveindetail.github.io/blog/post/2017/07/17/notes-setup.html)
separate_arguments(LLVM_DEFINITIONS)

# Some diagnostics (https://stackoverflow.com/a/17666004/1806760)
message(STATUS "LLVM libraries: ${LLVM_AVAILABLE_LIBS}")
message(STATUS "LLVM includes: ${LLVM_INCLUDE_DIRS}")
message(STATUS "LLVM definitions: ${LLVM_DEFINITIONS}")
message(STATUS "LLVM tools: ${LLVM_TOOLS_BINARY_DIR}")

add_library(LLVM-Wrapper INTERFACE IMPORTED)
target_include_directories(LLVM-Wrapper SYSTEM INTERFACE ${LLVM_INCLUDE_DIRS})
target_compile_definitions(LLVM-Wrapper INTERFACE ${LLVM_DEFINITIONS})

if(WIN32)
    target_compile_definitions(LLVM-Wrapper INTERFACE NOMINMAX)

    # If this is linked, this will cause InitializeNativeTarget & co. to be imported from LLVM-C.dll
    # However, the rest of LLVM will be statically linked, resulting in two separate target registries
    list(REMOVE_ITEM LLVM_AVAILABLE_LIBS "LLVM-C")
endif()

# https://github.com/JonathanSalwan/Triton/issues/1082#issuecomment-1030826696
if(LLVM_LINK_LLVM_DYLIB)
    target_link_libraries(LLVM-Wrapper INTERFACE LLVM)
else()
    target_link_libraries(LLVM-Wrapper INTERFACE ${LLVM_AVAILABLE_LIBS})
endif()

# In LLVM 10 (and potentially below) there is a full path to diaguids.lib embedded in the installation
if(WIN32 AND TARGET LLVMDebugInfoPDB)
    get_target_property(LLVMDebugInfoPDB_LIBS LLVMDebugInfoPDB INTERFACE_LINK_LIBRARIES)
    foreach(LLVMDebugInfoPDB_LIB ${LLVMDebugInfoPDB_LIBS})
        if(LLVMDebugInfoPDB_LIB MATCHES "diaguids.lib")
            list(REMOVE_ITEM LLVMDebugInfoPDB_LIBS "${LLVMDebugInfoPDB_LIB}")
            list(APPEND LLVMDebugInfoPDB_LIBS "diaguids.lib")
            break()
        endif()
    endforeach()
    set_target_properties(LLVMDebugInfoPDB PROPERTIES
        INTERFACE_LINK_LIBRARIES "${LLVMDebugInfoPDB_LIBS}"
    )
    unset(LLVMDebugInfoPDB_LIBS)
endif()

set(CMAKE_FOLDER "${CMAKE_FOLDER_LLVM}")
unset(CMAKE_FOLDER_LLVM)

set(LLVM-Wrapper_FOUND ON)
```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

project(levo
  LANGUAGES C CXX
)

if(NOT DEFINED CMAKE_PREFIX_PATH AND NOT DEFINED ENV{CMAKE_PREFIX_PATH})
  set(DEFAULT_PREFIX "${CMAKE_SOURCE_DIR}/dependencies/install")
  if(NOT EXISTS "${DEFAULT_PREFIX}/${CMAKE_SYSTEM}.build")
    message(FATAL_ERROR "Default dependency prefix not found: ${DEFAULT_PREFIX}\nTo build the dependencies, run:\n  cmake -B dependencies/build -S dependencies\n  cmake --build dependencies/build\nAlternatively specify the prefix manually:\n  cmake -B build \"-DCMAKE_PREFIX_PATH:FILEPATH=/path/to/dependencies/install\"")
  else()
    set(CMAKE_PREFIX_PATH "${DEFAULT_PREFIX}")
  endif()
endif()

# Set the optimization level

if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release)
endif()

# Temporarily disabled, as a lot of C98-incompatibility warnings pollute the output
#add_compile_options(-Wall -Wextra)
if(MSVC)
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")

  set(CMAKE_CXX_FLAGS_DEBUG "/Zi /Od")
  set(CMAKE_CXX_FLAGS_RELEASE "/O2 /DNDEBUG")
  #set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "/Zi /Od")
else()
  set(CMAKE_CXX_FLAGS_DEBUG "-g -O0 -fno-limit-debug-info")
  set(CMAKE_CXX_FLAGS_RELEASE "-O3 -g0 -fomit-frame-pointer -march=native")
endif()

# Find the dependencies

set(GFLAGS_USE_TARGET_NAMESPACE ON)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")

find_package(LLVM-Wrapper REQUIRED)
find_package(remill REQUIRED)

add_subdirectory(source)

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# ü™Å Levo

<a href="https://github.com/momo5502/levo?tab=GPL-3.0-1-ov-file.0-1-ov-file"><img src="https://img.shields.io/github/license/momo5502/levo?color=00B0F8"/></a>
<a href="https://github.com/momo5502/levo/actions"><img src="https://img.shields.io/github/actions/workflow/status/momo5502/levo/build.yml?branch=main&label=build"/></a>
<a href="https://github.com/momo5502/levo/issues"><img src="https://img.shields.io/github/issues/momo5502/levo?color=F8B000"/></a>
<img src="https://img.shields.io/github/commit-activity/m/momo5502/levo?color=FF3131"/>  

Levo is an ahead-of-time binary translation toolchain.

> [!NOTE]  
> It is extremely experimental and barely supports anything.  
> It started as a weekend side project. We will see if this ever reaches a state beyond that.

## Pipeline
- Control flow recovery using [Ghidra](https://github.com/NationalSecurityAgency/ghidra)
- Binary lifting using [Remill](https://github.com/lifting-bits/remill)
- Target independent recompilation using [LLVM](https://github.com/llvm/llvm-project)

```

`dependencies/CMakeLists.txt`:

```txt
# https://alexreinking.com/blog/how-to-use-cmake-without-the-agonizing-pain-part-1.html
cmake_minimum_required(VERSION 3.21)

project(dependencies)

option(USE_EXTERNAL_LLVM "Do not compile LLVM as part of the superbuild, use an external one instead" OFF)
option(USE_SANITIZERS "Use ASan and UBSan" OFF)

if(USE_EXTERNAL_LLVM)
    if(CMAKE_HOST_SYSTEM_NAME MATCHES "Darwin" AND NOT CMAKE_PREFIX_PATH)
        execute_process(
            COMMAND brew --prefix llvm
            RESULT_VARIABLE BREW_LLVM
            OUTPUT_VARIABLE BREW_LLVM_PREFIX
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
        if(BREW_LLVM EQUAL 0 AND EXISTS "${BREW_LLVM_PREFIX}")
            set(CMAKE_PREFIX_PATH "${BREW_LLVM_PREFIX}")
            message(STATUS "Found LLVM keg installed by Homebrew at ${BREW_LLVM_PREFIX}")
        else()
            message(WARNING "LLVM not found, to install: brew install llvm")
        endif()
    endif()
    find_package(LLVM CONFIG REQUIRED)
    message(STATUS "LLVM ${LLVM_PACKAGE_VERSION}: ${LLVM_DIR}")
endif()

if(USE_SANITIZERS)
    list(APPEND CMAKE_C_FLAGS "-fsanitize=address,undefined")
    list(APPEND CMAKE_CXX_FLAGS "-fsanitize=address,undefined")
endif()

if(MSVC)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
endif()

include(superbuild.cmake)

simple_git(https://github.com/gflags/gflags 52e94563eba1968783864942fedf6e87e3c611f4
)
simple_git(https://github.com/google/glog v0.7.1
    "-DGFLAGS_USE_TARGET_NAMESPACE:STRING=ON"
    "-DBUILD_TESTING:STRING=OFF"
)
simple_git(https://github.com/google/googletest v1.17.0
    "-Dgtest_force_shared_crt:STRING=ON"
    "-DGFLAGS_USE_TARGET_NAMESPACE:STRING=ON"
)

include(xed.cmake)

if(NOT USE_EXTERNAL_LLVM)
    include(llvm.cmake)
endif()

simple_git(https://github.com/lifting-bits/remill 504ba56170360d5d5068886b83e3b533e772d77a
    "-DREMILL_ENABLE_TESTING:STRING=OFF"
)

```

`dependencies/README.md`:

```md
# dependencies

Standalone dependencies for remill based on [LLVMParty/packages](https://github.com/LLVMParty/packages) (superbuild pattern).

## Building

```sh
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build
```

This will create a [CMake prefix](https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure), which you pass to your project with `-DCMAKE_PREFIX_PATH=/path/to/dependencies/install`. See [presentation.md](https://github.com/LLVMParty/packages/blob/main/presentation.md) and [dependencies.md](https://github.com/LLVMParty/packages/blob/main/dependencies.md) for more information.

## Docker

```sh
export TAG="ghcr.io/llvmparty/remill-template/dependencies:22.04-llvm19.1.7-remill6.0.0"
docker buildx build --platform linux/arm64 -t "$TAG" .
docker buildx build --platform linux/amd64 -t "$TAG" .
docker buildx build --platform linux/arm64,linux/amd64 -t "$TAG" .
docker push "$TAG"
```

```

`dependencies/XEDConfig.cmake.in`:

```in
# /Users/admin/Projects/cxx-common/ports/xed/XEDConfig.cmake

if(XED_FOUND)
    return()
endif()

get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../../../" ABSOLUTE)

find_library(XED_LIBRARY xed PATHS "${PACKAGE_PREFIX_DIR}/lib" NO_CACHE REQUIRED NO_DEFAULT_PATH)
add_library(XED::XED STATIC IMPORTED)
set_target_properties(XED::XED PROPERTIES
    IMPORTED_CONFIGURATIONS "NOCONFIG"
    IMPORTED_LOCATION_NOCONFIG "${XED_LIBRARY}"
    INTERFACE_INCLUDE_DIRECTORIES "${PACKAGE_PREFIX_DIR}/include"
)

find_library(ILD_LIBRARY xed-ild PATHS "${PACKAGE_PREFIX_DIR}/lib" NO_CACHE REQUIRED NO_DEFAULT_PATH)
add_library(XED::ILD STATIC IMPORTED)
set_target_properties(XED::ILD PROPERTIES
    IMPORTED_CONFIGURATIONS "NOCONFIG"
    IMPORTED_LOCATION_NOCONFIG "${XED_LIBRARY}"
    INTERFACE_INCLUDE_DIRECTORIES "${PACKAGE_PREFIX_DIR}/include"
)

set(XED_FOUND ON)

```

`dependencies/llvm.cmake`:

```cmake
option(LLVM_ENABLE_ASSERTIONS "Enable assertions in LLVM" ON)

# Default values for LLVM_URL and LLVM_SHA256. This is required because "-DLLVM_URL=" would be an empty URL
if("${LLVM_URL}" STREQUAL "")
    set(LLVM_URL "https://github.com/llvm/llvm-project/releases/download/llvmorg-19.1.7/llvm-project-19.1.7.src.tar.xz")
endif()
if("${LLVM_SHA256}" STREQUAL "")
    set(LLVM_SHA256 "82401fea7b79d0078043f7598b835284d6650a75b93e64b6f761ea7b63097501")
endif()

set(LLVM_ARGS
    "-DLLVM_ENABLE_PROJECTS:STRING=lld;clang;clang-tools-extra"
    "-DLLVM_ENABLE_RUNTIMES:STRING=compiler-rt"
    "-DLLVM_ENABLE_ASSERTIONS:STRING=${LLVM_ENABLE_ASSERTIONS}"
    "-DLLVM_ENABLE_DUMP:STRING=${LLVM_ENABLE_ASSERTIONS}"
    "-DLLVM_ENABLE_RTTI:STRING=ON"
    "-DLLVM_ENABLE_LIBEDIT:STRING=OFF"
    "-DLLVM_PARALLEL_LINK_JOBS:STRING=1"
    "-DLLVM_ENABLE_DIA_SDK:STRING=OFF"
    # This is meant for LLVM development, we use the DYLIB option instead
    "-DBUILD_SHARED_LIBS:STRING=OFF"
    "-DLLVM_LINK_LLVM_DYLIB:STRING=${BUILD_SHARED_LIBS}"
)

if(USE_SANITIZERS)
    list(APPEND LLVM_ARGS "-DLLVM_USE_SANITIZER:STRING=Address;Undefined")
endif()

ExternalProject_Add(llvm
    URL
        ${LLVM_URL}
    URL_HASH
        "SHA256=${LLVM_SHA256}"
    CMAKE_CACHE_ARGS
        ${CMAKE_ARGS}
        ${LLVM_ARGS}
    CMAKE_GENERATOR
        "Ninja"
    SOURCE_SUBDIR
        "llvm"
)

```

`dependencies/superbuild.cmake`:

```cmake
include_guard()

option(BUILD_SHARED_LIBS "Build using shared libraries" OFF)

# Bail out early for multi-config generators
if(CMAKE_CONFIGURATION_TYPES)
    message(FATAL_ERROR "Multi-config generators are not supported. Use Make/NMake/Ninja instead")
endif()

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

# Default to a Release config
set(CMAKE_BUILD_TYPE "Release" CACHE STRING "")
if(CMAKE_BUILD_TYPE STREQUAL "")
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "" FORCE)
endif()

message(STATUS "Configuration: ${CMAKE_BUILD_TYPE}")

# Default to build/install (setting this variable is not recommended and might cause conflicts)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
    set(CMAKE_INSTALL_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/../install" CACHE PATH "Install prefix" FORCE)
endif()
message(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")

# Save the host platform in the install prefix
make_directory(${CMAKE_INSTALL_PREFIX})
file(TOUCH ${CMAKE_INSTALL_PREFIX}/${CMAKE_SYSTEM}.build)

# Git is necessary for submodules
find_package(Git REQUIRED)
message(STATUS "Git: ${GIT_EXECUTABLE}")

# Ninja is necessary for building the dependencies
find_program(ninja_EXECUTABLE ninja NO_CACHE NO_PACKAGE_ROOT_PATH NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH NO_CMAKE_SYSTEM_PATH NO_CMAKE_INSTALL_PREFIX NO_CMAKE_FIND_ROOT_PATH)
if(ninja_EXECUTABLE STREQUAL "ninja_EXECUTABLE-NOTFOUND")
    message(FATAL_ERROR "Could not find 'ninja' in the PATH")
endif()
message(STATUS "Ninja: ${ninja_EXECUTABLE}")

# Documentation: https://cmake.org/cmake/help/latest/module/ExternalProject.html
include(ExternalProject)

# Hook for ExternalProject_Add to make sure projects build in order
function(ExternalProject_Add name)
    # The DEPENDS argument is fully implicit
    cmake_parse_arguments(HOOK "" "" DEPENDS ${ARGN})
    if(HOOK_DEPENDS)
        message(FATAL_ERROR "Explicit DEPENDS (${HOOK_DEPENDS}) not supported")
    endif()

    # Update the LAST_EXTERNAL_PROJECT property
    get_property(LAST_EXTERNAL_PROJECT GLOBAL PROPERTY LAST_EXTERNAL_PROJECT)
    set_property(GLOBAL PROPERTY LAST_EXTERNAL_PROJECT ${name})

    # Pass the previous project as a dependency to this call
    if(LAST_EXTERNAL_PROJECT)
        set(HOOK_ARGS DEPENDS "${LAST_EXTERNAL_PROJECT}")
        message(STATUS "ExternalProject: ${name} depends on ${LAST_EXTERNAL_PROJECT}")
    else()
        message(STATUS "ExternalProject: ${name}")
    endif()
    _ExternalProject_Add(${name} ${ARGN} ${HOOK_ARGS}
        # Reference: https://www.scivision.dev/cmake-external-project-ninja-verbose/
        USES_TERMINAL_DOWNLOAD ON
        USES_TERMINAL_UPDATE ON
        USES_TERMINAL_PATCH ON
        USES_TERMINAL_CONFIGURE ON
        USES_TERMINAL_BUILD ON
        USES_TERMINAL_INSTALL ON
        USES_TERMINAL_TEST ON
        DOWNLOAD_EXTRACT_TIMESTAMP ON
    )
endfunction()

if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    if(CMAKE_CXX_SIMULATE_ID STREQUAL "MSVC")
        # Suppress warnings for clang-cl builds, some of these cause compilation errors.
        list(APPEND ADDITIONAL_FLAGS "-w")
    elseif(UNIX AND NOT APPLE)
        # To compile shared libraries, everything needs to be compiled as position independent code when using clang on linux
        list(APPEND ADDITIONAL_FLAGS "-fPIC")
    endif()
endif()

# Convert a CMake list to a space-separated list
list(JOIN ADDITIONAL_FLAGS " " ADDITIONAL_FLAGS)

# Default cache variables for all projects
list(APPEND CMAKE_ARGS
    "-DCMAKE_PREFIX_PATH:FILEPATH=${CMAKE_INSTALL_PREFIX};${CMAKE_PREFIX_PATH}"
    "-DCMAKE_INSTALL_PREFIX:FILEPATH=${CMAKE_INSTALL_PREFIX}"
    "-DCMAKE_BUILD_TYPE:STRING=${CMAKE_BUILD_TYPE}"
    "-DBUILD_SHARED_LIBS:STRING=${BUILD_SHARED_LIBS}"
    "-DCMAKE_C_COMPILER:FILEPATH=${CMAKE_C_COMPILER}"
    "-DCMAKE_CXX_COMPILER:FILEPATH=${CMAKE_CXX_COMPILER}"
    "-DCMAKE_C_FLAGS:STRING=${CMAKE_C_FLAGS} ${ADDITIONAL_FLAGS}"
    "-DCMAKE_CXX_FLAGS:STRING=${CMAKE_CXX_FLAGS} ${ADDITIONAL_FLAGS}"
    "-DCMAKE_MSVC_RUNTIME_LIBRARY:STRING=${CMAKE_MSVC_RUNTIME_LIBRARY}"
    "-DCMAKE_POLICY_DEFAULT_CMP0091:STRING=NEW"
)

if(CMAKE_C_COMPILER_LAUNCHER)
    list(APPEND CMAKE_ARGS "-DCMAKE_C_COMPILER_LAUNCHER:STRING=${CMAKE_C_COMPILER_LAUNCHER}")
endif()
if(CMAKE_CXX_COMPILER_LAUNCHER)
    list(APPEND CMAKE_ARGS "-DCMAKE_CXX_COMPILER_LAUNCHER:STRING=${CMAKE_CXX_COMPILER_LAUNCHER}")
endif()

message(STATUS "Compiling all dependencies with the following CMake arguments:")
foreach(CMAKE_ARG ${CMAKE_ARGS})
    message("\t${CMAKE_ARG}")
endforeach()

function(simple_git repo tag)
    set(options)
    set(oneValueArgs SUBDIR)
    set(multiValueArgs)
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    
    get_filename_component(name "${repo}" NAME_WE)
    
    set(source_subdir_args)
    if(ARG_SUBDIR)
        set(source_subdir_args SOURCE_SUBDIR "${ARG_SUBDIR}")
    endif()
    
    ExternalProject_Add(${name}
        GIT_REPOSITORY
            "${repo}"
        GIT_TAG
            "${tag}"
        GIT_PROGRESS
            ON
        ${source_subdir_args}
        CMAKE_CACHE_ARGS
            ${CMAKE_ARGS}
            ${ARG_UNPARSED_ARGUMENTS}
        CMAKE_GENERATOR
            "Ninja"
    )
endfunction()

function(simple_submodule folder)
    set(folder_path "${CMAKE_CURRENT_SOURCE_DIR}/${folder}")
    if(NOT EXISTS "${folder_path}" OR NOT EXISTS "${folder_path}/CMakeLists.txt")
        message(STATUS "Submodule '${folder}' not initialized, running git...")
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" rev-parse --show-toplevel
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
            OUTPUT_VARIABLE git_root
            OUTPUT_STRIP_TRAILING_WHITESPACE
            COMMAND_ERROR_IS_FATAL ANY
        )
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" submodule update --init
            WORKING_DIRECTORY "${git_root}"
            COMMAND_ERROR_IS_FATAL ANY
        )
    endif()
    ExternalProject_Add(${folder}
        SOURCE_DIR
            "${folder_path}"
        CMAKE_CACHE_ARGS
            ${CMAKE_ARGS}
            ${ARGN}
        CMAKE_GENERATOR
            "Ninja"
        # Always trigger the build step (necessary because there is no download step)
        BUILD_ALWAYS
            ON
    )
endfunction()

```

`dependencies/xed.cmake`:

```cmake
find_package(Python3 COMPONENTS Interpreter REQUIRED)
message(STATUS "Python3: ${Python3_EXECUTABLE}")

# Reference: https://github.com/lifting-bits/cxx-common/blob/e0063b2f5986582ed8dcab0c2863abf0893b3082/ports/xed/portfile.cmake

# TODO: pass compiler flags

if(CMAKE_SYSTEM_NAME STREQUAL "Windows" AND MSVC)
    set(compiler ms) #msvc or clang-cl
elseif(CMAKE_CXX_COMPILER_ID MATCHES "^(Apple)?Clang$")
    set(compiler clang)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(compiler gnu)
else()
    message(FATAL_ERROR "Unknown compiler: ${CMAKE_CXX_COMPILER_ID}")
endif()

set(MFILE_ARGS
    "install"
    "--install-dir=install"
    "--cc=${CMAKE_C_COMPILER}"
    "--cxx=${CMAKE_CXX_COMPILER}"
    "--compiler=${compiler}"
)

if(CMAKE_OSX_SYSROOT)
    list(APPEND MFILE_ARGS "--extra-ccflags=-isysroot ${CMAKE_OSX_SYSROOT}")
    list(APPEND MFILE_ARGS "--extra-cxxflags=-isysroot ${CMAKE_OSX_SYSROOT}")
endif()

if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    list(APPEND MFILE_ARGS "--extra-ccflags=${ADDITIONAL_FLAGS}")
    list(APPEND MFILE_ARGS "--extra-cxxflags=${ADDITIONAL_FLAGS}")
endif()

if(USE_SANITIZERS)
    list(APPEND MFILE_ARGS "--extra-ccflags=-fsanitize=address,undefined")
    list(APPEND MFILE_ARGS "--extra-cxxflags=-fsanitize=address,undefined")
endif()

if(BUILD_SHARED_LIBS)
    list(APPEND MFILE_ARGS "--shared")
else()
    list(APPEND MFILE_ARGS "--static")
endif()

if(CMAKE_AR)
    list(APPEND MFILE_ARGS "--ar=${CMAKE_AR}")
endif()

ExternalProject_Add(mbuild
    GIT_REPOSITORY
    "https://github.com/intelxed/mbuild"
    GIT_TAG
    "v2025.11.23"
    GIT_PROGRESS
    ON
    CONFIGURE_COMMAND
    "${CMAKE_COMMAND}" -E true
    BUILD_COMMAND
    "${CMAKE_COMMAND}" -E true
    INSTALL_COMMAND
    "${CMAKE_COMMAND}" -E true
    PREFIX
    xed-prefix
)

ExternalProject_Add(xed
    GIT_REPOSITORY
    "https://github.com/intelxed/xed"
    GIT_TAG
    "v2025.12.14"
    GIT_PROGRESS
    ON
    CMAKE_CACHE_ARGS
    ${CMAKE_ARGS}
    CONFIGURE_COMMAND
    "${CMAKE_COMMAND}" -E true
    BUILD_COMMAND
    "${Python3_EXECUTABLE}" "<SOURCE_DIR>/mfile.py" ${MFILE_ARGS}
    INSTALL_COMMAND
    "${CMAKE_COMMAND}" -E copy_directory <BINARY_DIR>/install "${CMAKE_INSTALL_PREFIX}"
    PREFIX
    xed-prefix
)

# TODO: generate XEDVersion.cmake as well file
configure_file("${CMAKE_CURRENT_SOURCE_DIR}/XEDConfig.cmake.in" "${CMAKE_INSTALL_PREFIX}/lib/cmake/XED/XEDConfig.cmake" @ONLY)

```

`ghidra_cfg/ExportCFG.java`:

```java
/* ###
 * IP: PUBLIC DOMAIN
 *
 * Export Control Flow Graph (functions, basic blocks, edges, indirect targets)
 * to JSON for use by the remill lifter pipeline. Run as a Ghidra headless
 * postScript after analysis.
 *
 * Usage (headless):
 *   analyzeHeadless /path/to/project ProjectName -import game.exe \
 *     -postScript ExportCFG.java output.json
 *
 * Script args: first argument is the output JSON file path (required in headless).
 */

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.block.*;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.FlowType;
import ghidra.util.exception.CancelledException;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ExportCFG extends GhidraScript {

    private static String addrToString(Address addr) {
        return addr == null ? null : "0x" + Long.toHexString(addr.getOffset());
    }

    @Override
    public void run() throws Exception {
        Program program = getCurrentProgram();
        if (program == null) {
            printerr("No current program.");
            return;
        }

        String[] args = getScriptArgs();
        String outputPath = (args != null && args.length > 0) ? args[0] : null;
        if (outputPath == null || outputPath.isEmpty()) {
            printerr("Usage: ExportCFG.java <output.json>");
            return;
        }

        File outFile = new File(outputPath);
        if (outFile.getParentFile() != null) {
            outFile.getParentFile().mkdirs();
        }

        BasicBlockModel blockModel = new BasicBlockModel(program);
        FunctionManager functionManager = program.getFunctionManager();

        CfgOutput output = new CfgOutput();
        output.program_name = program.getDomainFile().getName();
        output.image_base = addrToString(program.getImageBase());
        output.functions = new ArrayList<>();

        Iterator<Function> funcIter = functionManager.getFunctions(true);
        while (funcIter.hasNext()) {
            Function func = funcIter.next();
            if (func.getBody() == null || func.getBody().isEmpty()) continue;

            FunctionCfg fc = new FunctionCfg();
            fc.name = func.getName();
            fc.address = addrToString(func.getEntryPoint());
            fc.blocks = new ArrayList<>();
            fc.edges = new ArrayList<>();
            fc.indirect_call_sites = new ArrayList<>();

            CodeBlockIterator blockIter = blockModel.getCodeBlocksContaining(func.getBody(), getMonitor());
            List<CodeBlock> blocks = new ArrayList<>();
            while (blockIter.hasNext()) {
                try {
                    blocks.add(blockIter.next());
                } catch (CancelledException e) {
                    break;
                }
            }

            for (CodeBlock block : blocks) {
                Block b = new Block();
                b.start = addrToString(block.getFirstStartAddress());
                // end is exclusive (first address after the block)
                b.end = addrToString(block.getMaxAddress().add(1));
                fc.blocks.add(b);
            }

            for (CodeBlock block : blocks) {
                CodeBlockReferenceIterator destIter = block.getDestinations(getMonitor());
                while (destIter.hasNext()) {
                    CodeBlockReference ref;
                    try {
                        ref = destIter.next();
                    } catch (CancelledException e) {
                        break;
                    }
                    FlowType flowType = ref.getFlowType();
                    String edgeType = "branch";
                    if (flowType.isCall()) edgeType = "call";
                    else if (flowType.isFallthrough()) edgeType = "fallthrough";

                    Edge e = new Edge();
                    e.from = addrToString(block.getFirstStartAddress());
                    e.to = addrToString(ref.getDestinationAddress());
                    e.type = edgeType;
                    if (flowType.isComputed()) e.indirect = true;
                    fc.edges.add(e);

                    if (flowType.isComputed() && flowType.isCall()) {
                        fc.indirect_call_sites.add(addrToString(ref.getReferent()));
                    }
                }
            }

            output.functions.add(fc);
        }

        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String json = gson.toJson(output);
        Files.write(outFile.toPath(), json.getBytes(StandardCharsets.UTF_8));
        println("CFG written to " + outFile.getAbsolutePath());
    }

    private static class CfgOutput {
        String program_name;
        String image_base;
        List<FunctionCfg> functions;
    }

    private static class FunctionCfg {
        String name;
        String address;
        List<Block> blocks;
        List<Edge> edges;
        List<String> indirect_call_sites;
    }

    private static class Block {
        String start;
        String end;
    }

    private static class Edge {
        String from;
        String to;
        String type;
        Boolean indirect;
    }
}

```

`ghidra_cfg/README.md`:

```md
# CFG recovery with Ghidra

Export the control flow graph (functions, basic blocks, edges, indirect call sites) from a binary to JSON using Ghidra headless. The output is intended for use by the remill lifter pipeline.

## Prerequisites

- [Ghidra](https://ghidra-sre.org/) installed; `analyzeHeadless` must be on your `PATH` or run from Ghidra‚Äôs support directory (e.g. `Ghidra/support`).

## Usage

1. **Point headless at your script directory**  
   Use `-scriptPath` so Ghidra can find `ExportCFG.java`.

2. **Import and analyze the binary**  
   Use `-import <path_to_binary>` so the program is imported and analyzed before the postScript runs.

3. **Run the CFG export postScript**  
   Use `-postScript ExportCFG.java <output.json>` and pass the desired output JSON path as the first (and only) script argument.

### Example (Unix)

```bash
analyzeHeadless /tmp/ghidra_proj MyProject \
  -import /path/to/game.exe \
  -postScript ExportCFG.java /path/to/cfg_output.json \
  -scriptPath /path/to/levo/ghidra_cfg
```

### Example (Windows)

```powershell
analyzeHeadless C:\ghidra_proj MyProject `
  -import C:\path\to\game.exe `
  -postScript ExportCFG.java C:\path\to\cfg_output.json `
  -scriptPath C:\path\to\levo\ghidra_cfg
```

To run on an already-imported program (no import, no analysis):

```bash
analyzeHeadless /tmp/ghidra_proj MyProject \
  -process existing_binary.exe \
  -postScript ExportCFG.java cfg_output.json \
  -scriptPath /path/to/levo/ghidra_cfg
```

## Output JSON format

- **program_name** ‚Äì Domain file name of the program.
- **image_base** ‚Äì Program image base address (hex string).
- **functions** ‚Äì Array of function CFGs:
  - **name** ‚Äì Function symbol name.
  - **address** ‚Äì Entry point (hex string).
  - **blocks** ‚Äì Basic blocks: `start` and `end` addresses (hex strings). The range is **[start, end)** (inclusive start, exclusive end; `end` is the first address after the last byte of the block).
  - **edges** ‚Äì Control flow edges: `from`, `to` (block start addresses), `type` (`"call"`, `"branch"`, `"fallthrough"`), and optional `indirect: true`.
  - **indirect_call_sites** ‚Äì Addresses of instructions that perform indirect calls (for `call_indirect` table generation).

All addresses are hex strings with a `0x` prefix (e.g. `"0x401000"`).

```

`source/CMakeLists.txt`:

```txt
add_subdirectory(binary)
add_subdirectory(runtime)
add_subdirectory(shared)

```

`source/binary/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(${PROJECT_NAME} ${SRC_FILES})

# Pass LLVM tools dir so we can run llc/clang for --compile (compile and link bytecode)
if(DEFINED LLVM_TOOLS_BINARY_DIR)
  target_compile_definitions(${PROJECT_NAME} PRIVATE
    "LLVM_TOOLS_DIR=\"${LLVM_TOOLS_BINARY_DIR}\""
  )
endif()

target_link_libraries(${PROJECT_NAME} PRIVATE
  LLVM-Wrapper
  remill
  remill_settings
  shared
)

add_dependencies(${PROJECT_NAME} runtime)
```

`source/binary/main.cpp`:

```cpp
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/Support/InitLLVM.h>
#include <llvm/Support/JSON.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/Program.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/CodeGen.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/MC/TargetRegistry.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Analysis/CGSCCPassManager.h>
#include <llvm/Analysis/LoopAnalysisManager.h>
#include <llvm/Passes/PassBuilder.h>
#include <remill/Arch/Arch.h>
#include <remill/BC/IntrinsicTable.h>
#include <remill/BC/TraceLifter.h>
#include <remill/BC/Util.h>
#include <remill/BC/Optimizer.h>

#include <queue>
#include <array>
#include <cstdint>
#include <fstream>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>

#include <llvm/ADT/SmallString.h>
#include <llvm/Support/Path.h>

#include <shared/io.hpp>
#include <shared/pe_mapper.hpp>

namespace levo
{
    // -----------------------------------------------------------------------------
    // CFG types (from Ghidra ExportCFG.java output)
    // -----------------------------------------------------------------------------
    struct CfgBlock
    {
        uint64_t start = 0;
        uint64_t end = 0;
    };

    struct CfgFunction
    {
        std::string name;
        uint64_t address = 0;
        std::vector<CfgBlock> blocks;
        std::vector<std::string> indirect_call_sites;
    };

    struct Cfg
    {
        std::string program_name;
        uint64_t image_base = 0;
        std::vector<CfgFunction> functions;
    };

    struct PeSection
    {
        uint32_t virtual_address = 0;
        uint32_t virtual_size = 0;
        uint32_t pointer_to_raw_data = 0;
        uint32_t size_of_raw_data = 0;
    };

    namespace
    {
        std::string format_hex_address(uint64_t addr)
        {
            std::array<char, 24> hex_buf{};
            snprintf(hex_buf.data(), hex_buf.size(), "0x%" PRIx64, addr);
            return hex_buf.data();
        }

        uint64_t parse_hex_address(const std::string& s)
        {
            if (s.size() >= 2 && (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')))
            {
                return std::stoull(s.substr(2), nullptr, 16);
            }
            return std::stoull(s, nullptr, 16);
        }

        std::string get_string(const llvm::json::Object* obj, const char* key, const char* default_val = "0")
        {
            if (!obj)
            {
                return default_val;
            }
            if (auto s = obj->getString(key))
            {
                return s->str();
            }
            return default_val;
        }

        Cfg load_cfg(const std::string& path)
        {
            std::ifstream f(path);
            if (!f)
            {
                throw std::runtime_error("Cannot open CFG file: " + path);
            }
            std::stringstream buf;
            buf << f.rdbuf();
            llvm::Expected<llvm::json::Value> E = llvm::json::parse(buf.str());
            if (!E)
            {
                throw std::runtime_error("Invalid JSON: " + toString(E.takeError()));
            }
            llvm::json::Object* root = E->getAsObject();
            if (!root)
            {
                throw std::runtime_error("CFG root is not a JSON object");
            }

            Cfg cfg;
            cfg.program_name = get_string(root, "program_name", "");
            cfg.image_base = parse_hex_address(get_string(root, "image_base", "0"));

            if (llvm::json::Array* funcs = root->getArray("functions"))
            {
                for (const llvm::json::Value& v : *funcs)
                {
                    const auto* func = v.getAsObject();
                    if (!func)
                    {
                        continue;
                    }
                    CfgFunction cf;
                    cf.name = get_string(func, "name", "");
                    cf.address = parse_hex_address(get_string(func, "address", "0"));
                    if (const auto* blocks = func->getArray("blocks"))
                    {
                        for (const llvm::json::Value& bv : *blocks)
                        {
                            if (const auto* block = bv.getAsObject())
                            {
                                CfgBlock b;
                                b.start = parse_hex_address(get_string(block, "start", "0"));
                                b.end = parse_hex_address(get_string(block, "end", "0"));
                                cf.blocks.push_back(b);
                            }
                        }
                    }
                    if (const auto* sites = func->getArray("indirect_call_sites"))
                    {
                        for (const llvm::json::Value& av : *sites)
                        {
                            if (auto s = av.getAsString())
                            {
                                cf.indirect_call_sites.push_back(s->str());
                            }
                        }
                    }
                    cfg.functions.push_back(std::move(cf));
                }
            }
            return cfg;
        }

        std::vector<uint8_t> load_binary(const std::filesystem::path& path)
        {
            std::vector<uint8_t> data{};
            if (!read_file(path, data))
            {
                throw std::runtime_error("Failed to read binary: " + path.string());
            }

            return data;
        }

        void OptimizeModule(llvm::Module& M, const llvm::OptimizationLevel optimizationLevel)
        {
            llvm::LoopAnalysisManager LAM;
            llvm::FunctionAnalysisManager FAM;
            llvm::CGSCCAnalysisManager CGAM;
            llvm::ModuleAnalysisManager MAM;

            llvm::PassBuilder PB;

            PB.registerModuleAnalyses(MAM);
            PB.registerCGSCCAnalyses(CGAM);
            PB.registerFunctionAnalyses(FAM);
            PB.registerLoopAnalyses(LAM);
            PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);

            auto MPM = PB.buildPerModuleDefaultPipeline(optimizationLevel);

            MPM.run(M, MAM);
        }

        // Emit object file from Module using LLVM TargetMachine (in-process, no llc).
        bool emit_object_file(llvm::Module& module, const std::string& obj_path)
        {
            std::string error;
            const llvm::Target* target = llvm::TargetRegistry::lookupTarget(module.getTargetTriple(), error);
            if (!target)
            {
                llvm::errs() << "TargetRegistry::lookupTarget failed: " << error << "\n";
                return false;
            }
            llvm::TargetOptions opt;
            std::unique_ptr<llvm::TargetMachine> tm(target->createTargetMachine(module.getTargetTriple(), "generic", "", opt, std::nullopt,
                                                                                std::nullopt, llvm::CodeGenOptLevel::Default, true));
            if (!tm)
            {
                llvm::errs() << "createTargetMachine failed\n";
                return false;
            }
            module.setDataLayout(tm->createDataLayout());

            std::error_code ec;
            llvm::raw_fd_ostream dest(obj_path, ec, llvm::sys::fs::OF_None);
            if (ec)
            {
                llvm::errs() << "Cannot open output object: " << ec.message() << "\n";
                return false;
            }
            llvm::legacy::PassManager pm;
            if (tm->addPassesToEmitFile(pm, dest, nullptr, llvm::CodeGenFileType::ObjectFile))
            {
                llvm::errs() << "Target does not support object emission\n";
                return false;
            }
            pm.run(module);
            dest.flush();
            llvm::outs() << "Emitted object " << obj_path << "\n";
            return true;
        }

        bool link_executable(const std::string& obj_path, const std::string& exe_path, const std::filesystem::path& base_path,
                             uint32_t bitness)
        {
            std::string link_path;
            std::string lib_prefix;
            std::string lib_suffix;
#if defined(LLVM_TOOLS_DIR)
            llvm::SmallString<256> llvm_tools(LLVM_TOOLS_DIR);
            llvm::sys::path::native(llvm_tools);
            std::string tools_dir(llvm_tools.str());
            if (!tools_dir.empty() && tools_dir.back() != '/' && tools_dir.back() != '\\')
            {
                tools_dir += llvm::sys::path::get_separator().str();
            }
#if defined(_WIN32)
            link_path = tools_dir + "lld-link.exe";
            lib_prefix = "";
            lib_suffix = ".lib";
#else
            link_path = tools_dir + "clang++";
            lib_prefix = "lib";
            lib_suffix = ".a";
#endif
#else
#if defined(_WIN32)
            link_path = "lld-link";
#else
            link_path = "clang++";
#endif
#endif

            const std::vector<std::filesystem::path> libraries = {
                base_path / ".." / "runtime" / (lib_prefix + "runtime_" + std::to_string(bitness) + lib_suffix),
                base_path / ".." / "shared" / (lib_prefix + "shared" + lib_suffix),
            };

#if defined(_WIN32)
            std::vector<std::string> link_args = {
                "lld-link", "/DEBUG", "/out:" + exe_path, "/SUBSYSTEM:CONSOLE", obj_path,
            };
#else
            // Use clang++ to link so C++ runtime (typeinfo, vtables) and libc are included
            std::vector<std::string> link_args = {"clang++", "-o", exe_path, obj_path};
#endif

            for (const auto& library : libraries)
            {
                link_args.push_back(library.string());
            }

            std::vector<llvm::StringRef> link_refs(link_args.begin(), link_args.end());
            std::string err_msg;
            int ret = llvm::sys::ExecuteAndWait(link_path, link_refs, std::nullopt, {}, 0, 0, &err_msg);
            if (ret != 0)
            {
                llvm::errs() << "Link failed: " << err_msg << "\n";
                return false;
            }
            llvm::outs() << "Linked " << exe_path << "\n";
            return true;
        }

        // Emit object from Module (in-process) then invoke lld to link.
        bool compile_and_link(llvm::Module& dest_module, const std::string& output_path, const std::filesystem::path& base_path,
                              uint32_t bitness)
        {
            std::string base = output_path;
            const size_t dot = output_path.rfind('.');
            if (dot != std::string::npos && dot > 0)
            {
                base.resize(dot);
            }
#if defined(_WIN32)
            std::string obj_path = base + ".obj";
            std::string exe_path = base + "_transpiled.exe";
#else
            std::string obj_path = base + ".o";
            std::string exe_path = base + "_transpiled";
#endif
            if (!emit_object_file(dest_module, obj_path))
            {
                return false;
            }
            if (!link_executable(obj_path, exe_path, base_path, bitness))
            {
                return false;
            }
            return true;
        }

        // -----------------------------------------------------------------------------
        // TraceManager: provides bytes from image and stores lifted trace decls/defs.
        // Each basic block is lifted as its own function; blocks tail-call to successors.
        // -----------------------------------------------------------------------------
        class CfgTraceManager : public remill::TraceManager
        {
          public:
            CfgTraceManager(const remill::Arch* arch, llvm::Module* module, const std::vector<uint8_t>& image, uint64_t image_base,
                            const Cfg& cfg)
                : arch_(arch),
                  module_(module),
                  image_(image),
                  image_base_(image_base)
            {
                for (const auto& f : cfg.functions)
                {
                    for (const auto& block : f.blocks)
                    {
                        block_bounds_[block.start] = block.end;
                    }
                }
            }

            std::string TraceName(uint64_t addr) override
            {
                auto it = trace_names_.find(addr);
                if (it != trace_names_.end())
                {
                    return it->second;
                }

                return "block_" + format_hex_address(addr);
            }

            void SetLiftedTraceDefinition(uint64_t addr, llvm::Function* lifted_func) override
            {
                std::lock_guard<std::mutex> lock(mu_);
                traces_[addr] = lifted_func;
            }

            llvm::Function* GetLiftedTraceDeclaration(uint64_t addr) override
            {
                std::lock_guard<std::mutex> lock(mu_);
                const auto block_address = GetBasicBlockStart(addr);

                // Only return a declaration for block-start addresses. For mid-block
                // addresses (e.g. fall-through), return nullptr so the TraceLifter
                // decodes the instruction and continues the current trace instead of
                // emitting a tail call to "this address as trace head".
                if (addr != block_address)
                {
                    return nullptr;
                }

                auto it = traces_.find(block_address);
                if (it != traces_.end())
                {
                    return it->second;
                }

                const auto name = TraceName(block_address);
                auto* decl = arch_->DeclareLiftedFunction(name, module_);
                traces_[block_address] = decl;
                lift_queue_.push(block_address);
                return decl;
            }

            llvm::Function* GetLiftedTraceDefinition(uint64_t addr) override
            {
                std::lock_guard<std::mutex> lock(mu_);
                const auto block_address = GetBasicBlockStart(addr);
                auto it = traces_.find(block_address);
                if (it != traces_.end())
                {
                    if (!it->second->isDeclaration())
                    {
                        return it->second;
                    }
                }
                return nullptr;
            }

            bool TryReadExecutableByte(uint64_t addr, uint8_t* byte) override
            {
                if (!GetBasicBlockBounds(addr))
                {
                    return false;
                }

                if (addr < image_base_)
                {
                    return false;
                }

                const auto rva = static_cast<size_t>(addr - image_base_);
                if (rva >= image_.size())
                {
                    return false;
                }

                *byte = image_[rva];
                return true;
            }

            const std::unordered_map<uint64_t, llvm::Function*>& GetLiftedTraces() const
            {
                return traces_;
            }

            std::optional<uint64_t> GetNextLiftAddress()
            {
                std::lock_guard<std::mutex> lock(mu_);
                if (lift_queue_.empty())
                {
                    return std::nullopt;
                }

                const auto result = lift_queue_.front();
                lift_queue_.pop();
                return result;
            }

            uint64_t GetBasicBlockStart(uint64_t addr) const
            {
                const auto bounds = GetBasicBlockBounds(addr);
                if (!bounds)
                {
                    return addr;
                }

                return bounds->first;
            }

            std::optional<std::pair<uint64_t, uint64_t>> GetBasicBlockBounds(uint64_t addr) const
            {
                auto it = block_bounds_.upper_bound(addr);
                if (it == block_bounds_.begin())
                {
                    return std::nullopt;
                }

                --it;

                if (addr >= it->first && addr < it->second)
                {
                    return *it;
                }

                return std::nullopt;
            }

          private:
            const remill::Arch* arch_;
            llvm::Module* module_;
            const std::vector<uint8_t>& image_;
            uint64_t image_base_;
            std::unordered_map<uint64_t, std::string> trace_names_;
            std::mutex mu_;
            std::unordered_map<uint64_t, llvm::Function*> traces_;
            std::map<uint64_t, uint64_t> block_bounds_;
            std::queue<uint64_t> lift_queue_;
        };

        int run(int argc, char** argv)
        {
            llvm::InitLLVM init_llvm(argc, argv);
            llvm::InitializeAllTargets();
            llvm::InitializeAllAsmParsers();
            llvm::InitializeAllAsmPrinters();
            llvm::InitializeAllTargetMCs();

            bool do_compile = false;
            int arg_idx = 1;
            for (; arg_idx < argc && argv[arg_idx] != nullptr; ++arg_idx)
            {
                if (std::string(argv[arg_idx]) == "--compile")
                {
                    do_compile = true;
                    continue;
                }
                break;
            }
            if (argc - arg_idx < 3)
            {
                llvm::errs() << "Usage: " << argv[0] << " [--compile] <cfg.json> <binary> <output.bc>\n"
                             << "  --compile  After writing .bc, emit object (in-process) and link with lld.\n";
                return 1;
            }
            const char* cfg_path = argv[arg_idx];
            const char* binary_path = argv[arg_idx + 1];
            const char* output_path = argv[arg_idx + 2];

            const auto base_path = std::filesystem::path(argv[0]).parent_path();

            Cfg cfg = load_cfg(cfg_path);
            const auto binary_data = load_binary(binary_path);
            const auto architecture = get_pe_architecture(binary_data);
            if (!architecture)
            {
                llvm::errs() << "Failed to get PE architecture\n";
                return 1;
            }

            const auto image = map_pe_file(binary_data);

            llvm::LLVMContext context;

            uint32_t bitness{};
            if (architecture == pe_architecture::x64)
            {
                bitness = 64;
            }
            else if (architecture == pe_architecture::x86)
            {
                bitness = 32;
            }
            else
            {
                llvm::errs() << "Failed to get PE architecture\n";
                return 1;
            }

            remill::Arch::ArchPtr arch = remill::Arch::Get(context, "windows", bitness == 64 ? "amd64_avx512" : "x86_avx");
            if (!arch)
            {
                llvm::errs() << "Failed to get remill arch (windows/amd64)\n";
                return 1;
            }

            // Load arch semantics (required: TraceLifter uses arch->GetInstrinsicTable()
            // which is populated from this module).
            auto module = remill::LoadArchSemantics(arch.get());
            if (!module)
            {
                llvm::errs() << "Failed to load arch semantics (check REMILL_BUILD_SEMANTICS_DIR_*)\n";
                return 1;
            }
            arch->InitFromSemanticsModule(module.get());
            arch->PrepareModule(module.get());

            CfgTraceManager manager(arch.get(), module.get(), image, cfg.image_base, cfg);
            remill::TraceLifter lifter(arch.get(), manager);

            for (const auto& f : cfg.functions)
            {
                for (const auto& block : f.blocks)
                {
                    manager.GetLiftedTraceDeclaration(block.start);
                }
            }

            while (true)
            {
                const auto next_addr = manager.GetNextLiftAddress();
                if (!next_addr)
                {
                    break;
                }

                llvm::outs() << "Lifting block " << format_hex_address(*next_addr) << "\n";

                lifter.Lift(*next_addr);
            }

            remill::OptimizationGuide guide = {};
            remill::OptimizeModule(arch, module, manager.GetLiftedTraces(), guide);

            llvm::Module dest_module("lifted_code", context);
            dest_module.setTargetTriple(module->getTargetTriple());
            arch->PrepareModuleDataLayout(&dest_module);

            std::map<uint64_t, llvm::Function*> final_functions{};

            for (const auto& lifted_entry : manager.GetLiftedTraces())
            {
                remill::MoveFunctionIntoModule(lifted_entry.second, &dest_module);
                final_functions[lifted_entry.first] = dest_module.getFunction(lifted_entry.second->getName());
            }

            dest_module.setTargetTriple(LLVM_HOST_TRIPLE);

            auto* int64_type = llvm::Type::getInt64Ty(context);
            auto* ptr_type = llvm::PointerType::getUnqual(context);
            auto* dispatch_entry_type = llvm::StructType::get(context, {
                                                                           int64_type,
                                                                           ptr_type,
                                                                       });

            std::vector<llvm::Constant*> dispatch_entries;
            dispatch_entries.reserve(final_functions.size());
            for (const auto& final_function : final_functions)
            {
                auto* dispatch_entry =
                    llvm::ConstantStruct::get(dispatch_entry_type, {
                                                                       llvm::ConstantInt::get(int64_type, final_function.first),
                                                                       final_function.second,
                                                                   });
                dispatch_entries.push_back(dispatch_entry);
            }

            auto* null_entry = llvm::ConstantStruct::get(dispatch_entry_type, {
                                                                                  llvm::ConstantInt::get(int64_type, 0),
                                                                                  llvm::ConstantPointerNull::get(ptr_type),
                                                                              });
            dispatch_entries.push_back(null_entry);

            auto* dispatch_array_type = llvm::ArrayType::get(dispatch_entry_type, dispatch_entries.size());
            new llvm::GlobalVariable(dest_module, dispatch_array_type, true, llvm::GlobalValue::ExternalLinkage,
                                     llvm::ConstantArray::get(dispatch_array_type, dispatch_entries), "dispatch_table");

            auto* binary_data_array = llvm::ConstantDataArray::getString(
                context, llvm::StringRef(reinterpret_cast<const char*>(binary_data.data()), binary_data.size()), false);
            new llvm::GlobalVariable(dest_module, binary_data_array->getType(), true, llvm::GlobalValue::ExternalLinkage, binary_data_array,
                                     "binary_data");

            new llvm::GlobalVariable(dest_module, int64_type, true, llvm::GlobalValue::ExternalLinkage,
                                     llvm::ConstantInt::get(int64_type, binary_data.size()), "binary_size");

            new llvm::GlobalVariable(dest_module, int64_type, true, llvm::GlobalValue::ExternalLinkage,
                                     llvm::ConstantInt::get(int64_type, cfg.image_base), "image_base");

            llvm::outs() << "Optimizing module\n";
            OptimizeModule(dest_module, llvm::OptimizationLevel::O3);

            for (auto& func : dest_module)
            {
                func.removeFnAttr(llvm::Attribute::NoUnwind);
                func.setUWTableKind(llvm::UWTableKind::Default);
            }

            std::error_code ec;
            llvm::raw_fd_ostream os(output_path, ec);

            if (ec)
            {
                llvm::errs() << "Cannot open output: " << ec.message() << "\n";
                return 1;
            }

            dest_module.print(os, nullptr);
            llvm::outs() << "Lifted " << cfg.functions.size() << " functions to " << output_path << "\n";

            if (do_compile)
            {
                if (!compile_and_link(dest_module, output_path, base_path, bitness))
                {
                    return 1;
                }
            }

            return 0;
        }
    }
}

int main(int argc, char** argv)
{
    try
    {
        return levo::run(argc, argv);
    }
    catch (const std::exception& e)
    {
        llvm::errs() << "Error: " << e.what() << "\n";
    }
}

```

`source/runtime/CMakeLists.txt`:

```txt
if(NOT TARGET remill_settings)
    message(FATAL_ERROR "Could not find target 'remill_settings' (did remill update?)")
endif()
get_target_property(HELPER_REMILL_INCLUDE_DIR remill_settings INTERFACE_INCLUDE_DIRECTORIES)
if(HELPER_REMILL_INCLUDE STREQUAL "HELPER_REMILL_INCLUDE_DIR-NOTFOUND")
    message(FATAL_ERROR "Could not determine remill include directory")
endif()
set(HELPER_REMILL_SYSROOT_DIR "${HELPER_REMILL_INCLUDE_DIR}/remill/Arch/Runtime/sysroot")
if(NOT EXISTS "${HELPER_REMILL_SYSROOT_DIR}")
    message(FATAL_ERROR "Could not find remill sysroot directory: ${HELPER_REMILL_SYSROOT_DIR}")
endif()

file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

macro(add_runtime_library bitness)
add_library(runtime_${bitness} ${SRC_FILES})
target_include_directories(runtime_${bitness} PRIVATE ${HELPER_REMILL_INCLUDE_DIR})
target_compile_definitions(runtime_${bitness} PRIVATE -DADDRESS_SIZE_BITS=${bitness})
target_link_libraries(runtime_${bitness} PRIVATE shared)
endmacro()

add_runtime_library(32)
add_runtime_library(64)

add_custom_target(runtime ALL DEPENDS runtime_32 runtime_64)

```

`source/runtime/calling_convention.hpp`:

```hpp
#pragma once

#include "memory.hpp"
#include <stdexcept>

namespace levo::runtime
{
    enum class calling_convention
    {
        cdecl,
        stdcall,
    };

    namespace detail
    {
        inline void return_cdecl(Memory& memory, State& state)
        {
            state.gpr.rip.aword = *memory.read<addr_t>(state.gpr.rsp.aword);
            state.gpr.rsp.aword += sizeof(addr_t);
        }

        inline void return_stdcall(Memory& memory, State& state, uint32_t arg_count)
        {
            return_cdecl(memory, state);
            state.gpr.rsp.aword += sizeof(addr_t) * arg_count;
        }

        inline std::optional<addr_t> read_stack_value(Memory& memory, State& state, uint32_t arg_index)
        {
            return memory.read<addr_t>(state.gpr.rsp.aword + (sizeof(addr_t) * arg_index));
        }

        inline std::optional<addr_t> read_argument_win64(Memory& memory, State& state, uint32_t arg_index)
        {
            switch (arg_index)
            {
            case 0:
                return state.gpr.rcx.aword;
            case 1:
                return state.gpr.rdx.aword;
            case 2:
                return state.gpr.r8.aword;
            case 3:
                return state.gpr.r9.aword;
            default:
                return read_stack_value(memory, state, arg_index + 1);
            }
        }
    }

    inline Memory* return_function(Memory& memory, State& state, calling_convention cc, uint32_t arg_count)
    {
        if constexpr (ADDRESS_SIZE_BITS == 32)
        {
            switch (cc)
            {
            case calling_convention::cdecl:
                detail::return_cdecl(memory, state);
                break;
            case calling_convention::stdcall:
                detail::return_stdcall(memory, state, arg_count);
                break;
            default:
                throw std::runtime_error("Unsupported calling convention");
            }
        }
        else
        {
            detail::return_cdecl(memory, state);
        }

        return &memory;
    }

    inline std::optional<addr_t> read_argument(Memory& memory, State& state, calling_convention cc, uint32_t arg_index)
    {
        if constexpr (ADDRESS_SIZE_BITS == 64)
        {
            return detail::read_argument_win64(memory, state, arg_index);
        }

        switch (cc)
        {
        case calling_convention::cdecl:
        case calling_convention::stdcall:
            return detail::read_stack_value(memory, state, arg_index + 1);
        default:
            throw std::runtime_error("Unsupported calling convention");
        }
    }
}

```

`source/runtime/ci_string.hpp`:

```hpp
#pragma once
#include <cctype>
#include <map>
#include <string_view>

namespace levo::runtime
{
    struct ci_char_traits : public std::char_traits<char>
    {
        static char lower(char v)
        {
            return static_cast<char>(tolower(static_cast<uint8_t>(v)));
        }

        static bool eq(char c1, char c2)
        {
            return lower(c1) == lower(c2);
        }
        static bool ne(char c1, char c2)
        {
            return lower(c1) != lower(c2);
        }
        static bool lt(char c1, char c2)
        {
            return lower(c1) < lower(c2);
        }
        static int compare(const char* s1, const char* s2, size_t n)
        {
            while (n-- != 0)
            {
                if (lower(*s1) < lower(*s2))
                {
                    return -1;
                }

                if (lower(*s1) > lower(*s2))
                {
                    return 1;
                }

                ++s1;
                ++s2;
            }
            return 0;
        }
        static const char* find(const char* s, int n, char a)
        {
            while (n-- > 0 && lower(*s) != lower(a))
            {
                ++s;
            }
            return s;
        }
    };

    using ci_string_view = std::basic_string_view<char, ci_char_traits>;

    template <typename T>
    using ci_string_view_map = std::map<ci_string_view, T, std::less<>>;

    inline ci_string_view make_ci_string_view(const std::string_view view)
    {
        return {view.data(), view.size()};
    }
}

```

`source/runtime/execution_manager.hpp`:

```hpp
#pragma once
#include "memory.hpp"

#include <cstddef>
#include <cstring>
#include <map>
#include <span>
#include <array>
#include <stdexcept>
#include <mutex>
#include <shared_mutex>

namespace levo::runtime
{
    inline size_t align_down(const size_t value, const size_t alignment)
    {
        return value & ~(alignment - 1);
    }

    inline size_t align_up(const size_t value, const size_t alignment)
    {
        return align_down(value + alignment - 1, alignment);
    }

    class execution_manager : public Memory
    {
      public:
        bool read(addr_t address, void* buffer, size_t size) override
        {
            std::shared_lock lock(memory_mutex_);

            const auto memory = get_memory(address, size);
            if (memory.size() < size)
            {
                return false;
            }

            memcpy(buffer, memory.data(), size);
            return true;
        }

        bool write(addr_t address, const void* buffer, size_t size) override
        {
            // Maybe we should use a unique lock here?
            std::shared_lock lock(memory_mutex_);

            const auto memory = get_memory(address, size);
            if (memory.size() < size)
            {
                return false;
            }

            memcpy(memory.data(), buffer, size);
            return true;
        }

        bool compare_exchange(addr_t address, void* expected, void* desired, size_t size) override
        {
            std::unique_lock lock(memory_mutex_);

            const auto memory = get_memory(address, size);
            if (memory.size() < size)
            {
                return false;
            }

            const auto matches_expected = memcmp(memory.data(), expected, size) == 0;

            if (matches_expected)
            {
                memcpy(memory.data(), desired, size);
            }
            else
            {
                memcpy(expected, memory.data(), size);
            }

            return true;
        }

        void map(addr_t address, std::vector<uint8_t> data)
        {
            std::unique_lock lock(memory_mutex_);
            memory_[address] = std::move(data);
        }

        void map(addr_t address, size_t size)
        {
            map(address, std::vector<uint8_t>(size, 0));
        }

        addr_t map_somewhere(size_t size)
        {
            std::unique_lock lock(memory_mutex_);

            const auto address = find_free_address(size);
            memory_[address] = std::vector<uint8_t>(size, 0);
            return address;
        }

        void unmap(addr_t address)
        {
            std::unique_lock lock(memory_mutex_);

            const auto it = memory_.find(address);
            if (it != memory_.end())
            {
                memory_.erase(it);
            }
        }

        system_function* get_function(addr_t address)
        {
            std::shared_lock lock(function_mutex_);

            auto it = functions_.find(address);
            if (it != functions_.end())
            {
                return it->second;
            }
            return nullptr;
        }

        void add_function(addr_t address, system_function* function)
        {
            std::unique_lock lock(function_mutex_);
            functions_[address] = function;
        }

        Memory* run(State& state) override
        {
            const auto function = get_function(state.gpr.rip.aword);
            if (!function)
            {
                std::array<char, 100> buffer{};
                snprintf(buffer.data(), buffer.size() - 1, "Function not found at 0x%" ADDR_FORMAT, state.gpr.rip.aword);

                throw std::runtime_error(buffer.data());
            }

            //__attribute__((musttail))
            return function(state, state.gpr.rip.aword, this);
        }

      private:
        std::shared_mutex memory_mutex_;
        std::shared_mutex function_mutex_;
        std::map<addr_t, system_function*> functions_;
        std::map<addr_t, std::vector<uint8_t>> memory_;

        addr_t find_free_address(const size_t size) const
        {
            constexpr addr_t allocation_granularity = 0x10000;
            addr_t last_end = allocation_granularity;

            for (const auto& [address, data] : memory_)
            {
                if (address >= (last_end + size))
                {
                    return last_end;
                }

                last_end = align_up(address + data.size(), allocation_granularity);
            }

            return last_end;
        }

        std::span<uint8_t> get_memory(addr_t address, size_t size = 1)
        {
            auto it = memory_.upper_bound(address);
            if (it == memory_.begin())
            {
                return {};
            }

            --it;

            if (address < it->first && (address + size) > it->second.size())
            {
                return {};
            }

            const auto offset = address - it->first;
            return {it->second.data() + offset, it->second.size() - offset};
        }
    };
}

```

`source/runtime/external.hpp`:

```hpp
#pragma once

#include "system.hpp"

namespace levo::runtime
{
    struct DispatchEntry
    {
        uint64_t address;
        system_function* function;
    };

    extern "C"
    {
        extern const DispatchEntry dispatch_table[];
        extern const uint8_t binary_data[];
        extern const uint64_t binary_size;
        extern const uint64_t image_base;
    }
}

```

`source/runtime/handler_repository.cpp`:

```cpp
#include "handler_repository.hpp"
#include <cassert>

namespace levo::runtime
{
    system_function* handler_repository::lookup(const std::string_view library, const std::string_view function) const
    {
#ifndef NDEBUG
        lookup_done_ = true;
#endif

        const auto library_entry = handlers_.find(make_ci_string_view(library));
        if (library_entry == handlers_.end())
        {
            return nullptr;
        }

        const auto function_entry = library_entry->second.find(make_ci_string_view(function));
        if (function_entry == library_entry->second.end())
        {
            return nullptr;
        }

        return function_entry->second;
    }

    void handler_repository::add(const std::string_view library, const std::string_view function, system_function* handler)
    {
        assert(!lookup_done_ && "Can not add handlers after the first lookup has been done!");
        handlers_[make_ci_string_view(library)][make_ci_string_view(function)] = handler;
    }
}

```

`source/runtime/handler_repository.hpp`:

```hpp
#pragma once

#include "handler_utils.hpp"
#include "ci_string.hpp"

#define REGISTER_LIBRARY(name)     const std::string_view g_handler_library = name
#define REGISTER_HANDLER(cc, name) repo.add(g_handler_library, #name, make_handler<calling_convention::cc, handler_##name>());

namespace levo::runtime
{
    class handler_repository
    {
      public:
        system_function* lookup(std::string_view library, std::string_view function) const;
        void add(std::string_view library, std::string_view function, system_function* handler);

      private:
        ci_string_view_map<ci_string_view_map<system_function*>> handlers_{};

#ifndef NDEBUG
        mutable bool lookup_done_{false};
#endif
    };
}

```

`source/runtime/handler_utils.hpp`:

```hpp
#pragma once
#include "calling_convention.hpp"
#include <tuple>

namespace levo::runtime
{
    struct handler_context
    {
        State& s;
        Memory& m;
    };

    namespace detail
    {
        template <calling_convention CC, typename T>
        // Bigger arguments are not supported yet
        // 64 bit values need to be aligned on the stack,
        // so simply tracking the index is not enough
            requires(sizeof(T) <= sizeof(addr_t))
        T resolve_indexed_argument(const handler_context& c, uint32_t& index)
        {
            const auto result = read_argument(c.m, c.s, CC, index++);
            return static_cast<T>(*result);
        }

        // Technically, this can vary depending on type and calling convention
        // and should be moved to calling_convention.hpp
        template <typename Result>
        void store_result(State& state, const Result& res)
        {
            if constexpr (ADDRESS_SIZE_BITS == 64 || sizeof(res) <= sizeof(addr_t))
            {
                state.gpr.rax.aword = static_cast<addr_t>(res);
            }
            else
            {
                state.gpr.rax.aword = static_cast<addr_t>(res);
                state.gpr.rdx.aword = static_cast<addr_t>(res >> ADDRESS_SIZE_BITS);
            }
        }

        template <calling_convention CC, typename Result, typename... Args>
        void forward_handler(const handler_context& c, Result (*handler)(const handler_context&, Args...))
        {
            uint32_t index = 0;

            std::tuple<const handler_context&, Args...> func_args{
                c,
                resolve_indexed_argument<CC, std::remove_cv_t<std::remove_reference_t<Args>>>(c, index)...,
            };

            if constexpr (std::is_same_v<Result, void>)
            {
                std::apply(handler, std::move(func_args));
            }
            else
            {
                const auto ret = std::apply(handler, std::move(func_args));
                store_result<Result>(c.s, ret);
            }

            return_function(c.m, c.s, CC, index);
        }
    }

    template <calling_convention CC, auto Handler>
    system_function* make_handler()
    {
        return +[](State& state, addr_t, Memory* memory) {
            handler_context c{
                .s = state,
                .m = *memory,
            };

            detail::forward_handler<CC>(c, Handler);
            return memory;
        };
    }
}

```

`source/runtime/helpers.cpp`:

```cpp
#include "memory.hpp"
#include <cstdio>

namespace levo::runtime
{
    namespace
    {
        template <typename T>
        void write_memory(Memory* m, addr_t address, const T& value)
        {
            m->write(address, &value, sizeof(value));
        }

        template <typename T>
        T read_memory(Memory* m, uint64_t address)
        {
            T value{};
            m->read(address, &value, sizeof(value));
            return value;
        }

        template <typename T>
        bool compare_exchange_memory(Memory* m, addr_t address, T& expected, T desired)
        {
            return m->compare_exchange(address, &expected, &desired, sizeof(T));
        }

        int MapFpuExceptToFe(int32_t guest_except)
        {
            int host_except = 0;
            if (guest_except & kFPUExceptionInvalid)
            {
                host_except |= FE_INVALID;
            }
            if (guest_except & kFPUExceptionDivByZero)
            {
                host_except |= FE_DIVBYZERO;
            }
            if (guest_except & kFPUExceptionOverflow)
            {
                host_except |= FE_OVERFLOW;
            }
            if (guest_except & kFPUExceptionUnderflow)
            {
                host_except |= FE_UNDERFLOW;
            }
            if (guest_except & kFPUExceptionPrecision)
            {
                host_except |= FE_INEXACT;
            }
            // NOTE: denormal exception is not available on all architectures
#ifdef FE_DENORMALOPERAND
            if (guest_except & kFPUExceptionDenormal)
            {
                host_except |= FE_DENORMALOPERAND;
            }
#endif // FE_DENORMALOPERAND
#ifdef FE_DENORMAL
            if (guest_except & kFPUExceptionDenormal)
            {
                host_except |= FE_DENORMAL;
            }
#endif
            return host_except;
        }

        int MapFeToFpuExcept(int host_except)
        {
            int guest_except = 0;
            if (host_except & FE_INVALID)
            {
                guest_except |= kFPUExceptionInvalid;
            }
            if (host_except & FE_DIVBYZERO)
            {
                guest_except |= kFPUExceptionDivByZero;
            }
            if (host_except & FE_OVERFLOW)
            {
                guest_except |= kFPUExceptionOverflow;
            }
            if (host_except & FE_UNDERFLOW)
            {
                guest_except |= kFPUExceptionUnderflow;
            }
            if (host_except & FE_INEXACT)
            {
                guest_except |= kFPUExceptionPrecision;
            }
            // NOTE: denormal exception is not available on all architectures
#ifdef FE_DENORMALOPERAND
            if (host_except & FE_DENORMALOPERAND)
            {
                guest_except |= kFPUExceptionDenormal;
            }
#endif // FE_DENORMALOPERAND
#ifdef FE_DENORMAL
            if (host_except & FE_DENORMAL)
            {
                guest_except |= kFPUExceptionDenormal;
            }
#endif
            return guest_except;
        }

        int MapFpuRoundToFe(int32_t guest_round)
        {
            switch (guest_round)
            {
            case kFPURoundToNearestEven:
                return FE_TONEAREST;
            case kFPURoundUpInf:
                return FE_UPWARD;
            case kFPURoundDownNegInf:
                return FE_DOWNWARD;
            case kFPURoundToZero:
                return FE_TOWARDZERO;
            default:
                return FE_TONEAREST;
            }
        }

        int MapFeToFpuRound(int host_round)
        {
            switch (host_round)
            {
            case FE_TONEAREST:
                return kFPURoundToNearestEven;
            case FE_UPWARD:
                return kFPURoundUpInf;
            case FE_DOWNWARD:
                return kFPURoundDownNegInf;
            case FE_TOWARDZERO:
                return kFPURoundToZero;
            default:
                return kFPURoundToNearestEven;
            }
        }

    }

    extern "C"
    {
        Memory* __remill_missing_block(State&, addr_t, Memory* memory)
        {
            return memory;
        }

        Memory* __remill_function_call(State& state, addr_t address, Memory* memory)
        {
            state.gpr.rip.aword = address;
            // __attribute__((musttail))
            return memory->run(state);
        }

        Memory* __remill_jump(State& state, addr_t address, Memory* memory)
        {
            state.gpr.rip.aword = address;
            // __attribute__((musttail))
            return memory->run(state);
        }

        Memory* __remill_function_return(State&, addr_t, Memory* memory)
        {
            return memory;
        }

        Memory* __remill_async_hyper_call(State&, addr_t address, Memory*)
        {
            printf("Async hyper call to 0x%" ADDR_FORMAT "\n", address);
            abort();
        }

        uint8_t __remill_read_memory_8(Memory* m, addr_t a)
        {
            return read_memory<uint8_t>(m, a);
        }

        uint16_t __remill_read_memory_16(Memory* m, addr_t a)
        {
            return read_memory<uint16_t>(m, a);
        }

        uint32_t __remill_read_memory_32(Memory* m, addr_t a)
        {
            return read_memory<uint32_t>(m, a);
        }

        uint64_t __remill_read_memory_64(Memory* m, addr_t a)
        {
            return read_memory<uint64_t>(m, a);
        }

        float32_t __remill_read_memory_f32(Memory* m, addr_t a)
        {
            return read_memory<float32_t>(m, a);
        }

        float64_t __remill_read_memory_f64(Memory* m, addr_t a)
        {
            return read_memory<float64_t>(m, a);
        }

        Memory* __remill_read_memory_f80(Memory* m, addr_t a, float80_t& v)
        {
            v = read_memory<float80_t>(m, a);
            return m;
        }

        Memory* __remill_write_memory_8(Memory* m, addr_t a, uint8_t v)
        {
            write_memory(m, a, v);
            return m;
        }

        Memory* __remill_write_memory_16(Memory* m, addr_t a, uint16_t v)
        {
            write_memory(m, a, v);
            return m;
        }

        Memory* __remill_write_memory_32(Memory* m, addr_t a, uint32_t v)
        {
            write_memory(m, a, v);
            return m;
        }

        Memory* __remill_write_memory_64(Memory* m, addr_t a, uint64_t v)
        {
            write_memory(m, a, v);
            return m;
        }

        Memory* __remill_write_memory_f32(Memory* m, addr_t a, float32_t v)
        {
            write_memory(m, a, v);
            return m;
        }

        Memory* __remill_write_memory_f64(Memory* m, addr_t a, float64_t v)
        {
            write_memory(m, a, v);
            return m;
        }

        NEVER_INLINE Memory* __remill_write_memory_f80(Memory* m, addr_t a, const float80_t& v)
        {
            write_memory(m, a, v);
            return m;
        }

        Memory* __remill_compare_exchange_memory_8(Memory* memory, addr_t addr, uint8_t& expected, uint8_t desired)
        {
            compare_exchange_memory(memory, addr, expected, desired);
            return memory;
        }

        Memory* __remill_compare_exchange_memory_16(Memory* memory, addr_t addr, uint16_t& expected, uint16_t desired)
        {
            compare_exchange_memory(memory, addr, expected, desired);
            return memory;
        }

        Memory* __remill_compare_exchange_memory_32(Memory* memory, addr_t addr, uint32_t& expected, uint32_t desired)
        {
            compare_exchange_memory(memory, addr, expected, desired);
            return memory;
        }

        Memory* __remill_compare_exchange_memory_64(Memory* memory, addr_t addr, uint64_t& expected, uint64_t desired)
        {
            compare_exchange_memory(memory, addr, expected, desired);
            return memory;
        }

        bool __remill_flag_computation_zero(bool result, ...)
        {
            return result;
        }

        bool __remill_flag_computation_sign(bool result, ...)
        {
            return result;
        }

        bool __remill_flag_computation_overflow(bool result, ...)
        {
            return result;
        }

        bool __remill_flag_computation_carry(bool result, ...)
        {
            return result;
        }

        bool __remill_compare_sle(bool result)
        {
            return result;
        }

        bool __remill_compare_slt(bool result)
        {
            return result;
        }

        bool __remill_compare_sge(bool result)
        {
            return result;
        }

        bool __remill_compare_sgt(bool result)
        {
            return result;
        }

        bool __remill_compare_ule(bool result)
        {
            return result;
        }

        bool __remill_compare_ult(bool result)
        {
            return result;
        }

        bool __remill_compare_ugt(bool result)
        {
            return result;
        }

        bool __remill_compare_uge(bool result)
        {
            return result;
        }

        bool __remill_compare_eq(bool result)
        {
            return result;
        }

        bool __remill_compare_neq(bool result)
        {
            return result;
        }

        uint8_t __remill_undefined_8()
        {
            return 0;
        }

        uint16_t __remill_undefined_16()
        {
            return 0;
        }

        uint32_t __remill_undefined_32()
        {
            return 0;
        }

        uint64_t __remill_undefined_64()
        {
            return 0;
        }

        Memory* __remill_atomic_begin(Memory* memory)
        {
            return memory;
        }

        Memory* __remill_atomic_end(Memory* memory)
        {
            return memory;
        }

        Memory* __remill_error(State&, addr_t address, Memory* memory)
        {
            printf("Error at 0x%" ADDR_FORMAT "\n", address);
            abort();
            return memory;
        }

        int32_t __remill_fpu_exception_test(int32_t read_mask)
        {
            int host_mask = MapFpuExceptToFe(read_mask);
            int host_result = std::fetestexcept(host_mask);
            return MapFeToFpuExcept(host_result);
        }

        void __remill_fpu_exception_clear(int32_t clear_mask)
        {
            int host_mask = MapFpuExceptToFe(clear_mask);
            std::feclearexcept(host_mask);
        }

        void __remill_fpu_exception_raise(int32_t except_mask)
        {
            int host_mask = MapFpuExceptToFe(except_mask);
            std::feraiseexcept(host_mask);
        }

        void __remill_fpu_set_rounding(int32_t round_mode)
        {
            int host_mode = MapFpuRoundToFe(round_mode);
            std::fesetround(host_mode);
        }

        int32_t __remill_fpu_get_rounding()
        {
            int host_mode = std::fegetround();
            return MapFeToFpuRound(host_mode);
        }
    }
}

```

`source/runtime/lib/kernel32.cpp`:

```cpp
#include "../handler_repository.hpp"
#include "../libs.hpp"
#include <shared/finally.hpp>
#include <chrono>
#include <atomic>

namespace levo::runtime
{
    namespace
    {
        using DWORD = uint32_t;
        using BOOL = int32_t;
        using BYTE = uint8_t;
        using WORD = uint16_t;
        using FLOAT = float32_t;

        thread_local DWORD last_error = 0;

        std::atomic<uint32_t> globalthread_id = 0;
        thread_local uint32_t current_thread_id = ++globalthread_id;

        addr_t handler_GetStdHandle(const handler_context&, addr_t handle)
        {
            if (handle == (addr_t)-11)
            {
                return 1;
            }

            return (addr_t)~0ULL;
        }

        addr_t handler_WriteFile(const handler_context& c, addr_t handle, addr_t buffer, uint32_t size, addr_t written_size, addr_t)
        {
            size_t written = 0;
            const auto _ = finally([&] {
                if (written_size)
                {
                    c.m.write(written_size, static_cast<uint32_t>(written));
                }
            });

            if (handle != 1)
            {
                return 0;
            }

            const auto string = c.m.read(buffer, size);
            written = fwrite(string->data(), 1, string->size(), stdout);

            return 1;
        }

        void handler_ExitProcess(const handler_context&, uint32_t exit_code)
        {
            exit(static_cast<int>(exit_code));
        }

        void handler_GetSystemTimeAsFileTime(const handler_context& c, addr_t file_time_ptr)
        {
            constexpr auto HUNDRED_NANOSECONDS_IN_ONE_SECOND = 10000000LL;
            constexpr auto EPOCH_DIFFERENCE_1601_TO_1970_SECONDS = 11644473600LL;

            auto now = std::chrono::system_clock::now();
            auto now_time_t = std::chrono::system_clock::to_time_t(now);

            const uint64_t time = (now_time_t * HUNDRED_NANOSECONDS_IN_ONE_SECOND) + EPOCH_DIFFERENCE_1601_TO_1970_SECONDS;
            c.m.write(file_time_ptr, time);
        }

        uint32_t handler_GetCurrentThreadId(const handler_context&)
        {
            return current_thread_id;
        }

        uint32_t handler_GetCurrentProcessId(const handler_context&)
        {
            return 1;
        }

        BOOL handler_QueryPerformanceCounter(const handler_context& c, addr_t counter)
        {
            if (!counter)
            {
                return 0;
            }

            const auto now = std::chrono::high_resolution_clock::now().time_since_epoch();
            const uint64_t result = std::chrono::duration_cast<std::chrono::nanoseconds>(now).count();

            c.m.write(counter, result);

            return true;
        }

        BOOL handler_IsProcessorFeaturePresent(const handler_context&, DWORD)
        {
            return 1;
        }

        addr_t handler_LoadLibraryExW(const handler_context&, addr_t, addr_t, DWORD)
        {
            return 0;
        }

        DWORD handler_GetLastError(const handler_context&)
        {
            return last_error;
        }

        void handler_SetLastError(const handler_context&, DWORD error)
        {
            last_error = error;
        }

        BOOL handler_InitializeCriticalSectionAndSpinCount(const handler_context&, addr_t, DWORD)
        {
            return 1;
        }
    }

    namespace lib
    {
        void kernel32(handler_repository& repo)
        {
            REGISTER_LIBRARY("kernel32.dll");
            REGISTER_HANDLER(stdcall, GetStdHandle);
            REGISTER_HANDLER(stdcall, WriteFile);
            REGISTER_HANDLER(stdcall, ExitProcess);
            REGISTER_HANDLER(stdcall, GetSystemTimeAsFileTime);
            REGISTER_HANDLER(stdcall, GetCurrentThreadId);
            REGISTER_HANDLER(stdcall, GetCurrentProcessId);
            REGISTER_HANDLER(stdcall, QueryPerformanceCounter);
            REGISTER_HANDLER(stdcall, IsProcessorFeaturePresent);
            REGISTER_HANDLER(stdcall, LoadLibraryExW);
            REGISTER_HANDLER(stdcall, GetLastError);
            REGISTER_HANDLER(stdcall, SetLastError);
            REGISTER_HANDLER(stdcall, InitializeCriticalSectionAndSpinCount);
        }
    }
}

```

`source/runtime/libs.hpp`:

```hpp
#pragma once

namespace levo::runtime
{
    class handler_repository;

    namespace lib
    {
        void kernel32(handler_repository& repo);
    }

    inline void register_libs(handler_repository& repo)
    {
        lib::kernel32(repo);
    }
}

```

`source/runtime/main.cpp`:

```cpp
#include "system.hpp"
#include "external.hpp"
#include "execution_manager.hpp"
#include "handler_repository.hpp"

#include <shared/io.hpp>
#include <shared/pe_mapper.hpp>

#include "libs.hpp"

namespace levo::runtime
{
    namespace
    {
        std::vector<uint8_t> map_binary(const pe_import_resolver_t& import_resolver)
        {
            std::span<const uint8_t> data(binary_data, binary_size);
            return map_pe_file(data, import_resolver);
        }

        int run()
        {
            handler_repository repo{};
            register_libs(repo);

            execution_manager manager{};

            addr_t import_address = static_cast<addr_t>(0xF) << (ADDRESS_SIZE_BITS - 4);

            const auto import_resolver = [&](std::string_view library, std::string_view function) {
                const auto address = import_address++;

                auto* handler = repo.lookup(library, function);
                if (!handler)
                {
                    printf("Missing handler for %.*s::%.*s at 0x%" ADDR_FORMAT "\n", (int)library.size(), library.data(),
                           (int)function.size(), function.data(), address);
                    return address;
                }

                manager.add_function(address, handler);
                return address;
            };

            auto binary = map_binary(import_resolver);
            const auto entry_point = get_entry_point(binary);

            manager.map(image_base, std::move(binary));

            constexpr size_t stack_size = 0x100000;
            const auto stack_address = manager.map_somewhere(stack_size);

            for (size_t i = 0;; i++)
            {
                const auto& entry = dispatch_table[i];
                if (entry.address == 0)
                {
                    break;
                }

                manager.add_function(entry.address, entry.function);
            }

            State state{};
            state.gpr.rip.aword = static_cast<addr_t>(image_base + entry_point);
            state.gpr.rsp.aword = align_down(stack_address + stack_size - 0x10, 0x10);

            manager.run(state);

            return 0;
        }
    }
}

int main(int argc, char** argv)
{
    (void)argc;
    (void)argv;

    try
    {
        return levo::runtime::run();
    }
    catch (const std::exception& e)
    {
        printf("Error: %s\n", e.what());
    }
}

```

`source/runtime/memory.hpp`:

```hpp
#pragma once
#include "system.hpp"

#include <optional>
#include <vector>

struct Memory
{
    virtual bool read(addr_t address, void* buffer, size_t size) = 0;
    virtual bool write(addr_t address, const void* buffer, size_t size) = 0;
    virtual bool compare_exchange(addr_t address, void* expected, void* desired, size_t size) = 0;
    virtual Memory* run(State& state) = 0;

    template <typename T>
    std::optional<T> read(addr_t address)
    {
        T value{};
        if (read(address, &value, sizeof(value)))
        {
            return value;
        }

        return std::nullopt;
    }

    std::optional<std::vector<uint8_t>> read(addr_t address, size_t size)
    {
        std::vector<uint8_t> value(size);
        if (read(address, value.data(), size))
        {
            return value;
        }
        return std::nullopt;
    }

    template <typename T>
    bool write(addr_t address, const T& value)
    {
        return write(address, &value, sizeof(value));
    }
};

```

`source/runtime/system.hpp`:

```hpp
#pragma once

#include <cfenv>
#include <cfloat>
#include <cstdint>
#include <cinttypes>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-literal-operator"
#include "remill/Arch/X86/Runtime/State.h"
#pragma clang diagnostic pop

#if ADDRESS_SIZE_BITS == 32
using addr_t = uint32_t;
#define ADDR_FORMAT PRIx32
#define aword       dword
#else
using addr_t = uint64_t;
#define ADDR_FORMAT PRIx64
#define aword       qword
#endif

using system_function = Memory*(State& state, addr_t address, Memory* memory);

```

`source/shared/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
)

list(SORT SRC_FILES)

add_library(shared ${SRC_FILES})

target_include_directories(shared INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/../)

```

`source/shared/finally.hpp`:

```hpp
#pragma once
#include <type_traits>
#include <utility>

namespace levo
{
    /*
     * Copied from here: https://github.com/microsoft/GSL/blob/e0880931ae5885eb988d1a8a57acf8bc2b8dacda/include/gsl/util#L57
     */

    template <class F>
    class final_action
    {
      public:
        static_assert(!std::is_reference_v<F> && !std::is_const_v<F> && !std::is_volatile_v<F>,
                      "Final_action should store its callable by value");

        explicit final_action(F f) noexcept
            : f_(std::move(f))
        {
        }

        final_action(final_action&& other) noexcept
            : f_(std::move(other.f_)),
              invoke_(std::exchange(other.invoke_, false))
        {
        }

        final_action(const final_action&) = delete;
        final_action& operator=(const final_action&) = delete;
        final_action& operator=(final_action&&) = delete;

        ~final_action() noexcept
        {
            if (invoke_)
            {
                f_();
            }
        }

        // Added by momo5502
        void cancel()
        {
            invoke_ = false;
        }

      private:
        F f_;
        bool invoke_{true};
    };

    template <class F>
    final_action<std::remove_cv_t<std::remove_reference_t<F>>> finally(F&& f) noexcept
    {
        return final_action<std::remove_cv_t<std::remove_reference_t<F>>>(std::forward<F>(f));
    }
}

```

`source/shared/io.hpp`:

```hpp
#include <fstream>
#include <filesystem>
#include <vector>

namespace levo
{
    inline bool read_file(const std::filesystem::path& file, std::vector<uint8_t>& data)
    {
        data.clear();

        std::ifstream file_stream(file, std::ios::binary);
        if (!file_stream)
        {
            return false;
        }

        std::vector<char> temp_buffer(0x1000);

        while (file_stream)
        {
            file_stream.read(temp_buffer.data(), static_cast<std::streamsize>(temp_buffer.size()));
            const auto bytes_read = file_stream.gcount();

            if (bytes_read > 0)
            {
                const auto* buffer = reinterpret_cast<const uint8_t*>(temp_buffer.data());
                data.insert(data.end(), buffer, buffer + bytes_read);
            }
        }

        return true;
    }

    inline std::vector<uint8_t> read_file(const std::filesystem::path& file)
    {
        std::vector<uint8_t> data{};
        if (!read_file(file, data))
        {
            return {};
        }

        return data;
    }
}

```

`source/shared/pe_mapper.cpp`:

```cpp
#include "pe_mapper.hpp"

#include <algorithm>
#include <cstring>
#include <optional>
#include <string>
#include <type_traits>

namespace levo
{
    namespace
    {
        void grow_to_size(std::vector<uint8_t>& out, size_t size)
        {
            if (out.size() < size)
            {
                out.resize(size);
            }
        }

        // Returns a string_view over a null-terminated ASCII string at base + rva, or empty if invalid.
        std::string_view string_at_rva(std::span<const uint8_t> image, uint32_t rva)
        {
            if (rva >= image.size())
            {
                return {};
            }
            const char* start = reinterpret_cast<const char*>(image.data() + rva);
            const char* end = reinterpret_cast<const char*>(image.data() + image.size());
            const char* p = start;
            while (p < end && *p != '\0')
            {
                ++p;
            }

            return {start, static_cast<size_t>(p - start)};
        }

        // Maps PE sections and optionally resolves imports. OptionalHeaderT selects 32 vs 64 (IAT entry size).
        template <typename OptionalHeaderT>
        std::vector<uint8_t> map_pe_impl(std::span<const uint8_t> data, const pe_file_header& file_header, size_t section_table_offset,
                                         const pe_import_resolver_t& resolver)
        {
            constexpr size_t section_header_size = sizeof(pe_section_header);
            const size_t num_sections = file_header.number_of_sections;

            if (section_table_offset + (num_sections * section_header_size) > data.size())
            {
                return {};
            }

            std::vector<uint8_t> mapped_data;
            std::optional<size_t> first_section_file_offset;

            for (size_t i = 0; i < num_sections; ++i)
            {
                const size_t off = section_table_offset + (i * section_header_size);
                const auto* sh = reinterpret_cast<const pe_section_header*>(data.data() + off);

                const uint32_t virtual_address = sh->virtual_address;
                const uint32_t virtual_size = sh->virtual_size;
                const uint32_t size_of_raw_data = sh->size_of_raw_data;
                const uint32_t pointer_to_raw = sh->pointer_to_raw_data;

                if (size_of_raw_data > 0 && (pointer_to_raw + size_of_raw_data > data.size() || pointer_to_raw > data.size()))
                {
                    continue;
                }

                if (!first_section_file_offset.has_value() || pointer_to_raw < *first_section_file_offset)
                {
                    first_section_file_offset = pointer_to_raw;
                }

                grow_to_size(mapped_data, static_cast<size_t>(virtual_address) + virtual_size);
                const size_t copy_size = std::min(static_cast<size_t>(size_of_raw_data), static_cast<size_t>(virtual_size));
                if (copy_size > 0 && pointer_to_raw <= data.size() - copy_size)
                {
                    std::memcpy(mapped_data.data() + virtual_address, data.data() + pointer_to_raw, copy_size);
                }
            }

            // Copy headers (everything up to the first section's raw data).
            if (first_section_file_offset.has_value() && *first_section_file_offset > 0)
            {
                grow_to_size(mapped_data, *first_section_file_offset);
                std::memcpy(mapped_data.data(), data.data(), *first_section_file_offset);
            }

            // Resolve imports and fill IAT if resolver is provided.
            constexpr bool is_64 = std::is_same_v<OptionalHeaderT, pe_optional_header_64>;
            constexpr size_t iat_entry_size = is_64 ? 8u : 4u;

            if (resolver && mapped_data.size() >= sizeof(pe_dos_header))
            {
                const uint32_t e_lfanew = reinterpret_cast<const pe_dos_header*>(mapped_data.data())->e_lfanew;
                const size_t optional_header_offset = e_lfanew + 4u + sizeof(pe_file_header);
                if (optional_header_offset + sizeof(OptionalHeaderT) <= mapped_data.size())
                {
                    const auto* opt = reinterpret_cast<const OptionalHeaderT*>(mapped_data.data() + optional_header_offset);
                    const uint32_t import_rva = opt->data_directory[pe::directory_entry_import].virtual_address;
                    if (import_rva != 0)
                    {
                        std::span<const uint8_t> image(mapped_data.data(), mapped_data.size());
                        const auto* desc = reinterpret_cast<const pe_import_descriptor*>(mapped_data.data() + import_rva);

                        while (desc->name != 0)
                        {
                            const auto desc_offset = reinterpret_cast<const uint8_t*>(desc) - mapped_data.data();
                            if (desc_offset + sizeof(pe_import_descriptor) > mapped_data.size())
                            {
                                break;
                            }
                            std::string_view dll_name = string_at_rva(image, desc->name);
                            uint32_t ilt_rva = desc->original_first_thunk != 0 ? desc->original_first_thunk : desc->first_thunk;
                            uint32_t iat_rva = desc->first_thunk;

                            for (size_t idx = 0;; ++idx)
                            {
                                const size_t ilt_off = ilt_rva + (idx * iat_entry_size);
                                const size_t iat_off = iat_rva + (idx * iat_entry_size);
                                if (ilt_off + iat_entry_size > mapped_data.size() || iat_off + iat_entry_size > mapped_data.size())
                                {
                                    break;
                                }

                                uint64_t entry = 0;
                                if constexpr (is_64)
                                {
                                    entry = *reinterpret_cast<const uint64_t*>(mapped_data.data() + ilt_off);
                                    if (entry == 0)
                                    {
                                        break;
                                    }
                                    if ((entry & (1ULL << 63)) != 0)
                                    {
                                        const auto ord = static_cast<uint16_t>(entry & 0xFFFFu);
                                        const std::string ord_name = "#" + std::to_string(ord);
                                        const uint64_t addr = resolver(dll_name, ord_name);
                                        auto* iat_slot = reinterpret_cast<uint64_t*>(mapped_data.data() + iat_off);
                                        *iat_slot = addr;
                                        continue;
                                    }
                                }
                                else
                                {
                                    entry = *reinterpret_cast<const uint32_t*>(mapped_data.data() + ilt_off);
                                    if (entry == 0)
                                    {
                                        break;
                                    }
                                    if ((entry & 0x80000000u) != 0)
                                    {
                                        const auto ord = static_cast<uint16_t>(entry & 0xFFFFu);
                                        const std::string ord_name = "#" + std::to_string(ord);
                                        const uint64_t addr = resolver(dll_name, ord_name);
                                        auto* iat_slot = reinterpret_cast<uint32_t*>(mapped_data.data() + iat_off);
                                        *iat_slot = static_cast<uint32_t>(addr);
                                        continue;
                                    }
                                }

                                // Name import: RVA points to hint (2 bytes) then ASCII name
                                const auto name_rva = static_cast<uint32_t>(entry & 0x7FFFFFFFu);
                                if (name_rva + 2 >= mapped_data.size())
                                {
                                    break;
                                }
                                std::string_view func_name = string_at_rva(image, name_rva + 2);
                                const uint64_t addr = resolver(dll_name, func_name);
                                if constexpr (is_64)
                                {
                                    auto* iat_slot = reinterpret_cast<uint64_t*>(mapped_data.data() + iat_off);
                                    *iat_slot = addr;
                                }
                                else
                                {
                                    auto* iat_slot = reinterpret_cast<uint32_t*>(mapped_data.data() + iat_off);
                                    *iat_slot = static_cast<uint32_t>(addr);
                                }
                            }

                            ++desc;
                        }
                    }
                }
            }

            return mapped_data;
        }
    }

    std::optional<pe_architecture> get_pe_architecture(std::span<const uint8_t> data)
    {
        constexpr size_t dos_header_size = sizeof(pe_dos_header);
        constexpr size_t file_header_size = sizeof(pe_file_header);

        if (data.size() < dos_header_size)
        {
            return std::nullopt;
        }

        const auto* dos = reinterpret_cast<const pe_dos_header*>(data.data());
        if (dos->e_magic != pe::dos_signature)
        {
            return std::nullopt;
        }

        const uint32_t e_lfanew = dos->e_lfanew;
        const size_t nt_offset = e_lfanew + 4u; // after "PE\0\0"

        if (nt_offset + file_header_size + 2u > data.size()) // need file header + at least magic
        {
            return std::nullopt;
        }

        if (std::memcmp(data.data() + e_lfanew, "PE\0\0", 4) != 0)
        {
            return std::nullopt;
        }

        const auto* file_header = reinterpret_cast<const pe_file_header*>(data.data() + nt_offset);
        const uint16_t optional_magic = *reinterpret_cast<const uint16_t*>(data.data() + nt_offset + file_header_size);

        if (optional_magic == pe::optional_header_magic_32)
        {
            return pe_architecture::x86;
        }

        if (optional_magic == pe::optional_header_magic_64)
        {
            return pe_architecture::x64;
        }

        return std::nullopt;
    }

    std::vector<uint8_t> map_pe_file(std::span<const uint8_t> data, const pe_import_resolver_t& import_resolver)
    {
        constexpr size_t dos_header_size = sizeof(pe_dos_header);
        constexpr size_t file_header_size = sizeof(pe_file_header);

        if (data.size() < dos_header_size)
        {
            return {};
        }

        const auto* dos = reinterpret_cast<const pe_dos_header*>(data.data());
        if (dos->e_magic != pe::dos_signature)
        {
            return {};
        }

        const uint32_t e_lfanew = dos->e_lfanew;
        const size_t nt_offset = e_lfanew + 4u; // after "PE\0\0"

        if (nt_offset + file_header_size + 2u > data.size()) // need file header + at least magic
        {
            return {};
        }

        if (std::memcmp(data.data() + e_lfanew, "PE\0\0", 4) != 0)
        {
            return {};
        }

        const auto* file_header = reinterpret_cast<const pe_file_header*>(data.data() + nt_offset);
        const uint16_t optional_magic = *reinterpret_cast<const uint16_t*>(data.data() + nt_offset + file_header_size);

        const size_t section_table_offset = nt_offset + file_header_size + file_header->size_of_optional_header;

        if (optional_magic == pe::optional_header_magic_32)
        {
            return map_pe_impl<pe_optional_header_32>(data, *file_header, section_table_offset, import_resolver);
        }

        if (optional_magic == pe::optional_header_magic_64)
        {
            return map_pe_impl<pe_optional_header_64>(data, *file_header, section_table_offset, import_resolver);
        }

        return {};
    }

    uint64_t get_entry_point(std::span<const uint8_t> data)
    {
        constexpr size_t dos_header_size = sizeof(pe_dos_header);
        constexpr size_t file_header_size = sizeof(pe_file_header);

        const auto* dos = reinterpret_cast<const pe_dos_header*>(data.data());
        const auto* file_header = reinterpret_cast<const pe_file_header*>(data.data() + dos->e_lfanew);

        const uint32_t e_lfanew = dos->e_lfanew;
        const size_t nt_offset = e_lfanew + 4u; // after "PE\0\0"

        const uint16_t optional_magic = *reinterpret_cast<const uint16_t*>(data.data() + nt_offset + file_header_size);

        if (optional_magic == pe::optional_header_magic_32)
        {
            const auto* optional_header = reinterpret_cast<const pe_optional_header_32*>(data.data() + nt_offset + file_header_size);
            return optional_header->address_of_entry_point;
        }

        if (optional_magic == pe::optional_header_magic_64)
        {
            const auto* optional_header = reinterpret_cast<const pe_optional_header_64*>(data.data() + nt_offset + file_header_size);
            return optional_header->address_of_entry_point;
        }

        return 0;
    }
}

```

`source/shared/pe_mapper.hpp`:

```hpp
#pragma once

#include <array>
#include <cstdint>
#include <functional>
#include <span>
#include <optional>
#include <string_view>
#include <vector>

namespace levo
{
    // Platform-independent PE structure definitions (no Windows.h).
    // Layout matches the PE on-disk format; packed for cross-compiler layout consistency.

#pragma pack(push, 1)

    // DOS header (64 bytes).
    struct pe_dos_header
    {
        uint16_t e_magic;
        uint16_t e_cblp;
        uint16_t e_cp;
        uint16_t e_crlc;
        uint16_t e_cparhdr;
        uint16_t e_minalloc;
        uint16_t e_maxalloc;
        uint16_t e_ss;
        uint16_t e_sp;
        uint16_t e_csum;
        uint16_t e_ip;
        uint16_t e_cs;
        uint16_t e_lfarlc;
        uint16_t e_ovno;
        std::array<uint16_t, 4> e_res;
        uint16_t e_oemid;
        uint16_t e_oeminfo;
        std::array<uint16_t, 10> e_res2;
        uint32_t e_lfanew;
    };

    // COFF file header (20 bytes), same for PE32 and PE32+.
    struct pe_file_header
    {
        uint16_t machine;
        uint16_t number_of_sections;
        uint32_t time_date_stamp;
        uint32_t pointer_to_symbol_table;
        uint32_t number_of_symbols;
        uint16_t size_of_optional_header;
        uint16_t characteristics;
    };

    // Data directory entry (8 bytes).
    struct pe_data_directory
    {
        uint32_t virtual_address;
        uint32_t size;
    };

    // Optional header for PE32 (224 bytes typical; size varies with NumberOfRvaAndSizes).
    struct pe_optional_header_32
    {
        uint16_t magic;
        uint8_t major_linker_version;
        uint8_t minor_linker_version;
        uint32_t size_of_code;
        uint32_t size_of_initialized_data;
        uint32_t size_of_uninitialized_data;
        uint32_t address_of_entry_point;
        uint32_t base_of_code;
        uint32_t base_of_data;
        uint32_t image_base;
        uint32_t section_alignment;
        uint32_t file_alignment;
        uint16_t major_operating_system_version;
        uint16_t minor_operating_system_version;
        uint16_t major_image_version;
        uint16_t minor_image_version;
        uint16_t major_subsystem_version;
        uint16_t minor_subsystem_version;
        uint32_t win32_version_value;
        uint32_t size_of_image;
        uint32_t size_of_headers;
        uint32_t check_sum;
        uint16_t subsystem;
        uint16_t dll_characteristics;
        uint32_t size_of_stack_reserve;
        uint32_t size_of_stack_commit;
        uint32_t size_of_heap_reserve;
        uint32_t size_of_heap_commit;
        uint32_t loader_flags;
        uint32_t number_of_rva_and_sizes;
        std::array<pe_data_directory, 16> data_directory;
    };

    // Optional header for PE32+ (240 bytes typical).
    struct pe_optional_header_64
    {
        uint16_t magic;
        uint8_t major_linker_version;
        uint8_t minor_linker_version;
        uint32_t size_of_code;
        uint32_t size_of_initialized_data;
        uint32_t size_of_uninitialized_data;
        uint32_t address_of_entry_point;
        uint32_t base_of_code;
        uint64_t image_base;
        uint32_t section_alignment;
        uint32_t file_alignment;
        uint16_t major_operating_system_version;
        uint16_t minor_operating_system_version;
        uint16_t major_image_version;
        uint16_t minor_image_version;
        uint16_t major_subsystem_version;
        uint16_t minor_subsystem_version;
        uint32_t win32_version_value;
        uint32_t size_of_image;
        uint32_t size_of_headers;
        uint32_t check_sum;
        uint16_t subsystem;
        uint16_t dll_characteristics;
        uint64_t size_of_stack_reserve;
        uint64_t size_of_stack_commit;
        uint64_t size_of_heap_reserve;
        uint64_t size_of_heap_commit;
        uint32_t loader_flags;
        uint32_t number_of_rva_and_sizes;
        std::array<pe_data_directory, 16> data_directory;
    };

    // Section header (40 bytes), same for PE32 and PE32+.
    struct pe_section_header
    {
        std::array<uint8_t, 8> name;
        uint32_t virtual_size;
        uint32_t virtual_address;
        uint32_t size_of_raw_data;
        uint32_t pointer_to_raw_data;
        uint32_t pointer_to_relocations;
        uint32_t pointer_to_linenumbers;
        uint16_t number_of_relocations;
        uint16_t number_of_linenumbers;
        uint32_t characteristics;
    };

    // Import directory entry (20 bytes). Terminated by a null descriptor.
    struct pe_import_descriptor
    {
        uint32_t original_first_thunk; // RVA to ILT (Import Lookup Table)
        uint32_t time_date_stamp;
        uint32_t forwarder_chain;
        uint32_t name;        // RVA to DLL name (ASCII)
        uint32_t first_thunk; // RVA to IAT (Import Address Table)
    };

#pragma pack(pop)

    namespace pe
    {
        constexpr uint16_t dos_signature = 0x5A4D;           // "MZ"
        constexpr uint32_t nt_signature = 0x00004550;        // "PE\0\0"
        constexpr uint16_t optional_header_magic_32 = 0x10b; // PE32
        constexpr uint16_t optional_header_magic_64 = 0x20b; // PE32+
        constexpr unsigned directory_entry_import = 1;       // DataDirectory index for Import Table
    }

    // Import resolver: (library_name, function_name) -> address to store in IAT.
    // For ordinal imports, function_name is "#" + decimal ordinal (e.g. "#42").
    using pe_import_resolver_t = std::function<uint64_t(std::string_view library_name, std::string_view function_name)>;

    // Maps a PE file (from file layout) into a contiguous buffer (load layout).
    // If import_resolver is set, fills the Import Address Table with resolved addresses.
    // Supports both PE32 and PE32+; uses platform-independent structs only.
    std::vector<uint8_t> map_pe_file(std::span<const uint8_t> data, const pe_import_resolver_t& import_resolver = {});

    uint64_t get_entry_point(std::span<const uint8_t> data);

    enum class pe_architecture
    {
        x86,
        x64,
    };

    std::optional<pe_architecture> get_pe_architecture(std::span<const uint8_t> data);
}

```