Project Path: arc_momo5502_patch-finder_pn40m9lz

Source Tree:

```txt
arc_momo5502_patch-finder_pn40m9lz
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── cmake
│   ├── compiler-env.cmake
│   ├── utils.cmake
│   └── version.cmake
├── deps
│   ├── CMakeLists.txt
│   ├── ida-cmake
│   └── ida-sdk
├── docs
│   └── preview.png
└── src
    ├── CMakeLists.txt
    ├── buffer_accessor.hpp
    ├── ida_sdk.hpp
    ├── patch_finder.cpp
    ├── patch_finder.hpp
    ├── pe_parser.hpp
    ├── plugin.cpp
    └── win_pefile.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.26.4)

set(ENV{IDASDK} "${CMAKE_CURRENT_LIST_DIR}/deps/ida-sdk")

##########################################

set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

if(NOT MOMO_ENABLE_CLANG_TIDY)
  set(CMAKE_OSX_ARCHITECTURES arm64;x86_64)
endif()

##########################################

project(patch-finder LANGUAGES C CXX)

##########################################

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

##########################################

#include(cmake/version.cmake)
include(cmake/utils.cmake)
include(cmake/compiler-env.cmake)
include(deps/ida-cmake/bootstrap.cmake)
include(deps/ida-cmake/idasdkConfig.cmake)

##########################################

momo_set_new_artifact_directory()

##########################################

momo_add_subdirectory_and_get_targets("deps" EXTERNAL_TARGETS)
momo_add_subdirectory_and_get_targets("src" OWN_TARGETS)

##########################################

momo_targets_set_folder("External Dependencies" ${EXTERNAL_TARGETS})

momo_targets_exclude_from_all(${EXTERNAL_TARGETS})
momo_targets_disable_warnings(${EXTERNAL_TARGETS})

momo_targets_expose_includes(${OWN_TARGETS})
momo_targets_set_warnings_as_errors(${OWN_TARGETS})
momo_targets_enable_clang_tidy(${OWN_TARGETS})

```

`CMakePresets.json`:

```json
{
    "version": 6,
    "cmakeMinimumRequired": {
        "major": 3,
        "minor": 26,
        "patch": 4
    },
    "configurePresets": [
        {
            "name": "build",
            "hidden": true,
            "binaryDir": "${sourceDir}/build/${presetName}"
        },
        {
            "name": "ninja",
            "hidden": true,
            "generator": "Ninja"
        },
        {
            "name": "release",
            "inherits": [
                "ninja",
                "build"
            ],
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "RelWithDebInfo"
            }
        },
        {
            "name": "debug",
            "inherits": [
                "ninja",
                "build"
            ],
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "vs2022",
            "generator": "Visual Studio 17 2022",
            "inherits": "build"
        }
    ],
    "buildPresets": [
        {
            "name": "release",
            "configurePreset": "release"
        },
        {
            "name": "debug",
            "configurePreset": "debug"
        }
    ],
    "workflowPresets": [
        {
            "name": "release",
            "steps": [
                {
                    "type": "configure",
                    "name": "release"
                },
                {
                    "type": "build",
                    "name": "release"
                }
            ]
        },
        {
            "name": "debug",
            "steps": [
                {
                    "type": "configure",
                    "name": "debug"
                },
                {
                    "type": "build",
                    "name": "debug"
                }
            ]
        }
    ]
}
```

`LICENSE`:

```
Copyright 2025 Maurice Heumann

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# Patch Finder IDA Plugin

[![build](https://img.shields.io/github/actions/workflow/status/momo5502/patch-finder/build.yml?branch=main&label=Build&logo=github)](https://github.com/momo5502/patch-finder/actions)

An IDA Pro plugin to detect patched code during debugging sessions.  
It detectes patches and hooks by scanning executable memory regions and comparing the data to the files on disk.

Currently only works with PE files!

Download it [here](https://github.com/momo5502/patch-finder/actions?query=branch%3Amain), from GitHub actions.  
Click [here](https://youtu.be/xpRAqWmnmZc) to see a demo.

![preview](./docs/preview.png)



```

`cmake/compiler-env.cmake`:

```cmake
include_guard()

##########################################

set(IS_CI OFF)
if(DEFINED ENV{CI} AND ("$ENV{CI}" STREQUAL "true" OR "$ENV{CI}" STREQUAL "1"))
    set(IS_CI ON)
endif()

##########################################

if (IS_CI)
  add_compile_definitions(CI=1)
endif()

##########################################

cmake_policy(SET CMP0069 NEW) 
set(CMAKE_POLICY_DEFAULT_CMP0069 NEW)

set(CMAKE_POSITION_INDEPENDENT_CODE ON)
#set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)

##########################################

if(MSVC)
  momo_add_c_and_cxx_compile_options(
    /sdl
    /GS
    /Gy
    /guard:cf
  )

  momo_add_compile_options(CXX
    /Zc:__cplusplus
  )

  add_link_options(
    /INCREMENTAL:NO
  )
endif()

##########################################

set(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreaded$<$<CONFIG:Debug>:Debug>)

##########################################

if(MSVC)
  add_link_options(
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreaded>>:/NODEFAULTLIB:libcmt.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDLL>>:/NODEFAULTLIB:msvcrt.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDebug>>:/NODEFAULTLIB:libcmtd.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDebugDLL>>:/NODEFAULTLIB:msvcrtd.lib>
  )
endif()

##########################################

if(CMAKE_GENERATOR MATCHES "Visual Studio")
  momo_add_c_and_cxx_compile_options(/MP)
endif()

```

`cmake/utils.cmake`:

```cmake
include_guard()

##########################################

function(momo_silence_deprecation_warnings)
    set(CMAKE_WARN_DEPRECATED_OLD ${CMAKE_WARN_DEPRECATED} PARENT_SCOPE)
    set(CMAKE_WARN_DEPRECATED OFF CACHE BOOL "" FORCE)
endfunction()

##########################################

function(momo_restore_deprecation_warnings)
    set(CMAKE_WARN_DEPRECATED ${CMAKE_WARN_DEPRECATED_OLD} CACHE BOOL "" FORCE)
endfunction()

##########################################

function(momo_target_exclude_from_all target)
  set_target_properties(${target} PROPERTIES EXCLUDE_FROM_ALL 1)
  #set_target_properties(${target} PROPERTIES EXCLUDE_FROM_DEFAULT_BUILD 1)
endfunction()

##########################################

function(momo_targets_exclude_from_all)
  foreach(target ${ARGV})
    momo_target_exclude_from_all(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_set_folder folder target)
  get_target_property(CURRENT_FOLDER ${target} FOLDER)
  if(NOT CURRENT_FOLDER)
    set_target_properties(${target} PROPERTIES FOLDER "${folder}")
  endif()
endfunction()

##########################################

function(momo_targets_set_folder folder)
  foreach(target ${ARGN})
    momo_target_set_folder(${folder} ${target})
  endforeach()
endfunction()

##########################################

function(momo_target_disable_compile_commands target)
  set_target_properties(${target} PROPERTIES EXPORT_COMPILE_COMMANDS OFF)
endfunction()

##########################################

function(momo_targets_disable_compile_commands)
  foreach(target ${ARGV})
    momo_target_disable_compile_commands(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_expose_includes target)
  get_target_property(target_type ${target} TYPE)
  if("${target_type}" STREQUAL "UTILITY")
    return()
  endif()

  get_target_property(TARGET_SOURCE_DIR ${target} SOURCE_DIR)
  target_include_directories(${target} INTERFACE ${TARGET_SOURCE_DIR}/..)
endfunction()

##########################################

function(momo_targets_expose_includes)
  foreach(target ${ARGV})
  momo_target_expose_includes(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_compile_options language target mode)
  foreach(compile_option ${ARGN})
    target_compile_options(${target} ${mode}
      $<$<COMPILE_LANGUAGE:${language}>:${compile_option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_target_c_and_cxx_compile_options)
  momo_target_compile_options(C ${ARGV})
  momo_target_compile_options(CXX ${ARGV})
endfunction()

##########################################

macro(momo_target_remove_compile_option target option)
    get_target_property(target_flags ${target} COMPILE_OPTIONS)
    if(target_flags)
        list(REMOVE_ITEM target_flags ${option})
        set_target_properties(${target} PROPERTIES COMPILE_OPTIONS "${target_flags}")
    endif()

    get_target_property(target_interface_flags ${target} INTERFACE_COMPILE_OPTIONS)
    if(target_interface_flags)
        list(REMOVE_ITEM target_interface_flags ${option})
        set_target_properties(${target} PROPERTIES INTERFACE_COMPILE_OPTIONS "${target_interface_flags}")
    endif()
endmacro()

##########################################

macro(momo_target_remove_compile_options target)
  foreach(option ${ARGV})
    momo_target_remove_compile_option(${target} ${option})
  endforeach()
endmacro()

##########################################

function(momo_add_compile_options language)
  foreach(option ${ARGN})
    add_compile_options(
      $<$<COMPILE_LANGUAGE:${language}>:${option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_c_and_cxx_compile_options)
  momo_add_compile_options(C ${ARGV})
  momo_add_compile_options(CXX ${ARGV})
endfunction()

##########################################

function(momo_target_disable_warnings target)
  get_target_property(target_type ${target} TYPE)
  if(("${target_type}" STREQUAL "INTERFACE_LIBRARY") OR ("${target_type}" STREQUAL "UTILITY"))
    return()
  endif()

  if (NOT MSVC)
    return()
  endif()

  momo_target_remove_compile_options(${target} /W4 -W4 /W3 -W3)

  set(compile_options
    /W0
    /D_CRT_SECURE_NO_WARNINGS=1
  )

  momo_target_c_and_cxx_compile_options(${target} PRIVATE ${compile_options})
endfunction()

##########################################

function(momo_targets_disable_warnings)
  foreach(target ${ARGV})
    momo_target_disable_warnings(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_set_warnings_as_errors target)
  get_target_property(target_type ${target} TYPE)
  if(("${target_type}" STREQUAL "INTERFACE_LIBRARY") OR ("${target_type}" STREQUAL "UTILITY"))
    return()
  endif()

  set(compile_options)

  if(MSVC)
    set(compile_options /W4 /WX)
  endif()

  target_compile_options(${target} PRIVATE
    $<$<COMPILE_LANGUAGE:C>:$<$<CONFIG:RELEASE>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:CXX>:$<$<CONFIG:RELEASE>:${compile_options}>>
  )
endfunction()

##########################################

function(momo_targets_set_warnings_as_errors)
  foreach(target ${ARGV})
    momo_target_set_warnings_as_errors(${target})
  endforeach()
endfunction()

##########################################

function(momo_get_all_targets var)
    set(targets)
    momo_get_all_targets_recursive(targets ${CMAKE_CURRENT_SOURCE_DIR})
    set(${var} ${targets} PARENT_SCOPE)
endfunction()

##########################################

macro(momo_get_all_targets_recursive targets dir)
    get_property(subdirectories DIRECTORY ${dir} PROPERTY SUBDIRECTORIES)
    foreach(subdir ${subdirectories})
        momo_get_all_targets_recursive(${targets} ${subdir})
    endforeach()

    get_property(current_targets DIRECTORY ${dir} PROPERTY BUILDSYSTEM_TARGETS)
    list(APPEND ${targets} ${current_targets})
endmacro()

##########################################

macro(momo_list_difference list_a list_to_remove result)
  set(${result} ${list_a})
  list(REMOVE_ITEM ${result} ${list_to_remove})
endmacro()

##########################################

macro(momo_set_artifact_directory directory)
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${directory})
endmacro()

##########################################

macro(momo_set_new_artifact_directory)
  get_property(IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
  if(IS_MULTI_CONFIG)
      set(ARTIFACT_FOLDER_NAME "artifacts-$<LOWER_CASE:$<CONFIG>>")
  else()
      set(ARTIFACT_FOLDER_NAME "artifacts")
  endif()

  set(ARTIFACT_DIRECTORY "${CMAKE_BINARY_DIR}/${ARTIFACT_FOLDER_NAME}")
  momo_set_artifact_directory(${ARTIFACT_DIRECTORY})
endmacro()

##########################################

macro(momo_add_subdirectory_and_get_targets directory targets)
  momo_get_all_targets(EXISTING_TARGETS)
  add_subdirectory(${directory})
  momo_get_all_targets(ALL_TARGETS)

  momo_list_difference("${ALL_TARGETS}" "${EXISTING_TARGETS}" ${targets})
endmacro()

##########################################

macro(momo_target_include_libraries target mode)
  foreach(inc_target ${ARGN})
    target_include_directories(${target} ${mode}
      $<TARGET_PROPERTY:${inc_target},INTERFACE_INCLUDE_DIRECTORIES>
      $<TARGET_PROPERTY:${inc_target},PUBLIC_INCLUDE_DIRECTORIES>
    )
  endforeach()
endmacro()

##########################################

macro(momo_assign_source_group)
  source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${ARGN})
endmacro()

##########################################

function(momo_target_enable_clang_tidy target)
  if(MOMO_ENABLE_CLANG_TIDY)
    set(CLANG_TIDY_COMMAND "clang-tidy;--use-color;--config-file=${CMAKE_CURRENT_SOURCE_DIR}/.clang-tidy")

    set_target_properties(${target} PROPERTIES C_CLANG_TIDY "${CLANG_TIDY_COMMAND}")
    set_target_properties(${target} PROPERTIES CXX_CLANG_TIDY "${CLANG_TIDY_COMMAND}")
  endif()
endfunction()

##########################################

function(momo_targets_enable_clang_tidy)
  foreach(target ${ARGV})
    momo_target_enable_clang_tidy(${target})
  endforeach()
endfunction()

```

`cmake/version.cmake`:

```cmake
include_guard()

##########################################

find_package(Git)
if(NOT Git_FOUND)
  if(DEFINED ENV{GIT_EXECUTABLE})
    set(GIT_EXECUTABLE "$ENV{GIT_EXECUTABLE}")
  else()
    message(FATAL_ERROR "Unable to find Git executable")
  endif()
endif()

##########################################

execute_process(COMMAND "${GIT_EXECUTABLE}" "describe" "--tags" "--dirty=-d" "--match=v*" OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE PROJECT_VERSION
WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
execute_process(COMMAND "${GIT_EXECUTABLE}" "rev-parse" "HEAD" OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE PROJECT_COMMIT_HASH
WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
execute_process(COMMAND "${GIT_EXECUTABLE}" "rev-parse" "--abbrev-ref" "HEAD" OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE PROJECT_COMMIT_REF
WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")

##########################################

message("-- Build Version: ${PROJECT_VERSION} @ ${PROJECT_COMMIT_REF} ${PROJECT_COMMIT_HASH}")

```

`src/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

ida_add_plugin(patch-finder SOURCES ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

set_property(GLOBAL PROPERTY VS_STARTUP_PROJECT patch-finder)

```

`src/buffer_accessor.hpp`:

```hpp
#pragma once
#include <span>
#include <cstring>
#include <cstdint>
#include <stdexcept>

namespace momo::utils
{
    template <typename Type, typename SpanElement = const std::byte>
        requires(std::is_trivially_copyable_v<Type> &&
                 (std::is_same_v<uint8_t, std::remove_cv_t<SpanElement>> || std::is_same_v<std::byte, std::remove_cv_t<SpanElement>>))
    class safe_object_accessor
    {
      public:
        safe_object_accessor(const std::span<SpanElement> buffer, const size_t offset)
            : buffer_(buffer),
              offset_(offset)
        {
        }

        /*****************************************************************************
         * Object is copied to make sure platform-dependent alignment requirements
         * are respected
         ****************************************************************************/

        Type get(const size_t element_index = 0) const
        {
            Type value{};
            memcpy(&value, get_valid_pointer(element_index), size);
            return value;
        }

        void set(const Type value, const size_t element_index = 0) const
        {
            memcpy(get_valid_pointer(element_index), &value, size);
        }

      private:
        static constexpr auto size = sizeof(Type);

        std::span<SpanElement> buffer_{};
        size_t offset_{};

        SpanElement* get_valid_pointer(const size_t element_index) const
        {
            const auto start_offset = offset_ + (size * element_index);
            const auto end_offset = start_offset + size;
            if (end_offset > buffer_.size())
            {
                throw std::runtime_error("Buffer accessor overflow");
            }

            return buffer_.data() + start_offset;
        }
    };

    template <typename SpanElement>
        requires(std::is_same_v<uint8_t, std::remove_cv_t<SpanElement>> || std::is_same_v<std::byte, std::remove_cv_t<SpanElement>>)
    class safe_buffer_accessor
    {
      public:
        safe_buffer_accessor(const std::span<SpanElement> buffer)
            : buffer_(buffer)
        {
        }

        template <typename OtherSpanElement>
            requires(std::is_same_v<std::remove_cv_t<SpanElement>, std::remove_cv_t<OtherSpanElement>>)
        safe_buffer_accessor(const safe_buffer_accessor<OtherSpanElement>& obj)
            : buffer_(obj.get_buffer())
        {
        }

        template <typename Type>
        safe_object_accessor<Type, SpanElement> as(const size_t offset) const
        {
            return {this->buffer_, offset};
        }

        SpanElement* get_pointer_for_range(const size_t offset, const size_t size) const
        {
            this->validate(offset, size);
            return this->buffer_.data() + offset;
        }

        void validate(const size_t offset, const size_t size) const
        {
            const auto end = offset + size;
            if (end > buffer_.size())
            {
                throw std::runtime_error("Buffer accessor overflow");
            }
        }

        template <typename Char = char>
        std::basic_string<Char> as_string(const size_t offset) const
        {
            safe_object_accessor<Char> string_accessor{this->buffer_, offset};
            std::basic_string<Char> result{};

            while (true)
            {
                auto value = string_accessor.get(result.size());
                if (!value)
                {
                    return result;
                }

                result.push_back(std::move(value));
            }
        }

        std::span<SpanElement> get_buffer() const
        {
            return this->buffer_;
        }

      private:
        const std::span<SpanElement> buffer_{};
    };
}

```

`src/ida_sdk.hpp`:

```hpp

#pragma once

#define USE_DANGEROUS_FUNCTIONS
#include <ida.hpp>
#include <dbg.hpp>
#include <auto.hpp>
#include <name.hpp>
#include <loader.hpp>
#include <typeinf.hpp>
#include <kernwin.hpp>
#include <strlist.hpp>

```

`src/patch_finder.cpp`:

```cpp
#include "patch_finder.hpp"

#include <fstream>
#include <cinttypes>
#include <filesystem>

#include "pe_parser.hpp"

#include "ida_sdk.hpp"

namespace momo
{
    namespace
    {
        qvector<modinfo_t> get_loaded_modules()
        {
            qvector<modinfo_t> modules;

            modinfo_t modinfo{};
            bool ok = get_first_module(&modinfo);

            while (ok)
            {
                modules.push_back(modinfo);
                ok = get_next_module(&modinfo);
            }

            return modules;
        }

        std::string read_module(const std::filesystem::path& module_path)
        {
            std::ifstream stream(module_path, std::ios::binary);
            if (!stream)
            {
                return {};
            }

            return {std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>()};
        }

        std::string read_module(const modinfo_t& modinfo)
        {
            std::string_view mod_name(modinfo.name.c_str(), modinfo.name.size());
            return read_module(mod_name);
        }

        utils::safe_buffer_accessor<const std::byte> make_accessor(const std::string_view data)
        {
            std::span view(reinterpret_cast<const std::byte*>(data.data()), data.size());
            return {view};
        }

        std::vector<uint8_t> read_section_data(ea_t start, size_t size)
        {
            std::vector<uint8_t> data(size);

            const auto ssize = static_cast<ssize_t>(size);
            const auto bytes_read = get_bytes(data.data(), ssize, start);

            if (bytes_read == ssize)
            {
                return data;
            }

            if (bytes_read <= 0)
            {
                return {};
            }

            data.resize(bytes_read);
            return data;
        }

        bool is_similar_enough_for_analysis(const std::span<const uint8_t> buffer1, const std::span<const uint8_t> buffer2)
        {
            if (buffer1.size() != buffer2.size())
            {
                return false;
            }

            size_t equal_bytes = 0;

            for (size_t i = 0; i < buffer1.size(); ++i)
            {
                if (buffer1[i] == buffer2[i])
                {
                    ++equal_bytes;
                }
            }

            // Must be at least 90% equal
            return equal_bytes > ((buffer1.size() / 10) * 9);
        }

        struct patch
        {
            uint64_t address{};
            uint64_t length{};
        };

        std::vector<patch> find_patches_in_section(const section_map::value_type& section)
        {
            const auto runtime_data = read_section_data(section.first, section.second.size());
            if (!is_similar_enough_for_analysis(section.second, runtime_data))
            {
                return {};
            }

            std::vector<patch> patches{};
            std::optional<patch> current_diff{};

            const auto finish_diff = [&](const uint64_t address) {
                if (!current_diff)
                {
                    return;
                }

                current_diff->length = address - current_diff->address;
                current_diff->address += section.first;

                patches.emplace_back(*current_diff);
                current_diff.reset();
            };

            for (size_t i = 0; i < section.second.size(); ++i)
            {
                if (section.second[i] == runtime_data[i])
                {
                    if (current_diff)
                    {
                        finish_diff(i);
                    }
                }
                else if (!current_diff)
                {
                    current_diff.emplace(i);
                }
            }

            finish_diff(section.second.size());

            return patches;
        }

        std::vector<patch> find_patches_in_module(const modinfo_t& modinfo)
        {
            const auto data = read_module(modinfo);
            const auto buffer = make_accessor(data);
            const auto sections = parse_pe_file(buffer, modinfo.base);

            std::vector<patch> patches{};

            for (const auto& section : sections)
            {
                if (user_cancelled())
                {
                    return {};
                }

                const auto section_patches = find_patches_in_section(section);
                if (!section_patches.empty())
                {
                    patches.insert(patches.end(), section_patches.begin(), section_patches.end());
                }
            }

            return patches;
        }

        size_t find_and_log_patches_in_module(const modinfo_t& modinfo)
        {
            const auto patches = find_patches_in_module(modinfo);

            if (patches.empty())
            {
                return 0;
            }

            msg("\n%s\n\n", modinfo.name.c_str());

            for (const auto& patch : patches)
            {
                qstring symbol{};
                get_ea_name(&symbol, patch.address, GN_DEMANGLED | GN_VISIBLE | GN_SHORT | GN_LOCAL);

                msg("\t0x%" PRIX64 " (0x%" PRIX64 "): %s\n", patch.address, patch.length, symbol.c_str());
            }

            msg("\n");

            return patches.size();
        }
    }

    void find_patches()
    {
        msg("Finding patches...\n");

        if (!is_debugger_on())
        {
            msg("Debugger must be active to find patches!\n");
            return;
        }

        show_wait_box("NODELAY\nFinding modules...");

        size_t total_patches = 0;

        const auto modules = get_loaded_modules();

        for (size_t i = 0; i < modules.size(); ++i)
        {
            const auto& modinfo = modules[i];

            try
            {
                const auto module_filename = std::filesystem::path(modinfo.name.c_str()).filename().string();
                replace_wait_box("Scanning module (%zd/%zd):\n\n%s", i + 1, modules.size(), module_filename.c_str());

                if (user_cancelled())
                {
                    msg("Operation cancelled by user\n");
                    break;
                }

                total_patches += find_and_log_patches_in_module(modinfo);
            }
            catch (...)
            {
                // Just ignore all issues
            }
        }

        hide_wait_box();
        msg("Total patches found: %zu\n", total_patches);
    }
}

```

`src/patch_finder.hpp`:

```hpp
#pragma once

namespace momo
{
    void find_patches();
}

```

`src/pe_parser.hpp`:

```hpp
#pragma once

#include <map>
#include <string>
#include <vector>
#include <optional>

#include "win_pefile.hpp"
#include "buffer_accessor.hpp"

namespace momo
{
    using section_data = std::vector<uint8_t>;
    using section_map = std::map<uint64_t, section_data>;

    namespace detail
    {
        template <typename SpanElement>
        utils::safe_object_accessor<PEDosHeader_t, SpanElement> get_dos_header(const utils::safe_buffer_accessor<SpanElement>& buffer)
        {
            return buffer.template as<PEDosHeader_t>(0);
        }

        template <typename AddrType, typename SpanElement>
        utils::safe_object_accessor<PENTHeaders_t<AddrType>, SpanElement> get_nt_headers(
            const utils::safe_buffer_accessor<SpanElement>& buffer)
        {
            const auto dos_header = get_dos_header(buffer).get();
            const auto nt_headers_offset = dos_header.e_lfanew;

            return buffer.template as<PENTHeaders_t<AddrType>>(nt_headers_offset);
        }

        template <typename AddrType>
        uint64_t get_first_section_offset(const PENTHeaders_t<AddrType>& nt_headers, const uint64_t nt_headers_offset)
        {
            const auto* nt_headers_addr = reinterpret_cast<const uint8_t*>(&nt_headers);
            const size_t optional_header_offset =
                reinterpret_cast<uintptr_t>(&(nt_headers.OptionalHeader)) - reinterpret_cast<uintptr_t>(&nt_headers);
            const size_t optional_header_size = nt_headers.FileHeader.SizeOfOptionalHeader;
            const auto* first_section_addr = nt_headers_addr + optional_header_offset + optional_header_size;

            const auto first_section_absolute = reinterpret_cast<uint64_t>(first_section_addr);
            const auto absolute_base = reinterpret_cast<uint64_t>(&nt_headers);
            return nt_headers_offset + (first_section_absolute - absolute_base);
        }

        template <typename AddrType, typename SpanElement, typename Accessor>
        void access_sections(const utils::safe_buffer_accessor<SpanElement> buffer, const PENTHeaders_t<AddrType>& nt_headers,
                             const uint64_t nt_headers_offset, const Accessor& accessor)
        {
            const auto first_section_offset = get_first_section_offset(nt_headers, nt_headers_offset);
            const auto sections = buffer.template as<IMAGE_SECTION_HEADER>(static_cast<size_t>(first_section_offset));

            for (size_t i = 0; i < nt_headers.FileHeader.NumberOfSections; ++i)
            {
                const auto section = sections.get(i);

                if (!accessor(section))
                {
                    break;
                }
            }
        }

        template <typename AddrType, typename SpanElement>
        std::optional<size_t> rva_to_file_offset(const utils::safe_buffer_accessor<SpanElement> buffer,
                                                 const PENTHeaders_t<AddrType>& nt_headers, const uint64_t nt_headers_offset,
                                                 const uint32_t rva)
        {
            std::optional<size_t> result{};

            access_sections(buffer, nt_headers, nt_headers_offset, [&](const IMAGE_SECTION_HEADER& section) {
                const auto size_of_data = std::min(section.SizeOfRawData, section.Misc.VirtualSize);
                if (section.VirtualAddress <= rva && (section.VirtualAddress + size_of_data) > rva)
                {
                    result = section.PointerToRawData + rva - section.VirtualAddress;
                    return false;
                }

                return true;
            });

            return result;
        }

        template <typename AddrType, typename SpanElement>
        section_map parse_sections(const utils::safe_buffer_accessor<SpanElement> buffer, const PENTHeaders_t<AddrType>& nt_headers,
                                   const uint64_t nt_headers_offset, const uint64_t base_address)
        {
            section_map result{};

            access_sections(buffer, nt_headers, nt_headers_offset, [&](const IMAGE_SECTION_HEADER& section) {
                const auto is_writable = section.Characteristics & IMAGE_SCN_MEM_WRITE;
                const auto is_discardable = section.Characteristics & IMAGE_SCN_MEM_DISCARDABLE;
                const auto is_uninitialized = section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA;
                const auto is_executable = section.Characteristics & IMAGE_SCN_MEM_EXECUTE;
                const auto is_invalid = is_writable || is_discardable || is_uninitialized || !is_executable;

                if (section.SizeOfRawData <= 0 || is_invalid)
                {
                    return true;
                }

                const auto target_ptr = base_address + section.VirtualAddress;

                const auto size_of_data = std::min(section.SizeOfRawData, section.Misc.VirtualSize);
                const auto* byte_ptr = buffer.get_pointer_for_range(section.PointerToRawData, size_of_data);
                const auto* source_ptr = reinterpret_cast<const uint8_t*>(byte_ptr);

                section_data data{};
                data.assign(source_ptr, source_ptr + size_of_data);

                result[target_ptr] = std::move(data);
                return true;
            });

            return result;
        }

        inline section_map::iterator find_section(section_map& sections, const uint64_t address)
        {
            auto iter = sections.upper_bound(address);
            if (iter == sections.begin())
            {
                return sections.end();
            }

            std::advance(iter, -1);

            const auto offset = address - iter->first;
            if (offset < sections.size())
            {
                return iter;
            }

            return sections.end();
        }

        template <typename T>
            requires(std::is_integral_v<T>)
        bool apply_relocation(section_map& sections, const uint64_t address, const uint64_t delta)
        {
            auto section = find_section(sections, address);
            if (section == sections.end())
            {
                return false;
            }

            utils::safe_buffer_accessor<uint8_t> buffer{section->second};

            const auto offset = address - section->first;
            const auto obj = buffer.template as<T>(static_cast<size_t>(offset));
            const auto value = obj.get();
            const auto new_value = value + static_cast<T>(delta);
            obj.set(new_value);

            return true;
        }

        template <typename AddrType, typename SpanElement>
        void apply_relocations(const utils::safe_buffer_accessor<SpanElement> buffer, const PENTHeaders_t<AddrType>& nt_headers,
                               const uint64_t nt_headers_offset, section_map& sections, const int64_t delta, const uint64_t base_address)
        {
            if (delta == 0)
            {
                return;
            }

            const auto* directory = &nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
            if (directory->Size == 0)
            {
                return;
            }

            auto relocation_offset = directory->VirtualAddress;
            const auto relocation_end = relocation_offset + directory->Size;

            auto relocation_file_offset = rva_to_file_offset(buffer, nt_headers, nt_headers_offset, relocation_offset);
            if (!relocation_file_offset.has_value())
            {
                return;
            }

            while (relocation_offset < relocation_end)
            {
                const auto relocation = buffer.template as<IMAGE_BASE_RELOCATION>(*relocation_file_offset).get();

                if (relocation.VirtualAddress <= 0 || relocation.SizeOfBlock <= sizeof(IMAGE_BASE_RELOCATION))
                {
                    break;
                }

                const auto data_size = relocation.SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION);
                const auto entry_count = data_size / sizeof(uint16_t);

                const auto entries = buffer.template as<uint16_t>(*relocation_file_offset + sizeof(IMAGE_BASE_RELOCATION));

                relocation_offset += relocation.SizeOfBlock;
                *relocation_file_offset += relocation.SizeOfBlock;

                for (size_t i = 0; i < entry_count; ++i)
                {
                    const auto entry = entries.get(i);

                    const int type = entry >> 12;
                    const auto offset = static_cast<uint16_t>(entry & 0xfff);
                    const auto address = base_address + relocation.VirtualAddress + offset;

                    switch (type)
                    {
                    case IMAGE_REL_BASED_ABSOLUTE:
                        break;

                    case IMAGE_REL_BASED_HIGHLOW:
                        apply_relocation<uint32_t>(sections, address, delta);
                        break;

                    case IMAGE_REL_BASED_DIR64:
                        apply_relocation<uint64_t>(sections, address, delta);
                        break;

                    default:
                        throw std::runtime_error("Unknown relocation type: " + std::to_string(type));
                    }
                }
            }
        }

        template <typename AddrType, typename SpanElement>
        section_map parse_pe_variant(const utils::safe_buffer_accessor<SpanElement>& buffer, const uint64_t base_address)
        {
            const auto dos_header = get_dos_header(buffer).get();
            const auto nt_headers_offset = dos_header.e_lfanew;
            const auto nt_headers = get_nt_headers<AddrType>(buffer).get();
            const int64_t aslr_slide = base_address - nt_headers.OptionalHeader.ImageBase;

            auto sections = parse_sections(buffer, nt_headers, nt_headers_offset, base_address);
            apply_relocations(buffer, nt_headers, nt_headers_offset, sections, aslr_slide, base_address);

            return sections;
        }
    }

    template <typename SpanElement>
    section_map parse_pe_file(const utils::safe_buffer_accessor<SpanElement>& buffer, const uint64_t base_address)
    {
        const auto nt_headers = detail::get_nt_headers<uint64_t>(buffer);
        const auto machine_type = nt_headers.get().FileHeader.Machine;

        switch (machine_type)
        {
        case PEMachineType::I386:
            return detail::parse_pe_variant<uint32_t>(buffer, base_address);
        case PEMachineType::AMD64:
            return detail::parse_pe_variant<uint64_t>(buffer, base_address);
        default:
            return {};
        }
    }
}

```

`src/plugin.cpp`:

```cpp
#include "ida_sdk.hpp"
#include "patch_finder.hpp"

namespace momo
{
    namespace
    {
        namespace plugin
        {
            constexpr const char* name = "Patch Finder";

            plugmod_t* idaapi initialize()
            {
                return PLUGIN_OK;
            }

            void idaapi terminate()
            {
            }

            bool idaapi run(size_t /*arg*/)
            {
                find_patches();
                return true;
            }

            consteval plugin_t create()
            {
                return {
                    .version = IDP_INTERFACE_VERSION,
                    .flags = PLUGIN_UNL,
                    .init = plugin::initialize,
                    .term = plugin::terminate,
                    .run = plugin::run,
                    .comment = plugin::name,
                    .help = plugin::name,
                    .wanted_name = plugin::name,
                    .wanted_hotkey = nullptr,
                };
            }
        }
    }
}

plugin_t PLUGIN = momo::plugin::create();

```

`src/win_pefile.hpp`:

```hpp
#pragma once

#include <cstdint>

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-use-enum-class)

using CHAR = int8_t;
using UCHAR = uint8_t;
using BOOLEAN = UCHAR;
using WORD = uint16_t;
using USHORT = WORD;
using DWORD = uint32_t;
using UINT = DWORD;
using ULONG = DWORD;
using LONG = int32_t;
using BOOL = LONG;
using DWORD64 = uint64_t;
using ULONGLONG = DWORD64;
using LONGLONG = int64_t;

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0 // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1 // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2 // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3 // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4 // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5 // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6 // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7  // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8  // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9  // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG     10 // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT    11 // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT             12 // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT    13 // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR  14 // COM Runtime descriptor

#define IMAGE_SCN_LNK_NRELOC_OVFL             0x01000000 // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE             0x02000000 // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED              0x04000000 // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED               0x08000000 // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                  0x10000000 // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                 0x20000000 // Section is executable.
#define IMAGE_SCN_MEM_READ                    0x40000000 // Section is readable.
#define IMAGE_SCN_MEM_WRITE                   0x80000000 // Section is writeable.

#define IMAGE_SCN_CNT_CODE                    0x00000020 // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA        0x00000040 // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA      0x00000080 // Section contains uninitialized data.

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_ARM_MOV32A            5
#define IMAGE_REL_BASED_ARM_MOV32             5
#define IMAGE_REL_BASED_SECTION               6
#define IMAGE_REL_BASED_REL                   7
#define IMAGE_REL_BASED_ARM_MOV32T            7
#define IMAGE_REL_BASED_THUMB_MOV32           7
#define IMAGE_REL_BASED_MIPS_JMPADDR16        9
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10
#define IMAGE_REL_BASED_HIGH3ADJ              11

#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040
#define IMAGE_FILE_DLL                        0x2000

#define IMAGE_FILE_MACHINE_I386               0x014c
#define IMAGE_FILE_MACHINE_AMD64              0x8664

#define PROCESSOR_ARCHITECTURE_AMD64          9

enum class PEMachineType : std::uint16_t
{
    UNKNOWN = 0,
    I386 = 0x014c,      // Intel 386.
    R3000 = 0x0162,     // MIPS little-endian, 0x160 big-endian
    R4000 = 0x0166,     // MIPS little-endian
    R10000 = 0x0168,    // MIPS little-endian
    WCEMIPSV2 = 0x0169, // MIPS little-endian WCE v2
    ALPHA = 0x0184,     // Alpha_AXP
    SH3 = 0x01a2,       // SH3 little-endian
    SH3DSP = 0x01a3,
    SH3E = 0x01a4,  // SH3E little-endian
    SH4 = 0x01a6,   // SH4 little-endian
    SH5 = 0x01a8,   // SH5
    ARM = 0x01c0,   // ARM Little-Endian
    THUMB = 0x01c2, // ARM Thumb/Thumb-2 Little-Endian
    ARMNT = 0x01c4, // ARM Thumb-2 Little-Endian
    AM33 = 0x01d3,
    POWERPC = 0x01F0, // IBM PowerPC Little-Endian
    POWERPCFP = 0x01f1,
    IA64 = 0x0200,      // Intel 64
    MIPS16 = 0x0266,    // MIPS
    ALPHA64 = 0x0284,   // ALPHA64
    MIPSFPU = 0x0366,   // MIPS
    MIPSFPU16 = 0x0466, // MIPS
    AXP64 = ALPHA64,
    TRICORE = 0x0520, // Infineon
    CEF = 0x0CEF,
    EBC = 0x0EBC,   // EFI Byte Code
    AMD64 = 0x8664, // AMD64 (K8)
    M32R = 0x9041,  // M32R little-endian
    CEE = 0xC0EE,
};

#pragma pack(push, 4)

template <typename T>
struct PEOptionalHeaderBasePart2_t
{
};

template <>
struct PEOptionalHeaderBasePart2_t<std::uint32_t>
{
    std::uint32_t BaseOfData;
    std::uint32_t ImageBase;
};

template <>
struct PEOptionalHeaderBasePart2_t<std::uint64_t>
{
    std::uint64_t ImageBase;
};

template <typename T>
struct PEOptionalHeaderBasePart1_t
{
    enum
    {
        k_NumberOfDataDirectors = 16
    };

    uint16_t Magic;
    uint8_t MajorLinkerVersion;
    uint8_t MinorLinkerVersion;
    uint32_t SizeOfCode;
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint;
    uint32_t BaseOfCode;
};

struct PEDirectory_t2
{
    std::uint32_t VirtualAddress;
    std::uint32_t Size;
};

template <typename T>
struct PEOptionalHeaderBasePart3_t : PEOptionalHeaderBasePart1_t<T>, PEOptionalHeaderBasePart2_t<T>
{
    uint32_t SectionAlignment;
    uint32_t FileAlignment;
    uint16_t MajorOperatingSystemVersion;
    uint16_t MinorOperatingSystemVersion;
    uint16_t MajorImageVersion;
    uint16_t MinorImageVersion;
    uint16_t MajorSubsystemVersion;
    uint16_t MinorSubsystemVersion;
    uint32_t Win32VersionValue;
    uint32_t SizeOfImage;
    uint32_t SizeOfHeaders;
    uint32_t CheckSum;
    uint16_t Subsystem;
    uint16_t DllCharacteristics;
    T SizeOfStackReserve;
    T SizeOfStackCommit;
    T SizeOfHeapReserve;
    T SizeOfHeapCommit;
    uint32_t LoaderFlags;
    uint32_t NumberOfRvaAndSizes;
    PEDirectory_t2 DataDirectory[PEOptionalHeaderBasePart1_t<T>::k_NumberOfDataDirectors];
};

template <typename T>
struct PEOptionalHeader_t
{
};

template <>
struct PEOptionalHeader_t<std::uint32_t> : PEOptionalHeaderBasePart3_t<std::uint32_t>
{
    enum
    {
        k_Magic = 0x10b, // IMAGE_NT_OPTIONAL_HDR32_MAGIC
    };
};

template <>
struct PEOptionalHeader_t<std::uint64_t> : PEOptionalHeaderBasePart3_t<std::uint64_t>
{
    enum
    {
        k_Magic = 0x20b, // IMAGE_NT_OPTIONAL_HDR64_MAGIC
    };
};

struct PEFileHeader_t
{
    PEMachineType Machine;
    std::uint16_t NumberOfSections;
    std::uint32_t TimeDateStamp;
    std::uint32_t PointerToSymbolTable;
    std::uint32_t NumberOfSymbols;
    std::uint16_t SizeOfOptionalHeader;
    std::uint16_t Characteristics;
};

template <typename T>
struct PENTHeaders_t
{
    enum
    {
        k_Signature = 0x00004550, // IMAGE_NT_SIGNATURE
    };

    uint32_t Signature;
    PEFileHeader_t FileHeader;
    PEOptionalHeader_t<T> OptionalHeader;
};

struct PEDosHeader_t
{
    enum
    {
        k_Magic = 0x5A4D
    };

    std::uint16_t e_magic;    // Magic number ( k_Magic )
    std::uint16_t e_cblp;     // Bytes on last page of file
    std::uint16_t e_cp;       // Pages in file
    std::uint16_t e_crlc;     // Relocations
    std::uint16_t e_cparhdr;  // Size of header in paragraphs
    std::uint16_t e_minalloc; // Minimum extra paragraphs needed
    std::uint16_t e_maxalloc; // Maximum extra paragraphs needed
    std::uint16_t e_ss;       // Initial (relative) SS value
    std::uint16_t e_sp;       // Initial SP value
    std::uint16_t e_csum;     // Checksum
    std::uint16_t e_ip;       // Initial IP value
    std::uint16_t e_cs;       // Initial (relative) CS value
    std::uint16_t e_lfarlc;   // File address of relocation table
    std::uint16_t e_ovno;     // Overlay number
    std::uint16_t e_res[4];   // Reserved words
    std::uint16_t e_oemid;    // OEM identifier (for e_oeminfo)
    std::uint16_t e_oeminfo;  // OEM information; e_oemid specific
    std::uint16_t e_res2[10]; // Reserved words
    std::uint32_t e_lfanew;   // File address of new exe header
};

#pragma pack(pop)

#define IMAGE_SIZEOF_SHORT_NAME 8

#ifndef OS_WINDOWS
typedef struct _IMAGE_SECTION_HEADER
{
    std::uint8_t Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        std::uint32_t PhysicalAddress;
        std::uint32_t VirtualSize;
    } Misc;
    std::uint32_t VirtualAddress;
    std::uint32_t SizeOfRawData;
    std::uint32_t PointerToRawData;
    std::uint32_t PointerToRelocations;
    std::uint32_t PointerToLinenumbers;
    std::uint16_t NumberOfRelocations;
    std::uint16_t NumberOfLinenumbers;
    std::uint32_t Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_EXPORT_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_BASE_RELOCATION
{
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
    // WORD TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_ORDINAL_FLAG64             0x8000000000000000
#define IMAGE_ORDINAL_FLAG32             0x80000000
#define IMAGE_ORDINAL64(Ordinal)         (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal)         (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

typedef struct _IMAGE_IMPORT_BY_NAME
{
    WORD Hint;
    CHAR Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
    // union
    //{
    //     DWORD Characteristics;    // 0 for terminating null import descriptor
    DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    //} DUMMYUNIONNAME;
    DWORD TimeDateStamp; // 0 if not bound,
                         // -1 if bound, and real date\time stamp
                         //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                         // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD ForwarderChain; // -1 if no forwarders
    DWORD Name;
    DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_THUNK_DATA64
{
    union
    {
        ULONGLONG ForwarderString; // PBYTE
        ULONGLONG Function;        // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;

#endif

template <typename Traits>
struct SECTION_IMAGE_INFORMATION
{
    typename Traits::PVOID TransferAddress;
    ULONG ZeroBits;
    typename Traits::SIZE_T MaximumStackSize;
    typename Traits::SIZE_T CommittedStackSize;
    ULONG SubSystemType;

    union
    {
        struct
        {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };

        ULONG SubSystemVersion;
    };

    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };

        ULONG OperatingSystemVersion;
    };

    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    PEMachineType Machine;
    BOOLEAN ImageContainsCode;

    union
    {
        UCHAR ImageFlags;

        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };

    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
};

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-use-enum-class)

```