Project Path: arc_momo5502_sogen_ax2kd4hl

Source Tree:

```txt
arc_momo5502_sogen_ax2kd4hl
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ CMakePresets.json
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ cmake
â”‚   â”œâ”€â”€ compiler-env.cmake
â”‚   â”œâ”€â”€ misc
â”‚   â”‚   â””â”€â”€ node-pre-script.js
â”‚   â”œâ”€â”€ toolchain
â”‚   â”‚   â”œâ”€â”€ android-ndk.cmake
â”‚   â”‚   â”œâ”€â”€ emscripten.cmake
â”‚   â”‚   â”œâ”€â”€ ios.cmake
â”‚   â”‚   â””â”€â”€ mingw-w64.cmake
â”‚   â””â”€â”€ utils.cmake
â”œâ”€â”€ deps
â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ base64
â”‚   â”œâ”€â”€ capstone
â”‚   â”œâ”€â”€ flatbuffers
â”‚   â”œâ”€â”€ googletest
â”‚   â”œâ”€â”€ googletest.cmake
â”‚   â”œâ”€â”€ gtest-parallel
â”‚   â”œâ”€â”€ minidump_cpp
â”‚   â”œâ”€â”€ reflect
â”‚   â”œâ”€â”€ unicorn
â”‚   â”œâ”€â”€ zstd
â”‚   â””â”€â”€ zstd.cmake
â”œâ”€â”€ docs
â”‚   â””â”€â”€ images
â”‚       â”œâ”€â”€ cover.png
â”‚       â”œâ”€â”€ preview.jpg
â”‚       â””â”€â”€ yt.jpg
â”œâ”€â”€ page
â”‚   â”œâ”€â”€ components.json
â”‚   â”œâ”€â”€ eslint.config.js
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ public
â”‚   â”‚   â”œâ”€â”€ emulator-worker.js
â”‚   â”‚   â””â”€â”€ pinata.png
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ App.css
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”œâ”€â”€ Loader.ts
â”‚   â”‚   â”œâ”€â”€ animation.css
â”‚   â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”‚   â”œâ”€â”€ app-sidebar.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ emulation-summary.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ folder.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ item-list.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ output.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ settings-menu.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ status-indicator.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ text-tooltip.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ theme-provider.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ui
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ badge.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ breadcrumb.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ button.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ card.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ checkbox.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ context-menu.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dialog.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ drawer.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dropdown-menu.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ input.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ label.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ popover.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ radio-group.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ scroll-area.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ separator.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sheet.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sidebar.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ skeleton.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tabs.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ tooltip.tsx
â”‚   â”‚   â”‚   â””â”€â”€ youtube-video.tsx
â”‚   â”‚   â”œâ”€â”€ download.ts
â”‚   â”‚   â”œâ”€â”€ emulator.ts
â”‚   â”‚   â”œâ”€â”€ fb
â”‚   â”‚   â”‚   â”œâ”€â”€ debugger
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ application-exit.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ debug-event.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ emulation-status.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ event.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ get-state-request.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ get-state-response.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ pause-request.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ read-memory-request.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ read-memory-response.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ read-register-request.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ read-register-response.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ run-request.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ state.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ write-memory-request.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ write-memory-response.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ write-register-request.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ write-register-response.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ debugger.ts
â”‚   â”‚   â”‚   â””â”€â”€ events.ts
â”‚   â”‚   â”œâ”€â”€ filesystem-explorer.tsx
â”‚   â”‚   â”œâ”€â”€ filesystem.ts
â”‚   â”‚   â”œâ”€â”€ hooks
â”‚   â”‚   â”‚   â””â”€â”€ use-mobile.ts
â”‚   â”‚   â”œâ”€â”€ index.css
â”‚   â”‚   â”œâ”€â”€ landing-page.tsx
â”‚   â”‚   â”œâ”€â”€ lib
â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
â”‚   â”‚   â”œâ”€â”€ main.tsx
â”‚   â”‚   â”œâ”€â”€ pe-icon-parser.tsx
â”‚   â”‚   â”œâ”€â”€ playground.tsx
â”‚   â”‚   â”œâ”€â”€ settings.ts
â”‚   â”‚   â”œâ”€â”€ vite-env.d.ts
â”‚   â”‚   â””â”€â”€ zip-file.ts
â”‚   â”œâ”€â”€ tsconfig.app.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ tsconfig.node.json
â”‚   â””â”€â”€ vite.config.ts
â””â”€â”€ src
    â”œâ”€â”€ CMakeLists.txt
    â”œâ”€â”€ analyzer
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ analysis.cpp
    â”‚   â”œâ”€â”€ analysis.hpp
    â”‚   â”œâ”€â”€ disassembler.cpp
    â”‚   â”œâ”€â”€ disassembler.hpp
    â”‚   â”œâ”€â”€ main.cpp
    â”‚   â”œâ”€â”€ object_watching.hpp
    â”‚   â”œâ”€â”€ reflect_extension.hpp
    â”‚   â”œâ”€â”€ reflect_type_info.hpp
    â”‚   â”œâ”€â”€ resource.rc
    â”‚   â”œâ”€â”€ resources
    â”‚   â”‚   â””â”€â”€ icon.ico
    â”‚   â”œâ”€â”€ snapshot.cpp
    â”‚   â”œâ”€â”€ snapshot.hpp
    â”‚   â”œâ”€â”€ std_include.hpp
    â”‚   â”œâ”€â”€ tenet_tracer.cpp
    â”‚   â”œâ”€â”€ tenet_tracer.hpp
    â”‚   â””â”€â”€ test.py
    â”œâ”€â”€ backend-selection
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ backend_selection.cpp
    â”‚   â””â”€â”€ backend_selection.hpp
    â”œâ”€â”€ backends
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ icicle-emulator
    â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”‚   â”œâ”€â”€ icicle-bridge
    â”‚   â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”‚   â”‚   â”œâ”€â”€ Cargo.lock
    â”‚   â”‚   â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â”‚   â”‚   â”œâ”€â”€ data
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Ghidra
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ Processors
    â”‚   â”‚   â”‚   â”‚           â””â”€â”€ x86
    â”‚   â”‚   â”‚   â”‚               â””â”€â”€ data
    â”‚   â”‚   â”‚   â”‚                   â””â”€â”€ languages
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ adx.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ avx.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ avx2.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ avx2_manual.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ avx_manual.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ bmi1.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ bmi2.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ cet.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ clwb.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ fma.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ ia.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ lockable.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ lzcnt.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ macros.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ mpx.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ old
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86RealV1.lang
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86RealV1.trans
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86V1.lang
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86V1.trans
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86_64bit_v1.lang
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86_64bit_v1.trans
    â”‚   â”‚   â”‚   â”‚                       â”‚   â”œâ”€â”€ x86smmV1.lang
    â”‚   â”‚   â”‚   â”‚                       â”‚   â””â”€â”€ x86smmV1.trans
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ pclmulqdq.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ rdrand.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ sgx.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ sha.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ smx.sinc
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-16-real.pspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-16.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-16.gdis
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-16.pspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-32-golang.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-32-golang.register.info
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64-compat32.pspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64-gcc.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64-golang.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64-golang.register.info
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64-win.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64.dwarf
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64.pspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86-64.slaspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86.dwarf
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86.ldefs
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86.opinion
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86.pspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86.slaspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86borland.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86delphi.cspec
    â”‚   â”‚   â”‚   â”‚                       â”œâ”€â”€ x86gcc.cspec
    â”‚   â”‚   â”‚   â”‚                       â””â”€â”€ x86win.cspec
    â”‚   â”‚   â”‚   â””â”€â”€ src
    â”‚   â”‚   â”‚       â”œâ”€â”€ icicle.rs
    â”‚   â”‚   â”‚       â”œâ”€â”€ lib.rs
    â”‚   â”‚   â”‚       â””â”€â”€ registers.rs
    â”‚   â”‚   â”œâ”€â”€ icicle_x86_64_emulator.cpp
    â”‚   â”‚   â””â”€â”€ icicle_x86_64_emulator.hpp
    â”‚   â””â”€â”€ unicorn-emulator
    â”‚       â”œâ”€â”€ CMakeLists.txt
    â”‚       â”œâ”€â”€ function_wrapper.hpp
    â”‚       â”œâ”€â”€ unicorn.hpp
    â”‚       â”œâ”€â”€ unicorn_hook.hpp
    â”‚       â”œâ”€â”€ unicorn_memory_regions.hpp
    â”‚       â”œâ”€â”€ unicorn_x86_64_emulator.cpp
    â”‚       â””â”€â”€ unicorn_x86_64_emulator.hpp
    â”œâ”€â”€ common
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ network
    â”‚   â”‚   â”œâ”€â”€ address.cpp
    â”‚   â”‚   â”œâ”€â”€ address.hpp
    â”‚   â”‚   â”œâ”€â”€ socket.cpp
    â”‚   â”‚   â”œâ”€â”€ socket.hpp
    â”‚   â”‚   â”œâ”€â”€ tcp_client_socket.cpp
    â”‚   â”‚   â”œâ”€â”€ tcp_client_socket.hpp
    â”‚   â”‚   â”œâ”€â”€ tcp_server_socket.cpp
    â”‚   â”‚   â”œâ”€â”€ tcp_server_socket.hpp
    â”‚   â”‚   â”œâ”€â”€ udp_socket.cpp
    â”‚   â”‚   â””â”€â”€ udp_socket.hpp
    â”‚   â”œâ”€â”€ platform
    â”‚   â”‚   â”œâ”€â”€ compiler.hpp
    â”‚   â”‚   â”œâ”€â”€ file_management.hpp
    â”‚   â”‚   â”œâ”€â”€ kernel_mapped.hpp
    â”‚   â”‚   â”œâ”€â”€ memory.hpp
    â”‚   â”‚   â”œâ”€â”€ network.hpp
    â”‚   â”‚   â”œâ”€â”€ platform.hpp
    â”‚   â”‚   â”œâ”€â”€ port.hpp
    â”‚   â”‚   â”œâ”€â”€ primitives.hpp
    â”‚   â”‚   â”œâ”€â”€ process.hpp
    â”‚   â”‚   â”œâ”€â”€ registry.hpp
    â”‚   â”‚   â”œâ”€â”€ status.hpp
    â”‚   â”‚   â”œâ”€â”€ synchronisation.hpp
    â”‚   â”‚   â”œâ”€â”€ threading.hpp
    â”‚   â”‚   â”œâ”€â”€ traits.hpp
    â”‚   â”‚   â”œâ”€â”€ unicode.hpp
    â”‚   â”‚   â”œâ”€â”€ user.hpp
    â”‚   â”‚   â”œâ”€â”€ win_pefile.hpp
    â”‚   â”‚   â””â”€â”€ window.hpp
    â”‚   â”œâ”€â”€ segment_utils.hpp
    â”‚   â””â”€â”€ utils
    â”‚       â”œâ”€â”€ buffer_accessor.hpp
    â”‚       â”œâ”€â”€ compression.cpp
    â”‚       â”œâ”€â”€ compression.hpp
    â”‚       â”œâ”€â”€ concurrency.hpp
    â”‚       â”œâ”€â”€ container.hpp
    â”‚       â”œâ”€â”€ file_handle.hpp
    â”‚       â”œâ”€â”€ finally.hpp
    â”‚       â”œâ”€â”€ function.hpp
    â”‚       â”œâ”€â”€ interupt_handler.cpp
    â”‚       â”œâ”€â”€ interupt_handler.hpp
    â”‚       â”œâ”€â”€ io.cpp
    â”‚       â”œâ”€â”€ io.hpp
    â”‚       â”œâ”€â”€ lazy_object.hpp
    â”‚       â”œâ”€â”€ moved_marker.hpp
    â”‚       â”œâ”€â”€ nt_handle.hpp
    â”‚       â”œâ”€â”€ object.hpp
    â”‚       â”œâ”€â”€ path_key.hpp
    â”‚       â”œâ”€â”€ string.cpp
    â”‚       â”œâ”€â”€ string.hpp
    â”‚       â”œâ”€â”€ time.cpp
    â”‚       â”œâ”€â”€ time.hpp
    â”‚       â”œâ”€â”€ timer.hpp
    â”‚       â”œâ”€â”€ wildcard.hpp
    â”‚       â””â”€â”€ win.hpp
    â”œâ”€â”€ debugger
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ event_handler.cpp
    â”‚   â”œâ”€â”€ event_handler.hpp
    â”‚   â”œâ”€â”€ events.fbs
    â”‚   â”œâ”€â”€ events_generated.hxx
    â”‚   â”œâ”€â”€ message_transmitter.cpp
    â”‚   â””â”€â”€ message_transmitter.hpp
    â”œâ”€â”€ emulator
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ address_utils.hpp
    â”‚   â”œâ”€â”€ arch_emulator.hpp
    â”‚   â”œâ”€â”€ binary_writer.hpp
    â”‚   â”œâ”€â”€ cpu_interface.hpp
    â”‚   â”œâ”€â”€ empty.cpp
    â”‚   â”œâ”€â”€ emulator.hpp
    â”‚   â”œâ”€â”€ hook_interface.hpp
    â”‚   â”œâ”€â”€ memory_interface.hpp
    â”‚   â”œâ”€â”€ memory_permission.hpp
    â”‚   â”œâ”€â”€ memory_region.hpp
    â”‚   â”œâ”€â”€ scoped_hook.hpp
    â”‚   â”œâ”€â”€ serialization.hpp
    â”‚   â”œâ”€â”€ serialization_helper.hpp
    â”‚   â”œâ”€â”€ typed_emulator.hpp
    â”‚   â””â”€â”€ x86_register.hpp
    â”œâ”€â”€ fuzzer
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ main.cpp
    â”‚   â”œâ”€â”€ resource.rc
    â”‚   â”œâ”€â”€ resources
    â”‚   â”‚   â””â”€â”€ icon.ico
    â”‚   â””â”€â”€ std_include.hpp
    â”œâ”€â”€ fuzzing-engine
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ fuzzer.cpp
    â”‚   â”œâ”€â”€ fuzzer.hpp
    â”‚   â”œâ”€â”€ input_generator.cpp
    â”‚   â”œâ”€â”€ input_generator.hpp
    â”‚   â”œâ”€â”€ random_generator.cpp
    â”‚   â””â”€â”€ random_generator.hpp
    â”œâ”€â”€ gdb-stub
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ async_handler.cpp
    â”‚   â”œâ”€â”€ async_handler.hpp
    â”‚   â”œâ”€â”€ checksum.hpp
    â”‚   â”œâ”€â”€ connection_handler.cpp
    â”‚   â”œâ”€â”€ connection_handler.hpp
    â”‚   â”œâ”€â”€ gdb_stub.cpp
    â”‚   â”œâ”€â”€ gdb_stub.hpp
    â”‚   â”œâ”€â”€ stream_processor.cpp
    â”‚   â””â”€â”€ stream_processor.hpp
    â”œâ”€â”€ samples
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ bad-sample
    â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”‚   â””â”€â”€ bad.cpp
    â”‚   â”œâ”€â”€ minimal-32bit-sample
    â”‚   â”‚   â””â”€â”€ hello.asm
    â”‚   â””â”€â”€ test-sample
    â”‚       â”œâ”€â”€ CMakeLists.txt
    â”‚       â”œâ”€â”€ resource.rc
    â”‚       â”œâ”€â”€ resources
    â”‚       â”‚   â””â”€â”€ icon.ico
    â”‚       â””â”€â”€ test.cpp
    â”œâ”€â”€ tools
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ create-root.bat
    â”‚   â”œâ”€â”€ dump-apiset
    â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”‚   â””â”€â”€ dump-apiset.cpp
    â”‚   â””â”€â”€ grab-registry.bat
    â”œâ”€â”€ windows-emulator
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ apiset
    â”‚   â”‚   â”œâ”€â”€ apiset.cpp
    â”‚   â”‚   â”œâ”€â”€ apiset.hpp
    â”‚   â”‚   â””â”€â”€ default_apiset.hpp
    â”‚   â”œâ”€â”€ cpu_context.cpp
    â”‚   â”œâ”€â”€ cpu_context.hpp
    â”‚   â”œâ”€â”€ devices
    â”‚   â”‚   â”œâ”€â”€ afd_endpoint.cpp
    â”‚   â”‚   â”œâ”€â”€ afd_endpoint.hpp
    â”‚   â”‚   â”œâ”€â”€ afd_types.hpp
    â”‚   â”‚   â”œâ”€â”€ mount_point_manager.cpp
    â”‚   â”‚   â”œâ”€â”€ mount_point_manager.hpp
    â”‚   â”‚   â”œâ”€â”€ mountmgr.hpp
    â”‚   â”‚   â”œâ”€â”€ named_pipe.hpp
    â”‚   â”‚   â”œâ”€â”€ security_support_provider.cpp
    â”‚   â”‚   â””â”€â”€ security_support_provider.hpp
    â”‚   â”œâ”€â”€ emulator_thread.cpp
    â”‚   â”œâ”€â”€ emulator_thread.hpp
    â”‚   â”œâ”€â”€ emulator_utils.hpp
    â”‚   â”œâ”€â”€ exception_dispatch.cpp
    â”‚   â”œâ”€â”€ exception_dispatch.hpp
    â”‚   â”œâ”€â”€ file_system.hpp
    â”‚   â”œâ”€â”€ generic_logger.hpp
    â”‚   â”œâ”€â”€ handles.hpp
    â”‚   â”œâ”€â”€ io_completion_wait.cpp
    â”‚   â”œâ”€â”€ io_completion_wait.hpp
    â”‚   â”œâ”€â”€ io_device.cpp
    â”‚   â”œâ”€â”€ io_device.hpp
    â”‚   â”œâ”€â”€ kusd_mmio.cpp
    â”‚   â”œâ”€â”€ kusd_mmio.hpp
    â”‚   â”œâ”€â”€ logger.cpp
    â”‚   â”œâ”€â”€ logger.hpp
    â”‚   â”œâ”€â”€ memory_manager.cpp
    â”‚   â”œâ”€â”€ memory_manager.hpp
    â”‚   â”œâ”€â”€ memory_permission_ext.hpp
    â”‚   â”œâ”€â”€ memory_utils.hpp
    â”‚   â”œâ”€â”€ minidump_loader.cpp
    â”‚   â”œâ”€â”€ minidump_loader.hpp
    â”‚   â”œâ”€â”€ module
    â”‚   â”‚   â”œâ”€â”€ mapped_module.hpp
    â”‚   â”‚   â”œâ”€â”€ module_manager.cpp
    â”‚   â”‚   â”œâ”€â”€ module_manager.hpp
    â”‚   â”‚   â”œâ”€â”€ module_mapping.cpp
    â”‚   â”‚   â””â”€â”€ module_mapping.hpp
    â”‚   â”œâ”€â”€ network
    â”‚   â”‚   â”œâ”€â”€ i_socket.hpp
    â”‚   â”‚   â”œâ”€â”€ socket_factory.cpp
    â”‚   â”‚   â”œâ”€â”€ socket_factory.hpp
    â”‚   â”‚   â”œâ”€â”€ socket_wrapper.cpp
    â”‚   â”‚   â”œâ”€â”€ socket_wrapper.hpp
    â”‚   â”‚   â”œâ”€â”€ static_socket_factory.cpp
    â”‚   â”‚   â””â”€â”€ static_socket_factory.hpp
    â”‚   â”œâ”€â”€ port.cpp
    â”‚   â”œâ”€â”€ port.hpp
    â”‚   â”œâ”€â”€ ports
    â”‚   â”‚   â”œâ”€â”€ api_port.cpp
    â”‚   â”‚   â”œâ”€â”€ api_port.hpp
    â”‚   â”‚   â”œâ”€â”€ dns_resolver.cpp
    â”‚   â”‚   â”œâ”€â”€ dns_resolver.hpp
    â”‚   â”‚   â”œâ”€â”€ lsa_policy_lookup.cpp
    â”‚   â”‚   â””â”€â”€ lsa_policy_lookup.hpp
    â”‚   â”œâ”€â”€ process_context.cpp
    â”‚   â”œâ”€â”€ process_context.hpp
    â”‚   â”œâ”€â”€ registry
    â”‚   â”‚   â”œâ”€â”€ hive_parser.cpp
    â”‚   â”‚   â”œâ”€â”€ hive_parser.hpp
    â”‚   â”‚   â”œâ”€â”€ registry_manager.cpp
    â”‚   â”‚   â””â”€â”€ registry_manager.hpp
    â”‚   â”œâ”€â”€ std_include.hpp
    â”‚   â”œâ”€â”€ syscall_dispatcher.cpp
    â”‚   â”œâ”€â”€ syscall_dispatcher.hpp
    â”‚   â”œâ”€â”€ syscall_utils.hpp
    â”‚   â”œâ”€â”€ syscalls
    â”‚   â”‚   â”œâ”€â”€ event.cpp
    â”‚   â”‚   â”œâ”€â”€ exception.cpp
    â”‚   â”‚   â”œâ”€â”€ file.cpp
    â”‚   â”‚   â”œâ”€â”€ gdi.cpp
    â”‚   â”‚   â”œâ”€â”€ io_completion.cpp
    â”‚   â”‚   â”œâ”€â”€ license.cpp
    â”‚   â”‚   â”œâ”€â”€ locale.cpp
    â”‚   â”‚   â”œâ”€â”€ memory.cpp
    â”‚   â”‚   â”œâ”€â”€ mutant.cpp
    â”‚   â”‚   â”œâ”€â”€ object.cpp
    â”‚   â”‚   â”œâ”€â”€ port.cpp
    â”‚   â”‚   â”œâ”€â”€ process.cpp
    â”‚   â”‚   â”œâ”€â”€ registry.cpp
    â”‚   â”‚   â”œâ”€â”€ section.cpp
    â”‚   â”‚   â”œâ”€â”€ semaphore.cpp
    â”‚   â”‚   â”œâ”€â”€ system.cpp
    â”‚   â”‚   â”œâ”€â”€ thread.cpp
    â”‚   â”‚   â”œâ”€â”€ timer.cpp
    â”‚   â”‚   â”œâ”€â”€ token.cpp
    â”‚   â”‚   â”œâ”€â”€ trace.cpp
    â”‚   â”‚   â”œâ”€â”€ user.cpp
    â”‚   â”‚   â””â”€â”€ worker_factory.cpp
    â”‚   â”œâ”€â”€ syscalls.cpp
    â”‚   â”œâ”€â”€ user_callback_dispatch.hpp
    â”‚   â”œâ”€â”€ user_handle_table.hpp
    â”‚   â”œâ”€â”€ version
    â”‚   â”‚   â”œâ”€â”€ windows_version_manager.cpp
    â”‚   â”‚   â””â”€â”€ windows_version_manager.hpp
    â”‚   â”œâ”€â”€ win32k_userconnect.cpp
    â”‚   â”œâ”€â”€ win32k_userconnect.hpp
    â”‚   â”œâ”€â”€ windows_emulator.cpp
    â”‚   â”œâ”€â”€ windows_emulator.hpp
    â”‚   â”œâ”€â”€ windows_objects.hpp
    â”‚   â”œâ”€â”€ windows_path.hpp
    â”‚   â””â”€â”€ wow64_heaven_gate.hpp
    â”œâ”€â”€ windows-emulator-test
    â”‚   â”œâ”€â”€ CMakeLists.txt
    â”‚   â”œâ”€â”€ emulation_test.cpp
    â”‚   â”œâ”€â”€ emulation_test_utils.hpp
    â”‚   â”œâ”€â”€ file_system_test.cpp
    â”‚   â”œâ”€â”€ serialization_test.cpp
    â”‚   â”œâ”€â”€ time_test.cpp
    â”‚   â””â”€â”€ unicode_test.cpp
    â””â”€â”€ windows-gdb-stub
        â”œâ”€â”€ CMakeLists.txt
        â”œâ”€â”€ empty.cpp
        â”œâ”€â”€ win_x64_gdb_stub_handler.hpp
        â”œâ”€â”€ x64_gdb_stub_handler.hpp
        â”œâ”€â”€ x64_register_mapping.hpp
        â””â”€â”€ x64_target_descriptions.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.26.4)

##########################################

option(MOMO_ENABLE_AVX2 "Enable AVX2 support" ON)
option(MOMO_ENABLE_SANITIZER "Enable sanitizer" OFF)
option(MOMO_ENABLE_CLANG_TIDY "Enable clang-tidy checks" OFF)
option(MOMO_ENABLE_RUST_CODE "Enable code parts written in rust" ON)
option(MOMO_EMSCRIPTEN_MEMORY64 "Enable memory 64 support for emscripten builds" OFF)
option(MOMO_EMSCRIPTEN_SUPPORT_NODEJS "Enable Node.js filesystem for emscripten compilation" OFF)

set(MOMO_REFLECTION_LEVEL "0" CACHE STRING "Reflection level for the build")
message(STATUS "Reflection level is set to: ${MOMO_REFLECTION_LEVEL}")
add_compile_definitions(MOMO_REFLECTION_LEVEL=${MOMO_REFLECTION_LEVEL})

##########################################

set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

if(NOT CMAKE_SYSTEM_NAME STREQUAL "iOS")
  set(CMAKE_OSX_DEPLOYMENT_TARGET 11.0)
endif()

# Prevent unicorn from generating universal binaries on macOS
# It doesn't support it, even if it thinks it does...
set(ENV{ARCHFLAGS} "nope")

##########################################

project(sogen LANGUAGES C CXX)
enable_testing()

##########################################

if(PROJECT_IS_TOP_LEVEL)
  set(MOMO_IS_SUBPROJECT OFF)
else()
  set(MOMO_IS_SUBPROJECT ON)
endif()

##########################################

option(SOGEN_BUILD_STATIC "Build sogen as static libraries for embedding (e.g., IDA plugins)" ${MOMO_IS_SUBPROJECT})
if (MOMO_IS_SUBPROJECT)
  set(SOGEN_BUILD_TOOLS_DEFAULT OFF)
else()
  set(SOGEN_BUILD_TOOLS_DEFAULT ON)
endif()
option(SOGEN_BUILD_TOOLS "Build Sogen standalone tools (analyzer, debugger, fuzzer, etc.)" ${SOGEN_BUILD_TOOLS_DEFAULT})

##########################################

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

##########################################

include(cmake/utils.cmake)
include(cmake/compiler-env.cmake)

##########################################

momo_set_new_artifact_directory()

##########################################

momo_add_subdirectory_and_get_targets("deps" EXTERNAL_TARGETS)
momo_add_subdirectory_and_get_targets("src" OWN_TARGETS)

##########################################

momo_targets_set_folder("dependencies" ${EXTERNAL_TARGETS})

momo_targets_exclude_from_all(${EXTERNAL_TARGETS})
momo_targets_disable_warnings(${EXTERNAL_TARGETS})

momo_targets_expose_includes(${OWN_TARGETS})
momo_targets_set_warnings_as_errors(${OWN_TARGETS})
momo_targets_enable_clang_tidy(${OWN_TARGETS})

```

`CMakePresets.json`:

```json
{
    "version": 6,
    "cmakeMinimumRequired": {
        "major": 3,
        "minor": 26,
        "patch": 4
    },
    "configurePresets": [
        {
            "name": "build",
            "hidden": true,
            "binaryDir": "${sourceDir}/build/${presetName}"
        },
        {
            "name": "ninja",
            "hidden": true,
            "generator": "Ninja"
        },
        {
            "name": "release",
            "inherits": [
                "ninja",
                "build"
            ],
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "RelWithDebInfo"
            }
        },
        {
            "name": "debug",
            "inherits": [
                "ninja",
                "build"
            ],
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "vs2022",
            "generator": "Visual Studio 17 2022",
            "inherits": "build"
        }
    ],
    "buildPresets": [
        {
            "name": "release",
            "configurePreset": "release"
        },
        {
            "name": "debug",
            "configurePreset": "debug"
        }
    ],
    "workflowPresets": [
        {
            "name": "release",
            "steps": [
                {
                    "type": "configure",
                    "name": "release"
                },
                {
                    "type": "build",
                    "name": "release"
                }
            ]
        },
        {
            "name": "debug",
            "steps": [
                {
                    "type": "configure",
                    "name": "debug"
                },
                {
                    "type": "build",
                    "name": "debug"
                }
            ]
        }
    ]
}
```

`LICENSE`:

```
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.
```

`README.md`:

```md
<h1 align="center">
	<img src="https://momo5502.com/emulator/banner.png" height="200" />
	<br>
	<a href="https://github.com/momo5502/sogen?tab=GPL-2.0-1-ov-file"><img src="https://img.shields.io/github/license/momo5502/sogen?color=00B0F8"/></a>
	<a href="https://github.com/momo5502/sogen/actions"><img src="https://img.shields.io/github/actions/workflow/status/momo5502/sogen/build.yml?branch=main&label=build"/></a>
	<a href="https://github.com/momo5502/sogen/issues"><img src="https://img.shields.io/github/issues/momo5502/sogen?color=F8B000"/></a>
	<img src="https://img.shields.io/github/commit-activity/m/momo5502/sogen?color=FF3131"/>  
	<a href="https://deepwiki.com/momo5502/sogen"><img src="https://deepwiki.com/badge.svg"/></a>
</h1>

Sogen is a high-performance Windows user space emulator that operates at syscall level, providing full control over process execution through comprehensive hooking capabilities.

Perfect for security research, malware analysis, and DRM research where fine-grained control over process execution is required.

Built in C++ and powered by the [Unicorn Engine](https://github.com/unicorn-engine/unicorn) or the [icicle-emu](https://github.com/icicle-emu/icicle-emu).

Try it out: <a href="https://sogen.dev">sogen.dev</a>

<hr>

> [!WARNING]  
> Caution is advised when analyzing malware in Sogen, as host isolation might not be perfect.  
> To mitigate potential risk, use the <a href="https://sogen.dev/#/playground">web version</a> to benefit from the additional safety provided by your browser's sandbox.

## Key Features

* ğŸ”„ __Syscall-Level Emulation__
	* Instead of reimplementing Windows APIs, the emulator operates at the syscall level, allowing it to leverage existing system DLLs
* ğŸ“ __Advanced Memory Management__
	* Supports Windows-specific memory types including reserved, committed, built on top of Unicorn's memory management
* ğŸ“¦ __Complete PE Loading__
	* Handles executable and DLL loading with proper memory mapping, relocations, and TLS
* âš¡ __Exception Handling__
	* Implements Windows structured exception handling (SEH) with proper exception dispatcher and unwinding support
* ğŸ§µ __Threading Support__
	* Provides a scheduled (round-robin) threading model
* ğŸ’¾ __State Management__
	* Supports both full state serialization and ~~fast in-memory snapshots~~ (currently broken ğŸ˜•)
* ğŸ’» __Debugging Interface__
	* Implements GDB serial protocol for integration with common debugging tools (IDA Pro, GDB, LLDB, VS Code, ...)

## Preview

![Preview](./docs/images/preview.jpg)

## YouTube Overview

[![YouTube video](./docs/images/yt.jpg)](https://www.youtube.com/watch?v=wY9Q0DhodOQ)

Click <a href="https://docs.google.com/presentation/d/1pha4tFfDMpVzJ_ehJJ21SA_HAWkufQBVYQvh1IFhVls/edit">here</a> for the slides.

## Quick Start (Windows + Visual Studio)

> [!TIP]  
> Checkout the [Wiki](https://github.com/momo5502/sogen/wiki) for more details on how to build & run the emulator on Windows, Linux, macOS, ...

1\. Checkout the code:

```bash
git clone --recurse-submodules https://github.com/momo5502/sogen.git
```

2\. Run the following command in an x64 Development Command Prompt in the cloned directory:

```bash
cmake --preset=vs2022
```

3\. Build the solution that was generated at `build/vs2022/emulator.sln`

4\. Create a registry dump by running the [grab-registry.bat](https://github.com/momo5502/sogen/blob/main/src/tools/grab-registry.bat) as administrator and place it in the artifacts folder next to the `analyzer.exe`

5\. Run the program of your choice:

```bash
analyzer.exe C:\example.exe
```

```

`cmake/compiler-env.cmake`:

```cmake
include_guard()
include(CheckCXXCompilerFlag)

##########################################
# System identification

set(OSX OFF)
set(LINUX OFF)
set(WIN OFF)

if(CMAKE_SYSTEM_NAME MATCHES "Linux")
    set(LINUX ON)
elseif(CMAKE_SYSTEM_NAME MATCHES "Darwin")
    set(OSX ON)
elseif(CMAKE_SYSTEM_NAME MATCHES "Windows")
    set(WIN ON)
endif()

##########################################

cmake_policy(SET CMP0069 NEW) 
set(CMAKE_POLICY_DEFAULT_CMP0069 NEW)

set(CMAKE_POSITION_INDEPENDENT_CODE ON)

##########################################

if(NOT MINGW AND NOT CMAKE_SYSTEM_NAME MATCHES "Emscripten")
  set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)
endif()

##########################################

if(SOGEN_BUILD_STATIC)
    add_compile_definitions(SOGEN_BUILD_STATIC=1)
else()
    add_compile_definitions(SOGEN_BUILD_STATIC=0)
endif()

##########################################

set(MOMO_ENABLE_RUST OFF)
if(MOMO_ENABLE_RUST_CODE AND NOT MINGW AND NOT CMAKE_SYSTEM_NAME MATCHES "Emscripten")
  set(MOMO_ENABLE_RUST ON)
endif()

##########################################

if(MOMO_ENABLE_RUST)
  add_compile_definitions(MOMO_ENABLE_RUST_CODE=1)
else()
  add_compile_definitions(MOMO_ENABLE_RUST_CODE=0)
endif()

##########################################

if(UNIX)
  momo_add_c_and_cxx_compile_options(
    -fvisibility=hidden
    -ftrivial-auto-var-init=zero
  )
endif()

##########################################

if(MINGW)
  add_link_options(
    -static-libstdc++
    -static-libgcc
    -static
    -lwinpthread
  )

  momo_add_c_and_cxx_compile_options(
    -Wno-array-bounds
  )
endif()

##########################################

if(LINUX OR APPLE)
  momo_add_c_and_cxx_compile_options(
    -fdiagnostics-color=always
  )

  momo_add_c_and_cxx_release_compile_options(
    -ffunction-sections
    -fdata-sections
    -fstack-protector-strong
  )
  
  if(LINUX)
    add_link_options(
      -Wl,--no-undefined
      -Wl,-z,now
      -Wl,-z,noexecstack
      -static-libstdc++
    )

    momo_add_release_link_options(
      -Wl,--gc-sections
    )
  else()
    momo_add_release_link_options(
      -dead_strip
    )
  endif()

  add_compile_definitions(
    _REENTRANT
    _THREAD_SAFE
  )

  if(NOT MOMO_ENABLE_SANITIZER)
    add_compile_definitions(
      _FORTIFY_SOURCE=2
    )
  endif()

  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -pie")
endif()

##########################################

if(CMAKE_SYSTEM_NAME MATCHES "Emscripten")
  momo_add_c_and_cxx_compile_options(
    -fexceptions
    -ftrivial-auto-var-init=zero
    -Wno-dollar-in-identifier-extension
  )

  add_link_options(
    -fexceptions
    -sALLOW_MEMORY_GROWTH=1
    $<$<CONFIG:Debug>:-sASSERTIONS>
    -sWASM_BIGINT
    #-sUSE_OFFSET_CONVERTER
    #-sEXCEPTION_CATCHING_ALLOWED=[..]
    -sEXIT_RUNTIME
    -sASYNCIFY
  )

  if(MOMO_EMSCRIPTEN_MEMORY64)
    momo_add_c_and_cxx_compile_options(
      -sMEMORY64
    )

    add_link_options(
      -sMAXIMUM_MEMORY=8gb
      -sMEMORY64
    )
  else()
    add_link_options(
      -sMAXIMUM_MEMORY=4gb
    )
  endif()

  if(MOMO_EMSCRIPTEN_SUPPORT_NODEJS)
    add_compile_definitions(
      MOMO_EMSCRIPTEN_SUPPORT_NODEJS=1
    )

    add_link_options(
      -lnodefs.js -sNODERAWFS=1
      -sENVIRONMENT=node
      --pre-js ${CMAKE_CURRENT_LIST_DIR}/misc/node-pre-script.js
    )
  else() 
    add_link_options(
      -lidbfs.js
      -sENVIRONMENT=worker
      -sINVOKE_RUN=0
      -sEXPORTED_RUNTIME_METHODS=['callMain']
    )
  endif()
endif()

##########################################

if(MSVC)
  string(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
  string(REPLACE "/EHs" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")

  momo_add_c_and_cxx_compile_options(
    /sdl
    /GS
    /Gy
    /EHa
    #/guard:cf
  )

  momo_add_compile_options(CXX
    /Zc:__cplusplus
  )

  momo_add_c_and_cxx_release_compile_options(
    /Gw
  )

  momo_add_release_link_options(
    /OPT:REF
    /OPT:ICF
  )

  add_link_options(
    /INCREMENTAL:NO
  )

  add_compile_definitions(
    _CRT_SECURE_NO_WARNINGS
    _CRT_NONSTDC_NO_WARNINGS
  )
endif()

##########################################

if(MOMO_ENABLE_AVX2 AND NOT (CMAKE_SYSTEM_NAME STREQUAL "Android"))
  set(CMAKE_REQUIRED_FLAGS -Werror)
  check_cxx_compiler_flag(-mavx2 COMPILER_SUPPORTS_MAVX2)
  set(CMAKE_REQUIRED_FLAGS "")

  check_cxx_compiler_flag(/arch:AVX2 COMPILER_SUPPORTS_ARCH_AVX2)

  if(COMPILER_SUPPORTS_MAVX2)
    momo_add_c_and_cxx_compile_options(-mavx2)
  endif()

  if (COMPILER_SUPPORTS_ARCH_AVX2)
    momo_add_c_and_cxx_compile_options(/arch:AVX2)
  endif()
endif()

##########################################

if(MOMO_ENABLE_SANITIZER)
  momo_add_c_and_cxx_compile_options(-fsanitize=address)
  add_link_options(-fsanitize=address)
endif()

##########################################
# MSVC Runtime Library Selection
#
# Default is dynamic runtime (/MD or /MDd) to enforce shared allocators
# between emulator and implementation.
#
# Use SOGEN_STATIC_CRT=ON for static runtime (/MT or /MTd) when embedding
# in projects that require it (e.g., IDA plugins).
#
# WARNING: Static CRT may cause heap corruption if memory is allocated
# in one module and freed in another. Ensure allocation ownership is clear.

option(SOGEN_STATIC_CRT "Use static CRT (/MT) instead of dynamic (/MD)" OFF)

if(SOGEN_STATIC_CRT AND NOT SOGEN_BUILD_STATIC)
  message(FATAL_ERROR
    "SOGEN_STATIC_CRT=ON requires SOGEN_BUILD_STATIC=ON.\n"
    "Static CRT with shared libraries causes heap corruption - "
    "each DLL gets its own allocator, but sogen passes ownership across boundaries.")
endif()

if(SOGEN_STATIC_CRT)
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
elseif(DEFINED CMAKE_MSVC_RUNTIME_LIBRARY)
  # Respect parent project's setting
else()
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL")
endif()

##########################################

if(MSVC)
  add_link_options(
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreaded>>:/NODEFAULTLIB:libcmt.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDLL>>:/NODEFAULTLIB:msvcrt.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDebug>>:/NODEFAULTLIB:libcmtd.lib>
    $<$<NOT:$<STREQUAL:${CMAKE_MSVC_RUNTIME_LIBRARY},MultiThreadedDebugDLL>>:/NODEFAULTLIB:msvcrtd.lib>
  )
endif()

##########################################

if(CMAKE_GENERATOR MATCHES "Visual Studio")
  momo_add_c_and_cxx_compile_options(/MP)
endif()

```

`cmake/misc/node-pre-script.js`:

```js
Module["preRun"] = () => {
  ENV = process.env;
};

```

`cmake/toolchain/android-ndk.cmake`:

```cmake
set(CMAKE_SYSTEM_NAME "Android")
set(CMAKE_ANDROID_NDK "$ENV{ANDROID_NDK_ROOT}")

set(ANDROID_ABI "$ENV{ANDROID_ABI}")
set(CMAKE_ANDROID_ARCH_ABI "${ANDROID_ABI}")
set(CMAKE_ANDROID_API "24")
```

`cmake/toolchain/emscripten.cmake`:

```cmake
set(CMAKE_SYSTEM_NAME Emscripten)
set(CMAKE_SYSTEM_VERSION 1)

# Specify the cross-compilers
set(CMAKE_C_COMPILER emcc)
set(CMAKE_CXX_COMPILER em++)

# Set the Emscripten root directory
set(EMSCRIPTEN_ROOT_PATH $ENV{EMSDK}/upstream/emscripten)

# Set the Emscripten toolchain file
set(CMAKE_SYSROOT ${EMSCRIPTEN_ROOT_PATH}/system)

# Set the Emscripten include directories
set(CMAKE_FIND_ROOT_PATH ${EMSCRIPTEN_ROOT_PATH}/system/include)

# Set the Emscripten library directories
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# Set the Emscripten linker
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s USE_SDL=2 -s USE_SDL_MIXER=2")

# Set the Emscripten runtime
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --shell-file shell_minimal.html")

# Set the Emscripten optimization flags
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3")

# Set the Emscripten debug flags
set(CMAKE_BUILD_TYPE Release)

# Set the Emscripten output format
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -o <TARGET>.html")

# Set the Emscripten file extensions
set(CMAKE_EXECUTABLE_SUFFIX ".js")

# Set the Emscripten runtime options
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s EXPORTED_FUNCTIONS='[_main]' -s EXPORTED_RUNTIME_METHODS='[\"cwrap\"]'")
```

`cmake/toolchain/ios.cmake`:

```cmake
set(CMAKE_SYSTEM_NAME "iOS")
set(CMAKE_OSX_ARCHITECTURES "arm64")
set(CMAKE_OSX_DEPLOYMENT_TARGET 14.0)
```

`cmake/toolchain/mingw-w64.cmake`:

```cmake
# cross compile
set(CMAKE_SYSTEM_NAME Windows)

set(MINGW_C_COMPILER_NAME "x86_64-w64-mingw32-gcc")
set(MINGW_CXX_COMPILER_NAME "x86_64-w64-mingw32-g++")
set(MINGW_WINDRES_COMPILER_NAME "x86_64-w64-mingw32-windres")

find_file(MINGW_C_COMPILER ${MINGW_C_COMPILER_NAME})
find_file(MINGW_CXX_COMPILER ${MINGW_CXX_COMPILER_NAME})
find_file(MINGW_WINDRES_COMPILER ${MINGW_WINDRES_COMPILER_NAME})

if (${MINGW_C_COMPILER} STREQUAL "MINGW_C_COMPILER-NOTFOUND")
    message(FATAL_ERROR "mingw-w64 compiler not found: ${MINGW_C_COMPILER_NAME}")
endif()
if (${MINGW_CXX_COMPILER} STREQUAL "MINGW_CXX_COMPILER-NOTFOUND")
    message(FATAL_ERROR "mingw-w64 compiler not found: ${MINGW_CXX_COMPILER_NAME}")
endif()
if (${MINGW_WINDRES_COMPILER} STREQUAL "MINGW_WINDRES_COMPILER-NOTFOUND")
    message(FATAL_ERROR "mingw-w64 compiler not found: ${MINGW_WINDRES_COMPILER_NAME}")
endif()

# this macro is needed when compile `libwindows-emulator.a`
add_compile_definitions(NTDDI_VERSION=NTDDI_WIN10_MN)

# set the compiler
set(CMAKE_C_COMPILER  ${MINGW_C_COMPILER})
set(CMAKE_CXX_COMPILER ${MINGW_CXX_COMPILER})
set(CMAKE_RC_COMPILER ${MINGW_WINDRES_COMPILER})

# set the compiler search path
set(CMAKE_FIND_ROOT_PATH /usr/x86_64-w64-mingw32)

# adjust the default behaviour of the FIND_XXX() commands:
# search headers and libraries in the target environment, search 
# programs in the host environment
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

```

`cmake/utils.cmake`:

```cmake
include_guard()

##########################################

set(PYTHON3_EXE "python3")
if(CMAKE_SYSTEM_NAME MATCHES "Windows")
  set(PYTHON3_EXE "python")
endif()

##########################################

function(momo_silence_deprecation_warnings)
    set(CMAKE_WARN_DEPRECATED_OLD ${CMAKE_WARN_DEPRECATED} PARENT_SCOPE)
    set(CMAKE_WARN_DEPRECATED OFF CACHE BOOL "" FORCE)
endfunction()

##########################################

function(momo_restore_deprecation_warnings)
    set(CMAKE_WARN_DEPRECATED ${CMAKE_WARN_DEPRECATED_OLD} CACHE BOOL "" FORCE)
endfunction()

##########################################

function(momo_target_exclude_from_all target)
  set_target_properties(${target} PROPERTIES EXCLUDE_FROM_ALL 1)
  #set_target_properties(${target} PROPERTIES EXCLUDE_FROM_DEFAULT_BUILD 1)
endfunction()

##########################################

function(momo_targets_exclude_from_all)
  foreach(target ${ARGV})
    momo_target_exclude_from_all(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_set_folder folder target)
  #get_target_property(CURRENT_FOLDER ${target} FOLDER)
  #if(NOT CURRENT_FOLDER)
    set_target_properties(${target} PROPERTIES FOLDER "${folder}")
  #endif()
endfunction()

##########################################

function(momo_targets_set_folder folder)
  foreach(target ${ARGN})
    momo_target_set_folder(${folder} ${target})
  endforeach()
endfunction()

##########################################

function(momo_target_disable_compile_commands target)
  set_target_properties(${target} PROPERTIES EXPORT_COMPILE_COMMANDS OFF)
endfunction()

##########################################

function(momo_targets_disable_compile_commands)
  foreach(target ${ARGV})
    momo_target_disable_compile_commands(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_expose_includes target)
  get_target_property(target_type ${target} TYPE)
  if("${target_type}" STREQUAL "UTILITY")
    return()
  endif()

  get_target_property(TARGET_SOURCE_DIR ${target} SOURCE_DIR)
  target_include_directories(${target} INTERFACE ${TARGET_SOURCE_DIR}/..)
endfunction()

##########################################

function(momo_targets_expose_includes)
  foreach(target ${ARGV})
  momo_target_expose_includes(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_compile_options language target mode)
  foreach(compile_option ${ARGN})
    target_compile_options(${target} ${mode}
      $<$<COMPILE_LANGUAGE:${language}>:${compile_option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_target_c_and_cxx_compile_options)
  momo_target_compile_options(C ${ARGV})
  momo_target_compile_options(CXX ${ARGV})
endfunction()

##########################################

macro(momo_target_remove_compile_option target option)
    get_target_property(target_flags ${target} COMPILE_OPTIONS)
    if(target_flags)
        list(REMOVE_ITEM target_flags ${option})
        list(REMOVE_ITEM target_flags "$<$<COMPILE_LANGUAGE:C>:${option}>")
        list(REMOVE_ITEM target_flags "$<$<COMPILE_LANGUAGE:CXX>:${option}>")
        set_target_properties(${target} PROPERTIES COMPILE_OPTIONS "${target_flags}")
    endif()

    get_target_property(target_interface_flags ${target} INTERFACE_COMPILE_OPTIONS)
    if(target_interface_flags)
        list(REMOVE_ITEM target_interface_flags ${option})
        list(REMOVE_ITEM target_interface_flags "$<$<COMPILE_LANGUAGE:C>:${option}>")
        list(REMOVE_ITEM target_interface_flags "$<$<COMPILE_LANGUAGE:CXX>:${option}>")
        set_target_properties(${target} PROPERTIES INTERFACE_COMPILE_OPTIONS "${target_interface_flags}")
    endif()
endmacro()

##########################################

macro(momo_target_remove_compile_options target)
  foreach(option ${ARGN})
    momo_target_remove_compile_option(${target} ${option})
  endforeach()
endmacro()

##########################################

function(momo_targets_remove_compile_options targets)
  foreach(target ${targets})
    momo_target_remove_compile_options(${target} ${ARGN})
  endforeach()
endfunction()

##########################################

function(momo_add_compile_options language)
  foreach(option ${ARGN})
    add_compile_options(
      $<$<COMPILE_LANGUAGE:${language}>:${option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_release_compile_options language)
  foreach(option ${ARGN})
    add_compile_options(
      $<$<COMPILE_LANGUAGE:${language}>:$<$<CONFIG:RELEASE>:${option}>>
      $<$<COMPILE_LANGUAGE:${language}>:$<$<CONFIG:RELWITHDEBINFO>:${option}>>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_release_link_options)
  foreach(option ${ARGN})
    add_link_options(
      $<$<CONFIG:RELEASE>:${option}>
      $<$<CONFIG:RELWITHDEBINFO>:${option}>
    )
  endforeach()
endfunction()

##########################################

function(momo_add_c_and_cxx_compile_options)
  momo_add_compile_options(C ${ARGV})
  momo_add_compile_options(CXX ${ARGV})
endfunction()

##########################################

function(momo_add_c_and_cxx_release_compile_options)
  momo_add_release_compile_options(C ${ARGV})
  momo_add_release_compile_options(CXX ${ARGV})
endfunction()

##########################################

function(momo_target_disable_warnings target)
  get_target_property(target_type ${target} TYPE)
  if(("${target_type}" STREQUAL "INTERFACE_LIBRARY") OR ("${target_type}" STREQUAL "UTILITY"))
    return()
  endif()

  momo_target_remove_compile_options(${target} /W3 -W3 /W4 -W4)

  if(MSVC)
  set(compile_options
    /W0
    /D_CRT_SECURE_NO_WARNINGS=1
  )
  endif()

  momo_target_c_and_cxx_compile_options(${target} PRIVATE ${compile_options})

  set_target_properties(${target} PROPERTIES MOMO_WARNINGS_DISABLE ON)
endfunction()

##########################################

function(momo_targets_disable_warnings)
  foreach(target ${ARGV})
    momo_target_disable_warnings(${target})
  endforeach()
endfunction()

##########################################

function(momo_target_set_warnings_as_errors target)
  get_target_property(target_type ${target} TYPE)
  if(("${target_type}" STREQUAL "INTERFACE_LIBRARY") OR ("${target_type}" STREQUAL "UTILITY"))
    return()
  endif()

  get_target_property(warnings_disabled ${target} MOMO_WARNINGS_DISABLE)
  if(warnings_disabled)
    return()
  endif()

  set(compile_options -Wall -Wextra
   #-Wconversion
   -pedantic -Werror -Wno-comment)

  if(MSVC)
    set(compile_options /W4 /WX)
  endif()

  target_compile_options(${target} PRIVATE
    $<$<COMPILE_LANGUAGE:C>:$<$<CONFIG:RELEASE>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:CXX>:$<$<CONFIG:RELEASE>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:C>:$<$<CONFIG:RELWITHDEBINFO>:${compile_options}>>
    $<$<COMPILE_LANGUAGE:CXX>:$<$<CONFIG:RELWITHDEBINFO>:${compile_options}>>
  )
endfunction()

##########################################

function(momo_targets_set_warnings_as_errors)
  foreach(target ${ARGV})
    momo_target_set_warnings_as_errors(${target})
  endforeach()
endfunction()

##########################################

function(momo_get_all_targets var)
    set(targets)
    momo_get_all_targets_recursive(targets ${CMAKE_CURRENT_SOURCE_DIR})
    set(${var} ${targets} PARENT_SCOPE)
endfunction()

##########################################

macro(momo_get_all_targets_recursive targets dir)
    get_property(subdirectories DIRECTORY ${dir} PROPERTY SUBDIRECTORIES)
    foreach(subdir ${subdirectories})
        momo_get_all_targets_recursive(${targets} ${subdir})
    endforeach()

    get_property(current_targets DIRECTORY ${dir} PROPERTY BUILDSYSTEM_TARGETS)
    list(APPEND ${targets} ${current_targets})
endmacro()

##########################################

macro(momo_list_difference list_a list_to_remove result)
  set(${result} ${list_a})
  list(REMOVE_ITEM ${result} ${list_to_remove})
endmacro()

##########################################

macro(momo_set_artifact_directory directory)
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${directory})
  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${directory})
endmacro()

##########################################

macro(momo_set_new_artifact_directory)
  get_property(IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
  if(IS_MULTI_CONFIG)
      set(ARTIFACT_FOLDER_NAME "artifacts-$<LOWER_CASE:$<CONFIG>>")
  else()
      set(ARTIFACT_FOLDER_NAME "artifacts")
  endif()

  set(ARTIFACT_DIRECTORY "${CMAKE_BINARY_DIR}/${ARTIFACT_FOLDER_NAME}")
  momo_set_artifact_directory(${ARTIFACT_DIRECTORY})
endmacro()

##########################################

macro(momo_add_subdirectory_and_get_targets directory targets)
  momo_get_all_targets(EXISTING_TARGETS)
  add_subdirectory(${directory})
  momo_get_all_targets(ALL_TARGETS)

  momo_list_difference("${ALL_TARGETS}" "${EXISTING_TARGETS}" ${targets})
endmacro()

##########################################

macro(momo_target_include_libraries target mode)
  foreach(inc_target ${ARGN})
    target_include_directories(${target} ${mode}
      $<TARGET_PROPERTY:${inc_target},INTERFACE_INCLUDE_DIRECTORIES>
      $<TARGET_PROPERTY:${inc_target},PUBLIC_INCLUDE_DIRECTORIES>
    )
  endforeach()
endmacro()

##########################################

function(momo_strip_target target)
  if (CMAKE_BUILD_TYPE STREQUAL "Debug" OR MOMO_ENABLE_SANITIZER)
    return()
  endif()

  if(MSVC OR MOMO_ENABLE_SANITIZER OR CMAKE_SYSTEM_NAME STREQUAL "iOS" OR CMAKE_SYSTEM_NAME STREQUAL "Android" OR CMAKE_SYSTEM_NAME MATCHES "Emscripten")
    return()
  endif()

  find_program(STRIP_COMMAND NAMES strip llvm-strip)
  if(NOT STRIP_COMMAND)
    message(WARNING "strip command not found, target ${target} will not be stripped.")
    return()
  endif()

  set(STRIP_FLAGS "-s")

  if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    set(STRIP_FLAGS "-x")
  endif()

  get_property(target_type TARGET ${target} PROPERTY TYPE)

  if(NOT (target_type STREQUAL "EXECUTABLE" OR target_type STREQUAL "SHARED_LIBRARY"))
    return()
  endif()

  set(TARGET_FILE "$<TARGET_FILE:${target}>")

  add_custom_command(TARGET ${target} POST_BUILD
    COMMAND "${STRIP_COMMAND}" ${STRIP_FLAGS} "${TARGET_FILE}"
    COMMAND_EXPAND_LISTS
    COMMENT "Stripping ${target}"
    VERBATIM
  )

  message(STATUS "Will strip ${target} using ${STRIP_COMMAND} ${STRIP_FLAGS}")
endfunction()

##########################################

macro(momo_assign_source_group)
  source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${ARGN})
endmacro()

##########################################

function(momo_target_enable_clang_tidy target)
  if(MOMO_ENABLE_CLANG_TIDY)
    set(CLANG_TIDY_COMMAND "clang-tidy;--use-color;--config-file=${CMAKE_CURRENT_SOURCE_DIR}/.clang-tidy")

    set_target_properties(${target} PROPERTIES C_CLANG_TIDY "${CLANG_TIDY_COMMAND}")
    set_target_properties(${target} PROPERTIES CXX_CLANG_TIDY "${CLANG_TIDY_COMMAND}")
  endif()
endfunction()

##########################################

function(momo_targets_enable_clang_tidy)
  foreach(target ${ARGV})
    momo_target_enable_clang_tidy(${target})
  endforeach()
endfunction()

```

`deps/CMakeLists.txt`:

```txt
set(UNICORN_ARCH "x86" CACHE STRING "")
add_subdirectory(unicorn)

##########################################

option(BASE64_ENABLE_TESTING "" OFF)
add_subdirectory(base64)

##########################################

option(FLATBUFFERS_BUILD_TESTS "" OFF)
option(FLATBUFFERS_INSTALL "" OFF)
add_subdirectory(flatbuffers)

if(MSVC)
target_compile_options(flatc PRIVATE /MD$<$<CONFIG:Debug>:d>)
endif()

##########################################

add_library(reflect INTERFACE)
target_include_directories(reflect INTERFACE
    "${CMAKE_CURRENT_LIST_DIR}/reflect"
)

##########################################

add_subdirectory(minidump_cpp)

##########################################


option(CAPSTONE_BUILD_MACOS_THIN "" ON)
option(CAPSTONE_X86_SUPPORT "" ON)
option(CAPSTONE_X86_ATT_DISABLE "" ON)
option(CAPSTONE_ARCHITECTURE_DEFAULT "" OFF)
option(CAPSTONE_BUILD_STATIC_MSVC_RUNTIME "" OFF)
add_subdirectory(capstone)

##########################################

include(googletest.cmake)
include(zstd.cmake)

```

`deps/googletest.cmake`:

```cmake
option(BUILD_GMOCK OFF)
option(INSTALL_GTEST OFF)

add_subdirectory(googletest)

```

`deps/zstd.cmake`:

```cmake
set(ZSTD_BUILD_STATIC ON)
set(ZSTD_BUILD_SHARED OFF)
set(ZSTD_BUILD_DICTBUILDER OFF)
set(ZSTD_BUILD_PROGRAMS OFF)
set(ZSTD_BUILD_CONTRIB OFF)
set(ZSTD_BUILD_TESTS OFF)

if(MINGW)
  set(ZSTD_MULTITHREAD_SUPPORT OFF)
endif()

add_compile_definitions(
    ZSTD_STRIP_ERROR_STRINGS
    ZSTD_NO_UNUSED_FUNCTIONS
)

set(CMAKE_POLICY_DEFAULT_CMP0077 NEW)

add_subdirectory(zstd/build/cmake zstd)

```

`page/components.json`:

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

```

`page/eslint.config.js`:

```js
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
    },
  },
);

```

`page/index.html`:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Maurice Heumann" />
    <link
      rel="icon"
      type="image/png"
      crossorigin="anonymous"
      href="./pinata.png"
    />

    <title>Sogen - Windows User Space Emulator</title>

    <meta name="color-scheme" content="dark" />

    <meta
      name="description"
      content="Sogen is a high-performance Windows user space emulator that can emulate windows processes. It is ideal for security-, DRM- or malware research."
      data-react-helmet="true"
    />
    <meta property="og:site_name" content="Sogen" data-react-helmet="true" />
    <meta property="og:title" content="Sogen" data-react-helmet="true" />
    <meta
      property="og:description"
      content="A high-performance Windows user space emulator."
      data-react-helmet="true"
    />
    <meta property="og:locale" content="en-us" data-react-helmet="true" />
    <meta property="og:type" content="website" data-react-helmet="true" />
    <meta
      name="og:image"
      content="https://momo5502.com/emulator/preview.png"
      data-react-helmet="true"
    />
    <meta
      name="twitter:card"
      content="summary_large_image"
      data-react-helmet="true"
    />
    <meta name="twitter:title" content="Sogen" data-react-helmet="true" />
    <meta
      name="twitter:description"
      content="A high-performance Windows user space emulator."
      data-react-helmet="true"
    />
    <meta
      name="twitter:image"
      content="https://momo5502.com/emulator/preview.png"
      data-react-helmet="true"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

`page/package-lock.json`:

```json
{
  "name": "sogen",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "sogen",
      "version": "1.0.0",
      "dependencies": {
        "@fontsource/inter": "^5.2.8",
        "@irori/idbfs": "^0.5.1",
        "@radix-ui/react-checkbox": "^1.3.3",
        "@radix-ui/react-context-menu": "^2.2.16",
        "@radix-ui/react-dialog": "^1.1.15",
        "@radix-ui/react-dropdown-menu": "^2.1.16",
        "@radix-ui/react-label": "^2.1.8",
        "@radix-ui/react-popover": "^1.1.15",
        "@radix-ui/react-radio-group": "^1.3.8",
        "@radix-ui/react-scroll-area": "^1.2.10",
        "@radix-ui/react-separator": "^1.1.8",
        "@radix-ui/react-slot": "^1.2.4",
        "@radix-ui/react-tabs": "^1.1.13",
        "@radix-ui/react-tooltip": "^1.2.8",
        "@tailwindcss/vite": "^4.1.18",
        "class-variance-authority": "^0.7.1",
        "clsx": "^2.1.1",
        "flatbuffers": "^25.9.23",
        "jszip": "^3.10.1",
        "lucide-react": "^0.563.0",
        "pe-library": "^2.0.1",
        "react": "^19.2.4",
        "react-bootstrap-icons": "^1.11.6",
        "react-dom": "^19.2.4",
        "react-dropzone": "^14.4.0",
        "react-helmet": "^6.1.0",
        "react-router-dom": "^7.13.0",
        "react-window": "^2.2.6",
        "shell-quote": "^1.8.3",
        "tailwind-merge": "^3.4.0",
        "tailwindcss": "^4.1.16",
        "tw-animate-css": "^1.4.0",
        "vaul": "^1.1.2",
        "wasm-feature-detect": "^1.8.0"
      },
      "devDependencies": {
        "@eslint/js": "^9.39.1",
        "@types/node": "^25.2.0",
        "@types/react": "^19.2.10",
        "@types/react-dom": "^19.2.3",
        "@types/react-helmet": "^6.1.11",
        "@types/shell-quote": "^1.7.5",
        "@vitejs/plugin-react": "^5.1.2",
        "eslint": "^9.39.2",
        "eslint-plugin-react-hooks": "^7.0.1",
        "eslint-plugin-react-refresh": "^0.5.0",
        "globals": "^17.3.0",
        "prettier": "3.8.1",
        "typescript": "~5.9.3",
        "typescript-eslint": "^8.54.0",
        "vite": "^7.3.1",
        "vite-plugin-pwa": "^1.2.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.5.tgz",
      "integrity": "sha512-6uFXyCayocRbqhZOB+6XcuZbkMNimwfVGFji8CTZnCzOHVGvDqzvitu1re2AU5LROliz7eQPhB8CpAMvnx9EjA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.5.tgz",
      "integrity": "sha512-e7jT4DxYvIDLk1ZHmU/m/mB19rex9sv0c2ftBtjSBv+kVM/902eh0fINUzD7UwLLNR+jU585GxUJ8/EBfAM5fw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.5",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.28.3",
        "@babel/helpers": "^7.28.4",
        "@babel/parser": "^7.28.5",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.5",
        "@babel/types": "^7.28.5",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.5.tgz",
      "integrity": "sha512-3EwLFhZ38J4VyIP6WNtt2kUdW9dokXA9Cr4IVIFHuCpZ3H8/YFOl5JjZHisrn1fATPBmKKqXzDFvh9fUwHz6CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.5",
        "@babel/types": "^7.28.5",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-annotate-as-pure": {
      "version": "7.27.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.27.3.tgz",
      "integrity": "sha512-fXSwMQqitTGeHLBC08Eq5yXz2m37E4pJX1qAU1+2cNedz/ifv/bVXft90VeSav5nFO61EcNgwr0aJxbyPaWBPg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.3"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-create-class-features-plugin": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.28.5.tgz",
      "integrity": "sha512-q3WC4JfdODypvxArsJQROfupPBq9+lMwjKq7C33GhbFYJsufD0yd/ziwD+hJucLeWsnFPWZjsU2DNFqBPE7jwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.3",
        "@babel/helper-member-expression-to-functions": "^7.28.5",
        "@babel/helper-optimise-call-expression": "^7.27.1",
        "@babel/helper-replace-supers": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
        "@babel/traverse": "^7.28.5",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-create-regexp-features-plugin": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.28.5.tgz",
      "integrity": "sha512-N1EhvLtHzOvj7QQOUCCS3NrPJP8c5W6ZXCHDn7Yialuy1iu4r5EmIYkXlKNqT99Ciw+W0mDqWoR6HWMZlFP3hw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.3",
        "regexpu-core": "^6.3.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-define-polyfill-provider": {
      "version": "0.6.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-define-polyfill-provider/-/helper-define-polyfill-provider-0.6.5.tgz",
      "integrity": "sha512-uJnGFcPsWQK8fvjgGP5LZUZZsYGIoPeRjSF5PGwrelYgq7Q15/Ft9NGFp1zglwgIv//W0uG4BevRuSJRyylZPg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-plugin-utils": "^7.27.1",
        "debug": "^4.4.1",
        "lodash.debounce": "^4.0.8",
        "resolve": "^1.22.10"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-member-expression-to-functions": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.28.5.tgz",
      "integrity": "sha512-cwM7SBRZcPCLgl8a7cY0soT1SptSzAlMH39vwiRpOQkJlh53r5hdHwLSCZpQdVLT39sZt+CRpNwYG4Y2v77atg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.28.5",
        "@babel/types": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.3.tgz",
      "integrity": "sha512-gytXUbs8k2sXS9PnQptz5o0QnpLL51SwASIORY6XaBKF88nsOT0Zw9szLqlSGQDP/4TljBAD5y98p2U1fqkdsw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-optimise-call-expression": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.27.1.tgz",
      "integrity": "sha512-URMGH08NzYFhubNSGJrpUEphGKQwMQYBySzat5cAByY1/YgIRkULnIy3tAMeszlL/so2HbeilYloUmSpd7GdVw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-remap-async-to-generator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.27.1.tgz",
      "integrity": "sha512-7fiA521aVw8lSPeI4ZOD3vRFkoqkJcS+z4hFo82bFSH/2tNd6eJ5qCVMS5OzDmZh/kaHQeBaeyxK6wljcPtveA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "@babel/helper-wrap-function": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-replace-supers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.27.1.tgz",
      "integrity": "sha512-7EHz6qDZc8RYS5ElPoShMheWvEgERonFCs7IAonWLLUTXW59DP14bCZt89/GKyreYn8g3S83m21FelHKbeDCKA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-member-expression-to-functions": "^7.27.1",
        "@babel/helper-optimise-call-expression": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-skip-transparent-expression-wrappers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-skip-transparent-expression-wrappers/-/helper-skip-transparent-expression-wrappers-7.27.1.tgz",
      "integrity": "sha512-Tub4ZKEXqbPjXgWLl2+3JpQAYBJ8+ikpQ2Ocj/q/r0LwE3UhENh7EUabyHjz2kCEsrRY83ew2DQdHluuiDQFzg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-wrap-function": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.28.3.tgz",
      "integrity": "sha512-zdf983tNfLZFletc0RRXYrHrucBEg95NIFMkn6K9dbeMYnsgHaSBGcQqdsCSStG2PYwRre0Qc2NNSCXbG+xc6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.3",
        "@babel/types": "^7.28.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.4.tgz",
      "integrity": "sha512-HFN59MmQXGHVyYadKLVumYsA9dBFun/ldYxipEjzA4196jpLZd8UjEEBLkbEkvfYreDqJhZxYAWFPtrfhNpj4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.4"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.5.tgz",
      "integrity": "sha512-KKBU1VGYR7ORr3At5HAtUQ+TV3SzRCXmA/8OdDZiLDBIZxVyzXuztPjfLd3BV1PRAQGCMWWSHYhL0F8d5uHBDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.5"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-firefox-class-in-computed-class-key": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-firefox-class-in-computed-class-key/-/plugin-bugfix-firefox-class-in-computed-class-key-7.28.5.tgz",
      "integrity": "sha512-87GDMS3tsmMSi/3bWOte1UblL+YUTFMV8SZPZ2eSEL17s74Cw/l63rR6NmGVKMYW2GYi85nE+/d6Hw5N0bEk2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-safari-class-field-initializer-scope": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-class-field-initializer-scope/-/plugin-bugfix-safari-class-field-initializer-scope-7.27.1.tgz",
      "integrity": "sha512-qNeq3bCKnGgLkEXUuFry6dPlGfCdQNZbn7yUAPCInwAJHMU7THJfrBSozkcWq5sNM6RcF3S8XyQL2A52KNR9IA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.27.1.tgz",
      "integrity": "sha512-g4L7OYun04N1WyqMNjldFwlfPCLVkgB54A/YCXICZYBsvJJE3kByKv9c9+R/nAfmIfjl2rKYLNyMHboYbZaWaA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/-/plugin-bugfix-v8-spread-parameters-in-optional-chaining-7.27.1.tgz",
      "integrity": "sha512-oO02gcONcD5O1iTLi/6frMJBIwWEHceWGSGqrpCmEL8nogiS6J9PBlE48CaK20/Jx1LuRml9aDftLgdjXT8+Cw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
        "@babel/plugin-transform-optional-chaining": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.13.0"
      }
    },
    "node_modules/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/-/plugin-bugfix-v8-static-class-fields-redefine-readonly-7.28.3.tgz",
      "integrity": "sha512-b6YTX108evsvE4YgWyQ921ZAFFQm3Bn+CA3+ZXlNVnPhx+UfsVURoPjfGAPCjBgrqo30yX/C2nZGX96DxvR9Iw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-proposal-private-property-in-object": {
      "version": "7.21.0-placeholder-for-preset-env.2",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-property-in-object/-/plugin-proposal-private-property-in-object-7.21.0-placeholder-for-preset-env.2.tgz",
      "integrity": "sha512-SOSkfJDddaM7mak6cPEpswyTRnuRltl429hMraQEglW+OkovnCzsiszTmsrlY//qLFjCpQDFRvjdm2wA5pPm9w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-assertions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-assertions/-/plugin-syntax-import-assertions-7.27.1.tgz",
      "integrity": "sha512-UT/Jrhw57xg4ILHLFnzFpPDlMbcdEicaAtjPQpbj9wa8T4r5KVWCimHcL/460g8Ht0DMxDyjsLgiWSkVjnwPFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-attributes": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.27.1.tgz",
      "integrity": "sha512-oFT0FrKHgF53f4vOsZGi2Hh3I35PfSmVs4IBFLFj4dnafP+hIWDLg3VyKmUHfLoLHlyxY4C7DGtmHuJgn+IGww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-unicode-sets-regex": {
      "version": "7.18.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-unicode-sets-regex/-/plugin-syntax-unicode-sets-regex-7.18.6.tgz",
      "integrity": "sha512-727YkEAPwSIQTv5im8QHz3upqp92JTWhidIC81Tdx4VJYIte/VndKf1qKrfnnhPLiPghStWfvC/iFaMCQu7Nqg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
        "@babel/helper-plugin-utils": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-arrow-functions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.27.1.tgz",
      "integrity": "sha512-8Z4TGic6xW70FKThA5HYEKKyBpOOsucTOD1DjU3fZxDg+K3zBJcXMFnt/4yQiZnf5+MiOMSXQ9PaEK/Ilh1DeA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-async-generator-functions": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-generator-functions/-/plugin-transform-async-generator-functions-7.28.0.tgz",
      "integrity": "sha512-BEOdvX4+M765icNPZeidyADIvQ1m1gmunXufXxvRESy/jNNyfovIqUyE7MVgGBjWktCoJlzvFA1To2O4ymIO3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-remap-async-to-generator": "^7.27.1",
        "@babel/traverse": "^7.28.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-async-to-generator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.27.1.tgz",
      "integrity": "sha512-NREkZsZVJS4xmTr8qzE5y8AfIPqsdQfRuUiLRTEzb7Qii8iFWCyDKaUV2c0rCuh4ljDZ98ALHP/PetiBV2nddA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-remap-async-to-generator": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-block-scoped-functions": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.27.1.tgz",
      "integrity": "sha512-cnqkuOtZLapWYZUYM5rVIdv1nXYuFVIltZ6ZJ7nIj585QsjKM5dhL2Fu/lICXZ1OyIAFc7Qy+bvDAtTXqGrlhg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-block-scoping": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.28.5.tgz",
      "integrity": "sha512-45DmULpySVvmq9Pj3X9B+62Xe+DJGov27QravQJU1LLcapR6/10i+gYVAucGGJpHBp5mYxIMK4nDAT/QDLr47g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-class-properties": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-properties/-/plugin-transform-class-properties-7.27.1.tgz",
      "integrity": "sha512-D0VcalChDMtuRvJIu3U/fwWjf8ZMykz5iZsg77Nuj821vCKI3zCyRLwRdWbsuJ/uRwZhZ002QtCqIkwC/ZkvbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-class-static-block": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-class-static-block/-/plugin-transform-class-static-block-7.28.3.tgz",
      "integrity": "sha512-LtPXlBbRoc4Njl/oh1CeD/3jC+atytbnf/UqLoqTDcEYGUPj022+rvfkbDYieUrSj3CaV4yHDByPE+T2HwfsJg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.28.3",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.12.0"
      }
    },
    "node_modules/@babel/plugin-transform-classes": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.28.4.tgz",
      "integrity": "sha512-cFOlhIYPBv/iBoc+KS3M6et2XPtbT2HiCRfBXWtfpc9OAyostldxIf9YAYB6ypURBBbx+Qv6nyrLzASfJe+hBA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.3",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-globals": "^7.28.0",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-replace-supers": "^7.27.1",
        "@babel/traverse": "^7.28.4"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-computed-properties": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.27.1.tgz",
      "integrity": "sha512-lj9PGWvMTVksbWiDT2tW68zGS/cyo4AkZ/QTp0sQT0mjPopCmrSkzxeXkznjqBxzDI6TclZhOJbBmbBLjuOZUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/template": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-destructuring": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.28.5.tgz",
      "integrity": "sha512-Kl9Bc6D0zTUcFUvkNuQh4eGXPKKNDOJQXVyyM4ZAQPMveniJdxi8XMJwLo+xSoW3MIq81bD33lcUe9kZpl0MCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-dotall-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.27.1.tgz",
      "integrity": "sha512-gEbkDVGRvjj7+T1ivxrfgygpT7GUd4vmODtYpbs0gZATdkX8/iSnOtZSxiZnsgm1YjTgjI6VKBGSJJevkrclzw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-duplicate-keys": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.27.1.tgz",
      "integrity": "sha512-MTyJk98sHvSs+cvZ4nOauwTTG1JeonDjSGvGGUNHreGQns+Mpt6WX/dVzWBHgg+dYZhkC4X+zTDfkTU+Vy9y7Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-duplicate-named-capturing-groups-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-named-capturing-groups-regex/-/plugin-transform-duplicate-named-capturing-groups-regex-7.27.1.tgz",
      "integrity": "sha512-hkGcueTEzuhB30B3eJCbCYeCaaEQOmQR0AdvzpD4LoN0GXMWzzGSuRrxR2xTnCrvNbVwK9N6/jQ92GSLfiZWoQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-dynamic-import": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dynamic-import/-/plugin-transform-dynamic-import-7.27.1.tgz",
      "integrity": "sha512-MHzkWQcEmjzzVW9j2q8LGjwGWpG2mjwaaB0BNQwst3FIjqsg8Ct/mIZlvSPJvfi9y2AC8mi/ktxbFVL9pZ1I4A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-explicit-resource-management": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-explicit-resource-management/-/plugin-transform-explicit-resource-management-7.28.0.tgz",
      "integrity": "sha512-K8nhUcn3f6iB+P3gwCv/no7OdzOZQcKchW6N389V6PD8NUWKZHzndOd9sPDVbMoBsbmjMqlB4L9fm+fEFNVlwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/plugin-transform-destructuring": "^7.28.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-exponentiation-operator": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.28.5.tgz",
      "integrity": "sha512-D4WIMaFtwa2NizOp+dnoFjRez/ClKiC2BqqImwKd1X28nqBtZEyCYJ2ozQrrzlxAFrcrjxo39S6khe9RNDlGzw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-export-namespace-from": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-export-namespace-from/-/plugin-transform-export-namespace-from-7.27.1.tgz",
      "integrity": "sha512-tQvHWSZ3/jH2xuq/vZDy0jNn+ZdXJeM8gHvX4lnJmsc3+50yPlWdZXIc5ay+umX+2/tJIqHqiEqcJvxlmIvRvQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-for-of": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.27.1.tgz",
      "integrity": "sha512-BfbWFFEJFQzLCQ5N8VocnCtA8J1CLkNTe2Ms2wocj75dd6VpiqS5Z5quTYcUoo4Yq+DN0rtikODccuv7RU81sw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-function-name": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.27.1.tgz",
      "integrity": "sha512-1bQeydJF9Nr1eBCMMbC+hdwmRlsv5XYOMu03YSWFwNs0HsAmtSxxF1fyuYPqemVldVyFmlCU7w8UE14LupUSZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-compilation-targets": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-json-strings": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-json-strings/-/plugin-transform-json-strings-7.27.1.tgz",
      "integrity": "sha512-6WVLVJiTjqcQauBhn1LkICsR2H+zm62I3h9faTDKt1qP4jn2o72tSvqMwtGFKGTpojce0gJs+76eZ2uCHRZh0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.27.1.tgz",
      "integrity": "sha512-0HCFSepIpLTkLcsi86GG3mTUzxV5jpmbv97hTETW3yzrAij8aqlD36toB1D0daVFJM8NK6GvKO0gslVQmm+zZA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-logical-assignment-operators": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-logical-assignment-operators/-/plugin-transform-logical-assignment-operators-7.28.5.tgz",
      "integrity": "sha512-axUuqnUTBuXyHGcJEVVh9pORaN6wC5bYfE7FGzPiaWa3syib9m7g+/IT/4VgCOe2Upef43PHzeAvcrVek6QuuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-member-expression-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.27.1.tgz",
      "integrity": "sha512-hqoBX4dcZ1I33jCSWcXrP+1Ku7kdqXf1oeah7ooKOIiAdKQ+uqftgCFNOSzA5AMS2XIHEYeGFg4cKRCdpxzVOQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-amd": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.27.1.tgz",
      "integrity": "sha512-iCsytMg/N9/oFq6n+gFTvUYDZQOMK5kEdeYxmxt91fcJGycfxVP9CnrxoliM0oumFERba2i8ZtwRUCMhvP1LnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-commonjs": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-commonjs/-/plugin-transform-modules-commonjs-7.27.1.tgz",
      "integrity": "sha512-OJguuwlTYlN0gBZFRPqwOGNWssZjfIUdS7HMYtN8c1KmwpwHFBwTeFZrg9XZa+DFTitWOW5iTAG7tyCUPsCCyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-systemjs": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.28.5.tgz",
      "integrity": "sha512-vn5Jma98LCOeBy/KpeQhXcV2WZgaRUtjwQmjoBuLNlOmkg0fB5pdvYVeWRYI69wWKwK2cD1QbMiUQnoujWvrew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.28.3",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5",
        "@babel/traverse": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-modules-umd": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.27.1.tgz",
      "integrity": "sha512-iQBE/xC5BV1OxJbp6WG7jq9IWiD+xxlZhLrdwpPkTX3ydmXdvoCpyfJN7acaIBZaOqTfr76pgzqBJflNbeRK+w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-named-capturing-groups-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.27.1.tgz",
      "integrity": "sha512-SstR5JYy8ddZvD6MhV0tM/j16Qds4mIpJTOd1Yu9J9pJjH93bxHECF7pgtc28XvkzTD6Pxcm/0Z73Hvk7kb3Ng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-new-target": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.27.1.tgz",
      "integrity": "sha512-f6PiYeqXQ05lYq3TIfIDu/MtliKUbNwkGApPUvyo6+tc7uaR4cPjPe7DFPr15Uyycg2lZU6btZ575CuQoYh7MQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-nullish-coalescing-operator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-nullish-coalescing-operator/-/plugin-transform-nullish-coalescing-operator-7.27.1.tgz",
      "integrity": "sha512-aGZh6xMo6q9vq1JGcw58lZ1Z0+i0xB2x0XaauNIUXd6O1xXc3RwoWEBlsTQrY4KQ9Jf0s5rgD6SiNkaUdJegTA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-numeric-separator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-numeric-separator/-/plugin-transform-numeric-separator-7.27.1.tgz",
      "integrity": "sha512-fdPKAcujuvEChxDBJ5c+0BTaS6revLV7CJL08e4m3de8qJfNIuCc2nc7XJYOjBoTMJeqSmwXJ0ypE14RCjLwaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-object-rest-spread": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-rest-spread/-/plugin-transform-object-rest-spread-7.28.4.tgz",
      "integrity": "sha512-373KA2HQzKhQCYiRVIRr+3MjpCObqzDlyrM6u4I201wL8Mp2wHf7uB8GhDwis03k2ti8Zr65Zyyqs1xOxUF/Ew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/plugin-transform-destructuring": "^7.28.0",
        "@babel/plugin-transform-parameters": "^7.27.7",
        "@babel/traverse": "^7.28.4"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-object-super": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.27.1.tgz",
      "integrity": "sha512-SFy8S9plRPbIcxlJ8A6mT/CxFdJx/c04JEctz4jf8YZaVS2px34j7NXRrlGlHkN/M2gnpL37ZpGRGVFLd3l8Ng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-replace-supers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-optional-catch-binding": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-catch-binding/-/plugin-transform-optional-catch-binding-7.27.1.tgz",
      "integrity": "sha512-txEAEKzYrHEX4xSZN4kJ+OfKXFVSWKB2ZxM9dpcE3wT7smwkNmXo5ORRlVzMVdJbD+Q8ILTgSD7959uj+3Dm3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-optional-chaining": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-optional-chaining/-/plugin-transform-optional-chaining-7.28.5.tgz",
      "integrity": "sha512-N6fut9IZlPnjPwgiQkXNhb+cT8wQKFlJNqcZkWlcTqkcqx6/kU4ynGmLFoa4LViBSirn05YAwk+sQBbPfxtYzQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-parameters": {
      "version": "7.27.7",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.27.7.tgz",
      "integrity": "sha512-qBkYTYCb76RRxUM6CcZA5KRu8K4SM8ajzVeUgVdMVO9NN9uI/GaVmBg/WKJJGnNokV9SY8FxNOVWGXzqzUidBg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-private-methods": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-methods/-/plugin-transform-private-methods-7.27.1.tgz",
      "integrity": "sha512-10FVt+X55AjRAYI9BrdISN9/AQWHqldOeZDUoLyif1Kn05a56xVBXb8ZouL8pZ9jem8QpXaOt8TS7RHUIS+GPA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-private-property-in-object": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-private-property-in-object/-/plugin-transform-private-property-in-object-7.27.1.tgz",
      "integrity": "sha512-5J+IhqTi1XPa0DXF83jYOaARrX+41gOewWbkPyjMNRDqgOCqdffGh8L3f/Ek5utaEBZExjSAzcyjmV9SSAWObQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.27.1",
        "@babel/helper-create-class-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-property-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.27.1.tgz",
      "integrity": "sha512-oThy3BCuCha8kDZ8ZkgOg2exvPYUlprMukKQXI1r1pJ47NCvxfkEy8vK+r/hT9nF0Aa4H1WUPZZjHTFtAhGfmQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-regenerator": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.28.4.tgz",
      "integrity": "sha512-+ZEdQlBoRg9m2NnzvEeLgtvBMO4tkFBw5SQIUgLICgTrumLoU7lr+Oghi6km2PFj+dbUt2u1oby2w3BDO9YQnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-regexp-modifiers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regexp-modifiers/-/plugin-transform-regexp-modifiers-7.27.1.tgz",
      "integrity": "sha512-TtEciroaiODtXvLZv4rmfMhkCv8jx3wgKpL68PuiPh2M4fvz5jhsA7697N1gMvkvr/JTF13DrFYyEbY9U7cVPA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-reserved-words": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.27.1.tgz",
      "integrity": "sha512-V2ABPHIJX4kC7HegLkYoDpfg9PVmuWy/i6vUM5eGK22bx4YVFD3M5F0QQnWQoDs6AGsUWTVOopBiMFQgHaSkVw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-shorthand-properties": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.27.1.tgz",
      "integrity": "sha512-N/wH1vcn4oYawbJ13Y/FxcQrWk63jhfNa7jef0ih7PHSIHX2LB7GWE1rkPrOnka9kwMxb6hMl19p7lidA+EHmQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-spread": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.27.1.tgz",
      "integrity": "sha512-kpb3HUqaILBJcRFVhFUs6Trdd4mkrzcGXss+6/mxUd273PfbWqSDHRzMT2234gIg2QYfAjvXLSquP1xECSg09Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-sticky-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.27.1.tgz",
      "integrity": "sha512-lhInBO5bi/Kowe2/aLdBAawijx+q1pQzicSgnkB6dUPc1+RC8QmJHKf2OjvU+NZWitguJHEaEmbV6VWEouT58g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-template-literals": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.27.1.tgz",
      "integrity": "sha512-fBJKiV7F2DxZUkg5EtHKXQdbsbURW3DZKQUWphDum0uRP6eHGGa/He9mc0mypL680pb+e/lDIthRohlv8NCHkg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-typeof-symbol": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.27.1.tgz",
      "integrity": "sha512-RiSILC+nRJM7FY5srIyc4/fGIwUhyDuuBSdWn4y6yT6gm652DpCHZjIipgn6B7MQ1ITOUnAKWixEUjQRIBIcLw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-escapes": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.27.1.tgz",
      "integrity": "sha512-Ysg4v6AmF26k9vpfFuTZg8HRfVWzsh1kVfowA23y9j/Gu6dOuahdUVhkLqpObp3JIv27MLSii6noRnuKN8H0Mg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-property-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-property-regex/-/plugin-transform-unicode-property-regex-7.27.1.tgz",
      "integrity": "sha512-uW20S39PnaTImxp39O5qFlHLS9LJEmANjMG7SxIhap8rCHqu0Ik+tLEPX5DKmHn6CsWQ7j3lix2tFOa5YtL12Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.27.1.tgz",
      "integrity": "sha512-xvINq24TRojDuyt6JGtHmkVkrfVV3FPT16uytxImLeBZqW3/H52yN+kM1MGuyPkIQxrzKwPHs5U/MP3qKyzkGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-unicode-sets-regex": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-sets-regex/-/plugin-transform-unicode-sets-regex-7.27.1.tgz",
      "integrity": "sha512-EtkOujbc4cgvb0mlpQefi4NTPBzhSIevblFevACNLUspmrALgmEBdL/XfnyyITfd8fKBZrZys92zOWcik7j9Tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-regexp-features-plugin": "^7.27.1",
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/preset-env": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.28.5.tgz",
      "integrity": "sha512-S36mOoi1Sb6Fz98fBfE+UZSpYw5mJm0NUHtIKrOuNcqeFauy1J6dIvXm2KRVKobOSaGq4t/hBXdN4HGU3wL9Wg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.5",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-option": "^7.27.1",
        "@babel/plugin-bugfix-firefox-class-in-computed-class-key": "^7.28.5",
        "@babel/plugin-bugfix-safari-class-field-initializer-scope": "^7.27.1",
        "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.27.1",
        "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.27.1",
        "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly": "^7.28.3",
        "@babel/plugin-proposal-private-property-in-object": "7.21.0-placeholder-for-preset-env.2",
        "@babel/plugin-syntax-import-assertions": "^7.27.1",
        "@babel/plugin-syntax-import-attributes": "^7.27.1",
        "@babel/plugin-syntax-unicode-sets-regex": "^7.18.6",
        "@babel/plugin-transform-arrow-functions": "^7.27.1",
        "@babel/plugin-transform-async-generator-functions": "^7.28.0",
        "@babel/plugin-transform-async-to-generator": "^7.27.1",
        "@babel/plugin-transform-block-scoped-functions": "^7.27.1",
        "@babel/plugin-transform-block-scoping": "^7.28.5",
        "@babel/plugin-transform-class-properties": "^7.27.1",
        "@babel/plugin-transform-class-static-block": "^7.28.3",
        "@babel/plugin-transform-classes": "^7.28.4",
        "@babel/plugin-transform-computed-properties": "^7.27.1",
        "@babel/plugin-transform-destructuring": "^7.28.5",
        "@babel/plugin-transform-dotall-regex": "^7.27.1",
        "@babel/plugin-transform-duplicate-keys": "^7.27.1",
        "@babel/plugin-transform-duplicate-named-capturing-groups-regex": "^7.27.1",
        "@babel/plugin-transform-dynamic-import": "^7.27.1",
        "@babel/plugin-transform-explicit-resource-management": "^7.28.0",
        "@babel/plugin-transform-exponentiation-operator": "^7.28.5",
        "@babel/plugin-transform-export-namespace-from": "^7.27.1",
        "@babel/plugin-transform-for-of": "^7.27.1",
        "@babel/plugin-transform-function-name": "^7.27.1",
        "@babel/plugin-transform-json-strings": "^7.27.1",
        "@babel/plugin-transform-literals": "^7.27.1",
        "@babel/plugin-transform-logical-assignment-operators": "^7.28.5",
        "@babel/plugin-transform-member-expression-literals": "^7.27.1",
        "@babel/plugin-transform-modules-amd": "^7.27.1",
        "@babel/plugin-transform-modules-commonjs": "^7.27.1",
        "@babel/plugin-transform-modules-systemjs": "^7.28.5",
        "@babel/plugin-transform-modules-umd": "^7.27.1",
        "@babel/plugin-transform-named-capturing-groups-regex": "^7.27.1",
        "@babel/plugin-transform-new-target": "^7.27.1",
        "@babel/plugin-transform-nullish-coalescing-operator": "^7.27.1",
        "@babel/plugin-transform-numeric-separator": "^7.27.1",
        "@babel/plugin-transform-object-rest-spread": "^7.28.4",
        "@babel/plugin-transform-object-super": "^7.27.1",
        "@babel/plugin-transform-optional-catch-binding": "^7.27.1",
        "@babel/plugin-transform-optional-chaining": "^7.28.5",
        "@babel/plugin-transform-parameters": "^7.27.7",
        "@babel/plugin-transform-private-methods": "^7.27.1",
        "@babel/plugin-transform-private-property-in-object": "^7.27.1",
        "@babel/plugin-transform-property-literals": "^7.27.1",
        "@babel/plugin-transform-regenerator": "^7.28.4",
        "@babel/plugin-transform-regexp-modifiers": "^7.27.1",
        "@babel/plugin-transform-reserved-words": "^7.27.1",
        "@babel/plugin-transform-shorthand-properties": "^7.27.1",
        "@babel/plugin-transform-spread": "^7.27.1",
        "@babel/plugin-transform-sticky-regex": "^7.27.1",
        "@babel/plugin-transform-template-literals": "^7.27.1",
        "@babel/plugin-transform-typeof-symbol": "^7.27.1",
        "@babel/plugin-transform-unicode-escapes": "^7.27.1",
        "@babel/plugin-transform-unicode-property-regex": "^7.27.1",
        "@babel/plugin-transform-unicode-regex": "^7.27.1",
        "@babel/plugin-transform-unicode-sets-regex": "^7.27.1",
        "@babel/preset-modules": "0.1.6-no-external-plugins",
        "babel-plugin-polyfill-corejs2": "^0.4.14",
        "babel-plugin-polyfill-corejs3": "^0.13.0",
        "babel-plugin-polyfill-regenerator": "^0.6.5",
        "core-js-compat": "^3.43.0",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/preset-modules": {
      "version": "0.1.6-no-external-plugins",
      "resolved": "https://registry.npmjs.org/@babel/preset-modules/-/preset-modules-0.1.6-no-external-plugins.tgz",
      "integrity": "sha512-HrcgcIESLm9aIR842yhJ5RWan/gebQUJ6E/E5+rf0y9o6oj7w0Br+sWuL6kEQ/o/AdfvR1Je9jG18/gnpwjEyA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.0.0",
        "@babel/types": "^7.4.4",
        "esutils": "^2.0.2"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.4.tgz",
      "integrity": "sha512-Q/N6JNWvIvPnLDvjlE1OUBLPQHH6l3CltCEsHIujp45zQUSSh8K+gHnaEX45yAT1nyngnINhvWtzN+Nb9D8RAQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.5.tgz",
      "integrity": "sha512-TCCj4t55U90khlYkVV/0TfkJkAkUg3jZFA3Neb7unZT8CPok7iiRfaX0F+WnqWqt7OxhOn0uBKXCw4lbL8W0aQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.5",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.5",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.5",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.5.tgz",
      "integrity": "sha512-qQ5m48eI/MFLQ5PxQj4PFaprjyCTLI37ElWMmNs0K8Lk3dVeOdNpB3ks8jc7yM5CDmVC73eMVk/trk3fgmrUpA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.27.2.tgz",
      "integrity": "sha512-GZMB+a0mOMZs4MpDbj8RJp4cw+w1WV5NYD6xzgvzUJ5Ek2jerwfO2eADyI6ExDSUED+1X8aMbegahsJi+8mgpw==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.27.2.tgz",
      "integrity": "sha512-DVNI8jlPa7Ujbr1yjU2PfUSRtAUZPG9I1RwW4F4xFB1Imiu2on0ADiI/c3td+KmDtVKNbi+nffGDQMfcIMkwIA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.27.2.tgz",
      "integrity": "sha512-pvz8ZZ7ot/RBphf8fv60ljmaoydPU12VuXHImtAs0XhLLw+EXBi2BLe3OYSBslR4rryHvweW5gmkKFwTiFy6KA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.27.2.tgz",
      "integrity": "sha512-z8Ank4Byh4TJJOh4wpz8g2vDy75zFL0TlZlkUkEwYXuPSgX8yzep596n6mT7905kA9uHZsf/o2OJZubl2l3M7A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.27.2.tgz",
      "integrity": "sha512-davCD2Zc80nzDVRwXTcQP/28fiJbcOwvdolL0sOiOsbwBa72kegmVU0Wrh1MYrbuCL98Omp5dVhQFWRKR2ZAlg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.27.2.tgz",
      "integrity": "sha512-ZxtijOmlQCBWGwbVmwOF/UCzuGIbUkqB1faQRf5akQmxRJ1ujusWsb3CVfk/9iZKr2L5SMU5wPBi1UWbvL+VQA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.27.2.tgz",
      "integrity": "sha512-lS/9CN+rgqQ9czogxlMcBMGd+l8Q3Nj1MFQwBZJyoEKI50XGxwuzznYdwcav6lpOGv5BqaZXqvBSiB/kJ5op+g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.27.2.tgz",
      "integrity": "sha512-tAfqtNYb4YgPnJlEFu4c212HYjQWSO/w/h/lQaBK7RbwGIkBOuNKQI9tqWzx7Wtp7bTPaGC6MJvWI608P3wXYA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.27.2.tgz",
      "integrity": "sha512-vWfq4GaIMP9AIe4yj1ZUW18RDhx6EPQKjwe7n8BbIecFtCQG4CfHGaHuh7fdfq+y3LIA2vGS/o9ZBGVxIDi9hw==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.27.2.tgz",
      "integrity": "sha512-hYxN8pr66NsCCiRFkHUAsxylNOcAQaxSSkHMMjcpx0si13t1LHFphxJZUiGwojB1a/Hd5OiPIqDdXONia6bhTw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.27.2.tgz",
      "integrity": "sha512-MJt5BRRSScPDwG2hLelYhAAKh9imjHK5+NE/tvnRLbIqUWa+0E9N4WNMjmp/kXXPHZGqPLxggwVhz7QP8CTR8w==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.27.2.tgz",
      "integrity": "sha512-lugyF1atnAT463aO6KPshVCJK5NgRnU4yb3FUumyVz+cGvZbontBgzeGFO1nF+dPueHD367a2ZXe1NtUkAjOtg==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.27.2.tgz",
      "integrity": "sha512-nlP2I6ArEBewvJ2gjrrkESEZkB5mIoaTswuqNFRv/WYd+ATtUpe9Y09RnJvgvdag7he0OWgEZWhviS1OTOKixw==",
      "cpu": [
        "mips64el"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.27.2.tgz",
      "integrity": "sha512-C92gnpey7tUQONqg1n6dKVbx3vphKtTHJaNG2Ok9lGwbZil6DrfyecMsp9CrmXGQJmZ7iiVXvvZH6Ml5hL6XdQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.27.2.tgz",
      "integrity": "sha512-B5BOmojNtUyN8AXlK0QJyvjEZkWwy/FKvakkTDCziX95AowLZKR6aCDhG7LeF7uMCXEJqwa8Bejz5LTPYm8AvA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.27.2.tgz",
      "integrity": "sha512-p4bm9+wsPwup5Z8f4EpfN63qNagQ47Ua2znaqGH6bqLlmJ4bx97Y9JdqxgGZ6Y8xVTixUnEkoKSHcpRlDnNr5w==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.27.2.tgz",
      "integrity": "sha512-uwp2Tip5aPmH+NRUwTcfLb+W32WXjpFejTIOWZFw/v7/KnpCDKG66u4DLcurQpiYTiYwQ9B7KOeMJvLCu/OvbA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.27.2.tgz",
      "integrity": "sha512-Kj6DiBlwXrPsCRDeRvGAUb/LNrBASrfqAIok+xB0LxK8CHqxZ037viF13ugfsIpePH93mX7xfJp97cyDuTZ3cw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.27.2.tgz",
      "integrity": "sha512-HwGDZ0VLVBY3Y+Nw0JexZy9o/nUAWq9MlV7cahpaXKW6TOzfVno3y3/M8Ga8u8Yr7GldLOov27xiCnqRZf0tCA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.27.2.tgz",
      "integrity": "sha512-DNIHH2BPQ5551A7oSHD0CKbwIA/Ox7+78/AWkbS5QoRzaqlev2uFayfSxq68EkonB+IKjiuxBFoV8ESJy8bOHA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.27.2.tgz",
      "integrity": "sha512-/it7w9Nb7+0KFIzjalNJVR5bOzA9Vay+yIPLVHfIQYG/j+j9VTH84aNB8ExGKPU4AzfaEvN9/V4HV+F+vo8OEg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.27.2.tgz",
      "integrity": "sha512-LRBbCmiU51IXfeXk59csuX/aSaToeG7w48nMwA6049Y4J4+VbWALAuXcs+qcD04rHDuSCSRKdmY63sruDS5qag==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.27.2.tgz",
      "integrity": "sha512-kMtx1yqJHTmqaqHPAzKCAkDaKsffmXkPHThSfRwZGyuqyIeBvf08KSsYXl+abf5HDAPMJIPnbBfXvP2ZC2TfHg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.27.2.tgz",
      "integrity": "sha512-Yaf78O/B3Kkh+nKABUF++bvJv5Ijoy9AN1ww904rOXZFLWVc5OLOfL56W+C8F9xn5JQZa3UX6m+IktJnIb1Jjg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.27.2.tgz",
      "integrity": "sha512-Iuws0kxo4yusk7sw70Xa2E2imZU5HoixzxfGCdxwBdhiDgt9vX9VUCBhqcwY7/uh//78A1hMkkROMJq9l27oLQ==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.27.2.tgz",
      "integrity": "sha512-sRdU18mcKf7F+YgheI/zGf5alZatMUTKj/jNS6l744f9u3WFu4v7twcUI9vu4mknF4Y9aDlblIie0IM+5xxaqQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.1.tgz",
      "integrity": "sha512-gtF186CXhIl1p4pJNGZw8Yc6RlshoePRvE0X91oPGb3vZ8pM3qOS9W9NGPat9LziaBV7XrJWGylNQXkGcnM3IQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.2.tgz",
      "integrity": "sha512-q1mjIoW1VX4IvSocvM/vbTiveKC4k9eLrajNEuSsmjymSDEbpGddtpfOoN7YGAqBK3NG+uqo8ia4PDTt8buCYA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.6.9",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.6.9.tgz",
      "integrity": "sha512-uMXCuQ3BItDUbAMhIXw7UPXRfAlOAvZzdK9BWpE60MCn+Svt3aLn9jsPTi/WNGlRUu2uI0v5S7JiIUsbsvh3fw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.9"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.6.13",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.6.13.tgz",
      "integrity": "sha512-umqzocjDgNRGTuO7Q8CU32dkHkECqI8ZdMZ5Swb6QAM0t5rnlrN3lGo1hdpscRd3WS8T6DKYK4ephgIH9iRh3w==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.6.0",
        "@floating-ui/utils": "^0.2.9"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.2.tgz",
      "integrity": "sha512-06okr5cgPzMNBy+Ycse2A6udMi4bqwW/zgBF/rwjcNqWkyr82Mcg8b0vjX8OJpZFy/FKjJmw6wV7t44kK6kW7A==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.9",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.9.tgz",
      "integrity": "sha512-MDWhGtE+eHw5JW7lq4qhc5yRLS11ERl1c7Z6Xd0a58DozHES6EnNNwUWbMiG4J9Cgj053Bhk8zvlhFYKVhULwg==",
      "license": "MIT"
    },
    "node_modules/@fontsource/inter": {
      "version": "5.2.8",
      "resolved": "https://registry.npmjs.org/@fontsource/inter/-/inter-5.2.8.tgz",
      "integrity": "sha512-P6r5WnJoKiNVV+zvW2xM13gNdFhAEpQ9dQJHt3naLvfg+LkF2ldgSLiF4T41lf1SQCM9QmkqPTn4TH568IRagg==",
      "license": "OFL-1.1",
      "funding": {
        "url": "https://github.com/sponsors/ayuhito"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.6",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.6.tgz",
      "integrity": "sha512-YuI2ZHQL78Q5HbhDiBA1X4LmYdXCKCMQIfw0pw7piHJwyREFebJUvrQN4cMssyES6x+vfUbx1CIpaQUKYdQZOw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.3.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node/node_modules/@humanwhocodes/retry": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.3.1.tgz",
      "integrity": "sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.2.tgz",
      "integrity": "sha512-xeO57FpIu4p1Ri3Jq/EXq4ClRm86dVF2z/+kvFnyqVYRavTZmaFaUBbWCOuuTh0o/g7DSsk6kc2vrS4Vl5oPOQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@irori/idbfs": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/@irori/idbfs/-/idbfs-0.5.1.tgz",
      "integrity": "sha512-Kvf0Zs6mpP2XZbjSm/Btcmg8X8WFrjlU73Qqk3t/tddZZJ9/2rTSKi2GBNglNe1aF7DnjzL2gWugJTiz2lRUeA==",
      "license": "Unlicense"
    },
    "node_modules/@isaacs/balanced-match": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/@isaacs/balanced-match/-/balanced-match-4.0.1.tgz",
      "integrity": "sha512-yzMTt9lEb8Gv7zRioUilSglI0c0smZ9k5D65677DLWLtWJaXIS3CqcGyUFByYKlnUj6TkjLVs54fBl6+TiGQDQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@isaacs/brace-expansion": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/@isaacs/brace-expansion/-/brace-expansion-5.0.0.tgz",
      "integrity": "sha512-ZT55BDLV0yv0RBm2czMiZ+SqCGO7AvmOM3G/w2xhVPH+te0aKgFjmBvGlL1dH+ql2tgGO3MVrbb3jCKyvpgnxA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@isaacs/balanced-match": "^4.0.1"
      },
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@isaacs/cliui": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^5.1.2",
        "string-width-cjs": "npm:string-width@^4.2.0",
        "strip-ansi": "^7.0.1",
        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
        "wrap-ansi": "^8.1.0",
        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.12",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.12.tgz",
      "integrity": "sha512-OuLGC46TjB5BbN1dH8JULVVZY4WTdkF7tV9Ys6wLL1rubZnCMstOhNHueU5bLCrnRuDhKPDM4g6sw4Bel5Gzqg==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/source-map": {
      "version": "0.3.11",
      "resolved": "https://registry.npmjs.org/@jridgewell/source-map/-/source-map-0.3.11.tgz",
      "integrity": "sha512-ZMp1V8ZFcPG5dIWnQLr3NSI1MiCU7UETdS/A0G8V/XWHvJv3ZsFqutJn1Y5RPmAPX6F3BiE397OqveU/9NCuIA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.25"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.29",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.29.tgz",
      "integrity": "sha512-uw6guiW/gcAGPDhLmd77/6lW8QLeiV5RUTsAX46Db6oLhGaVj4lhnPwb184s1bkc8kdVg/+h988dro8GRDpmYQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@radix-ui/number": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/number/-/number-1.1.1.tgz",
      "integrity": "sha512-MkKCwxlXTgz6CFoJx3pCwn07GKp36+aZyu/u2Ln2VrA5DcdyCZkASEDBTd8x5whTQQL5CiYf4prXKLcgQdv29g==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/primitive": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/primitive/-/primitive-1.1.3.tgz",
      "integrity": "sha512-JTF99U/6XIjCBo0wqkU5sK10glYe27MRRsfwoiq5zzOEZLHU3A3KCMa5X/azekYRCJ0HlwI0crAXS/5dEHTzDg==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/react-arrow": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-arrow/-/react-arrow-1.1.7.tgz",
      "integrity": "sha512-F+M1tLhO+mlQaOWspE8Wstg+z6PwxwRd8oQ8IXceWz92kfAmalTRf0EjrouQeo7QssEPfCn05B4Ihs1K9WQ/7w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-checkbox": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-checkbox/-/react-checkbox-1.3.3.tgz",
      "integrity": "sha512-wBbpv+NQftHDdG86Qc0pIyXk5IR3tM8Vd0nWLKDcX8nNn4nXFOFwsKuqw2okA/1D/mpaAkmuyndrPJTYDNZtFw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-collection/-/react-collection-1.1.7.tgz",
      "integrity": "sha512-Fh9rGN0MoI4ZFUNyfFVNU4y9LUz93u9/0K+yLgA2bwRojxM8JU1DyvvMBabnZPBgMWREAJvU2jjVzq+LrFUglw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-compose-refs": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-compose-refs/-/react-compose-refs-1.1.2.tgz",
      "integrity": "sha512-z4eqJvfiNnFMHIIvXP3CY57y2WJs5g2v3X0zm9mEJkrkNv4rDxu+sg9Jh8EkXyeqBkB7SOcboo9dMVqhyrACIg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-context/-/react-context-1.1.2.tgz",
      "integrity": "sha512-jCi/QKUM2r1Ju5a3J64TH2A5SpKAgh0LpknyqdQ4m6DCV0xJ2HG1xARRwNGPQfi1SLdLWZ1OJz6F4OMBBNiGJA==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context-menu": {
      "version": "2.2.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-context-menu/-/react-context-menu-2.2.16.tgz",
      "integrity": "sha512-O8morBEW+HsVG28gYDZPTrT9UUovQUlJue5YO836tiTJhuIWBm/zQHc7j388sHWtdH/xUZurK9olD2+pcqx5ww==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-menu": "2.1.16",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context-menu/node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context-menu/node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.3.tgz",
      "integrity": "sha512-0rFg/Rj2Q62NCm62jZw0QX7a3sz6QCQU0LpZdNrJX8byRGaGVTqbrW9jAoIAHyMQqsNpeZ81YgSizOt5WXq0Pw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context-menu/node_modules/@radix-ui/react-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-menu/-/react-menu-2.1.16.tgz",
      "integrity": "sha512-72F2T+PLlphrqLcAotYPp0uJMr5SjP5SL01wfEspJbru5Zs5vQaSHb4VB3ZMJPimgHHCHG7gMOeOB9H3Hdmtxg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context-menu/node_modules/@radix-ui/react-popper": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.8.tgz",
      "integrity": "sha512-0NJQ4LFFUuWkE7Oxf0htBKS6zLkkjBH+hM1uk7Ng705ReR8m/uelduy1DBo0PyBXPKVnBA6YBlU94MBGXrSBCw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context-menu/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dialog/-/react-dialog-1.1.15.tgz",
      "integrity": "sha512-TCglVRtzlffRNxRMEyR36DGBLJpeusFcgMVD9PZEzAKnUs1lKCgX5u9BmC2Yg+LL9MgZDugFFs1Vl+Jp4t/PGw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog/node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog/node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.3.tgz",
      "integrity": "sha512-0rFg/Rj2Q62NCm62jZw0QX7a3sz6QCQU0LpZdNrJX8byRGaGVTqbrW9jAoIAHyMQqsNpeZ81YgSizOt5WXq0Pw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-direction": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-direction/-/react-direction-1.1.1.tgz",
      "integrity": "sha512-1UEWRX6jnOA2y4H5WczZ44gOOjTEmlqv1uNW4GAJEO5+bauCBhv8snY65Iw5/VOS/ghKN9gr2KjnLKxrsvoMVw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dropdown-menu/-/react-dropdown-menu-2.1.16.tgz",
      "integrity": "sha512-1PLGQEynI/3OX/ftV54COn+3Sud/Mn8vALg2rWnBLnRaGtJDduNW/22XjlGgPdpcIbiQxjKtb7BkcjP00nqfJw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-menu": "2.1.16",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu/node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu/node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.3.tgz",
      "integrity": "sha512-0rFg/Rj2Q62NCm62jZw0QX7a3sz6QCQU0LpZdNrJX8byRGaGVTqbrW9jAoIAHyMQqsNpeZ81YgSizOt5WXq0Pw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu/node_modules/@radix-ui/react-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-menu/-/react-menu-2.1.16.tgz",
      "integrity": "sha512-72F2T+PLlphrqLcAotYPp0uJMr5SjP5SL01wfEspJbru5Zs5vQaSHb4VB3ZMJPimgHHCHG7gMOeOB9H3Hdmtxg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu/node_modules/@radix-ui/react-popper": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.8.tgz",
      "integrity": "sha512-0NJQ4LFFUuWkE7Oxf0htBKS6zLkkjBH+hM1uk7Ng705ReR8m/uelduy1DBo0PyBXPKVnBA6YBlU94MBGXrSBCw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-scope": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-scope/-/react-focus-scope-1.1.7.tgz",
      "integrity": "sha512-t2ODlkXBQyn7jkl6TNaw/MtVEVvIGelJDCG41Okq/KwUsJBwQ4XVZsHAVUkK4mBv3ewiAS3PGuUWuY2BoK4ZUw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-id": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-id/-/react-id-1.1.1.tgz",
      "integrity": "sha512-kGkGegYIdQsOb4XjsfM97rXsiHaBwco+hFI66oO4s9LU+PLAC5oJ7khdOVFxkhsmlbpUqDAvXw11CluXP+jkHg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label": {
      "version": "2.1.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-label/-/react-label-2.1.8.tgz",
      "integrity": "sha512-FmXs37I6hSBVDlO4y764TNz1rLgKwjJMQ0EGte6F3Cb3f4bIuHB/iLa/8I9VKkmOy+gNHq8rql3j686ACVV21A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label/node_modules/@radix-ui/react-primitive": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.4.tgz",
      "integrity": "sha512-9hQc4+GNVtJAIEPEqlYqW5RiYdrr8ea5XQ0ZOnD6fgru+83kqT15mq2OCcbe8KnjRZl5vF3ks69AKz3kh1jrhg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popover/-/react-popover-1.1.15.tgz",
      "integrity": "sha512-kr0X2+6Yy/vJzLYJUPCZEc8SfQcf+1COFoAqauJm74umQhta9M7lNJHP7QQS3vkvcGLQUbWpMzwrXYwrYztHKA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.3.tgz",
      "integrity": "sha512-0rFg/Rj2Q62NCm62jZw0QX7a3sz6QCQU0LpZdNrJX8byRGaGVTqbrW9jAoIAHyMQqsNpeZ81YgSizOt5WXq0Pw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-popper": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.8.tgz",
      "integrity": "sha512-0NJQ4LFFUuWkE7Oxf0htBKS6zLkkjBH+hM1uk7Ng705ReR8m/uelduy1DBo0PyBXPKVnBA6YBlU94MBGXrSBCw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-portal": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-portal/-/react-portal-1.1.9.tgz",
      "integrity": "sha512-bpIxvq03if6UNwXZ+HTK71JLh4APvnXntDc6XOX8UVq4XQOVl7lwok0AvIl+b8zgCw3fSaVTZMpAPPagXbKmHQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-presence": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-presence/-/react-presence-1.1.5.tgz",
      "integrity": "sha512-/jfEwNDdQVBCNvjkGit4h6pMOzq8bHkopq458dPt2lMjx+eBQUohZNG9A7DtO/O5ukSbxuaNGXMjHicgwy6rQQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.3.tgz",
      "integrity": "sha512-m9gTwRkhy2lvCPe6QJp4d3G1TYEUHn/FzJUtq9MjH46an1wJU+GdoGC5VLof8RX8Ft/DlpshApkhswDLZzHIcQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-radio-group": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-radio-group/-/react-radio-group-1.3.8.tgz",
      "integrity": "sha512-VBKYIYImA5zsxACdisNQ3BjCBfmbGH3kQlnFVqlWU4tXwjy7cGX8ta80BcrO+WJXIn5iBylEH3K6ZTlee//lgQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-roving-focus": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-roving-focus/-/react-roving-focus-1.1.11.tgz",
      "integrity": "sha512-7A6S9jSgm/S+7MdtNDSb+IU859vQqJ/QAtcYQcfFC6W8RS4IxIZDldLR0xqCFZ6DCyrQLjLPsxtTNch5jVA4lA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-scroll-area": {
      "version": "1.2.10",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-scroll-area/-/react-scroll-area-1.2.10.tgz",
      "integrity": "sha512-tAXIa1g3sM5CGpVT0uIbUx/U3Gs5N8T52IICuCtObaos1S8fzsrPXG5WObkQN3S6NVl6wKgPhAIiBGbWnvc97A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/number": "1.1.1",
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-separator/-/react-separator-1.1.8.tgz",
      "integrity": "sha512-sDvqVY4itsKwwSMEe0jtKgfTh+72Sy3gPmQpjqcQneqQ4PFmr/1I0YA+2/puilhggCe2gJcx5EBAYFkWkdpa5g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator/node_modules/@radix-ui/react-primitive": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.4.tgz",
      "integrity": "sha512-9hQc4+GNVtJAIEPEqlYqW5RiYdrr8ea5XQ0ZOnD6fgru+83kqT15mq2OCcbe8KnjRZl5vF3ks69AKz3kh1jrhg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-slot": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.4.tgz",
      "integrity": "sha512-Jl+bCv8HxKnlTLVrcDE8zTMJ09R9/ukw4qBs/oZClOfoQk/cOTbDn+NceXfV7j09YPVQUryJPHurafcSg6EVKA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tabs": {
      "version": "1.1.13",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-tabs/-/react-tabs-1.1.13.tgz",
      "integrity": "sha512-7xdcatg7/U+7+Udyoj2zodtI9H/IIopqo+YOIcZOq1nJwXWBZ9p8xiu5llXlekDbZkca79a/fozEYQXIA4sW6A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-tooltip/-/react-tooltip-1.2.8.tgz",
      "integrity": "sha512-tY7sVt1yL9ozIxvmbtN5qtmH2krXcBCfjEiCgKGLqunJHvgvZG2Pcl2oQ3kbcZARb1BGEHdkLzcYGO8ynVlieg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-visually-hidden": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip/node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip/node_modules/@radix-ui/react-popper": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.8.tgz",
      "integrity": "sha512-0NJQ4LFFUuWkE7Oxf0htBKS6zLkkjBH+hM1uk7Ng705ReR8m/uelduy1DBo0PyBXPKVnBA6YBlU94MBGXrSBCw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-callback-ref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-callback-ref/-/react-use-callback-ref-1.1.1.tgz",
      "integrity": "sha512-FkBMwD+qbGQeMu1cOHnuGB6x4yzPjho8ap5WtbEJ26umhgqVXbhekKUQO+hZEL1vU92a3wHwdp0HAcqAUF5iDg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-controllable-state": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-controllable-state/-/react-use-controllable-state-1.2.2.tgz",
      "integrity": "sha512-BjasUjixPFdS+NKkypcyyN5Pmg83Olst0+c6vGov0diwTEo6mgdqVR6hxcEgFuh4QrAs7Rc+9KuGJ9TVCj0Zzg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-effect-event": "0.0.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-effect-event": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-effect-event/-/react-use-effect-event-0.0.2.tgz",
      "integrity": "sha512-Qp8WbZOBe+blgpuUT+lw2xheLP8q0oatc9UpmiemEICxGvFLYmHm9QowVZGHtJlGbS6A6yJ3iViad/2cVjnOiA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-escape-keydown": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-escape-keydown/-/react-use-escape-keydown-1.1.1.tgz",
      "integrity": "sha512-Il0+boE7w/XebUHyBjroE+DbByORGR9KKmITzbR7MyQ4akpORYP/ZmbhAr0DG7RmmBqoOnZdy2QlvajJ2QA59g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-layout-effect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-layout-effect/-/react-use-layout-effect-1.1.1.tgz",
      "integrity": "sha512-RbJRS4UWQFkzHTTwVymMTUv8EqYhOp8dOOviLj2ugtTiXRaRQS7GLGxZTLL1jWhMeoSCf5zmcZkqTl9IiYfXcQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-previous": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-previous/-/react-use-previous-1.1.1.tgz",
      "integrity": "sha512-2dHfToCj/pzca2Ck724OZ5L0EVrr3eHRNsG/b3xQJLA2hZpVCS99bLAX+hm1IHXDEnzU6by5z/5MIY794/a8NQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-rect/-/react-use-rect-1.1.1.tgz",
      "integrity": "sha512-QTYuDesS0VtuHNNvMh+CjlKJ4LJickCMUAqjlE3+j8w+RlRpwyX3apEQKGFzbZGdo7XNG1tXa+bQqIE7HIXT2w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-size": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-size/-/react-use-size-1.1.1.tgz",
      "integrity": "sha512-ewrXRDTAqAXlkl6t/fkXWNAhFX9I+CkKlw6zjEwk86RSPKwZr3xpBRso655aqYafwtnbpHLj6toFzmd6xdVptQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-visually-hidden": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-visually-hidden/-/react-visually-hidden-1.2.3.tgz",
      "integrity": "sha512-pzJq12tEaaIhqjbzpCuv/OypJY/BPavOofm+dbab+MHLajy277+1lLm6JFcGgF5eskJ6mquGirhXY2GD/8u8Ug==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/rect/-/rect-1.1.1.tgz",
      "integrity": "sha512-HPwpGIzkl28mWyZqG52jiqDJ12waP11Pa1lGoiyUkIEuMLBP0oeK/C89esbXrxsky5we7dfd8U58nm0SgAWpVw==",
      "license": "MIT"
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.53",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.53.tgz",
      "integrity": "sha512-vENRlFU4YbrwVqNDZ7fLvy+JR1CRkyr01jhSiDpE1u6py3OMzQfztQU2jxykW3ALNxO4kSlqIDeYyD0Y9RcQeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/plugin-node-resolve": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@rollup/plugin-node-resolve/-/plugin-node-resolve-15.3.1.tgz",
      "integrity": "sha512-tgg6b91pAybXHJQMAAwW9VuWBO6Thi+q7BCNARLwSqlmsHz0XYURtGvh/AuwSADXSI4h/2uHbs7s4FzlZDGSGA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@rollup/pluginutils": "^5.0.1",
        "@types/resolve": "1.20.2",
        "deepmerge": "^4.2.2",
        "is-module": "^1.0.0",
        "resolve": "^1.22.1"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "rollup": "^2.78.0||^3.0.0||^4.0.0"
      },
      "peerDependenciesMeta": {
        "rollup": {
          "optional": true
        }
      }
    },
    "node_modules/@rollup/plugin-terser": {
      "version": "0.4.4",
      "resolved": "https://registry.npmjs.org/@rollup/plugin-terser/-/plugin-terser-0.4.4.tgz",
      "integrity": "sha512-XHeJC5Bgvs8LfukDwWZp7yeqin6ns8RTl2B9avbejt6tZqsqvVoWI7ZTQrcNsfKEDWBTnTxM8nMDkO2IFFbd0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "serialize-javascript": "^6.0.1",
        "smob": "^1.0.0",
        "terser": "^5.17.4"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "rollup": "^2.0.0||^3.0.0||^4.0.0"
      },
      "peerDependenciesMeta": {
        "rollup": {
          "optional": true
        }
      }
    },
    "node_modules/@rollup/pluginutils": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-5.3.0.tgz",
      "integrity": "sha512-5EdhGZtnu3V88ces7s53hhfK5KSASnJZv8Lulpc04cWO3REESroJXg73DFsOmgbU2BhwV0E20bu2IDZb3VKW4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0",
        "estree-walker": "^2.0.2",
        "picomatch": "^4.0.2"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "rollup": "^1.20.0||^2.0.0||^3.0.0||^4.0.0"
      },
      "peerDependenciesMeta": {
        "rollup": {
          "optional": true
        }
      }
    },
    "node_modules/@rollup/pluginutils/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.46.3.tgz",
      "integrity": "sha512-UmTdvXnLlqQNOCJnyksjPs1G4GqXNGW1LrzCe8+8QoaLhhDeTXYBgJ3k6x61WIhlHX2U+VzEJ55TtIjR/HTySA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.46.3.tgz",
      "integrity": "sha512-8NoxqLpXm7VyeI0ocidh335D6OKT0UJ6fHdnIxf3+6oOerZZc+O7r+UhvROji6OspyPm+rrIdb1gTXtVIqn+Sg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.46.3.tgz",
      "integrity": "sha512-csnNavqZVs1+7/hUKtgjMECsNG2cdB8F7XBHP6FfQjqhjF8rzMzb3SLyy/1BG7YSfQ+bG75Ph7DyedbUqwq1rA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.46.3.tgz",
      "integrity": "sha512-r2MXNjbuYabSIX5yQqnT8SGSQ26XQc8fmp6UhlYJd95PZJkQD1u82fWP7HqvGUf33IsOC6qsiV+vcuD4SDP6iw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.46.3.tgz",
      "integrity": "sha512-uluObTmgPJDuJh9xqxyr7MV61Imq+0IvVsAlWyvxAaBSNzCcmZlhfYcRhCdMaCsy46ccZa7vtDDripgs9Jkqsw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.46.3.tgz",
      "integrity": "sha512-AVJXEq9RVHQnejdbFvh1eWEoobohUYN3nqJIPI4mNTMpsyYN01VvcAClxflyk2HIxvLpRcRggpX1m9hkXkpC/A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.46.3.tgz",
      "integrity": "sha512-byyflM+huiwHlKi7VHLAYTKr67X199+V+mt1iRgJenAI594vcmGGddWlu6eHujmcdl6TqSNnvqaXJqZdnEWRGA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.46.3.tgz",
      "integrity": "sha512-aLm3NMIjr4Y9LklrH5cu7yybBqoVCdr4Nvnm8WB7PKCn34fMCGypVNpGK0JQWdPAzR/FnoEoFtlRqZbBBLhVoQ==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.46.3.tgz",
      "integrity": "sha512-VtilE6eznJRDIoFOzaagQodUksTEfLIsvXymS+UdJiSXrPW7Ai+WG4uapAc3F7Hgs791TwdGh4xyOzbuzIZrnw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.46.3.tgz",
      "integrity": "sha512-dG3JuS6+cRAL0GQ925Vppafi0qwZnkHdPeuZIxIPXqkCLP02l7ka+OCyBoDEv8S+nKHxfjvjW4OZ7hTdHkx8/w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loongarch64-gnu": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.46.3.tgz",
      "integrity": "sha512-iU8DxnxEKJptf8Vcx4XvAUdpkZfaz0KWfRrnIRrOndL0SvzEte+MTM7nDH4A2Now4FvTZ01yFAgj6TX/mZl8hQ==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.46.3.tgz",
      "integrity": "sha512-VrQZp9tkk0yozJoQvQcqlWiqaPnLM6uY1qPYXvukKePb0fqaiQtOdMJSxNFUZFsGw5oA5vvVokjHrx8a9Qsz2A==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.46.3.tgz",
      "integrity": "sha512-uf2eucWSUb+M7b0poZ/08LsbcRgaDYL8NCGjUeFMwCWFwOuFcZ8D9ayPl25P3pl+D2FH45EbHdfyUesQ2Lt9wA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.46.3.tgz",
      "integrity": "sha512-7tnUcDvN8DHm/9ra+/nF7lLzYHDeODKKKrh6JmZejbh1FnCNZS8zMkZY5J4sEipy2OW1d1Ncc4gNHUd0DLqkSg==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.46.3.tgz",
      "integrity": "sha512-MUpAOallJim8CsJK+4Lc9tQzlfPbHxWDrGXZm2z6biaadNpvh3a5ewcdat478W+tXDoUiHwErX/dOql7ETcLqg==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.46.3.tgz",
      "integrity": "sha512-F42IgZI4JicE2vM2PWCe0N5mR5vR0gIdORPqhGQ32/u1S1v3kLtbZ0C/mi9FFk7C5T0PgdeyWEPajPjaUpyoKg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.46.3.tgz",
      "integrity": "sha512-oLc+JrwwvbimJUInzx56Q3ujL3Kkhxehg7O1gWAYzm8hImCd5ld1F2Gry5YDjR21MNb5WCKhC9hXgU7rRlyegQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.46.3.tgz",
      "integrity": "sha512-lOrQ+BVRstruD1fkWg9yjmumhowR0oLAAzavB7yFSaGltY8klttmZtCLvOXCmGE9mLIn8IBV/IFrQOWz5xbFPg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.46.3.tgz",
      "integrity": "sha512-vvrVKPRS4GduGR7VMH8EylCBqsDcw6U+/0nPDuIjXQRbHJc6xOBj+frx8ksfZAh6+Fptw5wHrN7etlMmQnPQVg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.46.3.tgz",
      "integrity": "sha512-fi3cPxCnu3ZeM3EwKZPgXbWoGzm2XHgB/WShKI81uj8wG0+laobmqy5wbgEwzstlbLu4MyO8C19FyhhWseYKNQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@surma/rollup-plugin-off-main-thread": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/@surma/rollup-plugin-off-main-thread/-/rollup-plugin-off-main-thread-2.2.3.tgz",
      "integrity": "sha512-lR8q/9W7hZpMWweNiAKU7NQerBnzQQLvi8qnTDU/fxItPhtZVMbPV3lbCwjhIlNBe9Bbr5V+KHshvWmVSG9cxQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "ejs": "^3.1.6",
        "json5": "^2.2.0",
        "magic-string": "^0.25.0",
        "string.prototype.matchall": "^4.0.6"
      }
    },
    "node_modules/@surma/rollup-plugin-off-main-thread/node_modules/magic-string": {
      "version": "0.25.9",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.9.tgz",
      "integrity": "sha512-RmF0AsMzgt25qzqqLc1+MbHmhdx0ojF2Fvs4XnOqz2ZOBXzzkEwc/dJQZCYHAn7v1jbVOjAZfK8msRn4BxO4VQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "sourcemap-codec": "^1.4.8"
      }
    },
    "node_modules/@tailwindcss/node": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/node/-/node-4.1.18.tgz",
      "integrity": "sha512-DoR7U1P7iYhw16qJ49fgXUlry1t4CpXeErJHnQ44JgTSKMaZUdf17cfn5mHchfJ4KRBZRFA/Coo+MUF5+gOaCQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/remapping": "^2.3.4",
        "enhanced-resolve": "^5.18.3",
        "jiti": "^2.6.1",
        "lightningcss": "1.30.2",
        "magic-string": "^0.30.21",
        "source-map-js": "^1.2.1",
        "tailwindcss": "4.1.18"
      }
    },
    "node_modules/@tailwindcss/oxide": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide/-/oxide-4.1.18.tgz",
      "integrity": "sha512-EgCR5tTS5bUSKQgzeMClT6iCY3ToqE1y+ZB0AKldj809QXk1Y+3jB0upOYZrn9aGIzPtUsP7sX4QQ4XtjBB95A==",
      "license": "MIT",
      "engines": {
        "node": ">= 10"
      },
      "optionalDependencies": {
        "@tailwindcss/oxide-android-arm64": "4.1.18",
        "@tailwindcss/oxide-darwin-arm64": "4.1.18",
        "@tailwindcss/oxide-darwin-x64": "4.1.18",
        "@tailwindcss/oxide-freebsd-x64": "4.1.18",
        "@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.18",
        "@tailwindcss/oxide-linux-arm64-gnu": "4.1.18",
        "@tailwindcss/oxide-linux-arm64-musl": "4.1.18",
        "@tailwindcss/oxide-linux-x64-gnu": "4.1.18",
        "@tailwindcss/oxide-linux-x64-musl": "4.1.18",
        "@tailwindcss/oxide-wasm32-wasi": "4.1.18",
        "@tailwindcss/oxide-win32-arm64-msvc": "4.1.18",
        "@tailwindcss/oxide-win32-x64-msvc": "4.1.18"
      }
    },
    "node_modules/@tailwindcss/oxide-android-arm64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-android-arm64/-/oxide-android-arm64-4.1.18.tgz",
      "integrity": "sha512-dJHz7+Ugr9U/diKJA0W6N/6/cjI+ZTAoxPf9Iz9BFRF2GzEX8IvXxFIi/dZBloVJX/MZGvRuFA9rqwdiIEZQ0Q==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-arm64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-arm64/-/oxide-darwin-arm64-4.1.18.tgz",
      "integrity": "sha512-Gc2q4Qhs660bhjyBSKgq6BYvwDz4G+BuyJ5H1xfhmDR3D8HnHCmT/BSkvSL0vQLy/nkMLY20PQ2OoYMO15Jd0A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-x64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-x64/-/oxide-darwin-x64-4.1.18.tgz",
      "integrity": "sha512-FL5oxr2xQsFrc3X9o1fjHKBYBMD1QZNyc1Xzw/h5Qu4XnEBi3dZn96HcHm41c/euGV+GRiXFfh2hUCyKi/e+yw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-freebsd-x64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-freebsd-x64/-/oxide-freebsd-x64-4.1.18.tgz",
      "integrity": "sha512-Fj+RHgu5bDodmV1dM9yAxlfJwkkWvLiRjbhuO2LEtwtlYlBgiAT4x/j5wQr1tC3SANAgD+0YcmWVrj8R9trVMA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm-gnueabihf": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm-gnueabihf/-/oxide-linux-arm-gnueabihf-4.1.18.tgz",
      "integrity": "sha512-Fp+Wzk/Ws4dZn+LV2Nqx3IilnhH51YZoRaYHQsVq3RQvEl+71VGKFpkfHrLM/Li+kt5c0DJe/bHXK1eHgDmdiA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-gnu": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-gnu/-/oxide-linux-arm64-gnu-4.1.18.tgz",
      "integrity": "sha512-S0n3jboLysNbh55Vrt7pk9wgpyTTPD0fdQeh7wQfMqLPM/Hrxi+dVsLsPrycQjGKEQk85Kgbx+6+QnYNiHalnw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-musl": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-musl/-/oxide-linux-arm64-musl-4.1.18.tgz",
      "integrity": "sha512-1px92582HkPQlaaCkdRcio71p8bc8i/ap5807tPRDK/uw953cauQBT8c5tVGkOwrHMfc2Yh6UuxaH4vtTjGvHg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-gnu": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-gnu/-/oxide-linux-x64-gnu-4.1.18.tgz",
      "integrity": "sha512-v3gyT0ivkfBLoZGF9LyHmts0Isc8jHZyVcbzio6Wpzifg/+5ZJpDiRiUhDLkcr7f/r38SWNe7ucxmGW3j3Kb/g==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-musl": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-musl/-/oxide-linux-x64-musl-4.1.18.tgz",
      "integrity": "sha512-bhJ2y2OQNlcRwwgOAGMY0xTFStt4/wyU6pvI6LSuZpRgKQwxTec0/3Scu91O8ir7qCR3AuepQKLU/kX99FouqQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-wasm32-wasi/-/oxide-wasm32-wasi-4.1.18.tgz",
      "integrity": "sha512-LffYTvPjODiP6PT16oNeUQJzNVyJl1cjIebq/rWWBF+3eDst5JGEFSc5cWxyRCJ0Mxl+KyIkqRxk1XPEs9x8TA==",
      "bundleDependencies": [
        "@napi-rs/wasm-runtime",
        "@emnapi/core",
        "@emnapi/runtime",
        "@tybys/wasm-util",
        "@emnapi/wasi-threads",
        "tslib"
      ],
      "cpu": [
        "wasm32"
      ],
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.7.1",
        "@emnapi/runtime": "^1.7.1",
        "@emnapi/wasi-threads": "^1.1.0",
        "@napi-rs/wasm-runtime": "^1.1.0",
        "@tybys/wasm-util": "^0.10.1",
        "tslib": "^2.4.0"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi/node_modules/@emnapi/core": {
      "version": "1.7.1",
      "inBundle": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/wasi-threads": "1.1.0",
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi/node_modules/@emnapi/runtime": {
      "version": "1.7.1",
      "inBundle": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi/node_modules/@emnapi/wasi-threads": {
      "version": "1.1.0",
      "inBundle": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi/node_modules/@napi-rs/wasm-runtime": {
      "version": "1.1.0",
      "inBundle": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.7.1",
        "@emnapi/runtime": "^1.7.1",
        "@tybys/wasm-util": "^0.10.1"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi/node_modules/@tybys/wasm-util": {
      "version": "0.10.1",
      "inBundle": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi/node_modules/tslib": {
      "version": "2.8.1",
      "inBundle": true,
      "license": "0BSD",
      "optional": true
    },
    "node_modules/@tailwindcss/oxide-win32-arm64-msvc": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-arm64-msvc/-/oxide-win32-arm64-msvc-4.1.18.tgz",
      "integrity": "sha512-HjSA7mr9HmC8fu6bdsZvZ+dhjyGCLdotjVOgLA2vEqxEBZaQo9YTX4kwgEvPCpRh8o4uWc4J/wEoFzhEmjvPbA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-x64-msvc": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-x64-msvc/-/oxide-win32-x64-msvc-4.1.18.tgz",
      "integrity": "sha512-bJWbyYpUlqamC8dpR7pfjA0I7vdF6t5VpUGMWRkXVE3AXgIZjYUYAK7II1GNaxR8J1SSrSrppRar8G++JekE3Q==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/vite": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/vite/-/vite-4.1.18.tgz",
      "integrity": "sha512-jVA+/UpKL1vRLg6Hkao5jldawNmRo7mQYrZtNHMIVpLfLhDml5nMRUo/8MwoX2vNXvnaXNNMedrMfMugAVX1nA==",
      "license": "MIT",
      "dependencies": {
        "@tailwindcss/node": "4.1.18",
        "@tailwindcss/oxide": "4.1.18",
        "tailwindcss": "4.1.18"
      },
      "peerDependencies": {
        "vite": "^5.2.0 || ^6 || ^7"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.20.7",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.7.tgz",
      "integrity": "sha512-dkO5fhS7+/oos4ciWxyEyjWe48zmG6wbCheo/G2ZnHx4fs3EU6YC6UM8rk56gAjNJ9P3MTH2jo5jb92/K6wbng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.20.7"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "25.2.0",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-25.2.0.tgz",
      "integrity": "sha512-DZ8VwRFUNzuqJ5khrvwMXHmvPe+zGayJhr2CDNiKB1WBE1ST8Djl00D0IC4vvNmHMdj6DlbYRIaFE7WHjlDl5w==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.16.0"
      }
    },
    "node_modules/@types/react": {
      "version": "19.2.10",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.10.tgz",
      "integrity": "sha512-WPigyYuGhgZ/cTPRXB2EwUw+XvsRA3GqHlsP4qteqrnnjDrApbS7MxcGr/hke5iUoeB7E/gQtrs9I37zAJ0Vjw==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==",
      "devOptional": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@types/react-helmet": {
      "version": "6.1.11",
      "resolved": "https://registry.npmjs.org/@types/react-helmet/-/react-helmet-6.1.11.tgz",
      "integrity": "sha512-0QcdGLddTERotCXo3VFlUSWO3ztraw8nZ6e3zJSgG7apwV5xt+pJUS8ewPBqT4NYB1optGLprNQzFleIY84u/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/react": "*"
      }
    },
    "node_modules/@types/resolve": {
      "version": "1.20.2",
      "resolved": "https://registry.npmjs.org/@types/resolve/-/resolve-1.20.2.tgz",
      "integrity": "sha512-60BCwRFOZCQhDncwQdxxeOEEkbc5dIMccYLwbxsS4TUNeVECQ/pBJ0j09mrHOl/JJvpRPGwO9SvE4nR2Nb/a4Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/shell-quote": {
      "version": "1.7.5",
      "resolved": "https://registry.npmjs.org/@types/shell-quote/-/shell-quote-1.7.5.tgz",
      "integrity": "sha512-+UE8GAGRPbJVQDdxi16dgadcBfQ+KG2vgZhV1+3A1XmHbmwcdwhCUwIdy+d3pAGrbvgRoVSjeI9vOWyq376Yzw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/trusted-types": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.7.tgz",
      "integrity": "sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.54.0.tgz",
      "integrity": "sha512-hAAP5io/7csFStuOmR782YmTthKBJ9ND3WVL60hcOjvtGFb+HJxH4O5huAcmcZ9v9G8P+JETiZ/G1B8MALnWZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.12.2",
        "@typescript-eslint/scope-manager": "8.54.0",
        "@typescript-eslint/type-utils": "8.54.0",
        "@typescript-eslint/utils": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0",
        "ignore": "^7.0.5",
        "natural-compare": "^1.4.0",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^8.54.0",
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/ignore": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-7.0.5.tgz",
      "integrity": "sha512-Hs59xBNfUIunMFgWAbGX5cq6893IbWg4KnrjbYwX3tx0ztorVgTDA6B2sxf8ejHJ4wz8BqGUMYlnzNBer5NvGg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.54.0.tgz",
      "integrity": "sha512-BtE0k6cjwjLZoZixN0t5AKP0kSzlGu7FctRXYuPAm//aaiZhmfq1JwdYpYr1brzEspYyFeF+8XF5j2VK6oalrA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.54.0",
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/project-service": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/project-service/-/project-service-8.54.0.tgz",
      "integrity": "sha512-YPf+rvJ1s7MyiWM4uTRhE4DvBXrEV+d8oC3P9Y2eT7S+HBS0clybdMIPnhiATi9vZOYDc7OQ1L/i6ga6NFYK/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/tsconfig-utils": "^8.54.0",
        "@typescript-eslint/types": "^8.54.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.54.0.tgz",
      "integrity": "sha512-27rYVQku26j/PbHYcVfRPonmOlVI6gihHtXFbTdB5sb6qA0wdAQAbyXFVarQ5t4HRojIz64IV90YtsjQSSGlQg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/tsconfig-utils": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/tsconfig-utils/-/tsconfig-utils-8.54.0.tgz",
      "integrity": "sha512-dRgOyT2hPk/JwxNMZDsIXDgyl9axdJI3ogZ2XWhBPsnZUv+hPesa5iuhdYt2gzwA9t8RE5ytOJ6xB0moV0Ujvw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.54.0.tgz",
      "integrity": "sha512-hiLguxJWHjjwL6xMBwD903ciAwd7DmK30Y9Axs/etOkftC3ZNN9K44IuRD/EB08amu+Zw6W37x9RecLkOo3pMA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0",
        "@typescript-eslint/utils": "8.54.0",
        "debug": "^4.4.3",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.54.0.tgz",
      "integrity": "sha512-PDUI9R1BVjqu7AUDsRBbKMtwmjWcn4J3le+5LpcFgWULN3LvHC5rkc9gCVxbrsrGmO1jfPybN5s6h4Jy+OnkAA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.54.0.tgz",
      "integrity": "sha512-BUwcskRaPvTk6fzVWgDPdUndLjB87KYDrN5EYGetnktoeAvPtO4ONHlAZDnj5VFnUANg0Sjm7j4usBlnoVMHwA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/project-service": "8.54.0",
        "@typescript-eslint/tsconfig-utils": "8.54.0",
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0",
        "debug": "^4.4.3",
        "minimatch": "^9.0.5",
        "semver": "^7.7.3",
        "tinyglobby": "^0.2.15",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
      "version": "7.7.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.3.tgz",
      "integrity": "sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.54.0.tgz",
      "integrity": "sha512-9Cnda8GS57AQakvRyG0PTejJNlA2xhvyNtEVIMlDWOOeEyBkYWhGPnfrIAnqxLMTSTo6q8g12XVjjev5l1NvMA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.9.1",
        "@typescript-eslint/scope-manager": "8.54.0",
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.54.0.tgz",
      "integrity": "sha512-VFlhGSl4opC0bprJiItPQ1RfUhGDIBokcPwaFH4yiBCaNPeld/9VeXbiPO1cLyorQi1G1vL+ecBk1x8o1axORA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.54.0",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-5.1.2.tgz",
      "integrity": "sha512-EcA07pHJouywpzsoTUqNh5NwGayl2PPVEJKUSinGGSxFGYn+shYbqMGBg6FXDqgXum9Ou/ecb+411ssw8HImJQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.5",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.53",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.18.0"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "devOptional": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-regex": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/aria-hidden": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/aria-hidden/-/aria-hidden-1.2.4.tgz",
      "integrity": "sha512-y+CcFFwelSXpLZk/7fMB2mUbGtX9lKycf1MWJ7CaTIERyitVlyQx6C+sxcROU2BAJ24OiZyK+8wj2i8AlBoS3A==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/array-buffer-byte-length": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/array-buffer-byte-length/-/array-buffer-byte-length-1.0.2.tgz",
      "integrity": "sha512-LHE+8BuR7RYGDKvnrmcuSq3tDcKv9OFEXQt/HpbZhY7V6h0zlUXutnAD82GiFx9rdieCMjkvtcsPqBwgUl1Iiw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "is-array-buffer": "^3.0.5"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/arraybuffer.prototype.slice": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/arraybuffer.prototype.slice/-/arraybuffer.prototype.slice-1.0.4.tgz",
      "integrity": "sha512-BNoCY6SXXPQ7gF2opIP4GBE+Xw7U+pHMYKuzjgCN3GwiaIR09UUeKfheyIry77QtrCBlC0KK0q5/TER/tYh3PQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-buffer-byte-length": "^1.0.1",
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "is-array-buffer": "^3.0.4"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/async": {
      "version": "3.2.6",
      "resolved": "https://registry.npmjs.org/async/-/async-3.2.6.tgz",
      "integrity": "sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/async-function": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/async-function/-/async-function-1.0.0.tgz",
      "integrity": "sha512-hsU18Ae8CDTR6Kgu9DYf0EbCr/a5iGL0rytQDobUcdpYOKokk8LEjVphnXkDkgpi0wYVsqrXuP0bZxJaTqdgoA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/at-least-node": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/at-least-node/-/at-least-node-1.0.0.tgz",
      "integrity": "sha512-+q/t7Ekv1EDY2l6Gda6LLiX14rU9TV20Wa3ofeQmwPFZbOMo9DXrLbOjFaaclkXKWidIaopwAObQDqwWtGUjqg==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">= 4.0.0"
      }
    },
    "node_modules/attr-accept": {
      "version": "2.2.5",
      "resolved": "https://registry.npmjs.org/attr-accept/-/attr-accept-2.2.5.tgz",
      "integrity": "sha512-0bDNnY/u6pPwHDMoF0FieU354oBi0a8rD9FcsLwzcGWbc8KS8KPIi7y+s13OlVY+gMWc/9xEMUgNE6Qm8ZllYQ==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/available-typed-arrays": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.7.tgz",
      "integrity": "sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "possible-typed-array-names": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/babel-plugin-polyfill-corejs2": {
      "version": "0.4.14",
      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs2/-/babel-plugin-polyfill-corejs2-0.4.14.tgz",
      "integrity": "sha512-Co2Y9wX854ts6U8gAAPXfn0GmAyctHuK8n0Yhfjd6t30g7yvKjspvvOo9yG+z52PZRgFErt7Ka2pYnXCjLKEpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.7",
        "@babel/helper-define-polyfill-provider": "^0.6.5",
        "semver": "^6.3.1"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/babel-plugin-polyfill-corejs3": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs3/-/babel-plugin-polyfill-corejs3-0.13.0.tgz",
      "integrity": "sha512-U+GNwMdSFgzVmfhNm8GJUX88AadB3uo9KpJqS3FaqNIPKgySuvMb+bHPsOmmuWyIcuqZj/pzt1RUIUZns4y2+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-define-polyfill-provider": "^0.6.5",
        "core-js-compat": "^3.43.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/babel-plugin-polyfill-regenerator": {
      "version": "0.6.5",
      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-regenerator/-/babel-plugin-polyfill-regenerator-0.6.5.tgz",
      "integrity": "sha512-ISqQ2frbiNU9vIJkzg7dlPpznPZ4jOiUQ1uSmB0fEHeowtN3COYRsXr/xexn64NpU13P06jc/L5TgiJXOgrbEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-define-polyfill-provider": "^0.6.5"
      },
      "peerDependencies": {
        "@babel/core": "^7.4.0 || ^8.0.0-0 <8.0.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.8.32",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.8.32.tgz",
      "integrity": "sha512-OPz5aBThlyLFgxyhdwf/s2+8ab3OvT7AdTNvKHBwpXomIYeXqpUUuT8LrdtxZSsWJ4R4CU1un4XGh5Ez3nlTpw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.js"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.0",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.0.tgz",
      "integrity": "sha512-tbydkR/CxfMwelN0vwdP/pLkDwyAASZ+VfWm4EOwlB6SWhx1sYnWLqo8N5j0rAzPfzfRaxt0mM/4wPU/Su84RQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "baseline-browser-mapping": "^2.8.25",
        "caniuse-lite": "^1.0.30001754",
        "electron-to-chromium": "^1.5.249",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.1.4"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/call-bind": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.8.tgz",
      "integrity": "sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.0",
        "es-define-property": "^1.0.0",
        "get-intrinsic": "^1.2.4",
        "set-function-length": "^1.2.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001757",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001757.tgz",
      "integrity": "sha512-r0nnL/I28Zi/yjk1el6ilj27tKcdjLsNqAOZr0yVjWPrSQyHgKI2INaEWw21bAQSv2LXRt1XuCS/GomNpWOxsQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/class-variance-authority": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/class-variance-authority/-/class-variance-authority-0.7.1.tgz",
      "integrity": "sha512-Ka+9Trutv7G8M6WT6SeiRWz792K5qEqIGEGzXKhAE6xOWAY6pPH8U+9IY3oCMv6kqTmLsv7Xh/2w2RigkePMsg==",
      "license": "Apache-2.0",
      "dependencies": {
        "clsx": "^2.1.1"
      },
      "funding": {
        "url": "https://polar.sh/cva"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/common-tags": {
      "version": "1.8.2",
      "resolved": "https://registry.npmjs.org/common-tags/-/common-tags-1.8.2.tgz",
      "integrity": "sha512-gk/Z852D2Wtb//0I+kRFNKKE9dIIVirjoqPoA1wJU+XePVXZfGeBpk45+A1rKO4Q43prqWBNY/MiIeRLbPWUaA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cookie": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.1.1.tgz",
      "integrity": "sha512-ei8Aos7ja0weRpFzJnEA9UHJ/7XQmqglbRwnf2ATjcB9Wq874VKH9kfjjirM6UhU2/E5fFYadylyhFldcqSidQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/core-js-compat": {
      "version": "3.47.0",
      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.47.0.tgz",
      "integrity": "sha512-IGfuznZ/n7Kp9+nypamBhvwdwLsW6KC8IOaURw2doAK5e98AG3acVLdh0woOnEqCfUtS+Vu882JE4k/DAm3ItQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.28.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/core-js"
      }
    },
    "node_modules/core-util-is": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==",
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/crypto-random-string": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/crypto-random-string/-/crypto-random-string-2.0.0.tgz",
      "integrity": "sha512-v1plID3y9r/lPhviJ1wrXpLeyUIGAZ2SHNYTEapm7/8A9nLPoyvVp3RK/EPFqn5kEznyWgYZNsRtYYIWbuG8KA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/data-view-buffer": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/data-view-buffer/-/data-view-buffer-1.0.2.tgz",
      "integrity": "sha512-EmKO5V3OLXh1rtK2wgXRansaK1/mtVdTUEiEI0W8RkvgT05kfxaH29PliLnpLP73yYO6142Q72QNa8Wx/A5CqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/data-view-byte-length": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/data-view-byte-length/-/data-view-byte-length-1.0.2.tgz",
      "integrity": "sha512-tuhGbE6CfTM9+5ANGf+oQb72Ky/0+s3xKUpHvShfiz2RxMFgFPjsXuRLBVMtvMs15awe45SRb83D6wH4ew6wlQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/inspect-js"
      }
    },
    "node_modules/data-view-byte-offset": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/data-view-byte-offset/-/data-view-byte-offset-1.0.1.tgz",
      "integrity": "sha512-BS8PfmtDGnrgYdOonGZQdLZslWIeCGFP9tpan0hi1Co2Zr2NKADsvGYA8XxuG/4UWgJ6Cjtv+YJnB6MM69QGlQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/deepmerge": {
      "version": "4.3.1",
      "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz",
      "integrity": "sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/define-data-property": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/define-properties": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.2.1.tgz",
      "integrity": "sha512-8QmQKqEASLd5nx0U1B1okLElbUuuttJ/AnYmRXbbbGDWh6uS208EjD4Xqq/I9wK7u0v6O08XhTWnt5XtEbR6Dg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.0.1",
        "has-property-descriptors": "^1.0.0",
        "object-keys": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.4.tgz",
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/detect-node-es": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/detect-node-es/-/detect-node-es-1.1.0.tgz",
      "integrity": "sha512-ypdmJU/TbBby2Dxibuv7ZLW3Bs1QEmM7nHjEANfohJLvE0XVujisn1qPJcZxg+qDucsr+bP6fLD1rPS3AhJ7EQ==",
      "license": "MIT"
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/ejs": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/ejs/-/ejs-3.1.10.tgz",
      "integrity": "sha512-UeJmFfOrAQS8OJWPZ4qtgHyWExa088/MtK5UEyoJGFH67cDEXkZSviOiKRCZ4Xij0zxI3JECgYs3oKx+AizQBA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "jake": "^10.8.5"
      },
      "bin": {
        "ejs": "bin/cli.js"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.262",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.262.tgz",
      "integrity": "sha512-NlAsMteRHek05jRUxUR0a5jpjYq9ykk6+kO0yRaMi5moe7u0fVIOeQ3Y30A8dIiWFBNUoQGi1ljb1i5VtS9WQQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/enhanced-resolve": {
      "version": "5.18.4",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.18.4.tgz",
      "integrity": "sha512-LgQMM4WXU3QI+SYgEc2liRgznaD5ojbmY3sb8LxyguVkIg5FxdpTkvk72te2R38/TGKxH634oLxXRGY6d7AP+Q==",
      "license": "MIT",
      "dependencies": {
        "graceful-fs": "^4.2.4",
        "tapable": "^2.2.0"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/es-abstract": {
      "version": "1.24.0",
      "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.24.0.tgz",
      "integrity": "sha512-WSzPgsdLtTcQwm4CROfS5ju2Wa1QQcVeT37jFjYzdFz1r9ahadC8B8/a4qxJxM+09F18iumCdRmlr96ZYkQvEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-buffer-byte-length": "^1.0.2",
        "arraybuffer.prototype.slice": "^1.0.4",
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "data-view-buffer": "^1.0.2",
        "data-view-byte-length": "^1.0.2",
        "data-view-byte-offset": "^1.0.1",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "es-set-tostringtag": "^2.1.0",
        "es-to-primitive": "^1.3.0",
        "function.prototype.name": "^1.1.8",
        "get-intrinsic": "^1.3.0",
        "get-proto": "^1.0.1",
        "get-symbol-description": "^1.1.0",
        "globalthis": "^1.0.4",
        "gopd": "^1.2.0",
        "has-property-descriptors": "^1.0.2",
        "has-proto": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "internal-slot": "^1.1.0",
        "is-array-buffer": "^3.0.5",
        "is-callable": "^1.2.7",
        "is-data-view": "^1.0.2",
        "is-negative-zero": "^2.0.3",
        "is-regex": "^1.2.1",
        "is-set": "^2.0.3",
        "is-shared-array-buffer": "^1.0.4",
        "is-string": "^1.1.1",
        "is-typed-array": "^1.1.15",
        "is-weakref": "^1.1.1",
        "math-intrinsics": "^1.1.0",
        "object-inspect": "^1.13.4",
        "object-keys": "^1.1.1",
        "object.assign": "^4.1.7",
        "own-keys": "^1.0.1",
        "regexp.prototype.flags": "^1.5.4",
        "safe-array-concat": "^1.1.3",
        "safe-push-apply": "^1.0.0",
        "safe-regex-test": "^1.1.0",
        "set-proto": "^1.0.0",
        "stop-iteration-iterator": "^1.1.0",
        "string.prototype.trim": "^1.2.10",
        "string.prototype.trimend": "^1.0.9",
        "string.prototype.trimstart": "^1.0.8",
        "typed-array-buffer": "^1.0.3",
        "typed-array-byte-length": "^1.0.3",
        "typed-array-byte-offset": "^1.0.4",
        "typed-array-length": "^1.0.7",
        "unbox-primitive": "^1.1.0",
        "which-typed-array": "^1.1.19"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-to-primitive": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.3.0.tgz",
      "integrity": "sha512-w+5mJ3GuFL+NjVtJlvydShqE1eN3h3PbI7/5LAsYJP/2qtuMXjfL2LpHSRqo4b4eSF5K/DH1JXKUAHSB2UW50g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-callable": "^1.2.7",
        "is-date-object": "^1.0.5",
        "is-symbol": "^1.0.4"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/esbuild": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.27.2.tgz",
      "integrity": "sha512-HyNQImnsOC7X9PMNaCIeAm4ISCQXs5a5YasTXVliKv4uuBo1dKrG0A+uQS8M5eXjVMnLg3WgXaKvprHlFJQffw==",
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.27.2",
        "@esbuild/android-arm": "0.27.2",
        "@esbuild/android-arm64": "0.27.2",
        "@esbuild/android-x64": "0.27.2",
        "@esbuild/darwin-arm64": "0.27.2",
        "@esbuild/darwin-x64": "0.27.2",
        "@esbuild/freebsd-arm64": "0.27.2",
        "@esbuild/freebsd-x64": "0.27.2",
        "@esbuild/linux-arm": "0.27.2",
        "@esbuild/linux-arm64": "0.27.2",
        "@esbuild/linux-ia32": "0.27.2",
        "@esbuild/linux-loong64": "0.27.2",
        "@esbuild/linux-mips64el": "0.27.2",
        "@esbuild/linux-ppc64": "0.27.2",
        "@esbuild/linux-riscv64": "0.27.2",
        "@esbuild/linux-s390x": "0.27.2",
        "@esbuild/linux-x64": "0.27.2",
        "@esbuild/netbsd-arm64": "0.27.2",
        "@esbuild/netbsd-x64": "0.27.2",
        "@esbuild/openbsd-arm64": "0.27.2",
        "@esbuild/openbsd-x64": "0.27.2",
        "@esbuild/openharmony-arm64": "0.27.2",
        "@esbuild/sunos-x64": "0.27.2",
        "@esbuild/win32-arm64": "0.27.2",
        "@esbuild/win32-ia32": "0.27.2",
        "@esbuild/win32-x64": "0.27.2"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.2.tgz",
      "integrity": "sha512-LEyamqS7W5HB3ujJyvi0HQK/dtVINZvd5mAAp9eT5S/ujByGjiZLCzPcHVzuXbpJDJF/cxwHlfceVUDZ2lnSTw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.2",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-7.0.1.tgz",
      "integrity": "sha512-O0d0m04evaNzEPoSW+59Mezf8Qt0InfgGIBJnpC0h3NH/WjUAR7BIKUfysC6todmtiZ/A0oUVS8Gce0WhBrHsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.24.4",
        "@babel/parser": "^7.24.4",
        "hermes-parser": "^0.25.1",
        "zod": "^3.25.0 || ^4.0.0",
        "zod-validation-error": "^3.5.0 || ^4.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react-refresh": {
      "version": "0.5.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-refresh/-/eslint-plugin-react-refresh-0.5.0.tgz",
      "integrity": "sha512-ZYvmh7VfVgqR/7wR71I3Zl6hK/C5CcxdWYKZSpHawS5JCNgE4efhQWg/+/WPpgGAp9Ngp/rRZYyaIwmPQBq/lA==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "eslint": ">=9"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
      "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estree-walker": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-2.0.2.tgz",
      "integrity": "sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-uri": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/fast-uri/-/fast-uri-3.1.0.tgz",
      "integrity": "sha512-iPeeDKJSWf4IEOasVVrknXpaBV0IApz/gp7S2bb7Z4Lljbl2MGJRqInZiUrQwV16cpzw/D3S5j5Julj/gT52AA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fastify"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fastify"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/file-selector": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/file-selector/-/file-selector-2.1.2.tgz",
      "integrity": "sha512-QgXo+mXTe8ljeqUFaX3QVHc5osSItJ/Km+xpocx0aSqWGMSCf6qYs/VnzZgS864Pjn5iceMRFigeAV7AfTlaig==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.7.0"
      },
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/filelist": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/filelist/-/filelist-1.0.4.tgz",
      "integrity": "sha512-w1cEuf3S+DrLCQL7ET6kz+gmlJdbq9J7yXCSjK/OZCPA+qEN1WyF4ZAf0YYJa4/shHJra2t/d/r8SV4Ji+x+8Q==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "minimatch": "^5.0.1"
      }
    },
    "node_modules/filelist/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/filelist/node_modules/minimatch": {
      "version": "5.1.6",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.1.6.tgz",
      "integrity": "sha512-lKwV/1brpG6mBUFHtb7NUmtABCb2WZZmm2wNiOA5hAb8VdCS4B3dtMWyvcoViccwAW/COERjXLt0zP1zXUN26g==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatbuffers": {
      "version": "25.9.23",
      "resolved": "https://registry.npmjs.org/flatbuffers/-/flatbuffers-25.9.23.tgz",
      "integrity": "sha512-MI1qs7Lo4Syw0EOzUl0xjs2lsoeqFku44KpngfIduHBYvzm8h2+7K8YMQh1JtVVVrUvhLpNwqVi4DERegUJhPQ==",
      "license": "Apache-2.0"
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/for-each": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.5.tgz",
      "integrity": "sha512-dKx12eRCVIzqCxFGplyFKJMPvLEWgmNtUrpTiJIR5u97zEhRG8ySrtboPHZXx7daLxQVrl643cTzbab2tkQjxg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-callable": "^1.2.7"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/foreground-child": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "cross-spawn": "^7.0.6",
        "signal-exit": "^4.0.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/fs-extra": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-9.1.0.tgz",
      "integrity": "sha512-hcg3ZmepS30/7BSFqRvoo3DOMQu7IjqxO5nCDt+zM9XWjb33Wg7ziNT+Qvqbuc3+gWpzO02JubVyk2G4Zvo1OQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "at-least-node": "^1.0.0",
        "graceful-fs": "^4.2.0",
        "jsonfile": "^6.0.1",
        "universalify": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/function.prototype.name": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/function.prototype.name/-/function.prototype.name-1.1.8.tgz",
      "integrity": "sha512-e5iwyodOHhbMr/yNrc7fDYG4qlbIvI5gajyzPnb5TCwyhjApznQh1BMFou9b30SevY43gCJKXycoCBjMbsuW0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "functions-have-names": "^1.2.3",
        "hasown": "^2.0.2",
        "is-callable": "^1.2.7"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/functions-have-names": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/functions-have-names/-/functions-have-names-1.2.3.tgz",
      "integrity": "sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/generator-function": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/generator-function/-/generator-function-2.0.1.tgz",
      "integrity": "sha512-SFdFmIJi+ybC0vjlHN0ZGVGHc3lgE0DxPAT0djjVg+kjOnSqclqmj0KQ7ykTOLP6YxoqOvuAODGdcHJn+43q3g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-nonce": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-nonce/-/get-nonce-1.0.1.tgz",
      "integrity": "sha512-FJhYRoDaiatfEkUK8HKlicmu/3SGFD51q3itKDGoSTysQJBnfOcxU5GxnhE1E6soB76MbT0MBtnKJuXyAx+96Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/get-own-enumerable-property-symbols": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/get-own-enumerable-property-symbols/-/get-own-enumerable-property-symbols-3.0.2.tgz",
      "integrity": "sha512-I0UBV/XOz1XkIJHEUDMZAbzCThU/H8DxmSfmdGcKPnVhu2VfFqr34jr9777IyaTYvxjedWhqVIilEDsCdP5G6g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/get-symbol-description": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/get-symbol-description/-/get-symbol-description-1.1.0.tgz",
      "integrity": "sha512-w9UMqWwJxHNOvoNzSJ2oPF5wvYcvP7jUvYzhp67yEhTi17ZDBBC1z9pTdGuzjD+EFIqLSYRweZjqfiPzQ06Ebg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/glob": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/glob/-/glob-11.1.0.tgz",
      "integrity": "sha512-vuNwKSaKiqm7g0THUBu2x7ckSs3XJLXE+2ssL7/MfTGPLLcrJQ/4Uq1CjPTtO5cCIiRxqvN6Twy1qOwhL0Xjcw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "foreground-child": "^3.3.1",
        "jackspeak": "^4.1.1",
        "minimatch": "^10.1.1",
        "minipass": "^7.1.2",
        "package-json-from-dist": "^1.0.0",
        "path-scurry": "^2.0.0"
      },
      "bin": {
        "glob": "dist/esm/bin.mjs"
      },
      "engines": {
        "node": "20 || >=22"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/glob/node_modules/minimatch": {
      "version": "10.1.1",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-10.1.1.tgz",
      "integrity": "sha512-enIvLvRAFZYXJzkCYG5RKmPfrFArdLv+R+lbQ53BmIMLIry74bjKzX6iHAm8WYamJkhSSEabrWN5D97XnKObjQ==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/brace-expansion": "^5.0.0"
      },
      "engines": {
        "node": "20 || >=22"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/globals": {
      "version": "17.3.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-17.3.0.tgz",
      "integrity": "sha512-yMqGUQVVCkD4tqjOJf3TnrvaaHDMYp4VlUSObbkIiuCPe/ofdMBFIAcBbCSRFWOnos6qRiTVStDwqPLUclaxIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globalthis": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/globalthis/-/globalthis-1.0.4.tgz",
      "integrity": "sha512-DpLKbNU4WylpxJykQujfCcwYWiV/Jhm50Goo0wrVILAv5jOr9d+H+UR3PhSCD2rCCEIg0uc+G+muBTwD54JhDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-properties": "^1.2.1",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "license": "ISC"
    },
    "node_modules/has-bigints": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-bigints/-/has-bigints-1.1.0.tgz",
      "integrity": "sha512-R3pbpkcIqv2Pm3dUwgjclDRVmWpTJW2DcMzcIhEXEx1oh/CEMObMm3KLmRJOdvhM7o4uQBnwr8pzRK2sJWIqfg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-property-descriptors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-define-property": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-proto": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/has-proto/-/has-proto-1.2.0.tgz",
      "integrity": "sha512-KIL7eQPfHQRC8+XluaIw7BHUwwqL19bQn4hzNgdr+1wXoU0KKj6rufu47lhY7KbJR2C6T6+PfyN0Ea7wkSS+qQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hermes-estree": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-estree/-/hermes-estree-0.25.1.tgz",
      "integrity": "sha512-0wUoCcLp+5Ev5pDW2OriHC2MJCbwLwuRx+gAqMTOkGKJJiBCLjtrvy4PWUGn6MIVefecRpzoOZ/UV6iGdOr+Cw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/hermes-parser": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-parser/-/hermes-parser-0.25.1.tgz",
      "integrity": "sha512-6pEjquH3rqaI6cYAXYPcz9MS4rY6R4ngRgrgfDshRptUZIc3lw0MCIJIGDj9++mfySOuPTHB4nrSW99BCvOPIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hermes-estree": "0.25.1"
      }
    },
    "node_modules/idb": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/idb/-/idb-7.1.1.tgz",
      "integrity": "sha512-gchesWBzyvGHRO9W8tzUWFDycow5gwjvFKfyV9FF32Y7F50yZMp7mP+T2mJIWFx49zicqyC4uefHM17o6xKIVQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/immediate": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/immediate/-/immediate-3.0.6.tgz",
      "integrity": "sha512-XXOFtyqDjNDAQxVfYxuF7g9Il/IbWmmlQg2MYKOH8ExIT1qg6xc4zyS3HaEEATgs1btfzxq15ciUiY7gjSXRGQ==",
      "license": "MIT"
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/internal-slot": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/internal-slot/-/internal-slot-1.1.0.tgz",
      "integrity": "sha512-4gd7VpWNQNB4UKKCFFVcp1AVv+FMOgs9NKzjHKusc8jTMhd5eL1NqQqOpE0KzMds804/yHlglp3uxgluOqAPLw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "hasown": "^2.0.2",
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/is-array-buffer": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/is-array-buffer/-/is-array-buffer-3.0.5.tgz",
      "integrity": "sha512-DDfANUiiG2wC1qawP66qlTugJeL5HyzMpfr8lLK+jMQirGzNod0B12cFB/9q838Ru27sBwfw78/rdoU7RERz6A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-async-function": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-async-function/-/is-async-function-2.1.1.tgz",
      "integrity": "sha512-9dgM/cZBnNvjzaMYHVoxxfPj2QXt22Ev7SuuPrs+xav0ukGB0S6d4ydZdEiM48kLx5kDV+QBPrpVnFyefL8kkQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "async-function": "^1.0.0",
        "call-bound": "^1.0.3",
        "get-proto": "^1.0.1",
        "has-tostringtag": "^1.0.2",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-bigint": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-bigint/-/is-bigint-1.1.0.tgz",
      "integrity": "sha512-n4ZT37wG78iz03xPRKJrHTdZbe3IicyucEtdRsV5yglwc3GyUfbAfpSeD0FJ41NbUNSt5wbhqfp1fS+BgnvDFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-bigints": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-boolean-object": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.2.2.tgz",
      "integrity": "sha512-wa56o2/ElJMYqjCjGkXri7it5FbebW5usLw/nPmCMs5DeZ7eziSYZhSmPRn0txqeW4LnAmQQU7FgqLpsEFKM4A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-callable": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-data-view": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-data-view/-/is-data-view-1.0.2.tgz",
      "integrity": "sha512-RKtWF8pGmS87i2D6gqQu/l7EYRlVdfzemCJN/P3UOs//x1QE7mfhvzHIApBTRf7axvT6DMGwSwBXYCT0nfB9xw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "get-intrinsic": "^1.2.6",
        "is-typed-array": "^1.1.13"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-date-object": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.1.0.tgz",
      "integrity": "sha512-PwwhEakHVKTdRNVOw+/Gyh0+MzlCl4R6qKvkhuvLtPMggI1WAHt9sOwZxQLSGpUaDnrdyDsomoRgNnCfKNSXXg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-finalizationregistry": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-finalizationregistry/-/is-finalizationregistry-1.1.1.tgz",
      "integrity": "sha512-1pC6N8qWJbWoPtEjgcL2xyhQOP491EQjeUo3qTKcmV8YSDDJrOepfG8pcC7h/QgnQHYSv0mJ3Z/ZWxmatVrysg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-generator-function": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.1.2.tgz",
      "integrity": "sha512-upqt1SkGkODW9tsGNG5mtXTXtECizwtS2kA161M+gJPc1xdb/Ax629af6YrTwcOeQHbewrPNlE5Dx7kzvXTizA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.4",
        "generator-function": "^2.0.0",
        "get-proto": "^1.0.1",
        "has-tostringtag": "^1.0.2",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-map": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-map/-/is-map-2.0.3.tgz",
      "integrity": "sha512-1Qed0/Hr2m+YqxnM09CjA2d/i6YZNfF6R2oRAOj36eUdS6qIV/huPJNSEpKbupewFs+ZsJlxsjjPbc0/afW6Lw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-module": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-module/-/is-module-1.0.0.tgz",
      "integrity": "sha512-51ypPSPCoTEIN9dy5Oy+h4pShgJmPCygKfyRCISBI+JoWT/2oJvK8QPxmwv7b/p239jXrm9M1mlQbyKJ5A152g==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/is-negative-zero": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-negative-zero/-/is-negative-zero-2.0.3.tgz",
      "integrity": "sha512-5KoIu2Ngpyek75jXodFvnafB6DJgr3u8uuK0LEZJjrU19DrMD3EVERaR8sjz8CCGgpZvxPl9SuE1GMVPFHx1mw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-number-object": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-number-object/-/is-number-object-1.1.1.tgz",
      "integrity": "sha512-lZhclumE1G6VYD8VHe35wFaIif+CTy5SJIi5+3y4psDgWu4wPDoBhF8NxUOinEc7pHgiTsT6MaBb92rKhhD+Xw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-obj": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/is-obj/-/is-obj-1.0.1.tgz",
      "integrity": "sha512-l4RyHgRqGN4Y3+9JHVrNqO+tN0rV5My76uW5/nuO4K1b6vw5G8d/cmFjP9tRfEsdhZNt0IFdZuK/c2Vr4Nb+Qg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-regex": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.2.1.tgz",
      "integrity": "sha512-MjYsKHO5O7mCsmRGxWcLWheFqN9DJ/2TmngvjKXihe6efViPqc274+Fx/4fYj/r03+ESvBdTXK0V6tA3rgez1g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "gopd": "^1.2.0",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-regexp": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-regexp/-/is-regexp-1.0.0.tgz",
      "integrity": "sha512-7zjFAPO4/gwyQAAgRRmqeEeyIICSdmCqa3tsVHMdBzaXXRiqopZL4Cyghg/XulGWrtABTpbnYYzzIRffLkP4oA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-set": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-set/-/is-set-2.0.3.tgz",
      "integrity": "sha512-iPAjerrse27/ygGLxw+EBR9agv9Y6uLeYVJMu+QNCoouJ1/1ri0mGrcWpfCqFZuzzx3WjtwxG098X+n4OuRkPg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-shared-array-buffer": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/is-shared-array-buffer/-/is-shared-array-buffer-1.0.4.tgz",
      "integrity": "sha512-ISWac8drv4ZGfwKl5slpHG9OwPNty4jOWPRIhBpxOoD+hqITiwuipOQ2bNthAzwA3B4fIjO4Nln74N0S9byq8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/is-string": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-string/-/is-string-1.1.1.tgz",
      "integrity": "sha512-BtEeSsoaQjlSPBemMQIrY1MY0uM6vnS1g5fmufYOtnxLGUZM2178PKbhsk7Ffv58IX+ZtcvoGwccYsh0PglkAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-symbol": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.1.1.tgz",
      "integrity": "sha512-9gGx6GTtCQM73BgmHQXfDmLtfjjTUDSyoxTCbp5WtoixAhfgsDirWIcVQ/IHpvI5Vgd5i/J5F7B9cN/WlVbC/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "has-symbols": "^1.1.0",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-typed-array": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.15.tgz",
      "integrity": "sha512-p3EcsicXjit7SaskXHs1hA91QxgTw46Fv6EFKKGS5DRFLD8yKnohjF3hxoju94b/OcMZoQukzpPpBE9uLVKzgQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "which-typed-array": "^1.1.16"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakmap": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.2.tgz",
      "integrity": "sha512-K5pXYOm9wqY1RgjpL3YTkF39tni1XajUIkawTLUo9EZEVUFga5gSQJF8nNS7ZwJQ02y+1YCNYcMh+HIf1ZqE+w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-weakref/-/is-weakref-1.1.1.tgz",
      "integrity": "sha512-6i9mGWSlqzNMEqpCp93KwRS1uUOodk2OJ6b+sq7ZPDSy2WuI5NFIxp/254TytR8ftefexkWn5xNiHUNpPOfSew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakset": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-weakset/-/is-weakset-2.0.4.tgz",
      "integrity": "sha512-mfcwb6IzQyOKTs84CQMrOwW4gQcaTOAWJ0zzJCl2WSPDrWk/OzDaImWFH3djXhb24g4eudZfLRozAvPGw4d9hQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==",
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/jackspeak": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-4.1.1.tgz",
      "integrity": "sha512-zptv57P3GpL+O0I7VdMJNBZCu+BPHVQUk55Ft8/QCJjTVxrnJHuVuX/0Bl2A6/+2oyR/ZMEuFKwmzqqZ/U5nPQ==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/cliui": "^8.0.2"
      },
      "engines": {
        "node": "20 || >=22"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/jake": {
      "version": "10.9.4",
      "resolved": "https://registry.npmjs.org/jake/-/jake-10.9.4.tgz",
      "integrity": "sha512-wpHYzhxiVQL+IV05BLE2Xn34zW1S223hvjtqk0+gsPrwd/8JNLXJgZZM/iPFsYc1xyphF+6M6EvdE5E9MBGkDA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "async": "^3.2.6",
        "filelist": "^1.0.4",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "jake": "bin/cli.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/jiti": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.6.1.tgz",
      "integrity": "sha512-ekilCSN1jwRvIbgeg/57YFh8qQDNbwDb9xT/qu2DAHbFFZUicIl4ygVaAvzveMhMVr3LnpSKTNnwt8PoOfmKhQ==",
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/json-schema/-/json-schema-0.4.0.tgz",
      "integrity": "sha512-es94M3nTIfsEPisRafak+HDLfHXnKBhV3vU5eqPcS3flIWqcxJWgXHXiey3YrpaNsanY5ei1VoYEbOzijuq9BA==",
      "dev": true,
      "license": "(AFL-2.1 OR BSD-3-Clause)"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jsonfile": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-6.2.0.tgz",
      "integrity": "sha512-FGuPw30AdOIUTRMC2OMRtQV+jkVj2cfPqSeWXv1NEAJ1qZ5zb1X6z1mFhbfOB/iy3ssJCD+3KuZ8r8C3uVFlAg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "universalify": "^2.0.0"
      },
      "optionalDependencies": {
        "graceful-fs": "^4.1.6"
      }
    },
    "node_modules/jsonpointer": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/jsonpointer/-/jsonpointer-5.0.1.tgz",
      "integrity": "sha512-p/nXbhSEcu3pZRdkW1OfJhpsVtW1gd4Wa1fnQc9YLiTfAjn0312eMKimbdIQzuZl9aa9xUGaRlP9T/CJE/ditQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/jszip": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/jszip/-/jszip-3.10.1.tgz",
      "integrity": "sha512-xXDvecyTpGLrqFrvkrUSoxxfJI5AH7U8zxxtVclpsUtMCq4JQ290LY8AW5c7Ggnr/Y/oK+bQMbqK2qmtk3pN4g==",
      "license": "(MIT OR GPL-3.0-or-later)",
      "dependencies": {
        "lie": "~3.3.0",
        "pako": "~1.0.2",
        "readable-stream": "~2.3.6",
        "setimmediate": "^1.0.5"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/leven": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/leven/-/leven-3.1.0.tgz",
      "integrity": "sha512-qsda+H8jTaUaN/x5vzW2rzc+8Rw4TAQ/4KjB46IwK5VH+IlVeeeje/EoZRpiXvIqjFgK84QffqPztGI3VBLG1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lie": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/lie/-/lie-3.3.0.tgz",
      "integrity": "sha512-UaiMJzeWRlEujzAuw5LokY1L5ecNQYZKfmyZ9L7wDHb/p5etKaxXhohBcrw0EYby+G/NA52vRSN4N39dxHAIwQ==",
      "license": "MIT",
      "dependencies": {
        "immediate": "~3.0.5"
      }
    },
    "node_modules/lightningcss": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss/-/lightningcss-1.30.2.tgz",
      "integrity": "sha512-utfs7Pr5uJyyvDETitgsaqSyjCb2qNRAtuqUeWIAKztsOYdcACf2KtARYXg2pSvhkt+9NfoaNY7fxjl6nuMjIQ==",
      "license": "MPL-2.0",
      "dependencies": {
        "detect-libc": "^2.0.3"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      },
      "optionalDependencies": {
        "lightningcss-android-arm64": "1.30.2",
        "lightningcss-darwin-arm64": "1.30.2",
        "lightningcss-darwin-x64": "1.30.2",
        "lightningcss-freebsd-x64": "1.30.2",
        "lightningcss-linux-arm-gnueabihf": "1.30.2",
        "lightningcss-linux-arm64-gnu": "1.30.2",
        "lightningcss-linux-arm64-musl": "1.30.2",
        "lightningcss-linux-x64-gnu": "1.30.2",
        "lightningcss-linux-x64-musl": "1.30.2",
        "lightningcss-win32-arm64-msvc": "1.30.2",
        "lightningcss-win32-x64-msvc": "1.30.2"
      }
    },
    "node_modules/lightningcss-android-arm64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-android-arm64/-/lightningcss-android-arm64-1.30.2.tgz",
      "integrity": "sha512-BH9sEdOCahSgmkVhBLeU7Hc9DWeZ1Eb6wNS6Da8igvUwAe0sqROHddIlvU06q3WyXVEOYDZ6ykBZQnjTbmo4+A==",
      "cpu": [
        "arm64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-darwin-arm64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-arm64/-/lightningcss-darwin-arm64-1.30.2.tgz",
      "integrity": "sha512-ylTcDJBN3Hp21TdhRT5zBOIi73P6/W0qwvlFEk22fkdXchtNTOU4Qc37SkzV+EKYxLouZ6M4LG9NfZ1qkhhBWA==",
      "cpu": [
        "arm64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-darwin-x64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-x64/-/lightningcss-darwin-x64-1.30.2.tgz",
      "integrity": "sha512-oBZgKchomuDYxr7ilwLcyms6BCyLn0z8J0+ZZmfpjwg9fRVZIR5/GMXd7r9RH94iDhld3UmSjBM6nXWM2TfZTQ==",
      "cpu": [
        "x64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-freebsd-x64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-freebsd-x64/-/lightningcss-freebsd-x64-1.30.2.tgz",
      "integrity": "sha512-c2bH6xTrf4BDpK8MoGG4Bd6zAMZDAXS569UxCAGcA7IKbHNMlhGQ89eRmvpIUGfKWNVdbhSbkQaWhEoMGmGslA==",
      "cpu": [
        "x64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm-gnueabihf": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm-gnueabihf/-/lightningcss-linux-arm-gnueabihf-1.30.2.tgz",
      "integrity": "sha512-eVdpxh4wYcm0PofJIZVuYuLiqBIakQ9uFZmipf6LF/HRj5Bgm0eb3qL/mr1smyXIS1twwOxNWndd8z0E374hiA==",
      "cpu": [
        "arm"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-gnu": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-gnu/-/lightningcss-linux-arm64-gnu-1.30.2.tgz",
      "integrity": "sha512-UK65WJAbwIJbiBFXpxrbTNArtfuznvxAJw4Q2ZGlU8kPeDIWEX1dg3rn2veBVUylA2Ezg89ktszWbaQnxD/e3A==",
      "cpu": [
        "arm64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-musl": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-musl/-/lightningcss-linux-arm64-musl-1.30.2.tgz",
      "integrity": "sha512-5Vh9dGeblpTxWHpOx8iauV02popZDsCYMPIgiuw97OJ5uaDsL86cnqSFs5LZkG3ghHoX5isLgWzMs+eD1YzrnA==",
      "cpu": [
        "arm64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-gnu": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-gnu/-/lightningcss-linux-x64-gnu-1.30.2.tgz",
      "integrity": "sha512-Cfd46gdmj1vQ+lR6VRTTadNHu6ALuw2pKR9lYq4FnhvgBc4zWY1EtZcAc6EffShbb1MFrIPfLDXD6Xprbnni4w==",
      "cpu": [
        "x64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-musl": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-musl/-/lightningcss-linux-x64-musl-1.30.2.tgz",
      "integrity": "sha512-XJaLUUFXb6/QG2lGIW6aIk6jKdtjtcffUT0NKvIqhSBY3hh9Ch+1LCeH80dR9q9LBjG3ewbDjnumefsLsP6aiA==",
      "cpu": [
        "x64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-arm64-msvc": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-arm64-msvc/-/lightningcss-win32-arm64-msvc-1.30.2.tgz",
      "integrity": "sha512-FZn+vaj7zLv//D/192WFFVA0RgHawIcHqLX9xuWiQt7P0PtdFEVaxgF9rjM/IRYHQXNnk61/H/gb2Ei+kUQ4xQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-x64-msvc": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-x64-msvc/-/lightningcss-win32-x64-msvc-1.30.2.tgz",
      "integrity": "sha512-5g1yc73p+iAkid5phb4oVFMB45417DkRevRbt/El/gKXJk4jid+vPFF/AXbxn05Aky8PapwzZrdJShv5C0avjw==",
      "cpu": [
        "x64"
      ],
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.23",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.23.tgz",
      "integrity": "sha512-LgVTMpQtIopCi79SJeDiP0TfWi5CNEc/L/aRdTh3yIvmZXTnheWpKjSZhnvMl8iXbC1tFg9gdHHDMLoV7CnG+w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lodash.debounce": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/lodash.debounce/-/lodash.debounce-4.0.8.tgz",
      "integrity": "sha512-FT1yDzDYEoYWhnSGnpE/4Kj1fLZkDFyqRb7fNt6FdYOSxlUWAtp42Eh6Wb0rGIv/m9Bgo7x4GhQbm5Ys4SG5ow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lodash.sortby": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz",
      "integrity": "sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/lucide-react": {
      "version": "0.563.0",
      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.563.0.tgz",
      "integrity": "sha512-8dXPB2GI4dI8jV4MgUDGBeLdGk8ekfqVZ0BdLcrRzocGgG75ltNEmWS+gE7uokKF/0oSUuczNDT+g9hFJ23FkA==",
      "license": "ISC",
      "peerDependencies": {
        "react": "^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object-keys": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.assign": {
      "version": "4.1.7",
      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.7.tgz",
      "integrity": "sha512-nK28WOo+QIjBkDduTINE4JkF/UJJKyf2EJxvJKfblDpyg0Q+pkOHNTL0Qwy6NP6FhE/EnzV73BxxqcJaXY9anw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0",
        "has-symbols": "^1.1.0",
        "object-keys": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/own-keys": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/own-keys/-/own-keys-1.0.1.tgz",
      "integrity": "sha512-qFOyK5PjiWZd+QQIh+1jhdb9LpxTF0qs7Pm8o5QHYZ0M3vKqSqzsZaEB6oWlxZ+q2sJBMI/Ktgd2N5ZwQoRHfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "get-intrinsic": "^1.2.6",
        "object-keys": "^1.1.1",
        "safe-push-apply": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/package-json-from-dist": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
      "dev": true,
      "license": "BlueOak-1.0.0"
    },
    "node_modules/pako": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/pako/-/pako-1.0.11.tgz",
      "integrity": "sha512-4hLB8Py4zZce5s4yd9XzopqwVv/yGNhV1Bl8NTmCq1763HeK2+EwVTv+leGeL13Dnh2wfbqowVPXCIO0z4taYw==",
      "license": "(MIT AND Zlib)"
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-scurry": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-2.0.1.tgz",
      "integrity": "sha512-oWyT4gICAu+kaA7QWk/jvCHWarMKNs6pXOGWKDTr7cw4IGcUbW+PeTfbaQiLGheFRpjo6O9J0PmyMfQPjH71oA==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "lru-cache": "^11.0.0",
        "minipass": "^7.1.2"
      },
      "engines": {
        "node": "20 || >=22"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/path-scurry/node_modules/lru-cache": {
      "version": "11.2.4",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.4.tgz",
      "integrity": "sha512-B5Y16Jr9LB9dHVkh6ZevG+vAbOsNOYCX+sXvFWFu7B3Iz5mijW3zdbMyhsh8ANd2mSWBYdJgnqi+mL7/LrOPYg==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/pe-library": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/pe-library/-/pe-library-2.0.1.tgz",
      "integrity": "sha512-/qjYFqNSlq59B5DI36am++5/3gMgh02QnzpYigrwrW6s+QpU0mHf09/iA4wjTu21UUxodyV7ZCetV5MiDhaN/A==",
      "license": "MIT",
      "engines": {
        "node": ">=20"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/jet2jet"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/possible-typed-array-names": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/possible-typed-array-names/-/possible-typed-array-names-1.1.0.tgz",
      "integrity": "sha512-/+5VFTchJDoVj3bhoqi6UeymcD00DAwb1nJwamzPvHEszJ4FpF6SNNbUbOS8yI56qHzdV8eK0qEfOSiodkTdxg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/prettier": {
      "version": "3.8.1",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-3.8.1.tgz",
      "integrity": "sha512-UOnG6LftzbdaHZcKoPFtOcCKztrQ57WkHDeRD9t/PTQtmT0NHSeWWepj6pS0z/N7+08BHFDQVUrfmfMRcZwbMg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "prettier": "bin/prettier.cjs"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/prettier/prettier?sponsor=1"
      }
    },
    "node_modules/pretty-bytes": {
      "version": "6.1.1",
      "resolved": "https://registry.npmjs.org/pretty-bytes/-/pretty-bytes-6.1.1.tgz",
      "integrity": "sha512-mQUvGU6aUFQ+rNvTIAcZuWGRT9a6f6Yrg9bHs4ImKF+HZCEK+plBvnAZYSIQztknZF2qnzNtr6F8s0+IuptdlQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==",
      "license": "MIT"
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/randombytes": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "^5.1.0"
      }
    },
    "node_modules/react": {
      "version": "19.2.4",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.4.tgz",
      "integrity": "sha512-9nfp2hYpCwOjAN+8TZFGhtWEwgvWHXqESH8qT89AT/lWklpLON22Lc8pEtnpsZz7VmawabSU0gCjnj8aC0euHQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-bootstrap-icons": {
      "version": "1.11.6",
      "resolved": "https://registry.npmjs.org/react-bootstrap-icons/-/react-bootstrap-icons-1.11.6.tgz",
      "integrity": "sha512-ycXiyeSyzbS1C4+MlPTYe0riB+UlZ7LV7YZQYqlERV2cxDiKtntI0huHmP/3VVvzPt4tGxqK0K+Y6g7We3U6tQ==",
      "license": "MIT",
      "dependencies": {
        "prop-types": "^15.7.2"
      },
      "peerDependencies": {
        "react": ">=16.8.6"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.4",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.4.tgz",
      "integrity": "sha512-AXJdLo8kgMbimY95O2aKQqsz2iWi9jMgKJhRBAxECE4IFxfcazB2LmzloIoibJI3C12IlY20+KFaLv+71bUJeQ==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.4"
      }
    },
    "node_modules/react-dropzone": {
      "version": "14.4.0",
      "resolved": "https://registry.npmjs.org/react-dropzone/-/react-dropzone-14.4.0.tgz",
      "integrity": "sha512-8VvsHqg9WGAr+wAnP0oVErK5HOwAoTOzRsxLPzbBXrtXtFfukkxMyuvdI/lJ+5OxtsrzmvWE5Eoo3Y4hMsaxpA==",
      "license": "MIT",
      "dependencies": {
        "attr-accept": "^2.2.4",
        "file-selector": "^2.1.0",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">= 10.13"
      },
      "peerDependencies": {
        "react": ">= 16.8 || 18.0.0"
      }
    },
    "node_modules/react-fast-compare": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/react-fast-compare/-/react-fast-compare-3.2.2.tgz",
      "integrity": "sha512-nsO+KSNgo1SbJqJEYRE9ERzo7YtYbou/OqjSQKxV7jcKox7+usiUVZOAC+XnDOABXggQTno0Y1CpVnuWEc1boQ==",
      "license": "MIT"
    },
    "node_modules/react-helmet": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/react-helmet/-/react-helmet-6.1.0.tgz",
      "integrity": "sha512-4uMzEY9nlDlgxr61NL3XbKRy1hEkXmKNXhjbAIOVw5vcFrsdYbH2FEwcNyWvWinl103nXgzYNlns9ca+8kFiWw==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4.1.1",
        "prop-types": "^15.7.2",
        "react-fast-compare": "^3.1.1",
        "react-side-effect": "^2.1.0"
      },
      "peerDependencies": {
        "react": ">=16.3.0"
      }
    },
    "node_modules/react-helmet/node_modules/react-side-effect": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/react-side-effect/-/react-side-effect-2.1.2.tgz",
      "integrity": "sha512-PVjOcvVOyIILrYoyGEpDN3vmYNLdy1CajSFNt4TDsVQC5KpTijDvWVoR+/7Rz2xT978D8/ZtFceXxzsPwZEDvw==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.3.0 || ^17.0.0 || ^18.0.0"
      }
    },
    "node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/react-refresh": {
      "version": "0.18.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.18.0.tgz",
      "integrity": "sha512-QgT5//D3jfjJb6Gsjxv0Slpj23ip+HtOpnNgnb2S5zU3CB26G/IDPGoy4RJB42wzFE46DRsstbW6tKHoKbhAxw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-remove-scroll": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/react-remove-scroll/-/react-remove-scroll-2.6.3.tgz",
      "integrity": "sha512-pnAi91oOk8g8ABQKGF5/M9qxmmOPxaAnopyTHYfqYEwJhyFrbbBtHuSgtKEoH0jpcxx5o3hXqH1mNd9/Oi+8iQ==",
      "license": "MIT",
      "dependencies": {
        "react-remove-scroll-bar": "^2.3.7",
        "react-style-singleton": "^2.2.3",
        "tslib": "^2.1.0",
        "use-callback-ref": "^1.3.3",
        "use-sidecar": "^1.1.3"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-remove-scroll-bar": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/react-remove-scroll-bar/-/react-remove-scroll-bar-2.3.8.tgz",
      "integrity": "sha512-9r+yi9+mgU33AKcj6IbT9oRCO78WriSj6t/cF8DWBZJ9aOGPOTEDvdUDz1FwKim7QXWwmHqtdHnRJfhAxEG46Q==",
      "license": "MIT",
      "dependencies": {
        "react-style-singleton": "^2.2.2",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-router": {
      "version": "7.13.0",
      "resolved": "https://registry.npmjs.org/react-router/-/react-router-7.13.0.tgz",
      "integrity": "sha512-PZgus8ETambRT17BUm/LL8lX3Of+oiLaPuVTRH3l1eLvSPpKO3AvhAEb5N7ihAFZQrYDqkvvWfFh9p0z9VsjLw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "^1.0.1",
        "set-cookie-parser": "^2.6.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      },
      "peerDependenciesMeta": {
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/react-router-dom": {
      "version": "7.13.0",
      "resolved": "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.13.0.tgz",
      "integrity": "sha512-5CO/l5Yahi2SKC6rGZ+HDEjpjkGaG/ncEP7eWFTvFxbHP8yeeI0PxTDjimtpXYlR3b3i9/WIL4VJttPrESIf2g==",
      "license": "MIT",
      "dependencies": {
        "react-router": "7.13.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      }
    },
    "node_modules/react-style-singleton": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/react-style-singleton/-/react-style-singleton-2.2.3.tgz",
      "integrity": "sha512-b6jSvxvVnyptAiLjbkWLE/lOnR4lfTtDAl+eUC7RZy+QQWc6wRzIV2CE6xBuMmDxc2qIihtDCZD5NPOFl7fRBQ==",
      "license": "MIT",
      "dependencies": {
        "get-nonce": "^1.0.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-window": {
      "version": "2.2.6",
      "resolved": "https://registry.npmjs.org/react-window/-/react-window-2.2.6.tgz",
      "integrity": "sha512-v89O08xRdpCaEuf380B39D1C/0KgUDZA59xft6SVAjzjz/xQxSyXrgDWHymIsYI6TMrqE8WO+G0/PB9AGE8VNA==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0",
        "react-dom": "^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/reflect.getprototypeof": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/reflect.getprototypeof/-/reflect.getprototypeof-1.0.10.tgz",
      "integrity": "sha512-00o4I+DVrefhv+nX0ulyi3biSHCPDe+yLv5o/p6d/UVlirijB8E16FtfwSAi4g3tcqrQ4lRAqQSoFEZJehYEcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.9",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.7",
        "get-proto": "^1.0.1",
        "which-builtin-type": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/regenerate": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/regenerate/-/regenerate-1.4.2.tgz",
      "integrity": "sha512-zrceR/XhGYU/d/opr2EKO7aRHUeiBI8qjtfHqADTwZd6Szfy16la6kqD0MIUs5z5hx6AaKa+PixpPrR289+I0A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/regenerate-unicode-properties": {
      "version": "10.2.2",
      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-10.2.2.tgz",
      "integrity": "sha512-m03P+zhBeQd1RGnYxrGyDAPpWX/epKirLrp8e3qevZdVkKtnCrjjWczIbYc8+xd6vcTStVlqfycTx1KR4LOr0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "regenerate": "^1.4.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/regexp.prototype.flags": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.5.4.tgz",
      "integrity": "sha512-dYqgNSZbDwkaJ2ceRd9ojCGjBq+mOm9LmtXnAnEGyHhN/5R7iDW2TRw3h+o/jCFxus3P2LfWIIiwowAjANm7IA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-errors": "^1.3.0",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "set-function-name": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/regexpu-core": {
      "version": "6.4.0",
      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-6.4.0.tgz",
      "integrity": "sha512-0ghuzq67LI9bLXpOX/ISfve/Mq33a4aFRzoQYhnnok1JOFpmE/A2TBGkNVenOGEeSBCjIiWcc6MVOG5HEQv0sA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "regenerate": "^1.4.2",
        "regenerate-unicode-properties": "^10.2.2",
        "regjsgen": "^0.8.0",
        "regjsparser": "^0.13.0",
        "unicode-match-property-ecmascript": "^2.0.0",
        "unicode-match-property-value-ecmascript": "^2.2.1"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/regjsgen": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.8.0.tgz",
      "integrity": "sha512-RvwtGe3d7LvWiDQXeQw8p5asZUmfU1G/l6WbUXeHta7Y2PEIvBTwH6E2EfmYUK8pxcxEdEmaomqyp0vZZ7C+3Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/regjsparser": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.13.0.tgz",
      "integrity": "sha512-NZQZdC5wOE/H3UT28fVGL+ikOZcEzfMGk/c3iN9UGxzWHMa1op7274oyiUVrAG4B2EuFhus8SvkaYnhvW92p9Q==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "jsesc": "~3.1.0"
      },
      "bin": {
        "regjsparser": "bin/parser"
      }
    },
    "node_modules/require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/rollup": {
      "version": "4.46.3",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.46.3.tgz",
      "integrity": "sha512-RZn2XTjXb8t5g13f5YclGoilU/kwT696DIkY3sywjdZidNSi3+vseaQov7D7BZXVJCPv3pDWUN69C78GGbXsKw==",
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.46.3",
        "@rollup/rollup-android-arm64": "4.46.3",
        "@rollup/rollup-darwin-arm64": "4.46.3",
        "@rollup/rollup-darwin-x64": "4.46.3",
        "@rollup/rollup-freebsd-arm64": "4.46.3",
        "@rollup/rollup-freebsd-x64": "4.46.3",
        "@rollup/rollup-linux-arm-gnueabihf": "4.46.3",
        "@rollup/rollup-linux-arm-musleabihf": "4.46.3",
        "@rollup/rollup-linux-arm64-gnu": "4.46.3",
        "@rollup/rollup-linux-arm64-musl": "4.46.3",
        "@rollup/rollup-linux-loongarch64-gnu": "4.46.3",
        "@rollup/rollup-linux-ppc64-gnu": "4.46.3",
        "@rollup/rollup-linux-riscv64-gnu": "4.46.3",
        "@rollup/rollup-linux-riscv64-musl": "4.46.3",
        "@rollup/rollup-linux-s390x-gnu": "4.46.3",
        "@rollup/rollup-linux-x64-gnu": "4.46.3",
        "@rollup/rollup-linux-x64-musl": "4.46.3",
        "@rollup/rollup-win32-arm64-msvc": "4.46.3",
        "@rollup/rollup-win32-ia32-msvc": "4.46.3",
        "@rollup/rollup-win32-x64-msvc": "4.46.3",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/safe-array-concat": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/safe-array-concat/-/safe-array-concat-1.1.3.tgz",
      "integrity": "sha512-AURm5f0jYEOydBj7VQlVvDrjeFgthDdEF5H1dP+6mNpoXOMo1quQqJ4wvJDyRZ9+pO3kGWoOdmV08cSv2aJV6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "get-intrinsic": "^1.2.6",
        "has-symbols": "^1.1.0",
        "isarray": "^2.0.5"
      },
      "engines": {
        "node": ">=0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-array-concat/node_modules/isarray": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz",
      "integrity": "sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/safe-push-apply": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/safe-push-apply/-/safe-push-apply-1.0.0.tgz",
      "integrity": "sha512-iKE9w/Z7xCzUMIZqdBsp6pEQvwuEebH4vdpjcDWnyzaI6yl6O9FHvVpmGelvEHNsoY6wGblkxR6Zty/h00WiSA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "isarray": "^2.0.5"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-push-apply/node_modules/isarray": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz",
      "integrity": "sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/safe-regex-test": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/safe-regex-test/-/safe-regex-test-1.1.0.tgz",
      "integrity": "sha512-x/+Cz4YrimQxQccJf5mKEbIa1NzeCRNI5Ecl/ekmlYaampdNLPalVyIcCZNNH3MvmqBugV5TMYZXv0ljslUlaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "is-regex": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/serialize-javascript": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.2.tgz",
      "integrity": "sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "randombytes": "^2.1.0"
      }
    },
    "node_modules/set-cookie-parser": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.2.tgz",
      "integrity": "sha512-oeM1lpU/UvhTxw+g3cIfxXHyJRc/uidd3yK1P242gzHds0udQBYzs3y8j4gCCW+ZJ7ad0yctld8RYO+bdurlvw==",
      "license": "MIT"
    },
    "node_modules/set-function-length": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "gopd": "^1.0.1",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/set-function-name": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/set-function-name/-/set-function-name-2.0.2.tgz",
      "integrity": "sha512-7PGFlmtwsEADb0WYyvCMa1t+yke6daIG4Wirafur5kcf+MhUnPms1UeR0CKQdTZD81yESwMHbtn+TR+dMviakQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "functions-have-names": "^1.2.3",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/set-proto": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/set-proto/-/set-proto-1.0.0.tgz",
      "integrity": "sha512-RJRdvCo6IAnPdsvP/7m6bsQqNnn1FCBX5ZNtFL98MmFF/4xAIJTIg1YbHW5DC2W5SKZanrC6i4HsJqlajw/dZw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/setimmediate": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/setimmediate/-/setimmediate-1.0.5.tgz",
      "integrity": "sha512-MATJdZp8sLqDl/68LfQmbP8zKPLQNV6BIZoIgrscFDQ+RsvK/BxeDQOgyxKKoh0y/8h3BqVFnCqQ/gd+reiIXA==",
      "license": "MIT"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shell-quote": {
      "version": "1.8.3",
      "resolved": "https://registry.npmjs.org/shell-quote/-/shell-quote-1.8.3.tgz",
      "integrity": "sha512-ObmnIF4hXNg1BqhnHmgbDETF8dLPCggZWBjkQfhZpbszZnYur5DUljTcCHii5LC3J5E0yeO/1LIMyH+UvHQgyw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/smob": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/smob/-/smob-1.5.0.tgz",
      "integrity": "sha512-g6T+p7QO8npa+/hNx9ohv1E5pVCmWrVCUzUXJyLdMmftX6ER0oiWY/w9knEonLpnOp6b6FenKnMfR8gqwWdwig==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/source-map": {
      "version": "0.8.0-beta.0",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.8.0-beta.0.tgz",
      "integrity": "sha512-2ymg6oRBpebeZi9UUNsgQ89bhx01TcTkmNTGnNO88imTmbSgy4nfujrgVEFKWpMTEGA11EDkTt7mqObTPdigIA==",
      "deprecated": "The work that was done in this beta branch won't be included in future versions",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "whatwg-url": "^7.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.21",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
      "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/source-map-support/node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "devOptional": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/sourcemap-codec": {
      "version": "1.4.8",
      "resolved": "https://registry.npmjs.org/sourcemap-codec/-/sourcemap-codec-1.4.8.tgz",
      "integrity": "sha512-9NykojV5Uih4lgo5So5dtw+f0JgJX30KCNI8gwhz2J9A15wD0Ml6tjHKwf6fTSa6fAdVBdZeNOs9eJ71qCk8vA==",
      "deprecated": "Please use @jridgewell/sourcemap-codec instead",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/stop-iteration-iterator": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/stop-iteration-iterator/-/stop-iteration-iterator-1.1.0.tgz",
      "integrity": "sha512-eLoXW/DHyl62zxY4SCaIgnRhuMr6ri4juEYARS8E6sCEqzKpOiE521Ucofdx+KnDZl5xmvGYaaKCk5FEOxJCoQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "internal-slot": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/string-width": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width-cjs": {
      "name": "string-width",
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width-cjs/node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width-cjs/node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string.prototype.matchall": {
      "version": "4.0.12",
      "resolved": "https://registry.npmjs.org/string.prototype.matchall/-/string.prototype.matchall-4.0.12.tgz",
      "integrity": "sha512-6CC9uyBL+/48dYizRf7H7VAYCMCNTBeM78x/VTUe9bFEaxBepPJDa1Ow99LqI/1yF7kuy7Q3cQsYMrcjGUcskA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.6",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.6",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "internal-slot": "^1.1.0",
        "regexp.prototype.flags": "^1.5.3",
        "set-function-name": "^2.0.2",
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trim": {
      "version": "1.2.10",
      "resolved": "https://registry.npmjs.org/string.prototype.trim/-/string.prototype.trim-1.2.10.tgz",
      "integrity": "sha512-Rs66F0P/1kedk5lyYyH9uBzuiI/kNRmwJAR9quK6VOtIpZ2G+hMZd+HQbbv25MgCA6gEffoMZYxlTod4WcdrKA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "define-data-property": "^1.1.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-object-atoms": "^1.0.0",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trimend": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.9.tgz",
      "integrity": "sha512-G7Ok5C6E/j4SGfyLCloXTrngQIQU3PWtXGst3yM7Bea9FRURf1S42ZHlZZtsNque2FN2PoUhfZXYLNWwEr4dLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trimstart": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.8.tgz",
      "integrity": "sha512-UXSH262CSZY1tfu3G3Secr6uGLCFVPMhIqHjlgCUtCCcgihYc/xKs9djMTMUOb2j1mVSeU8EU6NWc/iQKU6Gfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/stringify-object": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/stringify-object/-/stringify-object-3.3.0.tgz",
      "integrity": "sha512-rHqiFh1elqCQ9WPLIC8I0Q/g/wj5J1eMkyoiD6eoQApWHP0FtlK7rqnhmabL5VUY9JQCcqwwvlOaSuutekgyrw==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "get-own-enumerable-property-symbols": "^3.0.0",
        "is-obj": "^1.0.1",
        "is-regexp": "^1.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/strip-ansi": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/strip-ansi-cjs": {
      "name": "strip-ansi",
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-comments/-/strip-comments-2.0.1.tgz",
      "integrity": "sha512-ZprKx+bBLXv067WTCALv8SSz5l2+XhpYCsVtSqlMnkAXMWDq+/ekVbl1ghqP9rUHTzv6sm/DwCOiYutU/yp1fw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tailwind-merge": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/tailwind-merge/-/tailwind-merge-3.4.0.tgz",
      "integrity": "sha512-uSaO4gnW+b3Y2aWoWfFpX62vn2sR3skfhbjsEnaBI81WD1wBLlHZe5sWf0AqjksNdYTbGBEd0UasQMT3SNV15g==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/dcastil"
      }
    },
    "node_modules/tailwindcss": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-4.1.18.tgz",
      "integrity": "sha512-4+Z+0yiYyEtUVCScyfHCxOYP06L5Ne+JiHhY2IjR2KWMIWhJOYZKLSGZaP5HkZ8+bY0cxfzwDE5uOmzFXyIwxw==",
      "license": "MIT"
    },
    "node_modules/tapable": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-2.3.0.tgz",
      "integrity": "sha512-g9ljZiwki/LfxmQADO3dEY1CbpmXT5Hm2fJ+QaGKwSXUylMybePR7/67YW7jOrrvjEgL1Fmz5kzyAjWVWLlucg==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/webpack"
      }
    },
    "node_modules/temp-dir": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/temp-dir/-/temp-dir-2.0.0.tgz",
      "integrity": "sha512-aoBAniQmmwtcKp/7BzsH8Cxzv8OL736p7v1ihGb5e9DJ9kTwGWHrQrVB5+lfVDzfGrdRzXch+ig7LHaY1JTOrg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/tempy": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/tempy/-/tempy-0.6.0.tgz",
      "integrity": "sha512-G13vtMYPT/J8A4X2SjdtBTphZlrp1gKv6hZiOjw14RCWg6GbHuQBGtjlx75xLbYV/wEc0D7G5K4rxKP/cXk8Bw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-stream": "^2.0.0",
        "temp-dir": "^2.0.0",
        "type-fest": "^0.16.0",
        "unique-string": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/terser": {
      "version": "5.44.0",
      "resolved": "https://registry.npmjs.org/terser/-/terser-5.44.0.tgz",
      "integrity": "sha512-nIVck8DK+GM/0Frwd+nIhZ84pR/BX7rmXMfYwyg+Sri5oGVE99/E3KvXqpC2xHFxyqXyGHTKBSioxxplrO4I4w==",
      "devOptional": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "@jridgewell/source-map": "^0.3.3",
        "acorn": "^8.15.0",
        "commander": "^2.20.0",
        "source-map-support": "~0.5.20"
      },
      "bin": {
        "terser": "bin/terser"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/tr46": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-1.0.1.tgz",
      "integrity": "sha512-dTpowEjclQ7Kgx5SdBkqRzVhERQXov8/l9Ft9dVM9fmg0W0KQSVaXX9T4i6twCPNtYiZM53lpSSUAwJbFPOHxA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.4.0.tgz",
      "integrity": "sha512-3TaVTaAv2gTiMB35i3FiGJaRfwb3Pyn/j3m/bfAvGe8FB7CF6u+LMYqYlDh7reQf7UNvoTvdfAqHGmPGOSsPmA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/tw-animate-css": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/tw-animate-css/-/tw-animate-css-1.4.0.tgz",
      "integrity": "sha512-7bziOlRqH0hJx80h/3mbicLW7o8qLsH5+RaLR2t+OHM3D0JlWGODQKQ4cxbK7WlvmUxpcj6Kgu6EKqjrGFe3QQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/Wombosvideo"
      }
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-fest": {
      "version": "0.16.0",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.16.0.tgz",
      "integrity": "sha512-eaBzG6MxNzEn9kiwvtre90cXaNLkmadMWa1zQMs3XORCXNbsH/OewwbxC5ia9dCxIxnTAsSxXJaa/p5y8DlvJg==",
      "dev": true,
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typed-array-buffer": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/typed-array-buffer/-/typed-array-buffer-1.0.3.tgz",
      "integrity": "sha512-nAYYwfY3qnzX30IkA6AQZjVbtK6duGontcQm1WSG1MD94YLqK0515GNApXkoxKOWMusVssAHWLh9SeaoefYFGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-typed-array": "^1.1.14"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/typed-array-byte-length": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/typed-array-byte-length/-/typed-array-byte-length-1.0.3.tgz",
      "integrity": "sha512-BaXgOuIxz8n8pIq3e7Atg/7s+DpiYrxn4vdot3w9KbnBhcRQq6o3xemQdIfynqSeXeDrF32x+WvfzmOjPiY9lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "for-each": "^0.3.3",
        "gopd": "^1.2.0",
        "has-proto": "^1.2.0",
        "is-typed-array": "^1.1.14"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typed-array-byte-offset": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/typed-array-byte-offset/-/typed-array-byte-offset-1.0.4.tgz",
      "integrity": "sha512-bTlAFB/FBYMcuX81gbL4OcpH5PmlFHqlCCpAl8AlEzMz5k53oNDvN8p1PNOWLEmI2x4orp3raOFB51tv9X+MFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "for-each": "^0.3.3",
        "gopd": "^1.2.0",
        "has-proto": "^1.2.0",
        "is-typed-array": "^1.1.15",
        "reflect.getprototypeof": "^1.0.9"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typed-array-length": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/typed-array-length/-/typed-array-length-1.0.7.tgz",
      "integrity": "sha512-3KS2b+kL7fsuk/eJZ7EQdnEmQoaho/r6KUef7hxvltNA5DR8NAUM+8wJMbJyZ4G9/7i3v5zPBIMN5aybAh2/Jg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "is-typed-array": "^1.1.13",
        "possible-typed-array-names": "^1.0.0",
        "reflect.getprototypeof": "^1.0.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/typescript-eslint": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.54.0.tgz",
      "integrity": "sha512-CKsJ+g53QpsNPqbzUsfKVgd3Lny4yKZ1pP4qN3jdMOg/sisIDLGyDMezycquXLE5JsEU0wp3dGNdzig0/fmSVQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/eslint-plugin": "8.54.0",
        "@typescript-eslint/parser": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0",
        "@typescript-eslint/utils": "8.54.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/unbox-primitive": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/unbox-primitive/-/unbox-primitive-1.1.0.tgz",
      "integrity": "sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-bigints": "^1.0.2",
        "has-symbols": "^1.1.0",
        "which-boxed-primitive": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/undici-types": {
      "version": "7.16.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
      "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/unicode-canonical-property-names-ecmascript": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-2.0.1.tgz",
      "integrity": "sha512-dA8WbNeb2a6oQzAQ55YlT5vQAWGV9WXOsi3SskE3bcCdM0P4SDd+24zS/OCacdRq5BkdsRj9q3Pg6YyQoxIGqg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unicode-match-property-ecmascript": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/unicode-match-property-ecmascript/-/unicode-match-property-ecmascript-2.0.0.tgz",
      "integrity": "sha512-5kaZCrbp5mmbz5ulBkDkbY0SsPOjKqVS35VpL9ulMPfSl0J0Xsm+9Evphv9CoIZFwre7aJoa94AY6seMKGVN5Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "unicode-canonical-property-names-ecmascript": "^2.0.0",
        "unicode-property-aliases-ecmascript": "^2.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unicode-match-property-value-ecmascript": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-2.2.1.tgz",
      "integrity": "sha512-JQ84qTuMg4nVkx8ga4A16a1epI9H6uTXAknqxkGF/aFfRLw1xC/Bp24HNLaZhHSkWd3+84t8iXnp1J0kYcZHhg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unicode-property-aliases-ecmascript": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-2.2.0.tgz",
      "integrity": "sha512-hpbDzxUY9BFwX+UeBnxv3Sh1q7HFxj48DTmXchNgRa46lO8uj3/1iEn3MiNUYTg1g9ctIqXCCERn8gYZhHC5lQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/unique-string": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/unique-string/-/unique-string-2.0.0.tgz",
      "integrity": "sha512-uNaeirEPvpZWSgzwsPGtU2zVSTrn/8L5q/IexZmH0eH6SA73CmAA5U4GwORTxQAZs95TAXLNqeLoPPNO5gZfWg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "crypto-random-string": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/universalify": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/universalify/-/universalify-2.0.1.tgz",
      "integrity": "sha512-gptHNQghINnc/vTGIk0SOFGFNXw7JVrlRUtConJRlvaw6DuX0wO5Jeko9sWrMBhh+PsYAZ7oXAiOnf/UKogyiw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/upath": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/upath/-/upath-1.2.0.tgz",
      "integrity": "sha512-aZwGpamFO61g3OlfT7OQCHqhGnW43ieH9WZeP7QxN/G/jS4jfqUkZxoryvJgVPEcrl5NL/ggHsSmLMHuH64Lhg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4",
        "yarn": "*"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.4.tgz",
      "integrity": "sha512-q0SPT4xyU84saUX+tomz1WLkxUbuaJnR1xWt17M7fJtEJigJeWUNGUqrauFXsHnqev9y9JTRGwk13tFBuKby4A==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-callback-ref": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/use-callback-ref/-/use-callback-ref-1.3.3.tgz",
      "integrity": "sha512-jQL3lRnocaFtu3V00JToYz/4QkNWswxijDaCVNZRiRTO3HQDLsdu1ZtmIUvV4yPp+rvWm5j0y0TG/S61cuijTg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/use-sidecar": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/use-sidecar/-/use-sidecar-1.1.3.tgz",
      "integrity": "sha512-Fedw0aZvkhynoPYlA5WXrMCAMm+nSWdZt6lzJQ7Ok8S6Q+VsHmHpRWndVRJ8Be0ZbkfPc5LRYH+5XrzXcEeLRQ==",
      "license": "MIT",
      "dependencies": {
        "detect-node-es": "^1.1.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/vaul": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vaul/-/vaul-1.1.2.tgz",
      "integrity": "sha512-ZFkClGpWyI2WUQjdLJ/BaGuV6AVQiJ3uELGk3OYtP+B6yCO7Cmn9vPFXVJkRaGkOJu3m8bQMgtyzNHixULceQA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-dialog": "^1.1.1"
      },
      "peerDependencies": {
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0.0 || ^19.0.0-rc"
      }
    },
    "node_modules/vite": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-7.3.1.tgz",
      "integrity": "sha512-w+N7Hifpc3gRjZ63vYBXA56dvvRlNWRczTdmCBBa+CotUzAPf5b7YMdMR/8CQoeYE5LX3W4wj6RYTgonm1b9DA==",
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.27.0",
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3",
        "postcss": "^8.5.6",
        "rollup": "^4.43.0",
        "tinyglobby": "^0.2.15"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^20.19.0 || >=22.12.0",
        "jiti": ">=1.21.0",
        "less": "^4.0.0",
        "lightningcss": "^1.21.0",
        "sass": "^1.70.0",
        "sass-embedded": "^1.70.0",
        "stylus": ">=0.54.8",
        "sugarss": "^5.0.0",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite-plugin-pwa": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/vite-plugin-pwa/-/vite-plugin-pwa-1.2.0.tgz",
      "integrity": "sha512-a2xld+SJshT9Lgcv8Ji4+srFJL4k/1bVbd1x06JIkvecpQkwkvCncD1+gSzcdm3s+owWLpMJerG3aN5jupJEVw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^4.3.6",
        "pretty-bytes": "^6.1.1",
        "tinyglobby": "^0.2.10",
        "workbox-build": "^7.4.0",
        "workbox-window": "^7.4.0"
      },
      "engines": {
        "node": ">=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      },
      "peerDependencies": {
        "@vite-pwa/assets-generator": "^1.0.0",
        "vite": "^3.1.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0",
        "workbox-build": "^7.4.0",
        "workbox-window": "^7.4.0"
      },
      "peerDependenciesMeta": {
        "@vite-pwa/assets-generator": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/wasm-feature-detect": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/wasm-feature-detect/-/wasm-feature-detect-1.8.0.tgz",
      "integrity": "sha512-zksaLKM2fVlnB5jQQDqKXXwYHLQUVH9es+5TOOHwGOVJOCeRBCiPjwSg+3tN2AdTCzjgli4jijCH290kXb/zWQ==",
      "license": "Apache-2.0"
    },
    "node_modules/webidl-conversions": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-4.0.2.tgz",
      "integrity": "sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==",
      "dev": true,
      "license": "BSD-2-Clause"
    },
    "node_modules/whatwg-url": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-7.1.0.tgz",
      "integrity": "sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "lodash.sortby": "^4.7.0",
        "tr46": "^1.0.1",
        "webidl-conversions": "^4.0.2"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/which-boxed-primitive": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/which-boxed-primitive/-/which-boxed-primitive-1.1.1.tgz",
      "integrity": "sha512-TbX3mj8n0odCBFVlY8AxkqcHASw3L60jIuF8jFP78az3C2YhmGvqbHBpAjTRH2/xqYunrJ9g1jSyjCjpoWzIAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-bigint": "^1.1.0",
        "is-boolean-object": "^1.2.1",
        "is-number-object": "^1.1.1",
        "is-string": "^1.1.1",
        "is-symbol": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-builtin-type": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/which-builtin-type/-/which-builtin-type-1.2.1.tgz",
      "integrity": "sha512-6iBczoX+kDQ7a3+YJBnh3T+KZRxM/iYNPXicqk66/Qfm1b93iu+yOImkg0zHbj5LNOcNv1TEADiZ0xa34B4q6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "function.prototype.name": "^1.1.6",
        "has-tostringtag": "^1.0.2",
        "is-async-function": "^2.0.0",
        "is-date-object": "^1.1.0",
        "is-finalizationregistry": "^1.1.0",
        "is-generator-function": "^1.0.10",
        "is-regex": "^1.2.1",
        "is-weakref": "^1.0.2",
        "isarray": "^2.0.5",
        "which-boxed-primitive": "^1.1.0",
        "which-collection": "^1.0.2",
        "which-typed-array": "^1.1.16"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-builtin-type/node_modules/isarray": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz",
      "integrity": "sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/which-collection": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/which-collection/-/which-collection-1.0.2.tgz",
      "integrity": "sha512-K4jVyjnBdgvc86Y6BkaLZEN933SwYOuBFkdmBu9ZfkcAbdVbpITnDmjvZ/aQjRXQrv5EPkTnD1s39GiiqbngCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-map": "^2.0.3",
        "is-set": "^2.0.3",
        "is-weakmap": "^2.0.2",
        "is-weakset": "^2.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-typed-array": {
      "version": "1.1.19",
      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.19.tgz",
      "integrity": "sha512-rEvr90Bck4WZt9HHFC4DJMsjvu7x+r6bImz0/BrbWb7A2djJ8hnZMrWnHo9F8ssv0OMErasDhftrfROTyqSDrw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "for-each": "^0.3.5",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/workbox-background-sync": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-background-sync/-/workbox-background-sync-7.4.0.tgz",
      "integrity": "sha512-8CB9OxKAgKZKyNMwfGZ1XESx89GryWTfI+V5yEj8sHjFH8MFelUwYXEyldEK6M6oKMmn807GoJFUEA1sC4XS9w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "idb": "^7.0.1",
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-broadcast-update": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-broadcast-update/-/workbox-broadcast-update-7.4.0.tgz",
      "integrity": "sha512-+eZQwoktlvo62cI0b+QBr40v5XjighxPq3Fzo9AWMiAosmpG5gxRHgTbGGhaJv/q/MFVxwFNGh/UwHZ/8K88lA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-build": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-build/-/workbox-build-7.4.0.tgz",
      "integrity": "sha512-Ntk1pWb0caOFIvwz/hfgrov/OJ45wPEhI5PbTywQcYjyZiVhT3UrwwUPl6TRYbTm4moaFYithYnl1lvZ8UjxcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@apideck/better-ajv-errors": "^0.3.1",
        "@babel/core": "^7.24.4",
        "@babel/preset-env": "^7.11.0",
        "@babel/runtime": "^7.11.2",
        "@rollup/plugin-babel": "^5.2.0",
        "@rollup/plugin-node-resolve": "^15.2.3",
        "@rollup/plugin-replace": "^2.4.1",
        "@rollup/plugin-terser": "^0.4.3",
        "@surma/rollup-plugin-off-main-thread": "^2.2.3",
        "ajv": "^8.6.0",
        "common-tags": "^1.8.0",
        "fast-json-stable-stringify": "^2.1.0",
        "fs-extra": "^9.0.1",
        "glob": "^11.0.1",
        "lodash": "^4.17.20",
        "pretty-bytes": "^5.3.0",
        "rollup": "^2.79.2",
        "source-map": "^0.8.0-beta.0",
        "stringify-object": "^3.3.0",
        "strip-comments": "^2.0.1",
        "tempy": "^0.6.0",
        "upath": "^1.2.0",
        "workbox-background-sync": "7.4.0",
        "workbox-broadcast-update": "7.4.0",
        "workbox-cacheable-response": "7.4.0",
        "workbox-core": "7.4.0",
        "workbox-expiration": "7.4.0",
        "workbox-google-analytics": "7.4.0",
        "workbox-navigation-preload": "7.4.0",
        "workbox-precaching": "7.4.0",
        "workbox-range-requests": "7.4.0",
        "workbox-recipes": "7.4.0",
        "workbox-routing": "7.4.0",
        "workbox-strategies": "7.4.0",
        "workbox-streams": "7.4.0",
        "workbox-sw": "7.4.0",
        "workbox-window": "7.4.0"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/workbox-build/node_modules/@apideck/better-ajv-errors": {
      "version": "0.3.6",
      "resolved": "https://registry.npmjs.org/@apideck/better-ajv-errors/-/better-ajv-errors-0.3.6.tgz",
      "integrity": "sha512-P+ZygBLZtkp0qqOAJJVX4oX/sFo5JR3eBWwwuqHHhK0GIgQOKWrAfiAaWX0aArHkRWHMuggFEgAZNxVPwPZYaA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-schema": "^0.4.0",
        "jsonpointer": "^5.0.0",
        "leven": "^3.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "ajv": ">=8"
      }
    },
    "node_modules/workbox-build/node_modules/@rollup/plugin-babel": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/@rollup/plugin-babel/-/plugin-babel-5.3.1.tgz",
      "integrity": "sha512-WFfdLWU/xVWKeRQnKmIAQULUI7Il0gZnBIH/ZFO069wYIfPu+8zrfp/KMW0atmELoRDq8FbiP3VCss9MhCut7Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.10.4",
        "@rollup/pluginutils": "^3.1.0"
      },
      "engines": {
        "node": ">= 10.0.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0",
        "@types/babel__core": "^7.1.9",
        "rollup": "^1.20.0||^2.0.0"
      },
      "peerDependenciesMeta": {
        "@types/babel__core": {
          "optional": true
        }
      }
    },
    "node_modules/workbox-build/node_modules/@rollup/plugin-replace": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/@rollup/plugin-replace/-/plugin-replace-2.4.2.tgz",
      "integrity": "sha512-IGcu+cydlUMZ5En85jxHH4qj2hta/11BHq95iHEyb2sbgiN0eCdzvUcHw5gt9pBL5lTi4JDYJ1acCoMGpTvEZg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@rollup/pluginutils": "^3.1.0",
        "magic-string": "^0.25.7"
      },
      "peerDependencies": {
        "rollup": "^1.20.0 || ^2.0.0"
      }
    },
    "node_modules/workbox-build/node_modules/@rollup/pluginutils": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-3.1.0.tgz",
      "integrity": "sha512-GksZ6pr6TpIjHm8h9lSQ8pi8BE9VeubNT0OMJ3B5uZJ8pz73NPiqOtCog/x2/QzM1ENChPKxMDhiQuRHsqc+lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "0.0.39",
        "estree-walker": "^1.0.1",
        "picomatch": "^2.2.2"
      },
      "engines": {
        "node": ">= 8.0.0"
      },
      "peerDependencies": {
        "rollup": "^1.20.0||^2.0.0"
      }
    },
    "node_modules/workbox-build/node_modules/@types/estree": {
      "version": "0.0.39",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-0.0.39.tgz",
      "integrity": "sha512-EYNwp3bU+98cpU4lAWYYL7Zz+2gryWH1qbdDTidVd6hkiR6weksdbMadyXKXNPEkQFhXM+hVO9ZygomHXp+AIw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/workbox-build/node_modules/ajv": {
      "version": "8.17.1",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.17.1.tgz",
      "integrity": "sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.3",
        "fast-uri": "^3.0.1",
        "json-schema-traverse": "^1.0.0",
        "require-from-string": "^2.0.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/workbox-build/node_modules/estree-walker": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-1.0.1.tgz",
      "integrity": "sha512-1fMXF3YP4pZZVozF8j/ZLfvnR8NSIljt56UhbZ5PeeDmmGHpgpdwQt7ITlGvYaQukCvuBRMLEiKiYC+oeIg4cg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/workbox-build/node_modules/json-schema-traverse": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/workbox-build/node_modules/magic-string": {
      "version": "0.25.9",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.9.tgz",
      "integrity": "sha512-RmF0AsMzgt25qzqqLc1+MbHmhdx0ojF2Fvs4XnOqz2ZOBXzzkEwc/dJQZCYHAn7v1jbVOjAZfK8msRn4BxO4VQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "sourcemap-codec": "^1.4.8"
      }
    },
    "node_modules/workbox-build/node_modules/pretty-bytes": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/pretty-bytes/-/pretty-bytes-5.6.0.tgz",
      "integrity": "sha512-FFw039TmrBqFK8ma/7OL3sDz/VytdtJr044/QUJtH0wK9lb9jLq9tJyIxUwtQJHwar2BqtiA4iCWSwo9JLkzFg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/workbox-build/node_modules/rollup": {
      "version": "2.79.2",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.79.2.tgz",
      "integrity": "sha512-fS6iqSPZDs3dr/y7Od6y5nha8dW1YnbgtsyotCVvoFGKbERG++CVRFv1meyGDE1SNItQA8BrnCw7ScdAhRJ3XQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=10.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/workbox-cacheable-response": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-cacheable-response/-/workbox-cacheable-response-7.4.0.tgz",
      "integrity": "sha512-0Fb8795zg/x23ISFkAc7lbWes6vbw34DGFIMw31cwuHPgDEC/5EYm6m/ZkylLX0EnEbbOyOCLjKgFS/Z5g0HeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-core": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-core/-/workbox-core-7.4.0.tgz",
      "integrity": "sha512-6BMfd8tYEnN4baG4emG9U0hdXM4gGuDU3ectXuVHnj71vwxTFI7WOpQJC4siTOlVtGqCUtj0ZQNsrvi6kZZTAQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/workbox-expiration": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-expiration/-/workbox-expiration-7.4.0.tgz",
      "integrity": "sha512-V50p4BxYhtA80eOvulu8xVfPBgZbkxJ1Jr8UUn0rvqjGhLDqKNtfrDfjJKnLz2U8fO2xGQJTx/SKXNTzHOjnHw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "idb": "^7.0.1",
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-google-analytics": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-google-analytics/-/workbox-google-analytics-7.4.0.tgz",
      "integrity": "sha512-MVPXQslRF6YHkzGoFw1A4GIB8GrKym/A5+jYDUSL+AeJw4ytQGrozYdiZqUW1TPQHW8isBCBtyFJergUXyNoWQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-background-sync": "7.4.0",
        "workbox-core": "7.4.0",
        "workbox-routing": "7.4.0",
        "workbox-strategies": "7.4.0"
      }
    },
    "node_modules/workbox-navigation-preload": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-navigation-preload/-/workbox-navigation-preload-7.4.0.tgz",
      "integrity": "sha512-etzftSgdQfjMcfPgbfaZCfM2QuR1P+4o8uCA2s4rf3chtKTq/Om7g/qvEOcZkG6v7JZOSOxVYQiOu6PbAZgU6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-precaching": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-precaching/-/workbox-precaching-7.4.0.tgz",
      "integrity": "sha512-VQs37T6jDqf1rTxUJZXRl3yjZMf5JX/vDPhmx2CPgDDKXATzEoqyRqhYnRoxl6Kr0rqaQlp32i9rtG5zTzIlNg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0",
        "workbox-routing": "7.4.0",
        "workbox-strategies": "7.4.0"
      }
    },
    "node_modules/workbox-range-requests": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-range-requests/-/workbox-range-requests-7.4.0.tgz",
      "integrity": "sha512-3Vq854ZNuP6Y0KZOQWLaLC9FfM7ZaE+iuQl4VhADXybwzr4z/sMmnLgTeUZLq5PaDlcJBxYXQ3U91V7dwAIfvw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-recipes": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-recipes/-/workbox-recipes-7.4.0.tgz",
      "integrity": "sha512-kOkWvsAn4H8GvAkwfJTbwINdv4voFoiE9hbezgB1sb/0NLyTG4rE7l6LvS8lLk5QIRIto+DjXLuAuG3Vmt3cxQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-cacheable-response": "7.4.0",
        "workbox-core": "7.4.0",
        "workbox-expiration": "7.4.0",
        "workbox-precaching": "7.4.0",
        "workbox-routing": "7.4.0",
        "workbox-strategies": "7.4.0"
      }
    },
    "node_modules/workbox-routing": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-routing/-/workbox-routing-7.4.0.tgz",
      "integrity": "sha512-C/ooj5uBWYAhAqwmU8HYQJdOjjDKBp9MzTQ+otpMmd+q0eF59K+NuXUek34wbL0RFrIXe/KKT+tUWcZcBqxbHQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-strategies": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-strategies/-/workbox-strategies-7.4.0.tgz",
      "integrity": "sha512-T4hVqIi5A4mHi92+5EppMX3cLaVywDp8nsyUgJhOZxcfSV/eQofcOA6/EMo5rnTNmNTpw0rUgjAI6LaVullPpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/workbox-streams": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-streams/-/workbox-streams-7.4.0.tgz",
      "integrity": "sha512-QHPBQrey7hQbnTs5GrEVoWz7RhHJXnPT+12qqWM378orDMo5VMJLCkCM1cnCk+8Eq92lccx/VgRZ7WAzZWbSLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "workbox-core": "7.4.0",
        "workbox-routing": "7.4.0"
      }
    },
    "node_modules/workbox-sw": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-sw/-/workbox-sw-7.4.0.tgz",
      "integrity": "sha512-ltU+Kr3qWR6BtbdlMnCjobZKzeV1hN+S6UvDywBrwM19TTyqA03X66dzw1tEIdJvQ4lYKkBFox6IAEhoSEZ8Xw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/workbox-window": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/workbox-window/-/workbox-window-7.4.0.tgz",
      "integrity": "sha512-/bIYdBLAVsNR3v7gYGaV4pQW3M3kEPx5E8vDxGvxo6khTrGtSSCS7QiFKv9ogzBgZiy0OXLP9zO28U/1nF1mfw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/trusted-types": "^2.0.2",
        "workbox-core": "7.4.0"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.1.0",
        "string-width": "^5.0.1",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs": {
      "name": "wrap-ansi",
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-styles": {
      "version": "6.2.3",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/zod": {
      "version": "4.1.12",
      "resolved": "https://registry.npmjs.org/zod/-/zod-4.1.12.tgz",
      "integrity": "sha512-JInaHOamG8pt5+Ey8kGmdcAcg3OL9reK8ltczgHTAwNhMys/6ThXHityHxVV2p3fkw/c+MAvBHFVYHFZDmjMCQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-validation-error": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/zod-validation-error/-/zod-validation-error-4.0.2.tgz",
      "integrity": "sha512-Q6/nZLe6jxuU80qb/4uJ4t5v2VEZ44lzQjPDhYJNztRQ4wyWc6VF3D3Kb/fAuPetZQnhS3hnajCf9CsWesghLQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      },
      "peerDependencies": {
        "zod": "^3.25.0 || ^4.0.0"
      }
    }
  }
}

```

`page/package.json`:

```json
{
  "name": "sogen",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@fontsource/inter": "^5.2.8",
    "@irori/idbfs": "^0.5.1",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tailwindcss/vite": "^4.1.18",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "flatbuffers": "^25.9.23",
    "jszip": "^3.10.1",
    "lucide-react": "^0.563.0",
    "pe-library": "^2.0.1",
    "react": "^19.2.4",
    "react-bootstrap-icons": "^1.11.6",
    "react-dom": "^19.2.4",
    "react-dropzone": "^14.4.0",
    "react-helmet": "^6.1.0",
    "react-router-dom": "^7.13.0",
    "react-window": "^2.2.6",
    "shell-quote": "^1.8.3",
    "tailwind-merge": "^3.4.0",
    "tailwindcss": "^4.1.16",
    "tw-animate-css": "^1.4.0",
    "vaul": "^1.1.2",
    "wasm-feature-detect": "^1.8.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^25.2.0",
    "@types/react": "^19.2.10",
    "@types/react-dom": "^19.2.3",
    "@types/react-helmet": "^6.1.11",
    "@types/shell-quote": "^1.7.5",
    "@vitejs/plugin-react": "^5.1.2",
    "eslint": "^9.39.2",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.5.0",
    "globals": "^17.3.0",
    "prettier": "3.8.1",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.54.0",
    "vite": "^7.3.1",
    "vite-plugin-pwa": "^1.2.0"
  }
}

```

`page/public/emulator-worker.js`:

```js
var logLines = [];
var lastFlush = new Date().getTime();

var msgQueue = [];

onmessage = async (event) => {
  const data = event.data;
  const payload = data.data;

  switch (data.message) {
    case "run":
      runEmulation(
        payload.file,
        payload.options,
        payload.arguments,
        payload.persist,
        payload.wasm64,
        payload.cacheBuster,
      );
      break;
    case "event":
      msgQueue.push(payload);
      break;
  }
};

function sendMessage(message, data) {
  postMessage({ message, data });
}

function flushLines() {
  const lines = logLines;
  logLines = [];
  lastFlush = new Date().getTime();
  sendMessage("log", lines);
}

function logLine(text) {
  logLines.push(text);

  const now = new Date().getTime();

  if (lastFlush + 15 < now) {
    flushLines();
  }
}

function notifyExit(code, persist) {
  flushLines();

  const finishExecution = () => {
    sendMessage("end", code);
    self.close();
  };

  if (persist) {
    FS.syncfs(false, finishExecution);
  } else {
    finishExecution();
  }
}

function handleMessage(message) {
  sendMessage("event", message);
}

function getMessageFromQueue() {
  if (msgQueue.length == 0) {
    return "";
  }

  return msgQueue.shift();
}

function runEmulation(
  file,
  options,
  appArguments,
  persist,
  wasm64,
  cacheBuster,
) {
  const mainArguments = [...options, "-e", "./root", file, ...appArguments];

  globalThis.Module = {
    arguments: mainArguments,
    noInitialRun: true,
    locateFile: (path, scriptDirectory) => {
      const bitness = wasm64 ? "64" : "32";
      const busterParams = cacheBuster ? `?${cacheBuster}` : "";
      return `${scriptDirectory}${bitness}/${path}${busterParams}`;
    },
    onRuntimeInitialized: function () {
      FS.mkdir("/root");
      FS.mount(IDBFS, {}, "/root");
      FS.syncfs(true, function (_) {
        setTimeout(() => {
          Module.callMain(mainArguments);
        }, 0);
      });
    },
    print: logLine,
    printErr: logLine,
    onAbort: () => notifyExit(null, persist),
    onExit: (code) => notifyExit(code, persist),
    postRun: flushLines,
  };

  const busterParams = cacheBuster ? `?${cacheBuster}` : "";

  if (wasm64) {
    importScripts("./64/analyzer.js" + busterParams);
  } else {
    importScripts("./32/analyzer.js" + busterParams);
  }
}

```

`page/src/App.css`:

```css
html {
  font-family: "Inter", sans-serif;
}

@media (pointer: fine) {
  ::-webkit-scrollbar {
    width: 20px;
    height: 20px;
  }

  ::-webkit-scrollbar-track {
    background: transparent;
  }

  ::-webkit-scrollbar-thumb {
    background-color: rgba(97, 97, 97, 0.7);
    border-radius: 20px;
    border: 6px solid transparent;
    background-clip: content-box;
    transition: all 0.1s linear;
    min-height: 50px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background-color: rgba(97, 97, 97, 0.9);
  }

  ::-webkit-scrollbar-corner {
    background: transparent;
  }
}

button {
  cursor: pointer;
}

button.fancy.bg-primary,
button.fancy.bg-secondary,
button.fancy.bg-destructive {
  transition: all 0.2s ease;
}

button.fancy.bg-primary {
  background: linear-gradient(
    180deg,
    rgba(38, 144, 255, 1) 0%,
    rgba(0, 123, 255, 1) 100%
  );
  border: 0px solid rgb(27, 149, 255);
  text-shadow: rgba(0, 0, 0, 0.2) 0px 1px;
  color: oklch(0.97 0.014 254.604);
}

button.fancy.bg-primary:hover {
  background: linear-gradient(
    180deg,
    rgba(46, 151, 255, 1) 0%,
    rgba(8, 130, 255, 1) 100%
  );
  /*border: 1px solid rgb(33, 33, 34);*/
}

button.fancy.bg-destructive {
  background: linear-gradient(
    180deg,
    rgb(173, 35, 35) 0%,
    rgb(143, 46, 24) 100%
  );
  border: 0px solid rgb(147, 32, 7);
  text-shadow: rgba(0, 0, 0, 0.2) 0px 1px;
}

button.fancy.bg-destructive:hover {
  background: linear-gradient(
    180deg,
    rgb(185, 47, 47) 0%,
    rgb(153, 53, 30) 100%
  );
  /*border: 1px solid rgb(33, 33, 34);*/
}

button.fancy.bg-secondary {
  background: linear-gradient(180deg, rgb(38, 38, 39) 0%, rgb(34, 34, 35) 100%);
  border: 0px solid rgb(44, 44, 46);
}

button.fancy.bg-secondary:hover {
  background: linear-gradient(180deg, rgb(42, 42, 43) 0%, rgb(38, 38, 39) 100%);
  /*border: 1px solid rgb(33, 33, 34);*/
}

/*.terminal-output span {
  padding: 0px 16px;
}*/

.terminal-output {
  font-weight: 600;
  font-size: 1.05em;
  font-family: monospace;
  height: 100%;
}

.terminal-black {
  color: #0c0c0c;
}

.terminal-red {
  color: #ff3131;
}

.terminal-green {
  color: #86c000;
}

.terminal-yellow {
  color: #ffb940;
}

.terminal-blue {
  color: #3a96dd;
}

.terminal-cyan {
  color: #00adf7;
}

.terminal-pink {
  color: #9750dd;
}

.terminal-white {
  color: #ececec;
}

.terminal-dark-gray {
  color: rgb(81, 81, 81);
}

.terminal-glass {
  box-shadow: 0px 0px 15px 4px rgba(255, 255, 255, 0.04);
  backdrop-filter: blur(6px) brightness(0.8) saturate(1.3);
  background: transparent;
}

.folder-element .folder-icon,
.folder-element svg {
  filter: drop-shadow(0px 0px 4px rgba(0, 0, 0, 0.4));
}

.folder-element:hover .folder-icon,
.folder-element:hover svg {
  filter: drop-shadow(0px 0px 4px rgba(80, 80, 80, 0.3));
}

```

`page/src/App.tsx`:

```tsx
import { ThemeProvider } from "@/components/theme-provider";
import { TooltipProvider } from "@/components/ui/tooltip";
import { HashRouter, Route, Routes, Navigate } from "react-router-dom";
import { Playground, storeEmulateData } from "./playground";
import { LandingPage } from "./landing-page";
import { useParams } from "react-router-dom";
import Loader from "./Loader";

import "@fontsource/inter/latin.css";

import "./App.css";
import "./animation.css";

function EmulateFile() {
  const { encodedData } = useParams();
  storeEmulateData(encodedData);
  return <Navigate to="/playground" replace />;
}

function Spinner() {
  const loading = Loader.useLoader();

  return (
    <div
      className={
        "fixed z-9999 top-0 left-0 right-0 h-[2px] pointer-events-none select-none transition-opacity duration-1000 animated-gradient " +
        (loading ? "opacity-100" : "opacity-0")
      }
    ></div>
  );
}

function App() {
  return (
    <ThemeProvider defaultTheme="dark" storageKey="vite-ui-theme">
      <TooltipProvider>
        <HashRouter>
          <Routes>
            <Route path="*" element={<Navigate to="/" replace />} />
            <Route path="/" element={<LandingPage />} />
            <Route path="/playground" element={<Playground />} />
            <Route path="/emulate/:encodedData?" element={<EmulateFile />} />
          </Routes>
        </HashRouter>
        <Spinner />
      </TooltipProvider>
    </ThemeProvider>
  );
}

export default App;

```

`page/src/Header.tsx`:

```tsx
import { Helmet } from "react-helmet";

export interface HeaderProps {
  title: string;
  description: string;
  preload?: string[];
}

const image = "https://momo5502.com/emulator/preview.png";

export function Header(props: HeaderProps) {
  return (
    <Helmet>
      <title>{props.title}</title>
      <meta name="description" content={props.description} />
      <meta property="og:site_name" content={props.title} />
      <meta property="og:title" content={props.title} />
      <meta property="og:description" content={props.description} />
      <meta property="og:locale" content="en-us" />
      <meta property="og:type" content="website" />
      <meta name="og:image" content={image} />
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content={props.title} />
      <meta name="twitter:description" content={props.description} />
      <meta name="twitter:image" content={image} />

      {props.preload?.map((l) => (
        <link
          key={`link-${l}`}
          rel="preload"
          as={l.endsWith(".js") ? "script" : "fetch"}
          crossOrigin=""
          href={`${l}${l.indexOf("?") == -1 ? "?" : "&"}cb=${import.meta.env.VITE_BUILD_TIME}`}
        />
      ))}
    </Helmet>
  );
}

```

`page/src/Loader.ts`:

```ts
import { useEffect, useState } from "react";

type Callback = (loading: boolean) => void;

class Loader {
  private callbacks: Set<Callback> = new Set();
  private loading: boolean = false;

  public isLoading(): boolean {
    return this.loading;
  }

  public setLoading(value: boolean) {
    if (this.loading == value) {
      return;
    }

    this.loading = value;
    this.callbacks.forEach((callback) => callback(this.loading));
  }

  public register(callback: Callback): void {
    this.callbacks.add(callback);
  }

  public unregister(callback: Callback): void {
    this.callbacks.delete(callback);
  }

  public useLoader() {
    const [isLoading, setIsLoading] = useState(this.isLoading());

    useEffect(() => {
      function callback(loading: boolean) {
        setIsLoading(loading);
      }

      this.register(callback);

      return () => {
        this.unregister(callback);
      };
    });

    return isLoading;
  }
}

export default new Loader();

```

`page/src/animation.css`:

```css
:root {
  --gradient-loader-1: rgba(38, 38, 38, 0);
  --gradient-loader-2: rgb(255, 255, 255);
}

.animated-gradient {
  background: repeating-linear-gradient(
    to right,
    var(--gradient-loader-1) 0%,
    var(--gradient-loader-1) 35%,
    var(--gradient-loader-2) 50%,
    var(--gradient-loader-1) 53%,
    var(--gradient-loader-1) 100%
  );
  width: 100%;
  background-size: 200% auto;
  background-position: 0 100%;
  animation: gradient 2s infinite;
  animation-fill-mode: forwards;
  animation-timing-function: linear;
}

@keyframes gradient {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: -200% 0;
  }
}

```

`page/src/components/app-sidebar.tsx`:

```tsx
import * as React from "react";

import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupLabel,
  SidebarHeader,
  /*SidebarMenu,
  SidebarGroupContent,
  SidebarMenuButton,
  SidebarMenuItem,*/
  SidebarRail,
} from "@/components/ui/sidebar";

// This is sample data.
const data = {
  navMain: [
    {
      title: "TODO",
    },
  ],
};

export function AppSidebar({ ...props }: React.ComponentProps<typeof Sidebar>) {
  return (
    <Sidebar {...props}>
      <SidebarHeader>Filesystem</SidebarHeader>
      <SidebarContent>
        {/* We create a SidebarGroup for each parent. */}
        {data.navMain.map((item) => (
          <SidebarGroup key={item.title}>
            <SidebarGroupLabel>{item.title}</SidebarGroupLabel>
            {/*<SidebarGroupContent>
              <SidebarMenu>
                {item.items.map((item) => (
                  <SidebarMenuItem key={item.title}>
                    <SidebarMenuButton asChild isActive={item.isActive}>
                      <a href={item.url}>{item.title}</a>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                ))}
              </SidebarMenu>
            </SidebarGroupContent>*/}
          </SidebarGroup>
        ))}
      </SidebarContent>
      <SidebarRail />
    </Sidebar>
  );
}

```

`page/src/components/emulation-summary.tsx`:

```tsx
import { EmulationStatus } from "@/emulator";
import { TextTooltip } from "./text-tooltip";
import {
  BarChartSteps,
  CpuFill,
  FloppyFill,
  StopwatchFill,
} from "react-bootstrap-icons";
import React from "react";

export interface EmulationSummaryProps {
  status?: EmulationStatus;
  executionTimeFetcher: () => number;
}

function formatMemory(value: BigInt): string {
  const abbr = ["B", "KB", "MB", "GB", "PB"];

  let num = Number(value);
  let index = 0;

  while (num >= 1024 && index < abbr.length - 1) {
    num /= 1024;
    index++;
  }

  return num.toFixed(2) + " " + abbr[index];
}

function formatTime(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  const secsString = secs < 10 ? "0" + secs : secs.toString();

  if (hrs > 0) {
    const minsString = mins < 10 ? "0" + mins : mins.toString();
    return `${hrs.toString()}:${minsString}:${secsString}`;
  }

  return `${mins.toString()}:${secsString}`;
}

export class EmulationSummary extends React.Component<
  EmulationSummaryProps,
  {}
> {
  private timer: NodeJS.Timeout | undefined = undefined;

  constructor(props: EmulationSummaryProps) {
    super(props);
  }

  componentDidMount(): void {
    if (this.timer) {
      clearInterval(this.timer);
    }

    this.timer = setInterval(() => {
      this.forceUpdate();
    }, 200);
  }

  componentWillUnmount(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = undefined;
    }
  }

  render() {
    if (!this.props.status) {
      return <></>;
    }

    return (
      <div className="emulation-summary terminal-glass items-center absolute z-49 right-0 m-6 rounded-xl min-w-[150px] p-3 text-white cursor-default font-medium text-right text-sm whitespace-nowrap leading-6 font-mono">
        <TextTooltip tooltip={"Active Threads"}>
          {this.props.status.activeThreads}
          <BarChartSteps className="inline ml-3" />
        </TextTooltip>
        <br />
        <TextTooltip tooltip={"Application Memory"}>
          {formatMemory(this.props.status.committedMemory)}
          <FloppyFill className="inline ml-3" />
        </TextTooltip>
        <br />
        <TextTooltip tooltip={"Executed Instructions"}>
          {this.props.status.executedInstructions.toLocaleString()}
          <CpuFill className="inline ml-3" />
        </TextTooltip>
        <br />
        <TextTooltip tooltip={"Execution Time"}>
          {formatTime(this.props.executionTimeFetcher() / 1000)}
          <StopwatchFill className="inline ml-3" />
        </TextTooltip>
      </div>
    );
  }
}

```

`page/src/components/folder.tsx`:

```tsx
import {
  FolderFill,
  FolderSymlinkFill,
  FileEarmark,
  FiletypeExe,
  FileEarmarkBinary,
} from "react-bootstrap-icons";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuTrigger,
  ContextMenuSeparator,
  ContextMenuLabel,
} from "@/components/ui/context-menu";
import { TextTooltip } from "./text-tooltip";

export enum FolderElementType {
  Folder = 0,
  File,
}

export interface FolderElement {
  name: string;
  type: FolderElementType;
}

type ClickHandler = (element: FolderElement) => void;
type CreateFolderHandler = () => void;
type RemoveElementHandler = (element: FolderElement) => void;
type RenameElementHandler = (element: FolderElement) => void;
type DownloadElementHandler = (element: FolderElement) => void;
type AddFilesHandler = () => void;
type IconReader = (element: FolderElement) => string | null;

export interface FolderProps {
  elements: FolderElement[];
  iconReader: IconReader;
  clickHandler: ClickHandler;
  createFolderHandler: CreateFolderHandler;
  removeElementHandler: RemoveElementHandler;
  renameElementHandler: RenameElementHandler;
  downloadElementHandler: DownloadElementHandler;
  addFilesHandler: AddFilesHandler;
}

function elementComparator(e1: FolderElement, e2: FolderElement) {
  if (e1.type != e2.type) {
    return e1.type - e2.type;
  }

  return e1.name.localeCompare(e2.name);
}

function getIcon(
  element: FolderElement,
  iconReader: IconReader,
  className: string = "",
) {
  const icon = iconReader(element);
  if (icon) {
    return (
      <div className={className}>
        <div className="w-full h-full flex items-center">
          <img className="rounded-lg folder-icon" src={icon} />
        </div>
      </div>
    );
  }

  switch (element.type) {
    case FolderElementType.File:
      if (element.name.endsWith(".dll")) {
        return <FileEarmarkBinary className={className} />;
      }
      if (element.name.endsWith(".exe")) {
        return <FiletypeExe className={className} />;
      }
      return <FileEarmark className={className} />;
    case FolderElementType.Folder:
      return element.name == ".." ? (
        <FolderSymlinkFill className={className} />
      ) : (
        <FolderFill className={className} />
      );
    default:
      return <></>;
  }
}

function renderIcon(element: FolderElement, iconReader: IconReader) {
  let className = "w-11 h-11 flex-1";
  return getIcon(element, iconReader, className);
}

function renderElement(element: FolderElement, props: FolderProps) {
  return (
    <div
      onClick={() => props.clickHandler(element)}
      className="folder-element cursor-default select-none flex flex-col gap-2 items-center text-center text-xs p-2 m-2 w-27 h-25 rounded-lg border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50"
    >
      {renderIcon(element, props.iconReader)}
      <span className="whitespace-nowrap text-ellipsis overflow-hidden w-20">
        {element.name}
      </span>
    </div>
  );
}

export function trimFilename(filename: string, limit = 25) {
  if (limit < 4) {
    limit = 4;
  }

  if (filename.length < limit) {
    return filename;
  }

  return filename.substring(0, limit - 3) + "...";
}

function renderElementWithContext(element: FolderElement, props: FolderProps) {
  if (element.name == "..") {
    return renderElement(element, props);
  }

  return (
    <ContextMenu>
      <ContextMenuTrigger>
        <TextTooltip tooltip={element.name}>
          {renderElement(element, props)}
        </TextTooltip>
      </ContextMenuTrigger>
      <ContextMenuContent>
        <ContextMenuLabel>{trimFilename(element.name)}</ContextMenuLabel>
        <ContextMenuSeparator />
        {element.type != FolderElementType.File ? (
          <></>
        ) : (
          <ContextMenuItem
            onClick={() => props.downloadElementHandler(element)}
          >
            Download
          </ContextMenuItem>
        )}
        <ContextMenuItem onClick={() => props.renameElementHandler(element)}>
          Rename
        </ContextMenuItem>
        <ContextMenuItem onClick={() => props.removeElementHandler(element)}>
          Delete
        </ContextMenuItem>
      </ContextMenuContent>
    </ContextMenu>
  );
}

function renderElementWrapper(element: FolderElement, props: FolderProps) {
  return (
    <div key={`folder-element-${element.name}`}>
      {renderElementWithContext(element, props)}
    </div>
  );
}

export function Folder(props: FolderProps) {
  return (
    <ContextMenu>
      <ContextMenuTrigger>
        <ScrollArea className="h-[50dvh]">
          <div className="folder flex flex-wrap h-full text-neutral-300">
            {props.elements
              .sort(elementComparator)
              .map((e) => renderElementWrapper(e, props))}
          </div>
        </ScrollArea>
      </ContextMenuTrigger>
      <ContextMenuContent>
        <ContextMenuItem onClick={props.createFolderHandler}>
          Create new Folder
        </ContextMenuItem>
        <ContextMenuItem onClick={props.addFilesHandler}>
          Add Files
        </ContextMenuItem>
      </ContextMenuContent>
    </ContextMenu>
  );
}

```

`page/src/components/item-list.tsx`:

```tsx
import { Input } from "./ui/input";
import { Button } from "./ui/button";
import { Plus, Trash } from "react-bootstrap-icons";
import { Label } from "./ui/label";

interface ItemListProps {
  title: string;
  items: string[];
  onChange: (items: string[]) => void;
}

export function ItemList(props: ItemListProps) {
  const removeItem = (index: number) => {
    const newItems = [...props.items];
    newItems.splice(index, 1);
    props.onChange(newItems);
  };

  const addItem = (item: string) => {
    if (item.length == 0) {
      return;
    }

    const newItems = props.items.concat(item);
    props.onChange(newItems);
  };

  return (
    <div className="grid gap-3">
      <div className="space-y-2">
        <h4 className="font-medium leading-none">{props.title}</h4>
        {/*<p className="text-sm text-muted-foreground">
          Set the settings for the emulation.
        </p>*/}
      </div>

      <div className="grid gap-2 overflow-auto overflow-x-hidden max-h-45 mt-2 mb-2">
        {props.items.map((item, index) => {
          return (
            <div
              key={`item-list-item-${index}-${item}`}
              className="flex gap-3 items-center min-w-0"
            >
              <Label className="flex-1 text-left truncate min-w-0">
                {item}
              </Label>
              <Button
                onClick={() => removeItem(index)}
                variant="ghost"
                size="sm"
                className="fancy rounded-lg"
              >
                <Trash />
              </Button>
            </div>
          );
        })}
      </div>

      <form
        onSubmit={(e) => {
          const nameInput = (e.target as any).elements.name;
          const newItem = nameInput.value;
          nameInput.value = "";

          addItem(newItem);
          e.preventDefault();
        }}
      >
        <div className="flex gap-3 items-center">
          <Input id="name" />
          <Button
            type="submit"
            variant="secondary"
            className="fancy rounded-lg"
          >
            <Plus />
          </Button>
        </div>
      </form>
    </div>
  );
}

```

`page/src/components/output.tsx`:

```tsx
import React from "react";
import { List, ListImperativeAPI, type RowComponentProps } from "react-window";
import { ArrowDown } from "react-bootstrap-icons";
import { Button } from "./ui/button";

interface OutputProps {}

interface ColorState {
  color: string;
}

interface OutputState extends ColorState {
  lines: LogLine[];
}

enum SizeState {
  Final,
  Updating,
}

interface FullOutputState extends OutputState {
  grouper: OutputGrouper;
  height: number;
  width: number;
  state: SizeState;
  autoScroll: boolean;
}

interface LogLine {
  text: string;
  classNames: string;
}

function removeSubstringFromStart(str: string, substring: string): string {
  if (str.startsWith(substring)) {
    return str.slice(substring.length);
  }
  return str;
}

function removeSubstringFromEnd(str: string, substring: string): string {
  if (str.endsWith(substring)) {
    return str.slice(0, -substring.length);
  }
  return str;
}

function removeSpanFromStart(str: string, color: string) {
  const pattern = /^<span class="(terminal-[a-z-]+)">/;
  const match = str.match(pattern);

  if (match) {
    const terminalValue = match[1];
    const cleanedString = str.replace(pattern, "");
    return [cleanedString, terminalValue];
  }

  return [str, color];
}

function extractColor(line: string, colorState: ColorState) {
  while (true) {
    const newLine = removeSubstringFromStart(line, "</span>");
    if (newLine == line) {
      break;
    }

    line = newLine;
    colorState.color = "";
  }

  const [nextLine, color] = removeSpanFromStart(line, colorState.color);

  const finalLine = removeSubstringFromEnd(nextLine, "</span>");
  if (finalLine != nextLine) {
    colorState.color = "";
  } else {
    colorState.color = color;
  }

  return [finalLine, color];
}

function renderLine(line: string, colorState: ColorState) {
  const [newLine, color] = extractColor(line, colorState);

  return {
    text: newLine,
    classNames: "whitespace-nowrap block " + color,
  };
}

function renderLines(lines: string[], color: string): OutputState {
  var state: ColorState = {
    color,
  };

  const resultLines = lines.map((line) => renderLine(line, state));

  return {
    lines: resultLines,
    color: state.color,
  };
}

function mergeLines(
  previousState: OutputState,
  newLines: string[],
): OutputState {
  const result = renderLines(newLines, previousState.color);
  return {
    lines: previousState.lines.concat(result.lines),
    color: result.color,
  };
}

class OutputGrouper {
  private lines: string[];
  private flushQueued: boolean;
  handler: (lines: string[]) => void;

  constructor() {
    this.lines = [];
    this.flushQueued = false;
    this.handler = () => {};
  }

  clear() {
    this.lines = [];
    this.flushQueued = false;
  }

  flush() {
    const lines = this.lines;
    this.lines = [];
    this.handler(lines);
  }

  queueFlush() {
    if (this.flushQueued) {
      return false;
    }

    this.flushQueued = true;

    requestAnimationFrame(() => {
      if (!this.flushQueued) {
        return;
      }

      this.flushQueued = false;
      this.flush();
    });
  }

  storeLines(lines: string[]) {
    this.lines = this.lines.concat(lines);
    this.queueFlush();
  }
}

function LogLineRow({
  ariaAttributes,
  lines,
  index,
  style,
}: RowComponentProps<{
  lines: LogLine[];
}>) {
  {
    const line = lines[index];
    return (
      <span className={line.classNames} style={style} {...ariaAttributes}>
        {line.text}
      </span>
    );
  }
}

export class Output extends React.Component<OutputProps, FullOutputState> {
  private outputRef: React.RefObject<HTMLDivElement | null>;
  private listRef: React.RefObject<ListImperativeAPI | null>;
  private resizeObserver: ResizeObserver;
  private scrollElement: HTMLDivElement | null | undefined;

  constructor(props: OutputProps) {
    super(props);

    this.clear = this.clear.bind(this);
    this.logLine = this.logLine.bind(this);
    this.logLines = this.logLines.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.scrollListToEnd = this.scrollListToEnd.bind(this);
    this.updateDimensions = this.updateDimensions.bind(this);

    this.outputRef = React.createRef();
    this.listRef = React.createRef();
    this.resizeObserver = new ResizeObserver(this.updateDimensions);

    this.state = {
      lines: [],
      color: "",
      grouper: new OutputGrouper(),
      height: 10,
      width: 10,
      state: SizeState.Final,
      autoScroll: true,
    };

    this.state.grouper.handler = (lines: string[]) => {
      this.setState((s) => mergeLines(s, lines));
    };
  }

  handleScroll(e: Event) {
    const threshold = 40;
    const element = e.target as HTMLElement;
    const { scrollTop, scrollHeight, clientHeight } = element;
    const isAtEnd = scrollTop + clientHeight >= scrollHeight - threshold;

    this.setState({ autoScroll: isAtEnd });
  }

  unregisterScrollListener() {
    this.scrollElement?.removeEventListener("scroll", this.handleScroll);
  }

  registerScrollListener(element: HTMLDivElement | null | undefined) {
    if (element == this.scrollElement) {
      return;
    }

    this.unregisterScrollListener();
    this.scrollElement = element;
    element?.addEventListener("scroll", this.handleScroll);
  }

  registerScrollOnList() {
    this.registerScrollListener(this.listRef.current?.element);
  }

  componentDidMount() {
    this.updateDimensions();

    if (this.outputRef.current) {
      this.resizeObserver.observe(this.outputRef.current);
    }

    this.registerScrollOnList();
  }

  componentWillUnmount() {
    this.resizeObserver.disconnect();
    this.unregisterScrollListener();
  }

  scrollListToEnd() {
    if (this.listRef.current && this.state.lines.length > 0) {
      this.listRef.current.scrollToRow({
        index: this.state.lines.length - 1,
        behavior: "instant",
      });
    }

    this.setState({ autoScroll: true });
  }

  componentDidUpdate(_: OutputProps, prevState: FullOutputState) {
    this.registerScrollOnList();

    if (
      this.state.autoScroll &&
      prevState.lines.length != this.state.lines.length
    ) {
      this.scrollListToEnd();
    }
  }

  clear() {
    this.state.grouper.clear();
    this.setState({
      lines: [],
      color: "",
    });
  }

  updateDimensions() {
    if (!this.outputRef.current) {
      return;
    }

    if (this.state.state == SizeState.Updating) {
      this.setState({
        width: this.outputRef.current.offsetWidth - 1,
        height: this.outputRef.current.offsetHeight - 1,
        state: SizeState.Final,
      });

      return;
    }

    this.setState(
      {
        width: 0,
        height: 0,
        state: SizeState.Updating,
      },
      this.triggerDimensionUpdate.bind(this),
    );
  }

  triggerDimensionUpdate() {
    requestAnimationFrame(() => {
      this.updateDimensions();
    });
  }

  logLines(lines: string[]) {
    this.state.grouper.storeLines(lines);
  }

  logLine(line: string) {
    this.logLines([line]);
  }

  render() {
    return (
      <div className="terminal-output" ref={this.outputRef}>
        <List
          listRef={this.listRef}
          overscanCount={30}
          rowComponent={LogLineRow}
          rowCount={this.state.lines.length}
          rowProps={{ lines: this.state.lines }}
          rowHeight={20}
          style={{ height: this.state.height, width: this.state.width }}
        />
        <Button
          title="Scroll to end"
          className={
            "absolute bottom-6 right-6 z-50 terminal-glass transition-opacity duration-50 ease-linear " +
            (this.state.autoScroll ? "opacity-0" : "")
          }
          variant="secondary"
          onClick={this.scrollListToEnd}
        >
          <ArrowDown />
        </Button>
      </div>
    );
  }
}

```

`page/src/components/settings-menu.tsx`:

```tsx
import React from "react";
import { Checkbox } from "./ui/checkbox";
import { Label } from "./ui/label";

import { Settings } from "@/settings";
import { TextTooltip } from "./text-tooltip";
import { ItemList } from "./item-list";

import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { ChevronDown } from "react-bootstrap-icons";
import { Input } from "./ui/input";
import { RadioGroup, RadioGroupItem } from "./ui/radio-group";

interface SettingsMenuProps {
  settings: Settings;
  allowWasm64: boolean;
  onChange: (settings: Settings) => void;
}

interface SettingsLabelProps {
  htmlFor?: string | undefined;
  text: React.ReactNode;
  tooltip: React.ReactNode;
}

function SettingsLabel(props: SettingsLabelProps) {
  return (
    <Label htmlFor={props.htmlFor}>
      <TextTooltip tooltip={props.tooltip}>{props.text}</TextTooltip>
    </Label>
  );
}

export class SettingsMenu extends React.Component<SettingsMenuProps, Settings> {
  constructor(props: SettingsMenuProps) {
    super(props);
    this.getSettings = this.getSettings.bind(this);
    this.state = props.settings;
  }

  getSettings() {
    return this.state;
  }

  updateSettings(settings: Settings) {
    this.setState(() => settings);
  }

  componentDidUpdate(_: SettingsMenuProps, oldSettings: Settings) {
    if (JSON.stringify(oldSettings) !== JSON.stringify(this.state)) {
      this.props.onChange(this.state);
    }
  }

  updateArgv(commandLine: string) {
    this.setState({ commandLine });
  }

  render() {
    return (
      <div className="grid gap-3">
        <div className="space-y-2 mb-1">
          <h4 className="font-medium leading-none">Settings</h4>
          <p className="text-sm text-muted-foreground">
            Set the settings for the emulation.
          </p>
        </div>

        <div className="flex gap-6 mb-2">
          <RadioGroup
            defaultValue="regular"
            value={this.state.logging}
            onValueChange={(value) => this.setState({ logging: value })}
          >
            <div className="flex items-center gap-4">
              <RadioGroupItem value="regular" id="settings-regular" />
              <SettingsLabel
                htmlFor="settings-regular"
                text={"Regular Logging"}
                tooltip={
                  "Default logging behaviour, not too verbose, but also not very concise"
                }
              />
            </div>
            <div className="flex items-center gap-4">
              <RadioGroupItem value="verbose" id="settings-verbose" />
              <SettingsLabel
                htmlFor="settings-verbose"
                text={"Verbose Logging"}
                tooltip={
                  "Very detailed logging of all function calls and accesses"
                }
              />
            </div>
            <div className="flex items-center gap-4">
              <RadioGroupItem value="concise" id="settings-concise" />
              <SettingsLabel
                htmlFor="settings-concise"
                text={"Concise Logging"}
                tooltip={"Suppress logging until the application code runs"}
              />
            </div>
            <div className="flex items-center gap-4">
              <RadioGroupItem value="silent" id="settings-silent" />
              <SettingsLabel
                htmlFor="settings-silent"
                text={"Silent Logging"}
                tooltip={"Suppress all logging except for stdout"}
              />
            </div>
          </RadioGroup>
        </div>

        <div className="flex gap-4">
          <Checkbox
            id="settings-buffer"
            checked={this.state.bufferStdout}
            onCheckedChange={(checked: boolean) => {
              this.setState({ bufferStdout: checked });
            }}
          />
          <SettingsLabel
            htmlFor="settings-buffer"
            text={"Buffer stdout"}
            tooltip={
              "Group stdout and print everything when the emulation ends"
            }
          />
        </div>

        <div className="flex gap-4">
          <Checkbox
            id="settings-exec"
            checked={this.state.execAccess}
            onCheckedChange={(checked: boolean) => {
              this.setState({ execAccess: checked });
            }}
          />
          <SettingsLabel
            htmlFor="settings-exec"
            text={"Log exec Memory Access"}
            tooltip={"Log when the application reads/writes executable memory"}
          />
        </div>

        <div className="flex gap-4">
          <Checkbox
            id="settings-foreign"
            checked={this.state.foreignAccess}
            onCheckedChange={(checked: boolean) => {
              this.setState({ foreignAccess: checked });
            }}
          />
          <SettingsLabel
            htmlFor="settings-foreign"
            text={"Log Foreign Access"}
            tooltip={
              "Log when the application reads/writes memory of other modules"
            }
          />
        </div>

        <div className="flex gap-4">
          <Checkbox
            id="settings-summary"
            checked={this.state.instructionSummary}
            onCheckedChange={(checked: boolean) => {
              this.setState({ instructionSummary: checked });
            }}
          />
          <SettingsLabel
            htmlFor="settings-summary"
            text={"Print Instruction Summary"}
            tooltip={"Print summary of executed instructions"}
          />
        </div>

        <div className="flex gap-4">
          <Checkbox
            id="settings-persist"
            checked={this.state.persist}
            onCheckedChange={(checked: boolean) => {
              this.setState({ persist: checked });
            }}
          />
          <SettingsLabel
            htmlFor="settings-persist"
            text={"Persist Filesystem"}
            tooltip={
              "Persist files and folders that were created, modified or deleted during the emulation"
            }
          />
        </div>

        <div className="flex gap-4">
          <Checkbox
            id="settings-mem64"
            disabled={!this.props.allowWasm64}
            checked={this.state.wasm64}
            onCheckedChange={(checked: boolean) => {
              this.setState({ wasm64: checked });
            }}
          />
          <SettingsLabel
            htmlFor="settings-mem64"
            text={"64-Bit WebAssembly"}
            tooltip={
              "Use 64-bit WebAssembly which supports emulating applications that require more than 2gb of memory"
            }
          />
        </div>

        <div className="flex gap-6 my-2">
          <Input
            id="settings-argv"
            placeholder="Command-Line Arguments"
            value={this.state.commandLine}
            onChange={(e) => this.updateArgv(e.target.value)}
          />
        </div>

        <Popover>
          <PopoverTrigger>
            <TextTooltip tooltip="Don't log executions of listed functions">
              <div className="flex items-center mb-2">
                <Label className="flex-1 text-left cursor-pointer">
                  Ignored Functions
                </Label>
                <ChevronDown />
              </div>
            </TextTooltip>
          </PopoverTrigger>
          <PopoverContent className="shadow-2xl">
            <ItemList
              title="Ignored Functions"
              items={this.state.ignoredFunctions}
              onChange={(items) => this.setState({ ignoredFunctions: items })}
            />
          </PopoverContent>
        </Popover>

        <Popover>
          <PopoverTrigger>
            <TextTooltip tooltip="Log interactions of additional modules">
              <div className="flex items-center mb-1">
                <Label className="flex-1 text-left cursor-pointer">
                  Interesting Modules
                </Label>
                <ChevronDown />
              </div>
            </TextTooltip>
          </PopoverTrigger>
          <PopoverContent className="shadow-2xl">
            <ItemList
              title="Interesting Modules"
              items={this.state.interestingModules}
              onChange={(items) => this.setState({ interestingModules: items })}
            />
          </PopoverContent>
        </Popover>
      </div>
    );
  }
}

```

`page/src/components/status-indicator.tsx`:

```tsx
import { Badge } from "@/components/ui/badge";
import { CircleFill } from "react-bootstrap-icons";
import { EmulationStatus, EmulationState as State } from "@/emulator";

function getStateName(state: State) {
  switch (state) {
    case State.Stopped:
      return "Stopped";
    case State.Paused:
      return "Paused";
    case State.Running:
      return "Running";
    case State.Failed:
      return "Failed";
    case State.Success:
      return "Success";
    default:
      return "";
  }
}

function getStateColor(state: State) {
  switch (state) {
    case State.Failed:
      return "bg-orange-600";
    case State.Paused:
      return "bg-amber-500";
    case State.Success:
      return "bg-lime-600";
    case State.Stopped:
      return "bg-yellow-800";
    case State.Running:
      return "bg-sky-500";
    default:
      return "";
  }
}

function getStateEmoji(state: State) {
  switch (state) {
    case State.Stopped:
      return "ğŸŸ¤";
    case State.Paused:
      return "ğŸŸ¡";
    case State.Running:
      return "ğŸ”µ";
    case State.Failed:
      return "ğŸ”´";
    case State.Success:
      return "ğŸŸ¢";
    default:
      return "";
  }
}

function getFilename(path: string) {
  const lastSlash = path.lastIndexOf("/");
  if (lastSlash == -1) {
    return path;
  }

  return path.substring(lastSlash + 1);
}

export interface StatusIndicatorProps {
  state: State;
  application: string | undefined;
}

export function StatusIndicator(props: StatusIndicatorProps) {
  if (props.application && props.application.length > 0) {
    document.title = `${getStateEmoji(props.state)} ${getFilename(props.application)} | Sogen`;
  }

  return (
    <Badge variant="outline">
      <CircleFill
        className={
          getStateColor(props.state) +
          " rounded-full mr-1 n  duration-200 ease-in-out"
        }
        color="transparent"
      />
      {getStateName(props.state)}
    </Badge>
  );
}

```

`page/src/components/text-tooltip.tsx`:

```tsx
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";

export interface TextTooltipProps {
  children?: React.ReactNode;
  tooltip: React.ReactNode;
}

export function TextTooltip(props: TextTooltipProps) {
  return (
    <Tooltip delayDuration={700} disableHoverableContent>
      <TooltipTrigger asChild>
        <span>{props.children}</span>
      </TooltipTrigger>
      <TooltipContent>{props.tooltip}</TooltipContent>
    </Tooltip>
  );
}

```

`page/src/components/theme-provider.tsx`:

```tsx
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
};

type ThemeProviderState = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "vite-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme,
  );

  useEffect(() => {
    const root = window.document.documentElement;

    root.classList.remove("light", "dark");

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light";

      root.classList.add(systemTheme);
      return;
    }

    root.classList.add(theme);
  }, [theme]);

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme);
      setTheme(theme);
    },
  };

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext);

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider");

  return context;
};

```

`page/src/components/ui/badge.tsx`:

```tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span";

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}

export { Badge, badgeVariants };

```

`page/src/components/ui/breadcrumb.tsx`:

```tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />;
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className,
      )}
      {...props}
    />
  );
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  );
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
}) {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  );
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  );
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  );
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  );
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};

```

`page/src/components/ui/button.tsx`:

```tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };

```

`page/src/components/ui/card.tsx`:

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className,
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className,
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className,
      )}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
};

```

`page/src/components/ui/checkbox.tsx`:

```tsx
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };

```

`page/src/components/ui/context-menu.tsx`:

```tsx
import * as React from "react";
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />;
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  );
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  );
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  );
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />;
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  );
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  );
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  );
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  );
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  );
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};

```

`page/src/components/ui/dialog.tsx`:

```tsx
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

```

`page/src/components/ui/drawer.tsx`:

```tsx
import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />;
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />;
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />;
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />;
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className,
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  );
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  );
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  );
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  );
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};

```

`page/src/components/ui/dropdown-menu.tsx`:

```tsx
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
};

```

`page/src/components/ui/input.tsx`:

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

export { Input };

```

`page/src/components/ui/label.tsx`:

```tsx
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";

import { cn } from "@/lib/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className,
      )}
      {...props}
    />
  );
}

export { Label };

```

`page/src/components/ui/popover.tsx`:

```tsx
import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };

```

`page/src/components/ui/radio-group.tsx`:

```tsx
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { CircleIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  );
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };

```

`page/src/components/ui/scroll-area.tsx`:

```tsx
import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "@/lib/utils";

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className,
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}

export { ScrollArea, ScrollBar };

```

`page/src/components/ui/separator.tsx`:

```tsx
"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className,
      )}
      {...props}
    />
  );
}

export { Separator };

```

`page/src/components/ui/sheet.tsx`:

```tsx
import * as React from "react";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left";
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className,
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  );
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  );
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  );
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};

```

`page/src/components/ui/sidebar.tsx`:

```tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { VariantProps, cva } from "class-variance-authority";
import { PanelLeftIcon } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open],
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className,
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right";
  variant?: "sidebar" | "floating" | "inset";
  collapsible?: "offcanvas" | "icon" | "none";
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className,
        )}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)",
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className,
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar();

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className,
      )}
      {...props}
    />
  );
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className,
      )}
      {...props}
    />
  );
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  );
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  );
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className,
      )}
      {...props}
    />
  );
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div";

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className,
      )}
      {...props}
    />
  );
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  );
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  );
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  );
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className,
      )}
      {...props}
    />
  );
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean;
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  );
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
  size?: "sm" | "md";
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

```

`page/src/components/ui/skeleton.tsx`:

```tsx
import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  );
}

export { Skeleton };

```

`page/src/components/ui/tabs.tsx`:

```tsx
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  );
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className,
      )}
      {...props}
    />
  );
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  );
}

export { Tabs, TabsList, TabsTrigger, TabsContent };

```

`page/src/components/ui/tooltip.tsx`:

```tsx
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-neutral-700 text-secondary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className,
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-neutral-700 fill-neutral-700 z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

```

`page/src/components/youtube-video.tsx`:

```tsx
export interface FolderProps {
  id: string;
}

export function YoutubeVideo(props: FolderProps) {
  const style = `
* {
  padding: 0;
  margin: 0;
  overflow: hidden;
}

html,
body {
  height: 100%;
}

img,
div {
  position: absolute;
  width: 100%;
  top: 0;
  bottom: 0;
  margin: auto;
}

div {
  height: 1.5em;
  text-align: center;
  font: 30px/1.5 sans-serif;
  color: white;
  overflow: visible;
}

span {
  background: red;
  padding: 10px 20px;
  border-radius: 15px;
  box-shadow: 3px 5px 10px #0000007a;
}
`;

  return (
    <iframe
      className="w-full h-full"
      title="Sogen Emulator Overview"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerPolicy="strict-origin-when-cross-origin"
      allowFullScreen
      srcDoc={`
        <style>${style}</style>
        <a href="https://www.youtube.com/embed/${props.id}/?autoplay=1&rel=0&hl=en">
            <img src="https://img.youtube.com/vi/${props.id}/maxresdefault.jpg">
            <div>
                <span>&nbsp;â–¶</span>
            </div>
        </a>`}
    ></iframe>
  );
}

```

`page/src/download.ts`:

```ts
export type DownloadProgressHandler = (
  receivedBytes: number,
  totalBytes: number,
) => void;

export type DownloadPercentHandler = (percent: number) => void;

export function makePercentHandler(
  handler: DownloadPercentHandler,
): DownloadProgressHandler {
  const progress = {
    tracked: 0,
  };

  return (current, total) => {
    if (total == 0) {
      return;
    }

    const percent = Math.floor((current * 100) / total);
    const sanePercent = Math.max(Math.min(percent, 100), 0);

    if (sanePercent + 1 > progress.tracked) {
      progress.tracked = sanePercent + 1;
      handler(sanePercent);
    }
  };
}

export function downloadBinaryFile(
  file: string,
  progressCallback: DownloadProgressHandler,
) {
  return fetch(file, {
    method: "GET",
    headers: {
      "Content-Type": "application/octet-stream",
    },
  }).then((response) => {
    const maybeReader = response.body?.getReader();
    if (!maybeReader) {
      throw new Error("Bad reader");
    }

    const reader = maybeReader;

    const contentLength = parseInt(
      response.headers?.get("Content-Length") || "0",
    );

    let receivedLength = 0;
    let chunks: Uint8Array<ArrayBufferLike>[] = [];

    function processData(
      res: ReadableStreamReadResult<Uint8Array<ArrayBufferLike>>,
    ): Promise<ArrayBuffer> {
      if (res.value) {
        chunks.push(res.value);
        receivedLength += res.value.length;
      }

      progressCallback(receivedLength, contentLength);

      if (!res.done) {
        return reader.read().then(processData);
      }
      const chunksAll = new Uint8Array(receivedLength);
      let position = 0;
      for (const chunk of chunks) {
        chunksAll.set(new Uint8Array(chunk), position);
        position += chunk.length;
      }

      return Promise.resolve(chunksAll.buffer);
    }

    return reader.read().then(processData);
  });
}

export function downloadBinaryFilePercent(
  file: string,
  progressCallback: DownloadPercentHandler,
) {
  return downloadBinaryFile(file, makePercentHandler(progressCallback));
}

```

`page/src/emulator.ts`:

```ts
import { Settings, translateSettings } from "./settings";

import * as flatbuffers from "flatbuffers";
import * as fbDebugger from "@/fb/debugger";

type LogHandler = (lines: string[]) => void;

export enum EmulationState {
  Stopped,
  Paused,
  Running,
  Success,
  Failed,
}

export interface EmulationStatus {
  activeThreads: number;
  reservedMemory: BigInt;
  committedMemory: BigInt;
  executedInstructions: BigInt;
}

function createDefaultEmulationStatus(): EmulationStatus {
  return {
    executedInstructions: BigInt(0),
    activeThreads: 0,
    reservedMemory: BigInt(0),
    committedMemory: BigInt(0),
  };
}

export function isFinalState(state: EmulationState) {
  switch (state) {
    case EmulationState.Stopped:
    case EmulationState.Success:
    case EmulationState.Failed:
      return true;

    default:
      return false;
  }
}

function base64Encode(uint8Array: Uint8Array): string {
  let binaryString = "";
  for (let i = 0; i < uint8Array.byteLength; i++) {
    binaryString += String.fromCharCode(uint8Array[i]);
  }

  return btoa(binaryString);
}

function base64Decode(data: string) {
  const binaryString = atob(data);

  const len = binaryString.length;
  const bytes = new Uint8Array(len);

  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }

  return bytes;
}

function decodeEvent(data: string) {
  const array = base64Decode(data);
  const buffer = new flatbuffers.ByteBuffer(array);
  const event = fbDebugger.DebugEvent.getRootAsDebugEvent(buffer);
  return event.unpack();
}

type StateChangeHandler = (state: EmulationState) => void;
type StatusUpdateHandler = (status: EmulationStatus) => void;

const cacheBuster = undefined; //import.meta.env.VITE_BUILD_TIME || Date.now();

export class Emulator {
  logHandler: LogHandler;
  stateChangeHandler: StateChangeHandler;
  stautsUpdateHandler: StatusUpdateHandler;
  terminatePromise: Promise<number | null>;
  terminateResolve: (value: number | null) => void;
  terminateReject: (reason?: any) => void;
  worker: Worker;
  state: EmulationState = EmulationState.Stopped;
  exit_status: number | null = null;
  start_time: Date = new Date();
  pause_time: Date | null = null;
  paused_time: number = 0;

  constructor(
    logHandler: LogHandler,
    stateChangeHandler: StateChangeHandler,
    stautsUpdateHandler: StatusUpdateHandler,
  ) {
    this.logHandler = logHandler;
    this.stateChangeHandler = stateChangeHandler;
    this.stautsUpdateHandler = stautsUpdateHandler;
    this.terminateResolve = () => {};
    this.terminateReject = () => {};
    this.terminatePromise = new Promise((resolve, reject) => {
      this.terminateResolve = resolve;
      this.terminateReject = reject;
    });

    const busterParams = cacheBuster ? `?${cacheBuster}` : "";

    this.worker = new Worker("./emulator-worker.js" + busterParams);
    this.worker.onerror = this._onError.bind(this);
    this.worker.onmessage = (e) => queueMicrotask(() => this._onMessage(e));
  }

  async start(settings: Settings, file: string) {
    this.start_time = new Date();
    this.pause_time = null;
    this.paused_time = 0;
    this._setState(EmulationState.Running);
    this.stautsUpdateHandler(createDefaultEmulationStatus());

    const options = translateSettings(settings);

    this.worker.postMessage({
      message: "run",
      data: {
        file,
        options: options.emulatorOptions,
        arguments: options.applicationOptions,
        persist: settings.persist,
        wasm64: settings.wasm64,
        cacheBuster,
      },
    });
  }

  updateState() {
    this.sendEvent(
      new fbDebugger.DebugEventT(
        fbDebugger.Event.GetStateRequest,
        new fbDebugger.GetStateRequestT(),
      ),
    );
  }

  getState() {
    return this.state;
  }

  stop() {
    this.worker.terminate();
    this._setState(EmulationState.Stopped);
    this.terminateResolve(null);
  }

  onTerminate() {
    return this.terminatePromise;
  }

  sendEvent(event: fbDebugger.DebugEventT) {
    const builder = new flatbuffers.Builder(1024);
    fbDebugger.DebugEvent.finishDebugEventBuffer(builder, event.pack(builder));

    const message = base64Encode(builder.asUint8Array());

    this.worker.postMessage({
      message: "event",
      data: message,
    });
  }

  pause() {
    this.sendEvent(
      new fbDebugger.DebugEventT(
        fbDebugger.Event.PauseRequest,
        new fbDebugger.PauseRequestT(),
      ),
    );

    this.updateState();
  }

  resume() {
    this.sendEvent(
      new fbDebugger.DebugEventT(
        fbDebugger.Event.RunRequest,
        new fbDebugger.RunRequestT(),
      ),
    );

    this.updateState();
  }

  getExecutionTime() {
    const endTime = this.pause_time ? this.pause_time : new Date();
    const totalTime = endTime.getTime() - this.start_time.getTime();
    return totalTime - this.paused_time;
  }

  logError(message: string) {
    this.logHandler([`<span class="terminal-red">${message}</span>`]);
  }

  _onError(ev: ErrorEvent) {
    try {
      this.worker.terminate();
    } catch (e) {}

    this.logError(`Emulator encountered fatal error: ${ev.message}`);
    this._setState(EmulationState.Failed);
    this.terminateResolve(-1);
  }

  _onMessage(event: MessageEvent) {
    if (event.data.message == "log") {
      this.logHandler(event.data.data);
    } else if (event.data.message == "event") {
      this._onEvent(decodeEvent(event.data.data));
    } else if (event.data.message == "end") {
      this._setState(
        this.exit_status === 0 ? EmulationState.Success : EmulationState.Failed,
      );
      this.terminateResolve(this.exit_status);
    }
  }

  _onEvent(event: fbDebugger.DebugEventT) {
    switch (event.eventType) {
      case fbDebugger.Event.GetStateResponse:
        this._handle_state_response(
          event.event as fbDebugger.GetStateResponseT,
        );
        break;
      case fbDebugger.Event.ApplicationExit:
        this._handle_application_exit(
          event.event as fbDebugger.ApplicationExitT,
        );
        break;
      case fbDebugger.Event.EmulationStatus:
        this._handle_emulation_status(
          event.event as fbDebugger.EmulationStatusT,
        );
        break;
    }
  }

  _setState(state: EmulationState) {
    this.state = state;

    if (isFinalState(this.state) || this.state === EmulationState.Paused) {
      this.pause_time = new Date();
    } else if (this.state == EmulationState.Running && this.pause_time) {
      this.paused_time += new Date().getTime() - this.pause_time.getTime();
      this.pause_time = null;
    }

    this.stateChangeHandler(this.state);
  }

  _handle_application_exit(info: fbDebugger.ApplicationExitT) {
    this.exit_status = info.exitStatus;
  }

  _handle_emulation_status(info: fbDebugger.EmulationStatusT) {
    this.stautsUpdateHandler({
      activeThreads: info.activeThreads,
      executedInstructions: info.executedInstructions,
      reservedMemory: info.reservedMemory,
      committedMemory: info.committedMemory,
    });
  }

  _handle_state_response(response: fbDebugger.GetStateResponseT) {
    switch (response.state) {
      case fbDebugger.State.None:
        this._setState(EmulationState.Stopped);
        break;

      case fbDebugger.State.Paused:
        this._setState(EmulationState.Paused);
        break;

      case fbDebugger.State.Running:
        this._setState(EmulationState.Running);
        break;
    }
  }
}

```

`page/src/fb/debugger.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

export { ApplicationExit, ApplicationExitT } from './debugger/application-exit.js';
export { DebugEvent, DebugEventT } from './debugger/debug-event.js';
export { EmulationStatus, EmulationStatusT } from './debugger/emulation-status.js';
export { Event } from './debugger/event.js';
export { GetStateRequest, GetStateRequestT } from './debugger/get-state-request.js';
export { GetStateResponse, GetStateResponseT } from './debugger/get-state-response.js';
export { PauseRequest, PauseRequestT } from './debugger/pause-request.js';
export { ReadMemoryRequest, ReadMemoryRequestT } from './debugger/read-memory-request.js';
export { ReadMemoryResponse, ReadMemoryResponseT } from './debugger/read-memory-response.js';
export { ReadRegisterRequest, ReadRegisterRequestT } from './debugger/read-register-request.js';
export { ReadRegisterResponse, ReadRegisterResponseT } from './debugger/read-register-response.js';
export { RunRequest, RunRequestT } from './debugger/run-request.js';
export { State } from './debugger/state.js';
export { WriteMemoryRequest, WriteMemoryRequestT } from './debugger/write-memory-request.js';
export { WriteMemoryResponse, WriteMemoryResponseT } from './debugger/write-memory-response.js';
export { WriteRegisterRequest, WriteRegisterRequestT } from './debugger/write-register-request.js';
export { WriteRegisterResponse, WriteRegisterResponseT } from './debugger/write-register-response.js';

```

`page/src/fb/debugger/application-exit.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class ApplicationExit implements flatbuffers.IUnpackableObject<ApplicationExitT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ApplicationExit {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsApplicationExit(bb:flatbuffers.ByteBuffer, obj?:ApplicationExit):ApplicationExit {
  return (obj || new ApplicationExit()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsApplicationExit(bb:flatbuffers.ByteBuffer, obj?:ApplicationExit):ApplicationExit {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ApplicationExit()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

exitStatus():number|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : null;
}

mutate_exit_status(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

static startApplicationExit(builder:flatbuffers.Builder) {
  builder.startObject(1);
}

static addExitStatus(builder:flatbuffers.Builder, exitStatus:number) {
  builder.addFieldInt32(0, exitStatus, null);
}

static endApplicationExit(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createApplicationExit(builder:flatbuffers.Builder, exitStatus:number|null):flatbuffers.Offset {
  ApplicationExit.startApplicationExit(builder);
  if (exitStatus !== null)
    ApplicationExit.addExitStatus(builder, exitStatus);
  return ApplicationExit.endApplicationExit(builder);
}

unpack(): ApplicationExitT {
  return new ApplicationExitT(
    this.exitStatus()
  );
}


unpackTo(_o: ApplicationExitT): void {
  _o.exitStatus = this.exitStatus();
}
}

export class ApplicationExitT implements flatbuffers.IGeneratedObject {
constructor(
  public exitStatus: number|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return ApplicationExit.createApplicationExit(builder,
    this.exitStatus
  );
}
}

```

`page/src/fb/debugger/debug-event.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { ApplicationExit, ApplicationExitT } from '../debugger/application-exit.js';
import { EmulationStatus, EmulationStatusT } from '../debugger/emulation-status.js';
import { Event, unionToEvent, unionListToEvent } from '../debugger/event.js';
import { GetStateRequest, GetStateRequestT } from '../debugger/get-state-request.js';
import { GetStateResponse, GetStateResponseT } from '../debugger/get-state-response.js';
import { PauseRequest, PauseRequestT } from '../debugger/pause-request.js';
import { ReadMemoryRequest, ReadMemoryRequestT } from '../debugger/read-memory-request.js';
import { ReadMemoryResponse, ReadMemoryResponseT } from '../debugger/read-memory-response.js';
import { ReadRegisterRequest, ReadRegisterRequestT } from '../debugger/read-register-request.js';
import { ReadRegisterResponse, ReadRegisterResponseT } from '../debugger/read-register-response.js';
import { RunRequest, RunRequestT } from '../debugger/run-request.js';
import { WriteMemoryRequest, WriteMemoryRequestT } from '../debugger/write-memory-request.js';
import { WriteMemoryResponse, WriteMemoryResponseT } from '../debugger/write-memory-response.js';
import { WriteRegisterRequest, WriteRegisterRequestT } from '../debugger/write-register-request.js';
import { WriteRegisterResponse, WriteRegisterResponseT } from '../debugger/write-register-response.js';


export class DebugEvent implements flatbuffers.IUnpackableObject<DebugEventT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):DebugEvent {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsDebugEvent(bb:flatbuffers.ByteBuffer, obj?:DebugEvent):DebugEvent {
  return (obj || new DebugEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsDebugEvent(bb:flatbuffers.ByteBuffer, obj?:DebugEvent):DebugEvent {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new DebugEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

eventType():Event {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Event.NONE;
}

event<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

static startDebugEvent(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addEventType(builder:flatbuffers.Builder, eventType:Event) {
  builder.addFieldInt8(0, eventType, Event.NONE);
}

static addEvent(builder:flatbuffers.Builder, eventOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, eventOffset, 0);
}

static endDebugEvent(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishDebugEventBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset);
}

static finishSizePrefixedDebugEventBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, undefined, true);
}

static createDebugEvent(builder:flatbuffers.Builder, eventType:Event, eventOffset:flatbuffers.Offset):flatbuffers.Offset {
  DebugEvent.startDebugEvent(builder);
  DebugEvent.addEventType(builder, eventType);
  DebugEvent.addEvent(builder, eventOffset);
  return DebugEvent.endDebugEvent(builder);
}

unpack(): DebugEventT {
  return new DebugEventT(
    this.eventType(),
    (() => {
      const temp = unionToEvent(this.eventType(), this.event.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })()
  );
}


unpackTo(_o: DebugEventT): void {
  _o.eventType = this.eventType();
  _o.event = (() => {
      const temp = unionToEvent(this.eventType(), this.event.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
}
}

export class DebugEventT implements flatbuffers.IGeneratedObject {
constructor(
  public eventType: Event = Event.NONE,
  public event: ApplicationExitT|EmulationStatusT|GetStateRequestT|GetStateResponseT|PauseRequestT|ReadMemoryRequestT|ReadMemoryResponseT|ReadRegisterRequestT|ReadRegisterResponseT|RunRequestT|WriteMemoryRequestT|WriteMemoryResponseT|WriteRegisterRequestT|WriteRegisterResponseT|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const event = builder.createObjectOffset(this.event);

  return DebugEvent.createDebugEvent(builder,
    this.eventType,
    event
  );
}
}

```

`page/src/fb/debugger/emulation-status.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class EmulationStatus implements flatbuffers.IUnpackableObject<EmulationStatusT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EmulationStatus {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEmulationStatus(bb:flatbuffers.ByteBuffer, obj?:EmulationStatus):EmulationStatus {
  return (obj || new EmulationStatus()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEmulationStatus(bb:flatbuffers.ByteBuffer, obj?:EmulationStatus):EmulationStatus {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EmulationStatus()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

activeThreads():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_active_threads(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

reservedMemory():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_reserved_memory(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

committedMemory():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_committed_memory(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

executedInstructions():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_executed_instructions(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

static startEmulationStatus(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addActiveThreads(builder:flatbuffers.Builder, activeThreads:number) {
  builder.addFieldInt32(0, activeThreads, 0);
}

static addReservedMemory(builder:flatbuffers.Builder, reservedMemory:bigint) {
  builder.addFieldInt64(1, reservedMemory, BigInt('0'));
}

static addCommittedMemory(builder:flatbuffers.Builder, committedMemory:bigint) {
  builder.addFieldInt64(2, committedMemory, BigInt('0'));
}

static addExecutedInstructions(builder:flatbuffers.Builder, executedInstructions:bigint) {
  builder.addFieldInt64(3, executedInstructions, BigInt('0'));
}

static endEmulationStatus(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createEmulationStatus(builder:flatbuffers.Builder, activeThreads:number, reservedMemory:bigint, committedMemory:bigint, executedInstructions:bigint):flatbuffers.Offset {
  EmulationStatus.startEmulationStatus(builder);
  EmulationStatus.addActiveThreads(builder, activeThreads);
  EmulationStatus.addReservedMemory(builder, reservedMemory);
  EmulationStatus.addCommittedMemory(builder, committedMemory);
  EmulationStatus.addExecutedInstructions(builder, executedInstructions);
  return EmulationStatus.endEmulationStatus(builder);
}

unpack(): EmulationStatusT {
  return new EmulationStatusT(
    this.activeThreads(),
    this.reservedMemory(),
    this.committedMemory(),
    this.executedInstructions()
  );
}


unpackTo(_o: EmulationStatusT): void {
  _o.activeThreads = this.activeThreads();
  _o.reservedMemory = this.reservedMemory();
  _o.committedMemory = this.committedMemory();
  _o.executedInstructions = this.executedInstructions();
}
}

export class EmulationStatusT implements flatbuffers.IGeneratedObject {
constructor(
  public activeThreads: number = 0,
  public reservedMemory: bigint = BigInt('0'),
  public committedMemory: bigint = BigInt('0'),
  public executedInstructions: bigint = BigInt('0')
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return EmulationStatus.createEmulationStatus(builder,
    this.activeThreads,
    this.reservedMemory,
    this.committedMemory,
    this.executedInstructions
  );
}
}

```

`page/src/fb/debugger/event.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import { ApplicationExit, ApplicationExitT } from '../debugger/application-exit.js';
import { EmulationStatus, EmulationStatusT } from '../debugger/emulation-status.js';
import { GetStateRequest, GetStateRequestT } from '../debugger/get-state-request.js';
import { GetStateResponse, GetStateResponseT } from '../debugger/get-state-response.js';
import { PauseRequest, PauseRequestT } from '../debugger/pause-request.js';
import { ReadMemoryRequest, ReadMemoryRequestT } from '../debugger/read-memory-request.js';
import { ReadMemoryResponse, ReadMemoryResponseT } from '../debugger/read-memory-response.js';
import { ReadRegisterRequest, ReadRegisterRequestT } from '../debugger/read-register-request.js';
import { ReadRegisterResponse, ReadRegisterResponseT } from '../debugger/read-register-response.js';
import { RunRequest, RunRequestT } from '../debugger/run-request.js';
import { WriteMemoryRequest, WriteMemoryRequestT } from '../debugger/write-memory-request.js';
import { WriteMemoryResponse, WriteMemoryResponseT } from '../debugger/write-memory-response.js';
import { WriteRegisterRequest, WriteRegisterRequestT } from '../debugger/write-register-request.js';
import { WriteRegisterResponse, WriteRegisterResponseT } from '../debugger/write-register-response.js';


export enum Event {
  NONE = 0,
  PauseRequest = 1,
  RunRequest = 2,
  GetStateRequest = 3,
  GetStateResponse = 4,
  WriteMemoryRequest = 5,
  WriteMemoryResponse = 6,
  ReadMemoryRequest = 7,
  ReadMemoryResponse = 8,
  WriteRegisterRequest = 9,
  WriteRegisterResponse = 10,
  ReadRegisterRequest = 11,
  ReadRegisterResponse = 12,
  ApplicationExit = 13,
  EmulationStatus = 14
}

export function unionToEvent(
  type: Event,
  accessor: (obj:ApplicationExit|EmulationStatus|GetStateRequest|GetStateResponse|PauseRequest|ReadMemoryRequest|ReadMemoryResponse|ReadRegisterRequest|ReadRegisterResponse|RunRequest|WriteMemoryRequest|WriteMemoryResponse|WriteRegisterRequest|WriteRegisterResponse) => ApplicationExit|EmulationStatus|GetStateRequest|GetStateResponse|PauseRequest|ReadMemoryRequest|ReadMemoryResponse|ReadRegisterRequest|ReadRegisterResponse|RunRequest|WriteMemoryRequest|WriteMemoryResponse|WriteRegisterRequest|WriteRegisterResponse|null
): ApplicationExit|EmulationStatus|GetStateRequest|GetStateResponse|PauseRequest|ReadMemoryRequest|ReadMemoryResponse|ReadRegisterRequest|ReadRegisterResponse|RunRequest|WriteMemoryRequest|WriteMemoryResponse|WriteRegisterRequest|WriteRegisterResponse|null {
  switch(Event[type]) {
    case 'NONE': return null; 
    case 'PauseRequest': return accessor(new PauseRequest())! as PauseRequest;
    case 'RunRequest': return accessor(new RunRequest())! as RunRequest;
    case 'GetStateRequest': return accessor(new GetStateRequest())! as GetStateRequest;
    case 'GetStateResponse': return accessor(new GetStateResponse())! as GetStateResponse;
    case 'WriteMemoryRequest': return accessor(new WriteMemoryRequest())! as WriteMemoryRequest;
    case 'WriteMemoryResponse': return accessor(new WriteMemoryResponse())! as WriteMemoryResponse;
    case 'ReadMemoryRequest': return accessor(new ReadMemoryRequest())! as ReadMemoryRequest;
    case 'ReadMemoryResponse': return accessor(new ReadMemoryResponse())! as ReadMemoryResponse;
    case 'WriteRegisterRequest': return accessor(new WriteRegisterRequest())! as WriteRegisterRequest;
    case 'WriteRegisterResponse': return accessor(new WriteRegisterResponse())! as WriteRegisterResponse;
    case 'ReadRegisterRequest': return accessor(new ReadRegisterRequest())! as ReadRegisterRequest;
    case 'ReadRegisterResponse': return accessor(new ReadRegisterResponse())! as ReadRegisterResponse;
    case 'ApplicationExit': return accessor(new ApplicationExit())! as ApplicationExit;
    case 'EmulationStatus': return accessor(new EmulationStatus())! as EmulationStatus;
    default: return null;
  }
}

export function unionListToEvent(
  type: Event, 
  accessor: (index: number, obj:ApplicationExit|EmulationStatus|GetStateRequest|GetStateResponse|PauseRequest|ReadMemoryRequest|ReadMemoryResponse|ReadRegisterRequest|ReadRegisterResponse|RunRequest|WriteMemoryRequest|WriteMemoryResponse|WriteRegisterRequest|WriteRegisterResponse) => ApplicationExit|EmulationStatus|GetStateRequest|GetStateResponse|PauseRequest|ReadMemoryRequest|ReadMemoryResponse|ReadRegisterRequest|ReadRegisterResponse|RunRequest|WriteMemoryRequest|WriteMemoryResponse|WriteRegisterRequest|WriteRegisterResponse|null, 
  index: number
): ApplicationExit|EmulationStatus|GetStateRequest|GetStateResponse|PauseRequest|ReadMemoryRequest|ReadMemoryResponse|ReadRegisterRequest|ReadRegisterResponse|RunRequest|WriteMemoryRequest|WriteMemoryResponse|WriteRegisterRequest|WriteRegisterResponse|null {
  switch(Event[type]) {
    case 'NONE': return null; 
    case 'PauseRequest': return accessor(index, new PauseRequest())! as PauseRequest;
    case 'RunRequest': return accessor(index, new RunRequest())! as RunRequest;
    case 'GetStateRequest': return accessor(index, new GetStateRequest())! as GetStateRequest;
    case 'GetStateResponse': return accessor(index, new GetStateResponse())! as GetStateResponse;
    case 'WriteMemoryRequest': return accessor(index, new WriteMemoryRequest())! as WriteMemoryRequest;
    case 'WriteMemoryResponse': return accessor(index, new WriteMemoryResponse())! as WriteMemoryResponse;
    case 'ReadMemoryRequest': return accessor(index, new ReadMemoryRequest())! as ReadMemoryRequest;
    case 'ReadMemoryResponse': return accessor(index, new ReadMemoryResponse())! as ReadMemoryResponse;
    case 'WriteRegisterRequest': return accessor(index, new WriteRegisterRequest())! as WriteRegisterRequest;
    case 'WriteRegisterResponse': return accessor(index, new WriteRegisterResponse())! as WriteRegisterResponse;
    case 'ReadRegisterRequest': return accessor(index, new ReadRegisterRequest())! as ReadRegisterRequest;
    case 'ReadRegisterResponse': return accessor(index, new ReadRegisterResponse())! as ReadRegisterResponse;
    case 'ApplicationExit': return accessor(index, new ApplicationExit())! as ApplicationExit;
    case 'EmulationStatus': return accessor(index, new EmulationStatus())! as EmulationStatus;
    default: return null;
  }
}

```

`page/src/fb/debugger/get-state-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class GetStateRequest implements flatbuffers.IUnpackableObject<GetStateRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GetStateRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGetStateRequest(bb:flatbuffers.ByteBuffer, obj?:GetStateRequest):GetStateRequest {
  return (obj || new GetStateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGetStateRequest(bb:flatbuffers.ByteBuffer, obj?:GetStateRequest):GetStateRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GetStateRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static startGetStateRequest(builder:flatbuffers.Builder) {
  builder.startObject(0);
}

static endGetStateRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createGetStateRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  GetStateRequest.startGetStateRequest(builder);
  return GetStateRequest.endGetStateRequest(builder);
}

unpack(): GetStateRequestT {
  return new GetStateRequestT();
}


unpackTo(_o: GetStateRequestT): void {}
}

export class GetStateRequestT implements flatbuffers.IGeneratedObject {
constructor(){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return GetStateRequest.createGetStateRequest(builder);
}
}

```

`page/src/fb/debugger/get-state-response.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { State } from '../debugger/state.js';


export class GetStateResponse implements flatbuffers.IUnpackableObject<GetStateResponseT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GetStateResponse {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGetStateResponse(bb:flatbuffers.ByteBuffer, obj?:GetStateResponse):GetStateResponse {
  return (obj || new GetStateResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGetStateResponse(bb:flatbuffers.ByteBuffer, obj?:GetStateResponse):GetStateResponse {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GetStateResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

state():State {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : State.None;
}

mutate_state(value:State):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

static startGetStateResponse(builder:flatbuffers.Builder) {
  builder.startObject(1);
}

static addState(builder:flatbuffers.Builder, state:State) {
  builder.addFieldInt32(0, state, State.None);
}

static endGetStateResponse(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createGetStateResponse(builder:flatbuffers.Builder, state:State):flatbuffers.Offset {
  GetStateResponse.startGetStateResponse(builder);
  GetStateResponse.addState(builder, state);
  return GetStateResponse.endGetStateResponse(builder);
}

unpack(): GetStateResponseT {
  return new GetStateResponseT(
    this.state()
  );
}


unpackTo(_o: GetStateResponseT): void {
  _o.state = this.state();
}
}

export class GetStateResponseT implements flatbuffers.IGeneratedObject {
constructor(
  public state: State = State.None
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return GetStateResponse.createGetStateResponse(builder,
    this.state
  );
}
}

```

`page/src/fb/debugger/pause-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class PauseRequest implements flatbuffers.IUnpackableObject<PauseRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PauseRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPauseRequest(bb:flatbuffers.ByteBuffer, obj?:PauseRequest):PauseRequest {
  return (obj || new PauseRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPauseRequest(bb:flatbuffers.ByteBuffer, obj?:PauseRequest):PauseRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PauseRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static startPauseRequest(builder:flatbuffers.Builder) {
  builder.startObject(0);
}

static endPauseRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createPauseRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  PauseRequest.startPauseRequest(builder);
  return PauseRequest.endPauseRequest(builder);
}

unpack(): PauseRequestT {
  return new PauseRequestT();
}


unpackTo(_o: PauseRequestT): void {}
}

export class PauseRequestT implements flatbuffers.IGeneratedObject {
constructor(){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return PauseRequest.createPauseRequest(builder);
}
}

```

`page/src/fb/debugger/read-memory-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class ReadMemoryRequest implements flatbuffers.IUnpackableObject<ReadMemoryRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ReadMemoryRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsReadMemoryRequest(bb:flatbuffers.ByteBuffer, obj?:ReadMemoryRequest):ReadMemoryRequest {
  return (obj || new ReadMemoryRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsReadMemoryRequest(bb:flatbuffers.ByteBuffer, obj?:ReadMemoryRequest):ReadMemoryRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ReadMemoryRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

address():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_address(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

size():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_size(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

static startReadMemoryRequest(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addAddress(builder:flatbuffers.Builder, address:bigint) {
  builder.addFieldInt64(0, address, BigInt('0'));
}

static addSize(builder:flatbuffers.Builder, size:number) {
  builder.addFieldInt32(1, size, 0);
}

static endReadMemoryRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createReadMemoryRequest(builder:flatbuffers.Builder, address:bigint, size:number):flatbuffers.Offset {
  ReadMemoryRequest.startReadMemoryRequest(builder);
  ReadMemoryRequest.addAddress(builder, address);
  ReadMemoryRequest.addSize(builder, size);
  return ReadMemoryRequest.endReadMemoryRequest(builder);
}

unpack(): ReadMemoryRequestT {
  return new ReadMemoryRequestT(
    this.address(),
    this.size()
  );
}


unpackTo(_o: ReadMemoryRequestT): void {
  _o.address = this.address();
  _o.size = this.size();
}
}

export class ReadMemoryRequestT implements flatbuffers.IGeneratedObject {
constructor(
  public address: bigint = BigInt('0'),
  public size: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return ReadMemoryRequest.createReadMemoryRequest(builder,
    this.address,
    this.size
  );
}
}

```

`page/src/fb/debugger/read-memory-response.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class ReadMemoryResponse implements flatbuffers.IUnpackableObject<ReadMemoryResponseT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ReadMemoryResponse {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsReadMemoryResponse(bb:flatbuffers.ByteBuffer, obj?:ReadMemoryResponse):ReadMemoryResponse {
  return (obj || new ReadMemoryResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsReadMemoryResponse(bb:flatbuffers.ByteBuffer, obj?:ReadMemoryResponse):ReadMemoryResponse {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ReadMemoryResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

address():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_address(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

data(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

dataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

dataArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startReadMemoryResponse(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addAddress(builder:flatbuffers.Builder, address:bigint) {
  builder.addFieldInt64(0, address, BigInt('0'));
}

static addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, dataOffset, 0);
}

static createDataVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endReadMemoryResponse(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createReadMemoryResponse(builder:flatbuffers.Builder, address:bigint, dataOffset:flatbuffers.Offset):flatbuffers.Offset {
  ReadMemoryResponse.startReadMemoryResponse(builder);
  ReadMemoryResponse.addAddress(builder, address);
  ReadMemoryResponse.addData(builder, dataOffset);
  return ReadMemoryResponse.endReadMemoryResponse(builder);
}

unpack(): ReadMemoryResponseT {
  return new ReadMemoryResponseT(
    this.address(),
    this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  );
}


unpackTo(_o: ReadMemoryResponseT): void {
  _o.address = this.address();
  _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength());
}
}

export class ReadMemoryResponseT implements flatbuffers.IGeneratedObject {
constructor(
  public address: bigint = BigInt('0'),
  public data: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const data = ReadMemoryResponse.createDataVector(builder, this.data);

  return ReadMemoryResponse.createReadMemoryResponse(builder,
    this.address,
    data
  );
}
}

```

`page/src/fb/debugger/read-register-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class ReadRegisterRequest implements flatbuffers.IUnpackableObject<ReadRegisterRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ReadRegisterRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsReadRegisterRequest(bb:flatbuffers.ByteBuffer, obj?:ReadRegisterRequest):ReadRegisterRequest {
  return (obj || new ReadRegisterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsReadRegisterRequest(bb:flatbuffers.ByteBuffer, obj?:ReadRegisterRequest):ReadRegisterRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ReadRegisterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

register():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_register(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

static startReadRegisterRequest(builder:flatbuffers.Builder) {
  builder.startObject(1);
}

static addRegister(builder:flatbuffers.Builder, register:number) {
  builder.addFieldInt32(0, register, 0);
}

static endReadRegisterRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createReadRegisterRequest(builder:flatbuffers.Builder, register:number):flatbuffers.Offset {
  ReadRegisterRequest.startReadRegisterRequest(builder);
  ReadRegisterRequest.addRegister(builder, register);
  return ReadRegisterRequest.endReadRegisterRequest(builder);
}

unpack(): ReadRegisterRequestT {
  return new ReadRegisterRequestT(
    this.register()
  );
}


unpackTo(_o: ReadRegisterRequestT): void {
  _o.register = this.register();
}
}

export class ReadRegisterRequestT implements flatbuffers.IGeneratedObject {
constructor(
  public register: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return ReadRegisterRequest.createReadRegisterRequest(builder,
    this.register
  );
}
}

```

`page/src/fb/debugger/read-register-response.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class ReadRegisterResponse implements flatbuffers.IUnpackableObject<ReadRegisterResponseT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ReadRegisterResponse {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsReadRegisterResponse(bb:flatbuffers.ByteBuffer, obj?:ReadRegisterResponse):ReadRegisterResponse {
  return (obj || new ReadRegisterResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsReadRegisterResponse(bb:flatbuffers.ByteBuffer, obj?:ReadRegisterResponse):ReadRegisterResponse {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ReadRegisterResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

register():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_register(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

data(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

dataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

dataArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startReadRegisterResponse(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addRegister(builder:flatbuffers.Builder, register:number) {
  builder.addFieldInt32(0, register, 0);
}

static addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, dataOffset, 0);
}

static createDataVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endReadRegisterResponse(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createReadRegisterResponse(builder:flatbuffers.Builder, register:number, dataOffset:flatbuffers.Offset):flatbuffers.Offset {
  ReadRegisterResponse.startReadRegisterResponse(builder);
  ReadRegisterResponse.addRegister(builder, register);
  ReadRegisterResponse.addData(builder, dataOffset);
  return ReadRegisterResponse.endReadRegisterResponse(builder);
}

unpack(): ReadRegisterResponseT {
  return new ReadRegisterResponseT(
    this.register(),
    this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  );
}


unpackTo(_o: ReadRegisterResponseT): void {
  _o.register = this.register();
  _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength());
}
}

export class ReadRegisterResponseT implements flatbuffers.IGeneratedObject {
constructor(
  public register: number = 0,
  public data: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const data = ReadRegisterResponse.createDataVector(builder, this.data);

  return ReadRegisterResponse.createReadRegisterResponse(builder,
    this.register,
    data
  );
}
}

```

`page/src/fb/debugger/run-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class RunRequest implements flatbuffers.IUnpackableObject<RunRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):RunRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsRunRequest(bb:flatbuffers.ByteBuffer, obj?:RunRequest):RunRequest {
  return (obj || new RunRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsRunRequest(bb:flatbuffers.ByteBuffer, obj?:RunRequest):RunRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new RunRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

singleStep():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_single_step(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

static startRunRequest(builder:flatbuffers.Builder) {
  builder.startObject(1);
}

static addSingleStep(builder:flatbuffers.Builder, singleStep:boolean) {
  builder.addFieldInt8(0, +singleStep, +false);
}

static endRunRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createRunRequest(builder:flatbuffers.Builder, singleStep:boolean):flatbuffers.Offset {
  RunRequest.startRunRequest(builder);
  RunRequest.addSingleStep(builder, singleStep);
  return RunRequest.endRunRequest(builder);
}

unpack(): RunRequestT {
  return new RunRequestT(
    this.singleStep()
  );
}


unpackTo(_o: RunRequestT): void {
  _o.singleStep = this.singleStep();
}
}

export class RunRequestT implements flatbuffers.IGeneratedObject {
constructor(
  public singleStep: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return RunRequest.createRunRequest(builder,
    this.singleStep
  );
}
}

```

`page/src/fb/debugger/state.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

export enum State {
  None = 0,
  Running = 1,
  Paused = 2
}

```

`page/src/fb/debugger/write-memory-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class WriteMemoryRequest implements flatbuffers.IUnpackableObject<WriteMemoryRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):WriteMemoryRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsWriteMemoryRequest(bb:flatbuffers.ByteBuffer, obj?:WriteMemoryRequest):WriteMemoryRequest {
  return (obj || new WriteMemoryRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsWriteMemoryRequest(bb:flatbuffers.ByteBuffer, obj?:WriteMemoryRequest):WriteMemoryRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new WriteMemoryRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

address():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_address(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

data(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

dataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

dataArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startWriteMemoryRequest(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addAddress(builder:flatbuffers.Builder, address:bigint) {
  builder.addFieldInt64(0, address, BigInt('0'));
}

static addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, dataOffset, 0);
}

static createDataVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endWriteMemoryRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createWriteMemoryRequest(builder:flatbuffers.Builder, address:bigint, dataOffset:flatbuffers.Offset):flatbuffers.Offset {
  WriteMemoryRequest.startWriteMemoryRequest(builder);
  WriteMemoryRequest.addAddress(builder, address);
  WriteMemoryRequest.addData(builder, dataOffset);
  return WriteMemoryRequest.endWriteMemoryRequest(builder);
}

unpack(): WriteMemoryRequestT {
  return new WriteMemoryRequestT(
    this.address(),
    this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  );
}


unpackTo(_o: WriteMemoryRequestT): void {
  _o.address = this.address();
  _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength());
}
}

export class WriteMemoryRequestT implements flatbuffers.IGeneratedObject {
constructor(
  public address: bigint = BigInt('0'),
  public data: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const data = WriteMemoryRequest.createDataVector(builder, this.data);

  return WriteMemoryRequest.createWriteMemoryRequest(builder,
    this.address,
    data
  );
}
}

```

`page/src/fb/debugger/write-memory-response.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class WriteMemoryResponse implements flatbuffers.IUnpackableObject<WriteMemoryResponseT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):WriteMemoryResponse {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsWriteMemoryResponse(bb:flatbuffers.ByteBuffer, obj?:WriteMemoryResponse):WriteMemoryResponse {
  return (obj || new WriteMemoryResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsWriteMemoryResponse(bb:flatbuffers.ByteBuffer, obj?:WriteMemoryResponse):WriteMemoryResponse {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new WriteMemoryResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

address():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_address(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

size():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_size(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

success():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_success(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

static startWriteMemoryResponse(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addAddress(builder:flatbuffers.Builder, address:bigint) {
  builder.addFieldInt64(0, address, BigInt('0'));
}

static addSize(builder:flatbuffers.Builder, size:number) {
  builder.addFieldInt32(1, size, 0);
}

static addSuccess(builder:flatbuffers.Builder, success:boolean) {
  builder.addFieldInt8(2, +success, +false);
}

static endWriteMemoryResponse(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createWriteMemoryResponse(builder:flatbuffers.Builder, address:bigint, size:number, success:boolean):flatbuffers.Offset {
  WriteMemoryResponse.startWriteMemoryResponse(builder);
  WriteMemoryResponse.addAddress(builder, address);
  WriteMemoryResponse.addSize(builder, size);
  WriteMemoryResponse.addSuccess(builder, success);
  return WriteMemoryResponse.endWriteMemoryResponse(builder);
}

unpack(): WriteMemoryResponseT {
  return new WriteMemoryResponseT(
    this.address(),
    this.size(),
    this.success()
  );
}


unpackTo(_o: WriteMemoryResponseT): void {
  _o.address = this.address();
  _o.size = this.size();
  _o.success = this.success();
}
}

export class WriteMemoryResponseT implements flatbuffers.IGeneratedObject {
constructor(
  public address: bigint = BigInt('0'),
  public size: number = 0,
  public success: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return WriteMemoryResponse.createWriteMemoryResponse(builder,
    this.address,
    this.size,
    this.success
  );
}
}

```

`page/src/fb/debugger/write-register-request.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class WriteRegisterRequest implements flatbuffers.IUnpackableObject<WriteRegisterRequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):WriteRegisterRequest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsWriteRegisterRequest(bb:flatbuffers.ByteBuffer, obj?:WriteRegisterRequest):WriteRegisterRequest {
  return (obj || new WriteRegisterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsWriteRegisterRequest(bb:flatbuffers.ByteBuffer, obj?:WriteRegisterRequest):WriteRegisterRequest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new WriteRegisterRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

register():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_register(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

data(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

dataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

dataArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startWriteRegisterRequest(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addRegister(builder:flatbuffers.Builder, register:number) {
  builder.addFieldInt32(0, register, 0);
}

static addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, dataOffset, 0);
}

static createDataVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endWriteRegisterRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createWriteRegisterRequest(builder:flatbuffers.Builder, register:number, dataOffset:flatbuffers.Offset):flatbuffers.Offset {
  WriteRegisterRequest.startWriteRegisterRequest(builder);
  WriteRegisterRequest.addRegister(builder, register);
  WriteRegisterRequest.addData(builder, dataOffset);
  return WriteRegisterRequest.endWriteRegisterRequest(builder);
}

unpack(): WriteRegisterRequestT {
  return new WriteRegisterRequestT(
    this.register(),
    this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength())
  );
}


unpackTo(_o: WriteRegisterRequestT): void {
  _o.register = this.register();
  _o.data = this.bb!.createScalarList<number>(this.data.bind(this), this.dataLength());
}
}

export class WriteRegisterRequestT implements flatbuffers.IGeneratedObject {
constructor(
  public register: number = 0,
  public data: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const data = WriteRegisterRequest.createDataVector(builder, this.data);

  return WriteRegisterRequest.createWriteRegisterRequest(builder,
    this.register,
    data
  );
}
}

```

`page/src/fb/debugger/write-register-response.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class WriteRegisterResponse implements flatbuffers.IUnpackableObject<WriteRegisterResponseT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):WriteRegisterResponse {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsWriteRegisterResponse(bb:flatbuffers.ByteBuffer, obj?:WriteRegisterResponse):WriteRegisterResponse {
  return (obj || new WriteRegisterResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsWriteRegisterResponse(bb:flatbuffers.ByteBuffer, obj?:WriteRegisterResponse):WriteRegisterResponse {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new WriteRegisterResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

register():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_register(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

size():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_size(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

success():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_success(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

static startWriteRegisterResponse(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addRegister(builder:flatbuffers.Builder, register:number) {
  builder.addFieldInt32(0, register, 0);
}

static addSize(builder:flatbuffers.Builder, size:number) {
  builder.addFieldInt32(1, size, 0);
}

static addSuccess(builder:flatbuffers.Builder, success:boolean) {
  builder.addFieldInt8(2, +success, +false);
}

static endWriteRegisterResponse(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createWriteRegisterResponse(builder:flatbuffers.Builder, register:number, size:number, success:boolean):flatbuffers.Offset {
  WriteRegisterResponse.startWriteRegisterResponse(builder);
  WriteRegisterResponse.addRegister(builder, register);
  WriteRegisterResponse.addSize(builder, size);
  WriteRegisterResponse.addSuccess(builder, success);
  return WriteRegisterResponse.endWriteRegisterResponse(builder);
}

unpack(): WriteRegisterResponseT {
  return new WriteRegisterResponseT(
    this.register(),
    this.size(),
    this.success()
  );
}


unpackTo(_o: WriteRegisterResponseT): void {
  _o.register = this.register();
  _o.size = this.size();
  _o.success = this.success();
}
}

export class WriteRegisterResponseT implements flatbuffers.IGeneratedObject {
constructor(
  public register: number = 0,
  public size: number = 0,
  public success: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return WriteRegisterResponse.createWriteRegisterResponse(builder,
    this.register,
    this.size,
    this.success
  );
}
}

```

`page/src/fb/events.ts`:

```ts
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

export * as Debugger from './debugger.js';

```

`page/src/filesystem-explorer.tsx`:

```tsx
import React from "react";
import {
  Folder,
  FolderElement,
  FolderElementType,
  trimFilename,
} from "./components/folder";
import { Filesystem } from "./filesystem";

import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "./components/ui/button";
import { Input } from "./components/ui/input";
import { DialogDescription } from "@radix-ui/react-dialog";

import Dropzone from "react-dropzone";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";

import { HouseFill } from "react-bootstrap-icons";
import { parsePeIcon } from "./pe-icon-parser";

export interface FilesystemExplorerProps {
  filesystem: Filesystem;
  runFile: (file: string) => void;
  resetFilesys: () => void;
  path: string[];
  iconCache: Map<string, string | null>;
}
export interface FilesystemExplorerState {
  path: string[];
  createFolder: boolean;
  resetFilesys: boolean;
  errorText: string;
  removeFile: string;
  renameFile: string;
}

function makeFullPath(path: string[]) {
  return "/root/filesys/" + path.join("/");
}

function makeFullPathAndJoin(path: string[], element: string) {
  return makeFullPath([...path, element]);
}

function makeFullPathWithState(
  state: FilesystemExplorerState,
  element: string,
) {
  return makeFullPathAndJoin(state.path, element);
}

function relativePathToWindowsPath(fullPath: string) {
  if (fullPath.length == 0) {
    return fullPath;
  }

  const drive = fullPath.substring(0, 1);
  const rest = fullPath.substring(1);

  return `${drive}:${rest}`;
}

function makeRelativePathWithState(
  state: FilesystemExplorerState,
  element: string,
) {
  return [...state.path, element].join("/");
}

function makeWindowsPathWithState(
  state: FilesystemExplorerState,
  element: string,
) {
  const fullPath = makeRelativePathWithState(state, element);
  return relativePathToWindowsPath(fullPath);
}

function getFolderElements(filesystem: Filesystem, path: string[]) {
  const fullPath = makeFullPath(path);
  const files = filesystem.readDir(fullPath);

  return files
    .filter((f) => {
      if (f == ".") {
        return false;
      }

      if (path.length == 0 && f == "..") {
        return false;
      }

      return true;
    })
    .map((f) => {
      const element: FolderElement = {
        name: f,
        type: filesystem.isFolder(`${fullPath}/${f}`)
          ? FolderElementType.Folder
          : FolderElementType.File,
      };

      return element;
    });
}

interface FileWithData {
  file: File;
  data: ArrayBuffer;
}

function readFile(file: File): Promise<FileWithData> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      if (reader.readyState === FileReader.DONE) {
        resolve({
          file,
          data: reader.result as ArrayBuffer,
        });
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

async function readFiles(files: FileList | File[]): Promise<FileWithData[]> {
  const promises = [];

  for (let i = 0; i < files.length; i++) {
    promises.push(readFile(files[i]));
  }

  return Promise.all(promises);
}

function selectFiles(): Promise<FileList> {
  return new Promise((resolve) => {
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".exe";

    fileInput.addEventListener("change", function (event) {
      const files = (event as any).target.files as FileList;
      resolve(files);
    });

    fileInput.click();
  });
}

function getPeIcon(
  filesystem: Filesystem,
  file: string,
  cache: Map<string, string | null>,
) {
  if (!file || !file.endsWith(".exe")) {
    return null;
  }

  const cachedValue = cache.get(file);
  if (cachedValue) {
    return cachedValue;
  }

  const data = filesystem.readFile(file);
  const icon = parsePeIcon(data);
  cache.set(file, icon);

  return icon;
}

interface BreadcrumbElement {
  node: React.ReactNode;
  targetPath: string[];
}

function isGoodPath(path: any) {
  return typeof path === "string" && path.length > 0;
}

function trimLeadingSlash(path: string) {
  if (path.startsWith("/")) {
    return path.substring(1);
  }

  return path;
}

function getFileName(file: File) {
  const fileObj = file as any;
  const properties = ["relativePath", "webkitRelativePath", "name"];

  for (let i = 0; i < properties.length; ++i) {
    const prop = properties[i];

    if (prop in fileObj) {
      const relativePath = fileObj[prop];
      if (isGoodPath(relativePath)) {
        return trimLeadingSlash(relativePath);
      }
    }
  }

  return file.name;
}

function generateBreadcrumbElements(path: string[]): BreadcrumbElement[] {
  const elements = path.map((p, index) => {
    const e: BreadcrumbElement = {
      node: p,
      targetPath: path.slice(0, index + 1),
    };

    return e;
  });
  elements.unshift({
    node: <HouseFill />,
    targetPath: [],
  });

  return elements;
}

function downloadData(
  data: Uint8Array,
  filename: string,
  mimeType: string = "application/octet-stream",
) {
  const buffer = data.buffer.slice(
    data.byteOffset,
    data.byteOffset + data.byteLength,
  ) as ArrayBuffer;
  const blob = new Blob([buffer], { type: mimeType });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  link.click();

  URL.revokeObjectURL(url);
}

export class FilesystemExplorer extends React.Component<
  FilesystemExplorerProps,
  FilesystemExplorerState
> {
  constructor(props: FilesystemExplorerProps) {
    super(props);

    this._onAddFiles = this._onAddFiles.bind(this);
    this._uploadFiles = this._uploadFiles.bind(this);
    this._onElementSelect = this._onElementSelect.bind(this);

    this.state = {
      path: this.props.path,
      createFolder: false,
      resetFilesys: false,
      errorText: "",
      removeFile: "",
      renameFile: "",
    };
  }

  _showError(errorText: string) {
    this.setState({ errorText });
  }

  _onElementSelect(element: FolderElement) {
    if (element.type != FolderElementType.Folder) {
      if (element.name.endsWith(".exe")) {
        const file = makeWindowsPathWithState(this.state, element.name);
        this.props.runFile(file);
      }

      return;
    }

    this.setState((s) => {
      const path = [...s.path];

      if (element.name == "..") {
        path.pop();
      } else {
        path.push(element.name);
      }

      return {
        path,
      };
    });
  }

  async _onFileRename(file: string, newFile: string) {
    newFile = newFile.toLowerCase();

    if (newFile == file) {
      this.setState({ renameFile: "" });
      return;
    }

    if (!this._validateName(newFile)) {
      return;
    }

    const oldPath = makeFullPathWithState(this.state, file);
    const newPath = makeFullPathWithState(this.state, newFile);

    this.setState({ renameFile: "" });

    this._removeFromCache(file);
    this._removeFromCache(newFile);

    await this.props.filesystem.rename(oldPath, newPath);
    this.forceUpdate();
  }

  async _onAddFiles() {
    const files = await selectFiles();
    await this._uploadFiles(files);
  }

  _validateName(name: string) {
    if (name.length == 0) {
      return false;
    }

    if (name.includes("/") || name.includes("\\")) {
      this._showError("Folder must not contain special characters");
      return false;
    }

    if (this.state.path.length == 0 && name.length > 1) {
      this._showError("Drives must be a single letter");
      return false;
    }

    return true;
  }

  async _onFolderCreate(name: string) {
    name = name.toLowerCase();

    if (!this._validateName(name)) {
      return;
    }

    this.setState({ createFolder: false });

    const fullPath = makeFullPathWithState(this.state, name);
    await this.props.filesystem.createFolder(fullPath);
    this.forceUpdate();
  }

  async _uploadFiles(files: FileList | File[]) {
    if (files.length == 0) {
      return;
    }

    if (this.state.path.length == 0) {
      this._showError("Files must be within a drive");
      return;
    }

    const fileData = (await readFiles(files)).map((f) => {
      const name = getFileName(f.file);
      return {
        name: makeFullPathWithState(this.state, name.toLowerCase()),
        data: f.data,
      };
    });

    fileData.forEach((d) => {
      this._removeFromCache(d.name);
    });

    await this.props.filesystem.storeFiles(fileData);
    this.forceUpdate();
  }

  _renderCreateFolderDialog() {
    return (
      <Dialog
        open={this.state.createFolder}
        onOpenChange={(open) => this.setState({ createFolder: open })}
      >
        <DialogContent className="sm:max-w-[425px]">
          <form
            onSubmit={(e) => {
              const folderName = (e.target as any).elements.name.value;
              this._onFolderCreate(folderName);
              e.preventDefault();
            }}
          >
            <DialogHeader>
              <DialogTitle>Create new folder</DialogTitle>
              <DialogDescription className="hidden">
                Create new folder
              </DialogDescription>
            </DialogHeader>
            <div className="py-4">
              <Input id="name" defaultValue="New Folder" />
            </div>
            <DialogFooter>
              <Button type="submit" className="fancy rounded-lg">
                Create
              </Button>
              <DialogClose asChild>
                <Button variant="secondary" className="fancy rounded-lg">
                  Cancel
                </Button>
              </DialogClose>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  _renderRenameDialog() {
    return (
      <Dialog
        open={this.state.renameFile.length > 0}
        onOpenChange={(open) => (open ? {} : this.setState({ renameFile: "" }))}
      >
        <DialogContent className="sm:max-w-[425px]">
          <form
            onSubmit={(e) => {
              const newName = (e.target as any).elements.name.value;
              this._onFileRename(this.state.renameFile, newName);
              e.preventDefault();
            }}
          >
            <DialogHeader>
              <DialogTitle>
                Rename {trimFilename(this.state.renameFile)}
              </DialogTitle>
              <DialogDescription className="hidden">
                Rename {this.state.renameFile}
              </DialogDescription>
            </DialogHeader>
            <div className="py-4">
              <Input id="name" defaultValue={this.state.renameFile} />
            </div>
            <DialogFooter>
              <Button type="submit" className="fancy rounded-lg">
                Rename
              </Button>
              <DialogClose asChild>
                <Button variant="secondary" className="fancy rounded-lg">
                  Cancel
                </Button>
              </DialogClose>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  _renderErrorDialog() {
    return (
      <Dialog
        open={this.state.errorText.length > 0}
        onOpenChange={(open) => (open ? {} : this.setState({ errorText: "" }))}
      >
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Error</DialogTitle>
            <DialogDescription className="hidden">
              Error: {this.state.errorText}
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">{this.state.errorText}</div>
          <DialogFooter>
            <Button
              variant="destructive"
              className="fancy rounded-lg"
              onClick={() => this.setState({ errorText: "" })}
            >
              Ok
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  _renderRemoveDialog() {
    return (
      <Dialog
        open={this.state.removeFile.length > 0}
        onOpenChange={(open) => (open ? {} : this.setState({ removeFile: "" }))}
      >
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>
              Delete {trimFilename(this.state.removeFile)}?
            </DialogTitle>
            <DialogDescription className="hidden">
              Delete {this.state.removeFile}
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">
            Are you sure you want to delete{" "}
            <b className="break-all">
              {makeWindowsPathWithState(this.state, this.state.removeFile)}
            </b>
          </div>
          <DialogFooter>
            <Button
              variant="destructive"
              className="fancy rounded-lg"
              onClick={() => {
                const file = makeFullPathWithState(
                  this.state,
                  this.state.removeFile,
                );
                this.setState({ removeFile: "" });
                this._removeFromCache(file);
                this.props.filesystem
                  .unlink(file)
                  .then(() => this.forceUpdate());
              }}
            >
              Delete
            </Button>
            <Button
              variant="secondary"
              className="fancy rounded-lg"
              onClick={() => {
                this.setState({ removeFile: "" });
              }}
            >
              Cancel
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  _renderResetDialog() {
    return (
      <Dialog
        open={this.state.resetFilesys}
        onOpenChange={(open) => this.setState({ resetFilesys: open })}
      >
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Reset filesystem</DialogTitle>
            <DialogDescription className="hidden">
              Reset filesystem
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">
            Are you sure you want to reset the filesystem?
          </div>
          <DialogFooter>
            <Button
              variant="destructive"
              className="fancy rounded-lg"
              onClick={() => {
                this.setState({ resetFilesys: false });
                this.props.iconCache.clear();
                this.props.resetFilesys();
              }}
            >
              Reset
            </Button>
            <Button
              variant="secondary"
              className="fancy rounded-lg"
              onClick={() => {
                this.setState({ resetFilesys: false });
              }}
            >
              Cancel
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  _renderBreadcrumbElements() {
    const elements = generateBreadcrumbElements(this.state.path);

    return elements.map((e, index) => {
      if (index == this.state.path.length) {
        return (
          <BreadcrumbItem key={`breadcrumb-item-${index}`}>
            <BreadcrumbPage key={`breadcrumb-page-${index}`}>
              {e.node}
            </BreadcrumbPage>
          </BreadcrumbItem>
        );
      }

      const navigate = () => this.setState({ path: e.targetPath });
      return [
        <BreadcrumbItem key={`breadcrumb-item-${index}`}>
          <BreadcrumbLink key={`breadcrumb-link-${index}`} onClick={navigate}>
            {e.node}
          </BreadcrumbLink>
        </BreadcrumbItem>,
        <BreadcrumbSeparator key={`breadcrumb-separator-${index}`} />,
      ];
    });
  }

  _renderBreadCrumb() {
    return (
      <Breadcrumb>
        <BreadcrumbList>{this._renderBreadcrumbElements()}</BreadcrumbList>
      </Breadcrumb>
    );
  }

  _removeFromCache(file: string) {
    this.props.iconCache.delete(file);
  }

  _downloadFile(file: string) {
    const fullPath = makeFullPathWithState(this.state, file);
    const data = this.props.filesystem.readFile(fullPath);
    downloadData(data, file);
  }

  render() {
    const elements = getFolderElements(this.props.filesystem, this.state.path);

    return (
      <>
        {this._renderCreateFolderDialog()}
        {this._renderRenameDialog()}
        {this._renderErrorDialog()}
        {this._renderRemoveDialog()}
        {this._renderResetDialog()}

        <div className="flex flex-row w-full items-center gap-3">
          <div className="whitespace-nowrap">{this._renderBreadCrumb()}</div>
          <div className="flex-1 text-right">
            <Button
              onClick={() => this.setState({ resetFilesys: true })}
              variant="destructive"
              size="sm"
              className="fancy rounded-lg"
            >
              Reset
            </Button>
          </div>
        </div>

        <Dropzone onDrop={this._uploadFiles} noClick={true}>
          {({ getRootProps, getInputProps }) => (
            <div {...getRootProps()}>
              <input {...getInputProps()} />
              <Folder
                elements={elements}
                clickHandler={this._onElementSelect}
                createFolderHandler={() =>
                  this.setState({ createFolder: true })
                }
                removeElementHandler={(e) =>
                  this.setState({ removeFile: e.name })
                }
                renameElementHandler={(e) =>
                  this.setState({ renameFile: e.name })
                }
                downloadElementHandler={(e) => this._downloadFile(e.name)}
                addFilesHandler={this._onAddFiles}
                iconReader={(e) =>
                  getPeIcon(
                    this.props.filesystem,
                    makeFullPathWithState(this.state, e.name),
                    this.props.iconCache,
                  )
                }
              />
            </div>
          )}
        </Dropzone>
      </>
    );
  }
}

```

`page/src/filesystem.ts`:

```ts
import { downloadBinaryFilePercent, DownloadPercentHandler } from "./download";
import { parseZipFile, ProgressHandler } from "./zip-file";
import idbfsModule, { MainModule } from "@irori/idbfs";

function fetchFilesystemZip(progressCallback: DownloadPercentHandler) {
  return downloadBinaryFilePercent("./root.zip", progressCallback);
}

async function fetchFilesystem(
  progressHandler: ProgressHandler,
  downloadProgressHandler: DownloadPercentHandler,
) {
  const filesys = await fetchFilesystemZip(downloadProgressHandler);
  return await parseZipFile(filesys, progressHandler);
}

function synchronizeIDBFS(idbfs: MainModule, populate: boolean) {
  return new Promise<void>((resolve, reject) => {
    idbfs.FS.syncfs(populate, function (err: any) {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

const filesystemPrefix = "/root/filesys/";

export function internalToWindowsPath(internalPath: string): string {
  if (
    !internalPath.startsWith(filesystemPrefix) ||
    internalPath.length <= filesystemPrefix.length
  ) {
    throw new Error("Invalid path");
  }

  const winPath = internalPath.substring(filesystemPrefix.length);
  return `${winPath[0]}:${winPath.substring(1)}`;
}

export function windowsToInternalPath(windowsPath: string): string {
  if (windowsPath.length < 2 || windowsPath[1] != ":") {
    throw new Error("Invalid path");
  }

  return `${filesystemPrefix}${windowsPath[0]}${windowsPath.substring(2)}`;
}

async function initializeIDBFS() {
  const idbfs = await idbfsModule();

  idbfs.FS.mkdir("/root");
  idbfs.FS.mount(idbfs.IDBFS, {}, "/root");

  await synchronizeIDBFS(idbfs, true);

  return idbfs;
}

export interface FileWithData {
  name: string;
  data: ArrayBuffer;
}

function deleteDatabase(dbName: string) {
  return new Promise<void>((resolve, reject) => {
    const request = indexedDB.deleteDatabase(dbName);

    request.onsuccess = () => {
      resolve();
    };

    request.onerror = () => {
      reject(new Error(`Error deleting database ${dbName}.`));
    };

    request.onblocked = () => {
      reject(new Error(`Deletion of database ${dbName} blocked.`));
    };
  });
}

function filterPseudoDir(e: string) {
  return e != "." && e != "..";
}

export class Filesystem {
  private idbfs: MainModule;

  constructor(idbfs: MainModule) {
    this.idbfs = idbfs;
  }

  _storeFile(file: FileWithData) {
    if (file.name.includes("/")) {
      const folder = file.name.split("/").slice(0, -1).join("/");
      this._createFolder(folder);
    }

    const buffer = new Uint8Array(file.data);
    this.idbfs.FS.writeFile(file.name, buffer);
  }

  readFile(file: string): Uint8Array {
    return this.idbfs.FS.readFile(file);
  }

  async storeFiles(files: FileWithData[]) {
    files.forEach((f) => {
      this._storeFile(f);
    });

    await this.sync();
  }

  _unlinkRecursive(element: string) {
    if (!this.isFolder(element)) {
      this.idbfs.FS.unlink(element);
      return;
    }

    this.readDir(element) //
      .filter(filterPseudoDir)
      .forEach((e) => {
        this._unlinkRecursive(`${element}/${e}`);
      });

    this.idbfs.FS.rmdir(element);
  }

  async rename(oldFile: string, newFile: string) {
    this.idbfs.FS.rename(oldFile, newFile);
    await this.sync();
  }

  async unlink(file: string) {
    this._unlinkRecursive(file);
    await this.sync();
  }

  _createFolder(folder: string) {
    this.idbfs.FS.mkdirTree(folder, 0o777);
  }

  async createFolder(folder: string) {
    this._createFolder(folder);
    await this.sync();
  }

  async sync() {
    await synchronizeIDBFS(this.idbfs, false);
  }

  readDir(dir: string): string[] {
    return this.idbfs.FS.readdir(dir);
  }

  stat(file: string) {
    return this.idbfs.FS.stat(file, false);
  }

  isFolder(file: string) {
    return (this.stat(file).mode & 0x4000) != 0;
  }

  async delete() {
    this.readDir("/root") //
      .filter(filterPseudoDir) //
      .forEach((e) => {
        try {
          this._unlinkRecursive(e);
        } catch (_) {}
      });

    await this.sync();

    try {
      await deleteDatabase("/root");
    } catch (e) {}
  }
}

export async function setupFilesystem(
  progressHandler: ProgressHandler,
  downloadProgressHandler: DownloadPercentHandler,
) {
  const idbfs = await initializeIDBFS();
  const fs = new Filesystem(idbfs);

  if (idbfs.FS.analyzePath("/root/api-set.bin", false).exists) {
    return fs;
  }

  const filesystem = await fetchFilesystem(
    progressHandler,
    downloadProgressHandler,
  );

  filesystem.forEach((e) => {
    if (idbfs.FS.analyzePath("/" + e.name, false).exists) {
      return;
    }

    if (e.name.endsWith("/")) {
      idbfs.FS.mkdir("/" + e.name.slice(0, -1));
    } else {
      const buffer = new Uint8Array(e.data);
      idbfs.FS.writeFile("/" + e.name, buffer);
    }
  });

  await fs.sync();

  return fs;
}

```

`page/src/hooks/use-mobile.ts`:

```ts
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}

```

`page/src/index.css`:

```css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.5rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(61.686% 0.20434 256.402);
  --primary-foreground: oklch(0.97 0.014 254.604);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.623 0.214 259.815);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.623 0.214 259.815);
  --sidebar-primary-foreground: oklch(0.97 0.014 254.604);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.623 0.214 259.815);
}

:root,
.dark {
  --background: oklch(0.19 0.004 286.01);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(66.906% 0.18376 248.826);
  --primary-foreground: oklch(29.313% 0.00003 271.152);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.69 0.1953 33.18);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(57.771% 0.18952 256.306);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.546 0.245 262.881);
  --sidebar-primary-foreground: oklch(0.379 0.146 265.522);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.488 0.243 264.376);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }

  body {
    @apply bg-background text-foreground;
  }
}

```

`page/src/landing-page.tsx`:

```tsx
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Shield,
  Cpu,
  Terminal,
  ExternalLink,
  Github,
  Play,
  ArrowRight,
  BookOpen,
  Download,
  Lock,
  Bug,
  Split,
  Layers,
} from "lucide-react";
import { Header } from "./Header";
import { YoutubeVideo } from "@/components/youtube-video";

function generateButtons(additionalClasses: string = "") {
  return (
    <div
      className={`flex flex-col sm:flex-row gap-4 justify-center items-stretch sm:items-center px-4 min-[340px]:px-16 ${additionalClasses}`}
    >
      <a href="#/playground">
        <Button
          asChild
          size="lg"
          className="rounded-lg bg-linear-to-br from-white to-neutral-300 text-neutral-900 border-0 px-8 py-6 text-lg font-semibold group transition-all duration-100 w-full flex"
        >
          <span>
            <Play className="mr-2 h-5 w-5 transition-transform" />
            <span className="flex-1">Try Online</span>
            <ArrowRight className="ml-2 h-5 w-5 group-hover:translate-x-1 transition-transform" />
          </span>
        </Button>
      </a>
      <a href="https://github.com/momo5502/sogen" target="_blank">
        <Button
          asChild
          size="lg"
          variant="outline"
          className="rounded-lg border-neutral-600 text-neutral-300 hover:bg-neutral-800/50 px-8 py-6 text-lg font-semibold group transition-all duration-300 w-full flex"
        >
          <span>
            <Github className="mr-2 h-5 w-5 group-hover:scale-110 transition-transform" />
            <span className="flex-1">Get Source</span>
            <ExternalLink className="ml-2 h-4 w-4" />
          </span>
        </Button>
      </a>
    </div>
  );
}

export function LandingPage() {
  const features = [
    {
      icon: <Cpu className="h-6 w-6" />,
      title: "Syscall Emulation",
      description:
        "Operates at syscall level, leveraging existing system DLLs instead of reimplementing Windows APIs",
      accent: "from-[#f76548] to-[#b00101]",
    },
    {
      icon: <Split className="h-6 w-6" />,
      title: "Hooking Capabilities",
      description:
        "Provides powerful hooking interfaces to intercept memory access, code execution and much more",
      accent: "from-[#ffcb00] to-[#da6000]",
    },
    {
      icon: <Terminal className="h-6 w-6" />,
      title: "Debugging Interface",
      description:
        "Implements GDB serial protocol for integration with common debugging tools",
      accent: "from-[#00c4e9] to-[#005ff6]",
    },
    {
      icon: <Layers className="h-6 w-6" />,
      title: "State Management",
      description:
        "Saves and restores the entire state of the emulator to quickly resume your work exactly where you left off.",
      accent: "from-[#aee703] to-[#647502]",
    },
  ];

  const useCases = [
    {
      icon: <Shield className="h-6 w-6" />,
      title: "Security Research",
      description:
        "Analyze security vulnerabilities in a controlled environment",
    },
    {
      icon: <Lock className="h-6 w-6" />,
      title: "DRM Research",
      description:
        "Study digital rights management systems and protection mechanisms",
    },
    {
      icon: <Bug className="h-6 w-6" />,
      title: "Malware Analysis",
      description:
        "Reverse engineer malicious software with full process control",
    },
  ];

  const stats = [
    { value: "100%", label: "Open Source" },
    { value: "14", label: "Platforms" },
    { value: "2", label: "Backends" },
    { value: "100%", label: "Deterministic" },
  ];

  return (
    <>
      <Header
        title="Sogen"
        description="A high-performance Windows user space emulator."
      />
      <div className="flex flex-col min-h-screen bg-linear-to-br from-zinc-900 via-neutral-900 to-black overflow-x-hidden">
        {/* Hero Section with Animated Background */}
        <section className="relative overflow-visible">
          {/* Animated Background Elements */}
          <div className="absolute inset-0 container mx-auto">
            <div className="absolute top-20 left-10 w-72 h-72 bg-yellow-500/15 rounded-full blur-3xl"></div>
            <div className="absolute top-40 right-20 w-96 h-96 bg-lime-500/15 rounded-full blur-3xl"></div>
            <div className="absolute bottom-20 left-1/3 w-80 h-80 bg-cyan-500/15 rounded-full blur-3xl"></div>
          </div>

          <div className="relative container mx-auto min-h-dvh p-1 min-[340px]:p-4 flex items-center xl:min-h-0 xl:px-6 xl:py-32">
            <div className="text-center space-y-8 max-w-4xl mx-auto">
              {/* Main Headline */}
              <h1 className="text-5xl md:text-7xl font-bold text-white leading-tight">
                Sogen
              </h1>

              <p className="text-xl md:text-2xl text-neutral-300 font-light leading-relaxed">
                A high-performance Windows user space emulator.
              </p>

              {
                /* CTA Buttons */
                generateButtons("pt-8")
              }

              {/* Stats */}
              <div className="flex justify-center flex-col min-[400px]:flex-row gap-6 sm:gap-8 pt-12">
                {stats.map((stat, index) => (
                  <div key={index} className="text-center">
                    <div className="text-2xl font-bold text-white">
                      {stat.value}
                    </div>
                    <div className="text-sm text-neutral-400">{stat.label}</div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </section>

        {/* Features Section with Hover Effects */}
        <section className="py-24 relative">
          <div className="container mx-auto px-6">
            <div className="text-center mb-16">
              <h2 className="text-4xl md:text-5xl font-bold text-white mb-6">
                Powerful Features
              </h2>
              <p className="text-xl text-neutral-400 max-w-2xl mx-auto">
                Built from the ground up for performance and accuracy.
              </p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-8 lg:m-32">
              {features.map((feature, index) => (
                <Card
                  key={index}
                  className="bg-neutral-800/50 border-neutral-700 hover:border-neutral-600 hover:bg-neutral-800/80 cursor-default transition-all duration-150 group hover:shadow-2xl"
                >
                  <CardHeader>
                    <div
                      className={`w-12 h-12 rounded-[0.625rem] bg-linear-to-br ${feature.accent} p-3 mb-4`}
                    >
                      <div className="text-neutral-900">{feature.icon}</div>
                    </div>
                    <CardTitle className="text-white text-xl font-semibold transition-colors">
                      {feature.title}
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <p className="text-neutral-300 leading-relaxed">
                      {feature.description}
                    </p>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        </section>

        {/* Use Cases */}
        <section className="py-24 bg-neutral-800/40">
          <div className="container mx-auto px-6">
            <div className="text-center mb-16">
              <h2 className="text-4xl font-bold text-white mb-6">
                Perfect For Your Research
              </h2>
              <p className="text-xl text-neutral-400">
                Designed for researchers who need precise control over Windows
                process execution.
              </p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-4xl mx-auto">
              {useCases.map((useCase, index) => (
                <div
                  key={index}
                  className="text-center p-8 rounded-2xl bg-neutral-800/50 border border-neutral-700 hover:border-neutral-600 hover:bg-neutral-800/80 cursor-default transition-all duration-150 group"
                >
                  <div className="w-12 h-12 mx-auto mb-4 rounded-[0.625rem] bg-linear-to-br from-cyan-500 to-blue-500 p-3">
                    <div className="text-neutral-800">{useCase.icon}</div>
                  </div>
                  <h3 className="text-xl font-semibold text-white mb-3">
                    {useCase.title}
                  </h3>
                  <p className="text-neutral-400">{useCase.description}</p>
                </div>
              ))}
            </div>
          </div>
        </section>

        {/* Video Section with Modern Design */}
        <section className="py-24">
          <div className="container mx-auto px-6">
            <div className="text-center mb-16">
              <h2 className="text-4xl font-bold text-white mb-6">
                See Sogen in Action
              </h2>
              <p className="text-xl text-neutral-400 max-w-3xl mx-auto">
                Watch a comprehensive overview of the emulator's capabilities
                and discover how it can accelerate your research workflow.
              </p>
            </div>

            <div className="mx-auto w-full gap-12 flex items-center justify-center flex-col lg:flex-row">
              {["wY9Q0DhodOQ", "RkodCUEmiuA"].map((id) => {
                return (
                  <div
                    key={`video-${id}`}
                    className="flex-1 w-full max-w-xl relative group"
                  >
                    <div className="absolute -inset-4 bg-linear-to-r from-neutral-500/15 to-neutral-500/15 rounded-3xl blur-md group-hover:blur-lg transition-all duration-300"></div>
                    <div className="relative aspect-video rounded-2xl overflow-hidden ">
                      <YoutubeVideo id={id} />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </section>

        {/* CTA Section */}
        <section className="py-24 bg-linear-to-r from-neutral-800/40 to-neutral-900">
          <div className="container mx-auto px-6 text-center">
            <h2 className="text-4xl font-bold text-white mb-6">
              Ready to Start Emulating?
            </h2>
            <p className="text-xl text-neutral-300 mb-8 max-w-2xl mx-auto">
              Try Sogen directly in your browser or explore the source code.
            </p>
            {generateButtons()}
          </div>
        </section>

        {/* Footer */}
        <footer className="py-16 border-t border-neutral-800">
          <div className="container mx-auto px-6">
            <div className="flex flex-col md:flex-row justify-between items-center">
              <div className="mb-8 md:mb-0 text-center md:text-left">
                <h2 className="text-3xl font-bold">Sogen</h2>
                <p className="mt-1 text-neutral-500 text-sm">
                  Built by{" "}
                  <a
                    href="https://momo5502.com"
                    className="underline"
                    target="_blank"
                  >
                    momo5502
                  </a>{" "}
                  with lots of help from{" "}
                  <a
                    href="https://github.com/momo5502/sogen/graphs/contributors"
                    className="underline"
                    target="_blank"
                  >
                    the community
                  </a>
                  .
                </p>
              </div>
              <div className="flex items-center space-x-6">
                <a
                  href="https://github.com/momo5502/sogen"
                  target="_blank"
                  title="Soure Code"
                  className="text-neutral-400 hover:text-blue-400 transition-colors p-2 rounded-lg hover:bg-neutral-800/50"
                >
                  <Github className="h-6 w-6" />
                </a>
                <a
                  href="#/playground"
                  title="Playground"
                  className="text-neutral-400 hover:text-blue-400 transition-colors p-2 rounded-lg hover:bg-neutral-800/50"
                >
                  <Play className="h-6 w-6" />
                </a>
                <a
                  href="https://github.com/momo5502/sogen/wiki"
                  target="_blank"
                  title="Wiki"
                  className="text-neutral-400 hover:text-blue-400 transition-colors p-2 rounded-lg hover:bg-neutral-800/50"
                >
                  <BookOpen className="h-6 w-6" />
                </a>
              </div>
            </div>
          </div>
        </footer>
      </div>
    </>
  );
}

```

`page/src/lib/utils.ts`:

```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

```

`page/src/main.tsx`:

```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.tsx";
import { registerSW } from "virtual:pwa-register";
import Loader from "./Loader";

registerSW({
  onNeedRefresh() {
    Loader.setLoading(false);
    window.location.reload();
  },
  onOfflineReady() {
    Loader.setLoading(false);
  },
  onRegisteredSW(_, registration) {
    registration?.addEventListener("updatefound", () => {
      Loader.setLoading(true);
    });
  },
});

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);

```

`page/src/pe-icon-parser.tsx`:

```tsx
import * as PE from "pe-library";

function patchExeFile(exe: PE.NtExecutable) {
  // The PE library doesn't support parsing resources if other sections follow
  // This might make sense, as the library will have issues rewriting the PE file.
  // As we only care about parsing though, just kill the other sections.
  const rsrc = exe.getSectionByEntry(PE.Format.ImageDirectoryEntry.Resource);
  const orig = exe.getAllSections.bind(exe);
  exe.getAllSections = function () {
    let x = { skip: false };
    return orig().filter((s) => {
      if (x.skip) {
        return false;
      }
      if (s == rsrc) {
        x.skip = true;
      }

      return true;
    });
  };
}

function arrayBufferToBase64(bytes: Uint8Array) {
  let binary = "";
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function isPng(buffer: Uint8Array) {
  if (buffer.length < 4) {
    return false;
  }

  return buffer[1] === 80 && buffer[2] === 78 && buffer[3] === 71;
}

function generateDataURL(arrayBuffer: Uint8Array, contentType: string) {
  const base64 = arrayBufferToBase64(arrayBuffer);
  return `data:${contentType};base64,${base64}`;
}

interface IconEntry {
  width: number;
  height: number;
  colorCount: number;
  reserved: number;
  planes: number;
  bitCount: number;
  bytesInRes: number;
  id: number;
}

interface IconGroup {
  reserved: number;
  type: number;
  icons: IconEntry[];
}

function writeUint8(buffer: Uint8Array, offset: number, value: number) {
  buffer[offset] = value;
}

function writeUint16(buffer: Uint8Array, offset: number, value: number) {
  writeUint8(buffer, offset + 0, value & 0xff);
  writeUint8(buffer, offset + 1, (value >> 8) & 0xff);
}

function writeUint32(buffer: Uint8Array, offset: number, value: number) {
  writeUint16(buffer, offset + 0, value & 0xffff);
  writeUint16(buffer, offset + 2, (value >> 16) & 0xffff);
}

function readUInt8(buffer: Uint8Array, offset: number) {
  return buffer[offset];
}

function readUInt16(buffer: Uint8Array, offset: number) {
  return readUInt8(buffer, offset) | (readUInt8(buffer, offset + 1) << 8);
}

function readUInt32(buffer: Uint8Array, offset: number) {
  return readUInt16(buffer, offset) | (readUInt16(buffer, offset + 2) << 16);
}

function parseIconGroup(buffer: Uint8Array): IconGroup {
  const reserved = readUInt16(buffer, 0);
  const type = readUInt16(buffer, 2);
  const count = readUInt16(buffer, 4);

  const icons: IconEntry[] = [];

  for (let i = 0; i < count; ++i) {
    const start = 6 + i * 14;
    const width = readUInt8(buffer, start + 0);
    const height = readUInt8(buffer, start + 1);
    const colorCount = readUInt8(buffer, start + 2);
    const reserved2 = readUInt8(buffer, start + 3);
    const planes = readUInt16(buffer, start + 4);
    const bitCount = readUInt16(buffer, start + 6);
    const bytesInRes = readUInt32(buffer, start + 8);
    const id = readUInt16(buffer, start + 12);

    icons.push({
      width,
      height,
      colorCount,
      reserved: reserved2,
      planes,
      bitCount,
      bytesInRes,
      id,
    });
  }

  return {
    reserved,
    type,
    icons,
  };
}

function mergeArrayBuffers(
  buffer1: ArrayBuffer,
  buffer2: ArrayBuffer,
): ArrayBuffer {
  const mergedBuffer = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);

  const view1 = new Uint8Array(buffer1);
  const view2 = new Uint8Array(buffer2);
  const mergedView = new Uint8Array(mergedBuffer);

  mergedView.set(view1, 0);
  mergedView.set(view2, buffer1.byteLength);

  return mergedBuffer;
}

function generateIcoHeader(icon: IconEntry) {
  const headerSize = 0x16;
  const header = new Uint8Array(headerSize);
  writeUint8(header, 2, 1); // Image type -> ico
  writeUint8(header, 4, 1); // Image count

  const start = 6;

  writeUint8(header, start + 0, icon.width);
  writeUint8(header, start + 1, icon.height);
  writeUint8(header, start + 2, icon.colorCount);

  writeUint16(header, start + 4, icon.planes);
  writeUint16(header, start + 6, icon.bitCount);
  writeUint32(header, start + 8, icon.bytesInRes);
  writeUint32(header, start + 12, headerSize);

  return header;
}

function isMaxResIcon(icon: IconEntry) {
  return icon.width == 0 && icon.height == 0;
}

function getBiggestIcon(group: IconGroup) {
  if (group.icons.length == 0) {
    return null;
  }

  var biggest = group.icons[0];
  if (isMaxResIcon(biggest)) {
    return biggest;
  }

  for (let i = 1; i < group.icons.length; ++i) {
    let current = group.icons[i];
    if (isMaxResIcon(current)) {
      return current;
    }

    if (current.width * current.height > biggest.width * biggest.height) {
      biggest = current;
    }
  }

  return biggest;
}

function getPeResources(data: Uint8Array) {
  const exe = PE.NtExecutable.from(data, { ignoreCert: true });
  patchExeFile(exe);
  return PE.NtExecutableResource.from(exe, true);
}

function getIconDataUrl(iconEntry: IconEntry, iconData: ArrayBuffer) {
  let contentType = "image/png";

  if (!isPng(new Uint8Array(iconData))) {
    contentType = "image/x-icon";

    const header = generateIcoHeader(iconEntry);
    iconData = mergeArrayBuffers(header.slice().buffer, iconData);
  }

  return generateDataURL(new Uint8Array(iconData), contentType);
}

function tryParsePeIcon(data: Uint8Array) {
  const res = getPeResources(data);
  const icons = res.entries.filter((e) => e.type == 3);
  const iconGroups = res.entries.filter((e) => e.type == 14);

  if (iconGroups.length == 0 || icons.length == 0) {
    return null;
  }

  const groupData = new Uint8Array(iconGroups[0].bin);
  const group = parseIconGroup(groupData);
  const iconEntry = getBiggestIcon(group);

  if (!iconEntry) {
    return null;
  }

  const icon = icons.find((i) => i.id == iconEntry.id);
  if (!icon) {
    return null;
  }

  return getIconDataUrl(iconEntry, icon.bin);
}

export function parsePeIcon(data: Uint8Array) {
  try {
    return tryParsePeIcon(data);
  } catch (e) {
    // console.error(e);
    return null;
  }
}

```

`page/src/playground.tsx`:

```tsx
import React from "react";

import { Output } from "@/components/output";

import { Emulator, EmulationState, isFinalState } from "./emulator";
import {
  Filesystem,
  setupFilesystem,
  windowsToInternalPath,
} from "./filesystem";

import { memory64 } from "wasm-feature-detect";

import "./App.css";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";

import { Settings, loadSettings, saveSettings } from "./settings";
import { SettingsMenu } from "@/components/settings-menu";

import {
  PlayFill,
  StopFill,
  GearFill,
  PauseFill,
  HouseFill,
} from "react-bootstrap-icons";
import { StatusIndicator } from "@/components/status-indicator";
import { Header } from "./Header";

import { Button } from "@/components/ui/button";

import {
  Drawer,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerTitle,
} from "@/components/ui/drawer";
import { FilesystemExplorer } from "./filesystem-explorer";
import { EmulationStatus } from "./emulator";
import { EmulationSummary } from "./components/emulation-summary";
import { downloadBinaryFilePercent } from "./download";

export interface PlaygroundFile {
  file: string;
  storage: string;
}

export interface PlaygroundProps {}

export interface PlaygroundState {
  settings: Settings;
  filesystemPromise?: Promise<Filesystem>;
  filesystem?: Filesystem;
  emulator?: Emulator;
  emulationStatus?: EmulationStatus;
  application?: string;
  drawerOpen: boolean;
  allowWasm64: boolean;
  file?: PlaygroundFile;
}

function decodeFileData(data: string | null): PlaygroundFile | undefined {
  if (!data) {
    return undefined;
  }

  try {
    const jsonData = JSON.parse(atob(data));

    return {
      file: jsonData.file,
      storage: jsonData.storage,
    };
  } catch (e) {
    console.log(e);
  }

  return undefined;
}

interface GlobalThisExt {
  emulateCache?: string | null;
}

function getGlobalThis() {
  return globalThis as GlobalThisExt;
}

export function storeEmulateData(data?: string) {
  getGlobalThis().emulateCache = undefined;

  if (data) {
    localStorage.setItem("emulate", data);
  } else {
    localStorage.removeItem("emulate");
  }
}

function getEmulateData() {
  const gt = getGlobalThis();
  if (gt.emulateCache) {
    return gt.emulateCache;
  }

  const emulateData = localStorage.getItem("emulate");
  localStorage.removeItem("emulate");

  gt.emulateCache = emulateData;
  return emulateData;
}

export class Playground extends React.Component<
  PlaygroundProps,
  PlaygroundState
> {
  private output: React.RefObject<Output | null>;
  private iconCache: Map<string, string | null> = new Map();

  constructor(props: PlaygroundProps) {
    super(props);

    this.output = React.createRef();

    this.start = this.start.bind(this);
    this.resetFilesys = this.resetFilesys.bind(this);
    this.startEmulator = this.startEmulator.bind(this);
    this.fetchExecutionTime = this.fetchExecutionTime.bind(this);
    this.toggleEmulatorState = this.toggleEmulatorState.bind(this);

    this.state = {
      settings: loadSettings(),
      drawerOpen: false,
      allowWasm64: false,
      file: decodeFileData(getEmulateData()),
    };
  }

  componentDidMount(): void {
    memory64().then((allowWasm64) => {
      this.setState({ allowWasm64 });
    });

    if (this.state.file) {
      this.emulateRemoteFile(this.state.file);
    }
  }

  componentWillUnmount(): void {
    this.state.emulator?.stop();
  }

  resetFilesystemState() {
    this.setState({
      filesystemPromise: undefined,
      filesystem: undefined,
      drawerOpen: false,
    });
  }

  fetchExecutionTime() {
    return this.state.emulator ? this.state.emulator.getExecutionTime() : 0;
  }

  async resetFilesys() {
    if (!this.state.filesystem) {
      return;
    }

    await this.state.filesystem.delete();

    this.resetFilesystemState();
    this.output.current?.clear();
    location.reload();
  }

  _onEmulatorStatusChanged(s: EmulationStatus) {
    this.setState({ emulationStatus: s });
  }

  _onEmulatorStateChanged(s: EmulationState, persistFs: boolean) {
    if (isFinalState(s) && persistFs) {
      this.setState({ filesystemPromise: undefined, filesystem: undefined });
      this.initFilesys(true);
    } else {
      this.forceUpdate();
    }
  }

  initFilesys(force: boolean = false) {
    if (!force && this.state.filesystemPromise) {
      return this.state.filesystemPromise;
    }

    const promise = new Promise<Filesystem>((resolve, reject) => {
      if (!force) {
        this.output.current?.clear();
        this.logLine("Loading filesystem...");
      }

      setupFilesystem(
        (current, total, file) => {
          this.logLine(`Processing filesystem (${current}/${total}): ${file}`);
        },
        (percent) => {
          this.logLine(`Downloading filesystem: ${percent}%`);
        },
      )
        .then(resolve)
        .catch(reject);
    });

    promise.then((filesystem) => this.setState({ filesystem }));
    this.setState({ filesystemPromise: promise });

    promise.catch((e) => {
      console.log(e);
      this.logLine("Failed to fetch filesystem:");
      this.logLine(e.toString());
      this.resetFilesystemState();
    });

    return promise;
  }

  setDrawerOpen(drawerOpen: boolean) {
    this.setState({ drawerOpen });
  }

  async downloadFileToFilesystem(file: PlaygroundFile) {
    const fs = await this.initFilesys();

    const fileData = await downloadBinaryFilePercent(
      file.storage,
      (percent) => {
        this.logLine(`Downloading binary: ${percent}%`);
      },
    );

    await fs.storeFiles([
      {
        name: windowsToInternalPath(file.file),
        data: fileData,
      },
    ]);
  }

  async emulateRemoteFile(file: PlaygroundFile) {
    await this.downloadFileToFilesystem(file);
    await this.startEmulator(file.file);
  }

  async start() {
    await this.initFilesys();
    this.setDrawerOpen(true);
  }

  logLine(line: string) {
    this.output.current?.logLine(line);
  }

  logLines(lines: string[]) {
    this.output.current?.logLines(lines);
  }

  isEmulatorPaused() {
    return (
      this.state.emulator &&
      this.state.emulator.getState() == EmulationState.Paused
    );
  }

  toggleEmulatorState() {
    if (this.isEmulatorPaused()) {
      this.state.emulator?.resume();
    } else {
      this.state.emulator?.pause();
    }
  }

  async startEmulator(userFile: string) {
    this.state.emulator?.stop();
    this.output.current?.clear();

    this.setDrawerOpen(false);

    if (this.state.filesystemPromise) {
      await this.state.filesystemPromise;
    }

    const persistFs = this.state.settings.persist;

    const new_emulator = new Emulator(
      (l) => this.logLines(l),
      (s) => this._onEmulatorStateChanged(s, persistFs),
      (s) => this._onEmulatorStatusChanged(s),
    );
    //new_emulator.onTerminate().then(() => this.setState({ emulator: null }));

    this.setState({ emulator: new_emulator, application: userFile });

    new_emulator.start(this.state.settings, userFile);
  }

  render() {
    return (
      <>
        <Header
          title="Sogen - Playground"
          description="Playground to test and run Sogen, a Windows user space emulator, right in your browser."
          preload={
            [
              /*"./emulator-worker.js", "./analyzer.js", "./analyzer.wasm"*/
            ]
          }
        />
        <div className="h-[100dvh] flex flex-col">
          <header className="flex shrink-0 items-center gap-2 border-b p-2 overflow-y-auto">
            <a title="Home" href="#/">
              <Button
                size="sm"
                variant="secondary"
                className="fancy"
                title="Home Button"
              >
                <HouseFill />
              </Button>
            </a>
            <Button
              size="sm"
              className="fancy"
              onClick={this.start}
              title="Start"
            >
              <PlayFill /> <span>Start</span>
            </Button>

            <Button
              disabled={
                !this.state.emulator ||
                isFinalState(this.state.emulator.getState())
              }
              size="sm"
              title="Stop"
              variant="secondary"
              className="fancy"
              onClick={() => this.state.emulator?.stop()}
            >
              <StopFill /> <span className="hidden sm:inline">Stop</span>
            </Button>
            <Button
              size="sm"
              title={this.isEmulatorPaused() ? "Resume" : "Pause"}
              disabled={
                !this.state.emulator ||
                isFinalState(this.state.emulator.getState())
              }
              variant="secondary"
              className="fancy"
              onClick={this.toggleEmulatorState}
            >
              {this.isEmulatorPaused() ? (
                <>
                  <PlayFill /> <span className="hidden sm:inline">Resume</span>
                </>
              ) : (
                <>
                  <PauseFill /> <span className="hidden sm:inline">Pause</span>
                </>
              )}
            </Button>

            <Popover>
              <PopoverTrigger asChild>
                <Button
                  size="sm"
                  variant="secondary"
                  className="fancy"
                  title="Settings"
                >
                  <GearFill />{" "}
                  <span className="hidden sm:inline">Settings</span>
                </Button>
              </PopoverTrigger>
              <PopoverContent>
                <SettingsMenu
                  settings={this.state.settings}
                  allowWasm64={this.state.allowWasm64}
                  onChange={(s) => {
                    saveSettings(s);
                    this.setState({ settings: s });
                  }}
                />
              </PopoverContent>
            </Popover>

            {!this.state.filesystem ? (
              <></>
            ) : (
              <Drawer
                open={this.state.drawerOpen}
                onOpenChange={(o) => this.setState({ drawerOpen: o })}
              >
                <DrawerContent className="!will-change-auto">
                  <DrawerHeader>
                    <DrawerTitle className="hidden">
                      Filesystem Explorer
                    </DrawerTitle>
                    <DrawerDescription className="hidden">
                      Filesystem Explorer
                    </DrawerDescription>
                  </DrawerHeader>
                  <DrawerFooter>
                    <FilesystemExplorer
                      filesystem={this.state.filesystem}
                      iconCache={this.iconCache}
                      runFile={this.startEmulator}
                      resetFilesys={this.resetFilesys}
                      path={["c"]}
                    />
                  </DrawerFooter>
                </DrawerContent>
              </Drawer>
            )}

            {/* Separator */}
            <div className="flex-1"></div>

            <div className="text-right items-center">
              <StatusIndicator
                application={this.state.application}
                state={
                  this.state.emulator
                    ? this.state.emulator.getState()
                    : EmulationState.Stopped
                }
              />
            </div>
          </header>
          <div className="flex flex-1">
            <EmulationSummary
              status={this.state.emulationStatus}
              executionTimeFetcher={this.fetchExecutionTime}
            />
            <div className="flex flex-1 flex-col pl-1 overflow-auto">
              <Output ref={this.output} />
            </div>
          </div>
        </div>
      </>
    );
  }
}

```

`page/src/settings.ts`:

```ts
import { parse } from "shell-quote";

export interface Settings {
  logging: "verbose" | "silent" | "concise" | string;
  bufferStdout: boolean;
  persist: boolean;
  execAccess: boolean;
  foreignAccess: boolean;
  wasm64: boolean;
  instructionSummary: boolean;
  ignoredFunctions: string[];
  interestingModules: string[];
  commandLine: string;
}

export interface TranslatedSettings {
  emulatorOptions: string[];
  applicationOptions: string[];
}

export function createDefaultSettings(): Settings {
  return {
    logging: "regular",
    bufferStdout: true,
    persist: false,
    execAccess: false,
    foreignAccess: false,
    wasm64: false,
    instructionSummary: false,
    ignoredFunctions: [],
    interestingModules: [],
    commandLine: "",
  };
}

export function loadSettings(): Settings {
  const defaultSettings = createDefaultSettings();

  const settingsStr = localStorage.getItem("settings");
  if (!settingsStr) {
    return defaultSettings;
  }

  try {
    const userSettings = JSON.parse(settingsStr);
    const keys = Object.keys(defaultSettings);

    keys.forEach((k) => {
      if (k in userSettings) {
        (defaultSettings as any)[k] = userSettings[k];
      }
    });
  } catch (e) {}

  return defaultSettings;
}

export function saveSettings(settings: Settings) {
  localStorage.setItem("settings", JSON.stringify(settings));
}

export function translateSettings(settings: Settings): TranslatedSettings {
  const switches: string[] = [];
  const options: string[] = [];

  switch (settings.logging) {
    case "verbose":
      switches.push("-v");
      break;
    case "silent":
      switches.push("-s");
      break;
    case "concise":
      switches.push("-c");
      break;

    default:
      break;
  }

  if (settings.bufferStdout) {
    switches.push("-b");
  }

  if (settings.execAccess) {
    switches.push("-x");
  }

  if (settings.foreignAccess) {
    switches.push("-f");
  }

  if (settings.instructionSummary) {
    switches.push("-is");
  }

  settings.ignoredFunctions.forEach((f) => {
    switches.push("-i");
    switches.push(f);
  });

  settings.interestingModules.forEach((m) => {
    switches.push("-m");
    switches.push(m);
  });

  try {
    const argv = parse(settings.commandLine) as string[];
    options.push(...argv);
  } catch (e) {
    console.log(e);
  }

  return {
    applicationOptions: options,
    emulatorOptions: switches,
  };
}

```

`page/src/vite-env.d.ts`:

```ts
/// <reference types="vite/client" />
/// <reference types="vite-plugin-pwa/client" />

```

`page/src/zip-file.ts`:

```ts
import JSZip from "jszip";

export type ProgressHandler = (
  processed: number,
  total: number,
  filename: string,
) => void;

export interface FileEntry {
  name: string;
  data: ArrayBuffer;
}

export async function parseZipFile(
  arrayBuffer: ArrayBuffer,
  progressHandler?: ProgressHandler,
) {
  const zip = await JSZip.loadAsync(arrayBuffer);

  const files: Promise<FileEntry>[] = [];
  const progress = {
    files: 0,
    processed: 0,
  };

  zip.forEach(function (relativePath, zipEntry) {
    progress.files += 1;
    files.push(
      zipEntry.async("arraybuffer").then((data) => {
        progress.processed += 1;

        if (progressHandler) {
          progressHandler(progress.processed, progress.files, relativePath);
        }

        return { name: relativePath, data };
      }),
    );
  });

  return await Promise.all(files);
}

```

`page/tsconfig.app.json`:

```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}

```

`page/tsconfig.json`:

```json
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.node.json"
    }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["vite-plugin-pwa/client"]
  }
}

```

`page/tsconfig.node.json`:

```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

```

`page/vite.config.ts`:

```ts
import path from "path";
import tailwindcss from "@tailwindcss/vite";
import { defineConfig } from "vite";
import { VitePWA } from "vite-plugin-pwa";
import react from "@vitejs/plugin-react";
import { RuntimeCaching } from "workbox-build";

const mb = 1024 ** 2;

function generateExternalCache(
  pattern: string | RegExp,
  name: string,
): RuntimeCaching {
  return {
    urlPattern: pattern,
    handler: "CacheFirst",
    options: {
      cacheName: name,
      expiration: {
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // <== 365 days
      },
      cacheableResponse: {
        statuses: [0, 200],
      },
    },
  };
}

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),
    VitePWA({
      registerType: "autoUpdate",
      manifest: {
        theme_color: "#0279E8",
        background_color: "#141416",
      },
      workbox: {
        maximumFileSizeToCacheInBytes: 100 * mb,
        cleanupOutdatedCaches: true,
        globPatterns: ["**/*.{js,css,html,woff,woff2,wasm}"],
        globIgnores: ["root.zip"],
        navigateFallbackDenylist: [/^\/root\.zip$/],
        runtimeCaching: [
          generateExternalCache(
            /^https:\/\/momo5502\.com\/.*/i,
            "momo5502-cache",
          ),
          generateExternalCache(
            /^https:\/\/img\.youtube\.com\/.*/i,
            "youtube-img-cache",
          ),
        ],
      },
    }),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  define: {
    "import.meta.env.VITE_BUILD_TIME": JSON.stringify(Date.now()),
  },
});

```

`src/CMakeLists.txt`:

```txt
add_subdirectory(common)
add_subdirectory(emulator)
add_subdirectory(gdb-stub)
add_subdirectory(windows-emulator)
add_subdirectory(windows-gdb-stub)
add_subdirectory(backend-selection)

momo_add_subdirectory_and_get_targets("backends" BACKEND_TARGETS)
momo_targets_set_folder("backends" ${BACKEND_TARGETS})

set(_SOGEN_BUILD_STANDALONE_TARGETS ON)
if (SOGEN_BUILD_STATIC)
  # if static build, tools are opt in
  set(_SOGEN_BUILD_STANDALONE_TARGETS ${SOGEN_BUILD_TOOLS})
endif()

if (_SOGEN_BUILD_STANDALONE_TARGETS)
  add_subdirectory(analyzer)
  add_subdirectory(debugger)
  add_subdirectory(fuzzing-engine)
  add_subdirectory(fuzzer)
  add_subdirectory(windows-emulator-test)
  if(WIN32 AND CMAKE_SIZEOF_VOID_P EQUAL 8)
    momo_add_subdirectory_and_get_targets("tools" TOOL_TARGETS)
    momo_targets_set_folder("tools" ${TOOL_TARGETS})

    momo_add_subdirectory_and_get_targets("samples" SAMPLE_TARGETS)
    momo_targets_set_folder("samples" ${SAMPLE_TARGETS})
  endif()
endif()

```

`src/analyzer/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(analyzer ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

if(NOT MOMO_ENABLE_CLANG_TIDY)
  target_precompile_headers(analyzer PRIVATE std_include.hpp)
endif()

target_link_libraries(analyzer PRIVATE
  reflect
  debugger
  capstone
  windows-emulator
  windows-gdb-stub
  backend-selection
)

set_property(GLOBAL PROPERTY VS_STARTUP_PROJECT analyzer)

momo_strip_target(analyzer)

set(ENV_PREFIX "$")
set(ENV_SUFFIX "")

if(WIN)
set(ENV_PREFIX "%")
set(ENV_SUFFIX "%")
endif()

add_test(NAME analyzer-test
         COMMAND "${PYTHON3_EXE}" "${CMAKE_CURRENT_LIST_DIR}/test.py"
         WORKING_DIRECTORY "$<TARGET_FILE_DIR:analyzer>")

```

`src/analyzer/analysis.cpp`:

```cpp
#include "std_include.hpp"

#include "analysis.hpp"
#include "disassembler.hpp"
#include "windows_emulator.hpp"
#include <utils/lazy_object.hpp>

#if defined(OS_EMSCRIPTEN) && !defined(MOMO_EMSCRIPTEN_SUPPORT_NODEJS)
#include <event_handler.hpp>
#endif

#define STR_VIEW_VA(str) static_cast<int>((str).size()), (str).data()

namespace
{
    constexpr size_t MAX_INSTRUCTION_BYTES = 15;

    template <typename Return, typename... Args>
    std::function<Return(Args...)> make_callback(analysis_context& c, Return (*callback)(analysis_context&, Args...))
    {
        return [&c, callback](Args... args) {
            return callback(c, std::forward<Args>(args)...); //
        };
    }

    template <typename Return, typename... Args>
    std::function<Return(Args...)> make_callback(analysis_context& c, Return (*callback)(const analysis_context&, Args...))
    {
        return [&c, callback](Args... args) {
            return callback(c, std::forward<Args>(args)...); //
        };
    }

    std::string get_instruction_string(const disassembler& d, const emulator& emu, const uint64_t address)
    {
        std::array<uint8_t, MAX_INSTRUCTION_BYTES> instruction_bytes{};
        const auto result = emu.try_read_memory(address, instruction_bytes.data(), instruction_bytes.size());
        if (!result)
        {
            return {};
        }

        uint16_t reg_cs = 0;
        auto& emu_ref = const_cast<emulator&>(emu);
        emu_ref.read_raw_register(static_cast<int>(x86_register::cs), &reg_cs, sizeof(reg_cs));
        const auto instructions = d.disassemble(emu_ref, reg_cs, instruction_bytes, 1);
        if (instructions.empty())
        {
            return {};
        }

        const auto& inst = instructions[0];
        return std::string(inst.mnemonic) + (strlen(inst.op_str) ? " "s + inst.op_str : "");
    }

    void handle_suspicious_activity(const analysis_context& c, const std::string_view details)
    {
        std::string addition{};
        const auto rip = c.win_emu->emu().read_instruction_pointer();

        // TODO: Pass enum?
        if (details == "Illegal instruction")
        {
            const auto inst = get_instruction_string(c.d, c.win_emu->emu(), rip);
            if (!inst.empty())
            {
                addition = " (" + inst + ")";
            }
        }

        c.win_emu->log.print(color::pink, "Suspicious: %.*s%.*s at 0x%" PRIx64 " (via 0x%" PRIx64 ")\n", STR_VIEW_VA(details),
                             STR_VIEW_VA(addition), rip, c.win_emu->current_thread().previous_ip);
    }

    void handle_debug_string(const analysis_context& c, const std::string_view details)
    {
        c.win_emu->log.info("--> Debug string: %.*s\n", STR_VIEW_VA(details));
    }

    void handle_generic_activity(const analysis_context& c, const std::string_view details)
    {
        c.win_emu->log.print(color::dark_gray, "%.*s\n", STR_VIEW_VA(details));
    }

    void handle_generic_access(const analysis_context& c, const std::string_view type, const std::u16string_view name)
    {
        c.win_emu->log.print(color::dark_gray, "--> %.*s: %s\n", STR_VIEW_VA(type), u16_to_u8(name).c_str()); //
    }

    void handle_memory_allocate(const analysis_context& c, const uint64_t address, const uint64_t length,
                                const memory_permission permission, const bool commit)
    {
        const auto* action = commit ? "Committed" : "Allocating";

        c.win_emu->log.print(is_executable(permission) ? color::gray : color::dark_gray, "--> %s 0x%" PRIx64 " - 0x%" PRIx64 " (%s)\n",
                             action, address, address + length, get_permission_string(permission).c_str());
    }

    void handle_memory_protect(const analysis_context& c, const uint64_t address, const uint64_t length, const memory_permission permission)
    {
        c.win_emu->log.print(color::dark_gray, "--> Changing protection at 0x%" PRIx64 "-0x%" PRIx64 " to %s\n", address, address + length,
                             get_permission_string(permission).c_str());
    }

    void handle_memory_violate(const analysis_context& c, const uint64_t address, const uint64_t size, const memory_operation operation,
                               const memory_violation_type type)
    {
        const auto permission = get_permission_string(operation);
        const auto ip = c.win_emu->emu().read_instruction_pointer();
        const char* name = c.win_emu->mod_manager.find_name(ip);

        if (type == memory_violation_type::protection)
        {
            c.win_emu->log.print(color::gray, "Protection violation: 0x%" PRIx64 " (%" PRIx64 ") - %s at 0x%" PRIx64 " (%s)\n", address,
                                 size, permission.c_str(), ip, name);
        }
        else if (type == memory_violation_type::unmapped)
        {
            c.win_emu->log.print(color::gray, "Mapping violation: 0x%" PRIx64 " (%" PRIx64 ") - %s at 0x%" PRIx64 " (%s)\n", address, size,
                                 permission.c_str(), ip, name);
        }
    }

    void handle_ioctrl(const analysis_context& c, const io_device&, const std::u16string_view device_name, const ULONG code)
    {
        c.win_emu->log.print(color::dark_gray, "--> %s: 0x%X\n", u16_to_u8(device_name).c_str(), static_cast<uint32_t>(code));
    }

    void handle_thread_create(const analysis_context& c, handle, emulator_thread& t)
    {
        std::vector<std::string> flags{};

        if (t.create_flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED)
        {
            flags.emplace_back("suspended");
        }
        if (t.create_flags & THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH)
        {
            flags.emplace_back("skip thread attach");
        }
        if (t.create_flags & THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER)
        {
            flags.emplace_back("hide from debugger");
        }
        if (t.create_flags & THREAD_CREATE_FLAGS_LOADER_WORKER)
        {
            flags.emplace_back("loader worker");
        }
        if (t.create_flags & THREAD_CREATE_FLAGS_SKIP_LOADER_INIT)
        {
            flags.emplace_back("skip loader init");
        }
        if (t.create_flags & THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE)
        {
            flags.emplace_back("bypass process freeze");
        }

        std::string flags_string{};
        for (const auto& flag : flags)
        {
            flags_string += ", ";
            flags_string += flag;
        }

        c.win_emu->log.print(color::gray, "Thread created: tid %d, start address 0x%" PRIx64 " (param 0x%" PRIx64 ")%s\n", t.id,
                             t.start_address, t.argument, flags_string.c_str());
    }

    void handle_thread_terminated(const analysis_context& c, handle, emulator_thread& t)
    {
        c.win_emu->log.print(color::gray, "Thread terminated: tid %d\n", t.id);
    }

    void handle_thread_set_name(const analysis_context& c, const emulator_thread& t)
    {
        c.win_emu->log.print(color::blue, "Setting thread (%u) name: %s\n", t.id, u16_to_u8(t.name).c_str());
    }

    void handle_thread_switch(const analysis_context& c, const emulator_thread& current_thread, const emulator_thread& new_thread)
    {
        c.win_emu->log.print(color::dark_gray, "Performing thread switch: %X -> %X\n", current_thread.id, new_thread.id);
    }

    void handle_module_load(const analysis_context& c, const mapped_module& mod)
    {
        c.win_emu->log.log("Mapped %s at 0x%" PRIx64 "\n", mod.path.generic_string().c_str(), mod.image_base);
    }

    void handle_module_unload(const analysis_context& c, const mapped_module& mod)
    {
        c.win_emu->log.log("Unmapping %s (0x%" PRIx64 ")\n", mod.path.generic_string().c_str(), mod.image_base);
    }

    void print_string(logger& log, const std::string_view str)
    {
        log.print(color::dark_gray, "--> %.*s\n", STR_VIEW_VA(str));
    }

    void print_string(logger& log, const std::u16string_view str)
    {
        print_string(log, u16_to_u8(str));
    }

    bool is_int_resource(const uint64_t address)
    {
        return (address >> 0x10) == 0;
    }

    template <typename CharType = char>
    void print_arg_as_string(windows_emulator& win_emu, const size_t index)
    {
        const auto var_ptr = get_function_argument(win_emu.emu(), index);
        if (var_ptr && !is_int_resource(var_ptr))
        {
            try
            {
                const auto str = read_string<CharType>(win_emu.memory, var_ptr);
                print_string(win_emu.log, str);
            }
            catch (...)
            {
                print_string(win_emu.log, "[failed to read]");
            }
        }
    }

    void print_module_name(windows_emulator& win_emu, const size_t index)
    {
        const auto var_ptr = get_function_argument(win_emu.emu(), index);
        if (var_ptr)
        {
            const auto* module_name = win_emu.mod_manager.find_name(var_ptr);
            print_string(win_emu.log, module_name);
        }
    }

    void handle_function_details(const analysis_context& c, const std::string_view function)
    {
        if (function == "GetEnvironmentVariableA"      //
            || function == "ExpandEnvironmentStringsA" //
            || function == "LoadLibraryA")
        {
            print_arg_as_string(*c.win_emu, 0);
        }
        else if (function == "LoadLibraryW")
        {
            print_arg_as_string<char16_t>(*c.win_emu, 0);
        }
        else if (function == "MessageBoxA")
        {
            print_arg_as_string(*c.win_emu, 2);
            print_arg_as_string(*c.win_emu, 1);
        }
        else if (function == "MessageBoxW")
        {
            print_arg_as_string<char16_t>(*c.win_emu, 2);
            print_arg_as_string<char16_t>(*c.win_emu, 1);
        }
        else if (function == "GetProcAddress")
        {
            print_module_name(*c.win_emu, 0);
            print_arg_as_string(*c.win_emu, 1);
        }
        else if (function == "WinVerifyTrust")
        {
            auto& emu = c.win_emu->emu();
            emu.reg(x86_register::rip, emu.read_stack(0));
            emu.reg(x86_register::rsp, emu.reg(x86_register::rsp) + 8);
            emu.reg(x86_register::rax, 0);
        }
        else if (function == "lstrcmp" || function == "lstrcmpi")
        {
            print_arg_as_string(*c.win_emu, 0);
            print_arg_as_string(*c.win_emu, 1);
        }
    }

    bool is_thread_alive(const analysis_context& c, const uint32_t thread_id)
    {
        for (const auto& t : c.win_emu->process.threads | std::views::values)
        {
            if (t.id == thread_id)
            {
                return true;
            }
        }

        return false;
    }

    void update_import_access(analysis_context& c, const uint64_t address)
    {
        if (c.accessed_imports.empty())
        {
            return;
        }

        const auto& t = c.win_emu->current_thread();
        for (auto entry = c.accessed_imports.begin(); entry != c.accessed_imports.end();)
        {
            auto& a = *entry;
            const auto is_same_thread = t.id == a.thread_id;

            if (is_same_thread && address == a.address)
            {
                entry = c.accessed_imports.erase(entry);
                continue;
            }

            constexpr auto inst_delay = 100u;
            const auto execution_delay_reached = is_same_thread && a.access_inst_count + inst_delay <= t.executed_instructions;

            if (!execution_delay_reached && is_thread_alive(c, a.thread_id))
            {
                ++entry;
                continue;
            }

            c.win_emu->log.print(color::green, "Import read access: %s (%s) at 0x%" PRIx64 " (%s)\n", a.import_name.c_str(),
                                 a.import_module.c_str(), a.access_rip, a.accessor_module.c_str());

            entry = c.accessed_imports.erase(entry);
        }
    }

    bool is_return(const disassembler& d, const emulator& emu, const uint64_t address)
    {
        std::array<uint8_t, MAX_INSTRUCTION_BYTES> instruction_bytes{};
        const auto result = emu.try_read_memory(address, instruction_bytes.data(), instruction_bytes.size());
        if (!result)
        {
            return false;
        }

        uint16_t reg_cs = 0;
        auto& emu_ref = const_cast<emulator&>(emu);
        emu_ref.read_raw_register(static_cast<int>(x86_register::cs), &reg_cs, sizeof(reg_cs));
        const auto instructions = d.disassemble(emu_ref, reg_cs, instruction_bytes, 1);
        if (instructions.empty())
        {
            return false;
        }

        const auto handle = d.resolve_handle(emu_ref, reg_cs);
        return cs_insn_group(handle, instructions.data(), CS_GRP_RET);
    }

    void record_instruction(analysis_context& c, const uint64_t address)
    {
        auto& emu = c.win_emu->emu();
        std::array<uint8_t, MAX_INSTRUCTION_BYTES> instruction_bytes{};
        const auto result = emu.try_read_memory(address, instruction_bytes.data(), instruction_bytes.size());
        if (!result)
        {
            return;
        }

        const auto reg_cs = emu.reg<uint16_t>(x86_register::cs);
        disassembler disasm{};
        const auto instructions = disasm.disassemble(emu, reg_cs, instruction_bytes, 1);
        if (instructions.empty())
        {
            return;
        }

        ++c.instructions[instructions[0].id];
    }

    void handle_instruction(analysis_context& c, const uint64_t address)
    {
        auto& win_emu = *c.win_emu;
        update_import_access(c, address);

#if defined(OS_EMSCRIPTEN) && !defined(MOMO_EMSCRIPTEN_SUPPORT_NODEJS)
        if ((win_emu.get_executed_instructions() % 0x20000) == 0)
        {
            debugger::event_context ec{.win_emu = win_emu};
            debugger::handle_events(ec);
        }
#endif

        const auto& current_thread = c.win_emu->current_thread();
        const auto previous_ip = current_thread.previous_ip;
        [[maybe_unused]] const auto current_ip = current_thread.current_ip;
        const auto is_main_exe = win_emu.mod_manager.executable->contains(address);
        const auto is_previous_main_exe = win_emu.mod_manager.executable->contains(previous_ip);

        const auto binary = utils::make_lazy([&] {
            if (is_main_exe)
            {
                return win_emu.mod_manager.executable;
            }

            return win_emu.mod_manager.find_by_address(address); //
        });

        if (binary)
        {
            for (auto& section : binary->sections)
            {
                if (is_within_start_and_length(address, section.region.start, section.region.length) && section.first_execute == UINT64_MAX)
                {
                    section.first_execute = address;
                    win_emu.log.print(color::green, "Section %s (%s) first execute at 0x%" PRIx64 " 0x%" PRIx64 " (tid: %" PRIx32 ")\n",
                                      binary->name.c_str(), section.name.c_str(), section.first_execute,
                                      section.first_execute - binary->image_base + binary->image_base_file, current_thread.id);
                }
            }
        }

        const auto previous_binary = utils::make_lazy([&] {
            if (is_previous_main_exe)
            {
                return win_emu.mod_manager.executable;
            }

            return win_emu.mod_manager.find_by_address(previous_ip); //
        });

        const auto is_current_binary_interesting = utils::make_lazy([&] {
            return is_main_exe || (binary && c.settings->modules.contains(binary->name)); //
        });

        const auto is_in_interesting_module = [&] {
            if (c.settings->modules.empty())
            {
                return false;
            }

            return is_current_binary_interesting || (previous_binary && c.settings->modules.contains(previous_binary->name));
        };

        if (c.settings->instruction_summary && (is_current_binary_interesting || !binary))
        {
            record_instruction(c, address);
        }

        const auto is_interesting_call = is_previous_main_exe                                              //
                                         || (!previous_binary && current_thread.executed_instructions > 1) //
                                         || is_in_interesting_module();

        if (!c.has_reached_main && c.settings->concise_logging && !c.settings->silent && is_main_exe)
        {
            c.has_reached_main = true;
            win_emu.log.disable_output(false);
        }

        if ((!c.settings->verbose_logging && !is_interesting_call) || !binary)
        {
            return;
        }

        const auto export_entry = binary->address_names.find(address);
        if (export_entry != binary->address_names.end())
        {
            if (!c.settings->ignored_functions.contains(export_entry->second))
            {
                win_emu.log.print(is_interesting_call ? color::yellow : color::dark_gray,
                                  "Executing function: %s (%s) (0x%" PRIx64 ") via (0x%" PRIx64 ") %s\n", export_entry->second.c_str(),
                                  binary->name.c_str(), address, previous_ip, previous_binary ? previous_binary->name.c_str() : "<N/A>");

                if (is_interesting_call)
                {
                    handle_function_details(c, export_entry->second);
                }
            }
        }
        else if (address == binary->entry_point)
        {
            win_emu.log.print(is_interesting_call ? color::yellow : color::gray, "Executing entry point: %s (0x%" PRIx64 ")\n",
                              binary->name.c_str(), address);
        }
        else if (is_previous_main_exe && binary != previous_binary && !is_return(c.d, c.win_emu->emu(), previous_ip))
        {
            auto nearest_entry = binary->address_names.upper_bound(address);
            if (nearest_entry == binary->address_names.begin())
            {
                return;
            }

            --nearest_entry;

            win_emu.log.print(is_interesting_call ? color::yellow : color::dark_gray,
                              "Transition to foreign code: %s+0x%" PRIx64 " (%s) (0x%" PRIx64 ") via (0x%" PRIx64 ") %s\n",
                              nearest_entry->second.c_str(), address - nearest_entry->first, binary->name.c_str(), address, previous_ip,
                              previous_binary ? previous_binary->name.c_str() : "<N/A>");
        }
    }

    void handle_rdtsc(analysis_context& c)
    {
        auto& win_emu = *c.win_emu;
        auto& emu = win_emu.emu();

        const auto rip = emu.read_instruction_pointer();
        const auto mod = get_module_if_interesting(win_emu.mod_manager, c.settings->modules, rip);

        if (!mod.has_value() || (c.settings->concise_logging && !c.rdtsc_cache.insert(rip).second))
        {
            return;
        }

        win_emu.log.print(color::blue, "Executing RDTSC instruction at 0x%" PRIx64 " (%s)\n", rip, (*mod) ? (*mod)->name.c_str() : "<N/A>");
    }

    void handle_rdtscp(analysis_context& c)
    {
        auto& win_emu = *c.win_emu;
        auto& emu = win_emu.emu();

        const auto rip = emu.read_instruction_pointer();
        const auto mod = get_module_if_interesting(win_emu.mod_manager, c.settings->modules, rip);

        if (!mod.has_value() || (c.settings->concise_logging && !c.rdtscp_cache.insert(rip).second))
        {
            return;
        }

        win_emu.log.print(color::blue, "Executing RDTSCP instruction at 0x%" PRIx64 " (%s)\n", rip,
                          (*mod) ? (*mod)->name.c_str() : "<N/A>");
    }

    emulator_callbacks::continuation handle_syscall(const analysis_context& c, const uint32_t syscall_id,
                                                    const std::string_view syscall_name)
    {
        auto& win_emu = *c.win_emu;
        auto& emu = win_emu.emu();

        const auto address = emu.read_instruction_pointer();
        const auto* mod = win_emu.mod_manager.find_by_address(address);
        const auto is_sus_module = mod != win_emu.mod_manager.ntdll && mod != win_emu.mod_manager.win32u;
        const auto previous_ip = win_emu.current_thread().previous_ip;

        if (is_sus_module)
        {
            win_emu.log.print(color::blue, "Executing inline syscall: %.*s (0x%X) at 0x%" PRIx64 " (%s)\n", STR_VIEW_VA(syscall_name),
                              syscall_id, address, mod ? mod->name.c_str() : "<N/A>");
        }
        else if (mod->contains(previous_ip))
        {
            if (!c.settings->skip_syscalls)
            {
                const auto rsp = emu.read_stack_pointer();

                uint64_t return_address{};
                emu.try_read_memory(rsp, &return_address, sizeof(return_address));

                const auto* caller_mod_name = win_emu.mod_manager.find_name(return_address);

                win_emu.log.print(color::dark_gray, "Executing syscall: %.*s (0x%X) at 0x%" PRIx64 " via 0x%" PRIx64 " (%s)\n",
                                  STR_VIEW_VA(syscall_name), syscall_id, address, return_address, caller_mod_name);
            }
        }
        else
        {
            const auto* previous_mod = win_emu.mod_manager.find_by_address(previous_ip);

            win_emu.log.print(color::blue, "Crafted out-of-line syscall: %.*s (0x%X) at 0x%" PRIx64 " (%s) via 0x%" PRIx64 " (%s)\n",
                              STR_VIEW_VA(syscall_name), syscall_id, address, mod ? mod->name.c_str() : "<N/A>", previous_ip,
                              previous_mod ? previous_mod->name.c_str() : "<N/A>");
        }

        return instruction_hook_continuation::run_instruction;
    }

    void handle_stdout(analysis_context& c, const std::string_view data)
    {
        if (c.settings->silent)
        {
            (void)fwrite(data.data(), 1, data.size(), stdout);
        }
        else if (c.settings->buffer_stdout)
        {
            c.output.append(data);
        }
        else
        {
            c.win_emu->log.info("%.*s%s", static_cast<int>(data.size()), data.data(), data.ends_with("\n") ? "" : "\n");
        }
    }

    void watch_import_table(analysis_context& c)
    {
        c.win_emu->setup_process_if_necessary();

        const auto& import_list = c.win_emu->mod_manager.executable->imports;
        if (import_list.empty())
        {
            return;
        }

        auto min = std::numeric_limits<uint64_t>::max();
        auto max = std::numeric_limits<uint64_t>::min();

        for (const auto& import_thunk : import_list | std::views::keys)
        {
            min = std::min(import_thunk, min);
            max = std::max(import_thunk, max);
        }

        c.win_emu->emu().hook_memory_write(min, max - min, [&c](const uint64_t address, const void*, size_t) {
            const auto& watched_module = *c.win_emu->mod_manager.executable;
            const auto& accessor_module = *c.win_emu->mod_manager.executable;

            const auto rip = c.win_emu->emu().read_instruction_pointer();

            if (!accessor_module.contains(rip))
            {
                return;
            }

            const auto sym = watched_module.imports.find(address);
            if (sym == watched_module.imports.end())
            {
                return;
            }

            const auto import_module = watched_module.imported_modules.at(sym->second.module_index);

            c.win_emu->log.print(color::blue, "Import write access: %s (%s) at 0x%" PRIx64 " (%s)\n", sym->second.name.c_str(),
                                 import_module.c_str(), rip, accessor_module.name.c_str());
        });

        c.win_emu->emu().hook_memory_read(min, max - min, [&c](const uint64_t address, const void*, size_t) {
            const auto& watched_module = *c.win_emu->mod_manager.executable;
            const auto& accessor_module = *c.win_emu->mod_manager.executable;

            const auto rip = c.win_emu->emu().read_instruction_pointer();

            if (!accessor_module.contains(rip))
            {
                return;
            }

            const auto sym = watched_module.imports.find(address);
            if (sym == watched_module.imports.end())
            {
                return;
            }

            accessed_import access{};

            access.address = c.win_emu->emu().read_memory<uint64_t>(address);

            access.access_rip = rip;
            access.accessor_module = accessor_module.name;

            access.import_name = sym->second.name;
            access.import_module = watched_module.imported_modules.at(sym->second.module_index);

            const auto& t = c.win_emu->current_thread();
            access.thread_id = t.id;
            access.access_inst_count = t.executed_instructions;

            c.accessed_imports.push_back(std::move(access));
        });
    }
}

void register_analysis_callbacks(analysis_context& c)
{
    auto& cb = c.win_emu->callbacks;

    cb.on_stdout = make_callback(c, handle_stdout);
    cb.on_syscall = make_callback(c, handle_syscall);
    cb.on_rdtsc = make_callback(c, handle_rdtsc);
    cb.on_rdtscp = make_callback(c, handle_rdtscp);
    cb.on_ioctrl = make_callback(c, handle_ioctrl);

    cb.on_memory_protect = make_callback(c, handle_memory_protect);
    cb.on_memory_violate = make_callback(c, handle_memory_violate);
    cb.on_memory_allocate = make_callback(c, handle_memory_allocate);

    (void)cb.on_module_load.add(make_callback(c, handle_module_load));
    (void)cb.on_module_unload.add(make_callback(c, handle_module_unload));

    cb.on_thread_create = make_callback(c, handle_thread_create);
    cb.on_thread_terminated = make_callback(c, handle_thread_terminated);
    cb.on_thread_switch = make_callback(c, handle_thread_switch);
    cb.on_thread_set_name = make_callback(c, handle_thread_set_name);

    cb.on_instruction = make_callback(c, handle_instruction);
    cb.on_debug_string = make_callback(c, handle_debug_string);
    cb.on_generic_access = make_callback(c, handle_generic_access);
    cb.on_generic_activity = make_callback(c, handle_generic_activity);
    cb.on_suspicious_activity = make_callback(c, handle_suspicious_activity);

    watch_import_table(c);
}

std::optional<mapped_module*> get_module_if_interesting(module_manager& manager, const string_set& modules, const uint64_t address)
{
    if (manager.executable->contains(address))
    {
        return manager.executable;
    }

    auto* mod = manager.find_by_address(address);
    if (!mod)
    {
        // Not being part of any module is interesting
        return nullptr;
    }

    if (modules.contains(mod->name))
    {
        return mod;
    }

    return std::nullopt;
}

```

`src/analyzer/analysis.hpp`:

```hpp
#pragma once

#include <set>
#include <string>
#include "disassembler.hpp"

struct mapped_module;
class module_manager;
class windows_emulator;

using string_set = std::set<std::string, std::less<>>;

struct analysis_settings
{
    bool concise_logging{false};
    bool verbose_logging{false};
    bool silent{false};
    bool buffer_stdout{false};
    bool instruction_summary{false};
    bool skip_syscalls{false};

    string_set modules{};
    string_set ignored_functions{};
};

struct accessed_import
{
    uint64_t address{};
    uint32_t thread_id{};
    uint64_t access_rip{};
    uint64_t access_inst_count{};
    std::string accessor_module{};
    std::string import_name{};
    std::string import_module{};
};

struct analysis_context
{
    const analysis_settings* settings{};
    windows_emulator* win_emu{};

    std::string output{};
    bool has_reached_main{false};

    disassembler d{};
    std::unordered_map<uint32_t, uint64_t> instructions{};
    std::vector<accessed_import> accessed_imports{};
    std::set<uint64_t> rdtsc_cache{};
    std::set<uint64_t> rdtscp_cache{};
    std::set<std::pair<uint64_t, uint32_t>> cpuid_cache{};
};

void register_analysis_callbacks(analysis_context& c);
std::optional<mapped_module*> get_module_if_interesting(module_manager& manager, const string_set& modules, uint64_t address);

```

`src/analyzer/disassembler.cpp`:

```cpp
#include "std_include.hpp"
#include "disassembler.hpp"
#include "common/segment_utils.hpp"

#include <utils/finally.hpp>

namespace
{
    void cse(const cs_err error)
    {
        if (error != CS_ERR_OK)
        {
            throw std::runtime_error(cs_strerror(error));
        }
    }
}

disassembler::disassembler()
{
    auto deleter = utils::finally([&] { this->release(); });

    cse(cs_open(CS_ARCH_X86, CS_MODE_64, &this->handle_64_));
    cse(cs_option(this->handle_64_, CS_OPT_DETAIL, CS_OPT_ON));

    cse(cs_open(CS_ARCH_X86, CS_MODE_32, &this->handle_32_));
    cse(cs_option(this->handle_32_, CS_OPT_DETAIL, CS_OPT_ON));

    cse(cs_open(CS_ARCH_X86, CS_MODE_16, &this->handle_16_));
    cse(cs_option(this->handle_16_, CS_OPT_DETAIL, CS_OPT_ON));

    deleter.cancel();
}

disassembler::~disassembler()
{
    this->release();
}

disassembler::disassembler(disassembler&& obj) noexcept
{
    this->operator=(std::move(obj));
}

disassembler& disassembler::operator=(disassembler&& obj) noexcept
{
    if (this != &obj)
    {
        this->release();
        this->handle_64_ = obj.handle_64_;
        this->handle_32_ = obj.handle_32_;
        this->handle_16_ = obj.handle_16_;
        obj.handle_64_ = 0;
        obj.handle_32_ = 0;
        obj.handle_16_ = 0;
    }

    return *this;
}

void disassembler::release()
{
    if (this->handle_64_)
    {
        cs_close(&this->handle_64_);
        this->handle_64_ = 0;
    }

    if (this->handle_32_)
    {
        cs_close(&this->handle_32_);
        this->handle_32_ = 0;
    }

    if (this->handle_16_)
    {
        cs_close(&this->handle_16_);
        this->handle_16_ = 0;
    }
}

instructions disassembler::disassemble(emulator& cpu, const uint16_t cs_selector, const std::span<const uint8_t> data,
                                       const size_t count) const
{
    // Select the handle by decoding the code segment descriptor as documented in Intel 64 and IA-32 Architectures SDM Vol. 3.
    const csh handle_to_use = this->resolve_handle(cpu, cs_selector);

    cs_insn* insts{};
    const auto inst_count = cs_disasm(handle_to_use, data.data(), data.size(), count, 0, &insts);
    return instructions{std::span(insts, inst_count)};
}

std::optional<disassembler::segment_bitness> disassembler::get_segment_bitness(emulator& cpu, const uint16_t cs_selector)
{
    return segment_utils::get_segment_bitness(cpu, cs_selector);
}

csh disassembler::resolve_handle(emulator& cpu, const uint16_t cs_selector) const
{
    const auto mode = disassembler::get_segment_bitness(cpu, cs_selector);
    if (!mode)
    {
        return this->handle_64_;
    }

    switch (*mode)
    {
    case segment_bitness::bit16:
        return this->handle_16_;
    case segment_bitness::bit32:
        return this->handle_32_;
    case segment_bitness::bit64:
    default:
        return this->handle_64_;
    }
}

void instructions::release()
{
    if (!this->instructions_.empty())
    {
        cs_free(this->instructions_.data(), this->instructions_.size());
    }

    this->instructions_ = {};
}

```

`src/analyzer/disassembler.hpp`:

```hpp
#pragma once

#include <capstone/capstone.h>
#include <optional>
#include <span>

#include "common/segment_utils.hpp"

class emulator;

class instructions
{
  public:
    instructions() = default;
    ~instructions()
    {
        this->release();
    }

    instructions(instructions&& obj) noexcept
        : instructions()
    {
        this->operator=(std::move(obj));
    }

    instructions& operator=(instructions&& obj) noexcept
    {
        if (this != &obj)
        {
            this->release();
            this->instructions_ = obj.instructions_;
            obj.instructions_ = {};
        }

        return *this;
    }

    instructions(const instructions&) = delete;
    instructions& operator=(const instructions&) = delete;

    operator std::span<cs_insn>() const
    {
        return this->instructions_;
    }

    bool empty() const noexcept
    {
        return this->instructions_.empty();
    }

    size_t size() const noexcept
    {
        return this->instructions_.size();
    }

    const cs_insn* data() const noexcept
    {
        return this->instructions_.data();
    }

    const cs_insn& operator[](const size_t index) const
    {
        return this->instructions_[index];
    }

    auto begin() const
    {
        return this->instructions_.begin();
    }
    auto end() const
    {
        return this->instructions_.end();
    }

  private:
    friend class disassembler;
    std::span<cs_insn> instructions_{};

    explicit instructions(const std::span<cs_insn> insts)
        : instructions_(insts)
    {
    }

    void release();
};

class disassembler
{
  public:
    disassembler();
    ~disassembler();

    disassembler(disassembler&& obj) noexcept;
    disassembler& operator=(disassembler&& obj) noexcept;

    disassembler(const disassembler& obj) = delete;
    disassembler& operator=(const disassembler& obj) = delete;

    using segment_bitness = segment_utils::segment_bitness;

    instructions disassemble(emulator& cpu, uint16_t cs_selector, std::span<const uint8_t> data, size_t count) const;
    static std::optional<segment_bitness> get_segment_bitness(emulator& cpu, uint16_t cs_selector);
    csh resolve_handle(emulator& cpu, uint16_t cs_selector) const;

    csh get_handle_64() const
    {
        return this->handle_64_;
    }

    csh get_handle_32() const
    {
        return this->handle_32_;
    }

    csh get_handle_16() const
    {
        return this->handle_16_;
    }

  private:
    csh handle_64_{};
    csh handle_32_{};
    csh handle_16_{};

    void release();
};

```

`src/analyzer/main.cpp`:

```cpp
#include "std_include.hpp"

#include <windows_emulator.hpp>
#include <backend_selection.hpp>
#include <win_x64_gdb_stub_handler.hpp>
#include <minidump_loader.hpp>
#include <scoped_hook.hpp>

#include "object_watching.hpp"
#include "snapshot.hpp"
#include "analysis.hpp"
#include "tenet_tracer.hpp"

#include <utils/finally.hpp>
#include <utils/interupt_handler.hpp>

#if defined(OS_EMSCRIPTEN) && !defined(MOMO_EMSCRIPTEN_SUPPORT_NODEJS)
#include <event_handler.hpp>
#endif

namespace
{
    struct analysis_options : analysis_settings
    {
        mutable bool use_gdb{false};
        bool log_executable_access{false};
        bool log_foreign_module_access{false};
        bool tenet_trace{false};
        std::filesystem::path dump{};
        std::filesystem::path minidump_path{};
        std::string registry_path{"./registry"};
        std::string emulation_root{};
        std::unordered_map<windows_path, std::filesystem::path> path_mappings{};
    };

    void split_and_insert(std::set<std::string, std::less<>>& container, const std::string_view str, const char splitter = ',')
    {
        size_t current_start = 0;
        for (size_t i = 0; i < str.size(); ++i)
        {
            const auto value = str[i];
            if (value != splitter)
            {
                continue;
            }

            if (current_start < i)
            {
                container.emplace(str.substr(current_start, i - current_start));
            }

            current_start = i + 1;
        }

        if (current_start < str.size())
        {
            container.emplace(str.substr(current_start));
        }
    }

#if !defined(__GNUC__) || defined(__clang__)
    struct analysis_state
    {
        windows_emulator& win_emu_;
        scoped_hook env_data_hook_;
        scoped_hook env_ptr_hook_;
        scoped_hook params_hook_;
        scoped_hook ldr_hook_;
        std::map<std::string, uint64_t> env_module_cache_{};
        std::shared_ptr<object_watching_state> params_state_ = std::make_shared<object_watching_state>();
        std::shared_ptr<object_watching_state> ldr_state_ = std::make_shared<object_watching_state>();
        std::set<std::string, std::less<>> modules_;
        bool verbose_;
        bool concise_;

        analysis_state(windows_emulator& win_emu, std::set<std::string, std::less<>> modules, const bool verbose, const bool concise)
            : win_emu_(win_emu),
              env_data_hook_(win_emu.emu()),
              env_ptr_hook_(win_emu.emu()),
              params_hook_(win_emu.emu()),
              ldr_hook_(win_emu.emu()),
              modules_(std::move(modules)),
              verbose_(verbose),
              concise_(concise)
        {
        }
    };

    emulator_object<RTL_USER_PROCESS_PARAMETERS64> get_process_params(windows_emulator& win_emu)
    {
        const auto peb = win_emu.process.peb64.read();
        return {win_emu.emu(), peb.ProcessParameters};
    }

    uint64_t get_environment_ptr(windows_emulator& win_emu)
    {
        const auto process_params = get_process_params(win_emu);
        return process_params.read().Environment;
    }

    size_t get_environment_size(const x86_64_emulator& emu, const uint64_t env)
    {
        std::array<uint8_t, 4> data{};
        std::array<uint8_t, 4> empty{};

        for (size_t i = 0; i < 0x100000; ++i)
        {
            if (!emu.try_read_memory(env + i, data.data(), data.size()))
            {
                return i;
            }

            if (data == empty)
            {
                return i + data.size();
            }
        }

        return 0;
    }

    emulator_hook* install_env_hook(const std::shared_ptr<analysis_state>& state)
    {
        const auto process_params = get_process_params(state->win_emu_);

        auto install_env_access_hook = [state] {
            const auto env_ptr = get_environment_ptr(state->win_emu_);
            const auto env_size = get_environment_size(state->win_emu_.emu(), env_ptr);
            if (!env_size)
            {
                state->env_data_hook_.remove();
                return;
            }

            auto hook_handler = [state, env_ptr](const uint64_t address, const void*, const size_t size) {
                const auto rip = state->win_emu_.emu().read_instruction_pointer();
                const auto* mod = state->win_emu_.mod_manager.find_by_address(rip);
                const auto is_main_access = !mod || (mod == state->win_emu_.mod_manager.executable || state->modules_.contains(mod->name));

                if (!is_main_access && !state->verbose_)
                {
                    return;
                }

                if (state->concise_)
                {
                    const auto count = ++state->env_module_cache_[mod->name];
                    if (count > 100 && count % 1000 != 0)
                    {
                        return;
                    }
                }

                const auto offset = address - env_ptr;
                const auto* mod_name = mod ? mod->name.c_str() : "<N/A>";
                state->win_emu_.log.print(is_main_access ? color::green : color::dark_gray,
                                          "Environment access: 0x%" PRIx64 " (0x%zX) at 0x%" PRIx64 " (%s)\n", offset, size, rip, mod_name);
            };

            state->env_data_hook_ = state->win_emu_.emu().hook_memory_read(env_ptr, env_size, std::move(hook_handler));
        };

        install_env_access_hook();

        auto& win_emu = state->win_emu_;
        return state->win_emu_.emu().hook_memory_write(
            process_params.value() + offsetof(RTL_USER_PROCESS_PARAMETERS64, Environment), 0x8,
            [&win_emu, install = std::move(install_env_access_hook)](const uint64_t address, const void*, size_t) {
                const auto new_process_params = get_process_params(win_emu);

                const auto target_address = new_process_params.value() + offsetof(RTL_USER_PROCESS_PARAMETERS64, Environment);

                if (address == target_address)
                {
                    install();
                }
            });
    }
#endif

    void watch_system_objects(windows_emulator& win_emu, const std::set<std::string, std::less<>>& modules, const bool verbose,
                              const bool concise)
    {
        win_emu.setup_process_if_necessary();

        (void)win_emu;
        (void)modules;
        (void)verbose;
        (void)concise;

#if !defined(__GNUC__) || defined(__clang__)
        watch_object(win_emu, modules, *win_emu.current_thread().teb64, verbose);
        watch_object(win_emu, modules, win_emu.process.peb64, verbose);
        watch_object<KUSER_SHARED_DATA64>(win_emu, modules, kusd_mmio::address(), verbose);

        auto state = std::make_shared<analysis_state>(win_emu, modules, verbose, concise);

        state->params_hook_ = watch_object(win_emu, modules, win_emu.process.process_params64, verbose, state->params_state_);
        state->ldr_hook_ = watch_object<PEB_LDR_DATA64>(win_emu, modules, win_emu.process.peb64.read().Ldr, verbose, state->ldr_state_);

        const auto update_env_hook = [state] {
            state->env_ptr_hook_ = install_env_hook(state); //
        };

        update_env_hook();

        win_emu.emu().hook_memory_write(win_emu.process.peb64.value() + offsetof(PEB64, ProcessParameters), 0x8,
                                        [state, update_env = std::move(update_env_hook)](const uint64_t, const void*, size_t) {
                                            const auto new_ptr = state->win_emu_.process.peb64.read().ProcessParameters;
                                            state->params_hook_ = watch_object<RTL_USER_PROCESS_PARAMETERS64>(
                                                state->win_emu_, state->modules_, new_ptr, state->verbose_, state->params_state_);
                                            update_env();
                                        });

        win_emu.emu().hook_memory_write(
            win_emu.process.peb64.value() + offsetof(PEB64, Ldr), 0x8, [state](const uint64_t, const void*, size_t) {
                const auto new_ptr = state->win_emu_.process.peb64.read().Ldr;
                state->ldr_hook_ =
                    watch_object<PEB_LDR_DATA64>(state->win_emu_, state->modules_, new_ptr, state->verbose_, state->ldr_state_);
            });
#endif
    }

    bool read_yes_no_answer()
    {
        while (true)
        {
            const auto chr = static_cast<char>(getchar());
            if (chr == 'y')
            {
                return true;
            }

            if (chr == 'n')
            {
                return false;
            }
        }
    }

    void print_instruction_summary(const analysis_context& c)
    {
        std::map<uint64_t, std::vector<uint32_t>> instruction_counts{};

        for (const auto& [instruction, count] : c.instructions)
        {
            instruction_counts[count].push_back(instruction);
        }

        c.win_emu->log.print(color::white, "Instruction summary:\n");

        for (const auto& [count, instructions] : instruction_counts)
        {
            for (const auto& instruction : instructions)
            {
                const auto& e = c.win_emu;
                auto& emu = e->emu();
                const auto reg_cs = emu.reg<uint16_t>(x86_register::cs);
                const auto handle = c.d.resolve_handle(emu, reg_cs);
                const auto* mnemonic = cs_insn_name(handle, instruction);
                c.win_emu->log.print(color::white, "%s: %" PRIu64 "\n", mnemonic, count);
            }
        }
    }

    void do_post_emulation_work(const analysis_context& c)
    {
        if (c.settings->instruction_summary)
        {
            print_instruction_summary(c);
        }

        if (c.settings->buffer_stdout)
        {
            c.win_emu->log.info("%.*s%s", static_cast<int>(c.output.size()), c.output.data(), c.output.ends_with("\n") ? "" : "\n");
        }
    }

    bool run_emulation(const analysis_context& c, const analysis_options& options)
    {
        auto& win_emu = *c.win_emu;

        std::atomic_uint32_t signals_received{0};
        utils::interupt_handler _{[&] {
            const auto value = signals_received++;
            if (value == 1)
            {
                win_emu.log.log("Exit already requested. Press CTRL+C again to force kill!\n");
            }
            else if (value >= 2)
            {
                _Exit(1);
            }

            win_emu.stop();
        }};

        std::optional<NTSTATUS> exit_status{};
#if defined(OS_EMSCRIPTEN) && !defined(MOMO_EMSCRIPTEN_SUPPORT_NODEJS)
        const auto _1 = utils::finally([&] {
            debugger::handle_exit(win_emu, exit_status); //
        });
#endif

        try
        {
            if (options.use_gdb)
            {
                const auto* address = "127.0.0.1:28960";
                win_emu.log.force_print(color::pink, "Waiting for GDB connection on %s...\n", address);

                const auto should_stop = [&] { return signals_received > 0; };

                win_x64_gdb_stub_handler handler{win_emu, should_stop};
                gdb_stub::run_gdb_stub(network::address{address, AF_INET}, handler);
            }
            else if (!options.minidump_path.empty())
            {
                // For minidumps, don't start execution automatically; just report ready state
                win_emu.log.print(color::green, "Minidump loaded successfully. Process state ready for analysis.\n");
                return true; // Return success without starting emulation
            }
            else
            {
                win_emu.start();
            }

            if (signals_received > 0)
            {
                options.use_gdb = false;

                win_emu.log.log("Do you want to create a snapshot? (y/n)\n");
                const auto write_snapshot = read_yes_no_answer();

                if (write_snapshot)
                {
                    snapshot::write_emulator_snapshot(win_emu);
                }
            }
        }
        catch (const std::exception& e)
        {
            do_post_emulation_work(c);
            win_emu.log.error("Emulation failed at: 0x%" PRIx64 " - %s\n", win_emu.emu().read_instruction_pointer(), e.what());
            throw;
        }
        catch (...)
        {
            do_post_emulation_work(c);
            win_emu.log.error("Emulation failed at: 0x%" PRIx64 "\n", win_emu.emu().read_instruction_pointer());
            throw;
        }

        exit_status = win_emu.process.exit_status;
        if (!exit_status.has_value())
        {
            do_post_emulation_work(c);
            win_emu.log.error("Emulation terminated without status!\n");
            return false;
        }

        const auto success = *exit_status == STATUS_SUCCESS;

        if (!options.silent)
        {
            do_post_emulation_work(c);
            win_emu.log.disable_output(false);
            win_emu.log.print(success ? color::green : color::red, "Emulation terminated with status: %X\n", *exit_status);
        }

        return success;
    }

    std::vector<std::u16string> parse_arguments(const std::span<const std::string_view> args)
    {
        std::vector<std::u16string> wide_args{};
        wide_args.reserve(args.size() - 1);

        for (size_t i = 1; i < args.size(); ++i)
        {
            const auto& arg = args[i];
            wide_args.emplace_back(arg.begin(), arg.end());
        }

        return wide_args;
    }

    emulator_settings create_emulator_settings(const analysis_options& options)
    {
        return {
            .emulation_root = options.emulation_root,
            .registry_directory = options.registry_path,
            .path_mappings = options.path_mappings,
        };
    }

    std::unique_ptr<windows_emulator> create_empty_emulator(const analysis_options& options)
    {
        const auto settings = create_emulator_settings(options);
        return std::make_unique<windows_emulator>(create_x86_64_emulator(), settings);
    }

    std::unique_ptr<windows_emulator> create_application_emulator(const analysis_options& options,
                                                                  const std::span<const std::string_view> args)
    {
        if (args.empty())
        {
            throw std::runtime_error("No args provided");
        }

        application_settings app_settings{
            .application = args[0],
            .arguments = parse_arguments(args),
        };

        const auto settings = create_emulator_settings(options);
        return std::make_unique<windows_emulator>(create_x86_64_emulator(), std::move(app_settings), settings);
    }

    std::unique_ptr<windows_emulator> setup_emulator(const analysis_options& options, const std::span<const std::string_view> args)
    {
        if (!options.dump.empty())
        {
            // load snapshot
            auto win_emu = create_empty_emulator(options);
            snapshot::load_emulator_snapshot(*win_emu, options.dump);
            return win_emu;
        }
        if (!options.minidump_path.empty())
        {
            // load minidump
            auto win_emu = create_empty_emulator(options);
            minidump_loader::load_minidump_into_emulator(*win_emu, options.minidump_path);
            return win_emu;
        }

        // default: load application
        return create_application_emulator(options, args);
    }

    const char* get_module_memory_region_name(const mapped_module& mod, const uint64_t address)
    {
        if (!mod.contains(address))
        {
            return "outside???";
        }

        uint64_t first_section = mod.image_base + mod.size_of_image;

        for (const auto& section : mod.sections)
        {
            first_section = std::min(first_section, section.region.start);

            if (is_within_start_and_length(address, section.region.start, section.region.length))
            {
                return section.name.c_str();
            }
        }

        if (address < first_section)
        {
            return "header";
        }

        return "?";
    }

    bool run(const analysis_options& options, const std::span<const std::string_view> args)
    {
        analysis_context context{
            .settings = &options,
        };

        const auto concise_logging = options.concise_logging;

        const auto win_emu = setup_emulator(options, args);
        context.win_emu = win_emu.get();

        win_emu->log.disable_output(concise_logging || options.silent);

        if (!options.silent)
        {
            win_emu->log.force_print(color::gray, "Using emulator backend: %s\n", win_emu->emu().get_name().c_str());
        }

        std::optional<tenet_tracer> tenet_tracer{};
        if (options.tenet_trace)
        {
            win_emu->log.log("Tenet Tracer enabled. Output: tenet_trace.log\n");
            tenet_tracer.emplace(*win_emu, "tenet_trace.log");
        }

        register_analysis_callbacks(context);
        watch_system_objects(*win_emu, options.modules, options.verbose_logging, options.concise_logging);

        const auto& exe = *win_emu->mod_manager.executable;

        win_emu->emu().hook_instruction(x86_hookable_instructions::cpuid, [&] {
            auto& emu = win_emu->emu();

            const auto rip = emu.read_instruction_pointer();
            const auto leaf = emu.reg<uint32_t>(x86_register::eax);
            const auto mod = get_module_if_interesting(win_emu->mod_manager, options.modules, rip);

            if (mod.has_value() && (!concise_logging || context.cpuid_cache.insert({rip, leaf}).second))
            {
                win_emu->log.print(color::blue, "Executing CPUID instruction with leaf 0x%X at 0x%" PRIx64 " (%s)\n", leaf, rip,
                                   (*mod) ? (*mod)->name.c_str() : "<N/A>");
            }

            if (leaf == 1)
            {
                // NOTE: We hard-code these values to disable SSE4.x and AVX
                //       See: https://github.com/momo5502/sogen/issues/560
                emu.reg<uint32_t>(x86_register::eax, 0x000906EA);
                emu.reg<uint32_t>(x86_register::ebx, 0x00100800);
                emu.reg<uint32_t>(x86_register::ecx, 0xEFE2F38F);
                emu.reg<uint32_t>(x86_register::edx, 0xBFEBFBFF);

                return instruction_hook_continuation::skip_instruction;
            }

            return instruction_hook_continuation::run_instruction;
        });

        if (options.log_foreign_module_access)
        {
            auto module_cache = std::make_shared<std::map<std::string, uint64_t>>();
            win_emu->emu().hook_memory_read(
                0, std::numeric_limits<uint64_t>::max(), [&, module_cache](const uint64_t address, const void*, size_t size) {
                    const auto rip = win_emu->emu().read_instruction_pointer();
                    const auto accessor = get_module_if_interesting(win_emu->mod_manager, options.modules, rip);

                    if (!accessor.has_value())
                    {
                        return;
                    }

                    const auto* mod = win_emu->mod_manager.find_by_address(address);
                    if (!mod || mod == *accessor)
                    {
                        return;
                    }

                    if (concise_logging)
                    {
                        const auto count = ++(*module_cache)[mod->name];
                        if (count > 100 && count % 100000 != 0)
                        {
                            return;
                        }
                    }

                    const auto* region_name = get_module_memory_region_name(*mod, address);

                    win_emu->log.print(color::pink, "Reading %zd bytes from module %s at 0x%" PRIx64 " (%s) via 0x%" PRIx64 " (%s)\n", size,
                                       mod->name.c_str(), address, region_name, rip, (*accessor) ? (*accessor)->name.c_str() : "<N/A>");
                });
        }

        if (options.log_executable_access)
        {
            for (const auto& section : exe.sections)
            {
                if ((section.region.permissions & memory_permission::exec) != memory_permission::exec)
                {
                    continue;
                }

                const auto read_count = std::make_shared<uint64_t>(0);
                const auto write_count = std::make_shared<uint64_t>(0);

                auto read_handler = [&, section, concise_logging, read_count](const uint64_t address, const void*, size_t) {
                    const auto rip = win_emu->emu().read_instruction_pointer();
                    if (!win_emu->mod_manager.executable->contains(rip))
                    {
                        return;
                    }

                    if (concise_logging)
                    {
                        const auto count = ++*read_count;
                        if (count > 20 && count % 100000 != 0)
                        {
                            return;
                        }
                    }

                    win_emu->log.print(color::green, "Reading from executable section %s at 0x%" PRIx64 " via 0x%" PRIx64 "\n",
                                       section.name.c_str(), address, rip);
                };

                const auto write_handler = [&, section, concise_logging, write_count](const uint64_t address, const void*, size_t size) {
                    const auto rip = win_emu->emu().read_instruction_pointer();
                    if (!win_emu->mod_manager.executable->contains(rip))
                    {
                        return;
                    }

                    if (concise_logging)
                    {
                        const auto count = ++*write_count;
                        if (count > 100 && count % 100000 != 0)
                        {
                            return;
                        }
                    }

                    win_emu->log.print(color::blue, "Writing %zd bytes to executable section %s at 0x%" PRIx64 " via 0x%" PRIx64 "\n", size,
                                       section.name.c_str(), address, rip);
                };

                win_emu->emu().hook_memory_read(section.region.start, section.region.length, std::move(read_handler));
                win_emu->emu().hook_memory_write(section.region.start, section.region.length, std::move(write_handler));
            }
        }

        return run_emulation(context, options);
    }

    std::vector<std::string_view> bundle_arguments(const int argc, char** argv)
    {
        std::vector<std::string_view> args{};

        for (int i = 1; i < argc; ++i)
        {
            args.emplace_back(argv[i]);
        }

        return args;
    }

    void print_help()
    {
        printf("Usage: analyzer [options] [application] [args...]\n\n");
        printf("Options:\n");
        printf("  -h, --help                Show this help message\n");
        printf("  -d, --debug               Enable GDB debugging mode\n");
        printf("  -s, --silent              Silent mode\n");
        printf("  -v, --verbose             Verbose logging\n");
        printf("  -b, --buffer              Buffer stdout\n");
        printf("  -f, --foreign             Log read access to foreign modules\n");
        printf("  -c, --concise             Concise logging\n");
        printf("  -x, --exec                Log r/w access to executable memory\n");
        printf("  -m, --module <module>     Specify module to track\n");
        printf("  -e, --emulation <path>    Set emulation root path\n");
        printf("  -a, --snapshot <path>     Load snapshot dump from path\n");
        printf("  --minidump <path>         Load minidump from path\n");
        printf("  -t, --tenet-trace         Enable Tenet tracer\n");
        printf("  -i, --ignore <funcs>      Comma-separated list of functions to ignore\n");
        printf("  -p, --path <src> <dst>    Map Windows path to host path\n");
        printf("  -r, --registry <path>     Set registry path (default: ./registry)\n\n");
        printf("  -is, --inst-summary       Print a summary of executed instructions of the analyzed modules\n");
        printf("  -ss, --skip-syscalls      Skip the logging of regular syscalls\n");
        printf("Examples:\n");
        printf("  analyzer -v -e path/to/root myapp.exe\n");
        printf("  analyzer -e path/to/root -p c:/analysis-sample.exe /path/to/sample.exe c:/analysis-sample.exe\n");
    }

    analysis_options parse_options(std::vector<std::string_view>& args)
    {
        analysis_options options{};

        while (!args.empty())
        {
            auto arg_it = args.begin();
            const auto& arg = *arg_it;

            if (arg == "-h" || arg == "--help")
            {
                print_help();
                std::exit(0);
            }

            if (arg == "-d" || arg == "--debug")
            {
                options.use_gdb = true;
            }
            else if (arg == "-s" || arg == "--silent")
            {
                options.silent = true;
            }
            else if (arg == "-v" || arg == "--verbose")
            {
                options.verbose_logging = true;
            }
            else if (arg == "-b" || arg == "--buffer")
            {
                options.buffer_stdout = true;
            }
            else if (arg == "-x" || arg == "--exec")
            {
                options.log_executable_access = true;
            }
            else if (arg == "-f" || arg == "--foreign")
            {
                options.log_foreign_module_access = true;
            }
            else if (arg == "-c" || arg == "--concise")
            {
                options.concise_logging = true;
            }
            else if (arg == "-t" || arg == "--tenet-trace")
            {
                options.tenet_trace = true;
            }
            else if (arg == "-is" || arg == "--inst-summary")
            {
                options.instruction_summary = true;
            }
            else if (arg == "-ss" || arg == "--skip-syscalls")
            {
                options.skip_syscalls = true;
            }
            else if (arg == "-m" || arg == "--module")
            {
                if (args.size() < 2)
                {
                    throw std::runtime_error("No module provided after -m/--module");
                }

                arg_it = args.erase(arg_it);
                options.modules.insert(std::string(args[0]));
            }
            else if (arg == "-e" || arg == "--emulation")
            {
                if (args.size() < 2)
                {
                    throw std::runtime_error("No emulation root path provided after -e/--emulation");
                }
                arg_it = args.erase(arg_it);
                options.emulation_root = args[0];
            }
            else if (arg == "-a" || arg == "--snapshot")
            {
                if (args.size() < 2)
                {
                    throw std::runtime_error("No dump path provided after -a/--snapshot");
                }
                arg_it = args.erase(arg_it);
                options.dump = args[0];
            }
            else if (arg == "--minidump")
            {
                if (args.size() < 2)
                {
                    throw std::runtime_error("No minidump path provided after --minidump");
                }
                arg_it = args.erase(arg_it);
                options.minidump_path = args[0];
            }
            else if (arg == "-i" || arg == "--ignore")
            {
                if (args.size() < 2)
                {
                    throw std::runtime_error("No ignored function(s) provided after -i/--ignore");
                }
                arg_it = args.erase(arg_it);
                split_and_insert(options.ignored_functions, args[0]);
            }
            else if (arg == "-p" || arg == "--path")
            {
                if (args.size() < 3)
                {
                    throw std::runtime_error("No path mapping provided after -p/--path");
                }
                arg_it = args.erase(arg_it);
                windows_path source = args[0];
                arg_it = args.erase(arg_it);
                std::filesystem::path target = std::filesystem::absolute(args[0]);

                options.path_mappings[std::move(source)] = std::move(target);
            }
            else if (arg == "-r" || arg == "--registry")
            {
                if (args.size() < 2)
                {
                    throw std::runtime_error("No registry path provided after -r/--registry");
                }
                arg_it = args.erase(arg_it);
                options.registry_path = args[0];
            }
            else
            {
                break;
            }

            args.erase(arg_it);
        }

        return options;
    }

    int run_main(const int argc, char** argv)
    {
        try
        {
            auto args = bundle_arguments(argc, argv);
            if (args.empty())
            {
                print_help();
                return 1;
            }

            const auto options = parse_options(args);

            bool result{};

            do
            {
                result = run(options, args);
            } while (options.use_gdb);

            return result ? 0 : 1;
        }
        catch (std::exception& e)
        {
            puts(e.what());
        }
        catch (...)
        {
            puts("An unknown exception occured");
        }

        return 1;
    }
}

int main(const int argc, char** argv)
{
    return run_main(argc, argv);
}

#ifdef _WIN32
int WINAPI WinMain(HINSTANCE, HINSTANCE, PSTR, int)
{
    return run_main(__argc, __argv);
}
#endif

```

`src/analyzer/object_watching.hpp`:

```hpp
#pragma once

#include "reflect_type_info.hpp"
#include <set>
#include <memory>
#include <cinttypes>

struct object_watching_state
{
    std::unordered_set<uint64_t> logged_addresses{};
};

template <typename T>
emulator_hook* watch_object(windows_emulator& emu, const std::set<std::string, std::less<>>& modules, emulator_object<T> object,
                            const auto verbose,
                            std::shared_ptr<object_watching_state> shared_state = std::make_unique<object_watching_state>())
{
    const reflect_type_info<T> info{};

    return emu.emu().hook_memory_read(
        object.value(), static_cast<size_t>(object.size()),
        [i = std::move(info), object, &emu, verbose, modules, state = std::move(shared_state)](const uint64_t address, const void*,
                                                                                               const size_t size) {
            const auto rip = emu.emu().read_instruction_pointer();
            const auto* mod = emu.mod_manager.find_by_address(rip);
            const auto is_main_access = !mod || (mod == emu.mod_manager.executable || modules.contains(mod->name));

            if (!verbose && !is_main_access)
            {
                return;
            }

            if (!verbose)
            {
                bool is_new = false;
                for (size_t j = 0; j < size; ++j)
                {
                    is_new |= state->logged_addresses.insert(address + j).second;
                }

                if (!is_new)
                {
                    return;
                }
            }

            const auto start_offset = address - object.value();
            const auto end_offset = start_offset + size;
            const auto* mod_name = mod ? mod->name.c_str() : "<N/A>";
            const auto& type_name = i.get_type_name();

            for (auto offset = start_offset; offset < end_offset;)
            {
                const auto member_info = i.get_member_info(static_cast<size_t>(offset));
                if (!member_info.has_value())
                {
                    const auto remaining_size = end_offset - offset;
                    emu.log.print(is_main_access ? color::green : color::dark_gray,
                                  "Object access: %s - 0x%" PRIx64 " 0x%" PRIx64 " (<N/A>) at 0x%" PRIx64 " (%s)\n", type_name.c_str(),
                                  offset, remaining_size, rip, mod_name);
                    break;
                }

                const auto remaining_size = end_offset - offset;
                const auto member_end = member_info->offset + member_info->size;
                const auto member_access_size = member_end - offset;
                const auto access_size = std::min(remaining_size, member_access_size);

                emu.log.print(is_main_access ? color::green : color::dark_gray,
                              "Object access: %s - 0x%" PRIx64 " 0x%" PRIx64 " (%s) at 0x%" PRIx64 " (%s)\n", type_name.c_str(), offset,
                              access_size, member_info->get_diff_name(static_cast<size_t>(offset)).c_str(), rip, mod_name);

                offset = member_end;
            }
        });
}

template <typename T>
emulator_hook* watch_object(windows_emulator& emu, const std::set<std::string, std::less<>>& modules, const uint64_t address,
                            const auto verbose, std::shared_ptr<object_watching_state> state = std::make_unique<object_watching_state>())
{
    return watch_object<T>(emu, modules, emulator_object<T>{emu.emu(), address}, verbose, std::move(state));
}

```

`src/analyzer/reflect_extension.hpp`:

```hpp
#pragma once

namespace
{
    template <bool Cond>
    struct REFLECT_FWD_LIKE2
    {
        template <class T>
        using type = std::remove_reference_t<T>&&;
    };
    template <>
    struct REFLECT_FWD_LIKE2<true>
    {
        template <class T>
        using type = std::remove_reference_t<T>&;
    };
} // to speed up compilation times

#define REFLECT_FWD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
#define REFLECT_FWD_LIKE(T, ...) \
    static_cast<typename ::REFLECT_FWD_LIKE2<::std::is_lvalue_reference_v<T>>::template type<decltype(__VA_ARGS__)>>(__VA_ARGS__)

namespace reflect::inline v1_2_5
{
    namespace detail
    {
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 65>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 66>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 67>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 68>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 69>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 70>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 71>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 72>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 73>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 74>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73,
                    _74] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 75>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 76>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 77>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 78>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 79>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 80>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 81>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 82>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 83>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 84>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 85>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 86>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 87>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 88>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 89>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 90>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 91>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 92>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 93>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 94>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 95>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 96>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 97>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 98>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97,
                    _98] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 99>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 100>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 101>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 102>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 103>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 104>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 105>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 106>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 107>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 108>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 109>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 110>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                                   REFLECT_FWD_LIKE(T, _110));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 111>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                                   REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 112>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                                   REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 113>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 114>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                                   REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112),
                                   REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 115>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                                   REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112),
                                   REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 116>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 117>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 118>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118] =
                REFLECT_FWD(t);
            return REFLECT_FWD(fn)(REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4),
                                   REFLECT_FWD_LIKE(T, _5), REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8),
                                   REFLECT_FWD_LIKE(T, _9), REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12),
                                   REFLECT_FWD_LIKE(T, _13), REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16),
                                   REFLECT_FWD_LIKE(T, _17), REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20),
                                   REFLECT_FWD_LIKE(T, _21), REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24),
                                   REFLECT_FWD_LIKE(T, _25), REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28),
                                   REFLECT_FWD_LIKE(T, _29), REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32),
                                   REFLECT_FWD_LIKE(T, _33), REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36),
                                   REFLECT_FWD_LIKE(T, _37), REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40),
                                   REFLECT_FWD_LIKE(T, _41), REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44),
                                   REFLECT_FWD_LIKE(T, _45), REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48),
                                   REFLECT_FWD_LIKE(T, _49), REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52),
                                   REFLECT_FWD_LIKE(T, _53), REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56),
                                   REFLECT_FWD_LIKE(T, _57), REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60),
                                   REFLECT_FWD_LIKE(T, _61), REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64),
                                   REFLECT_FWD_LIKE(T, _65), REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68),
                                   REFLECT_FWD_LIKE(T, _69), REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72),
                                   REFLECT_FWD_LIKE(T, _73), REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76),
                                   REFLECT_FWD_LIKE(T, _77), REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80),
                                   REFLECT_FWD_LIKE(T, _81), REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84),
                                   REFLECT_FWD_LIKE(T, _85), REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88),
                                   REFLECT_FWD_LIKE(T, _89), REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92),
                                   REFLECT_FWD_LIKE(T, _93), REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96),
                                   REFLECT_FWD_LIKE(T, _97), REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100),
                                   REFLECT_FWD_LIKE(T, _101), REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103),
                                   REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105), REFLECT_FWD_LIKE(T, _106),
                                   REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                                   REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112),
                                   REFLECT_FWD_LIKE(T, _113), REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115),
                                   REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117), REFLECT_FWD_LIKE(T, _118));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 119>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 120>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 121>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 122>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 123>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122, _123] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 124>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122, _123, _124] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 125>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122, _123, _124, _125] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 126>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122, _123, _124, _125, _126] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125),
                REFLECT_FWD_LIKE(T, _126));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 127>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122, _123, _124, _125, _126, _127] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125),
                REFLECT_FWD_LIKE(T, _126), REFLECT_FWD_LIKE(T, _127));
        }
        template <class Fn, class T>
        [[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, std::integral_constant<std::size_t, 128>) noexcept
        {
            auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,
                    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,
                    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74,
                    _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98,
                    _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118,
                    _119, _120, _121, _122, _123, _124, _125, _126, _127, _128] = REFLECT_FWD(t);
            return REFLECT_FWD(fn)(
                REFLECT_FWD_LIKE(T, _1), REFLECT_FWD_LIKE(T, _2), REFLECT_FWD_LIKE(T, _3), REFLECT_FWD_LIKE(T, _4), REFLECT_FWD_LIKE(T, _5),
                REFLECT_FWD_LIKE(T, _6), REFLECT_FWD_LIKE(T, _7), REFLECT_FWD_LIKE(T, _8), REFLECT_FWD_LIKE(T, _9),
                REFLECT_FWD_LIKE(T, _10), REFLECT_FWD_LIKE(T, _11), REFLECT_FWD_LIKE(T, _12), REFLECT_FWD_LIKE(T, _13),
                REFLECT_FWD_LIKE(T, _14), REFLECT_FWD_LIKE(T, _15), REFLECT_FWD_LIKE(T, _16), REFLECT_FWD_LIKE(T, _17),
                REFLECT_FWD_LIKE(T, _18), REFLECT_FWD_LIKE(T, _19), REFLECT_FWD_LIKE(T, _20), REFLECT_FWD_LIKE(T, _21),
                REFLECT_FWD_LIKE(T, _22), REFLECT_FWD_LIKE(T, _23), REFLECT_FWD_LIKE(T, _24), REFLECT_FWD_LIKE(T, _25),
                REFLECT_FWD_LIKE(T, _26), REFLECT_FWD_LIKE(T, _27), REFLECT_FWD_LIKE(T, _28), REFLECT_FWD_LIKE(T, _29),
                REFLECT_FWD_LIKE(T, _30), REFLECT_FWD_LIKE(T, _31), REFLECT_FWD_LIKE(T, _32), REFLECT_FWD_LIKE(T, _33),
                REFLECT_FWD_LIKE(T, _34), REFLECT_FWD_LIKE(T, _35), REFLECT_FWD_LIKE(T, _36), REFLECT_FWD_LIKE(T, _37),
                REFLECT_FWD_LIKE(T, _38), REFLECT_FWD_LIKE(T, _39), REFLECT_FWD_LIKE(T, _40), REFLECT_FWD_LIKE(T, _41),
                REFLECT_FWD_LIKE(T, _42), REFLECT_FWD_LIKE(T, _43), REFLECT_FWD_LIKE(T, _44), REFLECT_FWD_LIKE(T, _45),
                REFLECT_FWD_LIKE(T, _46), REFLECT_FWD_LIKE(T, _47), REFLECT_FWD_LIKE(T, _48), REFLECT_FWD_LIKE(T, _49),
                REFLECT_FWD_LIKE(T, _50), REFLECT_FWD_LIKE(T, _51), REFLECT_FWD_LIKE(T, _52), REFLECT_FWD_LIKE(T, _53),
                REFLECT_FWD_LIKE(T, _54), REFLECT_FWD_LIKE(T, _55), REFLECT_FWD_LIKE(T, _56), REFLECT_FWD_LIKE(T, _57),
                REFLECT_FWD_LIKE(T, _58), REFLECT_FWD_LIKE(T, _59), REFLECT_FWD_LIKE(T, _60), REFLECT_FWD_LIKE(T, _61),
                REFLECT_FWD_LIKE(T, _62), REFLECT_FWD_LIKE(T, _63), REFLECT_FWD_LIKE(T, _64), REFLECT_FWD_LIKE(T, _65),
                REFLECT_FWD_LIKE(T, _66), REFLECT_FWD_LIKE(T, _67), REFLECT_FWD_LIKE(T, _68), REFLECT_FWD_LIKE(T, _69),
                REFLECT_FWD_LIKE(T, _70), REFLECT_FWD_LIKE(T, _71), REFLECT_FWD_LIKE(T, _72), REFLECT_FWD_LIKE(T, _73),
                REFLECT_FWD_LIKE(T, _74), REFLECT_FWD_LIKE(T, _75), REFLECT_FWD_LIKE(T, _76), REFLECT_FWD_LIKE(T, _77),
                REFLECT_FWD_LIKE(T, _78), REFLECT_FWD_LIKE(T, _79), REFLECT_FWD_LIKE(T, _80), REFLECT_FWD_LIKE(T, _81),
                REFLECT_FWD_LIKE(T, _82), REFLECT_FWD_LIKE(T, _83), REFLECT_FWD_LIKE(T, _84), REFLECT_FWD_LIKE(T, _85),
                REFLECT_FWD_LIKE(T, _86), REFLECT_FWD_LIKE(T, _87), REFLECT_FWD_LIKE(T, _88), REFLECT_FWD_LIKE(T, _89),
                REFLECT_FWD_LIKE(T, _90), REFLECT_FWD_LIKE(T, _91), REFLECT_FWD_LIKE(T, _92), REFLECT_FWD_LIKE(T, _93),
                REFLECT_FWD_LIKE(T, _94), REFLECT_FWD_LIKE(T, _95), REFLECT_FWD_LIKE(T, _96), REFLECT_FWD_LIKE(T, _97),
                REFLECT_FWD_LIKE(T, _98), REFLECT_FWD_LIKE(T, _99), REFLECT_FWD_LIKE(T, _100), REFLECT_FWD_LIKE(T, _101),
                REFLECT_FWD_LIKE(T, _102), REFLECT_FWD_LIKE(T, _103), REFLECT_FWD_LIKE(T, _104), REFLECT_FWD_LIKE(T, _105),
                REFLECT_FWD_LIKE(T, _106), REFLECT_FWD_LIKE(T, _107), REFLECT_FWD_LIKE(T, _108), REFLECT_FWD_LIKE(T, _109),
                REFLECT_FWD_LIKE(T, _110), REFLECT_FWD_LIKE(T, _111), REFLECT_FWD_LIKE(T, _112), REFLECT_FWD_LIKE(T, _113),
                REFLECT_FWD_LIKE(T, _114), REFLECT_FWD_LIKE(T, _115), REFLECT_FWD_LIKE(T, _116), REFLECT_FWD_LIKE(T, _117),
                REFLECT_FWD_LIKE(T, _118), REFLECT_FWD_LIKE(T, _119), REFLECT_FWD_LIKE(T, _120), REFLECT_FWD_LIKE(T, _121),
                REFLECT_FWD_LIKE(T, _122), REFLECT_FWD_LIKE(T, _123), REFLECT_FWD_LIKE(T, _124), REFLECT_FWD_LIKE(T, _125),
                REFLECT_FWD_LIKE(T, _126), REFLECT_FWD_LIKE(T, _127), REFLECT_FWD_LIKE(T, _128));
        }
    }
}

#undef REFLECT_FWD_LIKE
#undef REFLECT_FWD

```

`src/analyzer/reflect_type_info.hpp`:

```hpp
#pragma once

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wtautological-compare"
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4189)
#pragma warning(disable : 4308)
#pragma warning(disable : 4715)
#endif

#include "reflect_extension.hpp"
#include <reflect>

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

template <typename T>
class reflect_type_info
{
  public:
    reflect_type_info()
    {
        this->type_name_ = reflect::type_name<T>();

        reflect::for_each<T>([this](auto I) {
            const auto member_name = reflect::member_name<I, T>();
            const auto member_offset = reflect::offset_of<I, T>();
            const auto member_size = reflect::size_of<I, T>();

            this->members_[member_offset] = std::make_pair(std::string(member_name), member_size);
        });
    }

    std::string get_member_name(const size_t offset) const
    {
        const auto info = this->get_member_info(offset);
        if (!info.has_value())
        {
            return "<N/A>";
        }

        return info->get_diff_name(offset);
    }

    struct member_info
    {
        std::string name{};
        size_t offset{};
        size_t size{};

        std::string get_diff_name(const size_t access) const
        {
            const auto diff = access - this->offset;
            if (diff == 0)
            {
                return this->name;
            }

            return this->name + "+" + std::to_string(diff);
        }
    };

    std::optional<member_info> get_member_info(const size_t offset) const
    {
        auto entry = this->members_.upper_bound(offset);
        if (entry == this->members_.begin())
        {
            return std::nullopt;
        }

        --entry;

        if (entry->first + entry->second.second <= offset)
        {
            return std::nullopt;
        }

        return member_info{
            .name = entry->second.first,
            .offset = entry->first,
            .size = entry->second.second,
        };
    }

    const std::string& get_type_name() const
    {
        return this->type_name_;
    }

  private:
    std::string type_name_{};
    std::map<size_t, std::pair<std::string, size_t>> members_{};
};

```

`src/analyzer/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "Windows Emulator"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "emulator"
            VALUE "LegalCopyright", "All rights reserved."
            VALUE "OriginalFilename", "emulator.exe"
            VALUE "ProductName", "emulator"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

GLFW_ICON       ICON   "resources/icon.ico"


#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/analyzer/snapshot.cpp`:

```cpp
#include "snapshot.hpp"

#include <utils/io.hpp>
#include <utils/compression.hpp>

namespace snapshot
{
    namespace
    {
        struct snapshot_header
        {
            // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
            char magic[4] = {'S', 'N', 'A', 'P'};
            uint32_t version{1};
        };

        static_assert(sizeof(snapshot_header) == 8);

        std::span<const std::byte> validate_header(const std::span<const std::byte> snapshot)
        {
            snapshot_header header{};
            constexpr snapshot_header default_header{};

            if (snapshot.size() < sizeof(header))
            {
                throw std::runtime_error("Snapshot is too small");
            }

            memcpy(&header, snapshot.data(), sizeof(header));

            if (memcmp(default_header.magic, header.magic, sizeof(header.magic)) != 0)
            {
                throw std::runtime_error("Invalid snapshot");
            }

            if (default_header.version != header.version)
            {
                throw std::runtime_error("Unsupported snapshot version: " + std::to_string(header.version) +
                                         "(needed: " + std::to_string(default_header.version) + ")");
            }

            return snapshot.subspan(sizeof(header));
        }

        std::vector<std::byte> get_compressed_emulator_state(const windows_emulator& win_emu)
        {
            utils::buffer_serializer serializer{};
            win_emu.serialize(serializer);

            return utils::compression::zstd::compress(serializer.get_buffer());
        }

        std::vector<std::byte> get_decompressed_emulator_state(const std::span<const std::byte> snapshot)
        {
            const auto data = validate_header(snapshot);
            return utils::compression::zstd::decompress(data);
        }

        std::string get_main_executable_name(const windows_emulator& win_emu)
        {
            const auto* exe = win_emu.mod_manager.executable;
            if (exe)
            {
                return std::filesystem::path(exe->name).stem().string();
            }

            return "process";
        }
    }

    std::vector<std::byte> create_emulator_snapshot(const windows_emulator& win_emu)
    {
        const auto state = get_compressed_emulator_state(win_emu);

        snapshot_header header{};
        std::span header_span(reinterpret_cast<const std::byte*>(&header), sizeof(header));

        std::vector<std::byte> snapshot{};
        snapshot.reserve(header_span.size() + state.size());
        snapshot.assign(header_span.begin(), header_span.end());
        snapshot.insert(snapshot.end(), state.begin(), state.end());

        return snapshot;
    }

    std::filesystem::path write_emulator_snapshot(const windows_emulator& win_emu, const bool log)
    {
        std::filesystem::path snapshot_file = get_main_executable_name(win_emu) + "-" + std::to_string(time(nullptr)) + ".snap";

        if (log)
        {
            win_emu.log.log("Writing snapshot to %s...\n", snapshot_file.string().c_str());
        }

        const auto snapshot = create_emulator_snapshot(win_emu);
        if (!utils::io::write_file(snapshot_file, snapshot))
        {
            throw std::runtime_error("Failed to write snapshot!");
        }

        return snapshot_file;
    }

    void load_emulator_snapshot(windows_emulator& win_emu, const std::span<const std::byte> snapshot)
    {
        const auto data = get_decompressed_emulator_state(snapshot);

        utils::buffer_deserializer deserializer{data};
        win_emu.deserialize(deserializer);
    }

    void load_emulator_snapshot(windows_emulator& win_emu, const std::filesystem::path& snapshot_file)
    {
        std::vector<std::byte> data{};
        if (!utils::io::read_file(snapshot_file, &data))
        {
            throw std::runtime_error("Failed to read snapshot file: " + snapshot_file.string());
        }

        load_emulator_snapshot(win_emu, data);
    }
}

```

`src/analyzer/snapshot.hpp`:

```hpp
#pragma once

#include <windows_emulator.hpp>

namespace snapshot
{
    std::vector<std::byte> create_emulator_snapshot(const windows_emulator& win_emu);
    std::filesystem::path write_emulator_snapshot(const windows_emulator& win_emu, bool log = true);

    void load_emulator_snapshot(windows_emulator& win_emu, std::span<const std::byte> snapshot);
    void load_emulator_snapshot(windows_emulator& win_emu, const std::filesystem::path& snapshot_file);
}

```

`src/analyzer/std_include.hpp`:

```hpp
#pragma once

#include <map>
#include <set>
#include <list>
#include <array>
#include <deque>
#include <queue>
#include <mutex>
#include <thread>
#include <ranges>
#include <atomic>
#include <vector>
#include <string>
#include <chrono>
#include <memory>
#include <fstream>
#include <sstream>
#include <functional>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <string_view>
#include <unordered_set>
#include <condition_variable>

#include <cstdio>
#include <cassert>

#include <platform/platform.hpp>

// NOLINTNEXTLINE(google-global-names-in-headers)
using namespace std::literals;

```

`src/analyzer/tenet_tracer.cpp`:

```cpp
#include "std_include.hpp"
#include "tenet_tracer.hpp"
#include <utils/finally.hpp>

#include <iomanip>

namespace
{
    std::string format_hex(uint64_t value)
    {
        std::stringstream ss;
        ss << "0x" << std::hex << value;
        return ss.str();
    }

    std::string format_byte_array(const uint8_t* data, size_t size)
    {
        std::stringstream ss;
        for (size_t i = 0; i < size; ++i)
        {
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(data[i]);
        }
        return ss.str();
    }

    void parse_and_accumulate_changes(const std::string& line, std::map<std::string, std::string>& changes)
    {
        size_t start = 0;
        while (start < line.length())
        {
            size_t end = line.find(',', start);
            if (end == std::string::npos)
            {
                end = line.length();
            }

            std::string pair_str = line.substr(start, end - start);
            size_t equals_pos = pair_str.find('=');
            if (equals_pos != std::string::npos)
            {
                std::string key = pair_str.substr(0, equals_pos);
                std::string value = pair_str.substr(equals_pos + 1);
                changes[key] = value;
            }

            start = end + 1;
        }
    }
}

tenet_tracer::tenet_tracer(windows_emulator& win_emu, const std::filesystem::path& log_filename)
    : win_emu_(win_emu),
      log_file_(log_filename)
{
    if (!log_file_)
    {
        throw std::runtime_error("TenetTracer: Failed to open log file -> " + log_filename.string());
    }

    auto& emu = win_emu_.emu();

    auto* read_hook = emu.hook_memory_read(0, 0xFFFFFFFFFFFFFFFF, [this](uint64_t a, const void* d, size_t s) {
        this->log_memory_read(a, d, s); //
    });
    read_hook_ = scoped_hook(emu, read_hook);

    auto* write_hook = emu.hook_memory_write(0, 0xFFFFFFFFFFFFFFFF, [this](uint64_t a, const void* d, size_t s) {
        this->log_memory_write(a, d, s); //
    });
    write_hook_ = scoped_hook(emu, write_hook);

    auto* execute_hook = emu.hook_memory_execution([&](uint64_t address) {
        this->process_instruction(address); //
    });
    execute_hook_ = scoped_hook(emu, execute_hook);
}

tenet_tracer::~tenet_tracer()
{
    filter_and_write_buffer();

    if (log_file_.is_open())
    {
        log_file_.close();
    }
}

void tenet_tracer::filter_and_write_buffer()
{
    if (raw_log_buffer_.empty())
    {
        return;
    }

    const auto* exe_module = win_emu_.mod_manager.executable;
    if (!exe_module)
    {
        for (const auto& line : raw_log_buffer_)
        {
            log_file_ << line << '\n';
        }

        return;
    }

    if (!raw_log_buffer_.empty())
    {
        log_file_ << raw_log_buffer_.front() << '\n';
    }

    bool currently_outside = false;
    std::map<std::string, std::string> accumulated_changes;

    for (size_t i = 1; i < raw_log_buffer_.size(); ++i)
    {
        const auto& line = raw_log_buffer_[i];

        size_t rip_pos = line.find("rip=0x");
        if (rip_pos == std::string::npos)
        {
            continue;
        }

        char* end_ptr = nullptr;
        uint64_t address = std::strtoull(line.c_str() + rip_pos + 6, &end_ptr, 16);

        bool is_line_inside = exe_module->contains(address);
        const auto _1 = utils::finally([&] {
            currently_outside = !is_line_inside; //
        });

        if (!is_line_inside)
        {
            parse_and_accumulate_changes(line, accumulated_changes);
            continue;
        }

        const auto _2 = utils::finally([&] {
            log_file_ << line << '\n'; //
        });

        if (!currently_outside || accumulated_changes.empty())
        {
            continue;
        }

        std::stringstream summary_line;
        bool first = true;

        auto rip_it = accumulated_changes.find("rip");
        std::string last_rip;
        if (rip_it != accumulated_changes.end())
        {
            last_rip = rip_it->second;
            accumulated_changes.erase(rip_it);
        }

        for (const auto& pair : accumulated_changes)
        {
            if (!first)
            {
                summary_line << ",";
            }
            summary_line << pair.first << "=" << pair.second;
            first = false;
        }

        if (!last_rip.empty())
        {
            if (!first)
            {
                summary_line << ",";
            }
            summary_line << "rip=" << last_rip;
        }

        log_file_ << summary_line.str() << '\n';
        accumulated_changes.clear();
    }

    raw_log_buffer_.clear();
}

void tenet_tracer::log_memory_read(uint64_t address, const void* data, size_t size)
{
    if (!mem_read_log_.str().empty())
    {
        mem_read_log_ << ";";
    }

    mem_read_log_ << format_hex(address) << ":" << format_byte_array(static_cast<const uint8_t*>(data), size);
}

void tenet_tracer::log_memory_write(uint64_t address, const void* data, size_t size)
{
    if (!mem_write_log_.str().empty())
    {
        mem_write_log_ << ";";
    }

    mem_write_log_ << format_hex(address) << ":" << format_byte_array(static_cast<const uint8_t*>(data), size);
}

void tenet_tracer::process_instruction(const uint64_t address)
{
    auto& emu = win_emu_.emu();
    std::stringstream trace_line;

    std::array<uint64_t, GPRs_TO_TRACE.size()> current_regs{};
    for (size_t i = 0; i < GPRs_TO_TRACE.size(); ++i)
    {
        current_regs[i] = emu.reg<uint64_t>(GPRs_TO_TRACE[i].first);
    }

    bool first_entry = true;
    auto append_separator = [&] {
        if (!first_entry)
        {
            trace_line << ",";
        }
        first_entry = false;
    };

    if (is_first_instruction_)
    {
        for (size_t i = 0; i < GPRs_TO_TRACE.size(); ++i)
        {
            append_separator();
            trace_line << GPRs_TO_TRACE[i].second << "=" << format_hex(current_regs[i]);
        }
        is_first_instruction_ = false;
    }
    else
    {
        for (size_t i = 0; i < GPRs_TO_TRACE.size(); ++i)
        {
            if (previous_registers_[i] != current_regs[i])
            {
                append_separator();
                trace_line << GPRs_TO_TRACE[i].second << "=" << format_hex(current_regs[i]);
            }
        }
    }

    append_separator();
    trace_line << "rip=" << format_hex(address);

    const auto mem_reads = mem_read_log_.str();
    if (!mem_reads.empty())
    {
        append_separator();
        trace_line << "mr=" << mem_reads;
    }

    const auto mem_writes = mem_write_log_.str();
    if (!mem_writes.empty())
    {
        append_separator();
        trace_line << "mw=" << mem_writes;
    }

    raw_log_buffer_.push_back(trace_line.str());
    previous_registers_ = current_regs;

    mem_read_log_.str("");
    mem_read_log_.clear();
    mem_write_log_.str("");
    mem_write_log_.clear();
}

```

`src/analyzer/tenet_tracer.hpp`:

```hpp
#pragma once

#include <windows_emulator.hpp>
#include <emulator/x86_register.hpp>
#include <emulator/scoped_hook.hpp>

constexpr std::array<std::pair<x86_register, std::string_view>, 16> GPRs_TO_TRACE = {
    {
        {x86_register::rax, "rax"},
        {x86_register::rbx, "rbx"},
        {x86_register::rcx, "rcx"},
        {x86_register::rdx, "rdx"},
        {x86_register::rsi, "rsi"},
        {x86_register::rdi, "rdi"},
        {x86_register::rbp, "rbp"},
        {x86_register::rsp, "rsp"},
        {x86_register::r8, "r8"},
        {x86_register::r9, "r9"},
        {x86_register::r10, "r10"},
        {x86_register::r11, "r11"},
        {x86_register::r12, "r12"},
        {x86_register::r13, "r13"},
        {x86_register::r14, "r14"},
        {x86_register::r15, "r15"},
    },
};

class tenet_tracer
{
  public:
    tenet_tracer(windows_emulator& win_emu, const std::filesystem::path& log_filename);
    ~tenet_tracer();

    tenet_tracer(tenet_tracer&) = delete;
    tenet_tracer(const tenet_tracer&) = delete;
    tenet_tracer& operator=(tenet_tracer&) = delete;
    tenet_tracer& operator=(const tenet_tracer&) = delete;

  private:
    void filter_and_write_buffer();
    void log_memory_read(uint64_t address, const void* data, size_t size);
    void log_memory_write(uint64_t address, const void* data, size_t size);
    void process_instruction(uint64_t address);

    windows_emulator& win_emu_;
    std::ofstream log_file_;

    std::vector<std::string> raw_log_buffer_;
    std::array<uint64_t, GPRs_TO_TRACE.size()> previous_registers_{};
    bool is_first_instruction_ = true;

    std::stringstream mem_read_log_;
    std::stringstream mem_write_log_;

    scoped_hook read_hook_;
    scoped_hook write_hook_;
    scoped_hook execute_hook_;
};

```

`src/analyzer/test.py`:

```py
import os
import subprocess

emulator_root = os.getenv('EMULATOR_ROOT')
analysis_sample = os.getenv('ANALYSIS_SAMPLE')
virtual_sample = 'C:/analysis-sample.exe'

application = 'analyzer'

def make_app(app):
    if os.name == 'nt':
        return app + ".exe"

    return app

command = [
    os.path.join(os.getcwd(), make_app(application)),
    '-c',
    '-e', emulator_root,
    '-p', virtual_sample, analysis_sample,
    virtual_sample
]

result = subprocess.run(command, cwd=os.getcwd())

exit(result.returncode)

```

`src/backend-selection/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(backend-selection ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_include_directories(backend-selection INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

target_link_libraries(backend-selection PRIVATE
  unicorn-emulator
)

if (MOMO_ENABLE_RUST)
  target_link_libraries(backend-selection PRIVATE
    icicle-emulator
  )
endif()
```

`src/backend-selection/backend_selection.cpp`:

```cpp
#include "backend_selection.hpp"

#include <string_view>
#include <unicorn_x86_64_emulator.hpp>

#if MOMO_ENABLE_RUST_CODE
#include <icicle_x86_64_emulator.hpp>
#endif

using namespace std::literals;

std::unique_ptr<x86_64_emulator> create_x86_64_emulator()
{
#if MOMO_ENABLE_RUST_CODE
    const auto* env = getenv("EMULATOR_ICICLE");
    if (env && (env == "1"sv || env == "true"sv))
    {
        // TODO: Add proper handling for WOW64 case (x64 -> x86 emulation is not supported yet).
        // icicle does not support automatic cross-architecture conversion from x64 to x86.
        // therefore WOW64 programs are naturally not supported to run.
        return icicle::create_x86_64_emulator();
    }
#endif

    return unicorn::create_x86_64_emulator();
}

```

`src/backend-selection/backend_selection.hpp`:

```hpp
#pragma once

#include <memory>
#include <arch_emulator.hpp>

std::unique_ptr<x86_64_emulator> create_x86_64_emulator();

```

`src/backends/CMakeLists.txt`:

```txt
add_subdirectory(unicorn-emulator)

if (MOMO_ENABLE_RUST)
  add_subdirectory(icicle-emulator)
endif()

```

`src/backends/icicle-emulator/CMakeLists.txt`:

```txt
add_subdirectory(icicle-bridge)

file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

if(SOGEN_BUILD_STATIC)
	add_library(icicle-emulator STATIC ${SRC_FILES})
else()
    add_library(icicle-emulator SHARED ${SRC_FILES})
endif()

target_include_directories(icicle-emulator INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

target_link_libraries(icicle-emulator PUBLIC emulator)
target_link_libraries(icicle-emulator PRIVATE emulator-common icicle-bridge)

```

`src/backends/icicle-emulator/icicle-bridge/CMakeLists.txt`:

```txt
include(ExternalProject)

set(ICICLE_BUILD_DIR ${CMAKE_CURRENT_BINARY_DIR}/cargo-build)
set(ICICLE_ARTIFACT_DIR ${ICICLE_BUILD_DIR}/$<IF:$<CONFIG:Debug>,debug,release>)

set(ICICLE_RUST_PROJECT_NAME "icicle")
set(ICICLE_RUST_LIBNAME "lib${ICICLE_RUST_PROJECT_NAME}.a")

if(MSVC)
    set(ICICLE_RUST_LIBNAME "${ICICLE_RUST_PROJECT_NAME}.lib")
endif()

set(CARGO_TRIPLE)
set(CARGO_OPTIONS)

if (MINGW)
  set(CARGO_TRIPLE "x86_64-pc-windows-gnu")
elseif (CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
  set(CARGO_TRIPLE "wasm32-unknown-emscripten")
elseif(WIN32 AND CMAKE_SIZEOF_VOID_P EQUAL 4)
  set(CARGO_TRIPLE "i686-pc-windows-msvc")
elseif(CMAKE_SYSTEM_NAME STREQUAL "iOS")
  set(CARGO_TRIPLE "aarch64-apple-ios")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Android")
  if(CMAKE_ANDROID_ARCH_ABI STREQUAL "arm64-v8a")
    set(CARGO_TRIPLE "aarch64-linux-android")
  else()
    set(CARGO_TRIPLE "${CMAKE_ANDROID_ARCH_ABI}-linux-android")
  endif()
endif()

if(CARGO_TRIPLE)
  set(CARGO_OPTIONS ${CARGO_OPTIONS} "--target=${CARGO_TRIPLE}")
  set(ICICLE_ARTIFACT_DIR ${ICICLE_BUILD_DIR}/${CARGO_TRIPLE}/$<IF:$<CONFIG:Debug>,debug,release>)
endif()


set(ICICLE_RUST_LIB ${ICICLE_ARTIFACT_DIR}/${ICICLE_RUST_LIBNAME})

ExternalProject_Add(
    icicle-rust-project
    PREFIX ${CMAKE_CURRENT_BINARY_DIR}
    SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}
    BINARY_DIR ${CMAKE_CURRENT_LIST_DIR}
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ${CMAKE_COMMAND} -E env "CARGO_TARGET_DIR=${ICICLE_BUILD_DIR}" -- cargo build ${CARGO_OPTIONS} --lib --profile $<IF:$<CONFIG:Debug>,dev,release>
    INSTALL_COMMAND ""
    USES_TERMINAL_CONFIGURE 1
    USES_TERMINAL_BUILD 1
    BUILD_ALWAYS 1
    BUILD_BYPRODUCTS ${ICICLE_RUST_LIB}
)

add_custom_command(
    TARGET icicle-rust-project POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory "${CMAKE_CURRENT_LIST_DIR}/data" "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}"
    COMMENT "Copying Ghidra Processor Specification"
)

add_library(icicle-bridge INTERFACE)
add_dependencies(icicle-bridge icicle-rust-project)
target_link_libraries(icicle-bridge INTERFACE ${ICICLE_RUST_LIB})

if(MSVC)
  target_link_libraries(icicle-bridge INTERFACE
    ws2_32.lib
    Userenv.lib
    ntdll.lib
    Bcrypt.lib
  )
endif()
```

`src/backends/icicle-emulator/icicle-bridge/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5d307320b3181d6d7954e663bd7c774a838b8220fe0593c86d9fb09f498b4b"
dependencies = [
 "cpp_demangle",
 "fallible-iterator",
 "gimli",
 "memmap2",
 "object 0.37.3",
 "rustc-demangle",
 "smallvec",
 "typed-arena",
]

[[package]]
name = "adler2"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"

[[package]]
name = "ahash"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
dependencies = [
 "cfg-if",
 "getrandom",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "anyhow"
version = "1.0.97"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcfed56ad506cb2c684a14971b8861fdc3baaaae314b9e5f9bb532cbe3ba7a4f"

[[package]]
name = "arbitrary"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dde20b3d026af13f561bdd0f15edf01fc734f0dafcedbaf42bba506a9517f223"

[[package]]
name = "autocfg"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c8214115b7bf84099f1309324e63141d4c5d7cc26862f97a0a857dbefe165bd"
dependencies = [
 "serde",
]

[[package]]
name = "bstr"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "234113d19d0d7d613b40e86fb654acf958910802bcceab913a4f9e7cda03b1a4"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "bumpalo"
version = "3.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf"
dependencies = [
 "allocator-api2",
]

[[package]]
name = "bytemuck"
version = "1.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6b1fc10dbac614ebc03540c9dbd60e83887fda27794998c6528f1782047d540"

[[package]]
name = "cc"
version = "1.2.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37521ac7aabe3d13122dc382493e20c9416f299d2ccd5b3a5340a2570cdeb0f3"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cpp_demangle"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96e58d342ad113c2b878f16d5d034c03be492ae460cdbc02b7f0f2284d310c7d"
dependencies = [
 "cfg-if",
]

[[package]]
name = "cranelift"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40339ed9c3d642760e4d68fe04cc97a9c1053f754fb1b923099105d13b5388c2"
dependencies = [
 "cranelift-codegen",
 "cranelift-frontend",
 "cranelift-module",
]

[[package]]
name = "cranelift-assembler-x64"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6e2df3d5caad11e71bb0b70115a5210c3af4a0bcb2893f78ee9311b1b266b05"
dependencies = [
 "cranelift-assembler-x64-meta",
]

[[package]]
name = "cranelift-assembler-x64-meta"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b63e87985fc9166a2541b05fd5f913a398cff9aec6b13ebca865253cdee15806"
dependencies = [
 "cranelift-srcgen",
]

[[package]]
name = "cranelift-bforest"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b5364dfe182d4b89af2f4bd0dafc8f6c590bbf0216ee8ce60bfd8893c3d14a6"
dependencies = [
 "cranelift-entity",
]

[[package]]
name = "cranelift-bitset"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3067ca8c10796434497a5faac73d949b5ac0008ed572013debe88694bfef426e"

[[package]]
name = "cranelift-codegen"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eb420cc46d7f0956e2e3d9e6389036c612ada3542a29edc6f5deedf86d568ba"
dependencies = [
 "bumpalo",
 "cranelift-assembler-x64",
 "cranelift-bforest",
 "cranelift-bitset",
 "cranelift-codegen-meta",
 "cranelift-codegen-shared",
 "cranelift-control",
 "cranelift-entity",
 "cranelift-isle",
 "gimli",
 "hashbrown",
 "log",
 "regalloc2",
 "rustc-hash",
 "serde",
 "smallvec",
 "target-lexicon",
 "wasmtime-internal-math",
]

[[package]]
name = "cranelift-codegen-meta"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "440d31dd36e477fb6292821b593da65df60328bca1046ea5881f424aa5a44b5d"
dependencies = [
 "cranelift-assembler-x64-meta",
 "cranelift-codegen-shared",
 "cranelift-srcgen",
 "heck",
]

[[package]]
name = "cranelift-codegen-shared"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0b342ef4835787577f6e7553747cdd902797509eb5af733cd89e5ce97cea0f0"

[[package]]
name = "cranelift-control"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b34de54534b61c3f3e475558cf19c90b2a7a758c7018e557e5d1a47b9a1fbb03"
dependencies = [
 "arbitrary",
]

[[package]]
name = "cranelift-entity"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3d7bf1aae1800d053aa965381dcb01054404d0bcd8ea5ffe65bb855b8e3f654"
dependencies = [
 "cranelift-bitset",
]

[[package]]
name = "cranelift-frontend"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36158c03d70e1f443cc2d6d9adc838fc0a031b166f3861534e9cb77742380e2a"
dependencies = [
 "cranelift-codegen",
 "log",
 "smallvec",
 "target-lexicon",
]

[[package]]
name = "cranelift-isle"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fa194bbc189c965454f3a94c1acb6c89d63d5d0b183e60edc17db758bfbe519"

[[package]]
name = "cranelift-jit"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "180c0ef490bba2993328d264996265f6dfc5c8d3e892b92bcfbc40381755845c"
dependencies = [
 "anyhow",
 "cranelift-codegen",
 "cranelift-control",
 "cranelift-entity",
 "cranelift-module",
 "cranelift-native",
 "libc",
 "log",
 "region",
 "target-lexicon",
 "wasmtime-internal-jit-icache-coherence",
 "windows-sys 0.60.2",
]

[[package]]
name = "cranelift-module"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47111dbbf532c0c8e0b298230521d94a1b355913249480af728ae7ca7fd071de"
dependencies = [
 "anyhow",
 "cranelift-codegen",
 "cranelift-control",
]

[[package]]
name = "cranelift-native"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c469bb98ffe9f38a1a5ada0427ab096f0f1b9a22a30149fc705205c56cf8985"
dependencies = [
 "cranelift-codegen",
 "libc",
 "target-lexicon",
]

[[package]]
name = "cranelift-srcgen"
version = "0.124.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "12d694cd4c6b28fb8a4d0cf5b58d532b6b3b6e4afb2b65603e2ab8dc35bf18bd"

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crunchy"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43da5946c66ffcc7745f48db692ffbb10a83bfe0afd96235c5c2a4fb23994929"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "976dd42dc7e85965fe702eb8164f21f450704bdde31faefd6471dba214cb594e"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "fallible-iterator"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2acce4a10f12dc2fb14a218589d4f1f62ef011b2d0cc4b3cb1bba8e94da14649"

[[package]]
name = "find-msvc-tools"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52051878f80a721bb68ebfbc930e07b65ba72f2da88968ea5c06fd6ca3d3a127"

[[package]]
name = "flate2"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ced92e76e966ca2fd84c8f7aa01a4aea65b0eb6648d72f7c8f3e2764a67fece"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.32.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e629b9b98ef3dd8afe6ca2bd0f89306cec16d43d907889945bc5d6687f2f13c7"
dependencies = [
 "fallible-iterator",
 "indexmap",
 "stable_deref_trait",
]

[[package]]
name = "half"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "459196ed295495a68f7d7fe1d84f6c4b7ff0e21fe3017b2f283c6fac3ad803c9"
dependencies = [
 "cfg-if",
 "crunchy",
]

[[package]]
name = "hashbrown"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
dependencies = [
 "foldhash",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "icicle"
version = "0.1.0"
dependencies = [
 "icicle-cpu",
 "icicle-vm",
 "pcode",
]

[[package]]
name = "icicle-cpu"
version = "0.1.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "addr2line",
 "ahash",
 "anyhow",
 "bitflags 2.9.0",
 "bytemuck",
 "gimli",
 "half",
 "icicle-mem",
 "object 0.37.3",
 "pcode",
 "sleigh-runtime",
 "target-lexicon",
 "tracing",
]

[[package]]
name = "icicle-jit"
version = "0.2.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "cranelift",
 "cranelift-codegen",
 "cranelift-jit",
 "cranelift-module",
 "cranelift-native",
 "icicle-cpu",
 "memoffset",
 "pcode",
 "target-lexicon",
 "tracing",
 "wasmtime-jit-debug",
]

[[package]]
name = "icicle-linux"
version = "0.1.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "bitflags 2.9.0",
 "bstr",
 "bytemuck",
 "icicle-cpu",
 "object 0.37.3",
 "pcode",
 "sleigh-runtime",
 "target-lexicon",
 "tracing",
]

[[package]]
name = "icicle-mem"
version = "0.3.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "ahash",
 "tracing",
]

[[package]]
name = "icicle-vm"
version = "0.2.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "anyhow",
 "icicle-cpu",
 "icicle-jit",
 "icicle-linux",
 "ihex",
 "object 0.37.3",
 "pcode",
 "ron",
 "serde",
 "serde-xml-rs",
 "sleigh-compile",
 "sleigh-runtime",
 "target-lexicon",
 "tracing",
]

[[package]]
name = "ihex"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "365a784774bb381e8c19edb91190a90d7f2625e057b55de2bc0f6b57bc779ff2"

[[package]]
name = "indexmap"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "libc"
version = "0.2.171"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6"

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "mach2"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b955cdeb2a02b9117f121ce63aa52d08ade45de53e48fe6a38b39c10f6f709"
dependencies = [
 "libc",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memmap2"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd3f7eed9d3848f8b98834af67102b720745c4ec028fcd0aa0239277e7de374f"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
dependencies = [
 "autocfg",
]

[[package]]
name = "miniz_oxide"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3be647b768db090acb35d5ec5db2b0e1f1de11133ca123b9eacf5137868f892a"
dependencies = [
 "adler2",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "object"
version = "0.37.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff76201f031d8863c38aa7f905eca4f53abbfa15f609db4277d44cd8938f33fe"
dependencies = [
 "crc32fast",
 "flate2",
 "hashbrown",
 "indexmap",
 "memchr",
 "ruzstd",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "pcode"
version = "0.2.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "proc-macro2"
version = "1.0.94"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "regalloc2"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "efd8138ce7c3d7c13be4f61893154b5d711bd798d2d7be3ecb8dcc7e7a06ca98"
dependencies = [
 "allocator-api2",
 "bumpalo",
 "hashbrown",
 "log",
 "rustc-hash",
 "smallvec",
]

[[package]]
name = "region"
version = "3.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6b6ebd13bc009aef9cd476c1310d49ac354d36e240cf1bd753290f3dc7199a7"
dependencies = [
 "bitflags 1.3.2",
 "libc",
 "mach2",
 "windows-sys 0.52.0",
]

[[package]]
name = "ron"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db09040cc89e461f1a265139777a2bde7f8d8c67c4936f700c63ce3e2904d468"
dependencies = [
 "base64",
 "bitflags 2.9.0",
 "serde",
 "serde_derive",
 "unicode-ident",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustix"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd15f8a2c5551a84d56efdc1cd049089e409ac19a3072d5037a17fd70719ff3e"
dependencies = [
 "bitflags 2.9.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.60.2",
]

[[package]]
name = "ruzstd"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3640bec8aad418d7d03c72ea2de10d5c646a598f9883c7babc160d91e3c1b26c"
dependencies = [
 "twox-hash",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde-xml-rs"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53630160a98edebde0123eb4dfd0fce6adff091b2305db3154a9e920206eb510"
dependencies = [
 "log",
 "serde",
 "thiserror",
 "xml-rs",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "sleigh-compile"
version = "0.3.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "pcode",
 "serde",
 "serde-xml-rs",
 "serde_derive",
 "sleigh-parse",
 "sleigh-runtime",
]

[[package]]
name = "sleigh-parse"
version = "0.3.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"

[[package]]
name = "sleigh-runtime"
version = "0.1.0"
source = "git+https://github.com/icicle-emu/icicle-emu#6040b08d23e8690b98f950cff5847fe5daa093f7"
dependencies = [
 "ahash",
 "pcode",
 "sleigh-parse",
]

[[package]]
name = "smallvec"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8917285742e9f3e1683f0a9c4e6b57960b7314d0b08d30d1ecd426713ee2eee9"

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "syn"
version = "2.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "target-lexicon"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df7f62577c25e07834649fc3b39fafdc597c0a3527dc1c60129201ccfcbaa50c"

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-core",
]

[[package]]
name = "tracing-core"
version = "0.1.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"

[[package]]
name = "twox-hash"
version = "2.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ea3136b675547379c4bd395ca6b938e5ad3c3d20fad76e7fe85f9e0d011419c"

[[package]]
name = "typed-arena"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6af6ae20167a9ece4bcb41af5b80f8a1f1df981f6391189ce00fd257af04126a"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasmtime-internal-jit-icache-coherence"
version = "37.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a03f55a9dbfa30f2ed269fa9735c2994b8423461d45c3ca08aa7a103daeff20"
dependencies = [
 "anyhow",
 "cfg-if",
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "wasmtime-internal-math"
version = "37.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed7f491d2c7f1be3f6e5485ab5a26f26f177860c8b5c16d3ab87df4b24f28e40"
dependencies = [
 "libm",
]

[[package]]
name = "wasmtime-jit-debug"
version = "34.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f935b198c58d3f85b6f8d2fedcbaf71e6f41dee3a8278d60cbe9326b82ac91aa"
dependencies = [
 "cc",
 "object 0.36.7",
 "rustix",
 "wasmtime-versioned-export-macros",
]

[[package]]
name = "wasmtime-versioned-export-macros"
version = "34.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ca100ed168ffc9b37aefc07a5be440645eab612a2ff6e2ff884e8cc3740e666"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.1",
 "windows_aarch64_msvc 0.53.1",
 "windows_i686_gnu 0.53.1",
 "windows_i686_gnullvm 0.53.1",
 "windows_i686_msvc 0.53.1",
 "windows_x86_64_gnu 0.53.1",
 "windows_x86_64_gnullvm 0.53.1",
 "windows_x86_64_msvc 0.53.1",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"

[[package]]
name = "xml-rs"
version = "0.8.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5b940ebc25896e71dd073bad2dbaa2abfe97b0a391415e22ad1326d9c54e3c4"

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

```

`src/backends/icicle-emulator/icicle-bridge/Cargo.toml`:

```toml
[package]
name = "icicle"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["staticlib"]

[dependencies]
icicle-vm = { git = "https://github.com/icicle-emu/icicle-emu" }
icicle-cpu = { git = "https://github.com/icicle-emu/icicle-emu" }
pcode = { git = "https://github.com/icicle-emu/icicle-emu" }

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/adx.sinc`:

```sinc
:ADCX Reg32, rm32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xF6; rm32 & Reg32 ... & check_Reg32_dest ... {
	tmp:5 = zext(Reg32) + zext(rm32) + zext(CF);
	tmpCF:1 = tmp(4); # just the carry byte 
	CF = tmpCF != 0;
	Reg32 = tmp:4;
	build check_Reg32_dest;
}

@ifdef IA64
:ADCX Reg64, rm64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xF6; Reg64 ... & rm64 {
	tmp:9 = zext(Reg64) + zext(rm64) + zext(CF);
	tmpCF:1 = tmp(8); # just the carry byte 
	CF = tmpCF != 0;
	Reg64 = tmp:8;
}
@endif

:ADOX Reg32, rm32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x38; byte=0xF6; rm32 & Reg32 ... & check_Reg32_dest ... {
	tmp:5 = zext(Reg32) + zext(rm32) + zext(OF);
	tmpOF:1 = tmp(4); # just the carry byte 
	OF = tmpOF != 0;
	Reg32 = tmp:4;
	build check_Reg32_dest;
}

@ifdef IA64
:ADOX Reg64, rm64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0F; byte=0x38; byte=0xF6; Reg64 ... & rm64 {
	tmp:9 = zext(Reg64) + zext(rm64) + zext(OF);
	tmpOF:1 = tmp(8); # just the carry byte 
	OF = tmpOF != 0;
	Reg64 = tmp:8;
}
@endif

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/avx.sinc`:

```sinc
# INFO This file automatically generated by andre on Thu May 10 10:49:02 2018
# INFO Direct edits to this file may be lost in future updates
# INFO Command line arguments: ['--sinc', '--cpuid-match', '^AVX\\b', '--skip-sinc', '../../../Processors/x86/data/languages/avx_manual.sinc']

# ADDPD 3-33 PAGE 603 LINE 33405
define pcodeop vaddpd_avx ;
:VADDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ADDPD 3-33 PAGE 603 LINE 33408
:VADDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x58; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ADDPS 3-36 PAGE 606 LINE 33558
define pcodeop vaddps_avx ;
:VADDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ADDPS 3-36 PAGE 606 LINE 33560
:VADDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x58; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ADDSD 3-39 PAGE 609 LINE 33718
define pcodeop vaddsd_avx ;
:VADDSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vaddsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ADDSS 3-41 PAGE 611 LINE 33812
define pcodeop vaddss_avx ;
:VADDSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vaddss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ADDSUBPD 3-43 PAGE 613 LINE 33906
define pcodeop vaddsubpd_avx ;
:VADDSUBPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD0; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddsubpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ADDSUBPD 3-43 PAGE 613 LINE 33909
:VADDSUBPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD0; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddsubpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ADDSUBPS 3-45 PAGE 615 LINE 34013
define pcodeop vaddsubps_avx ;
:VADDSUBPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD0; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddsubps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ADDSUBPS 3-45 PAGE 615 LINE 34016
:VADDSUBPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD0; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddsubps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ANDPD 3-64 PAGE 634 LINE 34821
define pcodeop vandpd_avx ;
:VANDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x54; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ANDPD 3-64 PAGE 634 LINE 34824
:VANDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x54; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ANDPS 3-67 PAGE 637 LINE 34947
define pcodeop vandps_avx ;
:VANDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x54; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ANDPS 3-67 PAGE 637 LINE 34950
:VANDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x54; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ANDNPD 3-70 PAGE 640 LINE 35081
define pcodeop vandnpd_avx ;
:VANDNPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x55; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandnpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ANDNPD 3-70 PAGE 640 LINE 35084
:VANDNPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x55; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandnpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ANDNPS 3-73 PAGE 643 LINE 35207
define pcodeop vandnps_avx ;
:VANDNPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x55; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandnps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ANDNPS 3-73 PAGE 643 LINE 35210
:VANDNPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x55; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandnps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# BLENDPD 3-78 PAGE 648 LINE 35433
define pcodeop vblendpd_avx ;
:VBLENDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8_3_0 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8_3_0
{
	local tmp:16 = vblendpd_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8_3_0:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# BLENDPD 3-78 PAGE 648 LINE 35436
:VBLENDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8_3_0 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0D; YmmReg1 ... & YmmReg2_m256; imm8_3_0
{
	YmmReg1 = vblendpd_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8_3_0:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# BLENDPS 3-81 PAGE 651 LINE 35580
define pcodeop vblendps_avx ;
:VBLENDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vblendps_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# BLENDPS 3-81 PAGE 651 LINE 35583
:VBLENDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0C; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vblendps_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# BLENDVPD 3-83 PAGE 653 LINE 35684
define pcodeop vblendvpd_avx ;
:VBLENDVPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x4B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; Xmm_imm8_7_4
{
	local tmp:16 = vblendvpd_avx( vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# BLENDVPD 3-83 PAGE 653 LINE 35688
:VBLENDVPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x4B; YmmReg1 ... & YmmReg2_m256; Ymm_imm8_7_4
{
	YmmReg1 = vblendvpd_avx( vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# BLENDVPS 3-85 PAGE 655 LINE 35789
define pcodeop vblendvps_avx ;
:VBLENDVPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x4A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; Xmm_imm8_7_4
{
	local tmp:16 = vblendvps_avx( vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# BLENDVPS 3-85 PAGE 655 LINE 35793
:VBLENDVPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x4A; YmmReg1 ... & YmmReg2_m256; Ymm_imm8_7_4
{
	YmmReg1 = vblendvps_avx( vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CMPPD 3-155 PAGE 725 LINE 39240
VCMPPD_mon: "VCMPEQPD" is imm8=0x0 { }
VCMPPD_op: "" is imm8=0x0 { export 0x0:1; }
VCMPPD_mon: "VCMPLTPD" is imm8=0x1 { }
VCMPPD_op: "" is imm8=0x1 { export 0x1:1; }
VCMPPD_mon: "VCMPLEPD" is imm8=0x2 { }
VCMPPD_op: "" is imm8=0x2 { export 0x2:1; }
VCMPPD_mon: "VCMPUNORDPD" is imm8=0x3 { }
VCMPPD_op: "" is imm8=0x3 { export 0x3:1; }
VCMPPD_mon: "VCMPNEQPD" is imm8=0x4 { }
VCMPPD_op: "" is imm8=0x4 { export 0x4:1; }
VCMPPD_mon: "VCMPNLTPD" is imm8=0x5 { }
VCMPPD_op: "" is imm8=0x5 { export 0x5:1; }
VCMPPD_mon: "VCMPNLEPD" is imm8=0x6 { }
VCMPPD_op: "" is imm8=0x6 { export 0x6:1; }
VCMPPD_mon: "VCMPORDPD" is imm8=0x7 { }
VCMPPD_op: "" is imm8=0x7 { export 0x7:1; }
VCMPPD_mon: "VCMPEQ_UQPD" is imm8=0x8 { }
VCMPPD_op: "" is imm8=0x8 { export 0x8:1; }
VCMPPD_mon: "VCMPNGEPD" is imm8=0x9 { }
VCMPPD_op: "" is imm8=0x9 { export 0x9:1; }
VCMPPD_mon: "VCMPNGTPD" is imm8=0xa { }
VCMPPD_op: "" is imm8=0xa { export 0xa:1; }
VCMPPD_mon: "VCMPFALSEPD" is imm8=0xb { }
VCMPPD_op: "" is imm8=0xb { export 0xb:1; }
VCMPPD_mon: "VCMPNEQ_OQPD" is imm8=0xc { }
VCMPPD_op: "" is imm8=0xc { export 0xc:1; }
VCMPPD_mon: "VCMPGEPD" is imm8=0xd { }
VCMPPD_op: "" is imm8=0xd { export 0xd:1; }
VCMPPD_mon: "VCMPGTPD" is imm8=0xe { }
VCMPPD_op: "" is imm8=0xe { export 0xe:1; }
VCMPPD_mon: "VCMPTRUEPD" is imm8=0xf { }
VCMPPD_op: "" is imm8=0xf { export 0xf:1; }
VCMPPD_mon: "VCMPEQ_OSPD" is imm8=0x10 { }
VCMPPD_op: "" is imm8=0x10 { export 0x10:1; }
VCMPPD_mon: "VCMPLT_OQPD" is imm8=0x11 { }
VCMPPD_op: "" is imm8=0x11 { export 0x11:1; }
VCMPPD_mon: "VCMPLE_OQPD" is imm8=0x12 { }
VCMPPD_op: "" is imm8=0x12 { export 0x12:1; }
VCMPPD_mon: "VCMPUNORD_SPD" is imm8=0x13 { }
VCMPPD_op: "" is imm8=0x13 { export 0x13:1; }
VCMPPD_mon: "VCMPNEQ_USPD" is imm8=0x14 { }
VCMPPD_op: "" is imm8=0x14 { export 0x14:1; }
VCMPPD_mon: "VCMPNLT_UQPD" is imm8=0x15 { }
VCMPPD_op: "" is imm8=0x15 { export 0x15:1; }
VCMPPD_mon: "VCMPNLE_UQPD" is imm8=0x16 { }
VCMPPD_op: "" is imm8=0x16 { export 0x16:1; }
VCMPPD_mon: "VCMPORD_SPD" is imm8=0x17 { }
VCMPPD_op: "" is imm8=0x17 { export 0x17:1; }
VCMPPD_mon: "VCMPEQ_USPD" is imm8=0x18 { }
VCMPPD_op: "" is imm8=0x18 { export 0x18:1; }
VCMPPD_mon: "VCMPNGE_UQPD" is imm8=0x19 { }
VCMPPD_op: "" is imm8=0x19 { export 0x19:1; }
VCMPPD_mon: "VCMPNGT_UQPD" is imm8=0x1a { }
VCMPPD_op: "" is imm8=0x1a { export 0x1a:1; }
VCMPPD_mon: "VCMPFALSE_OSPD" is imm8=0x1b { }
VCMPPD_op: "" is imm8=0x1b { export 0x1b:1; }
VCMPPD_mon: "VCMPNEQ_OSPD" is imm8=0x1c { }
VCMPPD_op: "" is imm8=0x1c { export 0x1c:1; }
VCMPPD_mon: "VCMPGE_OQPD" is imm8=0x1d { }
VCMPPD_op: "" is imm8=0x1d { export 0x1d:1; }
VCMPPD_mon: "VCMPGT_OQPD" is imm8=0x1e { }
VCMPPD_op: "" is imm8=0x1e { export 0x1e:1; }
VCMPPD_mon: "VCMPTRUE_USPD" is imm8=0x1f { }
VCMPPD_op: "" is imm8=0x1f { export 0x1f:1; }
VCMPPD_mon: "VCMPPD" is imm8 { }
VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
define pcodeop vcmppd_avx ;
:^VCMPPD_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m128^VCMPPD_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; VCMPPD_mon & VCMPPD_op
{
	local tmp:16 = vcmppd_avx( vexVVVV_XmmReg, XmmReg2_m128, VCMPPD_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CMPPD 3-155 PAGE 725 LINE 39243
:^VCMPPD_mon YmmReg1, vexVVVV_YmmReg, YmmReg2_m256^VCMPPD_op is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC2; YmmReg1 ... & YmmReg2_m256; VCMPPD_mon & VCMPPD_op
{
	YmmReg1 = vcmppd_avx( vexVVVV_YmmReg, YmmReg2_m256, VCMPPD_op );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CMPPS 3-162 PAGE 732 LINE 39607
VCMPPS_mon: "VCMPEQPS" is imm8=0x0 { }
VCMPPS_op: "" is imm8=0x0 { export 0x0:1; }
VCMPPS_mon: "VCMPLTPS" is imm8=0x1 { }
VCMPPS_op: "" is imm8=0x1 { export 0x1:1; }
VCMPPS_mon: "VCMPLEPS" is imm8=0x2 { }
VCMPPS_op: "" is imm8=0x2 { export 0x2:1; }
VCMPPS_mon: "VCMPUNORDPS" is imm8=0x3 { }
VCMPPS_op: "" is imm8=0x3 { export 0x3:1; }
VCMPPS_mon: "VCMPNEQPS" is imm8=0x4 { }
VCMPPS_op: "" is imm8=0x4 { export 0x4:1; }
VCMPPS_mon: "VCMPNLTPS" is imm8=0x5 { }
VCMPPS_op: "" is imm8=0x5 { export 0x5:1; }
VCMPPS_mon: "VCMPNLEPS" is imm8=0x6 { }
VCMPPS_op: "" is imm8=0x6 { export 0x6:1; }
VCMPPS_mon: "VCMPORDPS" is imm8=0x7 { }
VCMPPS_op: "" is imm8=0x7 { export 0x7:1; }
VCMPPS_mon: "VCMPEQ_UQPS" is imm8=0x8 { }
VCMPPS_op: "" is imm8=0x8 { export 0x8:1; }
VCMPPS_mon: "VCMPNGEPS" is imm8=0x9 { }
VCMPPS_op: "" is imm8=0x9 { export 0x9:1; }
VCMPPS_mon: "VCMPNGTPS" is imm8=0xa { }
VCMPPS_op: "" is imm8=0xa { export 0xa:1; }
VCMPPS_mon: "VCMPFALSEPS" is imm8=0xb { }
VCMPPS_op: "" is imm8=0xb { export 0xb:1; }
VCMPPS_mon: "VCMPNEQ_OQPS" is imm8=0xc { }
VCMPPS_op: "" is imm8=0xc { export 0xc:1; }
VCMPPS_mon: "VCMPGEPS" is imm8=0xd { }
VCMPPS_op: "" is imm8=0xd { export 0xd:1; }
VCMPPS_mon: "VCMPGTPS" is imm8=0xe { }
VCMPPS_op: "" is imm8=0xe { export 0xe:1; }
VCMPPS_mon: "VCMPTRUEPS" is imm8=0xf { }
VCMPPS_op: "" is imm8=0xf { export 0xf:1; }
VCMPPS_mon: "VCMPEQ_OSPS" is imm8=0x10 { }
VCMPPS_op: "" is imm8=0x10 { export 0x10:1; }
VCMPPS_mon: "VCMPLT_OQPS" is imm8=0x11 { }
VCMPPS_op: "" is imm8=0x11 { export 0x11:1; }
VCMPPS_mon: "VCMPLE_OQPS" is imm8=0x12 { }
VCMPPS_op: "" is imm8=0x12 { export 0x12:1; }
VCMPPS_mon: "VCMPUNORD_SPS" is imm8=0x13 { }
VCMPPS_op: "" is imm8=0x13 { export 0x13:1; }
VCMPPS_mon: "VCMPNEQ_USPS" is imm8=0x14 { }
VCMPPS_op: "" is imm8=0x14 { export 0x14:1; }
VCMPPS_mon: "VCMPNLT_UQPS" is imm8=0x15 { }
VCMPPS_op: "" is imm8=0x15 { export 0x15:1; }
VCMPPS_mon: "VCMPNLE_UQPS" is imm8=0x16 { }
VCMPPS_op: "" is imm8=0x16 { export 0x16:1; }
VCMPPS_mon: "VCMPORD_SPS" is imm8=0x17 { }
VCMPPS_op: "" is imm8=0x17 { export 0x17:1; }
VCMPPS_mon: "VCMPEQ_USPS" is imm8=0x18 { }
VCMPPS_op: "" is imm8=0x18 { export 0x18:1; }
VCMPPS_mon: "VCMPNGE_UQPS" is imm8=0x19 { }
VCMPPS_op: "" is imm8=0x19 { export 0x19:1; }
VCMPPS_mon: "VCMPNGT_UQPS" is imm8=0x1a { }
VCMPPS_op: "" is imm8=0x1a { export 0x1a:1; }
VCMPPS_mon: "VCMPFALSE_OSPS" is imm8=0x1b { }
VCMPPS_op: "" is imm8=0x1b { export 0x1b:1; }
VCMPPS_mon: "VCMPNEQ_OSPS" is imm8=0x1c { }
VCMPPS_op: "" is imm8=0x1c { export 0x1c:1; }
VCMPPS_mon: "VCMPGE_OQPS" is imm8=0x1d { }
VCMPPS_op: "" is imm8=0x1d { export 0x1d:1; }
VCMPPS_mon: "VCMPGT_OQPS" is imm8=0x1e { }
VCMPPS_op: "" is imm8=0x1e { export 0x1e:1; }
VCMPPS_mon: "VCMPTRUE_USPS" is imm8=0x1f { }
VCMPPS_op: "" is imm8=0x1f { export 0x1f:1; }
VCMPPS_mon: "VCMPPS" is imm8 { }
VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
define pcodeop vcmpps_avx ;
:^VCMPPS_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m128^VCMPPS_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; VCMPPS_mon & VCMPPS_op
{
	local tmp:16 = vcmpps_avx( vexVVVV_XmmReg, XmmReg2_m128, VCMPPS_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CMPPS 3-162 PAGE 732 LINE 39610
:^VCMPPS_mon YmmReg1, vexVVVV_YmmReg, YmmReg2_m256^VCMPPS_op is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC2; YmmReg1 ... & YmmReg2_m256; VCMPPS_mon & VCMPPS_op
{
	YmmReg1 = vcmpps_avx( vexVVVV_YmmReg, YmmReg2_m256, VCMPPS_op );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CMPSD 3-173 PAGE 743 LINE 40154
VCMPSD_mon: "VCMPEQSD" is imm8=0x0 { }
VCMPSD_op: "" is imm8=0x0 { export 0x0:1; }
VCMPSD_mon: "VCMPLTSD" is imm8=0x1 { }
VCMPSD_op: "" is imm8=0x1 { export 0x1:1; }
VCMPSD_mon: "VCMPLESD" is imm8=0x2 { }
VCMPSD_op: "" is imm8=0x2 { export 0x2:1; }
VCMPSD_mon: "VCMPUNORDSD" is imm8=0x3 { }
VCMPSD_op: "" is imm8=0x3 { export 0x3:1; }
VCMPSD_mon: "VCMPNEQSD" is imm8=0x4 { }
VCMPSD_op: "" is imm8=0x4 { export 0x4:1; }
VCMPSD_mon: "VCMPNLTSD" is imm8=0x5 { }
VCMPSD_op: "" is imm8=0x5 { export 0x5:1; }
VCMPSD_mon: "VCMPNLESD" is imm8=0x6 { }
VCMPSD_op: "" is imm8=0x6 { export 0x6:1; }
VCMPSD_mon: "VCMPORDSD" is imm8=0x7 { }
VCMPSD_op: "" is imm8=0x7 { export 0x7:1; }
VCMPSD_mon: "VCMPEQ_UQSD" is imm8=0x8 { }
VCMPSD_op: "" is imm8=0x8 { export 0x8:1; }
VCMPSD_mon: "VCMPNGESD" is imm8=0x9 { }
VCMPSD_op: "" is imm8=0x9 { export 0x9:1; }
VCMPSD_mon: "VCMPNGTSD" is imm8=0xa { }
VCMPSD_op: "" is imm8=0xa { export 0xa:1; }
VCMPSD_mon: "VCMPFALSESD" is imm8=0xb { }
VCMPSD_op: "" is imm8=0xb { export 0xb:1; }
VCMPSD_mon: "VCMPNEQ_OQSD" is imm8=0xc { }
VCMPSD_op: "" is imm8=0xc { export 0xc:1; }
VCMPSD_mon: "VCMPGESD" is imm8=0xd { }
VCMPSD_op: "" is imm8=0xd { export 0xd:1; }
VCMPSD_mon: "VCMPGTSD" is imm8=0xe { }
VCMPSD_op: "" is imm8=0xe { export 0xe:1; }
VCMPSD_mon: "VCMPTRUESD" is imm8=0xf { }
VCMPSD_op: "" is imm8=0xf { export 0xf:1; }
VCMPSD_mon: "VCMPEQ_OSSD" is imm8=0x10 { }
VCMPSD_op: "" is imm8=0x10 { export 0x10:1; }
VCMPSD_mon: "VCMPLT_OQSD" is imm8=0x11 { }
VCMPSD_op: "" is imm8=0x11 { export 0x11:1; }
VCMPSD_mon: "VCMPLE_OQSD" is imm8=0x12 { }
VCMPSD_op: "" is imm8=0x12 { export 0x12:1; }
VCMPSD_mon: "VCMPUNORD_SSD" is imm8=0x13 { }
VCMPSD_op: "" is imm8=0x13 { export 0x13:1; }
VCMPSD_mon: "VCMPNEQ_USSD" is imm8=0x14 { }
VCMPSD_op: "" is imm8=0x14 { export 0x14:1; }
VCMPSD_mon: "VCMPNLT_UQSD" is imm8=0x15 { }
VCMPSD_op: "" is imm8=0x15 { export 0x15:1; }
VCMPSD_mon: "VCMPNLE_UQSD" is imm8=0x16 { }
VCMPSD_op: "" is imm8=0x16 { export 0x16:1; }
VCMPSD_mon: "VCMPORD_SSD" is imm8=0x17 { }
VCMPSD_op: "" is imm8=0x17 { export 0x17:1; }
VCMPSD_mon: "VCMPEQ_USSD" is imm8=0x18 { }
VCMPSD_op: "" is imm8=0x18 { export 0x18:1; }
VCMPSD_mon: "VCMPNGE_UQSD" is imm8=0x19 { }
VCMPSD_op: "" is imm8=0x19 { export 0x19:1; }
VCMPSD_mon: "VCMPNGT_UQSD" is imm8=0x1a { }
VCMPSD_op: "" is imm8=0x1a { export 0x1a:1; }
VCMPSD_mon: "VCMPFALSE_OSSD" is imm8=0x1b { }
VCMPSD_op: "" is imm8=0x1b { export 0x1b:1; }
VCMPSD_mon: "VCMPNEQ_OSSD" is imm8=0x1c { }
VCMPSD_op: "" is imm8=0x1c { export 0x1c:1; }
VCMPSD_mon: "VCMPGE_OQSD" is imm8=0x1d { }
VCMPSD_op: "" is imm8=0x1d { export 0x1d:1; }
VCMPSD_mon: "VCMPGT_OQSD" is imm8=0x1e { }
VCMPSD_op: "" is imm8=0x1e { export 0x1e:1; }
VCMPSD_mon: "VCMPTRUE_USSD" is imm8=0x1f { }
VCMPSD_op: "" is imm8=0x1f { export 0x1f:1; }
VCMPSD_mon: "VCMPSD" is imm8 { }
VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
define pcodeop vcmpsd_avx ;
:^VCMPSD_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m64^VCMPSD_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m64; VCMPSD_mon & VCMPSD_op
{
	local tmp:16 = vcmpsd_avx( vexVVVV_XmmReg, XmmReg2_m64, VCMPSD_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CMPSS 3-177 PAGE 747 LINE 40390
VCMPSS_mon: "VCMPEQSS" is imm8=0x0 { }
VCMPSS_op: "" is imm8=0x0 { export 0x0:1; }
VCMPSS_mon: "VCMPLTSS" is imm8=0x1 { }
VCMPSS_op: "" is imm8=0x1 { export 0x1:1; }
VCMPSS_mon: "VCMPLESS" is imm8=0x2 { }
VCMPSS_op: "" is imm8=0x2 { export 0x2:1; }
VCMPSS_mon: "VCMPUNORDSS" is imm8=0x3 { }
VCMPSS_op: "" is imm8=0x3 { export 0x3:1; }
VCMPSS_mon: "VCMPNEQSS" is imm8=0x4 { }
VCMPSS_op: "" is imm8=0x4 { export 0x4:1; }
VCMPSS_mon: "VCMPNLTSS" is imm8=0x5 { }
VCMPSS_op: "" is imm8=0x5 { export 0x5:1; }
VCMPSS_mon: "VCMPNLESS" is imm8=0x6 { }
VCMPSS_op: "" is imm8=0x6 { export 0x6:1; }
VCMPSS_mon: "VCMPORDSS" is imm8=0x7 { }
VCMPSS_op: "" is imm8=0x7 { export 0x7:1; }
VCMPSS_mon: "VCMPEQ_UQSS" is imm8=0x8 { }
VCMPSS_op: "" is imm8=0x8 { export 0x8:1; }
VCMPSS_mon: "VCMPNGESS" is imm8=0x9 { }
VCMPSS_op: "" is imm8=0x9 { export 0x9:1; }
VCMPSS_mon: "VCMPNGTSS" is imm8=0xa { }
VCMPSS_op: "" is imm8=0xa { export 0xa:1; }
VCMPSS_mon: "VCMPFALSESS" is imm8=0xb { }
VCMPSS_op: "" is imm8=0xb { export 0xb:1; }
VCMPSS_mon: "VCMPNEQ_OQSS" is imm8=0xc { }
VCMPSS_op: "" is imm8=0xc { export 0xc:1; }
VCMPSS_mon: "VCMPGESS" is imm8=0xd { }
VCMPSS_op: "" is imm8=0xd { export 0xd:1; }
VCMPSS_mon: "VCMPGTSS" is imm8=0xe { }
VCMPSS_op: "" is imm8=0xe { export 0xe:1; }
VCMPSS_mon: "VCMPTRUESS" is imm8=0xf { }
VCMPSS_op: "" is imm8=0xf { export 0xf:1; }
VCMPSS_mon: "VCMPEQ_OSSS" is imm8=0x10 { }
VCMPSS_op: "" is imm8=0x10 { export 0x10:1; }
VCMPSS_mon: "VCMPLT_OQSS" is imm8=0x11 { }
VCMPSS_op: "" is imm8=0x11 { export 0x11:1; }
VCMPSS_mon: "VCMPLE_OQSS" is imm8=0x12 { }
VCMPSS_op: "" is imm8=0x12 { export 0x12:1; }
VCMPSS_mon: "VCMPUNORD_SSS" is imm8=0x13 { }
VCMPSS_op: "" is imm8=0x13 { export 0x13:1; }
VCMPSS_mon: "VCMPNEQ_USSS" is imm8=0x14 { }
VCMPSS_op: "" is imm8=0x14 { export 0x14:1; }
VCMPSS_mon: "VCMPNLT_UQSS" is imm8=0x15 { }
VCMPSS_op: "" is imm8=0x15 { export 0x15:1; }
VCMPSS_mon: "VCMPNLE_UQSS" is imm8=0x16 { }
VCMPSS_op: "" is imm8=0x16 { export 0x16:1; }
VCMPSS_mon: "VCMPORD_SSS" is imm8=0x17 { }
VCMPSS_op: "" is imm8=0x17 { export 0x17:1; }
VCMPSS_mon: "VCMPEQ_USSS" is imm8=0x18 { }
VCMPSS_op: "" is imm8=0x18 { export 0x18:1; }
VCMPSS_mon: "VCMPNGE_UQSS" is imm8=0x19 { }
VCMPSS_op: "" is imm8=0x19 { export 0x19:1; }
VCMPSS_mon: "VCMPNGT_UQSS" is imm8=0x1a { }
VCMPSS_op: "" is imm8=0x1a { export 0x1a:1; }
VCMPSS_mon: "VCMPFALSE_OSSS" is imm8=0x1b { }
VCMPSS_op: "" is imm8=0x1b { export 0x1b:1; }
VCMPSS_mon: "VCMPNEQ_OSSS" is imm8=0x1c { }
VCMPSS_op: "" is imm8=0x1c { export 0x1c:1; }
VCMPSS_mon: "VCMPGE_OQSS" is imm8=0x1d { }
VCMPSS_op: "" is imm8=0x1d { export 0x1d:1; }
VCMPSS_mon: "VCMPGT_OQSS" is imm8=0x1e { }
VCMPSS_op: "" is imm8=0x1e { export 0x1e:1; }
VCMPSS_mon: "VCMPTRUE_USSS" is imm8=0x1f { }
VCMPSS_op: "" is imm8=0x1f { export 0x1f:1; }
VCMPSS_mon: "VCMPSS" is imm8 { }
VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
define pcodeop vcmpss_avx ;
:^VCMPSS_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m32^VCMPSS_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m32; VCMPSS_mon & VCMPSS_op
{
	local tmp:16 = vcmpss_avx( vexVVVV_XmmReg, XmmReg2_m32, VCMPSS_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# COMISD 3-186 PAGE 756 LINE 40860
define pcodeop vcomisd_avx ;
:VCOMISD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2F; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcomisd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# COMISS 3-188 PAGE 758 LINE 40938
define pcodeop vcomiss_avx ;
:VCOMISS XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2F; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vcomiss_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTDQ2PD 3-228 PAGE 798 LINE 43074
define pcodeop vcvtdq2pd_avx ;
:VCVTDQ2PD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcvtdq2pd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTDQ2PD 3-228 PAGE 798 LINE 43077
:VCVTDQ2PD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vcvtdq2pd_avx( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CVTDQ2PS 3-232 PAGE 802 LINE 43242
define pcodeop vcvtdq2ps_avx ;
:VCVTDQ2PS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtdq2ps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTDQ2PS 3-232 PAGE 802 LINE 43245
:VCVTDQ2PS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vcvtdq2ps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CVTPD2DQ 3-235 PAGE 805 LINE 43408
define pcodeop vcvtpd2dq_avx ;
:VCVTPD2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtpd2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTPD2DQ 3-235 PAGE 805 LINE 43411
:VCVTPD2DQ XmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & YmmReg2_m256
{
	local tmp:16 = vcvtpd2dq_avx( YmmReg2_m256 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTPD2PS 3-240 PAGE 810 LINE 43643
define pcodeop vcvtpd2ps_avx ;
:VCVTPD2PS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtpd2ps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTPD2PS 3-240 PAGE 810 LINE 43646
:VCVTPD2PS XmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; (XmmReg1 & YmmReg1) ... & YmmReg2_m256
{
	local tmp:16 = vcvtpd2ps_avx( YmmReg2_m256 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTPS2DQ 3-246 PAGE 816 LINE 43927
define pcodeop vcvtps2dq_avx ;
:VCVTPS2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtps2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTPS2DQ 3-246 PAGE 816 LINE 43930
:VCVTPS2DQ YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vcvtps2dq_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CVTPS2PD 3-249 PAGE 819 LINE 44098
define pcodeop vcvtps2pd_avx ;
:VCVTPS2PD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcvtps2pd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTPS2PD 3-249 PAGE 819 LINE 44101
:VCVTPS2PD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vcvtps2pd_avx( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VCVTPH2PS 5-33 PAGE 1857 LINE 96839
define pcodeop vcvtph2ps_f16c ;
:VCVTPH2PS XmmReg1, XmmReg2_m64 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
        local tmp:16 = vcvtph2ps_f16c( XmmReg2_m64 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}

# VCVTPH2PS 5-33 PAGE 1857 LINE 96842
:VCVTPH2PS YmmReg1, XmmReg2_m128 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; YmmReg1 ... & XmmReg2_m128
{
        YmmReg1 = vcvtph2ps_f16c( XmmReg2_m128 );
        # TODO ZmmReg1 = zext(YmmReg1)
}

# VCVTPS2PH 5-36 PAGE 1860 LINE 96992
define pcodeop vcvtps2ph_f16c ;
:VCVTPS2PH XmmReg2_m64, XmmReg1, imm8 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; XmmReg1 ... & XmmReg2_m64; imm8
{
        XmmReg2_m64 = vcvtps2ph_f16c( XmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}

# VCVTPS2PH 5-36 PAGE 1860 LINE 96995
:VCVTPS2PH XmmReg2_m128, YmmReg1, imm8 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; YmmReg1 ... & XmmReg2_m128; imm8
{
        XmmReg2_m128 = vcvtps2ph_f16c( YmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}


# CVTSD2SI 3-253 PAGE 823 LINE 44315
define pcodeop vcvtsd2si_avx ;
:VCVTSD2SI Reg32, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W0); byte=0x2D; Reg32 ... & XmmReg2_m64
{
	Reg32 = vcvtsd2si_avx( XmmReg2_m64 );
	# TODO Reg64 = zext(Reg32)
}

# CVTSD2SI 3-253 PAGE 823 LINE 44317
@ifdef IA64
:VCVTSD2SI Reg64, XmmReg2_m64 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W1); byte=0x2D; Reg64 ... & XmmReg2_m64
{
	Reg64 = vcvtsd2si_avx( XmmReg2_m64 );
}
@endif

# CVTSD2SS 3-255 PAGE 825 LINE 44414
define pcodeop vcvtsd2ss_avx ;
:VCVTSD2SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcvtsd2ss_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTSI2SD 3-257 PAGE 827 LINE 44516
define pcodeop vcvtsi2sd_avx ;
:VCVTSI2SD XmmReg1, vexVVVV_XmmReg, rm32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2A; (XmmReg1 & YmmReg1) ... & rm32
{
	local tmp:16 = vcvtsi2sd_avx( vexVVVV_XmmReg, rm32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTSI2SD 3-257 PAGE 827 LINE 44519
@ifdef IA64
:VCVTSI2SD XmmReg1, vexVVVV_XmmReg, rm64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x2A; (XmmReg1 & YmmReg1) ... & rm64
{
	local tmp:16 = vcvtsi2sd_avx( vexVVVV_XmmReg, rm64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
@endif

# CVTSI2SS 3-259 PAGE 829 LINE 44632
define pcodeop vcvtsi2ss_avx ;
:VCVTSI2SS XmmReg1, vexVVVV_XmmReg, rm32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2A; (XmmReg1 & YmmReg1) ... & rm32
{
	local tmp:16 = vcvtsi2ss_avx( vexVVVV_XmmReg, rm32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTSI2SS 3-259 PAGE 829 LINE 44634
@ifdef IA64
:VCVTSI2SS XmmReg1, vexVVVV_XmmReg, rm64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x2A; (XmmReg1 & YmmReg1) ... & rm64
{
	local tmp:16 = vcvtsi2ss_avx( vexVVVV_XmmReg, rm64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
@endif

# CVTSS2SD 3-261 PAGE 831 LINE 44744
define pcodeop vcvtss2sd_avx ;
:VCVTSS2SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vcvtss2sd_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTSS2SI 3-263 PAGE 833 LINE 44835
define pcodeop vcvtss2si_avx ;
:VCVTSS2SI Reg32, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W0); byte=0x2D; Reg32 ... & XmmReg2_m32
{
	Reg32 = vcvtss2si_avx( XmmReg2_m32 );
	# TODO Reg64 = zext(Reg32)
}

# CVTSS2SI 3-263 PAGE 833 LINE 44837
@ifdef IA64
:VCVTSS2SI Reg64, XmmReg2_m32 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W1); byte=0x2D; Reg64 ... & XmmReg2_m32
{
	Reg64 = vcvtss2si_avx( XmmReg2_m32 );
}
@endif

# CVTTPD2DQ 3-265 PAGE 835 LINE 44930
define pcodeop vcvttpd2dq_avx ;
:VCVTTPD2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvttpd2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTTPD2DQ 3-265 PAGE 835 LINE 44933
:VCVTTPD2DQ XmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & YmmReg2_m256
{
	local tmp:16 = vcvttpd2dq_avx( YmmReg2_m256 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTTPS2DQ 3-270 PAGE 840 LINE 45163
define pcodeop vcvttps2dq_avx ;
:VCVTTPS2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvttps2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# CVTTPS2DQ 3-270 PAGE 840 LINE 45166
:VCVTTPS2DQ YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vcvttps2dq_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# CVTTSD2SI 3-274 PAGE 844 LINE 45379
define pcodeop vcvttsd2si_avx ;
:VCVTTSD2SI Reg32, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W0); byte=0x2C; Reg32 ... & XmmReg2_m64
{
	Reg32 = vcvttsd2si_avx( XmmReg2_m64 );
	# TODO Reg64 = zext(Reg32)
}

# CVTTSD2SI 3-274 PAGE 844 LINE 45382
@ifdef IA64
:VCVTTSD2SI Reg64, XmmReg2_m64 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W1); byte=0x2C; Reg64 ... & XmmReg2_m64
{
	Reg64 = vcvttsd2si_avx( XmmReg2_m64 );
}
@endif

# CVTTSS2SI 3-276 PAGE 846 LINE 45473
define pcodeop vcvttss2si_avx ;
:VCVTTSS2SI Reg32, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W0); byte=0x2C; Reg32 ... & XmmReg2_m32
{
	Reg32 = vcvttss2si_avx( XmmReg2_m32 );
	# TODO Reg64 = zext(Reg32)
}

# CVTTSS2SI 3-276 PAGE 846 LINE 45476
@ifdef IA64
:VCVTTSS2SI Reg64, XmmReg2_m32 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W1); byte=0x2C; Reg64 ... & XmmReg2_m32
{
	Reg64 = vcvttss2si_avx( XmmReg2_m32 );
}
@endif

# DIVPD 3-288 PAGE 858 LINE 46023
define pcodeop vdivpd_avx ;
:VDIVPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vdivpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# DIVPD 3-288 PAGE 858 LINE 46026
:VDIVPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vdivpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# DIVPS 3-291 PAGE 861 LINE 46164
define pcodeop vdivps_avx ;
:VDIVPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vdivps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# DIVPS 3-291 PAGE 861 LINE 46167
:VDIVPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vdivps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# DIVSD 3-294 PAGE 864 LINE 46312
define pcodeop vdivsd_avx ;
:VDIVSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vdivsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# DIVSS 3-296 PAGE 866 LINE 46410
define pcodeop vdivss_avx ;
:VDIVSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vdivss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# DPPD 3-298 PAGE 868 LINE 46509
define pcodeop vdppd_avx ;
:VDPPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x41; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vdppd_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# DPPS 3-300 PAGE 870 LINE 46612
define pcodeop vdpps_avx ;
:VDPPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x40; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vdpps_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# DPPS 3-300 PAGE 870 LINE 46616
:VDPPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x40; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vdpps_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# EXTRACTPS 3-307 PAGE 877 LINE 46978
define pcodeop vextractps_avx ;
:VEXTRACTPS rm32, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x17; XmmReg1 ... & rm32; imm8
{
	rm32 = vextractps_avx( XmmReg1, imm8:1 );
}

# HADDPD 3-427 PAGE 997 LINE 52447
define pcodeop vhaddpd_avx ;
:VHADDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhaddpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# HADDPD 3-427 PAGE 997 LINE 52450
:VHADDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhaddpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# HADDPS 3-430 PAGE 1000 LINE 52586
define pcodeop vhaddps_avx ;
:VHADDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhaddps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# HADDPS 3-430 PAGE 1000 LINE 52589
:VHADDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhaddps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# HSUBPD 3-434 PAGE 1004 LINE 52795
define pcodeop vhsubpd_avx ;
:VHSUBPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhsubpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# HSUBPD 3-434 PAGE 1004 LINE 52798
:VHSUBPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhsubpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# HSUBPS 3-437 PAGE 1007 LINE 52933
define pcodeop vhsubps_avx ;
:VHSUBPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhsubps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# HSUBPS 3-437 PAGE 1007 LINE 52936
:VHSUBPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhsubps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# INSERTPS 3-454 PAGE 1024 LINE 53780
define pcodeop vinsertps_avx ;
:VINSERTPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x21; (XmmReg1 & YmmReg1) ... & XmmReg2_m32; imm8
{
	local tmp:16 = vinsertps_avx( vexVVVV_XmmReg, XmmReg2_m32, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# LDDQU 3-518 PAGE 1088 LINE 57123
define pcodeop vlddqu_avx ;
:VLDDQU XmmReg1, m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xF0; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vlddqu_avx( m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# LDDQU 3-518 PAGE 1088 LINE 57126
:VLDDQU YmmReg1, m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xF0; YmmReg1 ... & m256
{
	YmmReg1 = vlddqu_avx( m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# LDMXCSR 3-520 PAGE 1090 LINE 57208
define pcodeop vldmxcsr_avx ;
:VLDMXCSR m32 is $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0xAE; reg_opcode=2 ... & m32
{
	vldmxcsr_avx( m32 );
	# TODO missing destination or side effects
}

# MASKMOVDQU 4-8 PAGE 1128 LINE 59041
define pcodeop vmaskmovdqu_avx ;
:VMASKMOVDQU XmmReg1, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xF7; XmmReg1 & (mod=0x3 & XmmReg2)
{
	vmaskmovdqu_avx( XmmReg1, XmmReg2 );
	# TODO missing destination or side effects
}

# MAXPD 4-12 PAGE 1132 LINE 59201
define pcodeop vmaxpd_avx ;
:VMAXPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmaxpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MAXPD 4-12 PAGE 1132 LINE 59203
:VMAXPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmaxpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MAXPS 4-15 PAGE 1135 LINE 59350
define pcodeop vmaxps_avx ;
:VMAXPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmaxps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MAXPS 4-15 PAGE 1135 LINE 59353
:VMAXPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmaxps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MAXSD 4-18 PAGE 1138 LINE 59503
define pcodeop vmaxsd_avx ;
:VMAXSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmaxsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MAXSS 4-20 PAGE 1140 LINE 59606
define pcodeop vmaxss_avx ;
:VMAXSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vmaxss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MINPD 4-23 PAGE 1143 LINE 59765
define pcodeop vminpd_avx ;
:VMINPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vminpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MINPD 4-23 PAGE 1143 LINE 59768
:VMINPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vminpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MINPS 4-26 PAGE 1146 LINE 59909
define pcodeop vminps_avx ;
:VMINPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vminps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MINPS 4-26 PAGE 1146 LINE 59912
:VMINPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vminps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MINSD 4-29 PAGE 1149 LINE 60061
define pcodeop vminsd_avx ;
:VMINSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vminsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MINSS 4-31 PAGE 1151 LINE 60164
define pcodeop vminss_avx ;
:VMINSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vminss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVD/MOVQ 4-55 PAGE 1175 LINE 61358
define pcodeop vmovd_avx ;
:VMOVD XmmReg1, rm32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0); byte=0x6E; (XmmReg1 & YmmReg1) ... & rm32
{
	local tmp:16 = vmovd_avx( rm32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVD/MOVQ 4-55 PAGE 1175 LINE 61360
define pcodeop vmovq_avx ;
@ifdef IA64
:VMOVQ XmmReg1, rm64 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W1); byte=0x6E; (XmmReg1 & YmmReg1) ... & rm64
{
	local tmp:16 = vmovq_avx( rm64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
@endif

# MOVD/MOVQ 4-55 PAGE 1175 LINE 61362
:VMOVD rm32, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0); byte=0x7E; XmmReg1 ... & rm32
{
	rm32 = vmovd_avx( XmmReg1 );
}

# MOVD/MOVQ 4-55 PAGE 1175 LINE 61364
@ifdef IA64
:VMOVQ rm64, XmmReg1 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W1); byte=0x7E; XmmReg1 ... & rm64
{
	rm64 = vmovq_avx( XmmReg1 );
}
@endif

# MOVDDUP 4-59 PAGE 1179 LINE 61521
define pcodeop vmovddup_avx ;
:VMOVDDUP XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x12; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmovddup_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVDDUP 4-59 PAGE 1179 LINE 61523
:VMOVDDUP YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x12; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovddup_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVDQU,VMOVDQU8/16/32/64 4-67 PAGE 1187 LINE 61930
define pcodeop vmovdqu_avx ;
:VMOVDQU XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovdqu_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVDQU,VMOVDQU8/16/32/64 4-67 PAGE 1187 LINE 61932
:VMOVDQU XmmReg2_m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; XmmReg1 ... & XmmReg2_m128
{
	XmmReg2_m128 = vmovdqu_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVDQU,VMOVDQU8/16/32/64 4-67 PAGE 1187 LINE 61934
:VMOVDQU YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovdqu_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVDQU,VMOVDQU8/16/32/64 4-67 PAGE 1187 LINE 61936
:VMOVDQU YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = vmovdqu_avx( YmmReg1 );
	# TODO ZmmReg2 = zext(YmmReg2)
}

# MOVHLPS 4-76 PAGE 1196 LINE 62410
define pcodeop vmovhlps_avx ;
:VMOVHLPS XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x12; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
	local tmp:16 = vmovhlps_avx( vexVVVV_XmmReg, XmmReg2 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVHPD 4-78 PAGE 1198 LINE 62483
define pcodeop vmovhpd_avx ;
:VMOVHPD XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x16; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovhpd_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVHPD 4-78 PAGE 1198 LINE 62489
:VMOVHPD m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x17; XmmReg1 ... & m64
{
	m64 = vmovhpd_avx( XmmReg1 );
}

# MOVHPS 4-80 PAGE 1200 LINE 62570
define pcodeop vmovhps_avx ;
:VMOVHPS XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x16; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovhps_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVHPS 4-80 PAGE 1200 LINE 62576
:VMOVHPS m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x17; XmmReg1 ... & m64
{
	m64 = vmovhps_avx( XmmReg1 );
}

# MOVLHPS 4-82 PAGE 1202 LINE 62658
define pcodeop vmovlhps_avx ;
:VMOVLHPS XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x16; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
	local tmp:16 = vmovlhps_avx( vexVVVV_XmmReg, XmmReg2 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVLPD 4-84 PAGE 1204 LINE 62731
define pcodeop vmovlpd_avx ;
:VMOVLPD XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x12; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovlpd_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVLPD 4-84 PAGE 1204 LINE 62737
:VMOVLPD m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x13; XmmReg1 ... & m64
{
	m64 = vmovlpd_avx( XmmReg1 );
}

# MOVLPS 4-86 PAGE 1206 LINE 62816
define pcodeop vmovlps_avx ;
:VMOVLPS XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x12; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovlps_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVLPS 4-86 PAGE 1206 LINE 62822
:VMOVLPS m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x13; XmmReg1 ... & m64
{
	m64 = vmovlps_avx( XmmReg1 );
}

# MOVMSKPD 4-88 PAGE 1208 LINE 62906
define pcodeop vmovmskpd_avx ;
:VMOVMSKPD Reg32, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & XmmReg2)
{
	Reg32 = vmovmskpd_avx( XmmReg2 );
	# TODO Reg64 = zext(Reg32)
}

# MOVMSKPD 4-88 PAGE 1208 LINE 62910
:VMOVMSKPD Reg32, YmmReg2 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & YmmReg2)
{
	Reg32 = vmovmskpd_avx( YmmReg2 );
	# TODO Reg64 = zext(Reg32)
}

# MOVMSKPS 4-90 PAGE 1210 LINE 62986
define pcodeop vmovmskps_avx ;
:VMOVMSKPS Reg32, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & XmmReg2)
{
	Reg32 = vmovmskps_avx( XmmReg2 );
	# TODO Reg64 = zext(Reg32)
}

# MOVMSKPS 4-90 PAGE 1210 LINE 62990
:VMOVMSKPS Reg32, YmmReg2 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & YmmReg2)
{
	Reg32 = vmovmskps_avx( YmmReg2 );
	# TODO Reg64 = zext(Reg32)
}

# MOVNTDQA 4-92 PAGE 1212 LINE 63084
define pcodeop vmovntdqa_avx ;
:VMOVNTDQA XmmReg1, m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x2A; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vmovntdqa_avx( m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVNTDQ 4-94 PAGE 1214 LINE 63187
define pcodeop vmovntdq_avx ;
:VMOVNTDQ m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE7; XmmReg1 ... & m128
{
	m128 = vmovntdq_avx( XmmReg1 );
}

# MOVNTDQ 4-94 PAGE 1214 LINE 63189
:VMOVNTDQ m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE7; YmmReg1 ... & m256
{
	m256 = vmovntdq_avx( YmmReg1 );
}

# MOVNTPD 4-98 PAGE 1218 LINE 63357
define pcodeop vmovntpd_avx ;
:VMOVNTPD m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; XmmReg1 ... & m128
{
	m128 = vmovntpd_avx( XmmReg1 );
}

# MOVNTPD 4-98 PAGE 1218 LINE 63359
:VMOVNTPD m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; YmmReg1 ... & m256
{
	m256 = vmovntpd_avx( YmmReg1 );
}

# MOVNTPS 4-100 PAGE 1220 LINE 63441
define pcodeop vmovntps_avx ;
:VMOVNTPS m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; XmmReg1 ... & m128
{
	m128 = vmovntps_avx( XmmReg1 );
}

# MOVNTPS 4-100 PAGE 1220 LINE 63443
:VMOVNTPS m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; YmmReg1 ... & m256
{
	m256 = vmovntps_avx( YmmReg1 );
}

# MOVQ 4-103 PAGE 1223 LINE 63579
:VMOVQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x7E; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmovq_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVQ 4-103 PAGE 1223 LINE 63585
:VMOVQ XmmReg2_m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xD6; XmmReg1 ... & XmmReg2_m64
{
	XmmReg2_m64 = vmovq_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVSD 4-111 PAGE 1231 LINE 63970
# INFO mnemonic VMOVSD was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVSD 4-111 PAGE 1231 LINE 63972
# INFO mnemonic VMOVSD was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVSD 4-111 PAGE 1231 LINE 63974
# INFO mnemonic VMOVSD was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVSD 4-111 PAGE 1231 LINE 63976
# INFO mnemonic VMOVSD was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVSHDUP 4-114 PAGE 1234 LINE 64126
define pcodeop vmovshdup_avx ;
:VMOVSHDUP XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x16; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovshdup_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVSHDUP 4-114 PAGE 1234 LINE 64128
:VMOVSHDUP YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x16; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovshdup_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVSLDUP 4-117 PAGE 1237 LINE 64280
define pcodeop vmovsldup_avx ;
:VMOVSLDUP XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x12; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovsldup_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVSLDUP 4-117 PAGE 1237 LINE 64282
:VMOVSLDUP YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x12; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovsldup_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVSS 4-120 PAGE 1240 LINE 64433
define pcodeop vmovss_avx ;
:VMOVSS XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x10; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
	local tmp:16 = vmovss_avx( vexVVVV_XmmReg, XmmReg2 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVSS 4-120 PAGE 1240 LINE 64435
:VMOVSS XmmReg1, m32 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & m32
{
	local tmp:16 = vmovss_avx( m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVSS 4-120 PAGE 1240 LINE 64439
:VMOVSS XmmReg2, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x11; XmmReg1 & (mod=0x3 & (XmmReg2 & YmmReg2))
{
	local tmp:16 = vmovss_avx( vexVVVV_XmmReg, XmmReg1 );
	YmmReg2 = zext(tmp);
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVSS 4-120 PAGE 1240 LINE 64441
:VMOVSS m32, XmmReg1 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & m32
{
	m32 = vmovss_avx( XmmReg1 );
}

# MOVUPD 4-126 PAGE 1246 LINE 64687
define pcodeop vmovupd_avx ;
:VMOVUPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovupd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVUPD 4-126 PAGE 1246 LINE 64689
:VMOVUPD XmmReg2_m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & XmmReg2_m128
{
	XmmReg2_m128 = vmovupd_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVUPD 4-126 PAGE 1246 LINE 64691
:VMOVUPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x10; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovupd_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVUPD 4-126 PAGE 1246 LINE 64693
:VMOVUPD YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x11; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = vmovupd_avx( YmmReg1 );
	# TODO ZmmReg2 = zext(YmmReg2)
}

# MOVUPS 4-130 PAGE 1250 LINE 64872
# INFO mnemonic VMOVUPS was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVUPS 4-130 PAGE 1250 LINE 64874
# INFO mnemonic VMOVUPS was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVUPS 4-130 PAGE 1250 LINE 64876
# INFO mnemonic VMOVUPS was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MOVUPS 4-130 PAGE 1250 LINE 64878
# INFO mnemonic VMOVUPS was found in ../../../Processors/x86/data/languages/avx_manual.sinc

# MPSADBW 4-136 PAGE 1256 LINE 65135
define pcodeop vmpsadbw_avx ;
:VMPSADBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x42; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vmpsadbw_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MULPD 4-146 PAGE 1266 LINE 65682
define pcodeop vmulpd_avx ;
:VMULPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmulpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MULPD 4-146 PAGE 1266 LINE 65684
:VMULPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x59; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmulpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MULPS 4-149 PAGE 1269 LINE 65813
define pcodeop vmulps_avx ;
:VMULPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmulps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MULPS 4-149 PAGE 1269 LINE 65815
:VMULPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x59; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmulps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MULSD 4-152 PAGE 1272 LINE 65956
define pcodeop vmulsd_avx ;
:VMULSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmulsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MULSS 4-154 PAGE 1274 LINE 66052
define pcodeop vmulss_avx ;
:VMULSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vmulss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ORPD 4-168 PAGE 1288 LINE 66720
define pcodeop vorpd_avx ;
:VORPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x56; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vorpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ORPD 4-168 PAGE 1288 LINE 66722
:VORPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x56; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vorpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ORPS 4-171 PAGE 1291 LINE 66846
define pcodeop vorps_avx ;
:VORPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x56; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vorps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ORPS 4-171 PAGE 1291 LINE 66848
:VORPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x56; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vorps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PABSB/PABSW/PABSD/PABSQ 4-180 PAGE 1300 LINE 67302
define pcodeop vpabsb_avx ;
:VPABSB XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpabsb_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PABSB/PABSW/PABSD/PABSQ 4-180 PAGE 1300 LINE 67305
define pcodeop vpabsw_avx ;
:VPABSW XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpabsw_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PABSB/PABSW/PABSD/PABSQ 4-180 PAGE 1300 LINE 67308
define pcodeop vpabsd_avx ;
:VPABSD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpabsd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PACKSSWB/PACKSSDW 4-186 PAGE 1306 LINE 67629
define pcodeop vpacksswb_avx ;
:VPACKSSWB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x63; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpacksswb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PACKSSWB/PACKSSDW 4-186 PAGE 1306 LINE 67633
define pcodeop vpackssdw_avx ;
:VPACKSSDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpackssdw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PACKUSDW 4-194 PAGE 1314 LINE 68086
define pcodeop vpackusdw_avx ;
:VPACKUSDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x2B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpackusdw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PACKUSWB 4-199 PAGE 1319 LINE 68366
define pcodeop vpackuswb_avx ;
:VPACKUSWB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x67; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpackuswb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68658
define pcodeop vpaddb_avx ;
:VPADDB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68660
define pcodeop vpaddw_avx ;
:VPADDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFD; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68662
define pcodeop vpaddd_avx ;
:VPADDD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68664
define pcodeop vpaddq_avx ;
:VPADDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD4; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDSB/PADDSW 4-211 PAGE 1331 LINE 69040
define pcodeop vpaddsb_avx ;
:VPADDSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDSB/PADDSW 4-211 PAGE 1331 LINE 69042
define pcodeop vpaddsw_avx ;
:VPADDSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xED; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDUSB/PADDUSW 4-215 PAGE 1335 LINE 69257
define pcodeop vpaddusb_avx ;
:VPADDUSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddusb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PADDUSB/PADDUSW 4-215 PAGE 1335 LINE 69260
define pcodeop vpaddusw_avx ;
:VPADDUSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDD; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddusw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PALIGNR 4-219 PAGE 1339 LINE 69485
define pcodeop vpalignr_avx ;
:VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PAND 4-223 PAGE 1343 LINE 69678
define pcodeop vpand_avx ;
:VPAND XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpand_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PANDN 4-226 PAGE 1346 LINE 69854
define pcodeop vpandn_avx ;
:VPANDN XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDF; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpandn_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PAVGB/PAVGW 4-230 PAGE 1350 LINE 70085
define pcodeop vpavgb_avx ;
:VPAVGB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE0; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpavgb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PAVGB/PAVGW 4-230 PAGE 1350 LINE 70088
define pcodeop vpavgw_avx ;
:VPAVGW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE3; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpavgw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PBLENDVB 4-234 PAGE 1354 LINE 70296
define pcodeop vpblendvb_avx ;
:VPBLENDVB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x4C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; Xmm_imm8_7_4
{
	local tmp:16 = vpblendvb_avx( vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PBLENDW 4-238 PAGE 1358 LINE 70522
define pcodeop vpblendw_avx ;
:VPBLENDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpblendw_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}




# PCMPEQB/PCMPEQW/PCMPEQD 4-244 PAGE 1364 LINE 70821
define pcodeop vpcmpeqb_avx ;
:VPCMPEQB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x74; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpeqb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPEQB/PCMPEQW/PCMPEQD 4-244 PAGE 1364 LINE 70824
define pcodeop vpcmpeqw_avx ;
:VPCMPEQW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x75; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpeqw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPEQB/PCMPEQW/PCMPEQD 4-244 PAGE 1364 LINE 70827
define pcodeop vpcmpeqd_avx ;
:VPCMPEQD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x76; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpeqd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPESTRI 4-253 PAGE 1373 LINE 71311
define pcodeop vpcmpestri_avx ;
:VPCMPESTRI XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A); byte=0x61; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpestri_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}

# PCMPESTRM 4-255 PAGE 1375 LINE 71395
define pcodeop vpcmpestrm_avx ;
:VPCMPESTRM XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A); byte=0x60; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpestrm_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}

# PCMPGTB/PCMPGTW/PCMPGTD 4-257 PAGE 1377 LINE 71499
define pcodeop vpcmpgtb_avx ;
:VPCMPGTB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x64; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPGTB/PCMPGTW/PCMPGTD 4-257 PAGE 1377 LINE 71502
define pcodeop vpcmpgtw_avx ;
:VPCMPGTW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x65; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPGTB/PCMPGTW/PCMPGTD 4-257 PAGE 1377 LINE 71505
define pcodeop vpcmpgtd_avx ;
:VPCMPGTD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x66; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPGTQ 4-263 PAGE 1383 LINE 71833
define pcodeop vpcmpgtq_avx ;
:VPCMPGTQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x37; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PCMPISTRI 4-266 PAGE 1386 LINE 71966
define pcodeop vpcmpistri_avx ;
:VPCMPISTRI XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x63; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpistri_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}

# PCMPISTRM 4-268 PAGE 1388 LINE 72052
define pcodeop vpcmpistrm_avx ;
:VPCMPISTRM XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x62; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpistrm_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}

# PEXTRB/PEXTRD/PEXTRQ 4-274 PAGE 1394 LINE 72322
define pcodeop vpextrb_avx ;
:VPEXTRB Reg32_m8, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x14; XmmReg1 ... & Reg32_m8; imm8
{
	Reg32_m8 = vpextrb_avx( XmmReg1, imm8:1 );
	# TODO Reg64 = zext(Reg32)
}

# PEXTRB/PEXTRD/PEXTRQ 4-274 PAGE 1394 LINE 72326
define pcodeop vpextrd_avx ;
:VPEXTRD rm32, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x16; XmmReg1 ... & rm32; imm8
{
	rm32 = vpextrd_avx( XmmReg1, imm8:1 );
}

# PEXTRB/PEXTRD/PEXTRQ 4-274 PAGE 1394 LINE 72330
define pcodeop vpextrq_avx ;
@ifdef IA64
:VPEXTRQ rm64, XmmReg1, imm8 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W1); byte=0x16; XmmReg1 ... & rm64; imm8
{
	rm64 = vpextrq_avx( XmmReg1, imm8:1 );
}
@endif

# PEXTRW 4-277 PAGE 1397 LINE 72478
define pcodeop vpextrw_avx ;
:VPEXTRW Reg32, XmmReg2, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0); byte=0xC5; Reg32 & (mod=0x3 & XmmReg2); imm8
{
	Reg32 = vpextrw_avx( XmmReg2, imm8:1 );
	# TODO Reg64 = zext(Reg32)
}

# PEXTRW 4-277 PAGE 1397 LINE 72483
:VPEXTRW Reg32_m16, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x15; XmmReg1 ... & Reg32_m16; imm8
{
	Reg32_m16 = vpextrw_avx( XmmReg1, imm8:1 );
	# TODO Reg64 = zext(Reg32)
}

# PHADDW/PHADDD 4-280 PAGE 1400 LINE 72627
define pcodeop vphaddw_avx ;
:VPHADDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x01; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphaddw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PHADDW/PHADDD 4-280 PAGE 1400 LINE 72630
define pcodeop vphaddd_avx ;
:VPHADDD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x02; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphaddd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PHADDSW 4-284 PAGE 1404 LINE 72821
define pcodeop vphaddsw_avx ;
:VPHADDSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x03; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphaddsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PHMINPOSUW 4-286 PAGE 1406 LINE 72939
define pcodeop vphminposuw_avx ;
:VPHMINPOSUW XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x41; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphminposuw_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PHSUBW/PHSUBD 4-288 PAGE 1408 LINE 73032
define pcodeop vphsubw_avx ;
:VPHSUBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x05; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphsubw_avx( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PHSUBW/PHSUBD 4-288 PAGE 1408 LINE 73035
define pcodeop vphsubd_avx ;
:VPHSUBD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x06; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphsubd_avx( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PHSUBSW 4-291 PAGE 1411 LINE 73197
define pcodeop vphsubsw_avx ;
:VPHSUBSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x07; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphsubsw_avx( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PINSRB/PINSRD/PINSRQ 4-293 PAGE 1413 LINE 73321
define pcodeop vpinsrb_avx ;
:VPINSRB XmmReg1, vexVVVV_XmmReg, Reg32_m8, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x20; (XmmReg1 & YmmReg1) ... & Reg32_m8; imm8
{
	local tmp:16 = vpinsrb_avx( vexVVVV_XmmReg, Reg32_m8, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PINSRB/PINSRD/PINSRQ 4-293 PAGE 1413 LINE 73324
define pcodeop vpinsrd_avx ;
:VPINSRD XmmReg1, vexVVVV_XmmReg, rm32, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x22; (XmmReg1 & YmmReg1) ... & rm32; imm8
{
	local tmp:16 = vpinsrd_avx( vexVVVV_XmmReg, rm32, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PINSRB/PINSRD/PINSRQ 4-293 PAGE 1413 LINE 73327
define pcodeop vpinsrq_avx ;
@ifdef IA64
:VPINSRQ XmmReg1, vexVVVV_XmmReg, rm64, imm8 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x22; (XmmReg1 & YmmReg1) ... & rm64; imm8
{
	local tmp:16 = vpinsrq_avx( vexVVVV_XmmReg, rm64, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
@endif

# PINSRW 4-296 PAGE 1416 LINE 73446
define pcodeop vpinsrw_avx ;
:VPINSRW XmmReg1, vexVVVV_XmmReg, Reg32_m16, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xC4; (XmmReg1 & YmmReg1) ... & Reg32_m16; imm8
{
	local tmp:16 = vpinsrw_avx( vexVVVV_XmmReg, Reg32_m16, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMADDUBSW 4-298 PAGE 1418 LINE 73552
define pcodeop vpmaddubsw_avx ;
:VPMADDUBSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x04; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaddubsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMADDWD 4-301 PAGE 1421 LINE 73700
define pcodeop vpmaddwd_avx ;
:VPMADDWD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF5; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaddwd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMAXSB/PMAXSW/PMAXSD/PMAXSQ 4-304 PAGE 1424 LINE 73882
define pcodeop vpmaxsb_avx ;
:VPMAXSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMAXSB/PMAXSW/PMAXSD/PMAXSQ 4-304 PAGE 1424 LINE 73885
define pcodeop vpmaxsw_avx ;
:VPMAXSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMAXSB/PMAXSW/PMAXSD/PMAXSQ 4-304 PAGE 1424 LINE 73888
define pcodeop vpmaxsd_avx ;
:VPMAXSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxsd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMAXUB/PMAXUW 4-311 PAGE 1431 LINE 74283
define pcodeop vpmaxub_avx ;
:VPMAXUB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0xDE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxub_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMAXUB/PMAXUW 4-311 PAGE 1431 LINE 74286
define pcodeop vpmaxuw_avx ;
:VPMAXUW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x3E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxuw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMAXUD/PMAXUQ 4-316 PAGE 1436 LINE 74534
define pcodeop vpmaxud_avx ;
:VPMAXUD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxud_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMINSB/PMINSW 4-320 PAGE 1440 LINE 74736
define pcodeop vpminsb_avx ;
:VPMINSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x38; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMINSB/PMINSW 4-320 PAGE 1440 LINE 74739
define pcodeop vpminsw_avx ;
:VPMINSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0xEA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMINSD/PMINSQ 4-325 PAGE 1445 LINE 74989
define pcodeop vpminsd_avx ;
:VPMINSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x39; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminsd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMINUB/PMINUW 4-329 PAGE 1449 LINE 75195
define pcodeop vpminub_avx ;
:VPMINUB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0xDA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminub_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMINUB/PMINUW 4-329 PAGE 1449 LINE 75198
define pcodeop vpminuw_avx ;
:VPMINUW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x3A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminuw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMINUD/PMINUQ 4-334 PAGE 1454 LINE 75445
define pcodeop vpminud_avx ;
:VPMINUD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminud_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75770
define pcodeop vpmovsxbw_avx ;
:VPMOVSXBW XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x20; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovsxbw_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75772
define pcodeop vpmovsxbd_avx ;
:VPMOVSXBD XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x21; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovsxbd_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75774
define pcodeop vpmovsxbq_avx ;
:VPMOVSXBQ XmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x22; (XmmReg1 & YmmReg1) ... & XmmReg2_m16
{
	local tmp:16 = vpmovsxbq_avx( XmmReg2_m16 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75776
define pcodeop vpmovsxwd_avx ;
:VPMOVSXWD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x23; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovsxwd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75778
define pcodeop vpmovsxwq_avx ;
:VPMOVSXWQ XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x24; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovsxwq_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75780
define pcodeop vpmovsxdq_avx ;
:VPMOVSXDQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x25; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovsxdq_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76285
define pcodeop vpmovzxbw_avx ;
:VPMOVZXBW XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x30; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovzxbw_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76288
define pcodeop vpmovzxbd_avx ;
:VPMOVZXBD XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x31; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovzxbd_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76291
define pcodeop vpmovzxbq_avx ;
:VPMOVZXBQ XmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x32; (XmmReg1 & YmmReg1) ... & XmmReg2_m16
{
	local tmp:16 = vpmovzxbq_avx( XmmReg2_m16 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76294
define pcodeop vpmovzxwd_avx ;
:VPMOVZXWD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x33; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovzxwd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76297
define pcodeop vpmovzxwq_avx ;
:VPMOVZXWQ XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x34; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovzxwq_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76301
define pcodeop vpmovzxdq_avx ;
:VPMOVZXDQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x35; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovzxdq_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULDQ 4-359 PAGE 1479 LINE 76788
define pcodeop vpmuldq_avx ;
:VPMULDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x28; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmuldq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULHRSW 4-362 PAGE 1482 LINE 76928
define pcodeop vpmulhrsw_avx ;
:VPMULHRSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulhrsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULHUW 4-366 PAGE 1486 LINE 77141
define pcodeop vpmulhuw_avx ;
:VPMULHUW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE4; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulhuw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULHW 4-370 PAGE 1490 LINE 77370
define pcodeop vpmulhw_avx ;
:VPMULHW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE5; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulhw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULLD/PMULLQ 4-374 PAGE 1494 LINE 77576
define pcodeop vpmulld_avx ;
:VPMULLD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x40; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulld_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULLW 4-378 PAGE 1498 LINE 77775
define pcodeop vpmullw_avx ;
:VPMULLW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD5; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmullw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PMULUDQ 4-382 PAGE 1502 LINE 77969
define pcodeop vpmuludq_avx ;
:VPMULUDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF4; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmuludq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# POR 4-399 PAGE 1519 LINE 78850
define pcodeop vpor_avx ;
:VPOR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpor_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSADBW 4-408 PAGE 1528 LINE 79240
define pcodeop vpsadbw_avx ;
:VPSADBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsadbw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSHUFB 4-412 PAGE 1532 LINE 79460
define pcodeop vpshufb_avx ;
:VPSHUFB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x00; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpshufb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSHUFD 4-416 PAGE 1536 LINE 79651
define pcodeop vpshufd_avx ;
:VPSHUFD XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x70; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpshufd_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSHUFHW 4-420 PAGE 1540 LINE 79857
define pcodeop vpshufhw_avx ;
:VPSHUFHW XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x70; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpshufhw_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSHUFLW 4-423 PAGE 1543 LINE 80032
define pcodeop vpshuflw_avx ;
:VPSHUFLW XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x70; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpshuflw_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSIGNB/PSIGNW/PSIGND 4-427 PAGE 1547 LINE 80269
define pcodeop vpsignb_avx ;
:VPSIGNB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x08; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsignb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSIGNB/PSIGNW/PSIGND 4-427 PAGE 1547 LINE 80272
define pcodeop vpsignw_avx ;
:VPSIGNW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x09; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsignw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSIGNB/PSIGNW/PSIGND 4-427 PAGE 1547 LINE 80275
define pcodeop vpsignd_avx ;
:VPSIGND XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsignd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSLLDQ 4-431 PAGE 1551 LINE 80485
define pcodeop vpslldq_avx ;
:VPSLLDQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=7 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpslldq_avx( XmmReg2, imm8:1 );
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80620
define pcodeop vpsllw_avx ;
:VPSLLW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF1; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80623
:VPSLLW vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x71; reg_opcode=6 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsllw_avx( XmmReg2, imm8:1 );
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80626
define pcodeop vpslld_avx ;
:VPSLLD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpslld_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80629
:VPSLLD vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x72; reg_opcode=6 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpslld_avx( XmmReg2, imm8:1 );
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80632
define pcodeop vpsllq_avx ;
:VPSLLQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF3; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80635
:VPSLLQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=6 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsllq_avx( XmmReg2, imm8:1 );
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81305
define pcodeop vpsraw_avx ;
:VPSRAW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE1; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsraw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81308
:VPSRAW vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x71; reg_opcode=4 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsraw_avx( XmmReg2, imm8:1 );
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81311
define pcodeop vpsrad_avx ;
:VPSRAD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrad_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81314
:VPSRAD vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x72; reg_opcode=4 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrad_avx( XmmReg2, imm8:1 );
}

# PSRLDQ 4-455 PAGE 1575 LINE 81873
define pcodeop vpsrldq_avx ;
:VPSRLDQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=3 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrldq_avx( XmmReg2, imm8:1 );
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82012
define pcodeop vpsrlw_avx ;
:VPSRLW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD1; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82015
:VPSRLW vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x71; reg_opcode=2 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrlw_avx( XmmReg2, imm8:1 );
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82018
define pcodeop vpsrld_avx ;
:VPSRLD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrld_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82021
:VPSRLD vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x72; reg_opcode=2 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrld_avx( XmmReg2, imm8:1 );
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82024
define pcodeop vpsrlq_avx ;
:VPSRLQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD3; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82027
:VPSRLQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=2 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrlq_avx( XmmReg2, imm8:1 );
}

# PSUBB/PSUBW/PSUBD 4-469 PAGE 1589 LINE 82689
define pcodeop vpsubb_avx ;
:VPSUBB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBB/PSUBW/PSUBD 4-469 PAGE 1589 LINE 82691
define pcodeop vpsubw_avx ;
:VPSUBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBB/PSUBW/PSUBD 4-469 PAGE 1589 LINE 82694
define pcodeop vpsubd_avx ;
:VPSUBD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBQ 4-476 PAGE 1596 LINE 83101
define pcodeop vpsubq_avx ;
:VPSUBQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBSB/PSUBSW 4-479 PAGE 1599 LINE 83258
define pcodeop vpsubsb_avx ;
:VPSUBSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBSB/PSUBSW 4-479 PAGE 1599 LINE 83261
define pcodeop vpsubsw_avx ;
:VPSUBSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBUSB/PSUBUSW 4-483 PAGE 1603 LINE 83498
define pcodeop vpsubusb_avx ;
:VPSUBUSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubusb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PSUBUSB/PSUBUSW 4-483 PAGE 1603 LINE 83501
define pcodeop vpsubusw_avx ;
:VPSUBUSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubusw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PTEST 4-487 PAGE 1607 LINE 83728
define pcodeop vptest_avx ;
:VPTEST XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x17; XmmReg1 ... & XmmReg2_m128
{
	vptest_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}

# PTEST 4-487 PAGE 1607 LINE 83730
:VPTEST YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x17; YmmReg1 ... & YmmReg2_m256
{
	vptest_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83929
define pcodeop vpunpckhbw_avx ;
:VPUNPCKHBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x68; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhbw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83932
define pcodeop vpunpckhwd_avx ;
:VPUNPCKHWD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x69; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhwd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83935
define pcodeop vpunpckhdq_avx ;
:VPUNPCKHDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhdq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83938
define pcodeop vpunpckhqdq_avx ;
:VPUNPCKHQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhqdq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84529
define pcodeop vpunpcklbw_avx ;
:VPUNPCKLBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x60; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpcklbw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84532
define pcodeop vpunpcklwd_avx ;
:VPUNPCKLWD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x61; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpcklwd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84535
define pcodeop vpunpckldq_avx ;
:VPUNPCKLDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x62; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckldq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84538
define pcodeop vpunpcklqdq_avx ;
:VPUNPCKLQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpcklqdq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# PXOR 4-518 PAGE 1638 LINE 85495
define pcodeop vpxor_avx ;
:VPXOR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEF; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpxor_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# RCPPS 4-526 PAGE 1646 LINE 85950
define pcodeop vrcpps_avx ;
:VRCPPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x53; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vrcpps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# RCPPS 4-526 PAGE 1646 LINE 85953
:VRCPPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x53; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vrcpps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# RCPSS 4-528 PAGE 1648 LINE 86052
define pcodeop vrcpss_avx ;
:VRCPSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x53; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vrcpss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ROUNDPD 4-564 PAGE 1684 LINE 87791
define pcodeop vroundpd_avx ;
:VROUNDPD XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x09; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vroundpd_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ROUNDPD 4-564 PAGE 1684 LINE 87795
:VROUNDPD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x09; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vroundpd_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ROUNDPS 4-567 PAGE 1687 LINE 87934
define pcodeop vroundps_avx ;
:VROUNDPS XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x08; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vroundps_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ROUNDPS 4-567 PAGE 1687 LINE 87938
:VROUNDPS YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x08; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vroundps_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# ROUNDSD 4-570 PAGE 1690 LINE 88058
define pcodeop vroundsd_avx ;
:VROUNDSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64, imm8 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0B; (XmmReg1 & YmmReg1) ... & XmmReg2_m64; imm8
{
	local tmp:16 = vroundsd_avx( vexVVVV_XmmReg, XmmReg2_m64, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# ROUNDSS 4-572 PAGE 1692 LINE 88145
define pcodeop vroundss_avx ;
:VROUNDSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32, imm8 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0A; (XmmReg1 & YmmReg1) ... & XmmReg2_m32; imm8
{
	local tmp:16 = vroundss_avx( vexVVVV_XmmReg, XmmReg2_m32, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# RSQRTPS 4-576 PAGE 1696 LINE 88301
define pcodeop vrsqrtps_avx ;
:VRSQRTPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x52; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vrsqrtps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# RSQRTPS 4-576 PAGE 1696 LINE 88304
:VRSQRTPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x52; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vrsqrtps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# RSQRTSS 4-578 PAGE 1698 LINE 88399
define pcodeop vrsqrtss_avx ;
:VRSQRTSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x52; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vrsqrtss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SHUFPD 4-617 PAGE 1737 LINE 90223
define pcodeop vshufpd_avx ;
:VSHUFPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vshufpd_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SHUFPD 4-617 PAGE 1737 LINE 90227
:VSHUFPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC6; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vshufpd_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# SHUFPS 4-622 PAGE 1742 LINE 90483
define pcodeop vshufps_avx ;
:VSHUFPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vshufps_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SHUFPS 4-622 PAGE 1742 LINE 90486
:VSHUFPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC6; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vshufps_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# SQRTPD 4-632 PAGE 1752 LINE 91001
define pcodeop vsqrtpd_avx ;
:VSQRTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsqrtpd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SQRTPD 4-632 PAGE 1752 LINE 91004
:VSQRTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x51; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsqrtpd_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# SQRTPS 4-635 PAGE 1755 LINE 91133
define pcodeop vsqrtps_avx ;
:VSQRTPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsqrtps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SQRTPS 4-635 PAGE 1755 LINE 91136
:VSQRTPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x51; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsqrtps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# SQRTSD 4-638 PAGE 1758 LINE 91272
define pcodeop vsqrtsd_avx ;
:VSQRTSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vsqrtsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SQRTSS 4-640 PAGE 1760 LINE 91367
define pcodeop vsqrtss_avx ;
:VSQRTSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vsqrtss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# STMXCSR 4-647 PAGE 1767 LINE 91697
define pcodeop vstmxcsr_avx ;
:VSTMXCSR m32 is $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0xAE; reg_opcode=3 ... & m32
{
	m32 = vstmxcsr_avx(  );
}

# SUBPD 4-656 PAGE 1776 LINE 92116
define pcodeop vsubpd_avx ;
:VSUBPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsubpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SUBPD 4-656 PAGE 1776 LINE 92118
:VSUBPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsubpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# SUBPS 4-659 PAGE 1779 LINE 92265
define pcodeop vsubps_avx ;
:VSUBPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsubps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SUBPS 4-659 PAGE 1779 LINE 92267
:VSUBPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsubps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# SUBSD 4-662 PAGE 1782 LINE 92419
define pcodeop vsubsd_avx ;
:VSUBSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vsubsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# SUBSS 4-664 PAGE 1784 LINE 92512
define pcodeop vsubss_avx ;
:VSUBSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vsubss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# UCOMISD 4-683 PAGE 1803 LINE 93421
define pcodeop vucomisd_avx ;
:VUCOMISD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2E; XmmReg1 ... & XmmReg2_m64
{
	vucomisd_avx( XmmReg1, XmmReg2_m64 );
	# TODO set flags AF, CF, OF, PF, SF, ZF
}

# UCOMISS 4-685 PAGE 1805 LINE 93504
define pcodeop vucomiss_avx ;
:VUCOMISS XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2E; XmmReg1 ... & XmmReg2_m32
{
	vucomiss_avx( XmmReg1, XmmReg2_m32 );
	# TODO set flags AF, CF, OF, PF, SF, ZF
}

# UNPCKHPD 4-688 PAGE 1808 LINE 93623
define pcodeop vunpckhpd_avx ;
:VUNPCKHPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x15; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpckhpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# UNPCKHPD 4-688 PAGE 1808 LINE 93626
:VUNPCKHPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x15; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpckhpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# UNPCKHPS 4-692 PAGE 1812 LINE 93807
define pcodeop vunpckhps_avx ;
:VUNPCKHPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x15; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpckhps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# UNPCKHPS 4-692 PAGE 1812 LINE 93810
:VUNPCKHPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x15; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpckhps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# UNPCKLPD 4-696 PAGE 1816 LINE 94039
define pcodeop vunpcklpd_avx ;
:VUNPCKLPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x14; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpcklpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# UNPCKLPD 4-696 PAGE 1816 LINE 94042
:VUNPCKLPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x14; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpcklpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# UNPCKLPS 4-700 PAGE 1820 LINE 94225
define pcodeop vunpcklps_avx ;
:VUNPCKLPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x14; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpcklps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# UNPCKLPS 4-700 PAGE 1820 LINE 94228
:VUNPCKLPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x14; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpcklps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}


# VBROADCAST 5-12 PAGE 1836 LINE 95843
define pcodeop vbroadcastss_avx ;
:VBROADCASTSS XmmReg1, m32 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; (XmmReg1 & YmmReg1) ... & m32
{
        local tmp:16 = vbroadcastss_avx( m32 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}

# VBROADCAST 5-12 PAGE 1836 LINE 95845
:VBROADCASTSS YmmReg1, m32 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; YmmReg1 ... & m32
{
        YmmReg1 = vbroadcastss_avx( m32 );
        # TODO ZmmReg1 = zext(YmmReg1)
}

# VBROADCAST 5-12 PAGE 1836 LINE 95847
define pcodeop vbroadcastsd_avx ;
:VBROADCASTSD YmmReg1, m64 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 ... & m64
{
        YmmReg1 = vbroadcastsd_avx( m64 );
        # TODO ZmmReg1 = zext(YmmReg1)
}

# VBROADCAST 5-12 PAGE 1836 LINE 95849
define pcodeop vbroadcastf128_avx ;
:VBROADCASTF128 YmmReg1, m128 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x1A; YmmReg1 ... & m128
{
        YmmReg1 = vbroadcastf128_avx( m128 );
        # TODO ZmmReg1 = zext(YmmReg1)
}

# VBROADCAST 5-12 PAGE 1836 LINE 95851
# WARNING: duplicate opcode VEX.128.66.0F38.W0 18 /r last seen on 5-12 PAGE 1836 LINE 95843 for "VBROADCASTSS xmm1, xmm2"
define pcodeop vbroadcastss_avx2 ;
:VBROADCASTSS XmmReg1, XmmReg2 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
        local tmp:16 = vbroadcastss_avx2( XmmReg2 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}

# VBROADCAST 5-12 PAGE 1836 LINE 95854
# WARNING: duplicate opcode VEX.256.66.0F38.W0 18 /r last seen on 5-12 PAGE 1836 LINE 95845 for "VBROADCASTSS ymm1, xmm2"
:VBROADCASTSS YmmReg1, XmmReg2 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; YmmReg1 & (mod=0x3 & XmmReg2)
{
        YmmReg1 = vbroadcastss_avx2( XmmReg2 );
        # TODO ZmmReg1 = zext(YmmReg1)
}

# VBROADCAST 5-12 PAGE 1836 LINE 95856
# WARNING: duplicate opcode VEX.256.66.0F38.W0 19 /r last seen on 5-12 PAGE 1836 LINE 95847 for "VBROADCASTSD ymm1, xmm2"
define pcodeop vbroadcastsd_avx2 ;
:VBROADCASTSD YmmReg1, XmmReg2 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 & (mod=0x3 & XmmReg2)
{
        YmmReg1 = vbroadcastsd_avx2( XmmReg2 );
        # TODO ZmmReg1 = zext(YmmReg1)
}


# VEXTRACTF128/VEXTRACTF32x4/VEXTRACTF64x2/VEXTRACTF32x8/VEXTRACTF64x4 5-99 PAGE 1923 LINE 99102
define pcodeop vextractf128_avx ;
:VEXTRACTF128 XmmReg2_m128, YmmReg1, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x19; YmmReg1 ... & XmmReg2_m128; imm8
{
	XmmReg2_m128 = vextractf128_avx( YmmReg1, imm8:1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}

# VINSERTF128/VINSERTF32x4/VINSERTF64x2/VINSERTF32x8/VINSERTF64x4 5-310 PAGE 2134 LINE 109703
define pcodeop vinsertf128_avx ;
:VINSERTF128 YmmReg1, vexVVVV_YmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x18; YmmReg1 ... & XmmReg2_m128; imm8
{
	YmmReg1 = vinsertf128_avx( vexVVVV_YmmReg, XmmReg2_m128, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VMASKMOV 5-318 PAGE 2142 LINE 110151
define pcodeop vmaskmovps_avx ;
:VMASKMOVPS XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2C; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vmaskmovps_avx( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VMASKMOV 5-318 PAGE 2142 LINE 110154
:VMASKMOVPS YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2C; YmmReg1 ... & m256
{
	YmmReg1 = vmaskmovps_avx( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VMASKMOV 5-318 PAGE 2142 LINE 110157
define pcodeop vmaskmovpd_avx ;
:VMASKMOVPD XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2D; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vmaskmovpd_avx( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VMASKMOV 5-318 PAGE 2142 LINE 110160
:VMASKMOVPD YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2D; YmmReg1 ... & m256
{
	YmmReg1 = vmaskmovpd_avx( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VMASKMOV 5-318 PAGE 2142 LINE 110163
:VMASKMOVPS m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2E; XmmReg1 ... & m128
{
	m128 = vmaskmovps_avx( vexVVVV_XmmReg, XmmReg1 );
}

# VMASKMOV 5-318 PAGE 2142 LINE 110166
:VMASKMOVPS m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2E; YmmReg1 ... & m256
{
	m256 = vmaskmovps_avx( vexVVVV_YmmReg, YmmReg1 );
}

# VMASKMOV 5-318 PAGE 2142 LINE 110168
:VMASKMOVPD m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2F; XmmReg1 ... & m128
{
	m128 = vmaskmovpd_avx( vexVVVV_XmmReg, XmmReg1 );
}

# VMASKMOV 5-318 PAGE 2142 LINE 110171
:VMASKMOVPD m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2F; YmmReg1 ... & m256
{
	m256 = vmaskmovpd_avx( vexVVVV_YmmReg, YmmReg1 );
}

# VPERM2F128 5-358 PAGE 2182 LINE 112216
define pcodeop vperm2f128_avx ;
:VPERM2F128 YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x06; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vperm2f128_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMILPD 5-371 PAGE 2195 LINE 112860
define pcodeop vpermilpd_avx ;
:VPERMILPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x0D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpermilpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPERMILPD 5-371 PAGE 2195 LINE 112863
:VPERMILPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x0D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermilpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMILPD 5-371 PAGE 2195 LINE 112875
:VPERMILPD XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x05; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpermilpd_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPERMILPD 5-371 PAGE 2195 LINE 112877
:VPERMILPD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x05; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermilpd_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMILPS 5-376 PAGE 2200 LINE 113158
define pcodeop vpermilps_avx ;
:VPERMILPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x0C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpermilps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPERMILPS 5-376 PAGE 2200 LINE 113161
:VPERMILPS XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x04; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpermilps_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPERMILPS 5-376 PAGE 2200 LINE 113164
:VPERMILPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x0C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermilps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMILPS 5-376 PAGE 2200 LINE 113167
:VPERMILPS YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x04; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermilps_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VTESTPD/VTESTPS 5-560 PAGE 2384 LINE 122257
define pcodeop vtestps_avx ;
:VTESTPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0E; XmmReg1 ... & XmmReg2_m128
{
	vtestps_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}

# VTESTPD/VTESTPS 5-560 PAGE 2384 LINE 122260
:VTESTPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0E; YmmReg1 ... & YmmReg2_m256
{
	vtestps_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}

# VTESTPD/VTESTPS 5-560 PAGE 2384 LINE 122263
define pcodeop vtestpd_avx ;
:VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}

# VTESTPD/VTESTPS 5-560 PAGE 2384 LINE 122266
:VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}

# XORPD 5-596 PAGE 2420 LINE 123828
define pcodeop vxorpd_avx ;
:VXORPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x57; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vxorpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# XORPD 5-596 PAGE 2420 LINE 123831
:VXORPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x57; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vxorpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# XORPS 5-599 PAGE 2423 LINE 123953
define pcodeop vxorps_avx ;
:VXORPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x57; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vxorps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# XORPS 5-599 PAGE 2423 LINE 123956
:VXORPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x57; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vxorps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/avx2.sinc`:

```sinc
# INFO This file automatically generated by andre on Thu May 10 11:02:19 2018
# INFO Direct edits to this file may be lost in future updates
# INFO Command line arguments: ['--sinc', '--cpuid-match', '^AVX2\\b', '--skip-sinc', '../../../Processors/x86/data/languages/avx2_manual.sinc']

# MOVNTDQA 4-92 PAGE 1212 LINE 63086
define pcodeop vmovntdqa_avx2 ;
:VMOVNTDQA YmmReg1, m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x2A; YmmReg1 ... & m256
{
	YmmReg1 = vmovntdqa_avx2( m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MPSADBW 4-136 PAGE 1256 LINE 65140
define pcodeop vmpsadbw_avx2 ;
:VMPSADBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x42; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vmpsadbw_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PABSB/PABSW/PABSD/PABSQ 4-180 PAGE 1300 LINE 67311
define pcodeop vpabsb_avx2 ;
:VPABSB YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpabsb_avx2( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PABSB/PABSW/PABSD/PABSQ 4-180 PAGE 1300 LINE 67314
define pcodeop vpabsw_avx2 ;
:VPABSW YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpabsw_avx2( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PABSB/PABSW/PABSD/PABSQ 4-180 PAGE 1300 LINE 67317
define pcodeop vpabsd_avx2 ;
:VPABSD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpabsd_avx2( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PACKSSWB/PACKSSDW 4-186 PAGE 1306 LINE 67637
define pcodeop vpacksswb_avx2 ;
:VPACKSSWB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x63; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpacksswb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PACKSSWB/PACKSSDW 4-186 PAGE 1306 LINE 67641
define pcodeop vpackssdw_avx2 ;
:VPACKSSDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpackssdw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PACKUSDW 4-194 PAGE 1314 LINE 68090
define pcodeop vpackusdw_avx2 ;
:VPACKUSDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x2B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpackusdw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PACKUSWB 4-199 PAGE 1319 LINE 68370
define pcodeop vpackuswb_avx2 ;
:VPACKUSWB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x67; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpackuswb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68666
define pcodeop vpaddb_avx2 ;
:VPADDB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68668
define pcodeop vpaddw_avx2 ;
:VPADDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFD; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68670
define pcodeop vpaddd_avx2 ;
:VPADDD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDB/PADDW/PADDD/PADDQ 4-204 PAGE 1324 LINE 68672
define pcodeop vpaddq_avx2 ;
:VPADDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD4; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDSB/PADDSW 4-211 PAGE 1331 LINE 69045
define pcodeop vpaddsb_avx2 ;
:VPADDSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDSB/PADDSW 4-211 PAGE 1331 LINE 69048
define pcodeop vpaddsw_avx2 ;
:VPADDSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xED; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDUSB/PADDUSW 4-215 PAGE 1335 LINE 69263
define pcodeop vpaddusb_avx2 ;
:VPADDUSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddusb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PADDUSB/PADDUSW 4-215 PAGE 1335 LINE 69266
define pcodeop vpaddusw_avx2 ;
:VPADDUSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDD; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddusw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PALIGNR 4-219 PAGE 1339 LINE 69489
define pcodeop vpalignr_avx2 ;
:VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PAND 4-223 PAGE 1343 LINE 69680
define pcodeop vpand_avx2 ;
:VPAND YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDB; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpand_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PANDN 4-226 PAGE 1346 LINE 69856
define pcodeop vpandn_avx2 ;
:VPANDN YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDF; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpandn_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PAVGB/PAVGW 4-230 PAGE 1350 LINE 70091
define pcodeop vpavgb_avx2 ;
:VPAVGB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE0; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpavgb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PAVGB/PAVGW 4-230 PAGE 1350 LINE 70094
define pcodeop vpavgw_avx2 ;
:VPAVGW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE3; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpavgw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PBLENDVB 4-234 PAGE 1354 LINE 70300
define pcodeop vpblendvb_avx2 ;
:VPBLENDVB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x4C; YmmReg1 ... & YmmReg2_m256; Ymm_imm8_7_4
{
	YmmReg1 = vpblendvb_avx2( vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PBLENDW 4-238 PAGE 1358 LINE 70525
define pcodeop vpblendw_avx2 ;
:VPBLENDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0E; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpblendw_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPEQB/PCMPEQW/PCMPEQD 4-244 PAGE 1364 LINE 70830
define pcodeop vpcmpeqb_avx2 ;
:VPCMPEQB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x74; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpeqb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPEQB/PCMPEQW/PCMPEQD 4-244 PAGE 1364 LINE 70833
define pcodeop vpcmpeqw_avx2 ;
:VPCMPEQW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x75; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpeqw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPEQB/PCMPEQW/PCMPEQD 4-244 PAGE 1364 LINE 70837
define pcodeop vpcmpeqd_avx2 ;
:VPCMPEQD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x76; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpeqd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPGTB/PCMPGTW/PCMPGTD 4-257 PAGE 1377 LINE 71508
define pcodeop vpcmpgtb_avx2 ;
:VPCMPGTB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x64; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPGTB/PCMPGTW/PCMPGTD 4-257 PAGE 1377 LINE 71511
define pcodeop vpcmpgtw_avx2 ;
:VPCMPGTW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x65; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPGTB/PCMPGTW/PCMPGTD 4-257 PAGE 1377 LINE 71514
define pcodeop vpcmpgtd_avx2 ;
:VPCMPGTD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x66; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PCMPGTQ 4-263 PAGE 1383 LINE 71835
define pcodeop vpcmpgtq_avx2 ;
:VPCMPGTQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x37; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PHADDW/PHADDD 4-280 PAGE 1400 LINE 72633
define pcodeop vphaddw_avx2 ;
:VPHADDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x01; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphaddw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PHADDW/PHADDD 4-280 PAGE 1400 LINE 72636
define pcodeop vphaddd_avx2 ;
:VPHADDD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x02; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphaddd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PHADDSW 4-284 PAGE 1404 LINE 72824
define pcodeop vphaddsw_avx2 ;
:VPHADDSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x03; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphaddsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PHSUBW/PHSUBD 4-288 PAGE 1408 LINE 73038
define pcodeop vphsubw_avx2 ;
:VPHSUBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x05; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphsubw_avx2( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PHSUBW/PHSUBD 4-288 PAGE 1408 LINE 73041
define pcodeop vphsubd_avx2 ;
:VPHSUBD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x06; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphsubd_avx2( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PHSUBSW 4-291 PAGE 1411 LINE 73200
define pcodeop vphsubsw_avx2 ;
:VPHSUBSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x07; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphsubsw_avx2( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMADDUBSW 4-298 PAGE 1418 LINE 73555
define pcodeop vpmaddubsw_avx2 ;
:VPMADDUBSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x04; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaddubsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMADDWD 4-301 PAGE 1421 LINE 73704
define pcodeop vpmaddwd_avx2 ;
:VPMADDWD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF5; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaddwd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMAXSB/PMAXSW/PMAXSD/PMAXSQ 4-304 PAGE 1424 LINE 73891
define pcodeop vpmaxsb_avx2 ;
:VPMAXSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMAXSB/PMAXSW/PMAXSD/PMAXSQ 4-304 PAGE 1424 LINE 73894
define pcodeop vpmaxsw_avx2 ;
:VPMAXSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMAXSB/PMAXSW/PMAXSD/PMAXSQ 4-304 PAGE 1424 LINE 73897
define pcodeop vpmaxsd_avx2 ;
:VPMAXSD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxsd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMAXUB/PMAXUW 4-311 PAGE 1431 LINE 74289
define pcodeop vpmaxub_avx2 ;
:VPMAXUB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0xDE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxub_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMAXUB/PMAXUW 4-311 PAGE 1431 LINE 74292
define pcodeop vpmaxuw_avx2 ;
:VPMAXUW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x3E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxuw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMAXUD/PMAXUQ 4-316 PAGE 1436 LINE 74537
define pcodeop vpmaxud_avx2 ;
:VPMAXUD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxud_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMINSB/PMINSW 4-320 PAGE 1440 LINE 74742
define pcodeop vpminsb_avx2 ;
:VPMINSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x38; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMINSB/PMINSW 4-320 PAGE 1440 LINE 74745
define pcodeop vpminsw_avx2 ;
:VPMINSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0xEA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMINSD/PMINSQ 4-325 PAGE 1445 LINE 74992
define pcodeop vpminsd_avx2 ;
:VPMINSD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x39; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminsd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMINUB/PMINUW 4-329 PAGE 1449 LINE 75201
define pcodeop vpminub_avx2 ;
:VPMINUB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0xDA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminub_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMINUB/PMINUW 4-329 PAGE 1449 LINE 75204
define pcodeop vpminuw_avx2 ;
:VPMINUW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x3A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminuw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMINUD/PMINUQ 4-334 PAGE 1454 LINE 75448
define pcodeop vpminud_avx2 ;
:VPMINUD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminud_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75782
define pcodeop vpmovsxbw_avx2 ;
:VPMOVSXBW YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x20; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovsxbw_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75784
define pcodeop vpmovsxbd_avx2 ;
:VPMOVSXBD YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x21; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovsxbd_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75786
define pcodeop vpmovsxbq_avx2 ;
:VPMOVSXBQ YmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x22; YmmReg1 ... & XmmReg2_m32
{
	YmmReg1 = vpmovsxbq_avx2( XmmReg2_m32 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75788
define pcodeop vpmovsxwd_avx2 ;
:VPMOVSXWD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x23; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovsxwd_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75791
define pcodeop vpmovsxwq_avx2 ;
:VPMOVSXWQ YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x24; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovsxwq_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVSX 4-340 PAGE 1460 LINE 75793
define pcodeop vpmovsxdq_avx2 ;
:VPMOVSXDQ YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x25; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovsxdq_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76304
define pcodeop vpmovzxbw_avx2 ;
:VPMOVZXBW YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x30; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovzxbw_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76306
define pcodeop vpmovzxbd_avx2 ;
:VPMOVZXBD YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x31; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovzxbd_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76309
define pcodeop vpmovzxbq_avx2 ;
:VPMOVZXBQ YmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x32; YmmReg1 ... & XmmReg2_m32
{
	YmmReg1 = vpmovzxbq_avx2( XmmReg2_m32 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76312
define pcodeop vpmovzxwd_avx2 ;
:VPMOVZXWD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x33; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovzxwd_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76314
define pcodeop vpmovzxwq_avx2 ;
:VPMOVZXWQ YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x34; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovzxwq_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMOVZX 4-350 PAGE 1470 LINE 76317
define pcodeop vpmovzxdq_avx2 ;
:VPMOVZXDQ YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x35; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovzxdq_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULDQ 4-359 PAGE 1479 LINE 76791
define pcodeop vpmuldq_avx2 ;
:VPMULDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x28; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmuldq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULHRSW 4-362 PAGE 1482 LINE 76931
define pcodeop vpmulhrsw_avx2 ;
:VPMULHRSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulhrsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULHUW 4-366 PAGE 1486 LINE 77144
define pcodeop vpmulhuw_avx2 ;
:VPMULHUW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE4; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulhuw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULHW 4-370 PAGE 1490 LINE 77373
define pcodeop vpmulhw_avx2 ;
:VPMULHW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE5; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulhw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULLD/PMULLQ 4-374 PAGE 1494 LINE 77579
define pcodeop vpmulld_avx2 ;
:VPMULLD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x40; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulld_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULLW 4-378 PAGE 1498 LINE 77778
define pcodeop vpmullw_avx2 ;
:VPMULLW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD5; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmullw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PMULUDQ 4-382 PAGE 1502 LINE 77973
define pcodeop vpmuludq_avx2 ;
:VPMULUDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF4; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmuludq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# POR 4-399 PAGE 1519 LINE 78852
define pcodeop vpor_avx2 ;
:VPOR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEB; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpor_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSADBW 4-408 PAGE 1528 LINE 79245
define pcodeop vpsadbw_avx2 ;
:VPSADBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF6; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsadbw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSHUFB 4-412 PAGE 1532 LINE 79463
define pcodeop vpshufb_avx2 ;
:VPSHUFB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x00; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpshufb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSHUFD 4-416 PAGE 1536 LINE 79653
define pcodeop vpshufd_avx2 ;
:VPSHUFD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x70; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpshufd_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSHUFHW 4-420 PAGE 1540 LINE 79860
define pcodeop vpshufhw_avx2 ;
:VPSHUFHW YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x70; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpshufhw_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSHUFLW 4-423 PAGE 1543 LINE 80035
define pcodeop vpshuflw_avx2 ;
:VPSHUFLW YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x70; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpshuflw_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSIGNB/PSIGNW/PSIGND 4-427 PAGE 1547 LINE 80278
define pcodeop vpsignb_avx2 ;
:VPSIGNB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x08; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsignb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSIGNB/PSIGNW/PSIGND 4-427 PAGE 1547 LINE 80281
define pcodeop vpsignw_avx2 ;
:VPSIGNW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x09; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsignw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSIGNB/PSIGNW/PSIGND 4-427 PAGE 1547 LINE 80284
define pcodeop vpsignd_avx2 ;
:VPSIGND YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsignd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSLLDQ 4-431 PAGE 1551 LINE 80488
define pcodeop vpslldq_avx2 ;
:VPSLLDQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=7 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpslldq_avx2( YmmReg2, imm8:1 );
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80638
define pcodeop vpsllw_avx2 ;
:VPSLLW YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF1; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsllw_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSLLW/PSLLD/PSLLQ 4-433 PAGE 1553 LINE 80641
:VPSLLW vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x71; reg_opcode=6 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsllw_avx2( YmmReg2, imm8:1 );
}

# PSLLW/PSLLD/PSLLQ 4-434 PAGE 1554 LINE 80656
define pcodeop vpslld_avx2 ;
:VPSLLD YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF2; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpslld_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSLLW/PSLLD/PSLLQ 4-434 PAGE 1554 LINE 80659
:VPSLLD vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x72; reg_opcode=6 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpslld_avx2( YmmReg2, imm8:1 );
}

# PSLLW/PSLLD/PSLLQ 4-434 PAGE 1554 LINE 80662
define pcodeop vpsllq_avx2 ;
:VPSLLQ YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF3; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsllq_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSLLW/PSLLD/PSLLQ 4-434 PAGE 1554 LINE 80664
:VPSLLQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=6 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsllq_avx2( YmmReg2, imm8:1 );
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81317
define pcodeop vpsraw_avx2 ;
:VPSRAW YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE1; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsraw_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81320
:VPSRAW vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x71; reg_opcode=4 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsraw_avx2( YmmReg2, imm8:1 );
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81323
define pcodeop vpsrad_avx2 ;
:VPSRAD YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE2; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrad_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSRAW/PSRAD/PSRAQ 4-445 PAGE 1565 LINE 81326
:VPSRAD vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x72; reg_opcode=4 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrad_avx2( YmmReg2, imm8:1 );
}

# PSRLDQ 4-455 PAGE 1575 LINE 81876
define pcodeop vpsrldq_avx2 ;
:VPSRLDQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=3 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrldq_avx2( YmmReg2, imm8:1 );
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82030
define pcodeop vpsrlw_avx2 ;
:VPSRLW YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD1; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrlw_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSRLW/PSRLD/PSRLQ 4-457 PAGE 1577 LINE 82033
:VPSRLW vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x71; reg_opcode=2 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrlw_avx2( YmmReg2, imm8:1 );
}

# PSRLW/PSRLD/PSRLQ 4-458 PAGE 1578 LINE 82048
define pcodeop vpsrld_avx2 ;
:VPSRLD YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD2; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrld_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSRLW/PSRLD/PSRLQ 4-458 PAGE 1578 LINE 82051
:VPSRLD vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x72; reg_opcode=2 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrld_avx2( YmmReg2, imm8:1 );
}

# PSRLW/PSRLD/PSRLQ 4-458 PAGE 1578 LINE 82054
define pcodeop vpsrlq_avx2 ;
:VPSRLQ YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD3; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrlq_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSRLW/PSRLD/PSRLQ 4-458 PAGE 1578 LINE 82056
:VPSRLQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=2 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrlq_avx2( YmmReg2, imm8:1 );
}

# PSUBB/PSUBW/PSUBD 4-469 PAGE 1589 LINE 82696
define pcodeop vpsubb_avx2 ;
:VPSUBB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBB/PSUBW/PSUBD 4-469 PAGE 1589 LINE 82698
define pcodeop vpsubw_avx2 ;
:VPSUBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF9; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBB/PSUBW/PSUBD 4-469 PAGE 1589 LINE 82700
define pcodeop vpsubd_avx2 ;
:VPSUBD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBQ 4-476 PAGE 1596 LINE 83104
define pcodeop vpsubq_avx2 ;
:VPSUBQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFB; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBSB/PSUBSW 4-479 PAGE 1599 LINE 83264
define pcodeop vpsubsb_avx2 ;
:VPSUBSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBSB/PSUBSW 4-479 PAGE 1599 LINE 83267
define pcodeop vpsubsw_avx2 ;
:VPSUBSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE9; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBUSB/PSUBUSW 4-483 PAGE 1603 LINE 83504
define pcodeop vpsubusb_avx2 ;
:VPSUBUSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubusb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PSUBUSB/PSUBUSW 4-483 PAGE 1603 LINE 83507
define pcodeop vpsubusw_avx2 ;
:VPSUBUSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD9; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubusw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83940
define pcodeop vpunpckhbw_avx2 ;
:VPUNPCKHBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x68; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhbw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83942
define pcodeop vpunpckhwd_avx2 ;
:VPUNPCKHWD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x69; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhwd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83944
define pcodeop vpunpckhdq_avx2 ;
:VPUNPCKHDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhdq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ 4-491 PAGE 1611 LINE 83946
define pcodeop vpunpckhqdq_avx2 ;
:VPUNPCKHQDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhqdq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84541
define pcodeop vpunpcklbw_avx2 ;
:VPUNPCKLBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x60; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpcklbw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84544
define pcodeop vpunpcklwd_avx2 ;
:VPUNPCKLWD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x61; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpcklwd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84547
define pcodeop vpunpckldq_avx2 ;
:VPUNPCKLDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x62; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckldq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ 4-501 PAGE 1621 LINE 84550
define pcodeop vpunpcklqdq_avx2 ;
:VPUNPCKLQDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpcklqdq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# PXOR 4-518 PAGE 1638 LINE 85497
define pcodeop vpxor_avx2 ;
:VPXOR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEF; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpxor_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VEXTRACTI128/VEXTRACTI32x4/VEXTRACTI64x2/VEXTRACTI32x8/VEXTRACTI64x4 5-106 PAGE 1930 LINE 99432
define pcodeop vextracti128_avx2 ;
:VEXTRACTI128 XmmReg2_m128, YmmReg1, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x39; YmmReg1 ... & XmmReg2_m128; imm8
{
	XmmReg2_m128 = vextracti128_avx2( YmmReg1, imm8:1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106903
# INFO mnemonic VGATHERDPD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106908
# INFO mnemonic VGATHERQPD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106913
# INFO mnemonic VGATHERDPD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106918
# INFO mnemonic VGATHERQPD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107130
# INFO mnemonic VGATHERDPS was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107135
# INFO mnemonic VGATHERQPS was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107140
# INFO mnemonic VGATHERDPS was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107145
# INFO mnemonic VGATHERQPS was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107884
# INFO mnemonic VPGATHERDD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107888
# INFO mnemonic VPGATHERQD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107892
# INFO mnemonic VPGATHERDD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107896
# INFO mnemonic VPGATHERQD was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108234
# INFO mnemonic VPGATHERDQ was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108238
# INFO mnemonic VPGATHERQQ was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108242
# INFO mnemonic VPGATHERDQ was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108246
# INFO mnemonic VPGATHERQQ was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VINSERTI128/VINSERTI32x4/VINSERTI64x2/VINSERTI32x8/VINSERTI64x4 5-314 PAGE 2138 LINE 109927
# INFO mnemonic VINSERTI128 was found in ../../../Processors/x86/data/languages/avx2_manual.sinc

# VPBLENDD 5-321 PAGE 2145 LINE 110309
define pcodeop vpblendd_avx2 ;
:VPBLENDD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x02; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpblendd_avx2( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPBLENDD 5-321 PAGE 2145 LINE 110312
:VPBLENDD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x02; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpblendd_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110776
define pcodeop vpbroadcastb_avx2 ;
:VPBROADCASTB XmmReg1, XmmReg2_m8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x78; (XmmReg1 & YmmReg1) ... & XmmReg2_m8
{
	local tmp:16 = vpbroadcastb_avx2( XmmReg2_m8 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110778
:VPBROADCASTB YmmReg1, XmmReg2_m8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x78; YmmReg1 ... & XmmReg2_m8
{
	YmmReg1 = vpbroadcastb_avx2( XmmReg2_m8 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110787
define pcodeop vpbroadcastw_avx2 ;
:VPBROADCASTW XmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x79; (XmmReg1 & YmmReg1) ... & XmmReg2_m16
{
	local tmp:16 = vpbroadcastw_avx2( XmmReg2_m16 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110789
:VPBROADCASTW YmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x79; YmmReg1 ... & XmmReg2_m16
{
	YmmReg1 = vpbroadcastw_avx2( XmmReg2_m16 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110800
define pcodeop vpbroadcastd_avx2 ;
:VPBROADCASTD XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpbroadcastd_avx2( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110802
:VPBROADCASTD YmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x58; YmmReg1 ... & XmmReg2_m32
{
	YmmReg1 = vpbroadcastd_avx2( XmmReg2_m32 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110813
define pcodeop vpbroadcastq_avx2 ;
:VPBROADCASTQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpbroadcastq_avx2( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPBROADCAST 5-331 PAGE 2155 LINE 110815
:VPBROADCASTQ YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x59; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpbroadcastq_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPBROADCAST 5-332 PAGE 2156 LINE 110843
define pcodeop vbroadcasti128_avx2 ;
:VBROADCASTI128 YmmReg1, m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x5A; YmmReg1 ... & m128
{
	YmmReg1 = vbroadcasti128_avx2( m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERM2I128 5-360 PAGE 2184 LINE 112312
define pcodeop vperm2i128_avx2 ;
:VPERM2I128 YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x46; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vperm2i128_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMD/VPERMW 5-362 PAGE 2186 LINE 112405
define pcodeop vpermd_avx2 ;
:VPERMD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x36; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMPD 5-381 PAGE 2205 LINE 113452
define pcodeop vpermpd_avx2 ;
:VPERMPD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W1); byte=0x01; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermpd_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMPS 5-384 PAGE 2208 LINE 113633
define pcodeop vpermps_avx2 ;
:VPERMPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x16; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermps_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPERMQ 5-387 PAGE 2211 LINE 113768
define pcodeop vpermq_avx2 ;
:VPERMQ YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W1); byte=0x00; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermq_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114262
define pcodeop vpmaskmovd_avx2 ;
:VPMASKMOVD XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x8C; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vpmaskmovd_avx2( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114264
:VPMASKMOVD YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x8C; YmmReg1 ... & m256
{
	YmmReg1 = vpmaskmovd_avx2( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114266
define pcodeop vpmaskmovq_avx2 ;
:VPMASKMOVQ XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x8C; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vpmaskmovq_avx2( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114268
:VPMASKMOVQ YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x8C; YmmReg1 ... & m256
{
	YmmReg1 = vpmaskmovq_avx2( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114270
:VPMASKMOVD m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x8E; XmmReg1 ... & m128
{
	m128 = vpmaskmovd_avx2( vexVVVV_XmmReg, XmmReg1 );
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114272
:VPMASKMOVD m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x8E; YmmReg1 ... & m256
{
	m256 = vpmaskmovd_avx2( vexVVVV_YmmReg, YmmReg1 );
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114274
:VPMASKMOVQ m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x8E; XmmReg1 ... & m128
{
	m128 = vpmaskmovq_avx2( vexVVVV_XmmReg, XmmReg1 );
}

# VPMASKMOV 5-397 PAGE 2221 LINE 114276
:VPMASKMOVQ m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x8E; YmmReg1 ... & m256
{
	m256 = vpmaskmovq_avx2( vexVVVV_YmmReg, YmmReg1 );
}

# VPSLLVW/VPSLLVD/VPSLLVQ 5-445 PAGE 2269 LINE 116620
define pcodeop vpsllvd_avx2 ;
:VPSLLVD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x47; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllvd_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPSLLVW/VPSLLVD/VPSLLVQ 5-445 PAGE 2269 LINE 116623
define pcodeop vpsllvq_avx2 ;
:VPSLLVQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x47; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllvq_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPSLLVW/VPSLLVD/VPSLLVQ 5-445 PAGE 2269 LINE 116626
:VPSLLVD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x47; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsllvd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPSLLVW/VPSLLVD/VPSLLVQ 5-445 PAGE 2269 LINE 116629
:VPSLLVQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x47; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsllvq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPSRAVW/VPSRAVD/VPSRAVQ 5-450 PAGE 2274 LINE 116874
define pcodeop vpsravd_avx2 ;
:VPSRAVD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x46; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsravd_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPSRAVW/VPSRAVD/VPSRAVQ 5-450 PAGE 2274 LINE 116877
:VPSRAVD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x46; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsravd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPSRLVW/VPSRLVD/VPSRLVQ 5-455 PAGE 2279 LINE 117139
define pcodeop vpsrlvd_avx2 ;
:VPSRLVD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x45; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlvd_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPSRLVW/VPSRLVD/VPSRLVQ 5-455 PAGE 2279 LINE 117142
define pcodeop vpsrlvq_avx2 ;
:VPSRLVQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x45; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlvq_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VPSRLVW/VPSRLVD/VPSRLVQ 5-455 PAGE 2279 LINE 117145
:VPSRLVD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x45; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsrlvd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPSRLVW/VPSRLVD/VPSRLVQ 5-455 PAGE 2279 LINE 117148
:VPSRLVQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x45; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsrlvq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/avx2_manual.sinc`:

```sinc
# VINSERTI128/VINSERTI32x4/VINSERTI64x2/VINSERTI32x8/VINSERTI64x4 5-314 PAGE 2138 LINE 109785
define pcodeop vinserti128 ;
:VINSERTI128 YmmReg1, vexVVVV_YmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x38; YmmReg1 ... & XmmReg2_m128; imm8 & imm8_0 {
	local tmp:16 = XmmReg2_m128;

	# ignoring all but the least significant bit
	if (imm8_0:1 == 0) goto <case0>;
	if (imm8_0:1 == 1) goto <case1>;

 <case0>
	YmmReg1[0,128] = tmp;
	YmmReg1[128,128] = vexVVVV_YmmReg[128,128];
	goto <done>;

 <case1>
	YmmReg1[0,128] = vexVVVV_YmmReg[0,128];
	YmmReg1[128,128] = tmp;

 <done>
}

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106903
define pcodeop vgatherdpd ;
:VGATHERDPD XmmReg1, q_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x92; (XmmReg1 & YmmReg1) ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherdpd(XmmReg1, q_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vgatherdpd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106908
@ifdef IA64
define pcodeop vgatherqpd ;
:VGATHERQPD XmmReg1, q_vm64x, vexVVVV_XmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x93; (XmmReg1 & YmmReg1) ... & q_vm64x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherqpd(XmmReg1, q_vm64x, vexVVVV_XmmReg);
	local tmp:16 = vgatherqpd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
@endif

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106913
:VGATHERDPD YmmReg1, q_vm32x, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x92; YmmReg1 ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vgatherdpd(YmmReg1, q_vm32x, vexVVVV_YmmReg);
	YmmReg1 = vgatherdpd(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}

# VGATHERDPD/VGATHERQPD 5-251 PAGE 2075 LINE 106918
@ifdef IA64
:VGATHERQPD YmmReg1, q_vm64y, vexVVVV_YmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x93; YmmReg1 ... & q_vm64y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vgatherqpd(YmmReg1, q_vm64y, vexVVVV_YmmReg);
	YmmReg1 = vgatherqpd(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}
@endif


# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107130
define pcodeop vgatherdps ;
:VGATHERDPS XmmReg1, d_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x92; (XmmReg1 & YmmReg1) ... & d_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherdps(XmmReg1, d_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vgatherdps(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107135
@ifdef IA64
define pcodeop vgatherqps ;
:VGATHERQPS XmmReg1, d_vm64x, vexVVVV_XmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x93; (XmmReg1 & YmmReg1) ... & d_vm64x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherqps(XmmReg1, d_vm64x, vexVVVV_XmmReg);
	local tmp:16 = vgatherqps(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
@endif

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107140
:VGATHERDPS YmmReg1, d_vm32y, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x92; YmmReg1 ... & d_vm32y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vgatherdps(YmmReg1, d_vm32y, vexVVVV_YmmReg);
	YmmReg1 = vgatherdps(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}

# VGATHERDPS/VGATHERQPS 5-256 PAGE 2080 LINE 107145
@ifdef IA64
:VGATHERQPS XmmReg1, d_vm64y, vexVVVV_XmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x93; (XmmReg1 & YmmReg1) ... & d_vm64y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherqps(XmmReg1, d_vm64y, vexVVVV_XmmReg);
	XmmReg1 = vgatherqps(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(XmmReg1);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
@endif

# PCMPEQQ 4-250 PAGE 1370 LINE 71171
:VPCMPEQQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x29; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1[0,64] = zext(vexVVVV_YmmReg[0,64] == YmmReg2_m256[0,64]) * 0xffffffffffffffff:8;
	YmmReg1[64,64] = zext(vexVVVV_YmmReg[64,64] == YmmReg2_m256[64,64]) * 0xffffffffffffffff:8;
	YmmReg1[128,64] = zext(vexVVVV_YmmReg[128,64] == YmmReg2_m256[128,64]) * 0xffffffffffffffff:8;
	YmmReg1[192,64] = zext(vexVVVV_YmmReg[192,64] == YmmReg2_m256[192,64]) * 0xffffffffffffffff:8;
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107884
define pcodeop vpgatherdd ;
:VPGATHERDD XmmReg1, d_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x90; (XmmReg1 & YmmReg1) ... & d_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherdd(XmmReg1, d_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vpgatherdd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107888
@ifdef IA64
define pcodeop vpgatherqd ;
:VPGATHERQD XmmReg1, d_vm64x, vexVVVV_XmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x91; (XmmReg1 & YmmReg1) ... & d_vm64x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherqd(XmmReg1, d_vm64x, vexVVVV_XmmReg);
	local tmp:16 = vpgatherqd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
@endif

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107892
:VPGATHERDD YmmReg1, d_vm32y, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x90; YmmReg1 ... & d_vm32y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vpgatherdd(YmmReg1, d_vm32y, vexVVVV_YmmReg);
	YmmReg1 = vpgatherdd(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}

# VPGATHERDD/VPGATHERQD 5-273 PAGE 2097 LINE 107896
@ifdef IA64
:VPGATHERQD XmmReg1, d_vm64y, vexVVVV_XmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x91; (XmmReg1 & YmmReg1) ... & d_vm64y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherqd(XmmReg1, d_vm64y, vexVVVV_XmmReg);
	local tmp:16 = vpgatherqd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
@endif


# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108234
define pcodeop vpgatherdq ;
:VPGATHERDQ XmmReg1, q_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x90; (XmmReg1 & YmmReg1) ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherdq(XmmReg1, q_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vpgatherdq(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108238
@ifdef IA64
define pcodeop vpgatherqq ;
:VPGATHERQQ XmmReg1, q_vm64x, vexVVVV_XmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x91; (XmmReg1 & YmmReg1) ... & q_vm64x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherqq(XmmReg1, q_vm64x, vexVVVV_XmmReg);
	local tmp:16 = vpgatherqq(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
@endif

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108242
:VPGATHERDQ YmmReg1, q_vm32x, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x90; YmmReg1 ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vpgatherdq(YmmReg1, q_vm32x, vexVVVV_YmmReg);
	YmmReg1 = vpgatherdq(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}

# VPGATHERDQ/VPGATHERQQ 5-280 PAGE 2104 LINE 108246
@ifdef IA64
:VPGATHERQQ YmmReg1, q_vm64y, vexVVVV_YmmReg is $(LONGMODE_ON) & $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x91; YmmReg1 ... & q_vm64y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vpgatherqq(YmmReg1, q_vm64y, vexVVVV_YmmReg);
	YmmReg1 = vpgatherqq(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}
@endif


# PMOVMSKB 4-338 PAGE 1458 LINE 75655
:VPMOVMSKB Reg32, YmmReg2 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xD7; Reg32 & (mod=0x3 & YmmReg2) & check_Reg32_dest
{
	local byte_mask:4 = 0:4;
	byte_mask[0,1] = YmmReg2[7,1];
	byte_mask[1,1] = YmmReg2[15,1];
	byte_mask[2,1] = YmmReg2[23,1];
	byte_mask[3,1] = YmmReg2[31,1];
	byte_mask[4,1] = YmmReg2[39,1];
	byte_mask[5,1] = YmmReg2[47,1];
	byte_mask[6,1] = YmmReg2[55,1];
	byte_mask[7,1] = YmmReg2[63,1];
	byte_mask[8,1] = YmmReg2[71,1];
	byte_mask[9,1] = YmmReg2[79,1];
	byte_mask[10,1] = YmmReg2[87,1];
	byte_mask[11,1] = YmmReg2[95,1];
	byte_mask[12,1] = YmmReg2[103,1];
	byte_mask[13,1] = YmmReg2[111,1];
	byte_mask[14,1] = YmmReg2[119,1];
	byte_mask[15,1] = YmmReg2[127,1];
	byte_mask[16,1] = YmmReg2[135,1];
	byte_mask[17,1] = YmmReg2[143,1];
	byte_mask[18,1] = YmmReg2[151,1];
	byte_mask[19,1] = YmmReg2[159,1];
	byte_mask[20,1] = YmmReg2[167,1];
	byte_mask[21,1] = YmmReg2[175,1];
	byte_mask[22,1] = YmmReg2[183,1];
	byte_mask[23,1] = YmmReg2[191,1];
	byte_mask[24,1] = YmmReg2[199,1];
	byte_mask[25,1] = YmmReg2[207,1];
	byte_mask[26,1] = YmmReg2[215,1];
	byte_mask[27,1] = YmmReg2[223,1];
	byte_mask[28,1] = YmmReg2[231,1];
	byte_mask[29,1] = YmmReg2[239,1];
	byte_mask[30,1] = YmmReg2[247,1];
	byte_mask[31,1] = YmmReg2[255,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/avx_manual.sinc`:

```sinc
# MOVAPD 4-45 PAGE 1165 LINE 60844
:VMOVAPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x28; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
    YmmReg1 = zext(XmmReg2_m128);
    # TODO ZmmReg1 = zext(XmmReg1)
}

# MOVAPD 4-45 PAGE 1165 LINE 60846
:VMOVAPD XmmReg2, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x29; mod=3 & XmmReg1 & (XmmReg2 & YmmReg2)
{
    YmmReg2 = zext(XmmReg1);
    # TODO ZmmReg2 = zext(XmmReg2)
}

# MOVAPD 4-45 PAGE 1165 LINE 60846
:VMOVAPD m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x29; XmmReg1 ... & m128
{
    m128 = XmmReg1;
    # TODO ZmmReg2 = zext(XmmReg2)
}

# MOVAPD 4-45 PAGE 1165 LINE 60848
:VMOVAPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x28; YmmReg1 ... & YmmReg2_m256
{
    YmmReg1 = YmmReg2_m256;
    # TODO ZmmReg1 = zext(YmmReg1)
}

# MOVAPD 4-45 PAGE 1165 LINE 60850
:VMOVAPD YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x29; YmmReg1 ... & YmmReg2_m256
{
    YmmReg2_m256 = YmmReg1;
    # TODO ZmmReg2 = zext(YmmReg2)
}

# MOVAPS 4-49 PAGE 1169 LINE 61039
:VMOVAPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x28; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
    YmmReg1 = zext(XmmReg2_m128);
    # TODO ZmmReg1 = zext(XmmReg1)
}

# MOVAPS 4-49 PAGE 1169 LINE 61041
:VMOVAPS XmmReg2, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x29; mod=3 & XmmReg1 & (XmmReg2 & YmmReg2)
{
    YmmReg2 = zext(XmmReg1);
    # TODO ZmmReg2 = zext(XmmReg2)
}

# MOVAPS 4-49 PAGE 1169 LINE 61041
:VMOVAPS m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x29; XmmReg1 ... & m128
{
    m128 = XmmReg1;
    # TODO ZmmReg2 = zext(XmmReg2)
}

# MOVAPS 4-49 PAGE 1169 LINE 61043
:VMOVAPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x28; YmmReg1 ... & YmmReg2_m256
{
    YmmReg1 = YmmReg2_m256;
    # TODO ZmmReg1 = zext(YmmReg1)
}

# MOVAPS 4-49 PAGE 1169 LINE 61045
:VMOVAPS YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x29; YmmReg1 ... & YmmReg2_m256
{
    YmmReg2_m256 = YmmReg1;
    # TODO ZmmReg2 = zext(YmmReg2)
}

# MOVDQA,VMOVDQA32/64 4-62 PAGE 1182 LINE 61667
# Note: we do not model the exception generated if VMOVDQA is used with a memory operand which is not 16-bye aligned
:VMOVDQA XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	YmmReg1 = zext(XmmReg2_m128);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVDQA,VMOVDQA32/64 4-62 PAGE 1182 LINE 61669
:VMOVDQA XmmReg2, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; XmmReg1 & (mod = 3 & XmmReg2 & YmmReg2)
{
	YmmReg2 = zext(XmmReg1);
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVDQA,VMOVDQA32/64 4-62 PAGE 1182 LINE 61669
:VMOVDQA m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; XmmReg1 ... & m128
{
	m128 = XmmReg1;
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVDQA,VMOVDQA32/64 4-62 PAGE 1182 LINE 61671
:VMOVDQA YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = YmmReg2_m256;
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVDQA,VMOVDQA32/64 4-62 PAGE 1182 LINE 61673
:VMOVDQA YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = YmmReg1;
	# TODO ZmmReg2 = zext(YmmReg2)
}

# MOVSD 4-111 PAGE 1231 LINE 63970
:VMOVSD XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x10; XmmReg1 & YmmReg1 & (mod=0x3 & XmmReg2)
{
	local tmpa:8 = XmmReg2[0,64];
	local tmpb:8 = vexVVVV_XmmReg[64,64];
	YmmReg1 = 0;
	XmmReg1[0,64] = tmpa;
	XmmReg1[64,64] = tmpb;
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVSD 4-111 PAGE 1231 LINE 63972
:VMOVSD XmmReg1, m64 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & m64
{
	YmmReg1[0,64] = m64;
	YmmReg1[64,64] = 0;
	# TODO ZmmReg1 = zext(XmmReg1)
}

# MOVSD 4-111 PAGE 1231 LINE 63974
:VMOVSD XmmReg2, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x11; XmmReg1 & (mod=0x3 & (XmmReg2 & YmmReg2))
{
	local tmpa:8 = XmmReg1[0,64];
	local tmpb:8 = vexVVVV_XmmReg[64,64];
	YmmReg2 = 0;
	XmmReg2[0,64] = tmpa;
	XmmReg2[64,64] = tmpb;
	# TODO ZmmReg2 = zext(XmmReg2)
}

# MOVSD 4-111 PAGE 1231 LINE 63976
:VMOVSD m64, XmmReg1 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & m64
{
	m64 = XmmReg1[0,64];
}

# MOVUPS 4-130 PAGE 1250 LINE 64872
:VMOVUPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = XmmReg2_m128;
	YmmReg1[0,128] = tmp;
	YmmReg1[128,64] = 0;
	YmmReg1[192,64] = 0;
}

# MOVUPS 4-130 PAGE 1250 LINE 64874
# break this into two constructors to handle the zext for the register destination case
:VMOVUPS XmmReg2, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 & (mod = 3 & XmmReg2 & YmmReg2) 
{
	XmmReg2 = XmmReg1;
	YmmReg2 = zext(XmmReg2);
}

# MOVUPS 4-130 PAGE 1250 LINE 64874
:VMOVUPS m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & m128
{
	m128 = XmmReg1;
}

# MOVUPS 4-130 PAGE 1250 LINE 64876
:VMOVUPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x10; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = YmmReg2_m256;
	# TODO ZmmReg1 = zext(YmmReg1)
}

# MOVUPS 4-130 PAGE 1250 LINE 64878
# TODO in general, what do we do with the zext of only the register case; needs investigation
:VMOVUPS YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x11; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = YmmReg1;
}

# PCMPEQQ 4-250 PAGE 1370 LINE 71169
:VPCMPEQQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x29; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1[0,64] = zext(vexVVVV_XmmReg[0,64] == XmmReg2_m128[0,64]) * 0xffffffffffffffff:8;
	XmmReg1[64,64] = zext(vexVVVV_XmmReg[64,64] == XmmReg2_m128[64,64]) * 0xffffffffffffffff:8;
	YmmReg1 = zext(XmmReg1);
	# TODO ZmmReg1 = zext(XmmReg1)
}


# PMOVMSKB 4-338 PAGE 1458 LINE 75651
:VPMOVMSKB Reg32, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xD7; Reg32 & (mod=0x3 & XmmReg2) & check_Reg32_dest
{
	local byte_mask:2 = 0:2;
	byte_mask[0,1] = XmmReg2[7,1];
	byte_mask[1,1] = XmmReg2[15,1];
	byte_mask[2,1] = XmmReg2[23,1];
	byte_mask[3,1] = XmmReg2[31,1];
	byte_mask[4,1] = XmmReg2[39,1];
	byte_mask[5,1] = XmmReg2[47,1];
	byte_mask[6,1] = XmmReg2[55,1];
	byte_mask[7,1] = XmmReg2[63,1];
	byte_mask[8,1] = XmmReg2[71,1];
	byte_mask[9,1] = XmmReg2[79,1];
	byte_mask[10,1] = XmmReg2[87,1];
	byte_mask[11,1] = XmmReg2[95,1];
	byte_mask[12,1] = XmmReg2[103,1];
	byte_mask[13,1] = XmmReg2[111,1];
	byte_mask[14,1] = XmmReg2[119,1];
	byte_mask[15,1] = XmmReg2[127,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}

# VZEROALL 5-563 PAGE 2387 LINE 122405
:VZEROALL  is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x77
{
    YMM0[0,64] = 0:8; YMM0[64,64] = 0:8; YMM0[128,64] = 0:8; YMM0[192,64] = 0:8;
    YMM1[0,64] = 0:8; YMM1[64,64] = 0:8; YMM1[128,64] = 0:8; YMM1[192,64] = 0:8;
    YMM2[0,64] = 0:8; YMM2[64,64] = 0:8; YMM2[128,64] = 0:8; YMM2[192,64] = 0:8;
    YMM3[0,64] = 0:8; YMM3[64,64] = 0:8; YMM3[128,64] = 0:8; YMM3[192,64] = 0:8;
    YMM4[0,64] = 0:8; YMM4[64,64] = 0:8; YMM4[128,64] = 0:8; YMM4[192,64] = 0:8;
    YMM5[0,64] = 0:8; YMM5[64,64] = 0:8; YMM5[128,64] = 0:8; YMM5[192,64] = 0:8;
    YMM6[0,64] = 0:8; YMM6[64,64] = 0:8; YMM6[128,64] = 0:8; YMM6[192,64] = 0:8;
    YMM7[0,64] = 0:8; YMM7[64,64] = 0:8; YMM7[128,64] = 0:8; YMM7[192,64] = 0:8;
    #TODO: Zmm
}

@ifdef IA64
:VZEROALL  is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x77
{
    YMM0[0,64] = 0:8; YMM0[64,64] = 0:8; YMM0[128,64] = 0:8; YMM0[192,64] = 0:8;
    YMM1[0,64] = 0:8; YMM1[64,64] = 0:8; YMM1[128,64] = 0:8; YMM1[192,64] = 0:8;
    YMM2[0,64] = 0:8; YMM2[64,64] = 0:8; YMM2[128,64] = 0:8; YMM2[192,64] = 0:8;
    YMM3[0,64] = 0:8; YMM3[64,64] = 0:8; YMM3[128,64] = 0:8; YMM3[192,64] = 0:8;
    YMM4[0,64] = 0:8; YMM4[64,64] = 0:8; YMM4[128,64] = 0:8; YMM4[192,64] = 0:8;
    YMM5[0,64] = 0:8; YMM5[64,64] = 0:8; YMM5[128,64] = 0:8; YMM5[192,64] = 0:8;
    YMM6[0,64] = 0:8; YMM6[64,64] = 0:8; YMM6[128,64] = 0:8; YMM6[192,64] = 0:8;
    YMM7[0,64] = 0:8; YMM7[64,64] = 0:8; YMM7[128,64] = 0:8; YMM7[192,64] = 0:8;
    YMM8[0,64] = 0:8; YMM8[64,64] = 0:8; YMM8[128,64] = 0:8; YMM8[192,64] = 0:8;
    YMM9[0,64] = 0:8; YMM9[64,64] = 0:8; YMM9[128,64] = 0:8; YMM9[192,64] = 0:8;
    YMM10[0,64] = 0:8; YMM10[64,64] = 0:8; YMM10[128,64] = 0:8; YMM10[192,64] = 0:8;
    YMM11[0,64] = 0:8; YMM11[64,64] = 0:8; YMM11[128,64] = 0:8; YMM11[192,64] = 0:8;
    YMM12[0,64] = 0:8; YMM12[64,64] = 0:8; YMM12[128,64] = 0:8; YMM12[192,64] = 0:8;
    YMM13[0,64] = 0:8; YMM13[64,64] = 0:8; YMM13[128,64] = 0:8; YMM13[192,64] = 0:8;
    YMM14[0,64] = 0:8; YMM14[64,64] = 0:8; YMM14[128,64] = 0:8; YMM14[192,64] = 0:8;
    YMM15[0,64] = 0:8; YMM15[64,64] = 0:8; YMM15[128,64] = 0:8; YMM15[192,64] = 0:8;
    #TODO: Zmm
}
@endif

# VZEROUPPER 5-565 PAGE 2389 LINE 122480
:VZEROUPPER  is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x77
{
    YMM0[128,64] = 0:8; YMM0[192,64] = 0:8;
    YMM1[128,64] = 0:8; YMM1[192,64] = 0:8;
    YMM2[128,64] = 0:8; YMM2[192,64] = 0:8;
    YMM3[128,64] = 0:8; YMM3[192,64] = 0:8;
    YMM4[128,64] = 0:8; YMM4[192,64] = 0:8;
    YMM5[128,64] = 0:8; YMM5[192,64] = 0:8;
    YMM6[128,64] = 0:8; YMM6[192,64] = 0:8;
    YMM7[128,64] = 0:8; YMM7[192,64] = 0:8;
    #TODO: Zmm
}

@ifdef IA64
:VZEROUPPER  is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x77
{
    YMM0[128,64] = 0:8; YMM0[192,64] = 0:8;
    YMM1[128,64] = 0:8; YMM1[192,64] = 0:8;
    YMM2[128,64] = 0:8; YMM2[192,64] = 0:8;
    YMM3[128,64] = 0:8; YMM3[192,64] = 0:8;
    YMM4[128,64] = 0:8; YMM4[192,64] = 0:8;
    YMM5[128,64] = 0:8; YMM5[192,64] = 0:8;
    YMM6[128,64] = 0:8; YMM6[192,64] = 0:8;
    YMM7[128,64] = 0:8; YMM7[192,64] = 0:8;
    YMM8[128,64] = 0:8; YMM8[192,64] = 0:8;
    YMM9[128,64] = 0:8; YMM9[192,64] = 0:8;
    YMM10[128,64] = 0:8; YMM10[192,64] = 0:8;
    YMM11[128,64] = 0:8; YMM11[192,64] = 0:8;
    YMM12[128,64] = 0:8; YMM12[192,64] = 0:8;
    YMM13[128,64] = 0:8; YMM13[192,64] = 0:8;
    YMM14[128,64] = 0:8; YMM14[192,64] = 0:8;
    YMM15[128,64] = 0:8; YMM15[192,64] = 0:8;
    #TODO: Zmm
}
@endif


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/bmi1.sinc`:

```sinc
macro tzcntflags(input, output) {
 ZF = (output == 0);
 CF = (input == 0);
 # OF, SF, PF, AF are undefined
}


####
#### BMI1 instructions
####

# TODO remove ANDN from ia.sinc ?????
:ANDN Reg32, vexVVVV_r32, rm32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf2; Reg32 ... & check_Reg32_dest ... &rm32
{
  Reg32 = ~(vexVVVV_r32) & rm32;
  resultflags(Reg32);
  OF = 0;
  CF = 0;
  build check_Reg32_dest;
}

@ifdef IA64
# TODO remove ANDN from ia.sinc ?????
:ANDN Reg64, vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf2; Reg64 ... & rm64
{
  Reg64 = ~(vexVVVV_r64) & rm64;
  resultflags(Reg64);
  OF = 0;
  CF = 0;
}
@endif


:BEXTR Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  sourceTmp:1 = vexVVVV_r32[0,8];
  lengthTmp:1 = vexVVVV_r32[8,8];

  Reg32 = (rm32 >> sourceTmp) & ((1 << lengthTmp) - 1);
  build check_Reg32_dest;

  ZF = (Reg32 == 0);
  OF = 0;
  CF = 0;
  # AF, SF, and PF are undefined
}

@ifdef IA64
:BEXTR Reg64, rm64, vexVVVV_r64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf7; Reg64 ... & rm64
{
  sourceTmp:1 = vexVVVV_r64[0,8];
  lengthTmp:1 = vexVVVV_r64[8,8];

  Reg64 = (rm64 >> sourceTmp) & ((1 << lengthTmp) - 1);

  ZF = (Reg64 == 0);
  OF = 0;
  CF = 0;
  # AF, SF, and PF are undefined
}
@endif


:BLSI vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf3; reg_opcode=3 ... & check_vexVVVV_r32_dest ... & rm32
{
  vexVVVV_r32 = -rm32 & rm32;
  build check_vexVVVV_r32_dest;

  ZF = (vexVVVV_r32 == 0);
  SF = (vexVVVV_r32 s< 0);
  CF = (rm32 != 0);
  OF = 0;
  # AF and PF are undefined
}

@ifdef IA64
:BLSI vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf3; reg_opcode=3 ... & rm64
{
  vexVVVV_r64 = -rm64 & rm64;

  ZF = (vexVVVV_r64 == 0);
  SF = (vexVVVV_r64 s< 0);
  CF = (rm64 != 0);
  OF = 0;
  # AF and PF are undefined
}
@endif


:BLSMSK vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf3; reg_opcode=2 ... & check_vexVVVV_r32_dest ... &rm32
{
  CF = (rm32 == 0);
  vexVVVV_r32 = (rm32 - 1) ^ rm32;

  SF = (vexVVVV_r32 s< 0);
  build check_vexVVVV_r32_dest;
  ZF = 0;
  OF = 0;
  # AF and PF are undefined
}

@ifdef IA64
:BLSMSK vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf3; reg_opcode=2 ... & rm64
{
  CF = (rm64 == 0);
  vexVVVV_r64 = (rm64 - 1) ^ rm64;

  SF = (vexVVVV_r64 s< 0);
  ZF = 0;
  OF = 0;
  # AF and PF are undefined
}
@endif


:BLSR vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf3; reg_opcode=1 ... & check_vexVVVV_r32_dest ... &rm32
{
  CF = (rm32 == 0);
  vexVVVV_r32 = (rm32 - 1) & rm32;
  build check_vexVVVV_r32_dest;

  ZF = (vexVVVV_r32 == 0);
  SF = (vexVVVV_r32 s< 0);
  OF = 0;
  # AF and PF are undefined
}

@ifdef IA64
:BLSR vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf3; reg_opcode=1 ... & rm64
{
  CF = (rm64 == 0);
  vexVVVV_r64 = (rm64 - 1) & rm64;

  ZF = (vexVVVV_r64 == 0);
  SF = (vexVVVV_r64 s< 0);
  OF = 0;
  # AF and PF are undefined
}
@endif

# not as documented in manual; requires PRE_66 prefix to get 16-bit operation
:TZCNT Reg16, rm16	is vexMode=0 & opsize=0 & $(PRE_66) & $(PRE_F3) & byte=0x0F; byte=0xBC; Reg16 ... & rm16 {

  countTmp:2 = 0;
  inputTmp:2 = rm16;

 <loopbegin>
  if ((inputTmp & 1) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp >> 1) | 0x8000;
  goto <loopbegin>;

 <loopend>
  tzcntflags(rm16, countTmp);
  Reg16 = countTmp;
 
}

:TZCNT Reg32, rm32	is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0F; byte=0xBC; Reg32 ... & check_Reg32_dest ... & rm32 {

  countTmp:4 = 0;
  inputTmp:4 = rm32;

 <loopbegin>
  if ((inputTmp & 1) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp >> 1) | 0x80000000;
  goto <loopbegin>;

 <loopend>
  tzcntflags(rm32, countTmp);
  Reg32 = countTmp;
  build check_Reg32_dest;
}

@ifdef IA64
:TZCNT Reg64, rm64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & $(REX_W) & byte=0x0F; byte=0xBC; Reg64 ... & rm64 {

  countTmp:8 = 0;
  inputTmp:8 = rm64;

 <loopbegin>
  if ((inputTmp & 1) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp >> 1) | 0x8000000000000000;
  goto <loopbegin>;

 <loopend>
  tzcntflags(rm64, countTmp);
  Reg64 = countTmp;
}
@endif

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/bmi2.sinc`:

```sinc
####
#### BMI2 instructions
####


:BZHI Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf5; Reg32 ... & check_Reg32_dest ... & rm32
{
  indexTmp:1 = vexVVVV_r32:1;

  # saturate index amount to 32; operand size or higher does not clear any bits
  shift:1 = (indexTmp <= 32) * (32 - indexTmp);

  # clear the upper bits
  Reg32 = (rm32 << shift) >> shift;
  build check_Reg32_dest;

  ZF = (Reg32 == 0);
  SF = (Reg32 s< 0);
  CF = indexTmp > 31;
  OF = 0;
  # AF and PF are undefined
}

@ifdef IA64
:BZHI Reg64, rm64, vexVVVV_r64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf5; Reg64 ... & rm64
{
  indexTmp:1 = vexVVVV_r64:1;

  # saturate index amount to 64; operand size or higher does not clear any bits
  shift:1 = (indexTmp <= 64) * (64 - indexTmp);

  # clear the upper bits
  Reg64 = (rm64 << shift) >> shift;

  ZF = (Reg64 == 0);
  SF = (Reg64 s< 0);
  CF = indexTmp > 63;
  OF = 0;
  # AF and PF are undefined
}
@endif


:MULX Reg32, vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf6; Reg32 ... & check_Reg32_dest ... &  check_vexVVVV_r32_dest ... & rm32
{
  temp:8 = zext(EDX) * zext(rm32);

  vexVVVV_r32 = temp:4;
  build check_vexVVVV_r32_dest;
  Reg32 = temp(4);
  build check_Reg32_dest;
}

@ifdef IA64
:MULX Reg64, vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf6; Reg64 ... & rm64
{
  temp:16 = zext(RDX) * zext(rm64);

  vexVVVV_r64 = temp:8;
  Reg64 = temp(8);
}
@endif


:PDEP Reg32, vexVVVV_r32, rm32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf5; Reg32 ... & check_Reg32_dest ... & rm32
{
  sourceTmp:4 = vexVVVV_r32;

  indexTmp:4 = 1;
  resultTmp:4 = 0;

 <loop>
  maskBit:4 = rm32 & indexTmp;

  if (maskBit == 0) goto <nextMaskBit>;
  resultTmp = resultTmp | (maskBit * (sourceTmp & 1));
  sourceTmp = sourceTmp >> 1;

 <nextMaskBit>
  indexTmp = indexTmp << 1;
  if (indexTmp != 0) goto <loop>;

  Reg32 = resultTmp;
  build check_Reg32_dest;
}

@ifdef IA64
:PDEP Reg64, vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf5; Reg64 ... & rm64
{
  sourceTmp:8 = vexVVVV_r64;

  indexTmp:8 = 1;
  resultTmp:8 = 0;

 <loop>
  maskBit:8 = rm64 & indexTmp;

  if (maskBit == 0) goto <nextMaskBit>;
  resultTmp = resultTmp | (maskBit * (sourceTmp & 1));
  sourceTmp = sourceTmp >> 1;

 <nextMaskBit>
  indexTmp = indexTmp << 1;
  if (indexTmp != 0) goto <loop>;

  Reg64 = resultTmp;
}
@endif


:PEXT Reg32, vexVVVV_r32, rm32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F3) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf5; Reg32 ... & check_Reg32_dest ... & rm32
{
  indexTmp:4 = 0x80000000;
  resultTmp:4 = 0;

 <loop>
  maskBit:4 = rm32 & indexTmp;

  if (maskBit == 0) goto <nextMaskBit>;
  resultTmp = (resultTmp << 1) | zext((maskBit & vexVVVV_r32) != 0);

 <nextMaskBit>
  indexTmp = indexTmp >> 1;
  if (indexTmp != 0) goto <loop>;

  build check_Reg32_dest;
  Reg32 = resultTmp;
}

@ifdef IA64
:PEXT Reg64, vexVVVV_r64, rm64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F3) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf5; Reg64 ... & rm64
{
  indexTmp:8 = 0x8000000000000000;
  resultTmp:8 = 0;

 <loop>
  maskBit:8 = rm64 & indexTmp;

  if (maskBit == 0) goto <nextMaskBit>;
  resultTmp = (resultTmp << 1) | zext((maskBit & vexVVVV_r64) != 0);

 <nextMaskBit>
  indexTmp = indexTmp >> 1;
  if (indexTmp != 0) goto <loop>;

  Reg64 = resultTmp;
}
@endif


:RORX Reg32, rm32, imm8 is $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F3A) & $(VEX_W0); byte=0xf0; Reg32 ... & check_Reg32_dest ... & rm32; imm8
{
  shiftTmp:1 = (imm8:1 & 0x1F);

  Reg32 = (rm32 >> shiftTmp) | ( rm32 << (32 - shiftTmp));
  build check_Reg32_dest;
}

@ifdef IA64
:RORX Reg64, rm64, imm8 is $(LONGMODE_ON) & $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F3A) & $(VEX_W1); byte=0xf0; Reg64 ... & rm64; imm8
{
  shiftTmp:1 = (imm8:1 & 0x3F);

  Reg64 = (rm64 >> shiftTmp) | ( rm64 << (64 - shiftTmp));
}
@endif


:SARX Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F3) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  Reg32 = rm32 s>> (vexVVVV_r32 & 0x0000001F);
  build check_Reg32_dest;
}

@ifdef IA64
:SARX Reg64, rm64, vexVVVV_r64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F3) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf7; Reg64 ... & rm64
{
  Reg64 = rm64 s>> (vexVVVV_r64 & 0x000000000000003F);
}
@endif


:SHLX Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  Reg32 = rm32 << (vexVVVV_r32 & 0x0000001F);
  build check_Reg32_dest;
}

@ifdef IA64
:SHLX Reg64, rm64, vexVVVV_r64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf7; Reg64 ... & rm64
{
  Reg64 = rm64 << (vexVVVV_r64 & 0x000000000000003F);
}
@endif


:SHRX Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  Reg32 = rm32 >> (vexVVVV_r32 & 0x0000001F);
  build check_Reg32_dest;
}

@ifdef IA64
:SHRX Reg64, rm64, vexVVVV_r64 is $(LONGMODE_ON) & $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_r64; byte=0xf7; Reg64 ... & rm64
{
  Reg64 = rm64 >> (vexVVVV_r64 & 0x000000000000003F);
}
@endif


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/cet.sinc`:

```sinc
#
# Instructions based on Intel Control-flow Enforcement Technology Preview
#
# Note: Shadow Stack semantics is not currently implemented correctly in these instructions
#       nor in the instructions affected by CET
#


define pcodeop ShadowStackPush8B;
define pcodeop ShadowStackPush4B;

define pcodeop ShadowStackLoad8B;
define pcodeop ShadowStackLoad4B;

:INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
@ifdef IA64
:INCSSPQ r64 is $(LONGMODE_ON) & vexMode=0 & $(PRE_F3) & $(REX_W) & byte=0x0f; byte=0xae; reg_opcode=5 & r64 {
    SSP = SSP + zext(8 * r64:1);
}
@endif

:RDSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; mod=3 & reg_opcode=1 & r32 {
    r32 = SSP:4;
}
@ifdef IA64
:RDSSPQ r64 is $(LONGMODE_ON) & vexMode=0 & $(PRE_F3) & $(REX_W) & byte=0x0f; byte=0x1e; mod=3 & reg_opcode=1 & r64 {
    r64 = SSP;
}
@endif

:SAVEPREVSSP  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xea {
    tmp:8 = SSP;
    SSP = SSP & ~0x7;
    ShadowStackPush8B(tmp);
}
   

:RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}

define pcodeop writeToShadowStack;
define pcodeop writeToUserShadowStack;


:WRSSD rm32,Reg32 is vexMode=0 & byte=0x0f; byte=0x38; byte=0xf6; rm32 & Reg32 ... { 
    writeToShadowStack(rm32, Reg32);
}
@ifdef IA64
:WRSSQ rm64,Reg64 is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0f; byte=0x0f; byte=0x38; byte=0xf6; rm64 & Reg64 ...  { 
    writeToShadowStack(rm64, Reg64);
}
@endif

:WRUSSD rm32,Reg32 is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0xf5; rm32 & Reg32 ... { 
    writeToUserShadowStack(rm32, Reg32);
}
@ifdef IA64
:WRUSSQ rm64,Reg64 is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & $(REX_W) & byte=0x0f; byte=0x0f; byte=0x38; byte=0xf5; rm64 & Reg64 ...  { 
    writeToUserShadowStack(rm64, Reg64);
}
@endif

define pcodeop markShadowStackBusy;
define pcodeop clearShadowStackBusy;

:SETSSBSY is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xe8 {
   SSP = markShadowStackBusy(IA32_PL0_SSP);
}

:CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}

:ENDBR32  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; byte=0xfb {}
@ifdef IA64
:ENDBR64  is $(LONGMODE_ON) & vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; byte=0xfa {}
@endif



```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/clwb.sinc`:

```sinc
define pcodeop clwb;
:CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}

@ifdef IA64
define pcodeop clflushopt;
:CLFLUSHOPT m8      is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=7 ... {
	clflushopt(m8);
}
@endif

# Note: PCOMMIT was deprecated prior to it ever being implemented in production processors.
# I never found the encoding for it.  Therefore, no constructor.

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/fma.sinc`:

```sinc
#
# x86 FMA instructions
#

# VFIXUPIMMSD 5-120 PAGE 1944 LINE 101211
define pcodeop vfmadd132pd_fma ;
:VFMADD132PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x98; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmadd132pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFIXUPIMMSD 5-120 PAGE 1944 LINE 101214
define pcodeop vfmadd213pd_fma ;
:VFMADD213PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xA8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmadd213pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFIXUPIMMSD 5-120 PAGE 1944 LINE 101217
define pcodeop vfmadd231pd_fma ;
:VFMADD231PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xB8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmadd231pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFIXUPIMMSD 5-120 PAGE 1944 LINE 101220
:VFMADD132PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x98; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmadd132pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFIXUPIMMSD 5-120 PAGE 1944 LINE 101223
:VFMADD213PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xA8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmadd213pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFIXUPIMMSD 5-120 PAGE 1944 LINE 101226
:VFMADD231PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xB8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmadd231pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFIXUPIMMSS 5-127 PAGE 1951 LINE 101572
define pcodeop vfmadd132ps_fma ;
:VFMADD132PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x98; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmadd132ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFIXUPIMMSS 5-127 PAGE 1951 LINE 101575
define pcodeop vfmadd213ps_fma ;
:VFMADD213PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xA8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmadd213ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFIXUPIMMSS 5-127 PAGE 1951 LINE 101578
define pcodeop vfmadd231ps_fma ;
:VFMADD231PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xB8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmadd231ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFIXUPIMMSS 5-127 PAGE 1951 LINE 101581
:VFMADD132PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x98; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmadd132ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFIXUPIMMSS 5-127 PAGE 1951 LINE 101584
:VFMADD213PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xA8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmadd213ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFIXUPIMMSS 5-127 PAGE 1951 LINE 101587
# WARNING: did not recognize VEX field 0 for "VFMADD231PS ymm1, ymm2, ymm3/m256"
:VFMADD231PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0xB8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmadd231ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMADD132PS/VFMADD213PS/VFMADD231PS 5-134 PAGE 1958 LINE 101931
define pcodeop vfmadd132sd_fma ;
:VFMADD132SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x99; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfmadd132sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132PS/VFMADD213PS/VFMADD231PS 5-134 PAGE 1958 LINE 101934
define pcodeop vfmadd213sd_fma ;
:VFMADD213SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xA9; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfmadd213sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132PS/VFMADD213PS/VFMADD231PS 5-134 PAGE 1958 LINE 101937
define pcodeop vfmadd231sd_fma ;
:VFMADD231SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xB9; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfmadd231sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-137 PAGE 1961 LINE 102099
define pcodeop vfmadd132ss_fma ;
:VFMADD132SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x99; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfmadd132ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-137 PAGE 1961 LINE 102102
define pcodeop vfmadd213ss_fma ;
:VFMADD213SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xA9; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfmadd213ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-137 PAGE 1961 LINE 102105
define pcodeop vfmadd231ss_fma ;
:VFMADD231SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xB9; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfmadd231ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD 5-140 PAGE 1964 LINE 102272
define pcodeop vfmaddsub132pd_fma ;
:VFMADDSUB132PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x96; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmaddsub132pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD 5-140 PAGE 1964 LINE 102275
define pcodeop vfmaddsub213pd_fma ;
:VFMADDSUB213PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xA6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmaddsub213pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD 5-140 PAGE 1964 LINE 102278
define pcodeop vfmaddsub231pd_fma ;
:VFMADDSUB231PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xB6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmaddsub231pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD 5-140 PAGE 1964 LINE 102281
:VFMADDSUB132PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x96; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmaddsub132pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD 5-140 PAGE 1964 LINE 102284
:VFMADDSUB213PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xA6; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmaddsub213pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD 5-140 PAGE 1964 LINE 102287
:VFMADDSUB231PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xB6; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmaddsub231pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-150 PAGE 1974 LINE 102711
define pcodeop vfmaddsub132ps_fma ;
:VFMADDSUB132PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x96; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmaddsub132ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-150 PAGE 1974 LINE 102714
define pcodeop vfmaddsub213ps_fma ;
:VFMADDSUB213PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xA6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmaddsub213ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-150 PAGE 1974 LINE 102717
define pcodeop vfmaddsub231ps_fma ;
:VFMADDSUB231PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xB6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmaddsub231ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-150 PAGE 1974 LINE 102720
:VFMADDSUB132PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x96; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmaddsub132ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-150 PAGE 1974 LINE 102723
:VFMADDSUB213PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xA6; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmaddsub213ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMADD132SS/VFMADD213SS/VFMADD231SS 5-150 PAGE 1974 LINE 102726
:VFMADDSUB231PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xB6; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmaddsub231ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD 5-159 PAGE 1983 LINE 103141
define pcodeop vfmsubadd132pd_fma ;
:VFMSUBADD132PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x97; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsubadd132pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD 5-159 PAGE 1983 LINE 103144
define pcodeop vfmsubadd213pd_fma ;
:VFMSUBADD213PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xA7; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsubadd213pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD 5-159 PAGE 1983 LINE 103147
define pcodeop vfmsubadd231pd_fma ;
:VFMSUBADD231PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xB7; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsubadd231pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD 5-159 PAGE 1983 LINE 103150
:VFMSUBADD132PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x97; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsubadd132pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD 5-159 PAGE 1983 LINE 103153
:VFMSUBADD213PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xA7; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsubadd213pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD 5-159 PAGE 1983 LINE 103156
:VFMSUBADD231PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xB7; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsubadd231pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS 5-169 PAGE 1993 LINE 103581
define pcodeop vfmsubadd132ps_fma ;
:VFMSUBADD132PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x97; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsubadd132ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS 5-169 PAGE 1993 LINE 103584
define pcodeop vfmsubadd213ps_fma ;
:VFMSUBADD213PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xA7; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsubadd213ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS 5-169 PAGE 1993 LINE 103587
define pcodeop vfmsubadd231ps_fma ;
:VFMSUBADD231PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xB7; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsubadd231ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS 5-169 PAGE 1993 LINE 103590
:VFMSUBADD132PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x97; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsubadd132ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS 5-169 PAGE 1993 LINE 103593
:VFMSUBADD213PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xA7; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsubadd213ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS 5-169 PAGE 1993 LINE 103596
:VFMSUBADD231PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xB7; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsubadd231ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132PD/VFMSUB213PD/VFMSUB231PD 5-179 PAGE 2003 LINE 104019
define pcodeop vfmsub132pd_fma ;
:VFMSUB132PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x9A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsub132pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132PD/VFMSUB213PD/VFMSUB231PD 5-179 PAGE 2003 LINE 104022
define pcodeop vfmsub213pd_fma ;
:VFMSUB213PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xAA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsub213pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132PD/VFMSUB213PD/VFMSUB231PD 5-179 PAGE 2003 LINE 104025
define pcodeop vfmsub231pd_fma ;
:VFMSUB231PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xBA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsub231pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132PD/VFMSUB213PD/VFMSUB231PD 5-179 PAGE 2003 LINE 104028
:VFMSUB132PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x9A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsub132pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132PD/VFMSUB213PD/VFMSUB231PD 5-179 PAGE 2003 LINE 104031
:VFMSUB213PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xAA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsub213pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132PD/VFMSUB213PD/VFMSUB231PD 5-179 PAGE 2003 LINE 104034
:VFMSUB231PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xBA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsub231pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132PS/VFMSUB213PS/VFMSUB231PS 5-186 PAGE 2010 LINE 104379
define pcodeop vfmsub132ps_fma ;
:VFMSUB132PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x9A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsub132ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132PS/VFMSUB213PS/VFMSUB231PS 5-186 PAGE 2010 LINE 104382
define pcodeop vfmsub213ps_fma ;
:VFMSUB213PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xAA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsub213ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132PS/VFMSUB213PS/VFMSUB231PS 5-186 PAGE 2010 LINE 104385
define pcodeop vfmsub231ps_fma ;
:VFMSUB231PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xBA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfmsub231ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132PS/VFMSUB213PS/VFMSUB231PS 5-186 PAGE 2010 LINE 104388
:VFMSUB132PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x9A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsub132ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132PS/VFMSUB213PS/VFMSUB231PS 5-186 PAGE 2010 LINE 104391
:VFMSUB213PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xAA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsub213ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132PS/VFMSUB213PS/VFMSUB231PS 5-186 PAGE 2010 LINE 104394
# WARNING: did not recognize VEX field 0 for "VFMSUB231PS ymm1, ymm2, ymm3/m256"
:VFMSUB231PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0xBA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfmsub231ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFMSUB132SD/VFMSUB213SD/VFMSUB231SD 5-193 PAGE 2017 LINE 104738
define pcodeop vfmsub132sd_fma ;
:VFMSUB132SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x9B; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfmsub132sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132SD/VFMSUB213SD/VFMSUB231SD 5-193 PAGE 2017 LINE 104741
define pcodeop vfmsub213sd_fma ;
:VFMSUB213SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xAB; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfmsub213sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132SD/VFMSUB213SD/VFMSUB231SD 5-193 PAGE 2017 LINE 104744
define pcodeop vfmsub231sd_fma ;
:VFMSUB231SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xBB; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfmsub231sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132SS/VFMSUB213SS/VFMSUB231SS 5-196 PAGE 2020 LINE 104913
define pcodeop vfmsub132ss_fma ;
:VFMSUB132SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x9B; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfmsub132ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132SS/VFMSUB213SS/VFMSUB231SS 5-196 PAGE 2020 LINE 104916
define pcodeop vfmsub213ss_fma ;
:VFMSUB213SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xAB; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfmsub213ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFMSUB132SS/VFMSUB213SS/VFMSUB231SS 5-196 PAGE 2020 LINE 104919
define pcodeop vfmsub231ss_fma ;
:VFMSUB231SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xBB; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfmsub231ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PD/VFNMADD213PD/VFNMADD231PD 5-199 PAGE 2023 LINE 105088
define pcodeop vfnmadd132pd_fma ;
:VFNMADD132PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x9C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmadd132pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PD/VFNMADD213PD/VFNMADD231PD 5-199 PAGE 2023 LINE 105091
define pcodeop vfnmadd213pd_fma ;
:VFNMADD213PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xAC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmadd213pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PD/VFNMADD213PD/VFNMADD231PD 5-199 PAGE 2023 LINE 105094
define pcodeop vfnmadd231pd_fma ;
:VFNMADD231PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xBC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmadd231pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PD/VFNMADD213PD/VFNMADD231PD 5-199 PAGE 2023 LINE 105097
:VFNMADD132PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x9C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmadd132pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMADD132PD/VFNMADD213PD/VFNMADD231PD 5-199 PAGE 2023 LINE 105100
:VFNMADD213PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xAC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmadd213pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMADD132PD/VFNMADD213PD/VFNMADD231PD 5-199 PAGE 2023 LINE 105103
:VFNMADD231PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xBC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmadd231pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMADD132PS/VFNMADD213PS/VFNMADD231PS 5-206 PAGE 2030 LINE 105447
define pcodeop vfnmadd132ps_fma ;
:VFNMADD132PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x9C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmadd132ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PS/VFNMADD213PS/VFNMADD231PS 5-206 PAGE 2030 LINE 105450
define pcodeop vfnmadd213ps_fma ;
:VFNMADD213PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xAC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmadd213ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PS/VFNMADD213PS/VFNMADD231PS 5-206 PAGE 2030 LINE 105453
define pcodeop vfnmadd231ps_fma ;
:VFNMADD231PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xBC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmadd231ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132PS/VFNMADD213PS/VFNMADD231PS 5-206 PAGE 2030 LINE 105456
:VFNMADD132PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x9C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmadd132ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMADD132PS/VFNMADD213PS/VFNMADD231PS 5-206 PAGE 2030 LINE 105459
:VFNMADD213PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xAC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmadd213ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMADD132PS/VFNMADD213PS/VFNMADD231PS 5-206 PAGE 2030 LINE 105462
# WARNING: did not recognize VEX field 0 for "VFNMADD231PS ymm1, ymm2, ymm3/m256"
:VFNMADD231PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0xBC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmadd231ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMADD132SD/VFNMADD213SD/VFNMADD231SD 5-212 PAGE 2036 LINE 105794
define pcodeop vfnmadd132sd_fma ;
:VFNMADD132SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x9D; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfnmadd132sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132SD/VFNMADD213SD/VFNMADD231SD 5-212 PAGE 2036 LINE 105797
define pcodeop vfnmadd213sd_fma ;
:VFNMADD213SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xAD; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfnmadd213sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132SD/VFNMADD213SD/VFNMADD231SD 5-212 PAGE 2036 LINE 105800
define pcodeop vfnmadd231sd_fma ;
:VFNMADD231SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xBD; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfnmadd231sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132SS/VFNMADD213SS/VFNMADD231SS 5-215 PAGE 2039 LINE 105966
define pcodeop vfnmadd132ss_fma ;
:VFNMADD132SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x9D; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfnmadd132ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132SS/VFNMADD213SS/VFNMADD231SS 5-215 PAGE 2039 LINE 105969
define pcodeop vfnmadd213ss_fma ;
:VFNMADD213SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xAD; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfnmadd213ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMADD132SS/VFNMADD213SS/VFNMADD231SS 5-215 PAGE 2039 LINE 105972
define pcodeop vfnmadd231ss_fma ;
:VFNMADD231SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xBD; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfnmadd231ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD 5-218 PAGE 2042 LINE 106138
define pcodeop vfnmsub132pd_fma ;
:VFNMSUB132PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x9E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmsub132pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD 5-218 PAGE 2042 LINE 106141
define pcodeop vfnmsub213pd_fma ;
:VFNMSUB213PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xAE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmsub213pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD 5-218 PAGE 2042 LINE 106144
define pcodeop vfnmsub231pd_fma ;
:VFNMSUB231PD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xBE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmsub231pd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD 5-218 PAGE 2042 LINE 106147
:VFNMSUB132PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x9E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmsub132pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD 5-218 PAGE 2042 LINE 106150
:VFNMSUB213PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xAE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmsub213pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD 5-218 PAGE 2042 LINE 106153
:VFNMSUB231PD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0xBE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmsub231pd_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS 5-224 PAGE 2048 LINE 106487
define pcodeop vfnmsub132ps_fma ;
:VFNMSUB132PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x9E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmsub132ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS 5-224 PAGE 2048 LINE 106490
define pcodeop vfnmsub213ps_fma ;
:VFNMSUB213PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xAE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmsub213ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS 5-224 PAGE 2048 LINE 106493
define pcodeop vfnmsub231ps_fma ;
:VFNMSUB231PS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xBE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vfnmsub231ps_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS 5-224 PAGE 2048 LINE 106496
:VFNMSUB132PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x9E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmsub132ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS 5-224 PAGE 2048 LINE 106499
:VFNMSUB213PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0xAE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmsub213ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS 5-224 PAGE 2048 LINE 106502
# WARNING: did not recognize VEX field 0 for "VFNMSUB231PS ymm1, ymm2, ymm3/m256"
:VFNMSUB231PS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0xBE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vfnmsub231ps_fma( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}

# VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD 5-230 PAGE 2054 LINE 106832
define pcodeop vfnmsub132sd_fma ;
:VFNMSUB132SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x9F; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfnmsub132sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD 5-230 PAGE 2054 LINE 106835
define pcodeop vfnmsub213sd_fma ;
:VFNMSUB213SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xAF; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfnmsub213sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD 5-230 PAGE 2054 LINE 106838
define pcodeop vfnmsub231sd_fma ;
:VFNMSUB231SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0xBF; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vfnmsub231sd_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS 5-233 PAGE 2057 LINE 107004
define pcodeop vfnmsub132ss_fma ;
:VFNMSUB132SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x9F; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfnmsub132ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS 5-233 PAGE 2057 LINE 107007
define pcodeop vfnmsub213ss_fma ;
:VFNMSUB213SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xAF; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfnmsub213ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}

# VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS 5-233 PAGE 2057 LINE 107010
define pcodeop vfnmsub231ss_fma ;
:VFNMSUB231SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xBF; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vfnmsub231ss_fma( XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/ia.sinc`:

```sinc
# SLA specification file for Intel x86

@ifdef IA64
@define SIZE     "8"
@define STACKPTR "RSP"
@else
@define SIZE     "4"
@define STACKPTR "ESP"
@endif

define endian=little;

define space ram type=ram_space size=$(SIZE) default;
define space register type=register_space size=4;

# General purpose registers

@ifdef IA64
define register offset=0 size=8      [  RAX               RCX               RDX               RBX               RSP               RBP               RSI               RDI ];
define register offset=0 size=4      [  EAX _             ECX _             EDX _             EBX _             ESP _             EBP _             ESI _             EDI ];
define register offset=0 size=2      [  AX _ _ _          CX _ _ _          DX _ _ _          BX _ _ _          SP _ _ _          BP _ _ _          SI _ _ _          DI ];
define register offset=0 size=1      [  AL AH _ _ _ _ _ _ CL CH _ _ _ _ _ _ DL DH _ _ _ _ _ _ BL BH _ _ _ _ _ _ SPL _ _ _ _ _ _ _ BPL _ _ _ _ _ _ _ SIL _ _ _ _ _ _ _ DIL ];

define register offset=0x80 size=8     [ R8                R9                R10                R11                R12                R13                R14                R15 ];
define register offset=0x80 size=4     [ R8D _             R9D _             R10D _             R11D _             R12D _             R13D _             R14D _             R15D _ ];
define register offset=0x80 size=2     [ R8W _ _ _         R9W _ _ _         R10W _ _ _         R11W _ _ _         R12W _ _ _         R13W _ _ _         R14W _ _ _         R15W _ _ _ ];
define register offset=0x80 size=1     [ R8B _ _ _ _ _ _ _ R9B _ _ _ _ _ _ _ R10B _ _ _ _ _ _ _ R11B _ _ _ _ _ _ _ R12B _ _ _ _ _ _ _ R13B _ _ _ _ _ _ _ R14B _ _ _ _ _ _ _ R15B _ _ _ _ _ _ _ ];
@else
define register offset=0 size=4      [  EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI ];
define register offset=0 size=2      [  AX _ CX _ DX _ BX _ SP _ BP _ SI _ DI ];
define register offset=0 size=1      [  AL AH _ _ CL CH _ _ DL DH _ _ BL BH ];
@endif

# Segment registers
define register offset=0x100 size=2          [ ES CS SS DS FS GS ];
define register offset=0x110 size=$(SIZE)    [ FS_OFFSET GS_OFFSET ];

# Flags
define register offset=0x200 size=1    [ CF F1 PF F3 AF F5 ZF SF
                                         TF IF DF OF IOPL NT F15
                                         RF VM AC VIF VIP ID ];
@ifdef IA64
define register offset=0x280 size=8    [ rflags      RIP ];
define register offset=0x280 size=4    [ eflags _    EIP _ ];
define register offset=0x280 size=2    [ flags _ _ _ IP _ _ _];
@else
define register offset=0x280 size=4    [ eflags EIP] ;
define register offset=0x280 size=2    [ flags _ IP] ;
@endif

# Debug and control registers

@ifdef IA64
define register offset=0x300 size=8    [ DR0 DR1 DR2 DR3 DR4 DR5 DR6 DR7
                                         DR8 DR9 DR10 DR11 DR12 DR13 DR14 DR15
                                         CR0 CR1 CR2 CR3 CR4 CR5 CR6 CR7
                                         CR8 CR9 CR10 CR11 CR12 CR13 CR14 CR15 ];
@else
define register offset=0x300 size=4    [ DR0 DR1 DR2 DR3 DR4 DR5 DR6 DR7
                                         CR0 _   CR2 CR3 CR4 ];
define register offset=0x400 size=4    [ TR0 TR1 TR2 TR3 TR4 TR5 TR6 TR7 ];
@endif

#Processor State Register - currently only XFEATURE_ENABLED_MASK=XCR0 is defined
#
define register offset=0x600 size=8    [ XCR0 ];

# Memory Protection Extensions (MPX)
define register offset=0x700 size=8    [ BNDCFGS BNDCFGU BNDSTATUS ];

define register offset=0x740 size=16   [ BND0 BND1 BND2 BND3 _ _ _ _ ];
define register offset=0x740 size=8    [ BND0_LB BND0_UB BND1_LB BND1_UB BND2_LB BND2_UB BND3_LB BND3_UB _ _ _ _ _ _ _ _ ];

# Control Flow Extensions
define register offset=0x7c0 size=8    [ SSP IA32_PL2_SSP IA32_PL1_SSP IA32_PL0_SSP ];

# Floating point registers - as they are in 32-bit protected mode
# See MMx registers below
define register offset=0x1106 size=10  [ ST0 ];
define register offset=0x1116 size=10  [ ST1 ];
define register offset=0x1126 size=10  [ ST2 ];
define register offset=0x1136 size=10  [ ST3 ];
define register offset=0x1146 size=10  [ ST4 ];
define register offset=0x1156 size=10  [ ST5 ];
define register offset=0x1166 size=10  [ ST6 ];
define register offset=0x1176 size=10  [ ST7 ];
define register offset=0x1090 size=1   [ C0 C1 C2 C3 ];
define register offset=0x1094 size=4   [ MXCSR ];
define register offset=0x10a0 size=2   [ FPUControlWord FPUStatusWord FPUTagWord
                                         FPULastInstructionOpcode ];
define register offset=0x10a8 size=$(SIZE)   [ FPUDataPointer FPUInstructionPointer ];
define register offset=0x10c8 size=2  [ FPUPointerSelector FPUDataSelector]; #FCS FDS
                                         
  # FCS is not modeled, deprecated as 0.
  # FDS not modeled, deprecated as 0.

#
# YMM0 - YMM7    - available in 32 bit mode
# YMM0 - YMM15   - available in 64 bit mode
#                                      
define register offset=0x1100 size=8   [ _ MM0 _ MM1 _ MM2 _ MM3 _ MM4 _ MM5 _ MM6 _ MM7 ];
define register offset=0x1100 size=4   [
  _ _ MM0_Da MM0_Db 
  _ _ MM1_Da MM1_Db 
  _ _ MM2_Da MM2_Db 
  _ _ MM3_Da MM3_Db 
  _ _ MM4_Da MM4_Db 
  _ _ MM5_Da MM5_Db 
  _ _ MM6_Da MM6_Db 
  _ _ MM7_Da MM7_Db 
];
define register offset=0x1100 size=2   [
  _ _ _ _ MM0_Wa MM0_Wb MM0_Wc MM0_Wd 
  _ _ _ _ MM1_Wa MM1_Wb MM1_Wc MM1_Wd 
  _ _ _ _ MM2_Wa MM2_Wb MM2_Wc MM2_Wd 
  _ _ _ _ MM3_Wa MM3_Wb MM3_Wc MM3_Wd 
  _ _ _ _ MM4_Wa MM4_Wb MM4_Wc MM4_Wd 
  _ _ _ _ MM5_Wa MM5_Wb MM5_Wc MM5_Wd 
  _ _ _ _ MM6_Wa MM6_Wb MM6_Wc MM6_Wd 
  _ _ _ _ MM7_Wa MM7_Wb MM7_Wc MM7_Wd 
];
define register offset=0x1100 size=1   [
  _ _ _ _ _ _ _ _ 
  MM0_Ba MM0_Bb MM0_Bc MM0_Bd MM0_Be MM0_Bf MM0_Bg MM0_Bh 
  _ _ _ _ _ _ _ _ 
  MM1_Ba MM1_Bb MM1_Bc MM1_Bd MM1_Be MM1_Bf MM1_Bg MM1_Bh 
  _ _ _ _ _ _ _ _ 
  MM2_Ba MM2_Bb MM2_Bc MM2_Bd MM2_Be MM2_Bf MM2_Bg MM2_Bh 
  _ _ _ _ _ _ _ _ 
  MM3_Ba MM3_Bb MM3_Bc MM3_Bd MM3_Be MM3_Bf MM3_Bg MM3_Bh 
  _ _ _ _ _ _ _ _ 
  MM4_Ba MM4_Bb MM4_Bc MM4_Bd MM4_Be MM4_Bf MM4_Bg MM4_Bh 
  _ _ _ _ _ _ _ _ 
  MM5_Ba MM5_Bb MM5_Bc MM5_Bd MM5_Be MM5_Bf MM5_Bg MM5_Bh 
  _ _ _ _ _ _ _ _ 
  MM6_Ba MM6_Bb MM6_Bc MM6_Bd MM6_Be MM6_Bf MM6_Bg MM6_Bh 
  _ _ _ _ _ _ _ _ 
  MM7_Ba MM7_Bb MM7_Bc MM7_Bd MM7_Be MM7_Bf MM7_Bg MM7_Bh 
];


# YMMx_H is the formal name for the high double quadword of the YMMx register, XMMx is the overlay in the XMM register set
define register offset=0x1200 size=16  [
	XMM0 YMM0_H
	XMM1 YMM1_H 
	XMM2 YMM2_H 
	XMM3 YMM3_H 
	XMM4 YMM4_H
	XMM5 YMM5_H
	XMM6 YMM6_H
	XMM7 YMM7_H
	XMM8 YMM8_H
	XMM9 YMM9_H
	XMM10 YMM10_H
	XMM11 YMM11_H
	XMM12 YMM12_H
	XMM13 YMM13_H
	XMM14 YMM14_H
	XMM15 YMM15_H
];

define register offset=0x1200 size=8   [
  XMM0_Qa  XMM0_Qb  _ _
  XMM1_Qa  XMM1_Qb  _ _
  XMM2_Qa  XMM2_Qb  _ _
  XMM3_Qa  XMM3_Qb  _ _
  XMM4_Qa  XMM4_Qb  _ _
  XMM5_Qa  XMM5_Qb  _ _
  XMM6_Qa  XMM6_Qb  _ _
  XMM7_Qa  XMM7_Qb  _ _
  XMM8_Qa  XMM8_Qb  _ _
  XMM9_Qa  XMM9_Qb  _ _
  XMM10_Qa XMM10_Qb _ _
  XMM11_Qa XMM11_Qb _ _
  XMM12_Qa XMM12_Qb _ _
  XMM13_Qa XMM13_Qb _ _
  XMM14_Qa XMM14_Qb _ _
  XMM15_Qa XMM15_Qb _ _
];
define register offset=0x1200 size=4   [
  XMM0_Da  XMM0_Db  XMM0_Dc  XMM0_Dd  _ _ _ _
  XMM1_Da  XMM1_Db  XMM1_Dc  XMM1_Dd  _ _ _ _
  XMM2_Da  XMM2_Db  XMM2_Dc  XMM2_Dd  _ _ _ _
  XMM3_Da  XMM3_Db  XMM3_Dc  XMM3_Dd  _ _ _ _
  XMM4_Da  XMM4_Db  XMM4_Dc  XMM4_Dd  _ _ _ _
  XMM5_Da  XMM5_Db  XMM5_Dc  XMM5_Dd  _ _ _ _
  XMM6_Da  XMM6_Db  XMM6_Dc  XMM6_Dd  _ _ _ _
  XMM7_Da  XMM7_Db  XMM7_Dc  XMM7_Dd  _ _ _ _
  XMM8_Da  XMM8_Db  XMM8_Dc  XMM8_Dd  _ _ _ _
  XMM9_Da  XMM9_Db  XMM9_Dc  XMM9_Dd  _ _ _ _
  XMM10_Da XMM10_Db XMM10_Dc XMM10_Dd _ _ _ _
  XMM11_Da XMM11_Db XMM11_Dc XMM11_Dd _ _ _ _
  XMM12_Da XMM12_Db XMM12_Dc XMM12_Dd _ _ _ _
  XMM13_Da XMM13_Db XMM13_Dc XMM13_Dd _ _ _ _
  XMM14_Da XMM14_Db XMM14_Dc XMM14_Dd _ _ _ _
  XMM15_Da XMM15_Db XMM15_Dc XMM15_Dd _ _ _ _
];
define register offset=0x1200 size=2   [
  XMM0_Wa  XMM0_Wb  XMM0_Wc  XMM0_Wd  XMM0_We  XMM0_Wf  XMM0_Wg  XMM0_Wh  _ _ _ _ _ _ _ _
  XMM1_Wa  XMM1_Wb  XMM1_Wc  XMM1_Wd  XMM1_We  XMM1_Wf  XMM1_Wg  XMM1_Wh  _ _ _ _ _ _ _ _
  XMM2_Wa  XMM2_Wb  XMM2_Wc  XMM2_Wd  XMM2_We  XMM2_Wf  XMM2_Wg  XMM2_Wh  _ _ _ _ _ _ _ _
  XMM3_Wa  XMM3_Wb  XMM3_Wc  XMM3_Wd  XMM3_We  XMM3_Wf  XMM3_Wg  XMM3_Wh  _ _ _ _ _ _ _ _
  XMM4_Wa  XMM4_Wb  XMM4_Wc  XMM4_Wd  XMM4_We  XMM4_Wf  XMM4_Wg  XMM4_Wh  _ _ _ _ _ _ _ _
  XMM5_Wa  XMM5_Wb  XMM5_Wc  XMM5_Wd  XMM5_We  XMM5_Wf  XMM5_Wg  XMM5_Wh  _ _ _ _ _ _ _ _
  XMM6_Wa  XMM6_Wb  XMM6_Wc  XMM6_Wd  XMM6_We  XMM6_Wf  XMM6_Wg  XMM6_Wh  _ _ _ _ _ _ _ _
  XMM7_Wa  XMM7_Wb  XMM7_Wc  XMM7_Wd  XMM7_We  XMM7_Wf  XMM7_Wg  XMM7_Wh  _ _ _ _ _ _ _ _
  XMM8_Wa  XMM8_Wb  XMM8_Wc  XMM8_Wd  XMM8_We  XMM8_Wf  XMM8_Wg  XMM8_Wh  _ _ _ _ _ _ _ _
  XMM9_Wa  XMM9_Wb  XMM9_Wc  XMM9_Wd  XMM9_We  XMM9_Wf  XMM9_Wg  XMM9_Wh  _ _ _ _ _ _ _ _
  XMM10_Wa XMM10_Wb XMM10_Wc XMM10_Wd XMM10_We XMM10_Wf XMM10_Wg XMM10_Wh _ _ _ _ _ _ _ _
  XMM11_Wa XMM11_Wb XMM11_Wc XMM11_Wd XMM11_We XMM11_Wf XMM11_Wg XMM11_Wh _ _ _ _ _ _ _ _
  XMM12_Wa XMM12_Wb XMM12_Wc XMM12_Wd XMM12_We XMM12_Wf XMM12_Wg XMM12_Wh _ _ _ _ _ _ _ _
  XMM13_Wa XMM13_Wb XMM13_Wc XMM13_Wd XMM13_We XMM13_Wf XMM13_Wg XMM13_Wh _ _ _ _ _ _ _ _
  XMM14_Wa XMM14_Wb XMM14_Wc XMM14_Wd XMM14_We XMM14_Wf XMM14_Wg XMM14_Wh _ _ _ _ _ _ _ _
  XMM15_Wa XMM15_Wb XMM15_Wc XMM15_Wd XMM15_We XMM15_Wf XMM15_Wg XMM15_Wh _ _ _ _ _ _ _ _
];
define register offset=0x1200 size=1   [
  XMM0_Ba  XMM0_Bb  XMM0_Bc  XMM0_Bd  XMM0_Be  XMM0_Bf  XMM0_Bg  XMM0_Bh  XMM0_Bi  XMM0_Bj  XMM0_Bk  XMM0_Bl  XMM0_Bm  XMM0_Bn  XMM0_Bo  XMM0_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM1_Ba  XMM1_Bb  XMM1_Bc  XMM1_Bd  XMM1_Be  XMM1_Bf  XMM1_Bg  XMM1_Bh  XMM1_Bi  XMM1_Bj  XMM1_Bk  XMM1_Bl  XMM1_Bm  XMM1_Bn  XMM1_Bo  XMM1_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM2_Ba  XMM2_Bb  XMM2_Bc  XMM2_Bd  XMM2_Be  XMM2_Bf  XMM2_Bg  XMM2_Bh  XMM2_Bi  XMM2_Bj  XMM2_Bk  XMM2_Bl  XMM2_Bm  XMM2_Bn  XMM2_Bo  XMM2_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM3_Ba  XMM3_Bb  XMM3_Bc  XMM3_Bd  XMM3_Be  XMM3_Bf  XMM3_Bg  XMM3_Bh  XMM3_Bi  XMM3_Bj  XMM3_Bk  XMM3_Bl  XMM3_Bm  XMM3_Bn  XMM3_Bo  XMM3_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM4_Ba  XMM4_Bb  XMM4_Bc  XMM4_Bd  XMM4_Be  XMM4_Bf  XMM4_Bg  XMM4_Bh  XMM4_Bi  XMM4_Bj  XMM4_Bk  XMM4_Bl  XMM4_Bm  XMM4_Bn  XMM4_Bo  XMM4_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM5_Ba  XMM5_Bb  XMM5_Bc  XMM5_Bd  XMM5_Be  XMM5_Bf  XMM5_Bg  XMM5_Bh  XMM5_Bi  XMM5_Bj  XMM5_Bk  XMM5_Bl  XMM5_Bm  XMM5_Bn  XMM5_Bo  XMM5_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM6_Ba  XMM6_Bb  XMM6_Bc  XMM6_Bd  XMM6_Be  XMM6_Bf  XMM6_Bg  XMM6_Bh  XMM6_Bi  XMM6_Bj  XMM6_Bk  XMM6_Bl  XMM6_Bm  XMM6_Bn  XMM6_Bo  XMM6_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM7_Ba  XMM7_Bb  XMM7_Bc  XMM7_Bd  XMM7_Be  XMM7_Bf  XMM7_Bg  XMM7_Bh  XMM7_Bi  XMM7_Bj  XMM7_Bk  XMM7_Bl  XMM7_Bm  XMM7_Bn  XMM7_Bo  XMM7_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM8_Ba  XMM8_Bb  XMM8_Bc  XMM8_Bd  XMM8_Be  XMM8_Bf  XMM8_Bg  XMM8_Bh  XMM8_Bi  XMM8_Bj  XMM8_Bk  XMM8_Bl  XMM8_Bm  XMM8_Bn  XMM8_Bo  XMM8_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM9_Ba  XMM9_Bb  XMM9_Bc  XMM9_Bd  XMM9_Be  XMM9_Bf  XMM9_Bg  XMM9_Bh  XMM9_Bi  XMM9_Bj  XMM9_Bk  XMM9_Bl  XMM9_Bm  XMM9_Bn  XMM9_Bo  XMM9_Bp  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM10_Ba XMM10_Bb XMM10_Bc XMM10_Bd XMM10_Be XMM10_Bf XMM10_Bg XMM10_Bh XMM10_Bi XMM10_Bj XMM10_Bk XMM10_Bl XMM10_Bm XMM10_Bn XMM10_Bo XMM10_Bp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM11_Ba XMM11_Bb XMM11_Bc XMM11_Bd XMM11_Be XMM11_Bf XMM11_Bg XMM11_Bh XMM11_Bi XMM11_Bj XMM11_Bk XMM11_Bl XMM11_Bm XMM11_Bn XMM11_Bo XMM11_Bp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM12_Ba XMM12_Bb XMM12_Bc XMM12_Bd XMM12_Be XMM12_Bf XMM12_Bg XMM12_Bh XMM12_Bi XMM12_Bj XMM12_Bk XMM12_Bl XMM12_Bm XMM12_Bn XMM12_Bo XMM12_Bp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM13_Ba XMM13_Bb XMM13_Bc XMM13_Bd XMM13_Be XMM13_Bf XMM13_Bg XMM13_Bh XMM13_Bi XMM13_Bj XMM13_Bk XMM13_Bl XMM13_Bm XMM13_Bn XMM13_Bo XMM13_Bp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM14_Ba XMM14_Bb XMM14_Bc XMM14_Bd XMM14_Be XMM14_Bf XMM14_Bg XMM14_Bh XMM14_Bi XMM14_Bj XMM14_Bk XMM14_Bl XMM14_Bm XMM14_Bn XMM14_Bo XMM14_Bp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  XMM15_Ba XMM15_Bb XMM15_Bc XMM15_Bd XMM15_Be XMM15_Bf XMM15_Bg XMM15_Bh XMM15_Bi XMM15_Bj XMM15_Bk XMM15_Bl XMM15_Bm XMM15_Bn XMM15_Bo XMM15_Bp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
];
define register offset=0x1200 size=32  [ YMM0   YMM1   YMM2   YMM3   YMM4    YMM5    YMM6    YMM7    YMM8    YMM9   YMM10    YMM11    YMM12    YMM13    YMM14    YMM15 ];

# 0x1400 is next spot
define register offset=0x1400 size=16  [ xmmTmp1 xmmTmp2 ];
define register offset=0x1400 size=8   [
  xmmTmp1_Qa  xmmTmp1_Qb
  xmmTmp2_Qa  xmmTmp2_Qb
];
define register offset=0x1400 size=4   [
  xmmTmp1_Da  xmmTmp1_Db  xmmTmp1_Dc  xmmTmp1_Dd
  xmmTmp2_Da  xmmTmp2_Db  xmmTmp2_Dc  xmmTmp2_Dd
];

# Define context bits
define register offset=0x2000 size=8   contextreg;

#
#
# This context layout is important:  the 32 bit version sees addrsize as just the
# low-order bit, whereas the 64 bit sees both bits.  This ensures that the 32 and 64
# are technically binary compatible, but since the 32 bit language can't see that
# addrsize is 2 bits, they won't be pulled up into constructors where bit 0 is always
# 0 (which it is), and then you don't get the decision conflicts that choose
# context over table order
#
#

define context contextreg
@ifdef IA64
  # Stored context
  longMode=(0,0)      # 0 for 32-bit emulation, 1 for 64-bit mode
  reserved=(1,3)
  addrsize=(4,5)        # =0  16-bit addressing  =1  32-bit addressing   =2 64-bit addressing
@else
  # Stored context
  reserved=(0,3)
  addrsize=(5,5)        # =0  16-bit addressing  =1  32-bit addressing
@endif
  bit64=(4,4)           # =0  16/32 bit          =1  64-bit
  opsize=(6,7)          # =0  16-bit operands    =1  32-bit operands     =2 64-bit operands
  segover=(8,10)         # 0=default 1=cs 2=ss 3=ds 4=es 5=fs 6=gs
  highseg=(8,8)         # high bit of segover will be set for ES, FS, GS
  protectedMode=(11,11)   # 0 for real mode, 1 for protected mode
  # End stored context

  repneprefx=(12,12)      # 0xf2 REPNE prefix
  repprefx=(13,13)        # 0xf3 REP prefix
  xacquireprefx=(12,12)   # 0xf2 XACQUIRE prefix
  xreleaseprefx=(13,13)   # 0xf3 XRELEASE prefix
  prefix_66=(14,14)       # This is not really a OPSIZE override, it means there is an real(read)/implied(vex) 66 byte
  prefix_f3=(13,13)       # This is not really a REP override, it means there is an real(read)/implied(vex) f3 byte
  prefix_f2=(12,12)       # This is not really a REPNE override, it means there is a real(read)/implied(vex) f2 byte
  mandover=(12,14)        # 0x66 0xf2 or 0xf3 overrides (for mandatory prefixes)

  rexWprefix=(15,15)    # REX.W bit prefix (opsize=2 when REX.W is set)
  rexRprefix=(16,16)    # REX.R bit prefix extend r
  rexXprefix=(17,17)    # REX.X bit prefix extend SIB index field to 4 bits
  rexBprefix=(18,18)    # REX.B bit prefix extend r/m, SIB base, Reg operand
  rexWRXBprefix=(15,18) # REX.WRXB bits
  rexprefix=(19,19)     # True if the Rex prefix is present - note, if present, vex_mode is not supported
                        #   rexWRXB bits can be re-used since they are incompatible.
  vexMode=(20,20)       # 1 for vex instruction, 0 for normal
  vexL=(21,21)          # 0 for 128, 1 for 256
  vexVVVV=(22,25)       # value of vex byte for matching
  vexVVVV_r32=(22,25)   # value of vex byte for matching a normal 32 bit register
  vexVVVV_r64=(22,25)   # value of vex byte for matching a normal 64 bit register
  vexVVVV_XmmReg=(22,25)       # value of vex byte for matching XmmReg
  vexVVVV_YmmReg=(22,25)       # value of vex byte for matching YmmReg
  vexMMMMM=(26,30)      # need to match for preceding bytes 1=0x0F, 2=0x0F 0x38, 3=0x0F 0x3A
  
  suffix3D=(21,28)      # 3DNow suffix byte (overlaps un-modified vex context region)
  instrPhase=(31,31)    # 0: initial/prefix phase, 1: primary instruction phase

  lockprefx=(32,32)     # 0xf0 LOCK prefix
;


# These are only to be used with pre-REX (original 8086, 80386) and REX encoding.  Do not use with VEX encoding.
# These are to be used to designate that the opcode sequence begins with one of these "mandatory" prefix values.
# This allows the other prefixes to come before the mandatory value.
# For example:    CRC32 r32, r16 -- 66  F2 OF 38 F1 C8

@define PRE_NO		"mandover=0"
@define PRE_66		"prefix_66=1"
@define PRE_F3		"prefix_f3=1"
@define PRE_F2		"prefix_f2=1"



# Define special registers for debugger
@ifdef IA64
define register offset=0x2200 size=4   [ IDTR_Limit ];
define register offset=0x2200 size=12   [ IDTR   ];
define register offset=0x2204 size=8   [ IDTR_Address ];

define register offset=0x2220 size=4   [ GDTR_Limit ];
define register offset=0x2220 size=12   [ GDTR   ];
define register offset=0x2224 size=8   [ GDTR_Address ];

define register offset=0x2240 size=4   [ LDTR_Limit ];
define register offset=0x2240 size=14  [ LDTR   ];
define register offset=0x2244 size=8   [ LDTR_Address ];
define register offset=0x2248 size=2   [ LDTR_Attributes ];

define register offset=0x2260 size=4   [ TR_Limit ];
define register offset=0x2260 size=14  [ TR   ];
define register offset=0x2264 size=8   [ TR_Address ];
define register offset=0x2268 size=2   [ TR_Attributes ];
@else
define register offset=0x2200 size=6   [ IDTR         ];
define register offset=0x2200 size=2   [ IDTR_Limit   ];
define register offset=0x2202 size=4   [ IDTR_Address ];

define register offset=0x2210 size=6   [ GDTR         ];
define register offset=0x2210 size=2   [ GDTR_Limit   ];
define register offset=0x2212 size=4   [ GDTR_Address ];

define register offset=0x2220 size=6   [ LDTR         ];
define register offset=0x2220 size=2   [ LDTR_Limit   ];
define register offset=0x2222 size=4   [ LDTR_Address ];

define register offset=0x2230 size=6   [ TR           ];
define register offset=0x2230 size=2   [ TR_Limit     ];
define register offset=0x2232 size=4   [ TR_Address   ];
@endif

define token opbyte (8)
  byte=(0,7)
  high4=(4,7)
  high5=(3,7)
  low5=(0,4)
  byte_4=(4,4)
  byte_0=(0,0)
;

define token modrm (8)
  mod           = (6,7)
  reg_opcode    = (3,5)
  reg_opcode_hb = (5,5)
  r_m           = (0,2)
  row           = (4,7)
  col           = (0,2)
  page          = (3,3)
  cond          = (0,3)
  reg8          = (3,5)
  reg16         = (3,5)
  reg32         = (3,5)
  reg64         = (3,5)
  reg8_x0       = (3,5)
  reg8_x1       = (3,5)
  reg16_x       = (3,5)
  reg32_x       = (3,5)
  reg64_x       = (3,5)
  Sreg          = (3,5)
  creg          = (3,5)
  creg_x        = (3,5)
  debugreg      = (3,5)
  debugreg_x    = (3,5)
  testreg       = (3,5)
  r8            = (0,2)
  r16           = (0,2)
  r32           = (0,2)
  r64           = (0,2)
  r8_x0         = (0,2)
  r8_x1         = (0,2)
  r16_x         = (0,2)
  r32_x         = (0,2)
  r64_x         = (0,2)
  frow          = (4,7)
  fpage         = (3,3)
  freg          = (0,2)
  rexw          = (3,3)
  rexr          = (2,2)
  rexx          = (1,1)
  rexb          = (0,0)
  mmxmod        = (6,7)
  mmxreg        = (3,5)
  mmxreg1       = (3,5)
  mmxreg2       = (0,2)
  xmmmod        = (6,7)
  xmmreg        = (3,5)
  ymmreg        = (3,5)

  xmmreg1       = (3,5)
  ymmreg1       = (3,5)
  xmmreg2       = (0,2)
  ymmreg2       = (0,2)

  xmmreg_x      = (3,5)
  ymmreg_x      = (3,5)
  xmmreg1_x     = (3,5)
  ymmreg1_x     = (3,5)
  xmmreg2_x     = (0,2)
  ymmreg2_x     = (0,2)
  vex_pp        = (0,1)
  vex_l         = (2,2)
  vex_vvvv      = (3,6)
  vex_r         = (7,7)
  vex_x         = (6,6)
  vex_b         = (5,5)
  vex_w         = (7,7)
  vex_mmmmm     = (0,4)
  bnd1          = (3,5)
  bnd1_lb       = (3,5)
  bnd1_ub       = (3,5)
  bnd2          = (0,2)
  bnd2_lb       = (0,2)
  bnd2_ub       = (0,2)
;

define token sib (8)
  ss			= (6,7)
  index			= (3,5)
  index_x		= (3,5)
  index64		= (3,5)
  index64_x		= (3,5)
  xmm_vsib		= (3,5)
  xmm_vsib_x	= (3,5)
  ymm_vsib		= (3,5)
  ymm_vsib_x	= (3,5)
  base			= (0,2)
  base_x		= (0,2)
  base64		= (0,2)
  base64_x		= (0,2)
;

define token I8 (8)
  imm8_7=(7,7)
  Xmm_imm8_7_4=(4,7)
  Ymm_imm8_7_4=(4,7)
  imm8_4=(4,4)
  imm8_0=(0,0)
  imm8_3_0=(0,3)
  imm8=(0,7)
  simm8=(0,7) signed
;
  
define token I16 (16)     imm16_15=(15,15) imm16=(0,15)   simm16=(0,15) signed   j16=(0,15);
define token I32 (32)     imm32=(0,31)   simm32=(0,31) signed;
define token I64 (64)     imm64=(0,63)   simm64=(0,63) signed;
define token override (8)  over=(0,7);

attach variables [ r32   reg32   base   index ]         [ EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI ];
attach variables [ r16   reg16 ]                        [ AX   CX   DX   BX   SP   BP   SI   DI ];
attach variables [ r8    reg8 ]                         [ AL   CL   DL   BL   AH   CH   DH   BH ];
attach variables Sreg  [  ES  CS  SS  DS  FS  GS   _   _  ];
attach variables freg  [  ST0 ST1 ST2 ST3 ST4 ST5 ST6 ST7 ];
attach variables [ debugreg ]  [ DR0 DR1 DR2 DR3 DR4 DR5 DR6 DR7 ];
@ifdef IA64
attach variables [ r64   reg64   base64   index64 ]     [ RAX  RCX RDX RBX RSP RBP RSI RDI ];
attach variables [ r64_x reg64_x base64_x index64_x ]   [ R8   R9  R10 R11 R12 R13 R14 R15 ];
attach variables [ r32_x reg32_x base_x index_x ]       [ R8D  R9D  R10D R11D R12D R13D R14D R15D ];
attach variables [ r16_x reg16_x ]                      [ R8W  R9W  R10W R11W R12W R13W R14W R15W ];
attach variables [ r8_x0  reg8_x0 ]                     [ AL   CL   DL   BL   SPL  BPL  SIL  DIL  ];
attach variables [ r8_x1  reg8_x1 ]                     [ R8B  R9B  R10B R11B R12B R13B R14B R15B ];
attach variables [ debugreg_x ]  [ DR8 DR9 DR10 DR11 DR12 DR13 DR14 DR15 ];
attach variables creg  [ CR0 CR1 CR2 CR3 CR4 CR5 CR6 CR7 ];
attach variables creg_x [ CR8 CR9 CR10 CR11 CR12 CR13 CR14 CR15 ];
@else
attach variables [ testreg ]   [ TR0 TR1 TR2 TR3 TR6 TR7 TR6 TR7 ];
attach variables creg  [ CR0 _ CR2 CR3 CR4 _ _ _ ];
@endif

attach values ss  [ 1 2 4 8];

attach variables [ mmxreg mmxreg1 mmxreg2 ] [ MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7 ];

attach variables [ xmmreg xmmreg1 xmmreg2 xmm_vsib ] [ XMM0 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 ];

attach variables [ xmmreg_x xmmreg1_x xmmreg2_x xmm_vsib_x ] [ XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15 ];

attach variables [ vexVVVV_XmmReg Xmm_imm8_7_4 ] [ XMM0 XMM1 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15 ];

attach variables [ vexVVVV_YmmReg Ymm_imm8_7_4 ] [ YMM0 YMM1 YMM2 YMM3 YMM4 YMM5 YMM6 YMM7 YMM8 YMM9 YMM10 YMM11 YMM12 YMM13 YMM14 YMM15 ];

@ifdef IA64
attach variables [ vexVVVV_r32 ] [ EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI R8D  R9D  R10D R11D R12D R13D R14D R15D ];
attach variables [ vexVVVV_r64 ] [ RAX  RCX  RDX  RBX  RSP  RBP  RSI  RDI R8   R9   R10  R11  R12  R13  R14  R15 ];
@else
attach variables [ vexVVVV_r32 ] [ EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI _    _    _    _    _    _    _    _ ];
@endif


attach variables [ ymmreg ymmreg1 ymmreg2 ymm_vsib ]			[ YMM0 YMM1  YMM2  YMM3  YMM4  YMM5  YMM6  YMM7 ];
attach variables [ ymmreg_x ymmreg1_x ymmreg2_x ymm_vsib_x ]	[ YMM8 YMM9 YMM10 YMM11 YMM12 YMM13 YMM14 YMM15 ];

attach variables [ bnd1 bnd2 ]       [ BND0 BND1 BND2 BND3 _ _ _ _ ];
attach variables [ bnd1_lb bnd2_lb ] [ BND0_LB BND1_LB BND2_LB BND3_LB _ _ _ _ ];
attach variables [ bnd1_ub bnd2_ub ] [ BND0_UB BND1_UB BND2_UB BND3_UB _ _ _ _ ];

define pcodeop segment;    # Define special pcodeop that calculates the RAM address
                           # given the segment selector and offset as input

define pcodeop in;         # force in/out to show up in decompiler
define pcodeop out;
define pcodeop sysenter;
define pcodeop sysexit;
define pcodeop syscall;
define pcodeop sysret;
define pcodeop swapgs;
define pcodeop invlpg;
define pcodeop invlpga;
define pcodeop invpcid;
define pcodeop rdtscp;
define pcodeop mwait;
define pcodeop mwaitx;
define pcodeop monitor;
define pcodeop monitorx;
define pcodeop swi;        # for INT instruction

define pcodeop LOCK;       # for LOCK prefix
define pcodeop UNLOCK;     # for LOCK prefix
define pcodeop XACQUIRE;   # for XACQUIRE prefix
define pcodeop XRELEASE;   # for XRELEASE prefix

# MFL: definitions for AMD hardware assisted virtualization instructions
define pcodeop clgi;      # clear global interrupt flag (GIF)
define pcodeop stgi;      # set global interrupt flag (GIF)
define pcodeop vmload;    # Load state from VMCD, opcode 0f 01 da
define pcodeop vmmcall;   # Call VMM, opcode 0f 01 d9
define pcodeop vmrun;     # Run virtual machine, opcode 0f 01 d8
define pcodeop vmsave;    # Save state to VMCB, opcode 0f 0a db

# MFL: definitions for Intel IA hardware assisted virtualization instructions
define pcodeop invept;   # Invalidate Translations Derived from extended page tables (EPT); opcode 66 0f 38 80
define pcodeop invvpid;  # Invalidate Translations Based on virtual-processor identifier (VPID); opcode 66 0f 38 81
define pcodeop vmcall;   # Call to VM monitor by causing VM exit, opcode 0f 01 c1
define pcodeop vmclear;  # Clear virtual-machine control structure, opcode 66 0f c7 /6
define pcodeop vmfunc;   # call virtual-machine function refernced by EAX
define pcodeop vmlaunch; # Launch virtual machine managed by current VMCCS; opcode 0f 01 c2
define pcodeop vmresume; # Resume virtual machine managed by current VMCS; opcode 0f 01 c3
define pcodeop vmptrld;  # Load pointer to virtual-machine control structure; opcode 0f c6 /6
define pcodeop vmptrst;  # Store pointer to virtual-machine control structure; opcode 0f c7 /7
define pcodeop vmread;   # Read field from virtual-machine control structure; opcode 0f 78
define pcodeop vmwrite;  # Write field to virtual-machine control structure; opcode 0f 79
define pcodeop vmxoff;   # Leave VMX operation; opcode 0f 01 c4
define pcodeop vmxon;    # Enter VMX operation; opcode f3 0f C7 /6 

@ifdef IA64
@define LONGMODE_ON "longMode=1"
@define LONGMODE_OFF "longMode=0"
@else
@define LONGMODE_OFF "epsilon" # NOP
@endif

# When not running in 64-bit mode opcode 0x82 is an alias for 0x80

@ifdef IA64
@define BYTE_80_82 "(byte=0x80 | (longMode=0 & byte=0x82))"
@else
@define BYTE_80_82 "(byte=0x80 | byte=0x82)"
@endif

@ifdef IA64
Reg8:   reg8        is rexprefix=0 & reg8                               { export reg8; }
Reg8:   reg8_x0     is rexprefix=1 & rexRprefix=0 & reg8_x0             { export reg8_x0; }
Reg8:   reg8_x1     is rexprefix=1 & rexRprefix=1 & reg8_x1             { export reg8_x1; }
Reg16:  reg16       is rexRprefix=0 & reg16                             { export reg16; }
Reg16:  reg16_x     is rexRprefix=1 & reg16_x                           { export reg16_x; }
Reg32:  reg32       is rexRprefix=0 & reg32                             { export reg32; }
Reg32:  reg32_x     is rexRprefix=1 & reg32_x                           { export reg32_x; }
Reg64:  reg64       is rexRprefix=0 & reg64                             { export reg64; }
Reg64:  reg64_x     is rexRprefix=1 & reg64_x                           { export reg64_x; }
Rmr8:   r8          is rexprefix=0 & r8                                 { export r8; }
Rmr8:   r8_x0       is rexprefix=1 & rexBprefix=0 & r8_x0               { export r8_x0; }
Rmr8:   r8_x1       is rexprefix=1 & rexBprefix=1 & r8_x1               { export r8_x1; }
CRmr8:  r8          is rexBprefix=0 & r8	                            { export r8; }
CRmr8:  r8          is addrsize=2 & rexBprefix=0 & r8                   { export r8; }
CRmr8:  r8_x0       is addrsize=2 & rexprefix=1 & rexBprefix=0 & r8_x0  { export r8_x0; }
CRmr8:  r8_x1       is addrsize=2 & rexprefix=1 & rexBprefix=1 & r8_x1  { export r8_x1; }
Rmr16:  r16         is rexBprefix=0 & r16                               { export r16; }
Rmr16:  r16_x       is rexBprefix=1 & r16_x                             { export r16_x; }
CRmr16: r16         is rexBprefix=0 & r16                               { export r16; }
CRmr16: r16_x       is rexBprefix=1 & r16_x                             { export r16_x; }
Rmr32:  r32         is rexBprefix=0 & r32                               { export r32; }
Rmr32:  r32_x       is rexBprefix=1 & r32_x                             { export r32_x; }
CRmr32: r32         is rexBprefix=0 & r32 & r64                         { export r64; }
CRmr32: r32_x       is rexBprefix=1 & r32_x & r64_x                     { export r64_x; }
Rmr64:  r64         is rexBprefix=0 & r64                               { export r64; }
Rmr64:  r64_x       is rexBprefix=1 & r64_x                             { export r64_x; }
Base:   base        is rexBprefix=0 & base                              { export base; }
Base:   base_x      is rexBprefix=1 & base_x                            { export base_x; }
Index:  index       is rexXprefix=0 & index                             { export index; }
Index:  index_x     is rexXprefix=1 & index_x                           { export index_x; }
Base64: base64      is rexBprefix=0 & base64                            { export base64; }
Base64: base64_x    is rexBprefix=1 & base64_x                          { export base64_x; }
Index64: index64    is rexXprefix=0 & index64                           { export index64; }
Index64: index64_x  is rexXprefix=1 & index64_x                         { export index64_x; }
XmmReg:   xmmreg    is rexRprefix=0 & xmmreg                            { export xmmreg; }
XmmReg:   xmmreg_x  is rexRprefix=1 & xmmreg_x                          { export xmmreg_x; }
XmmReg1:  xmmreg1   is rexRprefix=0 & xmmreg1                           { export xmmreg1; }
XmmReg1:  xmmreg1_x is rexRprefix=1 & xmmreg1_x                         { export xmmreg1_x; }
XmmReg2:  xmmreg2   is rexBprefix=0 & xmmreg2                           { export xmmreg2; }
XmmReg2:  xmmreg2_x is rexBprefix=1 & xmmreg2_x                         { export xmmreg2_x; }
YmmReg1:  ymmreg1   is rexRprefix=0 & ymmreg1                           { export ymmreg1; }
YmmReg1:  ymmreg1_x is rexRprefix=1 & ymmreg1_x                         { export ymmreg1_x; }
YmmReg2:  ymmreg2   is rexBprefix=0 & ymmreg2                           { export ymmreg2; }
YmmReg2:  ymmreg2_x is rexBprefix=1 & ymmreg2_x                         { export ymmreg2_x; }
Xmm_vsib:  xmm_vsib       is rexXprefix=0 & xmm_vsib                             { export xmm_vsib; }
Xmm_vsib:  xmm_vsib_x     is rexXprefix=1 & xmm_vsib_x                           { export xmm_vsib_x; }
Ymm_vsib:  ymm_vsib       is rexXprefix=0 & ymm_vsib                             { export ymm_vsib; }
Ymm_vsib:  ymm_vsib_x     is rexXprefix=1 & ymm_vsib_x                           { export ymm_vsib_x; }
@else
Reg8:   reg8        is reg8                              { export reg8; }
Reg16:  reg16       is reg16                             { export reg16; }
Reg32:  reg32       is reg32                             { export reg32; }
Rmr8:   r8          is r8                                { export r8; }
CRmr8:  r8          is r8                                { export r8; }
Rmr16:  r16         is r16                               { export r16; }
CRmr16: r16         is r16                               { export r16; }
Rmr32:  r32         is r32                               { export r32; }
CRmr32: r32         is r32                               { export r32; }
Base:   base        is base                              { export base; }
Index:  index       is index                             { export index; }
XmmReg:   xmmreg    is xmmreg                            { export xmmreg; }
XmmReg1:  xmmreg1   is xmmreg1                           { export xmmreg1; }
XmmReg2:  xmmreg2   is xmmreg2                           { export xmmreg2; }
YmmReg1:  ymmreg1   is ymmreg1                           { export ymmreg1; }
YmmReg2:  ymmreg2   is ymmreg2                           { export ymmreg2; }
Xmm_vsib:  xmm_vsib       is xmm_vsib                    { export xmm_vsib; }
Ymm_vsib:  ymm_vsib       is ymm_vsib                    { export ymm_vsib; }
@endif

# signed immediate value subconstructors

simm8_16: simm8 is simm8 { export *[const]:2 simm8; }
simm8_32: simm8 is simm8 { export *[const]:4 simm8; }
@ifdef IA64
simm8_64: simm8 is simm8 { export *[const]:8 simm8; }
@endif
simm16_16: simm16 is simm16 { export *[const]:2 simm16; }
simm32_32: simm32 is simm32 { export *[const]:4 simm32; }
@ifdef IA64
simm32_64: simm32 is simm32 { export *[const]:8 simm32; }
imm32_64: imm32 is imm32 { export *[const]:8 imm32; }
@endif

usimm8_16: imm8 is imm8 & imm8_7=0 { export *[const]:2 imm8; }
usimm8_16: val is imm8 & imm8_7=1 [ val = 0xff00 | imm8; ] { export *[const]:2 val; }
usimm8_32: imm8 is imm8 & imm8_7=0 { export *[const]:4 imm8; }
usimm8_32: val is imm8 & imm8_7=1 [ val = 0xffffff00 | imm8; ] { export *[const]:4 val; }
@ifdef IA64
usimm8_64: imm8 is imm8 & imm8_7=0 { export *[const]:8 imm8; }
usimm8_64: val is imm8 & imm8_7=1 [ val = 0xffffffffffffff00 | imm8; ] { export *[const]:8 val; }
@endif

# unused
#usimm16_32: imm16 is imm16 & imm16_15=0 { export *[const]:4 imm16; }
#usimm16_32: val is imm16 & imm16_15=1 [ val = 0xffff0000 | imm16; ] { export *[const]:4 val; }

# RIP/EIP relative address - NOTE: export of size 0 is intentional so it may be adjusted
pcRelSimm32: addr	is simm32 [ addr=inst_next+simm32; ] { export addr; }

# 16-bit addressing modes   (the offset portion)
addr16: [BX + SI]		is mod=0 & r_m=0 & BX & SI		{ local tmp=BX+SI; export tmp; }
addr16: [BX + DI]		is mod=0 & r_m=1 & BX & DI		{ local tmp=BX+DI; export tmp; }
addr16: [BP + SI]		is mod=0 & r_m=2 & BP & SI		{ local tmp=BP+SI; export tmp; }
addr16: [BP + DI]		is mod=0 & r_m=3 & BP & DI		{ local tmp=BP+DI; export tmp; }
addr16: [SI]		is mod=0 & r_m=4 & SI			{ export SI; }
addr16: [DI]		is mod=0 & r_m=5 & DI			{ export DI; }
addr16: [imm16]		is mod=0 & r_m=6; imm16			{ export *[const]:2 imm16; }
addr16: [BX]		is mod=0 & r_m=7 & BX			{ export BX; }
addr16: [BX + SI + simm8_16]   is mod=1 & r_m=0 & BX & SI; simm8_16   { local tmp=BX+SI+simm8_16; export tmp; }
addr16: [BX + DI + simm8_16]   is mod=1 & r_m=1 & BX & DI; simm8_16   { local tmp=BX+DI+simm8_16; export tmp; }
addr16: [BP + SI + simm8_16]   is mod=1 & r_m=2 & BP & SI; simm8_16   { local tmp=BP+SI+simm8_16; export tmp; }
addr16: [BP + DI + simm8_16]   is mod=1 & r_m=3 & BP & DI; simm8_16   { local tmp=BP+DI+simm8_16; export tmp; }
addr16: [SI + simm8_16]  is mod=1 & r_m=4 & SI; simm8_16        { local tmp=SI+simm8_16; export tmp; }
addr16: [DI + simm8_16]  is mod=1 & r_m=5 & DI; simm8_16        { local tmp=DI+simm8_16; export tmp; }
addr16: [BP + simm8_16]  is mod=1 & r_m=6 & BP; simm8_16        { local tmp=BP+simm8_16; export tmp; }
addr16: [BX + simm8_16]  is mod=1 & r_m=7 & BX; simm8_16        { local tmp=BX+simm8_16; export tmp; }
addr16: [BX + SI + imm16]   is mod=2 & r_m=0 & BX & SI; imm16   { local tmp=BX+SI+imm16; export tmp; }
addr16: [BX + DI + imm16]   is mod=2 & r_m=1 & BX & DI; imm16   { local tmp=BX+DI+imm16; export tmp; }
addr16: [BP + SI + imm16]   is mod=2 & r_m=2 & BP & SI; imm16   { local tmp=BP+SI+imm16; export tmp; }
addr16: [BP + DI + imm16]   is mod=2 & r_m=3 & BP & DI; imm16   {local tmp=BP+DI+imm16; export tmp; }
addr16: [SI + imm16]  is mod=2 & r_m=4 & SI; imm16        { local tmp=SI+imm16; export tmp; }
addr16: [DI + imm16]  is mod=2 & r_m=5 & DI; imm16        { local tmp=DI+imm16; export tmp; }
addr16: [BP + imm16]  is mod=2 & r_m=6 & BP; imm16        { local tmp=BP+imm16; export tmp; }
addr16: [BX + imm16]  is mod=2 & r_m=7 & BX; imm16        { local tmp=BX+imm16; export tmp; }

# 32-bit addressing modes   (the offset portion)
addr32: [Rmr32]							is mod=0 & Rmr32  							 { export Rmr32; }
addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
addr32: [imm32]							is mod=0 & r_m=5; imm32                      { export *[const]:4 imm32; }
addr32: [Base + Index*ss]				is mod=0 & r_m=4; Index & Base & ss          { local tmp=Base+Index*ss; export tmp; }
addr32: [Base]							is mod=0 & r_m=4; index=4 & Base             { export Base; }
addr32: [Index*ss + imm32]				is mod=0 & r_m=4; Index & base=5 & ss; imm32 { local tmp=imm32+Index*ss; export tmp; }
addr32: [imm32]							is mod=0 & r_m=4; index=4 & base=5; imm32    { export *[const]:4 imm32; }
addr32: [Base + Index*ss + simm8_32]	is mod=1 & r_m=4; Index & Base & ss; simm8_32    { local tmp=simm8_32+Base+Index*ss; export tmp; }
addr32: [Base + simm8_32]				is mod=1 & r_m=4; index=4 & Base; simm8_32   { local tmp=simm8_32+Base; export tmp; }
addr32: [Base + Index*ss]				is mod=1 & r_m=4; Index & Base & ss; simm8=0 { local tmp=Base+Index*ss; export tmp; }
addr32: [Base]							is mod=1 & r_m=4; index=4 & Base; simm8=0    { export Base; }
addr32: [Base + Index*ss + imm32]		is mod=2 & r_m=4; Index & Base & ss; imm32   { local tmp=imm32+Base+Index*ss; export tmp; }
addr32: [Base + imm32]					is mod=2 & r_m=4; index=4 & Base; imm32      { local tmp=imm32+Base; export tmp; }
addr32: [Base + Index*ss]				is mod=2 & r_m=4; Index & Base & ss; imm32=0 { local tmp=Base+Index*ss; export tmp; }
addr32: [Base]							is mod=2 & r_m=4; index=4 & Base; imm32=0    { export Base; }
@ifdef IA64
addr32: [pcRelSimm32]					is bit64=1 & mod=0 & r_m=4; index=4 & base=5; pcRelSimm32 { export *[const]:4 pcRelSimm32; }

Addr32_64: [pcRelSimm32]				is $(LONGMODE_ON) & mod=0 & r_m=5; pcRelSimm32                { export *[const]:8 pcRelSimm32; }
Addr32_64: [imm32]						is $(LONGMODE_ON) & mod=0 & r_m=4; index=4 & base=5; imm32    { export *[const]:8 imm32; }
Addr32_64: addr32						is addr32									 { tmp:8 = sext(addr32); export tmp; }

@endif

# 64-bit addressing modes   (the offset portion)

@ifdef IA64
addr64: [Rmr64]							is mod=0 & Rmr64                                   { export Rmr64; }
addr64: [Rmr64 + simm8_64]				is mod=1 & Rmr64; simm8_64                         { local tmp=Rmr64+simm8_64; export tmp; }
addr64: [Rmr64 + simm32_64]				is mod=2 & Rmr64; simm32_64                        { local tmp=Rmr64+simm32_64; export tmp; }
addr64: [Rmr64]							is mod=1 & r_m!=4 & Rmr64; simm8=0                 { export Rmr64; }
addr64: [Rmr64]							is mod=2 & r_m!=4 & Rmr64; simm32=0                { export Rmr64; }
addr64: [pcRelSimm32]					is mod=0 & r_m=5; pcRelSimm32                      { export *[const]:8 pcRelSimm32; }
addr64: [Base64 + Index64*ss]			is mod=0 & r_m=4; Index64 & Base64 & ss            { local tmp=Base64+Index64*ss; export tmp; }
addr64: [Base64]						is mod=0 & r_m=4; rexXprefix=0 & index64=4 & Base64    { export Base64; }
addr64: [simm32_64 + Index64*ss]		is mod=0 & r_m=4; Index64 & base64=5 & ss; simm32_64   { local tmp=simm32_64+Index64*ss; export tmp; }
addr64: [Index64*ss]					is mod=0 & r_m=4; Index64 & base64=5 & ss; imm32=0 { local tmp=Index64*ss; export tmp; }
addr64: [simm32_64]						is mod=0 & r_m=4; rexXprefix=0 & index64=4 & base64=5; simm32_64      { export *[const]:8 simm32_64; }
addr64: [Base64 + simm8_64]				is mod=1 & r_m=4; rexXprefix=0 & index64=4 & Base64; simm8_64     { local tmp=simm8_64+Base64; export tmp; }
addr64: [Base64 + Index64*ss + simm8_64] is mod=1 & r_m=4; Index64 & Base64 & ss; simm8_64 { local tmp=simm8_64+Base64+Index64*ss; export tmp; }
addr64: [Base64 + Index64*ss]			is mod=1 & r_m=4; Index64 & Base64 & ss; simm8=0   { local tmp=Base64+Index64*ss; export tmp; }
addr64: [Base64 + simm32_64]			is mod=2 & r_m=4; rexXprefix=0 & index64=4 & Base64; simm32_64        { local tmp=simm32_64+Base64; export tmp; }
addr64: [Base64]						is mod=2 & r_m=4; rexXprefix=0 & index64=4 & Base64; imm32=0      { export Base64; }
addr64: [Base64 + Index64*ss + simm32_64] is mod=2 & r_m=4; Index64 & Base64 & ss; simm32_64     { local tmp=simm32_64+Base64+Index64*ss; export tmp; }
addr64: [Base64 + Index64*ss]			is mod=2 & r_m=4; Index64 & Base64 & ss; imm32=0   { local tmp=Base64+Index64*ss; export tmp; }
@endif

currentCS: CS is protectedMode=0 & CS { tmp:4 = (inst_next >> 4) & 0xf000; CS = tmp:2; export CS; }
currentCS: CS is protectedMode=1 & CS { tmp:4 = (inst_next >> 16) & 0xffff; CS = tmp:2; export CS; }
 
segWide: is segover=0		        { export 0:$(SIZE); }
segWide: CS: is segover=1 & CS	{ export 0:$(SIZE); }
segWide: SS: is segover=2 & SS	{ export 0:$(SIZE); }
segWide: DS: is segover=3 & DS	{ export 0:$(SIZE); }
segWide: ES: is segover=4 & ES	{ export 0:$(SIZE); }
segWide: FS: is segover=5 & FS	{ export FS_OFFSET; }
segWide: GS: is segover=6 & GS	{ export GS_OFFSET; }

seg16: 	   is segover=0			{ export DS; }
seg16: currentCS: is segover=1 & currentCS	{ export currentCS; }
seg16: SS: is segover=2 & SS	{ export SS; }
seg16: DS: is segover=3 & DS	{ export DS; }
seg16: ES: is segover=4 & ES	{ export ES; }
seg16: FS: is segover=5 & FS	{ export FS; }
seg16: GS: is segover=6 & GS	{ export GS; }

Mem16: addr16	is (segover=0 & mod=0 & r_m=2) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16	is (segover=0 & mod=0 & r_m=3) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16	is (segover=0 & mod=1 & r_m=2) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16	is (segover=0 & mod=1 & r_m=3) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16  	is (segover=0 & mod=1 & r_m=6) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16   is (segover=0 & mod=2 & r_m=2) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16   is (segover=0 & mod=2 & r_m=3) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: addr16  	is (segover=0 & mod=2 & r_m=6) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }

Mem: Mem16 is addrsize=0 & Mem16             { export Mem16; }

@ifdef IA64
Mem: segWide^Addr32_64 is $(LONGMODE_ON) & addrsize=1 & segWide; Addr32_64 			{ export Addr32_64; }
Mem: segWide^Addr32_64 is $(LONGMODE_ON) & addrsize=1 & segWide & highseg=1; Addr32_64	{ tmp:8 = segWide + Addr32_64; export tmp; }
Mem: segWide^addr64 is $(LONGMODE_ON) & addrsize=2 & segWide; addr64             { export addr64; }
Mem: segWide^addr64 is $(LONGMODE_ON) & addrsize=2 & segWide & highseg=1; addr64 { tmp:$(SIZE) = segWide + addr64; export tmp; }
Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{ tmp:$(SIZE) = zext(addr32); export tmp; }
@else
Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{ export addr32; }
@endif
Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }

rel8: reloc is simm8        [ reloc=inst_next+simm8; ] { export *[ram]:$(SIZE) reloc; }
rel16: reloc is simm16      [ reloc=((inst_next >> 16) << 16) | ((inst_next + simm16) & 0xFFFF); ] { export *[ram]:$(SIZE) reloc; }
rel32: reloc is simm32      [ reloc=inst_next+simm32; ] { export *[ram]:$(SIZE) reloc; }


m8:   "byte ptr" Mem   	is Mem      { export *:1 Mem; }
m16:  "word ptr" Mem  	is Mem      { export *:2 Mem; }
m32:  "dword ptr" Mem  	is Mem      { export *:4 Mem; }
m64:  "qword ptr" Mem  	is Mem      { export *:8 Mem; }
# m80: Mem    is Mem      { export *:10 Mem; }
m128: "xmmword ptr" Mem	is Mem      { export *:16 Mem; }
m256: "ymmword ptr" Mem	is Mem      { export *:32 Mem; }

# spec versions of the m8/m16/m32/... tables explicitly print the operand size
spec_m8: "byte ptr "^Mem     is Mem      { export *:1 Mem; }
spec_m16: "word ptr "^Mem    is Mem      { export *:2 Mem; }
spec_m32: "dword ptr "^Mem    is Mem      { export *:4 Mem; }
spec_m64: "qword ptr "^Mem    is Mem      { export *:8 Mem; }
spec_m80: "tword ptr "^Mem    is Mem      { export *:10 Mem; }
# spec_m128: "16-byte ptr "^Mem   is Mem      { export *:16 Mem; }
# spec_m512: "64-byte ptr "^Mem   is Mem      { export *:64 Mem; }



##
## VSIB
##

vaddr32x: [Base + Xmm_vsib*ss]					is mod=0 & r_m=4; Xmm_vsib & Base & ss					{ }
vaddr32x: [Xmm_vsib*ss + simm32_32]				is mod=0 & r_m=4; Xmm_vsib & base=5 & ss;	simm32_32	{ }
vaddr32x: [Base + Xmm_vsib*ss + simm8_32]		is mod=1 & r_m=4; Xmm_vsib & Base & ss;		simm8_32	{ }
vaddr32x: [Base + Xmm_vsib*ss + simm32_32]		is mod=2 & r_m=4; Xmm_vsib & Base & ss;		simm32_32	{ }

vaddr32y: [Base + Ymm_vsib*ss]					is mod=0 & r_m=4; Ymm_vsib & Base & ss					{ }
vaddr32y: [Ymm_vsib*ss + simm32_32]				is mod=0 & r_m=4; Ymm_vsib & base=5 & ss;	simm32_32	{ }
vaddr32y: [Base + Ymm_vsib*ss + simm8_32]		is mod=1 & r_m=4; Ymm_vsib & Base & ss;		simm8_32	{ }
vaddr32y: [Base + Ymm_vsib*ss + simm32_32]		is mod=2 & r_m=4; Ymm_vsib & Base & ss;		simm32_32	{ }

@ifdef IA64
vaddr64x: [Base64 + Xmm_vsib*ss]				is mod=0 & r_m=4; Xmm_vsib & Base64 & ss				{ }
vaddr64x: [Xmm_vsib*ss + simm32_64]				is mod=0 & r_m=4; Xmm_vsib & base64=5 & ss;	simm32_64	{ }
vaddr64x: [Base64 + Xmm_vsib*ss + simm8_64]		is mod=1 & r_m=4; Xmm_vsib & Base64 & ss;	simm8_64	{ }
vaddr64x: [Base64 + Xmm_vsib*ss + simm32_64]	is mod=2 & r_m=4; Xmm_vsib & Base64 & ss;	simm32_64	{ }

vaddr64y: [Base64 + Ymm_vsib*ss]				is mod=0 & r_m=4; Ymm_vsib & Base64 & ss				{ }
vaddr64y: [Ymm_vsib*ss + simm32_64]				is mod=0 & r_m=4; Ymm_vsib & base64=5 & ss;	simm32_64	{ }
vaddr64y: [Base64 + Ymm_vsib*ss + simm8_64]		is mod=1 & r_m=4; Ymm_vsib & Base64 & ss;	simm8_64	{ }
vaddr64y: [Base64 + Ymm_vsib*ss + simm32_64]	is mod=2 & r_m=4; Ymm_vsib & Base64 & ss;	simm32_64	{ }
@endif


vMem32x: segWide^vaddr32x	is addrsize=1 & segWide; vaddr32x       			{ }
vMem32x: segWide^vaddr32x	is addrsize=1 & segWide & highseg=1; vaddr32x 		{ }

vMem32y: segWide^vaddr32y	is addrsize=1 & segWide; vaddr32y       			{ }
vMem32y: segWide^vaddr32y	is addrsize=1 & segWide & highseg=1; vaddr32y 		{ }

@ifdef IA64
#      GAS always inserts a 0x67 prefix before a VSIB instruction with a 32-bit base.
#      Behavior is coded to match Binutils; exceeds what the manual indicates is possible.
vMem32x: segWide^vaddr64x	is addrsize=2 & segWide; vaddr64x             		{ }
vMem32x: segWide^vaddr64x	is addrsize=2 & segWide & highseg=1; vaddr64x 		{ }

#      GAS always inserts a 0x67 prefix before a VSIB instruction with a 32-bit base.
#      Behavior is coded to match Binutils; exceeds what the manual indicates is possible.
vMem32y: segWide^vaddr64y	is addrsize=2 & segWide; vaddr64y             		{ }
vMem32y: segWide^vaddr64y	is addrsize=2 & segWide & highseg=1; vaddr64y 		{ }

#      GAS always inserts a 0x67 prefix before a VSIB instruction with a 32-bit base.
#      Behavior is coded to match Binutils; exceeds what the manual indicates is possible.
vMem64x: segWide^vaddr32x	is addrsize=1 & segWide; vaddr32x 					{ }
vMem64x: segWide^vaddr32x	is addrsize=1 & segWide & highseg=1; vaddr32x		{ }

vMem64x: segWide^vaddr64x	is addrsize=2 & segWide; vaddr64x             		{ }
vMem64x: segWide^vaddr64x	is addrsize=2 & segWide & highseg=1; vaddr64x 		{ }

#      GAS always inserts a 0x67 prefix before a VSIB instruction with a 32-bit base.
#      Behavior is coded to match Binutils; exceeds what the manual indicates is possible.
vMem64y: segWide^vaddr32y	is addrsize=1 & segWide; vaddr32y 					{ }
vMem64y: segWide^vaddr32y	is addrsize=1 & segWide & highseg=1; vaddr32y		{ }

vMem64y: segWide^vaddr64y	is addrsize=2 & segWide; vaddr64y             		{ }
vMem64y: segWide^vaddr64y	is addrsize=2 & segWide & highseg=1; vaddr64y 		{ }
@endif


d_vm32x: "dword ptr "^vMem32x is vMem32x { }
d_vm32y: "dword ptr "^vMem32y is vMem32y { }

@ifdef IA64
d_vm64x: "dword ptr "^vMem64x is vMem64x { }
d_vm64y: "dword ptr "^vMem64y is vMem64y { }
@endif


q_vm32x: "qword ptr "^vMem32x is vMem32x { }
# not used q_vm32y: "qword ptr "^vMem32y is vMem32y { }

@ifdef IA64
q_vm64x: "qword ptr "^vMem64x is vMem64x { }
q_vm64y: "qword ptr "^vMem64y is vMem64y { }
@endif

Reg32_m8:     Rmr32     is mod=3 & Rmr32                     { export Rmr32; }
Reg32_m8:     m8        is m8                                { local tmp:4 = zext(m8); export tmp; }
Reg32_m16:    Rmr32     is mod=3 & Rmr32                     { export Rmr32; }
Reg32_m16:    m16       is m16                               { local tmp:4 = zext(m16); export tmp; }

mmxreg2_m64:  mmxreg2   is mod=3 & mmxreg2                   { export mmxreg2; }
mmxreg2_m64:  m64       is m64                               { export m64; }

XmmReg2_m8:   XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
XmmReg2_m8:   m8        is m8                                { local tmp:16 = zext(m8); export tmp; }
XmmReg2_m16:  XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
XmmReg2_m16:  m16       is m16                               { local tmp:16 = zext(m16); export tmp; }
XmmReg2_m32:  XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
XmmReg2_m32:  m32       is m32                               { local tmp:16 = zext(m32); export tmp; }
XmmReg2_m64:  XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
XmmReg2_m64:  m64       is m64                               { local tmp:16 = zext(m64); export tmp; }
XmmReg2_m128: XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
XmmReg2_m128: m128      is m128                              { export m128; }

YmmReg2_m256: YmmReg2   is mod=3 & YmmReg2                   { export YmmReg2; }
YmmReg2_m256: m256      is m256                              { export m256; }

moffs8: seg16^[imm16]   is addrsize=0 & seg16 & imm16                   { tmp:$(SIZE) = segment(seg16,imm16:2); export *:1 tmp; }
moffs8: segWide^[imm32]   is addrsize=1 & highseg=1 & segWide & imm32   { tmp:$(SIZE) = segWide + imm32; export *:1 tmp; }
moffs8: segWide^[imm32]   is addrsize=1 & segWide & imm32               { export *:1 imm32; }
@ifdef IA64
moffs8: segWide^[imm64]   is addrsize=2 & highseg=1 & segWide & imm64   { tmp:8 = segWide + imm64; export *:1 tmp; }
moffs8: segWide^[imm64]   is addrsize=2 & segWide & imm64               { export *:1 imm64; }
@endif
moffs16: seg16^[imm16]  is addrsize=0 & seg16 & imm16                   { tmp:$(SIZE) = segment(seg16,imm16:2); export *:2 tmp; }
moffs16: segWide^[imm32]  is addrsize=1 & highseg=1 & segWide & imm32   { tmp:$(SIZE) = segWide + imm32; export *:2 tmp; }
moffs16: segWide^[imm32]  is addrsize=1 & segWide & imm32               { export *:2 imm32; }
@ifdef IA64
moffs16: segWide^[imm64]  is addrsize=2 & highseg=1 & segWide & imm64   { tmp:8 = segWide + imm64; export *:2 tmp; }
moffs16: segWide^[imm64]  is addrsize=2 & segWide & imm64               { export *:2 imm64; }
@endif

moffs32: seg16^[imm16]  is addrsize=0 & seg16 & imm16                   { tmp:$(SIZE) = segment(seg16,imm16:2); export *:4 tmp; }
moffs32: segWide^[imm32]  is addrsize=1 & segWide & imm32               { export *:4 imm32; }
moffs32: segWide^[imm32]  is addrsize=1 & highseg=1 & segWide & imm32   { tmp:$(SIZE) = segWide + imm32; export *:4 tmp; }
@ifdef IA64
moffs32: segWide^[imm64]  is addrsize=2 & segWide & imm64               { export *:4 imm64; }
moffs32: segWide^[imm64]  is addrsize=2 & highseg=1 & segWide & imm64   { tmp:8 = segWide + imm64; export *:4 tmp; }
@endif

@ifdef IA64
moffs64: segWide^[imm64]  is addrsize=2 & segWide & imm64               { export *:8 imm64; }
moffs64: segWide^[imm64]  is addrsize=2 & highseg=1 & segWide & imm64   { tmp:8 = segWide + imm64; export *:8 tmp; }
moffs64: segWide^[imm32]  is addrsize=1 & segWide & imm32               { export *:8 imm32; }
moffs64: segWide^[imm32]  is addrsize=1 & highseg=1 & segWide & imm32   { tmp:8 = segWide + imm32; export *:8 tmp; }
@endif
# TODO: segment register offset in 64bit might not be right

# String memory access
dseSI1: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 1-2*zext(DF); export *:1 tmp; }
dseSI1: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 1-2*zext(DF); export *:1 tmp; }
dseSI2: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 2-4*zext(DF); export *:2 tmp; }
dseSI2: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 2-4*zext(DF); export *:2 tmp; }
dseSI4: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 4-8*zext(DF); export *:4 tmp; }
dseSI4: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 4-8*zext(DF); export *:4 tmp; }
eseDI1: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 1-2*zext(DF); export *:1 tmp; }
eseDI1: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+1-2*zext(DF); export *:1 tmp; }
eseDI2: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 2-4*zext(DF); export *:2 tmp; }
eseDI2: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+2-4*zext(DF); export *:2 tmp; }
eseDI4: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 4-8*zext(DF); export *:4 tmp; }
eseDI4: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+4-8*zext(DF); export *:4 tmp; }

@ifdef IA64
# quadword string functions
dseSI8: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 8-16*zext(DF); export *:8 tmp; }
dseSI8: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 8-16*zext(DF); export *:8 tmp; }
eseDI8: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 8-16*zext(DF); export *:8 tmp; }
eseDI8: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+8-16*zext(DF); export *:8 tmp; }

dseSI1: RSI   is addrsize=2 & RSI { local tmp = RSI; RSI = RSI + 1-2*zext(DF); export *:1 tmp; }
dseSI2: RSI   is addrsize=2 & RSI { local tmp = RSI; RSI = RSI + 2-4*zext(DF); export *:2 tmp; }
dseSI4: RSI   is addrsize=2 & RSI { local tmp = RSI; RSI = RSI + 4-8*zext(DF); export *:4 tmp; }
dseSI8: RSI   is addrsize=2 & RSI { local tmp = RSI; RSI = RSI + 8-16*zext(DF); export *:8 tmp; }
eseDI1: RDI   is addrsize=2 & RDI    { local tmp = RDI; RDI=RDI+1-2*zext(DF); export *:1 tmp; }
eseDI2: RDI   is addrsize=2 & RDI    { local tmp = RDI; RDI=RDI+2-4*zext(DF); export *:2 tmp; }
eseDI4: RDI   is addrsize=2 & RDI    { local tmp = RDI; RDI=RDI+4-8*zext(DF); export *:4 tmp; }
eseDI8: RDI   is addrsize=2 & RDI    { local tmp = RDI; RDI=RDI+8-16*zext(DF); export *:8 tmp; }
@endif

rm8: Rmr8   is mod=3 & Rmr8     { export Rmr8; }
rm8: "byte ptr" Mem    is  Mem             { export *:1 Mem; }

spec_rm8: Rmr8 				is mod=3 & Rmr8		{ export Rmr8; }
spec_rm8: "byte ptr "^Mem 	is	Mem				{ export *:1 Mem; }

rm16: Rmr16 is mod=3 & Rmr16    { export Rmr16; }
rm16: "word ptr" Mem   is Mem              { export *:2 Mem; }

spec_rm16: Rmr16				is mod=3 & Rmr16		{ export Rmr16; }
spec_rm16: "word ptr "^Mem	is Mem				{ export *:2 Mem; }

rm32: Rmr32 is mod=3 & Rmr32    { export Rmr32; }
rm32: "dword ptr" Mem   is Mem              { export *:4 Mem; }

spec_rm32: Rmr32				is mod=3 & Rmr32		{ export Rmr32; }
spec_rm32: "dword ptr "^Mem	is Mem				{ export *:4 Mem; }

@ifdef IA64
rm64: Rmr64 is mod=3 & Rmr64    { export Rmr64; }
rm64: "qword ptr" Mem   is Mem              { export *:8 Mem; }

spec_rm64: Rmr64				is mod=3 & Rmr64		{ export Rmr64; }
spec_rm64: "qword ptr "^Mem	is Mem				{ export *:8 Mem; }
@endif

n1: one	is epsilon			[ one = 1; ] { export *[const]:1 one; }

@ifdef IA64
# Handle zero extension in 64-bit mode for 32-bit destination registers
check_Reg32_dest:	is $(LONGMODE_ON) & Reg32 & Reg64 					{ Reg64 = zext(Reg32); }
check_Rmr32_dest:	is $(LONGMODE_ON) & Rmr32 & Rmr64					{ Rmr64 = zext(Rmr32); }
check_rm32_dest:	is $(LONGMODE_ON) & mod=3 & check_Rmr32_dest		{ build check_Rmr32_dest; }

check_Rmr16_dest:	is $(LONGMODE_ON) & Rmr16 & Rmr64			{ Rmr64 = zext(Rmr16); }
check_rm16_dest:	is $(LONGMODE_ON) & mod=3 & check_Rmr16_dest	{ build check_Rmr16_dest; }

check_EAX_dest:		is $(LONGMODE_ON)									{ RAX = zext(EAX); }
check_EDX_dest:     is $(LONGMODE_ON)									{ RDX = zext(EDX); }
check_vexVVVV_r32_dest: is $(LONGMODE_ON) & vexVVVV_r64 & vexVVVV_r32  	{ vexVVVV_r64 = zext(vexVVVV_r32);}
@endif
check_Reg32_dest:	is epsilon	{ }
check_Rmr32_dest:	is epsilon	{ }

check_Rmr16_dest:	is $(LONGMODE_OFF) & Rmr16 & Rmr32		{ Rmr32 = zext(Rmr16); }
check_rm16_dest:	is $(LONGMODE_OFF) & mod=3 & check_Rmr16_dest	{ build check_Rmr16_dest; }
check_Rmr16_dest:	is epsilon	{ }
check_rm16_dest:	is epsilon	{ }

check_EAX_dest:		is epsilon  { }
check_EDX_dest:		is epsilon  { }
check_vexVVVV_r32_dest: is epsilon {  }
check_rm32_dest:	is epsilon	{ }


ptr1616: reloc is protectedMode=0 & imm16; j16		[ reloc = j16*0x10 + imm16; ] { CS = j16; export *[ram]:4 reloc; }
ptr1616: reloc is protectedMode=1 & imm16; j16		[ reloc = j16*0x10000 + imm16; ] { CS = j16; export *[ram]:4 reloc; }
ptr1632: j16":"imm32 is imm32; j16	{ CS = j16; export *:4 imm32; }

# conditions

cc: "O" is cond=0           { export OF; }
cc: "NO" is cond=1          { local tmp = !OF; export tmp; }
cc: "C" is cond=2           { export CF; }
cc: "NC" is cond=3          { local tmp = !CF; export tmp; }
cc: "Z" is cond=4           { export ZF; }
cc: "NZ" is cond=5          { local tmp = !ZF; export tmp; }
cc: "BE" is cond=6          { local tmp = CF || ZF; export tmp; }
cc: "A" is cond=7           { local tmp = !(CF || ZF); export tmp; }
cc: "S" is cond=8           { export SF; }
cc: "NS" is cond=9          { local tmp = !SF; export tmp; }
cc: "P" is cond=10          { export PF; }
cc: "NP" is cond=11         { local tmp = !PF; export tmp; }
cc: "L" is cond=12          { local tmp = OF != SF; export tmp; }
cc: "GE" is cond=13         { local tmp = OF == SF; export tmp; }
cc: "LE" is cond=14         { local tmp = ZF || (OF != SF); export tmp; }
cc: "G" is cond=15          { local tmp = !ZF && (OF == SF); export tmp; }

# repeat prefixes
rep_check: is addrsize=0  { if (CX==0) goto inst_next; }
rep_check: is addrsize=1  { if (ECX==0) goto inst_next; }
@ifdef IA64
rep_check: is addrsize=2  { if (RCX==0) goto inst_next; }
@endif

rep_update: is addrsize=0  { CX=CX-1; }
rep_update: is addrsize=1  { ECX=ECX-1; }
@ifdef IA64
rep_update: is addrsize=2  { RCX=RCX-1; }
@endif

rep: ".REP" 	is repprefx=1 & repneprefx=0 & rep_check 	{ }
rep: ".REPNE"  	is repprefx=0 & repneprefx=1 & rep_check 	{ } # Although undocumented, either rep prefix is allowed but ZF is always ignored
rep:        	is repprefx=0 & repneprefx=0			{ }


reptail:	is (repprefx=1 | repneprefx=1) & rep_update	{ goto inst_start; }
reptail: 	is repprefx=0 & repneprefx=0			{ }

repe: ".REPE"   is repprefx=1 & repneprefx=0 & rep_check 	{ }
repe: ".REPNE"  is repprefx=0 & repneprefx=1 & rep_check	{ }
repe:           is repprefx=0 & repneprefx=0  			{ }

repetail:   is repprefx=1 & repneprefx=0 & rep_update	{ if (ZF) goto inst_start; }
repetail:   is repprefx=0 & repneprefx=1 & rep_update	{ if (!ZF) goto inst_start; }
repetail:   is repprefx=0 & repneprefx=0		{ }

# XACQUIRE/XRELEASE prefix
xacq_xrel_prefx: ".XACQUIRE"	is xacquireprefx=1 & xreleaseprefx=0 { XACQUIRE(); }
xacq_xrel_prefx: ".XRELEASE"	is xacquireprefx=0 & xreleaseprefx=1 { XRELEASE(); }
xacq_xrel_prefx:            	is epsilon { }

#the XRELEASE prefix can be used with several variants of MOV (without the LOCK prefix)
xrelease: ".XRELEASE"	is xacquireprefx=0 & xreleaseprefx=1 { XRELEASE(); }
xrelease: 	is epsilon { }

#XCHG with a memory destination asserts a LOCK signal whether or not there is a LOCK prefix (f0) 
#"alwaysLock" constructor will place "LOCK" in the disassembly if the prefix occurs 
alwaysLock:  ".LOCK"	is lockprefx=1 { LOCK(); }
alwaysLock:        	    is epsilon { LOCK(); }

#check for LOCK prefix and the optional XACQUIRE/XRELEASE
lockx: xacq_xrel_prefx^".LOCK"	is lockprefx=1 & xacq_xrel_prefx { build xacq_xrel_prefx; LOCK(); }
lockx: 		                    is epsilon { }

#"unlock" constructor is used to pair every LOCK pcodeop with a matching UNLOCK pcodeop
unlock:		is lockprefx=1 { UNLOCK(); }
unlock:		is epsilon { }

# Some macros

@include "macros.sinc"

macro ptr2(r,x) {
  r = zext(x);
}

macro ptr4(r,x) {
@ifdef IA64
  r = zext(x);
@else
  r = x;
@endif
}

macro ptr8(r,x) {
@ifdef IA64
  r = x;
@else
  r = x:$(SIZE);
@endif
}

macro push22(x) {
  mysave:2 = x;
  tmp:$(SIZE) = segment(SS,SP-2);
  *:2 tmp = mysave;
  SP = SP-2;
}

macro push24(x) {
  mysave:4 = x;
  tmp:$(SIZE) = segment(SS,SP-4);
  *:4 tmp = mysave;
  SP = SP-4;
}

macro push28(x) {
  mysave:8 = x;
  tmp:$(SIZE) = segment(SS,SP-8);
  *:8 tmp = mysave;
  SP = SP-8;
}

macro push42(x) {
  mysave:2 = x;
  *:2 ($(STACKPTR)-2) = mysave;
  $(STACKPTR) = $(STACKPTR)-2;
}

macro push44(x) {
  mysave:4 = x;
  *:4 ($(STACKPTR)-4) = mysave;
  $(STACKPTR) = $(STACKPTR)-4;
}

macro pushseg44(x) {
  mysave:2 = x;
  *:2 ($(STACKPTR)-4) = mysave;
  $(STACKPTR) = $(STACKPTR)-4;
}

macro push48(x) {
  mysave:8 = x;
  *:8 ($(STACKPTR)-8) = mysave;
  $(STACKPTR) = $(STACKPTR)-8;
}

@ifdef IA64
macro push82(x) {
  mysave:2 = x;
  *:2 ($(STACKPTR)-2) = mysave;
  $(STACKPTR) = $(STACKPTR)-2;
}

macro push84(x) {
  mysave:4 = x;
  *:4 ($(STACKPTR)-4) = mysave;
  $(STACKPTR) = $(STACKPTR)-4;
}

macro push88(x) {
  mysave:8 = x;
  *:8 ($(STACKPTR)-8) = mysave;
  $(STACKPTR) = $(STACKPTR)-8;
}

macro pushseg82(x) {
  mysave:2 = x;
  *:2 ($(STACKPTR)-2) = mysave;
  $(STACKPTR) = $(STACKPTR)-2;
}

macro pushseg88(x) {
  mysave:2 = x;
  *:2 ($(STACKPTR)-8) = mysave;
  $(STACKPTR) = $(STACKPTR)-8;
}
@endif

# Note: for each pop operation we are careful to order the operations such that is correct for
# both 'POP [RSP + offset]' and 'POP RSP'

macro pop22(x) {
  tmp:$(SIZE) = segment(SS,SP);
  value = *:2 tmp;
  SP = SP+2;
  x = value;
}

macro pop24(x) {
  tmp:$(SIZE) = segment(SS,SP);
  value = *:4 tmp;
  SP = SP+4;
  x = value;
}

macro pop28(x) {
  tmp:$(SIZE) = segment(SS,SP);
  value = *:8 tmp;
  SP = SP+8;
  x = value;
}

macro pop42(x) {
  value = *:2 $(STACKPTR);
  ESP = ESP + 2;
  x = value;
}

macro pop44(x) {
  value = *:4 $(STACKPTR);
  ESP = ESP + 4;
  x = value;
}

macro popseg44(x) {
  value = *:2 $(STACKPTR);
  ESP = ESP + 4;
  x = value;
}

macro pop48(x) {
  value = *:8 $(STACKPTR);
  ESP = ESP + 8;
  x = value;
}

@ifdef IA64
macro pop82(x) {
  value = *:2 $(STACKPTR);
  RSP = RSP + 2;
  x = value;
}

macro pop84(x) {
  value = *:4 $(STACKPTR);
  RSP = RSP + 4;
  x = value;
}

macro pop88(x) {
  value = *:8 $(STACKPTR);
  RSP = RSP + 8;
  x = value;
}

macro popseg82(x) {
  value = *:2 $(STACKPTR);
  RSP = RSP + 2;
  x = value;
}

macro popseg88(x) {
  value = *:2 $(STACKPTR);
  RSP = RSP + 8;
  x = value;
}

@endif

macro unpackflags(tmp) {
  NT = (tmp & 0x4000) != 0;
#  IOPL = (tmp & 0x1000) != 0;
  OF = (tmp & 0x0800) != 0;
  DF = (tmp & 0x0400) != 0;
  IF = (tmp & 0x0200) != 0;
  TF = (tmp & 0x0100) != 0;
  SF = (tmp & 0x0080) != 0;
  ZF = (tmp & 0x0040) != 0;
  AF = (tmp & 0x0010) != 0;
  PF = (tmp & 0x0004) != 0;
  CF = (tmp & 0x0001) != 0;
}

macro unpackeflags(tmp) {
  ID = (tmp & 0x00200000) != 0;
  AC = (tmp & 0x00040000) != 0;
#  RF = (tmp & 0x00010000) != 0;
  VIP = 0;
  VIF = 0;
}

macro packflags(tmp) {
  tmp=       (0x4000 * zext(NT&1))
#                | (0x1000 * zext(IOPL&1))
                | (0x0800 * zext(OF&1))
                | (0x0400 * zext(DF&1)) | (0x0200 * zext(IF&1))   | (0x0100 * zext(TF&1))
                | (0x0080 * zext(SF&1)) | (0x0040 * zext(ZF&1))   | (0x0010 * zext(AF&1))
                | (0x0004 * zext(PF&1)) | (0x0001 * zext(CF&1));
}

macro packeflags(tmp) {
  tmp = tmp     | (0x00200000 * zext(ID&1))  | (0x00100000 * zext(VIP&1))
                | (0x00080000 * zext(VIF&1)) | (0x00040000 * zext(AC&1));
}

macro addflags(op1,op2) {
 CF = carry(op1,op2);
 OF = scarry(op1,op2);
}

#
# full-adder carry and overflow calculations
#
macro addCarryFlags ( op1, op2 ) {
	local CFcopy = zext(CF);
	CF = carry( op1, op2 );
	OF = scarry( op1, op2 );
	local result = op1 + op2;
	CF = CF || carry( result, CFcopy );
	OF = OF ^^ scarry( result, CFcopy );
	op1 = result + CFcopy;
	# AF not implemented
}


macro subCarryFlags ( op1, op2 ) {
	local CFcopy = zext(CF);
	CF = op1 < op2;
	OF = sborrow( op1, op2 );
	local result = op1 - op2;
	CF = CF || (result < CFcopy);
	OF = OF ^^ sborrow( result, CFcopy );
	op1 = result - CFcopy;
	# AF not implemented
}

macro resultflags(result) {
 SF = result s< 0;
 ZF = result == 0;
 PF = ((popcount(result & 0xff) & 1:1) == 0);
 # AF not implemented
}

macro shiftresultflags(result,count) {

 local notzero = (count != 0);

 local newSF = (result s< 0);
 SF = (!notzero && SF) || (notzero && newSF);

 local newZF = (result == 0);
 ZF = (!notzero && ZF) || (notzero && newZF);
 
 local newPF = ((popcount(result & 0xff) & 1:1) == 0);
 PF = (!notzero && PF) || (notzero && newPF);
 # AF not implemented
}

macro subflags(op1,op2) {
 CF = op1 < op2;
 OF = sborrow(op1,op2);
}

macro negflags(op1) {
 CF = (op1 != 0);
 OF = sborrow(0,op1);
}

macro logicalflags() {
 CF = 0;
 OF = 0;
}

macro imultflags(low,total){
  CF = sext(low) != total;
  OF = CF;
}

macro multflags(highhalf) {
 CF = highhalf != 0;
 OF = CF;
}

macro rolflags(result,count) {

 local notzero = (count != 0);
 local newCF = ((result & 1) != 0);
 CF = (!notzero && CF) || (notzero && newCF);

 local one = (count == 1);
 local newOF = CF ^^ (result s< 0);
 OF = (!one && OF) || (one && newOF);
}

macro rorflags(result,count) {

 local notzero = (count != 0);
 local newCF = (result s< 0);
 CF = (!notzero && CF) || (notzero && newCF);

 local one = (count == 1);
 local newOF = (result s< 0) ^^ ((result << 1) s< 0);
 OF = (!one && OF) || (one && newOF);
}

macro shlflags(op1,result,count) { # works for shld also

 local notzero = (count != 0);
 local newCF = ( (op1 << (count - 1)) s< 0 );
 CF = (!notzero && CF) || (notzero && newCF);

 local one = (count == 1);
 local newOF = CF ^^ (result s< 0);
 OF = (!one && OF) || (one && newOF);
}

macro sarflags(op1,result,count) {

 local notzero = (count != 0);
 local newCF = ( ( (op1 s>> (count - 1)) & 1 ) != 0 );
 CF = (!notzero && CF) || (notzero && newCF);

 local one = (count == 1);
 OF = (!one && OF);
}

macro shrflags(op1,result,count) {

 local notzero = (count != 0);
 local newCF = ( ( (op1 >> (count - 1)) & 1 ) != 0 );
 CF = (!notzero && CF) || (notzero && newCF);

 local one = (count == 1);
 local newOF = (op1 s< 0);
 OF = (!one && OF) || (one && newOF);
}

macro shrdflags(op1,result,count) {

 local notzero = (count != 0);
 local newCF = ( ( (op1 >> (count - 1)) & 1 ) != 0 );
 CF = (!notzero && CF) || (notzero && newCF);

 local one = (count == 1);
 local newOF = ((op1 s< 0) ^^ (result s< 0));
 OF = (!one && OF) || (one && newOF);
}

macro fdec() {
    local tmp = ST7;
	ST7 = ST6;
	ST6 = ST5;
	ST5 = ST4;
	ST4 = ST3;
	ST3 = ST2;
	ST2 = ST1;
	ST1 = ST0;
	ST0 = tmp;
}

macro finc() {
    local tmp = ST0;
	ST0 = ST1;
	ST1 = ST2;
	ST2 = ST3;
	ST3 = ST4;
	ST4 = ST5;
	ST5 = ST6;
	ST6 = ST7;
	ST7 = tmp;
}

macro fpop() {
	ST0 = ST1;
	ST1 = ST2;
	ST2 = ST3;
	ST3 = ST4;
	ST4 = ST5;
	ST5 = ST6;
	ST6 = ST7;
}

 macro fpushv(val) {
	ST7 = ST6;
	ST6 = ST5;
	ST5 = ST4;
	ST4 = ST3;
	ST3 = ST2;
	ST2 = ST1;
	ST1 = ST0;
	ST0 = val;
}

macro fpopv(val) {
    val = ST0;
	ST0 = ST1;
	ST1 = ST2;
	ST2 = ST3;
	ST3 = ST4;
	ST4 = ST5;
	ST5 = ST6;
	ST6 = ST7;
}

macro fcom(val) {
    C1 = 0;
    
    C2 = nan(ST0) || nan(val);
    C0 = C2 | ( ST0 f< val  ); 
    C3 = C2 | ( ST0 f== val );

    FPUStatusWord = (zext(C0)<<8) | (zext(C1)<<9) | (zext(C2)<<10) | (zext(C3)<<14);
}

macro fcomi(val) {
    PF = nan(ST0) || nan(val);
	ZF = PF | ( ST0 f== val );
	CF = PF | ( ST0 f< val  ); 
 
    OF = 0;
    AF = 0;
    SF = 0;
	
    FPUStatusWord = FPUStatusWord & 0xfdff;  # Clear C1
    C1 = 0;
}

# floating point NaN comparison into EFLAGS
macro fucompe(val1, val2) {
    PF = nan(val1) || nan(val2 );
    ZF = PF | ( val1 f== val2 );
    CF = PF | ( val1 f< val2 );    
 
    OF = 0;
    AF = 0;
    SF = 0;
}

# The base level constructors
#   The prefixes
:^instruction is instrPhase=0 & over=0x2e; instruction     [ segover=1; ]  {} # CS override
:^instruction is instrPhase=0 & over=0x36; instruction     [ segover=2; ]  {} # SS override
:^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; repprefx=0; ] {}
:^instruction is instrPhase=0 & over=0xf3; instruction     [ repneprefx=0; repprefx=1; ] {}
:^instruction is instrPhase=0 & over=0xf0; instruction     [ lockprefx=1; ] {}
@ifdef IA64

#
# REX opcode extension prefixes
#

# REX prefix present
# Specification is "REX"
@define REX        "longMode=1 & rexprefix=1 & rexWprefix=0"

# Specification is "REX.W"
@define REX_W      "longMode=1 & rexprefix=1 & rexWprefix=1"



# TODO I don't think the following line can really happen because the 66 67 prefix must come before REX prefix
:^instruction is $(LONGMODE_ON) & instrPhase=0 & over=0x66 & opsize=2; instruction   [ opsize=0; mandover=mandover $xor 1; ] {} # Operand size override
:^instruction is $(LONGMODE_ON) & instrPhase=0 & over=0x67 & addrsize=2; instruction [ addrsize=1; ] {} # Address size override

:^instruction is $(LONGMODE_ON) & instrPhase=0 &            row=0x4 & rexw=0 & rexr & rexx & rexb;  instruction [ instrPhase=1; rexprefix=1; opsize=1; rexWprefix=0; rexRprefix=rexr; rexXprefix=rexx; rexBprefix=rexb; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 &            row=0x4 & rexw=1 & rexr & rexx & rexb;  instruction [ instrPhase=1; rexprefix=1; opsize=2; rexWprefix=1; rexRprefix=rexr; rexXprefix=rexx; rexBprefix=rexb; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & opsize=0 & row=0x4 & rexw=0 & rexr & rexx & rexb;  instruction [ instrPhase=1; rexprefix=1; opsize=0; rexWprefix=0; rexRprefix=rexr; rexXprefix=rexx; rexBprefix=rexb; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & opsize=0 & row=0x4 & rexw=1 & rexr & rexx & rexb;  instruction [ instrPhase=1; rexprefix=1; opsize=2; rexWprefix=1; rexRprefix=rexr; rexXprefix=rexx; rexBprefix=rexb; ] {}

 # if longmode is off (on 64-bit processor in 32-bit compatibility mode), there is no 64-bit addressing, make sure is off before parsing
 #
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & addrsize=2 & instruction [ addrsize=1; ] {}
@endif

#
# VEX definitions:  One from each group must be present in the decoding; following the specification from the manual.
#

# VEX encoding for type of VEX data flow.
# Specification is "VEX.", "VEX.NDS", "VEX.NDD", or "VEX.DDS". If only "VEX." is present, then "VEX_NONE" must be used. 
@define VEX_NONE	"vexMode=1 & vexVVVV=0"
@define VEX_NDS		"vexMode=1"
@define VEX_NDD		"vexMode=1"
@define VEX_DDS		"vexMode=1"

# Specification is "LIG", "LZ", "128", or "256".
@define VEX_LIG		"vexL"
@define VEX_LZ		"vexL=0"
@define VEX_L128	"vexL=0"
@define VEX_L256	"vexL=1"

# These are only to be used with VEX or EVEX decoding, where only one "mandatory" prefix is encoded in the VEX or EVEX.
# If no prefix is specified, then VEX_PRE_NONE must be used.
# No other "physical" prefixes are allowed.
# Specification is "(empty)", "66", "F3", or "F2". If none of these are present (empty), then "VEX_PRE_NONE" must be used.
@define VEX_PRE_NONE	"mandover=0"
@define VEX_PRE_66		"mandover=1"
@define VEX_PRE_F3		"mandover=2"
@define VEX_PRE_F2		"mandover=4"

# Specification is "0F", "0F38", or "0F3A".
@define VEX_0F		"vexMMMMM=1"
@define VEX_0F38	"vexMMMMM=2"
@define VEX_0F3A	"vexMMMMM=3"

# Specification is "WIG", "W0", or "W1".
@define VEX_WIG		"rexWprefix"
@define VEX_W0		"rexWprefix=0"
@define VEX_W1		"rexWprefix=1"



@ifdef IA64

# 64-bit 3-byte VEX
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r & vex_x & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; rexXprefix=~vex_x; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r & vex_x & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; rexXprefix=~vex_x; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_66=1; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r & vex_x & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; rexXprefix=~vex_x; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f3=1; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r & vex_x & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; rexXprefix=~vex_x; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f2=1; ] {}

# 64-bit 2-byte VEX
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_66=1; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f3=1; ] {}
:^instruction is $(LONGMODE_ON) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexRprefix=~vex_r; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f2=1; ] {}

@endif

# 32-bit 3-byte VEX
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; ] {}
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_66=1; ] {}
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f3=1; ] {}
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f2=1; ] {}

# 32-bit 2-byte VEX
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_x=1 & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; ] {}
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_x=1 & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_66=1; ] {}
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_x=1 & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f3=1; ] {}
:^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_x=1 & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f2=1; ] {}


# Many of the multimedia instructions have a "mandatory" prefix, either 0x66, 0xf2 or 0xf3
# where the prefix really becomes part of the encoding.  We collect the three possible prefixes of this
# sort in the mandover context variable so we can pattern all three at once

# 3DNow pre-parse to isolate suffix byte into context (suffix3D)
# - general format: 0x0f 0x0f <modR/M> [sib] [displacement] <suffix3D-byte>
# - must determine number of bytes consumed by addressing modes
# TODO: determine supported prefixes? (e.g., 0x26)

Suffix3D: imm8        is imm8 [ suffix3D=imm8; ] { }

:^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
:^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }


# Instructions in alphabetical order

# See 'lockable.sinc' file for instructions that are lockable
with : lockprefx=0 {

:AAA			is $(LONGMODE_OFF) & vexMode=0 & byte=0x37		{ local car = ((AL & 0xf) > 9) | AF; AL = (AL+6*car)&0xf; AH=AH+car; CF=car; AF=car; }
:AAD imm8		is $(LONGMODE_OFF) & vexMode=0 & byte=0xd5; imm8	{ AL = AL + imm8*AH; AH=0; resultflags(AX); }
:AAM imm8		is $(LONGMODE_OFF) & vexMode=0 & byte=0xd4; imm8	{ AH = AL/imm8; AL = AL % imm8; resultflags(AX); }
:AAS			is $(LONGMODE_OFF) & vexMode=0 & byte=0x3f		{ local car = ((AL & 0xf) > 9) | AF; AL = (AL-6*car)&0xf; AH=AH-car; CF=car; AF=car; }

# See 'lockable.sinc' for memory destination, lockable variants
:ADC AL,imm8		is vexMode=0 & byte=0x14; AL & imm8						{ addCarryFlags( AL, imm8:1 ); resultflags( AL ); }
:ADC AX,imm16		is vexMode=0 & opsize=0 & byte=0x15; AX & imm16			{ addCarryFlags( AX, imm16:2 ); resultflags( AX ); }
:ADC EAX,imm32		is vexMode=0 & opsize=1 & byte=0x15; EAX & check_EAX_dest & imm32 { addCarryFlags( EAX, imm32:4 ); build check_EAX_dest; resultflags( EAX ); }
@ifdef IA64
:ADC RAX,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x15; RAX & simm32         { addCarryFlags( RAX, simm32 ); resultflags( RAX ); }
@endif
:ADC Rmr8,imm8		is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=2; imm8 { addCarryFlags( Rmr8, imm8:1 ); resultflags( Rmr8 ); }
:ADC Rmr16,imm16	is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=2; imm16 { addCarryFlags( Rmr16, imm16:2 ); resultflags( Rmr16 ); }
:ADC Rmr32,imm32	is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=2; imm32 { addCarryFlags( Rmr32, imm32:4 ); build check_Rmr32_dest; resultflags( Rmr32 ); }
@ifdef IA64
:ADC Rmr64,simm32       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=2; simm32 { addCarryFlags( Rmr64, simm32 ); resultflags( Rmr64 ); }
@endif
:ADC Rmr16,simm8_16	is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=2; simm8_16	{ addCarryFlags( Rmr16, simm8_16 ); resultflags( Rmr16 ); }
:ADC Rmr32,simm8_32	is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=2; simm8_32 { addCarryFlags( Rmr32, simm8_32 ); build check_Rmr32_dest; resultflags( Rmr32 ); }
@ifdef IA64
:ADC Rmr64,simm8_64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=2; simm8_64 { addCarryFlags( Rmr64, simm8_64 ); resultflags( Rmr64 ); }
@endif
:ADC Rmr8,Reg8      is vexMode=0 & byte=0x10; mod=3 & Rmr8 & Reg8                 { addCarryFlags( Rmr8, Reg8 ); resultflags( Rmr8 ); }
:ADC Rmr16,Reg16    is vexMode=0 & opsize=0 & byte=0x11; mod=3 & Rmr16 & Reg16    { addCarryFlags( Rmr16, Reg16 ); resultflags( Rmr16 ); }
:ADC Rmr32,Reg32    is vexMode=0 & opsize=1 & byte=0x11; mod=3 & Rmr32 & check_Rmr32_dest & Reg32    { addCarryFlags( Rmr32, Reg32 ); build check_Rmr32_dest; resultflags( Rmr32 ); }
@ifdef IA64
:ADC Rmr64,Reg64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x11; mod=3 & Rmr64 & Reg64    { addCarryFlags( Rmr64, Reg64 ); resultflags( Rmr64 ); }
@endif
:ADC Reg8,rm8      is vexMode=0 & byte=0x12; rm8 & Reg8 ...                 { addCarryFlags( Reg8, rm8 ); resultflags( Reg8 ); }
:ADC Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x13; rm16 & Reg16 ...    { addCarryFlags( Reg16, rm16 ); resultflags( Reg16 ); }
:ADC Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x13; rm32 & Reg32 ... & check_Reg32_dest ...   { addCarryFlags( Reg32, rm32 ); build check_Reg32_dest; resultflags( Reg32 ); }
@ifdef IA64
:ADC Reg64,rm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x13; rm64 & Reg64 ...    { addCarryFlags( Reg64, rm64 ); resultflags( Reg64 ); }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:ADD AL,imm8		is vexMode=0 & byte=0x4; AL & imm8					{ addflags(   AL,imm8 );    AL =    AL +  imm8; resultflags(   AL); }
:ADD AX,imm16		is vexMode=0 & opsize=0 & byte=0x5; AX & imm16			{ addflags(   AX,imm16);    AX =    AX + imm16; resultflags(   AX); }
:ADD EAX,imm32		is vexMode=0 & opsize=1 & byte=0x5; EAX & check_EAX_dest & imm32			{ addflags(  EAX,imm32);   EAX =   EAX + imm32; build check_EAX_dest; resultflags(  EAX); }
@ifdef IA64
:ADD RAX,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x5; RAX & simm32          { addflags(  RAX,simm32);   RAX =   RAX + simm32; resultflags(  RAX); }
@endif
:ADD Rmr8,imm8		is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=0; imm8		{ addflags(  Rmr8,imm8 );   Rmr8 =   Rmr8 +  imm8; resultflags(  Rmr8); }
:ADD Rmr16,imm16		is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=0; imm16	{ addflags( Rmr16,imm16);  Rmr16 =  Rmr16 + imm16; resultflags( Rmr16); }
:ADD Rmr32,imm32		is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=0; imm32	{ addflags( Rmr32,imm32);  Rmr32 =  Rmr32 + imm32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:ADD Rmr64,simm32		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=0; simm32	{ addflags( Rmr64,simm32);  Rmr64 =  Rmr64 + simm32; resultflags( Rmr64); }
@endif
:ADD Rmr16,simm8_16		is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=0; simm8_16	{ addflags( Rmr16,simm8_16);  Rmr16 =  Rmr16 + simm8_16; resultflags( Rmr16); }
:ADD Rmr32,simm8_32		is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=0; simm8_32	{ addflags( Rmr32,simm8_32);  Rmr32 =  Rmr32 + simm8_32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:ADD Rmr64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=0; simm8_64	{ addflags( Rmr64,simm8_64);  Rmr64 =  Rmr64 + simm8_64; resultflags( Rmr64); }
@endif
:ADD Rmr8,Reg8      is vexMode=0 & byte=0x00; mod=3 & Rmr8 & Reg8                 { addflags(  Rmr8,Reg8 );   Rmr8 =   Rmr8 +  Reg8; resultflags(  Rmr8); }
:ADD Rmr16,Reg16    is vexMode=0 & opsize=0 & byte=0x1; mod=3 & Rmr16 & Reg16     { addflags( Rmr16,Reg16);  Rmr16 =  Rmr16 + Reg16; resultflags( Rmr16); }
:ADD Rmr32,Reg32    is vexMode=0 & opsize=1 & byte=0x1; mod=3 & Rmr32 & check_Rmr32_dest & Reg32     { addflags( Rmr32,Reg32);  Rmr32 =  Rmr32 + Reg32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:ADD Rmr64,Reg64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x1; mod=3 & Rmr64 & Reg64     { addflags( Rmr64,Reg64);  Rmr64 =  Rmr64 + Reg64; resultflags( Rmr64); }
@endif
:ADD Reg8,rm8      is vexMode=0 & byte=0x2; rm8 & Reg8 ...                             { addflags( Reg8,rm8  );  Reg8 =  Reg8 +   rm8; resultflags( Reg8); }
:ADD Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x3; rm16 & Reg16 ...     { addflags(Reg16,rm16 ); Reg16 = Reg16 +  rm16; resultflags(Reg16); }
:ADD Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x3; rm32 & Reg32 ... & check_Reg32_dest ...     { addflags(Reg32,rm32 ); Reg32 = Reg32 +  rm32; build check_Reg32_dest; resultflags(Reg32); }
@ifdef IA64
:ADD Reg64,rm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x3; rm64 & Reg64 ...     { addflags(Reg64,rm64 ); Reg64 = Reg64 +  rm64; resultflags(Reg64); }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:AND AL,imm8       is vexMode=0 & byte=0x24; AL & imm8                                 { logicalflags();    AL =    AL &  imm8; resultflags(   AL); }
:AND AX,imm16      is vexMode=0 & opsize=0 & byte=0x25; AX & imm16          { logicalflags();    AX =    AX & imm16; resultflags(   AX); }
:AND EAX,imm32     is vexMode=0 & opsize=1 & byte=0x25; EAX & check_EAX_dest & imm32         { logicalflags();   EAX =   EAX & imm32; build check_EAX_dest; resultflags(  EAX); }
@ifdef IA64
:AND RAX,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x25; RAX & simm32         { logicalflags();   RAX =   RAX & simm32; resultflags(  RAX); }
@endif
:AND Rmr8,imm8      is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=4; imm8     { logicalflags();   Rmr8 =   Rmr8 &  imm8; resultflags(  Rmr8); }
:AND Rmr16,imm16    is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=4; imm16  { logicalflags();  Rmr16 =  Rmr16 & imm16; resultflags( Rmr16); }
:AND Rmr32,imm32    is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=4; imm32  { logicalflags();  Rmr32 =  Rmr32 & imm32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:AND Rmr64,simm32    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=4; simm32  { logicalflags();  Rmr64 =  Rmr64 & simm32; resultflags( Rmr64); }
@endif
:AND Rmr16,usimm8_16		is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=4; usimm8_16	{ logicalflags();  Rmr16 =  Rmr16 & usimm8_16; resultflags( Rmr16); }
:AND Rmr32,usimm8_32		is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=4; usimm8_32	{ logicalflags();  Rmr32 =  Rmr32 & usimm8_32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:AND Rmr64,usimm8_64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=4; usimm8_64	{ logicalflags();  Rmr64 =  Rmr64 & usimm8_64; resultflags( Rmr64); }
@endif
:AND Rmr8,Reg8      is vexMode=0 & byte=0x20; mod=3 & Rmr8 & Reg8                     { logicalflags();   Rmr8 =   Rmr8 &  Reg8; resultflags(  Rmr8); }
:AND Rmr16,Reg16    is vexMode=0 & opsize=0 & byte=0x21; mod=3 & Rmr16 & Reg16        { logicalflags();  Rmr16 =  Rmr16 & Reg16; resultflags( Rmr16); }
:AND Rmr32,Reg32    is vexMode=0 & opsize=1 & byte=0x21; mod=3 & Rmr32 & check_Rmr32_dest & Reg32        { logicalflags();  Rmr32 =  Rmr32 & Reg32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:AND Rmr64,Reg64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x21; mod=3 & Rmr64 & Reg64        { logicalflags();  Rmr64 =  Rmr64 & Reg64; resultflags( Rmr64); }
@endif
:AND Reg8,rm8      is vexMode=0 & byte=0x22; rm8 & Reg8 ...                            { logicalflags();  Reg8 =  Reg8 &   rm8; resultflags( Reg8); }
:AND Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x23; rm16 & Reg16 ...        { logicalflags(); Reg16 = Reg16 &  rm16; resultflags(Reg16); }
:AND Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x23; rm32 & Reg32 ... & check_Reg32_dest ...        { logicalflags(); Reg32 = Reg32 &  rm32; build check_Reg32_dest; resultflags(Reg32); }
@ifdef IA64
:AND Reg64,rm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x23; rm64 & Reg64 ...        { logicalflags(); Reg64 = Reg64 &  rm64; resultflags(Reg64); }
@endif

#ARPL is not encodable in 64-bit mode
:ARPL rm16,Reg16    is $(LONGMODE_OFF) & vexMode=0 & bit64=0 & byte=0x63; rm16 & Reg16 ...                { local rpldest=rm16&3; local rplsrc=Reg16&3; local rpldiff=rplsrc-rpldest;
                                          ZF = rpldiff s> 0; rm16 = rm16 + (zext(CF) * rpldiff); }

:BOUND Reg16,m16    is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0x62; m16 & Reg16 ...      { }
:BOUND Reg32,m32    is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0x62; m32 & Reg32 ...      { }

#:BSF Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0xbc; rm16 & Reg16 ... { ZF = rm16 == 0;
#                                                  choose = 0xffff * (zext((0xff & rm16) == 0));
#                                                      mask = (0xf00 & choose) | (0xf | ~choose);
#                                                      pos = 8 & choose;
#                                          choose = 0xffff * (zext((mask & rm16) == 0));
#                                          mask1 = (mask << 2) & (mask << 4);
#                                          mask2 = (mask >> 2) & mask;
#                                          mask = (mask1 & choose) | (mask2 | ~choose);
#                                          pos = pos + (4 & choose);
#                                          choose = 0xffff * (zext((mask & rm16) == 0));
#                                          mask1 = (mask << 1) & (mask << 2);
#                                          mask2 = (mask >> 1) & mask;
#                                          mask = (mask1 & choose) | (mask2 | ~choose);
#                                          pos = pos + (2 & choose);
#                                          choose = zext((mask & rm16) == 0);
#                                          Reg16 = pos + choose; }
                                          
:BSF Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0xbc; rm16 & Reg16 ...
{
    bitIndex:2 = 0;

    ZF = ( rm16 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( ((rm16 >> bitIndex) & 0x0001) != 0 ) goto <done>;
      bitIndex = bitIndex + 1;
    goto <start>;
    
<done>
    Reg16 = bitIndex;
}                             

#:BSF Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0xbc; rm32 & Reg32 ... & check_Reg32_dest ...      { ZF = rm32 == 0;                 
#                                                choose = 0xffffffff * (zext((0xffff & rm32) == 0));
#                                                    mask = (0xff0000 & choose) | (0xff | ~choose);  
#                                                    pos = 16 & choose;                  
#                                                    choose = 0xffffffff * (zext((mask & rm32) == 0));   
#                                                    mask1 = (mask << 4) & (mask << 8);          
#                                                    mask2 = (mask >> 4) & mask;         
#                                                    mask = (mask1 & choose) | (mask2 | ~choose);    
#                                                    pos = pos + (8 & choose);               
#                                                    choose = 0xffffffff * (zext((mask & rm32) == 0));   
#                                                    mask1 = (mask << 2) & (mask << 4);          
#                                                    mask2 = (mask >> 2) & mask;         
#                                                    mask = (mask1 & choose) | (mask2 | ~choose);    
#                                                    pos = pos + (4 & choose);               
#                                                    choose = 0xffffffff * (zext((mask & rm32) == 0));   
#                                                    mask1 = (mask << 1) & (mask << 2);          
#                                                    mask2 = (mask >> 1) & mask;         
#                                                    mask = (mask1 & choose) | (mask2 | ~choose);    
#                                                    pos = pos + (2 & choose);               
#                                                    choose = zext((mask & rm32) == 0);          
#                                                    Reg32 = pos + choose; 
#                                                    build check_Reg32_dest;  }

:BSF Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0xbc; rm32 & Reg32 ... & check_Reg32_dest ...                 
{
    bitIndex:4 = 0;

    ZF = ( rm32 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( ((rm32 >> bitIndex) & 0x00000001) != 0 ) goto <done>;
      bitIndex = bitIndex + 1;
    goto <start>;
    
<done>
    Reg32 = bitIndex;
    build check_Reg32_dest;
}                             
                            
@ifdef IA64
#:BSF Reg64,rm64     is vexMode=0 & opsize=2 & byte=0xf; byte=0xbc; rm64 & Reg64 ...       { ZF = rm64 == 0;
## TODO: NEED TO EXTEND THIS TO 64bit op             
#                                                    choose = 0xffffffff * (zext((0xffff & rm64) == 0));
#                                                    mask = (0xff0000 & choose) | (0xff | ~choose);  
#                                                    pos = 16 & choose;                  
#                                                    choose = 0xffffffff * (zext((mask & rm64) == 0));   
#                                                    mask1 = (mask << 4) & (mask << 8);          
#                                                    mask2 = (mask >> 4) & mask;         
#                                                    mask = (mask1 & choose) | (mask2 | ~choose);    
#                                                    pos = pos + (8 & choose);               
#                                                    choose = 0xffffffff * (zext((mask & rm64) == 0));   
#                                                    mask1 = (mask << 2) & (mask << 4);          
#                                                    mask2 = (mask >> 2) & mask;         
#                                                    mask = (mask1 & choose) | (mask2 | ~choose);    
#                                                    pos = pos + (4 & choose);               
#                                                    choose = 0xffffffff * (zext((mask & rm64) == 0));   
#                                                    mask1 = (mask << 1) & (mask << 2);          
#                                                    mask2 = (mask >> 1) & mask;         
#                                                    mask = (mask1 & choose) | (mask2 | ~choose);    
#                                                    pos = pos + (2 & choose);               
#                                                    choose = zext((mask & rm64) == 0);          
#                                                    Reg64 = pos + choose; }                            

:BSF Reg64,rm64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbc; rm64 & Reg64 ...                         
{
    bitIndex:8 = 0;

    ZF = ( rm64 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( ((rm64 >> bitIndex) & 0x0000000000000001) != 0 ) goto <done>;
      bitIndex = bitIndex + 1;
    goto <start>;
    
<done>
    Reg64 = bitIndex;
}                             
@endif

#:BSR Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0xbd; rm16 & Reg16 ... { ZF = rm16 == 0;                  
#                                                   choose = 0xffff * (zext((0xff00 & rm16) == 0));
#                                                   mask = (0xf000 & ~choose) | (0xf0 | choose);  
#                                                   pos = 16 - (8 & choose);            
#                                                   choose = 0xffff * (zext((mask & rm16) == 0)); 
#                                                   mask1 = (mask >> 2) & (mask >> 4);          
#                                                   mask2 = (mask << 2) & mask;         
#                                                   mask = (mask1 & choose) | (mask2 | ~choose);  
#                                                   pos = pos - (4 & choose);               
#                                                   choose = 0xffff * (zext((mask & rm16) == 0)); 
#                                                   mask1 = (mask >> 1) & (mask >> 2);          
#                                                   mask2 = (mask << 1) & mask;         
#                                                   mask = (mask1 & choose) | (mask2 | ~choose);  
#                                                   pos = pos - (2 & choose);               
#                                                   choose = zext((mask & rm16) == 0);          
#                                                   Reg16 = pos - choose; }                       

:BSR Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0xbd; rm16 & Reg16 ...                   
{
    bitIndex:2 = 15;

    ZF = ( rm16 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( (rm16 >> bitIndex) != 0 ) goto <done>;
      bitIndex = bitIndex - 1;
    goto <start>;
    
<done>
    Reg16 = bitIndex;
}                             

#:BSR Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0xbd; rm32 & Reg32 ... & check_Reg32_dest ... { ZF = rm32 == 0;                         
#                                                  choose = 0xffffffff * (zext((0xffff0000 & rm32) == 0));  
#                                                  mask = (0xff000000 & ~choose) | (0xff00 | choose);          
#                                                  pos = 32 - (16 & choose);                   
#                                                  choose = 0xffffffff * (zext((mask & rm32) == 0));       
#                                                  mask1 = (mask >> 4) & (mask >> 8);                  
#                                                  mask2 = (mask << 4) & mask;                 
#                                                  mask = (mask1 & choose) | (mask2 | ~choose);        
#                                                  pos = pos - (8 & choose);                   
#                                                  choose = 0xffffffff * (zext((mask & rm32) == 0));       
#                                                  mask1 = (mask >> 2) & (mask >> 4);                  
#                                                  mask2 = (mask << 2) & mask;                 
#                                                  mask = (mask1 & choose) | (mask2 | ~choose);        
#                                                  pos = pos - (4 & choose);                   
#                                                  choose = 0xffffffff * (zext((mask & rm32) == 0));       
#                                                  mask1 = (mask >> 1) & (mask >> 2);                  
#                                                  mask2 = (mask << 1) & mask;                 
#                                                  mask = (mask1 & choose) | (mask2 | ~choose);        
#                                                  pos = pos - (2 & choose);                   
#                                                  choose = zext((mask & rm32) == 0);                  
#                                                  Reg32 = pos - choose; 
#                                                  build check_Reg32_dest; }
                                                                                  
:BSR Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0xbd; rm32 & Reg32 ... & check_Reg32_dest ...
{
    bitIndex:4 = 31;

    ZF = ( rm32 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( (rm32 >> bitIndex) != 0 ) goto <done>;
      bitIndex = bitIndex - 1;
    goto <start>;
    
<done>
    Reg32 = bitIndex;
    build check_Reg32_dest;
}                             


@ifdef IA64
#:BSR Reg64,rm64     is vexMode=0 & opsize=2 & byte=0xf; byte=0xbd; rm64 & Reg64 ... { ZF = rm64 == 0;                         
## TODO: NEED TO EXTEND THIS TO 64bit op     
#                                                  choose = 0xffffffff * (zext((0xffff0000 & rm64) == 0));  
#                                                  mask = (0xff000000 & ~choose) | (0xff00 | choose);          
#                                                  pos = 32 - (16 & choose);                   
#                                                  choose = 0xffffffff * (zext((mask & rm64) == 0));       
#                                                  mask1 = (mask >> 4) & (mask >> 8);                  
#                                                  mask2 = (mask << 4) & mask;                 
#                                                  mask = (mask1 & choose) | (mask2 | ~choose);        
#                                                  pos = pos - (8 & choose);                   
#                                                  choose = 0xffffffff * (zext((mask & rm64) == 0));       
#                                                  mask1 = (mask >> 2) & (mask >> 4);                  
#                                                  mask2 = (mask << 2) & mask;                 
#                                                  mask = (mask1 & choose) | (mask2 | ~choose);        
#                                                  pos = pos - (4 & choose);                   
#                                                  choose = 0xffffffff * (zext((mask & rm64) == 0));       
#                                                  mask1 = (mask >> 1) & (mask >> 2);                  
#                                                  mask2 = (mask << 1) & mask;                 
#                                                  mask = (mask1 & choose) | (mask2 | ~choose);        
#                                                  pos = pos - (2 & choose);                   
#                                                  choose = zext((mask & rm64) == 0);                  
#                                                  Reg64 = pos - choose; }                                  

:BSR Reg64,rm64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbd; rm64 & Reg64 ...                         
{
    bitIndex:8 = 63;

    ZF = ( rm64 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( (rm64 >> bitIndex) != 0 ) goto <done>;
      bitIndex = bitIndex - 1;
    goto <start>;
    
<done>
    Reg64 = bitIndex;
}                             

@endif

:BSWAP Rmr32        is vexMode=0 & byte=0xf; row=12 & page=1 & Rmr32 & check_Rmr32_dest
                                            { local tmp =        (Rmr32 & 0xff000000) >> 24 ;
                                              tmp = tmp | ((Rmr32 & 0x00ff0000) >> 8 );
                                              tmp = tmp | ((Rmr32 & 0x0000ff00) << 8 );
                                              Rmr32 = tmp | ((Rmr32 & 0x000000ff) << 24); 
                                              build check_Rmr32_dest; }
@ifdef IA64
:BSWAP Rmr64        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; row=12 & page=1 & Rmr64
                                            { local tmp =          (Rmr64 & 0xff00000000000000) >> 56 ;
                                              tmp = tmp |   ((Rmr64 & 0x00ff000000000000) >> 40 );
                                              tmp = tmp |   ((Rmr64 & 0x0000ff0000000000) >> 24 );
                                              tmp = tmp |   ((Rmr64 & 0x000000ff00000000) >>  8 );
                                              tmp = tmp |   ((Rmr64 & 0x00000000ff000000) <<  8 );
                                              tmp = tmp |   ((Rmr64 & 0x0000000000ff0000) << 24 );
                                              tmp = tmp |   ((Rmr64 & 0x000000000000ff00) << 40 );
                                              Rmr64 = tmp | ((Rmr64 & 0x00000000000000ff) << 56); }
@endif

:BT Rmr16,Reg16		is vexMode=0 & opsize=0 & byte=0xf; byte=0xa3; mod=3 & Rmr16 & Reg16		{ CF = ((Rmr16 >> (Reg16 &  0xf)) & 1) != 0; }
:BT Mem,Reg16		is vexMode=0 & opsize=0 & byte=0xf; byte=0xa3; Mem & Reg16 ...		{ local ptr = Mem + (sext(Reg16) s>> 3);
											  CF = ((*:1 ptr >> (Reg16 & 0x7)) & 1) != 0; }
:BT Rmr32,Reg32		is vexMode=0 & opsize=1 & byte=0xf; byte=0xa3; mod=3 & Rmr32 & Reg32		{ CF = ((Rmr32 >> (Reg32 & 0x1f)) & 1) != 0; }
:BT Mem,Reg32		is vexMode=0 & opsize=1 & byte=0xf; byte=0xa3; Mem & Reg32 ...		{
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    CF = ((*:1 ptr >> (Reg32 & 0x7)) & 1) != 0;
}
@ifdef IA64
:BT Rmr64,Reg64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xa3; mod=3 & Rmr64 & Reg64		{ CF = ((Rmr64 >> (Reg64 & 0x3f)) & 1) != 0; }
:BT Mem,Reg64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xa3; Mem & Reg64 ...		{ local ptr = Mem + (Reg64 s>> 3);
											  CF = ((*:1 ptr >> (Reg64 & 0x7)) & 1) != 0; }
@endif
:BT rm16,imm8       is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; (rm16 & reg_opcode=4 ...); imm8  { CF = ((rm16 >> (imm8 & 0x0f)) & 1) != 0; } 
:BT rm32,imm8       is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; (rm32 & reg_opcode=4 ...); imm8  { CF = ((rm32 >> (imm8 & 0x1f)) & 1) != 0; }
@ifdef IA64
:BT rm64,imm8       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xba; (rm64 & reg_opcode=4 ...); imm8  { CF = ((rm64 >> (imm8 & 0x3f)) & 1) != 0; }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:BTC Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xbb; mod=3 & Rmr16 & Reg16		{ local bit=Reg16&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16^(1<<bit); CF=(val!=0); }
:BTC Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xbb; mod=3 & Rmr32 & Reg32 & check_Rmr32_dest 		{ local bit=Reg32&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32^(1<<bit); build check_Rmr32_dest; }
@ifdef IA64
:BTC Rmr64,Reg64   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbb; mod=3 & Rmr64 & Reg64		{ local bit=Reg64&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64^(1<<bit); CF=(val!=0); }
@endif
:BTC Rmr16,imm8     is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; mod=3 & Rmr16 & reg_opcode=7; imm8   { local bit=imm8&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16^(1<<bit); CF=(val!=0); }
:BTC Rmr32,imm8     is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=7; imm8   { local bit=imm8&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32^(1<<bit); build check_Rmr32_dest; }
@ifdef IA64
:BTC Rmr64,imm8     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xba; mod=3 & Rmr64 & reg_opcode=7; imm8   { local bit=imm8&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64^(1<<bit); CF=(val!=0); }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:BTR Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xb3; mod=3 & Rmr16 & Reg16		{ local bit=Reg16&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16 & ~(1<<bit); CF=(val!=0); }
:BTR Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xb3; mod=3 & Rmr32 & check_Rmr32_dest & Reg32		{ local bit=Reg32&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32 & ~(1<<bit); build check_Rmr32_dest;  }
@ifdef IA64
:BTR Rmr64,Reg64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb3; mod=3 & Rmr64 & Reg64		{ local bit=Reg64&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64 & ~(1<<bit); CF=(val!=0); }
@endif
:BTR Rmr16,imm8     is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; mod=3 & Rmr16 & reg_opcode=6; imm8   { local bit=imm8&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16 & ~(1<<bit); CF=(val!=0); }
:BTR Rmr32,imm8     is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; mod=3 & Rmr32 & reg_opcode=6 & check_Rmr32_dest; imm8   { local bit=imm8&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32 & ~(1<<bit); build check_Rmr32_dest;  }
@ifdef IA64
:BTR Rmr64,imm8     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xba; mod=3 & Rmr64 & reg_opcode=6; imm8   { local bit=imm8&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64 & ~(1<<bit); CF=(val!=0); }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:BTS Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xab; mod=3 & Rmr16 & Reg16		{ local bit=Reg16&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16 | (1<<bit); CF=(val!=0); }
:BTS Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xab; mod=3 & Rmr32 & check_Rmr32_dest & Reg32		{ local bit=Reg32&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32 | (1<<bit); build check_Rmr32_dest; }
@ifdef IA64
:BTS Rmr64,Reg64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xab; mod=3 & Rmr64 & Reg64		{ local bit=Reg64&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64 | (1<<bit); CF=(val!=0); }
@endif
:BTS Rmr16,imm8     is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; mod=3 & Rmr16 & reg_opcode=5; imm8   { local bit=imm8&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16 | (1<<bit); CF=(val!=0); }
:BTS Rmr32,imm8     is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; mod=3 & Rmr32 & reg_opcode=5 & check_Rmr32_dest; imm8   { local bit=imm8&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32 | (1<<bit); build check_Rmr32_dest;  }
@ifdef IA64
:BTS Rmr64,imm8     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xba; mod=3 & Rmr64 & reg_opcode=5; imm8   { local bit=imm8&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64 | (1<<bit); CF=(val!=0); }
@endif

:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; rel16     { push22(&:2 inst_next); call rel16; }
:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; rel16     { push42(&:2 inst_next); call rel16; }
@ifdef IA64
:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xe8; rel16     { push88(&:8 inst_next); call rel16; }
@endif

#  When is a Call a Jump, when it jumps right after.  Not always the case but...
:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push22(&:2 inst_next); goto rel16; }
:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push42(&:2 inst_next); goto rel16; }
@ifdef IA64
:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push88(&:8 inst_next); goto rel16; }
@endif

:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; rel32     { push24(&:4 inst_next); call rel32; }
:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     { push44(&:4 inst_next); call rel32; }
@ifdef IA64
:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & (opsize=1 | opsize=2) & byte=0xe8; rel32     { push88(&:8 inst_next); call rel32; }
@endif

#  When is a call a Jump, when it jumps right after.  Not always the case but...
:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push24(&:4 inst_next); goto rel32; }
:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push44(&:4 inst_next); goto rel32; }
@ifdef IA64
:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & (opsize=1 | opsize=2) & byte=0xe8; simm32=0 & rel32      { push88(&:8 inst_next); goto rel32; }
@endif

:CALL rm16	    is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=2 ...	{ local dest:4 = segment(currentCS,rm16); push22(&:2 inst_next); call [dest]; }
:CALL rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:2 = rm16; push42(&:2 inst_next); call [dest]; }
@ifdef IA64
:CALL rm16      is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:8 = inst_next + zext(rm16); push88(&:8 inst_next); call [dest]; }
@endif

:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push24(&:4 inst_next); call [dest]; }
:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push44(&:4 inst_next); call [dest]; }
@ifdef IA64
:CALL rm64      is $(LONGMODE_ON) & vexMode=0 & (opsize=1 | opsize=2) & byte=0xff; rm64 & reg_opcode=2 ...   { local dest:8 = rm64; push88(&:8 inst_next); call [dest]; }
@endif

# direct far calls generate an opcode undefined exception in x86-64
:CALLF ptr1616      is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           { push22(CS); build ptr1616; push22(&:2 inst_next); call ptr1616; }
:CALLF ptr1616      is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           { push42(CS); build ptr1616; push42(&:2 inst_next); call ptr1616; }
:CALLF ptr1632      is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           { push22(CS); build ptr1632; push24(&:4 inst_next); call ptr1632; }
:CALLF ptr1632      is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           { pushseg44(CS); build ptr1632; push44(&:4 inst_next); call ptr1632; }
:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; addr16 & reg_opcode=3 ... { local ptr:$(SIZE) = segment(DS,addr16); local addrptr:$(SIZE) = segment(*:2 (ptr+2),*:2 ptr);
                                                                                                  push22(CS); push22(&:2 inst_next); call [addrptr]; }
:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push42(&:2 inst_next); call [dest]; }
@ifdef IA64
:CALLF addr64       is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push82(&:2 inst_next); call [dest]; }
@endif


:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; addr16 & reg_opcode=3 ... { local dest:2 = addr16; push22(CS); push24(&:4 inst_next); call [dest]; }
:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; pushseg44(CS); push44(&:4 inst_next); call [dest]; }
@ifdef IA64
:CALLF addr32       is $(LONGMODE_ON) &vexMode=0 & addrsize=1 & opsize=2 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; pushseg88(CS); push88(&:8 inst_next); call [dest]; }
:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=1 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; pushseg44(CS); push84(&:4 inst_next); call [dest]; }
:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=2 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; pushseg88(CS); push88(&:8 inst_next); call [dest]; }
@endif

:CBW            is vexMode=0 & opsize=0 & byte=0x98                 { AX = sext(AL); }
:CWDE           is vexMode=0 & opsize=1 & byte=0x98 & check_EAX_dest { EAX = sext(AX); build check_EAX_dest;}
@ifdef IA64
:CDQE           is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x98                 { RAX = sext(EAX); }
@endif

:CWD            is vexMode=0 & opsize=0 & byte=0x99                 { tmp:4 = sext(AX); DX = tmp(2); }
:CDQ            is vexMode=0 & opsize=1 & byte=0x99 & check_EDX_dest { tmp:8 = sext(EAX); EDX = tmp(4); build check_EDX_dest;}
@ifdef IA64
:CQO            is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x99                 { tmp:16 = sext(RAX); RDX = tmp(8); }
@endif

define pcodeop clflush;
:CLFLUSH m8     is vexMode=0 & mandover=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=7 ) ... & m8 {
	clflush(m8);
}

:CLAC           is vexMode=0 & byte=0x0F; byte=0x01; byte=0xCA { AC = 0; }

:CLC			is vexMode=0 & byte=0xf8						{ CF = 0; }
:CLD			is vexMode=0 & byte=0xfc						{ DF = 0; }
# MFL:  AMD instruction
# TODO: define the action.
# CLGI:  clear global interrupt flag (GIF); while GIF is zero, all external interrupts are disabled.
:CLGI                   is vexMode=0 & byte=0x0f; byte=0x01; byte=0xDD                      { clgi(); }
:CLI			is vexMode=0 & byte=0xfa						{ IF = 0; }
define pcodeop clts;
:CLTS			is vexMode=0 & byte=0x0f; byte=0x06				{ CR0 = CR0 & ~(0x8); }

define pcodeop clzero;

:CLZERO        is vexMode=0 & opsize=0 & byte=0x0F; byte=0x01; byte=0xFC { clzero(AX); }
:CLZERO        is vexMode=0 & opsize=1 & byte=0x0F; byte=0x01; byte=0xFC { clzero(EAX); }
@ifdef IA64
:CLZERO        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0F; byte=0x01; byte=0xFC { clzero(RAX); }
@endif


:CMC			is vexMode=0 & byte=0xf5						{ CF = CF==0; }

:CMOV^cc Reg16,rm16 is vexMode=0 & opsize=0 & byte=0xf; row=4 & cc; rm16 & Reg16 ...    { local tmp = rm16; if (!cc) goto inst_next; Reg16 = tmp; }
:CMOV^cc Reg32,rm32 is vexMode=0 & opsize=1 & byte=0xf; row=4 & cc; rm32 & Reg32 ... & check_Reg32_dest ...   { local tmp = rm32; build check_Reg32_dest; if (!cc) goto inst_next; Reg32 = tmp; }
@ifdef IA64
:CMOV^cc Reg64,rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; row=4 & cc; rm64 & Reg64 ...    { local tmp = rm64; if (!cc) goto inst_next; Reg64 = tmp; }
@endif

:CMP AL,imm8        is vexMode=0 & byte=0x3c; AL & imm8                                 { subflags(   AL,imm8 ); local tmp =    AL -   imm8; resultflags(tmp); }
:CMP AX,imm16       is vexMode=0 & opsize=0 & byte=0x3d; AX & imm16         { subflags(   AX,imm16); local tmp =    AX -  imm16; resultflags(tmp); }
:CMP EAX,imm32      is vexMode=0 & opsize=1 & byte=0x3d; EAX & imm32            { subflags(  EAX,imm32); local tmp =   EAX -  imm32; resultflags(tmp); }
@ifdef IA64
:CMP RAX,simm32      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x3d; RAX & simm32            { subflags(  RAX,simm32); local tmp =   RAX -  simm32; resultflags(tmp); }
@endif
:CMP spec_rm8,imm8       is vexMode=0 & $(BYTE_80_82); spec_rm8 & reg_opcode=7 ...; imm8        { local temp:1 = spec_rm8; subflags(temp,imm8 ); local diff = temp - imm8; resultflags(diff); }
:CMP spec_rm16,imm16     is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=7 ...; imm16 { local temp:2 = spec_rm16; subflags(temp,imm16); local diff = temp - imm16; resultflags(diff); }
:CMP spec_rm32,imm32     is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & reg_opcode=7 ...; imm32 { local temp:4 = spec_rm32; subflags(temp,imm32); local diff = temp - imm32; resultflags(diff); }
@ifdef IA64
:CMP spec_rm64,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; spec_rm64 & reg_opcode=7 ...; simm32 { local temp:8 = spec_rm64; subflags(temp,simm32); local diff = temp - simm32; resultflags(diff); }
@endif
:CMP spec_rm16,simm8_16		is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=7 ...; simm8_16	{ local temp:2 = spec_rm16; subflags(temp,simm8_16); local diff = temp - simm8_16; resultflags(diff); }
:CMP spec_rm32,simm8_32		is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & reg_opcode=7 ...; simm8_32	{ local temp:4 = spec_rm32; subflags(temp,simm8_32); local diff = temp - simm8_32; resultflags(diff); }
@ifdef IA64
:CMP spec_rm64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; spec_rm64 & reg_opcode=7 ...; simm8_64	{ local temp:8 = spec_rm64; subflags(temp,simm8_64); local diff = temp - simm8_64; resultflags(diff); }
@endif
:CMP rm8,Reg8       is vexMode=0 & byte=0x38; rm8 & Reg8 ...                { local temp:1 = rm8; subflags(temp,Reg8); local diff = temp - Reg8; resultflags(diff); }
:CMP rm16,Reg16     is vexMode=0 & opsize=0 & byte=0x39; rm16 & Reg16 ...       { local temp:2 = rm16; subflags(temp,Reg16); local diff = temp - Reg16; resultflags(diff); }
:CMP rm32,Reg32     is vexMode=0 & opsize=1 & byte=0x39; rm32 & Reg32 ...       { local temp:4 = rm32; subflags(temp,Reg32 ); local diff = temp - Reg32; resultflags(diff); }
@ifdef IA64
:CMP rm64,Reg64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x39; rm64 & Reg64 ...       { local temp:8 = rm64; subflags(temp,Reg64); local diff = temp - Reg64; resultflags(diff); }
@endif
:CMP Reg8,rm8       is vexMode=0 & byte=0x3a; rm8 & Reg8 ...                            { local temp:1 = rm8; subflags(Reg8,temp); local diff = Reg8 - temp; resultflags(diff); } 
:CMP Reg16,rm16     is vexMode=0 & opsize=0 & byte=0x3b; rm16 & Reg16 ...       { local temp:2 = rm16; subflags(Reg16,temp); local diff = Reg16 - temp; resultflags(diff); }
:CMP Reg32,Rmr32     is vexMode=0 & opsize=1 & byte=0x3b; Reg32 & mod=3 & Rmr32       { local temp:4 = Rmr32; subflags(Reg32,temp); local diff = Reg32 - temp; resultflags(diff); }
:CMP Reg32,m32     is vexMode=0 & opsize=1 & byte=0x3b; Reg32 ... & m32      {local temp:4 = m32; subflags(Reg32, temp); local diff = Reg32 - temp; resultflags(diff); }
@ifdef IA64
:CMP Reg64,rm64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x3b; rm64 & Reg64 ...       { local temp:8 = rm64; subflags(Reg64,temp); local diff = Reg64 - temp; resultflags(diff); }
@endif

:CMPSB^repe^repetail eseDI1,dseSI1  is vexMode=0 & repe & repetail & byte=0xa6 & dseSI1 & eseDI1        { build repe; build eseDI1; build dseSI1; local temp_DI1:1 = eseDI1; local temp_SI1:1 = dseSI1;  subflags(temp_SI1,temp_DI1); local diff=temp_SI1 - temp_DI1; resultflags(diff); build repetail; }
:CMPSW^repe^repetail eseDI2,dseSI2  is vexMode=0 & repe & repetail & opsize=0 & byte=0xa7 & dseSI2 & eseDI2 { build repe; build eseDI2; build dseSI2; local temp_DI2:2 = eseDI2; local temp_SI2:2 = dseSI2; subflags(temp_SI2,temp_DI2); local diff=temp_SI2 - temp_DI2; resultflags(diff); build repetail; }
:CMPSD^repe^repetail eseDI4,dseSI4  is vexMode=0 & repe & repetail & opsize=1 & byte=0xa7 & dseSI4 & eseDI4 { build repe; build eseDI4; build dseSI4; local temp_DI4:4 = eseDI4; local temp_SI4:4 = dseSI4; subflags(temp_SI4,temp_DI4); local diff=temp_SI4 - temp_DI4; resultflags(diff); build repetail; }
@ifdef IA64
:CMPSD^repe^repetail eseDI8,dseSI8  is $(LONGMODE_ON) & vexMode=0 & repe & repetail & opsize=2 & byte=0xa7 & dseSI8 & eseDI8 { build repe; build eseDI8; build dseSI8; local temp_DI8:8 = eseDI8; local temp_SI8:8 = dseSI8; subflags(temp_SI8,temp_DI8); local diff=temp_SI8-temp_DI8; resultflags(diff); build repetail; }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:CMPXCHG Rmr8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; mod=3 & Rmr8 & Reg8           
{ 
    local dest = Rmr8;
    subflags(AL,dest); 
    local diff = AL-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    AL = dest;
    goto inst_next;
<equal>
    Rmr8 = Reg8;
 }
:CMPXCHG Rmr16,Reg16    is vexMode=0 & opsize=0 & byte=0xf; byte=0xb1; mod=3 & Rmr16 & Reg16  
{ 
    local dest = Rmr16;
    subflags(AX,dest); 
    local diff = AX-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    AX = dest;
    goto inst_next;
<equal>
    Rmr16 = Reg16;
 }
:CMPXCHG Rmr32,Reg32    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb1; mod=3 & Rmr32 & Reg32 & check_EAX_dest & check_Rmr32_dest
{
	#this instruction writes to either EAX or Rmr32
	#in 64-bit mode, a 32-bit register that is written to 
	#(and only the register that is written to) 
	#must be zero-extended to 64 bits
    local dest = Rmr32;
    subflags(EAX,dest); 
    local diff = EAX-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    EAX = dest;
    build check_EAX_dest;
    goto inst_next;
<equal>
    Rmr32 = Reg32;
    build check_Rmr32_dest;
}
@ifdef IA64
:CMPXCHG Rmr64,Reg64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb1; mod=3 & Rmr64 & Reg64  
{ 
    local dest = Rmr64;
    subflags(RAX,dest); 
    local diff = RAX-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    RAX = dest;
    goto inst_next;
<equal>
    Rmr64 = Reg64;
} 
@endif

# CMPXCHG8B See 'lockable.sinc' for memory destination, lockable variants

# This "bad_CMPXCHG8B" instruction encoding was not meant to be part of the x86 language.
# It was allowed by a toolchain (at Intel) and was encoded into at least one library.
# GCC does not recognize it.  It does not make any semantic sense.
define pcodeop bad_CMPXCHG8B;
:bad_CMPXCHG8B  r32        is vexMode=0 & byte=0xf; byte=0xc7; ( mod = 0b11 & reg_opcode=0b001 ) & r32 {
  r32 = bad_CMPXCHG8B(r32);
}

# CMPXCHG16B See 'lockable.sinc' for memory destination, lockable variants

define pcodeop cpuid;
define pcodeop cpuid_basic_info;
define pcodeop cpuid_Version_info;
define pcodeop cpuid_cache_tlb_info;
define pcodeop cpuid_serial_info;
define pcodeop cpuid_Deterministic_Cache_Parameters_info;
define pcodeop cpuid_MONITOR_MWAIT_Features_info;
define pcodeop cpuid_Thermal_Power_Management_info;
define pcodeop cpuid_Extended_Feature_Enumeration_info;
define pcodeop cpuid_Direct_Cache_Access_info;
define pcodeop cpuid_Architectural_Performance_Monitoring_info;
define pcodeop cpuid_Extended_Topology_info;
define pcodeop cpuid_Processor_Extended_States_info;
define pcodeop cpuid_Quality_of_Service_info;
define pcodeop cpuid_brand_part1_info;
define pcodeop cpuid_brand_part2_info;
define pcodeop cpuid_brand_part3_info;

# CPUID is very difficult to implement correctly
#   The side-effects of the call will show up, but not the correct values

:CPUID          is vexMode=0 & byte=0xf; byte=0xa2                  {
    local tmp:16;
    if (EAX == 0) goto <basic_info>;
    if (EAX == 1) goto <Version_info>;
    if (EAX == 2) goto <cache_tlb_info>;
    if (EAX == 3) goto <serial_info>;
    if (EAX == 0x4) goto <Deterministic_Cache_Parameters_info>;
    if (EAX == 0x5) goto <MONITOR_MWAIT_Features_info>;
    if (EAX == 0x6) goto <Thermal_Power_Management_info>;
    if (EAX == 0x7) goto <Extended_Feature_Enumeration_info>;
    if (EAX == 0x9) goto <Direct_Cache_Access_info>;
    if (EAX == 0xa) goto <Architectural_Performance_Monitoring_info>;
    if (EAX == 0xb) goto <Extended_Topology_info>;
    if (EAX == 0xd) goto <Processor_Extended_States_info>;
    if (EAX == 0xf) goto <Quality_of_Service_info>;
    if (EAX == 0x80000002) goto <brand_part1_info>;
    if (EAX == 0x80000003) goto <brand_part2_info>;
    if (EAX == 0x80000004) goto <brand_part3_info>;
    tmp = cpuid(EAX, ECX);
    goto <finish>;
 <basic_info>
    tmp = cpuid_basic_info(EAX, ECX);
    goto <finish>;
 <Version_info>
    tmp = cpuid_Version_info(EAX, ECX);
    goto <finish>;
 <cache_tlb_info>
    tmp = cpuid_cache_tlb_info(EAX, ECX);
    goto <finish>;
 <serial_info>
    tmp = cpuid_serial_info(EAX, ECX);
    goto <finish>;
 <Deterministic_Cache_Parameters_info>
    tmp = cpuid_Deterministic_Cache_Parameters_info(EAX, ECX);
    goto <finish>;    
 <MONITOR_MWAIT_Features_info>
    tmp = cpuid_MONITOR_MWAIT_Features_info(EAX, ECX);
    goto <finish>;    
 <Thermal_Power_Management_info>
    tmp = cpuid_Thermal_Power_Management_info(EAX, ECX);
    goto <finish>;
 <Extended_Feature_Enumeration_info>
    tmp = cpuid_Extended_Feature_Enumeration_info(EAX, ECX);
    goto <finish>;
 <Direct_Cache_Access_info>
    tmp = cpuid_Direct_Cache_Access_info(EAX, ECX);
    goto <finish>;
 <Architectural_Performance_Monitoring_info>
    tmp = cpuid_Architectural_Performance_Monitoring_info(EAX, ECX);
    goto <finish>;
 <Extended_Topology_info>
    tmp = cpuid_Extended_Topology_info(EAX, ECX);
    goto <finish>;
 <Processor_Extended_States_info>
    tmp = cpuid_Processor_Extended_States_info(EAX, ECX);
    goto <finish>;
 <Quality_of_Service_info>
    tmp = cpuid_Quality_of_Service_info(EAX, ECX);
    goto <finish>;
 <brand_part1_info>
    tmp = cpuid_brand_part1_info(EAX, ECX);
    goto <finish>;
 <brand_part2_info>
    tmp = cpuid_brand_part2_info(EAX, ECX);
    goto <finish>;
 <brand_part3_info>
    tmp = cpuid_brand_part3_info(EAX, ECX);
    goto <finish>;  
 <finish>
@ifdef IA64
	RAX = zext(tmp[0,32]);
	RBX = zext(tmp[32,32]);
	RDX = zext(tmp[64,32]);
	RCX = zext(tmp[96,32]);
@else
	EAX = tmp[0,32];
	EBX = tmp[32,32];
	EDX = tmp[64,32];
	ECX = tmp[96,32];
@endif
}


:DAA            is $(LONGMODE_OFF) & vexMode=0 & byte=0x27       { local car = ((AL & 0xf) > 9) | AF;
                           AL = AL + 6 * car;
                           CF = CF | car * carry(AL,6);
                           AF = car;
                           car = ((AL & 0xf0) > 0x90) | CF;
                           AL = AL + 0x60 * car;
                           CF = car; }
:DAS            is $(LONGMODE_OFF) & vexMode=0 & byte=0x2f       { local car = ((AL & 0xf) > 9) | AF;
                           AL = AL - 6 * car;
                           CF = CF | car * (AL < 6);
                           AF = car;
                           car = (AL > 0x9f) | CF;
                           AL = AL - 0x60 * car;
                           CF = car; }

# See 'lockable.sinc' for memory destination, lockable variants
:DEC Rmr8       is vexMode=0 & byte=0xfe; mod=3 & Rmr8 & reg_opcode=1         { OF = sborrow(Rmr8,1);   Rmr8 =  Rmr8 - 1; resultflags( Rmr8); }
:DEC Rmr16      is vexMode=0 & opsize=0 & byte=0xff; mod=3 & Rmr16 & reg_opcode=1 { OF = sborrow(Rmr16,1); Rmr16 = Rmr16 - 1; resultflags(Rmr16); }
:DEC Rmr32      is vexMode=0 & opsize=1 & byte=0xff; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=1 { OF = sborrow(Rmr32,1); Rmr32 = Rmr32 - 1; build check_rm32_dest; resultflags(Rmr32); }
@ifdef IA64
:DEC Rmr64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xff; mod=3 & Rmr64 & reg_opcode=1 { OF = sborrow(Rmr64,1); Rmr64 = Rmr64 - 1; resultflags(Rmr64); }
@endif

:DEC Rmr16     is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & row=4 & page=1 & Rmr16  { OF = sborrow(Rmr16,1);   Rmr16 =  Rmr16 - 1; resultflags( Rmr16); }
:DEC Rmr32     is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & row=4 & page=1 & Rmr32 & check_Rmr32_dest  { OF = sborrow(Rmr32,1);   Rmr32 =  Rmr32 - 1; build check_Rmr32_dest; resultflags( Rmr32); }

:DIV rm8        is vexMode=0 & byte=0xf6; rm8 & reg_opcode=6 ...            { rm8ext:2 = zext(rm8);
                                                  local quotient = AX / rm8ext;  # DE exception if quotient doesn't fit in AL
                                                  local rem      = AX % rm8ext;
                                                  AL = quotient:1;
                                                  AH = rem:1; }
:DIV rm16       is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=6 ...    { rm16ext:4 = zext(rm16);
                                                  tmp:4 = (zext(DX) << 16) | zext(AX);   # DE exception if quotient doesn't fit in AX
                                                  local quotient = tmp / rm16ext;
                                                  AX = quotient:2;
                                                  local rem = tmp % rm16ext;
                                                  DX = rem:2; }
:DIV rm32       is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EDX_dest ... & check_EAX_dest ... & reg_opcode=6 ...    { rm32ext:8 = zext(rm32);
                                                  tmp:8 = (zext(EDX) << 32) | zext(EAX); # DE exception if quotient doesn't fit in EAX
                                                  local quotient = tmp / rm32ext;
                                                  EAX = quotient:4;
                                                  build check_EAX_dest;
                                                  local rem = tmp % rm32ext;
                                                  EDX = rem:4;
                                                  build check_EDX_dest; }
@ifdef IA64
:DIV rm64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf7; rm64 & reg_opcode=6 ...    { rm64ext:16 = zext(rm64);
                                                  tmp:16 = (zext(RDX) << 64) | zext(RAX); # DE exception if quotient doesn't fit in RAX
                                                  local quotient = tmp / rm64ext;
                                                  RAX = quotient:8;
                                                  local rem = tmp % rm64ext;
                                                  RDX = rem:8; }                                                  
@endif

enterFrames: low5 is low5 { tmp:1 = low5; export tmp; }

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push44(EBP);
        EBP = ESP;
        ESP = ESP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push44(EBP);
        frameTemp:4 = ESP;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xc8; imm16; enterFrames {
        push44(EBP);
        frameTemp:4 = ESP;
@ifdef IA64
        ESPt:$(SIZE) = zext(ESP);
        EBPt:$(SIZE) = zext(EBP);
@else
        ESPt:$(SIZE) = ESP;
        EBPt:$(SIZE) = EBP;
@endif

        ii:1 = enterFrames - 1;
<loop>
        EBPt = EBPt - 4;
        ESPt = ESPt - 4;
        *:4 ESPt = *:4 EBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:4 = 4 * zext(enterFrames - 1);
        ESP = ESP - tmp_offset;
        EBP = EBP - tmp_offset;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push44(EBP);
        frameTemp:4 = ESP;
@ifdef IA64
        ESPt:$(SIZE) = zext(ESP);
        EBPt:$(SIZE) = zext(EBP);
@else
        ESPt:$(SIZE) = ESP;
        EBPt:$(SIZE) = EBP;
@endif

        ii:1 = enterFrames - 1;
<loop>
        EBPt = EBPt - 2;
        ESPt = ESPt - 2;
        *:2 ESPt = *:2 EBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:4 = 2 * zext(enterFrames - 1);
        ESP = ESP - tmp_offset;
        EBP = EBP - tmp_offset;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push22(BP);
        BP = SP;
        SP = SP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push22(BP);
        frameTemp:2 = SP;

        push22(frameTemp);
        BP = frameTemp;
        SP = SP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & seg16 & addrsize=0 & opsize=1 & byte=0xc8; imm16; enterFrames {
        push24(zext(BP));
        frameTemp:2 = SP;

        SPt:2 = SP;
        BPt:2 = BP;
        ii:1 = enterFrames - 1;
<loop>

        BPt = BPt - 4;
        tmp2:$(SIZE) = segment(seg16,BPt);
        SPt = SPt - 4;
        tmp:$(SIZE) = segment(SS,SPt);
        *:4 tmp = *:4 tmp2;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:2 = 4 * zext(enterFrames - 1);
        SP = SP - tmp_offset;
        BP = BP - tmp_offset;

        push24(zext(frameTemp));
        BP = frameTemp;
        SP = SP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_OFF) & vexMode=0 & seg16 & addrsize=0 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push22(BP);
        frameTemp:2 = SP;

        SPt:2 = SP;
        BPt:2 = BP;
        ii:1 = enterFrames - 1;
<loop>
        BPt = BPt - 2;
        tmp2:$(SIZE) = segment(seg16,BPt);
        SPt = SPt - 2;
        tmp:$(SIZE) = segment(SS,SPt);
        *:2 tmp = *:2 tmp2;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:2 = 2 * zext(enterFrames - 1);
        SP = SP - tmp_offset;
        BP = BP - tmp_offset;

        push22(frameTemp);
        BP = frameTemp;
        SP = SP - imm16;
}

@ifdef IA64
:ENTER imm16,enterFrames is $(LONGMODE_ON) & vexMode=0 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push88(RBP);
        RBP = RSP;
        RSP = RSP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_ON) & vexMode=0 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push88(RBP);
        frameTemp:8 = RSP;

        push88(frameTemp);
        RBP = frameTemp;
        RSP = RSP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_ON) & vexMode=0 & byte=0xc8; imm16; enterFrames {
        push88(RBP);
        frameTemp:8 = RSP;

        RSPt:$(SIZE) = RSP;
        RBPt:$(SIZE) = RBP;
        ii:1 = enterFrames - 1;
<loop>
        RBPt = RBPt - 8;
        RSPt = RSPt - 8;
        *:8 RSPt = *:8 RBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:8 = 8 * zext(enterFrames - 1);
        RSP = RSP - tmp_offset;
        RBP = RBP - tmp_offset;

        push88(frameTemp);
        RBP = frameTemp;
        RSP = RSP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push82(BP);
        RBP = RSP;
        RSP = RSP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push82(BP);
        frameTemp:2 = SP;

        push82(frameTemp);
        BP = frameTemp;
        RSP = RSP - imm16;
}

:ENTER imm16,enterFrames is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push82(BP);
        frameTemp:2 = SP;

        RSPt:$(SIZE) = RSP;
        RBPt:$(SIZE) = RBP;
        ii:1 = enterFrames - 1;
<loop>
        RBPt = RBPt - 2;
        RSPt = RSPt - 2;
        *:2 RSPt = *:2 RBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:8 = 2 * zext(enterFrames - 1);
        RSP = RSP - tmp_offset;
        RBP = RBP - tmp_offset;

        push82(frameTemp);
        BP = frameTemp;
        RSP = RSP - imm16;
}
@endif



# Informs the 80287 coprocessor of the switch to protected mode, treated as NOP for 80387 and later.
# We used to have a pseudo-op, but as this is a legacy instruction which is now explicitly treated
# as a NOP.  We treat it as a NOP as well.
:FSETPM 	is vexMode=0 & byte=0xdb; byte=0xe4	{ } # 80287 set protected mode

:HLT            is vexMode=0 & byte=0xf4                        { goto inst_start; }

:IDIV rm8       is vexMode=0 & byte=0xf6;  rm8 & reg_opcode=7 ...           { rm8ext:2 = sext(rm8);
                                                  local quotient = AX s/ rm8ext;  # DE exception if quotient doesn't fit in AL
                                                  local rem = AX s% rm8ext;
                                                  AL = quotient:1;
                                                  AH = rem:1; }
:IDIV rm16      is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=7 ...    { rm16ext:4 = sext(rm16);
                                                  tmp:4 = (zext(DX) << 16) | zext(AX);   # DE exception if quotient doesn't fit in AX
                                                  local quotient = tmp s/ rm16ext;
                                                  AX = quotient:2;
                                                  local rem = tmp s% rm16ext;
                                                  DX = rem:2; }
:IDIV rm32      is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EAX_dest ... & check_EDX_dest ... & reg_opcode=7 ...    { rm32ext:8 = sext(rm32);
                                                  tmp:8 = (zext(EDX) << 32) | zext(EAX); # DE exception if quotient doesn't fit in EAX
                                                  local quotient = tmp s/ rm32ext;
                                                  EAX = quotient:4;
                                                  build check_EAX_dest;
                                                  local rem = tmp s% rm32ext;
                                                  EDX = rem:4; 
                                                  build check_EDX_dest; }
@ifdef IA64
:IDIV rm64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf7; rm64 & reg_opcode=7 ...    { rm64ext:16 = sext(rm64);
                                                  tmp:16 = (zext(RDX) << 64) | zext(RAX); # DE exception if quotient doesn't fit in RAX
                                                  local quotient = tmp s/ rm64ext;
                                                  RAX = quotient:8;
                                                  local rem = tmp s% rm64ext;
                                                  RDX = rem:8; }
@endif

:IMUL             rm8   is vexMode=0 & byte=0xf6; rm8 & reg_opcode=5 ...            { AX = sext(AL) * sext(rm8); imultflags(AL,AX); }    
:IMUL            rm16   is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=5 ...    { tmp:4 = sext(AX) * sext(rm16);
                                          DX = tmp(2); AX = tmp(0); imultflags(AX,tmp); }
:IMUL            rm32   is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EAX_dest ... & check_EDX_dest ... & reg_opcode=5 ...    { tmp:8 = sext(EAX) * sext(rm32);
                                          EDX = tmp(4); build check_EDX_dest; EAX = tmp(0); build check_EAX_dest; imultflags(EAX,tmp); }
@ifdef IA64
# We do a second multiply so emulator(s) that only have precision up to 64 bits will still get lower 64 bits correct
:IMUL            rm64   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf7; rm64 & reg_opcode=5 ...    { tmp:16 = sext(RAX) * sext(rm64);
                                           RAX = RAX * rm64; RDX = tmp(8); imultflags(RAX,tmp); }
@endif
:IMUL      Reg16,rm16   is vexMode=0 & opsize=0 & byte=0xf; byte=0xaf; rm16 & Reg16 ... { tmp:4 = sext(Reg16) * sext(rm16);
                                          Reg16 = tmp(0); high:2 = tmp(2); imultflags(Reg16,tmp);}
:IMUL      Reg32,rm32   is vexMode=0 & opsize=1 & byte=0xf; byte=0xaf; rm32 & Reg32 ... & check_Reg32_dest ... { tmp:8 = sext(Reg32) * sext(rm32);
                                          Reg32 = tmp(0); high:4 = tmp(4); imultflags(Reg32,tmp); build check_Reg32_dest; }
@ifdef IA64
# We do a second multiply so emulator(s) that only have precision up to 64 bits will still get lower 64 bits correct
:IMUL      Reg64,rm64   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xaf; rm64 & Reg64 ... { tmp:16 = sext(Reg64) * sext(rm64);
                                          Reg64 = Reg64 * rm64; high:8 = tmp(8); imultflags(Reg64,tmp);}
@endif
:IMUL Reg16,rm16,simm8_16  is vexMode=0 & opsize=0 & byte=0x6b; (rm16 & Reg16 ...) ; simm8_16 { tmp:4 = sext(rm16) * sext(simm8_16);
                                          Reg16 = tmp(0); high:2 = tmp(2); imultflags(Reg16,tmp);}
:IMUL Reg32,rm32,simm8_32  is vexMode=0 & opsize=1 & byte=0x6b; (rm32 & Reg32 ... & check_Reg32_dest ... ) ; simm8_32 { tmp:8 = sext(rm32) * sext(simm8_32);
                                          Reg32 = tmp(0); high:4 = tmp(4); imultflags(Reg32,tmp); build check_Reg32_dest; }
@ifdef IA64
# We do a second multiply so emulator(s) that only have precision up to 64 bits will still get lower 64 bits correct
:IMUL Reg64,rm64,simm8_64  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x6b; (rm64 & Reg64 ...) ; simm8_64 { tmp:16 = sext(rm64) * sext(simm8_64);
                                          Reg64 = rm64 * simm8_64; high:8 = tmp(8); imultflags(Reg64,tmp);}
@endif
:IMUL Reg16,rm16,simm16_16 is vexMode=0 & opsize=0 & byte=0x69; (rm16 & Reg16 ...) ; simm16_16    { tmp:4 = sext(rm16) * sext(simm16_16);
                                          Reg16 = tmp(0); high:2 = tmp(2); imultflags(Reg16,tmp);}
:IMUL Reg32,rm32,simm32_32 is vexMode=0 & opsize=1 & byte=0x69; (rm32 & Reg32 ... & check_Reg32_dest ...) ; simm32_32    { tmp:8 = sext(rm32) * sext(simm32_32);
                                          Reg32 = tmp(0); high:4 = tmp(4); imultflags(Reg32,tmp); build check_Reg32_dest; }
@ifdef IA64
:IMUL Reg64,rm64,simm32_32 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x69; (rm64 & Reg64 ...) ; simm32_32    { tmp:16 = sext(rm64) * sext(simm32_32);
                                          Reg64 = rm64 * sext(simm32_32); high:8 = tmp(8); imultflags(Reg64,tmp);}
@endif

# these appear in intelman2.pdf, but do they really exist?
#:IMUL Reg16,simm8_16  is vexMode=0 & opsize=0 & byte=0x6b; Reg16; simm8_16
#:IMUL Reg32,simm8_32  is vexMode=0 & opsize=1 & byte=0x6b; Reg32; simm8_32
#:IMUL Reg16,simm16 is vexMode=0 & opsize=0 & byte=0x69; Reg16; simm16
#:IMUL Reg32,simm32 is vexMode=0 & opsize=1 & byte=0x69; Reg32; simm32

:IN    AL, imm8     is vexMode=0 & AL & (byte=0xe4; imm8)               { tmp:1 = imm8; AL = in(tmp); }
:IN    AX, imm8     is vexMode=0 & opsize=0 & AX & (byte=0xe5; imm8)    { tmp:1 = imm8; AX = in(tmp); }
:IN    EAX, imm8    is vexMode=0 & opsize=1 & EAX & check_EAX_dest & (byte=0xe5; imm8)   { tmp:1 = imm8; EAX = in(tmp); build check_EAX_dest; }
@ifdef IA64
:IN    RAX, imm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & RAX & (byte=0xe5; imm8)   { tmp:1 = imm8; RAX = in(tmp); }
@endif
:IN    AL, DX       is vexMode=0 & AL & DX & (byte=0xec)                { AL  = in(DX); }
:IN    AX, DX       is vexMode=0 & opsize=0 & AX & DX & (byte=0xed)     { AX  = in(DX); }
:IN    EAX, DX      is vexMode=0 & opsize=1 & EAX & check_EAX_dest & DX & (byte=0xed)    { EAX = in(DX); build check_EAX_dest; }
@ifdef IA64
:IN    RAX, DX      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & RAX & DX & (byte=0xed)    { RAX = in(DX); }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:INC  Rmr8	is vexMode=0 & byte=0xfe;  mod=3 & Rmr8 & reg_opcode=0			{ OF = scarry(Rmr8,1);   Rmr8 =  Rmr8 + 1; resultflags( Rmr8); }
:INC Rmr16	is vexMode=0 & opsize=0 & byte=0xff; mod=3 & Rmr16 & reg_opcode=0	{ OF = scarry(Rmr16,1); Rmr16 = Rmr16 + 1; resultflags(Rmr16); }
:INC Rmr32	is vexMode=0 & opsize=1 & byte=0xff; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=0	{ OF = scarry(Rmr32,1); Rmr32 = Rmr32 + 1; build check_Rmr32_dest; resultflags(Rmr32); }
@ifdef IA64
:INC      Rmr64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xff; mod=3 & Rmr64 & reg_opcode=0	{ OF = scarry(Rmr64,1); Rmr64 = Rmr64 + 1; resultflags(Rmr64); }
@endif

:INC          Rmr16	is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & row = 4 & page = 0 & Rmr16 { OF = scarry(Rmr16,1);   Rmr16 =  Rmr16 + 1; resultflags( Rmr16); }
:INC          Rmr32	is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & row = 4 & page = 0 & Rmr32 { OF = scarry(Rmr32,1);   Rmr32 =  Rmr32 + 1; resultflags( Rmr32); }

:INSB^rep^reptail eseDI1,DX is vexMode=0 & rep & reptail & byte=0x6c & eseDI1 & DX      { build rep; build eseDI1; eseDI1 = in(DX); build reptail; }
:INSW^rep^reptail eseDI2,DX is vexMode=0 & rep & reptail & opsize=0 & byte=0x6d & eseDI2 & DX   { build rep; build eseDI2; eseDI2 = in(DX); build reptail; }
:INSD^rep^reptail eseDI4,DX is vexMode=0 & rep & reptail & opsize=1 & byte=0x6d & eseDI4 & DX   { build rep; build eseDI4; eseDI4 = in(DX); build reptail; }
:INSD^rep^reptail eseDI4,DX is vexMode=0 & rep & reptail & opsize=2 & byte=0x6d & eseDI4 & DX   { build rep; build eseDI4; eseDI4 = in(DX); build reptail; }

:INT1           is vexMode=0 & byte=0xf1                            { tmp:1 = 0x1; intloc:$(SIZE) = swi(tmp); call [intloc]; return [0:1]; }
:INT3           is vexMode=0 & byte=0xcc                            { tmp:1 = 0x3; intloc:$(SIZE) = swi(tmp); call [intloc]; return [0:1]; }
:INT imm8       is vexMode=0 & byte=0xcd; imm8                      { tmp:1 = imm8; intloc:$(SIZE) = swi(tmp); call [intloc]; }
:INTO           is $(LONGMODE_OFF) & vexMode=0 & byte=0xce
{
  tmp:1 = 0x4;
  intloc:$(SIZE) = swi(tmp);

  if (OF != 1) goto <no_overflow>;
    call [intloc];
  <no_overflow>
}

:INVD           is vexMode=0 & byte=0xf; byte=0x8                   {}
:INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }

:INVLPGA        is vexMode=0 & addrsize=0 & byte=0xf; byte=0x1; byte=0xDF                   { invlpga(AX,ECX); }
:INVLPGA        is vexMode=0 & addrsize=1 & byte=0xf; byte=0x1; byte=0xDF                   { invlpga(EAX,ECX); }
@ifdef IA64
:INVLPGA        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xf; byte=0x1; byte=0xDF                   { invlpga(RAX,ECX); }
@endif

:INVPCID r32, m128     is vexMode=0 & addrsize=1 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x82; r32 ... & m128    { invpcid(r32, m128); }
@ifdef IA64
:INVPCID r64, m128     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x82; r64 ... & m128    { invpcid(r64, m128); }
@endif

:IRET           is vexMode=0 & addrsize=0 & opsize=0 & byte=0xcf            { pop22(IP); EIP=zext(IP); pop22(CS); pop22(flags); return [EIP]; }    
:IRET           is vexMode=0 & addrsize=1 & opsize=0 & byte=0xcf            { pop42(IP); EIP=zext(IP); pop42(CS); pop42(flags); return [EIP]; }    
@ifdef IA64
:IRET           is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xcf            { pop82(IP); RIP=zext(IP); pop82(CS); pop82(flags); return [RIP]; }    
@endif
:IRETD          is vexMode=0 & addrsize=0 & opsize=1 & byte=0xcf            { pop24(EIP); tmp:4=0; pop24(tmp); CS=tmp(0); pop24(tmp); flags=tmp(0); return [EIP]; }
:IRETD          is vexMode=0 & addrsize=1 & opsize=1 & byte=0xcf            { pop44(EIP); tmp:4=0; pop44(tmp); CS=tmp(0); pop44(eflags); return [EIP]; }
@ifdef IA64
:IRETD          is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=1 & byte=0xcf            { pop84(EIP); RIP=zext(EIP); tmp:4=0; pop84(tmp); CS=tmp(0); pop84(eflags); return [RIP]; }
:IRETQ          is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=2 & byte=0xcf            { pop88(RIP); tmp:8=0; pop88(tmp); CS=tmp(0); pop88(rflags); pop88(RSP); return [RIP]; }
@endif

:J^cc rel8      is vexMode=0 & row=7 & cc; rel8                                          { if (cc) goto rel8; }
:J^cc rel16     is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xf; row=8 & cc; rel16  { if (cc) goto rel16; }
:J^cc rel32     is vexMode=0 & opsize=1 & byte=0xf; row=8 & cc; rel32                    { if (cc) goto rel32; }
:J^cc rel32     is vexMode=0 & opsize=2 & byte=0xf; row=8 & cc; rel32                    { if (cc) goto rel32; }
# The following is vexMode=0 & picked up by the line above.  rel32 works for both 32 and 64 bit
#@ifdef IA64
#:J^cc rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xf; row=8 & cc; rel32     { if (cc) goto rel32; }
#@endif

:JCXZ rel8      is vexMode=0 & addrsize=0 & byte=0xe3; rel8                      { if (CX==0) goto rel8; }
:JECXZ rel8     is vexMode=0 & addrsize=1 & byte=0xe3; rel8                      { if (ECX==0) goto rel8; }
@ifdef IA64
:JRCXZ rel8     is $(LONGMODE_ON) & addrsize=2 & vexMode=0 & byte=0xe3; rel8     { if (RCX==0) goto rel8; }
@endif

:JMP rel8       is vexMode=0 & byte=0xeb; rel8                                  { goto rel8; }
:JMP rel16      is vexMode=0 & opsize=0 & byte=0xe9; rel16                      { goto rel16; }
:JMP rel32      is vexMode=0 & opsize=1 & byte=0xe9; rel32                      { goto rel32; }
:JMP rel32      is vexMode=0 & opsize=2 & byte=0xe9; rel32                      { goto rel32; }

:JMP rm16       is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=4 ...	{ target:4 = segment(currentCS,rm16); goto [target]; }
:JMP rm16       is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=4 ...	{ goto [rm16]; }
:JMP rm32       is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=4 ...    { goto [rm32]; }
@ifdef IA64
:JMP rm16       is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=4 ...	{ goto [rm16]; }
:JMP rm64       is $(LONGMODE_ON) & vexMode=0 & byte=0xff; rm64 & reg_opcode=4 ...   { goto [rm64]; }
@endif

:JMPF ptr1616   is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xea; ptr1616      { goto ptr1616; }
:JMPF ptr1632   is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xea; ptr1632      { goto ptr1632; }
:JMPF Mem       is vexMode=0 & opsize=0 & byte=0xff; Mem & reg_opcode=5 ...     { target:$(SIZE) = zext(*:2 Mem); goto [target]; }
:JMPF Mem       is vexMode=0 & opsize=1 & byte=0xff; Mem & reg_opcode=5 ...     {
@ifdef IA64
    target:$(SIZE) = zext(*:4 Mem);
@else
    target:$(SIZE) = *:4 Mem;
@endif
    goto [target];
}
@ifdef IA64
:JMPF Mem       is vexMode=0 & opsize=2 & byte=0xff; Mem & reg_opcode=5 ...     { target:$(SIZE) = *:8 Mem; goto [target]; }
@endif

# Initially disallowed in 64bit mode, but later reintroduced
:LAHF           is vexMode=0 & byte=0x9f { AH=(SF<<7)|(ZF<<6)|(AF<<4)|(PF<<2)|2|CF; }

:LAR Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0x2; rm16 & Reg16 ...  { Reg16 = rm16 & 0xff00; ZF=1; }
:LAR Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0x2; rm32 & Reg32 ... & check_Reg32_dest ... { Reg32 = rm32 & 0xffff00; build check_Reg32_dest; ZF=1; }
@ifdef IA64
:LAR Reg64,rm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0x2; rm32 & Reg64 ... { Reg64 = zext( rm32 & 0xffff00 ); ZF=1; }
@endif

:LDMXCSR m32		is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=2 ) ... & m32 { MXCSR = m32; }

# 16 & 32-bit only
:LDS Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC5; Mem & Reg16 ...        { tmp:4 = *Mem; DS = tmp(2); Reg16 = tmp(0); }
:LDS Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC5 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; DS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }

:LSS Reg16,Mem      is vexMode=0 & opsize=0 & byte=0x0F; byte=0xB2; Mem & Reg16 ... { tmp:4 = *Mem; SS = tmp(2); Reg16 = tmp(0); }
:LSS Reg32,Mem      is vexMode=0 & opsize=1 & byte=0x0F; byte=0xB2; Mem & Reg32 ... & check_Reg32_dest ... { tmp:6 = *Mem; SS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
@ifdef IA64
:LSS Reg64,Mem      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0F; byte=0xB2; Mem & Reg64 ... { tmp:10 = *Mem; SS = tmp(8); Reg64 = tmp(0); }
@endif

# 16 & 32-bit only
:LES Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC4; Mem & Reg16 ...        { tmp:4 = *Mem; ES = tmp(2); Reg16 = tmp(0); }
:LES Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC4 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; ES = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }

:LFS Reg16,Mem      is vexMode=0 & opsize=0 & byte=0x0F; byte=0xB4; Mem & Reg16 ... { tmp:4 = *Mem; FS = tmp(2); Reg16 = tmp(0); }
:LFS Reg32,Mem      is vexMode=0 & opsize=1 & byte=0x0F; byte=0xB4; Mem & Reg32 ... & check_Reg32_dest ... { tmp:6 = *Mem; FS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
@ifdef IA64
:LFS Reg64,Mem      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0F; byte=0xB4; Mem & Reg64 ... { tmp:10 = *Mem; FS = tmp(8); Reg64 = tmp(0); }
@endif
:LGS Reg16,Mem      is vexMode=0 & opsize=0 & byte=0x0F; byte=0xB5; Mem & Reg16 ... { tmp:4 = *Mem; GS = tmp(2); Reg16 = tmp(0); }
:LGS Reg32,Mem      is vexMode=0 & opsize=1 & byte=0x0F; byte=0xB5; Mem & Reg32 ... & check_Reg32_dest ... { tmp:6 = *Mem; GS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
@ifdef IA64
:LGS Reg64,Mem      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0F; byte=0xB5; Mem & Reg64 ... { tmp:10 = *Mem; GS = tmp(8); Reg64 = tmp(0); }
@endif

#in 64-bit mode address size of 16 is not encodable
:LEA Reg16,addr16  is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & addrsize=0 & byte=0x8D; addr16 & Reg16 ...  { Reg16 = addr16; }
:LEA Reg32,addr16  is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & addrsize=0 & byte=0x8D; addr16 & Reg32 ...  { Reg32 = zext(addr16); }

:LEA Reg16,addr32  is vexMode=0 & opsize=0 & addrsize=1 & byte=0x8D; addr32 & Reg16 ...  { Reg16 = addr32(0); }
:LEA Reg32,addr32  is vexMode=0 & opsize=1 & addrsize=1 & byte=0x8D; addr32 & Reg32 ...  & check_Reg32_dest ... {
    Reg32 = addr32;
	build check_Reg32_dest;
}

@ifdef IA64
:LEA Reg16,addr64   is $(LONGMODE_ON) & vexMode=0 & opsize=0 & addrsize=2 & byte=0x8D; addr64 & Reg16 ... { Reg16 = addr64(0); }
:LEA Reg32,addr64   is $(LONGMODE_ON) & vexMode=0 & opsize=1 & addrsize=2 & byte=0x8D; addr64 & Reg32 ... & check_Reg32_dest ... { 
   Reg32 = addr64(0);
   build check_Reg32_dest;
}
:LEA Reg64,addr32   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & addrsize=1 & byte=0x8D; addr32 & Reg64 ... { Reg64 = zext(addr32); }
:LEA Reg64,addr64   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & addrsize=2 & byte=0x8D; addr64 & Reg64 ... { Reg64 = addr64; }
@endif

:LEAVE          is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xc9         { SP = BP; pop22(BP); }
:LEAVE          is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xc9         { ESP = EBP; pop24(EBP); }
:LEAVE          is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xc9         { ESP = EBP; pop44(EBP); }
:LEAVE          is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xc9         { ESP = EBP; pop42(EBP); }
@ifdef IA64
:LEAVE          is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xc9         { RSP = RBP; pop82(BP); }
:LEAVE          is $(LONGMODE_ON) & vexMode=0 & byte=0xc9   { RSP = RBP; pop88(RBP); }
@endif

define pcodeop GlobalDescriptorTableRegister;
:LGDT m16       is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m16
{
	GlobalDescriptorTableRegister(m16);
}

:LGDT m32       is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m32
{
	GlobalDescriptorTableRegister(m32);
}
@ifdef IA64
:LGDT m64       is $(LONGMODE_ON) & vexMode=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m64
{
	GlobalDescriptorTableRegister(m64);
}
@endif

define pcodeop InterruptDescriptorTableRegister;
:LIDT m16       is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m16
{
	InterruptDescriptorTableRegister(m16);
}

:LIDT m32       is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m32
{
	InterruptDescriptorTableRegister(m32);
}
@ifdef IA64
:LIDT m64       is $(LONGMODE_ON) & vexMode=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m64
{
	InterruptDescriptorTableRegister(m64);
}
@endif

define pcodeop LocalDescriptorTableRegister;
:LLDT rm16      is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=2 ...
{
	LocalDescriptorTableRegister(rm16);
}

@ifdef IA64
:LMSW rm16      is vexMode=0 & byte=0xf; byte=0x01; rm16 & reg_opcode=6 ...
{
  CR0 = (CR0 & 0xFFFFFFFFFFFFFFF0) | zext(rm16 & 0x000F);
}
@else
:LMSW rm16      is vexMode=0 & byte=0xf; byte=0x01; rm16 & reg_opcode=6 ...
{
  CR0 = (CR0 & 0xFFFFFFF0) | zext(rm16 & 0x000F);
}
@endif

:LODSB^rep^reptail dseSI1   is vexMode=0 & rep & reptail & byte=0xAC & dseSI1           { build rep; build dseSI1; AL=dseSI1; build reptail; }
:LODSW^rep^reptail dseSI2   is vexMode=0 & rep & reptail & opsize=0 & byte=0xAD & dseSI2    { build rep; build dseSI2; AX=dseSI2; build reptail; }
:LODSD^rep^reptail dseSI4   is vexMode=0 & rep & reptail & opsize=1 & byte=0xAD & dseSI4    { build rep; build dseSI4; EAX=dseSI4; build reptail; }
@ifdef IA64
:LODSQ^rep^reptail dseSI8   is $(LONGMODE_ON) & vexMode=0 & rep & reptail & opsize=2 & byte=0xAD & dseSI8    { build rep; build dseSI8; RAX=dseSI8; build reptail; }
@endif

:LOOP   rel8        is vexMode=0 & addrsize=0 & byte=0xE2; rel8             { CX = CX -1; if (CX!=0) goto rel8; }
:LOOP   rel8        is vexMode=0 & addrsize=1 & byte=0xE2; rel8             { ECX = ECX -1; if (ECX!=0) goto rel8; }
@ifdef IA64
:LOOP   rel8        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xE2; rel8             { RCX = RCX -1; if (RCX!=0) goto rel8; }
@endif

:LOOPZ  rel8        is vexMode=0 & addrsize=0 & byte=0xE1; rel8             { CX = CX -1; if (CX!=0 && ZF!=0) goto rel8; }
:LOOPZ  rel8        is vexMode=0 & addrsize=1 & byte=0xE1; rel8             { ECX = ECX -1; if (ECX!=0 && ZF!=0) goto rel8; }
@ifdef IA64
:LOOPZ  rel8        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xE1; rel8             { RCX = RCX -1; if (RCX!=0 && ZF!=0) goto rel8; }
@endif

:LOOPNZ rel8        is vexMode=0 & addrsize=0 & byte=0xE0; rel8             { CX = CX -1; if (CX!=0 && ZF==0) goto rel8; }
:LOOPNZ rel8        is vexMode=0 & addrsize=1 & byte=0xE0; rel8             { ECX = ECX -1; if (ECX!=0 && ZF==0) goto rel8; }
@ifdef IA64
:LOOPNZ rel8        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xE0; rel8             { RCX = RCX -1; if (RCX!=0 && ZF==0) goto rel8; }
@endif

define pcodeop SegmentLimit;
:LSL Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0x3; rm16 & Reg16 ...
{
  tmp:3 = SegmentLimit(rm16);
  Reg16 = tmp:2;
  ZF = tmp[16,1];
}

:LSL Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0x3; rm32 & Reg32 ...
{
  tmp:3 = SegmentLimit(rm32);
  Reg32 = zext(tmp:2);
  ZF = tmp[16,1];
}

@ifdef IA64
:LSL Reg64,rm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0x3; rm32 & Reg64 ...
{
  tmp:3 = SegmentLimit(rm32);
  Reg64 = zext(tmp:2);
  ZF = tmp[16,1];
}
@endif

define pcodeop TaskRegister;
:LTR rm16       is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=3 ... { TaskRegister(rm16); }

:MOV Rmr8,Reg8       is vexMode=0 & byte=0x88; mod=3 & Rmr8 & Reg8                { Rmr8=Reg8; }

:MOV^xrelease m8,Reg8       is vexMode=0 & xrelease & byte=0x88; m8 & Reg8 ...                
{ 
    build xrelease;
    build m8;
    m8=Reg8;
 }

:MOV Rmr16,Reg16     is vexMode=0 & opsize=0 & byte=0x89; mod=3 & Rmr16 & Reg16       { Rmr16=Reg16; }

:MOV^xrelease m16,Reg16     is vexMode=0 & xrelease & opsize=0 & byte=0x89; m16 & Reg16 ...       
{ 
    build xrelease;
    build m16; 
    m16=Reg16;
 }

:MOV Rmr32,Reg32     is vexMode=0 & opsize=1 & byte=0x89; mod=3 & Rmr32 & check_Rmr32_dest & Reg32       { Rmr32=Reg32; build check_Rmr32_dest; }

:MOV^xrelease m32,Reg32     is vexMode=0 & xrelease & opsize=1 & byte=0x89; m32 & Reg32 ...       
{ 
    build xrelease; 
    build m32; 
    m32=Reg32;
}

@ifdef IA64
:MOV Rmr64,Reg64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x89; mod=3 & Rmr64 & Reg64       { Rmr64=Reg64; }

:MOV^xrelease m64,Reg64     is $(LONGMODE_ON) & vexMode=0 & xrelease & opsize=2 & byte=0x89; m64 & Reg64 ...       
{ 
    build xrelease;
    build m64; 
    m64=Reg64;
 }

@endif
:MOV Reg8,rm8       is vexMode=0 & byte=0x8a; rm8 & Reg8 ...                { Reg8 = rm8; }
:MOV Reg16,rm16     is vexMode=0 & opsize=0 & byte=0x8b; rm16 & Reg16 ...       { Reg16 = rm16; }
:MOV Reg32,rm32     is vexMode=0 & opsize=1 & byte=0x8b; rm32 & Reg32 ... & check_Reg32_dest ...      { Reg32 = rm32; build check_Reg32_dest; }
@ifdef IA64
:MOV Reg64,rm64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x8b; rm64 & Reg64 ...       { Reg64 = rm64; }
@endif
:MOV rm16,Sreg      is vexMode=0 & byte=0x8c; rm16 & check_rm16_dest ... & Sreg ...               { rm16 = Sreg; build check_rm16_dest; }
:MOV Sreg,rm16      is vexMode=0 & byte=0x8e; rm16 & Sreg ...               { Sreg=rm16; }
:MOV AL,moffs8      is vexMode=0 & byte=0xa0; AL & moffs8               { AL=moffs8; }
:MOV AX,moffs16     is vexMode=0 & opsize=0 & byte=0xa1; AX & moffs16         { AX=moffs16; }
:MOV EAX,moffs32    is vexMode=0 & opsize=1 & byte=0xa1; EAX & check_EAX_dest & moffs32            { EAX=moffs32; build check_EAX_dest; }
@ifdef IA64
:MOV RAX,moffs64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xa1; RAX & moffs64            { RAX=moffs64; }
@endif
:MOV moffs8,AL      is vexMode=0 & byte=0xa2; AL & moffs8               { moffs8=AL; }
:MOV moffs16,AX     is vexMode=0 & opsize=0 & byte=0xa3; AX & moffs16         { moffs16=AX; }
:MOV moffs32,EAX    is vexMode=0 & opsize=1 & byte=0xa3; EAX & moffs32            { moffs32=EAX; }
@ifdef IA64
:MOV moffs64,RAX    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xa3; RAX & moffs64            { moffs64=RAX; }
@endif
:MOV CRmr8,imm8     is vexMode=0 & row=11 & page=0 & CRmr8; imm8                        { CRmr8 = imm8; }
:MOV CRmr16,imm16   is vexMode=0 & opsize=0 & row=11 & page=1 & CRmr16; imm16       { CRmr16 = imm16; }
:MOV CRmr32,imm32   is vexMode=0 & opsize=1 & row=11 & page=1 & CRmr32; imm32       { CRmr32 = imm32; }
@ifdef IA64
:MOV Rmr64,imm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & row=11 & page=1 & Rmr64; imm64        { Rmr64 = imm64; }
@endif
:MOV Rmr8,imm8 is vexMode=0 & byte=0xc6; (mod=3 & Rmr8 & reg_opcode=0); imm8 { Rmr8 = imm8; }

:MOV^xrelease spec_m8,imm8       is vexMode=0 & xrelease & byte=0xc6; spec_m8 & reg_opcode=0 ...; imm8        
{ 
    build xrelease; 
    build spec_m8; 
    spec_m8 = imm8;
}
:MOV Rmr16,imm16 is vexMode=0 & opsize=0 & byte=0xc7; (mod=3 & Rmr16 & reg_opcode=0); imm16 { Rmr16 = imm16; }

:MOV^xrelease spec_m16,imm16     is vexMode=0 & xrelease & opsize=0 & byte=0xc7; spec_m16 & reg_opcode=0 ...; imm16 
{ 
    build xrelease; 
    build spec_m16; 
    spec_m16 = imm16;
}

:MOV Rmr32,imm32     is vexMode=0 & opsize=1 & byte=0xc7; (mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=0); imm32 { Rmr32 = imm32; build check_Rmr32_dest; }

:MOV^xrelease spec_m32,imm32     is vexMode=0 & xrelease & opsize=1 & byte=0xc7; (spec_m32 & reg_opcode=0 ...); imm32 
{ 
    build xrelease; 
    build spec_m32;
    spec_m32 = imm32;
}
@ifdef IA64
:MOV Rmr64,simm32     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xc7; (mod=3 & Rmr64 & reg_opcode=0); simm32 { Rmr64 = simm32; }

:MOV^xrelease spec_m64,simm32     is $(LONGMODE_ON) & vexMode=0 & xrelease & opsize=2 & byte=0xc7; (spec_m64 & reg_opcode=0 ...); simm32 
{ 
    build xrelease; 
    build spec_m64;
    spec_m64 = simm32; 
}
@endif

:MOV creg, Rmr32        is vexMode=0 &           byte=0xf; byte=0x22; Rmr32 & creg      {
@ifdef IA64
    creg=zext(Rmr32);
@else
    creg=Rmr32;
@endif
}
@ifdef IA64
:MOV creg, Rmr64        is $(LONGMODE_ON) & vexMode=0 & byte=0xf; byte=0x22; Rmr64 & creg      { creg=Rmr64; }
:MOV creg_x, Rmr64      is $(LONGMODE_ON) & vexMode=0 & rexRprefix=1 & byte=0xf; byte=0x22; Rmr64 & creg_x     { creg_x=Rmr64; }
@endif

:MOV Rmr32, creg        is $(LONGMODE_OFF) & vexMode=0 & byte=0xf; byte=0x20; Rmr32 & creg      {
@ifdef IA64
    Rmr32 = creg:4;
@else
    Rmr32 = creg;
@endif
}
@ifdef IA64
:MOV Rmr64, creg        is $(LONGMODE_ON) & vexMode=0 & byte=0xf; byte=0x20; Rmr64 & creg      { Rmr64 = creg; }
:MOV Rmr64, creg_x      is $(LONGMODE_ON) & vexMode=0 & rexRprefix=1 & byte=0xf; byte=0x20; Rmr64 & creg_x     { Rmr64 = creg_x; }
@endif

:MOV Rmr32, debugreg    is $(LONGMODE_OFF) & vexMode=0 & byte=0xf; byte=0x21; Rmr32 & debugreg      {
@ifdef IA64
    Rmr32 = debugreg:4;
@else
    Rmr32 = debugreg;
@endif
}
@ifdef IA64
:MOV Rmr64, debugreg    is $(LONGMODE_ON) & vexMode=0 & bit64=1 & byte=0xf; byte=0x21; Rmr64 & debugreg      { Rmr64 = debugreg; }
:MOV Rmr64, debugreg_x  is $(LONGMODE_ON) & vexMode=0 & bit64=1 & rexRprefix=1 & byte=0xf; byte=0x21; Rmr64 & debugreg_x     { Rmr64 = debugreg_x; }
@endif

:MOV debugreg, Rmr32    is $(LONGMODE_OFF) & vexMode=0 & byte=0xf; byte=0x23; Rmr32 & debugreg      {
@ifdef IA64
    debugreg = zext(Rmr32);
@else
    debugreg = Rmr32;
@endif
}
@ifdef IA64
:MOV debugreg, Rmr64    is $(LONGMODE_ON) & vexMode=0 & bit64=1 & byte=0xf; byte=0x23; Rmr64 & debugreg & mod=3      { debugreg = Rmr64; }
:MOV debugreg_x, Rmr64  is $(LONGMODE_ON) & vexMode=0 & bit64=1 & rexRprefix=1 & byte=0xf; byte=0x23; Rmr64 & debugreg_x & mod=3     { debugreg_x = Rmr64; }
@endif

@ifndef IA64
# These are obsolete instructions after the 486 generation.
# They were erroneously placed in the IA64 build.
# They were removed to facilitate instruction patching to generate "MOV EAX, 0x2" correctly.
#:MOV r32, testreg	is vexMode=0 & byte=0xf; byte=0x24; r32 &  testreg & mod=3  { r32 =  testreg; }
#:MOV testreg, r32	is vexMode=0 & byte=0xf; byte=0x26; r32 &  testreg & mod=3  {  testreg = r32; }
@endif

define pcodeop swap_bytes;
:MOVBE Reg16, m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x38; byte=0xf0; Reg16 ... & m16  { Reg16 = swap_bytes( m16 ); }
:MOVBE Reg32, m32       is vexMode=0 & opsize=1 & mandover=0 & byte=0xf; byte=0x38; byte=0xf0; Reg32 ... & m32  { Reg32 = swap_bytes( m32 ); }
:MOVBE m16, Reg16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x38; byte=0xf1; Reg16 ... & m16  { m16 = swap_bytes( Reg16 ); }
:MOVBE m32, Reg32       is vexMode=0 & opsize=1 & mandover=0 & byte=0xf; byte=0x38; byte=0xf1; Reg32 ... & m32  { m32 = swap_bytes( Reg32 ); }
@ifdef IA64
:MOVBE Reg64, m64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & mandover=0 & byte=0xf; byte=0x38; byte=0xf0; Reg64 ... & m64  { Reg64 = swap_bytes( m64 ); }
:MOVBE m64, Reg64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & mandover=0 & byte=0xf; byte=0x38; byte=0xf1; Reg64 ... & m64  { m64 = swap_bytes( Reg64 ); }
@endif


:MOVNTI Mem,Reg32       is vexMode=0 & opsize = 1; byte=0xf; byte=0xc3; Mem & Reg32 ...     { *Mem = Reg32; }
@ifdef IA64
:MOVNTI Mem,Reg64       is $(LONGMODE_ON) & vexMode=0 & opsize = 2; byte=0xf; byte=0xc3; Mem & Reg64 ...     { *Mem = Reg64; }
@endif

:MOVSB^rep^reptail eseDI1,dseSI1    is vexMode=0 & rep & reptail & byte=0xa4 & eseDI1 & dseSI1          { build rep; build eseDI1; build dseSI1; eseDI1 = dseSI1; build reptail; }
:MOVSW^rep^reptail eseDI2,dseSI2    is vexMode=0 & rep & reptail & opsize=0 & byte=0xa5 & eseDI2 & dseSI2   { build rep; build eseDI2; build dseSI2; eseDI2 = dseSI2; build reptail; }
:MOVSD^rep^reptail eseDI4,dseSI4    is vexMode=0 & rep & reptail & opsize=1 & byte=0xa5 & eseDI4 & dseSI4   { build rep; build eseDI4; build dseSI4; eseDI4 = dseSI4; build reptail; }
@ifdef IA64
:MOVSQ^rep^reptail eseDI8,dseSI8    is $(LONGMODE_ON) & vexMode=0 & rep & reptail & opsize=2 & byte=0xa5 & eseDI8 & dseSI8   { build rep; build eseDI8; build dseSI8; eseDI8 = dseSI8; build reptail; }
@endif

:MOVSX Reg16,spec_rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xbe; spec_rm8 & Reg16 ...  { Reg16 = sext(spec_rm8); }
:MOVSX Reg32,spec_rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xbe; spec_rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = sext(spec_rm8); build check_Reg32_dest; }
@ifdef IA64
:MOVSX Reg64,spec_rm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbe; spec_rm8 & Reg64 ...  { Reg64 = sext(spec_rm8); }
@endif
:MOVSX Reg32,spec_rm16   is vexMode=0 &            byte=0xf; byte=0xbf; spec_rm16 & Reg32 ... & check_Reg32_dest ...    { Reg32 = sext(spec_rm16); build check_Reg32_dest; }
@ifdef IA64
:MOVSX Reg64,spec_rm16   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xbf; spec_rm16 & Reg64 ...     { Reg64 = sext(spec_rm16); }
@endif

# Overlaps with ARPL in non-64bit modes
@ifdef IA64
:MOVSXD Reg32,rm32  is $(LONGMODE_ON) & vexMode=0 & opsize=1 & byte=0x63; rm32 & Reg32 ... & check_Reg32_dest ... { Reg32 = rm32; build check_Reg32_dest; }
:MOVSXD Reg64,rm32  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x63; rm32 & Reg64 ... { Reg64 = sext(rm32); }
@endif

:MOVZX Reg16,spec_rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xb6; spec_rm8 & Reg16 ...  { Reg16 = zext(spec_rm8); }
:MOVZX Reg32,spec_rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb6; spec_rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = zext(spec_rm8); build check_Reg32_dest; }
@ifdef IA64
:MOVZX Reg64,spec_rm8    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb6; spec_rm8 & Reg64 ...  { Reg64 = zext(spec_rm8); }
@endif

:MOVZX Reg32,spec_rm16   is vexMode=0 &            byte=0xf; byte=0xb7; spec_rm16 & Reg32 ... & check_Reg32_dest ...    { Reg32 = zext(spec_rm16); build check_Reg32_dest; }
@ifdef IA64
:MOVZX Reg64,spec_rm16   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb7; spec_rm16 & Reg64 ...     { Reg64 = zext(spec_rm16); }
@endif

:MUL rm8        is vexMode=0 & byte=0xf6; rm8 & reg_opcode=4 ...            { AX=zext(AL)*zext(rm8); multflags(AH); }
:MUL rm16       is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=4 ...    { tmp:4=zext(AX)*zext(rm16); DX=tmp(2); AX=tmp(0); multflags(DX); }
:MUL rm32       is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EAX_dest ... & check_EDX_dest ... & reg_opcode=4 ...    { tmp:8=zext(EAX)*zext(rm32); EDX=tmp(4); build check_EDX_dest; multflags(EDX);  EAX=tmp(0); build check_EAX_dest;  }
@ifdef IA64
:MUL rm64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf7; rm64 & reg_opcode=4 ...    { tmp:16=zext(RAX)*zext(rm64); RDX=tmp(8); RAX=tmp(0); multflags(RDX); }
@endif

:MWAIT          is vexMode=0 & byte=0x0f; byte=0x01; byte=0xC9              { mwait(); }
:MWAITX         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xFB              { mwaitx(); }
:MONITOR        is vexMode=0 & byte=0x0f; byte=0x01; byte=0xC8              { monitor(); }
:MONITORX       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xFA              { monitorx(); }

# See 'lockable.sinc' for memory destination, lockable variants
:NEG Rmr8       is vexMode=0 & byte=0xf6; mod=3 & Rmr8 & reg_opcode=3         { negflags(Rmr8);   Rmr8 =  -Rmr8; resultflags(Rmr8 ); }
:NEG Rmr16      is vexMode=0 & opsize=0 & byte=0xf7; mod=3 & Rmr16 & reg_opcode=3 { negflags(Rmr16); Rmr16 = -Rmr16; resultflags(Rmr16); }
:NEG Rmr32      is vexMode=0 & opsize=1 & byte=0xf7; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=3 { negflags(Rmr32); Rmr32 = -Rmr32; resultflags(Rmr32); build check_Rmr32_dest;}
@ifdef IA64
:NEG Rmr64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf7; mod=3 & Rmr64 & reg_opcode=3 { negflags(Rmr64); Rmr64 = -Rmr64; resultflags(Rmr64); }
@endif

:NOP            is vexMode=0 & byte=0x90 & (mandover=0 | mandover=4 | mandover=1) & (rexprefix=0 | rexWRXBprefix=8)  { }
:NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
:NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
:NOP^"/reserved" rm16 is vexMode=0 & mandover & opsize=0 & byte=0x0f; byte=0x18; rm16 & reg_opcode_hb=1 ...    { }
:NOP^"/reserved" rm32 is vexMode=0 & mandover & opsize=1 & byte=0x0f; byte=0x18; rm32 & reg_opcode_hb=1 ...    { }
:NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; byte=0x1f; rm16 & reg_opcode=0 ... { }
:NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; byte=0x1f; rm32 & reg_opcode=0 ... { }

# See 'lockable.sinc' for memory destination, lockable variants
:NOT Rmr8       is vexMode=0 & byte=0xf6; mod=3 & Rmr8 & reg_opcode=2         {  Rmr8 =  ~Rmr8; }
:NOT Rmr16      is vexMode=0 & opsize=0 & byte=0xf7; mod=3 & Rmr16 & reg_opcode=2 { Rmr16 = ~Rmr16; }
:NOT Rmr32      is vexMode=0 & opsize=1 & byte=0xf7; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=2 { Rmr32 = ~Rmr32; build check_Rmr32_dest;}
@ifdef IA64
:NOT Rmr64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf7; mod=3 & Rmr64 & reg_opcode=2 { Rmr64 = ~Rmr64; }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:OR  AL,imm8       is vexMode=0 & byte=0x0c; AL & imm8                                 { logicalflags();    AL =    AL |  imm8; resultflags(   AL); }
:OR  AX,imm16      is vexMode=0 & opsize=0 & byte=0xd; AX & imm16           { logicalflags();    AX =    AX | imm16; resultflags(   AX); }
:OR  EAX,imm32     is vexMode=0 & opsize=1 & byte=0xd; EAX & check_EAX_dest & imm32          { logicalflags();   EAX =   EAX | imm32; build check_EAX_dest; resultflags(  EAX); }
@ifdef IA64
:OR  RAX,simm32        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xd; RAX & simm32         { logicalflags();   RAX =   RAX | simm32; resultflags(  RAX); }
@endif
:OR  Rmr8,imm8      is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=1; imm8     { logicalflags();   Rmr8 =   Rmr8 |  imm8; resultflags(  Rmr8); }
:OR  Rmr16,imm16        is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=1; imm16  { logicalflags();  Rmr16 =  Rmr16 | imm16; resultflags( Rmr16); }
:OR  Rmr32,imm32        is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=1; imm32  { logicalflags();  Rmr32 =  Rmr32 | imm32; build check_rm32_dest; resultflags( Rmr32); }
@ifdef IA64
:OR  Rmr64,simm32       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=1; simm32 { logicalflags();  tmp:8 = Rmr64; Rmr64 =  tmp | simm32; resultflags( Rmr64); }
@endif
:OR  Rmr16,usimm8_16        is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=1; usimm8_16  { logicalflags();  Rmr16 =  Rmr16 | usimm8_16; resultflags( Rmr16); }
:OR  Rmr32,usimm8_32        is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=1; usimm8_32  { logicalflags();  Rmr32 =  Rmr32 | usimm8_32; build check_rm32_dest; resultflags( Rmr32); }
@ifdef IA64
:OR  Rmr64,usimm8_64        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=1; usimm8_64  { logicalflags();  Rmr64 =  Rmr64 | usimm8_64; resultflags( Rmr64); }
@endif
:OR  Rmr8,Reg8      is vexMode=0 & byte=0x8; mod=3 & Rmr8 & Reg8                  { logicalflags();   Rmr8 =   Rmr8 |  Reg8; resultflags(  Rmr8); }
:OR  Rmr16,Reg16        is vexMode=0 & opsize=0 & byte=0x9; mod=3 & Rmr16 & Reg16     { logicalflags();  Rmr16 =  Rmr16 | Reg16; resultflags( Rmr16); }
:OR  Rmr32,Reg32        is vexMode=0 & opsize=1 & byte=0x9; mod=3 & Rmr32 & check_Rmr32_dest & Reg32     { logicalflags();  Rmr32 =  Rmr32 | Reg32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:OR  Rmr64,Reg64        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x9; mod=3 & Rmr64 & Reg64     { logicalflags();  Rmr64 =  Rmr64 | Reg64; resultflags( Rmr64); }
@endif
:OR  Reg8,rm8      is vexMode=0 & byte=0xa; rm8 & Reg8 ...                             { logicalflags();  Reg8 =  Reg8 |   rm8; resultflags( Reg8); }
:OR  Reg16,rm16        is vexMode=0 & opsize=0 & byte=0xb; rm16 & Reg16 ...     { logicalflags(); Reg16 = Reg16 |  rm16; resultflags(Reg16); }
:OR  Reg32,rm32        is vexMode=0 & opsize=1 & byte=0xb; rm32 & Reg32 ... & check_Reg32_dest ...    { logicalflags(); Reg32 = Reg32 |  rm32; build check_Reg32_dest; resultflags(Reg32); }
@ifdef IA64
:OR  Reg64,rm64        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xb; rm64 & Reg64 ...     { logicalflags(); Reg64 = Reg64 |  rm64; resultflags(Reg64); }
@endif

:OUT imm8,AL        is vexMode=0 & byte=0xe6; imm8 & AL                 { tmp:1 = imm8; out(tmp,AL); }
:OUT imm8,AX        is vexMode=0 & opsize=0 & byte=0xe7; imm8 & AX      { tmp:1 = imm8; out(tmp,AX); }
:OUT imm8,EAX       is vexMode=0 &            byte=0xe7; imm8 & EAX     { tmp:1 = imm8; out(tmp,EAX); }
:OUT DX,AL          is vexMode=0 & byte=0xee & DX & AL                  { out(DX,AL); }
:OUT DX,AX          is vexMode=0 & opsize=0 & byte=0xef & DX & AX       { out(DX,AX); }
:OUT DX,EAX         is vexMode=0 &            byte=0xef & DX & EAX      { out(DX,EAX); }

:OUTSB^rep^reptail DX,dseSI1    is vexMode=0 & rep & reptail & byte=0x6e & DX & dseSI1      { build rep; build dseSI1; out(dseSI1,DX); build reptail;}
:OUTSW^rep^reptail DX,dseSI2    is vexMode=0 & rep & reptail & opsize=0 & byte=0x6f & DX & dseSI2   { build rep; build dseSI2; out(dseSI2,DX); build reptail;}
:OUTSD^rep^reptail DX,dseSI4    is vexMode=0 & rep & reptail &            byte=0x6f & DX & dseSI4   { build rep; build dseSI4; out(dseSI4,DX); build reptail;}

:PAUSE          is vexMode=0 & opsize=0 & $(PRE_F3) & byte=0x90     {  }
:PAUSE          is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x90     {  }

:POP rm16        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x8f; rm16 & reg_opcode=0 ... { pop22(rm16); }
:POP rm16        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x8f; rm16 & reg_opcode=0 ... { pop42(rm16); }
:POP rm32        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x8f; rm32 & reg_opcode=0 ... { pop24(rm32); }
:POP rm32        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x8f; rm32 & reg_opcode=0 ... { pop44(rm32); }
@ifdef IA64
:POP rm16        is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0x8f; rm16 & reg_opcode=0 ... { pop82(rm16); }
:POP rm64        is $(LONGMODE_ON) & vexMode=0 &            byte=0x8f; rm64 & reg_opcode=0 ... { pop88(rm64); }
@endif

:POP Rmr16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & row=5 & page=1 & Rmr16       { pop22(Rmr16); }
:POP Rmr16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & row=5 & page=1 & Rmr16       { pop42(Rmr16); }
:POP Rmr32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & row=5 & page=1 & Rmr32       { pop24(Rmr32); }
:POP Rmr32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & row=5 & page=1 & Rmr32       { pop44(Rmr32); }
@ifdef IA64
:POP Rmr16      is $(LONGMODE_ON) & vexMode=0 & opsize=0 & row=5 & page=1 & Rmr16       { pop82(Rmr16); }
:POP Rmr64      is $(LONGMODE_ON) & vexMode=0 &            row=5 & page=1 & Rmr64       { pop88(Rmr64); }
@endif

:POP DS         is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0x1f & DS              { pop22(DS); }
:POP DS         is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0x1f & DS              { popseg44(DS); }
:POP ES         is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0x7 & ES               { pop22(ES); }
:POP ES         is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0x7 & ES               { popseg44(ES); }
:POP SS         is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0x17 & SS              { pop22(SS); }
:POP SS         is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0x17 & SS              { popseg44(SS); }
:POP FS         is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0xf; byte=0xa1 & FS    { pop22(FS); }
:POP FS         is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0xf; byte=0xa1 & FS    { popseg44(FS); }
@ifdef IA64
:POP FS         is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xf; byte=0xa1 & FS   	  { popseg82(FS); }
:POP FS         is $(LONGMODE_ON) & vexMode=0 &            byte=0xf; byte=0xa1 & FS   	  { popseg88(FS); }
@endif
:POP GS         is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xf; byte=0xa9 & GS      { pop22(GS); }
:POP GS         is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xf; byte=0xa9 & GS      { popseg44(GS); }
@ifdef IA64
:POP GS         is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xf; byte=0xa9 & GS       { popseg82(GS); }
:POP GS         is $(LONGMODE_ON) & vexMode=0 &            byte=0xf; byte=0xa9 & GS       { popseg88(GS); }
@endif

:POPA           is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x61            { pop22(DI); pop22(SI); pop22(BP); tmp:2=0; pop22(tmp); pop22(BX); pop22(DX); pop22(CX); pop22(AX); }
:POPA           is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x61            { pop42(DI); pop42(SI); pop42(BP); tmp:2=0; pop42(tmp); pop42(BX); pop42(DX); pop42(CX); pop42(AX); }
:POPAD          is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x61            { pop24(EDI); pop24(ESI); pop24(EBP); tmp:4=0; pop24(tmp); pop24(EBX); pop24(EDX); pop24(ECX); pop24(EAX); }
:POPAD          is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x61            { pop44(EDI); pop44(ESI); pop44(EBP); tmp:4=0; pop44(tmp); pop44(EBX); pop44(EDX); pop44(ECX); pop44(EAX); }
:POPF           is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x9d            { pop22(flags); unpackflags(flags); }
:POPF           is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x9d            { pop42(flags); unpackflags(flags); }
:POPFD          is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x9d            { pop24(eflags); unpackflags(eflags); unpackeflags(eflags); }
:POPFD          is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x9d            { pop44(eflags); unpackflags(eflags); unpackeflags(eflags); }
@ifdef IA64
:POPF           is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0x9d            { pop82(flags); unpackflags(flags); }
:POPFQ          is $(LONGMODE_ON) & vexMode=0 & addrsize=2 &            byte=0x9d            { pop88(rflags); unpackflags(rflags); unpackeflags(rflags); }
@endif

:PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=0 ... { }
:PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode   ... { }  # rest aliased to /0
:PREFETCHW    m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=1 ... { }
:PREFETCHWT1  m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=2 ... { }

:PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
:PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
:PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
:PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }

define pcodeop ptwrite;

:PTWRITE rm32 is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xae; rm32 & reg_opcode=4 ...     { ptwrite(rm32); }


:PUSH rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; rm16 & reg_opcode=6 ... { push22(rm16); }
:PUSH rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=6 ... { push42(rm16); }

:PUSH rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=6 ... { push24(rm32); }
:PUSH rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=6 ... { push44(rm32); }
@ifdef IA64
:PUSH rm16      is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xff; rm16 & reg_opcode=6 ... { push82(rm16); }
:PUSH rm64      is $(LONGMODE_ON) & vexMode=0 &            byte=0xff; rm64 & reg_opcode=6 ... { push88(rm64); }
@endif

:PUSH Rmr16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & row=5 & page=0 & Rmr16       { push22(Rmr16); }
:PUSH Rmr16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & row=5 & page=0 & Rmr16       { push42(Rmr16); }
:PUSH Rmr32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & row=5 & page=0 & Rmr32       { push24(Rmr32); }
:PUSH Rmr32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & row=5 & page=0 & Rmr32       { push44(Rmr32); }
@ifdef IA64
:PUSH Rmr16     is $(LONGMODE_ON) & vexMode=0 & opsize=0 & row=5 & page=0 & Rmr16       { push82(Rmr16); }
:PUSH Rmr64     is $(LONGMODE_ON) & vexMode=0            & row=5 & page=0 & Rmr64       { push88(Rmr64); }
@endif

:PUSH simm8_16     is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0x6a; simm8_16     { tmp:2=simm8_16; push22(tmp); }
:PUSH simm8_32     is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0x6a; simm8_32     { tmp:4=simm8_32; push44(tmp); }
@ifdef IA64
:PUSH simm8_16     is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0x6a; simm8_16     { tmp:2=simm8_16; push82(tmp); }
:PUSH simm8_64     is $(LONGMODE_ON) & vexMode=0 &            byte=0x6a; simm8_64     { tmp:8=simm8_64; push88(tmp); }
@endif

:PUSH simm16_16    is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x68; simm16_16    { tmp:2=simm16_16; push22(tmp); }
:PUSH simm16_16    is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x68; simm16_16    { tmp:2=simm16_16; push42(tmp); }
:PUSH imm32        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x68; imm32     { tmp:4=imm32; push24(tmp); }
:PUSH imm32        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x68; imm32     { tmp:4=imm32; push44(tmp); }
@ifdef IA64
:PUSH simm16_16    is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0x68; simm16_16    { tmp:2=simm16_16; push82(tmp); }
:PUSH simm32       is $(LONGMODE_ON) & vexMode=0 &            byte=0x68; simm32    { tmp:8=simm32; push88(tmp); }
@endif

:PUSH CS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0xe & CS               { push22(CS); }
:PUSH CS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0xe & CS               { pushseg44(CS); }
:PUSH SS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0x16 & SS              { push22(SS); }
:PUSH SS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0x16 & SS              { pushseg44(SS); }
:PUSH DS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0x1e & DS              { push22(DS); }
:PUSH DS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0x1e & DS              { pushseg44(DS); }
:PUSH ES        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0x6 & ES               { push22(ES); }
:PUSH ES        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0x6 & ES               { pushseg44(ES); }
:PUSH FS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0xf; byte=0xa0 & FS        { push22(FS); }
:PUSH FS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0xf; byte=0xa0 & FS        { pushseg44(FS); }
@ifdef IA64
:PUSH FS        is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xf; byte=0xa0 & FS        { pushseg82(FS); }
:PUSH FS        is $(LONGMODE_ON) & vexMode=0 &            byte=0xf; byte=0xa0 & FS        { pushseg88(FS); }
@endif
:PUSH GS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & byte=0xf; byte=0xa8 & GS        { push22(GS); }
:PUSH GS        is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & byte=0xf; byte=0xa8 & GS        { pushseg44(GS); }
@ifdef IA64
:PUSH GS        is $(LONGMODE_ON) & vexMode=0 & opsize=0 & byte=0xf; byte=0xa8 & GS        { pushseg82(GS); }
:PUSH GS        is $(LONGMODE_ON) & vexMode=0 & 	   byte=0xf; byte=0xa8 & GS        { pushseg88(GS); }
@endif

:PUSHA          is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x60            { local tmp=SP; push22(AX); push22(CX); push22(DX); push22(BX); push22(tmp); push22(BP); push22(SI); push22(DI); }
:PUSHA          is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x60            { local tmp=SP; push42(AX); push42(CX); push42(DX); push42(BX); push42(tmp); push42(BP); push42(SI); push42(DI); }
:PUSHAD         is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x60            { local tmp=ESP; push24(EAX); push24(ECX); push24(EDX); push24(EBX); push24(tmp); push24(EBP); push24(ESI); push24(EDI); }
:PUSHAD         is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x60            { local tmp=ESP; push44(EAX); push44(ECX); push44(EDX); push44(EBX); push44(tmp); push44(EBP); push44(ESI); push44(EDI); }

:PUSHF          is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x9c            { packflags(flags); push22(flags); }
:PUSHF          is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x9c            { packflags(flags); push42(flags); }
:PUSHFD         is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x9c            { packflags(eflags); packeflags(eflags); push24(eflags); }
:PUSHFD         is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x9c            { packflags(eflags); packeflags(eflags); push44(eflags); }
@ifdef IA64
:PUSHF          is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0x9c            { packflags(flags); push82(flags); }
:PUSHFQ         is $(LONGMODE_ON) & vexMode=0 &                         byte=0x9c            { packflags(rflags); packeflags(rflags); push88(rflags); }
@endif

:RCL  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=2 ...           { local tmpCF = CF; CF = rm8 s< 0; rm8 = (rm8 << 1) | tmpCF; OF = CF ^ (rm8 s< 0); }
:RCL  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=2 ...       { local cnt=(CL&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp<<cnt)|(tmp>>(9-cnt));rm8=tmp(0); CF=(tmp&0x100)!=0; }
:RCL  rm8,imm8      is vexMode=0 & byte=0xC0; rm8 & reg_opcode=2 ... ; imm8     { local cnt=(imm8&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp<<cnt)|(tmp>>(9-cnt)); rm8=tmp(0); CF=(tmp&0x100)!=0; }
:RCL rm16,n1        is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=2 ...   { local tmpCF = CF; CF = rm16 s< 0; rm16 = (rm16 << 1) | zext(tmpCF); OF = CF ^ (rm16 s< 0);}
:RCL rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=2 ...   {local cnt=(CL&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp<<cnt)|(tmp>>(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
:RCL rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=2 ... ; imm8 { local cnt=(imm8&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp<<cnt)|(tmp>>(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
:RCL rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=2 ...   { local tmpCF=CF; CF=rm32 s< 0; rm32=(rm32<<1)|zext(tmpCF); OF=CF^(rm32 s< 0); build check_rm32_dest; }
:RCL rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=2 ...   { local cnt=CL&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp<<cnt)|(tmp>>(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
:RCL rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=2 ... ; imm8 { local cnt=imm8&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp<<cnt)|(tmp>>(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
@ifdef IA64
:RCL rm64,n1        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 & reg_opcode=2 ...   { local tmpCF=CF; CF=rm64 s< 0; rm64=(rm64<<1)|zext(tmpCF); OF=CF^(rm64 s< 0);}
:RCL rm64,CL        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & reg_opcode=2 ...   { local cnt=CL&0x3f; tmp:16=(zext(CF)<<64)|zext(rm64); tmp=(tmp<<cnt)|(tmp>>(65-cnt)); rm64=tmp(0); CF=(tmp&0x1000000000000000)!=0; }
:RCL rm64,imm8      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & reg_opcode=2 ... ; imm8 { local cnt=imm8&0x3f; tmp:16=(zext(CF)<<64)|zext(rm64); tmp=(tmp<<cnt)|(tmp>>(65-cnt)); rm64=tmp(0); CF=(tmp&0x1000000000000000)!=0; }
@endif

:RCR  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=3 ...           { local tmpCF=CF; OF=rm8 s< 0; CF=(rm8&1)!=0; rm8=(rm8>>1)|(tmpCF<<7); OF=OF^(rm8 s< 0); }
:RCR  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=3 ...       { local cnt=(CL&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp>>cnt)|(tmp<<(9-cnt)); rm8=tmp(0); CF=(tmp&0x100)!=0; }
:RCR rm8,imm8       is vexMode=0 & byte=0xC0; rm8 & reg_opcode=3 ... ; imm8     { local cnt=(imm8&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp>>cnt)|(tmp<<(9-cnt)); rm8=tmp(0); CF=(tmp&0x100)!=0; }
:RCR rm16,n1        is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=3 ...   { local tmpCF=CF; OF=rm16 s< 0; CF=(rm16&1)!=0; rm16=(rm16>>1)|(zext(tmpCF)<<15); OF=OF^(rm16 s< 0); }
:RCR rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=3 ...   { local cnt=(CL&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp>>cnt)|(tmp<<(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
:RCR rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=3 ... ; imm8 { local cnt=(imm8&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp>>cnt)|(tmp<<(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
:RCR rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=3 ...   { local tmpCF=CF; OF=rm32 s< 0; CF=(rm32&1)!=0; rm32=(rm32>>1)|(zext(tmpCF)<<31); OF=OF^(rm32 s< 0); build check_rm32_dest; }
:RCR rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=3 ...   { local cnt=CL&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp>>cnt)|(tmp<<(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
:RCR rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=3 ... ; imm8 { local cnt=imm8&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp>>cnt)|(tmp<<(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
@ifdef IA64
:RCR rm64,n1        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 & reg_opcode=3 ...   { local tmpCF=CF; OF=rm64 s< 0; CF=(rm64&1)!=0; rm64=(rm64>>1)|(zext(tmpCF)<<63); OF=OF^(rm64 s< 0); }
:RCR rm64,CL        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & reg_opcode=3 ...   { local cnt=CL&0x3f; tmp:16=(zext(CF)<<64)|zext(rm64); tmp=(tmp>>cnt)|(tmp<<(65-cnt)); rm64=tmp(0); CF=(tmp&0x1000000000000000)!=0; }
:RCR rm64,imm8      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & reg_opcode=3 ... ; imm8 { local cnt=imm8&0x3f; tmp:16=(zext(CF)<<64)|zext(rm64); tmp=(tmp>>cnt)|(tmp<<(65-cnt)); rm64=tmp(0); CF=(tmp&0x1000000000000000)!=0; }
@endif

@ifdef IA64
define pcodeop readfsbase;
:RDFSBASE r32 is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=0 & r32 { r32 = readfsbase(); }
:RDFSBASE r64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=0 & r64 { r64 = readfsbase(); }

define pcodeop readgsbase;
:RDGSBASE r32 is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=1 & r32 { r32 = readgsbase(); }
:RDGSBASE r64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=1 & r64 { r64 = readgsbase(); }
@endif

define pcodeop rdmsr;
:RDMSR          is vexMode=0 & byte=0xf; byte=0x32 & check_EAX_dest & check_EDX_dest {
	tmp:8 = rdmsr(ECX);
	EDX = tmp(4); build check_EDX_dest;
	EAX = tmp(0); build check_EAX_dest;
}

define pcodeop readPID;
:RDPID r32      is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xc7; reg_opcode=7 & r32 { r32 = readPID(); }
@ifdef IA64
:RDPID r64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0f; byte=0xc7; reg_opcode=7 & r64 { r64 = readPID(); }
@endif

define pcodeop rdpkru_u32;
:RDPKRU         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xee { EAX = rdpkru_u32(); }

define pcodeop rdpmc;
:RDPMC          is vexMode=0 & byte=0xf; byte=0x33 { tmp:8 = rdpmc(ECX); EDX = tmp(4); EAX = tmp:4; }

define pcodeop rdtsc;
:RDTSC          is vexMode=0 & byte=0xf; byte=0x31                  { tmp:8 = rdtsc(); EDX = tmp(4); EAX = tmp(0); }

:RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xc3            { pop22(IP); EIP=segment(CS,IP); return [EIP]; }
:RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xc3            { pop42(IP); EIP=zext(IP); return [EIP]; }
:RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xc3            { pop24(EIP); return [EIP]; }
:RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xc3            { pop44(EIP); return [EIP]; }
@ifdef IA64
:RET            is $(LONGMODE_ON) & vexMode=0 & byte=0xc3            { pop88(RIP); return [RIP]; }
@endif

:RETF           is vexMode=0 & addrsize=0 & opsize=0 & byte=0xcb            { pop22(IP); pop22(CS); EIP = segment(CS,IP); return [EIP]; }
:RETF           is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xcb            { pop42(IP); EIP=zext(IP); pop42(CS); return [EIP]; }        
@ifdef IA64
:RETF           is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xcb            { pop82(IP); RIP=zext(IP); pop82(CS); return [RIP]; }        
:RETF           is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xcb            { pop82(IP); RIP=zext(IP); pop82(CS); return [RIP]; }        
@endif
:RETF           is vexMode=0 & addrsize=0 & opsize=1 & byte=0xcb            { pop24(EIP); tmp:4=0; pop24(tmp); CS=tmp(0); return [EIP]; }
:RETF           is vexMode=0 & addrsize=1 & opsize=1 & byte=0xcb            { pop44(EIP); tmp:4=0; pop44(tmp); CS=tmp(0); return [EIP]; }
@ifdef IA64
:RETF           is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=1 & byte=0xcb            { pop84(EIP); RIP=zext(EIP); tmp:4=0; pop84(tmp); CS=tmp(0); return [RIP]; }
:RETF           is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=2 & byte=0xcb            { pop88(RIP); tmp:8=0; pop88(tmp); CS=tmp(0); return [RIP]; }
@endif

:RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xc2; imm16     { pop22(IP); EIP=zext(IP); SP=SP+imm16; return [EIP]; }      
:RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xc2; imm16     { pop42(IP); EIP=zext(IP); ESP=ESP+imm16; return [EIP]; }        
:RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xc2; imm16     { pop24(EIP); SP=SP+imm16; return [EIP]; }
:RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xc2; imm16     { pop44(EIP); ESP=ESP+imm16; return [EIP]; }
@ifdef IA64
:RET imm16      is $(LONGMODE_ON) & vexMode=0 & byte=0xc2; imm16     { pop88(RIP); RSP=RSP+imm16; return [RIP]; }
@endif

:RETF imm16     is vexMode=0 & addrsize=0 & opsize=0 & byte=0xca; imm16     { pop22(IP); EIP=zext(IP); pop22(CS); SP=SP+imm16; return [EIP]; }       
:RETF imm16     is vexMode=0 & addrsize=1 & opsize=0 & byte=0xca; imm16     { pop42(IP); EIP=zext(IP); pop42(CS); ESP=ESP+imm16; return [EIP]; }         
@ifdef IA64
:RETF imm16     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xca; imm16     { pop42(IP); RIP=zext(IP); pop42(CS); RSP=RSP+imm16; return [RIP]; }         
@endif

:RETF imm16     is vexMode=0 & addrsize=0 & opsize=1 & byte=0xca; imm16     { pop24(EIP); tmp:4=0; pop24(tmp); CS=tmp(0); SP=SP+imm16; return [EIP]; }
:RETF imm16     is vexMode=0 & addrsize=1 & opsize=1 & byte=0xca; imm16     { pop44(EIP); tmp:4=0; pop44(tmp); CS=tmp(0); ESP=ESP+imm16; return [EIP]; }
@ifdef IA64
:RETF imm16     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=1 & byte=0xca; imm16     { pop44(EIP); tmp:4=0; pop44(tmp); RIP=zext(EIP); CS=tmp(0); RSP=RSP+imm16; return [RIP]; }
:RETF imm16     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=2 & byte=0xca; imm16     { pop88(RIP); tmp:8=0; pop88(tmp); CS=tmp(0); RSP=RSP+imm16; return [RIP]; }
@endif

:ROL  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=0 ...           { CF = rm8 s< 0; rm8 = (rm8 << 1) | CF; OF = CF ^ (rm8 s< 0); }
:ROL  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=0 ...       { local cnt = CL & 0x7; local count_and_mask = CL & 0x1f;rm8 = (rm8 << cnt) | (rm8 >> (8 - cnt)); rolflags(rm8, count_and_mask);}
:ROL  rm8,imm8      is vexMode=0 & byte=0xC0; rm8 & reg_opcode=0 ... ; imm8     { local cnt = imm8 & 0x7; rm8 = (rm8 << cnt) | (rm8 >> (8 - cnt)); rolflags(rm8,imm8 & 0x1f:1);}
:ROL rm16,n1       is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=0 ...   { CF = rm16 s< 0; rm16 = (rm16 << 1) | zext(CF); OF = CF ^ (rm16 s< 0); }
:ROL rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=0 ...   { local cnt =   CL & 0xf; local count_and_mask = CL & 0x1f;rm16 = (rm16 << cnt) | (rm16 >> (16 - cnt)); rolflags(rm16,count_and_mask);}
:ROL rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=0 ... ; imm8 { local cnt = imm8 & 0xf; rm16 = (rm16 << cnt) | (rm16 >> (16 - cnt)); rolflags(rm16,imm8 & 0x1f:1);}
:ROL rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=0 ...   { CF = rm32 s< 0; rm32 = (rm32 << 1) | zext(CF); OF = CF ^ (rm32 s< 0); build check_rm32_dest; }
:ROL rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=0 ...   { local cnt =   CL & 0x1f; rm32 = (rm32 << cnt) | (rm32 >> (32 - cnt)); rolflags(rm32,cnt); build check_rm32_dest; }
:ROL rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=0 ... ; imm8 { local cnt = imm8 & 0x1f; rm32 = (rm32 << cnt) | (rm32 >> (32 - cnt)); rolflags(rm32,cnt); build check_rm32_dest; }
@ifdef IA64
:ROL rm64,n1        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 & reg_opcode=0 ...   { CF = rm64 s< 0; rm64 = (rm64 << 1) | zext(CF); OF = CF ^ (rm64 s< 0); }
:ROL rm64,CL        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & reg_opcode=0 ...   { local cnt =   CL & 0x3f; rm64 = (rm64 << cnt) | (rm64 >> (64 - cnt)); rolflags(rm64,cnt);}
:ROL rm64,imm8      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & reg_opcode=0 ... ; imm8 { local cnt = imm8 & 0x3f; rm64 = (rm64 << cnt) | (rm64 >> (64 - cnt)); rolflags(rm64,cnt);}
@endif
                    
:ROR  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=1 ...           { CF = rm8 & 1; rm8 = (rm8 >> 1) | (CF << 7); OF = ((rm8 & 0x40) != 0) ^ (rm8 s< 0); }
:ROR  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=1 ...       { local cnt = CL & 0x7; local count_and_mask = CL & 0x1f;rm8 = (rm8 >> cnt) | (rm8 << (8 - cnt)); rorflags(rm8,count_and_mask);}
:ROR  rm8,imm8      is vexMode=0 & byte=0xC0; rm8 & reg_opcode=1 ... ; imm8     { local cnt = imm8 & 0x7; rm8 = (rm8 >> cnt) | (rm8 << (8 - cnt)); rorflags(rm8,imm8 & 0x1f:1);}
:ROR rm16,n1        is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=1 ...   { CF=(rm16 & 1)!=0; rm16=(rm16>>1)|(zext(CF)<<15); OF=((rm16 & 0x4000) != 0) ^ (rm16 s< 0); }
:ROR rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=1 ...   { local cnt = CL & 0xf; local count_and_mask = CL & 0x1f; rm16 = (rm16 >> cnt) | (rm16 << (16 - cnt)); rorflags(rm16,count_and_mask);}
:ROR rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=1 ... ; imm8 { local cnt = imm8 & 0xf; rm16 = (rm16 >> cnt) | (rm16 << (16 - cnt)); rorflags(rm16,imm8 & 0x1f:1);}
:ROR rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=1 ...   { CF=(rm32&1)!=0; rm32=(rm32>>1)|(zext(CF)<<31); OF=((rm32&0x40000000)!=0) ^ (rm32 s< 0); build check_rm32_dest; }
:ROR rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=1 ...   { local cnt =   CL & 0x1f; rm32 = (rm32 >> cnt) | (rm32 << (32 - cnt)); rorflags(rm32,cnt); build check_rm32_dest; }
:ROR rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=1 ... ; imm8 { local cnt = imm8 & 0x1f; rm32 = (rm32 >> cnt) | (rm32 << (32 - cnt)); rorflags(rm32,cnt); build check_rm32_dest; }
@ifdef IA64
:ROR rm64,n1        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 & reg_opcode=1 ...   { CF=(rm64&1)!=0; rm64=(rm64>>1)|(zext(CF)<<63); OF=((rm64&0x4000000000000000)!=0) ^ (rm64 s< 0); }
:ROR rm64,CL        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & reg_opcode=1 ...   { local cnt =   CL & 0x3f; rm64 = (rm64 >> cnt) | (rm64 << (64 - cnt)); rorflags(rm64,cnt);}
:ROR rm64,imm8      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & reg_opcode=1 ... ; imm8 { local cnt = imm8 & 0x3f; rm64 = (rm64 >> cnt) | (rm64 << (64 - cnt)); rorflags(rm64,cnt);}
@endif

define pcodeop smm_restore_state;
:RSM            is vexMode=0 & byte=0xf; byte=0xaa                  { tmp:4 = smm_restore_state(); return [tmp]; }

# Initially disallowed in 64bit mode, but later reintroduced
:SAHF           is vexMode=0 & byte=0x9e { SF = (AH & 0x80) != 0;
                                          ZF = (AH & 0x40) != 0;
                                          AF = (AH & 0x10) != 0;
                                          PF = (AH & 0x04) != 0;
                                          CF = (AH & 0x01) != 0; }

:SALC         is $(LONGMODE_OFF) & vexMode=0 & byte=0xd6 { AL = CF * 0xff; }

:SAR  rm8,n1    is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=7 ...               { CF = rm8 & 1; OF = 0; rm8 = rm8 s>> 1; resultflags(rm8); }
:SAR  rm8,CL    is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=7 ...           { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 s>> count;
                                          sarflags(tmp, rm8,count); shiftresultflags(rm8,count); }
:SAR  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & reg_opcode=7 ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 s>> count;
                                          sarflags(tmp, rm8,count); shiftresultflags(rm8,count); }
:SAR rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=7 ...       { CF = (rm16 & 1) != 0; OF = 0; rm16 = rm16 s>> 1; resultflags(rm16); }
:SAR rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=7 ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 s>> count;
                                          sarflags(tmp, rm16,count); shiftresultflags(rm16,count); }
:SAR rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=7 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 s>> count;
                                          sarflags(tmp, rm16,count); shiftresultflags(rm16,count); }
:SAR rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=7 ...       { CF = (rm32 & 1) != 0; OF = 0; rm32 = rm32 s>> 1; build check_rm32_dest; resultflags(rm32); }
:SAR rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=7 ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 s>> count; build check_rm32_dest;
                                          sarflags(tmp, rm32,count); shiftresultflags(rm32,count); }
:SAR rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=7 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 s>> count; build check_rm32_dest;
                                          sarflags(tmp, rm32,count); shiftresultflags(rm32,count); }
@ifdef IA64
:SAR rm64,n1    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 & reg_opcode=7 ...       { CF = (rm64 & 1) != 0; OF = 0; rm64 = rm64 s>> 1; resultflags(rm64); }
:SAR rm64,CL    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & reg_opcode=7 ...       { local count =   CL & 0x3f; local tmp = rm64; rm64 = rm64 s>> count;
                                          sarflags(tmp, rm64,count); shiftresultflags(rm64,count); }
:SAR rm64,imm8  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & reg_opcode=7 ... ; imm8     { local count = imm8 & 0x3f; local tmp = rm64; rm64 = rm64 s>> count;
                                          sarflags(tmp, rm64,count); shiftresultflags(rm64,count); }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:SBB  AL,imm8      is vexMode=0 & byte=0x1c; AL & imm8									{ subCarryFlags( AL, imm8 ); resultflags(AL); }
:SBB  AX,imm16     is vexMode=0 & opsize=0 & byte=0x1d; AX & imm16						{ subCarryFlags( AX, imm16 ); resultflags(AX); }
:SBB  EAX,imm32    is vexMode=0 & opsize=1 & byte=0x1d; EAX & check_EAX_dest & imm32	{ subCarryFlags( EAX, imm32 ); build check_EAX_dest; resultflags(EAX); }
@ifdef IA64
:SBB  RAX,simm32_64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x1d; RAX & simm32_64						{ subCarryFlags( RAX, simm32_64 ); resultflags(RAX); }
@endif
:SBB  Rmr8,imm8     is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=3; imm8								{ subCarryFlags( Rmr8, imm8 ); resultflags(Rmr8); }
:SBB  Rmr16,imm16       is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=3; imm16							{ subCarryFlags( Rmr16, imm16 ); resultflags(Rmr16); }
:SBB  Rmr32,imm32       is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=3; imm32	{ subCarryFlags( Rmr32, imm32 ); build check_Rmr32_dest; resultflags(Rmr32); }
@ifdef IA64
:SBB  Rmr64,imm32       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=3; imm32							{ subCarryFlags( Rmr64, imm32 ); resultflags(Rmr64); }
@endif

:SBB  Rmr16,simm8_16       is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=3; simm8_16						{ subCarryFlags( Rmr16, simm8_16 ); resultflags(Rmr16); }
:SBB  Rmr32,simm8_32       is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_Rmr32_dest & reg_opcode=3; simm8_32	{ subCarryFlags( Rmr32, simm8_32 ); build check_Rmr32_dest; resultflags(Rmr32); }
@ifdef IA64
:SBB  Rmr64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=3; simm8_64						{ subCarryFlags( Rmr64, simm8_64 ); resultflags(Rmr64); }
@endif

:SBB  Rmr8,Reg8     is vexMode=0 & byte=0x18; mod=3 & Rmr8 & Reg8											{ subCarryFlags(  Rmr8, Reg8 ); resultflags(Rmr8); }
:SBB  Rmr16,Reg16       is vexMode=0 & opsize=0 & byte=0x19; mod=3 & Rmr16 & Reg16						{ subCarryFlags( Rmr16, Reg16 ); resultflags(Rmr16); }
:SBB  Rmr32,Reg32       is vexMode=0 & opsize=1 & byte=0x19; mod=3 & Rmr32 & check_Rmr32_dest & Reg32	{ subCarryFlags( Rmr32, Reg32 ); build check_Rmr32_dest; resultflags(Rmr32); }
@ifdef IA64
:SBB  Rmr64,Reg64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x19; mod=3 & Rmr64 & Reg64						{ subCarryFlags( Rmr64, Reg64 ); resultflags(Rmr64); }
@endif

:SBB  Reg8,rm8     is vexMode=0 & byte=0x1a; rm8 & Reg8 ...											{ subCarryFlags( Reg8, rm8 ); resultflags(Reg8); }
:SBB  Reg16,rm16       is vexMode=0 & opsize=0 & byte=0x1b; rm16 & Reg16 ...						{ subCarryFlags( Reg16, rm16 ); resultflags(Reg16); }
:SBB  Reg32,rm32       is vexMode=0 & opsize=1 & byte=0x1b; rm32 & Reg32 ... & check_Reg32_dest ...	{ subCarryFlags( Reg32, rm32 ); build check_Reg32_dest; resultflags(Reg32); }
@ifdef IA64
:SBB  Reg64,rm64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x1b; rm64 & Reg64 ...						{ subCarryFlags( Reg64, rm64 ); resultflags(Reg64); }
@endif

:SCASB^repe^repetail eseDI1 is vexMode=0 & repe & repetail &            byte=0xae & eseDI1  { build repe; build eseDI1; subflags(AL,eseDI1); local diff=AL-eseDI1; resultflags(diff); build repetail; }
:SCASW^repe^repetail eseDI2 is vexMode=0 & repe & repetail & opsize=0 & byte=0xaf & eseDI2  { build repe; build eseDI2; subflags(AX,eseDI2); local diff=AX-eseDI2; resultflags(diff); build repetail; }
:SCASD^repe^repetail eseDI4 is vexMode=0 & repe & repetail & opsize=1 & byte=0xaf & eseDI4  { build repe; build eseDI4; subflags(EAX,eseDI4); local diff=EAX-eseDI4; resultflags(diff); build repetail; }
@ifdef IA64
:SCASQ^repe^repetail eseDI8 is $(LONGMODE_ON) & vexMode=0 & repe & repetail & opsize=2 & byte=0xaf & eseDI8  { build repe; build eseDI8; subflags(RAX,eseDI8); local diff=RAX-eseDI8; resultflags(diff); build repetail; }
@endif

:SET^cc rm8     is vexMode=0 & byte=0xf; row=9 & cc; rm8                { rm8 = cc; }

# manual is not consistent on operands
:SGDT m16       is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m16
{
	m16 = GlobalDescriptorTableRegister();
}

:SGDT m32       is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m32
{
	m32 = GlobalDescriptorTableRegister();
}

@ifdef IA64
:SGDT m64       is $(LONGMODE_ON) & vexMode=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m64
{
	m64 = GlobalDescriptorTableRegister();
}
@endif


:SHL  rm8,n1    is vexMode=0 & byte=0xD0;  rm8 & n1 &(reg_opcode=4|reg_opcode=6) ...               { CF = rm8 s< 0; rm8 = rm8 << 1; OF = CF ^^ (rm8 s< 0); resultflags(rm8); }
:SHL  rm8,CL    is vexMode=0 & byte=0xD2;  CL & rm8 & (reg_opcode=4|reg_opcode=6) ...          { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 << count;
                                          shlflags(tmp, rm8,count); shiftresultflags(rm8,count); }
:SHL  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & (reg_opcode=4|reg_opcode=6) ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 << count;
                                          shlflags(tmp, rm8,count); shiftresultflags(rm8,count); }
:SHL rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & (reg_opcode=4|reg_opcode=6) ...       { CF = rm16 s< 0; rm16 = rm16 << 1; OF = CF ^^ (rm16 s< 0); resultflags(rm16); }
:SHL rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 << count;
                                          shlflags(tmp, rm16,count); shiftresultflags(rm16,count); }
:SHL rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 << count;
                                          shlflags(tmp, rm16,count); shiftresultflags(rm16,count); }
:SHL rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ...       { CF = rm32 s< 0; rm32 = rm32 << 1; OF = CF ^^ (rm32 s< 0); build check_rm32_dest; resultflags(rm32); }
:SHL rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 << count; build check_rm32_dest;
                                          shlflags(tmp, rm32,count); shiftresultflags(rm32,count); }
:SHL rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 << count; build check_rm32_dest;
                                          shlflags(tmp, rm32,count); shiftresultflags(rm32,count); }
@ifdef IA64
:SHL rm64,n1    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 & (reg_opcode=4|reg_opcode=6) ...       { CF = rm64 s< 0; rm64 = rm64 << 1; OF = CF ^^ (rm64 s< 0); resultflags(rm64); }
:SHL rm64,CL    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x3f; local tmp = rm64; rm64 = rm64 << count;
                                          shlflags(tmp, rm64,count); shiftresultflags(rm64,count); }
:SHL rm64,imm8  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x3f; local tmp = rm64; rm64 = rm64 << count;
                                          shlflags(tmp, rm64,count); shiftresultflags(rm64,count); }
@endif

:SHLD rm16,Reg16,imm8 is vexMode=0 & opsize=0; byte=0x0F; byte=0xA4; rm16 & Reg16 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm16;
                                           rm16 = (rm16 << count) | (Reg16 >> (16 - count));
                                           shlflags(tmp,rm16,count); shiftresultflags(rm16,count);}
:SHLD rm16,Reg16,CL   is vexMode=0 & opsize=0; byte=0x0F; byte=0xA5; CL & rm16 & Reg16 ...  { local count =   CL & 0x1f; local tmp = rm16;
                                          rm16 = (rm16 << count) | (Reg16 >> (16 - count));
                                          shlflags(tmp,rm16,count); shiftresultflags(rm16,count); }
:SHLD rm32,Reg32,imm8 is vexMode=0 & opsize=1; byte=0x0F; byte=0xA4; rm32 & check_rm32_dest ... & Reg32 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm32;
                                           rm32 = (rm32 << count) | (Reg32 >> (32 - count)); build check_rm32_dest;
                                           shlflags(tmp,rm32,count); shiftresultflags(rm32,count); }
:SHLD rm32,Reg32,CL   is vexMode=0 & opsize=1; byte=0x0F; byte=0xA5; CL & rm32 & check_rm32_dest ... & Reg32 ...  { local count =   CL & 0x1f; local tmp = rm32;
                                          rm32 = (rm32 << count) | (Reg32 >> (32 - count)); build check_rm32_dest;
                                          shlflags(tmp,rm32,count); shiftresultflags(rm32,count); }
@ifdef IA64
:SHLD rm64,Reg64,imm8 is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0x0F; byte=0xA4; rm64 & Reg64 ... ; imm8 { local count = imm8 & 0x3f; local tmp = rm64;
                                           rm64 = (rm64 << count) | (Reg64 >> (64 - count));
                                           shlflags(tmp,rm64,count); shiftresultflags(rm64,count); }
:SHLD rm64,Reg64,CL   is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0x0F; byte=0xA5; CL & rm64 & Reg64 ...  { local count =   CL & 0x3f; local tmp = rm64;
                                          rm64 = (rm64 << count) | (Reg64 >> (64 - count));
                                          shlflags(tmp,rm64,count); shiftresultflags(rm64,count); }
@endif

:SHRD rm16,Reg16,imm8 is vexMode=0 & opsize=0; byte=0x0F; byte=0xAC; rm16 & Reg16 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm16;
                                           rm16 = (rm16 >> count) | (Reg16 << (16 - count));
                                           shrdflags(tmp,rm16,count); shiftresultflags(rm16,count); }
:SHRD rm16,Reg16,CL   is vexMode=0 & opsize=0; byte=0x0F; byte=0xAD; CL & rm16 & Reg16 ...  { local count =   CL & 0x1f; local tmp = rm16;
                                          rm16 = (rm16 >> count) | (Reg16 << (16 - count));
                                          shrdflags(tmp,rm16,count); shiftresultflags(rm16,count); }
:SHRD rm32,Reg32,imm8 is vexMode=0 & opsize=1; byte=0x0F; byte=0xAC; rm32 & check_rm32_dest ... & Reg32 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm32;
                                           rm32 = (rm32 >> count) | (Reg32 << (32 - count)); build check_rm32_dest;
                                           shrdflags(tmp,rm32,count); shiftresultflags(rm32,count); }
:SHRD rm32,Reg32,CL   is vexMode=0 & opsize=1; byte=0x0F; byte=0xAD; CL & rm32 & check_rm32_dest ... & Reg32 ...  { local count =   CL & 0x1f; local tmp = rm32;
                                          rm32 = (rm32 >> count) | (Reg32 << (32 - count)); build check_rm32_dest;
                                          shrdflags(tmp,rm32,count); shiftresultflags(rm32,count); }
@ifdef IA64
:SHRD rm64,Reg64,imm8 is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0x0F; byte=0xAC; rm64 & Reg64 ... ; imm8 { local count = imm8 & 0x3f; local tmp = rm64;
                                           rm64 = (rm64 >> count) | (Reg64 << (64 - count));
                                           shrdflags(tmp,rm64,count); shiftresultflags(rm64,count); }
:SHRD rm64,Reg64,CL   is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0x0F; byte=0xAD; CL & rm64 & Reg64 ...  { local count =   CL & 0x3f; local tmp = rm64;
                                          rm64 = (rm64 >> count) | (Reg64 << (64 - count));
                                          shrdflags(tmp,rm64,count); shiftresultflags(rm64,count); }
@endif

:SHR  rm8,n1    is vexMode=0 & byte=0xD0;  rm8 & n1 & reg_opcode=5 ...              { CF = rm8 & 1; OF = 0; rm8 = rm8 >> 1; resultflags(rm8); }
:SHR  rm8,CL    is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=5 ...           { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 >> count;
                                          shrflags(tmp, rm8,count); shiftresultflags(rm8,count); }
:SHR  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & reg_opcode=5 ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 >> count;
                                          shrflags(tmp, rm8,count); shiftresultflags(rm8,count); }
:SHR rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=5 ...       { CF = (rm16 & 1) != 0; OF = 0; rm16 = rm16 >> 1; resultflags(rm16); }
:SHR rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=5 ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 >> count;
                                          shrflags(tmp, rm16,count); shiftresultflags(rm16,count); }
:SHR rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=5 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 >> count;
                                          shrflags(tmp, rm16,count); shiftresultflags(rm16,count); }
:SHR rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=5 ...        { CF = (rm32 & 1) != 0; OF = 0; rm32 = rm32 >> 1; build check_rm32_dest; resultflags(rm32); }
:SHR rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=5 ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 >> count; build check_rm32_dest;
                                          shrflags(tmp, rm32,count); shiftresultflags(rm32,count); }
:SHR rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=5 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 >> count; build check_rm32_dest;
                                          shrflags(tmp, rm32,count); shiftresultflags(rm32,count); }
@ifdef IA64
:SHR rm64,n1    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD1; rm64 & n1 &reg_opcode=5 ...        { CF = (rm64 & 1) != 0; OF = 0; rm64 = rm64 >> 1; resultflags(rm64); }
:SHR rm64,CL    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xD3; CL & rm64 & reg_opcode=5 ...       { local count =   CL & 0x3f; local tmp = rm64; rm64 = rm64 >> count;
                                          shrflags(tmp, rm64,count); shiftresultflags(rm64,count); }
:SHR rm64,imm8  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xC1; rm64 & reg_opcode=5 ... ; imm8     { local count = imm8 & 0x3f; local tmp = rm64; rm64 = rm64 >> count;
                                          shrflags(tmp, rm64,count); shiftresultflags(rm64,count); }
@endif

:SIDT m16       is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m16
{
	m16 = InterruptDescriptorTableRegister();
}

:SIDT m32       is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m32
{
	m32 = InterruptDescriptorTableRegister();
}
@ifdef IA64
:SIDT m64       is $(LONGMODE_ON) & vexMode=0 &  byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m64
{
	m64 = InterruptDescriptorTableRegister();
}
@endif

define pcodeop skinit;
:SKINIT EAX     is vexMode=0 & byte=0x0f; byte=0x01; byte=0xde & EAX { skinit(EAX); }

:SLDT rm16      is vexMode=0 & opsize=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=0 ...
{
	rm16 = LocalDescriptorTableRegister();
}
:SLDT rm32      is vexMode=0 & opsize=1 & byte=0xf; byte=0x0; rm32 & reg_opcode=0 ...
{
	rm32 = LocalDescriptorTableRegister();
}
@ifdef IA64
:SLDT rm64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0x0; rm64 & reg_opcode=0 ...
{
	rm64 = LocalDescriptorTableRegister();
}
@endif

:SMSW rm16      is vexMode=0 & opsize=0 & byte=0xf; byte=0x01; rm16 & reg_opcode=4 ...  { rm16 = CR0:2; }
:SMSW rm32      is vexMode=0 & opsize=1 & byte=0xf; byte=0x01; rm32 & reg_opcode=4 ...  { rm32 = zext(CR0:2); }
@ifdef IA64
:SMSW rm64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0x01; rm64 & reg_opcode=4 ...  { rm64 = CR0; }
@endif

:STAC           is vexMode=0 & byte=0x0f; byte=0x01; byte=0xcb  { AC = 1; }
:STC            is vexMode=0 & byte=0xf9                        { CF = 1; }
:STD            is vexMode=0 & byte=0xfd                        { DF = 1; }
# MFL:  AMD instruction
# TODO: define the action.
# STGI:  set global interrupt flag (GIF); while GIF is zero, all external interrupts are disabled.
:STGI           is vexMode=0 & byte=0x0f; byte=0x01; byte=0xdc              { stgi(); }
:STI            is vexMode=0 & byte=0xfb                        { IF = 1; }

:STMXCSR m32        is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=3 ) ... & m32 { m32 = MXCSR; }

:STOSB^rep^reptail eseDI1   is vexMode=0 & rep & reptail & byte=0xaa & eseDI1           { build rep; build eseDI1; eseDI1=AL; build reptail; }
:STOSW^rep^reptail eseDI2   is vexMode=0 & rep & reptail & opsize=0 & byte=0xab & eseDI2    { build rep; build eseDI2; eseDI2=AX; build reptail; }
:STOSD^rep^reptail eseDI4   is vexMode=0 & rep & reptail & opsize=1 & byte=0xab & eseDI4    { build rep; build eseDI4; eseDI4=EAX; build reptail; }
@ifdef IA64
:STOSQ^rep^reptail eseDI8   is $(LONGMODE_ON) & vexMode=0 & rep & reptail & opsize=2 & byte=0xab & eseDI8    { build rep; build eseDI8; eseDI8=RAX; build reptail; }
@endif

:STR rm16       is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=1 ... { rm16 = TaskRegister(); }

# See 'lockable.sinc' for memory destination, lockable variants
:SUB  AL,imm8      is vexMode=0 & byte=0x2c; AL & imm8                          { subflags(   AL,imm8 );    AL =    AL -  imm8; resultflags(   AL); }
:SUB  AX,imm16     is vexMode=0 & opsize=0 & byte=0x2d; AX & imm16              { subflags(   AX,imm16);    AX =    AX - imm16; resultflags(   AX); }
:SUB  EAX,imm32        is vexMode=0 & opsize=1 & byte=0x2d; EAX & check_EAX_dest & imm32         { subflags(  EAX,imm32);   EAX =   EAX - imm32; build check_EAX_dest; resultflags(  EAX); }
@ifdef IA64
:SUB  RAX,simm32        is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x2d; RAX & simm32         { subflags(  RAX,simm32);   RAX =   RAX - simm32; resultflags(  RAX); }
@endif
:SUB  Rmr8,imm8     is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=5; imm8     { subflags(  Rmr8,imm8 );   Rmr8 =   Rmr8 -  imm8; resultflags(  Rmr8); }
:SUB  Rmr16,imm16       is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=5; imm16  { subflags( Rmr16,imm16);  Rmr16 =  Rmr16 - imm16; resultflags( Rmr16); }
:SUB  Rmr32,imm32       is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=5; imm32  { subflags( Rmr32,imm32);  Rmr32 =  Rmr32 - imm32; build check_rm32_dest; resultflags( Rmr32); }
@ifdef IA64
:SUB  Rmr64,simm32       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=5; simm32  { subflags( Rmr64,simm32);  Rmr64 =  Rmr64 - simm32; resultflags( Rmr64); }
@endif
:SUB  Rmr16,simm8_16       is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=5; simm8_16  { subflags( Rmr16,simm8_16);  Rmr16 =  Rmr16 - simm8_16; resultflags( Rmr16); }
:SUB  Rmr32,simm8_32       is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=5; simm8_32  { subflags( Rmr32,simm8_32);  Rmr32 =  Rmr32 - simm8_32; build check_rm32_dest; resultflags( Rmr32); }
@ifdef IA64
:SUB  Rmr64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=5; simm8_64  { subflags( Rmr64,simm8_64);  Rmr64 =  Rmr64 - simm8_64; resultflags( Rmr64); }
@endif
:SUB  Rmr8,Reg8     is vexMode=0 & byte=0x28; mod=3 & Rmr8 & Reg8                 { subflags(  Rmr8,Reg8 );   Rmr8 =   Rmr8 -  Reg8; resultflags(  Rmr8); }
:SUB  Rmr16,Reg16       is vexMode=0 & opsize=0 & byte=0x29; mod=3 & Rmr16 & Reg16        { subflags( Rmr16,Reg16);  Rmr16 =  Rmr16 - Reg16; resultflags( Rmr16); }
:SUB  Rmr32,Reg32       is vexMode=0 & opsize=1 & byte=0x29; mod=3 & Rmr32 & check_Rmr32_dest & Reg32        { subflags( Rmr32,Reg32);  Rmr32 =  Rmr32 - Reg32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:SUB  Rmr64,Reg64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x29; mod=3 & Rmr64 & Reg64        { subflags( Rmr64,Reg64);  Rmr64 =  Rmr64 - Reg64; resultflags( Rmr64); }
@endif
:SUB  Reg8,rm8     is vexMode=0 & byte=0x2a; rm8 & Reg8 ...                 { subflags( Reg8,rm8  );  Reg8 =  Reg8 -   rm8; resultflags( Reg8); }
:SUB  Reg16,rm16       is vexMode=0 & opsize=0 & byte=0x2b; rm16 & Reg16 ...        { subflags(Reg16,rm16 ); Reg16 = Reg16 -  rm16; resultflags(Reg16); }
:SUB  Reg32,rm32       is vexMode=0 & opsize=1 & byte=0x2b; rm32 & Reg32 ... & check_Reg32_dest ...       { subflags(Reg32,rm32 ); Reg32 = Reg32 -  rm32; build check_Reg32_dest; resultflags(Reg32); }
@ifdef IA64
:SUB  Reg64,rm64       is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x2b; rm64 & Reg64 ...        { subflags(Reg64,rm64 ); Reg64 = Reg64 -  rm64; resultflags(Reg64); }
@endif

:SYSENTER           is vexMode=0 & byte=0x0f; byte=0x34                     { sysenter(); }
:SYSEXIT            is vexMode=0 & byte=0x0f; byte=0x35                     { sysexit();
@ifdef IA64
                                                                  RIP=RCX; return [RIP];
@endif
                                                                }

:SYSCALL            is vexMode=0 & byte=0x0f; byte=0x05                     {
	RCX = inst_next;
	packflags(R11);
	syscall();
}

# returning to 32bit mode loads ECX
# returning to 64bit mode loads RCX
:SYSRET             is vexMode=0 & byte=0x0f; byte=0x07                     { sysret();
@ifdef IA64
                                                                  RIP=RCX; return [RIP];
@endif
                                                                }

:SWAPGS             is vexMode=0 & bit64=1 & byte=0x0f; byte=0x01; byte=0xf8   { swapgs(); }

:RDTSCP             is vexMode=0 & bit64=1 & byte=0x0f; byte=0x01; byte=0xf9   { 
    tmp:8 = rdtsc();

@ifdef IA64
	RAX = zext(tmp[0,32]);
	RDX = zext(tmp[32,32]);
	RCX = zext(0);
@else
	EAX = tmp[0,32];
	EDX = tmp[32,32];
	ECX = 0;
@endif
 }

:TEST   AL,imm8     is vexMode=0 & byte=0xA8; AL & imm8                 { logicalflags(); local tmp =   AL & imm8;  resultflags(tmp); }
:TEST   AX,imm16    is vexMode=0 & opsize=0; byte=0xA9; AX & imm16          { logicalflags(); local tmp =   AX & imm16; resultflags(tmp); }
:TEST   EAX,imm32   is vexMode=0 & opsize=1; byte=0xA9; EAX & imm32         { logicalflags(); local tmp =  EAX & imm32; resultflags(tmp); }
@ifdef IA64
:TEST   RAX,simm32  is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0xA9; RAX & simm32            { logicalflags(); local tmp =  RAX & simm32; resultflags(tmp); }
@endif
:TEST  spec_rm8,imm8     is vexMode=0 & byte=0xF6;  spec_rm8 & (reg_opcode=0 | reg_opcode=1) ... ; imm8        { logicalflags(); local tmp =  spec_rm8 & imm8;  resultflags(tmp); }
:TEST spec_rm16,imm16    is vexMode=0 & opsize=0; byte=0xF7; spec_rm16 & (reg_opcode=0 | reg_opcode=1) ... ; imm16 { logicalflags(); local tmp = spec_rm16 & imm16; resultflags(tmp); }
:TEST spec_rm32,imm32    is vexMode=0 & opsize=1; byte=0xF7; spec_rm32 & (reg_opcode=0 | reg_opcode=1) ... ; imm32 { logicalflags(); local tmp = spec_rm32 & imm32; resultflags(tmp); }
@ifdef IA64
:TEST spec_rm64,simm32   is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0xF7; spec_rm64 & (reg_opcode=0 | reg_opcode=1) ... ; simm32    { logicalflags(); local tmp = spec_rm64 & simm32; resultflags(tmp); }
@endif
:TEST  rm8,Reg8     is vexMode=0 & byte=0x84;  rm8 & Reg8  ...              { logicalflags(); local tmp =  rm8 & Reg8;  resultflags(tmp); }
:TEST rm16,Reg16    is vexMode=0 & opsize=0; byte=0x85; rm16 & Reg16 ...        { logicalflags(); local tmp = rm16 & Reg16; resultflags(tmp); }
:TEST rm32,Reg32    is vexMode=0 & opsize=1; byte=0x85; rm32 & Reg32 ...        { logicalflags(); local tmp = rm32 & Reg32; resultflags(tmp); }
@ifdef IA64
:TEST rm64,Reg64    is $(LONGMODE_ON) & vexMode=0 & opsize=2; byte=0x85; rm64 & Reg64 ...        { logicalflags(); local tmp = rm64 & Reg64; resultflags(tmp); }
@endif

define pcodeop invalidInstructionException;
:UD0  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xff; rm32 & Reg32 ...           { invalidInstructionException(); goto inst_start; }
:UD1  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xb9; rm32 & Reg32 ...           { invalidInstructionException(); goto inst_start; }
:UD2              is vexMode=0 & byte=0xf; byte=0xb                               { invalidInstructionException(); goto inst_start; }

define pcodeop verr;
define pcodeop verw;
:VERR rm16      is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=4 ...      { ZF = verr(); }
:VERW rm16      is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=5 ...      { ZF = verw(); }

# MFL added VMX opcodes
#
# AMD hardware assisted virtualization opcodes
:VMLOAD EAX     is vexMode=0 & addrsize=1 & byte=0x0f; byte=0x01; byte=0xda & EAX       { vmload(EAX); }
@ifdef IA64
:VMLOAD RAX     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0x0f; byte=0x01; byte=0xda & RAX       { vmload(RAX); }
@endif
:VMMCALL        is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd9          { vmmcall(); }
# Limiting the effective address size to 32 and 64 bit.  Surely we're not expecting a 16-bit VM address, are we?
:VMRUN EAX      is vexMode=0 & addrsize=1 & byte=0x0f; byte=0x01; byte=0xd8 & EAX       { vmrun(EAX); }
@ifdef IA64
:VMRUN RAX      is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0x0f; byte=0x01; byte=0xd8 & RAX       { vmrun(RAX); }
@endif
# Limiting the effective address size to 32 and 64 bit.  Surely we're not expecting a 16-bit VM address, are we?
:VMSAVE EAX     is vexMode=0 & addrsize=1 & byte=0x0f; byte=0x01; byte=0xdb & EAX       { vmsave(EAX); }
@ifdef IA64
:VMSAVE RAX     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0x0f; byte=0x01; byte=0xdb & RAX       { vmsave(RAX); }
@endif
#

#
# Intel hardware assisted virtualization opcodes
@ifdef IA64
:INVEPT Reg64, m128  is $(LONGMODE_ON) & vexMode=0 & bit64=1 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0x80; Reg64 ... & m128 { invept(Reg64, m128); }
@endif
:INVEPT Reg32, m128  is vexMode=0 & bit64=0 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0x80; Reg32 ... & m128 { invept(Reg32, m128); }
@ifdef IA64
:INVVPID Reg64, m128 is $(LONGMODE_ON) & vexMode=0 & bit64=1 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0x81; Reg64 ... & m128 { invvpid(Reg64, m128); }
@endif
:INVVPID Reg32, m128 is vexMode=0 & bit64=0 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0x81; Reg32 ... & m128 { invvpid(Reg32, m128); }
:VMCALL         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc1                          { vmcall(); }
@ifdef IA64
:VMCLEAR m64    is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64 { vmclear(m64); }
@endif
#TODO: invokes a VM function specified in EAX
:VMFUNC EAX     is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd4 & EAX                         { vmfunc(EAX); }
#TODO: this launches the VM managed by the current VMCS.  How is the VMCS expressed for the emulator?  For Ghidra analysis?
:VMLAUNCH       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc2                          { vmlaunch(); }
#TODO: this resumes the VM managed by the current VMCS.  How is the VMCS expressed for the emulator?  For Ghidra analysis?
:VMRESUME       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc3                          { vmresume(); }
#TODO: this loads the VMCS pointer from the m64 memory address and makes the VMCS pointer valid; how to express
#  this for analysis and emulation?
:VMPTRLD m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64 { vmptrld(m64); }
#TODO: stores the current VMCS pointer into the specified 64-bit memory address; how to express this for analysis and emulation?
#TODO:  note that the Intel manual does not specify m64 (which it does for VMPTRLD, yet it does state that "the operand
#  of this instruction is always 64-bits and is always in memory".  Is it an error that the "Instruction" entry in the 
#  box giving the definition does not specify m64?
:VMPTRST m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=7 ) ... & m64  { vmptrst(m64); }
:VMREAD rm32, Reg32  is vexMode=0 & opsize=1 & byte=0x0f; byte=0x78; rm32 & check_rm32_dest ... & Reg32 ...     { rm32 = vmread(Reg32); build check_rm32_dest; }
@ifdef IA64
:VMREAD rm64, Reg64  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0f; byte=0x78; rm64 & Reg64 ...     { rm64 = vmread(Reg64); }
@endif
:VMWRITE Reg32, rm32 is vexMode=0 & opsize=1 & byte=0x0f; byte=0x79; rm32 & Reg32 ... & check_Reg32_dest ...   { vmwrite(rm32,Reg32); build check_Reg32_dest; }
@ifdef IA64
:VMWRITE Reg64, rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0f; byte=0x79; rm64 & Reg64 ...    { vmwrite(rm64,Reg64); }
@endif
:VMXOFF         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc4                           { vmxoff(); }
# NB: this opcode is incorrect in the 2005 edition of the Intel manual. Opcode below is taken from the 2008 version.
:VMXON m64      is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64  { vmxon(m64); }

#END of changes for VMX opcodes

:WAIT           is vexMode=0 & byte=0x9b                        { }
:WBINVD         is vexMode=0 & byte=0xf; byte=0x9                   { }

@ifdef IA64
define pcodeop writefsbase;
:WRFSBASE r32 is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=2 & r32 { tmp:8 = zext(r32); writefsbase(tmp); }
:WRFSBASE r64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=2 & r64 { writefsbase(r64); }

define pcodeop writegsbase;
:WRGSBASE r32 is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=3 & r32 { tmp:8 = zext(r32); writegsbase(tmp); }
:WRGSBASE r64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0f; byte=0xae; reg_opcode=3 & r64 { writegsbase(r64); }
@endif

define pcodeop wrpkru;
:WRPKRU         is byte=0x0F; byte=0x01; byte=0xEF              { wrpkru(EAX); }

define pcodeop wrmsr;
:WRMSR is vexMode=0 & byte=0xf; byte=0x30 { tmp:8 = (zext(EDX) << 32) | zext(EAX); wrmsr(ECX,tmp); }

# See 'lockable.sinc' for memory destination, lockable variants
:XADD       Rmr8,Reg8 	is vexMode=0 & byte=0x0F; byte=0xC0; mod=3 & Rmr8 & Reg8        { addflags( Rmr8,Reg8 ); local tmp =  Rmr8 +  Reg8;  Reg8 = Rmr8; Rmr8 = tmp;     resultflags(tmp); }
:XADD      Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0x0F; byte=0xC1; mod=3 & Rmr16 & Reg16 { addflags(Rmr16,Reg16); local tmp = Rmr16 + Reg16; Reg16 = Rmr16; Rmr16 = tmp; resultflags(tmp); }
:XADD      Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0x0F; byte=0xC1; mod=3 & Rmr32 & check_Rmr32_dest & Reg32 & check_Reg32_dest { addflags(Rmr32,Reg32); local tmp = Rmr32 + Reg32; Reg32 = Rmr32; Rmr32 = tmp; build check_Rmr32_dest; build check_Reg32_dest; resultflags(tmp); }
@ifdef IA64
:XADD      Rmr64,Reg64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x0F; byte=0xC1; mod=3 & Rmr64 & Reg64 { addflags(Rmr64,Reg64); local tmp = Rmr64 + Reg64; Reg64 = Rmr64; Rmr64 = tmp; resultflags(tmp); }
@endif

define pcodeop xabort;

:XABORT imm8     is vexMode=0 & byte=0xc6; byte=0xf8; imm8                         { tmp:1 = imm8; xabort(tmp); }

define pcodeop xbegin;
define pcodeop xend;

:XBEGIN rel16     is vexMode=0 & opsize=0 & byte=0xc7; byte=0xf8; rel16                      { xbegin(&:$(SIZE) rel16); }
:XBEGIN rel32     is vexMode=0 & (opsize=1 | opsize=2) & byte=0xc7; byte=0xf8; rel32         { xbegin(&:$(SIZE) rel32); }

:XEND            is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd5     { xend(); }

# See 'lockable.sinc' for memory destination, lockable variants
:XCHG   AX,Rmr16       is vexMode=0 & opsize=0 & row = 9 & page = 0 & AX & Rmr16        { local tmp = AX;     AX = Rmr16;     Rmr16 = tmp; }
:XCHG  EAX,Rmr32   is vexMode=0 & opsize=1 & row = 9 & page = 0 & EAX & check_EAX_dest & Rmr32 & check_Rmr32_dest      { local tmp = EAX;   EAX = Rmr32; build check_EAX_dest; Rmr32 = tmp; build check_Rmr32_dest; }
@ifdef IA64
:XCHG  RAX,Rmr64   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & row = 9 & page = 0 & RAX & Rmr64       { local tmp = RAX;   RAX = Rmr64;     Rmr64 = tmp; }
@endif

:XCHG  Rmr8,Reg8        is vexMode=0 & byte=0x86; mod=3 & Rmr8 & Reg8                { local tmp = Rmr8;   Rmr8 = Reg8;   Reg8 = tmp; }
:XCHG Rmr16,Reg16   is vexMode=0 & opsize=0 & byte=0x87; mod=3 & Rmr16 & Reg16        { local tmp = Rmr16; Rmr16 = Reg16; Reg16 = tmp; }
:XCHG Rmr32,Reg32   is vexMode=0 & opsize=1 & byte=0x87; mod=3 & Rmr32 & check_Rmr32_dest & Reg32 & check_Reg32_dest	{ local tmp = Rmr32; Rmr32 = Reg32; build check_Rmr32_dest; Reg32 = tmp; build check_Reg32_dest;}
@ifdef IA64
:XCHG Rmr64,Reg64   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x87; mod=3 & Rmr64 & Reg64        { local tmp = Rmr64; Rmr64 = Reg64; Reg64 = tmp; }
@endif

:XLAT seg16^BX      is vexMode=0 & addrsize=0 & seg16 & byte=0xd7; BX           { tmp:$(SIZE)= 0; ptr2(tmp,BX+zext(AL)); AL = *tmp; }
:XLAT segWide^EBX     is vexMode=0 & addrsize=1 & segWide & byte=0xd7; EBX          { tmp:$(SIZE)= 0; ptr4(tmp,EBX+zext(AL)); AL = *tmp; }
@ifdef IA64
:XLAT segWide^RBX     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & segWide & byte=0xd7; RBX          { tmp:$(SIZE)= 0; ptr8(tmp,RBX+zext(AL)); AL = *tmp; }
@endif

# See 'lockable.sinc' for memory destination, lockable variants
:XOR AL,imm8       is vexMode=0 & byte=0x34; AL & imm8                          { logicalflags();    AL =    AL ^  imm8; resultflags(   AL); }
:XOR AX,imm16      is vexMode=0 & opsize=0 & byte=0x35; AX & imm16              { logicalflags();    AX =    AX ^ imm16; resultflags(   AX); }
:XOR EAX,imm32     is vexMode=0 & opsize=1 & byte=0x35; EAX & imm32 & check_EAX_dest	{ logicalflags();  EAX = EAX ^ imm32; build check_EAX_dest; resultflags(  EAX);}
@ifdef IA64
:XOR RAX,simm32    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x35; RAX & simm32            { logicalflags();   RAX =   RAX ^ simm32; resultflags(  RAX); }
@endif
:XOR Rmr8,imm8      is vexMode=0 & $(BYTE_80_82); mod=3 & Rmr8 & reg_opcode=6; imm8     { logicalflags();   Rmr8 =   Rmr8 ^  imm8; resultflags(  Rmr8); }
:XOR Rmr16,imm16    is vexMode=0 & opsize=0 & byte=0x81; mod=3 & Rmr16 & reg_opcode=6; imm16  { logicalflags();  Rmr16 =  Rmr16 ^ imm16; resultflags( Rmr16); }
:XOR Rmr32,imm32    is vexMode=0 & opsize=1 & byte=0x81; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=6; imm32  { logicalflags();  Rmr32 =  Rmr32 ^ imm32; build check_rm32_dest; resultflags( Rmr32); }
@ifdef IA64
:XOR Rmr64,simm32   is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x81; mod=3 & Rmr64 & reg_opcode=6; simm32 { logicalflags();  Rmr64 =  Rmr64 ^ simm32; resultflags( Rmr64); }
@endif
:XOR Rmr16,usimm8_16    is vexMode=0 & opsize=0 & byte=0x83; mod=3 & Rmr16 & reg_opcode=6; usimm8_16  { logicalflags();  Rmr16 =  Rmr16 ^ usimm8_16; resultflags( Rmr16); }
:XOR Rmr32,usimm8_32    is vexMode=0 & opsize=1 & byte=0x83; mod=3 & Rmr32 & check_rm32_dest & reg_opcode=6; usimm8_32  { logicalflags();  Rmr32 =  Rmr32 ^ usimm8_32; build check_rm32_dest; resultflags( Rmr32); }
@ifdef IA64
:XOR Rmr64,usimm8_64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x83; mod=3 & Rmr64 & reg_opcode=6; usimm8_64  { logicalflags();  Rmr64 =  Rmr64 ^ usimm8_64; resultflags( Rmr64); }
@endif
:XOR Rmr8,Reg8      is vexMode=0 & byte=0x30; mod=3 & Rmr8 & Reg8                     { logicalflags();   Rmr8 =   Rmr8 ^  Reg8; resultflags(  Rmr8); }
:XOR Rmr16,Reg16    is vexMode=0 & opsize=0 & byte=0x31; mod=3 & Rmr16 & Reg16        { logicalflags();  Rmr16 =  Rmr16 ^ Reg16; resultflags( Rmr16); }
:XOR Rmr32,Reg32    is vexMode=0 & opsize=1 & byte=0x31; mod=3 & Rmr32 & check_Rmr32_dest & Reg32 { logicalflags();  Rmr32 =  Rmr32 ^ Reg32; build check_Rmr32_dest; resultflags( Rmr32); }
@ifdef IA64
:XOR Rmr64,Reg64    is vexMode=0 & $(LONGMODE_ON) & opsize=2 & byte=0x31; mod=3 & Rmr64 & Reg64        { logicalflags();  Rmr64 =  Rmr64 ^ Reg64; resultflags( Rmr64); }
@endif
:XOR Reg8,rm8      is vexMode=0 & byte=0x32; rm8 & Reg8 ...                     { logicalflags();  Reg8 =  Reg8 ^   rm8; resultflags( Reg8); }
:XOR Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x33; rm16 & Reg16 ...        { logicalflags(); Reg16 = Reg16 ^  rm16; resultflags(Reg16); }
:XOR Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x33; rm32 & Reg32 ... & check_Reg32_dest ... { logicalflags(); Reg32 = Reg32 ^  rm32; build check_Reg32_dest; resultflags(Reg32); }
@ifdef IA64
:XOR Reg64,rm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0x33; rm64 & Reg64 ...        { logicalflags(); Reg64 = Reg64 ^  rm64; resultflags(Reg64); }
@endif

:XGETBV         is vexMode=0 & byte=0x0F; byte=0x01; byte=0xD0  { local tmp = XCR0 >> 32; EDX = tmp:4;  EAX = XCR0:4; }
:XSETBV         is vexMode=0 & byte=0x0F; byte=0x01; byte=0xD1  { XCR0 = (zext(EDX) << 32) | zext(EAX); }

define pcodeop xsave;
define pcodeop xsave64;
define pcodeop xsavec;
define pcodeop xsavec64;
define pcodeop xsaveopt;
define pcodeop xsaveopt64;
define pcodeop xsaves;
define pcodeop xsaves64;
define pcodeop xrstor;
define pcodeop xrstor64;
define pcodeop xrstors;
define pcodeop xrstors64;

:XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
@ifdef IA64
:XRSTOR64 Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor64(Mem, tmp); }
@endif

:XRSTORS Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=3 ) ... & Mem { tmp:4 = 512; xrstors(Mem, tmp); }
@ifdef IA64
:XRSTORS64 Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=3 ) ... & Mem { tmp:4 = 512; xrstors64(Mem, tmp); }
@endif

:XSAVE  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsave(Mem, tmp); }
@ifdef IA64
:XSAVE64  Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsave64(Mem, tmp); }
@endif

:XSAVEC  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsavec(Mem, tmp); }
@ifdef IA64
:XSAVEC64  Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsavec64(Mem, tmp); }
@endif

:XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
@ifdef IA64
:XSAVEOPT64  Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt64(Mem, tmp); }
@endif

:XSAVES  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xsaves(Mem, tmp); }
@ifdef IA64
:XSAVES64  Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xsaves64(Mem, tmp); }
@endif

define pcodeop xtest;
:XTEST          is byte=0x0F; byte=0x01; byte=0xD6       { ZF = xtest(); }

:LFENCE         is vexMode=0 & $(PRE_NO) & byte=0x0F; byte=0xAE; mod = 0b11 & reg_opcode=5 & r_m=0 { }
:MFENCE         is vexMode=0 & $(PRE_NO) & byte=0x0F; byte=0xAE; mod = 0b11 & reg_opcode=6 & r_m=0 { }
:SFENCE         is vexMode=0 & $(PRE_NO) & byte=0x0F; byte=0xAE; mod = 0b11 & reg_opcode=7 & r_m=0 { }

#
# floating point instructions
#
define pcodeop f2xm1;
:F2XM1          is vexMode=0 & byte=0xD9; byte=0xF0                 { ST0 = f2xm1(ST0); } # compute 2^x-1

:FABS           is vexMode=0 & byte=0xD9; byte=0xE1                 { ST0 = abs(ST0); }

:FADD spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=0 ... & spec_m32                    { ST0 = ST0 f+ float2float(spec_m32); } 
:FADD spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=0 ... & spec_m64            { ST0 = ST0 f+ float2float(spec_m64); } 
:FADD ST0, freg     is vexMode=0 & byte=0xD8; frow=12 & fpage=0 & freg & ST0        { ST0 = ST0 f+ freg; }         
:FADD freg, ST0     is vexMode=0 & byte=0xDC; frow=12 & fpage=0 & freg & ST0        { freg = freg f+ ST0; }        
:FADDP              is vexMode=0 & byte=0xDE; byte=0xC1                 { ST1 = ST0 f+ ST1; fpop(); }      
:FADDP freg, ST0    is vexMode=0 & byte=0xDE; frow=12 & fpage=0 & freg & ST0        { freg = ST0 f+ freg; fpop(); }    
:FIADD spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=0 ... & spec_m32            { ST0 = ST0 f+ int2float(spec_m32); }   
:FIADD spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=0 ... & spec_m16            { ST0 = ST0 f+ int2float(spec_m16); }   

define pcodeop convert_bcd;
:FBLD  spec_m80     is vexMode=0 & byte=0xDF; reg_opcode=4 ... & spec_m80            { fdec(); ST0 = convert_bcd(spec_m80); }

:FBSTP spec_m80     is vexMode=0 & byte=0xDF; reg_opcode=6 ... & spec_m80            { spec_m80 = convert_bcd(ST0); fpop(); }

:FCHS           is vexMode=0 & byte=0xD9; byte=0xE0                 { ST0 = f- ST0; }

:FCLEX          is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE2      { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; }
:FNCLEX         is vexMode=0 & byte=0xDB; byte=0xE2                 { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; } 

:FCMOVB ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=0 & freg & ST0        { if ( !CF ) goto inst_next; ST0 = freg; }   
:FCMOVE ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=1 & freg & ST0        { if ( !ZF ) goto inst_next; ST0 = freg; }   
:FCMOVBE ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=0 & freg & ST0        { if ( !CF & !ZF ) goto inst_next; ST0 = freg; } 
:FCMOVU  ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=1 & freg & ST0        { if ( !PF ) goto inst_next; ST0 = freg; }   
:FCMOVNB ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=0 & freg & ST0        { if ( CF ) goto inst_next; ST0 = freg; }    
:FCMOVNE ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=1 & freg & ST0        { if ( ZF ) goto inst_next; ST0 = freg; }    
:FCMOVNBE ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=0 & freg & ST0        { if ( CF & ZF ) goto inst_next; ST0 = freg; }   
:FCMOVNU  ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=1 & freg & ST0        { if ( PF ) goto inst_next; ST0 = freg; }    
                                                                 
:FCOM spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=2 ... & spec_m32            { local tmp=float2float(spec_m32); fcom(tmp); }         
:FCOM spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=2 ... & spec_m64            { local tmp=float2float(spec_m64); fcom(tmp); }         
:FCOM freg      is vexMode=0 & byte=0xD8; frow=13 & fpage=0 & freg          { fcom(freg); }                  
:FCOM           is vexMode=0 & byte=0xD8; byte=0xD1                 { fcom(ST1); }                   
:FCOMP spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=3 ... & spec_m32            { local tmp=float2float(spec_m32); fcom(tmp); fpop(); }     
:FCOMP spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=3 ... & spec_m64            { local tmp=float2float(spec_m64); fcom(tmp); fpop(); }     
:FCOMP freg     is vexMode=0 & byte=0xD8; frow=13 & fpage=1 & freg          { fcom(freg); fpop(); }              
:FCOMP          is vexMode=0 & byte=0xD8; byte=0xD9                 { fcom(ST1); fpop(); }               
:FCOMPP         is vexMode=0 & byte=0xDE; byte=0xD9                 { fcom(ST1); fpop(); fpop(); }           
                                                                 
:FCOMI ST0, freg    is vexMode=0 & byte=0xDB; frow=15 & fpage=0 & freg & ST0        { fcomi(freg); }                 
:FCOMIP ST0, freg   is vexMode=0 & byte=0xDF; frow=15 & fpage=0 & freg & ST0        { fcomi(freg); fpop(); }             
:FUCOMI ST0, freg   is vexMode=0 & byte=0xDB; frow=14 & fpage=1 & freg & ST0        { fcomi(freg); }                 
:FUCOMIP ST0, freg  is vexMode=0 & byte=0xDF; frow=14 & fpage=1 & freg & ST0        { fcomi(freg); fpop(); }             
                                                                 
define pcodeop fcos;
:FCOS			    is vexMode=0 & byte=0xD9; byte=0xFF					{ ST0 = fcos(ST0); }
                                                                 
:FDECSTP		    is vexMode=0 & byte=0xD9; byte=0xF6					{ fdec(); FPUStatusWord = FPUStatusWord & 0xfeff; C0 = 0; }  #Clear C0

# Legacy 8087 instructions. Still valid but treated as NOP instructions.
:FDISI              is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE1 {}
:FNDISI             is vexMode=0 & byte=0xDB; byte=0xE1            {}
:FENI               is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE0 {}
:FNENI              is vexMode=0 & byte=0xDB; byte=0xE0            {}

:FDIV spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=6 ... & spec_m32            { ST0 = ST0 f/ float2float(spec_m32); }    
:FDIV spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=6 ... & spec_m64            { ST0 = ST0 f/ float2float(spec_m64); }    
:FDIV ST0,freg      is vexMode=0 & byte=0xD8; frow=15 & fpage=0 & freg & ST0        { ST0 = ST0 f/ freg; }            
:FDIV freg,ST0      is vexMode=0 & byte=0xDC; frow=15 & fpage=1 & freg & ST0        { freg = freg f/ ST0; }           
:FDIVP freg,ST0     is vexMode=0 & byte=0xDE; frow=15 & fpage=1 & freg & ST0        { freg = ST0 f/ freg; fpop(); }       
:FDIVP              is vexMode=0 & byte=0xDE; byte=0xF9                 { ST1 = ST1 f/ ST0; fpop(); }         
:FIDIV spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=6 ... & spec_m32            { ST0 = ST0 f/ int2float(spec_m32); }      
:FIDIV spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=6 ... & spec_m16            { ST0 = ST0 f/ int2float(spec_m16); }      
                                                              
:FDIVR spec_m32     is vexMode=0 & byte=0xD8; reg_opcode=7 ... & spec_m32            { ST0 = float2float(spec_m32) f/ ST0; }    
:FDIVR spec_m64     is vexMode=0 & byte=0xDC; reg_opcode=7 ... & spec_m64            { ST0 = float2float(spec_m64) f/ ST0; }    
:FDIVR ST0,freg     is vexMode=0 & byte=0xD8; frow=15 & fpage=1 & freg & ST0        { ST0 = freg f/ ST0; }            
:FDIVR freg,ST0     is vexMode=0 & byte=0xDC; frow=15 & fpage=0 & freg & ST0        { freg = ST0 f/ freg; }           
:FDIVRP freg,ST0    is vexMode=0 & byte=0xDE; frow=15 & fpage=0 & freg & ST0        { freg = freg f/ ST0; fpop(); }       
:FDIVRP             is vexMode=0 & byte=0xDE; byte=0xF1                 { ST1 = ST0 f/ ST1; fpop(); }         
:FIDIVR spec_m32    is vexMode=0 & byte=0xDA; reg_opcode=7 ... & spec_m32            { ST0 = int2float(spec_m32) f/ ST0; }      
:FIDIVR spec_m16    is vexMode=0 & byte=0xDE; reg_opcode=7 ... & spec_m16            { ST0 = int2float(spec_m16) f/ ST0; }      

define pcodeop ffree;
:FFREE freg         is vexMode=0 & byte=0xDD; frow=12 & fpage=0 & freg          { FPUTagWord = ffree(freg); }  # Set freg to invalid value
:FFREEP freg        is vexMode=0 & byte=0xDF; frow=12 & fpage=0 & freg          { FPUTagWord = ffree(freg); fpop(); }  # FFREE and pop
                                                                  
:FICOM spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=2 ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); }          
:FICOM spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=2 ... & spec_m32            { local tmp = int2float(spec_m32); fcom(tmp); }          
:FICOMP spec_m16    is vexMode=0 & byte=0xDE; (mod != 0b11 & reg_opcode=3) ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); fpop(); }  
:FICOMP spec_m32    is vexMode=0 & byte=0xDA; reg_opcode=3 ... & spec_m32            { local tmp = int2float(spec_m32); fcom(tmp); fpop(); }  
                                                                  
:FILD spec_m16      is vexMode=0 & byte=0xDF; reg_opcode=0 ... & spec_m16            { fdec(); ST0 = int2float(spec_m16); }         
:FILD spec_m32      is vexMode=0 & byte=0xDB; reg_opcode=0 ... & spec_m32            { fdec(); ST0 = int2float(spec_m32); }         
:FILD spec_m64      is vexMode=0 & byte=0xDF; reg_opcode=5 ... & spec_m64            { fdec(); ST0 = int2float(spec_m64); }         
                                                                  
:FINCSTP            is vexMode=0 & byte=0xD9; byte=0xF7                 { finc(); }                                   

:FINIT              is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE3          {
										  FPUControlWord = 0x037f;        
                                          FPUStatusWord = 0x0000;         
                                          FPUTagWord = 0xffff;            
                                          FPUDataPointer = 0x00000000;        
                                          FPUInstructionPointer = 0x00000000;     
                                          FPULastInstructionOpcode = 0x0000;  
                                          C0 = 0;                 
                                          C1 = 0;                 
                                          C2 = 0;                 
                                          C3 = 0; }                           

:FNINIT         is vexMode=0 & byte=0xDB; byte=0xE3                 {
										  FPUControlWord = 0x037f;        
                                          FPUStatusWord = 0x0000;         
                                          FPUTagWord = 0xffff;            
                                          FPUDataPointer = 0x00000000;        
                                          FPUInstructionPointer = 0x00000000;     
                                          FPULastInstructionOpcode = 0x0000;  
                                          C0 = 0;                 
                                          C1 = 0;                 
                                          C2 = 0;                 
                                          C3 = 0; }          

:FIST spec_m16       is vexMode=0 & byte=0xDF; (mod != 0b11 & reg_opcode=2) ... & spec_m16            { tmp:10 = round(ST0); spec_m16 = trunc(tmp); }                    
:FIST spec_m32       is vexMode=0 & byte=0xDB; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { tmp:10 = round(ST0); spec_m32 = trunc(tmp); }            
:FISTP spec_m16      is vexMode=0 & byte=0xDF; reg_opcode=3 ... & spec_m16            { tmp:10 = round(ST0); fpop(); spec_m16 = trunc(tmp); }                
:FISTP spec_m32      is vexMode=0 & byte=0xDB; reg_opcode=3 ... & spec_m32            { tmp:10 = round(ST0); fpop(); spec_m32 = trunc(tmp); }                
:FISTP spec_m64      is vexMode=0 & byte=0xDF; reg_opcode=7 ... & spec_m64            { tmp:10 = round(ST0); fpop(); spec_m64 = trunc(tmp); }                

:FISTTP spec_m16     is vexMode=0 & byte=0xDF; reg_opcode=1 ... & spec_m16            { spec_m16 = trunc(ST0); fpop(); }                 
:FISTTP spec_m32     is vexMode=0 & byte=0xDB; reg_opcode=1 ... & spec_m32            { spec_m32 = trunc(ST0); fpop(); }                 
:FISTTP spec_m64     is vexMode=0 & byte=0xDD; reg_opcode=1 ... & spec_m64            { spec_m64 = trunc(ST0); fpop(); }                 
                                                                      
:FLD spec_m32        is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=0) ... & spec_m32            { fdec(); ST0 = float2float(spec_m32); }           
:FLD spec_m64        is vexMode=0 & byte=0xDD; reg_opcode=0 ... & spec_m64            { fdec(); ST0 = float2float(spec_m64);}            
:FLD spec_m80        is vexMode=0 & byte=0xDB; reg_opcode=5 ... & spec_m80            { fpushv(spec_m80); }                      

# Be careful that you don't clobber freg during fpushv, need a tmp to hold the value
:FLD freg       is vexMode=0 & byte=0xD9; frow=12 & fpage=0 & freg          { tmp:10 = freg; fpushv(tmp); }                     
                                                                      
:FLD1           is vexMode=0 & byte=0xD9; byte=0xE8                 { one:4 = 1; tmp:10 = int2float(one); fpushv(tmp); }  
:FLDL2T		is vexMode=0 & byte=0xD9; byte=0xE9			{ src:8 = 0x400a934f0979a371; tmp:10 = float2float(src); fpushv(tmp); }
:FLDL2E		is vexMode=0 & byte=0xD9; byte=0xEA			{ src:8 = 0x3ff71547652b82fe; tmp:10 = float2float(src); fpushv(tmp); }
:FLDPI		is vexMode=0 & byte=0xD9; byte=0xEB			{ src:8 = 0x400921fb54442d18; tmp:10 = float2float(src); fpushv(tmp); }
:FLDLG2		is vexMode=0 & byte=0xD9; byte=0xEC			{ src:8 = 0x3fd34413509f79ff; tmp:10 = float2float(src); fpushv(tmp); }
:FLDLN2		is vexMode=0 & byte=0xD9; byte=0xED			{ src:8 = 0x3fe62e42fefa39ef; tmp:10 = float2float(src); fpushv(tmp); }
:FLDZ		is vexMode=0 & byte=0xD9; byte=0xEE			{ zero:4 = 0; tmp:10 = int2float(zero); fpushv(tmp); }

:FLDCW m16      is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=5) ... & m16            { FPUControlWord = m16; }

define pcodeop fldenv;
:FLDENV Mem     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=4) ... & Mem
{
  FPUControlWord           = *:2 (Mem);
  FPUStatusWord            = *:2 (Mem +  4);
  FPUTagWord               = *:2 (Mem +  8);
  FPUDataPointer           = *:4 (Mem + 20);
  FPUInstructionPointer    = *:4 (Mem + 12);
  FPULastInstructionOpcode = *:2 (Mem + 18);
}

:FMUL spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=1 ... & spec_m32            { ST0 = ST0 f* float2float(spec_m32); }  
:FMUL spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=1 ... & spec_m64            { ST0 = ST0 f* float2float(spec_m64); }  
:FMUL freg      is vexMode=0 & byte=0xD8; frow=12 & fpage=1 & freg          { ST0 = ST0 f* freg; }          
:FMUL freg      is vexMode=0 & byte=0xDC; frow=12 & fpage=1 & freg          { freg = freg f* ST0; }         
:FMULP freg     is vexMode=0 & byte=0xDE; frow=12 & fpage=1 & freg          { freg = ST0 f* freg; fpop(); }     
:FMULP          is vexMode=0 & byte=0xDE; byte=0xC9                         { ST1 = ST0 f* ST1; fpop(); }       
:FIMUL spec_m32      is vexMode=0 & byte=0xDA; reg_opcode=1 ... & spec_m32            { ST0 = ST0 f* int2float(spec_m32); }    
:FIMUL spec_m16      is vexMode=0 & byte=0xDE; reg_opcode=1 ... & spec_m16            { ST0 = ST0 f* int2float(spec_m16); }    

:FNOP           is vexMode=0 & byte=0xD9; byte=0xD0                 { }

define pcodeop fpatan;
:FPATAN		is vexMode=0 & byte=0xD9; byte=0xF3			{ ST1 = fpatan(ST1, ST0); fpop(); }

:FPREM          is vexMode=0 & byte=0xD9; byte=0xF8                 { local tmp = ST0 f/ ST1; tmp = tmp f* ST1; ST0 = ST0 f- tmp; }

:FPREM1         is vexMode=0 & byte=0xD9; byte=0xF5                 { local tmp = ST0 f/ ST1; tmp = tmp f* ST1; ST0 = ST0 f- tmp; }

define pcodeop fptan;
:FPTAN		is vexMode=0 & byte=0xD9; byte=0xF2			{ ST0 = fptan(ST0); one:4 = 1; tmp:10 = int2float(one); fpushv(tmp); }

:FRNDINT        is vexMode=0 & byte=0xD9; byte=0xFC                 { local tmp = round(ST0); ST0 = tmp; }

:FRSTOR Mem     is vexMode=0 & byte=0xDD; reg_opcode=4 ... & Mem
{
  FPUControlWord           = *:2  (Mem);
  FPUStatusWord            = *:2  (Mem +  4);
  FPUTagWord               = *:2  (Mem +  8);
  FPUDataPointer           = *:4  (Mem + 20);
  FPUInstructionPointer    = *:4  (Mem + 12);
  FPULastInstructionOpcode = *:2  (Mem + 18);

  ST0                      = *:10 (Mem + 28);
  ST1                      = *:10 (Mem + 38);
  ST2                      = *:10 (Mem + 48);
  ST3                      = *:10 (Mem + 58);
  ST4                      = *:10 (Mem + 68);
  ST5                      = *:10 (Mem + 78);
  ST6                      = *:10 (Mem + 88);
  ST7                      = *:10 (Mem + 98);
}

:FSAVE Mem      is vexMode=0 & byte=0x9B; byte=0xDD; reg_opcode=6 ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;

  *:10 (Mem + 28) = ST0;
  *:10 (Mem + 38) = ST1;
  *:10 (Mem + 48) = ST2;
  *:10 (Mem + 58) = ST3;
  *:10 (Mem + 68) = ST4;
  *:10 (Mem + 78) = ST5;
  *:10 (Mem + 88) = ST6;
  *:10 (Mem + 98) = ST7;

  FPUControlWord = 0x037f;
  FPUStatusWord = 0x0000;
  FPUTagWord = 0xffff;
  FPUDataPointer = 0x00000000;
  FPUInstructionPointer = 0x00000000;
  FPULastInstructionOpcode = 0x0000;
}

:FNSAVE Mem     is vexMode=0 & byte=0xDD; reg_opcode=6 ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;

  *:10 (Mem + 28) = ST0;
  *:10 (Mem + 38) = ST1;
  *:10 (Mem + 48) = ST2;
  *:10 (Mem + 58) = ST3;
  *:10 (Mem + 68) = ST4;
  *:10 (Mem + 78) = ST5;
  *:10 (Mem + 88) = ST6;
  *:10 (Mem + 98) = ST7;

  FPUControlWord = 0x037f;
  FPUStatusWord = 0x0000;
  FPUTagWord = 0xffff;
  FPUDataPointer = 0x00000000;
  FPUInstructionPointer = 0x00000000;
  FPULastInstructionOpcode = 0x0000;
}

define pcodeop fscale;
:FSCALE		    is vexMode=0 & byte=0xD9; byte=0xFD			{ ST0 = fscale(ST0, ST1); }

define pcodeop fsin;
:FSIN		    is vexMode=0 & byte=0xD9; byte=0xFE			{ ST0 = fsin(ST0); }
:FSINCOS	    is vexMode=0 & byte=0xD9; byte=0xFB			{ tmp:10 = fcos(ST0); ST0 = fsin(ST0); fpushv(tmp); }
:FSQRT          is vexMode=0 & byte=0xD9; byte=0xFA                 { ST0 = sqrt(ST0); }

:FST spec_m32   is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { spec_m32 = float2float(ST0); }     
:FST spec_m64   is vexMode=0 & byte=0xDD; reg_opcode=2 ... & spec_m64            { spec_m64 = float2float(ST0); }     
:FST freg       is vexMode=0 & byte=0xDD; frow=13 & fpage=0 & freg          { freg = ST0; }             
:FSTP spec_m32  is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=3) ... & spec_m32            { spec_m32 = float2float(ST0); fpop(); } 
:FSTP spec_m64  is vexMode=0 & byte=0xDD; reg_opcode=3 ... & spec_m64            { spec_m64 = float2float(ST0); fpop(); } 
:FSTP spec_m80  is vexMode=0 & byte=0xDB; reg_opcode=7 ... & spec_m80            { fpopv(spec_m80); }             
:FSTP freg      is vexMode=0 & byte=0xDD; frow=13 & fpage=1 & freg          { fpopv(freg); }                    

:FSTCW m16      is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16     { m16 = FPUControlWord; }
:FNSTCW m16     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16            { m16 = FPUControlWord; }

:FSTENV Mem     is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}

:FNSTENV Mem    is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}

:FSTSW m16      is vexMode=0 & byte=0x9B; byte=0xDD; reg_opcode=7 ... & m16     { m16 = FPUStatusWord; }
:FSTSW AX       is vexMode=0 & byte=0x9B; byte=0xDF; byte=0xE0 & AX         { AX = FPUStatusWord; }
:FNSTSW m16     is vexMode=0 & byte=0xDD; reg_opcode=7 ... & m16            { m16 = FPUStatusWord; }
:FNSTSW AX      is vexMode=0 & byte=0xDF; byte=0xE0 & AX                { AX = FPUStatusWord; }

:FSUB spec_m32  is vexMode=0 & byte=0xD8; reg_opcode=4 ... & spec_m32            { ST0 = ST0 f- float2float(spec_m32); }          
:FSUB spec_m64  is vexMode=0 & byte=0xDC; reg_opcode=4 ... & spec_m64            { ST0 = ST0 f- float2float(spec_m64); }          
:FSUB ST0,freg  is vexMode=0 & byte=0xD8; frow=14 & fpage=0 & freg & ST0        { ST0 = ST0 f- freg; }                  
:FSUB freg,ST0  is vexMode=0 & byte=0xDC; frow=14 & fpage=1 & freg & ST0        { freg = freg f- ST0; }                 
:FSUBP          is vexMode=0 & byte=0xDE; byte=0xE9                 { ST1 = ST1 f- ST0; fpop(); }               
:FSUBP freg,ST0 is vexMode=0 & byte=0xDE; frow=14 & fpage=1 & freg & ST0        { freg = freg f- ST0; fpop(); }             
:FISUB spec_m32 is vexMode=0 & byte=0xDA; (mod != 0b11 & reg_opcode=4) ... & spec_m32            { ST0 = ST0 f- int2float(spec_m32); }            
:FISUB spec_m16 is vexMode=0 & byte=0xDE; reg_opcode=4 ... & spec_m16            { ST0 = ST0 f- int2float(spec_m16); }            
                                                                    
:FSUBR spec_m32  is vexMode=0 & byte=0xD8; reg_opcode=5 ... & spec_m32           { ST0 = float2float(spec_m32) f- ST0; }          
:FSUBR spec_m64  is vexMode=0 & byte=0xDC; reg_opcode=5 ... & spec_m64           { ST0 = float2float(spec_m64) f- ST0; }          
:FSUBR ST0,freg  is vexMode=0 & byte=0xD8; frow=14 & fpage=1 & freg & ST0       { ST0 = freg f- ST0; }                  
:FSUBR freg,ST0  is vexMode=0 & byte=0xDC; frow=14 & fpage=0 & freg & ST0       { freg = ST0 f- freg; }                 
:FSUBRP          is vexMode=0 & byte=0xDE; byte=0xE1                    { ST1 = ST0 f- ST1; fpop(); }               
:FSUBRP freg,ST0 is vexMode=0 & byte=0xDE; frow=14 & fpage=0 & freg & ST0       { freg = ST0 f- freg; fpop(); }             
:FISUBR spec_m32 is vexMode=0 & byte=0xDA; reg_opcode=5 ... & spec_m32           { ST0 = int2float(spec_m32) f- ST0; }            
:FISUBR spec_m16 is vexMode=0 & byte=0xDE; reg_opcode=5 ... & spec_m16           { ST0 = int2float(spec_m16) f- ST0; }            
                                                                    
:FTST           is vexMode=0 & byte=0xD9; byte=0xE4                 { zero:4 = 0; tmp:10 = int2float(zero); fcom(tmp); }    
                                                                    
:FUCOM freg     is vexMode=0 & byte=0xDD; frow=14 & fpage=0 & freg          { fcom(freg); }                     
:FUCOM          is vexMode=0 & byte=0xDD; byte=0xE1                 { fcom(ST1); }                      
:FUCOMP freg    is vexMode=0 & byte=0xDD; frow=14 & fpage=1 & freg          { fcom(freg); fpop(); }                 
:FUCOMP         is vexMode=0 & byte=0xDD; byte=0xE9                 { fcom(ST1); fpop(); }                  
:FUCOMPP        is vexMode=0 & byte=0xDA; byte=0xE9                 { fcom(ST1); fpop(); fpop(); }                  
                                                                    
:FXAM           is vexMode=0 & byte=0xD9; byte=0xE5
{
  # this is not an exact implementation, but gets the sign and zero tests right
  izero:4 = 0;
  fzero:10 = int2float(izero);
  
  # did not know how test for infinity or empty
  C0 = nan(ST0);
  
  # sign of ST0
  C1 = ( ST0 f< fzero );

  # assume normal if not zero 
  C2 = ( ST0 f!= fzero );

  # equal to zero  
  C3 = ( ST0 f== fzero );
  
  FPUStatusWord = (zext(C0)<<8) | (zext(C1)<<9) | (zext(C2)<<10) | (zext(C3)<<14);
}
                                                                    
:FXCH freg      is vexMode=0 & byte=0xD9; frow=12 & fpage=1 & freg          { local tmp = ST0; ST0 = freg; freg = tmp; }          
:FXCH           is vexMode=0 & byte=0xD9; byte=0xC9                 { local tmp = ST0; ST0 = ST1; ST1 = tmp; }                    

# fxsave and fxrstor

@ifdef ICICLE
macro _fxsave(Mem) {
# not saved in the same spacing as the actual processor
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  2) = FPUStatusWord;
  *:2  (Mem +  4) = FPUTagWord; #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  *:2  (Mem +  6) = FPULastInstructionOpcode;
  *:4  (Mem +  8) = FPUInstructionPointer;
  *:2  (Mem + 12) = FPUPointerSelector;
  *:4  (Mem + 16) = FPUDataPointer;
  *:2  (Mem + 20) = FPUDataSelector;
  *:4  (Mem + 24) = MXCSR;
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  *:10 (Mem +  32) = ST0;
  *:10 (Mem +  48) = ST1;
  *:10 (Mem +  64) = ST2;
  *:10 (Mem +  80) = ST3;
  *:10 (Mem +  96) = ST4;
  *:10 (Mem + 112) = ST5;
  *:10 (Mem + 128) = ST6;
  *:10 (Mem + 144) = ST7;

  *:16 (Mem + 160) = XMM0;
  *:16 (Mem + 176) = XMM1;
  *:16 (Mem + 192) = XMM2;
  *:16 (Mem + 208) = XMM3;
  *:16 (Mem + 224) = XMM4;
  *:16 (Mem + 240) = XMM5;
  *:16 (Mem + 256) = XMM6;
  *:16 (Mem + 272) = XMM7;
@ifdef IA64
  *:16 (Mem + 288) = XMM8;
  *:16 (Mem + 304) = XMM9;
  *:16 (Mem + 320) = XMM10;
  *:16 (Mem + 336) = XMM11;
  *:16 (Mem + 352) = XMM12;
  *:16 (Mem + 368) = XMM13;
  *:16 (Mem + 384) = XMM14;
  *:16 (Mem + 400) = XMM15;
@endif
}
@else
define pcodeop _fxsave;
@endif

@ifdef ICICLE
macro _fxrstor(Mem) {
FPUControlWord           = *:2  (Mem);
  FPUStatusWord            = *:2  (Mem +  2);
  FPUTagWord               = *:2  (Mem +  4); #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  FPULastInstructionOpcode = *:2  (Mem +  6);
  FPUInstructionPointer    = *:4  (Mem +  8);
  FPUPointerSelector       = *:2  (Mem + 12);
  FPUDataPointer           = *:4  (Mem + 16);
  FPUDataSelector          = *:2  (Mem + 20);
  MXCSR                    = *:4  (Mem + 24);
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  ST0 = *:10 (Mem +  32);
  ST1 = *:10 (Mem +  48);
  ST2 = *:10 (Mem +  64);
  ST3 = *:10 (Mem +  80);
  ST4 = *:10 (Mem +  96);
  ST5 = *:10 (Mem + 112);
  ST6 = *:10 (Mem + 128);
  ST7 = *:10 (Mem + 144);


  XMM0 = *:16 (Mem + 160);
  XMM1 = *:16 (Mem + 176);
  XMM2 = *:16 (Mem + 192);
  XMM3 = *:16 (Mem + 208);
  XMM4 = *:16 (Mem + 224);
  XMM5 = *:16 (Mem + 240);
  XMM6 = *:16 (Mem + 256);
  XMM7 = *:16 (Mem + 272);
@ifdef IA64
  XMM8 = *:16 (Mem + 288);
  XMM9 = *:16 (Mem + 304);
  XMM10 = *:16 (Mem + 320);
  XMM11 = *:16 (Mem + 336);
  XMM12 = *:16 (Mem + 352);
  XMM13 = *:16 (Mem + 368);
  XMM14 = *:16 (Mem + 384);
  XMM15 = *:16 (Mem + 400);
@endif
}
@else
define pcodeop _fxrstor;
@endif

@ifdef IA64
define pcodeop _fxsave64;
define pcodeop _fxrstor64;
@endif

# this saves the FPU state into 512 bytes of memory
:FXSAVE Mem    is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=0 ) ... & Mem
{
  _fxsave(Mem);
}

:FXRSTOR Mem   is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=1 ) ... & Mem
{
  _fxrstor(Mem);
}

@ifdef IA64
# this saves the FPU state into 512 bytes of memory similar to the 32-bit mode
:FXSAVE Mem    is $(LONGMODE_ON) & vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=0 ) ... & Mem
{
  _fxsave(Mem);
}

:FXSAVE64 Mem    is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=0 ) ... & Mem
{
  _fxsave64(Mem);
}

:FXRSTOR Mem   is $(LONGMODE_ON) & vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=1 ) ... & Mem
{
  _fxrstor(Mem);
}

:FXRSTOR64 Mem   is $(LONGMODE_ON) & vexMode=0 & $(REX_W) & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=1 ) ... & Mem
{
  _fxrstor64(Mem);
}
@endif

:FXTRACT        is vexMode=0 & byte=0xD9; byte=0xF4                 { significand:10 = ST0; exponent:10 = ST0; ST0 = exponent; fpushv(significand); }

:FYL2X          is vexMode=0 & byte=0xD9; byte=0xF1                 { local log2st0 = ST0; ST1 = ST1 f* log2st0; fpop(); }
:FYL2XP1        is vexMode=0 & byte=0xD9; byte=0xF9                 { one:4 = 1; tmp:10 = int2float(one); log2st0:10 = ST0 f+ tmp; ST1 = ST1 f* log2st0; fpop(); }


#
# MMX instructions
#

:ADDPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; XmmReg ... & m128
{
    XmmReg[0,64]  = XmmReg[0,64]  f+ m128[0,64];
    XmmReg[64,64] = XmmReg[64,64] f+ m128[64,64];
}

:ADDPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64]  = XmmReg1[0,64]  f+ XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f+ XmmReg2[64,64];
}

:ADDPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x58; m128 & XmmReg ...
{
    local m:16 = m128;	# Guarantee value is in a fixed location
    XmmReg[0,32] = XmmReg[0,32] f+ m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f+ m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f+ m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f+ m[96,32];
}

:ADDPS        XmmReg1, XmmReg2 is vexMode=0 & mandover=0 & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f+ XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f+ XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f+ XmmReg2[96,32];
}

:ADDSD        XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x58; m64 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[0,64] f+ m64;
}

:ADDSD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f+ XmmReg2[0,64];
}

:ADDSS        XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x58; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f+ m32;
}

:ADDSS        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg2[0,32];
}

:ADDSUBPD     XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xD0; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f+ m[64,64];
}

:ADDSUBPD     XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xD0; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f+ XmmReg2[64,64];
}

:ADDSUBPS     XmmReg, m128     is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xD0; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f- m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f+ m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f- m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f+ m[96,32];
}

:ADDSUBPS     XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xD0; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f+ XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f- XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f+ XmmReg2[96,32];
}

# special FLOATING POINT bitwise AND
:ANDPD  XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x54; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] & m[0,64];
    XmmReg[64,64] = XmmReg[64,64] & m[64,64];
}

# special FLOATING POINT bitwise AND
:ANDPD  XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x54; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] & XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] & XmmReg2[64,64];
}

# special FLOATING POINT bitwise AND
:ANDPS        XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x54; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] & m[0,32];
    XmmReg[32,32] = XmmReg[32,32] & m[32,32];
    XmmReg[64,32] = XmmReg[64,32] & m[64,32];
    XmmReg[96,32] = XmmReg[96,32] & m[96,32];
}

# special FLOATING POINT bitwise AND
:ANDPS        XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x54; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] & XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] & XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] & XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] & XmmReg2[96,32];
}

# special FLOATING POINT bitwise AND NOT
:ANDNPD       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x55; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = ~XmmReg[0,64] & m[0,64];
    XmmReg[64,64] = ~XmmReg[64,64] & m[64,64];
}

:ANDNPD       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x55; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = ~XmmReg1[0,64] & XmmReg2[0,64];
    XmmReg1[64,64] = ~XmmReg1[64,64] & XmmReg2[64,64];
}

# special FLOATING POINT bitwise AND NOT
:ANDNPS       XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x55; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = ~XmmReg[0,32] & m[0,32];
    XmmReg[32,32] = ~XmmReg[32,32] & m[32,32];
    XmmReg[64,32] = ~XmmReg[64,32] & m[64,32];
    XmmReg[96,32] = ~XmmReg[96,32] & m[96,32];
}

:ANDNPS       XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x55; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = ~XmmReg1[0,32] & XmmReg2[0,32];
    XmmReg1[32,32] = ~XmmReg1[32,32] & XmmReg2[32,32];
    XmmReg1[64,32] = ~XmmReg1[64,32] & XmmReg2[64,32];
    XmmReg1[96,32] = ~XmmReg1[96,32] & XmmReg2[96,32];
}

# predicate mnemonics for "CMP...PD" opcode
XmmCondPD: "EQ"      is imm8=0     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f== xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f== xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "LT"      is imm8=1     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f< xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f< xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "LE"      is imm8=2     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f<= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f<= xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "UNORD"   is imm8=3     {
    xmmTmp1_Qa = zext( nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( nan(xmmTmp1_Qb) || nan(xmmTmp2_Qb) ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "NEQ"     is imm8=4     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f!= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f!= xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "NLT"     is imm8=5     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f< xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( !(xmmTmp1_Qb f< xmmTmp2_Qb) ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "NLE"     is imm8=6     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f<= xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( !(xmmTmp1_Qb f<= xmmTmp2_Qb) ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondPD: "ORD"     is imm8=7     {
    xmmTmp1_Qa = zext( !(nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa)) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( !(nan(xmmTmp1_Qb) || nan(xmmTmp2_Qb)) ) * 0xFFFFFFFFFFFFFFFF;   
}

define pcodeop cmppd;
XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}

# immediate operand for "CMP...PD" opcode
# note: normally blank, "imm8" emits for all out of range cases
CMPPD_OPERAND:           is imm8<8 { }
CMPPD_OPERAND: ", "^imm8 is imm8   { }

:CMP^XmmCondPD^"PD"        XmmReg,m128^CMPPD_OPERAND      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; (m128 & XmmReg ...); XmmCondPD & CMPPD_OPERAND
{
    local m:16 = m128;
	xmmTmp1_Qa = XmmReg[0,64];
	xmmTmp1_Qb = XmmReg[64,64];

	xmmTmp2_Qa = m[0,64];
	xmmTmp2_Qb = m[64,64];

	build XmmCondPD;
	
	XmmReg[0,64] = xmmTmp1_Qa;
	XmmReg[64,64] = xmmTmp1_Qb;
}

:CMP^XmmCondPD^"PD"        XmmReg1,XmmReg2^CMPPD_OPERAND  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondPD & CMPPD_OPERAND 
{
	xmmTmp1_Qa = XmmReg1[0,64];
	xmmTmp1_Qb = XmmReg1[64,64];
	
	xmmTmp2_Qa = XmmReg2[0,64];
	xmmTmp2_Qb = XmmReg2[64,64];
	
	build XmmCondPD;
	
	XmmReg1[0,64] = xmmTmp1_Qa;
	XmmReg1[64,64] = xmmTmp1_Qb;
}


# predicate mnemonics for "CMP...PS" opcode
XmmCondPS: "EQ"      is imm8=0     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f== xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f== xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f== xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f== xmmTmp2_Dd ) * 0xFFFFFFFF;
}

XmmCondPS: "LT"      is imm8=1     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f< xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f< xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f< xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f< xmmTmp2_Dd ) * 0xFFFFFFFF;
}

XmmCondPS: "LE"      is imm8=2     {
    xmmTmp1_Da = zext( xmmTmp1_Da f<= xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f<= xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f<= xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f<= xmmTmp2_Dd ) * 0xFFFFFFFF;
}

XmmCondPS: "UNORD"   is imm8=3     {
    xmmTmp1_Da = zext( nan(xmmTmp1_Da) || nan(xmmTmp2_Da) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( nan(xmmTmp1_Db) || nan(xmmTmp2_Db) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( nan(xmmTmp1_Dc) || nan(xmmTmp2_Dc) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( nan(xmmTmp1_Dd) || nan(xmmTmp2_Dd) ) * 0xFFFFFFFF;
}

XmmCondPS: "NEQ"     is imm8=4     {
    xmmTmp1_Da = zext( xmmTmp1_Da f!= xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f!= xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f!= xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f!= xmmTmp2_Dd ) * 0xFFFFFFFF;
}

XmmCondPS: "NLT"     is imm8=5     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f< xmmTmp2_Da) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( !(xmmTmp1_Db f< xmmTmp2_Db) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( !(xmmTmp1_Dc f< xmmTmp2_Dc) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( !(xmmTmp1_Dd f< xmmTmp2_Dd) ) * 0xFFFFFFFF;
}

XmmCondPS: "NLE"     is imm8=6     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f<= xmmTmp2_Da) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( !(xmmTmp1_Db f<= xmmTmp2_Db) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( !(xmmTmp1_Dc f<= xmmTmp2_Dc) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( !(xmmTmp1_Dd f<= xmmTmp2_Dd) ) * 0xFFFFFFFF;
}

XmmCondPS: "ORD"     is imm8=7     {
    xmmTmp1_Da = zext( !(nan(xmmTmp1_Da) || nan(xmmTmp2_Da)) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( !(nan(xmmTmp1_Db) || nan(xmmTmp2_Db)) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( !(nan(xmmTmp1_Dc) || nan(xmmTmp2_Dc)) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( !(nan(xmmTmp1_Dd) || nan(xmmTmp2_Dd)) ) * 0xFFFFFFFF;
}

define pcodeop cmpps;
XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}

# immediate operand for "CMP...PS" opcode
# note: normally blank, "imm8" emits for all out of range cases
CMPPS_OPERAND:           is imm8<8 { }
CMPPS_OPERAND: ", "^imm8 is imm8   { }

:CMP^XmmCondPS^"PS"        XmmReg,m128^CMPPS_OPERAND      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC2; (m128 & XmmReg ...); XmmCondPS & CMPPS_OPERAND
{
    local m:16 = m128;
	xmmTmp1_Da = XmmReg[0,32];
	xmmTmp1_Db = XmmReg[32,32];
	xmmTmp1_Dc = XmmReg[64,32];
	xmmTmp1_Dd = XmmReg[96,32];

	xmmTmp2_Da = m[0,32];
	xmmTmp2_Db = m[32,32];
	xmmTmp2_Dc = m[64,32];
	xmmTmp2_Dd = m[96,32];

	build XmmCondPS;
	
	XmmReg[0,32] = xmmTmp1_Da;
	XmmReg[32,32] = xmmTmp1_Db;
	XmmReg[64,32] = xmmTmp1_Dc;
	XmmReg[96,32] = xmmTmp1_Dd;
}

:CMP^XmmCondPS^"PS"        XmmReg1,XmmReg2^CMPPS_OPERAND  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondPS & CMPPS_OPERAND 
{
	xmmTmp1_Da = XmmReg1[0,32];
	xmmTmp1_Db = XmmReg1[32,32];
	xmmTmp1_Dc = XmmReg1[64,32];
	xmmTmp1_Dd = XmmReg1[96,32];
	
	xmmTmp2_Da = XmmReg2[0,32];
	xmmTmp2_Db = XmmReg2[32,32];
	xmmTmp2_Dc = XmmReg2[64,32];
	xmmTmp2_Dc = XmmReg2[96,32];
	
	build XmmCondPS;
	
	XmmReg1[0,32] = xmmTmp1_Da;
	XmmReg1[32,32] = xmmTmp1_Db;
	XmmReg1[64,32] = xmmTmp1_Dc;
	XmmReg1[96,32] = xmmTmp1_Dd;
}


# predicate mnemonics for "CMP...SD" opcode
XmmCondSD: "EQ"      is imm8=0     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f== xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "LT"      is imm8=1     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f< xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "LE"      is imm8=2     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f<= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "UNORD"   is imm8=3     {
    xmmTmp1_Qa = zext( nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "NEQ"     is imm8=4     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f!= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "NLT"     is imm8=5     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f< xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "NLE"     is imm8=6     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f<= xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
}

XmmCondSD: "ORD"     is imm8=7     {
    xmmTmp1_Qa = zext( !(nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa)) ) * 0xFFFFFFFFFFFFFFFF;   
}


define pcodeop cmpsd;
XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}

# immediate operand for "CMP...SD" opcode
# note: normally blank, "imm8" emits for all out of range cases
CMPSD_OPERAND:           is imm8<8 { }
CMPSD_OPERAND: ", "^imm8 is imm8   { }

:CMP^XmmCondSD^"SD"  XmmReg, m64^CMPSD_OPERAND  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xC2; (m64 & XmmReg ...); XmmCondSD & CMPSD_OPERAND
{ 
	xmmTmp1_Qa = XmmReg[0,64];
	xmmTmp2_Qa = m64;
	build XmmCondSD;
	XmmReg[0,64] = xmmTmp1_Qa;
}

:CMP^XmmCondSD^"SD"  XmmReg1, XmmReg2^CMPSD_OPERAND  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondSD & CMPSD_OPERAND
{ 
	xmmTmp1_Qa = XmmReg1[0,64];
	xmmTmp2_Qa = XmmReg2[0,64];
	build XmmCondSD;
	XmmReg1[0,64] = xmmTmp1_Qa;
}


# predicate mnemonics for "CMP...SS" opcode
XmmCondSS: "EQ"      is imm8=0     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f== xmmTmp2_Da ) * 0xFFFFFFFF;   
}

XmmCondSS: "LT"      is imm8=1     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f< xmmTmp2_Da ) * 0xFFFFFFFF;   
}

XmmCondSS: "LE"      is imm8=2     {
    xmmTmp1_Da = zext( xmmTmp1_Da f<= xmmTmp2_Da ) * 0xFFFFFFFF;   
}

XmmCondSS: "UNORD"   is imm8=3     {
    xmmTmp1_Da = zext( nan(xmmTmp1_Da) || nan(xmmTmp2_Da) ) * 0xFFFFFFFF;   
}

XmmCondSS: "NEQ"     is imm8=4     {
    xmmTmp1_Da = zext( xmmTmp1_Da f!= xmmTmp2_Da ) * 0xFFFFFFFF;   
}

XmmCondSS: "NLT"     is imm8=5     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f< xmmTmp2_Da) ) * 0xFFFFFFFF;   
}

XmmCondSS: "NLE"     is imm8=6     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f<= xmmTmp2_Da) ) * 0xFFFFFFFF;   
}

XmmCondSS: "ORD"     is imm8=7     {
    xmmTmp1_Da = zext( !(nan(xmmTmp1_Da) || nan(xmmTmp2_Da)) ) * 0xFFFFFFFF;   
}


define pcodeop cmpss;
XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}

# immediate operand for "CMP...SS" opcode
# note: normally blank, "imm8" emits for all out of range cases
CMPSS_OPERAND:           is imm8<8 { }
CMPSS_OPERAND: ", "^imm8 is imm8   { }

:CMP^XmmCondSS^"SS"  XmmReg, m32^CMPSS_OPERAND  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xC2; (m32 & XmmReg ...); XmmCondSS & CMPSS_OPERAND
{ 
	xmmTmp1_Da = XmmReg[0,32];
	xmmTmp2_Da = m32;
	build XmmCondSS;
	XmmReg[0,32] = xmmTmp1_Da;
}

:CMP^XmmCondSS^"SS"  XmmReg1, XmmReg2^CMPSS_OPERAND  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondSS & CMPSS_OPERAND
{ 
	xmmTmp1_Da = XmmReg1[0,32];
	xmmTmp2_Da = XmmReg2[0,32];
	build XmmCondSS;
	XmmReg1[0,32] = xmmTmp1_Da;
}


:COMISD       XmmReg, m64   is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2F; m64 & XmmReg ...
{
  fucompe(XmmReg[0,64], m64);
}
  
:COMISD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2F; xmmmod=3 & XmmReg1 & XmmReg2
{
  fucompe(XmmReg1[0,64], XmmReg2[0,64]);
}

:COMISS       XmmReg, m32       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2F; m32 & XmmReg ...
{
  fucompe(XmmReg[0,32], m32);
}

:COMISS       XmmReg1, XmmReg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2F; xmmmod=3 & XmmReg1 & XmmReg2
{
  fucompe(XmmReg1[0,32], XmmReg2[0,32]);
}

:CVTDQ2PD     XmmReg, m64       is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0xE6; m64 & XmmReg ...
{
    local m:8 = m64;
    XmmReg[0,64] = int2float( m[0,32] );
    XmmReg[64,64] = int2float( m[32,32] );
}

:CVTDQ2PD     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0xE6; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = int2float( XmmReg2[0,32] );
    XmmReg1[64,64] = int2float( XmmReg2[32,32] );
}

:CVTDQ2PS     XmmReg, m128      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = int2float( m[0,32] );
    XmmReg[32,32] = int2float( m[32,32] );
    XmmReg[64,32] = int2float( m[64,32] );
    XmmReg[96,32] = int2float( m[96,32] );
}

:CVTDQ2PS     XmmReg1, XmmReg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = int2float( XmmReg2[0,32] );
    XmmReg1[32,32] = int2float( XmmReg2[32,32] );
    XmmReg1[64,32] = int2float( XmmReg2[64,32] );
    XmmReg1[96,32] = int2float( XmmReg2[96,32] );
}

:CVTPD2DQ     XmmReg, m128      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xE6; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = trunc( m[0,64] );
    XmmReg[32,32] = trunc( m[64,64] );
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}

:CVTPD2DQ     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xE6; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = trunc( XmmReg2[0,64] );
    XmmReg1[32,32] = trunc( XmmReg2[64,64] );
    XmmReg1[64,32] = 0;
    XmmReg1[96,32] = 0;
}

:CVTPD2PI     mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; mmxreg ... & m128
{
    local m:16 = m128;
    mmxreg[0,32] = trunc( m[0,64] );
    mmxreg[32,32] = trunc( m[64,64] );
}

:CVTPD2PI     mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; xmmmod=3 & mmxreg1 & XmmReg2
{
    mmxreg1[0,32] = trunc( XmmReg2[0,64] );
    mmxreg1[32,32] = trunc( XmmReg2[64,64] );
}

:CVTPD2PS     XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = float2float( m[0,64] );
    XmmReg[32,32] = float2float( m[64,64] );
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}

:CVTPD2PS     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = float2float( XmmReg2[0,64] );
    XmmReg1[32,32] = float2float( XmmReg2[64,64] );
    XmmReg1[64,32] = 0;
    XmmReg1[96,32] = 0;
}

:CVTPI2PD     XmmReg, m64       is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2A; m64 & XmmReg ...
{
  local m:8 = m64;
  XmmReg[0,64] =  int2float(m[0,32]);
  XmmReg[64,64] =  int2float(m[32,32]);
}

:CVTPI2PD     XmmReg1, mmxreg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2A; xmmmod=3 & XmmReg1 & mmxreg2
{
  XmmReg1[0,64] = int2float(mmxreg2[0,32]);
  XmmReg1[64,64] = int2float(mmxreg2[32,32]);
}

:CVTPI2PS     XmmReg, m64       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2A; m64 & XmmReg ...
{
  local m:8 = m64;
  XmmReg[0,32] = int2float(m[0,32]);
  XmmReg[32,32] = int2float(m[32,32]);
}

:CVTPI2PS     XmmReg1, mmxreg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2A; xmmmod=3 & XmmReg1 & mmxreg2
{
  XmmReg1[0,32] = int2float(mmxreg2[0,32]);
  XmmReg1[32,32] = int2float(mmxreg2[32,32]);
}

:CVTPS2DQ      XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = trunc( m[0,32] );
    XmmReg[32,32] = trunc( m[32,32] );
    XmmReg[64,32] = trunc( m[64,32] );
    XmmReg[96,32] = trunc( m[96,32] );
}

:CVTPS2DQ      XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = trunc( XmmReg2[0,32] );
    XmmReg1[32,32] = trunc( XmmReg2[32,32] );
    XmmReg1[64,32] = trunc( XmmReg2[64,32] );
    XmmReg1[96,32] = trunc( XmmReg2[96,32] );
}

:CVTPS2PD     XmmReg, m64       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5A; m64 & XmmReg ...
{
    local m:8 = m64;
    XmmReg[0,64] = float2float( m[0,32] );
    XmmReg[64,64] = float2float( m[32,32] );
}

:CVTPS2PD     XmmReg1, XmmReg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = float2float( XmmReg2[0,32] );
    XmmReg1[64,64] = float2float( XmmReg2[32,32] );
}

:CVTPS2PI     mmxreg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2D; mmxreg ... & m64
{
  local m:8 = m64;
  mmxreg[0,32] = round(m[0,32]);
  mmxreg[32,32] = round(m[32,32]);
  FPUTagWord = 0x0000;         
}

:CVTPS2PI     mmxreg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2D; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = round(XmmReg2[0,32]);
  mmxreg1[32,32] = round(XmmReg2[32,32]);
  FPUTagWord = 0x0000;         
}

:CVTSD2SI     Reg32, m64    is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2D; Reg32 ... & m64
{
  Reg32 = trunc(round(m64));
}

:CVTSD2SI     Reg32, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = trunc(round(XmmReg2[0,64]));
}

@ifdef IA64
:CVTSD2SI     Reg64, m64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F2) & byte=0x0F; byte=0x2D; Reg64 ... & m64
{
  Reg64 = round(m64);
}

:CVTSD2SI     Reg64, XmmReg2 is vexMode=0 & opsize=2 & $(PRE_F2) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg64 & XmmReg2
{
  Reg64 = round(XmmReg2[0,64]);
}
@endif

:CVTSD2SS     XmmReg, m64       is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5A; m64 & XmmReg ...
{
  XmmReg[0,32] = float2float(m64);
}

:CVTSD2SS     XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = float2float(XmmReg2[0,64]);
}

:CVTSI2SD     XmmReg, rm32    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,64] = int2float(rm32);
}

@ifdef IA64
:CVTSI2SD     XmmReg, rm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F2) & byte=0x0F; byte=0x2A; rm64 & XmmReg ...
{
  XmmReg[0,64] = int2float(rm64);
}
@endif

:CVTSI2SS     XmmReg, rm32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,32] = int2float(rm32);
}

@ifdef IA64
:CVTSI2SS     XmmReg, rm64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0F; byte=0x2A; rm64 & XmmReg ...
{
  XmmReg[0,32] = int2float(rm64);
}
@endif

:CVTSS2SD     XmmReg, m32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5A; m32 & XmmReg ...
{
  XmmReg[0,64] = float2float(m32);
}

:CVTSS2SD     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,64] = float2float(XmmReg2[0,32]);
}

:CVTSS2SI     Reg32, m32    is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2D; Reg32 ... & m32
{
  Reg32 = round(m32);
}

:CVTSS2SI     Reg32, XmmReg2 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = round(XmmReg2[0,32]);
}

@ifdef IA64
:CVTSS2SI     Reg64, m32    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0F; byte=0x2D; Reg64 ... & m32
{
  Reg64 = trunc(round(m32));
}

:CVTSS2SI     Reg64, XmmReg2 is vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg64 & XmmReg2
{
  Reg64 = trunc(round(XmmReg2[0,32]));
}
@endif
                
:CVTTPD2PI    mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; mmxreg ... & m128
{
  local m:16 = m128;
  mmxreg[0,32] = trunc(m[0,64]);
  mmxreg[32,32] = trunc(m[64,64]);
  FPUTagWord = 0x0000;         
}

:CVTTPD2PI    mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = trunc(XmmReg2[0,64]);
  mmxreg1[32,32] = trunc(XmmReg2[64,64]);
  FPUTagWord = 0x0000;         
}

:CVTTPD2DQ    XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE6; m128 & XmmReg ...
{
  local m:16 = m128;
  XmmReg[0,32] = trunc(m[0,64]);
  XmmReg[32,32] = trunc(m[64,64]);
  XmmReg[64,32] = 0;
  XmmReg[96,32] = 0;
}

:CVTTPD2DQ    XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE6; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = trunc(XmmReg2[0,64]);
  XmmReg1[32,32] = trunc(XmmReg2[64,64]);
  XmmReg1[64,32] = 0;
  XmmReg1[96,32] = 0;
}

:CVTTPS2DQ    XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
  local m:16 = m128;
  XmmReg[0,32] = trunc(m[0,32]);
  XmmReg[32,32] = trunc(m[32,32]);
  XmmReg[64,32] = trunc(m[64,32]);
  XmmReg[96,32] = trunc(m[96,32]);
}

:CVTTPS2DQ    XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = trunc(XmmReg2[0,32]);
  XmmReg1[32,32] = trunc(XmmReg2[32,32]);
  XmmReg1[64,32] = trunc(XmmReg2[64,32]);
  XmmReg1[96,32] = trunc(XmmReg2[96,32]);
}

:CVTTPS2PI    mmxreg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2C; mmxreg ... & m64
{
  local m:8 = m64;
  mmxreg[0,32] = trunc(m[0,32]);
  mmxreg[32,32] = trunc(m[32,32]);
  FPUTagWord = 0x0000;         
}

:CVTTPS2PI    mmxreg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2C; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = trunc(XmmReg2[0,32]);
  mmxreg1[32,32] = trunc(XmmReg2[32,32]);
  FPUTagWord = 0x0000;         
}

:CVTTSD2SI    Reg32, m64  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2C; Reg32 ... & check_Reg32_dest ... & m64
{
  Reg32 = trunc(m64);
  build check_Reg32_dest;
}

:CVTTSD2SI    Reg32, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg32 & check_Reg32_dest & XmmReg2
{
  Reg32 = trunc(XmmReg2[0,64]);
  build check_Reg32_dest;
}

@ifdef IA64
:CVTTSD2SI    Reg64, m64  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F2) & byte=0x0F; byte=0x2C; Reg64 ... & m64
{
  Reg64 = trunc(m64);
}

:CVTTSD2SI    Reg64, XmmReg2  is vexMode=0 & opsize=2 & $(PRE_F2) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg64 & XmmReg2
{
  Reg64 = trunc(XmmReg2[0,64]);
}
@endif
                
:CVTTSS2SI    Reg32, m32  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2C; Reg32 ... & check_Reg32_dest ... & m32
{
  Reg32 = trunc(m32);
  build check_Reg32_dest;
}

:CVTTSS2SI    Reg32, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg32 & check_Reg32_dest & XmmReg2
{
  Reg32 = trunc(XmmReg2[0,32]);
  build check_Reg32_dest;
}

@ifdef IA64
:CVTTSS2SI    Reg64, m32  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0F; byte=0x2C; Reg64 ... & m32
{
  Reg64 = trunc(m32);
}

:CVTTSS2SI    Reg64, XmmReg2  is vexMode=0 & opsize=2 & $(PRE_F3) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg64 & XmmReg2
{
  Reg64 = trunc(XmmReg2[0,32]);
}
@endif

define pcodeop divpd;
:DIVPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; XmmReg ... & m128 { XmmReg = divpd(XmmReg, m128); }
:DIVPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = divpd(XmmReg1, XmmReg2); }

define pcodeop divps;
:DIVPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5E; XmmReg ... & m128 { XmmReg = divps(XmmReg, m128); }
:DIVPS        XmmReg1, XmmReg2 is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = divps(XmmReg1, XmmReg2); }
                
:DIVSD        XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5E; m64 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[0,64] f/ m64;
}

:DIVSD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f/ XmmReg2[0,64];
}

:DIVSS        XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5E; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f/ m32;
}

:DIVSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f/ XmmReg2[0,32];
}

:EMMS                     is vexMode=0 &  byte=0x0F; byte=0x77 { FPUTagWord = 0xFFFF; }

:HADDPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7C; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f+ XmmReg[64,64];
    XmmReg[64,64] = m[0,64]   f+ m[64,64];
}

:HADDPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f+ XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[0,64] f+ XmmReg2[64,64];
}

:HADDPS        XmmReg, m128        is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7C; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f+ XmmReg[32,32];
    XmmReg[32,32] = XmmReg[64,32] f+ XmmReg[96,32];
    XmmReg[64,32] = m[0,32]   f+ m[32,32];
    XmmReg[96,32] = m[64,32]   f+ m[96,32];
}

:HADDPS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg1[32,32];
    XmmReg1[32,32] = XmmReg1[64,32] f+ XmmReg1[96,32];
    XmmReg1[64,32] = XmmReg2[0,32] f+ XmmReg2[32,32];
    XmmReg1[96,32] = XmmReg2[64,32] f+ XmmReg2[96,32];
}

:HSUBPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7D; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- XmmReg[64,64];
    XmmReg[64,64] = m[0,64]   f- m[64,64];
}

:HSUBPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7D; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[0,64] f- XmmReg2[64,64];
}

:HSUBPS        XmmReg, m128        is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7D; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f- XmmReg[32,32];
    XmmReg[32,32] = XmmReg[64,32] f- XmmReg[96,32];
    XmmReg[64,32] = m[0,32]   f- m[32,32];
    XmmReg[96,32] = m[64,32]   f- m[96,32];
}

:HSUBPS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7D; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg1[32,32];
    XmmReg1[32,32] = XmmReg1[64,32] f- XmmReg1[96,32];
    XmmReg1[64,32] = XmmReg2[0,32] f- XmmReg2[32,32];
    XmmReg1[96,32] = XmmReg2[64,32] f- XmmReg2[96,32];
}

#--------------------
#SSE3...
#--------------------

define pcodeop lddqu;
:LDDQU        XmmReg, m128        is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xF0; XmmReg ... & m128 { XmmReg = lddqu(XmmReg, m128); }

define pcodeop maskmovdqu;
:MASKMOVDQU        XmmReg1, XmmReg2   is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xF7; XmmReg1 & XmmReg2		{ XmmReg1 = maskmovdqu(XmmReg1, XmmReg2); }

define pcodeop maxpd;
:MAXPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; XmmReg ... & m128 { XmmReg = maxpd(XmmReg, m128); }
:MAXPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxpd(XmmReg1, XmmReg2); }

define pcodeop maxps;
:MAXPS        XmmReg, m128        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5F; XmmReg ... & m128 { XmmReg = maxps(XmmReg, m128); }
:MAXPS        XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxps(XmmReg1, XmmReg2); }

:MAXSD        XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5F; XmmReg ... & m64
{
    local tmp:8 = m64;
    if (tmp f< XmmReg[0,64]) goto inst_next;
    XmmReg[0,64] = tmp;
}

:MAXSD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg2[0,64] f< XmmReg1[0,64]) goto inst_next;
    XmmReg1[0,64] = XmmReg2[0,64];
}

:MAXSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; XmmReg ... & m32
{
    local tmp:4 = m32;
    if (tmp f< XmmReg[0,32]) goto inst_next;
    XmmReg[0,32] = tmp;
}

:MAXSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg2[0,32] f< XmmReg1[0,32]) goto inst_next;
    XmmReg1[0,32] = XmmReg2[0,32];
}

define pcodeop minpd;
:MINPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minpd(XmmReg, m128); }
:MINPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minpd(XmmReg1, XmmReg2); }

define pcodeop minps;
:MINPS        XmmReg, m128        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minps(XmmReg, m128); }
:MINPS        XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minps(XmmReg1, XmmReg2); }

:MINSD        XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5D; XmmReg ... & m64
{
    local tmp:8 = m64;
    if (XmmReg[0,64] f< tmp) goto inst_next;
    XmmReg[0,64] = tmp;
}

:MINSD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg1[0,64] f< XmmReg2[0,64]) goto inst_next;
    XmmReg1[0,64] = XmmReg2[0,64];
}

:MINSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; XmmReg ... & m32
{
    local tmp:4 = m32;
    if (XmmReg[0,32] f< tmp) goto inst_next;
    XmmReg[0,32] = tmp;
}

:MINSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg1[0,32] f< XmmReg2[0,32]) goto inst_next;
    XmmReg1[0,32] = XmmReg2[0,32];
}

:MOVAPD       XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x28; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = m[0,64];
    XmmReg[64,64] = m[64,64];
}

:MOVAPD       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x28; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}

:MOVAPD       m128, XmmReg        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x29; m128 & XmmReg ...
{
    m128 = XmmReg;
}

:MOVAPD       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x29; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
    XmmReg2[64,64] = XmmReg1[64,64];
}

:MOVAPS       XmmReg, m128        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x28; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[32,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[96,32];
}

:MOVAPS       XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x28; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}

:MOVAPS       m128, XmmReg        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x29; m128 & XmmReg ...
{
    m128 = XmmReg;
}

:MOVAPS       XmmReg2, XmmReg1    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x29; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
    XmmReg2[32,32] = XmmReg1[32,32];
    XmmReg2[64,32] = XmmReg1[64,32];
    XmmReg2[96,32] = XmmReg1[96,32];
}

:MOVD         mmxreg, rm32   is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6E; rm32 & mmxreg ...                    { mmxreg = zext(rm32); }
:MOVD         rm32, mmxreg   is vexMode=0 &  rexWprefix=0 & mandover=0 & byte=0x0F; byte=0x7E; rm32 & check_rm32_dest ... & mmxreg ...                    { rm32 = mmxreg(0); build check_rm32_dest; }
:MOVD         XmmReg, rm32   is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6E; rm32 & XmmReg ...         { XmmReg = zext(rm32); }
:MOVD         rm32, XmmReg   is vexMode=0 &  $(PRE_66) & rexWprefix=0 & byte=0x0F; byte=0x7E; rm32 & check_rm32_dest ... & XmmReg ...         { rm32 = XmmReg(0); build check_rm32_dest; }
@ifdef IA64
:MOVQ         mmxreg, rm64   is $(LONGMODE_ON) & vexMode=0 &  opsize=2 & mandover=0 & byte=0x0F; byte=0x6E; rm64 & mmxreg ...         { mmxreg = rm64; }
:MOVQ         rm64, mmxreg   is $(LONGMODE_ON) & vexMode=0 &  opsize=2 & mandover=0 & byte=0x0F; byte=0x7E; rm64 & mmxreg ...         { rm64 = mmxreg; }
:MOVQ         XmmReg, rm64   is $(LONGMODE_ON) & vexMode=0 &  opsize=2 & $(PRE_66) & byte=0x0F; byte=0x6E; rm64 & XmmReg ...         { XmmReg = zext(rm64); }
:MOVQ         rm64, XmmReg   is $(LONGMODE_ON) & vexMode=0 &  opsize=2 & $(PRE_66) & byte=0x0F; byte=0x7E; rm64 & XmmReg ...         { rm64 = XmmReg(0); }
@endif

:MOVDDUP      XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x12; m64 & XmmReg ...
{
    XmmReg[0,64] = m64;
    XmmReg[64,64] = m64;
}

:MOVDDUP      XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg2[0,64];
}

:MOVSHDUP     XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x16; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[32,32];
    XmmReg[32,32] = m[32,32];
    XmmReg[64,32] = m[96,32];
    XmmReg[96,32] = m[96,32];
}

:MOVSHDUP     XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x16; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[32,32];
    XmmReg1[32,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg2[96,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}

:MOVSLDUP     XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x12; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[0,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[64,32];
}

:MOVSLDUP     XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[0,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[64,32];
}

:MOVDQA       XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6F; XmmReg ... & m128            { XmmReg = m128; }  
:MOVDQA       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg2; }
:MOVDQA       m128, XmmReg        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7F; XmmReg ... & m128            { m128 = XmmReg; }
:MOVDQA       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg2 = XmmReg1; }

:MOVDQU       XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x6F; XmmReg ... & m128            { XmmReg = m128; }
:MOVDQU       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x6F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg2; }
:MOVDQU       m128, XmmReg        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7F; XmmReg ... & m128            { m128 = XmmReg; }  
:MOVDQU       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg2 = XmmReg1; }

# TODO: this vexMode=0 & is potentially wrong

define pcodeop movdq2q;
:MOVDQ2Q      mmxreg2, XmmReg1    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xD6; XmmReg1 & mmxreg2 { mmxreg2 = movdq2q(mmxreg2, XmmReg1); }

:MOVHLPS      XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,64] = XmmReg2[64,64]; }

:MOVHPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x16; XmmReg ... & m64 { XmmReg[64,64] = m64; }

:MOVHPD       m64, XmmReg         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x17; XmmReg ... & m64 { m64 = XmmReg[64,64]; }

:MOVHPS       XmmReg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x16; XmmReg ... & m64 { XmmReg[64,64] = m64; }

:MOVHPS       m64, XmmReg         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x17; XmmReg ... & m64 { m64 = XmmReg[64,64]; }

:MOVLHPS      XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x16; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[64,64] = XmmReg2[0,64]; }

:MOVLPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x12; XmmReg ... & m64 { XmmReg[0,64] = m64; }

:MOVLPD       m64, XmmReg         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x13; XmmReg ... & m64 { m64 = XmmReg[0,64]; }

:MOVLPS       XmmReg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x12; XmmReg ... & m64 { XmmReg[0,64] = m64; }

:MOVLPS       m64, XmmReg         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x13; XmmReg ... & m64 { m64 = XmmReg[0,64]; }

define pcodeop movmskpd;
:MOVMSKPD     Reg32, XmmReg2      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x50; XmmReg2 & Reg32 { Reg32 = movmskpd(Reg32, XmmReg2); }

define pcodeop movmskps;
:MOVMSKPS     Reg32, XmmReg2      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x50; XmmReg2 & Reg32 { Reg32 = movmskps(Reg32, XmmReg2); }

:MOVNTQ       m64, mmxreg      is vexMode=0 & mandover=0 & byte=0x0F; byte=0xE7; mmxreg ... & m64   { m64 = mmxreg; }

:MOVNTDQ      m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE7; XmmReg ... & m128  { m128 = XmmReg; }

:MOVNTPD      m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2B; XmmReg ... & m128  { m128 = XmmReg; }

:MOVNTPS      m128, XmmReg     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2B; XmmReg ... & m128 { m128 = XmmReg; }

:MOVQ         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6F; mmxreg ... & m64                   { mmxreg = m64; }
:MOVQ         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6F; mmxmod = 3 & mmxreg1 & mmxreg2     { mmxreg1 = mmxreg2; }
:MOVQ         m64, mmxreg      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x7F; mmxreg ... & m64                   { m64 = mmxreg; }
:MOVQ         mmxreg2, mmxreg1 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x7F; mmxmod = 3 & mmxreg1 & mmxreg2     { mmxreg2 = mmxreg1; }

:MOVQ         XmmReg, m64      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7E; XmmReg ... & m64
{
	XmmReg = zext(m64);
}

:MOVQ         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7E; xmmmod = 3 & XmmReg1 & XmmReg2
{
	XmmReg1 = zext(XmmReg2[0,64]);
}

:MOVQ         m64, XmmReg      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD6; m64 & XmmReg ...
{
    m64 = XmmReg[0,64];
}

:MOVQ         XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD6; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2 = zext(XmmReg1[0,64]);
}

:MOVQ2DQ      XmmReg, mmxreg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0xD6; XmmReg & mmxreg2
{
    XmmReg = zext(mmxreg2);
# may need to model x87 FPU state changes too ?????
}

:MOVSD        XmmReg, m64      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x10; m64 & XmmReg ...
{
    XmmReg[0,64] = m64;
    XmmReg[64,64] = 0;
}

:MOVSD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
}

:MOVSD        m64, XmmReg      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x11; m64 & XmmReg ...
{
    m64 = XmmReg[0,64];
}

:MOVSD        XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
}

:MOVSS        XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x10; m32 & XmmReg ...
{
    XmmReg[0,32] = m32;
    XmmReg[32,32] = 0;
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}

:MOVSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
}

:MOVSS        m32, XmmReg      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x11; m32 & XmmReg ...
{
    m32 = XmmReg[0,32];
}

:MOVSS        XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
}

:MOVUPD       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x10; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = m[0,64];
    XmmReg[64,64] = m[64,64];
}

:MOVUPD       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}

:MOVUPD       m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; m128 & XmmReg ...
{
    m128 = XmmReg;
}

:MOVUPD       XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
    XmmReg2[64,64] = XmmReg1[64,64];
}

# Not sure why someone had done it this way ?????
#Xmm2m128: m128         is vexMode=0 &      m128                      { export m128; }  
#Xmm2m128: XmmReg2      is vexMode=0 &      xmmmod=3 & XmmReg2        { export XmmReg2; }
#
#define pcodeop movups;
##:MOVUPS       XmmReg, m128     is vexMode=0 &  byte=0x0F; byte=0x10; XmmReg ... & m128					{ XmmReg = movups(XmmReg, m128); }
##:MOVUPS       XmmReg1, XmmReg2 is vexMode=0 &  byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = movups(XmmReg1, XmmReg2); }
#
#:MOVUPS       XmmReg,Xmm2m128  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x10; XmmReg ... & Xmm2m128    { XmmReg = movups(XmmReg, Xmm2m128); }

:MOVUPS       XmmReg, m128     is vexMode=0 &  byte=0x0F; byte=0x10; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[32,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[96,32];
}

:MOVUPS       XmmReg1, XmmReg2 is vexMode=0 &  byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}

:MOVUPS       m128, XmmReg     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x11; m128 & XmmReg ...
{
    m128 = XmmReg;
}

:MOVUPS       XmmReg2, XmmReg1 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
    XmmReg2[32,32] = XmmReg1[32,32];
    XmmReg2[64,32] = XmmReg1[64,32];
    XmmReg2[96,32] = XmmReg1[96,32];
}

:MULPD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f* m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f* m[64,64];
}

:MULPD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f* XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f* XmmReg2[64,64];
}

:MULPS        XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x59; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f* m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f* m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f* m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f* m[96,32];
}

:MULPS        XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f* XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f* XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f* XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f* XmmReg2[96,32];
}

:MULSD        XmmReg, m64      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x59;  m64 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[0,64] f* m64;
}

:MULSD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f* XmmReg2[0,64];
}

:MULSS        XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x59; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f* m32;
}

:MULSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f* XmmReg2[0,32];
}

:ORPD          XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x56; XmmReg ... & m128 { XmmReg = XmmReg | m128; }
:ORPD          XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x56; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg1 | XmmReg2; }

:ORPS          XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x56; XmmReg ... & m128 { XmmReg = XmmReg | m128; }
:ORPS          XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x56; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg1 | XmmReg2; }

#sword < 0xff80: sbyte = 0x80
#sword > 0x007f: sbyte = 0x7f
#otherwise sbyte = sword
macro sswsb(sword, sbyte) {
	local less = (sword s< 0xff80:2);
    local greater = (sword s> 0x007f:2);
	local inbounds = !(less || greater);
    sbyte = (sword:1 * inbounds) + (0x80:1 * less) + (0x7f:1 * greater);
}

macro packsswb_mmx(dst, src) {
	local a:8 = dst;
	local b:8 = src;

	sswsb(a[ 0,16], dst[ 0,8]);
	sswsb(a[16,16], dst[ 8,8]);
	sswsb(a[32,16], dst[16,8]);
	sswsb(a[48,16], dst[24,8]);

	sswsb(b[ 0,16], dst[32,8]);
	sswsb(b[16,16], dst[40,8]);
	sswsb(b[32,16], dst[48,8]);
	sswsb(b[48,16], dst[56,8]);
}
:PACKSSWB      mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x63; mmxreg ... & m64 			  { packsswb_mmx(mmxreg, m64); }
:PACKSSWB      mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x63; mmxmod = 3 & mmxreg1 & mmxreg2 { packsswb_mmx(mmxreg1, mmxreg2); }

#sdword < 0xffff_8000: sword = 0x8000
#sdword > 0x0000_7fff: sword = 0x7fff
#otherwise sbyte = sword
macro ssdsw(sword, sbyte) {
	local less = (sword s< 0xffff8000:4);
    local greater = (sword s> 0x00007fff:4);
	local inbounds = !(less || greater);
    sbyte = (sword:2 * zext(inbounds)) + (0x8000:2 * zext(less)) + (0x7fff:2 * zext(greater));
}

macro packssdw_mmx(dst, src) {
	local a:8 = dst;
	local b:8 = src;

	ssdsw(a[ 0,32], dst[ 0,16]);
	ssdsw(a[32,32], dst[16,16]);

	ssdsw(b[ 0,32], dst[32,16]);
	ssdsw(b[32,32], dst[48,16]);
}
:PACKSSDW      mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6B; mmxreg ... & m64 			  { packssdw_mmx(mmxreg, m64); }
:PACKSSDW      mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6B; mmxmod = 3 & mmxreg1 & mmxreg2 { packssdw_mmx(mmxreg1, mmxreg2); }

macro packsswb_xmm(dst, src) {
	local a:16 = dst;
	local b:16 = src;

	sswsb(a[  0,16], dst[  0,8]);
	sswsb(a[ 16,16], dst[  8,8]);
	sswsb(a[ 32,16], dst[ 16,8]);
	sswsb(a[ 48,16], dst[ 24,8]);
	sswsb(a[ 64,16], dst[ 32,8]);
	sswsb(a[ 80,16], dst[ 40,8]);
	sswsb(a[ 96,16], dst[ 48,8]);
	sswsb(a[112,16], dst[ 56,8]);

	sswsb(b[  0,16], dst[ 64,8]);
	sswsb(b[ 16,16], dst[ 72,8]);
	sswsb(b[ 32,16], dst[ 80,8]);
	sswsb(b[ 48,16], dst[ 88,8]);
	sswsb(b[ 64,16], dst[ 96,8]);
	sswsb(b[ 80,16], dst[104,8]);
	sswsb(b[ 96,16], dst[112,8]);
	sswsb(b[112,16], dst[120,8]);
}
:PACKSSWB      XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x63; XmmReg ... & m128 			 { packsswb_xmm(XmmReg, m128); }
:PACKSSWB      XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x63; xmmmod = 3 & XmmReg1 & XmmReg2 { packsswb_xmm(XmmReg1, XmmReg2); }

macro packssdw_xmm(dst, src) {
	local a:16 = dst;
	local b:16 = src;

	ssdsw(a[ 0,32], dst[  0,16]);
	ssdsw(a[32,32], dst[ 16,16]);
	ssdsw(a[64,32], dst[ 32,16]);
	ssdsw(a[96,32], dst[ 48,16]);

	ssdsw(b[ 0,32], dst[ 64,16]);
	ssdsw(b[32,32], dst[ 80,16]);
	ssdsw(b[64,32], dst[ 96,16]);
	ssdsw(b[96,32], dst[112,16]);
}
:PACKSSDW      XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6B; XmmReg ... & m128 			 { packssdw_xmm(XmmReg, m128); }
:PACKSSDW      XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6B; xmmmod = 3 & XmmReg1 & XmmReg2 { packssdw_xmm(XmmReg1, XmmReg2); }

#sword < 0 : ubyte = 0
#sword > 0xff: ubyte = 0xff
#otherwise ubyte = sword
macro sswub(sword, ubyte) {
    ubyte = (sword s> 0xff:2) * 0xff:1;
    ubyte = ubyte + (sword s> 0:2) * (sword s<= 0xff:2) * sword:1;
}

:PACKUSWB      mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x67; mmxreg ... & m64
{
    local dest_copy:8 = mmxreg;
    local src_copy:8 = m64;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    mmxreg[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    mmxreg[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    mmxreg[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    mmxreg[24,8] = ubyte;
    sswub(src_copy[0,16],ubyte);
    mmxreg[32,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    mmxreg[40,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    mmxreg[48,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    mmxreg[56,8] = ubyte;
}

:PACKUSWB      mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x67; mmxmod = 3 & mmxreg1 & mmxreg2
{
    local dest_copy:8 = mmxreg1;
    local src_copy:8 = mmxreg2;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    mmxreg1[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    mmxreg1[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    mmxreg1[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    mmxreg1[24,8] = ubyte;
    sswub(src_copy[0,16],ubyte);
    mmxreg1[32,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    mmxreg1[40,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    mmxreg1[48,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    mmxreg1[56,8] = ubyte;
}

:PACKUSWB      XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x67; XmmReg ... & m128
{
    local dest_copy:16 = XmmReg;
    local src_copy:16 = m128;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    XmmReg[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    XmmReg[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    XmmReg[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    XmmReg[24,8] = ubyte;
    sswub(dest_copy[64,16],ubyte);
    XmmReg[32,8] = ubyte;
    sswub(dest_copy[80,16],ubyte);
    XmmReg[40,8] = ubyte;
    sswub(dest_copy[96,16],ubyte);
    XmmReg[48,8] = ubyte;
    sswub(dest_copy[112,16],ubyte);
    XmmReg[56,8] = ubyte;

    sswub(src_copy[0,16],ubyte);
    XmmReg[64,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    XmmReg[72,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    XmmReg[80,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    XmmReg[88,8] = ubyte;
    sswub(src_copy[64,16],ubyte);
    XmmReg[96,8] = ubyte;
    sswub(src_copy[80,16],ubyte);
    XmmReg[104,8] = ubyte;
    sswub(src_copy[96,16],ubyte);
    XmmReg[112,8] = ubyte;
    sswub(src_copy[112,16],ubyte);
    XmmReg[120,8] = ubyte;
}

:PACKUSWB      XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x67; xmmmod = 3 & XmmReg1 & XmmReg2
{
    local dest_copy:16 = XmmReg1;
    local src_copy:16 = XmmReg2;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    XmmReg1[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    XmmReg1[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    XmmReg1[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    XmmReg1[24,8] = ubyte;
    sswub(dest_copy[64,16],ubyte);
    XmmReg1[32,8] = ubyte;
    sswub(dest_copy[80,16],ubyte);
    XmmReg1[40,8] = ubyte;
    sswub(dest_copy[96,16],ubyte);
    XmmReg1[48,8] = ubyte;
    sswub(dest_copy[112,16],ubyte);
    XmmReg1[56,8] = ubyte;

    sswub(src_copy[0,16],ubyte);
    XmmReg1[64,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    XmmReg1[72,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    XmmReg1[80,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    XmmReg1[88,8] = ubyte;
    sswub(src_copy[64,16],ubyte);
    XmmReg1[96,8] = ubyte;
    sswub(src_copy[80,16],ubyte);
    XmmReg1[104,8] = ubyte;
    sswub(src_copy[96,16],ubyte);
    XmmReg1[112,8] = ubyte;
    sswub(src_copy[112,16],ubyte);
    XmmReg1[120,8] = ubyte;
}

define pcodeop pabsb;
:PABSB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1c; mmxreg ... & m64					{ mmxreg=pabsb(mmxreg,m64); }
:PABSB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1c; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1=pabsb(mmxreg1,mmxreg2); }
:PABSB         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1c; XmmReg ... & m128              { XmmReg=pabsb(XmmReg,m128); }
:PABSB         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1c; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pabsb(XmmReg1,XmmReg2); }

define pcodeop pabsw;
:PABSW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1d; mmxreg ... & m64					{ mmxreg=pabsw(mmxreg,m64); }
:PABSW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1d; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1=pabsw(mmxreg1,mmxreg2); }
:PABSW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1d; XmmReg ... & m128              { XmmReg=pabsw(XmmReg,m128); }
:PABSW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1d; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pabsw(XmmReg1,XmmReg2); }

define pcodeop pabsd;
:PABSD         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1e; mmxreg ... & m64					{ mmxreg=pabsd(mmxreg,m64); }
:PABSD         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1e; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1=pabsd(mmxreg1,mmxreg2); }
:PABSD         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1e; XmmReg ... & m128              { XmmReg=pabsd(XmmReg,m128); }
:PABSD         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1e; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pabsd(XmmReg1,XmmReg2); }

:PADDB          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFC; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = mmxreg[0,8] + m[0,8];
    mmxreg[8,8] = mmxreg[8,8] + m[8,8];
    mmxreg[16,8] = mmxreg[16,8] + m[16,8];
    mmxreg[24,8] = mmxreg[24,8] + m[24,8];
    mmxreg[32,8] = mmxreg[32,8] + m[32,8];
    mmxreg[40,8] = mmxreg[40,8] + m[40,8];
    mmxreg[48,8] = mmxreg[48,8] + m[48,8];
    mmxreg[56,8] = mmxreg[56,8] + m[56,8];
}

:PADDB          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFC; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = mmxreg1[0,8] + mmxreg2[0,8];
    mmxreg1[8,8] = mmxreg1[8,8] + mmxreg2[8,8];
    mmxreg1[16,8] = mmxreg1[16,8] + mmxreg2[16,8];
    mmxreg1[24,8] = mmxreg1[24,8] + mmxreg2[24,8];
    mmxreg1[32,8] = mmxreg1[32,8] + mmxreg2[32,8];
    mmxreg1[40,8] = mmxreg1[40,8] + mmxreg2[40,8];
    mmxreg1[48,8] = mmxreg1[48,8] + mmxreg2[48,8];
    mmxreg1[56,8] = mmxreg1[56,8] + mmxreg2[56,8];
}

:PADDW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFD; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = mmxreg[0,16] + m[0,16];
    mmxreg[16,16] = mmxreg[16,16] + m[16,16];
    mmxreg[32,16] = mmxreg[32,16] + m[32,16];
    mmxreg[48,16] = mmxreg[48,16] + m[48,16];
}

:PADDW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFD; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = mmxreg1[0,16] + mmxreg2[0,16];
    mmxreg1[16,16] = mmxreg1[16,16] + mmxreg2[16,16];
    mmxreg1[32,16] = mmxreg1[32,16] + mmxreg2[32,16];
    mmxreg1[48,16] = mmxreg1[48,16] + mmxreg2[48,16];
}

:PADDD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFE; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,32] = mmxreg[0,32] + m[0,32];
    mmxreg[32,32] = mmxreg[32,32] + m[32,32];
}

:PADDD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFE; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = mmxreg1[0,32] + mmxreg2[0,32];
    mmxreg1[32,32] = mmxreg1[32,32] + mmxreg2[32,32];
}

:PADDB          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFC; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = XmmReg[0,8] + m[0,8];
    XmmReg[8,8] = XmmReg[8,8] + m[8,8];
    XmmReg[16,8] = XmmReg[16,8] + m[16,8];
    XmmReg[24,8] = XmmReg[24,8] + m[24,8];
    XmmReg[32,8] = XmmReg[32,8] + m[32,8];
    XmmReg[40,8] = XmmReg[40,8] + m[40,8];
    XmmReg[48,8] = XmmReg[48,8] + m[48,8];
    XmmReg[56,8] = XmmReg[56,8] + m[56,8];
    XmmReg[64,8] = XmmReg[64,8] + m[64,8];
    XmmReg[72,8] = XmmReg[72,8] + m[72,8];
    XmmReg[80,8] = XmmReg[80,8] + m[80,8];
    XmmReg[88,8] = XmmReg[88,8] + m[88,8];
    XmmReg[96,8] = XmmReg[96,8] + m[96,8];
    XmmReg[104,8] = XmmReg[104,8] + m[104,8];
    XmmReg[112,8] = XmmReg[112,8] + m[112,8];
    XmmReg[120,8] = XmmReg[120,8] + m[120,8];
}

## example of bitfield solution
#:PADDB  XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xFC; xmmmod = 3 & XmmReg1 & XmmReg2  
#{
#     XmmReg1[  0,8] = XmmReg1[  0,8] + XmmReg2[  0,8];
#     XmmReg1[  8,8] = XmmReg1[  8,8] + XmmReg2[  8,8];
#     XmmReg1[ 16,8] = XmmReg1[ 16,8] + XmmReg2[ 16,8];
#     XmmReg1[ 24,8] = XmmReg1[ 24,8] + XmmReg2[ 24,8];
#     XmmReg1[ 32,8] = XmmReg1[ 32,8] + XmmReg2[ 32,8];
#     XmmReg1[ 40,8] = XmmReg1[ 40,8] + XmmReg2[ 40,8];
#     XmmReg1[ 48,8] = XmmReg1[ 48,8] + XmmReg2[ 48,8];
#     XmmReg1[ 56,8] = XmmReg1[ 56,8] + XmmReg2[ 56,8];
##    XmmReg1[ 64,8] = XmmReg1[ 64,8] + XmmReg2[ 64,8];
##    XmmReg1[ 72,8] = XmmReg1[ 72,8] + XmmReg2[ 72,8];
##    XmmReg1[ 80,8] = XmmReg1[ 80,8] + XmmReg2[ 80,8];
##    XmmReg1[ 88,8] = XmmReg1[ 88,8] + XmmReg2[ 88,8];
##    XmmReg1[ 96,8] = XmmReg1[ 96,8] + XmmReg2[ 96,8];
##    XmmReg1[104,8] = XmmReg1[104,8] + XmmReg2[104,8];
##    XmmReg1[112,8] = XmmReg1[112,8] + XmmReg2[112,8];
##    XmmReg1[120,8] = XmmReg1[120,8] + XmmReg2[120,8];
#}

# full set of XMM byte registers
:PADDB  XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xFC; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = XmmReg1[0,8] + XmmReg2[0,8];
    XmmReg1[8,8] = XmmReg1[8,8] + XmmReg2[8,8];
    XmmReg1[16,8] = XmmReg1[16,8] + XmmReg2[16,8];
    XmmReg1[24,8] = XmmReg1[24,8] + XmmReg2[24,8];
    XmmReg1[32,8] = XmmReg1[32,8] + XmmReg2[32,8];
    XmmReg1[40,8] = XmmReg1[40,8] + XmmReg2[40,8];
    XmmReg1[48,8] = XmmReg1[48,8] + XmmReg2[48,8];
    XmmReg1[56,8] = XmmReg1[56,8] + XmmReg2[56,8];
    XmmReg1[64,8] = XmmReg1[64,8] + XmmReg2[64,8];
    XmmReg1[72,8] = XmmReg1[72,8] + XmmReg2[72,8];
    XmmReg1[80,8] = XmmReg1[80,8] + XmmReg2[80,8];
    XmmReg1[88,8] = XmmReg1[88,8] + XmmReg2[88,8];
    XmmReg1[96,8] = XmmReg1[96,8] + XmmReg2[96,8];
    XmmReg1[104,8] = XmmReg1[104,8] + XmmReg2[104,8];
    XmmReg1[112,8] = XmmReg1[112,8] + XmmReg2[112,8];
    XmmReg1[120,8] = XmmReg1[120,8] + XmmReg2[120,8];
}

:PADDW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFD; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = XmmReg[0,16] + m[0,16];
    XmmReg[16,16] = XmmReg[16,16] + m[16,16];
    XmmReg[32,16] = XmmReg[32,16] + m[32,16];
    XmmReg[48,16] = XmmReg[48,16] + m[48,16];
    XmmReg[64,16] = XmmReg[64,16] + m[64,16];
    XmmReg[80,16] = XmmReg[80,16] + m[80,16];
    XmmReg[96,16] = XmmReg[96,16] + m[96,16];
    XmmReg[112,16] = XmmReg[112,16] + m[112,16];
}

:PADDW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFD; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = XmmReg1[0,16] + XmmReg2[0,16];
    XmmReg1[16,16] = XmmReg1[16,16] + XmmReg2[16,16];
    XmmReg1[32,16] = XmmReg1[32,16] + XmmReg2[32,16];
    XmmReg1[48,16] = XmmReg1[48,16] + XmmReg2[48,16];
    XmmReg1[64,16] = XmmReg1[64,16] + XmmReg2[64,16];
    XmmReg1[80,16] = XmmReg1[80,16] + XmmReg2[80,16];
    XmmReg1[96,16] = XmmReg1[96,16] + XmmReg2[96,16];
    XmmReg1[112,16] = XmmReg1[112,16] + XmmReg2[112,16];
}

:PADDD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFE; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] + m[0,32];
    XmmReg[32,32] = XmmReg[32,32] + m[32,32];
    XmmReg[64,32] = XmmReg[64,32] + m[64,32];
    XmmReg[96,32] = XmmReg[96,32] + m[96,32];
}

:PADDD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFE; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] + XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] + XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] + XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] + XmmReg2[96,32];
}

:PADDQ          mmxreg, m64       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD4; mmxreg ... & m64
{
    mmxreg = mmxreg + m64;
}

:PADDQ          mmxreg1, mmxreg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD4; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1 = mmxreg1 + mmxreg2;
}

:PADDQ          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD4; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] + m[0,64];
    XmmReg[64,64] = XmmReg[64,64] + m[64,64];
}

:PADDQ          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD4; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] + XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] + XmmReg2[64,64];
}

define pcodeop paddsb;
:PADDSB         mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEC; mmxreg1 ... & mmxreg2_m64 { mmxreg1 = paddsb(mmxreg1, mmxreg2_m64); }

define pcodeop paddsw;
:PADDSW         mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xED; mmxreg1 ... & mmxreg2_m64 { mmxreg1 = paddsw(mmxreg1, mmxreg2_m64); }

:PADDSB         XmmReg1, XmmReg2_m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEC; XmmReg1 ... & XmmReg2_m128 { XmmReg1 = paddsb(XmmReg1, XmmReg2_m128); }
:PADDSW         XmmReg1, XmmReg2_m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xED; XmmReg1 ... & XmmReg2_m128 { XmmReg1 = paddsw(XmmReg1, XmmReg2_m128); }

define pcodeop paddusb;
:PADDUSB        mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDC; mmxreg1 ... & mmxreg2_m64 { mmxreg1 = paddusb(mmxreg1, mmxreg2_m64); }

define pcodeop paddusw;
:PADDUSW        mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDD; mmxreg1 ... & mmxreg2_m64 { mmxreg1 = paddusw(mmxreg1, mmxreg2_m64); }

:PADDUSB        XmmReg1, XmmReg2_m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDC; XmmReg1 ... & XmmReg2_m128 { XmmReg1 = paddusb(XmmReg1, XmmReg2_m128); }
:PADDUSW        XmmReg1, XmmReg2_m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDD; XmmReg1 ... & XmmReg2_m128 { XmmReg1 = paddusw(XmmReg1, XmmReg2_m128); }

:PALIGNR        mmxreg, m64, imm8       is vexMode=0 & mandover=0 & byte=0x0F; byte=0x3A; byte=0x0F; m64 & mmxreg ...; imm8
{
    temp:16 = ( ( zext(mmxreg) << 64 ) | zext( m64 ) ) >> ( imm8 * 8 );
    mmxreg = temp:8;
}
     
:PALIGNR        mmxreg1, mmxreg2, imm8  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x3A; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2; imm8
{
    temp:16 = ( ( zext(mmxreg1) << 64 ) | zext( mmxreg2 ) ) >> ( imm8 * 8 );
    mmxreg1 = temp:8;
}
     
:PALIGNR        XmmReg1, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0F; m128 & XmmReg1 ...; imm8
{
    temp:32 = ( ( zext(XmmReg1) << 128 ) | zext( m128 ) ) >> ( imm8 * 8 );
    XmmReg1 = temp:16;
}

:PALIGNR        XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0F; xmmmod=3 & XmmReg1 & XmmReg2; imm8
{
    temp:32 = ( ( zext(XmmReg1) << 128 ) | zext( XmmReg2 ) ) >> ( imm8 * 8 );
    XmmReg1 = temp:16;
}

:PAND           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDB; mmxreg ... & m64	{ mmxreg = mmxreg & m64; }
:PAND           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDB; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1 = mmxreg1 & mmxreg2; }
:PAND           XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDB; XmmReg ... & m128	{ XmmReg = XmmReg & m128; }
:PAND           XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDB; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = XmmReg1 & XmmReg2; }

:PANDN          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDF; mmxreg ... & m64				{ mmxreg = ~mmxreg & m64; }
:PANDN          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDF; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1 = ~mmxreg1 & mmxreg2; }
:PANDN          XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDF; XmmReg ... & m128			    { XmmReg = ~XmmReg & m128; }
:PANDN          XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDF; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = ~XmmReg1 & XmmReg2; }

define pcodeop pavgb;
:PAVGB          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE0; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = pavgb(mmxreg[0,8], m[0,8]);
    mmxreg[8,8] = pavgb(mmxreg[8,8], m[8,8]);
    mmxreg[16,8] = pavgb(mmxreg[16,8], m[16,8]);
    mmxreg[24,8] = pavgb(mmxreg[24,8], m[24,8]);
    mmxreg[32,8] = pavgb(mmxreg[32,8], m[32,8]);
    mmxreg[40,8] = pavgb(mmxreg[40,8], m[40,8]);
    mmxreg[48,8] = pavgb(mmxreg[48,8], m[48,8]);
    mmxreg[56,8] = pavgb(mmxreg[56,8], m[56,8]);
}

:PAVGB          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE0; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = pavgb(mmxreg1[0,8], mmxreg2[0,8]);
    mmxreg1[8,8] = pavgb(mmxreg1[8,8], mmxreg2[8,8]);
    mmxreg1[16,8] = pavgb(mmxreg1[16,8], mmxreg2[16,8]);
    mmxreg1[24,8] = pavgb(mmxreg1[24,8], mmxreg2[24,8]);
    mmxreg1[32,8] = pavgb(mmxreg1[32,8], mmxreg2[32,8]);
    mmxreg1[40,8] = pavgb(mmxreg1[40,8], mmxreg2[40,8]);
    mmxreg1[48,8] = pavgb(mmxreg1[48,8], mmxreg2[48,8]);
    mmxreg1[56,8] = pavgb(mmxreg1[56,8], mmxreg2[56,8]);
}

define pcodeop pavgw;
:PAVGW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE3; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = pavgw(mmxreg[0,16], m[0,16]);
    mmxreg[16,16] = pavgw(mmxreg[16,16], m[16,16]);
    mmxreg[32,16] = pavgw(mmxreg[32,16], m[32,16]);
    mmxreg[48,16] = pavgw(mmxreg[48,16], m[48,16]);
}

:PAVGW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE3; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = pavgw(mmxreg1[0,16], mmxreg2[0,16]);
    mmxreg1[16,16] = pavgw(mmxreg1[16,16], mmxreg2[16,16]);
    mmxreg1[32,16] = pavgw(mmxreg1[32,16], mmxreg2[32,16]);
    mmxreg1[48,16] = pavgw(mmxreg1[48,16], mmxreg2[48,16]);
}

:PAVGB          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE0; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = pavgb(XmmReg[0,8], m[0,8]);
    XmmReg[8,8] = pavgb(XmmReg[8,8], m[8,8]);
    XmmReg[16,8] = pavgb(XmmReg[16,8], m[16,8]);
    XmmReg[24,8] = pavgb(XmmReg[24,8], m[24,8]);
    XmmReg[32,8] = pavgb(XmmReg[32,8], m[32,8]);
    XmmReg[40,8] = pavgb(XmmReg[40,8], m[40,8]);
    XmmReg[48,8] = pavgb(XmmReg[48,8], m[48,8]);
    XmmReg[56,8] = pavgb(XmmReg[56,8], m[56,8]);
    XmmReg[64,8] = pavgb(XmmReg[64,8], m[64,8]);
    XmmReg[72,8] = pavgb(XmmReg[72,8], m[72,8]);
    XmmReg[80,8] = pavgb(XmmReg[80,8], m[80,8]);
    XmmReg[88,8] = pavgb(XmmReg[88,8], m[88,8]);
    XmmReg[96,8] = pavgb(XmmReg[96,8], m[96,8]);
    XmmReg[104,8] = pavgb(XmmReg[104,8], m[104,8]);
    XmmReg[112,8] = pavgb(XmmReg[112,8], m[112,8]);
    XmmReg[120,8] = pavgb(XmmReg[120,8], m[120,8]);
}

# full set of XMM byte registers
:PAVGB  XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE0; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = pavgb(XmmReg1[0,8], XmmReg2[0,8]);
    XmmReg1[8,8] = pavgb(XmmReg1[8,8], XmmReg2[8,8]);
    XmmReg1[16,8] = pavgb(XmmReg1[16,8], XmmReg2[16,8]);
    XmmReg1[24,8] = pavgb(XmmReg1[24,8], XmmReg2[24,8]);
    XmmReg1[32,8] = pavgb(XmmReg1[32,8], XmmReg2[32,8]);
    XmmReg1[40,8] = pavgb(XmmReg1[40,8], XmmReg2[40,8]);
    XmmReg1[48,8] = pavgb(XmmReg1[48,8], XmmReg2[48,8]);
    XmmReg1[56,8] = pavgb(XmmReg1[56,8], XmmReg2[56,8]);
    XmmReg1[64,8] = pavgb(XmmReg1[64,8], XmmReg2[64,8]);
    XmmReg1[72,8] = pavgb(XmmReg1[72,8], XmmReg2[72,8]);
    XmmReg1[80,8] = pavgb(XmmReg1[80,8], XmmReg2[80,8]);
    XmmReg1[88,8] = pavgb(XmmReg1[88,8], XmmReg2[88,8]);
    XmmReg1[96,8] = pavgb(XmmReg1[96,8], XmmReg2[96,8]);
    XmmReg1[104,8] = pavgb(XmmReg1[104,8], XmmReg2[104,8]);
    XmmReg1[112,8] = pavgb(XmmReg1[112,8], XmmReg2[112,8]);
    XmmReg1[120,8] = pavgb(XmmReg1[120,8], XmmReg2[120,8]);
}

:PAVGW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE3; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = pavgw(XmmReg[0,16], m[0,16]);
    XmmReg[16,16] = pavgw(XmmReg[16,16], m[16,16]);
    XmmReg[32,16] = pavgw(XmmReg[32,16], m[32,16]);
    XmmReg[48,16] = pavgw(XmmReg[48,16], m[48,16]);
    XmmReg[64,16] = pavgw(XmmReg[64,16], m[64,16]);
    XmmReg[80,16] = pavgw(XmmReg[80,16], m[80,16]);
    XmmReg[96,16] = pavgw(XmmReg[96,16], m[96,16]);
    XmmReg[112,16] = pavgw(XmmReg[112,16], m[112,16]);
}

:PAVGW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE3; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = pavgw(XmmReg1[0,16], XmmReg2[0,16]);
    XmmReg1[16,16] = pavgw(XmmReg1[16,16], XmmReg2[16,16]);
    XmmReg1[32,16] = pavgw(XmmReg1[32,16], XmmReg2[32,16]);
    XmmReg1[48,16] = pavgw(XmmReg1[48,16], XmmReg2[48,16]);
    XmmReg1[64,16] = pavgw(XmmReg1[64,16], XmmReg2[64,16]);
    XmmReg1[80,16] = pavgw(XmmReg1[80,16], XmmReg2[80,16]);
    XmmReg1[96,16] = pavgw(XmmReg1[96,16], XmmReg2[96,16]);
    XmmReg1[112,16] = pavgw(XmmReg1[112,16], XmmReg2[112,16]);
}

:PCMPEQB       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x74; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = (mmxreg[0,8] == m[0,8]) * 0xFF;
    mmxreg[8,8] = (mmxreg[8,8] == m[8,8]) * 0xFF;
    mmxreg[16,8] = (mmxreg[16,8] == m[16,8]) * 0xFF;
    mmxreg[24,8] = (mmxreg[24,8] == m[24,8]) * 0xFF;
    mmxreg[32,8] = (mmxreg[32,8] == m[32,8]) * 0xFF;
    mmxreg[40,8] = (mmxreg[40,8] == m[40,8]) * 0xFF;
    mmxreg[48,8] = (mmxreg[48,8] == m[48,8]) * 0xFF;
    mmxreg[56,8] = (mmxreg[56,8] == m[56,8]) * 0xFF;
}

:PCMPEQB       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x74; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = (mmxreg1[0,8] == mmxreg2[0,8]) * 0xFF;
    mmxreg1[8,8] = (mmxreg1[8,8] == mmxreg2[8,8]) * 0xFF;
    mmxreg1[16,8] = (mmxreg1[16,8] == mmxreg2[16,8]) * 0xFF;
    mmxreg1[24,8] = (mmxreg1[24,8] == mmxreg2[24,8]) * 0xFF;
    mmxreg1[32,8] = (mmxreg1[32,8] == mmxreg2[32,8]) * 0xFF;
    mmxreg1[40,8] = (mmxreg1[40,8] == mmxreg2[40,8]) * 0xFF;
    mmxreg1[48,8] = (mmxreg1[48,8] == mmxreg2[48,8]) * 0xFF;
    mmxreg1[56,8] = (mmxreg1[56,8] == mmxreg2[56,8]) * 0xFF;
}

:PCMPEQW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x75; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = zext(mmxreg[0,16] == m[0,16]) * 0xFFFF;
    mmxreg[16,16] = zext(mmxreg[16,16] == m[16,16]) * 0xFFFF;
    mmxreg[32,16] = zext(mmxreg[32,16] == m[32,16]) * 0xFFFF;
    mmxreg[48,16] = zext(mmxreg[48,16] == m[48,16]) * 0xFFFF;
}

:PCMPEQW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x75; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = zext(mmxreg1[0,16] == mmxreg2[0,16]) * 0xFFFF;
    mmxreg1[16,16] = zext(mmxreg1[16,16] == mmxreg2[16,16]) * 0xFFFF;
    mmxreg1[32,16] = zext(mmxreg1[32,16] == mmxreg2[32,16]) * 0xFFFF;
    mmxreg1[48,16] = zext(mmxreg1[48,16] == mmxreg2[48,16]) * 0xFFFF;
}

:PCMPEQD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x76; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,32] = zext(mmxreg[0,32] == m[0,32]) * 0xFFFFFFFF;
    mmxreg[32,32] = zext(mmxreg[32,32] == m[32,32]) * 0xFFFFFFFF;
}

:PCMPEQD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x76; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = zext(mmxreg1[0,32] == mmxreg2[0,32]) * 0xFFFFFFFF;
    mmxreg1[32,32] = zext(mmxreg1[32,32] == mmxreg2[32,32]) * 0xFFFFFFFF;
}

:PCMPEQB       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x74; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = (XmmReg[0,8] == m[0,8]) * 0xFF;
    XmmReg[8,8] = (XmmReg[8,8] == m[8,8]) * 0xFF;
    XmmReg[16,8] = (XmmReg[16,8] == m[16,8]) * 0xFF;
    XmmReg[24,8] = (XmmReg[24,8] == m[24,8]) * 0xFF;
    XmmReg[32,8] = (XmmReg[32,8] == m[32,8]) * 0xFF;
    XmmReg[40,8] = (XmmReg[40,8] == m[40,8]) * 0xFF;
    XmmReg[48,8] = (XmmReg[48,8] == m[48,8]) * 0xFF;
    XmmReg[56,8] = (XmmReg[56,8] == m[56,8]) * 0xFF;
    XmmReg[64,8] = (XmmReg[64,8] == m[64,8]) * 0xFF;
    XmmReg[72,8] = (XmmReg[72,8] == m[72,8]) * 0xFF;
    XmmReg[80,8] = (XmmReg[80,8] == m[80,8]) * 0xFF;
    XmmReg[88,8] = (XmmReg[88,8] == m[88,8]) * 0xFF;
    XmmReg[96,8] = (XmmReg[96,8] == m[96,8]) * 0xFF;
    XmmReg[104,8] = (XmmReg[104,8] == m[104,8]) * 0xFF;
    XmmReg[112,8] = (XmmReg[112,8] == m[112,8]) * 0xFF;
    XmmReg[120,8] = (XmmReg[120,8] == m[120,8]) * 0xFF;
}

# full set of XMM byte registers
:PCMPEQB       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x74; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = (XmmReg1[0,8] == XmmReg2[0,8]) * 0xFF;
    XmmReg1[8,8] = (XmmReg1[8,8] == XmmReg2[8,8]) * 0xFF;
    XmmReg1[16,8] = (XmmReg1[16,8] == XmmReg2[16,8]) * 0xFF;
    XmmReg1[24,8] = (XmmReg1[24,8] == XmmReg2[24,8]) * 0xFF;
    XmmReg1[32,8] = (XmmReg1[32,8] == XmmReg2[32,8]) * 0xFF;
    XmmReg1[40,8] = (XmmReg1[40,8] == XmmReg2[40,8]) * 0xFF;
    XmmReg1[48,8] = (XmmReg1[48,8] == XmmReg2[48,8]) * 0xFF;
    XmmReg1[56,8] = (XmmReg1[56,8] == XmmReg2[56,8]) * 0xFF;
    XmmReg1[64,8] = (XmmReg1[64,8] == XmmReg2[64,8]) * 0xFF;
    XmmReg1[72,8] = (XmmReg1[72,8] == XmmReg2[72,8]) * 0xFF;
    XmmReg1[80,8] = (XmmReg1[80,8] == XmmReg2[80,8]) * 0xFF;
    XmmReg1[88,8] = (XmmReg1[88,8] == XmmReg2[88,8]) * 0xFF;
    XmmReg1[96,8] = (XmmReg1[96,8] == XmmReg2[96,8]) * 0xFF;
    XmmReg1[104,8] = (XmmReg1[104,8] == XmmReg2[104,8]) * 0xFF;
    XmmReg1[112,8] = (XmmReg1[112,8] == XmmReg2[112,8]) * 0xFF;
    XmmReg1[120,8] = (XmmReg1[120,8] == XmmReg2[120,8]) * 0xFF;
}

:PCMPEQW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x75; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = zext(XmmReg[0,16] == m[0,16]) * 0xFFFF;
    XmmReg[16,16] = zext(XmmReg[16,16] == m[16,16]) * 0xFFFF;
    XmmReg[32,16] = zext(XmmReg[32,16] == m[32,16]) * 0xFFFF;
    XmmReg[48,16] = zext(XmmReg[48,16] == m[48,16]) * 0xFFFF;
    XmmReg[64,16] = zext(XmmReg[64,16] == m[64,16]) * 0xFFFF;
    XmmReg[80,16] = zext(XmmReg[80,16] == m[80,16]) * 0xFFFF;
    XmmReg[96,16] = zext(XmmReg[96,16] == m[96,16]) * 0xFFFF;
    XmmReg[112,16] = zext(XmmReg[112,16] == m[112,16]) * 0xFFFF;
}

:PCMPEQW       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x75; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = zext(XmmReg1[0,16] == XmmReg2[0,16]) * 0xFFFF;
    XmmReg1[16,16] = zext(XmmReg1[16,16] == XmmReg2[16,16]) * 0xFFFF;
    XmmReg1[32,16] = zext(XmmReg1[32,16] == XmmReg2[32,16]) * 0xFFFF;
    XmmReg1[48,16] = zext(XmmReg1[48,16] == XmmReg2[48,16]) * 0xFFFF;
    XmmReg1[64,16] = zext(XmmReg1[64,16] == XmmReg2[64,16]) * 0xFFFF;
    XmmReg1[80,16] = zext(XmmReg1[80,16] == XmmReg2[80,16]) * 0xFFFF;
    XmmReg1[96,16] = zext(XmmReg1[96,16] == XmmReg2[96,16]) * 0xFFFF;
    XmmReg1[112,16] = zext(XmmReg1[112,16] == XmmReg2[112,16]) * 0xFFFF;
}

:PCMPEQD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x76; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = zext(XmmReg[0,32] == m[0,32]) * 0xFFFFFFFF;
    XmmReg[32,32] = zext(XmmReg[32,32] == m[32,32]) * 0xFFFFFFFF;
    XmmReg[64,32] = zext(XmmReg[64,32] == m[64,32]) * 0xFFFFFFFF;
    XmmReg[96,32] = zext(XmmReg[96,32] == m[96,32]) * 0xFFFFFFFF;
}

:PCMPEQD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x76; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = zext(XmmReg1[0,32] == XmmReg2[0,32]) * 0xFFFFFFFF;
    XmmReg1[32,32] = zext(XmmReg1[32,32] == XmmReg2[32,32]) * 0xFFFFFFFF;
    XmmReg1[64,32] = zext(XmmReg1[64,32] == XmmReg2[64,32]) * 0xFFFFFFFF;
    XmmReg1[96,32] = zext(XmmReg1[96,32] == XmmReg2[96,32]) * 0xFFFFFFFF;
}

:PCMPGTB       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x64; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = (mmxreg[0,8] s> m[0,8]) * 0xFF;
    mmxreg[8,8] = (mmxreg[8,8] s> m[8,8]) * 0xFF;
    mmxreg[16,8] = (mmxreg[16,8] s> m[16,8]) * 0xFF;
    mmxreg[24,8] = (mmxreg[24,8] s> m[24,8]) * 0xFF;
    mmxreg[32,8] = (mmxreg[32,8] s> m[32,8]) * 0xFF;
    mmxreg[40,8] = (mmxreg[40,8] s> m[40,8]) * 0xFF;
    mmxreg[48,8] = (mmxreg[48,8] s> m[48,8]) * 0xFF;
    mmxreg[56,8] = (mmxreg[56,8] s> m[56,8]) * 0xFF;
}

:PCMPGTB       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x64; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = (mmxreg1[0,8] s> mmxreg2[0,8]) * 0xFF;
    mmxreg1[8,8] = (mmxreg1[8,8] s> mmxreg2[8,8]) * 0xFF;
    mmxreg1[16,8] = (mmxreg1[16,8] s> mmxreg2[16,8]) * 0xFF;
    mmxreg1[24,8] = (mmxreg1[24,8] s> mmxreg2[24,8]) * 0xFF;
    mmxreg1[32,8] = (mmxreg1[32,8] s> mmxreg2[32,8]) * 0xFF;
    mmxreg1[40,8] = (mmxreg1[40,8] s> mmxreg2[40,8]) * 0xFF;
    mmxreg1[48,8] = (mmxreg1[48,8] s> mmxreg2[48,8]) * 0xFF;
    mmxreg1[56,8] = (mmxreg1[56,8] s> mmxreg2[56,8]) * 0xFF;
}

:PCMPGTW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x65; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = zext(mmxreg[0,16] s> m[0,16]) * 0xFFFF;
    mmxreg[16,16] = zext(mmxreg[16,16] s> m[16,16]) * 0xFFFF;
    mmxreg[32,16] = zext(mmxreg[32,16] s> m[32,16]) * 0xFFFF;
    mmxreg[48,16] = zext(mmxreg[48,16] s> m[48,16]) * 0xFFFF;
}

:PCMPGTW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x65; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = zext(mmxreg1[0,16] s> mmxreg2[0,16]) * 0xFFFF;
    mmxreg1[16,16] = zext(mmxreg1[16,16] s> mmxreg2[16,16]) * 0xFFFF;
    mmxreg1[32,16] = zext(mmxreg1[32,16] s> mmxreg2[32,16]) * 0xFFFF;
    mmxreg1[48,16] = zext(mmxreg1[48,16] s> mmxreg2[48,16]) * 0xFFFF;
}

:PCMPGTD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x66; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,32] = zext(mmxreg[0,32] s> m[0,32]) * 0xFFFFFFFF;
    mmxreg[32,32] = zext(mmxreg[32,32] s> m[32,32]) * 0xFFFFFFFF;
}

:PCMPGTD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x66; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = zext(mmxreg1[0,32] s> mmxreg2[0,32]) * 0xFFFFFFFF;
    mmxreg1[32,32] = zext(mmxreg1[32,32] s> mmxreg2[32,32]) * 0xFFFFFFFF;
}

:PCMPGTB       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x64; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = (XmmReg[0,8] s> m[0,8]) * 0xFF;
    XmmReg[8,8] = (XmmReg[8,8] s> m[8,8]) * 0xFF;
    XmmReg[16,8] = (XmmReg[16,8] s> m[16,8]) * 0xFF;
    XmmReg[24,8] = (XmmReg[24,8] s> m[24,8]) * 0xFF;
    XmmReg[32,8] = (XmmReg[32,8] s> m[32,8]) * 0xFF;
    XmmReg[40,8] = (XmmReg[40,8] s> m[40,8]) * 0xFF;
    XmmReg[48,8] = (XmmReg[48,8] s> m[48,8]) * 0xFF;
    XmmReg[56,8] = (XmmReg[56,8] s> m[56,8]) * 0xFF;
    XmmReg[64,8] = (XmmReg[64,8] s> m[64,8]) * 0xFF;
    XmmReg[72,8] = (XmmReg[72,8] s> m[72,8]) * 0xFF;
    XmmReg[80,8] = (XmmReg[80,8] s> m[80,8]) * 0xFF;
    XmmReg[88,8] = (XmmReg[88,8] s> m[88,8]) * 0xFF;
    XmmReg[96,8] = (XmmReg[96,8] s> m[96,8]) * 0xFF;
    XmmReg[104,8] = (XmmReg[104,8] s> m[104,8]) * 0xFF;
    XmmReg[112,8] = (XmmReg[112,8] s> m[112,8]) * 0xFF;
    XmmReg[120,8] = (XmmReg[120,8] s> m[120,8]) * 0xFF;
}

# full set of XMM byte registers
:PCMPGTB       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x64; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = (XmmReg1[0,8] s> XmmReg2[0,8]) * 0xFF;
    XmmReg1[8,8] = (XmmReg1[8,8] s> XmmReg2[8,8]) * 0xFF;
    XmmReg1[16,8] = (XmmReg1[16,8] s> XmmReg2[16,8]) * 0xFF;
    XmmReg1[24,8] = (XmmReg1[24,8] s> XmmReg2[24,8]) * 0xFF;
    XmmReg1[32,8] = (XmmReg1[32,8] s> XmmReg2[32,8]) * 0xFF;
    XmmReg1[40,8] = (XmmReg1[40,8] s> XmmReg2[40,8]) * 0xFF;
    XmmReg1[48,8] = (XmmReg1[48,8] s> XmmReg2[48,8]) * 0xFF;
    XmmReg1[56,8] = (XmmReg1[56,8] s> XmmReg2[56,8]) * 0xFF;
    XmmReg1[64,8] = (XmmReg1[64,8] s> XmmReg2[64,8]) * 0xFF;
    XmmReg1[72,8] = (XmmReg1[72,8] s> XmmReg2[72,8]) * 0xFF;
    XmmReg1[80,8] = (XmmReg1[80,8] s> XmmReg2[80,8]) * 0xFF;
    XmmReg1[88,8] = (XmmReg1[88,8] s> XmmReg2[88,8]) * 0xFF;
    XmmReg1[96,8] = (XmmReg1[96,8] s> XmmReg2[96,8]) * 0xFF;
    XmmReg1[104,8] = (XmmReg1[104,8] s> XmmReg2[104,8]) * 0xFF;
    XmmReg1[112,8] = (XmmReg1[112,8] s> XmmReg2[112,8]) * 0xFF;
    XmmReg1[120,8] = (XmmReg1[120,8] s> XmmReg2[120,8]) * 0xFF;
}

:PCMPGTW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x65; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = zext(XmmReg[0,16] s> m[0,16]) * 0xFFFF;
    XmmReg[16,16] = zext(XmmReg[16,16] s> m[16,16]) * 0xFFFF;
    XmmReg[32,16] = zext(XmmReg[32,16] s> m[32,16]) * 0xFFFF;
    XmmReg[48,16] = zext(XmmReg[48,16] s> m[48,16]) * 0xFFFF;
    XmmReg[64,16] = zext(XmmReg[64,16] s> m[64,16]) * 0xFFFF;
    XmmReg[80,16] = zext(XmmReg[80,16] s> m[80,16]) * 0xFFFF;
    XmmReg[96,16] = zext(XmmReg[96,16] s> m[96,16]) * 0xFFFF;
    XmmReg[112,16] = zext(XmmReg[112,16] s> m[112,16]) * 0xFFFF;
}

:PCMPGTW       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x65; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = zext(XmmReg1[0,16] s> XmmReg2[0,16]) * 0xFFFF;
    XmmReg1[16,16] = zext(XmmReg1[16,16] s> XmmReg2[16,16]) * 0xFFFF;
    XmmReg1[32,16] = zext(XmmReg1[32,16] s> XmmReg2[32,16]) * 0xFFFF;
    XmmReg1[48,16] = zext(XmmReg1[48,16] s> XmmReg2[48,16]) * 0xFFFF;
    XmmReg1[64,16] = zext(XmmReg1[64,16] s> XmmReg2[64,16]) * 0xFFFF;
    XmmReg1[80,16] = zext(XmmReg1[80,16] s> XmmReg2[80,16]) * 0xFFFF;
    XmmReg1[96,16] = zext(XmmReg1[96,16] s> XmmReg2[96,16]) * 0xFFFF;
    XmmReg1[112,16] = zext(XmmReg1[112,16] s> XmmReg2[112,16]) * 0xFFFF;
}

:PCMPGTD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x66; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = zext(XmmReg[0,32] s> m[0,32]) * 0xFFFFFFFF;
    XmmReg[32,32] = zext(XmmReg[32,32] s> m[32,32]) * 0xFFFFFFFF;
    XmmReg[64,32] = zext(XmmReg[64,32] s> m[64,32]) * 0xFFFFFFFF;
    XmmReg[96,32] = zext(XmmReg[96,32] s> m[96,32]) * 0xFFFFFFFF;
}

:PCMPGTD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x66; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = zext(XmmReg1[0,32] s> XmmReg2[0,32]) * 0xFFFFFFFF;
    XmmReg1[32,32] = zext(XmmReg1[32,32] s> XmmReg2[32,32]) * 0xFFFFFFFF;
    XmmReg1[64,32] = zext(XmmReg1[64,32] s> XmmReg2[64,32]) * 0xFFFFFFFF;
    XmmReg1[96,32] = zext(XmmReg1[96,32] s> XmmReg2[96,32]) * 0xFFFFFFFF;
}

:PEXTRW        Reg32, mmxreg2, imm8 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC5; Reg32 & check_Reg32_dest & mmxreg2; imm8
{
    temp:8 = mmxreg2 >> ( (imm8 & 0x03) * 16 );
    Reg32 = zext(temp:2);
    build check_Reg32_dest;
}

:PEXTRW        Reg32, XmmReg2, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC5; Reg32 & XmmReg2 & check_Reg32_dest; imm8
{
    local shift:1 = (imm8 & 0x7) * 16:1;
    local low:1 = shift < 64:1;
    local temp:8;
    conditionalAssign(temp,low,XmmReg2[0,64] >> shift, XmmReg2[64,64] >> (shift-64));
    Reg32 = zext(temp:2);
    build check_Reg32_dest;
}

#break PEXTRW with reg/mem dest into two constructors to handle zext in register case
:PEXTRW        Rmr32, XmmReg1, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x15; (mod = 3 & Rmr32 & check_Rmr32_dest) & XmmReg1 ; imm8
{
    local shift:1 = (imm8 & 0x7) * 16:1;
    local low:1 = shift < 64:1;
    local temp:8;
    conditionalAssign(temp,low,XmmReg1[0,64] >> shift,XmmReg1[64,64] >> (shift - 64));
    Rmr32 = zext(temp:2);
    build check_Rmr32_dest;
}

:PEXTRW        m16, XmmReg1, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x15; XmmReg1 ... & m16; imm8
{
   local shift:1 = (imm8 & 0x7) * 16:1;
   local low:1 = shift < 64:1;
   local temp:8;
   conditionalAssign(temp,low,XmmReg1[0,64] >> shift,XmmReg1[64,64] >> (shift - 64));
   m16 = temp:2; 
}

define pcodeop phaddd;
:PHADDD        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x02; mmxreg ... & m64                          { mmxreg=phaddd(mmxreg,m64); }
:PHADDD        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x02; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phaddd(mmxreg1,mmxreg2); }
:PHADDD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x02; XmmReg ... & m128              { XmmReg=phaddd(XmmReg,m128); }
:PHADDD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x02; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phaddd(XmmReg1,XmmReg2); }

define pcodeop phaddw;
:PHADDW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x01; mmxreg ... & m64                          { mmxreg=phaddw(mmxreg,m64); }
:PHADDW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x01; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phaddw(mmxreg1,mmxreg2); }
:PHADDW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x01; XmmReg ... & m128              { XmmReg=phaddw(XmmReg,m128); }
:PHADDW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x01; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phaddw(XmmReg1,XmmReg2); }

define pcodeop phaddsw;
:PHADDSW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x03; mmxreg ... & m64                          { mmxreg=phaddsw(mmxreg,m64); }
:PHADDSW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x03; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phaddsw(mmxreg1,mmxreg2); }
:PHADDSW       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x03; XmmReg ... & m128              { XmmReg=phaddsw(XmmReg,m128); }
:PHADDSW       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x03; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phaddsw(XmmReg1,XmmReg2); }

define pcodeop phsubd;
:PHSUBD        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x06; mmxreg ... & m64                          { mmxreg=phsubd(mmxreg,m64); }
:PHSUBD        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x06; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phsubd(mmxreg1,mmxreg2); }
:PHSUBD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x06; XmmReg ... & m128              { XmmReg=phsubd(XmmReg,m128); }
:PHSUBD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x06; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phsubd(XmmReg1,XmmReg2); }

define pcodeop phsubw;
:PHSUBW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x05; mmxreg ... & m64                          { mmxreg=phsubw(mmxreg,m64); }
:PHSUBW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x05; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phsubw(mmxreg1,mmxreg2); }
:PHSUBW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x05; XmmReg ... & m128              { XmmReg=phsubw(XmmReg,m128); }
:PHSUBW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x05; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phsubw(XmmReg1,XmmReg2); }

define pcodeop phsubsw;
:PHSUBSW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x07; mmxreg ... & m64                          { mmxreg=phsubsw(mmxreg,m64); }
:PHSUBSW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x07; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phsubsw(mmxreg1,mmxreg2); }
:PHSUBSW       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x07; XmmReg ... & m128              { XmmReg=phsubsw(XmmReg,m128); }
:PHSUBSW       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x07; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phsubsw(XmmReg1,XmmReg2); }

:PINSRW        mmxreg, Rmr32, imm8 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC4; mmxmod=3 & Rmr32 & mmxreg; imm8 
{ 
    local destIndex:1 = (imm8 & 0x7) * 16:1;
    mmxreg = mmxreg & ~(0xffff:8 << destIndex);
    local newVal:8 = zext(Rmr32[0,16]);
    mmxreg = mmxreg | (newVal << destIndex);
}

:PINSRW        mmxreg, m16, imm8 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC4; m16 & mmxreg ... ; imm8 
{ 
    local destIndex:1 = (imm8 & 0x7) * 16:1;
    mmxreg = mmxreg & ~(0xffff:8 << destIndex);
    local newVal:8 = zext(m16);
    mmxreg = mmxreg | (newVal << destIndex);
}

:PINSRW        XmmReg, Rmr32, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC4; xmmmod=3 & Rmr32 & XmmReg; imm8 
{ 
    local destIndex:1 = (imm8 & 0x7) * 16:1;
    local useLow:1 = destIndex < 64:1;
    local newLow:8 = zext(Rmr32:2) << destIndex;
    newLow = (XmmReg[0,64] & ~(0xffff:8 << destIndex)) |  newLow;
    local newHigh:8 = zext(Rmr32:2) << (destIndex-64:1);
    newHigh = (XmmReg[64,64] & ~(0xffff:8 << (destIndex - 64:1))) | newHigh;
    conditionalAssign(XmmReg[0,64],useLow,newLow,XmmReg[0,64]);
    conditionalAssign(XmmReg[64,64],!useLow,newHigh,XmmReg[64,64]);
}

:PINSRW        XmmReg, m16, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC4; m16 & XmmReg ...; imm8 
{ 
    local destIndex:1 = (imm8 & 0x7) * 16:1;
    local useLow:1 = destIndex < 64:1;
    local newLow:8 = zext(m16) << destIndex;
    newLow = (XmmReg[0,64] & ~(0xffff:8 << destIndex)) |  newLow;
    local newHigh:8 = zext(m16) << (destIndex-64:1);
    newHigh = (XmmReg[64,64] & ~(0xffff:8 << (destIndex - 64:1))) | newHigh;
    conditionalAssign(XmmReg[0,64],useLow,newLow,XmmReg[0,64]);
    conditionalAssign(XmmReg[64,64],!useLow,newHigh,XmmReg[64,64]);
}

define pcodeop pmaddubsw;
:PMADDUBSW     mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x04; mmxreg ... & m64                          { mmxreg=pmaddubsw(mmxreg,m64); }
:PMADDUBSW     mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x04; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=pmaddubsw(mmxreg1,mmxreg2); }
:PMADDUBSW     XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x04; XmmReg ... & m128              { XmmReg=pmaddubsw(XmmReg,m128); }
:PMADDUBSW     XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x04; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pmaddubsw(XmmReg1,XmmReg2); }

define pcodeop pmaddwd;
:PMADDWD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF5; mmxreg ... & m64 { mmxreg = pmaddwd(mmxreg, m64); }
:PMADDWD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF5; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pmaddwd(mmxreg1, mmxreg2); }
:PMADDWD       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF5; XmmReg ... & m128 { XmmReg = pmaddwd(XmmReg, m128); }
:PMADDWD       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF5; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pmaddwd(XmmReg1, XmmReg2); }

:PMAXSW        mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEE; mmxreg1 ... & mmxreg2_m64 
{ 
    local srcCopy:8 = mmxreg2_m64;
    conditionalAssign(mmxreg1[0,16],srcCopy[0,16] s> mmxreg1[0,16],srcCopy[0,16],mmxreg1[0,16]); 
    conditionalAssign(mmxreg1[16,16],srcCopy[16,16] s> mmxreg1[16,16],srcCopy[16,16],mmxreg1[16,16]); 
    conditionalAssign(mmxreg1[32,16],srcCopy[32,16] s> mmxreg1[32,16],srcCopy[32,16],mmxreg1[32,16]); 
    conditionalAssign(mmxreg1[48,16],srcCopy[48,16] s> mmxreg1[48,16],srcCopy[48,16],mmxreg1[48,16]); 
}

:PMAXSW        XmmReg1, XmmReg2_m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEE; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128; 
    conditionalAssign(XmmReg1[0,16],srcCopy[0,16] s> XmmReg1[0,16],srcCopy[0,16],XmmReg1[0,16]);
    conditionalAssign(XmmReg1[16,16],srcCopy[16,16] s> XmmReg1[16,16],srcCopy[16,16],XmmReg1[16,16]);
    conditionalAssign(XmmReg1[32,16],srcCopy[32,16] s> XmmReg1[32,16],srcCopy[32,16],XmmReg1[32,16]);
    conditionalAssign(XmmReg1[48,16],srcCopy[48,16] s> XmmReg1[48,16],srcCopy[48,16],XmmReg1[48,16]);
    conditionalAssign(XmmReg1[64,16],srcCopy[64,16] s> XmmReg1[64,16],srcCopy[64,16],XmmReg1[64,16]);
    conditionalAssign(XmmReg1[80,16],srcCopy[80,16] s> XmmReg1[80,16],srcCopy[80,16],XmmReg1[80,16]);
    conditionalAssign(XmmReg1[96,16],srcCopy[96,16] s> XmmReg1[96,16],srcCopy[96,16],XmmReg1[96,16]);
    conditionalAssign(XmmReg1[112,16],srcCopy[112,16] s> XmmReg1[112,16],srcCopy[112,16],XmmReg1[112,16]);
}

:PMAXUB        mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDE; mmxreg1 ... & mmxreg2_m64 
{ 
    local srcCopy:8 = mmxreg2_m64;
    conditionalAssign(mmxreg1[0,8],srcCopy[0,8] > mmxreg1[0,8],srcCopy[0,8],mmxreg1[0,8]); 
    conditionalAssign(mmxreg1[8,8],srcCopy[8,8] > mmxreg1[8,8],srcCopy[8,8],mmxreg1[8,8]); 
    conditionalAssign(mmxreg1[16,8],srcCopy[16,8] > mmxreg1[16,8],srcCopy[16,8],mmxreg1[16,8]); 
    conditionalAssign(mmxreg1[24,8],srcCopy[24,8] > mmxreg1[24,8],srcCopy[24,8],mmxreg1[24,8]); 
    conditionalAssign(mmxreg1[32,8],srcCopy[32,8] > mmxreg1[32,8],srcCopy[32,8],mmxreg1[32,8]); 
    conditionalAssign(mmxreg1[40,8],srcCopy[40,8] > mmxreg1[40,8],srcCopy[40,8],mmxreg1[40,8]); 
    conditionalAssign(mmxreg1[48,8],srcCopy[48,8] > mmxreg1[48,8],srcCopy[48,8],mmxreg1[48,8]); 
    conditionalAssign(mmxreg1[56,8],srcCopy[56,8] > mmxreg1[56,8],srcCopy[56,8],mmxreg1[56,8]); 
}

:PMAXUB        XmmReg1, XmmReg2_m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDE; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,8],srcCopy[0,8] > XmmReg1[0,8],srcCopy[0,8],XmmReg1[0,8]); 
    conditionalAssign(XmmReg1[8,8],srcCopy[8,8] > XmmReg1[8,8],srcCopy[8,8],XmmReg1[8,8]); 
    conditionalAssign(XmmReg1[16,8],srcCopy[16,8] > XmmReg1[16,8],srcCopy[16,8],XmmReg1[16,8]); 
    conditionalAssign(XmmReg1[24,8],srcCopy[24,8] > XmmReg1[24,8],srcCopy[24,8],XmmReg1[24,8]); 
    conditionalAssign(XmmReg1[32,8],srcCopy[32,8] > XmmReg1[32,8],srcCopy[32,8],XmmReg1[32,8]); 
    conditionalAssign(XmmReg1[40,8],srcCopy[40,8] > XmmReg1[40,8],srcCopy[40,8],XmmReg1[40,8]); 
    conditionalAssign(XmmReg1[48,8],srcCopy[48,8] > XmmReg1[48,8],srcCopy[48,8],XmmReg1[48,8]); 
    conditionalAssign(XmmReg1[56,8],srcCopy[56,8] > XmmReg1[56,8],srcCopy[56,8],XmmReg1[56,8]); 
    conditionalAssign(XmmReg1[64,8],srcCopy[64,8] > XmmReg1[64,8],srcCopy[64,8],XmmReg1[64,8]); 
    conditionalAssign(XmmReg1[72,8],srcCopy[72,8] > XmmReg1[72,8],srcCopy[72,8],XmmReg1[72,8]); 
    conditionalAssign(XmmReg1[80,8],srcCopy[80,8] > XmmReg1[80,8],srcCopy[80,8],XmmReg1[80,8]); 
    conditionalAssign(XmmReg1[88,8],srcCopy[88,8] > XmmReg1[88,8],srcCopy[88,8],XmmReg1[88,8]); 
    conditionalAssign(XmmReg1[96,8],srcCopy[96,8] > XmmReg1[96,8],srcCopy[96,8],XmmReg1[96,8]); 
    conditionalAssign(XmmReg1[104,8],srcCopy[104,8] > XmmReg1[104,8],srcCopy[104,8],XmmReg1[104,8]); 
    conditionalAssign(XmmReg1[112,8],srcCopy[112,8] > XmmReg1[112,8],srcCopy[112,8],XmmReg1[112,8]); 
    conditionalAssign(XmmReg1[120,8],srcCopy[120,8] > XmmReg1[120,8],srcCopy[120,8],XmmReg1[120,8]); 
}

:PMINSW        mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEA; mmxreg1 ... & mmxreg2_m64 
{ 
    local srcCopy:8 = mmxreg2_m64;
    conditionalAssign(mmxreg1[0,16],srcCopy[0,16] s< mmxreg1[0,16],srcCopy[0,16],mmxreg1[0,16]); 
    conditionalAssign(mmxreg1[16,16],srcCopy[16,16] s< mmxreg1[16,16],srcCopy[16,16],mmxreg1[16,16]); 
    conditionalAssign(mmxreg1[32,16],srcCopy[32,16] s< mmxreg1[32,16],srcCopy[32,16],mmxreg1[32,16]); 
    conditionalAssign(mmxreg1[48,16],srcCopy[48,16] s< mmxreg1[48,16],srcCopy[48,16],mmxreg1[48,16]); 
}

:PMINSW        XmmReg1, XmmReg2_m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEA; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128; 
    conditionalAssign(XmmReg1[0,16],srcCopy[0,16] s< XmmReg1[0,16],srcCopy[0,16],XmmReg1[0,16]);
    conditionalAssign(XmmReg1[16,16],srcCopy[16,16] s< XmmReg1[16,16],srcCopy[16,16],XmmReg1[16,16]);
    conditionalAssign(XmmReg1[32,16],srcCopy[32,16] s< XmmReg1[32,16],srcCopy[32,16],XmmReg1[32,16]);
    conditionalAssign(XmmReg1[48,16],srcCopy[48,16] s< XmmReg1[48,16],srcCopy[48,16],XmmReg1[48,16]);
    conditionalAssign(XmmReg1[64,16],srcCopy[64,16] s< XmmReg1[64,16],srcCopy[64,16],XmmReg1[64,16]);
    conditionalAssign(XmmReg1[80,16],srcCopy[80,16] s< XmmReg1[80,16],srcCopy[80,16],XmmReg1[80,16]);
    conditionalAssign(XmmReg1[96,16],srcCopy[96,16] s< XmmReg1[96,16],srcCopy[96,16],XmmReg1[96,16]);
    conditionalAssign(XmmReg1[112,16],srcCopy[112,16] s< XmmReg1[112,16],srcCopy[112,16],XmmReg1[112,16]);
}

:PMINUB        mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDA; mmxreg1 ... & mmxreg2_m64 
{ 
    local srcCopy:8 = mmxreg2_m64;
    conditionalAssign(mmxreg1[0,8],srcCopy[0,8] < mmxreg1[0,8],srcCopy[0,8],mmxreg1[0,8]); 
    conditionalAssign(mmxreg1[8,8],srcCopy[8,8] < mmxreg1[8,8],srcCopy[8,8],mmxreg1[8,8]); 
    conditionalAssign(mmxreg1[16,8],srcCopy[16,8] < mmxreg1[16,8],srcCopy[16,8],mmxreg1[16,8]); 
    conditionalAssign(mmxreg1[24,8],srcCopy[24,8] < mmxreg1[24,8],srcCopy[24,8],mmxreg1[24,8]); 
    conditionalAssign(mmxreg1[32,8],srcCopy[32,8] < mmxreg1[32,8],srcCopy[32,8],mmxreg1[32,8]); 
    conditionalAssign(mmxreg1[40,8],srcCopy[40,8] < mmxreg1[40,8],srcCopy[40,8],mmxreg1[40,8]); 
    conditionalAssign(mmxreg1[48,8],srcCopy[48,8] < mmxreg1[48,8],srcCopy[48,8],mmxreg1[48,8]); 
    conditionalAssign(mmxreg1[56,8],srcCopy[56,8] < mmxreg1[56,8],srcCopy[56,8],mmxreg1[56,8]); 
}

:PMINUB        XmmReg1, XmmReg2_m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDA; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,8],srcCopy[0,8] < XmmReg1[0,8],srcCopy[0,8],XmmReg1[0,8]); 
    conditionalAssign(XmmReg1[8,8],srcCopy[8,8] < XmmReg1[8,8],srcCopy[8,8],XmmReg1[8,8]); 
    conditionalAssign(XmmReg1[16,8],srcCopy[16,8] < XmmReg1[16,8],srcCopy[16,8],XmmReg1[16,8]); 
    conditionalAssign(XmmReg1[24,8],srcCopy[24,8] < XmmReg1[24,8],srcCopy[24,8],XmmReg1[24,8]); 
    conditionalAssign(XmmReg1[32,8],srcCopy[32,8] < XmmReg1[32,8],srcCopy[32,8],XmmReg1[32,8]); 
    conditionalAssign(XmmReg1[40,8],srcCopy[40,8] < XmmReg1[40,8],srcCopy[40,8],XmmReg1[40,8]); 
    conditionalAssign(XmmReg1[48,8],srcCopy[48,8] < XmmReg1[48,8],srcCopy[48,8],XmmReg1[48,8]); 
    conditionalAssign(XmmReg1[56,8],srcCopy[56,8] < XmmReg1[56,8],srcCopy[56,8],XmmReg1[56,8]); 
    conditionalAssign(XmmReg1[64,8],srcCopy[64,8] < XmmReg1[64,8],srcCopy[64,8],XmmReg1[64,8]); 
    conditionalAssign(XmmReg1[72,8],srcCopy[72,8] < XmmReg1[72,8],srcCopy[72,8],XmmReg1[72,8]); 
    conditionalAssign(XmmReg1[80,8],srcCopy[80,8] < XmmReg1[80,8],srcCopy[80,8],XmmReg1[80,8]); 
    conditionalAssign(XmmReg1[88,8],srcCopy[88,8] < XmmReg1[88,8],srcCopy[88,8],XmmReg1[88,8]); 
    conditionalAssign(XmmReg1[96,8],srcCopy[96,8] < XmmReg1[96,8],srcCopy[96,8],XmmReg1[96,8]); 
    conditionalAssign(XmmReg1[104,8],srcCopy[104,8] < XmmReg1[104,8],srcCopy[104,8],XmmReg1[104,8]); 
    conditionalAssign(XmmReg1[112,8],srcCopy[112,8] < XmmReg1[112,8],srcCopy[112,8],XmmReg1[112,8]); 
    conditionalAssign(XmmReg1[120,8],srcCopy[120,8] < XmmReg1[120,8],srcCopy[120,8],XmmReg1[120,8]); 
}

#in 64-bit mode the default operand size is 64 bits
#note that gcc assembles pmovmskb eax, mm0 and pmovmskb rax, mm0 to 0f d7 c0
:PMOVMSKB       Reg32, mmxreg2   is vexMode=0 & mandover=0 & byte=0x0F; byte=0xD7; mod = 3 & Reg32 & mmxreg2 & check_Reg32_dest
{ 
	local byte_mask:1 = 0:1;
	byte_mask[0,1] = mmxreg2[7,1];
	byte_mask[1,1] = mmxreg2[15,1];
	byte_mask[2,1] = mmxreg2[23,1];
	byte_mask[3,1] = mmxreg2[31,1];
	byte_mask[4,1] = mmxreg2[39,1];
	byte_mask[5,1] = mmxreg2[47,1];
	byte_mask[6,1] = mmxreg2[55,1];
	byte_mask[7,1] = mmxreg2[63,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}

#in 64-bit mode the default operand size is 64 bits
#note that gcc assembles pmovmskb eax, xmm0 and pmovmskb rax, xmm0 to 66 0f d7 c0
:PMOVMSKB       Reg32, XmmReg2   is vexMode=0 &   $(PRE_66) & byte=0x0F; byte=0xD7; mod = 3 & Reg32 & XmmReg2 & check_Reg32_dest
{ 
	local byte_mask:2 = 0:2;
	byte_mask[0,1] = XmmReg2[7,1];
	byte_mask[1,1] = XmmReg2[15,1];
	byte_mask[2,1] = XmmReg2[23,1];
	byte_mask[3,1] = XmmReg2[31,1];
	byte_mask[4,1] = XmmReg2[39,1];
	byte_mask[5,1] = XmmReg2[47,1];
	byte_mask[6,1] = XmmReg2[55,1];
	byte_mask[7,1] = XmmReg2[63,1];
	byte_mask[8,1] = XmmReg2[71,1];
	byte_mask[9,1] = XmmReg2[79,1];
	byte_mask[10,1] = XmmReg2[87,1];
	byte_mask[11,1] = XmmReg2[95,1];
	byte_mask[12,1] = XmmReg2[103,1];
	byte_mask[13,1] = XmmReg2[111,1];
	byte_mask[14,1] = XmmReg2[119,1];
	byte_mask[15,1] = XmmReg2[127,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}
	
define pcodeop pmulhrsw;
:PMULHRSW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0B; mmxreg ... & m64                          { mmxreg=pmulhrsw(mmxreg,m64); }
:PMULHRSW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0B; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=pmulhrsw(mmxreg1,mmxreg2); }
:PMULHRSW       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0B; XmmReg ... & m128              { XmmReg=pmulhrsw(XmmReg,m128); }
:PMULHRSW       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0B; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pmulhrsw(XmmReg1,XmmReg2); }

define pcodeop pmulhuw;
:PMULHUW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE4; mmxreg ... & m64 { mmxreg = pmulhuw(mmxreg, m64); }
:PMULHUW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE4; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pmulhuw(mmxreg1, mmxreg2); }
:PMULHUW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE4; XmmReg ... & m128 { XmmReg = pmulhuw(XmmReg, m128); }
:PMULHUW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE4; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pmulhuw(XmmReg1, XmmReg2); }

macro pmulhw64(mmx1, mmx2) {
	local tmp0:8 = sext(mmx1[ 0,16]) * sext(mmx2[ 0,16]);
    mmx1[ 0,16] = tmp0[16,16];
	local tmp1:8 = sext(mmx1[16,16]) * sext(mmx2[16,16]);
    mmx1[16,16] = tmp1[16,16];
	local tmp2:8 = sext(mmx1[32,16]) * sext(mmx2[32,16]);
    mmx1[32,16] = tmp2[16,16];
	local tmp3:8 = sext(mmx1[48,16]) * sext(mmx2[48,16]);
    mmx1[48,16] = tmp3[16,16];
}
:PMULHW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE5; mmxreg ... & m64                { pmulhw64(mmxreg, m64); }
:PMULHW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE5; mmxmod = 3 & mmxreg1 & mmxreg2  { pmulhw64(mmxreg1, mmxreg2); }

macro pmulhw128(xmm1, xmm2) {
	local tmp0:8 = sext(xmm1[  0,16]) * sext(xmm2[  0,16]);
    xmm1[  0,16] = tmp0[16,16];
	local tmp1:8 = sext(xmm1[ 16,16]) * sext(xmm2[ 16,16]);
    xmm1[ 16,16] = tmp1[16,16];
	local tmp2:8 = sext(xmm1[ 32,16]) * sext(xmm2[ 32,16]);
    xmm1[ 32,16] = tmp2[16,16];
	local tmp3:8 = sext(xmm1[ 48,16]) * sext(xmm2[ 48,16]);
    xmm1[ 48,16] = tmp3[16,16];
	local tmp4:8 = sext(xmm1[ 64,16]) * sext(xmm2[ 64,16]);
    xmm1[ 64,16] = tmp4[16,16];
	local tmp5:8 = sext(xmm1[ 80,16]) * sext(xmm2[ 80,16]);
    xmm1[ 80,16] = tmp5[16,16];
	local tmp6:8 = sext(xmm1[ 96,16]) * sext(xmm2[ 96,16]);
    xmm1[ 96,16] = tmp6[16,16];
	local tmp7:8 = sext(xmm1[112,16]) * sext(xmm2[112,16]);
    xmm1[112,16] = tmp7[16,16];
}
:PMULHW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE5; XmmReg ... & m128                { pmulhw128(XmmReg, m128); }
:PMULHW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE5; xmmmod = 3 & XmmReg1 & XmmReg2   { pmulhw128(XmmReg1, XmmReg2); }

:PMULLW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD5; mmxreg ... & m64 {
  local m:8 = m64;
  mmxreg[0,16] = mmxreg[0,16] * m[0,16];
  mmxreg[16,16] = mmxreg[16,16] * m[16,16];
  mmxreg[32,16] = mmxreg[32,16] * m[32,16];
  mmxreg[48,16] = mmxreg[48,16] * m[48,16];
}

:PMULLW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD5; mmxmod = 3 & mmxreg1 & mmxreg2 {
  mmxreg1[0,16] = mmxreg1[0,16] * mmxreg2[0,16];
  mmxreg1[16,16] = mmxreg1[16,16] * mmxreg2[16,16];
  mmxreg1[32,16] = mmxreg1[32,16] * mmxreg2[32,16];
  mmxreg1[48,16] = mmxreg1[48,16] * mmxreg2[48,16];
}

:PMULLW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD5; XmmReg ... & m128 {
  local m:16 = m128;
  XmmReg[0,16] = XmmReg[0,16] * m[0,16];
  XmmReg[16,16] = XmmReg[16,16] * m[16,16];
  XmmReg[32,16] = XmmReg[32,16] * m[32,16];
  XmmReg[48,16] = XmmReg[48,16] * m[48,16];
  XmmReg[64,16] = XmmReg[64,16] * m[64,16];
  XmmReg[80,16] = XmmReg[80,16] * m[80,16];
  XmmReg[96,16] = XmmReg[96,16] * m[96,16];
  XmmReg[112,16] = XmmReg[112,16] * m[112,16];
}

:PMULLW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD5; xmmmod = 3 & XmmReg1 & XmmReg2 {
  XmmReg1[0,16] = XmmReg1[0,16] * XmmReg2[0,16];
  XmmReg1[16,16] = XmmReg1[16,16] * XmmReg2[16,16];
  XmmReg1[32,16] = XmmReg1[32,16] * XmmReg2[32,16];
  XmmReg1[48,16] = XmmReg1[48,16] * XmmReg2[48,16];
  XmmReg1[64,16] = XmmReg1[64,16] * XmmReg2[64,16];
  XmmReg1[80,16] = XmmReg1[80,16] * XmmReg2[80,16];
  XmmReg1[96,16] = XmmReg1[96,16] * XmmReg2[96,16];
  XmmReg1[112,16] = XmmReg1[112,16] * XmmReg2[112,16];
 }

:PMULUDQ        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF4; mmxreg ... & m64
{
    local a:8 = zext(mmxreg[0,32]);
    local b:8 = zext(m64[0,32]);
    mmxreg = a * b;
}

:PMULUDQ        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF4; mmxmod = 3 & mmxreg1 & mmxreg2
{
    local a:8 = zext(mmxreg1[0,32]);
    local b:8 = zext(mmxreg2[0,32]);
    mmxreg1 = a * b;
}

:PMULUDQ        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF4; XmmReg ... & m128
{
    local a:8 = zext(XmmReg[0,32]);
    local b:8 = zext(m128[0,32]);
    XmmReg[0,64]  = a * b;
    local c:8 = zext(XmmReg[64,32]);
    local d:8 = zext(m128[64,32]);
    XmmReg[64,64] = c * d;
}

:PMULUDQ        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF4; xmmmod = 3 & XmmReg1 & XmmReg2
{
    local a:8 = zext(XmmReg1[0,32]);
    local b:8 = zext(XmmReg2[0,32]);
    XmmReg1[0,64]  = a * b;
    local c:8 = zext(XmmReg1[64,32]);
    local d:8 = zext(XmmReg2[64,32]);
    XmmReg1[64,64] = c * d;
}

:POR            mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEB; mmxreg ... & m64				{ mmxreg = mmxreg | m64; }
:POR            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEB; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1 = mmxreg1 | mmxreg2; }
:POR            XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEB; XmmReg ... & m128			    { XmmReg = XmmReg | m128; }
:POR            XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEB; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = XmmReg1 | XmmReg2; }

define pcodeop psadbw;
:PSADBW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF6; mmxreg ... & m64 { mmxreg = psadbw(mmxreg, m64); }
:PSADBW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF6; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psadbw(mmxreg1, mmxreg2); }
:PSADBW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF6; XmmReg ... & m128 { XmmReg = psadbw(XmmReg, m128); }
:PSADBW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF6; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psadbw(XmmReg1, XmmReg2); }

# these byte and word shuffles need to be done also ?????
define pcodeop pshufb;
:PSHUFB         mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x00; mmxreg1 ... & mmxreg2_m64                          { mmxreg1=pshufb(mmxreg1,mmxreg2_m64); }
:PSHUFB         XmmReg1, XmmReg2_m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x00; XmmReg1 ... & XmmReg2_m128              { XmmReg1=pshufb(XmmReg1,XmmReg2_m128); }

# determine the total shift required by the bit fields in a shuffle opcode
Order0: order0  is imm8 [ order0 = ( imm8       & 0x3); ] { export *[const]:1 order0; }
Order1: order1  is imm8 [ order1 = ((imm8 >> 2) & 0x3); ] { export *[const]:1 order1; }
Order2: order2  is imm8 [ order2 = ((imm8 >> 4) & 0x3); ] { export *[const]:1 order2; }
Order3: order3  is imm8 [ order3 = ((imm8 >> 6) & 0x3); ] { export *[const]:1 order3; }

macro shuffle_4(dest,ord,c0,c1,c2,c3){
    dest = zext(ord == 0) * c0 + zext(ord == 1) * c1 + zext(ord == 2) * c2 + zext(ord == 3) * c3;
}

:PSHUFD         XmmReg1, XmmReg2_m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; (XmmReg2_m128 & XmmReg1 ...); imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = XmmReg2_m128[0,32];
    local c1 = XmmReg2_m128[32,32];
    local c2 = XmmReg2_m128[64,32];
    local c3 = XmmReg2_m128[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}

define pcodeop pshufhw;
:PSHUFHW        XmmReg1, XmmReg2_m128, imm8     is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x70; XmmReg2_m128 & XmmReg1 ...; imm8 { XmmReg1 = pshufhw(XmmReg1, XmmReg2_m128, imm8:8); }

define pcodeop pshuflw;
:PSHUFLW        XmmReg1, XmmReg2_m128, imm8     is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x70; XmmReg2_m128 & XmmReg1 ...; imm8 { XmmReg1 = pshuflw(XmmReg1, XmmReg2_m128, imm8:8); }

define pcodeop pshufw;
:PSHUFW         mmxreg1, mmxreg2_m64, imm8       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x70; mmxreg2_m64 & mmxreg1 ...; imm8 { mmxreg1 = pshufw(mmxreg1, mmxreg2_m64, imm8:8); }

define pcodeop psignb;
:PSIGNB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x08; mmxreg ... & m64                          { mmxreg=psignb(mmxreg,m64); }
:PSIGNB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x08; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=psignb(mmxreg1,mmxreg2); }
:PSIGNB         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x08; XmmReg ... & m128              { XmmReg=psignb(XmmReg,m128); }
:PSIGNB         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x08; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=psignb(XmmReg1,XmmReg2); }

define pcodeop psignw;
:PSIGNW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x09; mmxreg ... & m64                          { mmxreg=psignw(mmxreg,m64); }
:PSIGNW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x09; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=psignw(mmxreg1,mmxreg2); }
:PSIGNW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x09; XmmReg ... & m128              { XmmReg=psignw(XmmReg,m128); }
:PSIGNW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x09; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=psignw(XmmReg1,XmmReg2); }

define pcodeop psignd;
:PSIGND         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0a; mmxreg ... & m64                          { mmxreg=psignd(mmxreg,m64); }
:PSIGND         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0a; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=psignd(mmxreg1,mmxreg2); }
:PSIGND         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0a; XmmReg ... & m128              { XmmReg=psignd(XmmReg,m128); }
:PSIGND         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0a; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=psignd(XmmReg1,XmmReg2); }

#break into two 64-bit chunks so decompiler can follow constants
:PSLLDQ         XmmReg2, imm8    is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x73; xmmmod = 3 & reg_opcode=7 & XmmReg2; imm8 
{ 
	if (imm8:1 > 15:1) goto <zero>;
    local low64copy:8 = XmmReg2[0,64];
    XmmReg2[0,64] = XmmReg2[0,64] << (8:1 * imm8:1);
    if (imm8:1 > 8:1)  goto <greater>;
    XmmReg2[64,64] = (XmmReg2[64,64] << (8:1 * imm8:1)) | (low64copy >> (8:1 * (8 - imm8:1)));
    goto <end>;
<greater>
    XmmReg2[64,64] = low64copy << (8:1 * (imm8 - 8));
    goto <end>;
<zero>
    XmmReg2[0,64] = 0:8;
    XmmReg2[64,64] = 0:8;
<end>
}

macro psllw64(mmx, count) {
    local tmp:8 = count;
    mmx[ 0,16] = mmx[ 0,16] << tmp;
    mmx[16,16] = mmx[16,16] << tmp;
    mmx[32,16] = mmx[32,16] << tmp;
    mmx[48,16] = mmx[48,16] << tmp;
}
:PSLLW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF1; mmxreg ... & m64 ...                        { psllw64(mmxreg, m64); }
:PSLLW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF1; mmxmod = 3 & mmxreg1 & mmxreg2              { psllw64(mmxreg1, mmxreg2); }
:PSLLW          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=6 & mmxreg2; imm8   { psllw64(mmxreg2, imm8:8); }

:PSLLD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF2; mmxreg ... & m64 ... {
  local m:8 = m64;
  mmxreg[0,32] = mmxreg[0,32] << m[0,32];
  mmxreg[32,32] = mmxreg[32,32] << m[32,32];
}

:PSLLD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF2; mmxmod = 3 & mmxreg1 & mmxreg2 {
  mmxreg1[0,32] = mmxreg1[0,32] << mmxreg2[0,32];
  mmxreg1[32,32] = mmxreg1[32,32] << mmxreg2[32,32];
}

:PSLLD          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=6 & mmxreg2; imm8 {
  mmxreg2[0,32] = mmxreg2[0,32] << imm8;
  mmxreg2[32,32] = mmxreg2[32,32] << imm8;
}

:PSLLQ          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF3; mmxreg ... & m64 ... { mmxreg = mmxreg << m64; }
:PSLLQ          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF3; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = mmxreg1 << mmxreg2; }
:PSLLQ          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=6 & mmxreg2; imm8 { mmxreg2 = mmxreg2 << imm8:8; }

macro psllw128(xmm, count) {
    local tmp:8 = count:8;
    xmm[  0,16] = xmm[  0,16] << tmp;
    xmm[ 16,16] = xmm[ 16,16] << tmp;
    xmm[ 32,16] = xmm[ 32,16] << tmp;
    xmm[ 48,16] = xmm[ 48,16] << tmp;
    xmm[ 64,16] = xmm[ 64,16] << tmp;
    xmm[ 80,16] = xmm[ 80,16] << tmp;
    xmm[ 96,16] = xmm[ 96,16] << tmp;
    xmm[112,16] = xmm[112,16] << tmp;
}
:PSLLW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF1; XmmReg ... & m128 ...                       { psllw128(XmmReg, m128); }
:PSLLW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF1; xmmmod = 3 & XmmReg1 & XmmReg2              { psllw128(XmmReg1, XmmReg2); }
:PSLLW          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=6 & XmmReg2; imm8   { local count:8 = imm8; psllw128(XmmReg2, count); }

:PSLLD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF2; XmmReg ... & m128 ... {
  local m:16 = m128;
  XmmReg[0,32] = XmmReg[0,32] << m[0,32];
  XmmReg[32,32] = XmmReg[32,32] << m[32,32];
  XmmReg[64,32] = XmmReg[64,32] << m[64,32];
  XmmReg[96,32] = XmmReg[96,32] << m[96,32];
}

:PSLLD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF2; xmmmod = 3 & XmmReg1 & XmmReg2 {
  XmmReg1[0,32] = XmmReg1[0,32] << XmmReg2[0,32];
  XmmReg1[32,32] = XmmReg1[32,32] << XmmReg2[32,32];
  XmmReg1[64,32] = XmmReg1[64,32] << XmmReg2[64,32];
  XmmReg1[96,32] = XmmReg1[96,32] << XmmReg2[96,32];
}

:PSLLD          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=6 & XmmReg2; imm8 {
  XmmReg2[0,32] = XmmReg2[0,32] << imm8;
  XmmReg2[32,32] = XmmReg2[32,32] << imm8;
  XmmReg2[64,32] = XmmReg2[64,32] << imm8;
  XmmReg2[96,32] = XmmReg2[96,32] << imm8;
}
                    
:PSLLQ          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF3; XmmReg ... & m128 ... {
  local m:16 = m128;
  XmmReg[0,64] = XmmReg[0,64] << m[0,64];
  XmmReg[64,64] = XmmReg[64,64] << m[64,64];
}

:PSLLQ          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF3; xmmmod = 3 & XmmReg1 & XmmReg2 {
  XmmReg1[0,64] = XmmReg1[0,64] << XmmReg2[0,64];
  XmmReg1[64,64] = XmmReg1[64,64] << XmmReg2[64,64];
}

:PSLLQ          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=6 & XmmReg2; imm8 {
  XmmReg2[0,64] = XmmReg2[0,64] << imm8;
  XmmReg2[64,64] = XmmReg2[64,64] << imm8;
}

macro psraw64(mmx, count) {
    local tmp:8 = count;
    mmx[ 0,16] = mmx[ 0,16] s>> tmp;
    mmx[16,16] = mmx[16,16] s>> tmp;
    mmx[32,16] = mmx[32,16] s>> tmp;
    mmx[48,16] = mmx[48,16] s>> tmp;
}
:PSRAW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE1; mmxreg ... & m64 ... { psraw64(mmxreg, m64); }
:PSRAW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE1; mmxmod = 3 & mmxreg1 & mmxreg2 { psraw64(mmxreg1, mmxreg2); }
:PSRAW          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=4 & mmxreg2; imm8 { psraw64(mmxreg2, imm8:8); }
                    
:PSRAD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE2; mmxreg ... & m64
{
# a count greater than 31 just clears all the bits
    mmxreg[0,32] = mmxreg[0,32] s>> m64;
    mmxreg[32,32] = mmxreg[32,32] s>> m64;
}

:PSRAD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE2; mmxmod = 3 & mmxreg1 & mmxreg2
{
# a count greater than 31 just clears all the bits
    mmxreg1[0,32] = mmxreg1[0,32] s>> mmxreg2;
    mmxreg1[32,32] = mmxreg1[32,32] s>> mmxreg2;
}

:PSRAD          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=4 & mmxreg2; imm8
{
# a count greater than 31 just clears all the bits
    mmxreg2[0,32] = mmxreg2[0,32] s>> imm8;
    mmxreg2[32,32] = mmxreg2[32,32] s>> imm8;
}

macro psraw128(xmm, count) {
    local tmp:8 = count:8;
    xmm[  0,16] = xmm[  0,16] s>> tmp;
    xmm[ 16,16] = xmm[ 16,16] s>> tmp;
    xmm[ 32,16] = xmm[ 32,16] s>> tmp;
    xmm[ 48,16] = xmm[ 48,16] s>> tmp;
    xmm[ 64,16] = xmm[ 64,16] s>> tmp;
    xmm[ 80,16] = xmm[ 80,16] s>> tmp;
    xmm[ 96,16] = xmm[ 96,16] s>> tmp;
    xmm[112,16] = xmm[112,16] s>> tmp;
}
:PSRAW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE1; XmmReg ... & m128 ...                       { psraw128(XmmReg, m128); }
:PSRAW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE1; xmmmod = 3 & XmmReg1 & XmmReg2              { psraw128(XmmReg1, XmmReg2); }
:PSRAW          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=4 & XmmReg2; imm8   { local count:8 = imm8; psraw128(XmmReg2, count); }
                    
:PSRAD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE2; m128 & XmmReg ...
{
# a count greater than 31 just clears all the bits
    XmmReg[0,32] = XmmReg[0,32] s>> m128;
    XmmReg[32,32] = XmmReg[32,32] s>> m128;
    XmmReg[64,32] = XmmReg[64,32] s>> m128;
    XmmReg[96,32] = XmmReg[96,32] s>> m128;
}

:PSRAD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE2; xmmmod = 3 & XmmReg1 & XmmReg2
{
# a count greater than 31 just clears all the bits
    XmmReg1[0,32] = XmmReg1[0,32] s>> XmmReg2;
    XmmReg1[32,32] = XmmReg1[32,32] s>> XmmReg2;
    XmmReg1[64,32] = XmmReg1[64,32] s>> XmmReg2;
    XmmReg1[96,32] = XmmReg1[96,32] s>> XmmReg2;
}

:PSRAD          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=4 & XmmReg2; imm8
{
# a count greater than 31 just clears all the bits
    XmmReg2[0,32] = XmmReg2[0,32] s>> imm8;
    XmmReg2[32,32] = XmmReg2[32,32] s>> imm8;
    XmmReg2[64,32] = XmmReg2[64,32] s>> imm8;
    XmmReg2[96,32] = XmmReg2[96,32] s>> imm8;
}

:PSRLDQ         XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x73; xmmmod=3 & reg_opcode=3 & XmmReg2; imm8
{
# a count greater than 15 just clears all the bits
    XmmReg2 = XmmReg2 >> (imm8 * 8);
}

:PSRLW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD1; mmxreg ... & m64 ...
{
    mmxreg[0,16]  = mmxreg[0,16]  >> m64;
    mmxreg[16,16] = mmxreg[16,16] >> m64;
    mmxreg[32,16] = mmxreg[32,16] >> m64;
    mmxreg[48,16] = mmxreg[48,16] >> m64;
}

:PSRLW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD1; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16]  = mmxreg1[0,16]  >> mmxreg2;
    mmxreg1[16,16] = mmxreg1[16,16] >> mmxreg2;
    mmxreg1[32,16] = mmxreg1[32,16] >> mmxreg2;
    mmxreg1[48,16] = mmxreg1[48,16] >> mmxreg2;
}

:PSRLW          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=2 & mmxreg2; imm8
{
    mmxreg2[0,16]  = mmxreg2[0,16]  >> imm8;
    mmxreg2[16,16] = mmxreg2[16,16] >> imm8;
    mmxreg2[32,16] = mmxreg2[32,16] >> imm8;
    mmxreg2[48,16] = mmxreg2[48,16] >> imm8;
}
                    
:PSRLD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD2; mmxreg ... & m64 ...
{
    mmxreg[0,32]  = mmxreg[0,32]  >> m64;
    mmxreg[32,32] = mmxreg[32,32] >> m64;
}

:PSRLD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD2; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32]  = mmxreg1[0,32]  >> mmxreg2;
    mmxreg1[32,32] = mmxreg1[32,32] >> mmxreg2;
}

:PSRLD          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=2 & mmxreg2; imm8
{
    mmxreg2[0,32]  = mmxreg2[0,32]  >> imm8;
    mmxreg2[32,32] = mmxreg2[32,32] >> imm8;
}

:PSRLQ          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD3; mmxreg ... & m64 ...
{
    mmxreg = mmxreg >> m64;
 }

:PSRLQ          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD3; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1 = mmxreg1 >> mmxreg2;
}

:PSRLQ          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=2 & mmxreg2; imm8
{
    mmxreg2 = mmxreg2 >> imm8;
}
                   
:PSRLW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD1; XmmReg ... & m128 ...
{
    XmmReg[0,16]   = XmmReg[0,16]   >> m128[0,64];
    XmmReg[16,16]  = XmmReg[16,16]  >> m128[0,64];
    XmmReg[32,16]  = XmmReg[32,16]  >> m128[0,64];
    XmmReg[48,16]  = XmmReg[48,16]  >> m128[0,64];
    XmmReg[64,16]  = XmmReg[64,16]  >> m128[0,64];
    XmmReg[80,16]  = XmmReg[80,16]  >> m128[0,64];
    XmmReg[96,16]  = XmmReg[96,16]  >> m128[0,64];
    XmmReg[112,16] = XmmReg[112,16] >> m128[0,64];
}

:PSRLW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD1; xmmmod = 3 & XmmReg1 & XmmReg2
{
    #save this off in case XmmReg1 and XmmReg2 are the same register
    local count:8 = XmmReg2[0,64];
    
    XmmReg1[0,16]   = XmmReg1[0,16]   >> count;
    XmmReg1[16,16]  = XmmReg1[16,16]  >> count;
    XmmReg1[32,16]  = XmmReg1[32,16]  >> count;
    XmmReg1[48,16]  = XmmReg1[48,16]  >> count;
    XmmReg1[64,16]  = XmmReg1[64,16]  >> count;
    XmmReg1[80,16]  = XmmReg1[80,16]  >> count;
    XmmReg1[96,16]  = XmmReg1[96,16]  >> count;
    XmmReg1[112,16] = XmmReg1[112,16] >> count;
}

:PSRLW          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=2 & XmmReg2; imm8
{
    XmmReg2[0,16]   = XmmReg2[0,16]   >> imm8;
    XmmReg2[16,16]  = XmmReg2[16,16]  >> imm8;
    XmmReg2[32,16]  = XmmReg2[32,16]  >> imm8;
    XmmReg2[48,16]  = XmmReg2[48,16]  >> imm8;
    XmmReg2[64,16]  = XmmReg2[64,16]  >> imm8;
    XmmReg2[80,16]  = XmmReg2[80,16]  >> imm8;
    XmmReg2[96,16]  = XmmReg2[96,16]  >> imm8;
    XmmReg2[112,16] = XmmReg2[112,16] >> imm8;
}

:PSRLD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD2; XmmReg ... & m128 ...
{
    XmmReg[0,32]  = XmmReg[0,32]  >> m128[0,64];
    XmmReg[32,32] = XmmReg[32,32] >> m128[0,64];
    XmmReg[64,32] = XmmReg[64,32] >> m128[0,64];
    XmmReg[96,32] = XmmReg[96,32] >> m128[0,64];
}

:PSRLD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD2; xmmmod = 3 & XmmReg1 & XmmReg2
{
    #save this off in case XmmReg1 and XmmReg2 are the same register
    local count = XmmReg2[0,64];
    
    XmmReg1[0,32]  = XmmReg1[0,32]  >> count;
    XmmReg1[32,32] = XmmReg1[32,32] >> count;
    XmmReg1[64,32] = XmmReg1[64,32] >> count;
    XmmReg1[96,32] = XmmReg1[96,32] >> count;
}

:PSRLD          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=2 & XmmReg2; imm8
{
    XmmReg2[0,32]  = XmmReg2[0,32]  >> imm8;
    XmmReg2[32,32] = XmmReg2[32,32] >> imm8;
    XmmReg2[64,32] = XmmReg2[64,32] >> imm8;
    XmmReg2[96,32] = XmmReg2[96,32] >> imm8;
}
                    
:PSRLQ          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD3; XmmReg ... & m128 ...
{
    XmmReg[0,64]  = XmmReg[0,64]  >> m128[0,64];
    XmmReg[64,64] = XmmReg[64,64] >> m128[0,64];
}

:PSRLQ          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD3; xmmmod = 3 & XmmReg1 & XmmReg2
{
    #save this off in case XmmReg1 and XmmReg2 are the same register
    local count = XmmReg2[0,64];
    
    XmmReg1[0,64]  = XmmReg1[0,64]  >> count;
    XmmReg1[64,64] = XmmReg1[64,64] >> count;
}

:PSRLQ          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=2 & XmmReg2; imm8
{
    XmmReg2[0,64]  = XmmReg2[0,64]  >> imm8;
    XmmReg2[64,64] = XmmReg2[64,64] >> imm8;
}

:PSUBB           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF8; mmxreg ... & m64 ...
{
    local m:8 = m64;
    mmxreg[0,8]  = mmxreg[0,8]  - m[0,8];
    mmxreg[8,8]  = mmxreg[8,8]  - m[8,8];
    mmxreg[16,8] = mmxreg[16,8] - m[16,8];
    mmxreg[24,8] = mmxreg[24,8] - m[24,8];
    mmxreg[32,8] = mmxreg[32,8] - m[32,8];
    mmxreg[40,8] = mmxreg[40,8] - m[40,8];
    mmxreg[48,8] = mmxreg[48,8] - m[48,8];
    mmxreg[56,8] = mmxreg[56,8] - m[56,8];
}

:PSUBB           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF8; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] =  mmxreg1[0,8] -  mmxreg2[0,8];
    mmxreg1[16,8] = mmxreg1[16,8] - mmxreg2[16,8];
    mmxreg1[24,8] = mmxreg1[24,8] - mmxreg2[24,8];
    mmxreg1[32,8] = mmxreg1[32,8] - mmxreg2[32,8];
    mmxreg1[40,8] = mmxreg1[40,8] - mmxreg2[40,8];
    mmxreg1[48,8] = mmxreg1[48,8] - mmxreg2[48,8];
    mmxreg1[56,8] = mmxreg1[56,8] - mmxreg2[56,8];
}
                    
:PSUBW           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF9; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = mmxreg[0,16] - m[0,16];
    mmxreg[16,16] = mmxreg[16,16] - m[16,16];
    mmxreg[32,16] = mmxreg[32,16] - m[32,16];
    mmxreg[48,16] = mmxreg[48,16] - m[48,16];
}

:PSUBW           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF9; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = mmxreg1[0,16] - mmxreg2[0,16];
    mmxreg1[16,16] = mmxreg1[16,16] - mmxreg2[16,16];
    mmxreg1[32,16] = mmxreg1[32,16] - mmxreg2[32,16];
    mmxreg1[48,16] = mmxreg1[48,16] - mmxreg2[48,16];
}
                    
:PSUBD           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFA; mmxreg ... & m64 ...
{
	local m:8 = m64;
	mmxreg[0,32] = mmxreg[0,32] - m[0,32];
	mmxreg[32,32] = mmxreg[32,32] - m[32,32];
}

:PSUBD           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFA; mmxmod = 3 & mmxreg1 & mmxreg2
{
	mmxreg1[0,32] = mmxreg1[0,32] - mmxreg2[0,32];
	mmxreg1[32,32] = mmxreg1[32,32] - mmxreg2[32,32];
}

:PSUBQ           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFB; mmxreg ... & m64 ...			{ mmxreg = mmxreg - m64; }
:PSUBQ           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFB; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = mmxreg1 - mmxreg2; }
:PSUBQ           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFB; XmmReg ... & m128 ...
{
	local m:16 = m128;
	XmmReg[0,64] = XmmReg[0,64] - m[0,64];
	XmmReg[64,64] = XmmReg[64,64] - m[64,64];
}

:PSUBQ           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFB; xmmmod = 3 & XmmReg1 & XmmReg2
{
	XmmReg1[0,64] = XmmReg1[0,64] - XmmReg2[0,64];
	XmmReg1[64,64] = XmmReg1[64,64] - XmmReg2[64,64];
}

:PSUBB           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF8; XmmReg ... & m128 ...
{
    local m:16 = m128;
    XmmReg[0,8]   = XmmReg[0,8]   - m[0,8];
    XmmReg[8,8]   = XmmReg[8,8]   - m[8,8];
    XmmReg[16,8]  = XmmReg[16,8]  - m[16,8];
    XmmReg[24,8]  = XmmReg[24,8]  - m[24,8];
    XmmReg[32,8]  = XmmReg[32,8]  - m[32,8];
    XmmReg[40,8]  = XmmReg[40,8]  - m[40,8];
    XmmReg[48,8]  = XmmReg[48,8]  - m[48,8];
    XmmReg[56,8]  = XmmReg[56,8]  - m[56,8];
    XmmReg[64,8]  = XmmReg[64,8]  - m[64,8];
    XmmReg[72,8]  = XmmReg[72,8]  - m[72,8];
    XmmReg[80,8]  = XmmReg[80,8]  - m[80,8];
    XmmReg[88,8]  = XmmReg[88,8]  - m[88,8];
    XmmReg[96,8]  = XmmReg[96,8]  - m[96,8];
    XmmReg[104,8] = XmmReg[104,8] - m[104,8];
    XmmReg[112,8] = XmmReg[112,8] - m[112,8];
    XmmReg[120,8] = XmmReg[120,8] - m[120,8];
}

:PSUBB           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF8; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8]   = XmmReg1[0,8]   - XmmReg2[0,8];
    XmmReg1[8,8]   = XmmReg1[8,8]   - XmmReg2[8,8];
    XmmReg1[16,8]  = XmmReg1[16,8]  - XmmReg2[16,8];
    XmmReg1[24,8]  = XmmReg1[24,8]  - XmmReg2[24,8];
    XmmReg1[32,8]  = XmmReg1[32,8]  - XmmReg2[32,8];
    XmmReg1[40,8]  = XmmReg1[40,8]  - XmmReg2[40,8];
    XmmReg1[48,8]  = XmmReg1[48,8]  - XmmReg2[48,8];
    XmmReg1[56,8]  = XmmReg1[56,8]  - XmmReg2[56,8];
    XmmReg1[64,8]  = XmmReg1[64,8]  - XmmReg2[64,8];
    XmmReg1[72,8]  = XmmReg1[72,8]  - XmmReg2[72,8];
    XmmReg1[80,8]  = XmmReg1[80,8]  - XmmReg2[80,8];
    XmmReg1[88,8]  = XmmReg1[88,8]  - XmmReg2[88,8];
    XmmReg1[96,8]  = XmmReg1[96,8]  - XmmReg2[96,8];
    XmmReg1[104,8] = XmmReg1[104,8] - XmmReg2[104,8];
    XmmReg1[112,8] = XmmReg1[112,8] - XmmReg2[112,8];
    XmmReg1[120,8] = XmmReg1[120,8] - XmmReg2[120,8];
}
                    
:PSUBW           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF9; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = XmmReg[0,16] - m[0,16];
    XmmReg[16,16] = XmmReg[16,16] - m[16,16];
    XmmReg[32,16] = XmmReg[32,16] - m[32,16];
    XmmReg[48,16] = XmmReg[48,16] - m[48,16];
    XmmReg[64,16] = XmmReg[64,16] - m[64,16];
    XmmReg[80,16] = XmmReg[80,16] - m[80,16];
    XmmReg[96,16] = XmmReg[96,16] - m[96,16];
    XmmReg[112,16] = XmmReg[112,16] - m[112,16];
}

:PSUBW           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF9; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = XmmReg1[0,16] - XmmReg2[0,16];
    XmmReg1[16,16] = XmmReg1[16,16] - XmmReg2[16,16];
    XmmReg1[32,16] = XmmReg1[32,16] - XmmReg2[32,16];
    XmmReg1[48,16] = XmmReg1[48,16] - XmmReg2[48,16];
    XmmReg1[64,16] = XmmReg1[64,16] - XmmReg2[64,16];
    XmmReg1[80,16] = XmmReg1[80,16] - XmmReg2[80,16];
    XmmReg1[96,16] = XmmReg1[96,16] - XmmReg2[96,16];
    XmmReg1[112,16] = XmmReg1[112,16] - XmmReg2[112,16];
}
                    
:PSUBD           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFA; XmmReg ... & m128 ...
{
  local m:16 = m128;
  XmmReg[0,32] = XmmReg[0,32] - m[0,32];
  XmmReg[32,32] = XmmReg[32,32] - m[32,32];
  XmmReg[64,32] = XmmReg[64,32] - m[64,32];
  XmmReg[96,32] = XmmReg[96,32] - m[96,32];
}

:PSUBD           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFA; xmmmod = 3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = XmmReg1[0,32] - XmmReg2[0,32];
  XmmReg1[32,32] = XmmReg1[32,32] - XmmReg2[32,32];
  XmmReg1[64,32] = XmmReg1[64,32] - XmmReg2[64,32];
  XmmReg1[96,32] = XmmReg1[96,32] - XmmReg2[96,32];
}

define pcodeop psubsb;
:PSUBSB          mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE8; mmxreg1 ... & mmxreg2_m64 ... { mmxreg1 = psubsb(mmxreg1, mmxreg2_m64); }

define pcodeop psubsw;
:PSUBSW          mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE9; mmxreg1 ... & mmxreg2_m64 ... { mmxreg1 = psubsw(mmxreg1, mmxreg2_m64); }

:PSUBSB          XmmReg1, XmmReg2_m128      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xE8; XmmReg1 ... & XmmReg2_m128 ... { XmmReg1 = psubsb(XmmReg1, XmmReg2_m128); }

:PSUBSW          XmmReg1, XmmReg2_m128      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xE9; XmmReg1 ... & XmmReg2_m128 ... { XmmReg1 = psubsw(XmmReg1, XmmReg2_m128); }

define pcodeop psubusb;
:PSUBUSB         mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD8; mmxreg1 ... & mmxreg2_m64 ... { mmxreg1 = psubusb(mmxreg1, mmxreg2_m64); }

define pcodeop psubusw;
:PSUBUSW         mmxreg1, mmxreg2_m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD9; mmxreg1 ... & mmxreg2_m64 ... { mmxreg1 = psubusw(mmxreg1, mmxreg2_m64); }

:PSUBUSB         XmmReg1, XmmReg2_m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD8; XmmReg1 ... & XmmReg2_m128 { XmmReg1 = psubusb(XmmReg1, XmmReg2_m128); }

:PSUBUSW         XmmReg1, XmmReg2_m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD9; XmmReg1 ... & XmmReg2_m128 { XmmReg1 = psubusw(XmmReg1, XmmReg2_m128); }

:PUNPCKHBW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x68; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = mmxreg[32,8];
    mmxreg[8,8] =    m[32,8];
    mmxreg[16,8] = mmxreg[40,8];
    mmxreg[24,8] =    m[40,8];
    mmxreg[32,8] = mmxreg[48,8];
    mmxreg[40,8] =    m[48,8];
    mmxreg[48,8] = mmxreg[56,8];
    mmxreg[56,8] =    m[56,8];
}

:PUNPCKHBW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x68; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = mmxreg1[32,8];
    mmxreg1[8,8] = mmxreg2[32,8];
    mmxreg1[16,8] = mmxreg1[40,8];
    mmxreg1[24,8] = mmxreg2[40,8];
    mmxreg1[32,8] = mmxreg1[48,8];
    mmxreg1[40,8] = mmxreg2[48,8];
    mmxreg1[48,8] = mmxreg1[56,8];
    mmxreg1[56,8] = mmxreg2[56,8];
}
                    
:PUNPCKHWD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x69; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = mmxreg[32,16];
    mmxreg[16,16] =    m[32,16];
    mmxreg[32,16] = mmxreg[48,16];
    mmxreg[48,16] =    m[48,16];
}

:PUNPCKHWD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x69; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = mmxreg1[32,16];
    mmxreg1[16,16] = mmxreg2[32,16];
    mmxreg1[32,16] = mmxreg1[48,16];
    mmxreg1[48,16] = mmxreg2[48,16];
}
                    
:PUNPCKHDQ       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6A; mmxreg ... & m64
{
    mmxreg[0,32] = mmxreg[32,32];
    mmxreg[32,32] =    m64[32,32];
}

:PUNPCKHDQ       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6A; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = mmxreg1[32,32];
    mmxreg1[32,32] = mmxreg2[32,32];
}

:PUNPCKHBW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x68; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = XmmReg[64,8];
    XmmReg[8,8] =   m[64,8];
    XmmReg[16,8] = XmmReg[72,8];
    XmmReg[24,8] =   m[72,8];
    XmmReg[32,8] = XmmReg[80,8];
    XmmReg[40,8] =   m[80,8];
    XmmReg[48,8] = XmmReg[88,8];
    XmmReg[56,8] =   m[88,8];
    XmmReg[64,8] = XmmReg[96,8];
    XmmReg[72,8] =   m[96,8];
    XmmReg[80,8] = XmmReg[104,8];
    XmmReg[88,8] =   m[104,8];
    XmmReg[96,8] = XmmReg[112,8];
    XmmReg[104,8] =   m[112,8];
    XmmReg[112,8] = XmmReg[120,8];
    XmmReg[120,8] =   m[120,8];
}

# full set of XMM byte registers
:PUNPCKHBW  XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x68; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = XmmReg1[64,8];
    XmmReg1[8,8] = XmmReg2[64,8];
    XmmReg1[16,8] = XmmReg1[72,8];
    XmmReg1[24,8] = XmmReg2[72,8];
    XmmReg1[32,8] = XmmReg1[80,8];
    XmmReg1[40,8] = XmmReg2[80,8];
    XmmReg1[48,8] = XmmReg1[88,8];
    XmmReg1[56,8] = XmmReg2[88,8];
    XmmReg1[64,8] = XmmReg1[96,8];
    XmmReg1[72,8] = XmmReg2[96,8];
    XmmReg1[80,8] = XmmReg1[104,8];
    XmmReg1[88,8] = XmmReg2[104,8];
    XmmReg1[96,8] = XmmReg1[112,8];
    XmmReg1[104,8] = XmmReg2[112,8];
    XmmReg1[112,8] = XmmReg1[120,8];
    XmmReg1[120,8] = XmmReg2[120,8];
}
                                      
:PUNPCKHWD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x69; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = XmmReg[64,16];
    XmmReg[16,16] =   m[64,16];
    XmmReg[32,16] = XmmReg[80,16];
    XmmReg[48,16] =   m[80,16];
    XmmReg[64,16] = XmmReg[96,16];
    XmmReg[80,16] =   m[96,16];
    XmmReg[96,16] = XmmReg[112,16];
    XmmReg[112,16] =   m[112,16];
}

:PUNPCKHWD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x69; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = XmmReg1[64,16];
    XmmReg1[16,16] = XmmReg2[64,16];
    XmmReg1[32,16] = XmmReg1[80,16];
    XmmReg1[48,16] = XmmReg2[80,16];
    XmmReg1[64,16] = XmmReg1[96,16];
    XmmReg1[80,16] = XmmReg2[96,16];
    XmmReg1[96,16] = XmmReg1[112,16];
    XmmReg1[112,16] = XmmReg2[112,16];
}
                     
:PUNPCKHDQ       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6A; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[64,32];
    XmmReg[32,32] =   m[64,32];
    XmmReg[64,32] = XmmReg[96,32];
    XmmReg[96,32] =   m[96,32];
}

:PUNPCKHDQ       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6A; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[64,32];
    XmmReg1[32,32] = XmmReg2[64,32];
    XmmReg1[64,32] = XmmReg1[96,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}

:PUNPCKHQDQ      XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6D; m128 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[64,64];
    XmmReg[64,64] =   m128[64,64];
}

:PUNPCKHQDQ      XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6D; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}

:PUNPCKLBW       mmxreg, m32      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x60; mmxreg ... & m32
{
    local m:4 = m32;
    mmxreg[56,8] =    m[24,8];
    mmxreg[48,8] = mmxreg[24,8];
    mmxreg[40,8] =    m[16,8];
    mmxreg[32,8] = mmxreg[16,8];
    mmxreg[24,8] =    m[8,8];
    mmxreg[16,8] = mmxreg[8,8];
    mmxreg[8,8] =    m[0,8];
#   mmxreg[0,8] = mmxreg[0,8]; superfluous
}
    
:PUNPCKLBW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x60; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[56,8] = mmxreg2[24,8];
    mmxreg1[48,8] = mmxreg1[24,8];
    mmxreg1[40,8] = mmxreg2[16,8];
    mmxreg1[32,8] = mmxreg1[16,8];
    mmxreg1[24,8] = mmxreg2[8,8];
    mmxreg1[16,8] = mmxreg1[8,8];
    mmxreg1[8,8] = mmxreg2[0,8];
#   mmxreg1[0,8] = mmxreg1[0,8]; superfluous
}
    
:PUNPCKLWD       mmxreg, m32      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x61; mmxreg ... & m32
{
    local m:4 = m32;
    mmxreg[48,16] =    m[16,16];
    mmxreg[32,16] = mmxreg[16,16];
    mmxreg[16,16] =    m[0,16];
#   mmxreg[0,16] = mmxreg[0,16]; superfluous
}

:PUNPCKLWD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x61; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[48,16] = mmxreg2[16,16];
    mmxreg1[32,16] = mmxreg1[16,16];
    mmxreg1[16,16] = mmxreg2[0,16];
#   mmxreg1[0,16] = mmxreg1[0,16]; superfluous
}

:PUNPCKLDQ       mmxreg, m32      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x62; mmxreg ... & m32
{
    mmxreg[32,32] =    m32;
#   mmxreg[0,32] = mmxreg[0,32]; superfluous
}

:PUNPCKLDQ       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x62; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[32,32] = mmxreg2[0,32];
#   mmxreg1[0,32] = mmxreg1[0,32]; superfluous
}

:PUNPCKLBW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x60; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[120,8] =   m[56,8];
    XmmReg[112,8] = XmmReg[56,8];
    XmmReg[104,8] =   m[48,8];
    XmmReg[96,8] = XmmReg[48,8];
    XmmReg[88,8] =   m[40,8];
    XmmReg[80,8] = XmmReg[40,8];
    XmmReg[72,8] =   m[32,8];
    XmmReg[64,8] = XmmReg[32,8];
    XmmReg[56,8] =   m[24,8];
    XmmReg[48,8] = XmmReg[24,8];
    XmmReg[40,8] =   m[16,8];
    XmmReg[32,8] = XmmReg[16,8];
    XmmReg[24,8] =   m[8,8];
    XmmReg[16,8] = XmmReg[8,8];
    XmmReg[8,8] =   m[0,8];
#   XmmReg[0,8] = XmmReg[0,8]; superfluous
}

:PUNPCKLBW       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x60; xmmmod = 3 &
XmmReg1 & XmmReg2
{
    XmmReg1[120,8] = XmmReg2[56,8];
    XmmReg1[112,8] = XmmReg1[56,8];
    XmmReg1[104,8] = XmmReg2[48,8];
    XmmReg1[96,8] = XmmReg1[48,8];
    XmmReg1[88,8] = XmmReg2[40,8];
    XmmReg1[80,8] = XmmReg1[40,8];
    XmmReg1[72,8] = XmmReg2[32,8];
    XmmReg1[64,8] = XmmReg1[32,8];
    XmmReg1[56,8] = XmmReg2[24,8];
    XmmReg1[48,8] = XmmReg1[24,8];
    XmmReg1[40,8] = XmmReg2[16,8];
    XmmReg1[32,8] = XmmReg1[16,8];
    XmmReg1[24,8] = XmmReg2[8,8];
    XmmReg1[16,8] = XmmReg1[8,8];
    XmmReg1[8,8] = XmmReg2[0,8];
#   XmmReg1[0,8] = XmmReg1[0,8]; superfluous
}

:PUNPCKLWD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x61; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[112,16] =   m[48,16];
    XmmReg[96,16] = XmmReg[48,16];
    XmmReg[80,16] =   m[32,16];
    XmmReg[64,16] = XmmReg[32,16];
    XmmReg[48,16] =   m[16,16];
    XmmReg[32,16] = XmmReg[16,16];
    XmmReg[16,16] =   m[0,16];
#   XmmReg[0,16] = XmmReg[0,16]; superfluous
}

:PUNPCKLWD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x61; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[112,16] = XmmReg2[48,16];
    XmmReg1[96,16] = XmmReg1[48,16];
    XmmReg1[80,16] = XmmReg2[32,16];
    XmmReg1[64,16] = XmmReg1[32,16];
    XmmReg1[48,16] = XmmReg2[16,16];
    XmmReg1[32,16] = XmmReg1[16,16];
    XmmReg1[16,16] = XmmReg2[0,16];
#   XmmReg1[0,16] = XmmReg1[0,16]; superfluous
}

:PUNPCKLDQ       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x62; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[96,32] =   m[32,32];
    XmmReg[64,32] = XmmReg[32,32];
    XmmReg[32,32] =   m[0,32];
#   XmmReg[0,32] = XmmReg[0,32]; superfluous
}

:PUNPCKLDQ       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x62; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[96,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[32,32];
    XmmReg1[32,32] = XmmReg2[0,32];
#   XmmReg1[0,32] = XmmReg1[0,32]; superfluous
}

define pcodeop punpcklqdq;
:PUNPCKLQDQ      XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6C; m128 & XmmReg ...
{
    XmmReg[64,64] =   m128[0,64];
#   XmmReg[0,64] = XmmReg[0,64]; superfluous
}

:PUNPCKLQDQ      XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6C; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[64,64] = XmmReg2[0,64];
#   XmmReg1[0,64] = XmmReg1[0,64]; superfluous
}

:PXOR            mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEF; mmxreg ... & m64 { mmxreg = mmxreg ^ m64; }
:PXOR            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEF; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = mmxreg1 ^ mmxreg2; }
:PXOR            XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEF; XmmReg ... & m128 { XmmReg = XmmReg ^ m128; }
:PXOR            XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEF; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = XmmReg1 ^ XmmReg2; }

define pcodeop rcpps;
:RCPPS           XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x53; XmmReg ... & m128 { XmmReg = rcpps(XmmReg, m128); }
:RCPPS           XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x53; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rcpps(XmmReg1, XmmReg2); }

define pcodeop rcpss;
:RCPSS           XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x53; XmmReg ... & m32 { XmmReg = rcpss(XmmReg, m32); }
:RCPSS           XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x53; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rcpss(XmmReg1, XmmReg2); }

define pcodeop rsqrtps;
:RSQRTPS         XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x52; XmmReg ... & m128 { XmmReg = rsqrtps(XmmReg, m128); }
:RSQRTPS         XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x52; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rsqrtps(XmmReg1, XmmReg2); }

define pcodeop rsqrtss;
:RSQRTSS         XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x52; XmmReg ... & m32 { XmmReg = rsqrtss(XmmReg, m32); }
:RSQRTSS         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x52; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rsqrtss(XmmReg1, XmmReg2); }

:SHUFPD          XmmReg1, XmmReg2_m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xC6; XmmReg1 ... & XmmReg2_m128; imm8 
{ 
    local srcLow:8 = XmmReg2_m128[0,64];
    local srcHigh:8 = XmmReg2_m128[64,64];
    local destLow:8 = XmmReg1[0,64];
    local destHigh:8 = XmmReg1[64,64];
    local control:1 = (imm8 & 0x1)== 0:1;
    conditionalAssign(XmmReg1[0,64],control,destLow,destHigh);
    control = (imm8 & 0x2) == 0:1;
    conditionalAssign(XmmReg1[64,64],control,srcLow,srcHigh); 
}

:SHUFPS  XmmReg1, XmmReg2_m128, imm8  is vexMode=0 & mandover=0 & byte=0x0F; byte=0xC6; (XmmReg2_m128 & XmmReg1 ...); imm8 & Order0 & Order1 & Order2 & Order3
{
    local xmmreg2_m128_c0 = XmmReg2_m128[0,32];
    local xmmreg2_m128_c1 = XmmReg2_m128[32,32];
    local xmmreg2_m128_c2 = XmmReg2_m128[64,32];
    local xmmreg2_m128_c3 = XmmReg2_m128[96,32];

    local xmm_c0 = XmmReg1[0,32];
    local xmm_c1 = XmmReg1[32,32];
    local xmm_c2 = XmmReg1[64,32];
    local xmm_c3 = XmmReg1[96,32];

    shuffle_4(XmmReg1[0,32],Order0,xmm_c0,xmm_c1,xmm_c2,xmm_c3);
    shuffle_4(XmmReg1[32,32],Order1,xmm_c0,xmm_c1,xmm_c2,xmm_c3);
    shuffle_4(XmmReg1[64,32],Order2,xmmreg2_m128_c0,xmmreg2_m128_c1,xmmreg2_m128_c2,xmmreg2_m128_c3);
    shuffle_4(XmmReg1[96,32],Order3,xmmreg2_m128_c0,xmmreg2_m128_c1,xmmreg2_m128_c2,xmmreg2_m128_c3);
}

define pcodeop sqrtpd;
:SQRTPD          XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; XmmReg ... & m128 { XmmReg = sqrtpd(XmmReg, m128); }
:SQRTPD          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = sqrtpd(XmmReg1, XmmReg2); }

define pcodeop sqrtps;
:SQRTPS          XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x51; XmmReg ... & m128 { XmmReg = sqrtps(XmmReg, m128); }
:SQRTPS          XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = sqrtps(XmmReg1, XmmReg2); }

:SQRTSD          XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x51; XmmReg ... & m64 { XmmReg[0,64] = sqrt(m64); }
:SQRTSD          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,64] = sqrt(XmmReg2[0,64]); }

:SQRTSS          XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x51; XmmReg ... & m32 { XmmReg[0,32] = sqrt(m32); }
:SQRTSS          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,32] = sqrt(XmmReg2[0,32]); }

:SUBPD           XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C;XmmReg ... & m128
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f- m[64,64];
}

:SUBPD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f- XmmReg2[64,64];
}

:SUBPS           XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5C; XmmReg ... & m128
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f- m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f- m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f- m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f- m[96,32];
}

:SUBPS           XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f- XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f- XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f- XmmReg2[96,32];
}

:SUBSD           XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5C; XmmReg ... & m64 { XmmReg[0,64] = XmmReg[0,64] f- m64; }
:SUBSD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64]; }

:SUBSS           XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5C; XmmReg ...& m32 { XmmReg[0,32] = XmmReg[0,32] f- m32; }
:SUBSS           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32]; }

#Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS
#   RESULT <- UnorderedCompare(SRC1[63-0] <> SRC2[63-0]) {
#   * Set EFLAGS *CASE (RESULT) OF
#   UNORDERED:      ZF,PF,CF <- 111;
#   GREATER_THAN:   ZF,PF,CF <- 000;
#   LESS_THAN:      ZF,PF,CF <- 001;
#   EQUAL:          ZF,PF,CF <- 100;
#   ESAC;
#   OF,AF,SF <- 0;}

:UCOMISD         XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x2E; m64 & XmmReg ...
{
	fucompe(XmmReg[0,64], m64);
}

:UCOMISD         XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x2E; xmmmod=3 & XmmReg1 & XmmReg2
{
	fucompe(XmmReg1[0,64], XmmReg2[0,64]);
}

#Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS
#   RESULT <- UnorderedCompare(SRC1[31-0] <> SRC2[31-0]) {
#   * Set EFLAGS *CASE (RESULT) OF
#   UNORDERED:      ZF,PF,CF <- 111;
#   GREATER_THAN:   ZF,PF,CF <- 000;
#   LESS_THAN:      ZF,PF,CF <- 001;
#   EQUAL:          ZF,PF,CF <- 100;
#   ESAC;
#   OF,AF,SF <- 0;}

:UCOMISS         XmmReg, m32      is vexMode=0 & mandover=0 & byte=0x0F; byte=0x2E; m32 & XmmReg ...
{
    fucompe(XmmReg[0,32], m32);
}

:UCOMISS         XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x2E; xmmmod=3 & XmmReg1 & XmmReg2
{
    fucompe(XmmReg1[0,32], XmmReg2[0,32]);
}

:UNPCKHPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x15; m128 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[64,64];
    XmmReg[64,64] = m128[64,64];
}

:UNPCKHPD        XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x15; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}

:UNPCKHPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x15; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[64,32];
    XmmReg[64,32] = XmmReg[96,32];
    XmmReg[32,32] = m[64,32];
    XmmReg[96,32] = m[96,32];
}

:UNPCKHPS        XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x15; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[64,32];
    XmmReg1[32,32] = XmmReg2[64,32];
    XmmReg1[64,32] = XmmReg1[96,32];  # XmmReg1 and XmmReg2 could be the same register, preserve XmmReg1[64,32] till later
    XmmReg1[96,32] = XmmReg2[96,32];
}

:UNPCKLPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x14; m128 & XmmReg ...
{
#   XmmReg[0,64] = XmmReg[0,64]; superfluous
    XmmReg[64,64] = m128[0,64];
}

:UNPCKLPD        XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x14; xmmmod=3 & XmmReg1 & XmmReg2
{
#   XmmReg1[0,64] = XmmReg1[0,64]; superfluous
    XmmReg1[64,64] = XmmReg2[0,64];
}

:UNPCKLPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x14; m128 & XmmReg ...
{
    local m:16 = m128;
#   XmmReg[0,32] = XmmReg[0,32]; superfluous
    XmmReg[64,32] = XmmReg[32,32];
    XmmReg[32,32] = m[0,32];
    XmmReg[96,32] = m[32,32];
}

:UNPCKLPS        XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x14; xmmmod=3 & XmmReg1 & XmmReg2
{
#   XmmReg1[0,32] = XmmReg1[0,32]; superfluous
    XmmReg1[64,32] = XmmReg1[32,32];
    XmmReg1[96,32] = XmmReg2[32,32];
    XmmReg1[32,32] = XmmReg2[0,32]; # XmmReg1 and XmmReg2 could be the same register, preserve Db till last
}

:XORPD           XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x57; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = ( XmmReg[0,64] ^ m[0,64] );
    XmmReg[64,64] = ( XmmReg[64,64] ^ m[64,64] );
}

:XORPD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x57; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = ( XmmReg1[0,64] ^ XmmReg2[0,64] );
    XmmReg1[64,64] = ( XmmReg1[64,64] ^ XmmReg2[64,64] );
}

:XORPS           XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x57; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = ( XmmReg[0,32] ^ m[0,32] );
    XmmReg[32,32] = ( XmmReg[32,32] ^ m[32,32] );
    XmmReg[64,32] = ( XmmReg[64,32] ^ m[64,32] );
    XmmReg[96,32] = ( XmmReg[96,32] ^ m[96,32] );
}

:XORPS           XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x57; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = ( XmmReg1[0,32] ^ XmmReg2[0,32] );
    XmmReg1[32,32] = ( XmmReg1[32,32] ^ XmmReg2[32,32] );
    XmmReg1[64,32] = ( XmmReg1[64,32] ^ XmmReg2[64,32] );
    XmmReg1[96,32] = ( XmmReg1[96,32] ^ XmmReg2[96,32] );
}

####
####  VIA Padlock instructions
####

define pcodeop xstore_available;
define pcodeop xstore;
define pcodeop xcrypt_ecb;
define pcodeop xcrypt_cbc;
define pcodeop xcrypt_ctr;
define pcodeop xcrypt_cfb;
define pcodeop xcrypt_ofb;
define pcodeop montmul;
define pcodeop xsha1;
define pcodeop xsha256;

:XSTORE is vexMode=0 & mandover=0 & byte=0x0F; byte=0xA7; byte=0xC0 {  
	EAX = xstore_available(EDX,EDI); 
}

:XSTORE.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xC0 {  
	EAX = xstore(ECX,EDX,EDI);
	ECX = 0;
}

:XCRYPTECB.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xC8 { 
	xcrypt_ecb(ECX,EDX,EBX,ESI,EDI); 
}

:XCRYPTCBC.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xD0 { 
	xcrypt_cbc(ECX,EAX,EDX,EBX,ESI,EDI); 
}

:XCRYPTCTR.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xD8 {  
	xcrypt_ctr(ECX,EAX,EDX,EBX,ESI,EDI); 
}

:XCRYPTCFB.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xE0 { 
	xcrypt_cfb(ECX,EAX,EDX,EBX,ESI,EDI); 
}

:XCRYPTOFB.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xE8 { 
	xcrypt_ofb(ECX,EAX,EDX,EBX,ESI,EDI); 
}

:MONTMUL.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA6; byte=0xC0 { 
	montmul(EAX,ECX,ESI); 
	ECX=0; 
	EDX=0; 
}

:XSHA1.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA6; byte=0xC8 {
	xsha1(ECX,ESI,EDI); 
	EAX = ECX;
}

:XSHA256.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA6; byte=0xD0 {  
	xsha256(ECX,ESI,EDI); 
	EAX = ECX; 
}

####
####  SSE4.1 instructions
####

define pcodeop mpsadbw;
:MPSADBW XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x42; XmmReg ... & m128; imm8 { XmmReg = mpsadbw(XmmReg, m128, imm8:8); }
:MPSADBW XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x42; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = mpsadbw(XmmReg1, XmmReg2, imm8:8); }

define pcodeop phminposuw;
:PHMINPOSUW XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x41; XmmReg ... & m128 { XmmReg = phminposuw(m128); }
:PHMINPOSUW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x41; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = phminposuw(XmmReg2); }

define pcodeop pmuldq;
:PMULDQ XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x28; XmmReg ... & m128 { XmmReg = pmuldq(XmmReg, m128); }
:PMULDQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x28; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmuldq(XmmReg1, XmmReg2); }

define pcodeop pmulld;
:PMULLD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x40; XmmReg ... & m128 { XmmReg = pmulld(XmmReg, m128); }
:PMULLD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x40; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmulld(XmmReg1, XmmReg2); }

define pcodeop dpps;
:DPPS XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x40; XmmReg ... & m128; imm8 { XmmReg = dpps(XmmReg, m128, imm8:8); }
:DPPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x40; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = dpps(XmmReg1, XmmReg2, imm8:8); }

define pcodeop dppd;
:DPPD XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x41; XmmReg ... & m128; imm8 { XmmReg = dppd(XmmReg, m128, imm8:8); }
:DPPD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x41; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = dppd(XmmReg1, XmmReg2, imm8:8); }

define pcodeop blendps;
:BLENDPS XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0C; XmmReg ... & m128; imm8 { XmmReg = blendps(XmmReg, m128, imm8:8); }
:BLENDPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0C; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = blendps(XmmReg1, XmmReg2, imm8:8); }

define pcodeop blendpd;
:BLENDPD XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0D; XmmReg ... & m128; imm8 { XmmReg = blendpd(XmmReg, m128, imm8:8); }
:BLENDPD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0D; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = blendpd(XmmReg1, XmmReg2, imm8:8); }

define pcodeop blendvps;
:BLENDVPS XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x14; XmmReg ... & m128 { XmmReg = blendvps(XmmReg, m128, XMM0); }
:BLENDVPS XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x14; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = blendvps(XmmReg1, XmmReg2, XMM0); }

define pcodeop blendvpd;
:BLENDVPD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x15; XmmReg ... & m128 { XmmReg = blendvpd(XmmReg, m128, XMM0); }
:BLENDVPD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x15; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = blendvpd(XmmReg1, XmmReg2, XMM0); }

define pcodeop pblendvb;
:PBLENDVB XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x10; XmmReg ... & m128 { XmmReg = pblendvb(XmmReg, m128, XMM0); }
:PBLENDVB XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x10; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pblendvb(XmmReg1, XmmReg2, XMM0); }

define pcodeop pblendw;
:PBLENDW XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0E; XmmReg ... & m128; imm8 { XmmReg = pblendw(XmmReg, m128, imm8:8); }
:PBLENDW XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0E; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = pblendw(XmmReg1, XmmReg2, imm8:8); }

:PMINSB XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x38; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,8],srcCopy[0,8] s< XmmReg1[0,8],srcCopy[0,8],XmmReg1[0,8]);
    conditionalAssign(XmmReg1[8,8],srcCopy[8,8] s< XmmReg1[8,8],srcCopy[8,8],XmmReg1[8,8]);
    conditionalAssign(XmmReg1[16,8],srcCopy[16,8] s< XmmReg1[16,8],srcCopy[16,8],XmmReg1[16,8]);
    conditionalAssign(XmmReg1[24,8],srcCopy[24,8] s< XmmReg1[24,8],srcCopy[24,8],XmmReg1[24,8]);
    conditionalAssign(XmmReg1[32,8],srcCopy[32,8] s< XmmReg1[32,8],srcCopy[32,8],XmmReg1[32,8]);
    conditionalAssign(XmmReg1[40,8],srcCopy[40,8] s< XmmReg1[40,8],srcCopy[40,8],XmmReg1[40,8]);
    conditionalAssign(XmmReg1[48,8],srcCopy[48,8] s< XmmReg1[48,8],srcCopy[48,8],XmmReg1[48,8]);
    conditionalAssign(XmmReg1[56,8],srcCopy[56,8] s< XmmReg1[56,8],srcCopy[56,8],XmmReg1[56,8]);
    conditionalAssign(XmmReg1[64,8],srcCopy[64,8] s< XmmReg1[64,8],srcCopy[64,8],XmmReg1[64,8]);
    conditionalAssign(XmmReg1[72,8],srcCopy[72,8] s< XmmReg1[72,8],srcCopy[72,8],XmmReg1[72,8]);
    conditionalAssign(XmmReg1[80,8],srcCopy[80,8] s< XmmReg1[80,8],srcCopy[80,8],XmmReg1[80,8]);
    conditionalAssign(XmmReg1[88,8],srcCopy[88,8] s< XmmReg1[88,8],srcCopy[88,8],XmmReg1[88,8]);
    conditionalAssign(XmmReg1[96,8],srcCopy[96,8] s< XmmReg1[96,8],srcCopy[96,8],XmmReg1[96,8]);
    conditionalAssign(XmmReg1[104,8],srcCopy[104,8] s< XmmReg1[104,8],srcCopy[104,8],XmmReg1[104,8]);
    conditionalAssign(XmmReg1[112,8],srcCopy[112,8] s< XmmReg1[112,8],srcCopy[112,8],XmmReg1[112,8]);
    conditionalAssign(XmmReg1[120,8],srcCopy[120,8] s< XmmReg1[120,8],srcCopy[120,8],XmmReg1[120,8]);
}

:PMINUW XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3A; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128; 
    conditionalAssign(XmmReg1[0,16],srcCopy[0,16] < XmmReg1[0,16],srcCopy[0,16],XmmReg1[0,16]);
    conditionalAssign(XmmReg1[16,16],srcCopy[16,16] < XmmReg1[16,16],srcCopy[16,16],XmmReg1[16,16]);
    conditionalAssign(XmmReg1[32,16],srcCopy[32,16] < XmmReg1[32,16],srcCopy[32,16],XmmReg1[32,16]);
    conditionalAssign(XmmReg1[48,16],srcCopy[48,16] < XmmReg1[48,16],srcCopy[48,16],XmmReg1[48,16]);
    conditionalAssign(XmmReg1[64,16],srcCopy[64,16] < XmmReg1[64,16],srcCopy[64,16],XmmReg1[64,16]);
    conditionalAssign(XmmReg1[80,16],srcCopy[80,16] < XmmReg1[80,16],srcCopy[80,16],XmmReg1[80,16]);
    conditionalAssign(XmmReg1[96,16],srcCopy[96,16] < XmmReg1[96,16],srcCopy[96,16],XmmReg1[96,16]);
    conditionalAssign(XmmReg1[112,16],srcCopy[112,16] < XmmReg1[112,16],srcCopy[112,16],XmmReg1[112,16]);
}

:PMINUD XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3B; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,32],srcCopy[0,32] < XmmReg1[0,32],srcCopy[0,32],XmmReg1[0,32]);
    conditionalAssign(XmmReg1[32,32],srcCopy[32,32] < XmmReg1[32,32],srcCopy[32,32],XmmReg1[32,32]);
    conditionalAssign(XmmReg1[64,32],srcCopy[64,32] < XmmReg1[64,32],srcCopy[64,32],XmmReg1[64,32]);
    conditionalAssign(XmmReg1[96,32],srcCopy[96,32] < XmmReg1[96,32],srcCopy[96,32],XmmReg1[96,32]);
}

:PMINSD XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x39; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,32],srcCopy[0,32] s< XmmReg1[0,32],srcCopy[0,32],XmmReg1[0,32]);
    conditionalAssign(XmmReg1[32,32],srcCopy[32,32] s< XmmReg1[32,32],srcCopy[32,32],XmmReg1[32,32]);
    conditionalAssign(XmmReg1[64,32],srcCopy[64,32] s< XmmReg1[64,32],srcCopy[64,32],XmmReg1[64,32]);
    conditionalAssign(XmmReg1[96,32],srcCopy[96,32] s< XmmReg1[96,32],srcCopy[96,32],XmmReg1[96,32]);
}

:PMAXSB XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3C; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,8],srcCopy[0,8] s> XmmReg1[0,8],srcCopy[0,8],XmmReg1[0,8]);
    conditionalAssign(XmmReg1[8,8],srcCopy[8,8] s> XmmReg1[8,8],srcCopy[8,8],XmmReg1[8,8]);
    conditionalAssign(XmmReg1[16,8],srcCopy[16,8] s> XmmReg1[16,8],srcCopy[16,8],XmmReg1[16,8]);
    conditionalAssign(XmmReg1[24,8],srcCopy[24,8] s> XmmReg1[24,8],srcCopy[24,8],XmmReg1[24,8]);
    conditionalAssign(XmmReg1[32,8],srcCopy[32,8] s> XmmReg1[32,8],srcCopy[32,8],XmmReg1[32,8]);
    conditionalAssign(XmmReg1[40,8],srcCopy[40,8] s> XmmReg1[40,8],srcCopy[40,8],XmmReg1[40,8]);
    conditionalAssign(XmmReg1[48,8],srcCopy[48,8] s> XmmReg1[48,8],srcCopy[48,8],XmmReg1[48,8]);
    conditionalAssign(XmmReg1[56,8],srcCopy[56,8] s> XmmReg1[56,8],srcCopy[56,8],XmmReg1[56,8]);
    conditionalAssign(XmmReg1[64,8],srcCopy[64,8] s> XmmReg1[64,8],srcCopy[64,8],XmmReg1[64,8]);
    conditionalAssign(XmmReg1[72,8],srcCopy[72,8] s> XmmReg1[72,8],srcCopy[72,8],XmmReg1[72,8]);
    conditionalAssign(XmmReg1[80,8],srcCopy[80,8] s> XmmReg1[80,8],srcCopy[80,8],XmmReg1[80,8]);
    conditionalAssign(XmmReg1[88,8],srcCopy[88,8] s> XmmReg1[88,8],srcCopy[88,8],XmmReg1[88,8]);
    conditionalAssign(XmmReg1[96,8],srcCopy[96,8] s> XmmReg1[96,8],srcCopy[96,8],XmmReg1[96,8]);
    conditionalAssign(XmmReg1[104,8],srcCopy[104,8] s> XmmReg1[104,8],srcCopy[104,8],XmmReg1[104,8]);
    conditionalAssign(XmmReg1[112,8],srcCopy[112,8] s> XmmReg1[112,8],srcCopy[112,8],XmmReg1[112,8]);
    conditionalAssign(XmmReg1[120,8],srcCopy[120,8] s> XmmReg1[120,8],srcCopy[120,8],XmmReg1[120,8]);
}


:PMAXUW XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3E; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128; 
    conditionalAssign(XmmReg1[0,16],srcCopy[0,16] > XmmReg1[0,16],srcCopy[0,16],XmmReg1[0,16]);
    conditionalAssign(XmmReg1[16,16],srcCopy[16,16] > XmmReg1[16,16],srcCopy[16,16],XmmReg1[16,16]);
    conditionalAssign(XmmReg1[32,16],srcCopy[32,16] > XmmReg1[32,16],srcCopy[32,16],XmmReg1[32,16]);
    conditionalAssign(XmmReg1[48,16],srcCopy[48,16] > XmmReg1[48,16],srcCopy[48,16],XmmReg1[48,16]);
    conditionalAssign(XmmReg1[64,16],srcCopy[64,16] > XmmReg1[64,16],srcCopy[64,16],XmmReg1[64,16]);
    conditionalAssign(XmmReg1[80,16],srcCopy[80,16] > XmmReg1[80,16],srcCopy[80,16],XmmReg1[80,16]);
    conditionalAssign(XmmReg1[96,16],srcCopy[96,16] > XmmReg1[96,16],srcCopy[96,16],XmmReg1[96,16]);
    conditionalAssign(XmmReg1[112,16],srcCopy[112,16] > XmmReg1[112,16],srcCopy[112,16],XmmReg1[112,16]);
}

:PMAXUD XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3F; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,32],srcCopy[0,32] > XmmReg1[0,32],srcCopy[0,32],XmmReg1[0,32]);
    conditionalAssign(XmmReg1[32,32],srcCopy[32,32] > XmmReg1[32,32],srcCopy[32,32],XmmReg1[32,32]);
    conditionalAssign(XmmReg1[64,32],srcCopy[64,32] > XmmReg1[64,32],srcCopy[64,32],XmmReg1[64,32]);
    conditionalAssign(XmmReg1[96,32],srcCopy[96,32] > XmmReg1[96,32],srcCopy[96,32],XmmReg1[96,32]);
}

:PMAXSD XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3D; XmmReg1 ... & XmmReg2_m128 
{ 
    local srcCopy:16 = XmmReg2_m128;
    conditionalAssign(XmmReg1[0,32],srcCopy[0,32] s> XmmReg1[0,32],srcCopy[0,32],XmmReg1[0,32]);
    conditionalAssign(XmmReg1[32,32],srcCopy[32,32] s> XmmReg1[32,32],srcCopy[32,32],XmmReg1[32,32]);
    conditionalAssign(XmmReg1[64,32],srcCopy[64,32] s> XmmReg1[64,32],srcCopy[64,32],XmmReg1[64,32]);
    conditionalAssign(XmmReg1[96,32],srcCopy[96,32] s> XmmReg1[96,32],srcCopy[96,32],XmmReg1[96,32]);
}

define pcodeop roundps;
:ROUNDPS XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x08; XmmReg ... & m128; imm8 { XmmReg = roundps(XmmReg, m128, imm8:8); }
:ROUNDPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x08; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundps(XmmReg1, XmmReg2, imm8:8); }

define pcodeop roundss;
:ROUNDSS XmmReg, m32, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0A; XmmReg ... & m32; imm8 { XmmReg = roundss(XmmReg, m32, imm8:8); }
:ROUNDSS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0A; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundss(XmmReg1, XmmReg2, imm8:8); }

define pcodeop roundpd;
:ROUNDPD XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x09; XmmReg ... & m128; imm8 { XmmReg = roundpd(XmmReg, m128, imm8:8); }
:ROUNDPD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x09; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundpd(XmmReg1, XmmReg2, imm8:8); }

define pcodeop roundsd;
:ROUNDSD XmmReg, m64, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0B; XmmReg ... & m64; imm8 { XmmReg = roundsd(XmmReg, m64, imm8:8); }
:ROUNDSD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0B; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundsd(XmmReg1, XmmReg2, imm8:8); }

define pcodeop insertps;
:INSERTPS XmmReg, m32, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x21; XmmReg ... & m32; imm8 { XmmReg = insertps(XmmReg, m32, imm8:8); }
:INSERTPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x21; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = insertps(XmmReg1, XmmReg2, imm8:8); }

:PINSRB XmmReg, rm32, imm8       is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x20; XmmReg ... & rm32; imm8 
{ 
    local destIndex:1 = (imm8 & 0xf) * 8:1;
    local useLow:1 = destIndex < 64:1;
    local newLow:8 = zext(rm32:1) << destIndex;
    newLow = (XmmReg[0,64] & ~(0xff:8 << destIndex)) |  newLow;
    local newHigh:8 = zext(rm32:1) << (destIndex-64:1);
    newHigh = (XmmReg[64,64] & ~(0xff:8 << (destIndex - 64:1))) | newHigh;
    conditionalAssign(XmmReg[0,64],useLow,newLow,XmmReg[0,64]);
    conditionalAssign(XmmReg[64,64],!useLow,newHigh,XmmReg[64,64]);
}

:PINSRD XmmReg, rm32, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x22; XmmReg ... & rm32; imm8 
{ 
    local destIndex:1 = (imm8 & 0x3) * 32:1;
    local useLow:1 = destIndex < 64:1;
    local newLow:8 = zext(rm32) << destIndex;
    newLow = (XmmReg[0,64] & ~(0xffffffff:8 << destIndex)) |  newLow;
    local newHigh:8 = zext(rm32) << (destIndex-64:1);
    newHigh = (XmmReg[64,64] & ~(0xffffffff:8 << (destIndex - 64:1))) | newHigh;
    conditionalAssign(XmmReg[0,64],useLow,newLow,XmmReg[0,64]);
    conditionalAssign(XmmReg[64,64],!useLow,newHigh,XmmReg[64,64]);
}

@ifdef IA64
:PINSRQ XmmReg, rm64, imm8     is $(LONGMODE_ON) & vexMode=0 & bit64=1 & $(PRE_66) & $(REX_W) & byte=0x0F; byte=0x3A; byte=0x22; XmmReg ... & rm64; imm8 
{ 
    local useHigh:1 = imm8 & 0x1;
    conditionalAssign(XmmReg[0,64],!useHigh,rm64,XmmReg[0,64]);
    conditionalAssign(XmmReg[64,64],useHigh,rm64,XmmReg[64,64]);
}
@endif

define pcodeop extractps;
@ifdef IA64
:EXTRACTPS rm64, XmmReg, imm8  is $(LONGMODE_ON) & vexMode=0 & bit64=1 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x17; XmmReg ... & rm64; imm8 { rm64 = extractps(XmmReg, imm8:8); }
@endif
:EXTRACTPS rm32, XmmReg, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x17; XmmReg ... & rm32 & check_rm32_dest ...; imm8 { rm32 = extractps(XmmReg, imm8:8); build check_rm32_dest; }

:PEXTRB Rmr32, XmmReg, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x14; mod=3 & XmmReg & Rmr32 & check_Rmr32_dest; imm8 
{ 
    local shift:1 = (imm8 & 0xf) * 8:1;
    local low:1 = shift < 64:1;
    local temp:8;
    conditionalAssign(temp,low,XmmReg[0,64] >> shift,XmmReg[64,64] >> (shift - 64));
    Rmr32 = zext(temp:1);
    build check_Rmr32_dest;
}

:PEXTRB Mem, XmmReg, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x14; XmmReg ... & Mem; imm8 
{ 
    local shift:1 = (imm8 & 0xf) * 8:1;
    local low:1 = shift < 64:1;
    local temp:8;
    conditionalAssign(temp,low,XmmReg[0,64] >> shift,XmmReg[64,64] >> (shift - 64));
    Mem = temp:1;
}

:PEXTRD Rmr32, XmmReg, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x16; mod=3 & XmmReg & Rmr32 & check_Rmr32_dest; imm8 
{ 
    local shift:1 = (imm8 & 0x3) * 32:1;
    local low:1 = shift < 64:1;
    local temp:8;
    conditionalAssign(temp,low,XmmReg[0,64] >> shift,XmmReg[64,64] >> (shift - 64));
    Rmr32 = zext(temp:4);
    build check_Rmr32_dest;    
}

:PEXTRD Mem, XmmReg, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x16; XmmReg ... & Mem; imm8 
{ 
    local shift:1 = (imm8 & 0x3) * 32:1;
    local low:1 = shift < 64:1;
    local temp:8;
    conditionalAssign(temp,low,XmmReg[0,64] >> shift,XmmReg[64,64] >> (shift - 64));
    Mem = temp:4;
}

@ifdef IA64
:PEXTRQ Rmr64, XmmReg, imm8     is $(LONGMODE_ON) & vexMode=0 & bit64=1 & $(PRE_66) & $(REX_W) & byte=0x0F; byte=0x3A; byte=0x16; mod=3 & XmmReg & Rmr64; imm8 
{ 
    local high:1 = imm8 & 0x1;
    conditionalAssign(Rmr64,high,XmmReg[64,64],XmmReg[0,64]);
}

:PEXTRQ Mem, XmmReg, imm8     is $(LONGMODE_ON) & vexMode=0 & bit64=1 & $(PRE_66) & $(REX_W) & byte=0x0F; byte=0x3A; byte=0x16; XmmReg ... & Mem; imm8 
{ 
    local high:1 = imm8 & 0x1;
    conditionalAssign(Mem,high,XmmReg[64,64],XmmReg[0,64]);
}
@endif

define pcodeop pmovsxbw;
:PMOVSXBW XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x20; XmmReg ... & m64 { XmmReg = pmovsxbw(XmmReg, m64); }
:PMOVSXBW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x20; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxbw(XmmReg1, XmmReg2); }

define pcodeop pmovsxbd;
:PMOVSXBD XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x21; XmmReg ... & m32 { XmmReg = pmovsxbd(XmmReg, m32); }
:PMOVSXBD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x21; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxbd(XmmReg1, XmmReg2); }

define pcodeop pmovsxbq;
:PMOVSXBQ XmmReg, m16      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x22; XmmReg ... & m16 { XmmReg = pmovsxbq(XmmReg, m16); }
:PMOVSXBQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x22; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxbq(XmmReg1, XmmReg2); }

define pcodeop pmovsxwd;
:PMOVSXWD XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x23; XmmReg ... & m64 { XmmReg = pmovsxwd(XmmReg, m64); }
:PMOVSXWD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x23; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxwd(XmmReg1, XmmReg2); }

define pcodeop pmovsxwq;
:PMOVSXWQ XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x24; XmmReg ... & m32 { XmmReg = pmovsxwq(XmmReg, m32); }
:PMOVSXWQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x24; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxwq(XmmReg1, XmmReg2); }

define pcodeop pmovsxdq;
:PMOVSXDQ XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x25; XmmReg ... & m64 { XmmReg = pmovsxdq(XmmReg, m64); }
:PMOVSXDQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x25; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxdq(XmmReg1, XmmReg2); }

define pcodeop pmovzxbw;
:PMOVZXBW XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x30; XmmReg ... & m64 { XmmReg = pmovzxbw(XmmReg, m64); }
:PMOVZXBW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x30; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxbw(XmmReg1, XmmReg2); }

define pcodeop pmovzxbd;
:PMOVZXBD XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x31; XmmReg ... & m32 { XmmReg = pmovzxbd(XmmReg, m32); }
:PMOVZXBD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x31; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxbd(XmmReg1, XmmReg2); }

define pcodeop pmovzxbq;
:PMOVZXBQ XmmReg, m16      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x32; XmmReg ... & m16 { XmmReg = pmovzxbq(XmmReg, m16); }
:PMOVZXBQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x32; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxbq(XmmReg1, XmmReg2); }

define pcodeop pmovzxwd;
:PMOVZXWD XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x33; XmmReg ... & m64 { XmmReg = pmovzxwd(XmmReg, m64); }
:PMOVZXWD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x33; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxwd(XmmReg1, XmmReg2); }

define pcodeop pmovzxwq;
:PMOVZXWQ XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x34; XmmReg ... & m32 { XmmReg = pmovzxwq(XmmReg, m32); }
:PMOVZXWQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x34; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxwq(XmmReg1, XmmReg2); }

define pcodeop pmovzxdq;
:PMOVZXDQ XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x35; XmmReg ... & m64 { XmmReg = pmovzxdq(XmmReg, m64); }
:PMOVZXDQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x35; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxdq(XmmReg1, XmmReg2); }

:PTEST XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x17; XmmReg ... & m128 {
    local temp_m128:16 = m128;
    local tmp = temp_m128 & XmmReg;
    ZF = tmp == 0;
    local tmp2 = temp_m128 & ~XmmReg;
    CF = tmp2 == 0;
    AF = 0;
    OF = 0;
    PF = 0;
    SF = 0;
}

:PTEST XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x17; xmmmod=3 & XmmReg1 & XmmReg2 {
    local tmp = XmmReg2 & XmmReg1;
    ZF = tmp == 0;
    local tmp2 = XmmReg2 & ~XmmReg1;
    CF = tmp2 == 0;
    AF = 0;
    OF = 0;
    PF = 0;
    SF = 0;
}

:PCMPEQQ XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x29; XmmReg ... & m128 
{ 
	local temp_m128:16 = m128;
	XmmReg[0,64] = zext(XmmReg[0,64] == temp_m128[0,64]) * 0xffffffffffffffff:8;
	XmmReg[64,64] = zext(XmmReg[64,64] == temp_m128[64,64]) * 0xffffffffffffffff:8;
}
:PCMPEQQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x29; xmmmod=3 & XmmReg1 & XmmReg2 
{ 
	XmmReg1[0,64] = zext(XmmReg1[0,64] == XmmReg2[0,64]) * 0xffffffffffffffff:8;
	XmmReg1[64,64] = zext(XmmReg1[64,64] == XmmReg2[64,64]) * 0xffffffffffffffff:8;
}

define pcodeop packusdw;
:PACKUSDW XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x2B; XmmReg ... & m128 { XmmReg = packusdw(XmmReg, m128); }
:PACKUSDW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x2B; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = packusdw(XmmReg1, XmmReg2); }

define pcodeop movntdqa;
:MOVNTDQA XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x2A; XmmReg ... & m128 { XmmReg = movntdqa(XmmReg, m128); }

####
####  SSE4.2 instructions
####

define pcodeop crc32;
:CRC32 Reg32, rm8  is vexMode=0 &            $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF0; Reg32 ... & check_Reg32_dest ... & rm8  { Reg32 = crc32(Reg32, rm8);  build check_Reg32_dest; }
:CRC32 Reg32, rm16 is vexMode=0 & opsize=0 & $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF1; Reg32 ... & check_Reg32_dest ... & rm16 { Reg32 = crc32(Reg32, rm16); build check_Reg32_dest; }
:CRC32 Reg32, rm32 is vexMode=0 & opsize=1 & $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF1; Reg32 ... & check_Reg32_dest ... & rm32 { Reg32 = crc32(Reg32, rm32); build check_Reg32_dest; }
@ifdef IA64
:CRC32 Reg32, rm8  is vexMode=0 & opsize=1 & $(PRE_F2) & $(REX)   & byte=0x0F; byte=0x38; byte=0xF0; Reg32 ... & check_Reg32_dest ... & rm8  { Reg32 = crc32(Reg32, rm8);  build check_Reg32_dest; }
:CRC32 Reg64, rm8  is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F2) & $(REX_W) & byte=0x0F; byte=0x38; byte=0xF0; Reg64 ... & rm8  { Reg64 = crc32(Reg64, rm8); }
:CRC32 Reg64, rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F2) & $(REX_W) & byte=0x0F; byte=0x38; byte=0xF1; Reg64 ... & rm64 { Reg64 = crc32(Reg64, rm64); }
@endif

define pcodeop pcmpestri;
:PCMPESTRI XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x61; XmmReg ... & m128; imm8 { ECX = pcmpestri(XmmReg, m128, imm8:8); }
:PCMPESTRI XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x61; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { ECX = pcmpestri(XmmReg1, XmmReg2, imm8:8); }

define pcodeop pcmpestrm;
:PCMPESTRM XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x60; XmmReg ... & m128; imm8 { XMM0 = pcmpestrm(XmmReg, m128, imm8:8); }
:PCMPESTRM XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x60; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XMM0 = pcmpestrm(XmmReg1, XmmReg2, imm8:8); }

define pcodeop pcmpistri;
:PCMPISTRI XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x63; XmmReg ... & m128; imm8 { ECX = pcmpistri(XmmReg, m128, imm8:8); }
:PCMPISTRI XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x63; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { ECX = pcmpistri(XmmReg1, XmmReg2, imm8:8); }

define pcodeop pcmpistrm;
:PCMPISTRM XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x62; XmmReg ... & m128; imm8 { XMM0 = pcmpistrm(XmmReg, m128, imm8:8); }
:PCMPISTRM XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x62; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XMM0 = pcmpistrm(XmmReg1, XmmReg2, imm8:8); }

:PCMPGTQ XmmReg1, XmmReg2_m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x37; XmmReg1 ... & XmmReg2_m128 
{ 
    XmmReg1[0,64] = 0xffffffffffffffff:8 * (zext(XmmReg1[0,64] s> XmmReg2_m128[0,64]));
    XmmReg1[64,64] = 0xffffffffffffffff:8 * (zext(XmmReg1[64,64] s> XmmReg2_m128[64,64]));
}

macro popcountflags(src){
	OF = 0:1;
	SF = 0:1;
	AF = 0:1;
	CF = 0:1;
	PF = 0:1;
	ZF = (src == 0);
}
:POPCNT Reg16, rm16      is vexMode=0 & opsize=0 & $(PRE_F3) &            byte=0x0F; byte=0xB8; Reg16 ... & rm16 { popcountflags(rm16); Reg16 = popcount(rm16); }
:POPCNT Reg32, rm32      is vexMode=0 & opsize=1 & $(PRE_F3) &            byte=0x0F; byte=0xB8; Reg32 ... & check_Reg32_dest ... & rm32 { popcountflags(rm32); Reg32 = popcount(rm32); build check_Reg32_dest; }
@ifdef IA64
:POPCNT Reg64, rm64      is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & $(REX_W) & byte=0x0F; byte=0xB8; Reg64 ... & rm64 { popcountflags(rm64); Reg64 = popcount(rm64); }
@endif

####
#### AESNI instructions
####

define pcodeop aesdec;
:AESDEC XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xde; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesdec(XmmReg1, XmmReg2_m128);
}
:VAESDEC XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xde; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesdec(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}

define pcodeop aesdeclast;
:AESDECLAST  XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdf; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesdeclast(XmmReg1, XmmReg2_m128);
}
:VAESDECLAST XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xdf; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesdeclast(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}

define pcodeop aesenc;
:AESENC XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdc; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesenc(XmmReg1, XmmReg2_m128);
}
:VAESENC XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xdc; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesenc(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}

define pcodeop aesenclast;
:AESENCLAST  XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdd; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesenclast(XmmReg1, XmmReg2_m128);
}
:VAESENCLAST XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xdd; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesenclast(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}

define pcodeop aesimc;
:AESIMC XmmReg1, XmmReg2_m128  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdb; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesimc(XmmReg2_m128);
}
:VAESIMC XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0xdb; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesimc(XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}

define pcodeop aeskeygenassist;
:AESKEYGENASSIST XmmReg1, XmmReg2_m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0xdf; XmmReg1 ... & XmmReg2_m128; imm8 {
	XmmReg1 = aeskeygenassist(XmmReg2_m128, imm8:1);
}
:VAESKEYGENASSIST XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0xdf; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8 {
	XmmReg1 = aeskeygenassist(XmmReg2_m128, imm8:1);
	YmmReg1 = zext(XmmReg1);
}



####
#### Deprecated 3DNow! instructions
####

define pcodeop PackedIntToFloatingDwordConv;
:PI2FD mmxreg, m64      is vexMode=0 & suffix3D=0x0D & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedIntToFloatingDwordConv(mmxreg, m64); }
:PI2FD mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x0D & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedIntToFloatingDwordConv(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingToIntDwordConv;
:PF2ID mmxreg, m64      is vexMode=0 & suffix3D=0x1D & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingToIntDwordConv(mmxreg, m64); }
:PF2ID mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x1D & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingToIntDwordConv(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingCompareGE;
:PFCMPGE mmxreg, m64      is vexMode=0 & suffix3D=0x90 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingCompareGE(mmxreg, m64); }
:PFCMPGE mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x90 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingCompareGE(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingCompareGT;
:PFCMPGT mmxreg, m64      is vexMode=0 & suffix3D=0xA0 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingCompareGT(mmxreg, m64); }
:PFCMPGT mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA0 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingCompareGT(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingCompareEQ;
:PFCMPEQ mmxreg, m64      is vexMode=0 & suffix3D=0xB0 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingCompareEQ(mmxreg, m64); }
:PFCMPEQ mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB0 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingCompareEQ(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingAccumulate;
:PFACC mmxreg, m64      is vexMode=0 & suffix3D=0xAE & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingAccumulate(mmxreg, m64); }
:PFACC mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xAE & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingAccumulate(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingADD;
:PFADD mmxreg, m64      is vexMode=0 & suffix3D=0x9E & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64  { mmxreg = PackedFloatingADD(mmxreg, m64); }
:PFADD mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x9E & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingADD(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingSUB;
:PFSUB mmxreg, m64      is vexMode=0 & suffix3D=0x9A & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingSUB(mmxreg, m64); }
:PFSUB mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x9A & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingSUB(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingSUBR;
:PFSUBR mmxreg, m64      is vexMode=0 & suffix3D=0xAA & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingSUBR(mmxreg, m64); }
:PFSUBR mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xAA & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingSUBR(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingMIN;
:PFMIN mmxreg, m64      is vexMode=0 & suffix3D=0x94 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingMIN(mmxreg, m64); }
:PFMIN mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x94 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingMIN(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingMAX;
:PFMAX mmxreg, m64      is vexMode=0 & suffix3D=0xA4 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingMAX(mmxreg, m64); }
:PFMAX mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA4 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingMAX(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingMUL;
:PFMUL mmxreg, m64      is vexMode=0 & suffix3D=0xB4 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingMUL(mmxreg, m64); }
:PFMUL mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB4 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingMUL(mmxreg1, mmxreg2); }

define pcodeop FloatingReciprocalAprox;
:PFRCP mmxreg, m64      is vexMode=0 & suffix3D=0x96 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = FloatingReciprocalAprox(mmxreg, m64); }
:PFRCP mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x96 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = FloatingReciprocalAprox(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingReciprocalSQRAprox;
:PFRSQRT mmxreg, m64      is vexMode=0 & suffix3D=0x97 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalSQRAprox(mmxreg, m64); }
:PFRSQRT mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x97 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalSQRAprox(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingReciprocalIter1;
:PFRCPIT1 mmxreg, m64      is vexMode=0 & suffix3D=0xA6 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalIter1(mmxreg, m64); }
:PFRCPIT1 mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA6 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalIter1(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingReciprocalSQRIter1;
:PFRSQIT1 mmxreg, m64      is vexMode=0 & suffix3D=0xA7 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalSQRIter1(mmxreg, m64); }
:PFRSQIT1 mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA7 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalSQRIter1(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingReciprocalIter2;
:PFRCPIT2 mmxreg, m64      is vexMode=0 & suffix3D=0xB6 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalIter2(mmxreg, m64); }
:PFRCPIT2 mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB6 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalIter2(mmxreg1, mmxreg2); }

define pcodeop PackedAverageUnsignedBytes;
:PAVGUSB mmxreg, m64      is vexMode=0 & suffix3D=0xBF & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedAverageUnsignedBytes(mmxreg, m64); }
:PAVGUSB mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xBF & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedAverageUnsignedBytes(mmxreg1, mmxreg2); }

define pcodeop PackedAverageHighRoundedWord;
:PMULHRW mmxreg, m64      is vexMode=0 & suffix3D=0xB7 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedAverageHighRoundedWord(mmxreg, m64); }
:PMULHRW mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB7 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedAverageHighRoundedWord(mmxreg1, mmxreg2); }

define pcodeop FastExitMediaState;
:FEMMS         is vexMode=0 & byte=0x0F; byte=0x0E    { FastExitMediaState(); }

#define pcodeop PrefetchDataIntoCache;
#:PREFETCH m8     is vexMode=0 & byte=0x0F; byte=0x18; m8 { PrefetchDataIntoCache(m8); }

#define pcodeop PrefetchDataIntoCacheWrite;
#:PREFETCHW m8     is vexMode=0 & byte=0x0F; byte=0x0D; reg_opcode=1 ... & m8 { PrefetchDataIntoCacheWrite(m8); }

# 3DNow! extensions

define pcodeop PackedFloatingToIntWord;
:PF2IW mmxreg, m64      is vexMode=0 & suffix3D=0x1C & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingToIntWord(mmxreg, m64); }
:PF2IW mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x1C & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingToIntWord(mmxreg1, mmxreg2); }

define pcodeop PackedIntToFloatingWord;
:PI2FW mmxreg, m64      is vexMode=0 & suffix3D=0x0C & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedIntToFloatingWord(mmxreg, m64); }
:PI2FW mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x0C & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedIntToFloatingWord(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingNegAccumulate;
:PFNACC mmxreg, m64      is vexMode=0 & suffix3D=0x8A & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingNegAccumulate(mmxreg, m64); }
:PFNACC mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x8A & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingNegAccumulate(mmxreg1, mmxreg2); }

define pcodeop PackedFloatingPosNegAccumulate;
:PFPNACC mmxreg, m64      is vexMode=0 & suffix3D=0x8E & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingPosNegAccumulate(mmxreg, m64); }
:PFPNACC mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x8E & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingPosNegAccumulate(mmxreg1, mmxreg2); }

define pcodeop PackedSwapDWords;
:PSWAPD mmxreg, m64      is vexMode=0 & suffix3D=0xBB & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedSwapDWords(mmxreg, m64); }
:PSWAPD mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xBB & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedSwapDWords(mmxreg1, mmxreg2); }

define pcodeop MaskedMoveQWord;
:MASKMOVQ            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF7; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = MaskedMoveQWord(mmxreg1, mmxreg2); }

} # end with : lockprefx=0

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/lockable.sinc`:

```sinc
# The LOCK prefix is only valid for certain instructions, otherwise, from the
# Intel instruction manual:
#     An undefined opcode exception will also be generated if the LOCK prefix
#     is used with any instruction not in the above list.
# The instructions in this file have their non-lockable counterparts in ia.sinc

:ADC^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=2 ... ; imm8 
{ 
    build lockx; 
    build spec_m8;
    addCarryFlags( spec_m8, imm8:1 ); 
    resultflags( spec_m8 );
    build unlock;
}

:ADC^lockx spec_m16,imm16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=2 ...; imm16 
{    
    build lockx;
    build spec_m16;
    addCarryFlags( spec_m16, imm16:2 );
    resultflags( spec_m16 );
    build unlock; 
}

:ADC^lockx spec_m32,imm32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=2 ...; imm32 
{    
    build lockx;
    build spec_m32;
    addCarryFlags( spec_m32, imm32:4 );
    resultflags( spec_m32 );
    build unlock; 
}

@ifdef IA64
:ADC^lockx spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=2 ...; simm32 
{    
    build lockx;
    build spec_m64;
    addCarryFlags( spec_m64, simm32 );
    resultflags( spec_m64 );
    build unlock; 
}
@endif

:ADC^lockx spec_m16,simm8_16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=2 ...; simm8_16	
{
    build lockx; 
    build spec_m16;
    addCarryFlags( spec_m16, simm8_16 );
    resultflags( spec_m16 );
    build unlock; 
}

:ADC^lockx spec_m32,simm8_32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=2 ...; simm8_32 
{
    build lockx;
    build spec_m32;
    addCarryFlags( spec_m32, simm8_32 );
    resultflags( spec_m32 );
    build unlock; 
}

@ifdef IA64
:ADC^lockx spec_m64,simm8_64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=2 ...; simm8_64 
{
    build lockx;
    build spec_m64;
    addCarryFlags( spec_m64, simm8_64 );
    resultflags( spec_m64 );
    build unlock; 
}
@endif

:ADC^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x10; m8 & Reg8 ...                 
{
    build lockx;
    build m8;
    addCarryFlags( m8, Reg8 );
    resultflags( m8 );
    build unlock;
}

:ADC^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x11; m16 & Reg16 ...    
{
    build lockx;
    build m16;
    addCarryFlags( m16, Reg16 );
    resultflags( m16 );
    build unlock;
}

:ADC^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x11; m32 & Reg32 ...    
{
    build lockx;
    build m32;
    addCarryFlags( m32, Reg32 );
    resultflags( m32 );
    build unlock;
}

@ifdef IA64
:ADC^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x11; m64 & Reg64 ...    
{
    build lockx;
    build m64;
    addCarryFlags( m64, Reg64 );
    resultflags( m64 );
    build unlock;
}
@endif

:ADD^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=0 ...; imm8		
{
    build lockx;
    build spec_m8;
    addflags( spec_m8,imm8 );
    spec_m8 =   spec_m8 +  imm8;
    resultflags(  spec_m8);
    build unlock;
}

:ADD^lockx spec_m16,imm16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=0 ...; imm16	
{
    build lockx;
    build spec_m16;
    addflags( spec_m16,imm16);
    spec_m16 =  spec_m16 + imm16;
    resultflags( spec_m16);
    build unlock;
}

:ADD^lockx spec_m32,imm32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=0 ...; imm32	
{
    build lockx;
    build spec_m32;
    addflags( spec_m32,imm32);
    spec_m32 =  spec_m32 + imm32;
    resultflags( spec_m32);
    build unlock;
}

@ifdef IA64
:ADD^lockx spec_m64,simm32		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=0 ...; simm32	
{
    build lockx;
    build spec_m64;
    addflags( spec_m64,simm32);
    spec_m64 =  spec_m64 + simm32;
    resultflags( spec_m64);
    build unlock;
}
@endif

:ADD^lockx spec_m16,simm8_16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=0 ...; simm8_16	
{
    build lockx;
    build spec_m16;
    addflags( spec_m16,simm8_16);
    spec_m16 =  spec_m16 + simm8_16;
    resultflags( spec_m16);
    build unlock;
}

:ADD^lockx spec_m32,simm8_32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=0 ...; simm8_32	
{
    build lockx;
    build spec_m32;
    addflags( spec_m32,simm8_32);
    spec_m32 =  spec_m32 + simm8_32;
    resultflags( spec_m32);
    build unlock;
}

@ifdef IA64
:ADD^lockx spec_m64,simm8_64		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=0 ...; simm8_64	
{
    build lockx;
    build spec_m64;
    addflags( spec_m64,simm8_64);
    spec_m64 =  spec_m64 + simm8_64;
    resultflags( spec_m64);
    build unlock;
}
@endif

:ADD^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x00; m8 & Reg8 ...                 
{
    build lockx;
    build m8;
    addflags(  m8,Reg8 );
    m8 =   m8 +  Reg8;
    resultflags(  m8);
    build unlock;
}

:ADD^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x1; m16 & Reg16 ...     
{
    build lockx;
    build m16;
    addflags( m16,Reg16);
    m16 =  m16 + Reg16;
    resultflags( m16);
    build unlock;
}

:ADD^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x1; m32 & Reg32 ...     
{
    build lockx;
    build m32;
    addflags( m32,Reg32);
    m32 =  m32 + Reg32;
    resultflags( m32);
    build unlock;
}

@ifdef IA64
:ADD^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x1; m64 & Reg64 ...    
{
    build lockx;
    build m64;
    addflags( m64,Reg64);
    m64 =  m64 + Reg64;
    resultflags( m64);
    build unlock;
}
@endif

:AND^lockx m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=4 ...; imm8     
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 &  imm8;
    resultflags(  m8);
    build unlock;
}

:AND^lockx m16,imm16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=4 ...; imm16  
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 & imm16;
    resultflags( m16);
    build unlock;
}

:AND^lockx m32,imm32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=4 ...; imm32  
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 & imm32;
    resultflags( m32);
    build unlock;
}

@ifdef IA64
:AND^lockx m64,simm32    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=4 ...; simm32  
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 & simm32;
    resultflags( m64);
    build unlock;
}
@endif

:AND^lockx m16,usimm8_16		is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=4 ...; usimm8_16	
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 & usimm8_16;
    resultflags( m16);
    build unlock;
}

:AND^lockx m32,usimm8_32		is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=4 ...; usimm8_32	
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 & usimm8_32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:AND^lockx m64,usimm8_64		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=4 ...; usimm8_64	
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 & usimm8_64;
    resultflags( m64);
    build unlock; 
}
@endif

:AND^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x20; m8 & Reg8 ...                     
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 &  Reg8;
    resultflags(  m8);
    build unlock; 
}

:AND^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x21; m16 & Reg16 ...        
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 & Reg16;
    resultflags( m16);
    build unlock; 
}

:AND^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x21; m32 & Reg32 ...        
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 & Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:AND^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x21; m64 & Reg64 ...        
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 & Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

:BTC^lockx Mem,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xbb; Mem & Reg16 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (sext(Reg16) s>> 3);
    local bit=Reg16&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr= *:1 ptr ^(1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTC^lockx Mem,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xbb; Mem & Reg32 ...		
{
    build lockx;
    build Mem;
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    local bit=Reg32&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr ^ (1<<bit);
    CF = (val != 0);
    build unlock;
}

@ifdef IA64
:BTC^lockx Mem,Reg64     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xbb; Mem & Reg64 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (Reg64 s>> 3);
    local bit=Reg64&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr ^ (1<<bit);
    CF = (val != 0);
    build unlock; 
}
@endif

:BTC^lockx m16,imm8     is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xba; m16 & reg_opcode=7 ...; imm8   
{
    build lockx;
    build m16;
    local bit=imm8&0xf;
    local val=(m16>>bit)&1;
    m16=m16^(1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTC^lockx m32,imm8     is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xba; m32 & reg_opcode=7 ...; imm8   
{
    build lockx;
    build m32;
    local bit=imm8&0x1f;
    local val=(m32>>bit)&1;
    CF=(val!=0);
    m32=m32^(1<<bit);
    build unlock; 
}

@ifdef IA64
:BTC^lockx m64,imm8     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xba; m64 & reg_opcode=7 ...; imm8   
{
    build lockx;
    build m64;
    local bit=imm8&0x3f;
    local val=(m64>>bit)&1;
    m64=m64^(1<<bit);
    CF=(val!=0);
    build unlock; 
}
@endif

:BTR^lockx Mem,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xb3; Mem & Reg16 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (sext(Reg16) s>> 3);
    local bit=Reg16&7;
    local val=(*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
    build unlock; 
}

:BTR^lockx Mem,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xb3; Mem & Reg32 ...		
{
    build lockx;
    build Mem;
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    local bit = Reg32 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
    build unlock;
}

@ifdef IA64
:BTR^lockx Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xb3; Mem & Reg64 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (Reg64 s>> 3);
    local bit = Reg64 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
    build unlock; 
}
@endif

:BTR^lockx m16,imm8     is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xba; m16 & reg_opcode=6 ...; imm8   
{
    build lockx;
    build m16;
    local bit=imm8&0xf;
    local val=(m16>>bit)&1;
    m16=m16 & ~(1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTR^lockx m32,imm8     is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xba; m32 & reg_opcode=6 ...; imm8   
{
    build lockx;
    build m32;
    local bit=imm8&0x1f;
    local val=(m32>>bit)&1;
    CF=(val!=0);
    m32=m32 & ~(1<<bit);
    build unlock; 
}

@ifdef IA64
:BTR^lockx m64,imm8     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xba; m64 & reg_opcode=6 ...; imm8   
{
    build lockx;
    build m64;
    local bit=imm8&0x3f;
    local val=(m64>>bit)&1;
    m64=m64 & ~(1<<bit);
    CF=(val!=0);
    build unlock; 
}
@endif

:BTS^lockx Mem,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xab; Mem & Reg16 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (sext(Reg16) s>> 3);
    local bit = Reg16&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
    build unlock; 
}

:BTS^lockx Mem,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xab; Mem & Reg32 ...		
{
    build lockx;
    build Mem;
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>>3);
@else
    local ptr = Mem + (Reg32 s>>3);
@endif
    local bit = Reg32 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
    build unlock;
}

@ifdef IA64
:BTS^lockx Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xab; Mem & Reg64 ...		
{
    build lockx;
    build Mem;
    local ptr = Mem + (Reg64 s>>3);
    local bit = Reg64 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
    build unlock; 
}
@endif

:BTS^lockx m16,imm8     is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xba; m16 & reg_opcode=5 ...; imm8   
{
    build lockx;
    build m16;
    local bit=imm8&0xf;
    local val=(m16>>bit)&1;
    m16=m16 | (1<<bit);
    CF=(val!=0);
    build unlock; 
}

:BTS^lockx m32,imm8     is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xba; m32 & reg_opcode=5 ...; imm8   
{
    build lockx;
    build m32;
    local bit=imm8&0x1f;
    local val=(m32>>bit)&1;
    CF=(val!=0);
    m32=m32 | (1<<bit);
    build unlock; 
}

@ifdef IA64
:BTS^lockx m64,imm8     is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xba; m64 & reg_opcode=5 ...; imm8   
{
    build lockx;
    build m64;
    local bit=imm8&0x3f;
    local val=(m64>>bit)&1;
    m64=m64 | (1<<bit);
    CF=(val!=0);
    build unlock; 
}
@endif

:CMPXCHG^lockx m8,Reg8  is vexMode=0 & lockx & unlock & byte=0xf; byte=0xb0; m8 & Reg8 ...           
{
    build lockx;
    local dest = m8;
    subflags(AL,dest); 
    local diff = AL-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    AL = dest;
    goto <inst_end>;
<equal>
    m8 = Reg8;
<inst_end>
    build unlock;
}

:CMPXCHG^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xb1; m16 & Reg16 ...  
{
    build lockx;
    local dest = m16;
    subflags(AX,dest); 
    local diff = AX-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    AX = dest;
    goto <inst_end>;
<equal>
    m16 = Reg16;
<inst_end>
    build unlock; 
}

:CMPXCHG^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xb1; m32 & Reg32 ... & check_EAX_dest ...
{
    build lockx;
    #this instruction writes to either EAX or Rmr32
	#in 64-bit mode, a 32-bit register that is written to 
	#(and only the register that is written to) 
	#must be zero-extended to 64 bits
    local dest = m32;
    subflags(EAX,dest); 
    local diff = EAX-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    EAX = dest;
    build check_EAX_dest;
    goto <inst_end>;
<equal>
    m32 = Reg32;
<inst_end>
    build unlock;
}

@ifdef IA64
:CMPXCHG^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xb1; m64 & Reg64 ...  
{
    build lockx;
    local dest = m64;
    subflags(RAX,dest); 
    local diff = RAX-dest; 
    resultflags(diff);
    if (ZF) goto <equal>;
    RAX = dest;
    goto <inst_end>;
<equal>
    m64 = Reg64;
<inst_end>
    build unlock;
}
@endif

:CMPXCHG8B^lockx  m64        is vexMode=0 & lockx & unlock & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64 
{
    build lockx;
    local dest = m64;
    ZF = ((zext(EDX) << 32) | zext(EAX)) == dest;
    if (ZF == 1) goto <equal>;
    EDX = dest(4);
    EAX = dest:4;
    goto <done>;
<equal>
    m64 = (zext(ECX) << 32) | zext(EBX);
  <done>
    build unlock;
}

@ifdef IA64
:CMPXCHG16B^lockx  m128	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & ( m128 ) {
    build lockx;
    local dest = m128;
    ZF = ((zext(RDX) << 64) | zext(RAX)) == dest;
    if (ZF == 1) goto <equal>;
    RDX = dest(8);
    RAX = dest:8;
    goto <done>;
<equal>
    m128 = ((zext(RCX) << 64) | zext(RBX));
<done>
    build unlock;
}
@endif

:DEC^lockx spec_m8       is vexMode=0 & lockx & unlock & byte=0xfe; spec_m8 & reg_opcode=1 ...         
{
    build lockx;
    build spec_m8;
    OF = sborrow(spec_m8,1);
    spec_m8 =  spec_m8 - 1;
    resultflags( spec_m8);
    build unlock; 
}

:DEC^lockx spec_m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; spec_m16 & reg_opcode=1 ... 
{
    build lockx;
    build spec_m16;
    OF = sborrow(spec_m16,1);
    spec_m16 = spec_m16 - 1;
    resultflags(spec_m16);
    build unlock; 
}

:DEC^lockx spec_m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; spec_m32 & reg_opcode=1 ... 
{
    build lockx;
    build spec_m32;
    OF = sborrow(spec_m32,1);
    spec_m32 = spec_m32 - 1;
    resultflags(spec_m32);
    build unlock; 
}

@ifdef IA64
:DEC^lockx spec_m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; spec_m64 & reg_opcode=1 ... 
{
    build lockx;
    build spec_m64;
    OF = sborrow(spec_m64,1);
    spec_m64 = spec_m64 - 1;
    resultflags(spec_m64);
    build unlock; 
}
@endif

:INC^lockx  spec_m8	is vexMode=0 & lockx & unlock & byte=0xfe; spec_m8 ...				
{
    build lockx;
    build spec_m8;
    OF = scarry(spec_m8,1);
    spec_m8 =  spec_m8 + 1;
    resultflags( spec_m8);
    build unlock; 
}

:INC^lockx spec_m16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; spec_m16 ...	
{
    build lockx;
    build spec_m16;
    OF = scarry(spec_m16,1);
    spec_m16 = spec_m16 + 1;
    resultflags(spec_m16);
    build unlock; 
}

:INC^lockx spec_m32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; spec_m32 ...	
{
    build lockx;
    build spec_m32;
    OF = scarry(spec_m32,1);
    spec_m32 = spec_m32 + 1;
    resultflags(spec_m32);
    build unlock; 
}

@ifdef IA64
:INC^lockx spec_m64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; spec_m64 ... 
{
    build lockx;
    build spec_m64;
    OF = scarry(spec_m64,1);
    spec_m64 = spec_m64 + 1;
    resultflags(spec_m64);
    build unlock; 
}
@endif

:NEG^lockx m8       is vexMode=0 & lockx & unlock & byte=0xf6; m8 & reg_opcode=3 ...         
{
    build lockx;
    build m8;
    negflags(m8);
    m8 =  -m8;
    resultflags(m8 );
    build unlock; 
}

:NEG^lockx m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf7; m16 & reg_opcode=3 ... 
{
    build lockx;
    build m16;
    negflags(m16);
    m16 = -m16;
    resultflags(m16);
    build unlock; 
}

:NEG^lockx m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf7; m32 & reg_opcode=3 ... 
{
    build lockx;
    build m32;
    negflags(m32);
    m32 = -m32;
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:NEG^lockx m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf7; m64 & reg_opcode=3 ... 
{
    build lockx;
    build m64;
    negflags(m64);
    m64 = -m64;
    resultflags(m64);
    build unlock; 
}
@endif

:NOT^lockx m8       is vexMode=0 & lockx & unlock & byte=0xf6; m8 & reg_opcode=2 ...         
{
    build lockx;
    build m8;
    m8 =  ~m8;
    build unlock; 
}

:NOT^lockx m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf7; m16 & reg_opcode=2 ... 
{
    build lockx;
    build m16;
    m16 = ~m16;
    build unlock; 
}

:NOT^lockx m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf7; m32 & reg_opcode=2 ... 
{
    build lockx;
    build m32;
    m32 = ~m32;
    build unlock; 
}

@ifdef IA64
:NOT^lockx m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf7; m64 & reg_opcode=2 ... 
{
    build lockx;
    build m64;
    m64 = ~m64;
    build unlock; 
}
@endif

:OR^lockx  spec_m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=1 ...; imm8     
{
    build lockx;
    build spec_m8;
    logicalflags();
    spec_m8 =   spec_m8 |  imm8;
    resultflags(  spec_m8);
    build unlock; 
}

:OR^lockx  spec_m16,imm16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=1 ...; imm16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 | imm16;
    resultflags( spec_m16);
    build unlock; 
}

:OR^lockx  spec_m32,imm32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=1 ...; imm32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 | imm32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:OR^lockx  spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=1 ...; simm32 
{
    build lockx;
    build spec_m64;
    logicalflags();
    tmp:8 = spec_m64;
    spec_m64 =  tmp | simm32;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:OR^lockx  spec_m16,usimm8_16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=1 ...; usimm8_16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 | usimm8_16;
    resultflags( spec_m16);
    build unlock; 
}

:OR^lockx  spec_m32,usimm8_32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=1 ...; usimm8_32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 | usimm8_32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:OR^lockx  spec_m64,usimm8_64        is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=1 ...; usimm8_64  
{
    build lockx;
    build spec_m64;
    logicalflags();
    spec_m64 =  spec_m64 | usimm8_64;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:OR^lockx  m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x8; m8 & Reg8 ...                  
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 |  Reg8;
    resultflags(  m8);
    build unlock; 
}

:OR^lockx  m16,Reg16        is vexMode=0 & lockx & unlock & opsize=0 & byte=0x9; m16 & Reg16 ...     
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 | Reg16;
    resultflags( m16);
    build unlock; 
}

:OR^lockx  m32,Reg32        is vexMode=0 & lockx & unlock & opsize=1 & byte=0x9; m32 & Reg32 ...     
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 | Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:OR^lockx  m64,Reg64        is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x9; m64 & Reg64 ...     
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 | Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

:SBB^lockx  m8,imm8     is vexMode=0 & lockx & unlock & $(BYTE_80_82); m8 & reg_opcode=3 ...; imm8								
{
    build lockx;
    build m8;
    subCarryFlags( m8, imm8 );
    resultflags(m8);
    build unlock; 
}

:SBB^lockx  m16,imm16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; m16 & reg_opcode=3 ...; imm16							
{
    build lockx;
    build m16;
    subCarryFlags( m16, imm16 );
    resultflags(m16);
    build unlock; 
}

:SBB^lockx  m32,imm32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; m32 & reg_opcode=3 ...; imm32	
{
    build lockx;
    build m32;
    subCarryFlags( m32, imm32 );
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:SBB^lockx  m64,imm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; m64 & reg_opcode=3 ...; imm32							
{
    build lockx;
    build m64;
    subCarryFlags( m64, imm32 );
    resultflags(m64);
    build unlock; 
}
@endif

:SBB^lockx  m16,simm8_16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; m16 & reg_opcode=3 ...; simm8_16						
{
    build lockx;
    build m16;
    subCarryFlags( m16, simm8_16 );
    resultflags(m16);
    build unlock; 
}

:SBB^lockx  m32,simm8_32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; m32 & reg_opcode=3 ...; simm8_32	
{
    build lockx;
    build m32;
    subCarryFlags( m32, simm8_32 );
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:SBB^lockx  m64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; m64 & reg_opcode=3 ...; simm8_64						
{
    build lockx;
    build m64;
    subCarryFlags( m64, simm8_64 );
    resultflags(m64);
    build unlock; 
}
@endif

:SBB^lockx  m8,Reg8     is vexMode=0 & lockx & unlock & byte=0x18; m8 & Reg8 ...											
{
    build lockx;
    build m8;
    subCarryFlags(  m8, Reg8 );
    resultflags(m8);
    build unlock; 
}

:SBB^lockx  m16,Reg16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x19; m16 & Reg16 ...						
{
    build lockx;
    build m16;
    subCarryFlags( m16, Reg16 );
    resultflags(m16);
    build unlock; 
}

:SBB^lockx  m32,Reg32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x19; m32 & Reg32 ...	
{
    build lockx;
    build m32;
    subCarryFlags( m32, Reg32 );
    resultflags(m32);
    build unlock; 
}

@ifdef IA64
:SBB^lockx  m64,Reg64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x19; m64 & Reg64 ...						
{
    build lockx;
    build m64;
    subCarryFlags( m64, Reg64 );
    resultflags(m64);
    build unlock; 
}
@endif

:SUB^lockx  spec_m8,imm8     is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=5 ...; imm8     
{
    build lockx;
    build spec_m8;
    subflags(  spec_m8,imm8 );
    spec_m8 =   spec_m8 -  imm8;
    resultflags(  spec_m8);
    build unlock; 
}

:SUB^lockx  spec_m16,imm16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=5 ...; imm16  
{
    build lockx;
    build spec_m16;
    subflags( spec_m16,imm16);
    spec_m16 =  spec_m16 - imm16;
    resultflags( spec_m16);
    build unlock; 
}

:SUB^lockx  spec_m32,imm32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=5 ...; imm32  
{
    build lockx;
    build spec_m32;
    subflags( spec_m32,imm32);
    spec_m32 =  spec_m32 - imm32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:SUB^lockx  spec_m64,simm32       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=5 ...; simm32  
{
    build lockx;
    build spec_m64;
    subflags( spec_m64,simm32);
    spec_m64 =  spec_m64 - simm32;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:SUB^lockx  spec_m16,simm8_16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=5 ...; simm8_16  
{
    build lockx;
    build spec_m16;
    subflags( spec_m16,simm8_16);
    spec_m16 =  spec_m16 - simm8_16;
    resultflags( spec_m16);
    build unlock; 
}

:SUB^lockx  spec_m32,simm8_32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=5 ...; simm8_32  
{
    build lockx;
    build spec_m32;
    subflags( spec_m32,simm8_32);
    spec_m32 =  spec_m32 - simm8_32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:SUB^lockx  spec_m64,simm8_64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=5 ...; simm8_64  
{
    build lockx;
    build spec_m64;
    subflags( spec_m64,simm8_64);
    spec_m64 =  spec_m64 - simm8_64;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:SUB^lockx  m8,Reg8     is vexMode=0 & lockx & unlock & byte=0x28; m8 & Reg8 ...                 
{
    build lockx;
    build m8;
    subflags(  m8,Reg8 );
    m8 =   m8 -  Reg8;
    resultflags(  m8);
    build unlock; 
}

:SUB^lockx  m16,Reg16       is vexMode=0 & lockx & unlock & opsize=0 & byte=0x29; m16 & Reg16 ...        
{
    build lockx;
    build m16;
    subflags( m16,Reg16);
    m16 =  m16 - Reg16;
    resultflags( m16);
    build unlock; 
}

:SUB^lockx  m32,Reg32       is vexMode=0 & lockx & unlock & opsize=1 & byte=0x29; m32 & Reg32 ...        
{
    build lockx;
    build m32;
    subflags( m32,Reg32);
    m32 =  m32 - Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:SUB^lockx  m64,Reg64       is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x29; m64 & Reg64 ...        
{
    build lockx;
    build m64;
    subflags( m64,Reg64);
    m64 =  m64 - Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

:XADD^lockx  m8,Reg8 	is vexMode=0 & lockx & unlock & byte=0x0F; byte=0xC0;  m8 & Reg8  ...        
{
    build lockx;
    build m8;
    addflags( m8,Reg8 );
    local tmp =  m8 +  Reg8;
    Reg8 = m8;
    m8 = tmp;
    resultflags(tmp);
    build unlock; 
}

:XADD^lockx m16,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x0F; byte=0xC1; m16 & Reg16 ... 
{
    build lockx;
    build m16;
    addflags(m16,Reg16);
    local tmp = m16 + Reg16;
    Reg16 = m16;
    m16 = tmp;
    resultflags(tmp);
    build unlock; 
}

:XADD^lockx m32,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x0F; byte=0xC1; m32 & Reg32 & check_Reg32_dest ... 
{
    build lockx;
    build m32;
    addflags(m32,Reg32);
    local tmp = m32 + Reg32;
    Reg32 = m32;
    build check_Reg32_dest;
    m32 = tmp;
    resultflags(tmp);
    build unlock; 
}

@ifdef IA64
:XADD^lockx m64,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x0F; byte=0xC1; m64 & Reg64 ... 
{
    build lockx;
    build m64;
    addflags(m64,Reg64);
    local tmp = m64 + Reg64;
    Reg64 = m64;
    m64 = tmp;
    resultflags(tmp);
    build unlock; 
}
@endif

# XCHG with memory operands always asserts a lock signal regardless of prefix presence
:XCHG^xacq_xrel_prefx^alwaysLock   m8,Reg8        is vexMode=0 & xacq_xrel_prefx & alwaysLock & byte=0x86; m8 & Reg8  ...                
{ 
   build xacq_xrel_prefx;
   build alwaysLock; 
   build m8;
   local tmp = m8;  
   m8 = Reg8;
   Reg8 = tmp; 
   UNLOCK();
}

:XCHG^xacq_xrel_prefx^alwaysLock  m16,Reg16   is vexMode=0 & xacq_xrel_prefx & alwaysLock & opsize=0 & byte=0x87; m16 & Reg16 ...        
{ 
   build xacq_xrel_prefx;
   build alwaysLock;
   build m16;
   local tmp = m16; 
   m16 = Reg16; 
   Reg16 = tmp; 
   UNLOCK();
}

:XCHG^xacq_xrel_prefx^alwaysLock  m32,Reg32   is vexMode=0 & xacq_xrel_prefx & alwaysLock & opsize=1 & byte=0x87; m32 & Reg32 ...        
{ 
  build xacq_xrel_prefx;
  build alwaysLock;
  build m32;
  local tmp = m32; 
  m32 = Reg32; 
  Reg32 = tmp; 
  UNLOCK(); 
}

@ifdef IA64
:XCHG^xacq_xrel_prefx^alwaysLock m64,Reg64   is $(LONGMODE_ON) & vexMode=0 & xacq_xrel_prefx & alwaysLock & opsize=2 & byte=0x87; m64 & Reg64 ...        
{ 
  build xacq_xrel_prefx; 
  build alwaysLock;
  build m64;
  local tmp = m64; 
  m64 = Reg64; 
  Reg64 = tmp; 
  UNLOCK(); 
}
@endif

:XOR^lockx spec_m8,imm8      is vexMode=0 & lockx & unlock & $(BYTE_80_82); spec_m8 & reg_opcode=6 ...; imm8     
{
    build lockx;
    build spec_m8;
    logicalflags();
    spec_m8 =   spec_m8 ^  imm8;
    resultflags(  spec_m8);
    build unlock; 
}

:XOR^lockx spec_m16,imm16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x81; spec_m16 & reg_opcode=6 ...; imm16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 ^ imm16;
    resultflags( spec_m16);
    build unlock; 
}

:XOR^lockx spec_m32,imm32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x81; spec_m32 & reg_opcode=6 ...; imm32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 ^ imm32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:XOR^lockx spec_m64,simm32   is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=6 ...; simm32 
{
    build lockx;
    build spec_m64;
    logicalflags();
    spec_m64 =  spec_m64 ^ simm32;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:XOR^lockx spec_m16,usimm8_16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x83; spec_m16 & reg_opcode=6 ...; usimm8_16  
{
    build lockx;
    build spec_m16;
    logicalflags();
    spec_m16 =  spec_m16 ^ usimm8_16;
    resultflags( spec_m16);
    build unlock; 
}

:XOR^lockx spec_m32,usimm8_32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x83; spec_m32 & reg_opcode=6 ...; usimm8_32  
{
    build lockx;
    build spec_m32;
    logicalflags();
    spec_m32 =  spec_m32 ^ usimm8_32;
    resultflags( spec_m32);
    build unlock; 
}

@ifdef IA64
:XOR^lockx spec_m64,usimm8_64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x83; spec_m64 & reg_opcode=6 ...; usimm8_64  
{
    build lockx;
    build spec_m64;
    logicalflags();
    spec_m64 =  spec_m64 ^ usimm8_64;
    resultflags( spec_m64);
    build unlock; 
}
@endif

:XOR^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x30; m8 & Reg8 ...                     
{
    build lockx;
    build m8;
    logicalflags();
    m8 =   m8 ^  Reg8;
    resultflags(  m8);
    build unlock; 
}

:XOR^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x31; m16 & Reg16 ...        
{
    build lockx;
    build m16;
    logicalflags();
    m16 =  m16 ^ Reg16;
    resultflags( m16);
    build unlock; 
}

:XOR^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x31; m32 & Reg32 ... 
{
    build lockx;
    build m32;
    logicalflags();
    m32 =  m32 ^ Reg32;
    resultflags( m32);
    build unlock; 
}

@ifdef IA64
:XOR^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x31; m64 & Reg64 ...        
{
    build lockx;
    build m64;
    logicalflags();
    m64 =  m64 ^ Reg64;
    resultflags( m64);
    build unlock; 
}
@endif

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/lzcnt.sinc`:

```sinc
macro lzcntflags(input, output) {
 ZF = (output == 0);
 CF = (input == 0);
 # OF, SF, PF, AF are undefined
}

####
#### LZCNT instructions
####


:LZCNT Reg16, rm16	is vexMode=0 & opsize=0 & $(PRE_66) & $(PRE_F3) & byte=0x0F; byte=0xBD; Reg16 ... & rm16 {

  Reg16 = lzcount(rm16);
  lzcntflags(rm16, Reg16);
}

:LZCNT Reg32, rm32	is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0F; byte=0xBD; Reg32 ... & check_Reg32_dest ... & rm32 {

  Reg32 = lzcount(rm32);
  lzcntflags(rm32, Reg32);
  build check_Reg32_dest;
}

@ifdef IA64
:LZCNT Reg64, rm64	is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(PRE_F3) & $(REX_W) & byte=0x0F; byte=0xBD; Reg64 ... & rm64 {

  Reg64 = lzcount(rm64);
  lzcntflags(rm64, Reg64);
}
@endif


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/macros.sinc`:

```sinc
macro conditionalAssign(dest, cond, trueVal, falseVal) {
    dest = zext(cond) * trueVal | zext(!cond) * falseVal;	
}

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/mpx.sinc`:

```sinc
define pcodeop br_exception;


# BNDMK needs the base address register only
#  - if no base register, needs 0

@ifdef IA64
bndmk_addr64: [Rmr64]							is mod=0 & Rmr64													{ export Rmr64; }
bndmk_addr64: [Rmr64 + simm8_64]				is mod=1 & Rmr64; simm8_64											{ export Rmr64; }
bndmk_addr64: [simm32_64 + Rmr64]				is mod=2 & Rmr64; simm32_64											{ export Rmr64; }
bndmk_addr64: [Rmr64]							is mod=1 & r_m!=4 & Rmr64; simm8=0									{ export Rmr64; }
bndmk_addr64: [Rmr64]							is mod=2 & r_m!=4 & Rmr64; simm32=0									{ export Rmr64; }
#invalid bndmk_addr64: [riprel]				  	is mod=0 & r_m=5; simm32 [ riprel=inst_next+simm32; ]				{ export *[const]:8 riprel; }
bndmk_addr64: [Base64 + Index64*ss]				is mod=0 & r_m=4; Index64 & Base64 & ss								{ export Base64; }
bndmk_addr64: [Base64]							is mod=0 & r_m=4; rexXprefix=0 & index64=4 & Base64					{ export Base64; }
bndmk_addr64: [simm32_64 + Index64*ss]			is mod=0 & r_m=4; Index64 & base64=5 & ss; simm32_64				{ tmp:8 = 0; export tmp; }
bndmk_addr64: [Index64*ss]						is mod=0 & r_m=4; Index64 & base64=5 & ss; imm32=0					{ tmp:8 = 0; export tmp; }
bndmk_addr64: [simm32_64]						is mod=0 & r_m=4; rexXprefix=0 & index64=4 & base64=5; simm32_64	{ tmp:8 = 0; export tmp; }
bndmk_addr64: [Base64 + Index64*ss + simm8_64]	is mod=1 & r_m=4; Index64 & Base64 & ss; simm8_64					{ export Base64; }
bndmk_addr64: [Base64 + Index64*ss]				is mod=1 & r_m=4; Index64 & Base64 & ss; simm8=0					{ export Base64; }
bndmk_addr64: [Base64 + simm8_64]				is mod=1 & r_m=4; rexXprefix=0 & index64=4 & Base64; simm8_64		{ export Base64; }
bndmk_addr64: [simm32_64 + Base64 + Index64*ss]	is mod=2 & r_m=4; Index64 & Base64 & ss; simm32_64					{ export Base64; }
bndmk_addr64: [simm32_64 + Base64]				is mod=2 & r_m=4; rexXprefix=0 & index64=4 & Base64; simm32_64		{ export Base64; }
bndmk_addr64: [Base64 + Index64*ss]				is mod=2 & r_m=4; Index64 & Base64 & ss; imm32=0					{ export Base64; }
bndmk_addr64: [Base64]							is mod=2 & r_m=4; rexXprefix=0 & index64=4 & Base64; imm32=0		{ export Base64; }
@endif

bndmk_addr32: [Rmr32]							is mod=0 & Rmr32								{ export Rmr32; }
bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
bndmk_addr32: [imm32]							is mod=0 & r_m=5; imm32							{ tmp:4 = 0; export tmp; }
bndmk_addr32: [Base + Index*ss]					is mod=0 & r_m=4; Index & Base & ss				{ export Base; }
bndmk_addr32: [Base]							is mod=0 & r_m=4; index=4 & Base				{ export Base; }
bndmk_addr32: [imm32 + Index*ss]				is mod=0 & r_m=4; Index & base=5 & ss; imm32	{ tmp:4 = 0; export tmp; }
bndmk_addr32: [imm32]							is mod=0 & r_m=4; index=4 & base=5; imm32		{ tmp:4 = 0; export tmp; }
bndmk_addr32: [Base + Index*ss + simm8_32]		is mod=1 & r_m=4; Index & Base & ss; simm8_32	{ export Base; }
bndmk_addr32: [Base + simm8_32]					is mod=1 & r_m=4; index=4 & Base; simm8_32		{ export Base; }
bndmk_addr32: [Base + Index*ss]					is mod=1 & r_m=4; Index & Base & ss; simm8=0	{ export Base; }
bndmk_addr32: [Base]							is mod=1 & r_m=4; index=4 & Base; simm8=0		{ export Base; }
bndmk_addr32: [imm32 + Base + Index*ss]			is mod=2 & r_m=4; Index & Base & ss; imm32		{ export Base; }
bndmk_addr32: [imm32 + Base]					is mod=2 & r_m=4; index=4 & Base; imm32			{ export Base; }
bndmk_addr32: [Base + Index*ss]					is mod=2 & r_m=4; Index & Base & ss; imm32=0	{ export Base; }
bndmk_addr32: [Base]							is mod=2 & r_m=4; index=4 & Base; imm32=0		{ export Base; }



@ifdef IA64

:BNDCL bnd1, Rmr64      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_lb & Rmr64 {
#   if (reg < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(Rmr64 < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCL bnd1, Mem      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_lb) ... & Mem {
#   if (LEA(mem) < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(Mem < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCU bnd1, Rmr64      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_ub & Rmr64 {
#   if (reg > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(Rmr64 > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCU bnd1, Mem      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(Mem > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCN bnd1, Rmr64      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd1_ub & Rmr64 {
#   if (reg > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(Rmr64 > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCN bnd1, Mem      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(Mem > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

#TODO: This probably cannot be fully modeled 
:BNDLDX bnd1, Mem      is $(LONGMODE_ON) & vexMode=0 & byte=0x0F; byte=0x1A; bnd1 ... & Mem {
#	BNDSTATUS = bndldx_status( Mem, BNDCFGS, BNDCFGU );
#	bnd1      = bndldx( Mem, BNDCFGS, BNDCFGU );
	
# core implementation
   bnd1 = *:16 Mem;
}

:BNDMK bnd1, Mem      is $(LONGMODE_ON) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & ( bndmk_addr64 & Mem ) {
#   BND.LB and BND.UB set from m64
	bnd1_lb = bndmk_addr64;
	bnd1_ub = Mem;
}

:BNDMOV bnd1, m128      is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; bnd1 ... & m128 {
	bnd1 = m128;
}

:BNDMOV bnd1, bnd2      is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd2 {
	bnd1 = bnd2;
}

:BNDMOV m128, bnd1      is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; bnd1 ... & m128 {
	m128 = bnd1;
}

:BNDMOV bnd2, bnd1      is $(LONGMODE_ON) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd2 {
	bnd2 = bnd1;
}

#TODO: This probably cannot be fully modeled 
:BNDSTX Mem, bnd1      is $(LONGMODE_ON) & vexMode=0 & byte=0x0F; byte=0x1B; bnd1 ... & Mem {
#	BNDSTATUS = bndstx_status( bnd1, BNDCFGS, BNDCFGU );
#	Mem       = bndstx( bnd1, BNDCFGS, BNDCFGU );

# core implementation
   *:16 Mem = bnd1;
}

@endif

:BNDCL bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_lb & Rmr32 {
#   if (reg < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCL bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_lb) ... & Mem {
#   if (LEA(mem) < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCU bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCU bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCN bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

:BNDCN bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}

#TODO: This probably cannot be fully modeled 
:BNDLDX bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndldx_status( Mem, BNDCFGS, BNDCFGU );
#	bnd1      = bndldx( Mem, BNDCFGS, BNDCFGU );
	
# core implementation
   tmp:8 = *:8 Mem;
   bnd1_lb = zext(tmp:4);
   tmp2:4 = tmp(4);
   bnd1_ub = zext(tmp2);
}

:BNDMK bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & ( bndmk_addr32 & Mem ) {
#   BND.LB and BND.UB set from m32
	bnd1_lb = zext(bndmk_addr32);
	bnd1_ub = zext(Mem);
}

:BNDMOV bnd1, m64      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	tmp:8 = m64;
	bnd1_lb = zext(tmp:4);
    tmp2:4 = tmp(4);
    bnd1_ub = zext(tmp2);
}

:BNDMOV bnd1, bnd2      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd2 {
	bnd1 = bnd2;
}

:BNDMOV m64, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	m64 = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}

:BNDMOV bnd2, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd2 {
	bnd2 = bnd1;
}

#TODO: This probably cannot be fully modeled 
:BNDSTX Mem, bnd1      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndstx_status( bnd1, BNDCFGS, BNDCFGU );
#	Mem       = bndstx( bnd1, BNDCFGS, BNDCFGU );

# core implementation
   *:8 Mem = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86RealV1.lang`:

```lang
<?xml version="1.0" encoding="UTF-8"?>
<language version="1" endian="little">
    <description>
        <id>x86:LE:16:Real Mode</id>
        <processor>x86</processor>
    </description>
    <compiler name="default" id="default"/>
    <spaces>
        <segmented_space name="ram" default="yes" />
        <space name="register" type="register" size="4" />
    </spaces>
    <registers>
        <context_register name="contextreg" offset="0x2000" bitsize="32">
            <field name="lockprefx" range="8,8" />
            <field name="repprefx" range="7,7" />
            <field name="repneprefx" range="6,6" />
            <field name="sstype" range="5,5" />
            <field name="segover" range="2,4" />
            <field name="opsize" range="1,1" />
            <field name="addrsize" range="0,0" />
        </context_register>
        <register name="EAX" offset="0x0" bitsize="32" />
        <register name="ECX" offset="0x4" bitsize="32" />
        <register name="EDX" offset="0x8" bitsize="32" />
        <register name="EBX" offset="0xc" bitsize="32" />
        <register name="ESP" offset="0x10" bitsize="32" />
        <register name="EBP" offset="0x14" bitsize="32" />
        <register name="ESI" offset="0x18" bitsize="32" />
        <register name="EDI" offset="0x1c" bitsize="32" />
        <register name="AX" offset="0x0" bitsize="16" />
        <register name="CX" offset="0x4" bitsize="16" />
        <register name="DX" offset="0x8" bitsize="16" />
        <register name="BX" offset="0xc" bitsize="16" />
        <register name="SP" offset="0x10" bitsize="16" />
        <register name="BP" offset="0x14" bitsize="16" />
        <register name="SI" offset="0x18" bitsize="16" />
        <register name="DI" offset="0x1c" bitsize="16" />
        <register name="AL" offset="0x0" bitsize="8" />
        <register name="AH" offset="0x1" bitsize="8" />
        <register name="CL" offset="0x4" bitsize="8" />
        <register name="CH" offset="0x5" bitsize="8" />
        <register name="DL" offset="0x8" bitsize="8" />
        <register name="DH" offset="0x9" bitsize="8" />
        <register name="BL" offset="0xc" bitsize="8" />
        <register name="BH" offset="0xd" bitsize="8" />
        <register name="ES" offset="0x100" bitsize="16" />
        <register name="CS" offset="0x102" bitsize="16" />
        <register name="SS" offset="0x104" bitsize="16" />
        <register name="DS" offset="0x106" bitsize="16" />
        <register name="FS" offset="0x108" bitsize="16" />
        <register name="GS" offset="0x10a" bitsize="16" />
        <register name="FS_OFFSET" offset="0x110" bitsize="32" />
        <register name="CF" offset="0x200" bitsize="8" />
        <register name="F1" offset="0x201" bitsize="8" />
        <register name="PF" offset="0x202" bitsize="8" />
        <register name="F3" offset="0x203" bitsize="8" />
        <register name="AF" offset="0x204" bitsize="8" />
        <register name="F5" offset="0x205" bitsize="8" />
        <register name="ZF" offset="0x206" bitsize="8" />
        <register name="SF" offset="0x207" bitsize="8" />
        <register name="TF" offset="0x208" bitsize="8" />
        <register name="IF" offset="0x209" bitsize="8" />
        <register name="DF" offset="0x20a" bitsize="8" />
        <register name="OF" offset="0x20b" bitsize="8" />
        <register name="IOPL" offset="0x20c" bitsize="8" />
        <register name="NT" offset="0x20d" bitsize="8" />
        <register name="F15" offset="0x20e" bitsize="8" />
        <register name="RF" offset="0x20f" bitsize="8" />
        <register name="VM" offset="0x210" bitsize="8" />
        <register name="AC" offset="0x211" bitsize="8" />
        <register name="VIF" offset="0x212" bitsize="8" />
        <register name="VIP" offset="0x213" bitsize="8" />
        <register name="ID" offset="0x214" bitsize="8" />
        <register name="eflags" offset="0x280" bitsize="32" />
        <register name="EIP" offset="0x284" bitsize="32" />
        <register name="flags" offset="0x280" bitsize="16" />
        <register name="IP" offset="0x284" bitsize="16" />
        <register name="DR0" offset="0x300" bitsize="32" />
        <register name="DR1" offset="0x304" bitsize="32" />
        <register name="DR2" offset="0x308" bitsize="32" />
        <register name="DR3" offset="0x30c" bitsize="32" />
        <register name="DR4" offset="0x310" bitsize="32" />
        <register name="DR5" offset="0x314" bitsize="32" />
        <register name="DR6" offset="0x318" bitsize="32" />
        <register name="DR7" offset="0x31c" bitsize="32" />
        <register name="CR0" offset="0x320" bitsize="32" />
        <register name="CR2" offset="0x328" bitsize="32" />
        <register name="CR3" offset="0x32c" bitsize="32" />
        <register name="CR4" offset="0x330" bitsize="32" />
        <register name="TR0" offset="0x400" bitsize="32" />
        <register name="TR1" offset="0x404" bitsize="32" />
        <register name="TR2" offset="0x408" bitsize="32" />
        <register name="TR3" offset="0x40c" bitsize="32" />
        <register name="TR4" offset="0x410" bitsize="32" />
        <register name="TR5" offset="0x414" bitsize="32" />
        <register name="TR6" offset="0x418" bitsize="32" />
        <register name="TR7" offset="0x41c" bitsize="32" />
        <register name="ST0" offset="0x1000" bitsize="80" />
        <register name="ST1" offset="0x100a" bitsize="80" />
        <register name="ST2" offset="0x1014" bitsize="80" />
        <register name="ST3" offset="0x101e" bitsize="80" />
        <register name="ST4" offset="0x1028" bitsize="80" />
        <register name="ST5" offset="0x1032" bitsize="80" />
        <register name="ST6" offset="0x103c" bitsize="80" />
        <register name="ST7" offset="0x1046" bitsize="80" />
        <register name="FPUControlWord" offset="0x1090" bitsize="16" />
        <register name="FPUStatusWord" offset="0x1092" bitsize="16" />
        <register name="FPUTagWord" offset="0x1094" bitsize="16" />
        <register name="FPUDataPointer" offset="0x1096" bitsize="16" />
        <register name="FPUInstructionPointer" offset="0x1098" bitsize="16" />
        <register name="FPULastInstructionOpcode" offset="0x109a" bitsize="16" />
        <register name="MM0" offset="0x1100" bitsize="64" />
        <register name="MM1" offset="0x1108" bitsize="64" />
        <register name="MM2" offset="0x1110" bitsize="64" />
        <register name="MM3" offset="0x1118" bitsize="64" />
        <register name="MM4" offset="0x1120" bitsize="64" />
        <register name="MM5" offset="0x1128" bitsize="64" />
        <register name="MM6" offset="0x1130" bitsize="64" />
        <register name="MM7" offset="0x1138" bitsize="64" />
        <register name="XMM0" offset="0x1200" bitsize="128" />
        <register name="XMM1" offset="0x1210" bitsize="128" />
        <register name="XMM2" offset="0x1220" bitsize="128" />
        <register name="XMM3" offset="0x1230" bitsize="128" />
        <register name="XMM4" offset="0x1240" bitsize="128" />
        <register name="XMM5" offset="0x1250" bitsize="128" />
        <register name="XMM6" offset="0x1260" bitsize="128" />
        <register name="XMM7" offset="0x1270" bitsize="128" />
        <register name="XMM8" offset="0x1280" bitsize="128" />
        <register name="XMM9" offset="0x1290" bitsize="128" />
        <register name="XMM10" offset="0x12a0" bitsize="128" />
        <register name="XMM11" offset="0x12b0" bitsize="128" />
        <register name="XMM12" offset="0x12c0" bitsize="128" />
        <register name="XMM13" offset="0x12d0" bitsize="128" />
        <register name="XMM14" offset="0x12e0" bitsize="128" />
        <register name="XMM15" offset="0x12f0" bitsize="128" />
        <register name="IDTR" offset="0x2200" bitsize="48" />
        <register name="IDTR_Limit" offset="0x2200" bitsize="16" />
        <register name="IDTR_Address" offset="0x2202" bitsize="32" />
        <register name="GDTR" offset="0x2210" bitsize="48" />
        <register name="GDTR_Limit" offset="0x2210" bitsize="16" />
        <register name="GDTR_Address" offset="0x2212" bitsize="32" />
        <register name="LDTR" offset="0x2220" bitsize="48" />
        <register name="LDTR_Limit" offset="0x2220" bitsize="16" />
        <register name="LDTR_Address" offset="0x2222" bitsize="32" />
        <register name="TR" offset="0x2230" bitsize="48" />
        <register name="TR_Limit" offset="0x2230" bitsize="16" />
        <register name="TR_Address" offset="0x2232" bitsize="32" />
    </registers>
</language>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86RealV1.trans`:

```trans
<?xml version="1.0" encoding="UTF-8"?>
<language_translation>
    <from_language version="1">x86:LE:16:Real Mode</from_language>
    <to_language version="2">x86:LE:16:Real Mode</to_language>
    <map_compiler_spec from="default" to="default" />
</language_translation>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86V1.lang`:

```lang
<?xml version="1.0" encoding="UTF-8"?>
<language version="1" endian="little">
    <description>
        <id>x86:LE:32:default</id>
        <processor>x86</processor>
    </description>
    <compiler name="Visual Studio" id="windows"/>
    <compiler name="gcc" id="gcc"/>
    <spaces>
        <space name="ram" type="ram" size="4" default="yes" />
        <space name="register" type="register" size="4" />
    </spaces>
    <registers>
        <context_register name="contextreg" offset="0x2000" bitsize="32">
            <field name="lockprefx" range="8,8" />
            <field name="repprefx" range="7,7" />
            <field name="repneprefx" range="6,6" />
            <field name="sstype" range="5,5" />
            <field name="segover" range="2,4" />
            <field name="opsize" range="1,1" />
            <field name="addrsize" range="0,0" />
        </context_register>
        <register name="EAX" offset="0x0" bitsize="32" />
        <register name="ECX" offset="0x4" bitsize="32" />
        <register name="EDX" offset="0x8" bitsize="32" />
        <register name="EBX" offset="0xc" bitsize="32" />
        <register name="ESP" offset="0x10" bitsize="32" />
        <register name="EBP" offset="0x14" bitsize="32" />
        <register name="ESI" offset="0x18" bitsize="32" />
        <register name="EDI" offset="0x1c" bitsize="32" />
        <register name="AX" offset="0x0" bitsize="16" />
        <register name="CX" offset="0x4" bitsize="16" />
        <register name="DX" offset="0x8" bitsize="16" />
        <register name="BX" offset="0xc" bitsize="16" />
        <register name="SP" offset="0x10" bitsize="16" />
        <register name="BP" offset="0x14" bitsize="16" />
        <register name="SI" offset="0x18" bitsize="16" />
        <register name="DI" offset="0x1c" bitsize="16" />
        <register name="AL" offset="0x0" bitsize="8" />
        <register name="AH" offset="0x1" bitsize="8" />
        <register name="CL" offset="0x4" bitsize="8" />
        <register name="CH" offset="0x5" bitsize="8" />
        <register name="DL" offset="0x8" bitsize="8" />
        <register name="DH" offset="0x9" bitsize="8" />
        <register name="BL" offset="0xc" bitsize="8" />
        <register name="BH" offset="0xd" bitsize="8" />
        <register name="ES" offset="0x100" bitsize="16" />
        <register name="CS" offset="0x102" bitsize="16" />
        <register name="SS" offset="0x104" bitsize="16" />
        <register name="DS" offset="0x106" bitsize="16" />
        <register name="FS" offset="0x108" bitsize="16" />
        <register name="GS" offset="0x10a" bitsize="16" />
        <register name="FS_OFFSET" offset="0x110" bitsize="32" />
        <register name="CF" offset="0x200" bitsize="8" />
        <register name="F1" offset="0x201" bitsize="8" />
        <register name="PF" offset="0x202" bitsize="8" />
        <register name="F3" offset="0x203" bitsize="8" />
        <register name="AF" offset="0x204" bitsize="8" />
        <register name="F5" offset="0x205" bitsize="8" />
        <register name="ZF" offset="0x206" bitsize="8" />
        <register name="SF" offset="0x207" bitsize="8" />
        <register name="TF" offset="0x208" bitsize="8" />
        <register name="IF" offset="0x209" bitsize="8" />
        <register name="DF" offset="0x20a" bitsize="8" />
        <register name="OF" offset="0x20b" bitsize="8" />
        <register name="IOPL" offset="0x20c" bitsize="8" />
        <register name="NT" offset="0x20d" bitsize="8" />
        <register name="F15" offset="0x20e" bitsize="8" />
        <register name="RF" offset="0x20f" bitsize="8" />
        <register name="VM" offset="0x210" bitsize="8" />
        <register name="AC" offset="0x211" bitsize="8" />
        <register name="VIF" offset="0x212" bitsize="8" />
        <register name="VIP" offset="0x213" bitsize="8" />
        <register name="ID" offset="0x214" bitsize="8" />
        <register name="eflags" offset="0x280" bitsize="32" />
        <register name="EIP" offset="0x284" bitsize="32" />
        <register name="flags" offset="0x280" bitsize="16" />
        <register name="IP" offset="0x284" bitsize="16" />
        <register name="DR0" offset="0x300" bitsize="32" />
        <register name="DR1" offset="0x304" bitsize="32" />
        <register name="DR2" offset="0x308" bitsize="32" />
        <register name="DR3" offset="0x30c" bitsize="32" />
        <register name="DR4" offset="0x310" bitsize="32" />
        <register name="DR5" offset="0x314" bitsize="32" />
        <register name="DR6" offset="0x318" bitsize="32" />
        <register name="DR7" offset="0x31c" bitsize="32" />
        <register name="CR0" offset="0x320" bitsize="32" />
        <register name="CR2" offset="0x328" bitsize="32" />
        <register name="CR3" offset="0x32c" bitsize="32" />
        <register name="CR4" offset="0x330" bitsize="32" />
        <register name="TR0" offset="0x400" bitsize="32" />
        <register name="TR1" offset="0x404" bitsize="32" />
        <register name="TR2" offset="0x408" bitsize="32" />
        <register name="TR3" offset="0x40c" bitsize="32" />
        <register name="TR4" offset="0x410" bitsize="32" />
        <register name="TR5" offset="0x414" bitsize="32" />
        <register name="TR6" offset="0x418" bitsize="32" />
        <register name="TR7" offset="0x41c" bitsize="32" />
        <register name="ST0" offset="0x1000" bitsize="80" />
        <register name="ST1" offset="0x100a" bitsize="80" />
        <register name="ST2" offset="0x1014" bitsize="80" />
        <register name="ST3" offset="0x101e" bitsize="80" />
        <register name="ST4" offset="0x1028" bitsize="80" />
        <register name="ST5" offset="0x1032" bitsize="80" />
        <register name="ST6" offset="0x103c" bitsize="80" />
        <register name="ST7" offset="0x1046" bitsize="80" />
        <register name="FPUControlWord" offset="0x1090" bitsize="16" />
        <register name="FPUStatusWord" offset="0x1092" bitsize="16" />
        <register name="FPUTagWord" offset="0x1094" bitsize="16" />
        <register name="FPUDataPointer" offset="0x1096" bitsize="16" />
        <register name="FPUInstructionPointer" offset="0x1098" bitsize="16" />
        <register name="FPULastInstructionOpcode" offset="0x109a" bitsize="16" />
        <register name="MM0" offset="0x1100" bitsize="64" />
        <register name="MM1" offset="0x1108" bitsize="64" />
        <register name="MM2" offset="0x1110" bitsize="64" />
        <register name="MM3" offset="0x1118" bitsize="64" />
        <register name="MM4" offset="0x1120" bitsize="64" />
        <register name="MM5" offset="0x1128" bitsize="64" />
        <register name="MM6" offset="0x1130" bitsize="64" />
        <register name="MM7" offset="0x1138" bitsize="64" />
        <register name="XMM0" offset="0x1200" bitsize="128" />
        <register name="XMM1" offset="0x1210" bitsize="128" />
        <register name="XMM2" offset="0x1220" bitsize="128" />
        <register name="XMM3" offset="0x1230" bitsize="128" />
        <register name="XMM4" offset="0x1240" bitsize="128" />
        <register name="XMM5" offset="0x1250" bitsize="128" />
        <register name="XMM6" offset="0x1260" bitsize="128" />
        <register name="XMM7" offset="0x1270" bitsize="128" />
        <register name="XMM8" offset="0x1280" bitsize="128" />
        <register name="XMM9" offset="0x1290" bitsize="128" />
        <register name="XMM10" offset="0x12a0" bitsize="128" />
        <register name="XMM11" offset="0x12b0" bitsize="128" />
        <register name="XMM12" offset="0x12c0" bitsize="128" />
        <register name="XMM13" offset="0x12d0" bitsize="128" />
        <register name="XMM14" offset="0x12e0" bitsize="128" />
        <register name="XMM15" offset="0x12f0" bitsize="128" />
        <register name="IDTR" offset="0x2200" bitsize="48" />
        <register name="IDTR_Limit" offset="0x2200" bitsize="16" />
        <register name="IDTR_Address" offset="0x2202" bitsize="32" />
        <register name="GDTR" offset="0x2210" bitsize="48" />
        <register name="GDTR_Limit" offset="0x2210" bitsize="16" />
        <register name="GDTR_Address" offset="0x2212" bitsize="32" />
        <register name="LDTR" offset="0x2220" bitsize="48" />
        <register name="LDTR_Limit" offset="0x2220" bitsize="16" />
        <register name="LDTR_Address" offset="0x2222" bitsize="32" />
        <register name="TR" offset="0x2230" bitsize="48" />
        <register name="TR_Limit" offset="0x2230" bitsize="16" />
        <register name="TR_Address" offset="0x2232" bitsize="32" />
    </registers>
</language>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86V1.trans`:

```trans
<?xml version="1.0" encoding="UTF-8"?>
<language_translation>
    <from_language version="1">x86:LE:32:default</from_language>
    <to_language version="2">x86:LE:32:default</to_language>
    <map_compiler_spec from="windows" to="windows" />
    <map_compiler_spec from="gcc" to="gcc" />
</language_translation>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86_64bit_v1.lang`:

```lang
<?xml version="1.0" encoding="UTF-8"?>
<language version="1" endian="little">
    <description>
        <id>x64:LE:64:default</id>
        <processor>x64</processor>
    </description>
    <compiler name="Visual Studio" id="windows"/>
    <compiler name="gcc" id="gcc"/>
    <spaces>
        <space name="ram" type="ram" size="8" default="yes" />
        <space name="register" type="register" size="4" />
    </spaces>
    <registers>
        <context_register name="contextreg" offset="0x2000" bitsize="32">
            <field name="rexprefix" range="15,15" />
            <field name="rexBprefix" range="14,14" />
            <field name="rexXprefix" range="13,13" />
            <field name="rexRprefix" range="12,12" />
            <field name="rexWprefix" range="11,11" />
            <field name="lockprefx" range="10,10" />
            <field name="repprefx" range="9,9" />
            <field name="repneprefx" range="8,8" />
            <field name="sstype" range="7,7" />
            <field name="segover" range="4,6" />
            <field name="opsize" range="2,3" />
            <field name="addrsize" range="0,1" />
            <field name="bit64" range="0,0" />
        </context_register>
        <register name="RAX" offset="0x0" bitsize="64" />
        <register name="RCX" offset="0x8" bitsize="64" />
        <register name="RDX" offset="0x10" bitsize="64" />
        <register name="RBX" offset="0x18" bitsize="64" />
        <register name="RSP" offset="0x20" bitsize="64" />
        <register name="RBP" offset="0x28" bitsize="64" />
        <register name="RSI" offset="0x30" bitsize="64" />
        <register name="RDI" offset="0x38" bitsize="64" />
        <register name="EAX" offset="0x0" bitsize="32" />
        <register name="ECX" offset="0x8" bitsize="32" />
        <register name="EDX" offset="0x10" bitsize="32" />
        <register name="EBX" offset="0x18" bitsize="32" />
        <register name="ESP" offset="0x20" bitsize="32" />
        <register name="EBP" offset="0x28" bitsize="32" />
        <register name="ESI" offset="0x30" bitsize="32" />
        <register name="EDI" offset="0x38" bitsize="32" />
        <register name="AX" offset="0x0" bitsize="16" />
        <register name="CX" offset="0x8" bitsize="16" />
        <register name="DX" offset="0x10" bitsize="16" />
        <register name="BX" offset="0x18" bitsize="16" />
        <register name="SP" offset="0x20" bitsize="16" />
        <register name="BP" offset="0x28" bitsize="16" />
        <register name="SI" offset="0x30" bitsize="16" />
        <register name="DI" offset="0x38" bitsize="16" />
        <register name="AL" offset="0x0" bitsize="8" />
        <register name="AH" offset="0x1" bitsize="8" />
        <register name="CL" offset="0x8" bitsize="8" />
        <register name="CH" offset="0x9" bitsize="8" />
        <register name="DL" offset="0x10" bitsize="8" />
        <register name="DH" offset="0x11" bitsize="8" />
        <register name="BL" offset="0x18" bitsize="8" />
        <register name="BH" offset="0x19" bitsize="8" />
        <register name="SPL" offset="0x20" bitsize="8" />
        <register name="BPL" offset="0x28" bitsize="8" />
        <register name="SIL" offset="0x30" bitsize="8" />
        <register name="DIL" offset="0x38" bitsize="8" />
        <register name="R8" offset="0x80" bitsize="64" />
        <register name="R9" offset="0x88" bitsize="64" />
        <register name="R10" offset="0x90" bitsize="64" />
        <register name="R11" offset="0x98" bitsize="64" />
        <register name="R12" offset="0xa0" bitsize="64" />
        <register name="R13" offset="0xa8" bitsize="64" />
        <register name="R14" offset="0xb0" bitsize="64" />
        <register name="R15" offset="0xb8" bitsize="64" />
        <register name="R8D" offset="0x80" bitsize="32" />
        <register name="R9D" offset="0x88" bitsize="32" />
        <register name="R10D" offset="0x90" bitsize="32" />
        <register name="R11D" offset="0x98" bitsize="32" />
        <register name="R12D" offset="0xa0" bitsize="32" />
        <register name="R13D" offset="0xa8" bitsize="32" />
        <register name="R14D" offset="0xb0" bitsize="32" />
        <register name="R15D" offset="0xb8" bitsize="32" />
        <register name="R8W" offset="0x80" bitsize="16" />
        <register name="R9W" offset="0x88" bitsize="16" />
        <register name="R10W" offset="0x90" bitsize="16" />
        <register name="R11W" offset="0x98" bitsize="16" />
        <register name="R12W" offset="0xa0" bitsize="16" />
        <register name="R13W" offset="0xa8" bitsize="16" />
        <register name="R14W" offset="0xb0" bitsize="16" />
        <register name="R15W" offset="0xb8" bitsize="16" />
        <register name="R8B" offset="0x80" bitsize="8" />
        <register name="R9B" offset="0x88" bitsize="8" />
        <register name="R10B" offset="0x90" bitsize="8" />
        <register name="R11B" offset="0x98" bitsize="8" />
        <register name="R12B" offset="0xa0" bitsize="8" />
        <register name="R13B" offset="0xa8" bitsize="8" />
        <register name="R14B" offset="0xb0" bitsize="8" />
        <register name="R15B" offset="0xb8" bitsize="8" />
        <register name="ES" offset="0x100" bitsize="16" />
        <register name="CS" offset="0x102" bitsize="16" />
        <register name="SS" offset="0x104" bitsize="16" />
        <register name="DS" offset="0x106" bitsize="16" />
        <register name="FS" offset="0x108" bitsize="16" />
        <register name="GS" offset="0x10a" bitsize="16" />
        <register name="FS_OFFSET" offset="0x110" bitsize="32" />
        <register name="CF" offset="0x200" bitsize="8" />
        <register name="F1" offset="0x201" bitsize="8" />
        <register name="PF" offset="0x202" bitsize="8" />
        <register name="F3" offset="0x203" bitsize="8" />
        <register name="AF" offset="0x204" bitsize="8" />
        <register name="F5" offset="0x205" bitsize="8" />
        <register name="ZF" offset="0x206" bitsize="8" />
        <register name="SF" offset="0x207" bitsize="8" />
        <register name="TF" offset="0x208" bitsize="8" />
        <register name="IF" offset="0x209" bitsize="8" />
        <register name="DF" offset="0x20a" bitsize="8" />
        <register name="OF" offset="0x20b" bitsize="8" />
        <register name="IOPL" offset="0x20c" bitsize="8" />
        <register name="NT" offset="0x20d" bitsize="8" />
        <register name="F15" offset="0x20e" bitsize="8" />
        <register name="RF" offset="0x20f" bitsize="8" />
        <register name="VM" offset="0x210" bitsize="8" />
        <register name="AC" offset="0x211" bitsize="8" />
        <register name="VIF" offset="0x212" bitsize="8" />
        <register name="VIP" offset="0x213" bitsize="8" />
        <register name="ID" offset="0x214" bitsize="8" />
        <register name="rflags" offset="0x280" bitsize="64" />
        <register name="RIP" offset="0x288" bitsize="64" />
        <register name="eflags" offset="0x280" bitsize="32" />
        <register name="EIP" offset="0x288" bitsize="32" />
        <register name="flags" offset="0x280" bitsize="16" />
        <register name="IP" offset="0x288" bitsize="16" />
        <register name="DR0" offset="0x300" bitsize="64" />
        <register name="DR1" offset="0x308" bitsize="64" />
        <register name="DR2" offset="0x310" bitsize="64" />
        <register name="DR3" offset="0x318" bitsize="64" />
        <register name="DR4" offset="0x320" bitsize="64" />
        <register name="DR5" offset="0x328" bitsize="64" />
        <register name="DR6" offset="0x330" bitsize="64" />
        <register name="DR7" offset="0x338" bitsize="64" />
        <register name="DR8" offset="0x340" bitsize="64" />
        <register name="DR9" offset="0x348" bitsize="64" />
        <register name="DR10" offset="0x350" bitsize="64" />
        <register name="DR11" offset="0x358" bitsize="64" />
        <register name="DR12" offset="0x360" bitsize="64" />
        <register name="DR13" offset="0x368" bitsize="64" />
        <register name="DR14" offset="0x370" bitsize="64" />
        <register name="DR15" offset="0x378" bitsize="64" />
        <register name="CR0" offset="0x380" bitsize="64" />
        <register name="CR1" offset="0x388" bitsize="64" />
        <register name="CR2" offset="0x390" bitsize="64" />
        <register name="CR3" offset="0x398" bitsize="64" />
        <register name="CR4" offset="0x3a0" bitsize="64" />
        <register name="CR5" offset="0x3a8" bitsize="64" />
        <register name="CR6" offset="0x3b0" bitsize="64" />
        <register name="CR7" offset="0x3b8" bitsize="64" />
        <register name="CR8" offset="0x3c0" bitsize="64" />
        <register name="CR9" offset="0x3c8" bitsize="64" />
        <register name="CR10" offset="0x3d0" bitsize="64" />
        <register name="CR11" offset="0x3d8" bitsize="64" />
        <register name="CR12" offset="0x3e0" bitsize="64" />
        <register name="CR13" offset="0x3e8" bitsize="64" />
        <register name="CR14" offset="0x3f0" bitsize="64" />
        <register name="CR15" offset="0x3f8" bitsize="64" />
        <register name="ST0" offset="0x1000" bitsize="80" />
        <register name="ST1" offset="0x100a" bitsize="80" />
        <register name="ST2" offset="0x1014" bitsize="80" />
        <register name="ST3" offset="0x101e" bitsize="80" />
        <register name="ST4" offset="0x1028" bitsize="80" />
        <register name="ST5" offset="0x1032" bitsize="80" />
        <register name="ST6" offset="0x103c" bitsize="80" />
        <register name="ST7" offset="0x1046" bitsize="80" />
        <register name="C0" offset="0x1080" bitsize="8" />
        <register name="C1" offset="0x1081" bitsize="8" />
        <register name="C2" offset="0x1082" bitsize="8" />
        <register name="C3" offset="0x1083" bitsize="8" />
        <register name="FPUControlWord" offset="0x1090" bitsize="16" />
        <register name="FPUStatusWord" offset="0x1092" bitsize="16" />
        <register name="FPUTagWord" offset="0x1094" bitsize="16" />
        <register name="FPUDataPointer" offset="0x1096" bitsize="16" />
        <register name="FPUInstructionPointer" offset="0x1098" bitsize="16" />
        <register name="FPULastInstructionOpcode" offset="0x109a" bitsize="16" />
        <register name="MM0" offset="0x1100" bitsize="64" />
        <register name="MM1" offset="0x1108" bitsize="64" />
        <register name="MM2" offset="0x1110" bitsize="64" />
        <register name="MM3" offset="0x1118" bitsize="64" />
        <register name="MM4" offset="0x1120" bitsize="64" />
        <register name="MM5" offset="0x1128" bitsize="64" />
        <register name="MM6" offset="0x1130" bitsize="64" />
        <register name="MM7" offset="0x1138" bitsize="64" />
        <register name="XMM0" offset="0x1200" bitsize="128" />
        <register name="XMM1" offset="0x1210" bitsize="128" />
        <register name="XMM2" offset="0x1220" bitsize="128" />
        <register name="XMM3" offset="0x1230" bitsize="128" />
        <register name="XMM4" offset="0x1240" bitsize="128" />
        <register name="XMM5" offset="0x1250" bitsize="128" />
        <register name="XMM6" offset="0x1260" bitsize="128" />
        <register name="XMM7" offset="0x1270" bitsize="128" />
        <register name="XMM8" offset="0x1280" bitsize="128" />
        <register name="XMM9" offset="0x1290" bitsize="128" />
        <register name="XMM10" offset="0x12a0" bitsize="128" />
        <register name="XMM11" offset="0x12b0" bitsize="128" />
        <register name="XMM12" offset="0x12c0" bitsize="128" />
        <register name="XMM13" offset="0x12d0" bitsize="128" />
        <register name="XMM14" offset="0x12e0" bitsize="128" />
        <register name="XMM15" offset="0x12f0" bitsize="128" />
        <register name="IDTR_Limit" offset="0x2200" bitsize="32" />
        <register name="IDTR" offset="0x2200" bitsize="96" />
        <register name="IDTR_Address" offset="0x2204" bitsize="64" />
        <register name="GDTR_Limit" offset="0x2220" bitsize="32" />
        <register name="GDTR" offset="0x2220" bitsize="96" />
        <register name="GDTR_Address" offset="0x2224" bitsize="64" />
        <register name="LDTR_Limit" offset="0x2240" bitsize="32" />
        <register name="LDTR" offset="0x2240" bitsize="112" />
        <register name="LDTR_Address" offset="0x2244" bitsize="64" />
        <register name="LDTR_Attributes" offset="0x2248" bitsize="16" />
        <register name="TR_Limit" offset="0x2260" bitsize="32" />
        <register name="TR" offset="0x2260" bitsize="112" />
        <register name="TR_Address" offset="0x2264" bitsize="64" />
        <register name="TR_Attributes" offset="0x2268" bitsize="16" />
    </registers>
</language>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86_64bit_v1.trans`:

```trans
<?xml version="1.0" encoding="UTF-8"?>
<language_translation>
    <from_language version="1">x64:LE:64:default</from_language>
    <to_language version="2">x86:LE:64:default</to_language>
    <map_compiler_spec from="windows" to="windows" />
    <map_compiler_spec from="gcc" to="gcc" />
</language_translation>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86smmV1.lang`:

```lang
<?xml version="1.0" encoding="UTF-8"?>
<language version="1" endian="little">
    <description>
        <id>x86:LE:32:System Management Mode</id>
        <processor>x86</processor>
    </description>
    <compiler name="default" id="default"/>
    <spaces>
        <space name="ram" type="ram" size="4" default="yes" />
        <space name="register" type="register" size="4" />
    </spaces>
    <registers>
        <context_register name="contextreg" offset="0x2000" bitsize="32">
            <field name="lockprefx" range="8,8" />
            <field name="repprefx" range="7,7" />
            <field name="repneprefx" range="6,6" />
            <field name="sstype" range="5,5" />
            <field name="segover" range="2,4" />
            <field name="opsize" range="1,1" />
            <field name="addrsize" range="0,0" />
        </context_register>
        <register name="EAX" offset="0x0" bitsize="32" />
        <register name="ECX" offset="0x4" bitsize="32" />
        <register name="EDX" offset="0x8" bitsize="32" />
        <register name="EBX" offset="0xc" bitsize="32" />
        <register name="ESP" offset="0x10" bitsize="32" />
        <register name="EBP" offset="0x14" bitsize="32" />
        <register name="ESI" offset="0x18" bitsize="32" />
        <register name="EDI" offset="0x1c" bitsize="32" />
        <register name="AX" offset="0x0" bitsize="16" />
        <register name="CX" offset="0x4" bitsize="16" />
        <register name="DX" offset="0x8" bitsize="16" />
        <register name="BX" offset="0xc" bitsize="16" />
        <register name="SP" offset="0x10" bitsize="16" />
        <register name="BP" offset="0x14" bitsize="16" />
        <register name="SI" offset="0x18" bitsize="16" />
        <register name="DI" offset="0x1c" bitsize="16" />
        <register name="AL" offset="0x0" bitsize="8" />
        <register name="AH" offset="0x1" bitsize="8" />
        <register name="CL" offset="0x4" bitsize="8" />
        <register name="CH" offset="0x5" bitsize="8" />
        <register name="DL" offset="0x8" bitsize="8" />
        <register name="DH" offset="0x9" bitsize="8" />
        <register name="BL" offset="0xc" bitsize="8" />
        <register name="BH" offset="0xd" bitsize="8" />
        <register name="ES" offset="0x100" bitsize="16" />
        <register name="CS" offset="0x102" bitsize="16" />
        <register name="SS" offset="0x104" bitsize="16" />
        <register name="DS" offset="0x106" bitsize="16" />
        <register name="FS" offset="0x108" bitsize="16" />
        <register name="GS" offset="0x10a" bitsize="16" />
        <register name="FS_OFFSET" offset="0x110" bitsize="32" />
        <register name="CF" offset="0x200" bitsize="8" />
        <register name="F1" offset="0x201" bitsize="8" />
        <register name="PF" offset="0x202" bitsize="8" />
        <register name="F3" offset="0x203" bitsize="8" />
        <register name="AF" offset="0x204" bitsize="8" />
        <register name="F5" offset="0x205" bitsize="8" />
        <register name="ZF" offset="0x206" bitsize="8" />
        <register name="SF" offset="0x207" bitsize="8" />
        <register name="TF" offset="0x208" bitsize="8" />
        <register name="IF" offset="0x209" bitsize="8" />
        <register name="DF" offset="0x20a" bitsize="8" />
        <register name="OF" offset="0x20b" bitsize="8" />
        <register name="IOPL" offset="0x20c" bitsize="8" />
        <register name="NT" offset="0x20d" bitsize="8" />
        <register name="F15" offset="0x20e" bitsize="8" />
        <register name="RF" offset="0x20f" bitsize="8" />
        <register name="VM" offset="0x210" bitsize="8" />
        <register name="AC" offset="0x211" bitsize="8" />
        <register name="VIF" offset="0x212" bitsize="8" />
        <register name="VIP" offset="0x213" bitsize="8" />
        <register name="ID" offset="0x214" bitsize="8" />
        <register name="eflags" offset="0x280" bitsize="32" />
        <register name="EIP" offset="0x284" bitsize="32" />
        <register name="flags" offset="0x280" bitsize="16" />
        <register name="IP" offset="0x284" bitsize="16" />
        <register name="DR0" offset="0x300" bitsize="32" />
        <register name="DR1" offset="0x304" bitsize="32" />
        <register name="DR2" offset="0x308" bitsize="32" />
        <register name="DR3" offset="0x30c" bitsize="32" />
        <register name="DR4" offset="0x310" bitsize="32" />
        <register name="DR5" offset="0x314" bitsize="32" />
        <register name="DR6" offset="0x318" bitsize="32" />
        <register name="DR7" offset="0x31c" bitsize="32" />
        <register name="CR0" offset="0x320" bitsize="32" />
        <register name="CR2" offset="0x328" bitsize="32" />
        <register name="CR3" offset="0x32c" bitsize="32" />
        <register name="CR4" offset="0x330" bitsize="32" />
        <register name="TR0" offset="0x400" bitsize="32" />
        <register name="TR1" offset="0x404" bitsize="32" />
        <register name="TR2" offset="0x408" bitsize="32" />
        <register name="TR3" offset="0x40c" bitsize="32" />
        <register name="TR4" offset="0x410" bitsize="32" />
        <register name="TR5" offset="0x414" bitsize="32" />
        <register name="TR6" offset="0x418" bitsize="32" />
        <register name="TR7" offset="0x41c" bitsize="32" />
        <register name="ST0" offset="0x1000" bitsize="80" />
        <register name="ST1" offset="0x100a" bitsize="80" />
        <register name="ST2" offset="0x1014" bitsize="80" />
        <register name="ST3" offset="0x101e" bitsize="80" />
        <register name="ST4" offset="0x1028" bitsize="80" />
        <register name="ST5" offset="0x1032" bitsize="80" />
        <register name="ST6" offset="0x103c" bitsize="80" />
        <register name="ST7" offset="0x1046" bitsize="80" />
        <register name="FPUControlWord" offset="0x1090" bitsize="16" />
        <register name="FPUStatusWord" offset="0x1092" bitsize="16" />
        <register name="FPUTagWord" offset="0x1094" bitsize="16" />
        <register name="FPUDataPointer" offset="0x1096" bitsize="16" />
        <register name="FPUInstructionPointer" offset="0x1098" bitsize="16" />
        <register name="FPULastInstructionOpcode" offset="0x109a" bitsize="16" />
        <register name="MM0" offset="0x1100" bitsize="64" />
        <register name="MM1" offset="0x1108" bitsize="64" />
        <register name="MM2" offset="0x1110" bitsize="64" />
        <register name="MM3" offset="0x1118" bitsize="64" />
        <register name="MM4" offset="0x1120" bitsize="64" />
        <register name="MM5" offset="0x1128" bitsize="64" />
        <register name="MM6" offset="0x1130" bitsize="64" />
        <register name="MM7" offset="0x1138" bitsize="64" />
        <register name="XMM0" offset="0x1200" bitsize="128" />
        <register name="XMM1" offset="0x1210" bitsize="128" />
        <register name="XMM2" offset="0x1220" bitsize="128" />
        <register name="XMM3" offset="0x1230" bitsize="128" />
        <register name="XMM4" offset="0x1240" bitsize="128" />
        <register name="XMM5" offset="0x1250" bitsize="128" />
        <register name="XMM6" offset="0x1260" bitsize="128" />
        <register name="XMM7" offset="0x1270" bitsize="128" />
        <register name="XMM8" offset="0x1280" bitsize="128" />
        <register name="XMM9" offset="0x1290" bitsize="128" />
        <register name="XMM10" offset="0x12a0" bitsize="128" />
        <register name="XMM11" offset="0x12b0" bitsize="128" />
        <register name="XMM12" offset="0x12c0" bitsize="128" />
        <register name="XMM13" offset="0x12d0" bitsize="128" />
        <register name="XMM14" offset="0x12e0" bitsize="128" />
        <register name="XMM15" offset="0x12f0" bitsize="128" />
        <register name="IDTR" offset="0x2200" bitsize="48" />
        <register name="IDTR_Limit" offset="0x2200" bitsize="16" />
        <register name="IDTR_Address" offset="0x2202" bitsize="32" />
        <register name="GDTR" offset="0x2210" bitsize="48" />
        <register name="GDTR_Limit" offset="0x2210" bitsize="16" />
        <register name="GDTR_Address" offset="0x2212" bitsize="32" />
        <register name="LDTR" offset="0x2220" bitsize="48" />
        <register name="LDTR_Limit" offset="0x2220" bitsize="16" />
        <register name="LDTR_Address" offset="0x2222" bitsize="32" />
        <register name="TR" offset="0x2230" bitsize="48" />
        <register name="TR_Limit" offset="0x2230" bitsize="16" />
        <register name="TR_Address" offset="0x2232" bitsize="32" />
    </registers>
</language>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/old/x86smmV1.trans`:

```trans
<?xml version="1.0" encoding="UTF-8"?>
<language_translation>
    <from_language version="1">x86:LE:32:System Management Mode</from_language>
    <to_language version="2">x86:LE:32:System Management Mode</to_language>
    <map_compiler_spec from="default" to="default" />
</language_translation>


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/pclmulqdq.sinc`:

```sinc
# Due to limitations on variable length matching that preclude opcode matching afterwards, all memory addressing forms of PCLMULQDQ are decoded to PCLMULQDQ, not the macro names.
# Display is non-standard, but semantics, and de-compilation should be correct.

macro pclmul(src1, src2, dest) {
    local i:4 = 0:4;
    local temp:16 = 0;

    <start>
    if (i > 63:4) goto <end>;
        if ((src1 & (1 << i)) == 0) goto <skip>;   
            temp = temp ^ (src2 << i);
    <skip>
        i = i+1;
        goto <start>;
    <end>
    dest = temp;
}

:PCLMULLQLQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x00
{
    local src1:16 = zext(XmmReg1[0,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
}

:PCLMULHQLQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x01
{
    local src1:16 = zext(XmmReg1[64,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
}

:PCLMULLQHQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x10
{
    local src1:16 = zext(XmmReg1[0,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
}

:PCLMULHQHQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x11
{
    local src1:16 = zext(XmmReg1[64,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
}

:PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}

:PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}

:VPCLMULLQLQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x00
{
    local src1:16 = zext(vexVVVV_XmmReg[0,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}

:VPCLMULHQLQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x01
{
    local src1:16 = zext(vexVVVV_XmmReg[64,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}

:VPCLMULLQHQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x10
{
    local src1:16 = zext(vexVVVV_XmmReg[0,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}

:VPCLMULHQHQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x11
{
    local src1:16 = zext(vexVVVV_XmmReg[64,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}

:VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}

:VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/rdrand.sinc`:

```sinc
define pcodeop rdrand;
define pcodeop rdrandIsValid;

macro rdflags(){
	OF = 0; SF = 0; ZF = 0; AF = 0; PF = 0;
}

:RDRAND Rmr16     is vexMode=0 & opsize=0 & byte=0x0f; byte=0xC7; mod=3 & Rmr16 & reg_opcode=6 
{ 
	Rmr16 = rdrand(); 
	CF=rdrandIsValid();
	rdflags();
	
}
:RDRAND Rmr32     is vexMode=0 & opsize=1 & byte=0x0f; byte=0xC7; mod=3 & Rmr32 & reg_opcode=6 
{ 
	Rmr32 = rdrand(); 
	CF=rdrandIsValid();
	rdflags();
}
@ifdef IA64
:RDRAND Rmr64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(REX_W) & byte=0x0f; byte=0xC7; mod=3 & Rmr64 & reg_opcode=6 
{ 
	Rmr64 = rdrand(); 
	CF=rdrandIsValid();
	rdflags();
}
@endif

define pcodeop rdseed;
define pcodeop rdseedIsValid;
:RDSEED Rmr16     is vexMode=0 & opsize=0 & byte=0x0f; byte=0xC7; mod=3 & Rmr16 & reg_opcode=7 
{ 
	Rmr16 = rdseed(); 
	CF=rdseedIsValid();
	rdflags();
}
:RDSEED Rmr32     is vexMode=0 & opsize=1 & byte=0x0f; byte=0xC7; mod=3 & Rmr32 & reg_opcode=7 
{ 
	Rmr32 = rdseed(); 
	CF=rdseedIsValid();
	rdflags();
}
@ifdef IA64
:RDSEED Rmr64     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & $(REX_W) & byte=0x0f; byte=0xC7; mod=3 & Rmr64 & reg_opcode=7 
{ 
	Rmr64 = rdseed(); 
	CF=rdseedIsValid();
	rdflags();
}
@endif

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/sgx.sinc`:

```sinc
define pcodeop encls_ecreate;
define pcodeop encls_eadd;
define pcodeop encls_einit;
define pcodeop encls_einit_ZF;
define pcodeop encls_eremove;
define pcodeop encls_eremove_ZF;
define pcodeop encls_edbgrd;
define pcodeop encls_edbgrd_RBX;
define pcodeop encls_edbgwr;
define pcodeop encls_eextend;
define pcodeop encls_eldb;
define pcodeop encls_eldb_ZF;
define pcodeop encls_eldu;
define pcodeop encls_eldu_ZF;
define pcodeop encls_eblock;
define pcodeop encls_eblock_ZF;
define pcodeop encls_epa;
define pcodeop encls_ewb;
define pcodeop encls_ewb_ZF;
define pcodeop encls_ewb_CF;
define pcodeop encls_etrack;
define pcodeop encls_etrack_ZF;
define pcodeop encls_eaug;
define pcodeop encls_emodpr;
define pcodeop encls_emodpr_ZF;
define pcodeop encls_emodt;
define pcodeop encls_emodt_ZF;
define pcodeop encls_unknown;

:ENCLS          is vexMode=0 & byte=0x0f; byte=0x01; byte=0xcf {

	if ( EAX != 0x0 ) goto <leaf_1>;
		encls_ecreate( RBX, RCX );
		goto <done>;
		
	<leaf_1>
	if ( EAX != 0x1 ) goto <leaf_2>;
		encls_eadd( RBX, RCX );
		goto <done>;

	<leaf_2>
	if ( EAX != 0x2 ) goto <leaf_3>;
		RAX = encls_einit( RBX, RCX, RDX );
		ZF = encls_einit_ZF( RBX, RCX, RDX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_3>
	if ( EAX != 0x3 ) goto <leaf_4>;
		RAX = encls_eremove( RCX );
		ZF = encls_eremove_ZF( RBX, RCX, RDX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_4>
	if ( EAX != 0x4 ) goto <leaf_5>;
		RAX = encls_edbgrd( RCX );
		RBX = encls_edbgrd_RBX( RCX );
		goto <done>;

	<leaf_5>
	if ( EAX != 0x5 ) goto <leaf_6>;
		RAX = encls_edbgwr( RBX, RCX );
		goto <done>;

	<leaf_6>
	if ( EAX != 0x6 ) goto <leaf_7>;
		encls_eextend( RBX, RCX );
		goto <done>;

	<leaf_7>
	if ( EAX != 0x7 ) goto <leaf_8>;
		RAX = encls_eldb( RBX, RCX, RDX );
		ZF = encls_eldb_ZF( RBX, RCX, RDX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_8>
	if ( EAX != 0x8 ) goto <leaf_9>;
		RAX = encls_eldu( RBX, RCX, RDX );
		ZF = encls_eldu_ZF( RBX, RCX, RDX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_9>
	if ( EAX != 0x9 ) goto <leaf_A>;
		RAX = encls_eblock( RCX );
		ZF = encls_eblock_ZF( RCX );
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_A>
	if ( EAX != 0xA ) goto <leaf_B>;
		encls_epa( RBX, RCX );
		goto <done>;

	<leaf_B>
	if ( EAX != 0xB ) goto <leaf_C>;
		RAX = encls_ewb( RBX, RCX, RDX );
		ZF = encls_ewb_ZF( RBX, RCX, RDX );
		CF = encls_ewb_CF( RBX, RCX, RDX );
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_C>
	if ( EAX != 0xC ) goto <leaf_D>;
		RAX = encls_etrack( RCX );
		ZF = encls_etrack_ZF( RBX, RCX, RDX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_D>
	if ( EAX != 0xD ) goto <leaf_E>;
		encls_eaug( RBX, RCX, RDX );
		goto <done>;

	<leaf_E>
	if ( EAX != 0xE ) goto <leaf_F>;
		RAX = encls_emodpr( RBX, RCX );
		ZF = encls_emodpr_ZF( RCX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_F>
	if ( EAX != 0xF ) goto <unknown>;
		RAX = encls_emodt( RBX, RCX );
		ZF = encls_emodt_ZF( RCX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<unknown>
		encls_unknown();

	<done>		
}


define pcodeop enclu_ereport;
define pcodeop enclu_egetkey;
define pcodeop enclu_egetkey_ZF;
define pcodeop enclu_eenter_EAX;
define pcodeop enclu_eenter_RCX;
define pcodeop enclu_eenter_TF;
define pcodeop enclu_eresume;
define pcodeop enclu_eexit;
define pcodeop enclu_eexit_TF;
define pcodeop enclu_eaccept;
define pcodeop enclu_eaccept_ZF;
define pcodeop enclu_emodpe;
define pcodeop enclu_eacceptcopy;
define pcodeop enclu_eacceptcopy_ZF;
define pcodeop enclu_unknown;

:ENCLU          is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd7 {

	if ( EAX != 0x0 ) goto <leaf_1>;
		enclu_ereport( RBX, RCX, RDX );
		goto <done>;
		
	<leaf_1>
	if ( EAX != 0x1 ) goto <leaf_2>;
		RAX = enclu_egetkey( RBX, RCX );
		ZF = enclu_egetkey_ZF( RBX, RCX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_2>
	if ( EAX != 0x2 ) goto <leaf_3>;
		tempBX:8 = RBX;
		tempCX:8 = RCX;
		
		EAX = enclu_eenter_EAX( tempBX, tempCX );
		RCX = enclu_eenter_RCX( tempBX, tempCX );
		TF = enclu_eenter_TF( tempBX, tempCX );
		goto <done>;

	<leaf_3>
	if ( EAX != 0x3 ) goto <leaf_4>;
		TF = enclu_eresume( RBX, RCX );
		goto <done>;

	<leaf_4>
	if ( EAX != 0x4 ) goto <leaf_5>;
		RCX = enclu_eexit( RBX );
		TF = enclu_eexit_TF( RBX );
		goto <done>;

	<leaf_5>
	if ( EAX != 0x5 ) goto <leaf_6>;
		RAX = enclu_eaccept( RBX, RCX );
		ZF = enclu_eaccept_ZF( RBX, RCX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<leaf_6>
	if ( EAX != 0x6 ) goto <leaf_7>;
		enclu_emodpe( RBX, RCX );
		goto <done>;

	<leaf_7>
	if ( EAX != 0x7 ) goto <unknown>;
		RAX = enclu_eacceptcopy( RBX, RCX, RDX );
		ZF = enclu_eacceptcopy_ZF( RBX, RCX, RDX );
		CF = 0;
		PF = 0;
		AF = 0;
		OF = 0;
		SF = 0;
		goto <done>;

	<unknown>
		enclu_unknown();

	<done>		
}

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/sha.sinc`:

```sinc
# INFO This file automatically generated by andre on Fri Mar 16 15:13:25 2018
# INFO Direct edits to this file may be lost in future updates
# INFO Command line arguments: ['--sinc', '--cpuid-match', 'SHA']

# SHA1RNDS4 4-602 PAGE 1722 LINE 89511
define pcodeop sha1rnds4_sha ;
:SHA1RNDS4 XmmReg1, XmmReg2_m128, imm8 is vexMode=0 & byte=0x0F; byte=0x3A; byte=0xCC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	XmmReg1 = sha1rnds4_sha( XmmReg1, XmmReg2_m128, imm8:1 );
}

# SHA1NEXTE 4-604 PAGE 1724 LINE 89602
define pcodeop sha1nexte_sha ;
:SHA1NEXTE XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xC8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha1nexte_sha( XmmReg1, XmmReg2_m128 );
}

# SHA1MSG1 4-605 PAGE 1725 LINE 89654
define pcodeop sha1msg1_sha ;
:SHA1MSG1 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xC9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha1msg1_sha( XmmReg1, XmmReg2_m128 );
}

# SHA1MSG2 4-606 PAGE 1726 LINE 89708
define pcodeop sha1msg2_sha ;
:SHA1MSG2 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha1msg2_sha( XmmReg1, XmmReg2_m128 );
}

# SHA256RNDS2 4-607 PAGE 1727 LINE 89765
define pcodeop sha256rnds2_sha ;
:SHA256RNDS2 XmmReg1, XmmReg2_m128, XMM0 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 & XMM0
{
	XmmReg1 = sha256rnds2_sha( XmmReg1, XmmReg2_m128, XMM0 );
}

# SHA256MSG1 4-609 PAGE 1729 LINE 89847
define pcodeop sha256msg1_sha ;
:SHA256MSG1 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha256msg1_sha( XmmReg1, XmmReg2_m128 );
}

# SHA256MSG2 4-610 PAGE 1730 LINE 89900
define pcodeop sha256msg2_sha ;
:SHA256MSG2 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCD; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha256msg2_sha( XmmReg1, XmmReg2_m128 );
}


```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/smx.sinc`:

```sinc
define pcodeop getsec_capabilities;
define pcodeop getsec_enteraccs;
define pcodeop getsec_exitac;
define pcodeop getsec_senter;
define pcodeop getsec_sexit;
define pcodeop getsec_parameters_EAX;
define pcodeop getsec_parameters_EBX;
define pcodeop getsec_parameters_ECX;
define pcodeop getsec_smctrl;
define pcodeop getsec_wakeup;
define pcodeop getsec_unknown;


:GETSEC          is vexMode=0 & byte=0x0f; byte=0x37  {

	if ( EAX != 0x0 ) goto <leaf_1>;
	    EAX = 0;
	    if ( EBX != 0x0 ) goto <done>;
		EAX = getsec_capabilities( EBX );
		goto <done>;
		
	<leaf_1>
	if ( EAX != 0x2 ) goto <leaf_2>;
		getsec_enteraccs( EBX, ECX );
		goto <done>;

	<leaf_2>
	if ( EAX != 0x3 ) goto <leaf_3>;
@ifdef IA64
	    getsec_exitac( RBX, EDX );
@else
	    getsec_exitac( EBX, EDX );
@endif
		goto <done>;

	<leaf_3>
	if ( EAX != 0x4 ) goto <leaf_4>;
	    getsec_senter( EBX, ECX, EDX);
		goto <done>;

	<leaf_4>
	if ( EAX != 0x5 ) goto <leaf_5>;
	    getsec_sexit();
		goto <done>;

	<leaf_5>
	if ( EAX != 0x6 ) goto <leaf_6>;
	    EAX = getsec_parameters_EAX( EBX );
	    ECX = getsec_parameters_ECX( EBX );
	    EBX = getsec_parameters_EBX( EBX );
		goto <done>;

	<leaf_6>
	if ( EAX != 0x7 ) goto <leaf_7>;
	    getsec_smctrl(EBX);
		goto <done>;

	<leaf_7>
	if ( EAX != 0x8 ) goto <unknown>;
	    getsec_wakeup();
		goto <done>;

	<unknown>
		getsec_unknown();

	<done>		
}

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-16-real.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>

<!-- Set up x86 16-bit in real mode -->
<processor_spec>
  <properties>
    <property key="useOperandReferenceAnalyzerSwitchTables" value="true"/>
  </properties>
  <programcounter register="EIP"/>
  <segmented_address space="ram" type="real" />
  <segmentop space="ram" userop="segment" farpointer="yes">
    <pcode>
      <input name="base" size="2"/>
      <input name="inner" size="2"/>
      <output name="res" size="4"/>
      <body><![CDATA[
        res = (zext(base) << 4) + zext(inner);
      ]]></body>
    </pcode>
    <constresolve>
      <register name="DS"/>
    </constresolve>
  </segmentop>
  <context_data>
    <context_set space="ram">
      <set name="addrsize" val="0"/>
      <set name="opsize" val="0"/>
      <set name="protectedMode" val="0"/>
    </context_set>
    <tracked_set space="ram">
      <set name="DF" val="0"/>
    </tracked_set>
  </context_data>
</processor_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-16.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>

  <data_organization>
	<absolute_max_alignment value="0" /> <!-- no maximum alignment -->
	<machine_alignment value="2" />
	<default_alignment value="1" />
	<default_pointer_alignment value="2" />
	<pointer_size value="2" /> <!-- near pointer, TODO: how do we define far 4-byte pointer? -->
	<wchar_size value="2" />
	<short_size value="2" />
	<integer_size value="2" />
	<long_size value="4" />
	<long_long_size value="4" />
	<float_size value="4" />
	<double_size value="8" />
	<long_double_size value="10" />
	<!-- alignment varies between MIcrosoft and Borland -->
	<!--
	<size_alignment_map>
		<entry size="1" alignment="1" />
		<entry size="2" alignment="2" />
		<entry size="4" alignment="2" />
		<entry size="8" alignment="2" />
	</size_alignment_map>
	-->
  </data_organization>
  
  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="SP" space="ram"/>
  <default_proto>
    <prototype name="__stdcall16near" extrapop="unknown" stackshift="2">
      <input>
        <pentry minsize="1" maxsize="500" align="2">
          <addr offset="2" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="2">
          <register name="AX"/>
        </pentry>
        <pentry minsize="3" maxsize="4">
          <addr space="join" piece1="DX" piece2="AX"/>
        </pentry>
      </output>
      <unaffected>
        <register name="SP"/>
        <register name="BP"/>
        <register name="SI"/>
        <register name="DI"/>
        <register name="DS"/>
        <register name="CS"/>
        <register name="ES"/>
        <register name="SS"/>
        <register name="DF"/>
      </unaffected>
    </prototype>
  </default_proto>
  <prototype name="__cdecl16near" extrapop="2" stackshift="2">
    <input>
      <pentry minsize="1" maxsize="500" align="2">
        <addr offset="2" space="stack"/>
      </pentry>
    </input>
    <output>
        <pentry minsize="1" maxsize="2">
          <register name="AX"/>
        </pentry>
        <pentry minsize="3" maxsize="4">
          <addr space="join" piece1="DX" piece2="AX"/>
        </pentry>
    </output>
    <unaffected>
      <register name="SP"/>
      <register name="BP"/>
      <register name="SI"/>
      <register name="DI"/>
      <register name="DS"/>
      <register name="CS"/>
      <register name="ES"/>
      <register name="SS"/>
      <register name="DF"/>
    </unaffected>
  </prototype>
  <prototype name="__stdcall16far" extrapop="unknown" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="2">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
        <pentry minsize="1" maxsize="2">
          <register name="AX"/>
        </pentry>
        <pentry minsize="3" maxsize="4">
          <addr space="join" piece1="DX" piece2="AX"/>
        </pentry>
    </output>
    <unaffected>
      <register name="SP"/>
      <register name="BP"/>
      <register name="SI"/>
      <register name="DI"/>
      <register name="DS"/>
      <register name="CS"/>
      <register name="ES"/>
      <register name="SS"/>
      <register name="DF"/>
    </unaffected>
  </prototype>
  <prototype name="__cdecl16far" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="2">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
      <pentry minsize="1" maxsize="2">
        <register name="AX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="SP"/>
      <register name="BP"/>
      <register name="SI"/>
      <register name="DI"/>
      <register name="DS"/>
      <register name="CS"/>
      <register name="ES"/>
      <register name="SS"/>
      <register name="DF"/>
    </unaffected>
  </prototype>
  <prototype name="__regcall" extrapop="2" stackshift="2">
    <input>
      <pentry minsize="1" maxsize="2">
        <register name="AX"/>
      </pentry>
      <pentry minsize="1" maxsize="2">
        <register name="BX"/>
      </pentry>
      <pentry minsize="1" maxsize="2">
        <register name="CX"/>
      </pentry>
      <pentry minsize="1" maxsize="2">
        <register name="DX"/>
      </pentry>
    </input>
    <output>
        <pentry minsize="1" maxsize="2">
          <register name="AX"/>
        </pentry>
        <pentry minsize="3" maxsize="4">
          <addr space="join" piece1="DX" piece2="AX"/>
        </pentry>
    </output>
    <unaffected>
      <register name="SP"/>
      <register name="BP"/>
      <register name="CX"/>
      <register name="DX"/>
      <register name="SI"/>
      <register name="DI"/>
      <register name="DS"/>
      <register name="CS"/>
      <register name="ES"/>
      <register name="SS"/>
      <register name="DF"/>
    </unaffected>
  </prototype>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-16.gdis`:

```gdis
<gdis>
    <global optstring="intel"/>
</gdis>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-16.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>

<!-- Set up x86 16-bit in protected mode -->

<processor_spec>
  <properties>
    <property key="useOperandReferenceAnalyzerSwitchTables" value="true"/>
  </properties>
  <programcounter register="EIP"/>
  <segmented_address space="ram" type="protected"/>
  <segmentop space="ram" userop="segment" farpointer="yes">
    <pcode>
      <input name="base" size="2"/>
      <input name="inner" size="2"/>
      <output name="res" size="4"/>
      <body><![CDATA[
        res = (zext(base) << 16) + zext(inner);
      ]]></body>
    </pcode>
    <constresolve>
      <register name="DS"/>
    </constresolve>
  </segmentop>
  <context_data>
    <context_set space="ram">
      <set name="addrsize" val="0"/>
      <set name="opsize" val="0"/>
      <set name="protectedMode" val="1"/>
    </context_set>
    <tracked_set space="ram">
      <set name="DF" val="0"/>
    </tracked_set>
  </context_data>
</processor_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-32-golang.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
	<data_organization>
		<absolute_max_alignment value="0" />
		<machine_alignment value="2" />
		<default_alignment value="1" />
		<default_pointer_alignment value="4" />
		<pointer_size value="4" />
		<wchar_size value="4" /> <!-- matches go's 'rune' -->
		<short_size value="2" />
		<integer_size value="4" />
		<long_size value="8" />
		<long_long_size value="8" />
		<float_size value="4" />
		<double_size value="8" />
		<long_double_size value="16" />
		<size_alignment_map>
				<entry size="1" alignment="1" />
				<entry size="2" alignment="2" />
				<entry size="4" alignment="4" />
				<entry size="8" alignment="4" />
		</size_alignment_map>
	</data_organization>
	
	<global>
		<range space="ram"/>
	</global>
	  
	<context_data>
	</context_data>
	  
	<stackpointer register="ESP" space="ram"/>

	<returnaddress>
		<varnode space="stack" offset="0" size="4"/>
	</returnaddress>

	<default_proto>
		<prototype name="abi0" extrapop="4" stackshift="4">
			<input>
				<pentry minsize="1" maxsize="500" align="4">
					<addr offset="4" space="stack"/>
				</pentry>
			</input>
			<output>
			</output>
			<unaffected>
				<register name="ESP"/>
				<register name="EBP"/>
			</unaffected>
		</prototype>
	</default_proto>
	
	<prototype name="duffzero" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="EDI"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
		</input>
      
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="EDI"/>
			</pentry>
		</output>
      
		<killedbycall>
			<register name="EDI"/>
		</killedbycall>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
		</unaffected>
	</prototype>
	
	<prototype name="duffcopy" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="EDI"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="ESI"/>
			</pentry>
		</input>
      
		<output>
		</output>
      
		<killedbycall>
			<register name="EDI"/>
			<register name="ESI"/>
			<register name="ECX"/>
		</killedbycall>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
		</unaffected>
	</prototype>
	
	<prototype name="__cdeclf" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="500" align="4">
			<addr offset="4" space="stack"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="1" maxsize="10">
				<register name="ST0"/>
			</pentry>
		</output>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
			<register name="ESI"/>
			<register name="EDI"/>
			<register name="EBX"/>
		</unaffected>
		<killedbycall>
			<register name="ECX"/>
			<register name="EDX"/>
		</killedbycall>
		<likelytrash>
			<register name="EAX"/>
		</likelytrash>
	</prototype>
	<prototype name="__thiscall" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="500" align="4">
				<addr offset="4" space="stack"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="4" maxsize="10" metatype="float" extension="float">
				<register name="ST0"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="5" maxsize="8">
				<addr space="join" piece1="EDX" piece2="EAX"/>
			</pentry>
		</output>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
			<register name="ESI"/>
			<register name="EDI"/>
			<register name="EBX"/>
		</unaffected>
		<killedbycall>
			<register name="ECX"/>
			<register name="EDX"/>
			<register name="ST0"/>
			<register name="ST1"/>
		</killedbycall>
		<likelytrash>
			<register name="EAX"/>
		</likelytrash>
	</prototype>
	<prototype name="__regparm3" extrapop="4" stackshift="4">   <!-- Used particularly by linux kernel -->
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EDX"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="ECX"/>
			</pentry>
			<pentry minsize="1" maxsize="500" align="4">
				<addr offset="4" space="stack"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="4" maxsize="10" metatype="float" extension="float">
				<register name="ST0"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="5" maxsize="8">
				<addr space="join" piece1="EDX" piece2="EAX"/>
			</pentry>
		</output>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
			<register name="ESI"/>
			<register name="EDI"/>
			<register name="EBX"/>
		</unaffected>
		<killedbycall>
			<register name="ECX"/>
			<register name="EDX"/>
			<register name="ST0"/>
			<register name="ST1"/>
		</killedbycall>
		<likelytrash>
			<register name="EAX"/>
		</likelytrash>
	</prototype>
	<prototype name="__regparm2" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EDX"/>
			</pentry>
			<pentry minsize="1" maxsize="500" align="4">
				<addr offset="4" space="stack"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="4" maxsize="10" metatype="float" extension="float">
				<register name="ST0"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="5" maxsize="8">
				<addr space="join" piece1="EDX" piece2="EAX"/>
			</pentry>
		</output>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
			<register name="ESI"/>
			<register name="EDI"/>
			<register name="EBX"/>
		</unaffected>
		<killedbycall>
			<register name="ECX"/>
			<register name="EDX"/>
			<register name="ST0"/>
			<register name="ST1"/>
		</killedbycall>
		<likelytrash>
			<register name="EAX"/>
		</likelytrash>
	</prototype>
	<prototype name="__regparm1" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="1" maxsize="500" align="4">
				<addr offset="4" space="stack"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="4" maxsize="10" metatype="float" extension="float">
				<register name="ST0"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
			<pentry minsize="5" maxsize="8">
				<addr space="join" piece1="EDX" piece2="EAX"/>
			</pentry>
		</output>
		<unaffected>
			<register name="ESP"/>
			<register name="EBP"/>
			<register name="ESI"/>
			<register name="EDI"/>
			<register name="EBX"/>
		</unaffected>
		<killedbycall>
			<register name="ECX"/>
			<register name="EDX"/>
			<register name="ST0"/>
			<register name="ST1"/>
		</killedbycall>
		<likelytrash>
			<register name="EAX"/>
		</likelytrash>
	</prototype>
	<prototype name="syscall" extrapop="4" stackshift="4">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="EBX"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="ECX"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EDX"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="ESI"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EDI"/>
			</pentry>
			<pentry minsize="1" maxsize="4">
				<register name="EBP"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="1" maxsize="4">
				<register name="EAX"/>
			</pentry>
		</output>
		<unaffected>
			<register name="EBX"/>
			<register name="ECX"/>
			<register name="EDX"/>
			<register name="EBP"/>
			<register name="EDI"/>
			<register name="ESI"/>
			<register name="ESP"/>
			<register name="DF"/>
		</unaffected>
		<killedbycall>
			<register name="EAX"/>
		</killedbycall>
	</prototype>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-32-golang.register.info`:

```info
<golang>
	<register_info versions="all">
		<int_registers list=""/>
		<float_registers list=""/>
		<stack initialoffset="4" maxalign="4"/>
		<current_goroutine register=""/>
		<zero_register register=""/>
	</register_info>
</golang>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64-compat32.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>

<processor_spec>
  <properties>
    <property key="useOperandReferenceAnalyzerSwitchTables" value="true"/>
    <property key="assemblyRating:x86:LE:64:compat32" value="GOLD"/>
  </properties>
  <programcounter register="RIP"/>
  <context_data>
    <context_set space="ram">
      <set name="addrsize" val="1"/>
      <set name="opsize" val="1"/>
      <set name="rexprefix" val="0"/>
      <set name="longMode" val="0"/>
    </context_set>
    <tracked_set space="ram">
      <set name="DF" val="0"/>
    </tracked_set>
  </context_data>
  <register_data>
    <register name="DR0" group="DEBUG"/>
    <register name="DR1" group="DEBUG"/>
    <register name="DR2" group="DEBUG"/>
    <register name="DR3" group="DEBUG"/>
    <register name="DR4" group="DEBUG"/>
    <register name="DR5" group="DEBUG"/>
    <register name="DR6" group="DEBUG"/>
    <register name="DR7" group="DEBUG"/>
    <register name="DR8" group="DEBUG"/>
    <register name="DR9" group="DEBUG"/>
    <register name="DR10" group="DEBUG"/>
    <register name="DR11" group="DEBUG"/>
    <register name="DR12" group="DEBUG"/>
    <register name="DR13" group="DEBUG"/>
    <register name="DR14" group="DEBUG"/>
    <register name="DR15" group="DEBUG"/>
    <register name="CR0" group="CONTROL"/>
    <register name="CR1" group="CONTROL"/>
    <register name="CR2" group="CONTROL"/>
    <register name="CR3" group="CONTROL"/>
    <register name="CR4" group="CONTROL"/>
    <register name="CR5" group="CONTROL"/>
    <register name="CR6" group="CONTROL"/>
    <register name="CR7" group="CONTROL"/>
    <register name="CR8" group="CONTROL"/>
    <register name="CR9" group="CONTROL"/>
    <register name="CR10" group="CONTROL"/>
    <register name="CR11" group="CONTROL"/>
    <register name="CR12" group="CONTROL"/>
    <register name="CR13" group="CONTROL"/>
    <register name="CR14" group="CONTROL"/>
    <register name="CR15" group="CONTROL"/>
    <register name="C0" group="Cx"/>
    <register name="C1" group="Cx"/>
    <register name="C2" group="Cx"/>
    <register name="C3" group="Cx"/>
    <register name="ST0" group="ST"/>
    <register name="ST1" group="ST"/>
    <register name="ST2" group="ST"/>
    <register name="ST3" group="ST"/>
    <register name="ST4" group="ST"/>
    <register name="ST5" group="ST"/>
    <register name="ST6" group="ST"/>
    <register name="ST7" group="ST"/>
    <register name="FPUControlWord" group="FPU"/>
    <register name="FPUStatusWord" group="FPU"/>
    <register name="FPUTagWord" group="FPU"/>
    <register name="FPUDataPointer" group="FPU"/>
    <register name="FPUInstructionPointer" group="FPU"/>
    <register name="FPULastInstructionOpcode" group="FPU"/>
    <register name="MM0" group="MMX"/>
    <register name="MM1" group="MMX"/>
    <register name="MM2" group="MMX"/>
    <register name="MM3" group="MMX"/>
    <register name="MM4" group="MMX"/>
    <register name="MM5" group="MMX"/>
    <register name="MM6" group="MMX"/>
    <register name="MM7" group="MMX"/>
    <register name="YMM0" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM1" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM2" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM3" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM4" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM5" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM6" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM7" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM8" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM9" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM10" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM11" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM12" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM13" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM14" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM15" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM0" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM1" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM2" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM3" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM4" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM5" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM6" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM7" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM8" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM9" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM10" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM11" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM12" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM13" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM14" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM15" vector_lane_sizes="1,2,4,8"/>
    <register name="CF" group="FLAGS"/>
    <register name="F1" group="FLAGS"/>
    <register name="PF" group="FLAGS"/>
    <register name="F3" group="FLAGS"/>
    <register name="AF" group="FLAGS"/>
    <register name="F5" group="FLAGS"/>
    <register name="ZF" group="FLAGS"/>
    <register name="SF" group="FLAGS"/>
    <register name="TF" group="FLAGS"/>
    <register name="IF" group="FLAGS"/>
    <register name="DF" group="FLAGS"/>
    <register name="OF" group="FLAGS"/>
    <register name="IOPL" group="FLAGS"/>
    <register name="NT" group="FLAGS"/>
    <register name="F15" group="FLAGS"/>
    <register name="RF" group="FLAGS"/>
    <register name="VM" group="FLAGS"/>
    <register name="AC" group="FLAGS"/>
    <register name="VIF" group="FLAGS"/>
    <register name="VIP" group="FLAGS"/>
    <register name="ID" group="FLAGS"/>
    <register name="rflags" group="FLAGS"/>
    <register name="eflags" group="FLAGS"/>
    <register name="flags" group="FLAGS"/>
    <register name="bit64" hidden="true"/>
    <register name="segover" hidden="true"/>
    <register name="repneprefx" hidden="true"/>
    <register name="repprefx" hidden="true"/>
    <register name="rexWprefix" hidden="true"/>
    <register name="rexRprefix" hidden="true"/>
    <register name="rexXprefix" hidden="true"/>
    <register name="rexBprefix" hidden="true"/>
    <register name="xmmTmp1" hidden="true"/>
    <register name="xmmTmp1_Qa" hidden="true"/>
    <register name="xmmTmp1_Da" hidden="true"/>
    <register name="xmmTmp1_Db" hidden="true"/>
    <register name="xmmTmp1_Qb" hidden="true"/>
    <register name="xmmTmp1_Dc" hidden="true"/>
    <register name="xmmTmp1_Dd" hidden="true"/>
    <register name="xmmTmp2" hidden="true"/>
    <register name="xmmTmp2_Qa" hidden="true"/>
    <register name="xmmTmp2_Da" hidden="true"/>
    <register name="xmmTmp2_Db" hidden="true"/>
    <register name="xmmTmp2_Qb" hidden="true"/>
    <register name="xmmTmp2_Dc" hidden="true"/>
    <register name="xmmTmp2_Dd" hidden="true"/>
    <register name="rexprefix" hidden="true"/>
  </register_data>
</processor_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64-gcc.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
  <data_organization>
     <machine_alignment value="2" />
     <default_alignment value="1" />
     <default_pointer_alignment value="8" />
     <pointer_size value="8" />
     <wchar_size value="4" />
     <short_size value="2" />
     <integer_size value="4" />
     <long_size value="8" />
     <long_long_size value="8" />
     <float_size value="4" />
     <double_size value="8" />
     <long_double_size value="10" /> <!-- aligned-length=16 -->
     <size_alignment_map>
          <entry size="1" alignment="1" />
          <entry size="2" alignment="2" />
          <entry size="4" alignment="4" />
          <entry size="8" alignment="8" />
          <entry size="16" alignment="16" />
     </size_alignment_map>
  </data_organization>

  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="RSP" space="ram"/>
  <returnaddress>
    <varnode space="stack" offset="0" size="8"/>
  </returnaddress>
  <default_proto>
    <prototype name="__stdcall" extrapop="8" stackshift="8">
      <!-- Derived from "System V Application Binary Interface AMD64 Architecture Processor Supplement" April 2016 -->
      <input>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM0_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM1_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM2_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM3_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM4_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM5_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM6_Qa"/>
        </pentry>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM7_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RDI"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RSI"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RDX"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RCX"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R8"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R9"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="8">
          <addr offset="8" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM0_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RAX"/>
        </pentry>
        <pentry minsize="9" maxsize="16">
          <addr space="join" piece1="RDX" piece2="RAX"/>
        </pentry>
      </output>
      <killedbycall>
        <register name="RAX"/>
        <register name="RDX"/>
        <register name="XMM0"/>
      </killedbycall>
      <unaffected>
        <register name="RBX"/>
        <register name="RSP"/>
        <register name="RBP"/>
        <register name="R12"/>
        <register name="R13"/>
        <register name="R14"/>
        <register name="R15"/>
      </unaffected>
    </prototype>
  </default_proto>
	<prototype name="MSABI" extrapop="8" stackshift="8">
	  <input pointermax="8">
	    <pentry minsize="4" maxsize="8" metatype="float">
	      <register name="XMM0_Qa"/>
	    </pentry>
	    <pentry minsize="4" maxsize="8" metatype="float">
	      <register name="XMM1_Qa"/>
	    </pentry>
	    <pentry minsize="4" maxsize="8" metatype="float">
	      <register name="XMM2_Qa"/>
	    </pentry>
	    <pentry minsize="4" maxsize="8" metatype="float">
	      <register name="XMM3_Qa"/>
	    </pentry>
	    <pentry minsize="1" maxsize="8">
	      <register name="RCX"/>
	    </pentry>
	    <pentry minsize="1" maxsize="8">
	      <register name="RDX"/>
	    </pentry>
	    <pentry minsize="1" maxsize="8">
	      <register name="R8"/>
	    </pentry>
	    <pentry minsize="1" maxsize="8">
	      <register name="R9"/>
	    </pentry>
	    <pentry minsize="1" maxsize="500" align="8">
	      <addr offset="40" space="stack"/>
	    </pentry>
	  </input>
	  <output>
	    <pentry minsize="4" maxsize="8" metatype="float">
	      <register name="XMM0_Qa"/>
	    </pentry>
	    <pentry minsize="1" maxsize="8">
	      <register name="RAX"/>
	    </pentry>
	  </output>
	  <unaffected>
	    <varnode space="ram" offset="0" size="8"/>
	    <register name="RBX"/>
	    <register name="RBP"/>
	    <register name="RDI"/>
	    <register name="RSI"/>
	    <register name="RSP"/>
	    <register name="R12"/>
	    <register name="R13"/>
	    <register name="R14"/>
	    <register name="R15"/>
	    <register name="DF"/>
	  </unaffected>
      <killedbycall>
        <register name="RAX"/>
        <register name="XMM0"/>
      </killedbycall>
	  <localrange>
	    <range space="stack" first="0xfffffffffff0bdc1" last="0xffffffffffffffff"/>
	    <range space="stack" first="8" last="39"/>
	  </localrange>
	</prototype>
	<prototype name="syscall" extrapop="8" stackshift="8">
      <input pointermax="8">
        <pentry minsize="1" maxsize="8">
          <register name="RDI"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RSI"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RDX"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R10"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R8"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R9"/>
        </pentry>
      </input>
      <output killedbycall="true">
        <pentry minsize="1" maxsize="8">
          <register name="RAX"/>
        </pentry>
      </output>
      <unaffected>
        <varnode space="ram" offset="0" size="8"/>
        <register name="RBX"/>
        <register name="RDX"/>
        <register name="RBP"/>
        <register name="RDI"/>
        <register name="RSI"/>
        <register name="RSP"/>
        <register name="R8"/>
        <register name="R9"/>
        <register name="R10"/>
        <register name="R12"/>
        <register name="R13"/>
        <register name="R14"/>
        <register name="R15"/>
        <register name="DF"/>
      </unaffected>
      <killedbycall>
        <register name="RCX"/>
        <register name="R11"/>
      </killedbycall>
    </prototype>
	<prototype name="processEntry" extrapop="0" stackshift="0">
      <input pointermax="8">
        <pentry minsize="1" maxsize="8">
          <register name="RDX"/>
        </pentry>
	    <pentry minsize="1" maxsize="500" align="8">
	      <addr offset="0" space="stack"/>
	    </pentry>
      </input>
      <output killedbycall="true">
        <pentry minsize="1" maxsize="8">
          <register name="RAX"/>
        </pentry>
      </output>
      <unaffected>
          <register name="RSP"/>
      </unaffected>
      <!-- Functions with this prototype don't have a return address. But, if we don't specify one, this prototype will
           use the default, which is to have the return address on the stack. That conflicts with how this prototype actually
           uses the stack, so we set a fake return address at a RBP, which is unspecified at process entry --> 
      <returnaddress>
         <register name="RBP"/>
      </returnaddress>
    </prototype>
    
    <callfixup name="x86_return_thunk">
      <target name="__x86_return_thunk"/>
      <pcode>
        <body><![CDATA[
	  RIP = *:8 RSP;
	  RSP = RSP + 8;
	  return [RIP];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="fentry">
      <target name="__fentry__"/>
      <pcode>
        <body><![CDATA[
	  temp:1 = 0;
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="mcount">
      <target name="mcount"/>
      <pcode>
        <body><![CDATA[
	  temp:1 = 0;
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_rbp">
      <target name="__x86_indirect_thunk_rbp"/>
      <pcode>
        <body><![CDATA[
	  call [RBP];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_rax">
      <target name="__x86_indirect_thunk_rax"/>
      <pcode>
        <body><![CDATA[
	  call [RAX];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_rbx">
      <target name="__x86_indirect_thunk_rbx"/>
      <pcode>
        <body><![CDATA[
	  call [RBX];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_rcx">
      <target name="__x86_indirect_thunk_rcx"/>
      <pcode>
        <body><![CDATA[
	  call [RCX];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_rdx">
      <target name="__x86_indirect_thunk_rdx"/>
      <pcode>
        <body><![CDATA[
	  call [RDX];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r8">
      <target name="__x86_indirect_thunk_r8"/>
      <pcode>
        <body><![CDATA[
	  call [R8];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r9">
      <target name="__x86_indirect_thunk_r9"/>
      <pcode>
        <body><![CDATA[
	  call [R9];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r10">
      <target name="__x86_indirect_thunk_r10"/>
      <pcode>
        <body><![CDATA[
	  call [R10];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r11">
      <target name="__x86_indirect_thunk_r11"/>
      <pcode>
        <body><![CDATA[
	  call [R11];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r12">
      <target name="__x86_indirect_thunk_r12"/>
      <pcode>
        <body><![CDATA[
	  call [R12];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r13">
      <target name="__x86_indirect_thunk_r13"/>
      <pcode>
        <body><![CDATA[
	  call [R13];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r14">
      <target name="__x86_indirect_thunk_r14"/>
      <pcode>
        <body><![CDATA[
	  call [R14];
        ]]></body>
      </pcode>
    </callfixup>
    <callfixup name="x86_indirect_thunk_r15">
      <target name="__x86_indirect_thunk_r15"/>
      <pcode>
        <body><![CDATA[
	  call [R15];
        ]]></body>
      </pcode>
    </callfixup>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64-golang.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
	<data_organization>
		<absolute_max_alignment value="0" />
		<machine_alignment value="2" />
		<default_alignment value="1" />
		<default_pointer_alignment value="8" />
		<pointer_size value="8" />
		<wchar_size value="4" /> <!-- matches go's 'rune' -->
		<short_size value="2" />
		<integer_size value="8" />
		<long_size value="8" />
		<long_long_size value="8" />
		<float_size value="4" />
		<double_size value="8" />
		<long_double_size value="16" />
		<size_alignment_map>
				<entry size="1" alignment="1" />
				<entry size="2" alignment="2" />
				<entry size="4" alignment="4" />
				<entry size="8" alignment="8" />
		</size_alignment_map>
	</data_organization>

	<global>
		<range space="ram"/>
	</global>
  
	<context_data>
	</context_data>
  
	<stackpointer register="RSP" space="ram"/>
  
	<returnaddress>
		<varnode space="stack" offset="0" size="8"/>
	</returnaddress>
  
	<default_proto>
		<prototype name="abi-internal" extrapop="8" stackshift="8">
			<input>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM0_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM1_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM2_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM3_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM4_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM5_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM6_Qa"/>
				</pentry>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM7_Qa"/>
				</pentry>
		        
				<pentry minsize="1" maxsize="8">
					<register name="RAX"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="RBX"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="RCX"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="RDI"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="RSI"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="R8"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="R9"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="R10"/>
				</pentry>
				<pentry minsize="1" maxsize="8">
					<register name="R11"/>
				</pentry>
		        
				<pentry minsize="1" maxsize="500" align="8">
					<addr offset="8" space="stack"/>
				</pentry>
			</input>
	      
			<output>
				<pentry minsize="4" maxsize="8" metatype="float">
					<register name="XMM0_Qa"/>
				</pentry>
		        
				<pentry minsize="1" maxsize="8">
					<register name="RAX"/>
				</pentry>
				<pentry minsize="9" maxsize="16">
					<addr space="join" piece2="RAX" piece1="RBX"/>
				</pentry>
				<pentry minsize="17" maxsize="24">
					<addr space="join" piece3="RAX" piece2="RBX" piece1="RCX"/>
				</pentry>
				<pentry minsize="25" maxsize="32">
					<addr space="join" piece4="RAX" piece3="RBX" piece2="RCX" piece1="RDI"/>
				</pentry>
				<pentry minsize="33" maxsize="40">
					<addr space="join" piece5="RAX" piece4="RBX" piece3="RCX" piece2="RDI" piece1="RSI"/>
				</pentry>
				<pentry minsize="41" maxsize="48">
					<addr space="join" piece6="RAX" piece5="RBX" piece4="RCX" piece3="RDI" piece2="RSI" piece1="R8"/>
				</pentry>
				<pentry minsize="49" maxsize="56">
					<addr space="join" piece7="RAX" piece6="RBX" piece5="RCX" piece4="RDI" piece3="RSI" piece2="R8" piece1="R9"/>
				</pentry>
				<pentry minsize="57" maxsize="64">
					<addr space="join" piece8="RAX" piece7="RBX" piece6="RCX" piece5="RDI" piece4="RSI" piece3="R8" piece2="R9" piece1="R10"/>
				</pentry>
				<pentry minsize="65" maxsize="72">
					<addr space="join" piece9="RAX" piece8="RBX" piece7="RCX" piece6="RDI" piece5="RSI" piece4="R8" piece3="R9" piece2="R10" piece1="R11"/>
				</pentry>
			</output>
	      
			<killedbycall>
				<register name="RAX"/>
				<register name="RBX"/>
				<register name="RCX"/>
				<register name="RDI"/>
				<register name="RSI"/>
				<register name="R8"/>
				<register name="R9"/>
				<register name="R10"/>
				<register name="R11"/>
			</killedbycall>
			<unaffected>
				<register name="RSP"/>
				<register name="RBP"/>
				<register name="R14"/>        
			</unaffected>
		</prototype>
	</default_proto>
  
	<prototype name="abi0" extrapop="8" stackshift="8">
		<input>
			<pentry minsize="1" maxsize="500" align="8">
				<addr offset="8" space="stack"/>
			</pentry>
		</input>
      
		<output>
		</output>
      
		<killedbycall>
			<register name="RAX"/>
			<register name="RBX"/>
			<register name="RCX"/>
			<register name="RDI"/>
			<register name="RSI"/>
			<register name="R8"/>
			<register name="R9"/>
			<register name="R10"/>
			<register name="R11"/>
		</killedbycall>
		<unaffected>
			<register name="RSP"/>
			<register name="RBP"/>
			<register name="R14"/>        
		</unaffected>
	</prototype>
    
	<prototype name="duffzero" extrapop="8" stackshift="8">
		<input>
			<pentry minsize="1" maxsize="8">
				<register name="RDI"/>
			</pentry>
		</input>
      
		<output>
			<pentry minsize="1" maxsize="8">
				<register name="RDI"/>
			</pentry>
		</output>
      
		<killedbycall>
			<register name="RDI"/>
		</killedbycall>
		<unaffected>
			<register name="RSP"/>
			<register name="RBP"/>
			<register name="R14"/>        
		</unaffected>
	</prototype>
	
	<prototype name="duffcopy" extrapop="8" stackshift="8">
		<input>
			<pentry minsize="1" maxsize="8">
				<register name="RDI"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RSI"/>
			</pentry>
		</input>
      
		<output>
			<pentry minsize="1" maxsize="8">
				<register name="RDI"/>
			</pentry>
			<pentry minsize="9" maxsize="16">
				<addr space="join" piece2="RDI" piece1="RSI"/>
			</pentry>
		</output>
      
		<killedbycall>
			<register name="RDI"/>
			<register name="RSI"/>
		</killedbycall>
		<unaffected>
			<register name="RAX"/>
			<register name="RBX"/>
			<register name="RCX"/>
			<register name="RDI"/>
			<register name="RSI"/>
			<register name="R8"/>
			<register name="R9"/>
			<register name="R10"/>
			<register name="R11"/>
			<register name="RSP"/>
			<register name="RBP"/>
			<register name="R14"/>        
		</unaffected>
	</prototype>
	
	<prototype name="__stdcall" extrapop="8" stackshift="8">
		<!-- Derived from "System V Application Binary Interface AMD64 Architecture Processor Supplement" April 2016 -->
		<input>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM0_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM1_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM2_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM3_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM4_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM5_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM6_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM7_Qa"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RDI"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RSI"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RDX"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RCX"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R8"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R9"/>
			</pentry>
			<pentry minsize="1" maxsize="500" align="8">
				<addr offset="8" space="stack"/>
			</pentry>
		</input>
		<output>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM0_Qa"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RAX"/>
			</pentry>
			<pentry minsize="9" maxsize="16">
				<addr space="join" piece1="RDX" piece2="RAX"/>
			</pentry>
		</output>
		<killedbycall>
			<register name="RAX"/>
			<register name="RDX"/>
			<register name="XMM0"/>
		</killedbycall>
		<unaffected>
			<register name="RBX"/>
			<register name="RSP"/>
			<register name="RBP"/>
			<register name="R12"/>
			<register name="R13"/>
			<register name="R14"/>
			<register name="R15"/>
		</unaffected>
	</prototype>

	<prototype name="MSABI" extrapop="8" stackshift="8">
		<input pointermax="8">
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM0_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM1_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM2_Qa"/>
			</pentry>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM3_Qa"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RCX"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RDX"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R8"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R9"/>
			</pentry>
			<pentry minsize="1" maxsize="500" align="8">
				<addr offset="40" space="stack"/>
			</pentry>
		</input>
		<output>
			<pentry minsize="4" maxsize="8" metatype="float">
				<register name="XMM0_Qa"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RAX"/>
			</pentry>
		</output>
		<unaffected>
			<varnode space="ram" offset="0" size="8"/>
			<register name="RBX"/>
			<register name="RBP"/>
			<register name="RDI"/>
			<register name="RSI"/>
			<register name="RSP"/>
			<register name="R12"/>
			<register name="R13"/>
			<register name="R14"/>
			<register name="R15"/>
			<register name="DF"/>
		</unaffected>
		<killedbycall>
			<register name="RAX"/>
			<register name="XMM0"/>
		</killedbycall>
		<localrange>
			<range space="stack" first="0xfffffffffff0bdc1" last="0xffffffffffffffff"/>
			<range space="stack" first="8" last="39"/>
		</localrange>
	</prototype>
	
	<prototype name="syscall" extrapop="8" stackshift="8">
		<input pointermax="8">
			<pentry minsize="1" maxsize="8">
				<register name="RDI"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RSI"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="RDX"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R10"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R8"/>
			</pentry>
			<pentry minsize="1" maxsize="8">
				<register name="R9"/>
			</pentry>
		</input>
		<output killedbycall="true">
			<pentry minsize="1" maxsize="8">
				<register name="RAX"/>
			</pentry>
		</output>
		<unaffected>
			<varnode space="ram" offset="0" size="8"/>
			<register name="RBX"/>
			<register name="RDX"/>
			<register name="RBP"/>
			<register name="RDI"/>
			<register name="RSI"/>
			<register name="RSP"/>
			<register name="R8"/>
			<register name="R9"/>
			<register name="R10"/>
			<register name="R12"/>
			<register name="R13"/>
			<register name="R14"/>
			<register name="R15"/>
			<register name="DF"/>
		</unaffected>
		<killedbycall>
			<register name="RCX"/>
			<register name="R11"/>
		</killedbycall>
	</prototype>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64-golang.register.info`:

```info
<golang>
	<!-- see https://github.com/golang/go/blob/master/src/internal/abi/abi_amd64.go -->
	<register_info versions="V1_17,V1_18,V1_19,V1_20"> <!-- "all", or comma list of: V1_2,V1_16,V1_17,V1_18 -->
		<int_registers list="RAX,RBX,RCX,RDI,RSI,R8,R9,R10,R11"/>
		<float_registers list="XMM0,XMM1,XMM2,XMM3,XMM4,XMM5,XMM6,XMM7,XMM8,XMM9,XMM10,XMM11,XMM12,XMM13,XMM14"/>
		<stack initialoffset="8" maxalign="8"/>
		<current_goroutine register="R14"/>
		<zero_register register="XMM15"/>
	</register_info>
</golang>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64-win.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<!-- see: -->
<!-- https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions#register-usage -->
<!-- https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention -->
<!-- https://docs.microsoft.com/en-us/cpp/c-runtime-library/direction-flag -->
<!-- https://docs.microsoft.com/en-us/cpp/cpp/vectorcall -->

<compiler_spec>

  <data_organization>
     <absolute_max_alignment value="0" />
     <machine_alignment value="2" />
     <default_alignment value="1" />
     <default_pointer_alignment value="8" />
     <pointer_size value="8" />
     <wchar_size value="2" />
     <short_size value="2" />
     <integer_size value="4" />
     <long_size value="4" />
     <long_long_size value="8" />
     <float_size value="4" />
     <double_size value="8" />
     <long_double_size value="8" />
     <size_alignment_map>
          <entry size="1" alignment="1" />
          <entry size="2" alignment="2" />
          <entry size="4" alignment="4" />
          <entry size="8" alignment="8" />
     </size_alignment_map>
     <bitfield_packing>
     	  <use_MS_convention value="true"/>
     </bitfield_packing>
  </data_organization>
  
  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="RSP" space="ram"/>
  <returnaddress>
    <varnode space="stack" offset="0" size="8"/>
  </returnaddress>
  <default_proto>
    <prototype name="__fastcall" extrapop="8" stackshift="8">
      <input pointermax="8">
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM0_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RCX"/>
        </pentry>
      </group>
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM1_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RDX"/>
        </pentry>
      </group>
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM2_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R8"/>
        </pentry>
      </group>
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM3_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R9"/>
        </pentry>
      </group>
      <pentry minsize="1" maxsize="500" align="8">
        <addr offset="40" space="stack"/>
      </pentry>  
    </input> 
      <output>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM0_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RAX"/>
        </pentry>
      </output>
      <unaffected>
        <varnode space="ram" offset="0" size="8"/>
        <register name="RBX"/>
        <register name="RBP"/>
        <register name="RDI"/>
        <register name="RSI"/>
        <register name="RSP"/>
        <register name="R12"/>
        <register name="R13"/>
        <register name="R14"/>
        <register name="R15"/>
        <register name="DF"/>
        <register name="GS_OFFSET"/>
        <register name="XMM6"/>
        <register name="XMM7"/>
        <register name="XMM8"/>
        <register name="XMM9"/>
        <register name="XMM10"/>
        <register name="XMM11"/>
        <register name="XMM12"/>
        <register name="XMM13"/>
        <register name="XMM14"/>
        <register name="XMM15"/>
      </unaffected>
      <killedbycall>
        <register name="RAX"/>
        <register name="XMM0"/>
      </killedbycall>
      <localrange>
        <range space="stack" first="0xfffffffffff0bdc1" last="0xffffffffffffffff"/>
        <range space="stack" first="8" last="39"/>
      </localrange>
    </prototype>
  </default_proto>
  <prototype name="__thiscall" extrapop="8" stackshift="8">
    <input pointermax="8" thisbeforeretpointer="true">
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM0_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RCX"/>
        </pentry>
      </group>
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM1_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="RDX"/>
        </pentry>
      </group>
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM2_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R8"/>
        </pentry>
      </group>
      <group>
        <pentry minsize="4" maxsize="8" metatype="float">
          <register name="XMM3_Qa"/>
        </pentry>
        <pentry minsize="1" maxsize="8">
          <register name="R9"/>
        </pentry>
      </group>
      <pentry minsize="1" maxsize="500" align="8">
        <addr offset="40" space="stack"/>
      </pentry>  
    </input> 
    <output>
      <pentry minsize="4" maxsize="8" metatype="float">
        <register name="XMM0_Qa"/>
      </pentry>
      <pentry minsize="1" maxsize="8">
        <register name="RAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="8"/>
        <register name="RBX"/>
        <register name="RBP"/>
        <register name="RDI"/>
        <register name="RSI"/>
        <register name="RSP"/>
        <register name="R12"/>
        <register name="R13"/>
        <register name="R14"/>
        <register name="R15"/>
        <register name="DF"/>
        <register name="GS_OFFSET"/>
        <register name="XMM6"/>
        <register name="XMM7"/>
        <register name="XMM8"/>
        <register name="XMM9"/>
        <register name="XMM10"/>
        <register name="XMM11"/>
        <register name="XMM12"/>
        <register name="XMM13"/>
        <register name="XMM14"/>
        <register name="XMM15"/>
    </unaffected>
    <killedbycall>
      <register name="RAX"/>
      <register name="XMM0"/>
    </killedbycall>
    <localrange>
      <range space="stack" first="0xfffffffffff0bdc1" last="0xffffffffffffffff"/>
      <range space="stack" first="8" last="39"/>
    </localrange>
  </prototype>
  <modelalias name="__cdecl" parent="__fastcall"/>
  <modelalias name="__stdcall" parent="__fastcall"/>
  <callfixup name="alloca_probe">
    <target name="_alloca_probe"/>
    <target name="_alloca_probe2"/>
    <target name="__chkstk"/>
    <target name="__chkstk2"/>
    <target name="___chkstk_ms"/>
    <pcode>
     <body><![CDATA[
       RSP = RSP + 0;
     ]]></body>
    </pcode>
  </callfixup>
  <callfixup name="guard_dispatch_icall">
    <target name="_guard_dispatch_icall"/>
    <pcode>
      <body><![CDATA[
        call [RAX];
      ]]></body>
    </pcode>
  </callfixup>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64.dwarf`:

```dwarf
<dwarf>
	<register_mappings>
		<register_mapping dwarf="0" ghidra="RAX"/>
		<register_mapping dwarf="1" ghidra="RDX"/>
		<register_mapping dwarf="2" ghidra="RCX"/>
		<register_mapping dwarf="3" ghidra="RBX"/>
		<register_mapping dwarf="4" ghidra="RSI"/>
		<register_mapping dwarf="5" ghidra="RDI"/>
		<register_mapping dwarf="6" ghidra="RBP"/>
		<register_mapping dwarf="7" ghidra="RSP" stackpointer="true"/>
		<register_mapping dwarf="8" ghidra="R8" auto_count="8"/> <!-- R8..R15 -->
		<register_mapping dwarf="16" ghidra="RIP"/>
		<register_mapping dwarf="17" ghidra="XMM0" auto_count="16"/> <!-- XMM0..XMM15 -->
		<register_mapping dwarf="33" ghidra="ST0" auto_count="8"/> <!-- ST0..ST7 -->
		<register_mapping dwarf="41" ghidra="MM0" auto_count="8"/> <!-- MM0..MM7 -->
		<register_mapping dwarf="49" ghidra="rflags"/>
		<register_mapping dwarf="50" ghidra="ES"/>
		<register_mapping dwarf="51" ghidra="CS"/>
		<register_mapping dwarf="52" ghidra="SS"/>
		<register_mapping dwarf="53" ghidra="DS"/>
		<register_mapping dwarf="54" ghidra="FS"/>
		<register_mapping dwarf="55" ghidra="GS"/>
		<!-- <register_mapping dwarf="58" ghidra="FSBASE"/> **not implemented** -->
		<!-- <register_mapping dwarf="59" ghidra="GSBASE"/> **not implemented** -->
		<register_mapping dwarf="62" ghidra="TR"/>
		<register_mapping dwarf="63" ghidra="LDTR"/>
		<register_mapping dwarf="64" ghidra="MXCSR"/>
		<!-- <register_mapping dwarf="65" ghidra="FCW"/> **not implemented** -->
		<!-- <register_mapping dwarf="66" ghidra="FSW"/> **not implemented** -->
		<!-- <register_mapping dwarf="68" ghidra="XMM16" auto_count="16"/> **not implemented yet** --> <!-- XMM16..XMM31 -->
		<!-- <register_mapping dwarf="118" ghidra="K0" auto_count="8"/>  **not implemented yet** -->
	</register_mappings>
	<call_frame_cfa value="8"/>
</dwarf>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>

<processor_spec>
  <properties>
    <property key="useOperandReferenceAnalyzerSwitchTables" value="true"/>
    <property key="assemblyRating:x86:LE:64:default" value="GOLD"/>
  </properties>
  <programcounter register="RIP"/>
  <context_data>
    <context_set space="ram">
      <set name="addrsize" val="2"/>
      <set name="opsize" val="1"/>
      <set name="rexprefix" val="0"/>
      <set name="longMode" val="1"/>
    </context_set>
    <tracked_set space="ram">
      <set name="DF" val="0"/>
    </tracked_set>
  </context_data>
  <register_data>
    <register name="DR0" group="DEBUG"/>
    <register name="DR1" group="DEBUG"/>
    <register name="DR2" group="DEBUG"/>
    <register name="DR3" group="DEBUG"/>
    <register name="DR4" group="DEBUG"/>
    <register name="DR5" group="DEBUG"/>
    <register name="DR6" group="DEBUG"/>
    <register name="DR7" group="DEBUG"/>
    <register name="DR8" group="DEBUG"/>
    <register name="DR9" group="DEBUG"/>
    <register name="DR10" group="DEBUG"/>
    <register name="DR11" group="DEBUG"/>
    <register name="DR12" group="DEBUG"/>
    <register name="DR13" group="DEBUG"/>
    <register name="DR14" group="DEBUG"/>
    <register name="DR15" group="DEBUG"/>
    <register name="CR0" group="CONTROL"/>
    <register name="CR1" group="CONTROL"/>
    <register name="CR2" group="CONTROL"/>
    <register name="CR3" group="CONTROL"/>
    <register name="CR4" group="CONTROL"/>
    <register name="CR5" group="CONTROL"/>
    <register name="CR6" group="CONTROL"/>
    <register name="CR7" group="CONTROL"/>
    <register name="CR8" group="CONTROL"/>
    <register name="CR9" group="CONTROL"/>
    <register name="CR10" group="CONTROL"/>
    <register name="CR11" group="CONTROL"/>
    <register name="CR12" group="CONTROL"/>
    <register name="CR13" group="CONTROL"/>
    <register name="CR14" group="CONTROL"/>
    <register name="CR15" group="CONTROL"/>
    <register name="C0" group="Cx"/>
    <register name="C1" group="Cx"/>
    <register name="C2" group="Cx"/>
    <register name="C3" group="Cx"/>
    <register name="ST0" group="ST"/>
    <register name="ST1" group="ST"/>
    <register name="ST2" group="ST"/>
    <register name="ST3" group="ST"/>
    <register name="ST4" group="ST"/>
    <register name="ST5" group="ST"/>
    <register name="ST6" group="ST"/>
    <register name="ST7" group="ST"/>
    <register name="FPUControlWord" group="FPU"/>
    <register name="FPUStatusWord" group="FPU"/>
    <register name="FPUTagWord" group="FPU"/>
    <register name="FPUDataPointer" group="FPU"/>
    <register name="FPUInstructionPointer" group="FPU"/>
    <register name="FPULastInstructionOpcode" group="FPU"/>
    <register name="MM0" group="MMX"/>
    <register name="MM1" group="MMX"/>
    <register name="MM2" group="MMX"/>
    <register name="MM3" group="MMX"/>
    <register name="MM4" group="MMX"/>
    <register name="MM5" group="MMX"/>
    <register name="MM6" group="MMX"/>
    <register name="MM7" group="MMX"/>
    <register name="YMM0" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM1" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM2" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM3" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM4" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM5" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM6" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM7" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM8" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM9" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM10" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM11" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM12" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM13" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM14" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="YMM15" group="AVX" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM0" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM1" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM2" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM3" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM4" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM5" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM6" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM7" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM8" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM9" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM10" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM11" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM12" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM13" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM14" vector_lane_sizes="1,2,4,8"/>
    <register name="XMM15" vector_lane_sizes="1,2,4,8"/>
    <register name="CF" group="FLAGS"/>
    <register name="F1" group="FLAGS"/>
    <register name="PF" group="FLAGS"/>
    <register name="F3" group="FLAGS"/>
    <register name="AF" group="FLAGS"/>
    <register name="F5" group="FLAGS"/>
    <register name="ZF" group="FLAGS"/>
    <register name="SF" group="FLAGS"/>
    <register name="TF" group="FLAGS"/>
    <register name="IF" group="FLAGS"/>
    <register name="DF" group="FLAGS"/>
    <register name="OF" group="FLAGS"/>
    <register name="IOPL" group="FLAGS"/>
    <register name="NT" group="FLAGS"/>
    <register name="F15" group="FLAGS"/>
    <register name="RF" group="FLAGS"/>
    <register name="VM" group="FLAGS"/>
    <register name="AC" group="FLAGS"/>
    <register name="VIF" group="FLAGS"/>
    <register name="VIP" group="FLAGS"/>
    <register name="ID" group="FLAGS"/>
    <register name="rflags" group="FLAGS"/>
    <register name="eflags" group="FLAGS"/>
    <register name="flags" group="FLAGS"/>
    <register name="bit64" hidden="true"/>
    <register name="segover" hidden="true"/>
    <register name="repneprefx" hidden="true"/>
    <register name="repprefx" hidden="true"/>
    <register name="rexWprefix" hidden="true"/>
    <register name="rexRprefix" hidden="true"/>
    <register name="rexXprefix" hidden="true"/>
    <register name="rexBprefix" hidden="true"/>
    <register name="xmmTmp1" hidden="true"/>
    <register name="xmmTmp1_Qa" hidden="true"/>
    <register name="xmmTmp1_Da" hidden="true"/>
    <register name="xmmTmp1_Db" hidden="true"/>
    <register name="xmmTmp1_Qb" hidden="true"/>
    <register name="xmmTmp1_Dc" hidden="true"/>
    <register name="xmmTmp1_Dd" hidden="true"/>
    <register name="xmmTmp2" hidden="true"/>
    <register name="xmmTmp2_Qa" hidden="true"/>
    <register name="xmmTmp2_Da" hidden="true"/>
    <register name="xmmTmp2_Db" hidden="true"/>
    <register name="xmmTmp2_Qb" hidden="true"/>
    <register name="xmmTmp2_Dc" hidden="true"/>
    <register name="xmmTmp2_Dd" hidden="true"/>
    <register name="rexprefix" hidden="true"/>
  </register_data>
</processor_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86-64.slaspec`:

```slaspec
@define IA64 "IA64"
@include "x86.slaspec"
with : lockprefx=0 {
@include "sgx.sinc"
@include "fma.sinc"
}

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86.dwarf`:

```dwarf
<dwarf>
	<register_mappings>
		<register_mapping dwarf="0" ghidra="EAX"/>
		<register_mapping dwarf="1" ghidra="ECX"/>
		<register_mapping dwarf="2" ghidra="EDX"/>
		<register_mapping dwarf="3" ghidra="EBX"/>
		<register_mapping dwarf="4" ghidra="ESP" stackpointer="true"/>
		<register_mapping dwarf="5" ghidra="EBP"/>
		<register_mapping dwarf="6" ghidra="ESI"/>
		<register_mapping dwarf="7" ghidra="EDI"/>
		<register_mapping dwarf="8" ghidra="EIP"/>
		<register_mapping dwarf="9" ghidra="eflags"/>
		<!-- <register_mapping dwarf="10" ghidra="TRAPNO"/> **not implemented** -->
		<register_mapping dwarf="11" ghidra="ST0" auto_count="8"/> <!-- ST0..ST7 -->
		
		<register_mapping dwarf="21" ghidra="XMM0" auto_count="8"/> <!-- XMM0..XMM7 -->
		<register_mapping dwarf="29" ghidra="MM0" auto_count="8"/> <!-- MM0..MM7 -->
		
		<!-- <register_mapping dwarf="37" ghidra="FCW"/> **not implemented** -->
		<!-- <register_mapping dwarf="38" ghidra="FSW"/> **not implemented** -->
		<register_mapping dwarf="39" ghidra="MXCSR"/>
		
		<register_mapping dwarf="40" ghidra="ES"/>
		<register_mapping dwarf="41" ghidra="CS"/>
		<register_mapping dwarf="42" ghidra="SS"/>
		<register_mapping dwarf="43" ghidra="DS"/>
		<register_mapping dwarf="44" ghidra="FS"/>
		<register_mapping dwarf="45" ghidra="GS"/>
		
		<register_mapping dwarf="48" ghidra="TR"/>
		<register_mapping dwarf="49" ghidra="LDTR"/>
	</register_mappings>
	<call_frame_cfa value="4"/>
</dwarf>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86.ldefs`:

```ldefs
<?xml version="1.0" encoding="UTF-8"?>

<language_definitions>
  <language processor="x86"
            endian="little"
            size="32"
            variant="default"
            version="2.14"
            slafile="x86.sla"
            processorspec="x86.pspec"
            manualindexfile="../manuals/x86.idx"
            id="x86:LE:32:default">
    <description>Intel/AMD 32-bit x86</description>
    <compiler name="Visual Studio" spec="x86win.cspec" id="windows"/>
    <compiler name="clang" spec="x86win.cspec" id="clangwindows"/>
    <compiler name="gcc" spec="x86gcc.cspec" id="gcc"/>
    <compiler name="Borland C++" spec="x86borland.cspec" id="borlandcpp"/>
    <compiler name="Delphi" spec="x86delphi.cspec" id="borlanddelphi"/>
    <compiler name="golang" spec="x86-32-golang.cspec" id="golang"/>
    <external_name tool="gnu" name="i386:intel"/>
    <external_name tool="IDA-PRO" name="8086"/>
	<external_name tool="IDA-PRO" name="80486p"/>
	<external_name tool="IDA-PRO" name="80586p"/>
	<external_name tool="IDA-PRO" name="80686p"/>
	<external_name tool="IDA-PRO" name="k62"/>
	<external_name tool="IDA-PRO" name="p2"/>
	<external_name tool="IDA-PRO" name="p3"/>
	<external_name tool="IDA-PRO" name="athlon"/>
	<external_name tool="IDA-PRO" name="p4"/>
	<external_name tool="IDA-PRO" name="metapc"/>
    <external_name tool="DWARF.register.mapping.file" name="x86.dwarf"/>
    <external_name tool="Golang.register.info.file" name="x86-32-golang.register.info"/>
  </language>
  <language processor="x86"
            endian="little"
            size="32"
            variant="System Management Mode"
            version="2.14"
            slafile="x86.sla"
            processorspec="x86-16.pspec"
            manualindexfile="../manuals/x86.idx"
            id="x86:LE:32:System Management Mode">
    <description>Intel/AMD 32-bit x86 System Management Mode</description>
    <compiler name="default" spec="x86-16.cspec" id="default"/>
    <external_name tool="DWARF.register.mapping.file" name="x86.dwarf"/>
  </language>
  <language processor="x86"
            endian="little"
            size="16"
            variant="Real Mode"
            version="2.14"
            slafile="x86.sla"
            processorspec="x86-16-real.pspec"
            manualindexfile="../manuals/x86.idx"
            id="x86:LE:16:Real Mode">
    <description>Intel/AMD 16-bit x86 Real Mode</description>
    <compiler name="default" spec="x86-16.cspec" id="default"/>
	<external_name tool="IDA-PRO" name="8086"/>
	<external_name tool="IDA-PRO" name="8086r"/>
	<external_name tool="IDA-PRO" name="80386r"/>
	<external_name tool="IDA-PRO" name="80486r"/>
	<external_name tool="IDA-PRO" name="80586r"/>
	<external_name tool="IDA-PRO" name="metapc"/>
    <external_name tool="gnu" name="i8086"/>
    <external_name tool="gdis.disassembler.options.file" name="x86-16.gdis"/>
  </language>
  <language processor="x86"
            endian="little"
            size="16"
            variant="Protected Mode"
            version="2.14"
            slafile="x86.sla"
            processorspec="x86-16.pspec"
            manualindexfile="../manuals/x86.idx"
            id="x86:LE:16:Protected Mode">
    <description>Intel/AMD 16-bit x86 Protected Mode</description>
    <compiler name="default" spec="x86-16.cspec" id="default"/>
	<external_name tool="IDA-PRO" name="8086p"/>
    <external_name tool="gnu" name="i8086"/>
    <external_name tool="gdis.disassembler.options.file" name="x86-16.gdis"/>
  </language>
  <language processor="x86"
            endian="little"
            size="64"
            variant="default"
            version="2.14"
            slafile="x86-64.sla"
            processorspec="x86-64.pspec"
            manualindexfile="../manuals/x86.idx"
            id="x86:LE:64:default">
    <description>Intel/AMD 64-bit x86</description>
    <compiler name="Visual Studio" spec="x86-64-win.cspec" id="windows"/>
    <compiler name="clang" spec="x86-64-win.cspec" id="clangwindows"/>
    <compiler name="gcc" spec="x86-64-gcc.cspec" id="gcc"/>
    <compiler name="golang" spec="x86-64-golang.cspec" id="golang"/>
    <external_name tool="gnu" name="i386:x86-64:intel"/>
    <external_name tool="gnu" name="i386:x86-64"/>
    <external_name tool="IDA-PRO" name="metapc"/>
    <external_name tool="DWARF.register.mapping.file" name="x86-64.dwarf"/>
    <external_name tool="Golang.register.info.file" name="x86-64-golang.register.info"/>
  </language>
  <language processor="x86"
            endian="little"
            size="64"
            variant="compat32"
            version="2.14"
            slafile="x86-64.sla"
            processorspec="x86-64-compat32.pspec"
            manualindexfile="../manuals/x86.idx"
            id="x86:LE:64:compat32">
    <description>Intel/AMD 64-bit x86 in 32-bit compatibility mode (long mode off)</description>
    <compiler name="Visual Studio" spec="x86win.cspec" id="windows"/>
    <compiler name="gcc" spec="x86gcc.cspec" id="gcc"/>
    <external_name tool="DWARF.register.mapping.file" name="x86.dwarf"/>
  </language>
</language_definitions>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86.opinion`:

```opinion
<opinions>
	<!-- NOTE: variant="default" is specified for 64-bit to give preference to the default variant -->
    <constraint loader="Portable Executable (PE)">
      <constraint compilerSpecID="windows">
        <constraint primary="332"   processor="x86"     endian="little" size="32" />
        <constraint primary="333"   processor="x86"     endian="little" size="32" />
        <constraint primary="334"   processor="x86"     endian="little" size="32" />
        <constraint primary="34404" processor="x86"     endian="little" size="64"	variant="default" />
      </constraint>
      <constraint compilerSpecID="clangwindows">
        <constraint primary="332"   secondary="clang" processor="x86" endian="little" size="32" />
        <constraint primary="333"   secondary="clang" processor="x86" endian="little" size="32" />
        <constraint primary="334"   secondary="clang" processor="x86" endian="little" size="32" />
        <constraint primary="34404" secondary="clang" processor="x86" endian="little" size="64"	variant="default" />
      </constraint>
      <constraint compilerSpecID="borlandcpp">
        <constraint primary="332"  secondary="borlandcpp" processor="x86" endian="little" size="32" />
        <constraint primary="333"  secondary="borlandcpp" processor="x86" endian="little" size="32" />
        <constraint primary="334"  secondary="borlandcpp" processor="x86" endian="little" size="32" />
      </constraint>
      <constraint compilerSpecID="borlanddelphi">
        <constraint primary="332"  secondary="borlanddelphi" processor="x86" endian="little" size="32" />
        <constraint primary="333"  secondary="borlanddelphi" processor="x86" endian="little" size="32" />
        <constraint primary="334"  secondary="borlanddelphi" processor="x86" endian="little" size="32" />
      </constraint>
      <constraint compilerSpecID="golang">
        <constraint primary="332"  secondary="golang" processor="x86" endian="little" size="32" />
        <constraint primary="34404"  secondary="golang" processor="x86" endian="little" size="64"	variant="default" />
      </constraint>
    </constraint>
    <constraint loader="Debug Symbols (DBG)" compilerSpecID="windows">
        <constraint primary="332"   processor="x86"     endian="little" size="32" />
        <constraint primary="333"   processor="x86"     endian="little" size="32" />
        <constraint primary="334"   processor="x86"     endian="little" size="32" />
        <constraint primary="34404" processor="x86"     endian="little" size="64"	variant="default" />
    </constraint>
    <constraint loader="Executable and Linking Format (ELF)" compilerSpecID="gcc">
        <constraint primary="3"    processor="x86"      endian="little" size="32" />
        <constraint primary="62"   processor="x86"      endian="little" size="64"	variant="default" />
    </constraint>
    <constraint loader="Module Definition (DEF)" compilerSpecID="windows">
        <constraint primary="0" processor="x86" endian="little" size="32" />
    </constraint>
    <constraint loader="Program Mapfile (MAP)" compilerSpecID="windows">
        <constraint primary="0" processor="x86" endian="little" size="32" />
    </constraint>
    <constraint loader="Old-style DOS Executable (MZ)" compilerSpecID="default">
        <constraint primary="23117" processor="x86" endian="little" size="16" variant="Real Mode"/>
    </constraint>
    <constraint loader="New Executable (NE)" compilerSpecID="default">
        <constraint primary="17742" processor="x86" endian="little" size="16" variant="Protected Mode"/>
    </constraint>
    <constraint loader="Mac OS X Mach-O" compilerSpecID="gcc">
        <constraint primary="7"        processor="x86"     endian="little" size="32" />
        <constraint primary="16777223" processor="x86"     endian="little" size="64"	variant="default" />
    </constraint>
    <constraint loader="DYLD Cache" compilerSpecID="gcc">
        <constraint primary="x86_64"   processor="x86"     endian="little" size="64"	variant="default" />
    </constraint>
    <constraint loader="Common Object File Format (COFF)" compilerSpecID="gcc">
        <constraint primary="332"     processor="x86"          endian="little" size="32" />
        <constraint primary="-31132"  processor="x86"          endian="little" size="64"	variant="default" />
    </constraint>
    <constraint loader="MS Common Object File Format (COFF)" compilerSpecID="windows">
        <constraint primary="332"    processor="x86"          endian="little" size="32" />
        <constraint primary="-31132" processor="x86"          endian="little" size="64"	variant="default" />
    </constraint>
    <constraint loader="Assembler Output (AOUT)" compilerSpecID="gcc">
        <constraint primary="134"  processor="x86"          endian="little" size="32" />
    </constraint>
    <constraint loader="Relocatable Object Module Format (OMF)">
      <constraint compilerSpecID="windows">
        <constraint primary="32bit" processor="x86"          endian="little" size="32" />
      </constraint>
      <constraint compilerSpecID="default">
        <constraint primary="16bit" processor="x86"          endian="little" size="16" />
      </constraint>
      <constraint compilerSpecID="borlandcpp">
        <constraint primary="32bit" secondary="borlandcpp"  processor="x86" endian="little" size="32" />
        <constraint primary="32bit" secondary="codegearcpp" processor="x86" endian="little" size="32" />
      </constraint>
      <constraint compilerSpecID="borlanddelphi">
        <constraint primary="32bit" secondary="borlanddelphi" processor="x86" endian="little" size="32" />
      </constraint>
    </constraint>
</opinions>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>

<processor_spec>
  <properties>
    <property key="useOperandReferenceAnalyzerSwitchTables" value="true"/>
    <property key="assemblyRating:x86:LE:32:default" value="GOLD"/>
  </properties>
  <programcounter register="EIP"/>
  <incidentalcopy>
    <register name="ST0"/>
    <register name="ST1"/>
    <register name="ST2"/>
    <register name="ST3"/>
    <register name="ST4"/>
    <register name="ST5"/>
    <register name="ST6"/>
    <register name="ST7"/>
  </incidentalcopy>
  <context_data>
    <context_set space="ram">
      <set name="addrsize" val="1"/>
      <set name="opsize" val="1"/>
    </context_set>
    <tracked_set space="ram">
      <set name="DF" val="0"/>
    </tracked_set>
  </context_data>
  <register_data>
    <register name="DR0" group="DEBUG"/>
    <register name="DR1" group="DEBUG"/>
    <register name="DR2" group="DEBUG"/>
    <register name="DR3" group="DEBUG"/>
    <register name="DR4" group="DEBUG"/>
    <register name="DR5" group="DEBUG"/>
    <register name="DR6" group="DEBUG"/>
    <register name="DR7" group="DEBUG"/>
    <register name="CR0" group="CONTROL"/>
    <register name="CR2" group="CONTROL"/>
    <register name="CR3" group="CONTROL"/>
    <register name="CR4" group="CONTROL"/>
    <register name="ST0" group="ST"/>
    <register name="ST1" group="ST"/>
    <register name="ST2" group="ST"/>
    <register name="ST3" group="ST"/>
    <register name="ST4" group="ST"/>
    <register name="ST5" group="ST"/>
    <register name="ST6" group="ST"/>
    <register name="ST7" group="ST"/>
    <register name="FPUControlWord" group="FPU"/>
    <register name="FPUStatusWord" group="FPU"/>
    <register name="FPUTagWord" group="FPU"/>
    <register name="FPUInstructionPointer" group="FPU"/>
    <register name="FPULastInstructionOpcode" group="FPU"/>
    <register name="FPUDataPointer" group="FPU"/>
    <register name="MM0" group="MMX"/>
    <register name="MM1" group="MMX"/>
    <register name="MM2" group="MMX"/>
    <register name="MM3" group="MMX"/>
    <register name="MM4" group="MMX"/>
    <register name="MM5" group="MMX"/>
    <register name="MM6" group="MMX"/>
    <register name="MM7" group="MMX"/>
    <register name="YMM0" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM1" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM2" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM3" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM4" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM5" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM6" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM7" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM8" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM9" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM10" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM11" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM12" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM13" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM14" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="YMM15" group="AVX" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM0" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM1" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM2" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM3" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM4" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM5" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM6" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM7" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM8" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM9" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM10" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM11" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM12" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM13" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM14" vector_lane_sizes="1,2,4,8"/> 
    <register name="XMM15" vector_lane_sizes="1,2,4,8"/> 
    <register name="CF" group="FLAGS"/>
    <register name="F1" group="FLAGS"/>
    <register name="PF" group="FLAGS"/>
    <register name="F3" group="FLAGS"/>
    <register name="AF" group="FLAGS"/>
    <register name="F5" group="FLAGS"/>
    <register name="ZF" group="FLAGS"/>
    <register name="SF" group="FLAGS"/>
    <register name="TF" group="FLAGS"/>
    <register name="IF" group="FLAGS"/>
    <register name="DF" group="FLAGS"/>
    <register name="OF" group="FLAGS"/>
    <register name="IOPL" group="FLAGS"/>
    <register name="NT" group="FLAGS"/>
    <register name="F15" group="FLAGS"/>
    <register name="RF" group="FLAGS"/>
    <register name="VM" group="FLAGS"/>
    <register name="AC" group="FLAGS"/>
    <register name="VIF" group="FLAGS"/>
    <register name="VIP" group="FLAGS"/>
    <register name="ID" group="FLAGS"/>
    <register name="eflags" group="FLAGS"/>
    <register name="flags" group="FLAGS"/>
    <register name="repneprefx" hidden="true"/>
    <register name="segover" hidden="true"/>
  </register_data>
</processor_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86.slaspec`:

```slaspec
@include "ia.sinc"
@include "lockable.sinc"
with : lockprefx=0 {
@include "avx.sinc"
@include "avx_manual.sinc"
@include "avx2.sinc"
@include "avx2_manual.sinc"
@include "adx.sinc"
@include "clwb.sinc"
@include "pclmulqdq.sinc"
@include "mpx.sinc"
@include "lzcnt.sinc"
@include "bmi1.sinc"
@include "bmi2.sinc"
@include "sha.sinc"
@include "smx.sinc"
@include "cet.sinc"
@include "rdrand.sinc"
}

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86borland.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
  <data_organization>
     <absolute_max_alignment value="0" />
     <machine_alignment value="2" />
     <default_alignment value="1" />
     <default_pointer_alignment value="4" />
     <pointer_size value="4" />
     <wchar_size value="4" />
     <short_size value="2" />
     <integer_size value="4" />
     <long_size value="4" />
     <long_long_size value="8" />
     <float_size value="4" />
     <double_size value="8" />
     <long_double_size value="10" /> <!-- aligned-length=12 -->
     <size_alignment_map>
          <entry size="1" alignment="1" />
          <entry size="2" alignment="2" />
          <entry size="4" alignment="4" />
          <entry size="8" alignment="4" />
     </size_alignment_map>
  </data_organization>
  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="ESP" space="ram"/>
  <default_proto>
    <prototype name="__fastcall" extrapop="unknown" stackshift="4">
      <input>
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
        <pentry minsize="1" maxsize="4">
          <register name="EDX"/>
        </pentry>
        <pentry minsize="1" maxsize="4">
          <register name="ECX"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="4">
          <addr offset="4" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
      </output>
      <unaffected>
        <register name="ESP"/>
        <register name="EBP"/>
        <register name="ESI"/>
        <register name="EDI"/>
        <register name="EBX"/>
      </unaffected>
      <killedbycall>
        <register name="ECX"/>
        <register name="EDX"/>
      </killedbycall>
    </prototype>
  </default_proto>
  <prototype name="__stdcall" extrapop="unknown" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
  	<register name="EDX"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
  <prototype name="__cdecl" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
  <prototype name="__thiscall" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
    </killedbycall>
    <likelytrash>
      <register name="EAX"/>
    </likelytrash>
  </prototype>
  <resolveprototype name="__stdcall/__fastcall">
    <model name="__stdcall"/>        <!-- The default case -->
    <model name="__fastcall"/>
  </resolveprototype>
  <eval_current_prototype name="__stdcall/__fastcall"/>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86delphi.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="ESP" space="ram"/>
  <default_proto>
    <prototype name="__register" extrapop="unknown" stackshift="4">
      <input>
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
        <pentry minsize="1" maxsize="4">
          <register name="EDX"/>
        </pentry>
        <pentry minsize="1" maxsize="4">
          <register name="ECX"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="4">
          <addr offset="4" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
      </output>
      <unaffected>
        <register name="ESP"/>
        <register name="EBP"/>
        <register name="ESI"/>
        <register name="EDI"/>
        <register name="EBX"/>
      </unaffected>
      <killedbycall>
        <register name="ECX"/>
        <register name="EDX"/>
      </killedbycall>
    </prototype>
  </default_proto>
  <!--there is also a "pascal" calling convention, which is the same as stdcall except that arguments are pushed left-to-right-->
  <prototype name="__stdcall" extrapop="unknown" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
  	<register name="EDX"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
  <prototype name="__cdecl" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86gcc.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
  <data_organization>
     <machine_alignment value="2" />
     <default_alignment value="1" />
     <default_pointer_alignment value="4" />
     <pointer_size value="4" />
     <wchar_size value="4" />
     <short_size value="2" />
     <integer_size value="4" />
     <long_size value="4" />
     <long_long_size value="8" />
     <float_size value="4" />
     <double_size value="8" />
     <long_double_size value="10" /> <!-- aligned-length=12 -->
     <size_alignment_map>
          <entry size="1" alignment="1" />
          <entry size="2" alignment="2" />
          <entry size="4" alignment="4" />
          <entry size="8" alignment="4" />
          <entry size="16" alignment="16" />
     </size_alignment_map>
  </data_organization>
  <global>
    <range space="ram"/>
    <range space="OTHER"/>
  </global>
  <stackpointer register="ESP" space="ram"/>
  <returnaddress>
    <varnode space="stack" offset="0" size="4"/>
  </returnaddress>
  <default_proto>
    <prototype name="__cdecl" extrapop="4" stackshift="4">
      <input>
        <pentry minsize="1" maxsize="500" align="4">
          <addr offset="4" space="stack"/>
        </pentry>
      </input>
      <output killedbycall="true">
        <pentry minsize="4" maxsize="10" metatype="float" extension="float">
          <register name="ST0"/>
        </pentry>
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
        <pentry minsize="5" maxsize="8">
          <addr space="join" piece1="EDX" piece2="EAX"/>
        </pentry>
      </output>
      <unaffected>
        <register name="ESP"/>
        <register name="EBP"/>
        <register name="ESI"/>
        <register name="EDI"/>
        <register name="EBX"/>
      </unaffected>
      <killedbycall>
        <register name="ECX"/>
        <register name="EDX"/>
        <register name="ST0"/>
        <register name="ST1"/>
      </killedbycall>
      <likelytrash>
        <register name="EAX"/>
      </likelytrash>
    </prototype>
  </default_proto>
  <prototype name="__cdeclf" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="1" maxsize="10">
        <register name="ST0"/>
      </pentry>
    </output>
    <unaffected>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
    </killedbycall>
    <likelytrash>
      <register name="EAX"/>
    </likelytrash>
  </prototype>
  <prototype name="__thiscall" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="EAX"/>
    </likelytrash>
  </prototype>
  <prototype name="__regparm3" extrapop="4" stackshift="4">   <!-- Used particularly by linux kernel -->
    <input>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EDX"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="ECX"/>
      </pentry>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="EAX"/>
    </likelytrash>
  </prototype>
  <prototype name="__regparm2" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EDX"/>
      </pentry>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="EAX"/>
    </likelytrash>
  </prototype>
  <prototype name="__regparm1" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="EAX"/>
    </likelytrash>
  </prototype>
  <prototype name="syscall" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="4">
        <register name="EBX"/>
      </pentry>
       <pentry minsize="1" maxsize="4">
        <register name="ECX"/>
      </pentry>
       <pentry minsize="1" maxsize="4">
        <register name="EDX"/>
      </pentry>
       <pentry minsize="1" maxsize="4">
        <register name="ESI"/>
      </pentry>
       <pentry minsize="1" maxsize="4">
        <register name="EDI"/>
      </pentry>
       <pentry minsize="1" maxsize="4">
        <register name="EBP"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <register name="EBX"/>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="EBP"/>
      <register name="EDI"/>
      <register name="ESI"/>
      <register name="ESP"/>
      <register name="DF"/>
    </unaffected>
    <killedbycall>
      <register name="EAX"/>
    </killedbycall>
  </prototype>
  <prototype name="processEntry" extrapop="0" stackshift="0">
      <input pointermax="4">
        <pentry minsize="1" maxsize="4">
          <register name="EDX"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="4">
          <addr offset="0" space="stack"/>
        </pentry>
      </input>
      <output killedbycall="true">
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
      </output>
      <unaffected>
          <register name="ESP"/>
      </unaffected>
      <!-- Functions with this prototype don't have a return address. But, if we don't specify one, this prototype will
           use the default, which is to have the return address on the stack. That conflicts with how this prototype actually
           uses the stack, so we set a fake return address at a EBP, which is unspecified at process entry -->
      <returnaddress>
         <register name="EBP"/>
      </returnaddress>
  </prototype>

  
  <resolveprototype name="__cdecl/__regparm">
    <model name="__cdecl"/>        <!-- The default case -->
    <model name="__regparm3"/>
    <model name="__regparm2"/>
    <model name="__regparm1"/>
  </resolveprototype>
  <eval_current_prototype name="__cdecl/__regparm"/>

  <callfixup name="get_pc_thunk_ax">
    <target name="__i686.get_pc_thunk.ax"/>
    <target name="__x86.get_pc_thunk.ax"/>
    <pcode>
      <body><![CDATA[
      EAX = * ESP;
      ESP = ESP + 4;
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="get_pc_thunk.bp">
    <target name="__i686.get_pc_thunk.bp"/>
    <target name="__x86.get_pc_thunk.bp"/>
    <pcode>
      <body><![CDATA[
      EBP = * ESP;
      ESP = ESP + 4;
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="get_pc_thunk_bx">
    <target name="__i686.get_pc_thunk.bx"/>
    <target name="__x86.get_pc_thunk.bx"/>
    <pcode>
      <body><![CDATA[
      EBX = * ESP;
      ESP = ESP + 4;
      ]]></body>
    </pcode>
  </callfixup>

  <callfixup name="get_pc_thunk_cx">
    <target name="__i686.get_pc_thunk.cx"/>
    <target name="__x86.get_pc_thunk.cx"/>
    <pcode>
      <body><![CDATA[
      ECX = * ESP;
      ESP = ESP + 4;
      ]]></body>
    </pcode>
  </callfixup>

  <callfixup name="get_pc_thunk_dx">
    <target name="__i686.get_pc_thunk.dx"/>
    <target name="__x86.get_pc_thunk.dx"/>
    <pcode>
      <body><![CDATA[
      EDX = * ESP;
      ESP = ESP + 4;
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="get_pc_thunk_si">
    <target name="__i686.get_pc_thunk.si"/>
    <target name="__x86.get_pc_thunk.si"/>
    <pcode>
      <body><![CDATA[
      ESI = * ESP;
      ESP = ESP + 4;
      ]]></body>
    </pcode>
  </callfixup>

  <callfixup name="x86_return_thunk">
	<target name="__x86_return_thunk"/>
	<pcode>
	  <body><![CDATA[
	  EIP = *:4 ESP;
	  ESP = ESP + 4;
	  return [EIP];
	  ]]></body>
	</pcode>
  </callfixup>
  
  <callfixup name="fentry">
    <target name="__fentry__"/>
    <pcode>
      <body><![CDATA[
	  temp:1 = 0;
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="mcount">
    <target name="mcount"/>
    <pcode>
      <body><![CDATA[
	  temp:1 = 0;
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="x86_indirect_thunk_ebp">
    <target name="__x86_indirect_thunk_ebp"/>
    <pcode>
      <body><![CDATA[
	  call [EBP];
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="x86_indirect_thunk_eax">
    <target name="__x86_indirect_thunk_eax"/>
    <pcode>
      <body><![CDATA[
	  call [EAX];
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="x86_indirect_thunk_ebx">
    <target name="__x86_indirect_thunk_ebx"/>
    <pcode>
      <body><![CDATA[
	  call [EBX];
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="x86_indirect_thunk_ecx">
    <target name="__x86_indirect_thunk_ecx"/>
    <pcode>
      <body><![CDATA[
	  call [ECX];
      ]]></body>
    </pcode>
  </callfixup>
  
  <callfixup name="x86_indirect_thunk_edx">
    <target name="__x86_indirect_thunk_edx"/>
    <pcode>
      <body><![CDATA[
	  call [EDX];
      ]]></body>
    </pcode>
  </callfixup>
  
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/data/Ghidra/Processors/x86/data/languages/x86win.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<compiler_spec>
  <data_organization>
	<absolute_max_alignment value="0" /> <!-- no maximum alignment -->
	<machine_alignment value="8" />
	<default_alignment value="1" />
	<default_pointer_alignment value="4" />
	<pointer_size value="4" />
	<wchar_size value="2" />
	<short_size value="2" />
	<integer_size value="4" />
	<long_size value="4" />
	<long_long_size value="8" />
	<float_size value="4" />
	<double_size value="8" />
	<long_double_size value="8" />
	<size_alignment_map>
		<entry size="1" alignment="1" />
		<entry size="2" alignment="2" />
		<entry size="4" alignment="4" />
		<entry size="8" alignment="8" />
	</size_alignment_map>
	<bitfield_packing>
     	<use_MS_convention value="true"/>
    </bitfield_packing>
  </data_organization>
  
  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="ESP" space="ram"/>
  <returnaddress>
    <varnode space="stack" offset="0" size="4"/>
  </returnaddress>
  <default_proto>
    <prototype name="__stdcall" extrapop="unknown" stackshift="4">
      <input>
        <pentry minsize="1" maxsize="500" align="4">
          <addr offset="4" space="stack"/>
        </pentry>
      </input>
      <output killedbycall="true">
        <pentry minsize="4" maxsize="10" metatype="float" extension="float">
          <register name="ST0"/>
        </pentry>
        <pentry minsize="1" maxsize="4">
          <register name="EAX"/>
        </pentry>
        <pentry minsize="5" maxsize="8">
          <addr space="join" piece1="EDX" piece2="EAX"/>
        </pentry>
      </output>
      <unaffected>
        <varnode space="ram" offset="0" size="4"/>
        <register name="ESP"/>
        <register name="EBP"/>
        <register name="ESI"/>
        <register name="EDI"/>
        <register name="EBX"/>
        <register name="DF"/>
        <register name="FS_OFFSET"/>
      </unaffected>
      <killedbycall>
        <register name="ECX"/>
	<register name="EDX"/>
        <register name="ST0"/>
        <register name="ST1"/>
      </killedbycall>
      <likelytrash>
        <register name="ECX"/>
      </likelytrash>
    </prototype>
  </default_proto>
  <prototype name="__cdecl" extrapop="4" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
      <register name="FS_OFFSET"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
  <prototype name="__fastcall" extrapop="unknown" stackshift="4">
    <input>
      <pentry minsize="1" maxsize="4">
        <register name="ECX"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EDX"/>
      </pentry>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
      <register name="FS_OFFSET"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
  <prototype name="__thiscall" extrapop="unknown" stackshift="4">
    <input thisbeforeretpointer="true">
      <pentry minsize="1" maxsize="4">
        <register name="ECX"/>
      </pentry>
      <pentry minsize="1" maxsize="500" align="4">
        <addr offset="4" space="stack"/>
      </pentry>
    </input>
    <output killedbycall="true">
      <pentry minsize="4" maxsize="10" metatype="float" extension="float">
        <register name="ST0"/>
      </pentry>
      <pentry minsize="1" maxsize="4">
        <register name="EAX"/>
      </pentry>
      <pentry minsize="5" maxsize="8">
        <addr space="join" piece1="EDX" piece2="EAX"/>
      </pentry>
    </output>
    <unaffected>
      <varnode space="ram" offset="0" size="4"/>
      <register name="ESP"/>
      <register name="EBP"/>
      <register name="ESI"/>
      <register name="EDI"/>
      <register name="EBX"/>
      <register name="DF"/>
      <register name="FS_OFFSET"/>
    </unaffected>
    <killedbycall>
      <register name="ECX"/>
      <register name="EDX"/>
      <register name="ST0"/>
      <register name="ST1"/>
    </killedbycall>
    <likelytrash>
      <register name="ECX"/>
    </likelytrash>
  </prototype>
  <resolveprototype name="__fastcall/__thiscall/__stdcall">
     <model name="__stdcall"/>      <!-- The default case -->
     <model name="__fastcall"/>
     <model name="__thiscall"/>
  </resolveprototype>
  <eval_current_prototype name="__fastcall/__thiscall/__stdcall"/>



  <!-- Injections for various compiler helper functions -->

<callfixup name="EH_prolog">
  <target name="__EH_prolog"/>
  <target name="_EH_prolog"/>
  <target name="thunk_EH_prolog"/>
  <pcode>
    <body><![CDATA[
     ESP = ESP - 4;
     *:4 ESP = -1;
     ESP = ESP - 4;
     * ESP = EAX;
     EAX = * FS_OFFSET;
     ESP = ESP - 4;
     * ESP = EAX;
     * FS_OFFSET = ESP;
     tmp = ESP + 12;
     * tmp = EBP;
     EBP = tmp;
    ]]></body>
  </pcode>
</callfixup>


<callfixup name="EH_prolog3">
  <target name="_EH_prolog3"/>
  <target name="__EH_prolog3"/>
  <target name="EH_prolog3_GS"/>
  <target name="_EH_prolog3_GS"/>
  <target name="__EH_prolog3_GS"/>
  <target name="EH_prolog3_catch"/>
  <target name="_EH_prolog3_catch"/>
  <target name="__EH_prolog3_catch"/>
  <target name="EH_prolog3_catch_GS"/>
  <target name="_EH_prolog3_catch_GS"/>
  <target name="__EH_prolog3_catch_GS"/>
  <target name="EH_prolog3_catch"/>
  <target name="_EH_prolog3_catch"/>
  <target name="__EH_prolog3_catch"/>
  <target name="EH_prolog3_catch_GS"/>
  <target name="_EH_prolog3_catch_GS"/>
  <target name="__EH_prolog3_catch_GS"/>
  <pcode>
    <body><![CDATA[
     EBP = ESP + 4;
     tmp = * EBP;
     ESP = ESP - tmp;
     ESP = ESP - 24;
    ]]></body>
  </pcode>
</callfixup>

<callfixup name="EH_epilog3">
  <target name="_EH_epilog3"/>
  <target name="__EH_epilog3"/>
  <target name="EH_epilog3_GS"/>
  <target name="_EH_epilog3_GS"/>
  <target name="__EH_epilog3_GS"/>
  <target name="EH_epilog3_catch"/>
  <target name="_EH_epilog3_catch"/>
  <target name="__EH_epilog3_catch"/>
  <target name="EH_epilog3_catch_GS"/>
  <target name="_EH_epilog3_catch_GS"/>
  <target name="FID_conflict:__EH_epilog3_GS"/>
  <target name="FID_conflict:__EH_epilog3_catch"/>
  <target name="FID_conflict:__EH_epilog3_catch_GS"/>
  <target name="SEH_epilog"/>
  <target name="_SEH_epilog"/>
  <target name="__SEH_epilog"/>
  <target name="SEH_epilog4"/>
  <target name="_SEH_epilog4"/>
  <target name="__SEH_epilog4"/>
  <target name="SEH_epilog4_GS"/>
  <target name="_SEH_epilog4_GS"/>
  <target name="__SEH_epilog4_GS"/>
  <target name="FID_conflict:__SEH_epilog4_GS"/>
  <pcode>
   <body><![CDATA[
    ESP = EBP;
    EBP = * ESP;
    ESP = ESP + 4;
   ]]></body>
  </pcode>
</callfixup>


<!-- Not sure if these are ever used, and how they affect the stack
<callfixup name="EH_prolog3_align">
  <target name="_EH_prolog3_align"/>
  <target name="__EH_prolog3_align"/>
  <target name="EH_prolog3_GS_align"/>
  <target name="_EH_prolog3_GS_align"/>
  <target name="__EH_prolog3_GS_align"/>
  <target name="EH_prolog3_catch_align"/>
  <target name="_EH_prolog3_catch_align"/>
  <target name="__EH_prolog3_catch_align"/>
  <target name="EH_prolog3_catch_GS_align"/>
  <target name="_EH_prolog3_catch_GS_align"/>
  <target name="__EH_prolog3_catch_GS_align"/>
  <pcode>
    <body><![CDATA[
     EBP = ESP + 4;
     tmp = * EBP;
     ESP = ESP - tmp;
     ESP = ESP - 24;
    ]]></body>
  </pcode>
</callfixup>

<callfixup name="EH_epilog3_align">
  <target name="_EH_epilog3_align"/>
  <target name="__EH_epilog3_align"/>
  <target name="EH_epilog3_GS_align"/>
  <target name="_EH_epilog3_GS_align"/>
  <target name="__EH_epilog3_GS_align"/>
  <pcode>
   <body><![CDATA[
    ESP = EBP;
    EBP = * ESP;
    ESP = ESP - 4;
   ]]></body>
  </pcode>
</callfixup>
-->
 
<callfixup name="alloca_probe">
  <target name="__alloca_probe"/>
  <target name="__alloca_probe_8"/>
  <target name="__alloca_probe_16"/>
  <target name="__chkstk"/>
  <pcode>
   <body><![CDATA[
     ESP = ESP + 4 - EAX;
   ]]></body>
  </pcode>
</callfixup>

<callfixup name="SEH_prolog">
  <target name="_SEH_prolog"/>
  <target name="__SEH_prolog"/>
  <pcode>
   <body><![CDATA[
    newframetmp = ESP + 8;
    localsizetmp:4 = * newframetmp; 
    ESP = ESP - localsizetmp;
    ESP = ESP - 20;
    * newframetmp = EBP;
    EBP = newframetmp;
    *ESP = EDI;
    *(ESP+4) = ESI;
    *(ESP+8) = EBX;
   ]]></body>
  </pcode>
</callfixup>

<callfixup name="SEH_prolog4">
  <target name="_SEH_prolog4"/>
  <target name="__SEH_prolog4"/>
  <target name="SEH_prolog4_GS"/>
  <target name="_SEH_prolog4_GS"/>
  <target name="__SEH_prolog4_GS"/>
  <pcode>
   <body><![CDATA[
    newframetmp = ESP + 8;
    localsizetmp:4 = * newframetmp; 
    ESP = ESP - localsizetmp;
    ESP = ESP - 24;
    * newframetmp = EBP;
    EBP = newframetmp;
    *(ESP+4) = EDI;
    *(ESP+8) = ESI;
    *(ESP+12) = EBX;
   ]]></body>
  </pcode>
</callfixup>

<callfixup name="__RTC_CheckEsp">
  <target name="__RTC_CheckEsp"/>
  <pcode>
   <body><![CDATA[
      temp:4 = 0;
   ]]></body>
  </pcode>
</callfixup>
</compiler_spec>

```

`src/backends/icicle-emulator/icicle-bridge/src/icicle.rs`:

```rs
use icicle_cpu::ExceptionCode;
use icicle_cpu::ValueSource;
use std::collections::HashSet;
use std::{cell::RefCell, collections::HashMap, rc::Rc};

use crate::registers;

fn create_x64_vm() -> icicle_vm::Vm {
    let mut cpu_config = icicle_vm::cpu::Config::from_target_triple("x86_64-none");
    cpu_config.enable_jit = false;
    cpu_config.enable_jit_mem = true;
    cpu_config.enable_shadow_stack = false;
    cpu_config.enable_recompilation = true;
    cpu_config.track_uninitialized = false;
    cpu_config.optimize_instructions = true;
    cpu_config.optimize_block = false;

    return icicle_vm::build(&cpu_config).unwrap();
}

const FOREIGN_READ: u8 = 1 << 0;
const FOREIGN_WRITE: u8 = 1 << 1;
const FOREIGN_EXEC: u8 = 1 << 2;

fn map_permissions(foreign_permissions: u8) -> u8 {
    let mut permissions: u8 = 0;

    if (foreign_permissions & FOREIGN_READ) != 0 {
        permissions |= icicle_vm::cpu::mem::perm::READ;
    }

    if (foreign_permissions & FOREIGN_WRITE) != 0 {
        permissions |= icicle_vm::cpu::mem::perm::WRITE;
    }

    if (foreign_permissions & FOREIGN_EXEC) != 0 {
        permissions |= icicle_vm::cpu::mem::perm::EXEC;
    }

    return permissions;
}

#[repr(u8)]
#[allow(dead_code)]
#[derive(PartialEq)]
enum HookType {
    Syscall = 1,
    Read,
    Write,
    ExecuteGeneric,
    ExecuteSpecific,
    Violation,
    Interrupt,
    Block,
    Unknown,
}

fn u8_to_hook_type_unsafe(value: u8) -> HookType {
    unsafe { std::mem::transmute(value) }
}

fn split_hook_id(id: u32) -> (u32, HookType) {
    let hook_id = id & 0xFFFFFF;
    let hook_type = u8_to_hook_type_unsafe((id >> 24) as u8);

    return (hook_id, hook_type);
}

fn qualify_hook_id(hook_id: u32, hook_type: HookType) -> u32 {
    let hook_type: u32 = (hook_type as u8).into();
    let hook_type_mask: u32 = hook_type << 24;
    return (hook_id | hook_type_mask).into();
}

pub struct HookContainer<Func: ?Sized> {
    hook_id: u32,
    is_iterating: bool,
    hooks: HashMap<u32, Box<Func>>,
    hooks_to_add: HashMap<u32, Box<Func>>,
    hooks_to_remove: HashSet<u32>,
}

impl<Func: ?Sized> HookContainer<Func> {
    pub fn new() -> Self {
        Self {
            hook_id: 0,
            is_iterating: false,
            hooks: HashMap::new(),
            hooks_to_add: HashMap::new(),
            hooks_to_remove: HashSet::new(),
        }
    }

    pub fn add_hook(&mut self, callback: Box<Func>) -> u32 {
        self.hook_id += 1;
        let id = self.hook_id;

        if self.is_iterating {
            self.hooks_to_add.insert(id, callback);
        } else {
            self.hooks.insert(id, callback);
        }

        return id;
    }

    pub fn for_each_hook<F>(&mut self, mut callback: F)
    where
        F: FnMut(&Func),
    {
        let was_iterating = self.do_pre_access_work();

        for (_, func) in &self.hooks {
            callback(func.as_ref());
        }

        self.do_post_access_work(was_iterating);
    }

    pub fn access_hook<F>(&mut self, id: u32, mut callback: F)
    where
        F: FnMut(&Func),
    {
        let was_iterating = self.do_pre_access_work();

        let hook = self.hooks.get(&id);
        if hook.is_some() {
            callback(hook.unwrap().as_ref());
        }

        self.do_post_access_work(was_iterating);
    }

    pub fn is_empty(&self) -> bool {
        return self.hooks.is_empty();
    }

    pub fn remove_hook(&mut self, id: u32) {
        if self.is_iterating {
            self.hooks_to_remove.insert(id);
        } else {
            self.hooks.remove(&id);
        }
    }

    fn do_pre_access_work(&mut self) -> bool {
        let was_iterating = self.is_iterating;
        self.is_iterating = true;
        return was_iterating;
    }

    fn do_post_access_work(&mut self, was_iterating: bool) {
        self.is_iterating = was_iterating;
        if self.is_iterating {
            return;
        }

        let to_remove = std::mem::take(&mut self.hooks_to_remove);
        for id in &to_remove {
            self.hooks.remove(&id);
        }

        let to_add = std::mem::take(&mut self.hooks_to_add);
        for (id, func) in to_add {
            self.hooks.insert(id, func);
        }
    }
}

struct InstructionHookInjector {
    inst_hook: pcode::HookId,
    block_hook: pcode::HookId,
}

fn count_instructions(block: &icicle_cpu::lifter::Block) -> u64 {
    return block.pcode.instructions.iter().fold(0u64, |count, &stmt| {
        if let pcode::Op::InstructionMarker = stmt.op {
            return count + 1;
        }

        return count;
    });
}

impl icicle_vm::CodeInjector for InstructionHookInjector {
    fn inject(
        &mut self,
        _cpu: &mut icicle_vm::cpu::Cpu,
        group: &icicle_vm::cpu::BlockGroup,
        code: &mut icicle_vm::BlockTable,
    ) {
        for id in group.range() {
            let block = &mut code.blocks[id];

            let mut tmp_block = pcode::Block::new();
            tmp_block.next_tmp = block.pcode.next_tmp;

            let mut is_first_inst = true;
            let inst_count = count_instructions(&block);

            for stmt in block.pcode.instructions.drain(..) {
                tmp_block.push(stmt);
                if let pcode::Op::InstructionMarker = stmt.op {
                    if is_first_inst {
                        is_first_inst = false;
                        tmp_block.push((pcode::Op::Arg(0), pcode::Inputs::one(inst_count)));
                        tmp_block.push(pcode::Op::Hook(self.block_hook));
                    }

                    tmp_block.push(pcode::Op::Hook(self.inst_hook));
                    code.modified.insert(id);
                }
            }

            std::mem::swap(&mut tmp_block.instructions, &mut block.pcode.instructions);
        }
    }
}

struct ExecutionHooks {
    stop: Rc<RefCell<bool>>,
    generic_hooks: HookContainer<dyn Fn(u64)>,
    specific_hooks: HookContainer<dyn Fn(u64)>,
    block_hooks: HookContainer<dyn Fn(u64, u64)>,
    address_mapping: HashMap<u64, Vec<u32>>,
    one_time_callbacks: Vec<Box<dyn Fn()>>,
}

impl ExecutionHooks {
    pub fn new(stop_value: Rc<RefCell<bool>>) -> Self {
        Self {
            stop: stop_value,
            generic_hooks: HookContainer::new(),
            specific_hooks: HookContainer::new(),
            block_hooks: HookContainer::new(),
            address_mapping: HashMap::new(),
            one_time_callbacks: Vec::new(),
        }
    }

    fn run_hooks(&mut self, address: u64) {
        if !self.one_time_callbacks.is_empty() {
            let callbacks = std::mem::take(&mut self.one_time_callbacks);
            for cb in callbacks {
                cb.as_ref()();
            }
        }

        self.generic_hooks.for_each_hook(|func| {
            func(address);
        });

        let mapping = self.address_mapping.get(&address);
        if mapping.is_none() {
            return;
        }

        for id in mapping.unwrap() {
            self.specific_hooks.access_hook(*id, |func| {
                func(address);
            });
        }
    }

    pub fn on_block(&mut self, address: u64, instructions: u64) {
        self.block_hooks.for_each_hook(|func| {
            func(address, instructions);
        });
    }

    pub fn execute(&mut self, cpu: &mut icicle_cpu::Cpu, address: u64) {
        self.run_hooks(address);

        if *self.stop.borrow() {
            cpu.exception.code = ExceptionCode::InstructionLimit as u32;
            cpu.exception.value = address;
        }
    }

    pub fn add_block_hook(&mut self, callback: Box<dyn Fn(u64, u64)>) -> u32 {
        self.block_hooks.add_hook(callback)
    }

    pub fn remove_block_hook(&mut self, id: u32) {
        self.block_hooks.remove_hook(id);
    }

    pub fn add_generic_hook(&mut self, callback: Box<dyn Fn(u64)>) -> u32 {
        self.generic_hooks.add_hook(callback)
    }

    pub fn add_specific_hook(&mut self, address: u64, callback: Box<dyn Fn(u64)>) -> u32 {
        let id = self.specific_hooks.add_hook(callback);

        let mapping = self.address_mapping.entry(address).or_insert_with(Vec::new);
        mapping.push(id);

        return id;
    }

    pub fn schedule(&mut self, callback: Box<dyn Fn()>) {
        self.one_time_callbacks.push(callback);
    }

    pub fn remove_generic_hook(&mut self, id: u32) {
        self.generic_hooks.remove_hook(id);
    }

    pub fn remove_specific_hook(&mut self, id: u32) {
        self.address_mapping.retain(|_, vec| {
            vec.retain(|&x| x != id);
            !vec.is_empty()
        });

        self.specific_hooks.remove_hook(id);
    }
}

pub struct IcicleEmulator {
    executing_thread: std::thread::ThreadId,
    vm: icicle_vm::Vm,
    reg: registers::X86RegisterNodes,
    syscall_hooks: HookContainer<dyn Fn()>,
    interrupt_hooks: HookContainer<dyn Fn(i32)>,
    violation_hooks: HookContainer<dyn Fn(u64, u8, bool) -> bool>,
    execution_hooks: Rc<RefCell<ExecutionHooks>>,
    stop: Rc<RefCell<bool>>,
    snapshots: Vec<Box<icicle_vm::Snapshot>>,
}

struct MemoryHook {
    callback: Box<dyn Fn(u64, &[u8])>,
}

impl icicle_cpu::mem::WriteHook for MemoryHook {
    fn write(&mut self, _mem: &mut icicle_cpu::Mmu, addr: u64, value: &[u8]) {
        (self.callback)(addr, value);
    }
}

impl icicle_cpu::mem::ReadAfterHook for MemoryHook {
    fn read(&mut self, _mem: &mut icicle_cpu::Mmu, addr: u64, value: &[u8]) {
        (self.callback)(addr, value);
    }
}

pub struct MmioHandler {
    read_handler: Box<dyn Fn(u64, &mut [u8])>,
    write_handler: Box<dyn Fn(u64, &[u8])>,
}

impl MmioHandler {
    pub fn new(
        read_function: Box<dyn Fn(u64, &mut [u8])>,
        write_function: Box<dyn Fn(u64, &[u8])>,
    ) -> Self {
        Self {
            read_handler: read_function,
            write_handler: write_function,
        }
    }
}

impl icicle_cpu::mem::IoMemory for MmioHandler {
    fn read(&mut self, addr: u64, buf: &mut [u8]) -> icicle_cpu::mem::MemResult<()> {
        (self.read_handler)(addr, buf);
        return Ok(());
    }

    fn write(&mut self, addr: u64, value: &[u8]) -> icicle_cpu::mem::MemResult<()> {
        (self.write_handler)(addr, value);
        return Ok(());
    }
}

impl IcicleEmulator {
    pub fn new() -> Self {
        let mut virtual_machine = create_x64_vm();
        let capacity_400mb = 50_000;

        let mut capacity = 8 * 2 * capacity_400mb; // ~8gb
        if cfg!(target_pointer_width = "32") {
            capacity = 2 * capacity_400mb; // ~1gb
        }

        virtual_machine.cpu.mem.set_capacity(capacity);

        let stop_value = Rc::new(RefCell::new(false));
        let exec_hooks = Rc::new(RefCell::new(ExecutionHooks::new(stop_value.clone())));

        let inst_exec_hooks = Rc::clone(&exec_hooks);

        let inst_hook = icicle_cpu::InstHook::new(move |cpu: &mut icicle_cpu::Cpu, addr: u64| {
            inst_exec_hooks.borrow_mut().execute(cpu, addr);
        });

        let block_exec_hooks = Rc::clone(&exec_hooks);

        let block_hook = icicle_cpu::InstHook::new(move |cpu: &mut icicle_cpu::Cpu, addr: u64| {
            let instructions = cpu.args[0] as u64;
            block_exec_hooks.borrow_mut().on_block(addr, instructions);
        });

        let inst_hook_id = virtual_machine.cpu.add_hook(inst_hook);
        let block_hook_id = virtual_machine.cpu.add_hook(block_hook);
        virtual_machine.add_injector(InstructionHookInjector {
            inst_hook: inst_hook_id,
            block_hook: block_hook_id,
        });

        Self {
            stop: stop_value,
            executing_thread: std::thread::current().id(),
            reg: registers::X86RegisterNodes::new(&virtual_machine.cpu.arch),
            vm: virtual_machine,
            syscall_hooks: HookContainer::new(),
            interrupt_hooks: HookContainer::new(),
            violation_hooks: HookContainer::new(),
            execution_hooks: exec_hooks,
            snapshots: Vec::new(),
        }
    }

    fn get_mem(&mut self) -> &mut icicle_vm::cpu::Mmu {
        return &mut self.vm.cpu.mem;
    }

    pub fn start(&mut self, count: u64) {
        self.executing_thread = std::thread::current().id();

        self.vm.icount_limit = match count {
            0 => u64::MAX,
            _ => self.vm.cpu.icount.saturating_add(count),
        };

        loop {
            self.vm.cpu.block_id = u64::MAX;
            self.vm.cpu.block_offset = 0;
            self.vm.cpu.pending_exception = None;
            self.vm.cpu.exception.clear();
            *self.stop.borrow_mut() = false;

            let reason = self.vm.run();

            match reason {
                icicle_vm::VmExit::InstructionLimit => break,
                icicle_vm::VmExit::UnhandledException((code, value)) => {
                    let continue_execution = self.handle_exception(code, value);
                    if !continue_execution {
                        break;
                    }
                }
                _ => break,
            };
        }
    }

    fn handle_interrupt(&mut self, code: i32) -> bool {
        self.interrupt_hooks.for_each_hook(|func| {
            func(code);
        });

        return true;
    }

    fn handle_exception(&mut self, code: ExceptionCode, value: u64) -> bool {
        let continue_execution = match code {
            ExceptionCode::Syscall => self.handle_syscall(value),
            ExceptionCode::ReadPerm => self.handle_violation(value, FOREIGN_READ, false),
            ExceptionCode::WritePerm => self.handle_violation(value, FOREIGN_WRITE, false),
            ExceptionCode::ReadUnmapped => self.handle_violation(value, FOREIGN_READ, true),
            ExceptionCode::WriteUnmapped => self.handle_violation(value, FOREIGN_WRITE, true),
            ExceptionCode::SoftwareBreakpoint => self.handle_interrupt(3),
            ExceptionCode::InvalidInstruction => self.handle_interrupt(6),
            ExceptionCode::DivisionException => self.handle_interrupt(0),
            _ => false,
        };

        return continue_execution;
    }

    fn handle_violation(&mut self, address: u64, permission: u8, unmapped: bool) -> bool {
        if self.violation_hooks.is_empty() {
            return false;
        }

        let mut continue_execution = true;

        self.violation_hooks.for_each_hook(|func| {
            continue_execution &= func(address, permission, unmapped);
        });

        return continue_execution;
    }

    fn handle_syscall(&mut self, value: u64) -> bool {
        if value != 0 {
            return self.handle_interrupt(value as i32);
        }

        self.syscall_hooks.for_each_hook(|func| {
            func();
        });

        self.vm.cpu.write_pc(self.vm.cpu.read_pc() + 2);
        return true;
    }

    pub fn stop(&mut self) {
        self.vm.icount_limit = 0;

        if self.executing_thread == std::thread::current().id() {
            *self.stop.borrow_mut() = true;
        }
    }

    pub fn add_block_hook(&mut self, callback: Box<dyn Fn(u64, u64)>) -> u32 {
        let hook_id = self.execution_hooks.borrow_mut().add_block_hook(callback);
        return qualify_hook_id(hook_id, HookType::Block);
    }

    pub fn add_violation_hook(&mut self, callback: Box<dyn Fn(u64, u8, bool) -> bool>) -> u32 {
        let hook_id = self.violation_hooks.add_hook(callback);
        return qualify_hook_id(hook_id, HookType::Violation);
    }

    pub fn add_execution_hook(&mut self, address: u64, callback: Box<dyn Fn(u64)>) -> u32 {
        let hook_id = self
            .execution_hooks
            .borrow_mut()
            .add_specific_hook(address, callback);
        return qualify_hook_id(hook_id, HookType::ExecuteSpecific);
    }

    pub fn add_generic_execution_hook(&mut self, callback: Box<dyn Fn(u64)>) -> u32 {
        let hook_id = self.execution_hooks.borrow_mut().add_generic_hook(callback);
        return qualify_hook_id(hook_id, HookType::ExecuteGeneric);
    }

    pub fn add_syscall_hook(&mut self, callback: Box<dyn Fn()>) -> u32 {
        let hook_id = self.syscall_hooks.add_hook(callback);
        return qualify_hook_id(hook_id, HookType::Syscall);
    }

    pub fn add_interrupt_hook(&mut self, callback: Box<dyn Fn(i32)>) -> u32 {
        let hook_id = self.interrupt_hooks.add_hook(callback);
        return qualify_hook_id(hook_id, HookType::Interrupt);
    }

    pub fn add_read_hook(
        &mut self,
        start: u64,
        end: u64,
        callback: Box<dyn Fn(u64, &[u8])>,
    ) -> u32 {
        let id = self
            .get_mem()
            .add_read_after_hook(start, end, Box::new(MemoryHook { callback }));
        if id.is_none() {
            return 0;
        }

        return qualify_hook_id(id.unwrap(), HookType::Read);
    }

    pub fn add_write_hook(
        &mut self,
        start: u64,
        end: u64,
        callback: Box<dyn Fn(u64, &[u8])>,
    ) -> u32 {
        let id = self
            .get_mem()
            .add_write_hook(start, end, Box::new(MemoryHook { callback }));
        if id.is_none() {
            return 0;
        }

        return qualify_hook_id(id.unwrap(), HookType::Write);
    }

    pub fn remove_hook(&mut self, id: u32) {
        let (hook_id, hook_type) = split_hook_id(id);

        match hook_type {
            HookType::Syscall => self.syscall_hooks.remove_hook(hook_id),
            HookType::Violation => self.violation_hooks.remove_hook(hook_id),
            HookType::Interrupt => self.interrupt_hooks.remove_hook(hook_id),
            HookType::ExecuteGeneric => self
                .execution_hooks
                .borrow_mut()
                .remove_generic_hook(hook_id),
            HookType::ExecuteSpecific => self
                .execution_hooks
                .borrow_mut()
                .remove_specific_hook(hook_id),
            HookType::Block => self.execution_hooks.borrow_mut().remove_block_hook(hook_id),
            HookType::Read => {
                self.get_mem().remove_read_after_hook(hook_id);
                ()
            }
            HookType::Write => {
                self.get_mem().remove_write_hook(hook_id);
                ()
            }
            _ => {}
        }
    }

    pub fn run_on_next_instruction(&mut self, callback: Box<dyn Fn()>) {
        self.execution_hooks.borrow_mut().schedule(callback);
    }

    pub fn map_memory(&mut self, address: u64, length: u64, permissions: u8) -> bool {
        const MAPPING_PERMISSIONS: u8 = icicle_vm::cpu::mem::perm::MAP
            | icicle_vm::cpu::mem::perm::INIT
            | icicle_vm::cpu::mem::perm::IN_CODE_CACHE;

        let native_permissions = map_permissions(permissions);

        let mapping = icicle_vm::cpu::mem::Mapping {
            perm: native_permissions | MAPPING_PERMISSIONS,
            value: 0x0,
        };

        return self.get_mem().map_memory_len(address, length, mapping);
    }

    pub fn map_mmio(
        &mut self,
        address: u64,
        length: u64,
        read_function: Box<dyn Fn(u64, &mut [u8])>,
        write_function: Box<dyn Fn(u64, &[u8])>,
    ) -> bool {
        let mem = self.get_mem();

        let handler = MmioHandler::new(read_function, write_function);
        let handler_id = mem.register_io_handler(handler);

        return self.get_mem().map_memory_len(address, length, handler_id);
    }

    pub fn unmap_memory(&mut self, address: u64, length: u64) -> bool {
        return self.get_mem().unmap_memory_len(address, length);
    }

    pub fn protect_memory(&mut self, address: u64, length: u64, permissions: u8) -> bool {
        let native_permissions = map_permissions(permissions);
        let res = self
            .get_mem()
            .update_perm(address, length, native_permissions);
        return res.is_ok();
    }

    pub fn write_memory(&mut self, address: u64, data: &[u8]) -> bool {
        let res = self
            .get_mem()
            .write_bytes(address, data, icicle_vm::cpu::mem::perm::NONE);
        return res.is_ok();
    }

    pub fn read_memory(&mut self, address: u64, data: &mut [u8]) -> bool {
        let res = self
            .get_mem()
            .read_bytes(address, data, icicle_vm::cpu::mem::perm::NONE);
        return res.is_ok();
    }

    pub fn save_registers(&self) -> Vec<u8> {
        const REG_SIZE: usize = std::mem::size_of::<icicle_cpu::Regs>();
        unsafe {
            let data: [u8; REG_SIZE] = self.vm.cpu.regs.read_at(0);
            return data.to_vec();
        }
    }

    pub fn restore_registers(&mut self, data: &[u8]) {
        const REG_SIZE: usize = std::mem::size_of::<icicle_cpu::Regs>();

        let mut buffer: [u8; REG_SIZE] = [0; REG_SIZE];
        let size = std::cmp::min(REG_SIZE, data.len());
        buffer.copy_from_slice(&data[..size]);

        unsafe {
            self.vm.cpu.regs.write_at(0, buffer);
        };
    }

    fn read_generic_register(&mut self, reg: registers::X86Register, buffer: &mut [u8]) -> usize {
        let reg_node = self.reg.get_node(reg);

        let res = self.vm.cpu.read_dynamic(pcode::Value::Var(reg_node));
        let bytes: [u8; 32] = res.zxt();

        let len = std::cmp::min(bytes.len(), buffer.len());
        buffer[..len].copy_from_slice(&bytes[..len]);

        return reg_node.size.into();
    }

    fn read_flags<T>(&mut self, data: &mut [u8]) -> usize {
        const REAL_SIZE: usize = std::mem::size_of::<u64>();
        let limit: usize = std::mem::size_of::<T>();
        let size = std::cmp::min(REAL_SIZE, limit);

        let flags: u64 = self.reg.get_flags(&mut self.vm.cpu);

        let copy_size = std::cmp::min(data.len(), size);
        data[..copy_size].copy_from_slice(&flags.to_ne_bytes()[..copy_size]);

        return limit;
    }

    pub fn read_register(&mut self, reg: registers::X86Register, data: &mut [u8]) -> usize {
        match reg {
            registers::X86Register::Rflags => self.read_flags::<u64>(data),
            registers::X86Register::Eflags => self.read_flags::<u32>(data),
            registers::X86Register::Flags => self.read_flags::<u16>(data),
            _ => self.read_generic_register(reg, data),
        }
    }

    pub fn create_snapshot(&mut self) -> u32 {
        let snap = self.vm.snapshot();

        let id = self.snapshots.len() as u32;
        self.snapshots.push(Box::new(snap));

        return id;
    }

    pub fn restore_snapshot(&mut self, id: u32) {
        let snap = self.snapshots[id as usize].as_ref();
        self.vm.restore(&snap);
    }

    fn write_flags<T>(&mut self, data: &[u8]) -> usize {
        const REAL_SIZE: usize = std::mem::size_of::<u64>();
        let limit: usize = std::mem::size_of::<T>();
        let size = std::cmp::min(REAL_SIZE, limit);
        let copy_size = std::cmp::min(data.len(), size);

        let mut buffer = [0u8; REAL_SIZE];
        self.read_flags::<u64>(&mut buffer);

        buffer[..copy_size].copy_from_slice(&data[..copy_size]);

        let flags = u64::from_ne_bytes(buffer);
        self.reg.set_flags(&mut self.vm.cpu, flags);

        return limit;
    }

    pub fn write_register(&mut self, reg: registers::X86Register, data: &[u8]) -> usize {
        match reg {
            registers::X86Register::Rflags => self.write_flags::<u64>(data),
            registers::X86Register::Eflags => self.write_flags::<u32>(data),
            registers::X86Register::Flags => self.write_flags::<u16>(data),
            _ => self.write_generic_register(reg, data),
        }
    }

    fn write_generic_register(&mut self, reg: registers::X86Register, data: &[u8]) -> usize {
        let reg_node = self.reg.get_node(reg);

        let mut buffer = [0u8; 32];
        let len = std::cmp::min(data.len(), buffer.len());
        buffer[..len].copy_from_slice(&data[..len]);

        //let value = icicle_cpu::regs::DynamicValue::new(buffer, reg_node.size.into());
        //self.vm.cpu.write_trunc(reg_node, value);

        let cpu = &mut self.vm.cpu;

        match reg_node.size {
            1 => cpu.write_var::<[u8; 1]>(reg_node, buffer[..1].try_into().unwrap()),
            2 => cpu.write_var::<[u8; 2]>(reg_node, buffer[..2].try_into().unwrap()),
            3 => cpu.write_var::<[u8; 3]>(reg_node, buffer[..3].try_into().unwrap()),
            4 => cpu.write_var::<[u8; 4]>(reg_node, buffer[..4].try_into().unwrap()),
            5 => cpu.write_var::<[u8; 5]>(reg_node, buffer[..5].try_into().unwrap()),
            6 => cpu.write_var::<[u8; 6]>(reg_node, buffer[..6].try_into().unwrap()),
            7 => cpu.write_var::<[u8; 7]>(reg_node, buffer[..7].try_into().unwrap()),
            8 => cpu.write_var::<[u8; 8]>(reg_node, buffer[..8].try_into().unwrap()),
            9 => cpu.write_var::<[u8; 9]>(reg_node, buffer[..9].try_into().unwrap()),
            10 => cpu.write_var::<[u8; 10]>(reg_node, buffer[..10].try_into().unwrap()),
            11 => cpu.write_var::<[u8; 11]>(reg_node, buffer[..11].try_into().unwrap()),
            12 => cpu.write_var::<[u8; 12]>(reg_node, buffer[..12].try_into().unwrap()),
            13 => cpu.write_var::<[u8; 13]>(reg_node, buffer[..13].try_into().unwrap()),
            14 => cpu.write_var::<[u8; 14]>(reg_node, buffer[..14].try_into().unwrap()),
            15 => cpu.write_var::<[u8; 15]>(reg_node, buffer[..15].try_into().unwrap()),
            16 => cpu.write_var::<[u8; 16]>(reg_node, buffer[..16].try_into().unwrap()),
            _ => panic!("invalid dynamic value size"),
        }

        return reg_node.size.into();
    }
}

```

`src/backends/icicle-emulator/icicle-bridge/src/lib.rs`:

```rs
mod icicle;
mod registers;

use icicle::IcicleEmulator;
use registers::X86Register;
use std::os::raw::c_void;

fn to_cbool(value: bool) -> i32 {
    if value {
        return 1;
    }

    return 0;
}

#[unsafe(no_mangle)]
pub fn icicle_create_emulator() -> *mut c_void {
    let emulator = Box::new(IcicleEmulator::new());
    return Box::into_raw(emulator) as *mut c_void;
}

#[unsafe(no_mangle)]
pub fn icicle_start(ptr: *mut c_void, count: usize) {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        emulator.start(count as u64);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_stop(ptr: *mut c_void) {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        emulator.stop();
    }
}

type RawFunction = extern "C" fn(*mut c_void);
type PtrFunction = extern "C" fn(*mut c_void, u64);
type BlockFunction = extern "C" fn(*mut c_void, u64, u64);
type DataFunction = extern "C" fn(*mut c_void, *const c_void, usize);
type MmioReadFunction = extern "C" fn(*mut c_void, u64, *mut c_void, usize);
type MmioWriteFunction = extern "C" fn(*mut c_void, u64, *const c_void, usize);
type ViolationFunction = extern "C" fn(*mut c_void, u64, u8, i32) -> i32;
type InterruptFunction = extern "C" fn(*mut c_void, i32);
type MemoryAccessFunction = MmioWriteFunction;

#[unsafe(no_mangle)]
pub fn icicle_map_mmio(
    ptr: *mut c_void,
    address: u64,
    length: u64,
    read_cb: MmioReadFunction,
    read_data: *mut c_void,
    write_cb: MmioWriteFunction,
    write_data: *mut c_void,
) -> i32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);

        let read_wrapper = Box::new(move |addr: u64, data: &mut [u8]| {
            let raw_pointer: *mut u8 = data.as_mut_ptr();
            read_cb(read_data, addr, raw_pointer as *mut c_void, data.len());
        });

        let write_wrapper = Box::new(move |addr: u64, data: &[u8]| {
            let raw_pointer: *const u8 = data.as_ptr();
            write_cb(write_data, addr, raw_pointer as *const c_void, data.len());
        });

        let res = emulator.map_mmio(address, length, read_wrapper, write_wrapper);
        return to_cbool(res);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_map_memory(ptr: *mut c_void, address: u64, length: u64, permissions: u8) -> i32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let res = emulator.map_memory(address, length, permissions);
        return to_cbool(res);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_unmap_memory(ptr: *mut c_void, address: u64, length: u64) -> i32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let res = emulator.unmap_memory(address, length);
        return to_cbool(res);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_protect_memory(ptr: *mut c_void, address: u64, length: u64, permissions: u8) -> i32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let res = emulator.protect_memory(address, length, permissions);
        return to_cbool(res);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_write_memory(
    ptr: *mut c_void,
    address: u64,
    data: *const c_void,
    size: usize,
) -> i32 {
    if size == 0 {
        return 1;
    }

    if data.is_null() {
        return 0;
    }

    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let u8_slice = std::slice::from_raw_parts(data as *const u8, size);
        let res = emulator.write_memory(address, u8_slice);
        return to_cbool(res);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_save_registers(ptr: *mut c_void, accessor: DataFunction, accessor_data: *mut c_void) {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let registers = emulator.save_registers();
        accessor(
            accessor_data,
            registers.as_ptr() as *const c_void,
            registers.len(),
        );
    }
}

#[unsafe(no_mangle)]
pub fn icicle_restore_registers(ptr: *mut c_void, data: *const c_void, size: usize) {
    if size == 0 || data.is_null() {
        return;
    }

    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let u8_slice = std::slice::from_raw_parts(data as *const u8, size);
        emulator.restore_registers(u8_slice);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_create_snapshot(ptr: *mut c_void) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.create_snapshot();
    }
}

#[unsafe(no_mangle)]
pub fn icicle_restore_snapshot(ptr: *mut c_void, id: u32) {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        emulator.restore_snapshot(id);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_read_memory(ptr: *mut c_void, address: u64, data: *mut c_void, size: usize) -> i32 {
    if size == 0 {
        return 1;
    }

    if data.is_null() {
        return 0;
    }

    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let u8_slice = std::slice::from_raw_parts_mut(data as *mut u8, size);
        let res = emulator.read_memory(address, u8_slice);
        return to_cbool(res);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_interrupt_hook(
    ptr: *mut c_void,
    callback: InterruptFunction,
    data: *mut c_void,
) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_interrupt_hook(Box::new(move |code: i32| callback(data, code)));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_violation_hook(
    ptr: *mut c_void,
    callback: ViolationFunction,
    data: *mut c_void,
) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_violation_hook(Box::new(
            move |address: u64, permission: u8, unmapped: bool| {
                let result = callback(data, address, permission, to_cbool(unmapped));
                if result == 0 {
                    return false;
                }

                return true;
            },
        ));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_read_hook(
    ptr: *mut c_void,
    start: u64,
    end: u64,
    callback: MemoryAccessFunction,
    user: *mut c_void,
) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_read_hook(
            start,
            end,
            Box::new(move |address: u64, data: &[u8]| {
                callback(user, address, data.as_ptr() as *const c_void, data.len());
            }),
        );
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_write_hook(
    ptr: *mut c_void,
    start: u64,
    end: u64,
    callback: MemoryAccessFunction,
    user: *mut c_void,
) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_write_hook(
            start,
            end,
            Box::new(move |address: u64, data: &[u8]| {
                callback(user, address, data.as_ptr() as *const c_void, data.len());
            }),
        );
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_syscall_hook(ptr: *mut c_void, callback: RawFunction, data: *mut c_void) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_syscall_hook(Box::new(move || callback(data)));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_block_hook(ptr: *mut c_void, callback: BlockFunction, data: *mut c_void) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_block_hook(Box::new(move |address: u64, instructions: u64| {
            callback(data, address, instructions)
        }));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_generic_execution_hook(
    ptr: *mut c_void,
    callback: PtrFunction,
    data: *mut c_void,
) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_generic_execution_hook(Box::new(move |ptr: u64| callback(data, ptr)));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_add_execution_hook(
    ptr: *mut c_void,
    address: u64,
    callback: PtrFunction,
    data: *mut c_void,
) -> u32 {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        return emulator.add_execution_hook(address, Box::new(move |ptr: u64| callback(data, ptr)));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_remove_hook(ptr: *mut c_void, id: u32) {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        emulator.remove_hook(id);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_run_on_next_instruction(ptr: *mut c_void, callback: RawFunction, data: *mut c_void) {
    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        emulator.run_on_next_instruction(Box::new(move || callback(data)));
    }
}

#[unsafe(no_mangle)]
pub fn icicle_read_register(
    ptr: *mut c_void,
    reg: X86Register,
    data: *mut c_void,
    size: usize,
) -> usize {
    if size == 0 {
        return 1;
    }

    if data.is_null() {
        return 0;
    }

    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let u8_slice = std::slice::from_raw_parts_mut(data as *mut u8, size);
        return emulator.read_register(reg, u8_slice);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_write_register(
    ptr: *mut c_void,
    reg: X86Register,
    data: *const c_void,
    size: usize,
) -> usize {
    if size == 0 {
        return 1;
    }

    if data.is_null() {
        return 0;
    }

    unsafe {
        let emulator = &mut *(ptr as *mut IcicleEmulator);
        let u8_slice = std::slice::from_raw_parts(data as *const u8, size);
        return emulator.write_register(reg, u8_slice);
    }
}

#[unsafe(no_mangle)]
pub fn icicle_destroy_emulator(ptr: *mut c_void) {
    if ptr.is_null() {
        return;
    }

    unsafe {
        let _ = Box::from_raw(ptr as *mut IcicleEmulator);
    }
}

```

`src/backends/icicle-emulator/icicle-bridge/src/registers.rs`:

```rs
#[repr(i32)]
#[derive(PartialEq)]
pub enum X86Register {
    Invalid = 0,
    Ah,
    Al,
    Ax,
    Bh,
    Bl,
    Bp,
    Bpl,
    Bx,
    Ch,
    Cl,
    Cs,
    Cx,
    Dh,
    Di,
    Dil,
    Dl,
    Ds,
    Dx,
    Eax,
    Ebp,
    Ebx,
    Ecx,
    Edi,
    Edx,
    Eflags,
    Eip,
    Es = 26 + 2,
    Esi,
    Esp,
    Fpsw,
    Fs,
    Gs,
    Ip,
    Rax,
    Rbp,
    Rbx,
    Rcx,
    Rdi,
    Rdx,
    Rip,
    Rsi = 41 + 2,
    Rsp,
    Si,
    Sil,
    Sp,
    Spl,
    Ss,
    Cr0,
    Cr1,
    Cr2,
    Cr3,
    Cr4,
    Cr8 = 54 + 4,
    Dr0 = 58 + 8,
    Dr1,
    Dr2,
    Dr3,
    Dr4,
    Dr5,
    Dr6,
    Dr7,
    Fp0 = 73 + 9,
    Fp1,
    Fp2,
    Fp3,
    Fp4,
    Fp5,
    Fp6,
    Fp7,
    K0,
    K1,
    K2,
    K3,
    K4,
    K5,
    K6,
    K7,
    Mm0,
    Mm1,
    Mm2,
    Mm3,
    Mm4,
    Mm5,
    Mm6,
    Mm7,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
    St0,
    St1,
    St2,
    St3,
    St4,
    St5,
    St6,
    St7,
    Xmm0,
    Xmm1,
    Xmm2,
    Xmm3,
    Xmm4,
    Xmm5,
    Xmm6,
    Xmm7,
    Xmm8,
    Xmm9,
    Xmm10,
    Xmm11,
    Xmm12,
    Xmm13,
    Xmm14,
    Xmm15,
    Xmm16,
    Xmm17,
    Xmm18,
    Xmm19,
    Xmm20,
    Xmm21,
    Xmm22,
    Xmm23,
    Xmm24,
    Xmm25,
    Xmm26,
    Xmm27,
    Xmm28,
    Xmm29,
    Xmm30,
    Xmm31,
    Ymm0,
    Ymm1,
    Ymm2,
    Ymm3,
    Ymm4,
    Ymm5,
    Ymm6,
    Ymm7,
    Ymm8,
    Ymm9,
    Ymm10,
    Ymm11,
    Ymm12,
    Ymm13,
    Ymm14,
    Ymm15,
    Ymm16,
    Ymm17,
    Ymm18,
    Ymm19,
    Ymm20,
    Ymm21,
    Ymm22,
    Ymm23,
    Ymm24,
    Ymm25,
    Ymm26,
    Ymm27,
    Ymm28,
    Ymm29,
    Ymm30,
    Ymm31,
    Zmm0,
    Zmm1,
    Zmm2,
    Zmm3,
    Zmm4,
    Zmm5,
    Zmm6,
    Zmm7,
    Zmm8,
    Zmm9,
    Zmm10,
    Zmm11,
    Zmm12,
    Zmm13,
    Zmm14,
    Zmm15,
    Zmm16,
    Zmm17,
    Zmm18,
    Zmm19,
    Zmm20,
    Zmm21,
    Zmm22,
    Zmm23,
    Zmm24,
    Zmm25,
    Zmm26,
    Zmm27,
    Zmm28,
    Zmm29,
    Zmm30,
    Zmm31,
    R8b,
    R9b,
    R10b,
    R11b,
    R12b,
    R13b,
    R14b,
    R15b,
    R8d,
    R9d,
    R10d,
    R11d,
    R12d,
    R13d,
    R14d,
    R15d,
    R8w,
    R9w,
    R10w,
    R11w,
    R12w,
    R13w,
    R14w,
    R15w,
    Idtr,
    Gdtr,
    Ldtr,
    Tr,
    Fpcw,
    Fptag,
    Msr,
    Mxcsr,
    FsBase,
    GsBase,
    Flags,
    Rflags,
    Fip,
    Fcs,
    Fdp,
    Fds,
    Fop,
    End, // Must be last
}

#[derive(Clone)]
pub(crate) struct X86RegisterNodes {
    rax: pcode::VarNode,
    rbx: pcode::VarNode,
    rcx: pcode::VarNode,
    rdx: pcode::VarNode,
    rsi: pcode::VarNode,
    rdi: pcode::VarNode,
    rbp: pcode::VarNode,
    rsp: pcode::VarNode,
    r8: pcode::VarNode,
    r9: pcode::VarNode,
    r10: pcode::VarNode,
    r11: pcode::VarNode,
    r12: pcode::VarNode,
    r13: pcode::VarNode,
    r14: pcode::VarNode,
    r15: pcode::VarNode,
    rip: pcode::VarNode,
    cs: pcode::VarNode,
    ds: pcode::VarNode,
    es: pcode::VarNode,
    fs: pcode::VarNode,
    gs: pcode::VarNode,
    ss: pcode::VarNode,
    ah: pcode::VarNode,
    al: pcode::VarNode,
    ax: pcode::VarNode,
    bh: pcode::VarNode,
    bl: pcode::VarNode,
    bpl: pcode::VarNode,
    ch: pcode::VarNode,
    cl: pcode::VarNode,
    cx: pcode::VarNode,
    dh: pcode::VarNode,
    dil: pcode::VarNode,
    dl: pcode::VarNode,
    dx: pcode::VarNode,
    eax: pcode::VarNode,
    ebp: pcode::VarNode,
    ebx: pcode::VarNode,
    ecx: pcode::VarNode,
    edi: pcode::VarNode,
    edx: pcode::VarNode,
    esi: pcode::VarNode,
    esp: pcode::VarNode,
    fpsw: pcode::VarNode,
    gdtr: pcode::VarNode,
    idtr: pcode::VarNode,
    ldtr: pcode::VarNode,
    tr: pcode::VarNode,
    cr0: pcode::VarNode,
    cr1: pcode::VarNode,
    cr2: pcode::VarNode,
    cr3: pcode::VarNode,
    cr4: pcode::VarNode,
    cr8: pcode::VarNode,
    dr0: pcode::VarNode,
    dr1: pcode::VarNode,
    dr2: pcode::VarNode,
    dr3: pcode::VarNode,
    dr4: pcode::VarNode,
    dr5: pcode::VarNode,
    dr6: pcode::VarNode,
    dr7: pcode::VarNode,
    fp0: pcode::VarNode,
    fp1: pcode::VarNode,
    fp2: pcode::VarNode,
    fp3: pcode::VarNode,
    fp4: pcode::VarNode,
    fp5: pcode::VarNode,
    fp6: pcode::VarNode,
    fp7: pcode::VarNode,
    /*k0: pcode::VarNode,
    k1: pcode::VarNode,
    k2: pcode::VarNode,
    k3: pcode::VarNode,
    k4: pcode::VarNode,
    k5: pcode::VarNode,
    k6: pcode::VarNode,
    k7: pcode::VarNode,*/
    mm0: pcode::VarNode,
    mm1: pcode::VarNode,
    mm2: pcode::VarNode,
    mm3: pcode::VarNode,
    mm4: pcode::VarNode,
    mm5: pcode::VarNode,
    mm6: pcode::VarNode,
    mm7: pcode::VarNode,
    st0: pcode::VarNode,
    st1: pcode::VarNode,
    st2: pcode::VarNode,
    st3: pcode::VarNode,
    st4: pcode::VarNode,
    st5: pcode::VarNode,
    st6: pcode::VarNode,
    st7: pcode::VarNode,
    xmm0: pcode::VarNode,
    xmm1: pcode::VarNode,
    xmm2: pcode::VarNode,
    xmm3: pcode::VarNode,
    xmm4: pcode::VarNode,
    xmm5: pcode::VarNode,
    xmm6: pcode::VarNode,
    xmm7: pcode::VarNode,
    xmm8: pcode::VarNode,
    xmm9: pcode::VarNode,
    xmm10: pcode::VarNode,
    xmm11: pcode::VarNode,
    xmm12: pcode::VarNode,
    xmm13: pcode::VarNode,
    xmm14: pcode::VarNode,
    xmm15: pcode::VarNode,
    /*xmm16: pcode::VarNode,
    xmm17: pcode::VarNode,
    xmm18: pcode::VarNode,
    xmm19: pcode::VarNode,
    xmm20: pcode::VarNode,
    xmm21: pcode::VarNode,
    xmm22: pcode::VarNode,
    xmm23: pcode::VarNode,
    xmm24: pcode::VarNode,
    xmm25: pcode::VarNode,
    xmm26: pcode::VarNode,
    xmm27: pcode::VarNode,
    xmm28: pcode::VarNode,
    xmm29: pcode::VarNode,
    xmm30: pcode::VarNode,
    xmm31: pcode::VarNode,*/
    ymm0: pcode::VarNode,
    ymm1: pcode::VarNode,
    ymm2: pcode::VarNode,
    ymm3: pcode::VarNode,
    ymm4: pcode::VarNode,
    ymm5: pcode::VarNode,
    ymm6: pcode::VarNode,
    ymm7: pcode::VarNode,
    ymm8: pcode::VarNode,
    ymm9: pcode::VarNode,
    ymm10: pcode::VarNode,
    ymm11: pcode::VarNode,
    ymm12: pcode::VarNode,
    ymm13: pcode::VarNode,
    ymm14: pcode::VarNode,
    ymm15: pcode::VarNode,
    /*ymm16: pcode::VarNode,
    ymm17: pcode::VarNode,
    ymm18: pcode::VarNode,
    ymm19: pcode::VarNode,
    ymm20: pcode::VarNode,
    ymm21: pcode::VarNode,
    ymm22: pcode::VarNode,
    ymm23: pcode::VarNode,
    ymm24: pcode::VarNode,
    ymm25: pcode::VarNode,
    ymm26: pcode::VarNode,
    ymm27: pcode::VarNode,
    ymm28: pcode::VarNode,
    ymm29: pcode::VarNode,
    ymm30: pcode::VarNode,
    ymm31: pcode::VarNode,*/
    /*zmm0: pcode::VarNode,
    zmm1: pcode::VarNode,
    zmm2: pcode::VarNode,
    zmm3: pcode::VarNode,
    zmm4: pcode::VarNode,
    zmm5: pcode::VarNode,
    zmm6: pcode::VarNode,
    zmm7: pcode::VarNode,
    zmm8: pcode::VarNode,
    zmm9: pcode::VarNode,
    zmm10: pcode::VarNode,
    zmm11: pcode::VarNode,
    zmm12: pcode::VarNode,
    zmm13: pcode::VarNode,
    zmm14: pcode::VarNode,
    zmm15: pcode::VarNode,
    zmm16: pcode::VarNode,
    zmm17: pcode::VarNode,
    zmm18: pcode::VarNode,
    zmm19: pcode::VarNode,
    zmm20: pcode::VarNode,
    zmm21: pcode::VarNode,
    zmm22: pcode::VarNode,
    zmm23: pcode::VarNode,
    zmm24: pcode::VarNode,
    zmm25: pcode::VarNode,
    zmm26: pcode::VarNode,
    zmm27: pcode::VarNode,
    zmm28: pcode::VarNode,
    zmm29: pcode::VarNode,
    zmm30: pcode::VarNode,
    zmm31: pcode::VarNode,*/
    r8b: pcode::VarNode,
    r9b: pcode::VarNode,
    r10b: pcode::VarNode,
    r11b: pcode::VarNode,
    r12b: pcode::VarNode,
    r13b: pcode::VarNode,
    r14b: pcode::VarNode,
    r15b: pcode::VarNode,
    r8d: pcode::VarNode,
    r9d: pcode::VarNode,
    r10d: pcode::VarNode,
    r11d: pcode::VarNode,
    r12d: pcode::VarNode,
    r13d: pcode::VarNode,
    r14d: pcode::VarNode,
    r15d: pcode::VarNode,
    r8w: pcode::VarNode,
    r9w: pcode::VarNode,
    r10w: pcode::VarNode,
    r11w: pcode::VarNode,
    r12w: pcode::VarNode,
    r13w: pcode::VarNode,
    r14w: pcode::VarNode,
    r15w: pcode::VarNode,
    fpcw: pcode::VarNode,
    fptag: pcode::VarNode,
    //msr: pcode::VarNode,
    mxcsr: pcode::VarNode,
    fs_base: pcode::VarNode,
    gs_base: pcode::VarNode,
    fip: pcode::VarNode,
    fcs: pcode::VarNode,
    fdp: pcode::VarNode,
    fds: pcode::VarNode,
    fop: pcode::VarNode,
    flags: Vec<pcode::VarNode>,
}

impl X86RegisterNodes {
    pub fn new(arch: &icicle_cpu::Arch) -> Self {
        let r = |name: &str| arch.sleigh.get_reg(name).unwrap().get_raw_var();
        let nodes = [
            "CF", "F1", "PF", "F3", "AF", "F5", "ZF", "SF", "TF", "IF", "DF", "OF", "IOPL", "NT",
            "F15", "RF", "VM", "AC", "VIF", "VIP", "ID",
        ];

        Self {
            rax: r("RAX"),
            rbx: r("RBX"),
            rcx: r("RCX"),
            rdx: r("RDX"),
            rsi: r("RSI"),
            rdi: r("RDI"),
            rbp: r("RBP"),
            rsp: r("RSP"),
            r8: r("R8"),
            r9: r("R9"),
            r10: r("R10"),
            r11: r("R11"),
            r12: r("R12"),
            r13: r("R13"),
            r14: r("R14"),
            r15: r("R15"),
            rip: r("RIP"),
            cs: r("CS"),
            ds: r("DS"),
            es: r("ES"),
            fs: r("FS"),
            gs: r("GS"),
            ss: r("SS"),
            ah: r("AH"),
            al: r("AL"),
            ax: r("AX"),
            bh: r("BH"),
            bl: r("BL"),
            bpl: r("BPL"),
            ch: r("CH"),
            cl: r("CL"),
            cx: r("CX"),
            dh: r("DH"),
            dil: r("DIL"),
            dl: r("DL"),
            dx: r("DX"),
            eax: r("EAX"),
            ebp: r("EBP"),
            ebx: r("EBX"),
            ecx: r("ECX"),
            edi: r("EDI"),
            edx: r("EDX"),
            esi: r("ESI"),
            esp: r("ESP"),
            fpsw: r("FPUStatusWord"),
            gdtr: r("GDTR"),
            idtr: r("IDTR"),
            ldtr: r("LDTR"),
            tr: r("TR"),
            cr0: r("CR0"),
            cr1: r("CR1"),
            cr2: r("CR2"),
            cr3: r("CR3"),
            cr4: r("CR4"),
            cr8: r("CR8"),
            dr0: r("DR0"),
            dr1: r("DR1"),
            dr2: r("DR2"),
            dr3: r("DR3"),
            dr4: r("DR4"),
            dr5: r("DR5"),
            dr6: r("DR6"),
            dr7: r("DR7"),
            fp0: r("ST0"), // ??
            fp1: r("ST1"),
            fp2: r("ST2"),
            fp3: r("ST3"),
            fp4: r("ST4"),
            fp5: r("ST5"),
            fp6: r("ST6"),
            fp7: r("ST7"),
            /*k0: r("K0"),
            k1: r("K1"),
            k2: r("K2"),
            k3: r("K3"),
            k4: r("K4"),
            k5: r("K5"),
            k6: r("K6"),
            k7: r("K7"),*/
            mm0: r("MM0"),
            mm1: r("MM1"),
            mm2: r("MM2"),
            mm3: r("MM3"),
            mm4: r("MM4"),
            mm5: r("MM5"),
            mm6: r("MM6"),
            mm7: r("MM7"),
            st0: r("ST0"),
            st1: r("ST1"),
            st2: r("ST2"),
            st3: r("ST3"),
            st4: r("ST4"),
            st5: r("ST5"),
            st6: r("ST6"),
            st7: r("ST7"),
            xmm0: r("XMM0"),
            xmm1: r("XMM1"),
            xmm2: r("XMM2"),
            xmm3: r("XMM3"),
            xmm4: r("XMM4"),
            xmm5: r("XMM5"),
            xmm6: r("XMM6"),
            xmm7: r("XMM7"),
            xmm8: r("XMM8"),
            xmm9: r("XMM9"),
            xmm10: r("XMM10"),
            xmm11: r("XMM11"),
            xmm12: r("XMM12"),
            xmm13: r("XMM13"),
            xmm14: r("XMM14"),
            xmm15: r("XMM15"),
            /*xmm16: r("XMM16"),
            xmm17: r("XMM17"),
            xmm18: r("XMM18"),
            xmm19: r("XMM19"),
            xmm20: r("XMM20"),
            xmm21: r("XMM21"),
            xmm22: r("XMM22"),
            xmm23: r("XMM23"),
            xmm24: r("XMM24"),
            xmm25: r("XMM25"),
            xmm26: r("XMM26"),
            xmm27: r("XMM27"),
            xmm28: r("XMM28"),
            xmm29: r("XMM29"),
            xmm30: r("XMM30"),
            xmm31: r("XMM31"),*/
            ymm0: r("YMM0"),
            ymm1: r("YMM1"),
            ymm2: r("YMM2"),
            ymm3: r("YMM3"),
            ymm4: r("YMM4"),
            ymm5: r("YMM5"),
            ymm6: r("YMM6"),
            ymm7: r("YMM7"),
            ymm8: r("YMM8"),
            ymm9: r("YMM9"),
            ymm10: r("YMM10"),
            ymm11: r("YMM11"),
            ymm12: r("YMM12"),
            ymm13: r("YMM13"),
            ymm14: r("YMM14"),
            ymm15: r("YMM15"),
            /*ymm16: r("YMM16"),
            ymm17: r("YMM17"),
            ymm18: r("YMM18"),
            ymm19: r("YMM19"),
            ymm20: r("YMM20"),
            ymm21: r("YMM21"),
            ymm22: r("YMM22"),
            ymm23: r("YMM23"),
            ymm24: r("YMM24"),
            ymm25: r("YMM25"),
            ymm26: r("YMM26"),
            ymm27: r("YMM27"),
            ymm28: r("YMM28"),
            ymm29: r("YMM29"),
            ymm30: r("YMM30"),
            ymm31: r("YMM31"),*/
            /*zmm0: r("ZMM0"),
            zmm1: r("ZMM1"),
            zmm2: r("ZMM2"),
            zmm3: r("ZMM3"),
            zmm4: r("ZMM4"),
            zmm5: r("ZMM5"),
            zmm6: r("ZMM6"),
            zmm7: r("ZMM7"),
            zmm8: r("ZMM8"),
            zmm9: r("ZMM9"),
            zmm10: r("ZMM10"),
            zmm11: r("ZMM11"),
            zmm12: r("ZMM12"),
            zmm13: r("ZMM13"),
            zmm14: r("ZMM14"),
            zmm15: r("ZMM15"),
            zmm16: r("ZMM16"),
            zmm17: r("ZMM17"),
            zmm18: r("ZMM18"),
            zmm19: r("ZMM19"),
            zmm20: r("ZMM20"),
            zmm21: r("ZMM21"),
            zmm22: r("ZMM22"),
            zmm23: r("ZMM23"),
            zmm24: r("ZMM24"),
            zmm25: r("ZMM25"),
            zmm26: r("ZMM26"),
            zmm27: r("ZMM27"),
            zmm28: r("ZMM28"),
            zmm29: r("ZMM29"),
            zmm30: r("ZMM30"),
            zmm31: r("ZMM31"),*/
            r8b: r("R8B"),
            r9b: r("R9B"),
            r10b: r("R10B"),
            r11b: r("R11B"),
            r12b: r("R12B"),
            r13b: r("R13B"),
            r14b: r("R14B"),
            r15b: r("R15B"),
            r8d: r("R8D"),
            r9d: r("R9D"),
            r10d: r("R10D"),
            r11d: r("R11D"),
            r12d: r("R12D"),
            r13d: r("R13D"),
            r14d: r("R14D"),
            r15d: r("R15D"),
            r8w: r("R8W"),
            r9w: r("R9W"),
            r10w: r("R10W"),
            r11w: r("R11W"),
            r12w: r("R12W"),
            r13w: r("R13W"),
            r14w: r("R14W"),
            r15w: r("R15W"),
            fpcw: r("FPUControlWord"),
            fptag: r("FPUTagWord"),
            mxcsr: r("MXCSR"),
            fip: r("FPUInstructionPointer"),
            fdp: r("FPUDataPointer"),
            fop: r("FPULastInstructionOpcode"),
            fds: r("DS"), // ?
            fcs: r("CS"), // ?
            //msr: r("MSR"),
            fs_base: r("FS_OFFSET"),
            gs_base: r("GS_OFFSET"),
            flags: nodes.map(|name: &str| r(name)).to_vec(),
        }
    }

    pub fn get_flags(&self, cpu: &mut icicle_cpu::Cpu) -> u64 {
        let mut res: u64 = 0;

        for (index, element) in self.flags.iter().enumerate() {
            let flag = cpu.read_reg(*element);
            res |= (flag & 1) << index;
        }

        res
    }

    pub fn set_flags(&self, cpu: &mut icicle_cpu::Cpu, value: u64) {
        for (index, element) in self.flags.iter().enumerate() {
            let flag = (value >> index) & 1;
            cpu.write_reg(*element, flag);
        }
    }

    pub fn get_node(&self, reg: X86Register) -> pcode::VarNode {
        match reg {
            X86Register::Rax => self.rax,
            X86Register::Rbx => self.rbx,
            X86Register::Rcx => self.rcx,
            X86Register::Rdx => self.rdx,
            X86Register::Rsi => self.rsi,
            X86Register::Rdi => self.rdi,
            X86Register::Rbp => self.rbp,
            X86Register::Rsp => self.rsp,
            X86Register::R8 => self.r8,
            X86Register::R9 => self.r9,
            X86Register::R10 => self.r10,
            X86Register::R11 => self.r11,
            X86Register::R12 => self.r12,
            X86Register::R13 => self.r13,
            X86Register::R14 => self.r14,
            X86Register::R15 => self.r15,
            X86Register::Rip => self.rip,
            X86Register::Cs => self.cs,
            X86Register::Ds => self.ds,
            X86Register::Es => self.es,
            X86Register::Fs => self.fs,
            X86Register::Gs => self.gs,
            X86Register::Ss => self.ss,
            X86Register::Ah => self.ah,
            X86Register::Al => self.al,
            X86Register::Ax => self.ax,
            X86Register::Bh => self.bh,
            X86Register::Bl => self.bl,
            X86Register::Bpl => self.bpl,
            X86Register::Ch => self.ch,
            X86Register::Cl => self.cl,
            X86Register::Cx => self.cx,
            X86Register::Dh => self.dh,
            X86Register::Dil => self.dil,
            X86Register::Dl => self.dl,
            X86Register::Dx => self.dx,
            X86Register::Eax => self.eax,
            X86Register::Ebp => self.ebp,
            X86Register::Ebx => self.ebx,
            X86Register::Ecx => self.ecx,
            X86Register::Edi => self.edi,
            X86Register::Edx => self.edx,
            X86Register::Esi => self.esi,
            X86Register::Esp => self.esp,
            X86Register::Fpsw => self.fpsw,
            X86Register::Gdtr => self.gdtr,
            X86Register::Idtr => self.idtr,
            X86Register::Ldtr => self.ldtr,
            X86Register::Tr => self.tr,
            X86Register::Cr0 => self.cr0,
            X86Register::Cr1 => self.cr1,
            X86Register::Cr2 => self.cr2,
            X86Register::Cr3 => self.cr3,
            X86Register::Cr4 => self.cr4,
            X86Register::Cr8 => self.cr8,
            X86Register::Dr0 => self.dr0,
            X86Register::Dr1 => self.dr1,
            X86Register::Dr2 => self.dr2,
            X86Register::Dr3 => self.dr3,
            X86Register::Dr4 => self.dr4,
            X86Register::Dr5 => self.dr5,
            X86Register::Dr6 => self.dr6,
            X86Register::Dr7 => self.dr7,
            X86Register::Fp0 => self.fp0,
            X86Register::Fp1 => self.fp1,
            X86Register::Fp2 => self.fp2,
            X86Register::Fp3 => self.fp3,
            X86Register::Fp4 => self.fp4,
            X86Register::Fp5 => self.fp5,
            X86Register::Fp6 => self.fp6,
            X86Register::Fp7 => self.fp7,
            /*X86Register::K0 => self.k0,
            X86Register::K1 => self.k1,
            X86Register::K2 => self.k2,
            X86Register::K3 => self.k3,
            X86Register::K4 => self.k4,
            X86Register::K5 => self.k5,
            X86Register::K6 => self.k6,
            X86Register::K7 => self.k7,*/
            X86Register::Mm0 => self.mm0,
            X86Register::Mm1 => self.mm1,
            X86Register::Mm2 => self.mm2,
            X86Register::Mm3 => self.mm3,
            X86Register::Mm4 => self.mm4,
            X86Register::Mm5 => self.mm5,
            X86Register::Mm6 => self.mm6,
            X86Register::Mm7 => self.mm7,
            X86Register::St0 => self.st0,
            X86Register::St1 => self.st1,
            X86Register::St2 => self.st2,
            X86Register::St3 => self.st3,
            X86Register::St4 => self.st4,
            X86Register::St5 => self.st5,
            X86Register::St6 => self.st6,
            X86Register::St7 => self.st7,
            X86Register::Xmm0 => self.xmm0,
            X86Register::Xmm1 => self.xmm1,
            X86Register::Xmm2 => self.xmm2,
            X86Register::Xmm3 => self.xmm3,
            X86Register::Xmm4 => self.xmm4,
            X86Register::Xmm5 => self.xmm5,
            X86Register::Xmm6 => self.xmm6,
            X86Register::Xmm7 => self.xmm7,
            X86Register::Xmm8 => self.xmm8,
            X86Register::Xmm9 => self.xmm9,
            X86Register::Xmm10 => self.xmm10,
            X86Register::Xmm11 => self.xmm11,
            X86Register::Xmm12 => self.xmm12,
            X86Register::Xmm13 => self.xmm13,
            X86Register::Xmm14 => self.xmm14,
            X86Register::Xmm15 => self.xmm15,
            /*X86Register::Xmm16 => self.xmm16,
            X86Register::Xmm17 => self.xmm17,
            X86Register::Xmm18 => self.xmm18,
            X86Register::Xmm19 => self.xmm19,
            X86Register::Xmm20 => self.xmm20,
            X86Register::Xmm21 => self.xmm21,
            X86Register::Xmm22 => self.xmm22,
            X86Register::Xmm23 => self.xmm23,
            X86Register::Xmm24 => self.xmm24,
            X86Register::Xmm25 => self.xmm25,
            X86Register::Xmm26 => self.xmm26,
            X86Register::Xmm27 => self.xmm27,
            X86Register::Xmm28 => self.xmm28,
            X86Register::Xmm29 => self.xmm29,
            X86Register::Xmm30 => self.xmm30,
            X86Register::Xmm31 => self.xmm31,*/
            X86Register::Ymm0 => self.ymm0,
            X86Register::Ymm1 => self.ymm1,
            X86Register::Ymm2 => self.ymm2,
            X86Register::Ymm3 => self.ymm3,
            X86Register::Ymm4 => self.ymm4,
            X86Register::Ymm5 => self.ymm5,
            X86Register::Ymm6 => self.ymm6,
            X86Register::Ymm7 => self.ymm7,
            X86Register::Ymm8 => self.ymm8,
            X86Register::Ymm9 => self.ymm9,
            X86Register::Ymm10 => self.ymm10,
            X86Register::Ymm11 => self.ymm11,
            X86Register::Ymm12 => self.ymm12,
            X86Register::Ymm13 => self.ymm13,
            X86Register::Ymm14 => self.ymm14,
            X86Register::Ymm15 => self.ymm15,
            /*X86Register::Ymm16 => self.ymm16,
            X86Register::Ymm17 => self.ymm17,
            X86Register::Ymm18 => self.ymm18,
            X86Register::Ymm19 => self.ymm19,
            X86Register::Ymm20 => self.ymm20,
            X86Register::Ymm21 => self.ymm21,
            X86Register::Ymm22 => self.ymm22,
            X86Register::Ymm23 => self.ymm23,
            X86Register::Ymm24 => self.ymm24,
            X86Register::Ymm25 => self.ymm25,
            X86Register::Ymm26 => self.ymm26,
            X86Register::Ymm27 => self.ymm27,
            X86Register::Ymm28 => self.ymm28,
            X86Register::Ymm29 => self.ymm29,
            X86Register::Ymm30 => self.ymm30,
            X86Register::Ymm31 => self.ymm31,*/
            /*X86Register::Zmm0 => self.zmm0,
            X86Register::Zmm1 => self.zmm1,
            X86Register::Zmm2 => self.zmm2,
            X86Register::Zmm3 => self.zmm3,
            X86Register::Zmm4 => self.zmm4,
            X86Register::Zmm5 => self.zmm5,
            X86Register::Zmm6 => self.zmm6,
            X86Register::Zmm7 => self.zmm7,
            X86Register::Zmm8 => self.zmm8,
            X86Register::Zmm9 => self.zmm9,
            X86Register::Zmm10 => self.zmm10,
            X86Register::Zmm11 => self.zmm11,
            X86Register::Zmm12 => self.zmm12,
            X86Register::Zmm13 => self.zmm13,
            X86Register::Zmm14 => self.zmm14,
            X86Register::Zmm15 => self.zmm15,
            X86Register::Zmm16 => self.zmm16,
            X86Register::Zmm17 => self.zmm17,
            X86Register::Zmm18 => self.zmm18,
            X86Register::Zmm19 => self.zmm19,
            X86Register::Zmm20 => self.zmm20,
            X86Register::Zmm21 => self.zmm21,
            X86Register::Zmm22 => self.zmm22,
            X86Register::Zmm23 => self.zmm23,
            X86Register::Zmm24 => self.zmm24,
            X86Register::Zmm25 => self.zmm25,
            X86Register::Zmm26 => self.zmm26,
            X86Register::Zmm27 => self.zmm27,
            X86Register::Zmm28 => self.zmm28,
            X86Register::Zmm29 => self.zmm29,
            X86Register::Zmm30 => self.zmm30,
            X86Register::Zmm31 => self.zmm31,*/
            X86Register::R8b => self.r8b,
            X86Register::R9b => self.r9b,
            X86Register::R10b => self.r10b,
            X86Register::R11b => self.r11b,
            X86Register::R12b => self.r12b,
            X86Register::R13b => self.r13b,
            X86Register::R14b => self.r14b,
            X86Register::R15b => self.r15b,
            X86Register::R8d => self.r8d,
            X86Register::R9d => self.r9d,
            X86Register::R10d => self.r10d,
            X86Register::R11d => self.r11d,
            X86Register::R12d => self.r12d,
            X86Register::R13d => self.r13d,
            X86Register::R14d => self.r14d,
            X86Register::R15d => self.r15d,
            X86Register::R8w => self.r8w,
            X86Register::R9w => self.r9w,
            X86Register::R10w => self.r10w,
            X86Register::R11w => self.r11w,
            X86Register::R12w => self.r12w,
            X86Register::R13w => self.r13w,
            X86Register::R14w => self.r14w,
            X86Register::R15w => self.r15w,
            X86Register::Fpcw => self.fpcw,
            X86Register::Fptag => self.fptag,
            //X86Register::Msr => self.msr,
            X86Register::Mxcsr => self.mxcsr,
            X86Register::FsBase => self.fs_base,
            X86Register::GsBase => self.gs_base,
            X86Register::Fip => self.fip,
            X86Register::Fcs => self.fcs,
            X86Register::Fdp => self.fdp,
            X86Register::Fds => self.fds,
            X86Register::Fop => self.fop,
            _ => panic!("Unsupported register"),
        }
    }
}

```

`src/backends/icicle-emulator/icicle_x86_64_emulator.cpp`:

```cpp
#define ICICLE_EMULATOR_IMPL
#include "icicle_x86_64_emulator.hpp"

#include <unordered_set>
#include <utils/object.hpp>
#include <utils/finally.hpp>

using icicle_emulator = struct icicle_emulator_;

extern "C"
{
    using icicle_mmio_read_func = void(void* user, uint64_t address, void* data, size_t length);
    using icicle_mmio_write_func = void(void* user, uint64_t address, const void* data, size_t length);

    using raw_func = void(void*);
    using ptr_func = void(void*, uint64_t);
    using block_func = void(void*, uint64_t, uint64_t);
    using interrupt_func = void(void*, int32_t);
    using violation_func = int32_t(void*, uint64_t address, uint8_t operation, int32_t unmapped);
    using data_accessor_func = void(void* user, const void* data, size_t length);
    using memory_access_func = icicle_mmio_write_func;

    icicle_emulator* icicle_create_emulator();
    int32_t icicle_protect_memory(icicle_emulator*, uint64_t address, uint64_t length, uint8_t permissions);
    int32_t icicle_map_memory(icicle_emulator*, uint64_t address, uint64_t length, uint8_t permissions);
    int32_t icicle_map_mmio(icicle_emulator*, uint64_t address, uint64_t length, icicle_mmio_read_func* read_callback, void* read_data,
                            icicle_mmio_write_func* write_callback, void* write_data);
    int32_t icicle_unmap_memory(icicle_emulator*, uint64_t address, uint64_t length);
    int32_t icicle_read_memory(icicle_emulator*, uint64_t address, void* data, size_t length);
    int32_t icicle_write_memory(icicle_emulator*, uint64_t address, const void* data, size_t length);
    void icicle_save_registers(icicle_emulator*, data_accessor_func* accessor, void* accessor_data);
    void icicle_restore_registers(icicle_emulator*, const void* data, size_t length);
    uint32_t icicle_create_snapshot(icicle_emulator*);
    void icicle_restore_snapshot(icicle_emulator*, uint32_t id);
    uint32_t icicle_add_syscall_hook(icicle_emulator*, raw_func* callback, void* data);
    uint32_t icicle_add_interrupt_hook(icicle_emulator*, interrupt_func* callback, void* data);
    uint32_t icicle_add_block_hook(icicle_emulator*, block_func* callback, void* data);
    uint32_t icicle_add_execution_hook(icicle_emulator*, uint64_t address, ptr_func* callback, void* data);
    uint32_t icicle_add_generic_execution_hook(icicle_emulator*, ptr_func* callback, void* data);
    uint32_t icicle_add_violation_hook(icicle_emulator*, violation_func* callback, void* data);
    uint32_t icicle_add_read_hook(icicle_emulator*, uint64_t start, uint64_t end, memory_access_func* cb, void* data);
    uint32_t icicle_add_write_hook(icicle_emulator*, uint64_t start, uint64_t end, memory_access_func* cb, void* data);
    void icicle_remove_hook(icicle_emulator*, uint32_t id);
    size_t icicle_read_register(icicle_emulator*, int reg, void* data, size_t length);
    size_t icicle_write_register(icicle_emulator*, int reg, const void* data, size_t length);
    void icicle_start(icicle_emulator*, size_t count);
    void icicle_stop(icicle_emulator*);
    void icicle_destroy_emulator(icicle_emulator*);
    void icicle_run_on_next_instruction(icicle_emulator*, raw_func* callback, void* data);
}

namespace icicle
{
    namespace
    {
        void ice(const bool result, const std::string_view error)
        {
            if (!result)
            {
                throw std::runtime_error(std::string(error));
            }
        }

        template <typename T>
        struct function_object : utils::object
        {
            bool* hook_state{};
            std::function<T> func{};

            function_object(std::function<T> f = {}, bool* state = nullptr)
                : hook_state(state),
                  func(std::move(f))
            {
            }

            template <typename... Args>
            auto operator()(Args&&... args) const
            {
                bool old_state{};
                if (this->hook_state)
                {
                    old_state = *this->hook_state;
                    *this->hook_state = true;
                }

                const auto _ = utils::finally([&] {
                    if (this->hook_state)
                    {
                        *this->hook_state = old_state;
                    }
                });

                return this->func.operator()(std::forward<Args>(args)...);
            }

            ~function_object() override = default;
        };

        template <typename T>
        std::unique_ptr<function_object<T>> make_function_object(std::function<T> func, bool& hook_state)
        {
            return std::make_unique<function_object<T>>(std::move(func), &hook_state);
        }

        struct memory_access_hook
        {
            uint64_t address{};
            uint64_t size{};
            memory_access_hook_callback callback{};
            bool is_read{};
        };
    }

    class icicle_x86_64_emulator : public x86_64_emulator
    {
      public:
        icicle_x86_64_emulator()
            : emu_(icicle_create_emulator())
        {
            if (!this->emu_)
            {
                throw std::runtime_error("Failed to create icicle emulator instance");
            }
        }

        ~icicle_x86_64_emulator() override
        {
            reset_object_with_delayed_destruction(this->hooks_);
            reset_object_with_delayed_destruction(this->storage_);
            utils::reset_object_with_delayed_destruction(this->hooks_to_install_);

            if (this->emu_)
            {
                icicle_destroy_emulator(this->emu_);
                this->emu_ = nullptr;
            }
        }

        void start(const size_t count) override
        {
            icicle_start(this->emu_, count);
        }

        void stop() override
        {
            icicle_stop(this->emu_);
        }

        void load_gdt(const pointer_type address, const uint32_t limit) override
        {
            struct gdtr
            {
                uint32_t padding{};
                uint32_t limit{};
                uint64_t address{};
            };

            const gdtr entry{.limit = limit, .address = address};
            static_assert(sizeof(gdtr) - offsetof(gdtr, limit) == 12);

            this->write_register(x86_register::gdtr, &entry.limit, 12);
        }

        void set_segment_base(const x86_register base, const pointer_type value) override
        {
            switch (base)
            {
            case x86_register::fs:
            case x86_register::fs_base:
                this->reg(x86_register::fs_base, value);
                break;
            case x86_register::gs:
            case x86_register::gs_base:
                this->reg(x86_register::gs_base, value);
                break;
            default:
                break;
            }
        }

        pointer_type get_segment_base(const x86_register base) override
        {
            switch (base)
            {
            case x86_register::fs:
            case x86_register::fs_base:
                return this->reg(x86_register::fs_base);
            case x86_register::gs:
            case x86_register::gs_base:
                return this->reg(x86_register::gs_base);
            default:
                return 0;
            }
        }

        size_t write_raw_register(const int reg, const void* value, const size_t size) override
        {
            return icicle_write_register(this->emu_, reg, value, size);
        }

        size_t read_raw_register(const int reg, void* value, const size_t size) override
        {
            return icicle_read_register(this->emu_, reg, value, size);
        }

        bool read_descriptor_table(const int reg, descriptor_table_register& table) override
        {
            if (reg != static_cast<int>(x86_register::gdtr) && reg != static_cast<int>(x86_register::idtr))
            {
                return false;
            }

            struct gdtr
            {
                uint32_t padding{};
                uint32_t limit{};
                uint64_t address{};
            };

            gdtr entry{};
            static_assert(sizeof(gdtr) - offsetof(gdtr, limit) == 12);
            this->read_register(x86_register::gdtr, &entry.limit, 12);

            table.base = entry.address;
            table.limit = entry.limit;
            return true;
        }

        void map_mmio(const uint64_t address, const size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb) override
        {
            struct mmio_wrapper : utils::object
            {
                uint64_t base{};
                mmio_read_callback read_cb{};
                mmio_write_callback write_cb{};
            };

            auto wrapper = std::make_unique<mmio_wrapper>();
            wrapper->base = address;
            wrapper->read_cb = std::move(read_cb);
            wrapper->write_cb = std::move(write_cb);

            auto* ptr = wrapper.get();
            this->storage_.push_back(std::move(wrapper));

            auto* read_wrapper = +[](void* user, const uint64_t addr, void* data, const size_t length) {
                const auto* w = static_cast<mmio_wrapper*>(user);
                w->read_cb(addr - w->base, data, length);
            };

            auto* write_wrapper = +[](void* user, const uint64_t addr, const void* data, const size_t length) {
                const auto* w = static_cast<mmio_wrapper*>(user);
                w->write_cb(addr + w->base, data, length);
            };

            icicle_map_mmio(this->emu_, address, size, read_wrapper, ptr, write_wrapper, ptr);
        }

        void map_memory(const uint64_t address, const size_t size, memory_permission permissions) override
        {
            const auto res = icicle_map_memory(this->emu_, address, size, static_cast<uint8_t>(permissions));
            ice(res, "Failed to map memory");
        }

        void unmap_memory(const uint64_t address, const size_t size) override
        {
            const auto res = icicle_unmap_memory(this->emu_, address, size);
            ice(res, "Failed to unmap memory");
        }

        bool try_read_memory(const uint64_t address, void* data, const size_t size) const override
        {
            return icicle_read_memory(this->emu_, address, data, size);
        }

        void read_memory(const uint64_t address, void* data, const size_t size) const override
        {
            const auto res = this->try_read_memory(address, data, size);
            ice(res, "Failed to read memory");
        }

        bool try_write_memory(const uint64_t address, const void* data, const size_t size) override
        {
            return icicle_write_memory(this->emu_, address, data, size);
        }

        void write_memory(const uint64_t address, const void* data, const size_t size) override
        {
            const auto res = try_write_memory(address, data, size);
            ice(res, "Failed to write memory");
        }

        void apply_memory_protection(const uint64_t address, const size_t size, memory_permission permissions) override
        {
            const auto res = icicle_protect_memory(this->emu_, address, size, static_cast<uint8_t>(permissions));
            ice(res, "Failed to apply permissions");
        }

        emulator_hook* hook_instruction(int instruction_type, instruction_hook_callback callback) override
        {
            if (static_cast<x86_hookable_instructions>(instruction_type) != x86_hookable_instructions::syscall)
            {
                // TODO
                return nullptr;
            }

            auto obj = make_function_object(std::move(callback), this->is_in_hook_);
            auto* ptr = obj.get();

            const auto invoker = +[](void* cb) {
                const auto& func = *static_cast<decltype(ptr)>(cb);
                (void)func(0); //
            };

            const auto id = icicle_add_syscall_hook(this->emu_, invoker, ptr);
            this->hooks_[id] = std::move(obj);

            return wrap_hook(id);
        }

        emulator_hook* hook_basic_block(basic_block_hook_callback callback) override
        {
            auto object = make_function_object(std::move(callback), this->is_in_hook_);
            auto* ptr = object.get();
            auto* wrapper = +[](void* user, const uint64_t addr, const uint64_t instructions) {
                basic_block block{};
                block.address = addr;
                block.instruction_count = static_cast<size_t>(instructions);

                const auto& func = *static_cast<decltype(ptr)>(user);
                (func)(block);
            };

            const auto id = icicle_add_block_hook(this->emu_, wrapper, ptr);
            this->hooks_[id] = std::move(object);

            return wrap_hook(id);
        }

        emulator_hook* hook_interrupt(interrupt_hook_callback callback) override
        {
            auto obj = make_function_object(std::move(callback), this->is_in_hook_);
            auto* ptr = obj.get();
            auto* wrapper = +[](void* user, const int32_t code) {
                const auto& func = *static_cast<decltype(ptr)>(user);
                func(code);
            };

            const auto id = icicle_add_interrupt_hook(this->emu_, wrapper, ptr);
            this->hooks_[id] = std::move(obj);

            return wrap_hook(id);
        }

        emulator_hook* hook_memory_violation(memory_violation_hook_callback callback) override
        {
            auto obj = make_function_object(std::move(callback), this->is_in_hook_);
            auto* ptr = obj.get();
            auto* wrapper = +[](void* user, const uint64_t address, const uint8_t operation, const int32_t unmapped) -> int32_t {
                const auto violation_type = unmapped //
                                                ? memory_violation_type::unmapped
                                                : memory_violation_type::protection;

                const auto& func = *static_cast<decltype(ptr)>(user);
                const auto res = func(address, 1, static_cast<memory_operation>(operation), violation_type);
                const auto restart = res == memory_violation_continuation::restart;
                const auto resume = res == memory_violation_continuation::resume || restart;
                return resume ? 1 : 0;
            };

            const auto id = icicle_add_violation_hook(this->emu_, wrapper, ptr);
            this->hooks_[id] = std::move(obj);

            return wrap_hook(id);
        }

        emulator_hook* hook_memory_execution(const uint64_t address, memory_execution_hook_callback callback) override
        {
            auto object = make_function_object(std::move(callback), this->is_in_hook_);
            auto* ptr = object.get();
            auto* wrapper = +[](void* user, const uint64_t addr) {
                const auto& func = *static_cast<decltype(ptr)>(user);
                (func)(addr);
            };

            const auto id = icicle_add_execution_hook(this->emu_, address, wrapper, ptr);
            this->hooks_[id] = std::move(object);

            return wrap_hook(id);
        }

        emulator_hook* hook_memory_execution(memory_execution_hook_callback callback) override
        {
            auto object = make_function_object(std::move(callback), this->is_in_hook_);
            auto* ptr = object.get();
            auto* wrapper = +[](void* user, const uint64_t addr) {
                const auto& func = *static_cast<decltype(ptr)>(user);
                (func)(addr);
            };

            const auto id = icicle_add_generic_execution_hook(this->emu_, wrapper, ptr);
            this->hooks_[id] = std::move(object);

            return wrap_hook(id);
        }

        emulator_hook* hook_memory_read(const uint64_t address, const uint64_t size, memory_access_hook_callback callback) override
        {
            return this->try_install_memory_access_hook(memory_access_hook{
                .address = address,
                .size = size,
                .callback = std::move(callback),
                .is_read = true,
            });
        }

        emulator_hook* hook_memory_write(const uint64_t address, const uint64_t size, memory_access_hook_callback callback) override
        {
            return this->try_install_memory_access_hook(memory_access_hook{
                .address = address,
                .size = size,
                .callback = std::move(callback),
                .is_read = false,
            });
        }

        void delete_hook(emulator_hook* hook) override
        {
            if (this->is_in_hook_)
            {
                this->hooks_to_delete_.insert(hook);
                this->schedule_action_execution();
            }
            else
            {
                this->delete_hook_internal(hook);
            }
        }

        void serialize_state(utils::buffer_serializer& buffer, const bool is_snapshot) const override
        {
            if (is_snapshot)
            {
                const auto snapshot = icicle_create_snapshot(this->emu_);
                buffer.write<uint32_t>(snapshot);
            }
            else
            {
                buffer.write_vector(this->save_registers());
            }
        }

        void deserialize_state(utils::buffer_deserializer& buffer, const bool is_snapshot) override
        {
            if (is_snapshot)
            {
                const auto snapshot = buffer.read<uint32_t>();
                icicle_restore_snapshot(this->emu_, snapshot);
            }
            else
            {
                const auto data = buffer.read_vector<std::byte>();
                this->restore_registers(data);
            }
        }

        std::vector<std::byte> save_registers() const override
        {
            std::vector<std::byte> data{};
            auto* accessor = +[](void* user, const void* data, const size_t length) {
                auto& vec = *static_cast<std::vector<std::byte>*>(user);
                vec.resize(length);
                memcpy(vec.data(), data, length);
            };

            icicle_save_registers(this->emu_, accessor, &data);

            return data;
        }

        void restore_registers(const std::vector<std::byte>& register_data) override
        {
            icicle_restore_registers(this->emu_, register_data.data(), register_data.size());
        }

        bool has_violation() const override
        {
            return false;
        }

        std::string get_name() const override
        {
            return "icicle-emu";
        }

      private:
        bool is_in_hook_{false};
        std::list<std::unique_ptr<utils::object>> storage_{};
        std::unordered_map<uint32_t, std::unique_ptr<utils::object>> hooks_{};
        std::unordered_map<emulator_hook*, std::optional<uint32_t>> id_mapping_{};
        icicle_emulator* emu_{};
        uint32_t index_{0};

        std::unordered_set<emulator_hook*> hooks_to_delete_{};
        std::unordered_map<emulator_hook*, memory_access_hook> hooks_to_install_{};

        emulator_hook* wrap_hook(const std::optional<uint32_t> icicle_id)
        {
            const auto id = ++this->index_;
            auto* hook = reinterpret_cast<emulator_hook*>(static_cast<size_t>(id));

            this->id_mapping_[hook] = icicle_id;

            return hook;
        }

        emulator_hook* hook_memory_access(memory_access_hook hook, emulator_hook* hook_id)
        {
            auto obj = make_function_object(std::move(hook.callback), this->is_in_hook_);
            auto* ptr = obj.get();
            auto* wrapper = +[](void* user, const uint64_t address, const void* data, size_t length) {
                const auto& func = *static_cast<decltype(ptr)>(user);
                func(address, data, length);
            };

            auto* installer = hook.is_read ? &icicle_add_read_hook : &icicle_add_write_hook;
            const auto id = installer(this->emu_, hook.address, hook.address + hook.size, wrapper, ptr);
            this->hooks_[id] = std::move(obj);

            if (hook_id)
            {
                this->id_mapping_[hook_id] = id;
                return hook_id;
            }

            return wrap_hook(id);
        }

        void delete_hook_internal(emulator_hook* hook)
        {
            auto hook_id = this->id_mapping_.find(hook);
            if (hook_id == this->id_mapping_.end())
            {
                return;
            }

            if (!hook_id->second.has_value())
            {
                this->hooks_to_delete_.insert(hook);
                return;
            }

            const auto id = *hook_id->second;
            this->id_mapping_.erase(hook_id);

            const auto entry = this->hooks_.find(id);
            if (entry == this->hooks_.end())
            {
                return;
            }

            icicle_remove_hook(this->emu_, id);
            const auto obj = std::move(entry->second);
            this->hooks_.erase(entry);
            (void)obj;
        }

        void perform_pending_actions()
        {
            auto hooks_to_install = std::move(this->hooks_to_install_);
            const auto hooks_to_delete = std::move(this->hooks_to_delete_);

            this->hooks_to_delete_ = {};
            this->hooks_to_install_ = {};

            for (auto& hook : hooks_to_install)
            {
                this->hook_memory_access(std::move(hook.second), hook.first);
            }

            for (auto* hook : hooks_to_delete)
            {
                this->delete_hook_internal(hook);
            }
        }

        emulator_hook* try_install_memory_access_hook(memory_access_hook hook)
        {
            if (!this->is_in_hook_)
            {
                return this->hook_memory_access(std::move(hook), nullptr);
            }

            auto* hook_id = wrap_hook(std::nullopt);
            this->hooks_to_install_[hook_id] = std::move(hook);

            this->schedule_action_execution();

            return hook_id;
        }

        void schedule_action_execution()
        {
            this->run_on_next_instruction([this] {
                this->perform_pending_actions(); //
            });
        }

        void run_on_next_instruction(std::function<void()> func) const
        {
            auto* heap_func = new std::function(std::move(func));
            auto* callback = +[](void* data) {
                auto* cb = static_cast<std::function<void()>*>(data);

                try
                {
                    (*cb)();
                }
                catch (...)
                {
                    // Ignore
                }

                delete cb;
            };

            icicle_run_on_next_instruction(this->emu_, callback, heap_func);
        }
    };

    std::unique_ptr<x86_64_emulator> create_x86_64_emulator()
    {
        return std::make_unique<icicle_x86_64_emulator>();
    }
}

```

`src/backends/icicle-emulator/icicle_x86_64_emulator.hpp`:

```hpp
#pragma once

#include <memory>
#include <arch_emulator.hpp>
#include "platform/platform.hpp"

#ifdef ICICLE_EMULATOR_IMPL
#define ICICLE_EMULATOR_DLL_STORAGE EXPORT_SYMBOL
#else
#define ICICLE_EMULATOR_DLL_STORAGE IMPORT_SYMBOL
#endif

namespace icicle
{
#if !SOGEN_BUILD_STATIC
    ICICLE_EMULATOR_DLL_STORAGE
#endif
    std::unique_ptr<x86_64_emulator> create_x86_64_emulator();
}

```

`src/backends/unicorn-emulator/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

if(SOGEN_BUILD_STATIC)
	add_library(unicorn-emulator STATIC ${SRC_FILES})
else()
    add_library(unicorn-emulator SHARED ${SRC_FILES})
endif()

target_include_directories(unicorn-emulator INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

target_link_libraries(unicorn-emulator PUBLIC emulator)
target_link_libraries(unicorn-emulator PRIVATE unicorn emulator-common)

momo_strip_target(unicorn-emulator)

```

`src/backends/unicorn-emulator/function_wrapper.hpp`:

```hpp
#pragma once

#include <memory>
#include <functional>

#include <utils/object.hpp>

template <typename ReturnType, typename... Args>
class function_wrapper : public utils::object
{
  public:
    using user_data_pointer = void*;
    using c_function_type = ReturnType(Args..., user_data_pointer);
    using functor_type = std::function<ReturnType(Args...)>;

    function_wrapper() = default;

    function_wrapper(functor_type functor)
        : functor_(std::make_unique<functor_type>(std::move(functor)))
    {
    }

    c_function_type* get_c_function() const
    {
        return +[](Args... args, user_data_pointer user_data) -> ReturnType {
            return (*static_cast<functor_type*>(user_data))(std::forward<Args>(args)...);
        };
    }

    void* get_function() const
    {
        return reinterpret_cast<void*>(this->get_c_function());
    }

    user_data_pointer get_user_data() const
    {
        return this->functor_.get();
    }

  private:
    std::unique_ptr<functor_type> functor_{};
};

```

`src/backends/unicorn-emulator/unicorn.hpp`:

```hpp
#pragma once

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4505)
#endif

#ifdef __clang__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif

#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <unicorn/unicorn.h>

#ifdef __clang__
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#include <stdexcept>

namespace unicorn
{
    struct unicorn_error : std::runtime_error
    {
        unicorn_error(const uc_err error_code)
            : std::runtime_error(uc_strerror(error_code)),
              code(error_code)
        {
        }

        uc_err code{};
    };

    inline void throw_if_unicorn_error(const uc_err error_code)
    {
        if (error_code != UC_ERR_OK)
        {
            throw unicorn_error(error_code);
        }
    }

    inline void uce(const uc_err error_code)
    {
        throw_if_unicorn_error(error_code);
    }
}

```

`src/backends/unicorn-emulator/unicorn_hook.hpp`:

```hpp
#pragma once

#include "unicorn.hpp"

namespace unicorn
{
    class unicorn_hook
    {
      public:
        unicorn_hook() = default;

        unicorn_hook(uc_engine* uc)
            : unicorn_hook(uc, {})
        {
        }

        unicorn_hook(uc_engine* uc, const uc_hook hook)
            : uc_(uc),
              hook_(hook)
        {
        }

        ~unicorn_hook()
        {
            release();
        }

        unicorn_hook(const unicorn_hook&) = delete;
        unicorn_hook& operator=(const unicorn_hook&) = delete;

        unicorn_hook(unicorn_hook&& obj) noexcept
        {
            this->operator=(std::move(obj));
        }

        uc_hook* make_reference()
        {
            if (!this->uc_)
            {
                throw std::runtime_error("Cannot make reference on default constructed hook");
            }

            this->release();
            return &this->hook_;
        }

        unicorn_hook& operator=(unicorn_hook&& obj) noexcept
        {
            if (this != &obj)
            {
                this->release();

                this->uc_ = obj.uc_;
                this->hook_ = obj.hook_;

                obj.hook_ = {};
                obj.uc_ = {};
            }

            return *this;
        }

        void release()
        {
            if (this->hook_ && this->uc_)
            {
                uc_hook_del(this->uc_, this->hook_);
                this->hook_ = {};
            }
        }

      private:
        uc_engine* uc_{};
        uc_hook hook_{};
    };
}

```

`src/backends/unicorn-emulator/unicorn_memory_regions.hpp`:

```hpp
#pragma once

#include <span>

#include "unicorn.hpp"

namespace unicorn
{
    class unicorn_memory_regions
    {
      public:
        unicorn_memory_regions(uc_engine* uc)
        {
            uce(uc_mem_regions(uc, &this->regions_, &this->count_));
        }

        ~unicorn_memory_regions()
        {
            this->release();
        }

        unicorn_memory_regions(const unicorn_memory_regions&) = delete;
        unicorn_memory_regions& operator=(const unicorn_memory_regions&) = delete;

        unicorn_memory_regions(unicorn_memory_regions&& obj) noexcept
        {
            this->operator=(std::move(obj));
        }

        unicorn_memory_regions& operator=(unicorn_memory_regions&& obj) noexcept
        {
            if (this != &obj)
            {
                this->release();

                this->count_ = obj.count_;
                this->regions_ = obj.regions_;

                obj.count_ = {};
                obj.regions_ = nullptr;
            }

            return *this;
        }

        std::span<uc_mem_region> get_span() const
        {
            return {this->regions_, this->count_};
        }

      private:
        uint32_t count_{};
        uc_mem_region* regions_{};

        void release()
        {
            if (this->regions_)
            {
                uc_free(regions_);
            }

            this->count_ = {};
            this->regions_ = nullptr;
        }
    };
}

```

`src/backends/unicorn-emulator/unicorn_x86_64_emulator.cpp`:

```cpp
#define UNICORN_EMULATOR_IMPL
#include "unicorn_x86_64_emulator.hpp"

#include <array>
#include <ranges>
#include <optional>

#include "unicorn_memory_regions.hpp"
#include "unicorn_hook.hpp"

#include "function_wrapper.hpp"

namespace unicorn
{
    namespace
    {
        static_assert(static_cast<uint32_t>(memory_permission::none) == UC_PROT_NONE);
        static_assert(static_cast<uint32_t>(memory_permission::read) == UC_PROT_READ);
        static_assert(static_cast<uint32_t>(memory_permission::exec) == UC_PROT_EXEC);
        static_assert(static_cast<uint32_t>(memory_permission::all) == UC_PROT_ALL);

        static_assert(static_cast<uint32_t>(x86_register::end) == UC_X86_REG_ENDING);

        constexpr auto IA32_FS_BASE_MSR = 0xC0000100;
        constexpr auto IA32_GS_BASE_MSR = 0xC0000101;

        struct msr_value
        {
            uint64_t id{};
            uint64_t value{};
        };

        uc_x86_insn map_hookable_instruction(const x86_hookable_instructions instruction)
        {
            switch (instruction)
            {
            case x86_hookable_instructions::syscall:
                return UC_X86_INS_SYSCALL;
            case x86_hookable_instructions::cpuid:
                return UC_X86_INS_CPUID;
            case x86_hookable_instructions::rdtsc:
                return UC_X86_INS_RDTSC;
            case x86_hookable_instructions::rdtscp:
                return UC_X86_INS_RDTSCP;
            default:
                throw std::runtime_error("Bad instruction for mapping");
            }
        }

        memory_violation_type map_memory_violation_type(const uc_mem_type mem_type)
        {
            switch (mem_type)
            {
            case UC_MEM_READ_PROT:
            case UC_MEM_WRITE_PROT:
            case UC_MEM_FETCH_PROT:
                return memory_violation_type::protection;
            case UC_MEM_READ_UNMAPPED:
            case UC_MEM_WRITE_UNMAPPED:
            case UC_MEM_FETCH_UNMAPPED:
                return memory_violation_type::unmapped;
            default:
                throw std::runtime_error("Memory type does not constitute a violation");
            }
        }

        memory_operation map_memory_operation(const uc_mem_type mem_type)
        {
            switch (mem_type)
            {
            case UC_MEM_READ:
            case UC_MEM_READ_PROT:
            case UC_MEM_READ_AFTER:
            case UC_MEM_READ_UNMAPPED:
                return memory_operation::read;
            case UC_MEM_WRITE:
            case UC_MEM_WRITE_PROT:
            case UC_MEM_WRITE_UNMAPPED:
                return memory_operation::write;
            case UC_MEM_FETCH:
            case UC_MEM_FETCH_PROT:
            case UC_MEM_FETCH_UNMAPPED:
                return memory_operation::exec;
            default:
                return memory_operation::none;
            }
        }

        struct hook_object : utils::object
        {
            emulator_hook* as_opaque_hook()
            {
                return reinterpret_cast<emulator_hook*>(this);
            }
        };

        class hook_container : public hook_object
        {
          public:
            template <typename T>
                requires(std::is_base_of_v<utils::object, T> && std::is_move_constructible_v<T>)
            void add(T data, unicorn_hook hook)
            {
                hook_entry entry{};

                entry.data = std::make_unique<T>(std::move(data));
                entry.hook = std::move(hook);

                this->hooks_.emplace_back(std::move(entry));
            }

          private:
            struct hook_entry
            {
                std::unique_ptr<utils::object> data{};
                unicorn_hook hook{};
            };

            std::vector<hook_entry> hooks_;
        };

        struct mmio_callbacks
        {
            using read_wrapper = function_wrapper<uint64_t, uc_engine*, uint64_t, unsigned>;
            using write_wrapper = function_wrapper<void, uc_engine*, uint64_t, unsigned, uint64_t>;

            read_wrapper read{};
            write_wrapper write{};
        };

        class uc_context_serializer
        {
          public:
            uc_context_serializer(uc_engine* uc, const bool in_place)
                : uc_(uc)
            {
                if (in_place)
                {
                    // Unicorn stores pointers in the struct. The serialization here is broken
                    throw std::runtime_error("Memory saving not supported atm");
                }

#ifndef OS_WINDOWS
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif

                uc_ctl_context_mode(uc, UC_CTL_CONTEXT_CPU | (in_place ? UC_CTL_CONTEXT_MEMORY : 0));

#ifndef OS_WINDOWS
#pragma GCC diagnostic pop
#endif

                this->size_ = uc_context_size(uc);
                uce(uc_context_alloc(uc, &this->context_));
            }

            ~uc_context_serializer()
            {
                if (this->context_)
                {
                    (void)uc_context_free(this->context_);
                }
            }

            void serialize(utils::buffer_serializer& buffer) const
            {
                uce(uc_context_save(this->uc_, this->context_));
                buffer.write(this->context_, this->size_);
            }

            void deserialize(utils::buffer_deserializer& buffer) const
            {
                buffer.read(this->context_, this->size_);
                uce(uc_context_restore(this->uc_, this->context_));
            }

            uc_context_serializer(uc_context_serializer&&) = delete;
            uc_context_serializer(const uc_context_serializer&) = delete;
            uc_context_serializer& operator=(uc_context_serializer&&) = delete;
            uc_context_serializer& operator=(const uc_context_serializer&) = delete;

          private:
            uc_engine* uc_{};
            uc_context* context_{};
            size_t size_{};
        };

        void assert_64bit_limit(const size_t size)
        {
            if (size > sizeof(uint64_t))
            {
                throw std::runtime_error("Exceeded uint64_t size limit");
            }
        }

        class unicorn_x86_64_emulator : public x86_64_emulator
        {
          public:
            unicorn_x86_64_emulator()
            {
                uce(uc_open(UC_ARCH_X86, UC_MODE_64, &this->uc_));
                // uce(uc_ctl_set_cpu_model(this->uc_, UC_CPU_X86_EPYC_ROME));

#ifndef OS_WINDOWS
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
                constexpr auto is_64_bit = sizeof(void*) >= 8;
                uce(uc_ctl_set_tcg_buffer_size(this->uc_, (is_64_bit ? 2 : 1) << 30 /* 2 gb */));

#ifndef OS_WINDOWS
#pragma GCC diagnostic pop
#endif
            }

            ~unicorn_x86_64_emulator() override
            {
                reset_object_with_delayed_destruction(this->hooks_);
                uc_close(this->uc_);
            }

            void start(const size_t count) override
            {
                const auto start = this->violation_ip_.value_or(this->read_instruction_pointer());
                this->violation_ip_ = std::nullopt;

                constexpr auto end = std::numeric_limits<uint64_t>::max();
                const auto res = uc_emu_start(*this, start, end, 0, count);
                if (res == UC_ERR_OK)
                {
                    return;
                }

                const auto is_violation =           //
                    res == UC_ERR_READ_UNMAPPED ||  //
                    res == UC_ERR_WRITE_UNMAPPED || //
                    res == UC_ERR_FETCH_UNMAPPED || //
                    res == UC_ERR_READ_PROT ||      //
                    res == UC_ERR_WRITE_PROT ||     //
                    res == UC_ERR_FETCH_PROT;

                if (!is_violation || !this->has_violation())
                {
                    uce(res);
                }
            }

            void stop() override
            {
                uce(uc_emu_stop(*this));
            }

            void load_gdt(const pointer_type address, const uint32_t limit) override
            {
                uc_x86_mmr gdt{};
                gdt.base = address;
                gdt.limit = limit;

                this->write_register(x86_register::gdtr, &gdt, sizeof(gdt));
            }

            void set_segment_base(const x86_register base, const pointer_type value) override
            {
                msr_value msr_val{
                    .id = 0,
                    .value = value,
                };

                switch (base)
                {
                case x86_register::fs:
                case x86_register::fs_base:
                    msr_val.id = IA32_FS_BASE_MSR;
                    break;
                case x86_register::gs:
                case x86_register::gs_base:
                    msr_val.id = IA32_GS_BASE_MSR;
                    break;
                default:
                    return;
                }

                this->write_register(x86_register::msr, &msr_val, sizeof(msr_val));
            }

            pointer_type get_segment_base(const x86_register base) override
            {
                msr_value msr_val{};

                switch (base)
                {
                case x86_register::fs:
                case x86_register::fs_base:
                    msr_val.id = IA32_FS_BASE_MSR;
                    break;
                case x86_register::gs:
                case x86_register::gs_base:
                    msr_val.id = IA32_GS_BASE_MSR;
                    break;
                default:
                    return 0;
                }

                size_t result_size = sizeof(msr_value);
                uce(uc_reg_read2(*this, (int)x86_register::msr, &msr_val, &result_size));

                return msr_val.value;
            }

            size_t write_raw_register(const int reg, const void* value, const size_t size) override
            {
                auto result_size = size;
                uce(uc_reg_write2(*this, reg, value, &result_size));

                if (size < result_size)
                {
                    throw std::runtime_error("Register size mismatch: " + std::to_string(size) + " != " + std::to_string(result_size));
                }

                return result_size;
            }

            size_t read_raw_register(const int reg, void* value, const size_t size) override
            {
                size_t result_size = size;
                memset(value, 0, size);
                uce(uc_reg_read2(*this, reg, value, &result_size));

                if (size < result_size)
                {
                    throw std::runtime_error("Register size mismatch: " + std::to_string(size) + " != " + std::to_string(result_size));
                }

                return result_size;
            }

            bool read_descriptor_table(const int reg, descriptor_table_register& table) override
            {
                if (reg != static_cast<int>(x86_register::gdtr) && reg != static_cast<int>(x86_register::idtr))
                {
                    return false;
                }

                uc_x86_mmr gdt{};

                this->read_register(x86_register::gdtr, &gdt, sizeof(gdt));

                table.base = gdt.base;
                table.limit = gdt.limit;
                return true;
            }

            void map_mmio(const uint64_t address, const size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb) override
            {
                auto read_wrapper = [c = std::move(read_cb)](uc_engine*, const uint64_t addr, const uint32_t s) {
                    assert_64bit_limit(s);
                    uint64_t value{};
                    c(addr, &value, s);
                    return value;
                };

                auto write_wrapper = [c = std::move(write_cb)](uc_engine*, const uint64_t addr, const uint32_t s, const uint64_t value) {
                    assert_64bit_limit(s);
                    c(addr, &value, s);
                };

                mmio_callbacks cb{
                    .read = mmio_callbacks::read_wrapper(std::move(read_wrapper)),
                    .write = mmio_callbacks::write_wrapper(std::move(write_wrapper)),
                };

                uce(uc_mmio_map(*this, address, size, cb.read.get_c_function(), cb.read.get_user_data(), cb.write.get_c_function(),
                                cb.write.get_user_data()));

                this->mmio_[address] = std::move(cb);
            }

            void map_memory(const uint64_t address, const size_t size, memory_permission permissions) override
            {
                uce(uc_mem_map(*this, address, size, static_cast<uint32_t>(permissions)));
            }

            void unmap_memory(const uint64_t address, const size_t size) override
            {
                uce(uc_mem_unmap(*this, address, size));

                const auto mmio_entry = this->mmio_.find(address);
                if (mmio_entry != this->mmio_.end())
                {
                    this->mmio_.erase(mmio_entry);
                }
            }

            bool try_read_memory(const uint64_t address, void* data, const size_t size) const override
            {
                return uc_mem_read(*this, address, data, size) == UC_ERR_OK;
            }

            void read_memory(const uint64_t address, void* data, const size_t size) const override
            {
                uce(uc_mem_read(*this, address, data, size));
            }

            bool try_write_memory(const uint64_t address, const void* data, const size_t size) override
            {
                return uc_mem_write(*this, address, data, size) == UC_ERR_OK;
            }

            void write_memory(const uint64_t address, const void* data, const size_t size) override
            {
                uce(uc_mem_write(*this, address, data, size));
            }

            void apply_memory_protection(const uint64_t address, const size_t size, memory_permission permissions) override
            {
                uce(uc_mem_protect(*this, address, size, static_cast<uint32_t>(permissions)));
            }

            emulator_hook* hook_instruction(const int instruction_type, instruction_hook_callback callback) override
            {
                unicorn_hook hook{*this};
                auto container = std::make_unique<hook_container>();

                const auto inst_type = static_cast<x86_hookable_instructions>(instruction_type);

                if (inst_type == x86_hookable_instructions::invalid)
                {
                    function_wrapper<int, uc_engine*> wrapper([c = std::move(callback)](uc_engine*) {
                        return (c(0) == instruction_hook_continuation::skip_instruction) ? 1 : 0;
                    });

                    uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INSN_INVALID, wrapper.get_function(), wrapper.get_user_data(), 0,
                                    std::numeric_limits<pointer_type>::max()));
                    container->add(std::move(wrapper), std::move(hook));
                }
                else if (inst_type == x86_hookable_instructions::syscall)
                {
                    function_wrapper<void, uc_engine*> wrapper([c = std::move(callback)](uc_engine*) { (void)c(0); });

                    const auto uc_instruction = map_hookable_instruction(inst_type);
                    uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INSN, wrapper.get_function(), wrapper.get_user_data(), 0,
                                    std::numeric_limits<pointer_type>::max(), uc_instruction));

                    container->add(std::move(wrapper), std::move(hook));
                }
                else
                {
                    function_wrapper<int, uc_engine*> wrapper([c = std::move(callback)](uc_engine*) {
                        return (c(0) == instruction_hook_continuation::skip_instruction) ? 1 : 0;
                    });

                    const auto uc_instruction = map_hookable_instruction(inst_type);
                    uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INSN, wrapper.get_function(), wrapper.get_user_data(), 0,
                                    std::numeric_limits<pointer_type>::max(), uc_instruction));

                    container->add(std::move(wrapper), std::move(hook));
                }

                auto* result = container->as_opaque_hook();

                this->hooks_.push_back(std::move(container));

                return result;
            }

            emulator_hook* hook_basic_block(basic_block_hook_callback callback) override
            {
                function_wrapper<void, uc_engine*, uint64_t, size_t> wrapper(
                    [c = std::move(callback)](uc_engine*, const uint64_t address, const size_t size) {
                        basic_block block{};
                        block.address = address;
                        block.size = size;

                        c(block);
                    });

                unicorn_hook hook{*this};
                auto container = std::make_unique<hook_container>();

                uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_BLOCK, wrapper.get_function(), wrapper.get_user_data(), 0,
                                std::numeric_limits<pointer_type>::max()));

                container->add(std::move(wrapper), std::move(hook));

                auto* result = container->as_opaque_hook();
                this->hooks_.push_back(std::move(container));
                return result;
            }

            emulator_hook* hook_interrupt(interrupt_hook_callback callback) override
            {
                function_wrapper<void, uc_engine*, int> wrapper(
                    [c = std::move(callback)](uc_engine*, const int interrupt_type) { c(interrupt_type); });

                unicorn_hook hook{*this};
                auto container = std::make_unique<hook_container>();

                uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_INTR, wrapper.get_function(), wrapper.get_user_data(), 0,
                                std::numeric_limits<pointer_type>::max()));

                container->add(std::move(wrapper), std::move(hook));

                auto* result = container->as_opaque_hook();
                this->hooks_.push_back(std::move(container));
                return result;
            }

            emulator_hook* hook_memory_violation(memory_violation_hook_callback callback) override
            {
                function_wrapper<bool, uc_engine*, uc_mem_type, uint64_t, int, int64_t> wrapper(
                    [c = std::move(callback), this](uc_engine*, const uc_mem_type type, const uint64_t address, const int size,
                                                    const int64_t) {
                        const auto ip = this->read_instruction_pointer();

                        assert(size >= 0);
                        const auto operation = map_memory_operation(type);
                        const auto violation = map_memory_violation_type(type);

                        const auto result = c(address, static_cast<uint64_t>(size), operation, violation);
                        const auto restart = result == memory_violation_continuation::restart;
                        const auto resume = result == memory_violation_continuation::resume || restart;

                        const auto new_ip = this->read_instruction_pointer();
                        const auto set_ip = ip != new_ip || restart;

                        if (!resume)
                        {
                            return false;
                        }

                        if (resume && set_ip)
                        {
                            this->violation_ip_ = new_ip;
                        }
                        else
                        {
                            this->violation_ip_ = std::nullopt;
                        }

                        if (set_ip)
                        {
                            return false;
                        }

                        return true;
                    });

                unicorn_hook hook{*this};
                auto container = std::make_unique<hook_container>();

                uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_MEM_INVALID, wrapper.get_function(), wrapper.get_user_data(), 0,
                                std::numeric_limits<uint64_t>::max()));

                container->add(std::move(wrapper), std::move(hook));

                auto* result = container->as_opaque_hook();
                this->hooks_.push_back(std::move(container));
                return result;
            }

            emulator_hook* hook_memory_execution(const uint64_t address, const uint64_t size, memory_execution_hook_callback callback)
            {
                auto exec_wrapper = [c = std::move(callback)](uc_engine*, const uint64_t address, const uint32_t /*size*/) {
                    c(address); //
                };

                function_wrapper<void, uc_engine*, uint64_t, uint32_t> wrapper(std::move(exec_wrapper));

                unicorn_hook hook{*this};

                uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_CODE, wrapper.get_function(), wrapper.get_user_data(), address,
                                calc_end_address(address, size)));

                auto* container = this->create_hook_container();
                container->add(std::move(wrapper), std::move(hook));
                return container->as_opaque_hook();
            }

            emulator_hook* hook_memory_execution(memory_execution_hook_callback callback) override
            {
                return this->hook_memory_execution(0, std::numeric_limits<uint64_t>::max(), std::move(callback));
            }

            emulator_hook* hook_memory_execution(const uint64_t address, memory_execution_hook_callback callback) override
            {
                return this->hook_memory_execution(address, 1, std::move(callback));
            }

            emulator_hook* hook_memory_read(const uint64_t address, const uint64_t size, memory_access_hook_callback callback) override
            {
                auto read_wrapper = [c = std::move(callback)](uc_engine*, const uc_mem_type type, const uint64_t address, const int length,
                                                              const uint64_t value) {
                    const auto operation = map_memory_operation(type);
                    if (operation == memory_operation::read && length > 0)
                    {
                        c(address, &value, std::min(static_cast<size_t>(length), sizeof(value)));
                    }
                };

                function_wrapper<void, uc_engine*, uc_mem_type, uint64_t, int, int64_t> wrapper(std::move(read_wrapper));

                unicorn_hook hook{*this};

                uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_MEM_READ_AFTER, wrapper.get_function(), wrapper.get_user_data(),
                                address, calc_end_address(address, size)));

                auto* container = this->create_hook_container();
                container->add(std::move(wrapper), std::move(hook));
                return container->as_opaque_hook();
            }

            emulator_hook* hook_memory_write(const uint64_t address, const uint64_t size, memory_access_hook_callback callback) override
            {
                auto write_wrapper = [c = std::move(callback)](uc_engine*, const uc_mem_type type, const uint64_t addr, const int length,
                                                               const uint64_t value) {
                    const auto operation = map_memory_operation(type);
                    if (operation == memory_operation::write && length > 0)
                    {
                        c(addr, &value, std::min(static_cast<size_t>(length), sizeof(value)));
                    }
                };

                function_wrapper<void, uc_engine*, uc_mem_type, uint64_t, int, int64_t> wrapper(std::move(write_wrapper));

                unicorn_hook hook{*this};

                uce(uc_hook_add(*this, hook.make_reference(), UC_HOOK_MEM_WRITE, wrapper.get_function(), wrapper.get_user_data(), address,
                                calc_end_address(address, size)));

                auto* container = this->create_hook_container();
                container->add(std::move(wrapper), std::move(hook));
                return container->as_opaque_hook();
            }

            hook_container* create_hook_container()
            {
                auto container = std::make_unique<hook_container>();
                auto* ptr = container.get();
                this->hooks_.push_back(std::move(container));
                return ptr;
            }

            void delete_hook(emulator_hook* hook) override
            {
                const auto entry = std::ranges::find_if(
                    this->hooks_, [&](const std::unique_ptr<hook_object>& hook_ptr) { return hook_ptr->as_opaque_hook() == hook; });

                if (entry != this->hooks_.end())
                {
                    const auto obj = std::move(*entry);
                    this->hooks_.erase(entry);
                    (void)obj;
                }
            }

            operator uc_engine*() const
            {
                return this->uc_;
            }

            void serialize_state(utils::buffer_serializer& buffer, const bool is_snapshot) const override
            {
                if (this->has_snapshots_ && !is_snapshot)
                {
                    // TODO: Investigate if this is really necessary
                    throw std::runtime_error("Unable to serialize after snapshot was taken!");
                }

                this->has_snapshots_ |= is_snapshot;

                const uc_context_serializer serializer(this->uc_, is_snapshot);
                serializer.serialize(buffer);
            }

            void deserialize_state(utils::buffer_deserializer& buffer, const bool is_snapshot) override
            {
                if (this->has_snapshots_ && !is_snapshot)
                {
                    // TODO: Investigate if this is really necessary
                    throw std::runtime_error("Unable to deserialize after snapshot was taken!");
                }

                const uc_context_serializer serializer(this->uc_, is_snapshot);
                serializer.deserialize(buffer);
            }

            std::vector<std::byte> save_registers() const override
            {
                utils::buffer_serializer buffer{};
                const uc_context_serializer serializer(this->uc_, false);
                serializer.serialize(buffer);
                return buffer.move_buffer();
            }

            void restore_registers(const std::vector<std::byte>& register_data) override
            {
                utils::buffer_deserializer buffer{register_data};
                const uc_context_serializer serializer(this->uc_, false);
                serializer.deserialize(buffer);
            }

            bool has_violation() const override
            {
                return this->violation_ip_.has_value();
            }

            std::string get_name() const override
            {
                return "Unicorn Engine";
            }

          private:
            mutable bool has_snapshots_{false};
            uc_engine* uc_{};
            std::optional<uint64_t> violation_ip_{};
            std::vector<std::unique_ptr<hook_object>> hooks_{};
            std::unordered_map<uint64_t, mmio_callbacks> mmio_{};

            static uint64_t calc_end_address(const uint64_t address, uint64_t size)
            {
                if (size == 0)
                {
                    size = 1;
                }
                else if (size == std::numeric_limits<uint64_t>::max())
                {
                    size = 0;
                }

                auto end_address = address + size - 1;

                if (end_address < address)
                {
                    end_address = std::numeric_limits<uint64_t>::max();
                }

                return end_address;
            }
        };
    }

    std::unique_ptr<x86_64_emulator> create_x86_64_emulator()
    {
        return std::make_unique<unicorn_x86_64_emulator>();
    }
}

```

`src/backends/unicorn-emulator/unicorn_x86_64_emulator.hpp`:

```hpp
#pragma once

#include <memory>
#include <arch_emulator.hpp>
#include "platform/platform.hpp"

#ifdef UNICORN_EMULATOR_IMPL
#define UNICORN_EMULATOR_DLL_STORAGE EXPORT_SYMBOL
#else
#define UNICORN_EMULATOR_DLL_STORAGE IMPORT_SYMBOL
#endif

namespace unicorn
{
#if !SOGEN_BUILD_STATIC
    UNICORN_EMULATOR_DLL_STORAGE
#endif
    std::unique_ptr<x86_64_emulator> create_x86_64_emulator();
}

```

`src/common/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
)

add_library(emulator-common ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_include_directories(emulator-common INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

target_link_libraries(emulator-common PUBLIC
  Threads::Threads
  libzstd_static
  minidump::minidump
)

if(WIN)
  target_link_libraries(emulator-common PUBLIC
    ws2_32
  )
endif()

```

`src/common/network/address.cpp`:

```cpp
#include "address.hpp"

#include <array>
#include <stdexcept>

#include "../utils/finally.hpp"

using namespace std::literals;

namespace network
{
    void initialize_wsa()
    {
#ifdef _WIN32
        static struct wsa_initializer
        {
            wsa_initializer()
            {
                WSADATA wsa_data;
                if (WSAStartup(MAKEWORD(2, 2), &wsa_data))
                {
                    throw std::runtime_error("Unable to initialize WSA");
                }
            }

            ~wsa_initializer()
            {
                WSACleanup();
            }
        } _;
#endif
    }

    address::address()
    {
        initialize_wsa();
        ZeroMemory(&this->storage_, this->get_max_size());

        this->address_.sa_family = AF_UNSPEC;
    }

    address::address(const std::string_view addr, const std::optional<int>& family)
        : address()
    {
        this->parse(addr, family);
    }

    address::address(const sockaddr_in6& addr)
        : address()
    {
        this->address6_ = addr;
    }

    address::address(const sockaddr_in& addr)
        : address()
    {
        this->address4_ = addr;
    }

    address::address(const sockaddr* addr, const socklen_t length)
        : address()
    {
        this->set_address(addr, length);
    }

    void address::set_ipv4(const uint32_t ip)
    {
        in_addr addr{};
        addr.s_addr = ip;
        this->set_ipv4(addr);
    }

    bool address::operator==(const address& obj) const
    {
        if (this->get_family() != obj.get_family())
        {
            return false;
        }

        if (this->get_port() != obj.get_port())
        {
            return false;
        }

        if (this->is_ipv4())
        {
            return this->address4_.sin_addr.s_addr == obj.address4_.sin_addr.s_addr;
        }

        if (this->is_ipv6())
        {
            return !memcmp(this->address6_.sin6_addr.s6_addr, obj.address6_.sin6_addr.s6_addr, sizeof(obj.address6_.sin6_addr.s6_addr));
        }

        return false;
    }

    void address::set_ipv4(const in_addr& addr)
    {
        ZeroMemory(&this->address4_, sizeof(this->address4_));
        this->address4_.sin_family = AF_INET;
        this->address4_.sin_addr = addr;
    }

    void address::set_ipv6(const in6_addr& addr)
    {
        ZeroMemory(&this->address6_, sizeof(this->address6_));
        this->address6_.sin6_family = AF_INET6;
        this->address6_.sin6_addr = addr;
    }

    void address::set_address(const sockaddr* addr, const socklen_t length)
    {
        if (static_cast<size_t>(length) >= sizeof(sockaddr_in) && addr->sa_family == AF_INET)
        {
            this->address4_ = *reinterpret_cast<const sockaddr_in*>(addr);
        }
        else if (static_cast<size_t>(length) == sizeof(sockaddr_in6) && addr->sa_family == AF_INET6)
        {
            this->address6_ = *reinterpret_cast<const sockaddr_in6*>(addr);
        }
        else
        {
            throw std::runtime_error("Invalid network address");
        }
    }

    void address::set_port(const uint16_t port)
    {
        switch (this->get_family())
        {
        case AF_INET:
            this->address4_.sin_port = htons(port);
            break;
        case AF_INET6:
            this->address6_.sin6_port = htons(port);
            break;
        default:
            throw std::runtime_error("Invalid address family");
        }
    }

    uint16_t address::get_port() const
    {
        switch (this->get_family())
        {
        case AF_INET:
            return ntohs(this->address4_.sin_port);
        case AF_INET6:
            return ntohs(this->address6_.sin6_port);
        default:
            return 0;
        }
    }

    std::string address::to_string() const
    {
        std::string addr{};
        std::array<char, 1000> buffer{};

        switch (this->get_family())
        {
        case AF_INET:
            inet_ntop(this->get_family(), &this->address4_.sin_addr, buffer.data(), buffer.size());
            addr = std::string(buffer.data());
            break;
        case AF_INET6:
            inet_ntop(this->get_family(), &this->address6_.sin6_addr, buffer.data(), buffer.size());
            addr = "[" + std::string(buffer.data()) + "]";
            break;
        default:
            buffer[0] = '?';
            buffer[1] = 0;
            addr = std::string(buffer.data());
            break;
        }

        return addr + ":" + std::to_string(this->get_port());
    }

    bool address::is_local() const
    {
        if (!this->is_ipv4())
        {
            return false;
        }

        // According to: https://en.wikipedia.org/wiki/Private_network

        std::array<uint8_t, 4> bytes{};
        memcpy(bytes.data(), &this->address4_.sin_addr.s_addr, bytes.size());

        // 10.X.X.X
        if (bytes[0] == 10)
        {
            return true;
        }

        // 192.168.X.X
        if (bytes[0] == 192 && bytes[1] == 168)
        {
            return true;
        }

        // 172.16.X.X - 172.31.X.X
        if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] < 32)
        {
            return true;
        }

        // 127.0.0.1
        if (this->address4_.sin_addr.s_addr == 0x0100007F)
        {
            return true;
        }

        return false;
    }

    sockaddr& address::get_addr()
    {
        return this->address_;
    }

    const sockaddr& address::get_addr() const
    {
        return this->address_;
    }

    sockaddr_in& address::get_in_addr()
    {
        return this->address4_;
    }

    sockaddr_in6& address::get_in6_addr()
    {
        return this->address6_;
    }

    const sockaddr_in& address::get_in_addr() const
    {
        return this->address4_;
    }

    const sockaddr_in6& address::get_in6_addr() const
    {
        return this->address6_;
    }

    socklen_t address::get_size() const
    {
        switch (this->get_family())
        {
        case AF_INET:
            return static_cast<socklen_t>(sizeof(this->address4_));
        case AF_INET6:
            return static_cast<socklen_t>(sizeof(this->address6_));
        default:
            return static_cast<socklen_t>(sizeof(this->address_));
        }
    }

    socklen_t address::get_max_size() const
    {
        constexpr auto s = sizeof(this->address_);
        constexpr auto s4 = sizeof(this->address4_);
        constexpr auto s6 = sizeof(this->address6_);
        constexpr auto sstore = sizeof(this->storage_);
        constexpr auto max_size = std::max(sstore, std::max(s, std::max(s4, s6)));
        static_assert(max_size == sstore);

        return static_cast<socklen_t>(max_size);
    }

    int address::get_family() const
    {
        return this->address_.sa_family;
    }

    bool address::is_ipv4() const
    {
        return this->get_family() == AF_INET;
    }

    bool address::is_ipv6() const
    {
        return this->get_family() == AF_INET6;
    }

    bool address::is_supported() const
    {
        return is_ipv4() || is_ipv6();
    }

    void address::parse(std::string_view addr, const std::optional<int>& family)
    {
        std::optional<uint16_t> port_value{};

        const auto pos = addr.find_last_of(':');
        if (pos != std::string::npos)
        {
            const auto port = addr.substr(pos + 1);
            port_value = static_cast<uint16_t>(atoi(port.data()));
            addr = addr.substr(0, pos);
        }

        this->resolve(std::string(addr), family);

        if (port_value)
        {
            this->set_port(*port_value);
        }
    }

    void address::resolve(const std::string& hostname, const std::optional<int>& family)
    {
        const auto port = this->get_port();
        auto port_reset_action = utils::finally([this, port]() { this->set_port(port); });

        const auto result = resolve_multiple(hostname);
        for (const auto& addr : result)
        {
            if (addr.is_supported() && (!family || addr.get_addr().sa_family == *family))
            {
                this->set_address(&addr.get_addr(), addr.get_size());
                return;
            }
        }

        port_reset_action.cancel();
        throw std::runtime_error{"Unable to resolve hostname: " + hostname};
    }

    std::vector<address> address::resolve_multiple(const std::string& hostname)
    {
        std::vector<address> results{};

        addrinfo* result = nullptr;
        if (!getaddrinfo(hostname.data(), nullptr, nullptr, &result))
        {
            const auto _2 = utils::finally([&result] { freeaddrinfo(result); });

            for (const auto* i = result; i; i = i->ai_next)
            {
                if (i->ai_family == AF_INET || i->ai_family == AF_INET6)
                {
                    address a{};
                    a.set_address(i->ai_addr, static_cast<socklen_t>(i->ai_addrlen));
                    results.emplace_back(a);
                }
            }
        }

        return results;
    }
}

std::size_t std::hash<network::address>::operator()(const network::address& a) const noexcept
{
    const uint32_t family = a.get_addr().sa_family;
    const uint32_t port = a.get_port();

    std::size_t hash = std::hash<uint32_t>{}(family);
    hash ^= std::hash<uint32_t>{}(port);
    switch (a.get_addr().sa_family)
    {
    case AF_INET:
        hash ^= std::hash<decltype(a.get_in_addr().sin_addr.s_addr)>{}(a.get_in_addr().sin_addr.s_addr);
        break;
    case AF_INET6:
        hash ^= std::hash<std::string_view>{}(std::string_view{reinterpret_cast<const char*>(a.get_in6_addr().sin6_addr.s6_addr),
                                                               sizeof(a.get_in6_addr().sin6_addr.s6_addr)});
        break;
    default:
        break;
    }

    return hash;
}

```

`src/common/network/address.hpp`:

```hpp
#pragma once

#if _WIN32
#include "../utils/win.hpp"
#ifdef __MINGW64__
#include <winsock2.h>
#include <ws2tcpip.h>
#include <cstdint>
#else
#include <WinSock2.h>
#include <WS2tcpip.h>
#endif
#else

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>

#include <cstring>

#define ZeroMemory(x, y) memset(x, 0, y)

#endif

#include <string>
#include <string_view>
#include <vector>
#include <optional>

#ifdef _WIN32
using socklen_t = int;
#endif

namespace network
{
    void initialize_wsa();

    class address
    {
      public:
        address();
        address(std::string_view addr, const std::optional<int>& family = std::nullopt);
        address(const sockaddr_in& addr);
        address(const sockaddr_in6& addr);
        address(const sockaddr* addr, socklen_t length);

        address(const address&) = default;
        address(address&&) noexcept = default;

        address& operator=(const address&) = default;
        address& operator=(address&&) noexcept = default;

        ~address() = default;

        void set_ipv4(uint32_t ip);
        void set_ipv4(const in_addr& addr);
        void set_ipv6(const in6_addr& addr);
        void set_address(const sockaddr* addr, socklen_t length);

        void set_port(uint16_t port);
        [[nodiscard]] uint16_t get_port() const;

        sockaddr& get_addr();
        sockaddr_in& get_in_addr();
        sockaddr_in6& get_in6_addr();

        const sockaddr& get_addr() const;
        const sockaddr_in& get_in_addr() const;
        const sockaddr_in6& get_in6_addr() const;

        socklen_t get_size() const;
        socklen_t get_max_size() const;

        int get_family() const;

        bool is_ipv4() const;
        bool is_ipv6() const;
        bool is_supported() const;

        [[nodiscard]] bool is_local() const;
        [[nodiscard]] std::string to_string() const;

        bool operator==(const address& obj) const;

        bool operator!=(const address& obj) const
        {
            return !(*this == obj);
        }

        static std::vector<address> resolve_multiple(const std::string& hostname);

      private:
        union
        {
            sockaddr address_;
            sockaddr_in address4_;
            sockaddr_in6 address6_;
            sockaddr_storage storage_;
        };

        void parse(std::string_view addr, const std::optional<int>& family = {});
        void resolve(const std::string& hostname, const std::optional<int>& family = {});
    };
}

namespace std
{
    template <>
    struct hash<network::address>
    {
        std::size_t operator()(const network::address& a) const noexcept;
    };
}

```

`src/common/network/socket.cpp`:

```cpp
#include "socket.hpp"
#include "address.hpp"

#include <thread>

using namespace std::literals;

namespace network
{
    socket::socket(const SOCKET s)
        : socket_(s)
    {
    }

    socket::socket(const int af, const int type, const int protocol)
    {
        initialize_wsa();
        this->socket_ = ::socket(af, type, protocol);

        if (af == AF_INET6)
        {
            int i = 1;
            setsockopt(this->socket_, IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<char*>(&i), static_cast<int>(sizeof(i)));
        }

        int optval = 1;
        setsockopt(this->socket_, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&optval), static_cast<int>(sizeof(optval)));
    }

    socket::~socket()
    {
        this->close();
    }

    socket::socket(socket&& obj) noexcept
    {
        this->operator=(std::move(obj));
    }

    socket& socket::operator=(socket&& obj) noexcept
    {
        if (this != &obj)
        {
            this->close();
            this->socket_ = obj.socket_;

            obj.socket_ = INVALID_SOCKET;
        }

        return *this;
    }

    socket::operator bool() const
    {
        return this->is_valid();
    }

    bool socket::is_valid() const
    {
        return this->socket_ != INVALID_SOCKET;
    }

    void socket::close()
    {
        if (this->socket_ != INVALID_SOCKET)
        {
            ::closesocket(this->socket_);
            this->socket_ = INVALID_SOCKET;
        }
    }

    // NOLINTNEXTLINE(readability-make-member-function-const)
    bool socket::bind(const address& target)
    {
        return ::bind(this->socket_, &target.get_addr(), target.get_size()) == 0;
    }

    // NOLINTNEXTLINE(readability-make-member-function-const)
    bool socket::set_blocking(const bool blocking)
    {
        return socket::set_blocking(this->socket_, blocking);
    }

    bool socket::set_blocking(SOCKET s, const bool blocking)
    {
#ifdef _WIN32
        unsigned long mode = blocking ? 0 : 1;
        return ioctlsocket(s, FIONBIO, &mode) == 0;
#else
        int flags = fcntl(s, F_GETFL, 0);
        if (flags == -1)
        {
            return false;
        }

        flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
        return fcntl(s, F_SETFL, flags) == 0;
#endif
    }

    bool socket::sleep(const std::chrono::milliseconds timeout, const bool in_poll) const
    {
        std::vector<const socket*> sockets{};
        sockets.push_back(this);

        return sleep_sockets(sockets, timeout, in_poll);
    }

    bool socket::sleep_until(const std::chrono::high_resolution_clock::time_point time_point, const bool in_poll) const
    {
        const auto duration = time_point - std::chrono::high_resolution_clock::now();
        return this->sleep(std::chrono::duration_cast<std::chrono::milliseconds>(duration), in_poll);
    }

    SOCKET socket::get_socket() const
    {
        return this->socket_;
    }

    std::optional<address> socket::get_name() const
    {
        address a{};
        auto len = a.get_max_size();
        if (getsockname(this->socket_, &a.get_addr(), &len) == SOCKET_ERROR)
        {
            return std::nullopt;
        }

        return a;
    }

    uint16_t socket::get_port() const
    {
        const auto address = this->get_name();
        if (!address)
        {
            return 0;
        }

        return address->get_port();
    }

    int socket::get_address_family() const
    {
        const auto address = this->get_name();
        if (!address)
        {
            return AF_UNSPEC;
        }

        return address->get_addr().sa_family;
    }

    bool socket::is_ready(const bool in_poll) const
    {
        return this->is_valid() && is_socket_ready(this->socket_, in_poll);
    }

    bool socket::sleep_sockets(const std::span<const socket*>& sockets, const std::chrono::milliseconds timeout, const bool in_poll)
    {
        std::vector<pollfd> pfds{};
        pfds.resize(sockets.size());

        for (size_t i = 0; i < sockets.size(); ++i)
        {
            auto& pfd = pfds.at(i);
            const auto& socket = sockets[i];

            pfd.fd = socket->get_socket();
            pfd.events = in_poll ? POLLIN : POLLOUT;
            pfd.revents = 0;
        }

        const auto retval = poll(pfds.data(), static_cast<uint32_t>(pfds.size()), static_cast<int>(timeout.count()));

        if (retval == SOCKET_ERROR)
        {
            std::this_thread::sleep_for(1ms);
            return socket_is_ready;
        }

        if (retval > 0)
        {
            return socket_is_ready;
        }

        return !socket_is_ready;
    }

    bool socket::is_socket_ready(const SOCKET s, const bool in_poll)
    {
        pollfd pfd{};

        pfd.fd = s;
        pfd.events = in_poll ? POLLIN : POLLOUT;
        pfd.revents = 0;

        const auto retval = poll(&pfd, 1, 0);

        if (retval == SOCKET_ERROR)
        {
            std::this_thread::sleep_for(1ms);
            return socket_is_ready;
        }

        if (retval > 0)
        {
            return socket_is_ready;
        }

        return !socket_is_ready;
    }

    bool socket::sleep_sockets_until(const std::span<const socket*>& sockets,
                                     const std::chrono::high_resolution_clock::time_point time_point, const bool in_poll)
    {
        const auto duration = time_point - std::chrono::high_resolution_clock::now();
        return sleep_sockets(sockets, std::chrono::duration_cast<std::chrono::milliseconds>(duration), in_poll);
    }
}

```

`src/common/network/socket.hpp`:

```hpp
#pragma once

#include "address.hpp"

#include <span>
#include <chrono>
#include <optional>

#ifdef _WIN32
using send_size = int;
using sent_size = int;
#define GET_SOCKET_ERROR() (WSAGetLastError())
#define poll               WSAPoll
#define SERR(x)            (WSA##x)
#define SHUT_RDWR          SD_BOTH
#else
using SOCKET = int;
using send_size = size_t;
using sent_size = ssize_t;
#define INVALID_SOCKET     (SOCKET)(~0)
#define SOCKET_ERROR       (-1)
#define GET_SOCKET_ERROR() (errno)
#define closesocket        close
#define SERR(x)            (x)
#endif

namespace network
{
    class socket
    {
      public:
        socket() = default;

        socket(SOCKET s);

        socket(int af, int type, int protocol);
        virtual ~socket();

        socket(const socket& obj) = delete;
        socket& operator=(const socket& obj) = delete;

        socket(socket&& obj) noexcept;
        socket& operator=(socket&& obj) noexcept;

        explicit operator bool() const;

        bool is_valid() const;

        bool bind(const address& target);

        bool set_blocking(bool blocking);
        static bool set_blocking(SOCKET s, bool blocking);

        static constexpr bool socket_is_ready = true;
        bool sleep(std::chrono::milliseconds timeout, bool in_poll = true) const;
        bool sleep_until(std::chrono::high_resolution_clock::time_point time_point, bool in_poll = true) const;

        SOCKET get_socket() const;
        uint16_t get_port() const;
        std::optional<address> get_name() const;

        int get_address_family() const;

        bool is_ready(bool in_poll) const;

        static bool sleep_sockets(const std::span<const socket*>& sockets, std::chrono::milliseconds timeout, bool in_poll);
        static bool sleep_sockets_until(const std::span<const socket*>& sockets, std::chrono::high_resolution_clock::time_point time_point,
                                        bool in_poll);

        static bool is_socket_ready(SOCKET s, bool in_poll);

        void close();

      private:
        SOCKET socket_ = INVALID_SOCKET;
    };
}

```

`src/common/network/tcp_client_socket.cpp`:

```cpp
#include "tcp_client_socket.hpp"

#include <array>
#include <cassert>

namespace network
{
    tcp_client_socket::tcp_client_socket(const int af)
        : socket(af, SOCK_STREAM, IPPROTO_TCP)
    {
    }

    tcp_client_socket::tcp_client_socket(SOCKET s, const address& target)
        : socket(s)
    {
        (void)target;
        assert(this->get_target() == target);
    }

    tcp_client_socket::~tcp_client_socket()
    {
        if (*this && this->get_target())
        {
            ::shutdown(this->get_socket(), SHUT_RDWR);
        }
    }

    bool tcp_client_socket::send(const void* data, const size_t size) const
    {
        return this->send(std::string_view(static_cast<const char*>(data), size));
    }

    bool tcp_client_socket::send(std::string_view data) const
    {
        while (!data.empty())
        {
            const auto res = ::send(this->get_socket(), data.data(), static_cast<send_size>(data.size()), 0);
            if (res < 0)
            {
                if (GET_SOCKET_ERROR() != SERR(EWOULDBLOCK))
                {
                    break;
                }

                this->sleep(std::chrono::milliseconds(10), true);
                continue;
            }

            if (static_cast<size_t>(res) > data.size())
            {
                break;
            }

            data = data.substr(res);
        }

        return data.empty();
    }

    std::optional<std::string> tcp_client_socket::receive(const std::optional<size_t> max_size)
    {
        std::array<char, 0x2000> buffer{};
        const auto size = std::min(buffer.size(), max_size.value_or(buffer.size()));

        const auto result = recv(this->get_socket(), buffer.data(), static_cast<int>(size), 0);
        if (result > 0)
        {
            return std::string(buffer.data(), static_cast<size_t>(result));
        }

        if (result == 0 || (result < 0 && GET_SOCKET_ERROR() == SERR(ECONNRESET)))
        {
            this->close();
        }

        return std::nullopt;
    }

    std::optional<address> tcp_client_socket::get_target() const
    {
        address a{};
        auto len = a.get_max_size();
        if (getpeername(this->get_socket(), &a.get_addr(), &len) == SOCKET_ERROR)
        {
            return std::nullopt;
        }

        return a;
    }

    bool tcp_client_socket::connect(const address& target)
    {
        if (::connect(this->get_socket(), &target.get_addr(), target.get_size()) != SOCKET_ERROR)
        {
            return true;
        }

        const auto error = GET_SOCKET_ERROR();
        return error == SERR(EWOULDBLOCK);
    }
}

```

`src/common/network/tcp_client_socket.hpp`:

```hpp
#pragma once

#include "socket.hpp"

#include <string_view>

namespace network
{
    class tcp_server_socket;

    class tcp_client_socket : public socket
    {
      public:
        tcp_client_socket(int af);

        tcp_client_socket() = default;
        ~tcp_client_socket() override;

        tcp_client_socket(tcp_client_socket&& obj) noexcept = default;
        tcp_client_socket& operator=(tcp_client_socket&& obj) noexcept = default;

        [[maybe_unused]] bool send(const void* data, size_t size) const;
        [[maybe_unused]] bool send(std::string_view data) const;
        std::optional<std::string> receive(std::optional<size_t> max_size = std::nullopt);

        std::optional<address> get_target() const;

        bool connect(const address& target);

      private:
        friend tcp_server_socket;
        tcp_client_socket(SOCKET s, const address& target);
    };
}

```

`src/common/network/tcp_server_socket.cpp`:

```cpp
#include "tcp_server_socket.hpp"

namespace network
{
    tcp_server_socket::tcp_server_socket(const int af)
        : socket(af, SOCK_STREAM, IPPROTO_TCP)
    {
    }

    tcp_client_socket tcp_server_socket::accept()
    {
        this->listen();

        address a{};
        auto len = a.get_max_size();
        const auto s = ::accept(this->get_socket(), &a.get_addr(), &len);
        if (s == INVALID_SOCKET)
        {
            return {};
        }

        return {s, a};
    }

    void tcp_server_socket::listen()
    {
        if (this->listening_)
        {
            return;
        }

        this->listening_ = ::listen(this->get_socket(), 32) == 0;
    }
}

```

`src/common/network/tcp_server_socket.hpp`:

```hpp
#pragma once

#include "socket.hpp"
#include "tcp_client_socket.hpp"

namespace network
{
    class tcp_server_socket : public socket
    {
      public:
        tcp_server_socket(int af);

        tcp_server_socket() = default;
        ~tcp_server_socket() override = default;

        tcp_server_socket(tcp_server_socket&& obj) noexcept = default;
        tcp_server_socket& operator=(tcp_server_socket&& obj) noexcept = default;

        tcp_client_socket accept();

        void listen();

      private:
        bool listening_{false};
    };
}

```

`src/common/network/udp_socket.cpp`:

```cpp
#include "udp_socket.hpp"
#include <array>

namespace network
{
    udp_socket::udp_socket(const int af)
        : socket(af, SOCK_DGRAM, IPPROTO_UDP)
    {
    }

    bool udp_socket::send(const address& target, const void* data, const size_t size) const
    {
        return this->send(target, std::string_view(static_cast<const char*>(data), size));
    }

    bool udp_socket::send(const address& target, const std::string_view data) const
    {
        while (true)
        {
            const auto res =
                sendto(this->get_socket(), data.data(), static_cast<send_size>(data.size()), 0, &target.get_addr(), target.get_size());

            if (res < 0 && GET_SOCKET_ERROR() == SERR(EWOULDBLOCK))
            {
                this->sleep(std::chrono::milliseconds(10), true);
                continue;
            }

            return static_cast<size_t>(res) == data.size();
        }
    }

    std::optional<std::pair<address, std::string>> udp_socket::receive() const
    {
        std::array<char, 0x2000> buffer{};
        address source{};
        auto len = source.get_max_size();

        const auto result = recvfrom(this->get_socket(), buffer.data(), static_cast<int>(buffer.size()), 0, &source.get_addr(), &len);
        if (result == SOCKET_ERROR)
        {
            return std::nullopt;
        }

        return {{source, std::string(buffer.data(), static_cast<size_t>(result))}};
    }
}

```

`src/common/network/udp_socket.hpp`:

```hpp
#pragma once

#include "socket.hpp"

#include <string_view>

namespace network
{
    struct udp_socket : socket
    {
        udp_socket(int af);
        udp_socket() = default;
        ~udp_socket() override = default;

        udp_socket(udp_socket&& obj) noexcept = default;
        udp_socket& operator=(udp_socket&& obj) noexcept = default;

        [[maybe_unused]] bool send(const address& target, const void* data, size_t size) const;
        [[maybe_unused]] bool send(const address& target, std::string_view data) const;
        std::optional<std::pair<address, std::string>> receive() const;
    };
}

```

`src/common/platform/compiler.hpp`:

```hpp
#pragma once

#if defined(_WIN32) || defined(_WIN64)
#define OS_WINDOWS

#if defined(_WIN64)
#define OS_WINDOWS_64
#else
#define OS_WINDOWS_32
#endif

#elif defined(__APPLE__) || defined(__MACH__)
#define OS_MAC
#elif defined(__linux__)
#define OS_LINUX
#elif defined(__EMSCRIPTEN__)
#define OS_EMSCRIPTEN
#else
#error "Unsupported platform"
#endif

#ifdef OS_WINDOWS
#define EXPORT_SYMBOL __declspec(dllexport)
#define IMPORT_SYMBOL __declspec(dllimport)
#define NO_INLINE     __declspec(noinline)

#ifndef DECLSPEC_ALIGN
#define DECLSPEC_ALIGN(n) __declspec(align(n))
#endif

#define RESTRICTED_POINTER

#else
#include <cstddef>

#define EXPORT_SYMBOL __attribute__((visibility("default")))
#define IMPORT_SYMBOL
#define NO_INLINE          __attribute__((noinline))

#define DECLSPEC_ALIGN(n)  alignas(n)
#define fopen_s            fopen
#define sscanf_s           sscanf

#define RESTRICTED_POINTER __restrict

#ifdef OS_MAC
#define _fseeki64 fseeko
#define _ftelli64 ftello
#define _stat64   stat
#else
#define _fseeki64 fseeko64
#define _ftelli64 ftello64
#define _stat64   stat64
#endif

#endif

```

`src/common/platform/file_management.hpp`:

```hpp
#pragma once

#include "kernel_mapped.hpp"

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#define ACCESS_MASK              DWORD
#define DEVICE_TYPE              DWORD

#define FILE_DEVICE_DISK         0x00000007
#define FILE_DEVICE_CONSOLE      0x00000050

#define FILE_SUPERSEDE           0x00000000
#define FILE_OPEN                0x00000001
#define FILE_CREATE              0x00000002
#define FILE_OPEN_IF             0x00000003
#define FILE_OVERWRITE           0x00000004
#define FILE_OVERWRITE_IF        0x00000005
#define FILE_MAXIMUM_DISPOSITION 0x00000005

#ifndef OS_WINDOWS
#define GENERIC_READ    0x80000000
#define GENERIC_WRITE   0x40000000
#define GENERIC_EXECUTE 0x20000000
#define GENERIC_ALL     0x10000000

#undef DELETE
#define DELETE                    0x00010000
#define READ_CONTROL              0x00020000
#define WRITE_DAC                 0x00040000
#define WRITE_OWNER               0x00080000
#define SYNCHRONIZE               0x00100000
#define STANDARD_RIGHTS_REQUIRED  0x000f0000

#define FILE_READ_DATA            0x0001 /* file & pipe */
#define FILE_LIST_DIRECTORY       0x0001 /* directory */
#define FILE_WRITE_DATA           0x0002 /* file & pipe */
#define FILE_ADD_FILE             0x0002 /* directory */
#define FILE_APPEND_DATA          0x0004 /* file */
#define FILE_ADD_SUBDIRECTORY     0x0004 /* directory */
#define FILE_CREATE_PIPE_INSTANCE 0x0004 /* named pipe */
#define FILE_READ_EA              0x0008 /* file & directory */
#define FILE_READ_PROPERTIES      FILE_READ_EA
#define FILE_WRITE_EA             0x0010 /* file & directory */
#define FILE_WRITE_PROPERTIES     FILE_WRITE_EA
#define FILE_EXECUTE              0x0020 /* file */
#define FILE_TRAVERSE             0x0020 /* directory */
#define FILE_DELETE_CHILD         0x0040 /* directory */
#define FILE_READ_ATTRIBUTES      0x0080 /* all */
#define FILE_WRITE_ATTRIBUTES     0x0100 /* all */
#define FILE_ALL_ACCESS           (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1ff)

#endif

#define FILE_DIRECTORY_FILE            0x00000001
#define FILE_WRITE_THROUGH             0x00000002
#define FILE_SEQUENTIAL_ONLY           0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT      0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT   0x00000020
#define FILE_NON_DIRECTORY_FILE        0x00000040
#define FILE_CREATE_TREE_CONNECTION    0x00000080

#define FILE_ATTRIBUTE_NORMAL          0x00000080
#define FILE_ATTRIBUTE_DIRECTORY       0x00000010

#define PS_ATTRIBUTE_NUMBER_MASK       0x0000ffff
#define PS_ATTRIBUTE_THREAD            0x00010000 // may be used with thread creation
#define PS_ATTRIBUTE_INPUT             0x00020000 // input only
#define PS_ATTRIBUTE_ADDITIVE          0x00040000 // "accumulated" e.g. bitmasks, counters, etc.

#define SL_RESTART_SCAN                0x01
#define SL_RETURN_SINGLE_ENTRY         0x02
#define SL_NO_CURSOR_UPDATE            0x10

#ifndef SEC_IMAGE
#define SEC_HUGE_PAGES             0x00020000
#define SEC_PARTITION_OWNER_HANDLE 0x00040000
#define SEC_64K_PAGES              0x00080000
#define SEC_FILE                   0x00800000
#define SEC_IMAGE                  0x01000000
#define SEC_PROTECTED_IMAGE        0x02000000
#define SEC_RESERVE                0x04000000
#define SEC_COMMIT                 0x08000000
#define SEC_NOCACHE                0x10000000
#define SEC_WRITECOMBINE           0x40000000
#define SEC_LARGE_PAGES            0x80000000
#define SEC_IMAGE_NO_EXECUTE       (SEC_IMAGE | SEC_NOCACHE)
#endif

#define CTL_CODE(DeviceType, Function, Method, Access) (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))

#define METHOD_BUFFERED                                0

#define FILE_ANY_ACCESS                                0
#define FILE_READ_ACCESS                               (0x0001) // file & pipe
#define FILE_WRITE_ACCESS                              (0x0002) // file & pipe

typedef enum _FSINFOCLASS
{
    FileFsVolumeInformation = 1, // q: FILE_FS_VOLUME_INFORMATION
    FileFsLabelInformation,      // s: FILE_FS_LABEL_INFORMATION (requires FILE_WRITE_DATA to volume)
    FileFsSizeInformation,       // q: FILE_FS_SIZE_INFORMATION
    FileFsDeviceInformation,     // q: FILE_FS_DEVICE_INFORMATION
    FileFsAttributeInformation,  // q: FILE_FS_ATTRIBUTE_INFORMATION
    FileFsControlInformation,
    // q, s: FILE_FS_CONTROL_INFORMATION  (q: requires FILE_READ_DATA; s: requires FILE_WRITE_DATA to volume)
    FileFsFullSizeInformation,   // q: FILE_FS_FULL_SIZE_INFORMATION
    FileFsObjectIdInformation,   // q; s: FILE_FS_OBJECTID_INFORMATION (s: requires FILE_WRITE_DATA to volume)
    FileFsDriverPathInformation, // q: FILE_FS_DRIVER_PATH_INFORMATION
    FileFsVolumeFlagsInformation,
    // q; s: FILE_FS_VOLUME_FLAGS_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES to
    // volume) // 10
    FileFsSectorSizeInformation,   // q: FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8
    FileFsDataCopyInformation,     // q: FILE_FS_DATA_COPY_INFORMATION
    FileFsMetadataSizeInformation, // q: FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD
    FileFsFullSizeInformationEx,   // q: FILE_FS_FULL_SIZE_INFORMATION_EX // since REDSTONE5
    FileFsGuidInformation,         // q: FILE_FS_GUID_INFORMATION // since 23H2
    FileFsMaximumInformation
} FSINFOCLASS, *PFSINFOCLASS;

using FS_INFORMATION_CLASS = enum _FSINFOCLASS;

typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation = 1,
    // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileFullDirectoryInformation,
    // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileBothDirectoryInformation,
    // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileBasicInformation,
    // q; s: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)
    FileStandardInformation,      // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX
    FileInternalInformation,      // q: FILE_INTERNAL_INFORMATION
    FileEaInformation,            // q: FILE_EA_INFORMATION
    FileAccessInformation,        // q: FILE_ACCESS_INFORMATION
    FileNameInformation,          // q: FILE_NAME_INFORMATION
    FileRenameInformation,        // s: FILE_RENAME_INFORMATION (requires DELETE) // 10
    FileLinkInformation,          // s: FILE_LINK_INFORMATION
    FileNamesInformation,         // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileDispositionInformation,   // s: FILE_DISPOSITION_INFORMATION (requires DELETE)
    FilePositionInformation,      // q; s: FILE_POSITION_INFORMATION
    FileFullEaInformation,        // FILE_FULL_EA_INFORMATION
    FileModeInformation,          // q; s: FILE_MODE_INFORMATION
    FileAlignmentInformation,     // q: FILE_ALIGNMENT_INFORMATION
    FileAllInformation,           // q: FILE_ALL_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileAllocationInformation,    // s: FILE_ALLOCATION_INFORMATION (requires FILE_WRITE_DATA)
    FileEndOfFileInformation,     // s: FILE_END_OF_FILE_INFORMATION (requires FILE_WRITE_DATA) // 20
    FileAlternateNameInformation, // q: FILE_NAME_INFORMATION
    FileStreamInformation,        // q: FILE_STREAM_INFORMATION
    FilePipeInformation,
    // q; s: FILE_PIPE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)
    FilePipeLocalInformation, // q: FILE_PIPE_LOCAL_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FilePipeRemoteInformation,
    // q; s: FILE_PIPE_REMOTE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)
    FileMailslotQueryInformation, // q: FILE_MAILSLOT_QUERY_INFORMATION
    FileMailslotSetInformation,   // s: FILE_MAILSLOT_SET_INFORMATION
    FileCompressionInformation,   // q: FILE_COMPRESSION_INFORMATION
    FileObjectIdInformation,      // q: FILE_OBJECTID_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileCompletionInformation,    // s: FILE_COMPLETION_INFORMATION // 30
    FileMoveClusterInformation,   // s: FILE_MOVE_CLUSTER_INFORMATION (requires FILE_WRITE_DATA)
    FileQuotaInformation,         // q: FILE_QUOTA_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileReparsePointInformation,
    // q: FILE_REPARSE_POINT_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileNetworkOpenInformation,  // q: FILE_NETWORK_OPEN_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileAttributeTagInformation, // q: FILE_ATTRIBUTE_TAG_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileTrackingInformation,     // s: FILE_TRACKING_INFORMATION (requires FILE_WRITE_DATA)
    FileIdBothDirectoryInformation,
    // q: FILE_ID_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileIdFullDirectoryInformation,
    // q: FILE_ID_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])
    FileValidDataLengthInformation,
    // s: FILE_VALID_DATA_LENGTH_INFORMATION (requires FILE_WRITE_DATA and/or SeManageVolumePrivilege)
    FileShortNameInformation, // s: FILE_NAME_INFORMATION (requires DELETE) // 40
    FileIoCompletionNotificationInformation,
    // q; s: FILE_IO_COMPLETION_NOTIFICATION_INFORMATION (q: requires FILE_READ_ATTRIBUTES) // since VISTA
    FileIoStatusBlockRangeInformation, // s: FILE_IOSTATUSBLOCK_RANGE_INFORMATION (requires SeLockMemoryPrivilege)
    FileIoPriorityHintInformation,
    // q; s: FILE_IO_PRIORITY_HINT_INFORMATION, FILE_IO_PRIORITY_HINT_INFORMATION_EX (q: requires FILE_READ_DATA)
    FileSfioReserveInformation,         // q; s: FILE_SFIO_RESERVE_INFORMATION (q: requires FILE_READ_DATA)
    FileSfioVolumeInformation,          // q: FILE_SFIO_VOLUME_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileHardLinkInformation,            // q: FILE_LINKS_INFORMATION
    FileProcessIdsUsingFileInformation, // q: FILE_PROCESS_IDS_USING_FILE_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileNormalizedNameInformation,      // q: FILE_NAME_INFORMATION
    FileNetworkPhysicalNameInformation, // q: FILE_NETWORK_PHYSICAL_NAME_INFORMATION
    FileIdGlobalTxDirectoryInformation,
    // q: FILE_ID_GLOBAL_TX_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex]) // since WIN7 //
    // 50
    FileIsRemoteDeviceInformation, // q: FILE_IS_REMOTE_DEVICE_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileUnusedInformation,
    FileNumaNodeInformation,                // q: FILE_NUMA_NODE_INFORMATION
    FileStandardLinkInformation,            // q: FILE_STANDARD_LINK_INFORMATION
    FileRemoteProtocolInformation,          // q: FILE_REMOTE_PROTOCOL_INFORMATION
    FileRenameInformationBypassAccessCheck, // (kernel-mode only); s: FILE_RENAME_INFORMATION // since WIN8
    FileLinkInformationBypassAccessCheck,   // (kernel-mode only); s: FILE_LINK_INFORMATION
    FileVolumeNameInformation,              // q: FILE_VOLUME_NAME_INFORMATION
    FileIdInformation,                      // q: FILE_ID_INFORMATION
    FileIdExtdDirectoryInformation,
    // q: FILE_ID_EXTD_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex]) // 60
    FileReplaceCompletionInformation, // s: FILE_COMPLETION_INFORMATION // since WINBLUE
    FileHardLinkFullIdInformation,    // q: FILE_LINK_ENTRY_FULL_ID_INFORMATION // FILE_LINKS_FULL_ID_INFORMATION
    FileIdExtdBothDirectoryInformation,
    // q: FILE_ID_EXTD_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex]) // since THRESHOLD
    FileDispositionInformationEx,             // s: FILE_DISPOSITION_INFO_EX (requires DELETE) // since REDSTONE
    FileRenameInformationEx,                  // s: FILE_RENAME_INFORMATION_EX
    FileRenameInformationExBypassAccessCheck, // (kernel-mode only); s: FILE_RENAME_INFORMATION_EX
    FileDesiredStorageClassInformation,
    // q; s: FILE_DESIRED_STORAGE_CLASS_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires
    // FILE_WRITE_ATTRIBUTES) // since REDSTONE2
    FileStatInformation,            // q: FILE_STAT_INFORMATION (requires FILE_READ_ATTRIBUTES)
    FileMemoryPartitionInformation, // s: FILE_MEMORY_PARTITION_INFORMATION // since REDSTONE3
    FileStatLxInformation,
    // q: FILE_STAT_LX_INFORMATION (requires FILE_READ_ATTRIBUTES and FILE_READ_EA) // since REDSTONE4 // 70
    FileCaseSensitiveInformation,
    // q; s: FILE_CASE_SENSITIVE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)
    FileLinkInformationEx,                  // s: FILE_LINK_INFORMATION_EX // since REDSTONE5
    FileLinkInformationExBypassAccessCheck, // (kernel-mode only); s: FILE_LINK_INFORMATION_EX
    FileStorageReserveIdInformation,
    // q; s: FILE_STORAGE_RESERVE_ID_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)
    FileCaseSensitiveInformationForceAccessCheck, // q; s: FILE_CASE_SENSITIVE_INFORMATION
    FileKnownFolderInformation,
    // q; s: FILE_KNOWN_FOLDER_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES) //
    // since WIN11
    FileStatBasicInformation,              // since 23H2
    FileId64ExtdDirectoryInformation,      // FILE_ID_64_EXTD_DIR_INFORMATION
    FileId64ExtdBothDirectoryInformation,  // FILE_ID_64_EXTD_BOTH_DIR_INFORMATION
    FileIdAllExtdDirectoryInformation,     // FILE_ID_ALL_EXTD_DIR_INFORMATION
    FileIdAllExtdBothDirectoryInformation, // FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION
    FileStreamReservationInformation,      // FILE_STREAM_RESERVATION_INFORMATION // since 24H2
    FileMupProviderInfo,                   // MUP_PROVIDER_INFORMATION
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

using OBJECT_INFORMATION_CLASS = enum _OBJECT_INFORMATION_CLASS
{
    ObjectBasicInformation,         // q: OBJECT_BASIC_INFORMATION
    ObjectNameInformation,          // q: OBJECT_NAME_INFORMATION
    ObjectTypeInformation,          // q: OBJECT_TYPE_INFORMATION
    ObjectTypesInformation,         // q: OBJECT_TYPES_INFORMATION
    ObjectHandleFlagInformation,    // qs: OBJECT_HANDLE_FLAG_INFORMATION
    ObjectSessionInformation,       // s: void // change object session // (requires SeTcbPrivilege)
    ObjectSessionObjectInformation, // s: void // change object session // (requires SeTcbPrivilege)
    MaxObjectInfoClass
};

using WORKERFACTORYINFOCLASS = enum _WORKERFACTORYINFOCLASS
{
    WorkerFactoryTimeout = 0,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters,
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    WorkerFactoryThreadCpuSets,
    MaxWorkerFactoryInfoClass
};

constexpr auto WORKER_FACTORY_FLAG_LOADER_POOL = 0x1; // real name is unknown

using HARDERROR_RESPONSE_OPTION = enum _HARDERROR_RESPONSE_OPTION
{
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
};

using HARDERROR_RESPONSE = enum _HARDERROR_RESPONSE
{
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
};

using RTL_ATOM = USHORT;

template <typename Traits>
struct IO_STATUS_BLOCK
{
    union
    {
        NTSTATUS Status;
        typename Traits::PVOID Pointer;
    };

    typename Traits::ULONG_PTR Information;
};

template <typename Traits>
struct FILE_IO_COMPLETION_INFORMATION
{
    typename Traits::PVOID KeyContext;
    typename Traits::PVOID ApcContext;
    IO_STATUS_BLOCK<Traits> IoStatusBlock;
};

template <typename Traits>
struct OBJECT_ATTRIBUTES
{
    ULONG Length;
    typename Traits::HANDLE RootDirectory;
    EMULATOR_CAST(typename Traits::PVOID, UNICODE_STRING*) ObjectName;
    ULONG Attributes;
    typename Traits::PVOID SecurityDescriptor;       // PSECURITY_DESCRIPTOR;
    typename Traits::PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE
};

typedef struct _FILE_FS_SIZE_INFORMATION
{
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION
{
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    char16_t VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_FS_DEVICE_INFORMATION
{
    DEVICE_TYPE DeviceType;
    ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;

typedef struct _FILE_FS_ATTRIBUTE_INFORMATION
{
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    char16_t FileSystemName[10];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION
{
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION
{
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_IS_REMOTE_DEVICE_INFORMATION
{
    BOOLEAN IsRemote;
} FILE_IS_REMOTE_DEVICE_INFORMATION, *PFILE_IS_REMOTE_DEVICE_INFORMATION;

#ifndef OS_WINDOWS
typedef struct _FILE_ID_128
{
    BYTE Identifier[16];
} FILE_ID_128, *PFILE_ID_128;
#endif

typedef struct _FILE_ID_INFORMATION
{
    ULONGLONG VolumeSerialNumber;
    FILE_ID_128 FileId;
} FILE_ID_INFORMATION, *PFILE_ID_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

typedef struct _FILE_NAME_INFORMATION
{
    ULONG FileNameLength;
    char16_t FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_BASIC_INFORMATION
{
    LARGE_INTEGER CreationTime;   // Specifies the time that the file was created.
    LARGE_INTEGER LastAccessTime; // Specifies the time that the file was last accessed.
    LARGE_INTEGER LastWriteTime;  // Specifies the time that the file was last written to.
    LARGE_INTEGER ChangeTime;     // Specifies the last time the file was changed.
    ULONG FileAttributes;         // Specifies one or more FILE_ATTRIBUTE_XXX flags.
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    char16_t FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    char16_t FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    char ShortNameLength;
    char16_t ShortName[12];
    char16_t FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION
{
    BOOLEAN ReplaceIfExists;
    EMULATOR_CAST(uint64_t, HANDLE) RootDirectory;
    ULONG FileNameLength;
    char16_t FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION
{
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    char16_t StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_EA_INFORMATION
{
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_VOLUME_NAME_INFORMATION
{
    ULONG DeviceNameLength;
    char16_t DeviceName[1];
} FILE_VOLUME_NAME_INFORMATION, *PFILE_VOLUME_NAME_INFORMATION;

#ifndef OS_WINDOWS
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE, *PSECURITY_CONTEXT_TRACKING_MODE;
typedef struct _SECURITY_QUALITY_OF_SERVICE
{
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE, *P_SECURITY_QUALITY_OF_SERVICE;

#endif

struct EMU_FILE_STAT_BASIC_INFORMATION
{
    LARGE_INTEGER FileId;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
    ULONG ReparseTag;
    ULONG NumberOfLinks;
    ULONG DeviceType;
    ULONG DeviceCharacteristics;
    ULONG Reserved;
    LARGE_INTEGER VolumeSerialNumber;
    FILE_ID_128 FileId128;
};

typedef struct _PORT_VIEW64
{
    ULONG Length;
    EMULATOR_CAST(std::uint64_t, HANDLE) SectionHandle;
    ULONG SectionOffset;
    EMULATOR_CAST(std::int64_t, SIZE_T) ViewSize;
    EmulatorTraits<Emu64>::PVOID ViewBase;
    EmulatorTraits<Emu64>::PVOID ViewRemoteBase;
} PORT_VIEW64, *PPORT_VIEW64;

typedef struct _REMOTE_PORT_VIEW64
{
    ULONG Length;
    EMULATOR_CAST(std::int64_t, SIZE_T) ViewSize;
    EmulatorTraits<Emu64>::PVOID ViewBase;
} REMOTE_PORT_VIEW64, *PREMOTE_PORT_VIEW64;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/kernel_mapped.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "primitives.hpp"
#include "traits.hpp"
#include "unicode.hpp"
#include "status.hpp"
#include "process.hpp"

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((static_cast<std::int32_t>(Status)) >= 0)
#endif

#define PROCESSOR_FEATURE_MAX                                           64
#define GDI_HANDLE_BUFFER_SIZE32                                        34
#define GDI_HANDLE_BUFFER_SIZE64                                        60
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION 0x00000001
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE           0x00000002
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST            0x00000004
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED          0x00000008
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED    0x00000010
#define ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED                  0x00000001
#define GDI_BATCH_BUFFER_SIZE                                           310
#define WIN32_CLIENT_INFO_LENGTH                                        62
#define STATIC_UNICODE_BUFFER_LENGTH                                    261
#define TLS_MINIMUM_AVAILABLE                                           64
#define TLS_EXPANSION_SLOTS                                             1024

#ifndef OS_WINDOWS
#define PF_FLOATING_POINT_PRECISION_ERRATA         0
#define PF_FLOATING_POINT_EMULATED                 1
#define PF_COMPARE_EXCHANGE_DOUBLE                 2
#define PF_MMX_INSTRUCTIONS_AVAILABLE              3
#define PF_PPC_MOVEMEM_64BIT_OK                    4
#define PF_ALPHA_BYTE_INSTRUCTIONS                 5
#define PF_XMMI_INSTRUCTIONS_AVAILABLE             6
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE            7
#define PF_RDTSC_INSTRUCTION_AVAILABLE             8
#define PF_PAE_ENABLED                             9
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE           10
#define PF_SSE_DAZ_MODE_AVAILABLE                  11
#define PF_NX_ENABLED                              12
#define PF_SSE3_INSTRUCTIONS_AVAILABLE             13
#define PF_COMPARE_EXCHANGE128                     14
#define PF_COMPARE64_EXCHANGE128                   15
#define PF_CHANNELS_ENABLED                        16
#define PF_XSAVE_ENABLED                           17
#define PF_ARM_VFP_32_REGISTERS_AVAILABLE          18
#define PF_ARM_NEON_INSTRUCTIONS_AVAILABLE         19
#define PF_SECOND_LEVEL_ADDRESS_TRANSLATION        20
#define PF_VIRT_FIRMWARE_ENABLED                   21
#define PF_RDWRFSGSBASE_AVAILABLE                  22
#define PF_FASTFAIL_AVAILABLE                      23
#define PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE        24
#define PF_ARM_64BIT_LOADSTORE_ATOMIC              25
#define PF_ARM_EXTERNAL_CACHE_AVAILABLE            26
#define PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE         27
#define PF_RDRAND_INSTRUCTION_AVAILABLE            28
#define PF_ARM_V8_INSTRUCTIONS_AVAILABLE           29
#define PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE    30
#define PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE     31
#define PF_RDTSCP_INSTRUCTION_AVAILABLE            32
#define PF_RDPID_INSTRUCTION_AVAILABLE             33
#define PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE   34
#define PF_MONITORX_INSTRUCTION_AVAILABLE          35
#define PF_SSSE3_INSTRUCTIONS_AVAILABLE            36
#define PF_SSE4_1_INSTRUCTIONS_AVAILABLE           37
#define PF_SSE4_2_INSTRUCTIONS_AVAILABLE           38
#define PF_AVX_INSTRUCTIONS_AVAILABLE              39
#define PF_AVX2_INSTRUCTIONS_AVAILABLE             40
#define PF_AVX512F_INSTRUCTIONS_AVAILABLE          41
#define PF_ERMS_AVAILABLE                          42
#define PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE       43
#define PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE    44
#define PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE    45
#define PF_ARM_SVE_INSTRUCTIONS_AVAILABLE          46
#define PF_ARM_SVE2_INSTRUCTIONS_AVAILABLE         47
#define PF_ARM_SVE2_1_INSTRUCTIONS_AVAILABLE       48
#define PF_ARM_SVE_AES_INSTRUCTIONS_AVAILABLE      49
#define PF_ARM_SVE_PMULL128_INSTRUCTIONS_AVAILABLE 50
#define PF_ARM_SVE_BITPERM_INSTRUCTIONS_AVAILABLE  51
#define PF_ARM_SVE_BF16_INSTRUCTIONS_AVAILABLE     52
#define PF_ARM_SVE_EBF16_INSTRUCTIONS_AVAILABLE    53
#define PF_ARM_SVE_B16B16_INSTRUCTIONS_AVAILABLE   54
#define PF_ARM_SVE_SHA3_INSTRUCTIONS_AVAILABLE     55
#define PF_ARM_SVE_SM4_INSTRUCTIONS_AVAILABLE      56
#define PF_ARM_SVE_I8MM_INSTRUCTIONS_AVAILABLE     57
#define PF_ARM_SVE_F32MM_INSTRUCTIONS_AVAILABLE    58
#define PF_ARM_SVE_F64MM_INSTRUCTIONS_AVAILABLE    59
#define PF_BMI2_INSTRUCTIONS_AVAILABLE             60
#define PF_MOVDIR64B_INSTRUCTION_AVAILABLE         61
#define PF_ARM_LSE2_AVAILABLE                      62
#define PF_RESERVED_FEATURE                        63
#define PF_ARM_SHA3_INSTRUCTIONS_AVAILABLE         64
#define PF_ARM_SHA512_INSTRUCTIONS_AVAILABLE       65
#define PF_ARM_V82_I8MM_INSTRUCTIONS_AVAILABLE     66
#define PF_ARM_V82_FP16_INSTRUCTIONS_AVAILABLE     67
#define PF_ARM_V86_BF16_INSTRUCTIONS_AVAILABLE     68
#define PF_ARM_V86_EBF16_INSTRUCTIONS_AVAILABLE    69
#define PF_ARM_SME_INSTRUCTIONS_AVAILABLE          70
#define PF_ARM_SME2_INSTRUCTIONS_AVAILABLE         71
#define PF_ARM_SME2_1_INSTRUCTIONS_AVAILABLE       72
#define PF_ARM_SME2_2_INSTRUCTIONS_AVAILABLE       73
#define PF_ARM_SME_AES_INSTRUCTIONS_AVAILABLE      74
#define PF_ARM_SME_SBITPERM_INSTRUCTIONS_AVAILABLE 75
#define PF_ARM_SME_SF8MM4_INSTRUCTIONS_AVAILABLE   76
#define PF_ARM_SME_SF8MM8_INSTRUCTIONS_AVAILABLE   77
#define PF_ARM_SME_SF8DP2_INSTRUCTIONS_AVAILABLE   78
#define PF_ARM_SME_SF8DP4_INSTRUCTIONS_AVAILABLE   79
#define PF_ARM_SME_SF8FMA_INSTRUCTIONS_AVAILABLE   80
#define PF_ARM_SME_F8F32_INSTRUCTIONS_AVAILABLE    81
#define PF_ARM_SME_F8F16_INSTRUCTIONS_AVAILABLE    82
#define PF_ARM_SME_F16F16_INSTRUCTIONS_AVAILABLE   83
#define PF_ARM_SME_B16B16_INSTRUCTIONS_AVAILABLE   84
#define PF_ARM_SME_F64F64_INSTRUCTIONS_AVAILABLE   85
#define PF_ARM_SME_I16I64_INSTRUCTIONS_AVAILABLE   86
#define PF_ARM_SME_LUTv2_INSTRUCTIONS_AVAILABLE    87
#define PF_ARM_SME_FA64_INSTRUCTIONS_AVAILABLE     88
#endif

typedef struct _EMU_NT_TIB64
{
    EMULATOR_CAST(std::uint64_t, struct _EXCEPTION_REGISTRATION_RECORD*) ExceptionList;
    std::uint64_t StackBase;
    std::uint64_t StackLimit;
    std::uint64_t SubSystemTib;
    std::uint64_t FiberData;
    std::uint64_t ArbitraryUserPointer;
    EMULATOR_CAST(std::uint64_t, struct _EMU_NT_TIB64*) Self;
} EMU_NT_TIB64, *PEMU_NT_TIB64;

typedef struct _EMU_NT_TIB32
{
    EMULATOR_CAST(std::uint32_t, struct _EXCEPTION_REGISTRATION_RECORD*) ExceptionList;
    std::uint32_t StackBase;
    std::uint32_t StackLimit;
    std::uint32_t SubSystemTib;
    std::uint32_t FiberData;
    std::uint32_t ArbitraryUserPointer;
    EMULATOR_CAST(std::uint32_t, struct _EMU_NT_TIB32*) Self;
} EMU_NT_TIB32, *PEMU_NT_TIB32;

union PEB_BITFIELD_UNION
{
    BOOLEAN BitField;

    struct
    {
        BOOLEAN ImageUsesLargePages : 1;
        BOOLEAN IsProtectedProcess : 1;
        BOOLEAN IsImageDynamicallyRelocated : 1;
        BOOLEAN SkipPatchingUser32Forwarders : 1;
        BOOLEAN IsPackagedProcess : 1;
        BOOLEAN IsAppContainer : 1;
        BOOLEAN IsProtectedProcessLight : 1;
        BOOLEAN IsLongPathAwareProcess : 1;
    };
};

#ifndef OS_WINDOWS

typedef struct _LIST_ENTRY64
{
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64, *PLIST_ENTRY64, *RESTRICTED_POINTER PRLIST_ENTRY64;

typedef struct _LIST_ENTRY32
{
    ULONG Flink;
    ULONG Blink;
} LIST_ENTRY32, *PLIST_ENTRY32, *RESTRICTED_POINTER PRLIST_ENTRY32;

typedef enum _PROCESS_MITIGATION_POLICY
{
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    ProcessSideChannelIsolationPolicy,
    ProcessUserShadowStackPolicy,
    ProcessRedirectionTrustPolicy,
    ProcessUserPointerAuthPolicy,
    ProcessSEHOPPolicy,
    ProcessActivationContextTrustPolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;

#define WOW64_SIZE_OF_80387_REGISTERS     80

#define WOW64_MAXIMUM_SUPPORTED_EXTENSION 512

typedef struct _WOW64_FLOATING_SAVE_AREA
{
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];
    DWORD Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef struct _WOW64_CONTEXT
{
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    WOW64_FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];

} WOW64_CONTEXT;

#define MEM_EXTENDED_PARAMETER_GRAPHICS            0x00000001
#define MEM_EXTENDED_PARAMETER_NONPAGED            0x00000002
#define MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL 0x00000004
#define MEM_EXTENDED_PARAMETER_NONPAGED_LARGE      0x00000008
#define MEM_EXTENDED_PARAMETER_NONPAGED_HUGE       0x00000010
#define MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES    0x00000020
#define MEM_EXTENDED_PARAMETER_EC_CODE             0x00000040
#define MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT       0x00000080

typedef enum MEM_EXTENDED_PARAMETER_TYPE
{
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements,
    MemExtendedParameterNumaNode,
    MemExtendedParameterPartitionHandle,
    MemExtendedParameterUserPhysicalHandle,
    MemExtendedParameterAttributeFlags,
    MemExtendedParameterImageMachine,
    MemExtendedParameterMax
} MEM_EXTENDED_PARAMETER_TYPE, *PMEM_EXTENDED_PARAMETER_TYPE;

#endif

typedef struct _PEB_LDR_DATA64
{
    ULONG Length;
    BOOLEAN Initialized;
    EmulatorTraits<Emu64>::HANDLE SsHandle;
    LIST_ENTRY64 InLoadOrderModuleList;
    LIST_ENTRY64 InMemoryOrderModuleList;
    LIST_ENTRY64 InInitializationOrderModuleList;
    std::uint64_t EntryInProgress;
    BOOLEAN ShutdownInProgress;
    EmulatorTraits<Emu64>::HANDLE ShutdownThreadId;
} PEB_LDR_DATA64, *PPEB_LDR_DATA64;

typedef struct _PEB_LDR_DATA32
{
    ULONG Length;
    BOOLEAN Initialized;
    EmulatorTraits<Emu32>::HANDLE SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    std::uint32_t EntryInProgress;
    BOOLEAN ShutdownInProgress;
    EmulatorTraits<Emu32>::HANDLE ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

static_assert(sizeof(PEB_LDR_DATA32) == 48);

using STRING64 = UNICODE_STRING<EmulatorTraits<Emu64>>;
using ANSI_STRING64 = STRING64;
using OEM_STRING64 = STRING64;

typedef struct _RTL_DRIVE_LETTER_CURDIR64
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING64 DosPath;
} RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64;

#define RTL_MAX_DRIVE_LETTERS  32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

template <typename T, size_t Size>
struct ARRAY_CONTAINER
{
    T arr[Size];
};

typedef struct _CURDIR64
{
    UNICODE_STRING<EmulatorTraits<Emu64>> DosPath;
    EmulatorTraits<Emu64>::HANDLE Handle;
} CURDIR64, *PCURDIR64;

#define RTL_USER_PROCESS_PARAMETERS_NORMALIZED            0x01
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_USER          0x02
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_KERNEL        0x04
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_SERVER        0x08
#define RTL_USER_PROCESS_PARAMETERS_RESERVE_1MB           0x20
#define RTL_USER_PROCESS_PARAMETERS_RESERVE_16MB          0x40
#define RTL_USER_PROCESS_PARAMETERS_CASE_SENSITIVE        0x80
#define RTL_USER_PROCESS_PARAMETERS_DISABLE_HEAP_DECOMMIT 0x100
#define RTL_USER_PROCESS_PARAMETERS_DLL_REDIRECTION_LOCAL 0x1000
#define RTL_USER_PROCESS_PARAMETERS_APP_MANIFEST_PRESENT  0x2000
#define RTL_USER_PROCESS_PARAMETERS_IMAGE_KEY_MISSING     0x4000
#define RTL_USER_PROCESS_PARAMETERS_NX_OPTIN              0x20000

typedef struct _RTL_USER_PROCESS_PARAMETERS64
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    EmulatorTraits<Emu64>::HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    EmulatorTraits<Emu64>::HANDLE StandardInput;
    EmulatorTraits<Emu64>::HANDLE StandardOutput;
    EmulatorTraits<Emu64>::HANDLE StandardError;

    CURDIR64 CurrentDirectory;
    UNICODE_STRING<EmulatorTraits<Emu64>> DllPath;
    UNICODE_STRING<EmulatorTraits<Emu64>> ImagePathName;
    UNICODE_STRING<EmulatorTraits<Emu64>> CommandLine;
    std::uint64_t Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING<EmulatorTraits<Emu64>> WindowTitle;
    UNICODE_STRING<EmulatorTraits<Emu64>> DesktopInfo;
    UNICODE_STRING<EmulatorTraits<Emu64>> ShellInfo;
    UNICODE_STRING<EmulatorTraits<Emu64>> RuntimeData;
    ARRAY_CONTAINER<RTL_DRIVE_LETTER_CURDIR64, RTL_MAX_DRIVE_LETTERS> CurrentDirectories;

    std::uint64_t EnvironmentSize;
    std::uint64_t EnvironmentVersion;

    std::uint64_t PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING<EmulatorTraits<Emu64>> RedirectionDllName; // REDSTONE4
    UNICODE_STRING<EmulatorTraits<Emu64>> HeapPartitionName;  // 19H1
    std::uint64_t DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
    ULONG DefaultThreadpoolThreadMaximum;
    ULONG HeapMemoryTypeMask; // WIN11
} RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64;

static_assert(sizeof(RTL_USER_PROCESS_PARAMETERS64) == 0x448);

union PEB_CROSS_PROCESS_FLAGS_UNION
{
    ULONG CrossProcessFlags;

    struct
    {
        ULONG ProcessInJob : 1;
        ULONG ProcessInitializing : 1;
        ULONG ProcessUsingVEH : 1;
        ULONG ProcessUsingVCH : 1;
        ULONG ProcessUsingFTH : 1;
        ULONG ProcessPreviouslyThrottled : 1;
        ULONG ProcessCurrentlyThrottled : 1;
        ULONG ProcessImagesHotPatched : 1; // REDSTONE5
        ULONG ReservedBits0 : 24;
    };
};

union PEB_KERNEL_CALLBACK_TABLE_UNION64
{
    std::uint64_t KernelCallbackTable;
    std::uint64_t UserSharedInfoPtr;
};

typedef struct _API_SET_NAMESPACE
{
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    ULONG EntryOffset;
    ULONG HashOffset;
    ULONG HashFactor;
} API_SET_NAMESPACE, *PAPI_SET_NAMESPACE;

union PEB_CONTEXT_DATA_UNION64
{
    std::uint64_t pContextData; // WIN7
    std::uint64_t pUnused;      // WIN10
    std::uint64_t EcCodeBitMap; // WIN11
};

union PEB_TRACING_FLAGS_UNION
{
    ULONG TracingFlags;

    struct
    {
        ULONG HeapTracingEnabled : 1;
        ULONG CritSecTracingEnabled : 1;
        ULONG LibLoaderTracingEnabled : 1;
        ULONG SpareTracingBits : 29;
    };
};

union PEB_LEAP_SECONDS_FLAG_UNION
{
    ULONG LeapSecondFlags;

    struct
    {
        ULONG SixtySecondEnabled : 1;
        ULONG Reserved : 31;
    };
};

#define MAXIMUM_LEADBYTES 12

typedef struct _CPTABLEINFO
{
    USHORT CodePage;
    USHORT MaximumCharacterSize;
    USHORT DefaultChar;
    USHORT UniDefaultChar;
    USHORT TransDefaultChar;
    USHORT TransUniDefaultChar;
    USHORT DBCSCodePage;
    UCHAR LeadByte[MAXIMUM_LEADBYTES];
    EMULATOR_CAST(uint64_t, USHORT*) MultiByteTable;
    EMULATOR_CAST(uint64_t, void*) WideCharTable;
    EMULATOR_CAST(uint64_t, USHORT*) DBCSRanges;
    EMULATOR_CAST(uint64_t, USHORT*) DBCSOffsets;
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO
{
    CPTABLEINFO OemTableInfo;
    CPTABLEINFO AnsiTableInfo;
    EMULATOR_CAST(uint64_t, USHORT*) UpperCaseTable;
    EMULATOR_CAST(uint64_t, USHORT*) LowerCaseTable;
} NLSTABLEINFO, *PNLSTABLEINFO;

typedef struct _CURDIR32
{
    UNICODE_STRING<EmulatorTraits<Emu32>> DosPath;
    EmulatorTraits<Emu32>::HANDLE Handle;
} CURDIR32, *PCURDIR32;

static_assert(sizeof(CURDIR32) == 12);

typedef struct _RTL_DRIVE_LETTER_CURDIR32
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    UNICODE_STRING<EmulatorTraits<Emu32>> DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

static_assert(sizeof(RTL_DRIVE_LETTER_CURDIR32) == 16);

typedef struct _RTL_USER_PROCESS_PARAMETERS32
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    EmulatorTraits<Emu32>::HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    EmulatorTraits<Emu32>::HANDLE StandardInput;
    EmulatorTraits<Emu32>::HANDLE StandardOutput;
    EmulatorTraits<Emu32>::HANDLE StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING<EmulatorTraits<Emu32>> DllPath;
    UNICODE_STRING<EmulatorTraits<Emu32>> ImagePathName;
    UNICODE_STRING<EmulatorTraits<Emu32>> CommandLine;
    std::uint32_t Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING<EmulatorTraits<Emu32>> WindowTitle;
    UNICODE_STRING<EmulatorTraits<Emu32>> DesktopInfo;
    UNICODE_STRING<EmulatorTraits<Emu32>> ShellInfo;
    UNICODE_STRING<EmulatorTraits<Emu32>> RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    std::uint32_t EnvironmentSize;
    std::uint32_t EnvironmentVersion;

    std::uint32_t PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING<EmulatorTraits<Emu32>> RedirectionDllName; // REDSTONE4
    UNICODE_STRING<EmulatorTraits<Emu32>> HeapPartitionName;  // 19H1
    std::uint32_t DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
    ULONG DefaultThreadpoolThreadMaximum;
    ULONG HeapMemoryTypeMask; // WIN11
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

static_assert(sizeof(RTL_USER_PROCESS_PARAMETERS32) == 708);

typedef struct _PEB64
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    PEB_BITFIELD_UNION BitField;

    EmulatorTraits<Emu64>::HANDLE Mutant;

    std::uint64_t ImageBaseAddress;
    EMULATOR_CAST(std::uint64_t, PPEB_LDR_DATA64) Ldr;
    EMULATOR_CAST(std::uint64_t, PRTL_USER_PROCESS_PARAMETERS64) ProcessParameters;
    std::uint64_t SubSystemData;
    std::uint64_t ProcessHeap;
    EMULATOR_CAST(std::uint64_t, PRTL_CRITICAL_SECTION) FastPebLock;
    EMULATOR_CAST(std::uint64_t, PSLIST_HEADER) AtlThunkSListPtr;
    std::uint64_t IFEOKey;
    PEB_CROSS_PROCESS_FLAGS_UNION CrossProcessFlags;
    PEB_KERNEL_CALLBACK_TABLE_UNION64 KernelCallbackTable;

    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    EMULATOR_CAST(std::uint64_t, PAPI_SET_NAMESPACE) ApiSetMap;
    ULONG TlsExpansionCounter;
    EMULATOR_CAST(std::uint64_t, PRTL_BITMAP) TlsBitmap;

    ARRAY_CONTAINER<ULONG, 2> TlsBitmapBits; // TLS_MINIMUM_AVAILABLE
    std::uint64_t ReadOnlySharedMemoryBase;
    EMULATOR_CAST(std::uint64_t, PSILO_USER_SHARED_DATA) SharedData; // HotpatchInformation
    std::uint64_t ReadOnlyStaticServerData;

    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PCPTABLEINFO) AnsiCodePageData;      // PCPTABLEINFO
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PCPTABLEINFO) OemCodePageData;       // PCPTABLEINFO
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PNLSTABLEINFO) UnicodeCaseTableData; // PNLSTABLEINFO

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    ULARGE_INTEGER CriticalSectionTimeout;
    EMULATOR_CAST(std::uint64_t, SIZE_T) HeapSegmentReserve;
    EMULATOR_CAST(std::uint64_t, SIZE_T) HeapSegmentCommit;
    EMULATOR_CAST(std::uint64_t, SIZE_T) HeapDeCommitTotalFreeThreshold;
    EMULATOR_CAST(std::uint64_t, SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    std::uint64_t ProcessHeaps; // PHEAP

    std::uint64_t GdiSharedHandleTable; // PGDI_SHARED_MEMORY
    std::uint64_t ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    EMULATOR_CAST(std::uint64_t, PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    EMULATOR_CAST(std::uint64_t, KAFFINITY) ActiveProcessAffinityMask;
    ARRAY_CONTAINER<ULONG, GDI_HANDLE_BUFFER_SIZE64> GdiHandleBuffer;
    std::uint64_t PostProcessInitRoutine;

    EMULATOR_CAST(std::uint64_t, PRTL_BITMAP) TlsExpansionBitmap;
    ARRAY_CONTAINER<ULONG, 32> TlsExpansionBitmapBits; // TLS_EXPANSION_SLOTS

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags; // KACF_*
    ULARGE_INTEGER AppCompatFlagsUser;
    std::uint64_t pShimData;
    std::uint64_t AppCompatInfo; // APPCOMPAT_EXE_DATA

    UNICODE_STRING<EmulatorTraits<Emu64>> CSDVersion;

    EMULATOR_CAST(std::uint64_t, PACTIVATION_CONTEXT_DATA) ActivationContextData;
    EMULATOR_CAST(std::uint64_t, PASSEMBLY_STORAGE_MAP) ProcessAssemblyStorageMap;
    EMULATOR_CAST(std::uint64_t, PACTIVATION_CONTEXT_DATA) SystemDefaultActivationContextData;
    EMULATOR_CAST(std::uint64_t, PASSEMBLY_STORAGE_MAP) SystemAssemblyStorageMap;

    EMULATOR_CAST(std::uint64_t, SIZE_T) MinimumStackCommit;

    ARRAY_CONTAINER<std::uint64_t, 2> SparePointers; // 19H1 (previously FlsCallback to FlsHighIndex)
    std::uint64_t PatchLoaderData;
    std::uint64_t ChpeV2ProcessInfo; // _CHPEV2_PROCESS_INFO

    ULONG AppModelFeatureState;
    ARRAY_CONTAINER<ULONG, 2> SpareUlongs;

    USHORT ActiveCodePage;
    USHORT OemCodePage;
    USHORT UseCaseMapping;
    USHORT UnusedNlsField;

    std::uint64_t WerRegistrationData;
    std::uint64_t WerShipAssertPtr;

    PEB_CONTEXT_DATA_UNION64 ContextData;

    std::uint64_t pImageHeaderHash;
    PEB_TRACING_FLAGS_UNION TracingFlags;

    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    EMULATOR_CAST(std::uint64_t, PRTL_CRITICAL_SECTION) TppWorkerpListLock;
    LIST_ENTRY64 TppWorkerpList;
    ARRAY_CONTAINER<std::uint64_t, 128> WaitOnAddressHashTable;
    EMULATOR_CAST(std::uint64_t, PTELEMETRY_COVERAGE_HEADER) TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    ARRAY_CONTAINER<CHAR, 7> PlaceholderCompatibilityModeReserved;
    EMULATOR_CAST(std::uint64_t, PLEAP_SECOND_DATA) LeapSecondData; // REDSTONE5
    PEB_LEAP_SECONDS_FLAG_UNION LeapSecondFlags;

    ULONG NtGlobalFlag2;
    ULONGLONG ExtendedFeatureDisableMask; // since WIN11
} PEB64, *PPEB64;

static_assert(sizeof(PEB64) == 0x7D0);

typedef struct _PEB32
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };

    EmulatorTraits<Emu32>::HANDLE Mutant;

    std::uint32_t ImageBaseAddress;
    EMULATOR_CAST(std::uint32_t, PPEB_LDR_DATA32) Ldr;
    EMULATOR_CAST(std::uint32_t, struct _RTL_USER_PROCESS_PARAMETERS32*) ProcessParameters;
    EMULATOR_CAST(std::uint32_t, PVOID32) SubSystemData;
    EMULATOR_CAST(std::uint32_t, PVOID32) ProcessHeap;
    EMULATOR_CAST(std::uint32_t, struct _RTL_CRITICAL_SECTION32*) FastPebLock;
    EMULATOR_CAST(std::uint32_t, union _SLIST_HEADER*) AtlThunkSListPtr;
    EMULATOR_CAST(std::uint32_t, PVOID32) IFEOKey;

    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1; // REDSTONE5
            ULONG ReservedBits0 : 24;
        };
    };
    union
    {
        EMULATOR_CAST(std::uint32_t, PVOID32) KernelCallbackTable;
        EMULATOR_CAST(std::uint32_t, PVOID32) UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    EMULATOR_CAST(std::uint32_t, struct _API_SET_NAMESPACE*) ApiSetMap;
    ULONG TlsExpansionCounter;
    EMULATOR_CAST(std::uint32_t, struct _RTL_BITMAP*) TlsBitmap;
    ARRAY_CONTAINER<ULONG, 2> TlsBitmapBits;

    EMULATOR_CAST(std::uint32_t, PVOID32) ReadOnlySharedMemoryBase;
    EMULATOR_CAST(std::uint32_t, struct _SILO_USER_SHARED_DATA*) SharedData; // HotpatchInformation
    EMULATOR_CAST(std::uint32_t, PVOID32*) ReadOnlyStaticServerData;

    EMULATOR_CAST(std::uint32_t, PVOID32) AnsiCodePageData;     // PCPTABLEINFO
    EMULATOR_CAST(std::uint32_t, PVOID32) OemCodePageData;      // PCPTABLEINFO
    EMULATOR_CAST(std::uint32_t, PVOID32) UnicodeCaseTableData; // PNLSTABLEINFO

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    ULARGE_INTEGER CriticalSectionTimeout;
    EMULATOR_CAST(std::uint32_t, SIZE_T32) HeapSegmentReserve;
    EMULATOR_CAST(std::uint32_t, SIZE_T32) HeapSegmentCommit;
    EMULATOR_CAST(std::uint32_t, SIZE_T32) HeapDeCommitTotalFreeThreshold;
    EMULATOR_CAST(std::uint32_t, SIZE_T32) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    EMULATOR_CAST(std::uint32_t, PVOID32*) ProcessHeaps; // PHEAP

    EMULATOR_CAST(std::uint32_t, PVOID32) GdiSharedHandleTable; // PGDI_SHARED_MEMORY
    EMULATOR_CAST(std::uint32_t, PVOID32) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    EMULATOR_CAST(std::uint32_t, struct _RTL_CRITICAL_SECTION32*) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    EMULATOR_CAST(std::uint32_t, KAFFINITY32) ActiveProcessAffinityMask;
    ARRAY_CONTAINER<ULONG, GDI_HANDLE_BUFFER_SIZE32> GdiHandleBuffer;
    EMULATOR_CAST(std::uint32_t, PVOID32) PostProcessInitRoutine;

    EMULATOR_CAST(std::uint32_t, PVOID32) TlsExpansionBitmap;
    ARRAY_CONTAINER<ULONG, 32> TlsExpansionBitmapBits;

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    EMULATOR_CAST(std::uint32_t, PVOID32) pShimData;
    EMULATOR_CAST(std::uint32_t, PVOID32) AppCompatInfo; // APPCOMPAT_EXE_DATA

    UNICODE_STRING<EmulatorTraits<Emu32>> CSDVersion;

    EMULATOR_CAST(std::uint32_t, struct _ACTIVATION_CONTEXT_DATA*) ActivationContextData;
    EMULATOR_CAST(std::uint32_t, struct _ASSEMBLY_STORAGE_MAP32*) ProcessAssemblyStorageMap;
    EMULATOR_CAST(std::uint32_t, struct _ACTIVATION_CONTEXT_DATA*) SystemDefaultActivationContextData;
    EMULATOR_CAST(std::uint32_t, struct _ASSEMBLY_STORAGE_MAP32*) SystemAssemblyStorageMap;

    EMULATOR_CAST(std::uint32_t, SIZE_T32) MinimumStackCommit;

    ARRAY_CONTAINER<ULONG, 2> SparePointers; // 19H1 (previously FlsCallback to FlsHighIndex)
    EMULATOR_CAST(std::uint32_t, PVOID32) PatchLoaderData;
    EMULATOR_CAST(std::uint32_t, PVOID32) ChpeV2ProcessInfo; // _CHPEV2_PROCESS_INFO

    ULONG AppModelFeatureState;
    ULONG SpareUlongs[2];

    USHORT ActiveCodePage;
    USHORT OemCodePage;
    USHORT UseCaseMapping;
    USHORT UnusedNlsField;

    EMULATOR_CAST(std::uint32_t, PVOID32) WerRegistrationData;
    EMULATOR_CAST(std::uint32_t, PVOID32) WerShipAssertPtr;

    union
    {
        EMULATOR_CAST(std::uint32_t, PVOID32) pContextData; // WIN7
        EMULATOR_CAST(std::uint32_t, PVOID32) pUnused;      // WIN10
        EMULATOR_CAST(std::uint32_t, PVOID32) EcCodeBitMap; // WIN11
    };

    EMULATOR_CAST(std::uint32_t, PVOID32) pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    EMULATOR_CAST(std::uint32_t, struct _RTL_CRITICAL_SECTION32*) TppWorkerpListLock;
    LIST_ENTRY32 TppWorkerpList;
    ARRAY_CONTAINER<ULONG, 128> WaitOnAddressHashTable;
    EMULATOR_CAST(std::uint32_t, struct _PTELEMETRY_COVERAGE_HEADER*) TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    ARRAY_CONTAINER<CHAR, 7> PlaceholderCompatibilityModeReserved;
    EMULATOR_CAST(std::uint32_t, struct _LEAP_SECOND_DATA*) LeapSecondData; // REDSTONE5
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
    ULONGLONG ExtendedFeatureDisableMask; // since WIN11

} PEB32, *PPEB32;

static_assert(sizeof(PEB32) == 0x488, "sizeof(PEB32) is incorrect"); // WIN11

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME64
{
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
    EMULATOR_CAST(std::uint64_t, ACTIVATION_CONTEXT) ActivationContext;
    ULONG Flags; // RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_*
} RTL_ACTIVATION_CONTEXT_STACK_FRAME64, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME64;

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY32
{
    ULONG Flags;
    UNICODE_STRING<EmulatorTraits<Emu32>> DosPath;
    EMULATOR_CAST(std::uint32_t, HANDLE32) Handle;
} ASSEMBLY_STORAGE_MAP_ENTRY32, *PASSEMBLY_STORAGE_MAP_ENTRY32;

static_assert(sizeof(ASSEMBLY_STORAGE_MAP_ENTRY32) == 16);

typedef struct _ASSEMBLY_STORAGE_MAP32
{
    ULONG Flags;
    ULONG AssemblyCount;
    EMULATOR_CAST(std::uint32_t, PASSEMBLY_STORAGE_MAP_ENTRY32*) AssemblyArray;
} ASSEMBLY_STORAGE_MAP32, *PASSEMBLY_STORAGE_MAP32;

static_assert(sizeof(ASSEMBLY_STORAGE_MAP32) == 12);

typedef struct _ACTIVATION_CONTEXT32
{
    LONG RefCount;
    ULONG Flags;
    EMULATOR_CAST(std::uint32_t, struct _ACTIVATION_CONTEXT_DATA*) ActivationContextData;
    std::uint32_t /*PACTIVATION_CONTEXT_NOTIFY_ROUTINE*/ NotificationRoutine;
    std::uint32_t NotificationContext;
    ULONG SentNotifications[8];
    ULONG DisabledNotifications[8];
    ASSEMBLY_STORAGE_MAP32 StorageMap;
    EMULATOR_CAST(std::uint32_t, PASSEMBLY_STORAGE_MAP_ENTRY32) InlineStorageMapEntries[32];
} ACTIVATION_CONTEXT32, *PACTIVATION_CONTEXT32;

static_assert(sizeof(ACTIVATION_CONTEXT32) == 224);

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME32
{
    EMULATOR_CAST(std::uint32_t, struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME32*) Previous;
    EMULATOR_CAST(std::uint32_t, PACTIVATION_CONTEXT32) ActivationContext;
    ULONG Flags; // RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_*
} RTL_ACTIVATION_CONTEXT_STACK_FRAME32, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME32;

static_assert(sizeof(RTL_ACTIVATION_CONTEXT_STACK_FRAME32) == 12);

typedef struct _ACTIVATION_CONTEXT_STACK32
{
    EMULATOR_CAST(std::uint32_t, PRTL_ACTIVATION_CONTEXT_STACK_FRAME32) ActiveFrame;
    LIST_ENTRY32 FrameListCache;
    ULONG Flags; // ACTIVATION_CONTEXT_STACK_FLAG_*
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK32, *PACTIVATION_CONTEXT_STACK32;

static_assert(sizeof(ACTIVATION_CONTEXT_STACK32) == 24);

typedef struct _ACTIVATION_CONTEXT_STACK64
{
    EMULATOR_CAST(std::uint64_t, PRTL_ACTIVATION_CONTEXT_STACK_FRAME64) ActiveFrame;
    LIST_ENTRY64 FrameListCache;
    ULONG Flags; // ACTIVATION_CONTEXT_STACK_FLAG_*
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK64, *PACTIVATION_CONTEXT_STACK64;

typedef struct _GDI_TEB_BATCH64
{
    ULONG Offset;
    std::uint64_t HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH64, *PGDI_TEB_BATCH64;

typedef struct _GDI_TEB_BATCH32
{
    ULONG Offset;
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

static_assert(sizeof(GDI_TEB_BATCH32) == 1248, "sizeof(GDI_TEB_BATCH32) is incorrect");

#ifndef OS_WINDOWS
typedef struct _GUID
{
    uint32_t Data1;
    uint16_t Data2;
    uint16_t Data3;
    uint8_t Data4[8];
} GUID;

typedef struct _PROCESSOR_NUMBER
{
    WORD Group;
    BYTE Number;
    BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;

#endif

union TEB_CURRENT_IDEAL_PROCESSOR_UNION
{
    PROCESSOR_NUMBER CurrentIdealProcessor;
    ULONG IdealProcessorValue;

    struct
    {
        UCHAR ReservedPad0;
        UCHAR ReservedPad1;
        UCHAR ReservedPad2;
        UCHAR IdealProcessor;
    };
};

union TEB_CROSS_TEB_FLAGS_UNION
{
    USHORT CrossTebFlags;
    USHORT SpareCrossTebBits : 16;
};

constexpr auto THREAD_CREATE_FLAGS_CREATE_SUSPENDED = 0x1;
constexpr auto THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH = 0x2;
constexpr auto THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER = 0x4;
constexpr auto THREAD_CREATE_FLAGS_LOADER_WORKER = 0x10;
constexpr auto THREAD_CREATE_FLAGS_SKIP_LOADER_INIT = 0x20;
constexpr auto THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE = 0x40;

union TEB_SAME_TEB_FLAGS_UNION
{
    USHORT SameTebFlags;

    struct
    {
        USHORT SafeThunkCall : 1;
        USHORT InDebugPrint : 1;
        USHORT HasFiberData : 1;
        USHORT SkipThreadAttach : 1;
        USHORT WerInShipAssertCode : 1;
        USHORT RanProcessInit : 1;
        USHORT ClonedThread : 1;
        USHORT SuppressDebugMsg : 1;
        USHORT DisableUserStackWalk : 1;
        USHORT RtlExceptionAttached : 1;
        USHORT InitialThread : 1;
        USHORT SessionAware : 1;
        USHORT LoadOwner : 1;
        USHORT LoaderWorker : 1;
        USHORT SkipLoaderInit : 1;
        USHORT SkipFileAPIBrokering : 1;
    };
};

#ifndef OS_WINDOWS
using LCID = DWORD;
using LANGID = WORD;
#endif

typedef struct _TEB64
{
    EMU_NT_TIB64 NtTib;

    std::uint64_t EnvironmentPointer;
    CLIENT_ID64 ClientId;
    std::uint64_t ActiveRpcHandle;
    std::uint64_t ThreadLocalStoragePointer;
    EMULATOR_CAST(std::uint64_t, PPEB64) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    std::uint64_t CsrClientThread;
    std::uint64_t Win32ThreadInfo;
    ARRAY_CONTAINER<ULONG, 26> User32Reserved;
    ARRAY_CONTAINER<ULONG, 5> UserReserved;
    std::uint64_t WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    ARRAY_CONTAINER<std::uint64_t, 16> ReservedForDebuggerInstrumentation;
    ARRAY_CONTAINER<std::uint64_t, 25> SystemReserved1;
    std::uint64_t HeapFlsData;
    ARRAY_CONTAINER<std::uint64_t, 4> RngState;
    CHAR PlaceholderCompatibilityMode;
    BOOLEAN PlaceholderHydrationAlwaysExplicit;
    ARRAY_CONTAINER<CHAR, 10> PlaceholderReserved;

    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK64 ActivationStack;

    ARRAY_CONTAINER<UCHAR, 8> WorkingOnBehalfTicket;

    NTSTATUS ExceptionCode;

    EMULATOR_CAST(std::uint64_t, PACTIVATION_CONTEXT_STACK64) ActivationContextStackPointer;
    std::uint64_t InstrumentationCallbackSp;
    std::uint64_t InstrumentationCallbackPreviousPc;
    std::uint64_t InstrumentationCallbackPreviousSp;
    ULONG TxFsContext;
    BOOLEAN InstrumentationCallbackDisabled;
    BOOLEAN UnalignedLoadStoreExceptions;
    GDI_TEB_BATCH64 GdiTebBatch;
    CLIENT_ID64 RealClientId;
    EmulatorTraits<Emu64>::HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    std::uint64_t GdiThreadLocalInfo;
    ARRAY_CONTAINER<std::uint64_t, WIN32_CLIENT_INFO_LENGTH> Win32ClientInfo;

    ARRAY_CONTAINER<std::uint64_t, 233> glDispatchTable;
    ARRAY_CONTAINER<std::uint64_t, 29> glReserved1;
    std::uint64_t glReserved2;
    std::uint64_t glSectionInfo;
    std::uint64_t glSection;
    std::uint64_t glTable;
    std::uint64_t glCurrentRC;
    std::uint64_t glContext;

    NTSTATUS LastStatusValue;

    UNICODE_STRING<EmulatorTraits<Emu64>> StaticUnicodeString;
    ARRAY_CONTAINER<char16_t, STATIC_UNICODE_BUFFER_LENGTH> StaticUnicodeBuffer;

    std::uint64_t DeallocationStack;

    ARRAY_CONTAINER<std::uint64_t, TLS_MINIMUM_AVAILABLE> TlsSlots;
    LIST_ENTRY64 TlsLinks;

    std::uint64_t Vdm;
    std::uint64_t ReservedForNtRpc;
    ARRAY_CONTAINER<std::uint64_t, 2> DbgSsReserved;

    ULONG HardErrorMode;
    ARRAY_CONTAINER<std::uint64_t, 11> Instrumentation;
    GUID ActivityId;

    std::uint64_t SubProcessTag;
    std::uint64_t PerflibData;
    std::uint64_t EtwTraceData;
    std::uint64_t WinSockData;
    ULONG GdiBatchCount;

    TEB_CURRENT_IDEAL_PROCESSOR_UNION CurrentIdealProcessor;

    ULONG GuaranteedStackBytes;
    std::uint64_t ReservedForPerf;
    std::uint64_t ReservedForOle; // tagSOleTlsData
    ULONG WaitingOnLoaderLock;
    std::uint64_t SavedPriorityState;
    std::uint64_t ReservedForCodeCoverage;
    std::uint64_t ThreadPoolData;
    std::uint64_t TlsExpansionSlots;
    std::uint64_t ChpeV2CpuAreaInfo; // CHPEV2_CPUAREA_INFO // previously DeallocationBStore
    std::uint64_t Unused;            // previously BStoreLimit
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    std::uint64_t NlsCache;
    std::uint64_t pShimData;
    ULONG HeapData;
    EmulatorTraits<Emu64>::HANDLE CurrentTransactionHandle;
    EMULATOR_CAST(std::uint64_t, PTEB_ACTIVE_FRAME) ActiveFrame;
    std::uint64_t FlsData;

    std::uint64_t PreferredLanguages;
    std::uint64_t UserPrefLanguages;
    std::uint64_t MergedPrefLanguages;
    ULONG MuiImpersonation;

    TEB_CROSS_TEB_FLAGS_UNION CrossTebFlags;
    TEB_SAME_TEB_FLAGS_UNION SameTebFlags;

    std::uint64_t TxnScopeEnterCallback;
    std::uint64_t TxnScopeExitCallback;
    std::uint64_t TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    std::uint64_t ResourceRetValue;
    std::uint64_t ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
    ULONGLONG LastSleepCounter; // Win11
    ULONG SpinCallCount;
    ULONGLONG ExtendedFeatureDisableMask;
    std::uint64_t SchedulerSharedDataSlot; // 24H2
    std::uint64_t HeapWalkContext;
    EMU_GROUP_AFFINITY64 PrimaryGroupAffinity;
    ARRAY_CONTAINER<ULONG, 2> Rcu;
} TEB64, *PTEB64;

static_assert(sizeof(TEB64) == 0x1878);

#if defined(OS_WINDOWS) && defined(_WIN64)
inline TEB64* NtCurrentTeb64()
{
    return reinterpret_cast<TEB64*>(__readgsqword(FIELD_OFFSET(EMU_NT_TIB64, Self)));
}
#endif

typedef struct _TEB32
{
    EMU_NT_TIB32 NtTib;

    std::uint32_t EnvironmentPointer;
    CLIENT_ID32 ClientId;
    std::uint32_t ActiveRpcHandle;
    std::uint32_t ThreadLocalStoragePointer;
    EMULATOR_CAST(std::uint32_t, PPEB32) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    std::uint32_t CsrClientThread;
    std::uint32_t Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    std::uint32_t WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    std::uint32_t ReservedForDebuggerInstrumentation[16];
    std::uint32_t SystemReserved1[26];

    CHAR PlaceholderCompatibilityMode;
    BOOLEAN PlaceholderHydrationAlwaysExplicit;
    CHAR PlaceholderReserved[10];

    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK32 ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    EMULATOR_CAST(std::uint32_t, PACTIVATION_CONTEXT_STACK32) ActivationContextStackPointer;
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) InstrumentationCallbackSp;
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) InstrumentationCallbackPreviousPc;
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) InstrumentationCallbackPreviousSp;

    BOOLEAN InstrumentationCallbackDisabled;
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    EmulatorTraits<Emu32>::HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    std::uint32_t GdiThreadLocalInfo;
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH];
    std::uint32_t glDispatchTable[233];
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) glReserved1[29];
    std::uint32_t glReserved2;
    std::uint32_t glSectionInfo;
    std::uint32_t glSection;
    std::uint32_t glTable;
    std::uint32_t glCurrentRC;
    std::uint32_t glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING<EmulatorTraits<Emu32>> StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];

    std::uint32_t DeallocationStack;
    ARRAY_CONTAINER<std::uint32_t, TLS_MINIMUM_AVAILABLE> TlsSlots;
    LIST_ENTRY32 TlsLinks;

    std::uint32_t Vdm;
    std::uint32_t ReservedForNtRpc;
    std::uint32_t DbgSsReserved[2];

    ULONG HardErrorMode;
    std::uint32_t Instrumentation[9];
    GUID ActivityId;

    std::uint32_t SubProcessTag;
    std::uint32_t PerflibData;
    std::uint32_t EtwTraceData;
    std::uint32_t WinSockData;
    ULONG GdiBatchCount;

    union
    {
        EMULATOR_CAST(std::uint32_t, PROCESSOR_NUMBER) CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    EMULATOR_CAST(std::uint32_t, PVOID32) ReservedForPerf;
    EMULATOR_CAST(std::uint32_t, PVOID32) ReservedForOle; // tagSOleTlsData32
    ULONG WaitingOnLoaderLock;
    EMULATOR_CAST(std::uint32_t, PVOID32) SavedPriorityState;
    EMULATOR_CAST(std::uint32_t, ULONG_PTR32) ReservedForCodeCoverage;
    std::uint32_t ThreadPoolData;
    EMULATOR_CAST(std::uint32_t, PVOID32*) TlsExpansionSlots;
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    std::uint32_t NlsCache;
    std::uint32_t pShimData;
    ULONG HeapData;
    EMULATOR_CAST(std::uint32_t, HANDLE32) CurrentTransactionHandle;
    EMULATOR_CAST(std::uint32_t, PTEB_ACTIVE_FRAME32) ActiveFrame;
    std::uint32_t FlsData;

    std::uint32_t PreferredLanguages;
    std::uint32_t UserPrefLanguages;
    std::uint32_t MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SkipFileAPIBrokering : 1;
        };
    };

    std::uint32_t TxnScopeEnterCallback;
    std::uint32_t TxnScopeExitCallback;
    std::uint32_t TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    std::uint32_t ResourceRetValue;
    std::uint32_t ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
    ULONGLONG LastSleepCounter; // Win11
    ULONG SpinCallCount;
    ULONGLONG ExtendedFeatureDisableMask;
} TEB32, *PTEB32;

static_assert(sizeof(TEB32) == 4120, "sizeof(TEB32) is incorrect");

#pragma pack(push, 4)
typedef struct _KSYSTEM_TIME
{
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;
#pragma pack(pop)

typedef enum _NT_PRODUCT_TYPE
{
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
    StandardDesign,
    NEC98x86,
    EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

union KUSD_SHARED_DATA_FLAGS_UNION
{
    ULONG SharedDataFlags;

    struct
    {
        //
        // The following bit fields are for the debugger only. Do not use.
        // Use the bit definitions instead.
        //

        ULONG DbgErrorPortPresent : 1;
        ULONG DbgElevationEnabled : 1;
        ULONG DbgVirtEnabled : 1;
        ULONG DbgInstallerDetectEnabled : 1;
        ULONG DbgLkgEnabled : 1;
        ULONG DbgDynProcessorEnabled : 1;
        ULONG DbgConsoleBrokerEnabled : 1;
        ULONG DbgSecureBootEnabled : 1;
        ULONG DbgMultiSessionSku : 1;
        ULONG DbgMultiUsersInSessionSku : 1;
        ULONG DbgStateSeparationEnabled : 1;
        ULONG DbgSplitTokenEnabled : 1;
        ULONG DbgShadowAdminEnabled : 1;
        ULONG SpareBits : 19;
    };
};

union KUSD_TICK_COUNT_UNION
{
    volatile KSYSTEM_TIME TickCount;
    volatile std::uint64_t TickCountQuad;

    struct
    {
        ULONG ReservedTickCountOverlay[3];
        ULONG TickCountPad[1];
    };
};

union KUSD_VIRTUALIZATION_FLAGS_UNION
{
    UCHAR VirtualizationFlags;
};

union KUSD_MITIGATION_POLICIES_UNION
{
    UCHAR MitigationPolicies;

    struct
    {
        UCHAR NXSupportPolicy : 2;
        UCHAR SEHValidationPolicy : 2;
        UCHAR CurDirDevicesSkippedForDlls : 2;
        UCHAR Reserved : 2;
    };
};

union KUSD_QPC_DATA_UNION
{
    USHORT QpcData;

    struct
    {
        volatile UCHAR QpcBypassEnabled;
        UCHAR QpcReserved;
    };
};

#ifndef OS_WINDOWS
#define MAXIMUM_XSTATE_FEATURES 64

typedef struct _XSTATE_FEATURE
{
    ULONG Offset;
    ULONG Size;
} XSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION
{
    std::uint64_t EnabledFeatures;
    std::uint64_t EnabledVolatileFeatures;
    ULONG Size;
    union
    {
        ULONG ControlFlags;
        struct
        {
            ULONG OptimizedSave : 1;
            ULONG CompactionEnabled : 1;
            ULONG Reserved1 : 30;
        };
    };
    XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];
    std::uint64_t EnabledSupervisorFeatures;
    std::uint64_t AlignedFeatures;
    std::uint64_t AllFeatureSize;
    ULONG AllFeatures[MAXIMUM_XSTATE_FEATURES];
} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;

#endif

#define ORIGINALLY_VOLATILE /*volatile*/

typedef struct _KUSER_SHARED_DATA64
{
    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;
    ORIGINALLY_VOLATILE KSYSTEM_TIME InterruptTime;
    ORIGINALLY_VOLATILE KSYSTEM_TIME SystemTime;
    ORIGINALLY_VOLATILE KSYSTEM_TIME TimeZoneBias;
    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;
    ARRAY_CONTAINER<char16_t, 260> NtSystemRoot;
    ULONG MaxStackTraceDepth;
    ULONG CryptoExponent;
    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG AitSamplingValue;
    ULONG AppCompatFlag;
    ULONGLONG RNGSeedVersion;
    ULONG GlobalValidationRunlevel;
    ORIGINALLY_VOLATILE LONG TimeZoneBiasStamp;
    ULONG NtBuildNumber;
    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    BOOLEAN Reserved0;
    USHORT NativeProcessorArchitecture;
    ULONG NtMajorVersion;
    ULONG NtMinorVersion;
    ARRAY_CONTAINER<BOOLEAN, PROCESSOR_FEATURE_MAX> ProcessorFeatures;
    ULONG Reserved1;
    ULONG Reserved3;
    ORIGINALLY_VOLATILE ULONG TimeSlip;
    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG BootId;
    LARGE_INTEGER SystemExpirationDate;
    ULONG SuiteMask;
    BOOLEAN KdDebuggerEnabled;
    KUSD_MITIGATION_POLICIES_UNION MitigationPolicies;
    USHORT CyclesPerYield;
    ORIGINALLY_VOLATILE ULONG ActiveConsoleId;
    ORIGINALLY_VOLATILE ULONG DismountCount;
    ULONG ComPlusPackage;
    ULONG LastSystemRITEventTickCount;
    ULONG NumberOfPhysicalPages;
    BOOLEAN SafeBootMode;
    KUSD_VIRTUALIZATION_FLAGS_UNION VirtualizationFlags;
    ARRAY_CONTAINER<UCHAR, 2> Reserved12;
    KUSD_SHARED_DATA_FLAGS_UNION SharedDataFlags;
    ULONG DataFlagsPad;
    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;
    ULONG SystemCall;
    ULONG Reserved2;
    ULONGLONG FullNumberOfPhysicalPages;
    ULONGLONG SystemCallPad;
    KUSD_TICK_COUNT_UNION TickCount;
    ULONG Cookie;
    ULONG CookiePad;
    LONGLONG ConsoleSessionForegroundProcessId;
    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;
    USHORT UnparkedProcessorCount;
    ARRAY_CONTAINER<ULONG, 4> EnclaveFeatureMask;
    ULONG TelemetryCoverageRound;
    ARRAY_CONTAINER<USHORT, 16> UserModeGlobalLogger;
    ULONG ImageFileExecutionOptions;
    ULONG LangGenerationCount;
    ULONGLONG Reserved4;
    ORIGINALLY_VOLATILE ULONGLONG InterruptTimeBias;
    ORIGINALLY_VOLATILE ULONGLONG QpcBias;
    ULONG ActiveProcessorCount;
    ORIGINALLY_VOLATILE UCHAR ActiveGroupCount;
    UCHAR Reserved9;
    KUSD_QPC_DATA_UNION QpcData;
    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
    XSTATE_CONFIGURATION XState;
    KSYSTEM_TIME FeatureConfigurationChangeStamp;
    ULONG Spare;
    std::uint64_t UserPointerAuthMask;
    ARRAY_CONTAINER<ULONG, 210> Reserved10;
} KUSER_SHARED_DATA64, *PKUSER_SHARED_DATA64;

typedef struct _API_SET_NAMESPACE_ENTRY
{
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG HashedLength;
    ULONG ValueOffset;
    ULONG ValueCount;
} API_SET_NAMESPACE_ENTRY, *PAPI_SET_NAMESPACE_ENTRY;

typedef struct _API_SET_HASH_ENTRY
{
    ULONG Hash;
    ULONG Index;
} API_SET_HASH_ENTRY, *PAPI_SET_HASH_ENTRY;

typedef struct _API_SET_VALUE_ENTRY
{
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY, *PAPI_SET_VALUE_ENTRY;

template <typename Traits>
struct PS_ATTRIBUTE
{
    typename Traits::ULONG_PTR Attribute;
    typename Traits::SIZE_T Size;

    union
    {
        typename Traits::ULONG_PTR Value;
        typename Traits::PVOID ValuePtr;
    };

    EMULATOR_CAST(uint64_t, typename Traits::SIZE_T*) ReturnLength;
};

template <typename Traits>
struct PS_ATTRIBUTE_LIST
{
    typename Traits::SIZE_T TotalLength;
    PS_ATTRIBUTE<Traits> Attributes[1];
};

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION64
{
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION64, *PSYSTEM_TIMEOFDAY_INFORMATION64;

typedef struct _SYSTEMTIME64
{
    WORD wYear;
    WORD wMonth;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    WORD wDayOfWeek;
} SYSTEMTIME64, *PSYSTEMTIME64, *LPSYSTEMTIME64;

typedef struct _SYSTEM_TIMEZONE_INFORMATION
{
    LONG Bias;
    ARRAY_CONTAINER<char16_t, 32> StandardName;
    SYSTEMTIME64 StandardDate;
    LONG StandardBias;
    ARRAY_CONTAINER<char16_t, 32> DaylightName;
    SYSTEMTIME64 DaylightDate;
    LONG DaylightBias;
} SYSTEM_TIMEZONE_INFORMATION, *PSYSTEM_TIMEZONE_INFORMATION;

typedef struct _SYSTEM_DYNAMIC_TIMEZONE_INFORMATION
{
    LONG Bias;
    ARRAY_CONTAINER<char16_t, 32> StandardName;
    SYSTEMTIME64 StandardDate;
    LONG StandardBias;
    ARRAY_CONTAINER<char16_t, 32> DaylightName;
    SYSTEMTIME64 DaylightDate;
    LONG DaylightBias;
    ARRAY_CONTAINER<char16_t, 128> TimeZoneKeyName;
    BOOLEAN DynamicDaylightTimeDisabled;
} SYSTEM_DYNAMIC_TIMEZONE_INFORMATION, *PSYSTEM_DYNAMIC_TIMEZONE_INFORMATION;

// Memory address requirements structure
typedef struct _MEM_ADDRESS_REQUIREMENTS64
{
    EMULATOR_CAST(std::uint64_t, PVOID) LowestStartingAddress;
    EMULATOR_CAST(std::uint64_t, PVOID) HighestEndingAddress;
    EMULATOR_CAST(std::uint64_t, SIZE_T) Alignment;
} MEM_ADDRESS_REQUIREMENTS64, *PMEM_ADDRESS_REQUIREMENTS64;

// Extended memory parameter structure
typedef struct _MEM_EXTENDED_PARAMETER64
{
    struct
    {
        ULONG64 Type : 8; // MEM_EXTENDED_PARAMETER_TYPE
        ULONG64 Reserved : 56;
    };

    union
    {
        ULONG64 ULong64;
        EMULATOR_CAST(std::uint64_t, PVOID) Pointer;
        EMULATOR_CAST(std::uint64_t, SIZE_T) Size;
        EMULATOR_CAST(std::uint64_t, HANDLE) Handle;
        ULONG ULong;
    };
} MEM_EXTENDED_PARAMETER64, *PMEM_EXTENDED_PARAMETER64;

typedef struct _PROCESS_BASIC_INFORMATION64
{
    NTSTATUS ExitStatus;
    EMULATOR_CAST(uint64_t, PPEB64) PebBaseAddress;
    EMULATOR_CAST(std::uint64_t, KAFFINITY) AffinityMask;
    EMULATOR_CAST(std::uint32_t, KPRIORITY) BasePriority;
    EMULATOR_CAST(std::uint64_t, HANDLE) UniqueProcessId;
    EMULATOR_CAST(std::uint64_t, HANDLE) InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION64, *PPROCESS_BASIC_INFORMATION64;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
    EMULATOR_CAST(std::uint64_t, SIZE_T) Size; // Ignored as input, written with structure size on output
    PROCESS_BASIC_INFORMATION64 BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        };
    };
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _KERNEL_USER_TIMES
{
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

struct THREAD_TLS_INFORMATION
{
    ULONG Flags;
    uint32_t _Padding;

    union
    {
        EmulatorTraits<Emu64>::PVOID NewTlsData;
        EmulatorTraits<Emu64>::PVOID OldTlsData;
    };

    uint64_t ThreadId;
};

static_assert(sizeof(THREAD_TLS_INFORMATION) == 0x18);

enum PROCESS_TLS_INFORMATION_TYPE
{
    ProcessTlsReplaceIndex,
    ProcessTlsReplaceVector,
    MaxProcessTlsOperation
};

struct PROCESS_TLS_INFORMATION
{
    ULONG Flags;
    PROCESS_TLS_INFORMATION_TYPE OperationType;
    ULONG ThreadDataCount;

    union
    {
        ULONG TlsIndex;
        ULONG PreviousCount;
    };

    THREAD_TLS_INFORMATION ThreadData[1];
};

static_assert(sizeof(PROCESS_TLS_INFORMATION) == 0x28);

struct EMU_GENERIC_MAPPING
{
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
};

struct OBJECT_TYPES_INFORMATION
{
    ULONG NumberOfTypes;
};

struct OBJECT_TYPE_INFORMATION
{
    STRING64 TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    EMU_GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex; // since WINBLUE
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
};

// WIN8 to REDSTONE
typedef struct _PS_MITIGATION_OPTIONS_MAP_V1
{
    ULONG64 Map[1];
} PS_MITIGATION_OPTIONS_MAP_V1, *PPS_MITIGATION_OPTIONS_MAP_V1;

// private // REDSTONE2 to 19H2
typedef struct _PS_MITIGATION_OPTIONS_MAP_V2
{
    ULONG64 Map[2];
} PS_MITIGATION_OPTIONS_MAP_V2, *PPS_MITIGATION_OPTIONS_MAP_V2;

// private // since 20H1
typedef struct _PS_MITIGATION_OPTIONS_MAP_V3
{
    ULONG64 Map[3];
} PS_MITIGATION_OPTIONS_MAP_V3, *PPS_MITIGATION_OPTIONS_MAP_V3;

typedef PS_MITIGATION_OPTIONS_MAP_V3 PS_MITIGATION_OPTIONS_MAP, *PPS_MITIGATION_OPTIONS_MAP;

// private // REDSTONE3 to 19H2
typedef struct _PS_MITIGATION_AUDIT_OPTIONS_MAP_V2
{
    ULONG64 Map[2];
} PS_MITIGATION_AUDIT_OPTIONS_MAP_V2, *PPS_MITIGATION_AUDIT_OPTIONS_MAP_V2;

// private // since 20H1
typedef struct _PS_MITIGATION_AUDIT_OPTIONS_MAP_V3
{
    ULONG64 Map[3];
} PS_MITIGATION_AUDIT_OPTIONS_MAP_V3, *PPS_MITIGATION_AUDIT_OPTIONS_MAP_V3, PS_MITIGATION_AUDIT_OPTIONS_MAP,
    *PPS_MITIGATION_AUDIT_OPTIONS_MAP;

// private // VISTA to WIN7 SP1
typedef enum class _WOW64_SHARED_INFORMATION_V1
{
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32LdrHotPatchRoutine = 4,
    SharedNtdll32ExpInterlockedPopEntrySListFault = 5,
    SharedNtdll32ExpInterlockedPopEntrySListResume = 6,
    SharedNtdll32ExpInterlockedPopEntrySListEnd = 7,
    SharedNtdll32RtlUserThreadStart = 8,
    SharedNtdll32pQueryProcessDebugInformationRemote = 9,
    SharedNtdll32EtwpNotificationThread = 10,
    SharedNtdll32BaseAddress = 11,
    Wow64SharedPageEntriesCount = 12
} WOW64_SHARED_INFORMATION_V1;

// private // WIN8
typedef enum class _WOW64_SHARED_INFORMATION_V2
{
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32LdrHotPatchRoutine = 4,
    SharedNtdll32ExpInterlockedPopEntrySListFault = 5,
    SharedNtdll32ExpInterlockedPopEntrySListResume = 6,
    SharedNtdll32ExpInterlockedPopEntrySListEnd = 7,
    SharedNtdll32RtlUserThreadStart = 8,
    SharedNtdll32pQueryProcessDebugInformationRemote = 9,
    SharedNtdll32EtwpNotificationThread = 10,
    SharedNtdll32BaseAddress = 11,
    SharedNtdll32RtlpWnfNotificationThread = 12,
    SharedNtdll32LdrSystemDllInitBlock = 13,
    Wow64SharedPageEntriesCount = 14
} WOW64_SHARED_INFORMATION_V2;

// private // WIN8.1 to THRESHOLD 1
typedef enum class _WOW64_SHARED_INFORMATION_V3
{
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32ExpInterlockedPopEntrySListFault = 4,
    SharedNtdll32ExpInterlockedPopEntrySListResume = 5,
    SharedNtdll32ExpInterlockedPopEntrySListEnd = 6,
    SharedNtdll32RtlUserThreadStart = 7,
    SharedNtdll32pQueryProcessDebugInformationRemote = 8,
    SharedNtdll32BaseAddress = 9,
    SharedNtdll32LdrSystemDllInitBlock = 10,
    Wow64SharedPageEntriesCount = 11
} WOW64_SHARED_INFORMATION_V3;

// private // THRESHOLD 2 to REDSTONE 2
typedef enum class _WOW64_SHARED_INFORMATION_V4
{
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32RtlUserThreadStart = 4,
    SharedNtdll32pQueryProcessDebugInformationRemote = 5,
    SharedNtdll32BaseAddress = 6,
    SharedNtdll32LdrSystemDllInitBlock = 7,
    Wow64SharedPageEntriesCount = 8
} WOW64_SHARED_INFORMATION_V4;

// private // REDSTONE 3 to 24H2
typedef enum class _WOW64_SHARED_INFORMATION_V5
{
    SharedNtdll32LdrInitializeThunk = 0,
    SharedNtdll32KiUserExceptionDispatcher = 1,
    SharedNtdll32KiUserApcDispatcher = 2,
    SharedNtdll32KiUserCallbackDispatcher = 3,
    SharedNtdll32RtlUserThreadStart = 4,
    SharedNtdll32pQueryProcessDebugInformationRemote = 5,
    SharedNtdll32BaseAddress = 6,
    SharedNtdll32LdrSystemDllInitBlock = 7,
    SharedNtdll32RtlpFreezeTimeBias = 8,
    Wow64SharedPageEntriesCount = 9
} WOW64_SHARED_INFORMATION_V5;

// private // WIN8 to REDSTONE
typedef struct _PS_SYSTEM_DLL_INIT_BLOCK_V1
{
    ULONG Size;
    ULONG SystemDllWowRelocation;
    ULONG64 SystemDllNativeRelocation;
    ULONG Wow64SharedInformation[16]; // use WOW64_SHARED_INFORMATION as index
    ULONG RngData;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CfgOverride : 1; // since REDSTONE
            ULONG Reserved : 31;
        };
    };
    ULONG64 MitigationOptions;
    ULONG64 CfgBitMap; // since WINBLUE
    ULONG64 CfgBitMapSize;
    ULONG64 Wow64CfgBitMap; // since THRESHOLD
    ULONG64 Wow64CfgBitMapSize;
} PS_SYSTEM_DLL_INIT_BLOCK_V1, *PPS_SYSTEM_DLL_INIT_BLOCK_V1;

// RS2 - 19H2
typedef struct _PS_SYSTEM_DLL_INIT_BLOCK_V2
{
    ULONG Size;
    ULONG64 SystemDllWowRelocation;
    ULONG64 SystemDllNativeRelocation;
    ULONG64 Wow64SharedInformation[16]; // use WOW64_SHARED_INFORMATION as index
    ULONG RngData;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CfgOverride : 1;
            ULONG Reserved : 31;
        };
    };
    PS_MITIGATION_OPTIONS_MAP_V2 MitigationOptionsMap;
    ULONG64 CfgBitMap;
    ULONG64 CfgBitMapSize;
    ULONG64 Wow64CfgBitMap;
    ULONG64 Wow64CfgBitMapSize;
    PS_MITIGATION_AUDIT_OPTIONS_MAP_V2 MitigationAuditOptionsMap; // since REDSTONE3
} PS_SYSTEM_DLL_INIT_BLOCK_V2, *PPS_SYSTEM_DLL_INIT_BLOCK_V2;

// private // since 20H1
typedef struct _PS_SYSTEM_DLL_INIT_BLOCK_V3
{
    ULONG Size;
    ULONG64 SystemDllWowRelocation; // effectively since WIN8
    ULONG64 SystemDllNativeRelocation;
    ULONG64 Wow64SharedInformation[16]; // use WOW64_SHARED_INFORMATION_V5 as index
    ULONG RngData;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CfgOverride : 1; // effectively since REDSTONE
            ULONG Reserved : 31;
        };
    };
    PS_MITIGATION_OPTIONS_MAP_V3 MitigationOptionsMap;
    ULONG64 CfgBitMap; // effectively since WINBLUE
    ULONG64 CfgBitMapSize;
    ULONG64 Wow64CfgBitMap; // effectively since THRESHOLD
    ULONG64 Wow64CfgBitMapSize;
    PS_MITIGATION_AUDIT_OPTIONS_MAP_V3 MitigationAuditOptionsMap; // effectively since REDSTONE3
    ULONG64 ScpCfgCheckFunction;                                  // since 24H2
    ULONG64 ScpCfgCheckESFunction;
    ULONG64 ScpCfgDispatchFunction;
    ULONG64 ScpCfgDispatchESFunction;
    ULONG64 ScpArm64EcCallCheck;
    ULONG64 ScpArm64EcCfgCheckFunction;
    ULONG64 ScpArm64EcCfgCheckESFunction;
} PS_SYSTEM_DLL_INIT_BLOCK_V3, *PPS_SYSTEM_DLL_INIT_BLOCK_V3, PS_SYSTEM_DLL_INIT_BLOCK, *PPS_SYSTEM_DLL_INIT_BLOCK;

static_assert(sizeof(PS_SYSTEM_DLL_INIT_BLOCK_V3) == 0x128);

//
// Process mitigation policy information
//  NtSetInformationProcess using ProcessMitigationPolicy
//

typedef struct _PROCESS_MITIGATION_POLICY_RAW_DATA
{
    PROCESS_MITIGATION_POLICY Policy;
    ULONG Value;
} PROCESS_MITIGATION_POLICY_RAW_DATA, *PPROCESS_MITIGATION_POLICY_RAW_DATA;

static_assert(sizeof(PROCESS_MITIGATION_POLICY_RAW_DATA) == 0x8);

typedef struct _WOW64_CPURESERVED
{
    USHORT Flags;       // Initialised to 0x02 by ntdll.dll and periodically bitwise OR'd with WOW64_CPURESERVED_FLAG_RESET_STATE
    USHORT MachineType; // IMAGE_FILE_MACHINE_I386 (0x014C) for x86 architecture

    // Under IMAGE_FILE_MACHINE_I386 machine type, this is the WOW64_CONTEXT structure containing x86 architecture context
    WOW64_CONTEXT Context;

    // Padding to align WOW64 stack
    BYTE AlignmentPad[0x10];
} WOW64_CPURESERVED, *PWOW64_CPURESERVED;

static_assert(sizeof(WOW64_CPURESERVED) == 0x2E0);

#define WOW64_CPURESERVED_FLAG_RESET_STATE 1

typedef enum class _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation = 0,
    SectionImageInformation = 1,
    SectionRelocationInformation = 2,
    SectionOriginalBaseInformation = 3,
    SectionInternalImageInformation = 4
} SECTION_INFORMATION_CLASS, *PSECTION_INFORMATION_CLASS;

typedef enum _WINDOWS_VERSION : uint32_t
{
    WINDOWS_10_1507 = 10240,
    WINDOWS_10_1511 = 10586,
    WINDOWS_10_1607 = 14393,
    WINDOWS_10_1703 = 15063,
    WINDOWS_10_1709 = 16299,
    WINDOWS_10_1803 = 17134,
    WINDOWS_10_1809 = 17763,
    WINDOWS_10_1903 = 18362,
    WINDOWS_10_1909 = 18363,
    WINDOWS_10_2004 = 19041,
    WINDOWS_10_20H2 = 19042,
    WINDOWS_10_21H1 = 19043,
    WINDOWS_10_21H2 = 19044,
    WINDOWS_10_22H2 = 19045,
    WINDOWS_11_21H2 = 22000,
    WINDOWS_11_22H2 = 22621,
    WINDOWS_11_23H2 = 22631,
    WINDOWS_11_24H2 = 26100,
} WINDOWS_VERSION, *PWINDOWS_VERSION;

constexpr uint64_t PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V1 = sizeof(PS_SYSTEM_DLL_INIT_BLOCK_V1);
constexpr uint64_t PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V2_1703 = offsetof(PS_SYSTEM_DLL_INIT_BLOCK_V2, MitigationAuditOptionsMap);
constexpr uint64_t PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V2 = sizeof(PS_SYSTEM_DLL_INIT_BLOCK_V2);
constexpr uint64_t PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V3_2004 = offsetof(PS_SYSTEM_DLL_INIT_BLOCK_V3, ScpCfgCheckFunction);
constexpr uint64_t PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V3 = sizeof(PS_SYSTEM_DLL_INIT_BLOCK_V3);

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/memory.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(modernize-use-using)

#define PAGE_EXECUTE           0x10
#define PAGE_EXECUTE_READ      0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80

#define PAGE_NOACCESS          0x01
#define PAGE_READONLY          0x02
#define PAGE_READWRITE         0x04
#define PAGE_WRITECOPY         0x08

#define PAGE_TARGETS_INVALID   0x40000000
#define PAGE_TARGETS_NO_UPDATE 0x40000000

#define PAGE_GUARD             0x100
#define PAGE_NOCACHE           0x200
#define PAGE_WRITECOMBINE      0x400

#ifndef MEM_64K_PAGES
#define MEM_COMMIT                  0x00001000
#define MEM_RESERVE                 0x00002000
#define MEM_DECOMMIT                0x00004000
#define MEM_RELEASE                 0x00008000
#define MEM_FREE                    0x00010000
#define MEM_PRIVATE                 0x00020000
#define MEM_MAPPED                  0x00040000
#define MEM_RESET                   0x00080000
#define MEM_IMAGE                   0x01000000
#define MEM_TOP_DOWN                0x00100000
#define MEM_WRITE_WATCH             0x00200000
#define MEM_PHYSICAL                0x00400000
#define MEM_ROTATE                  0x00800000
#define MEM_DIFFERENT_IMAGE_BASE_OK 0x00800000
#define MEM_RESET_UNDO              0x01000000
#define MEM_LARGE_PAGES             0x20000000
#define MEM_DOS_LIM                 0x40000000
#define MEM_4MB_PAGES               0x80000000
#define MEM_64K_PAGES               (MEM_LARGE_PAGES | MEM_PHYSICAL)
#endif

typedef enum _MEMORY_INFORMATION_CLASS
{
    MemoryBasicInformation,              // q: MEMORY_BASIC_INFORMATION
    MemoryWorkingSetInformation,         // q: MEMORY_WORKING_SET_INFORMATION
    MemoryMappedFilenameInformation,     // q: UNICODE_STRING
    MemoryRegionInformation,             // q: MEMORY_REGION_INFORMATION
    MemoryWorkingSetExInformation,       // q: MEMORY_WORKING_SET_EX_INFORMATION // since VISTA
    MemorySharedCommitInformation,       // q: MEMORY_SHARED_COMMIT_INFORMATION // since WIN8
    MemoryImageInformation,              // q: MEMORY_IMAGE_INFORMATION
    MemoryRegionInformationEx,           // MEMORY_REGION_INFORMATION
    MemoryPrivilegedBasicInformation,    // MEMORY_BASIC_INFORMATION
    MemoryEnclaveImageInformation,       // MEMORY_ENCLAVE_IMAGE_INFORMATION // since REDSTONE3
    MemoryBasicInformationCapped,        // 10
    MemoryPhysicalContiguityInformation, // MEMORY_PHYSICAL_CONTIGUITY_INFORMATION // since 20H1
    MemoryBadInformation,                // since WIN11
    MemoryBadInformationAllProcesses,    // since 22H1
    MemoryImageExtensionInformation,     // since 24H2
    MaxMemoryInfoClass
} MEMORY_INFORMATION_CLASS;

typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

typedef struct
#ifndef __MINGW64__
    DECLSPEC_ALIGN(16)
#endif
        _EMU_MEMORY_BASIC_INFORMATION64
{
    uint64_t BaseAddress;
    uint64_t AllocationBase;
    DWORD AllocationProtect;
    WORD PartitionId;
    std::int64_t RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} EMU_MEMORY_BASIC_INFORMATION64, *PEMU_MEMORY_BASIC_INFORMATION64;

typedef struct _MEMORY_IMAGE_INFORMATION64
{
    uint64_t ImageBase;
    std::int64_t SizeOfImage;

    union
    {
        ULONG ImageFlags;

        struct
        {
            ULONG ImagePartialMap : 1;
            ULONG ImageNotExecutable : 1;
            ULONG ImageSigningLevel : 4;     // REDSTONE3
            ULONG ImageExtensionPresent : 1; // since 24H2
            ULONG Reserved : 25;
        };
    };
} MEMORY_IMAGE_INFORMATION64, *PMEMORY_IMAGE_INFORMATION64;

typedef struct _MEMORY_REGION_INFORMATION
{
    uint64_t AllocationBase;
    ULONG AllocationProtect;

    union
    {
        ULONG RegionType;

        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // REDSTONE3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // REDSTONE4
            ULONG MappedAwe : 1;              // 21H1
            ULONG MappedWriteWatch : 1;
            ULONG PageSizeLarge : 1;
            ULONG PageSizeHuge : 1;
            ULONG Reserved : 19;
        };
    };

    std::int64_t RegionSize;
    std::int64_t CommitSize;
    // DWORD64 PartitionId;    // 19H1
    // DWORD64 NodePreference; // 20H1
} MEMORY_REGION_INFORMATION64, *PMEMORY_REGION_INFORMATION64;

// NOLINTEND(modernize-use-using)

```

`src/common/platform/network.hpp`:

```hpp
#pragma once

#include "traits.hpp"
#include "primitives.hpp"

template <typename Traits>
struct EMU_WSABUF
{
    ULONG len;
    EMULATOR_CAST(typename Traits::PVOID, CHAR*) buf;
};

```

`src/common/platform/platform.hpp`:

```hpp
#pragma once

#if defined(_WIN32) && !defined(__MINGW64__)
#pragma warning(push)
#pragma warning(disable : 4201) // nameless struct/union
#pragma warning(disable : 4702) // unreachable code
#endif

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#endif

#include "compiler.hpp"
#include "primitives.hpp"
#include "traits.hpp"
#include "unicode.hpp"
#include "status.hpp"
#include "process.hpp"
#include "user.hpp"
#include "kernel_mapped.hpp"
#include "memory.hpp"
#include "file_management.hpp"
#include "win_pefile.hpp"
#include "synchronisation.hpp"
#include "registry.hpp"
#include "network.hpp"
#include "threading.hpp"
#include "window.hpp"
#include "port.hpp"

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#if defined(_WIN32) && !defined(__MINGW64__)
#pragma warning(pop)
#endif

```

`src/common/platform/port.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#define LPC_REQUEST            1
#define LPC_REPLY              2
#define LPC_DATAGRAM           3
#define LPC_LOST_REPLY         4
#define LPC_PORT_CLOSED        5
#define LPC_CLIENT_DIED        6
#define LPC_EXCEPTION          7
#define LPC_DEBUG_EVENT        8
#define LPC_ERROR_EVENT        9
#define LPC_CONNECTION_REQUEST 10
#define LPC_NO_IMPERSONATE     0x4000
#define LPC_KERNELMODE_MESSAGE 0x8000

#define LpcpGetMessageType(x)  ((x)->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE)

struct PORT_MESSAGE64
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;

        ULONG Length;
    } u1;

    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;

        ULONG ZeroInit;
    } u2;

    union
    {
        CLIENT_ID64 ClientId;
        double DoNotUseThisField;
    };

    ULONG MessageId;

    union
    {
        EmulatorTraits<Emu64>::SIZE_T ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId;                             // only valid for LPC_REQUEST messages
    };
};

struct ALPC_MESSAGE_ATTRIBUTES
{
    ULONG AllocatedAttributes;
    ULONG ValidAttributes;
};

template <typename Traits>
struct PORT_DATA_ENTRY
{
    typename Traits::PVOID Base;
    ULONG Size;
};

template <typename Traits>
struct ALPC_SECURITY_ATTR
{
    ULONG Flags;
    typename Traits::PVOID SecurityQos;
    typename Traits::HANDLE ContextHandle;
};

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/primitives.hpp`:

```hpp
#pragma once

#include <cstdint>
#include "compiler.hpp"

// NOLINTBEGIN(modernize-use-using)

#ifdef OS_WINDOWS

#include "../utils/win.hpp"
#include <winnt.h>

#else

#define _Field_size_(...)
#define _Struct_size_bytes_(...)

#define ANYSIZE_ARRAY 1

#define DWORD         std::uint32_t
using LONG = std::int32_t;
using ULONG = DWORD;
using DWORD64 = std::uint64_t;
using ULONG64 = std::uint64_t;
using ULONGLONG = DWORD64;
using LONGLONG = std::int64_t;
using UINT = std::uint32_t;
using BOOL = std::int32_t;

typedef union _ULARGE_INTEGER
{
    struct
    {
        DWORD LowPart;
        DWORD HighPart;
    };

    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef union _LARGE_INTEGER
{
    struct
    {
        DWORD LowPart;
        LONG HighPart;
    };

    LONGLONG QuadPart;
} LARGE_INTEGER;

using BYTE = std::uint8_t;
#define CHAR          BYTE

typedef struct _RECT
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT;
#endif

using WORD = std::uint16_t;
#define WCHAR   WORD

#define UCHAR   uint8_t
#define BOOLEAN UCHAR

using CSHORT = int16_t;
using USHORT = WORD;

#define DUMMYSTRUCTNAME

#ifndef TRUE
#define TRUE  1
#define FALSE 0
#endif

static_assert(sizeof(DWORD) == 4);
static_assert(sizeof(ULONG) == 4);
static_assert(sizeof(int) == 4);
static_assert(sizeof(BOOLEAN) == 1);

// NOLINTEND(modernize-use-using)

```

`src/common/platform/process.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#ifndef OS_WINDOWS
#define CREATE_SUSPENDED 0x00000004
#endif

#define CONTEXT_X86_MAIN              0x00010000
#define CONTEXT_AMD64_MAIN            0x100000
#define CONTEXT_CONTROL_32            (CONTEXT_X86_MAIN | 0x1L)
#define CONTEXT_CONTROL_64            (CONTEXT_AMD64_MAIN | 0x1L)
#define CONTEXT_INTEGER_32            (CONTEXT_X86_MAIN | 0x2L)
#define CONTEXT_INTEGER_64            (CONTEXT_AMD64_MAIN | 0x2L)
#define CONTEXT_SEGMENTS_32           (CONTEXT_X86_MAIN | 0x4L)
#define CONTEXT_SEGMENTS_64           (CONTEXT_AMD64_MAIN | 0x4L)
#define CONTEXT_FLOATING_POINT_32     (CONTEXT_X86_MAIN | 0x8L)
#define CONTEXT_FLOATING_POINT_64     (CONTEXT_AMD64_MAIN | 0x8L)
#define CONTEXT_DEBUG_REGISTERS_32    (CONTEXT_X86_MAIN | 0x10L)
#define CONTEXT_DEBUG_REGISTERS_64    (CONTEXT_AMD64_MAIN | 0x10L)
#define CONTEXT_EXTENDED_REGISTERS_32 (CONTEXT_X86_MAIN | 0x20L)
#define CONTEXT_XSTATE_32             (CONTEXT_X86_MAIN | 0x40L)
#define CONTEXT_XSTATE_64             (CONTEXT_AMD64_MAIN | 0x40L)

#define CONTEXT64_ALL \
    (CONTEXT_CONTROL_64 | CONTEXT_INTEGER_64 | CONTEXT_SEGMENTS_64 | CONTEXT_FLOATING_POINT_64 | CONTEXT_DEBUG_REGISTERS_64)

#define CONTEXT32_ALL                                                                                                         \
    (CONTEXT_CONTROL_32 | CONTEXT_INTEGER_32 | CONTEXT_SEGMENTS_32 | CONTEXT_FLOATING_POINT_32 | CONTEXT_DEBUG_REGISTERS_32 | \
     CONTEXT_EXTENDED_REGISTERS_32)

using SYSTEM_INFORMATION_CLASS = enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation,                // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation,            // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation,          // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation,            // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation,                 // not implemented
    SystemProcessInformation,              // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation,            // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation,               // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemFlagsInformation,                // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation,             // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation,               // q: RTL_PROCESS_MODULES
    SystemLocksInformation,                // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation,           // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation,            // not implemented
    SystemNonPagedPoolInformation,         // not implemented
    SystemHandleInformation,               // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation,               // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation,             // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation,          // q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation,               // not implemented // 20
    SystemFileCacheInformation,
    // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation,   // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemDpcBehaviorInformation,
    // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation,      // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemLoadGdiDriverInformation,   // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation,
    // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemMirrorMemoryInformation,
    // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation,     // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0,                       // not implemented
    SystemExceptionInformation,            // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation,       // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation,       // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation,        // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation,        // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation,   // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation,              // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation,    // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation,        // q: SYSTEM_PROCESSOR_IDLE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemLegacyDriverInformation,         // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation,      // q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation,            // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification,            // s: HANDLE (NtCreateEvent) (requires SeSystemtimePrivilege)
    SystemSessionCreate,                   // not implemented
    SystemSessionDetach,                   // not implemented
    SystemSessionInformation,              // not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation,           // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation,             // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend,             // s (kernel-mode only)
    SystemSessionProcessInformation,       // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace,
    // s: SYSTEM_GDI_DRIVER_INFORMATION (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap,                        // q: SYSTEM_NUMA_INFORMATION
    SystemPrefetcherInformation,                   // q; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation,              // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment,          // q: ULONG // KeGetRecommendedSharedDataAlignment
    SystemComPlusPackage,                          // q; s: ULONG
    SystemNumaAvailableMemory,                     // q: SYSTEM_NUMA_INFORMATION // 60
    SystemProcessorPowerInformation,               // q: SYSTEM_PROCESSOR_POWER_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemEmulationBasicInformation,               // q: SYSTEM_BASIC_INFORMATION
    SystemEmulationProcessorInformation,           // q: SYSTEM_PROCESSOR_INFORMATION
    SystemExtendedHandleInformation,               // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation,             // q: ULONG
    SystemBigPoolInformation,                      // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation,               // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation,            // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation,                     // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode,                      // q: ULONG // 70
    SystemWatchdogTimerHandler,                    // s: SYSTEM_WATCHDOG_HANDLER_INFORMATION // (kernel-mode only)
    SystemWatchdogTimerInformation,                // q: SYSTEM_WATCHDOG_TIMER_INFORMATION // (kernel-mode only)
    SystemLogicalProcessorInformation,             // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemWow64SharedInformationObsolete,          // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation,                // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx,                     // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation,               // not implemented
    SystemSuperfetchInformation,                   // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation,
    // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx,
    // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation,
    // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation,
    // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemVerifierCancellationInformation,
    // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation,         // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation,
    // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then
    // MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation,       // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation,       // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation,      // q: SYSTEM_HYPERVISOR_QUERY_INFORMATION
    SystemVerifierInformationEx,      // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation,        // q; s: RTL_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation,
    // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation,
    // q: COVERAGE_MODULES s: COVERAGE_MODULE_REQUEST // ExpCovQueryInformation (requires SeDebugPrivilege)
    SystemPrefetchPatchInformation,   // SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation,  // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation,      // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution,
    // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION (EX in: USHORT ProcessorGroup) // 100
    SystemNumaProximityNodeInformation,        // q; s: SYSTEM_NUMA_PROXIMITY_MAP
    SystemDynamicTimeZoneInformation,          // q; s: RTL_DYNAMIC_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation,            // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString,                // q: CHAR[] // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation,
    // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) //
    // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation,
    // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX (EX in: LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType) // since WIN7
    // // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemStoreInformation,
    // q; s: SYSTEM_STORE_INFORMATION (requires SeProfileSingleProcessPrivilege) // SmQueryStoreInformation
    SystemRegistryAppendString,        // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue,            // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation,          // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation,         // q; s: PS_CPU_QUOTA_QUERY_INFORMATION
    SystemNativeBasicInformation,      // q: SYSTEM_BASIC_INFORMATION
    SystemErrorPortTimeouts,           // SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation,    // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation,   // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx,
    // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx,
    // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation, // q: USHORT[4*NumaNodes] // (EX in: USHORT NodeNumber)
    SystemAcpiAuditInformation,
    // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation,
    // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION //
    // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation,          // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation,            // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation,     // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,                 // SYSTEM_BAD_PAGE_INFORMATION
    SystemProcessorProfileControlArea,        // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation,
    // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation,   // q; s: SYSTEM_ENTROPY_TIMING_INFORMATION
    SystemConsoleInformation,                  // q; s: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation,           // q: SYSTEM_PLATFORM_BINARY_INFORMATION (requires SeTcbPrivilege)
    SystemPolicyInformation,                   // q: SYSTEM_POLICY_INFORMATION (Warbird/Encrypt/Decrypt/Execute)
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation,               // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation,    // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation,           // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation,            // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation,                 // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx,
    // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // (EX in: USHORT ProcessorGroup) // since WINBLUE
    SystemCriticalProcessErrorLogInformation,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx,       // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation,       // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation,
    // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx,       // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation,           // 150
    SystemSoftRebootInformation,             // q: ULONG
    SystemElamCertificateInformation,        // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation,      // q: OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
    SystemProcessorFeaturesInformation,      // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation,                   // q: SYSTEM_EDID_INFORMATION
    SystemManufacturingInformation,          // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation,       // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation,
    // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION (EX in: USHORT ProcessorGroup) // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags,              // SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation,   // q; s: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation,      // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation,         // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation,       // s: SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION
    SystemVsmProtectionInformation,        // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation,     // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation, // (requires SeIncreaseBasePriorityPrivilege)
    SystemRootSiloInformation,                      // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation,                        // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation,                     // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation,
    // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation,
    // q: in: SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT, out: SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT //
    // NtQuerySystemInformationEx // 180
    SystemSupportedProcessorArchitectures,
    // p: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx
    SystemMemoryUsageInformation,              // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation,           // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition,               // (Warbird/Encrypt/Decrypt/Execute)
    SystemKernelDebuggingAllowed,              // s: ULONG
    SystemActivityModerationExeState,          // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings,      // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation,             // q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation, // q: ULONG_PTR[ActiveGroupCount] // since REDSTONE3
    SystemSecureDumpEncryptionInformation,
    SystemWriteConstraintInformation,      // SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation,       // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation,
    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation,         // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation,
    // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation,          // SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation,    // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation,  // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION
    SystemLeapSecondInformation,              // SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information,                  // q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation,           // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation,
    SystemFeatureConfigurationInformation,
    // q: in: SYSTEM_FEATURE_CONFIGURATION_QUERY, out: SYSTEM_FEATURE_CONFIGURATION_INFORMATION; s:
    // SYSTEM_FEATURE_CONFIGURATION_UPDATE // NtQuerySystemInformationEx // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation,
    // q: in: SYSTEM_FEATURE_CONFIGURATION_SECTIONS_REQUEST, out: SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION //
    // NtQuerySystemInformationEx
    SystemFeatureUsageSubscriptionInformation,
    // q: SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS; s: SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE
    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION
    SystemSpacesBootInformation,               // since 20H2
    SystemFwRamdiskInformation,                // SYSTEM_FIRMWARE_RAMDISK_INFORMATION
    SystemWheaIpmiHardwareInformation,
    SystemDifSetRuleClassInformation, // SYSTEM_DIF_VOLATILE_INFORMATION
    SystemDifClearRuleClassInformation,
    SystemDifApplyPluginVerificationOnDriver,  // SYSTEM_DIF_PLUGIN_DRIVER_INFORMATION
    SystemDifRemovePluginVerificationOnDriver, // SYSTEM_DIF_PLUGIN_DRIVER_INFORMATION // 220
    SystemShadowStackInformation,              // SYSTEM_SHADOW_STACK_INFORMATION
    SystemBuildVersionInformation,
    // q: in: ULONG (LayerNumber), out: SYSTEM_BUILD_VERSION_INFORMATION // NtQuerySystemInformationEx // 222
    SystemPoolLimitInformation, // SYSTEM_POOL_LIMIT_INFORMATION (requires SeIncreaseQuotaPrivilege)
    SystemCodeIntegrityAddDynamicStore,
    SystemCodeIntegrityClearDynamicStores,
    SystemDifPoolTrackingInformation,
    SystemPoolZeroingInformation,  // q: SYSTEM_POOL_ZEROING_INFORMATION
    SystemDpcWatchdogInformation,  // q; s: SYSTEM_DPC_WATCHDOG_CONFIGURATION_INFORMATION
    SystemDpcWatchdogInformation2, // q; s: SYSTEM_DPC_WATCHDOG_CONFIGURATION_INFORMATION_V2
    SystemSupportedProcessorArchitectures2,
    // q: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx //
    // 230
    SystemSingleProcessorRelationshipInformation,
    // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // (EX in: PROCESSOR_NUMBER Processor)
    SystemXfgCheckFailureInformation,     // q: SYSTEM_XFG_FAILURE_INFORMATION
    SystemIommuStateInformation,          // SYSTEM_IOMMU_STATE_INFORMATION // since 22H1
    SystemHypervisorMinrootInformation,   // SYSTEM_HYPERVISOR_MINROOT_INFORMATION
    SystemHypervisorBootPagesInformation, // SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION
    SystemPointerAuthInformation,         // SYSTEM_POINTER_AUTH_INFORMATION
    SystemSecureKernelDebuggerInformation,
    SystemOriginalImageFeatureInformation,
    // q: in: SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT, out: SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT //
    // NtQuerySystemInformationEx
    SystemMemoryNumaInformation, // SYSTEM_MEMORY_NUMA_INFORMATION_INPUT, SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT
    SystemMemoryNumaPerformanceInformation,
    // SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUTSYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT,
    // SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT // since 24H2 // 240
    SystemCodeIntegritySignedPoliciesFullInformation,
    SystemSecureSecretsInformation,
    SystemTrustedAppsRuntimeInformation,          // SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION
    SystemBadPageInformationEx,                   // SYSTEM_BAD_PAGE_INFORMATION
    SystemResourceDeadlockTimeout,                // ULONG
    SystemBreakOnContextUnwindFailureInformation, // ULONG (requires SeDebugPrivilege)
    SystemOslRamdiskInformation,                  // SYSTEM_OSL_RAMDISK_INFORMATION
    MaxSystemInfoClass
};

#ifndef OS_WINDOWS
typedef enum _TOKEN_INFORMATION_CLASS
{
    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER
    TokenGroups,                          // q: TOKEN_GROUPS
    TokenPrivileges,                      // q: TOKEN_PRIVILEGES
    TokenOwner,                           // q; s: TOKEN_OWNER
    TokenPrimaryGroup,                    // q; s: TOKEN_PRIMARY_GROUP
    TokenDefaultDacl,                     // q; s: TOKEN_DEFAULT_DACL
    TokenSource,                          // q: TOKEN_SOURCE
    TokenType,                            // q: TOKEN_TYPE
    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL
    TokenStatistics,                      // q: TOKEN_STATISTICS // 10
    TokenRestrictedSids,                  // q: TOKEN_GROUPS
    TokenSessionId,                       // q; s: ULONG (requires SeTcbPrivilege)
    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES
    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)
    TokenSandBoxInert,                    // q: ULONG
    TokenAuditPolicy,                     // q; s: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)
    TokenOrigin,                          // q; s: TOKEN_ORIGIN (requires SeTcbPrivilege)
    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE
    TokenLinkedToken,                     // q; s: TOKEN_LINKED_TOKEN (requires SeCreateTokenPrivilege)
    TokenElevation,                       // q: TOKEN_ELEVATION // 20
    TokenHasRestrictions,                 // q: ULONG
    TokenAccessInformation,               // q: TOKEN_ACCESS_INFORMATION
    TokenVirtualizationAllowed,           // q; s: ULONG (requires SeCreateTokenPrivilege)
    TokenVirtualizationEnabled,           // q; s: ULONG
    TokenIntegrityLevel,                  // q; s: TOKEN_MANDATORY_LABEL
    TokenUIAccess,                        // q; s: ULONG (requires SeTcbPrivilege)
    TokenMandatoryPolicy,                 // q; s: TOKEN_MANDATORY_POLICY (requires SeTcbPrivilege)
    TokenLogonSid,                        // q: TOKEN_GROUPS
    TokenIsAppContainer,                  // q: ULONG // since WIN8
    TokenCapabilities,                    // q: TOKEN_GROUPS // 30
    TokenAppContainerSid,                 // q: TOKEN_APPCONTAINER_INFORMATION
    TokenAppContainerNumber,              // q: ULONG
    TokenUserClaimAttributes,             // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenDeviceClaimAttributes,           // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenRestrictedUserClaimAttributes,   // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenRestrictedDeviceClaimAttributes, // q: CLAIM_SECURITY_ATTRIBUTES_INFORMATION
    TokenDeviceGroups,                    // q: TOKEN_GROUPS
    TokenRestrictedDeviceGroups,          // q: TOKEN_GROUPS
    TokenSecurityAttributes,              // q; s: TOKEN_SECURITY_ATTRIBUTES_[AND_OPERATION_]INFORMATION (requires SeTcbPrivilege)
    TokenIsRestricted,                    // q: ULONG // 40
    TokenProcessTrustLevel,               // q: TOKEN_PROCESS_TRUST_LEVEL // since WINBLUE
    TokenPrivateNameSpace,                // q; s: ULONG  (requires SeTcbPrivilege) // since THRESHOLD
    TokenSingletonAttributes,             // q: TOKEN_SECURITY_ATTRIBUTES_INFORMATION // since REDSTONE
    TokenBnoIsolation,                    // q: TOKEN_BNO_ISOLATION_INFORMATION // since REDSTONE2
    TokenChildProcessFlags,               // s: ULONG  (requires SeTcbPrivilege) // since REDSTONE3
    TokenIsLessPrivilegedAppContainer,    // q: ULONG // since REDSTONE5
    TokenIsSandboxed,                     // q: ULONG // since 19H1
    TokenIsAppSilo,                       // q: ULONG // since WIN11 22H2 // previously TokenOriginatingProcessTrustLevel // q:
                                          // TOKEN_PROCESS_TRUST_LEVEL
    TokenLoggingInformation,              // TOKEN_LOGGING_INFORMATION // since 24H2
    MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

#endif

using PROCESSINFOCLASS = enum _PROCESSINFOCLASS
{
    ProcessBasicInformation,                // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits,                     // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters,                      // q: IO_COUNTERS
    ProcessVmCounters,                      // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes,                           // q: KERNEL_USER_TIMES
    ProcessBasePriority,                    // s: KPRIORITY
    ProcessRaisePriority,                   // s: ULONG
    ProcessDebugPort,                       // q: HANDLE
    ProcessExceptionPort,                   // s: PROCESS_EXCEPTION_PORT (requires SeTcbPrivilege)
    ProcessAccessToken,                     // s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation,                  // qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize,                         // s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode,            // qs: ULONG
    ProcessIoPortHandlers,                  // (kernel-mode only) // s: PROCESS_IO_PORT_HANDLER_INFORMATION
    ProcessPooledUsageAndLimits,            // q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch,                 // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL,                    // qs: ULONG (requires SeTcbPrivilege)
    ProcessEnableAlignmentFaultFixup,       // s: BOOLEAN
    ProcessPriorityClass,                   // qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information,                 // qs: ULONG (requires SeTcbPrivilege) (VdmAllowed)
    ProcessHandleCount,                     // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask,                    // (q >WIN7)s: KAFFINITY, qs: GROUP_AFFINITY
    ProcessPriorityBoost,                   // qs: ULONG
    ProcessDeviceMap,                       // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation,              // q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation,           // s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information,                // q: ULONG_PTR
    ProcessImageFileName,                   // q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled,           // q: ULONG
    ProcessBreakOnTermination,              // qs: ULONG
    ProcessDebugObjectHandle,               // q: HANDLE // 30
    ProcessDebugFlags,                      // qs: ULONG
    ProcessHandleTracing,                   // q: PROCESS_HANDLE_TRACING_QUERY; s: PROCESS_HANDLE_TRACING_ENABLE[_EX] or void to disable
    ProcessIoPriority,                      // qs: IO_PRIORITY_HINT
    ProcessExecuteFlags,                    // qs: ULONG (MEM_EXECUTE_OPTION_*)
    ProcessTlsInformation,                  // PROCESS_TLS_INFORMATION // ProcessResourceManagement
    ProcessCookie,                          // q: ULONG
    ProcessImageInformation,                // q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime,                       // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority,                    // qs: PAGE_PRIORITY_INFORMATION
    ProcessInstrumentationCallback,         // s: PVOID or PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
    ProcessThreadStackAllocation,           // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx,               // q: PROCESS_WS_WATCH_INFORMATION_EX[]; s: void
    ProcessImageFileNameWin32,              // q: UNICODE_STRING
    ProcessImageFileMapping,                // q: HANDLE (input)
    ProcessAffinityUpdateMode,              // qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode,            // qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation,                // q: USHORT[]
    ProcessTokenVirtualizationEnabled,      // s: ULONG
    ProcessConsoleHostProcess,              // qs: ULONG_PTR // ProcessOwnerInformation
    ProcessWindowInformation,               // q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation,               // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy,                // s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation, // s: PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION
    ProcessHandleCheckingMode,              // qs: ULONG; s: 0 disables, otherwise enables
    ProcessKeepAliveCount,                  // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles,               // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl,               // s: PROCESS_WORKING_SET_CONTROL (requires SeDebugPrivilege)
    ProcessHandleTable,                     // q: ULONG[] // since WINBLUE
    ProcessCheckStackExtentsMode,           // qs: ULONG // KPROCESS->CheckStackExtents (CFG)
    ProcessCommandLineInformation,          // q: UNICODE_STRING // 60
    ProcessProtectionInformation,           // q: PS_PROTECTION
    ProcessMemoryExhaustion,                // s: PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation,                // s: PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation,          // q: PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation,        // qs: PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation,       // qs: SYSTEM_CPU_SET_INFORMATION[5]
    ProcessAllowedCpuSetsInformation,       // qs: SYSTEM_CPU_SET_INFORMATION[5]
    ProcessSubsystemProcess,
    ProcessJobMemoryInformation,                 // q: PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate,                            // q: BOOLEAN; s: void // ETW // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessIumChallengeResponse,
    ProcessChildProcessInformation,         // q: PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation, // qs: BOOLEAN (requires SeTcbPrivilege)
    ProcessSubsystemInformation,            // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues,                    // q: PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessPowerThrottlingState,            // qs: POWER_THROTTLING_PROCESS_STATE
    ProcessReserved3Information,            // ProcessActivityThrottlePolicy // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation,  // q: WIN32K_SYSCALL_FILTER
    ProcessDisableSystemAllowedCpuSets,     // s: BOOLEAN // 80
    ProcessWakeInformation,                 // q: PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState,             // qs: PROCESS_ENERGY_TRACKING_STATE
    ProcessManageWritesToExecutableMemory,  // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ProcessCaptureTrustletLiveDump,
    ProcessTelemetryCoverage, // q: TELEMETRY_COVERAGE_HEADER; s: TELEMETRY_COVERAGE_POINT
    ProcessEnclaveInformation,
    ProcessEnableReadWriteVmLogging,           // qs: PROCESS_READWRITEVM_LOGGING_INFORMATION
    ProcessUptimeInformation,                  // q: PROCESS_UPTIME_INFORMATION
    ProcessImageSection,                       // q: HANDLE
    ProcessDebugAuthInformation,               // since REDSTONE4 // 90
    ProcessSystemResourceManagement,           // s: PROCESS_SYSTEM_RESOURCE_MANAGEMENT
    ProcessSequenceNumber,                     // q: ULONGLONG
    ProcessLoaderDetour,                       // since REDSTONE5
    ProcessSecurityDomainInformation,          // q: PROCESS_SECURITY_DOMAIN_INFORMATION
    ProcessCombineSecurityDomainsInformation,  // s: PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
    ProcessEnableLogging,                      // qs: PROCESS_LOGGING_INFORMATION
    ProcessLeapSecondInformation,              // qs: PROCESS_LEAP_SECOND_INFORMATION
    ProcessFiberShadowStackAllocation,         // s: PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
    ProcessFreeFiberShadowStackAllocation,     // s: PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
    ProcessAltSystemCallInformation,           // s: PROCESS_SYSCALL_PROVIDER_INFORMATION // since 20H1 // 100
    ProcessDynamicEHContinuationTargets,       // s: PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
    ProcessDynamicEnforcedCetCompatibleRanges, // s: PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_INFORMATION // since 20H2
    ProcessCreateStateChange,                  // since WIN11
    ProcessApplyStateChange,
    ProcessEnableOptionalXStateFeatures, // s: ULONG64 // optional XState feature bitmask
    ProcessAltPrefetchParam,             // qs: OVERRIDE_PREFETCH_PARAMETER // App Launch Prefetch (ALPF) // since 22H1
    ProcessAssignCpuPartitions,
    ProcessPriorityClassEx,       // s: PROCESS_PRIORITY_CLASS_EX
    ProcessMembershipInformation, // q: PROCESS_MEMBERSHIP_INFORMATION
    ProcessEffectiveIoPriority,   // q: IO_PRIORITY_HINT // 110
    ProcessEffectivePagePriority, // q: ULONG
    ProcessSchedulerSharedData,   // since 24H2
    ProcessSlistRollbackInformation,
    ProcessNetworkIoCounters,         // q: PROCESS_NETWORK_COUNTERS
    ProcessFindFirstThreadByTebValue, // PROCESS_TEB_VALUE_INFORMATION
    MaxProcessInfoClass
};

using PS_ATTRIBUTE_NUM = enum _PS_ATTRIBUTE_NUM
{
    PsAttributeParentProcess,      // in HANDLE
    PsAttributeDebugObject,        // in HANDLE
    PsAttributeToken,              // in HANDLE
    PsAttributeClientId,           // out PCLIENT_ID
    PsAttributeTebAddress,         // out PTEB *
    PsAttributeImageName,          // in PWSTR
    PsAttributeImageInfo,          // out PSECTION_IMAGE_INFORMATION
    PsAttributeMemoryReserve,      // in PPS_MEMORY_RESERVE
    PsAttributePriorityClass,      // in UCHAR
    PsAttributeErrorMode,          // in ULONG
    PsAttributeStdHandleInfo,      // 10, in PPS_STD_HANDLE_INFO
    PsAttributeHandleList,         // in HANDLE[]
    PsAttributeGroupAffinity,      // in PGROUP_AFFINITY
    PsAttributePreferredNode,      // in PUSHORT
    PsAttributeIdealProcessor,     // in PPROCESSOR_NUMBER
    PsAttributeUmsThread,          // ? in PUMS_CREATE_THREAD_ATTRIBUTES
    PsAttributeMitigationOptions,  // in PPS_MITIGATION_OPTIONS_MAP (PROCESS_CREATION_MITIGATION_POLICY_*) // since WIN8
    PsAttributeProtectionLevel,    // in PS_PROTECTION // since WINBLUE
    PsAttributeSecureProcess,      // in PPS_TRUSTLET_CREATE_ATTRIBUTES, since THRESHOLD
    PsAttributeJobList,            // in HANDLE[]
    PsAttributeChildProcessPolicy, // 20, in PULONG (PROCESS_CREATION_CHILD_PROCESS_*) // since THRESHOLD2
    PsAttributeAllApplicationPackagesPolicy,
    // in PULONG (PROCESS_CREATION_ALL_APPLICATION_PACKAGES_*) // since REDSTONE
    PsAttributeWin32kFilter,              // in PWIN32K_SYSCALL_FILTER
    PsAttributeSafeOpenPromptOriginClaim, // in SE_SAFE_OPEN_PROMPT_RESULTS
    PsAttributeBnoIsolation,              // in PPS_BNO_ISOLATION_PARAMETERS // since REDSTONE2
    PsAttributeDesktopAppPolicy,          // in PULONG (PROCESS_CREATION_DESKTOP_APP_*)
    PsAttributeChpe,                      // in BOOLEAN // since REDSTONE3
    PsAttributeMitigationAuditOptions,
    // in PPS_MITIGATION_AUDIT_OPTIONS_MAP (PROCESS_CREATION_MITIGATION_AUDIT_POLICY_*) // since 21H1
    PsAttributeMachineType, // in USHORT // since 21H2
    PsAttributeComponentFilter,
    PsAttributeEnableOptionalXStateFeatures, // since WIN11
    PsAttributeSupportedMachines,            // since 24H2
    PsAttributeSveVectorLength,              // PPS_PROCESS_CREATION_SVE_VECTOR_LENGTH
    PsAttributeMax
};

struct SYSTEM_PROCESSOR_INFORMATION64
{
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT MaximumProcessors;
    ULONG ProcessorFeatureBits;
};

#if !defined(OS_WINDOWS) || !defined(_WIN64)

#if !defined(OS_WINDOWS)
typedef struct _M128A
{
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;
#endif

typedef struct _XMM_SAVE_AREA32
{
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];
    M128A XmmRegisters[16];
    BYTE Reserved4[96];
} XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

#endif

using NEON128 = struct _NEON128
{
    ULONGLONG Low;
    LONGLONG High;
};

typedef struct
#if !defined(__MINGW64__)
    DECLSPEC_ALIGN(16)
#endif
        _CONTEXT64
{
    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;
    DWORD ContextFlags;
    DWORD MxCsr;
    WORD SegCs;
    WORD SegDs;
    WORD SegEs;
    WORD SegFs;
    WORD SegGs;
    WORD SegSs;
    DWORD EFlags;
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD64 Rip;

    union
    {
        XMM_SAVE_AREA32 FltSave;
        NEON128 Q[16];
        ULONGLONG D[32];

        struct
        {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        };

        DWORD S[32];
    };

    M128A VectorRegister[26];
    DWORD64 VectorControl;
    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
} CONTEXT64, *PCONTEXT64;

typedef struct _CONTEXT_CHUNK
{
    LONG Offset; // Offset may be negative.
    ULONG Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

typedef struct _CONTEXT_EX
{
    CONTEXT_CHUNK All;
    CONTEXT_CHUNK Legacy;
    CONTEXT_CHUNK XState;
    CONTEXT_CHUNK KernelCet;
} CONTEXT_EX, *PCONTEXT_EX;

template <typename Traits>
struct EMU_EXCEPTION_RECORD
{
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    EMULATOR_CAST(typename Traits::PVOID, struct EMU_EXCEPTION_RECORD*) ExceptionRecord;
    typename Traits::PVOID ExceptionAddress;
    DWORD NumberParameters;
    typename Traits::ULONG_PTR ExceptionInformation[15];
};

template <typename Traits>
struct EMU_EXCEPTION_POINTERS
{
    EMULATOR_CAST(typename Traits::PVOID, EMU_EXCEPTION_RECORD*) ExceptionRecord;
    EMULATOR_CAST(typename Traits::PVOID, CONTEXT64* or CONTEXT32*) ContextRecord;
};

#define MAXIMUM_NODE_COUNT64 0x40
#define MAXIMUM_NODE_COUNT32 0x10

struct EMU_GROUP_AFFINITY64
{
    EMULATOR_CAST(std::uint64_t, KAFFINITY) Mask;
    WORD Group;
    WORD Reserved[3];
};

typedef struct _SYSTEM_NUMA_INFORMATION64
{
    ULONG HighestNodeNumber;
    ULONG Reserved;

    union
    {
        EMU_GROUP_AFFINITY64 ActiveProcessorsGroupAffinity[MAXIMUM_NODE_COUNT64];
        ULONGLONG AvailableMemory[MAXIMUM_NODE_COUNT64];
        ULONGLONG Pad[MAXIMUM_NODE_COUNT64 * 2];
    };
} SYSTEM_NUMA_INFORMATION64, *PSYSTEM_NUMA_INFORMATION64;

typedef struct _SYSTEM_ERROR_PORT_TIMEOUTS
{
    ULONG StartTimeout;
    ULONG CommTimeout;
} SYSTEM_ERROR_PORT_TIMEOUTS, *PSYSTEM_ERROR_PORT_TIMEOUTS;

typedef struct _SYSTEM_BASIC_INFORMATION64
{
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, ULONG_PTR) MinimumUserModeAddress;
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, ULONG_PTR) MaximumUserModeAddress;
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, KAFFINITY) ActiveProcessorsAffinityMask;
    char NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION64, *PSYSTEM_BASIC_INFORMATION64;

typedef struct _SYSTEM_RANGE_START_INFORMATION64
{
    EmulatorTraits<Emu64>::SIZE_T SystemRangeStart;
} SYSTEM_RANGE_START_INFORMATION64, *PSYSTEM_RANGE_START_INFORMATION64;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

struct SID_AND_ATTRIBUTES64
{
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PSID) Sid;
    DWORD Attributes;
};

struct TOKEN_USER64
{
    SID_AND_ATTRIBUTES64 User;
};

struct TOKEN_GROUPS64
{
    ULONG GroupCount;
    SID_AND_ATTRIBUTES64 Groups[1];
};

struct TOKEN_OWNER64
{
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PSID) Owner;
};

struct TOKEN_PRIMARY_GROUP64
{
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PSID) PrimaryGroup;
};

#ifndef OS_WINDOWS
struct ACL
{
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
};

struct ACE_HEADER
{
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
};

typedef DWORD ACCESS_MASK;

struct ACCESS_ALLOWED_ACE
{
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
};
#endif

struct TOKEN_DEFAULT_DACL64
{
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PACL) DefaultDacl;
};

struct TOKEN_BNO_ISOLATION_INFORMATION64
{
    EmulatorTraits<Emu64>::PVOID IsolationPrefix;
    BOOLEAN IsolationEnabled;
};

struct TOKEN_MANDATORY_LABEL64
{
    SID_AND_ATTRIBUTES64 Label;
};

struct TOKEN_PROCESS_TRUST_LEVEL64
{
    EMULATOR_CAST(EmulatorTraits<Emu64>::PVOID, PSID) TrustLevelSid;
};

#ifndef OS_WINDOWS

typedef enum _TOKEN_TYPE
{
    TokenPrimary = 1,
    TokenImpersonation
} TOKEN_TYPE;
typedef TOKEN_TYPE* PTOKEN_TYPE;

typedef struct _TOKEN_ELEVATION
{
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef enum _SECURITY_IMPERSONATION_LEVEL
{
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;

typedef struct _LUID
{
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;

typedef struct _TOKEN_STATISTICS
{
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;

#endif

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;

    union
    {
        EmulatorTraits<Emu64>::PVOID pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

#ifndef OS_WINDOWS
#define SECURITY_DESCRIPTOR_REVISION  1
#define SECURITY_DESCRIPTOR_REVISION1 1

typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

#define SE_OWNER_DEFAULTED       0x0001
#define SE_GROUP_DEFAULTED       0x0002
#define SE_DACL_PRESENT          0x0004
#define SE_DACL_DEFAULTED        0x0008
#define SE_SACL_PRESENT          0x0010
#define SE_SACL_DEFAULTED        0x0020
#define SE_DACL_AUTO_INHERIT_REQ 0x0100
#define SE_SACL_AUTO_INHERIT_REQ 0x0200
#define SE_DACL_AUTO_INHERITED   0x0400
#define SE_SACL_AUTO_INHERITED   0x0800
#define SE_DACL_PROTECTED        0x1000
#define SE_SACL_PROTECTED        0x2000
#define SE_RM_CONTROL_VALID      0x4000
#define SE_SELF_RELATIVE         0x8000

struct SECURITY_DESCRIPTOR_RELATIVE
{
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
};

typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION               0x00000001L
#define GROUP_SECURITY_INFORMATION               0x00000002L
#define DACL_SECURITY_INFORMATION                0x00000004L
#define SACL_SECURITY_INFORMATION                0x00000008L
#define LABEL_SECURITY_INFORMATION               0x00000010L
#define ATTRIBUTE_SECURITY_INFORMATION           0x00000020L
#define SCOPE_SECURITY_INFORMATION               0x00000040L
#define PROCESS_TRUST_LABEL_SECURITY_INFORMATION 0x00000080L
#define ACCESS_FILTER_SECURITY_INFORMATION       0x00000100L
#define BACKUP_SECURITY_INFORMATION              0x00010000L
#endif

struct GDI_HANDLE_ENTRY64
{
    union
    {
        EmulatorTraits<Emu64>::PVOID Object;
        EmulatorTraits<Emu64>::PVOID NextFree;
    };

    union
    {
        struct
        {
            USHORT ProcessId;
            USHORT Lock : 1;
            USHORT Count : 15;
        };

        ULONG Value;
    } Owner;

    USHORT Unique;
    UCHAR Type;
    UCHAR Flags;
    EmulatorTraits<Emu64>::PVOID UserPointer;
};

#define GDI_MAX_HANDLE_COUNT 0xFFFF // 0x4000

struct GDI_SHARED_MEMORY64
{
    GDI_HANDLE_ENTRY64 Handles[GDI_MAX_HANDLE_COUNT];
    char pad[0xC8];
    uint64_t Objects[0x20];
    uint64_t Data[0x200]; // ?
};

static_assert(offsetof(GDI_SHARED_MEMORY64, Objects) == 0x1800B0);

struct CLIENT_ID32
{
    ULONG UniqueProcess;
    ULONG UniqueThread;
};

struct CLIENT_ID64
{
    DWORD64 UniqueProcess;
    DWORD64 UniqueThread;
};

template <typename Traits>
struct EMU_RTL_SRWLOCK
{
    typename Traits::PVOID Ptr;
};

#ifndef OS_WINDOWS
typedef enum _PROCESSOR_CACHE_TYPE
{
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP
{
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationProcessorDie,
    RelationNumaNodeEx,
    RelationProcessorModule,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;
#endif

struct EMU_NUMA_NODE_RELATIONSHIP64
{
    DWORD NodeNumber;
    BYTE Reserved[18];
    WORD GroupCount;
    union
    {
        EMU_GROUP_AFFINITY64 GroupMask;
        _Field_size_(GroupCount) EMU_GROUP_AFFINITY64 GroupMasks[ANYSIZE_ARRAY];
    };
};

struct EMU_CACHE_RELATIONSHIP64
{
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[18];
    WORD GroupCount;
    union
    {
        EMU_GROUP_AFFINITY64 GroupMask;
        _Field_size_(GroupCount) EMU_GROUP_AFFINITY64 GroupMasks[ANYSIZE_ARRAY];
    };
};

struct EMU_PROCESSOR_GROUP_INFO64
{
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    EMULATOR_CAST(std::uint64_t, KAFFINITY) ActiveProcessorMask;
};

struct EMU_GROUP_RELATIONSHIP64
{
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    _Field_size_(ActiveGroupCount) EMU_PROCESSOR_GROUP_INFO64 GroupInfo[ANYSIZE_ARRAY];
};

struct EMU_PROCESSOR_RELATIONSHIP64
{
    BYTE Flags;
    BYTE EfficiencyClass;
    BYTE Reserved[20];
    WORD GroupCount;
    _Field_size_(GroupCount) EMU_GROUP_AFFINITY64 GroupMask[ANYSIZE_ARRAY];
};

_Struct_size_bytes_(Size) struct EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX64
{
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union
    {
        EMU_PROCESSOR_RELATIONSHIP64 Processor;
        EMU_NUMA_NODE_RELATIONSHIP64 NumaNode;
        EMU_CACHE_RELATIONSHIP64 Cache;
        EMU_GROUP_RELATIONSHIP64 Group;
    };
};

struct EMU_CACHE_DESCRIPTOR
{
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD Size;
    PROCESSOR_CACHE_TYPE Type;
};

template <typename Traits>
struct EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION
{
    typename Traits::ULONG_PTR ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union
    {
        struct
        {
            BYTE Flags;
        } ProcessorCore;
        struct
        {
            DWORD NodeNumber;
        } NumaNode;
        EMU_CACHE_DESCRIPTOR Cache;
        ULONGLONG Reserved[2];
    } DUMMYUNIONNAME;
};

struct PROCESS_PRIORITY_CLASS
{
    BOOLEAN Foreground;
    UCHAR PriorityClass;
};

struct PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
{
    ULONG Version;
    ULONG Reserved;
    uint64_t Callback;
};
// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/registry.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

typedef enum _KEY_INFORMATION_CLASS
{
    KeyBasicInformation,          // KEY_BASIC_INFORMATION
    KeyNodeInformation,           // KEY_NODE_INFORMATION
    KeyFullInformation,           // KEY_FULL_INFORMATION
    KeyNameInformation,           // KEY_NAME_INFORMATION
    KeyCachedInformation,         // KEY_CACHED_INFORMATION
    KeyFlagsInformation,          // KEY_FLAGS_INFORMATION
    KeyVirtualizationInformation, // KEY_VIRTUALIZATION_INFORMATION
    KeyHandleTagsInformation,     // KEY_HANDLE_TAGS_INFORMATION
    KeyTrustInformation,          // KEY_TRUST_INFORMATION
    KeyLayerInformation,          // KEY_LAYER_INFORMATION
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef enum _KEY_VALUE_INFORMATION_CLASS
{
    KeyValueBasicInformation,   // KEY_VALUE_BASIC_INFORMATION
    KeyValueFullInformation,    // KEY_VALUE_FULL_INFORMATION
    KeyValuePartialInformation, // KEY_VALUE_PARTIAL_INFORMATION
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64, // KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
    KeyValueLayerInformation,          // KEY_VALUE_LAYER_INFORMATION
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

struct KEY_NAME_INFORMATION
{
    std::uint32_t NameLength;
    char16_t Name[1];
};

typedef struct _KEY_BASIC_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    char16_t Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG NameLength;
    char16_t Name[1];
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG SubKeys;
    ULONG MaxNameLength;
    ULONG MaxClassLength;
    ULONG Values;
    ULONG MaxValueNameLength;
    ULONG MaxValueDataLength;
    char16_t Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    ULONG NameLength;
} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;

struct KEY_HANDLE_TAGS_INFORMATION
{
    ULONG HandleTags;
};

struct KEY_VALUE_BASIC_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG NameLength;
    char16_t Name[1];
};

struct KEY_VALUE_PARTIAL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
};

struct KEY_VALUE_FULL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG NameLength;
    char16_t Name[1];
};

struct KEY_VALUE_ENTRY
{
    EmulatorTraits<Emu64>::PVOID ValueName;
    ULONG DataLength;
    ULONG DataOffset;
    ULONG Type;
};

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/status.hpp`:

```hpp
#pragma once

#include <cstdint>

using NTSTATUS = std::uint32_t;

#ifndef OS_WINDOWS
#define STATUS_WAIT_0                 ((NTSTATUS)0x00000000L)
#define STATUS_USER_APC               ((NTSTATUS)0x000000C0L)
#define STATUS_TIMEOUT                ((NTSTATUS)0x00000102L)
#define STATUS_PENDING                ((NTSTATUS)0x00000103L)

#define STATUS_GUARD_PAGE_VIOLATION   ((NTSTATUS)0x80000001L)
#define STATUS_DATATYPE_MISALIGNMENT  ((NTSTATUS)0x80000002L)
#define STATUS_BREAKPOINT             ((NTSTATUS)0x80000003L)
#define STATUS_SINGLE_STEP            ((NTSTATUS)0x80000004L)

#define STATUS_ACCESS_VIOLATION       ((NTSTATUS)0xC0000005L)
#define STATUS_INVALID_HANDLE         ((NTSTATUS)0xC0000008L)
#define STATUS_INVALID_PARAMETER      ((NTSTATUS)0xC000000DL)
#define STATUS_ILLEGAL_INSTRUCTION    ((NTSTATUS)0xC000001DL)
#define STATUS_INTEGER_DIVIDE_BY_ZERO ((NTSTATUS)0xC0000094L)
#endif

#define STATUS_SUCCESS                     ((NTSTATUS)0x00000000L)
#define STATUS_WAIT_1                      ((NTSTATUS)0x00000001L)
#define STATUS_ALERTED                     ((NTSTATUS)0x00000101L)
#define STATUS_PIPE_LISTENING              ((NTSTATUS)0x00000105L)
#define STATUS_PIPE_CONNECTED              ((NTSTATUS)0x00000106L)

#define STATUS_OBJECT_NAME_EXISTS          ((NTSTATUS)0x40000000L)
#define STATUS_SERVICE_NOTIFICATION        ((NTSTATUS)0x40000018L)

#define STATUS_BUFFER_OVERFLOW             ((NTSTATUS)0x80000005L)
#define STATUS_NO_MORE_FILES               ((NTSTATUS)0x80000006L)
#define STATUS_NO_MORE_ENTRIES             ((NTSTATUS)0x8000001AL)

#define STATUS_UNSUCCESSFUL                ((NTSTATUS)0xC0000001L)
#define STATUS_INVALID_INFO_CLASS          ((NTSTATUS)0xC0000003L)
#define STATUS_INFO_LENGTH_MISMATCH        ((NTSTATUS)0xC0000004L)
#define STATUS_INVALID_CID                 ((NTSTATUS)0xC000000BL)
#define STATUS_CONFLICTING_ADDRESSES       ((NTSTATUS)0xC0000018L)
#define STATUS_NOT_MAPPED_VIEW             ((NTSTATUS)0xC0000019L)
#define STATUS_UNABLE_TO_DELETE_SECTION    ((NTSTATUS)0xC000001BL)
#define STATUS_ACCESS_DENIED               ((NTSTATUS)0xC0000022L)
#define STATUS_BUFFER_TOO_SMALL            ((NTSTATUS)0xC0000023L)
#define STATUS_OBJECT_TYPE_MISMATCH        ((NTSTATUS)0xC0000024L)
#define STATUS_OBJECT_NAME_NOT_FOUND       ((NTSTATUS)0xC0000034L)
#define STATUS_OBJECT_TYPE_MISMATCH        ((NTSTATUS)0xC0000024L)
#define STATUS_OBJECT_NAME_COLLISION       ((NTSTATUS)0xC0000035L)
#define STATUS_OBJECT_PATH_NOT_FOUND       ((NTSTATUS)0xC000003AL)
#define STATUS_INVALID_PAGE_PROTECTION     ((NTSTATUS)0xC0000045L)
#define STATUS_MUTANT_NOT_OWNED            ((NTSTATUS)0xC0000046L)
#define STATUS_SEMAPHORE_LIMIT_EXCEEDED    ((NTSTATUS)0xC0000047L)
#define STATUS_SECTION_NOT_IMAGE           ((NTSTATUS)0xC0000049L)
#define STATUS_SUSPEND_COUNT_EXCEEDED      ((NTSTATUS)0xC000004AL)
#define STATUS_PROCEDURE_NOT_FOUND         ((NTSTATUS)0xC000007AL)
#define STATUS_NO_TOKEN                    ((NTSTATUS)0xC000007CL)
#define STATUS_FILE_INVALID                ((NTSTATUS)0xC0000098L)
#define STATUS_INSUFFICIENT_RESOURCES      ((NTSTATUS)0xC000009AL)
#define STATUS_FREE_VM_NOT_AT_BASE         ((NTSTATUS)0xC000009FL)
#define STATUS_MEMORY_NOT_ALLOCATED        ((NTSTATUS)0xC00000A0L)
#define STATUS_PIPE_BUSY                   ((NTSTATUS)0xC00000AAL)
#define STATUS_PIPE_NOT_AVAILABLE          ((NTSTATUS)0xC00000ACL)
#define STATUS_INVALID_PIPE_STATE          ((NTSTATUS)0xC00000ADL)
#define STATUS_PIPE_DISCONNECTED           ((NTSTATUS)0xC00000B0L)
#define STATUS_PIPE_CLOSING                ((NTSTATUS)0xC00000B1L)
#define STATUS_FILE_IS_A_DIRECTORY         ((NTSTATUS)0xC00000BAL)
#define STATUS_NOT_SUPPORTED               ((NTSTATUS)0xC00000BBL)
#define STATUS_PIPE_NOT_CONNECTED          ((NTSTATUS)0xC00000BEL)
#define STATUS_PIPE_EMPTY                  ((NTSTATUS)0xC00000D9L)
#define STATUS_INTERNAL_ERROR              ((NTSTATUS)0xC00000E5L)
#define STATUS_INVALID_PARAMETER_1         ((NTSTATUS)0xC00000EFL)
#define STATUS_INVALID_PARAMETER_2         ((NTSTATUS)0xC00000F0L)
#define STATUS_INVALID_PARAMETER_3         ((NTSTATUS)0xC00000F1L)
#define STATUS_INVALID_PARAMETER_4         ((NTSTATUS)0xC00000F2L)
#define STATUS_INVALID_PARAMETER_5         ((NTSTATUS)0xC00000F3L)
#define STATUS_INVALID_PARAMETER_6         ((NTSTATUS)0xC00000F4L)
#define STATUS_INVALID_PARAMETER_7         ((NTSTATUS)0xC00000F5L)
#define STATUS_INVALID_PARAMETER_8         ((NTSTATUS)0xC00000F6L)
#define STATUS_INVALID_PARAMETER_9         ((NTSTATUS)0xC00000F7L)
#define STATUS_INVALID_PARAMETER_10        ((NTSTATUS)0xC00000F8L)
#define STATUS_INVALID_PARAMETER_11        ((NTSTATUS)0xC00000F9L)
#define STATUS_INVALID_PARAMETER_12        ((NTSTATUS)0xC00000FAL)
#define STATUS_INVALID_ADDRESS             ((NTSTATUS)0xC0000141L)
#define STATUS_PIPE_BROKEN                 ((NTSTATUS)0xC000014BL)
#define STATUS_CONNECTION_RESET            ((NTSTATUS)0xC000020DL)
#define STATUS_NOT_FOUND                   ((NTSTATUS)0xC0000225L)
#define STATUS_NOT_SAME_OBJECT             ((NTSTATUS)0xC00001ACL)
#define STATUS_CONNECTION_REFUSED          ((NTSTATUS)0xC0000236L)
#define STATUS_TIMER_RESOLUTION_NOT_SET    ((NTSTATUS)0xC0000245L)
#define STATUS_ADDRESS_ALREADY_ASSOCIATED  ((NTSTATUS)0xC0000328L)
#define STATUS_PORT_NOT_SET                ((NTSTATUS)0xC0000353L)
#define STATUS_DEBUGGER_INACTIVE           ((NTSTATUS)0xC0000354L)
#define STATUS_IMAGE_NOT_AT_BASE           ((NTSTATUS)0x40000003L)
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS)0x4000000EL)

#define FILE_DEVICE_NETWORK                0x00000012
#define FSCTL_AFD_BASE                     FILE_DEVICE_NETWORK

```

`src/common/platform/synchronisation.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(modernize-use-using)

typedef enum _EVENT_TYPE
{
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef enum _WAIT_TYPE
{
    WaitAll,
    WaitAny,
    WaitNotification,
    WaitDequeue,
    WaitDpc,
} WAIT_TYPE;

struct EVENT_BASIC_INFORMATION
{
    EVENT_TYPE EventType;
    LONG EventState;
};

// NOLINTEND(modernize-use-using)

```

`src/common/platform/threading.hpp`:

```hpp
#pragma once

#include "kernel_mapped.hpp"

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

typedef enum _THREADINFOCLASS
{
    ThreadBasicInformation,          // q: THREAD_BASIC_INFORMATION
    ThreadTimes,                     // q: KERNEL_USER_TIMES
    ThreadPriority,                  // s: KPRIORITY (requires SeIncreaseBasePriorityPrivilege)
    ThreadBasePriority,              // s: KPRIORITY
    ThreadAffinityMask,              // s: KAFFINITY
    ThreadImpersonationToken,        // s: HANDLE
    ThreadDescriptorTableEntry,      // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
    ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress, // q: ULONG_PTR
    ThreadZeroTlsCell,               // s: ULONG // TlsIndex // 10
    ThreadPerformanceCount,          // q: LARGE_INTEGER
    ThreadAmILastThread,             // q: ULONG
    ThreadIdealProcessor,            // s: ULONG
    ThreadPriorityBoost,             // qs: ULONG
    ThreadSetTlsArrayAddress,        // s: ULONG_PTR // Obsolete
    ThreadIsIoPending,               // q: ULONG
    ThreadHideFromDebugger,          // q: BOOLEAN; s: void
    ThreadBreakOnTermination,        // qs: ULONG
    ThreadSwitchLegacyState,         // s: void // NtCurrentThread // NPX/FPU
    ThreadIsTerminated,              // q: ULONG // 20
    ThreadLastSystemCall,            // q: THREAD_LAST_SYSCALL_INFORMATION
    ThreadIoPriority,                // qs: IO_PRIORITY_HINT (requires SeIncreaseBasePriorityPrivilege)
    ThreadCycleTime,                 // q: THREAD_CYCLE_TIME_INFORMATION
    ThreadPagePriority,              // qs: PAGE_PRIORITY_INFORMATION
    ThreadActualBasePriority,        // s: LONG (requires SeIncreaseBasePriorityPrivilege)
    ThreadTebInformation,            // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
    ThreadCSwitchMon,                // Obsolete
    ThreadCSwitchPmu,
    ThreadWow64Context,             // qs: WOW64_CONTEXT, ARM_NT_CONTEXT since 20H1
    ThreadGroupInformation,         // qs: GROUP_AFFINITY // 30
    ThreadUmsInformation,           // q: THREAD_UMS_INFORMATION // Obsolete
    ThreadCounterProfiling,         // q: BOOLEAN; s: THREAD_PROFILING_INFORMATION?
    ThreadIdealProcessorEx,         // qs: PROCESSOR_NUMBER; s: previous PROCESSOR_NUMBER on return
    ThreadCpuAccountingInformation, // q: BOOLEAN; s: HANDLE (NtOpenSession) // NtCurrentThread // since WIN8
    ThreadSuspendCount,             // q: ULONG // since WINBLUE
    ThreadHeterogeneousCpuPolicy,   // q: KHETERO_CPU_POLICY // since THRESHOLD
    ThreadContainerId,              // q: GUID
    ThreadNameInformation,          // qs: THREAD_NAME_INFORMATION
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation,        // q: SYSTEM_THREAD_INFORMATION // 40
    ThreadActualGroupAffinity,            // q: GROUP_AFFINITY // since THRESHOLD2
    ThreadDynamicCodePolicyInfo,          // q: ULONG; s: ULONG (NtCurrentThread)
    ThreadExplicitCaseSensitivity,        // qs: ULONG; s: 0 disables, otherwise enables
    ThreadWorkOnBehalfTicket,             // RTL_WORK_ON_BEHALF_TICKET_EX
    ThreadSubsystemInformation,           // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ThreadDbgkWerReportActive,            // s: ULONG; s: 0 disables, otherwise enables
    ThreadAttachContainer,                // s: HANDLE (job object) // NtCurrentThread
    ThreadManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ThreadPowerThrottlingState,           // POWER_THROTTLING_THREAD_STATE // since REDSTONE3 (set), WIN11 22H2 (query)
    ThreadWorkloadClass,                  // THREAD_WORKLOAD_CLASS // since REDSTONE5 // 50
    ThreadCreateStateChange,              // since WIN11
    ThreadApplyStateChange,
    ThreadStrongerBadHandleChecks, // since 22H1
    ThreadEffectiveIoPriority,     // q: IO_PRIORITY_HINT
    ThreadEffectivePagePriority,   // q: ULONG
    ThreadUpdateLockOwnership,     // since 24H2
    ThreadSchedulerSharedDataSlot, // SCHEDULER_SHARED_DATA_SLOT_INFORMATION
    ThreadTebInformationAtomic,    // THREAD_TEB_INFORMATION
    ThreadIndexInformation,        // THREAD_INDEX_INFORMATION
    MaxThreadInfoClass
} THREADINFOCLASS;

template <typename Traits>
struct THREAD_NAME_INFORMATION
{
    UNICODE_STRING<Traits> ThreadName;
};

typedef struct _THREAD_BASIC_INFORMATION64
{
    NTSTATUS ExitStatus;
    EMULATOR_CAST(uint64_t, PTEB64) TebBaseAddress;
    CLIENT_ID64 ClientId;
    EMULATOR_CAST(std::uint64_t, KAFFINITY) AffinityMask;
    EMULATOR_CAST(std::uint32_t, KPRIORITY) Priority;
    EMULATOR_CAST(std::uint32_t, KPRIORITY) BasePriority;
} THREAD_BASIC_INFORMATION64, *PTHREAD_BASIC_INFORMATION64;

typedef struct _THREAD_TEB_INFORMATION
{
    EmulatorTraits<Emu64>::PVOID TebInformation; // Buffer to write data into.
    ULONG TebOffset;                             // Offset in TEB to begin reading from.
    ULONG BytesToRead;                           // Number of bytes to read.
} THREAD_TEB_INFORMATION, *PTHREAD_TEB_INFORMATION;

typedef enum _KCONTINUE_TYPE
{
    KCONTINUE_UNWIND,
    KCONTINUE_RESUME,
    KCONTINUE_LONGJUMP,
    KCONTINUE_SET,
    KCONTINUE_LAST,
} KCONTINUE_TYPE;

typedef struct _KCONTINUE_ARGUMENT
{
    KCONTINUE_TYPE ContinueType;
    ULONG ContinueFlags;
    ULONGLONG Reserved[2];
} KCONTINUE_ARGUMENT, *PKCONTINUE_ARGUMENT;

#define KCONTINUE_FLAG_TEST_ALERT  0x00000001
#define KCONTINUE_FLAG_DELIVER_APC 0x00000002

#ifndef OS_WINDOWS
typedef enum _QUEUE_USER_APC_FLAGS
{
    QUEUE_USER_APC_FLAGS_NONE,
    QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC,
    QUEUE_USER_APC_CALLBACK_DATA_CONTEXT
} QUEUE_USER_APC_FLAGS;
#endif

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/traits.hpp`:

```hpp
#pragma once

#include <cstdint>

// used to retain original type "x"
#define EMULATOR_CAST(T, x) T

struct Emu32
{
};

struct Emu64
{
};

template <typename EmuArch>
struct EmulatorTraits;

template <>
struct EmulatorTraits<Emu32>
{
    using PVOID = std::uint32_t;
    using ULONG_PTR = std::uint32_t;
    using SIZE_T = std::uint32_t;
    using UNICODE = char16_t;
    using HANDLE = std::uint32_t;
};

template <>
struct EmulatorTraits<Emu64>
{
    using PVOID = std::uint64_t;
    using ULONG_PTR = std::uint64_t;
    using SIZE_T = std::uint64_t;
    using UNICODE = char16_t;
    using HANDLE = std::uint64_t;
};

```

`src/common/platform/unicode.hpp`:

```hpp
#pragma once

#include <string>
#include <filesystem>
#include <type_traits>

template <typename Traits>
struct UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    EMULATOR_CAST(typename Traits::PVOID, char16_t*) Buffer;
};

template <typename string_type>
    requires(std::is_same_v<string_type, std::u16string> || std::is_same_v<string_type, std::u32string> ||
             std::is_same_v<string_type, std::wstring>)
constexpr string_type convert_from_u8(const std::string_view view)
{
    using char_type = typename string_type::value_type;
    constexpr auto char_size = sizeof(char_type);

    string_type result_str;
    result_str.reserve(view.size());

    bool recheck = false;
    int state = 0;
    uint8_t t1 = 0;
    uint8_t t2 = 0;
    uint8_t t3 = 0;

    for (const char8_t ch : view)
    {
        do
        {
            recheck = false;
            switch (state)
            {
            case 0:
                if (ch <= 0x7f)
                {
                    result_str.push_back(static_cast<char_type>(ch));
                }
                else if (ch >= 0xC2 && ch <= 0xDF)
                {
                    t1 = ch;
                    state = 1;
                }
                else if (ch == 0xE0)
                {
                    t1 = ch;
                    state = 2;
                }
                else if (ch == 0xED)
                {
                    t1 = ch;
                    state = 3;
                }
                else if ((ch >= 0xE1 && ch <= 0xEC) || (ch >= 0xEE && ch <= 0xEF))
                {
                    t1 = ch;
                    state = 4;
                }
                else if (ch == 0xF0)
                {
                    t1 = ch;
                    state = 5;
                }
                else if (ch == 0xF4)
                {
                    t1 = ch;
                    state = 6;
                }
                else if (ch >= 0xF1 && ch <= 0xF3)
                {
                    t1 = ch;
                    state = 7;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                }
                break;
            case 1:
                state = 0;
                if (ch >= 0x80 && ch <= 0xBF)
                {
                    result_str.push_back(static_cast<char_type>(((t1 & 0x1F) << 6) + (ch & 0x3F)));
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    recheck = true;
                }
                break;
            case 2:
                if (ch >= 0xA0 && ch <= 0xBF)
                {
                    t2 = ch;
                    state = 8;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 3:
                if (ch >= 0x80 && ch <= 0x9F)
                {
                    t2 = ch;
                    state = 8;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 4:
                if (ch >= 0x80 && ch <= 0xBF)
                {
                    t2 = ch;
                    state = 8;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 5:
                if (ch >= 0x90 && ch <= 0xBF)
                {
                    t2 = ch;
                    state = 9;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 6:
                if (ch >= 0x80 && ch <= 0x8F)
                {
                    t2 = ch;
                    state = 9;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 7:
                if (ch >= 0x80 && ch <= 0xBF)
                {
                    t2 = ch;
                    state = 9;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 8:
                if (ch >= 0x80 && ch <= 0xBF)
                {
                    result_str.push_back(static_cast<char_type>(((t1 & 0x0F) << 12) + ((t2 & 0x3F) << 6) + (ch & 0x3F)));
                    state = 0;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 9:
                if (ch >= 0x80 && ch <= 0xBF)
                {
                    t3 = ch;
                    state = 10;
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    state = 0;
                    recheck = true;
                }
                break;
            case 10:
                state = 0;
                if (ch >= 0x80 && ch <= 0xBF)
                {
                    uint32_t codepoint = ((t1 & 0x07) << 18) + ((t2 & 0x3F) << 12) + ((t3 & 0x3F) << 6) + (ch & 0x3F);

                    if constexpr (char_size == 2)
                    {
                        if (codepoint <= 0xFFFF)
                        {
                            result_str.push_back(static_cast<char_type>(codepoint));
                        }
                        else
                        {
                            const auto m = codepoint - 0x10000;
                            result_str.push_back(static_cast<char_type>(0xD800 + (m >> 10)));
                            result_str.push_back(static_cast<char_type>(0xDC00 + (m & 0x3ff)));
                        }
                    }
                    else
                    {
                        result_str.push_back(static_cast<char_type>(codepoint));
                    }
                }
                else
                {
                    result_str.push_back(static_cast<char_type>(0xFFFD));
                    recheck = true;
                }
                break;
            default:
                break;
            }
        } while (recheck);
    }

    if (state)
    {
        result_str.push_back(static_cast<char_type>(0xFFFD));
    }

    return result_str;
}

constexpr auto u8_to_u16(const std::string_view view)
{
    return convert_from_u8<std::u16string>(view);
}

constexpr auto u8_to_u32(const std::string_view view)
{
    return convert_from_u8<std::u32string>(view);
}

constexpr auto u8_to_w(const std::string_view view)
{
    return convert_from_u8<std::wstring>(view);
}

template <typename string_view_type>
    requires(std::is_same_v<string_view_type, std::u16string_view> || std::is_same_v<string_view_type, std::u32string_view> ||
             std::is_same_v<string_view_type, std::wstring_view>)
constexpr std::string convert_to_u8(const string_view_type view)
{
    using char_type = typename string_view_type::value_type;
    using uchar_type = std::make_unsigned_t<char_type>;
    constexpr auto char_size = sizeof(char_type);
    constexpr auto upper_codepoint = char_size == 2 ? 0xFFFF : 0x10FFFF;

    std::string utf8_str;
    utf8_str.reserve(view.size() * 2);

    bool recheck = false;
    uint32_t codepoint = 0;
    uint16_t wide = 0;

    // NOLINTNEXTLINE(bugprone-signed-char-misuse)
    for (const uchar_type ch : view)
    {
        do
        {
            recheck = false;
            if (wide)
            {
                if (ch >= 0xDC00 && ch <= 0xDFFF)
                {
                    codepoint = 0x10000 + ((wide - 0xD800) << 10) + (ch - 0xDC00);
                }
                else
                {
                    codepoint = 0xFFFD;
                    recheck = true;
                }
                wide = 0;
            }
            else
            {
                if ((ch <= 0xD7FF || ch >= 0xE000) && ch <= upper_codepoint)
                {
                    codepoint = ch;
                }
                else if (ch >= 0xD800 && ch <= 0xDBFF)
                {
                    if constexpr (char_size == 4)
                    {
                        codepoint = 0xFFFD;
                    }
                    else
                    {
                        wide = ch;
                        continue;
                    }
                }
                else
                {
                    codepoint = 0xFFFD;
                }
            }

            if (codepoint <= 0x7F)
            {
                utf8_str.push_back(static_cast<char>(codepoint));
            }
            else if (codepoint <= 0x7FF)
            {
                utf8_str.push_back(static_cast<char>(0xC0 | (codepoint >> 6)));
                utf8_str.push_back(static_cast<char>(0x80 | (codepoint & 0x3F)));
            }
            else if (codepoint <= 0xFFFF)
            {
                utf8_str.push_back(static_cast<char>(0xE0 | (codepoint >> 12)));
                utf8_str.push_back(static_cast<char>(0x80 | ((codepoint >> 6) & 0x3F)));
                utf8_str.push_back(static_cast<char>(0x80 | (codepoint & 0x3F)));
            }
            else if (codepoint <= 0x10FFFF)
            {
                utf8_str.push_back(static_cast<char>(0xF0 | (codepoint >> 18)));
                utf8_str.push_back(static_cast<char>(0x80 | ((codepoint >> 12) & 0x3F)));
                utf8_str.push_back(static_cast<char>(0x80 | ((codepoint >> 6) & 0x3F)));
                utf8_str.push_back(static_cast<char>(0x80 | (codepoint & 0x3F)));
            }
        } while (recheck);
    }

    if (wide)
    {
        utf8_str.push_back(static_cast<char>(0xEF));
        utf8_str.push_back(static_cast<char>(0xBF));
        utf8_str.push_back(static_cast<char>(0xBD));
    }

    return utf8_str;
}

constexpr auto u16_to_u8(const std::u16string_view view)
{
    return convert_to_u8<std::u16string_view>(view);
}

constexpr auto u32_to_u8(const std::u32string_view view)
{
    return convert_to_u8<std::u32string_view>(view);
}

constexpr auto w_to_u8(const std::wstring_view view)
{
    return convert_to_u8<std::wstring_view>(view);
}

constexpr auto u16_to_u32(const std::u16string_view view)
{
    std::u32string utf32_str;
    utf32_str.reserve(view.size());

    bool recheck = false;
    uint32_t codepoint = 0;
    uint16_t wide = 0;

    for (const auto ch : view)
    {
        do
        {
            recheck = false;
            if (wide)
            {
                if (ch >= 0xDC00 && ch <= 0xDFFF)
                {
                    codepoint = 0x10000 + ((wide - 0xD800) << 10) + (ch - 0xDC00);
                }
                else
                {
                    codepoint = 0xFFFD;
                    recheck = true;
                }
                wide = 0;
            }
            else
            {
                if (ch <= 0xD7FF || ch >= 0xE000)
                {
                    codepoint = ch;
                }
                else if (ch >= 0xD800 && ch <= 0xDBFF)
                {
                    wide = ch;
                    continue;
                }
                else
                {
                    codepoint = 0xFFFD;
                }
            }

            utf32_str.push_back(codepoint);
        } while (recheck);
    }

    if (wide)
    {
        utf32_str.push_back(0xFFFD);
    }

    return utf32_str;
}

constexpr std::wstring u16_to_w(const std::u16string_view view)
{
    if constexpr (sizeof(wchar_t) == 2)
    {
        return {view.begin(), view.end()};
    }
    else
    {
        const auto u32_str = u16_to_u32(view);
        return {u32_str.begin(), u32_str.end()};
    }
}

#ifndef OS_WINDOWS
inline int open_unicode(FILE** handle, const std::filesystem::path& fileName, const std::u16string& mode)
{
    *handle = fopen(fileName.string().c_str(), u16_to_u8(mode).c_str());
    return errno;
}
#else
inline auto open_unicode(FILE** handle, const std::filesystem::path& fileName, const std::u16string& mode)
{
    return _wfopen_s(handle, fileName.wstring().c_str(), u16_to_w(mode).c_str());
}
#endif

```

`src/common/platform/user.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#define FNID_START      0x29A
#define FNID_ARRAY_SIZE 24

constexpr size_t USER_NUM_SYSCOLORS = 31;
constexpr size_t USER_SERVERINFO_BRUSH_SLOT_COUNT = 32;
constexpr size_t USER_SERVERINFO_BRUSH_TRAILING_BYTES = 0x78;

struct USER_SERVERINFO
{
    DWORD dwSRVIFlags;
    uint64_t cHandleEntries;
    uint8_t unknown1[0x178];
    uint64_t apfnClientA[FNID_ARRAY_SIZE];
    uint64_t apfnClientW[FNID_ARRAY_SIZE];
    uint64_t apfnClientWorker[FNID_ARRAY_SIZE];
    uint8_t unknown2[0xE90];
    uint64_t ahbrSystem[USER_SERVERINFO_BRUSH_SLOT_COUNT];
    uint8_t unknown3[USER_SERVERINFO_BRUSH_TRAILING_BYTES];
};
static_assert(offsetof(USER_SERVERINFO, apfnClientA) == 0x188);
static_assert(offsetof(USER_SERVERINFO, ahbrSystem) == 0x1258);
static_assert(offsetof(USER_SERVERINFO, unknown3) == 0x1358);
static_assert(sizeof(USER_SERVERINFO) == 0x13D0);

struct USER_DISPINFO
{
    DWORD dwMonitorCount;
    EMULATOR_CAST(uint64_t, USER_MONITOR*) pPrimaryMonitor;
    uint8_t unknown[0xFF];
};

struct USER_HANDLEENTRY
{
    uint64_t pHead;
    uint64_t pOwner;
    uint64_t unknown;
    EMULATOR_CAST(uint8_t, USER_HANDLETYPE) bType;
    uint8_t bFlags;
    uint16_t wUniq;
};
static_assert(sizeof(USER_HANDLEENTRY) == 0x20);

struct USER_SHAREDINFO
{
    EMULATOR_CAST(uint64_t, USER_SERVERINFO*) psi;
    EMULATOR_CAST(uint64_t, USER_HANDLEENTRY*) aheList;
    uint32_t HeEntrySize;
    EMULATOR_CAST(uint64_t, USER_DISPINFO*) pDispInfo;
    uint8_t unknown[0xFF];
};

// user32 reads fields after copying 0x238 payload to _gSharedInfo
struct WIN32K_USERCONNECT32
{
    uint32_t psi;
    uint32_t reserved0;
    uint32_t ahe_list;
    uint32_t reserved1;
    uint32_t he_entry_size;
    uint32_t reserved2;
    uint32_t disp_info_low;
    uint32_t reserved3;
    uint8_t reserved4[0x10];
    uint32_t monitor_info_low;
    uint32_t reserved5;
    uint32_t shared_delta_low;
    uint32_t shared_delta_high;
    uint8_t wndmsg_table[0xC8];
    uint32_t wndmsg_count;
    uint32_t reserved6;
    uint32_t wndmsg_bits;
    uint32_t reserved7;
    uint32_t ime_msg_count;
    uint32_t reserved8;
    uint32_t ime_msg_bits;
    uint8_t reserved9[0x114];
};
static_assert(offsetof(WIN32K_USERCONNECT32, ahe_list) == 0x8);
static_assert(offsetof(WIN32K_USERCONNECT32, he_entry_size) == 0x10);
static_assert(offsetof(WIN32K_USERCONNECT32, disp_info_low) == 0x18);
static_assert(offsetof(WIN32K_USERCONNECT32, monitor_info_low) == 0x30);
static_assert(offsetof(WIN32K_USERCONNECT32, wndmsg_count) == 0x108);
static_assert(offsetof(WIN32K_USERCONNECT32, ime_msg_count) == 0x118);
static_assert(sizeof(WIN32K_USERCONNECT32) == 0x238);

enum USER_HANDLETYPE : uint8_t
{
    TYPE_FREE = 0,
    TYPE_WINDOW = 1,
    TYPE_MENU = 2,
    TYPE_CURSOR = 3,
    TYPE_SETWINDOWPOS = 4,
    TYPE_HOOK = 5,
    TYPE_CLIPDATA = 6,
    TYPE_CALLPROC = 7,
    TYPE_ACCELTABLE = 8,
    TYPE_DDEACCESS = 9,
    TYPE_DDECONV = 10,
    TYPE_DDEXACT = 11,
    TYPE_MONITOR = 12,
    TYPE_KBDLAYOUT = 13,
    TYPE_KBDFILE = 14,
    TYPE_WINEVENTHOOK = 15,
    TYPE_TIMER = 16,
    TYPE_INPUTCONTEXT = 17,
    TYPE_HIDDATA = 18,
    TYPE_DEVICEINFO = 19,
    TYPE_TOUCHINPUTINFO = 20,
    TYPE_GESTUREINFOOBJ = 21,
    TYPE_CTYPES = 22,
    TYPE_GENERIC = 255
};

struct USER_MONITOR
{
    EMULATOR_CAST(uint64_t, HMONITOR) hmon;
    uint8_t unknown1[0x14];
    RECT rcMonitor;
    RECT rcWork;
    union
    {
        struct
        {
            uint16_t monitorDpi;
            uint16_t nativeDpi;
        } b26;
        struct
        {
            uint32_t unknown1;
            uint16_t monitorDpi;
            uint16_t nativeDpi;
            uint16_t cachedDpi;
            uint16_t unknown2;
            RECT rcMonitorDpiAware;
        } b20;
    };
    uint8_t unknown4[0xFF];
};

template <typename Traits>
struct CLSMENUNAME
{
    EMULATOR_CAST(typename Traits::PVOID, char*) pszClientAnsiMenuName;
    EMULATOR_CAST(typename Traits::PVOID, char16_t*) pwszClientUnicodeMenuName;
    EMULATOR_CAST(typename Traits::PVOID, UNICODE_STRING*) pusMenuName;
};

struct USER_CLASS
{
    uint8_t unknown[0xFF];
};

struct USER_WINDOW
{
    uint64_t hWnd;
    uint64_t ptrBase;
    uint8_t pad_010[2];
    uint8_t bFlags;
    uint8_t pad_013[5];
    uint32_t dwExStyle;
    uint32_t dwStyle;
    uint64_t hInstance;
    uint8_t pad_028[8];
    uint64_t spwndParent;
    uint8_t pad_038[64];
    uint64_t lpfnWndProc;
    uint64_t pcls;
    uint8_t pad_088[16];
    uint64_t spmenu;
    uint8_t pad_0A0[40];
    uint32_t cbWndExtra;
    uint8_t pad_0CC[12];
    uint64_t userData;
    uint64_t pActCtx;
    uint8_t pad_0E8[16];
    uint32_t wndExtraOffset;
    uint8_t pad_0FC[44];
    uint64_t pExtraBytes;
    uint8_t pad_130[16];
    uint64_t wID;
};

struct USER_DESKTOPINFO
{
    uint8_t unknown[0xFF];
};

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/win_pefile.hpp`:

```hpp
#pragma once

#include <cstring>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <vector>
#include <system_error>
#include <variant>
#include <array>
#include "../utils/buffer_accessor.hpp"

#include "primitives.hpp"

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0 // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1 // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2 // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3 // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4 // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5 // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6 // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7  // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8  // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9  // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG     10 // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT    11 // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT             12 // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT    13 // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR  14 // COM Runtime descriptor

#define IMAGE_SCN_LNK_NRELOC_OVFL             0x01000000 // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE             0x02000000 // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED              0x04000000 // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED               0x08000000 // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                  0x10000000 // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                 0x20000000 // Section is executable.
#define IMAGE_SCN_MEM_READ                    0x40000000 // Section is readable.
#define IMAGE_SCN_MEM_WRITE                   0x80000000 // Section is writeable.

#define IMAGE_SCN_CNT_CODE                    0x00000020 // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA        0x00000040 // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA      0x00000080 // Section contains uninitialized data.

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_ARM_MOV32A            5
#define IMAGE_REL_BASED_ARM_MOV32             5
#define IMAGE_REL_BASED_SECTION               6
#define IMAGE_REL_BASED_REL                   7
#define IMAGE_REL_BASED_ARM_MOV32T            7
#define IMAGE_REL_BASED_THUMB_MOV32           7
#define IMAGE_REL_BASED_MIPS_JMPADDR16        9
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10
#define IMAGE_REL_BASED_HIGH3ADJ              11

#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040
#define IMAGE_FILE_DLL                        0x2000

#ifndef OS_WINDOWS
#define IMAGE_FILE_MACHINE_UNKNOWN     0
#define IMAGE_FILE_MACHINE_TARGET_HOST 0x0001 // Useful for indicating we want to interact with the host and not a WoW guest.
#define IMAGE_FILE_MACHINE_I386        0x014c // Intel 386.
#define IMAGE_FILE_MACHINE_R3000       0x0162 // MIPS little-endian, 0x160 big-endian
#define IMAGE_FILE_MACHINE_R4000       0x0166 // MIPS little-endian
#define IMAGE_FILE_MACHINE_R10000      0x0168 // MIPS little-endian
#define IMAGE_FILE_MACHINE_WCEMIPSV2   0x0169 // MIPS little-endian WCE v2
#define IMAGE_FILE_MACHINE_ALPHA       0x0184 // Alpha_AXP
#define IMAGE_FILE_MACHINE_SH3         0x01a2 // SH3 little-endian
#define IMAGE_FILE_MACHINE_SH3DSP      0x01a3
#define IMAGE_FILE_MACHINE_SH3E        0x01a4 // SH3E little-endian
#define IMAGE_FILE_MACHINE_SH4         0x01a6 // SH4 little-endian
#define IMAGE_FILE_MACHINE_SH5         0x01a8 // SH5
#define IMAGE_FILE_MACHINE_ARM         0x01c0 // ARM Little-Endian
#define IMAGE_FILE_MACHINE_THUMB       0x01c2 // ARM Thumb/Thumb-2 Little-Endian
#define IMAGE_FILE_MACHINE_ARMNT       0x01c4 // ARM Thumb-2 Little-Endian
#define IMAGE_FILE_MACHINE_AM33        0x01d3
#define IMAGE_FILE_MACHINE_POWERPC     0x01F0 // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_POWERPCFP   0x01f1
#define IMAGE_FILE_MACHINE_IA64        0x0200 // Intel 64
#define IMAGE_FILE_MACHINE_MIPS16      0x0266 // MIPS
#define IMAGE_FILE_MACHINE_ALPHA64     0x0284 // ALPHA64
#define IMAGE_FILE_MACHINE_MIPSFPU     0x0366 // MIPS
#define IMAGE_FILE_MACHINE_MIPSFPU16   0x0466 // MIPS
#define IMAGE_FILE_MACHINE_AXP64       IMAGE_FILE_MACHINE_ALPHA64
#define IMAGE_FILE_MACHINE_TRICORE     0x0520 // Infineon
#define IMAGE_FILE_MACHINE_CEF         0x0CEF
#define IMAGE_FILE_MACHINE_EBC         0x0EBC // EFI Byte Code
#define IMAGE_FILE_MACHINE_AMD64       0x8664 // AMD64 (K8)
#define IMAGE_FILE_MACHINE_M32R        0x9041 // M32R little-endian
#define IMAGE_FILE_MACHINE_ARM64       0xAA64 // ARM64 Little-Endian
#define IMAGE_FILE_MACHINE_CEE         0xC0EE
#endif

#define PROCESSOR_ARCHITECTURE_INTEL 0
#define PROCESSOR_ARCHITECTURE_AMD64 9

enum class PEMachineType : std::uint16_t
{
    UNKNOWN = 0,
    I386 = 0x014c,      // Intel 386.
    R3000 = 0x0162,     // MIPS little-endian, 0x160 big-endian
    R4000 = 0x0166,     // MIPS little-endian
    R10000 = 0x0168,    // MIPS little-endian
    WCEMIPSV2 = 0x0169, // MIPS little-endian WCE v2
    ALPHA = 0x0184,     // Alpha_AXP
    SH3 = 0x01a2,       // SH3 little-endian
    SH3DSP = 0x01a3,
    SH3E = 0x01a4,  // SH3E little-endian
    SH4 = 0x01a6,   // SH4 little-endian
    SH5 = 0x01a8,   // SH5
    ARM = 0x01c0,   // ARM Little-Endian
    THUMB = 0x01c2, // ARM Thumb/Thumb-2 Little-Endian
    ARMNT = 0x01c4, // ARM Thumb-2 Little-Endian
    AM33 = 0x01d3,
    POWERPC = 0x01F0, // IBM PowerPC Little-Endian
    POWERPCFP = 0x01f1,
    IA64 = 0x0200,      // Intel 64
    MIPS16 = 0x0266,    // MIPS
    ALPHA64 = 0x0284,   // ALPHA64
    MIPSFPU = 0x0366,   // MIPS
    MIPSFPU16 = 0x0466, // MIPS
    AXP64 = ALPHA64,
    TRICORE = 0x0520, // Infineon
    CEF = 0x0CEF,
    EBC = 0x0EBC,   // EFI Byte Code
    AMD64 = 0x8664, // AMD64 (K8)
    M32R = 0x9041,  // M32R little-endian
    CEE = 0xC0EE,
};

#pragma pack(push, 4)

template <typename T>
struct PEOptionalHeaderBasePart2_t
{
};

template <>
struct PEOptionalHeaderBasePart2_t<std::uint32_t>
{
    std::uint32_t BaseOfData;
    std::uint32_t ImageBase;
};

template <>
struct PEOptionalHeaderBasePart2_t<std::uint64_t>
{
    std::uint64_t ImageBase;
};

template <typename T>
struct PEOptionalHeaderBasePart1_t
{
    enum
    {
        k_NumberOfDataDirectors = 16
    };

    uint16_t Magic;
    uint8_t MajorLinkerVersion;
    uint8_t MinorLinkerVersion;
    uint32_t SizeOfCode;
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint;
    uint32_t BaseOfCode;
};

struct PEDirectory_t2
{
    std::uint32_t VirtualAddress;
    std::uint32_t Size;
};

template <typename T>
struct PEOptionalHeaderBasePart3_t : PEOptionalHeaderBasePart1_t<T>, PEOptionalHeaderBasePart2_t<T>
{
    uint32_t SectionAlignment;
    uint32_t FileAlignment;
    uint16_t MajorOperatingSystemVersion;
    uint16_t MinorOperatingSystemVersion;
    uint16_t MajorImageVersion;
    uint16_t MinorImageVersion;
    uint16_t MajorSubsystemVersion;
    uint16_t MinorSubsystemVersion;
    uint32_t Win32VersionValue;
    uint32_t SizeOfImage;
    uint32_t SizeOfHeaders;
    uint32_t CheckSum;
    uint16_t Subsystem;
    uint16_t DllCharacteristics;
    T SizeOfStackReserve;
    T SizeOfStackCommit;
    T SizeOfHeapReserve;
    T SizeOfHeapCommit;
    uint32_t LoaderFlags;
    uint32_t NumberOfRvaAndSizes;
    PEDirectory_t2 DataDirectory[PEOptionalHeaderBasePart1_t<T>::k_NumberOfDataDirectors];
};

template <typename T>
struct PEOptionalHeader_t
{
};

template <>
struct PEOptionalHeader_t<std::uint32_t> : PEOptionalHeaderBasePart3_t<std::uint32_t>
{
    enum
    {
        k_Magic = 0x10b, // IMAGE_NT_OPTIONAL_HDR32_MAGIC
    };
};

template <>
struct PEOptionalHeader_t<std::uint64_t> : PEOptionalHeaderBasePart3_t<std::uint64_t>
{
    enum
    {
        k_Magic = 0x20b, // IMAGE_NT_OPTIONAL_HDR64_MAGIC
    };
};

struct PEFileHeader_t
{
    PEMachineType Machine;
    std::uint16_t NumberOfSections;
    std::uint32_t TimeDateStamp;
    std::uint32_t PointerToSymbolTable;
    std::uint32_t NumberOfSymbols;
    std::uint16_t SizeOfOptionalHeader;
    std::uint16_t Characteristics;
};

template <typename T>
struct PENTHeaders_t
{
    enum
    {
        k_Signature = 0x00004550, // IMAGE_NT_SIGNATURE
    };

    uint32_t Signature;
    PEFileHeader_t FileHeader;
    PEOptionalHeader_t<T> OptionalHeader;
};

struct PEDosHeader_t
{
    enum
    {
        k_Magic = 0x5A4D
    };

    std::uint16_t e_magic;    // Magic number ( k_Magic )
    std::uint16_t e_cblp;     // Bytes on last page of file
    std::uint16_t e_cp;       // Pages in file
    std::uint16_t e_crlc;     // Relocations
    std::uint16_t e_cparhdr;  // Size of header in paragraphs
    std::uint16_t e_minalloc; // Minimum extra paragraphs needed
    std::uint16_t e_maxalloc; // Maximum extra paragraphs needed
    std::uint16_t e_ss;       // Initial (relative) SS value
    std::uint16_t e_sp;       // Initial SP value
    std::uint16_t e_csum;     // Checksum
    std::uint16_t e_ip;       // Initial IP value
    std::uint16_t e_cs;       // Initial (relative) CS value
    std::uint16_t e_lfarlc;   // File address of relocation table
    std::uint16_t e_ovno;     // Overlay number
    std::uint16_t e_res[4];   // Reserved words
    std::uint16_t e_oemid;    // OEM identifier (for e_oeminfo)
    std::uint16_t e_oeminfo;  // OEM information; e_oemid specific
    std::uint16_t e_res2[10]; // Reserved words
    std::uint32_t e_lfanew;   // File address of new exe header
};

#pragma pack(pop)

#define IMAGE_SIZEOF_SHORT_NAME 8

#ifndef OS_WINDOWS
typedef struct _IMAGE_SECTION_HEADER
{
    std::uint8_t Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        std::uint32_t PhysicalAddress;
        std::uint32_t VirtualSize;
    } Misc;
    std::uint32_t VirtualAddress;
    std::uint32_t SizeOfRawData;
    std::uint32_t PointerToRawData;
    std::uint32_t PointerToRelocations;
    std::uint32_t PointerToLinenumbers;
    std::uint16_t NumberOfRelocations;
    std::uint16_t NumberOfLinenumbers;
    std::uint32_t Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_EXPORT_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_BASE_RELOCATION
{
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
    // WORD TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_ORDINAL_FLAG64             0x8000000000000000
#define IMAGE_ORDINAL_FLAG32             0x80000000
#define IMAGE_ORDINAL64(Ordinal)         (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal)         (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

typedef struct _IMAGE_IMPORT_BY_NAME
{
    WORD Hint;
    CHAR Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
    // union
    //{
    //     DWORD Characteristics;    // 0 for terminating null import descriptor
    DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    //} DUMMYUNIONNAME;
    DWORD TimeDateStamp; // 0 if not bound,
                         // -1 if bound, and real date\time stamp
                         //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                         // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD ForwarderChain; // -1 if no forwarders
    DWORD Name;
    DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_THUNK_DATA64
{
    union
    {
        ULONGLONG ForwarderString; // PBYTE
        ULONGLONG Function;        // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;

typedef struct _IMAGE_THUNK_DATA32
{
    union
    {
        DWORD ForwarderString; // PBYTE
        DWORD Function;        // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;

#endif

// Template type definitions for architecture-specific thunk data
template <typename T>
struct thunk_data_traits;

template <>
struct thunk_data_traits<std::uint32_t>
{
    using type = IMAGE_THUNK_DATA32;
    static constexpr DWORD ordinal_flag = IMAGE_ORDINAL_FLAG32;

    static constexpr WORD ordinal_mask(DWORD ordinal)
    {
        return IMAGE_ORDINAL32(ordinal);
    }
    static constexpr bool snap_by_ordinal(DWORD ordinal)
    {
        return IMAGE_SNAP_BY_ORDINAL32(ordinal);
    }
};

template <>
struct thunk_data_traits<std::uint64_t>
{
    using type = IMAGE_THUNK_DATA64;
    static constexpr ULONGLONG ordinal_flag = IMAGE_ORDINAL_FLAG64;

    static constexpr WORD ordinal_mask(ULONGLONG ordinal)
    {
        return IMAGE_ORDINAL64(ordinal);
    }
    static constexpr bool snap_by_ordinal(ULONGLONG ordinal)
    {
        return IMAGE_SNAP_BY_ORDINAL64(ordinal);
    }
};

template <typename Traits>
struct SECTION_BASIC_INFORMATION
{
    typename Traits::PVOID BaseAddress;
    ULONG Attributes;
    LARGE_INTEGER Size;
};

template <typename Traits>
struct SECTION_IMAGE_INFORMATION
{
    typename Traits::PVOID TransferAddress;
    ULONG ZeroBits;
    typename Traits::SIZE_T MaximumStackSize;
    typename Traits::SIZE_T CommittedStackSize;
    ULONG SubSystemType;

    union
    {
        struct
        {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };

        ULONG SubSystemVersion;
    };

    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };

        ULONG OperatingSystemVersion;
    };

    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    PEMachineType Machine;
    BOOLEAN ImageContainsCode;

    union
    {
        UCHAR ImageFlags;

        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };

    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
};

namespace winpe
{
    struct pe_image_basic_info
    {
        uint64_t entry_point_rva{};
        uint64_t image_base{};
        uint64_t size_of_stack_reserve{};
        uint64_t size_of_stack_commit{};
        uint32_t size_of_code{};
        uint32_t loader_flags{};
        uint32_t checksum{};
        uint16_t machine{};
        uint16_t subsystem{};
        uint16_t subsystem_major_version{};
        uint16_t subsystem_minor_version{};
        uint16_t image_characteristics{};
        uint16_t dll_characteristics{};
        bool has_code{false};
        std::array<char, 7> _padding{};
    };

    enum class pe_arch
    {
        pe32,
        pe64
    };

    template <typename T>
    inline uint64_t get_first_section_offset(const PENTHeaders_t<T>& nt_headers, const uint64_t nt_headers_offset)
    {
        const auto* nt_headers_addr = reinterpret_cast<const uint8_t*>(&nt_headers);
        const size_t optional_header_offset =
            reinterpret_cast<uintptr_t>(&(nt_headers.OptionalHeader)) - reinterpret_cast<uintptr_t>(&nt_headers);
        const size_t optional_header_size = nt_headers.FileHeader.SizeOfOptionalHeader;
        const auto* first_section_addr = nt_headers_addr + optional_header_offset + optional_header_size;

        const auto first_section_absolute = reinterpret_cast<uint64_t>(first_section_addr);
        const auto absolute_base = reinterpret_cast<uint64_t>(&nt_headers);
        return nt_headers_offset + (first_section_absolute - absolute_base);
    }

    template <typename T>
    inline PEDirectory_t2 get_data_directory_by_index(const PENTHeaders_t<T>& nt_headers, uint64_t directory_index)
    {
        return nt_headers.OptionalHeader.DataDirectory[directory_index];
    }

    template <typename T>
    IMAGE_SECTION_HEADER get_section_header_by_rva(const utils::safe_buffer_accessor<const std::byte>& buffer,
                                                   const PENTHeaders_t<T>& nt_headers, uint64_t nt_headers_offset, uint64_t rva)
    {
        IMAGE_SECTION_HEADER section_header = {};

        auto next_section_offset = winpe::get_first_section_offset(nt_headers, nt_headers_offset);
        for (size_t i = 0; i < nt_headers.FileHeader.NumberOfSections; i++)
        {
            const auto section = buffer.as<IMAGE_SECTION_HEADER>(static_cast<size_t>(next_section_offset)).get();
            auto section_va_start = section.VirtualAddress;
            auto section_va_end = section.VirtualAddress + section.Misc.VirtualSize;

            if (section_va_start <= rva && rva <= section_va_end)
            {
                section_header = section;
                break;
            }

            next_section_offset += sizeof(IMAGE_SECTION_HEADER);
        }

        return section_header;
    }

    inline std::variant<pe_arch, std::error_code> get_pe_arch(const std::filesystem::path& file)
    {
        std::ifstream f(file, std::ios::binary);
        if (!f)
        {
            return std::make_error_code(std::errc::no_such_file_or_directory);
        }

        PEDosHeader_t dos{};
        f.read(reinterpret_cast<char*>(&dos), sizeof(dos));
        if (!f || dos.e_magic != PEDosHeader_t::k_Magic)
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        f.seekg(dos.e_lfanew, std::ios::beg);
        uint32_t nt_signature = 0;
        f.read(reinterpret_cast<char*>(&nt_signature), sizeof(nt_signature));
        if (!f || nt_signature != PENTHeaders_t<std::uint32_t>::k_Signature)
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        PEFileHeader_t file_header{};
        f.read(reinterpret_cast<char*>(&file_header), sizeof(file_header));
        if (!f)
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        uint16_t magic = 0;
        f.read(reinterpret_cast<char*>(&magic), sizeof(magic));
        if (!f)
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        if (magic == PEOptionalHeader_t<std::uint32_t>::k_Magic)
        {
            return pe_arch::pe32;
        }
        if (magic == PEOptionalHeader_t<std::uint64_t>::k_Magic)
        {
            return pe_arch::pe64;
        }

        return std::make_error_code(std::errc::executable_format_error);
    }

    inline std::variant<pe_arch, std::error_code> get_pe_arch(uint64_t base_address, uint64_t image_size)
    {
        const auto* base = reinterpret_cast<const std::byte*>(reinterpret_cast<const void*>(static_cast<uintptr_t>(base_address)));
        const uint64_t size = image_size;

        auto read = [&](uint64_t off, void* dst, size_t n) -> bool {
            if (off > size)
            {
                return false;
            }
            if (n > size - off)
            {
                return false;
            }
            memcpy(dst, base + off, n);
            return true;
        };

        PEDosHeader_t dos{};
        if (!read(0, &dos, sizeof(dos)) || dos.e_magic != PEDosHeader_t::k_Magic)
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        const auto nt_off = static_cast<uint64_t>(dos.e_lfanew);
        uint32_t nt_signature = 0;
        if (!read(nt_off, &nt_signature, sizeof(nt_signature)) || nt_signature != PENTHeaders_t<std::uint32_t>::k_Signature)
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        PEFileHeader_t file_header{};
        const uint64_t fh_off = nt_off + sizeof(nt_signature);
        if (!read(fh_off, &file_header, sizeof(file_header)))
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        uint16_t magic = 0;
        const uint64_t opt_magic_off = fh_off + sizeof(file_header);
        if (!read(opt_magic_off, &magic, sizeof(magic)))
        {
            return std::make_error_code(std::errc::executable_format_error);
        }

        if (magic == PEOptionalHeader_t<std::uint32_t>::k_Magic)
        {
            return pe_arch::pe32;
        }
        if (magic == PEOptionalHeader_t<std::uint64_t>::k_Magic)
        {
            return pe_arch::pe64;
        }

        return std::make_error_code(std::errc::executable_format_error);
    }

    template <typename T>
    inline bool parse_pe_headers(const std::vector<std::byte>& file_data, pe_image_basic_info& info)
    {
        if (file_data.size() < sizeof(PEDosHeader_t))
        {
            return false;
        }

        const auto* dos_header = reinterpret_cast<const PEDosHeader_t*>(file_data.data());
        if (dos_header->e_magic != PEDosHeader_t::k_Magic)
        {
            return false;
        }

        if (file_data.size() < dos_header->e_lfanew + sizeof(uint32_t) + sizeof(PEFileHeader_t) + sizeof(uint16_t))
        {
            return false;
        }

        const auto* magic_ptr =
            reinterpret_cast<const uint16_t*>(file_data.data() + dos_header->e_lfanew + sizeof(uint32_t) + sizeof(PEFileHeader_t));
        const uint16_t magic = *magic_ptr;

        constexpr uint16_t expected_magic = (sizeof(T) == sizeof(uint32_t))
                                                ? static_cast<uint16_t>(PEOptionalHeader_t<std::uint32_t>::k_Magic)
                                                : static_cast<uint16_t>(PEOptionalHeader_t<std::uint64_t>::k_Magic);

        if (magic != expected_magic)
        {
            return false;
        }

        if (file_data.size() < dos_header->e_lfanew + sizeof(PENTHeaders_t<T>))
        {
            return false;
        }

        const auto* nt_headers = reinterpret_cast<const PENTHeaders_t<T>*>(file_data.data() + dos_header->e_lfanew);
        if (nt_headers->Signature != PENTHeaders_t<T>::k_Signature)
        {
            return false;
        }

        const auto& file_header = nt_headers->FileHeader;
        const auto& optional_header = nt_headers->OptionalHeader;

        info.machine = static_cast<uint16_t>(file_header.Machine);
        info.image_characteristics = file_header.Characteristics;

        info.entry_point_rva = optional_header.AddressOfEntryPoint;
        info.image_base = optional_header.ImageBase;
        info.subsystem = optional_header.Subsystem;
        info.subsystem_major_version = optional_header.MajorSubsystemVersion;
        info.subsystem_minor_version = optional_header.MinorSubsystemVersion;
        info.dll_characteristics = optional_header.DllCharacteristics;
        info.size_of_stack_reserve = optional_header.SizeOfStackReserve;
        info.size_of_stack_commit = optional_header.SizeOfStackCommit;
        info.size_of_code = optional_header.SizeOfCode;
        info.loader_flags = optional_header.LoaderFlags;
        info.checksum = optional_header.CheckSum;

        info.has_code = (optional_header.SizeOfCode > 0) || (optional_header.AddressOfEntryPoint != 0);

        const auto sections_offset = dos_header->e_lfanew + sizeof(uint32_t) + sizeof(PEFileHeader_t) + file_header.SizeOfOptionalHeader;
        if (file_data.size() >= sections_offset + sizeof(IMAGE_SECTION_HEADER) * file_header.NumberOfSections)
        {
            const auto* sections = reinterpret_cast<const IMAGE_SECTION_HEADER*>(file_data.data() + sections_offset);
            for (uint16_t i = 0; i < file_header.NumberOfSections; ++i)
            {
                if (sections[i].Characteristics & IMAGE_SCN_CNT_CODE)
                {
                    info.has_code = true;
                    break;
                }
            }
        }

        return true;
    }
}

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/platform/window.hpp`:

```hpp
#pragma once

#include "kernel_mapped.hpp"

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

using pointer = uint64_t;

#ifndef OS_WINDOWS
typedef struct tagPOINT
{
    LONG x;
    LONG y;
} POINT;
#endif

using wparam = pointer;
using lparam = pointer;
using lresult = pointer;

typedef struct _LARGE_STRING
{
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    pointer Buffer;
} LARGE_STRING;

using hdc = pointer;
using hwnd = pointer;
using hdesk = pointer;
using hmenu = pointer;
using hinstance = pointer;
using hicon = pointer;
using hcursor = pointer;
using hbrush = pointer;

struct msg
{
    hwnd window;
    UINT message;
    wparam wParam;
    lparam lParam;
    DWORD time;
    POINT pt;
#ifdef _MAC
    DWORD lPrivate;
#endif
};

struct qmsg
{
    UINT message;
    wparam wParam;
    lparam lParam;
};

struct EMU_WNDCLASSEX
{
    uint32_t cbSize;
    uint32_t style;
    pointer lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    hinstance hInstance;
    hicon hIcon;
    hcursor hCursor;
    hbrush hbrBackground;
    pointer lpszMenuName;
    pointer lpszClassName;
    hicon hIconSm;
};

struct EMU_MINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
};

struct EMU_WINDOWPOS
{
    pointer hwnd;
    pointer hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    uint32_t flags;
};

struct EMU_CREATESTRUCT
{
    pointer lpCreateParams;
    hinstance hInstance;
    hmenu hMenu;
    hwnd hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    pointer lpszName;
    pointer lpszClass;
    DWORD dwExStyle;
};

#ifndef OS_WINDOWS
#define WS_VISIBLE           0x10000000L

#define SWP_SHOWWINDOW       0x0040
#define SWP_HIDEWINDOW       0x0080

#define WM_CREATE            0x0001
#define WM_DESTROY           0x0002
#define WM_MOVE              0x0003
#define WM_SIZE              0x0005
#define WM_ACTIVATE          0x0006
#define WM_SETFOCUS          0x0007
#define WM_KILLFOCUS         0x0008
#define WM_QUIT              0x0012
#define WM_SHOWWINDOW        0x0018
#define WM_GETMINMAXINFO     0x0024
#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED  0x0047
#define WM_NCCREATE          0x0081
#define WM_NCDESTROY         0x0082
#define WM_NCCALCSIZE        0x0083
#define WM_NCACTIVATE        0x0086

#define PM_NOREMOVE          0x0000
#define PM_REMOVE            0x0001
#define PM_NOYIELD           0x0002

#define GWLP_WNDPROC         (-4)
#define GWLP_HINSTANCE       (-6)
#define GWLP_HWNDPARENT      (-8)
#define GWLP_USERDATA        (-21)
#define GWLP_ID              (-12)
#endif

#define WM_UAHDESTROYWINDOW 0x0090

struct EMU_DISPLAY_DEVICEW
{
    DWORD cb;
    char16_t DeviceName[32];
    char16_t DeviceString[128];
    DWORD StateFlags;
    char16_t DeviceID[128];
    char16_t DeviceKey[128];
};

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS ((DWORD) - 1)
#endif

struct EMU_DEVMODEW
{
    char16_t dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union
    {
        struct
        {
            int16_t dmOrientation;
            int16_t dmPaperSize;
            int16_t dmPaperLength;
            int16_t dmPaperWidth;
            int16_t dmScale;
            int16_t dmCopies;
            int16_t dmDefaultSource;
            int16_t dmPrintQuality;
        } s;
        POINT dmPosition;
        struct
        {
            POINT dmPosition;
            DWORD dmDisplayOrientation;
            DWORD dmDisplayFixedOutput;
        } s2;
    } u;
    int16_t dmColor;
    int16_t dmDuplex;
    int16_t dmYResolution;
    int16_t dmTTOption;
    int16_t dmCollate;
    char16_t dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union
    {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    } u2;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
};

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/common/segment_utils.hpp`:

```hpp
#pragma once

#include <optional>
#include <cstdint>

#include "emulator.hpp"
#include "x86_register.hpp"

namespace segment_utils
{
    enum class segment_bitness
    {
        bit16 = 16,
        bit32 = 32,
        bit64 = 64,
    };

#pragma pack(push, 1)
    struct raw_segment_descriptor
    {
        uint16_t limit_low;
        uint16_t base_low;
        uint8_t base_mid;
        uint8_t access;
        uint8_t limit_high_flags;
        uint8_t base_high;
    };
#pragma pack(pop)

    struct descriptor
    {
        uint64_t base{};
        uint32_t limit{};
        bool present{};
        bool system{};
        uint8_t type{};
        bool long_mode{};
        bool default_op_size{};
    };

    inline std::optional<cpu_interface::descriptor_table_register> read_descriptor_table(emulator& cpu, const x86_register reg)
    {
        cpu_interface::descriptor_table_register table{};
        if (!cpu.read_descriptor_table(static_cast<int>(reg), table))
        {
            return std::nullopt;
        }

        return table;
    }

    inline std::optional<uint16_t> read_selector(emulator& cpu, const x86_register reg)
    {
        uint16_t selector{};
        const auto bytes_read = cpu.read_raw_register(static_cast<int>(reg), &selector, sizeof(selector));
        if (bytes_read < sizeof(selector))
        {
            return std::nullopt;
        }

        return selector;
    }

    inline std::optional<descriptor> read_descriptor(emulator& cpu, const cpu_interface::descriptor_table_register& table,
                                                     const uint16_t selector)
    {
        const auto index = selector >> 3;
        const auto byte_offset = static_cast<uint64_t>(index) * sizeof(raw_segment_descriptor);
        const auto table_size = static_cast<uint64_t>(table.limit) + 1;
        if (byte_offset + sizeof(raw_segment_descriptor) > table_size)
        {
            return std::nullopt;
        }

        raw_segment_descriptor raw{};
        cpu.read_memory(table.base + byte_offset, &raw, sizeof(raw));

        descriptor desc{};
        uint64_t base = raw.base_low;
        base |= static_cast<uint64_t>(raw.base_mid) << 16;
        base |= static_cast<uint64_t>(raw.base_high) << 24;
        desc.base = base;

        const auto limit_high = static_cast<uint32_t>(raw.limit_high_flags & 0x0F);
        uint32_t limit = raw.limit_low | (limit_high << 16);
        const bool granularity = (raw.limit_high_flags & 0x80) != 0;
        if (granularity)
        {
            limit = (limit << 12) | 0xFFF;
        }
        desc.limit = limit;

        desc.present = (raw.access & 0x80) != 0;
        desc.system = (raw.access & 0x10) == 0;
        desc.type = static_cast<uint8_t>(raw.access & 0x0F);
        desc.long_mode = (raw.limit_high_flags & 0x20) != 0;
        desc.default_op_size = (raw.limit_high_flags & 0x40) != 0;

        if (desc.system)
        {
            const bool needs_high_base = desc.type == 0x2 || desc.type == 0x9 || desc.type == 0xB;
            if (needs_high_base)
            {
                if (byte_offset + (2 * sizeof(raw_segment_descriptor)) > table_size)
                {
                    return std::nullopt;
                }

                uint32_t base_high{};
                cpu.read_memory(table.base + byte_offset + sizeof(raw_segment_descriptor), &base_high, sizeof(base_high));
                desc.base |= static_cast<uint64_t>(base_high) << 32;
            }
        }

        return desc;
    }

    inline std::optional<cpu_interface::descriptor_table_register> resolve_table(emulator& cpu, const uint16_t selector)
    {
        auto gdt = read_descriptor_table(cpu, x86_register::gdtr);
        if (!gdt)
        {
            return std::nullopt;
        }

        const bool table_indicator = (selector & 0x4) != 0;
        if (!table_indicator)
        {
            return gdt;
        }

        auto ldtr_selector = read_selector(cpu, x86_register::ldtr);
        if (!ldtr_selector || ((*ldtr_selector) & ~0x3u) == 0)
        {
            return std::nullopt;
        }

        auto ldt_descriptor = read_descriptor(cpu, *gdt, *ldtr_selector);
        if (!ldt_descriptor || !ldt_descriptor->present || !ldt_descriptor->system || ldt_descriptor->type != 0x2)
        {
            return std::nullopt;
        }

        cpu_interface::descriptor_table_register ldt{};
        ldt.base = ldt_descriptor->base;
        ldt.limit = ldt_descriptor->limit;
        return ldt;
    }

    inline std::optional<segment_bitness> get_segment_bitness(emulator& cpu, const uint16_t selector)
    {
        if ((selector & ~0x3u) == 0)
        {
            return std::nullopt;
        }

        auto table = resolve_table(cpu, selector);
        if (!table)
        {
            return std::nullopt;
        }

        auto desc = read_descriptor(cpu, *table, selector);
        if (!desc || !desc->present || desc->system || (desc->type & 0x8) == 0)
        {
            return std::nullopt;
        }

        if (desc->long_mode)
        {
            return segment_bitness::bit64;
        }

        if (desc->default_op_size)
        {
            return segment_bitness::bit32;
        }

        return segment_bitness::bit16;
    }
}

```

`src/common/utils/buffer_accessor.hpp`:

```hpp
#pragma once
#include <span>
#include <cstdint>
#include <stdexcept>

namespace utils
{
    template <typename Type, typename SpanElement = const std::byte>
        requires(std::is_trivially_copyable_v<Type> &&
                 (std::is_same_v<uint8_t, std::remove_cv_t<SpanElement>> || std::is_same_v<std::byte, std::remove_cv_t<SpanElement>>))
    class safe_object_accessor
    {
      public:
        safe_object_accessor(const std::span<SpanElement> buffer, const size_t offset)
            : buffer_(buffer),
              offset_(offset)
        {
        }

        /*****************************************************************************
         * Object is copied to make sure platform-dependent alignment requirements
         * are respected
         ****************************************************************************/

        Type get(const size_t element_index = 0) const
        {
            Type value{};
            memcpy(&value, get_valid_pointer(element_index), size);
            return value;
        }

        void set(const Type value, const size_t element_index = 0) const
        {
            memcpy(get_valid_pointer(element_index), &value, size);
        }

      private:
        static constexpr auto size = sizeof(Type);

        std::span<SpanElement> buffer_{};
        size_t offset_{};

        SpanElement* get_valid_pointer(const size_t element_index) const
        {
            const auto start_offset = offset_ + (size * element_index);
            const auto end_offset = start_offset + size;
            if (end_offset > buffer_.size())
            {
                throw std::runtime_error("Buffer accessor overflow");
            }

            return buffer_.data() + start_offset;
        }
    };

    template <typename SpanElement>
        requires(std::is_same_v<uint8_t, std::remove_cv_t<SpanElement>> || std::is_same_v<std::byte, std::remove_cv_t<SpanElement>>)
    class safe_buffer_accessor
    {
      public:
        safe_buffer_accessor(const std::span<SpanElement> buffer)
            : buffer_(buffer)
        {
        }

        template <typename OtherSpanElement>
            requires(std::is_same_v<std::remove_cv_t<SpanElement>, std::remove_cv_t<OtherSpanElement>>)
        safe_buffer_accessor(const safe_buffer_accessor<OtherSpanElement>& obj)
            : buffer_(obj.get_buffer())
        {
        }

        template <typename Type>
        safe_object_accessor<Type, SpanElement> as(const size_t offset) const
        {
            return {this->buffer_, offset};
        }

        SpanElement* get_pointer_for_range(const size_t offset, const size_t size) const
        {
            this->validate(offset, size);
            return this->buffer_.data() + offset;
        }

        void validate(const size_t offset, const size_t size) const
        {
            const auto end = offset + size;
            if (end > buffer_.size())
            {
                throw std::runtime_error("Buffer accessor overflow");
            }
        }

        template <typename Char = char>
        std::basic_string<Char> as_string(const size_t offset) const
        {
            safe_object_accessor<Char> string_accessor{this->buffer_, offset};
            std::basic_string<Char> result{};

            while (true)
            {
                auto value = string_accessor.get(result.size());
                if (!value)
                {
                    return result;
                }

                result.push_back(std::move(value));
            }
        }

        std::span<SpanElement> get_buffer() const
        {
            return this->buffer_;
        }

      private:
        const std::span<SpanElement> buffer_{};
    };
}

```

`src/common/utils/compression.cpp`:

```cpp
#include "compression.hpp"

#include <zstd.h>
#include <array>
#include <cstdint>
#include <cstring>

namespace utils::compression
{
    namespace zstd
    {
        std::vector<std::byte> decompress(const std::span<const std::byte> data)
        {
            const auto decompressed_size = ZSTD_getFrameContentSize(data.data(), data.size());

            if (decompressed_size == ZSTD_CONTENTSIZE_ERROR || decompressed_size == ZSTD_CONTENTSIZE_UNKNOWN)
            {
                return {};
            }

            std::vector<std::byte> buffer(static_cast<size_t>(decompressed_size));

            const auto result = ZSTD_decompress(buffer.data(), buffer.size(), data.data(), data.size());

            if (ZSTD_isError(result))
            {
                return {};
            }

            return buffer;
        }

        std::vector<std::byte> compress(const std::span<const std::byte> data, const int compression_level)
        {
            const auto max_size = ZSTD_compressBound(data.size());
            std::vector<std::byte> result(max_size);

            const auto compressed_size = ZSTD_compress(result.data(), max_size, data.data(), data.size(), compression_level);

            if (ZSTD_isError(compressed_size))
            {
                return {};
            }

            result.resize(compressed_size);
            return result;
        }
    }
}

```

`src/common/utils/compression.hpp`:

```hpp
#pragma once

#include <span>
#include <vector>

namespace utils::compression
{
    namespace zstd
    {
        std::vector<std::byte> compress(std::span<const std::byte> data, int compression_level = 8);
        std::vector<std::byte> decompress(std::span<const std::byte> data);
    }
}

```

`src/common/utils/concurrency.hpp`:

```hpp
#pragma once

#include <mutex>

namespace utils::concurrency
{
    template <typename T, typename MutexType = std::mutex>
    class container
    {
      public:
        template <typename R = void, typename F>
        R access(F&& accessor) const
        {
            std::lock_guard<MutexType> _{mutex_};
            return accessor(object_);
        }

        template <typename R = void, typename F>
        R access(F&& accessor)
        {
            std::lock_guard<MutexType> _{mutex_};
            return accessor(object_);
        }

        template <typename R = void, typename F>
        R access_with_lock(F&& accessor) const
        {
            std::unique_lock<MutexType> lock{mutex_};
            return accessor(object_, lock);
        }

        template <typename R = void, typename F>
        R access_with_lock(F&& accessor)
        {
            std::unique_lock<MutexType> lock{mutex_};
            return accessor(object_, lock);
        }

        T& get_raw()
        {
            return object_;
        }
        const T& get_raw() const
        {
            return object_;
        }

        T copy() const
        {
            std::unique_lock<MutexType> lock{mutex_};
            return object_;
        }

        std::unique_lock<MutexType> acquire_lock()
        {
            return std::unique_lock<MutexType>{mutex_};
        }

      private:
        mutable MutexType mutex_{};
        T object_{};
    };
}

```

`src/common/utils/container.hpp`:

```hpp
#pragma once

#include <string>
#include <string_view>
#include <unordered_set>
#include <unordered_map>
#include "string.hpp"

namespace utils
{
    template <typename Elem, typename Traits>
    struct basic_string_hash
    {
        using is_transparent = void;

        size_t operator()(const std::basic_string_view<Elem, Traits> str) const
        {
            constexpr std::hash<std::basic_string_view<Elem, Traits>> hasher{};
            return hasher(str);
        }
    };

    template <typename Elem, typename Traits>
    struct basic_insensitive_string_hash
    {
        using is_transparent = void;

        size_t operator()(const std::basic_string_view<Elem, Traits> str) const
        {
            size_t hash = 0;
            constexpr std::hash<int> hasher{};
            for (const auto c : str)
            {
                hash ^= hasher(string::char_to_lower(c)) + 0x9e3779b9 + (hash << 6) + (hash >> 2);
            }
            return hash;
        }
    };

    template <typename Elem, typename Traits>
    struct basic_insensitive_string_equal
    {
        using is_transparent = void;

        bool operator()(const std::basic_string_view<Elem, Traits> lhs, const std::basic_string_view<Elem, Traits> rhs) const
        {
            return string::equals_ignore_case(lhs, rhs);
        }
    };

    template <typename Elem, typename Traits>
    struct basic_insensitive_string_less
    {
        using is_transparent = void;

        bool operator()(std::basic_string_view<Elem, Traits> lhs, std::basic_string_view<Elem, Traits> rhs) const
        {
            return string::compare_ignore_case(lhs, rhs) < 0;
        }
    };

    using string_hash = basic_string_hash<char, std::char_traits<char>>;
    using u16string_hash = basic_string_hash<char16_t, std::char_traits<char16_t>>;

    using insensitive_string_hash = basic_insensitive_string_hash<char, std::char_traits<char>>;
    using insensitive_u16string_hash = basic_insensitive_string_hash<char16_t, std::char_traits<char16_t>>;

    using insensitive_string_equal = basic_insensitive_string_equal<char, std::char_traits<char>>;
    using insensitive_u16string_equal = basic_insensitive_string_equal<char16_t, std::char_traits<char16_t>>;

    using insensitive_string_less = basic_insensitive_string_less<char, std::char_traits<char>>;
    using insensitive_u16string_less = basic_insensitive_string_less<char16_t, std::char_traits<char16_t>>;

    template <typename T>
    using unordered_string_map = std::unordered_map<std::string, T, string_hash, std::equal_to<>>;
    template <typename T>
    using unordered_u16string_map = std::unordered_map<std::u16string, T, u16string_hash, std::equal_to<>>;

    template <typename T>
    using unordered_insensitive_string_map = std::unordered_map<std::string, T, insensitive_string_hash, insensitive_string_equal>;
    template <typename T>
    using unordered_insensitive_u16string_map =
        std::unordered_map<std::u16string, T, insensitive_u16string_hash, insensitive_u16string_equal>;

    template <typename T>
    using insensitive_string_map = std::map<std::string, T, insensitive_string_less>;
    template <typename T>
    using insensitive_u16string_map = std::map<std::u16string, T, insensitive_u16string_less>;

    using unordered_string_set = std::unordered_set<std::string, string_hash, std::equal_to<>>;
    using unordered_u16string_set = std::unordered_set<std::u16string, u16string_hash, std::equal_to<>>;
}

```

`src/common/utils/file_handle.hpp`:

```hpp
#pragma once

#include <cstdio>
#include <type_traits>

#if defined(OS_WINDOWS) && !defined(__MINGW64__)
#include <corecrt_io.h>
#else
#include <unistd.h>
#endif

namespace utils
{
    class file_handle
    {
      public:
        struct rename_information
        {
            std::filesystem::path old_filepath;
            std::filesystem::path new_filepath;

            void serialize(utils::buffer_serializer& buffer) const
            {
                buffer.write(this->old_filepath.u16string());
                buffer.write(this->new_filepath.u16string());
            }

            void deserialize(utils::buffer_deserializer& buffer)
            {
                this->old_filepath = buffer.read<std::u16string>();
                this->new_filepath = buffer.read<std::u16string>();
            }
        };

        struct delete_information
        {
            std::filesystem::path filepath;

            void serialize(utils::buffer_serializer& buffer) const
            {
                buffer.write(this->filepath.u16string());
            }

            void deserialize(utils::buffer_deserializer& buffer)
            {
                this->filepath = buffer.read<std::u16string>();
            }
        };

        file_handle() = default;

        file_handle(FILE* file)
            : file_(file)
        {
        }

        ~file_handle()
        {
            this->release();
        }

        file_handle(const file_handle&) = delete;
        file_handle& operator=(const file_handle&) = delete;

        file_handle(file_handle&& obj) noexcept
            : file_handle()
        {
            this->operator=(std::move(obj));
        }

        file_handle& operator=(file_handle&& obj) noexcept
        {
            if (this != &obj)
            {
                this->release();
                this->file_ = obj.file_;
                obj.file_ = {};
            }

            return *this;
        }

        file_handle& operator=(FILE* file) noexcept
        {
            this->release();
            this->file_ = file;

            return *this;
        }

        [[nodiscard]] explicit operator bool() const
        {
            return this->file_;
        }

        [[nodiscard]] operator FILE*() const
        {
            return this->file_;
        }

        [[nodiscard]] int file_descriptor() const
        {
            return fileno(this->file_);
        }

        [[nodiscard]] int64_t size() const
        {
            const auto current_position = this->tell();

            this->seek_to(0, SEEK_END);
            const auto size = this->tell();
            this->seek_to(current_position);

            return size;
        }

        bool seek_to(const int64_t position, const int origin = SEEK_SET) const
        {
            return _fseeki64(this->file_, position, origin) == 0;
        }

        [[nodiscard]] int64_t tell() const
        {
            return _ftelli64(this->file_);
        }

        bool resize(uint64_t size) const
        {
            const auto fd = this->file_descriptor();
            if (fd == -1)
            {
                return false;
            }

#ifdef OS_WINDOWS
            return _chsize_s(fd, static_cast<long long>(size)) == 0;
#else
            return ftruncate(fd, static_cast<off_t>(size)) == 0;
#endif
        }

        void defer_rename(std::filesystem::path oldname, std::filesystem::path newname)
        {
            deferred_rename_ = rename_information{.old_filepath = std::move(oldname), .new_filepath = std::move(newname)};
        }

        void defer_delete(std::filesystem::path name)
        {
            if (name == std::filesystem::path{})
            {
                deferred_delete_ = {};
                return;
            }

            deferred_delete_ = delete_information{.filepath = std::move(name)};
        }

        void serialize(utils::buffer_serializer& buffer) const
        {
            buffer.write(this->tell());
            buffer.write_optional(this->deferred_rename_);
            buffer.write_optional(this->deferred_delete_);
        }

        void deserialize(utils::buffer_deserializer& buffer)
        {
            int64_t position = 0;
            buffer.read(position);

            if (!this->seek_to(position))
            {
                throw std::runtime_error("Failed to seek to serialized file position");
            }

            buffer.read_optional(this->deferred_rename_);
            buffer.read_optional(this->deferred_delete_);
        }

      private:
        FILE* file_{};
        std::optional<rename_information> deferred_rename_;
        std::optional<delete_information> deferred_delete_;

        void release()
        {
            if (this->file_)
            {
                (void)fclose(this->file_);
                this->file_ = {};
            }

            if (this->deferred_rename_ && !this->deferred_delete_)
            {
                std::error_code ec{};
                std::filesystem::rename(this->deferred_rename_->old_filepath, this->deferred_rename_->new_filepath, ec);
                this->deferred_rename_ = {};
            }

            if (this->deferred_delete_)
            {
                std::error_code ec{};
                std::filesystem::remove(this->deferred_delete_->filepath, ec);
                this->deferred_delete_ = {};
            }
        }
    };
}

```

`src/common/utils/finally.hpp`:

```hpp
#pragma once
#include <utility>
#include <type_traits>

namespace utils
{
    /*
     * Copied from here:
     * https://github.com/microsoft/GSL/blob/e0880931ae5885eb988d1a8a57acf8bc2b8dacda/include/gsl/util#L57
     */

    template <class F>
    class final_action
    {
      public:
        static_assert(!std::is_reference_v<F> && !std::is_const_v<F> && !std::is_volatile_v<F>,
                      "Final_action should store its callable by value");

        explicit final_action(F f) noexcept
            : f_(std::move(f))
        {
        }

        final_action(final_action&& other) noexcept
            : f_(std::move(other.f_)),
              invoke_(std::exchange(other.invoke_, false))
        {
        }

        final_action(const final_action&) = delete;
        final_action& operator=(const final_action&) = delete;
        final_action& operator=(final_action&&) = delete;

        ~final_action() noexcept
        {
            if (this->invoke_)
            {
                this->f_();
            }
        }

        // Added by momo5502
        void cancel()
        {
            this->invoke_ = false;
        }

      private:
        F f_;
        bool invoke_{true};
    };

    template <class F>
    final_action<std::remove_cv_t<std::remove_reference_t<F>>> finally(F&& f) noexcept
    {
        return final_action<std::remove_cv_t<std::remove_reference_t<F>>>(std::forward<F>(f));
    }
}

```

`src/common/utils/function.hpp`:

```hpp
#pragma once

#include <functional>
#include <vector>
#include <algorithm>
#include <cstddef>

namespace utils
{
    template <typename Signature>
    class optional_function;

    template <typename Ret, typename... Args>
    class optional_function<Ret(Args...)>
    {
        std::function<Ret(Args...)> func;

      public:
        optional_function() = default;

        optional_function(std::function<Ret(Args...)> f)
            : func(std::move(f))
        {
        }

        template <typename F>
            requires(std::is_invocable_r_v<Ret, F, Args...>)
        optional_function(F&& f)
            : func(std::forward<F>(f))
        {
        }

        template <typename F>
            requires(std::is_invocable_r_v<Ret, F, Args...>)
        optional_function& operator=(F&& f)
        {
            func = std::forward<F>(f);
            return *this;
        }

        Ret operator()(Args... args) const
        {
            if (func)
            {
                return func(std::forward<Args>(args)...);
            }

            if constexpr (!std::is_void_v<Ret>)
            {
                return Ret();
            }
        }

        explicit operator bool() const noexcept
        {
            return static_cast<bool>(func);
        }
    };

    using callback_id_type = std::size_t;

    template <typename Signature>
    class callback_list;

    template <typename... Args>
    class callback_list<void(Args...)>
    {
      public:
        using function_type = std::function<void(Args...)>;

        callback_id_type add(function_type fn)
        {
            callbacks.emplace_back(next_id, std::move(fn));
            return next_id++;
        }

        void remove(callback_id_type id)
        {
            callbacks.erase(std::remove_if(callbacks.begin(), callbacks.end(), [id](auto& pair) { return pair.first == id; }),
                            callbacks.end());
        }

        void operator()(Args... args) const
        {
            for (auto& [id, fn] : callbacks)
            {
                fn(args...);
            }
        }

        explicit operator bool() const noexcept
        {
            return !callbacks.empty();
        }

      private:
        std::vector<std::pair<callback_id_type, function_type>> callbacks;
        callback_id_type next_id = 1;
    };
}

```

`src/common/utils/interupt_handler.cpp`:

```cpp
#include "interupt_handler.hpp"
#include <atomic>
#include <stdexcept>
#include <thread>

#include "win.hpp"

#ifndef _WIN32
#include <csignal>
#endif

namespace utils
{
    namespace
    {
        struct signal_data
        {
            std::atomic_bool installed{false};
            std::function<void()> handler{};
        };

        signal_data& get_signal_data()
        {
            static signal_data data{};
            return data;
        }

#ifdef _WIN32
        BOOL WINAPI handler(const DWORD signal)
        {
            const auto& data = get_signal_data();

            if (signal == CTRL_C_EVENT && data.handler)
            {
                data.handler();
            }

            return TRUE;
        }

#else
        void handler(int signal)
        {
            const auto& data = get_signal_data();

            if (signal == SIGINT && data.handler)
            {
                data.handler();
            }
        }
#endif
    }

    interupt_handler::interupt_handler(std::function<void()> callback)
    {
        auto& data = get_signal_data();

        bool value{false};
        if (!data.installed.compare_exchange_strong(value, true))
        {
            throw std::runtime_error("Global signal handler already installed");
        }

        data.handler = std::move(callback);

#ifdef _WIN32
        SetConsoleCtrlHandler(handler, TRUE);
#else
        signal(SIGINT, handler);
#endif
    }

    interupt_handler::~interupt_handler()
    {
#ifdef _WIN32
        SetConsoleCtrlHandler(handler, FALSE);
#else
        signal(SIGINT, SIG_DFL);
#endif

        std::this_thread::yield();

        auto& data = get_signal_data();

        data.handler = {};
        data.installed = false;
    }
}

```

`src/common/utils/interupt_handler.hpp`:

```hpp
#pragma once
#include <functional>

namespace utils
{
    struct interupt_handler
    {
        interupt_handler(std::function<void()> callback);
        ~interupt_handler();

        interupt_handler(interupt_handler&&) = delete;
        interupt_handler(const interupt_handler&) = delete;

        interupt_handler& operator=(interupt_handler&&) = delete;
        interupt_handler& operator=(const interupt_handler&) = delete;
    };
}

```

`src/common/utils/io.cpp`:

```cpp
#include "io.hpp"
#include <fstream>
#include <sstream>

namespace utils::io
{
    bool remove_file(const std::filesystem::path& file)
    {
        std::error_code ec{};
        return std::filesystem::remove(file, ec) && !ec;
    }

    bool move_file(const std::filesystem::path& src, const std::filesystem::path& target)
    {
        copy_folder(src, target);
        return remove_file(src);
    }

    bool file_exists(const std::filesystem::path& file)
    {
        return std::ifstream(file).good();
    }

    bool write_file(const std::filesystem::path& file, const std::span<const std::byte> data, const bool append)
    {
        if (file.has_parent_path())
        {
            io::create_directory(file.parent_path());
        }

        std::ofstream stream(file, std::ios::binary | std::ofstream::out | (append ? std::ofstream::app : std::ofstream::out));

        if (stream.is_open())
        {
            stream.write(reinterpret_cast<const char*>(data.data()), static_cast<std::streamsize>(data.size()));
            stream.close();
            return true;
        }

        return false;
    }

    std::vector<std::byte> read_file(const std::filesystem::path& file)
    {
        std::vector<std::byte> data{};
        read_file(file, &data);
        return data;
    }

    bool read_file(const std::filesystem::path& file, std::vector<std::byte>* data)
    {
        if (!data)
        {
            return false;
        }

        *data = {};

        std::ifstream file_stream(file, std::ios::binary);
        if (!file_stream)
        {
            return false;
        }

        std::vector<char> temp_buffer(0x1000);

        while (file_stream)
        {
            file_stream.read(temp_buffer.data(), static_cast<std::streamsize>(temp_buffer.size()));
            const auto bytes_read = file_stream.gcount();

            if (bytes_read > 0)
            {
                const auto* buffer = reinterpret_cast<const std::byte*>(temp_buffer.data());
                data->insert(data->end(), buffer, buffer + bytes_read);
            }
        }

        return true;
    }

    std::size_t file_size(const std::filesystem::path& file)
    {
        std::ifstream stream(file, std::ios::binary);

        if (stream)
        {
            stream.seekg(0, std::ios::end);
            return static_cast<std::size_t>(stream.tellg());
        }

        return 0;
    }

    bool create_directory(const std::filesystem::path& directory)
    {
        std::error_code ec{};
        return std::filesystem::create_directories(directory, ec) && !ec;
    }

    bool directory_exists(const std::filesystem::path& directory)
    {
        std::error_code ec{};
        return std::filesystem::is_directory(directory, ec) && !ec;
    }

    bool directory_is_empty(const std::filesystem::path& directory)
    {
        std::error_code ec{};
        return std::filesystem::is_empty(directory, ec) && !ec;
    }

    void copy_folder(const std::filesystem::path& src, const std::filesystem::path& target)
    {
        std::error_code ec{};
        std::filesystem::copy(src, target, std::filesystem::copy_options::overwrite_existing | std::filesystem::copy_options::recursive,
                              ec);
    }

    std::vector<std::filesystem::path> list_files(const std::filesystem::path& directory, const bool recursive)
    {
        std::error_code code{};
        std::vector<std::filesystem::path> files;

        if (recursive)
        {
            for (const auto& file : std::filesystem::recursive_directory_iterator(directory, code))
            {
                files.push_back(file.path());
            }
        }
        else
        {
            for (const auto& file : std::filesystem::directory_iterator(directory, code))
            {
                files.push_back(file.path());
            }
        }

        return files;
    }
}

```

`src/common/utils/io.hpp`:

```hpp
#pragma once

#include <span>
#include <vector>
#include <filesystem>

namespace utils::io
{
    bool remove_file(const std::filesystem::path& file);
    bool move_file(const std::filesystem::path& src, const std::filesystem::path& target);
    bool file_exists(const std::filesystem::path& file);
    bool write_file(const std::filesystem::path& file, std::span<const std::byte> data, bool append = false);
    bool read_file(const std::filesystem::path& file, std::vector<std::byte>* data);
    std::vector<std::byte> read_file(const std::filesystem::path& file);
    size_t file_size(const std::filesystem::path& file);
    bool create_directory(const std::filesystem::path& directory);
    bool directory_exists(const std::filesystem::path& directory);
    bool directory_is_empty(const std::filesystem::path& directory);
    void copy_folder(const std::filesystem::path& src, const std::filesystem::path& target);

    std::vector<std::filesystem::path> list_files(const std::filesystem::path& directory, bool recursive = false);
}

```

`src/common/utils/lazy_object.hpp`:

```hpp
#pragma once

#include <optional>
#include <type_traits>

namespace utils
{
    template <typename F, typename T>
    concept CallableWithReturn = requires(const F f) {
        { f() } -> std::same_as<T>;
    };

    template <typename T, typename F>
        requires(CallableWithReturn<F, T>)
    class lazy_object
    {
      public:
        lazy_object(F accessor)
            : accessor_(std::move(accessor))
        {
        }

        operator const T&() const
        {
            return this->get();
        }

        operator T&()
        {
            return this->get();
        }

        T& operator->()
            requires std::is_pointer_v<T>
        {
            return this->get();
        }

        const T& operator->() const
            requires std::is_pointer_v<T>
        {
            return this->get();
        }

      private:
        F accessor_{};
        mutable std::optional<T> object_{};

        T& get() const
        {
            this->ensure_construction();
            return *this->object_;
        }

        void ensure_construction() const
        {
            if (!this->object_.has_value())
            {
                this->object_.emplace(this->accessor_());
            }
        }
    };

    template <typename F>
    auto make_lazy(F accessor)
    {
        return lazy_object<std::invoke_result_t<F>, F>(std::move(accessor));
    }
}

```

`src/common/utils/moved_marker.hpp`:

```hpp
#pragma once
#include <type_traits>

namespace utils
{
    class moved_marker
    {
      public:
        moved_marker() = default;

        moved_marker(const moved_marker& copy) = default;
        moved_marker& operator=(const moved_marker&) = default;

        moved_marker(moved_marker&& obj) noexcept
            : moved_marker()
        {
            this->operator=(std::move(obj));
        }

        moved_marker& operator=(moved_marker&& obj) noexcept
        {
            if (this != &obj)
            {
                this->was_moved_ = obj.was_moved_;
                obj.was_moved_ = true;
            }

            return *this;
        }

        ~moved_marker() = default;

        bool was_moved() const
        {
            return this->was_moved_;
        }

        void mark_as_moved()
        {
            this->was_moved_ = true;
        }

      private:
        bool was_moved_{false};
    };
}

```

`src/common/utils/nt_handle.hpp`:

```hpp
#pragma once

#ifdef WIN32

#include "win.hpp"

#include <type_traits>

namespace utils::nt
{
    using HandleFunction = HANDLE();

    inline HANDLE null_handle()
    {
        return nullptr;
    }

    inline HANDLE invalid_handle()
    {
        return INVALID_HANDLE_VALUE;
    }

    template <HandleFunction InvalidHandleFunction = null_handle>
    class handle
    {
      public:
        handle() = default;

        handle(const HANDLE h)
            : handle_(h)
        {
        }

        ~handle()
        {
            if (*this)
            {
                CloseHandle(this->handle_);
                this->handle_ = InvalidHandleFunction();
            }
        }

        handle(const handle&) = delete;
        handle& operator=(const handle&) = delete;

        handle(handle&& obj) noexcept
            : handle()
        {
            this->operator=(std::move(obj));
        }

        handle& operator=(handle&& obj) noexcept
        {
            if (this != &obj)
            {
                this->~handle();
                this->handle_ = obj.handle_;
                obj.handle_ = InvalidHandleFunction();
            }

            return *this;
        }

        handle& operator=(HANDLE h) noexcept
        {
            this->~handle();
            this->handle_ = h;

            return *this;
        }

        [[nodiscard]] explicit operator bool() const
        {
            return this->handle_ != InvalidHandleFunction();
        }

        [[nodiscard]] operator HANDLE() const
        {
            return this->handle_;
        }

      private:
        HANDLE handle_{InvalidHandleFunction()};
    };
}

#endif

```

`src/common/utils/object.hpp`:

```hpp
#pragma once

namespace utils
{
    struct object
    {
        object() = default;
        virtual ~object() = default;

        object(object&&) = default;
        object(const object&) = default;
        object& operator=(object&&) = default;
        object& operator=(const object&) = default;
    };

    template <typename T>
    void reset_object_with_delayed_destruction(T& obj)
    {
        T new_obj{};
        const auto old = std::move(obj);
        obj = std::move(new_obj);
    }
}

```

`src/common/utils/path_key.hpp`:

```hpp
#pragma once

#include "string.hpp"
#include <filesystem>

namespace utils
{
    class path_key
    {
      public:
        path_key() = default;
        path_key(const std::filesystem::path& p)
            : path_(canonicalize_path(p))
        {
        }

        path_key(const path_key&) = default;
        path_key(path_key&&) noexcept = default;

        path_key& operator=(const path_key&) = default;
        path_key& operator=(path_key&&) noexcept = default;

        ~path_key() = default;

        const std::filesystem::path& get() const
        {
            return this->path_;
        }

        bool operator==(const path_key& other) const
        {
            return this->get() == other.get();
        }

        bool operator!=(const path_key& other) const
        {
            return !this->operator==(other);
        }

        static std::filesystem::path canonicalize_path(const std::filesystem::path& key)
        {
            auto key_string = key.u16string();
            std::ranges::replace(key_string, u'\\', '/');

            auto path = std::filesystem::path(key_string).lexically_normal().wstring();
            return utils::string::to_lower_consume(path);
        }

      private:
        std::filesystem::path path_{};
    };
}

namespace std
{
    template <>
    struct hash<utils::path_key>
    {
        size_t operator()(const utils::path_key& p) const noexcept
        {
            return hash<std::filesystem::path::string_type>()(p.get().native());
        }
    };
}

```

`src/common/utils/string.cpp`:

```cpp
#include "string.hpp"

#include <array>
#include <cstdarg>

namespace utils::string
{
    // NOLINTNEXTLINE(cert-dcl50-cpp)
    const char* va(const char* format, ...)
    {
        constexpr auto buffer_count = 4;
        thread_local std::array<std::vector<char>, buffer_count> buffers{};
        thread_local size_t current_index{0};

        const auto index = current_index++;
        current_index %= buffers.size();

        auto& buffer = buffers.at(index);

        if (buffer.size() < 10)
        {
            buffer.resize(10);
        }

        while (true)
        {
            va_list ap{};
            va_start(ap, format);

#ifdef _WIN32
            const int res = vsnprintf_s(buffer.data(), buffer.size(), _TRUNCATE, format, ap);
#else
            const int res = vsnprintf(buffer.data(), buffer.size(), format, ap);
#endif

            va_end(ap);

            if (res > 0 && static_cast<size_t>(res) < buffer.size())
            {
                break;
            }
            if (res == 0)
            {
                return nullptr;
            }

            buffer.resize(std::max(buffer.size() * 2, static_cast<size_t>(1)));
        }

        return buffer.data();
    }
}

```

`src/common/utils/string.hpp`:

```hpp
#pragma once
#include <span>
#include <string>
#include <vector>
#include <cstddef>
#include <cstdint>
#include <cwctype>
#include <algorithm>
#include <string_view>

namespace utils::string
{
#ifdef __clang__
    __attribute__((__format__(__printf__, 1, 2)))
#endif
    const char* va(const char* format, ...);

    template <typename T, size_t Size>
        requires(std::is_trivially_copyable_v<T>)
    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    void copy(T (&array)[Size], const T* str)
    {
        if constexpr (Size == 0)
        {
            return;
        }

        const auto size = std::min(Size, std::char_traits<T>::length(str));
        memcpy(array, str, size * sizeof(T));
        array[std::min(Size - 1, size)] = {};
    }

    template <typename T, size_t Size, class Traits = std::char_traits<T>>
        requires(std::is_trivially_copyable_v<T>)
    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    void copy(T (&array)[Size], const std::basic_string_view<T, Traits> str)
    {
        if constexpr (Size == 0)
        {
            return;
        }

        const auto size = std::min(Size - 1, str.size());
        memcpy(array, str.data(), size * sizeof(T));
        array[size] = {};
    }

    inline char char_to_lower(const char val)
    {
        return static_cast<char>(std::tolower(static_cast<unsigned char>(val)));
    }

    inline wchar_t char_to_lower(const wchar_t val)
    {
        return static_cast<wchar_t>(std::towlower(val));
    }

    inline char16_t char_to_lower(const char16_t val)
    {
        static_assert(sizeof(char16_t) <= sizeof(wchar_t));
        static_assert(sizeof(char16_t) == sizeof(uint16_t));
        return static_cast<char16_t>(char_to_lower(static_cast<wchar_t>(static_cast<uint16_t>(val))));
    }

    template <class Elem, class Traits, class Alloc>
    void to_lower_inplace(std::basic_string<Elem, Traits, Alloc>& str)
    {
        std::ranges::transform(str, str.begin(), [](const Elem e) { return char_to_lower(e); });
    }

    template <class Elem, class Traits, class Alloc>
    std::basic_string<Elem, Traits, Alloc> to_lower(std::basic_string<Elem, Traits, Alloc> str)
    {
        to_lower_inplace(str);
        return str;
    }

    template <class Elem, class Traits, class Alloc>
    std::basic_string<Elem, Traits, Alloc> to_lower_consume(std::basic_string<Elem, Traits, Alloc>& str)
    {
        return to_lower(std::move(str));
    }

    inline char to_nibble(std::byte value, const bool uppercase = false)
    {
        value = value & static_cast<std::byte>(0xF);

        if (value <= static_cast<std::byte>(9))
        {
            return static_cast<char>('0' + static_cast<char>(value));
        }

        return static_cast<char>((uppercase ? 'A' : 'a') + (static_cast<char>(value) - 0xA));
    }

    inline std::pair<char, char> to_hex(const std::byte value, const bool uppercase = false)
    {
        return {to_nibble(value >> 4, uppercase), to_nibble(value, uppercase)};
    }

    inline std::string to_hex_string(const void* data, const size_t size, const bool uppercase = false)
    {
        std::string result{};
        result.reserve(size * 2);

        for (size_t i = 0; i < size; ++i)
        {
            const auto value = static_cast<const std::byte*>(data)[i];
            const auto [high, low] = to_hex(value, uppercase);
            result.push_back(high);
            result.push_back(low);
        }

        return result;
    }

    template <typename Integer>
        requires(std::is_integral_v<Integer>)
    std::string to_hex_number(const Integer& i, const bool uppercase = false)
    {
        std::string res{};
        res.reserve(sizeof(i) * 2);

        const std::span data{reinterpret_cast<const std::byte*>(&i), sizeof(i)};

        for (const auto value : data)
        {
            const auto [high, low] = to_hex(value, uppercase);
            res.insert(res.begin(), {high, low});
        }

        while (res.size() > 1 && res.front() == '0')
        {
            res.erase(res.begin());
        }

        return res;
    }

    template <typename Integer>
        requires(std::is_integral_v<Integer>)
    std::string to_hex_string(const Integer& i, const bool uppercase = false)
    {
        return to_hex_string(&i, sizeof(Integer), uppercase);
    }

    inline std::string to_hex_string(const std::span<const std::byte> data, const bool uppercase = false)
    {
        return to_hex_string(data.data(), data.size(), uppercase);
    }

    inline std::byte parse_nibble(const char nibble)
    {
        const auto lower = char_to_lower(nibble);

        if (lower >= '0' && lower <= '9')
        {
            return static_cast<std::byte>(lower - '0');
        }

        if (lower >= 'a' && lower <= 'f')
        {
            return static_cast<std::byte>(10 + (lower - 'a'));
        }

        return static_cast<std::byte>(0);
    }

    inline std::vector<std::byte> from_hex_string(const std::string_view str)
    {
        const auto size = str.size() / 2;

        std::vector<std::byte> data{};
        data.reserve(size);

        for (size_t i = 0; i < size; ++i)
        {
            const auto high = parse_nibble(str[(i * 2) + 0]);
            const auto low = parse_nibble(str[(i * 2) + 1]);
            const auto value = (high << 4) | low;

            data.push_back(value);
        }

        return data;
    }

    template <class Elem, class Traits, class Alloc>
    bool equals_ignore_case(const std::basic_string<Elem, Traits, Alloc>& lhs, const std::basic_string<Elem, Traits, Alloc>& rhs)
    {
        return std::ranges::equal(lhs, rhs, [](const auto c1, const auto c2) { return char_to_lower(c1) == char_to_lower(c2); });
    }

    template <class Elem, class Traits>
    bool equals_ignore_case(const std::basic_string_view<Elem, Traits>& lhs, const std::basic_string_view<Elem, Traits>& rhs)
    {
        return std::ranges::equal(lhs, rhs, [](const auto c1, const auto c2) { return char_to_lower(c1) == char_to_lower(c2); });
    }

    template <class Elem, class Traits, class Alloc>
    bool starts_with_ignore_case(const std::basic_string<Elem, Traits, Alloc>& lhs, const std::basic_string<Elem, Traits, Alloc>& rhs)
    {
        if (lhs.length() < rhs.length())
        {
            return false;
        }

        return std::ranges::equal(lhs.substr(0, rhs.length()), rhs,
                                  [](const auto c1, const auto c2) { return char_to_lower(c1) == char_to_lower(c2); });
    }

    template <class Elem, class Traits>
    bool starts_with_ignore_case(const std::basic_string_view<Elem, Traits>& lhs, const std::basic_string_view<Elem, Traits>& rhs)
    {
        if (lhs.length() < rhs.length())
        {
            return false;
        }

        return std::ranges::equal(lhs.substr(0, rhs.length()), rhs,
                                  [](const auto c1, const auto c2) { return char_to_lower(c1) == char_to_lower(c2); });
    }

    template <class Elem, class Traits, class Alloc>
    bool ends_with_ignore_case(const std::basic_string<Elem, Traits, Alloc>& lhs, const std::basic_string<Elem, Traits, Alloc>& rhs)
    {
        if (lhs.length() < rhs.length())
        {
            return false;
        }

        auto start = lhs.length() - rhs.length();
        return std::ranges::equal(lhs.substr(start, rhs.length()), rhs,
                                  [](const auto c1, const auto c2) { return char_to_lower(c1) == char_to_lower(c2); });
    }

    template <class Elem, class Traits>
    bool ends_with_ignore_case(const std::basic_string_view<Elem, Traits>& lhs, const std::basic_string_view<Elem, Traits>& rhs)
    {
        if (lhs.length() < rhs.length())
        {
            return false;
        }

        auto start = lhs.length() - rhs.length();
        return std::ranges::equal(lhs.substr(start, rhs.length()), rhs,
                                  [](const auto c1, const auto c2) { return char_to_lower(c1) == char_to_lower(c2); });
    }

    template <class Elem, class Traits>
    int compare_ignore_case(std::basic_string_view<Elem, Traits> lhs, std::basic_string_view<Elem, Traits> rhs)
    {
        const std::size_t n = std::min(lhs.size(), rhs.size());

        for (std::size_t i = 0; i < n; ++i)
        {
            auto c1 = char_to_lower(lhs[i]);
            auto c2 = char_to_lower(rhs[i]);

            if (c1 < c2)
            {
                return -1;
            }
            if (c1 > c2)
            {
                return 1;
            }
        }

        if (lhs.size() < rhs.size())
        {
            return -1;
        }
        if (lhs.size() > rhs.size())
        {
            return 1;
        }
        return 0;
    }

    template <class Elem, class Traits, class Alloc>
    int compare_ignore_case(const std::basic_string<Elem, Traits, Alloc>& lhs, const std::basic_string<Elem, Traits, Alloc>& rhs)
    {
        return compare_ignore_case(std::basic_string_view<Elem, Traits>(lhs), std::basic_string_view<Elem, Traits>(rhs));
    }
}

```

`src/common/utils/time.cpp`:

```cpp
#include "time.hpp"
#include <cstring>

namespace utils
{
    std::chrono::steady_clock::time_point convert_delay_interval_to_time_point(clock& c, const LARGE_INTEGER delay_interval,
                                                                               const LARGE_INTEGER infinite_value)
    {
        if (delay_interval.QuadPart == infinite_value.QuadPart)
        {
            return std::chrono::steady_clock::time_point::min();
        }

        if (delay_interval.QuadPart <= 0)
        {
            const auto relative_time = -delay_interval.QuadPart;
            const auto relative_ticks_in_ms = relative_time / 10;
            const auto relative_fraction_ns = (relative_time % 10) * 100;
            const auto relative_duration = std::chrono::microseconds(relative_ticks_in_ms) + std::chrono::nanoseconds(relative_fraction_ns);

            return c.steady_now() + relative_duration;
        }

        const auto delay_seconds_since_1601 = delay_interval.QuadPart / HUNDRED_NANOSECONDS_IN_ONE_SECOND;
        const auto delay_fraction_ns = (delay_interval.QuadPart % HUNDRED_NANOSECONDS_IN_ONE_SECOND) * 100;

        const auto delay_seconds_since_1970 = delay_seconds_since_1601 - EPOCH_DIFFERENCE_1601_TO_1970_SECONDS;

        const auto target_time =
            std::chrono::system_clock::from_time_t(delay_seconds_since_1970) + std::chrono::nanoseconds(delay_fraction_ns);

        const auto now_system = c.system_now();

        const auto duration_until_target = std::chrono::duration_cast<std::chrono::microseconds>(target_time - now_system);

        return c.steady_now() + duration_until_target;
    }

    KSYSTEM_TIME convert_to_ksystem_time(const std::chrono::system_clock::time_point& tp)
    {
        const auto duration = tp.time_since_epoch();
        const auto ns_duration = std::chrono::duration_cast<std::chrono::nanoseconds>(duration);

        const auto total_ticks = ns_duration.count() / 100 + WINDOWS_EPOCH_DIFFERENCE;

        KSYSTEM_TIME time{};
        time.LowPart = static_cast<uint32_t>(total_ticks);
        time.High1Time = static_cast<int32_t>(total_ticks >> 32);
        time.High2Time = time.High1Time;

        return time;
    }

    void convert_to_ksystem_time(volatile KSYSTEM_TIME* dest, const std::chrono::system_clock::time_point& tp)
    {
        const auto time = convert_to_ksystem_time(tp);
        memcpy(const_cast<KSYSTEM_TIME*>(dest), &time, sizeof(*dest));
    }

    std::chrono::system_clock::time_point convert_from_ksystem_time(const KSYSTEM_TIME& time)
    {
        auto totalTicks = (static_cast<int64_t>(time.High1Time) << 32) | time.LowPart;
        totalTicks -= WINDOWS_EPOCH_DIFFERENCE;

        const auto duration = std::chrono::system_clock::duration(totalTicks * 100);
        return std::chrono::system_clock::time_point(duration);
    }

    std::chrono::system_clock::time_point convert_from_ksystem_time(const volatile KSYSTEM_TIME& time)
    {
        return convert_from_ksystem_time(*const_cast<const KSYSTEM_TIME*>(&time));
    }

#ifndef OS_WINDOWS
    using __time64_t = int64_t;
#endif

    LARGE_INTEGER convert_unix_to_windows_time(const __time64_t unix_time)
    {
        LARGE_INTEGER windows_time{};
        windows_time.QuadPart = (unix_time + EPOCH_DIFFERENCE_1601_TO_1970_SECONDS) * HUNDRED_NANOSECONDS_IN_ONE_SECOND;
        return windows_time;
    }
}

```

`src/common/utils/time.hpp`:

```hpp
#pragma once

#include <chrono>

#include "../platform/platform.hpp"
#if defined(_MSC_VER)
#include <intrin.h>
#pragma intrinsic(__rdtsc)
#elif defined(__x86_64__) || defined(__i386__) || defined(__amd64__)
#include <x86intrin.h>
#endif

constexpr auto HUNDRED_NANOSECONDS_IN_ONE_SECOND = 10000000LL;
constexpr auto EPOCH_DIFFERENCE_1601_TO_1970_SECONDS = 11644473600LL;
constexpr auto WINDOWS_EPOCH_DIFFERENCE = EPOCH_DIFFERENCE_1601_TO_1970_SECONDS * HUNDRED_NANOSECONDS_IN_ONE_SECOND;

namespace utils
{
    struct clock
    {
        using system_time_point = std::chrono::system_clock::time_point;
        using steady_time_point = std::chrono::steady_clock::time_point;

        using system_duration = system_time_point::duration;
        using steady_duration = steady_time_point::duration;

        virtual ~clock() = default;

        virtual system_time_point system_now()
        {
            return std::chrono::system_clock::now();
        }

        virtual steady_time_point steady_now()
        {
            return std::chrono::steady_clock::now();
        }

        // Returns the current timestamp counter value. RDTSC on x86/x64, or just time since epoch for ARM
        /// TODO: find better solution for ARM and Figure out better CPU base frequency heuristics
        virtual uint64_t timestamp_counter()
        {
#if defined(_M_X64) || defined(_M_AMD64) || defined(_M_IX86) || defined(__x86_64__) || defined(__i386__) || defined(__amd64__)
            return __rdtsc(); // any x86 system will have this instrinsic
#else
            const auto count = std::chrono::high_resolution_clock::now().time_since_epoch().count();
            return static_cast<uint64_t>((count * 38LL) / 10LL);
#endif
        }
    };

    class tick_clock : public clock
    {
      public:
        tick_clock(const uint64_t frequency = 1, const system_time_point system_start = {}, const steady_time_point steady_start = {})
            : frequency_(frequency),
              system_start_(system_start),
              steady_start_(steady_start)
        {
            if (this->frequency_ == 0)
            {
                throw std::invalid_argument("Frequency can not be 0");
            }
        }

        system_time_point system_now() override
        {
            return this->now(this->system_start_);
        }

        steady_time_point steady_now() override
        {
            return this->now(this->steady_start_);
        }

        uint64_t timestamp_counter() override
        {
            return this->ticks();
        }

        virtual uint64_t ticks() = 0;

        uint64_t get_frequency() const
        {
            return this->frequency_;
        }

      private:
        uint64_t frequency_{1};
        system_time_point system_start_{};
        steady_time_point steady_start_{};

        template <typename TimePoint>
        TimePoint now(const TimePoint start)
        {
            using duration = typename TimePoint::duration;

            const auto passed_ticks = this->ticks();
            const auto passed_time = duration(passed_ticks * duration::period::den / this->frequency_);

            return start + passed_time;
        }
    };

    std::chrono::steady_clock::time_point convert_delay_interval_to_time_point(clock& c, LARGE_INTEGER delay_interval,
                                                                               LARGE_INTEGER infinite_value = {.LowPart = 0,
                                                                                                               .HighPart = -2147483648});

    KSYSTEM_TIME convert_to_ksystem_time(const std::chrono::system_clock::time_point& tp);
    void convert_to_ksystem_time(volatile KSYSTEM_TIME* dest, const std::chrono::system_clock::time_point& tp);
    std::chrono::system_clock::time_point convert_from_ksystem_time(const KSYSTEM_TIME& time);
    std::chrono::system_clock::time_point convert_from_ksystem_time(const volatile KSYSTEM_TIME& time);
#ifndef OS_WINDOWS
    using __time64_t = int64_t;
#endif
    LARGE_INTEGER convert_unix_to_windows_time(__time64_t unix_time);
}

```

`src/common/utils/timer.hpp`:

```hpp
#pragma once

#include <chrono>

namespace utils
{
    template <typename Clock = std::chrono::high_resolution_clock>
    class timer
    {
      public:
        void update()
        {
            this->point_ = Clock::now();
        }

        bool has_elapsed(typename Clock::duration duration) const
        {
            return this->elapsed() > duration;
        }

        typename Clock::duration elapsed() const
        {
            const auto now = Clock::now();
            return now - this->point_;
        }

      private:
        typename Clock::time_point point_{Clock::now()};
    };
}

```

`src/common/utils/wildcard.hpp`:

```hpp
#pragma once
#include <string>

namespace utils::wildcard
{
    inline bool is_wildcard(char16_t c)
    {
        return c == '*' || c == '?' || c == '>' || c == '<' || c == '\"';
    }

    inline bool has_wildcard(const std::u16string_view mask)
    {
        return std::ranges::any_of(mask, is_wildcard);
    }

    inline bool match_filename(std::u16string_view name, std::u16string_view mask)
    {
        if (mask.empty() || mask == u"*" || mask == u"*.*")
        {
            return true;
        }

        size_t name_pos = 0;
        size_t mask_pos = 0;

        size_t star_mask_pos = std::u16string_view::npos;
        size_t star_name_pos = 0;

        while (name_pos < name.size())
        {
            if (mask_pos < mask.size())
            {
                char16_t mask_char = mask[mask_pos];
                char16_t name_char = name[name_pos];

                bool char_matches = false;
                if (mask_char == u'?' || mask_char == u'>')
                {
                    char_matches = true;
                }
                else if (mask_char == u'"')
                {
                    char_matches = name_char == u'.';
                }
                else
                {
                    char_matches = string::char_to_lower(name_char) == string::char_to_lower(mask_char);
                }

                // Advance if current characters match
                if (char_matches)
                {
                    name_pos++;
                    mask_pos++;
                    continue;
                }

                // If this is a wildcard, skip all consecutive wildcards and save position for backtracking
                if (mask[mask_pos] == u'*' || mask[mask_pos] == u'<')
                {
                    mask_pos++;
                    while (mask_pos < mask.size() && (mask[mask_pos] == u'*' || mask[mask_pos] == u'<'))
                    {
                        mask_pos++;
                    }

                    if (mask_pos == mask.size())
                    {
                        // There is no need to continue because all that remained were star masks.
                        return true;
                    }

                    star_mask_pos = mask_pos;
                    star_name_pos = name_pos;
                    continue;
                }
            }

            // The current characters didn't match...
            // If we had a wildcard earlier, backtrack to it and try to match at the next position
            if (star_mask_pos != std::u16string_view::npos)
            {
                mask_pos = star_mask_pos;
                name_pos = ++star_name_pos;
                continue;
            }

            return false;
        }

        // Skip any remaining wildcards in the mask
        while (mask_pos < mask.size() && (mask[mask_pos] == u'*' || mask[mask_pos] == u'<'))
        {
            mask_pos++;
        }

        return mask_pos == mask.size();
    }
}

```

`src/common/utils/win.hpp`:

```hpp
#pragma once

#ifdef _WIN32

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef _CRT_NO_POSIX_ERROR_CODES
#define _CRT_NO_POSIX_ERROR_CODES
#endif

#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifdef __MINGW64__
#include <windows.h>
#else
#include <Windows.h>
#endif

#endif

```

`src/debugger/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(debugger ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(debugger PRIVATE
  windows-emulator
  flatbuffers
  base64
)

target_include_directories(debugger INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

add_custom_target(generate-flatbuffer
  DEPENDS flatc
  COMMAND "$<TARGET_FILE:flatc>" --gen-mutable --gen-object-api --filename-ext hxx --cpp -o "${CMAKE_CURRENT_LIST_DIR}" "${CMAKE_CURRENT_LIST_DIR}/events.fbs"
  COMMAND "$<TARGET_FILE:flatc>" --gen-mutable --gen-object-api --ts -o "${PROJECT_SOURCE_DIR}/page/src/fb" "${CMAKE_CURRENT_LIST_DIR}/events.fbs"
)

```

`src/debugger/event_handler.cpp`:

```cpp
#include "event_handler.hpp"
#include "message_transmitter.hpp"
#include "windows_emulator.hpp"

#include <base64.hpp>

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4244)
#endif

#include "events_generated.hxx"

#ifdef _MSC_VER
#pragma warning(pop)
#endif

namespace debugger
{
    namespace
    {
        std::optional<Debugger::DebugEventT> receive_event()
        {
            const auto message = receive_message();
            if (message.empty())
            {
                return std::nullopt;
            }

            const auto data = base64::from_base64(message);

            flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(data.data()), data.size());
            if (!Debugger::VerifyDebugEventBuffer(verifier))
            {
                return std::nullopt;
            }

            Debugger::DebugEventT e{};
            Debugger::GetDebugEvent(data.data())->UnPackTo(&e);

            return {std::move(e)};
        }

        void send_event(const Debugger::DebugEventT& event)
        {
            flatbuffers::FlatBufferBuilder fbb{};
            fbb.Finish(Debugger::DebugEvent::Pack(fbb, &event));

            const std::string_view buffer(reinterpret_cast<const char*>(fbb.GetBufferPointer()), fbb.GetSize());
            const auto message = base64::to_base64(buffer);

            send_message(message);
        }

        template <typename T>
            requires(!std::is_same_v<std::remove_cvref_t<T>, Debugger::DebugEventT>)
        void send_event(T event)
        {
            Debugger::DebugEventT e{};
            e.event.Set(std::move(event));
            send_event(e);
        }

        Debugger::State translate_state(const emulation_state state)
        {
            switch (state)
            {
            case emulation_state::paused:
                return Debugger::State_Paused;

            case emulation_state::none:
            case emulation_state::running:
                return Debugger::State_Running;

            default:
                return Debugger::State_None;
            }
        }

        void handle_get_state(const event_context& c)
        {
            Debugger::GetStateResponseT response{};
            response.state = translate_state(c.state);

            send_event(response);
        }

        void handle_read_memory(const event_context& c, const Debugger::ReadMemoryRequestT& request)
        {
            std::vector<uint8_t> buffer{};
            buffer.resize(request.size);
            const auto res = c.win_emu.memory.try_read_memory(request.address, buffer.data(), buffer.size());

            Debugger::ReadMemoryResponseT response{};
            response.address = request.address;

            if (res)
            {
                response.data = std::move(buffer);
            }

            send_event(std::move(response));
        }

        void handle_write_memory(const event_context& c, const Debugger::WriteMemoryRequestT& request)
        {
            bool success{};

            try
            {
                c.win_emu.memory.write_memory(request.address, request.data.data(), request.data.size());
                success = true;
            }
            catch (...)
            {
                success = false;
            }

            Debugger::WriteMemoryResponseT response{};
            response.address = request.address;
            response.size = static_cast<uint32_t>(request.data.size());
            response.success = success;

            send_event(response);
        }

        void handle_read_register(const event_context& c, const Debugger::ReadRegisterRequestT& request)
        {
            std::array<uint8_t, 512> buffer{};
            const auto res = c.win_emu.emu().read_register(static_cast<x86_register>(request.register_), buffer.data(), buffer.size());

            const auto size = std::min(buffer.size(), res);

            Debugger::ReadRegisterResponseT response{};
            response.register_ = request.register_;
            response.data.assign(buffer.data(), buffer.data() + size);

            send_event(std::move(response));
        }

        void handle_write_register(const event_context& c, const Debugger::WriteRegisterRequestT& request)
        {
            bool success{};
            size_t size = request.data.size();

            try
            {
                size =
                    c.win_emu.emu().write_register(static_cast<x86_register>(request.register_), request.data.data(), request.data.size());
                success = true;
            }
            catch (...)
            {
                success = false;
            }

            Debugger::WriteRegisterResponseT response{};
            response.register_ = request.register_;
            response.size = static_cast<uint32_t>(size);
            response.success = success;

            send_event(response);
        }

        void handle_event(event_context& c, const Debugger::DebugEventT& e)
        {
            switch (e.event.type)
            {
            case Debugger::Event_PauseRequest:
                c.state = emulation_state::paused;
                break;

            case Debugger::Event_RunRequest:
                c.state = emulation_state::running;
                break;

            case Debugger::Event_GetStateRequest:
                handle_get_state(c);
                break;

            case Debugger::Event_ReadMemoryRequest:
                handle_read_memory(c, *e.event.AsReadMemoryRequest());
                break;

            case Debugger::Event_WriteMemoryRequest:
                handle_write_memory(c, *e.event.AsWriteMemoryRequest());
                break;

            case Debugger::Event_ReadRegisterRequest:
                handle_read_register(c, *e.event.AsReadRegisterRequest());
                break;

            case Debugger::Event_WriteRegisterRequest:
                handle_write_register(c, *e.event.AsWriteRegisterRequest());
                break;

            default:
                break;
            }
        }
    }

    void handle_events_once(event_context& c)
    {
        while (true)
        {
            suspend_execution(0ms);

            const auto e = receive_event();
            if (!e.has_value())
            {
                break;
            }

            handle_event(c, *e);
        }
    }

    void handle_events(event_context& c)
    {
        update_emulation_status(c.win_emu);

        while (true)
        {
            handle_events_once(c);

            if (c.state != emulation_state::paused)
            {
                break;
            }

            suspend_execution(2ms);
        }
    }

    void update_emulation_status(const windows_emulator& win_emu)
    {
        const auto memory_status = win_emu.memory.compute_memory_stats();

        Debugger::EmulationStatusT status{};
        status.reserved_memory = memory_status.reserved_memory;
        status.committed_memory = memory_status.committed_memory;
        status.executed_instructions = win_emu.get_executed_instructions();
        status.active_threads = static_cast<uint32_t>(win_emu.process.threads.size());
        send_event(status);
    }

    void handle_exit(const windows_emulator& win_emu, std::optional<NTSTATUS> exit_status)
    {
        update_emulation_status(win_emu);

        Debugger::ApplicationExitT response{};
        response.exit_status = exit_status;
        send_event(response);
    }
}

```

`src/debugger/event_handler.hpp`:

```hpp
#pragma once

#include <windows_emulator.hpp>

namespace debugger
{
    enum class emulation_state
    {
        none,
        running,
        paused,
    };

    struct event_context
    {
        windows_emulator& win_emu;
        emulation_state state{emulation_state::none};
    };

    void handle_events(event_context& c);
    void handle_exit(const windows_emulator& win_emu, std::optional<NTSTATUS> exit_status);
    void update_emulation_status(const windows_emulator& win_emu);
}

```

`src/debugger/events.fbs`:

```fbs
namespace Debugger;

table GetStateRequest {}

enum State : uint32 {
    None = 0,
    Running,
    Paused,
}

table GetStateResponse {
    state: State;
}

table PauseRequest {}

table RunRequest {
    single_step: bool;
}

table WriteMemoryRequest {
    address: uint64;
    data: [ubyte];
}

table WriteMemoryResponse {
    address: uint64;
    size: uint32;
    success: bool;
}

table ReadMemoryRequest {
    address: uint64;
    size: uint32;
}

table ReadMemoryResponse {
    address: uint64;
    data: [ubyte];
}

table WriteRegisterRequest {
    register: uint32;
    data: [ubyte];
}

table WriteRegisterResponse {
    register: uint32;
    size: uint32;
    success: bool;
}

table ReadRegisterRequest {
    register: uint32;
}

table ReadRegisterResponse {
    register: uint32;
    data: [ubyte];
}

table ApplicationExit {
    exit_status: uint32 = null;
}

table EmulationStatus {
    active_threads: uint32;
    reserved_memory: uint64;
    committed_memory: uint64;
    executed_instructions: uint64;
}

union Event { 
    PauseRequest, 
    RunRequest,
    GetStateRequest,
    GetStateResponse,
    WriteMemoryRequest,
    WriteMemoryResponse,
    ReadMemoryRequest,
    ReadMemoryResponse,
    WriteRegisterRequest,
    WriteRegisterResponse,
    ReadRegisterRequest,
    ReadRegisterResponse,
    ApplicationExit,
    EmulationStatus,
}

table DebugEvent {
    event: Event;
}

root_type DebugEvent;

```

`src/debugger/events_generated.hxx`:

```hxx
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_
#define FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace Debugger {

struct GetStateRequest;
struct GetStateRequestBuilder;
struct GetStateRequestT;

struct GetStateResponse;
struct GetStateResponseBuilder;
struct GetStateResponseT;

struct PauseRequest;
struct PauseRequestBuilder;
struct PauseRequestT;

struct RunRequest;
struct RunRequestBuilder;
struct RunRequestT;

struct WriteMemoryRequest;
struct WriteMemoryRequestBuilder;
struct WriteMemoryRequestT;

struct WriteMemoryResponse;
struct WriteMemoryResponseBuilder;
struct WriteMemoryResponseT;

struct ReadMemoryRequest;
struct ReadMemoryRequestBuilder;
struct ReadMemoryRequestT;

struct ReadMemoryResponse;
struct ReadMemoryResponseBuilder;
struct ReadMemoryResponseT;

struct WriteRegisterRequest;
struct WriteRegisterRequestBuilder;
struct WriteRegisterRequestT;

struct WriteRegisterResponse;
struct WriteRegisterResponseBuilder;
struct WriteRegisterResponseT;

struct ReadRegisterRequest;
struct ReadRegisterRequestBuilder;
struct ReadRegisterRequestT;

struct ReadRegisterResponse;
struct ReadRegisterResponseBuilder;
struct ReadRegisterResponseT;

struct ApplicationExit;
struct ApplicationExitBuilder;
struct ApplicationExitT;

struct EmulationStatus;
struct EmulationStatusBuilder;
struct EmulationStatusT;

struct DebugEvent;
struct DebugEventBuilder;
struct DebugEventT;

enum State : uint32_t {
  State_None = 0,
  State_Running = 1,
  State_Paused = 2,
  State_MIN = State_None,
  State_MAX = State_Paused
};

inline const State (&EnumValuesState())[3] {
  static const State values[] = {
    State_None,
    State_Running,
    State_Paused
  };
  return values;
}

inline const char * const *EnumNamesState() {
  static const char * const names[4] = {
    "None",
    "Running",
    "Paused",
    nullptr
  };
  return names;
}

inline const char *EnumNameState(State e) {
  if (::flatbuffers::IsOutRange(e, State_None, State_Paused)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesState()[index];
}

enum Event : uint8_t {
  Event_NONE = 0,
  Event_PauseRequest = 1,
  Event_RunRequest = 2,
  Event_GetStateRequest = 3,
  Event_GetStateResponse = 4,
  Event_WriteMemoryRequest = 5,
  Event_WriteMemoryResponse = 6,
  Event_ReadMemoryRequest = 7,
  Event_ReadMemoryResponse = 8,
  Event_WriteRegisterRequest = 9,
  Event_WriteRegisterResponse = 10,
  Event_ReadRegisterRequest = 11,
  Event_ReadRegisterResponse = 12,
  Event_ApplicationExit = 13,
  Event_EmulationStatus = 14,
  Event_MIN = Event_NONE,
  Event_MAX = Event_EmulationStatus
};

inline const Event (&EnumValuesEvent())[15] {
  static const Event values[] = {
    Event_NONE,
    Event_PauseRequest,
    Event_RunRequest,
    Event_GetStateRequest,
    Event_GetStateResponse,
    Event_WriteMemoryRequest,
    Event_WriteMemoryResponse,
    Event_ReadMemoryRequest,
    Event_ReadMemoryResponse,
    Event_WriteRegisterRequest,
    Event_WriteRegisterResponse,
    Event_ReadRegisterRequest,
    Event_ReadRegisterResponse,
    Event_ApplicationExit,
    Event_EmulationStatus
  };
  return values;
}

inline const char * const *EnumNamesEvent() {
  static const char * const names[16] = {
    "NONE",
    "PauseRequest",
    "RunRequest",
    "GetStateRequest",
    "GetStateResponse",
    "WriteMemoryRequest",
    "WriteMemoryResponse",
    "ReadMemoryRequest",
    "ReadMemoryResponse",
    "WriteRegisterRequest",
    "WriteRegisterResponse",
    "ReadRegisterRequest",
    "ReadRegisterResponse",
    "ApplicationExit",
    "EmulationStatus",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvent(Event e) {
  if (::flatbuffers::IsOutRange(e, Event_NONE, Event_EmulationStatus)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvent()[index];
}

template<typename T> struct EventTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventTraits<Debugger::PauseRequest> {
  static const Event enum_value = Event_PauseRequest;
};

template<> struct EventTraits<Debugger::RunRequest> {
  static const Event enum_value = Event_RunRequest;
};

template<> struct EventTraits<Debugger::GetStateRequest> {
  static const Event enum_value = Event_GetStateRequest;
};

template<> struct EventTraits<Debugger::GetStateResponse> {
  static const Event enum_value = Event_GetStateResponse;
};

template<> struct EventTraits<Debugger::WriteMemoryRequest> {
  static const Event enum_value = Event_WriteMemoryRequest;
};

template<> struct EventTraits<Debugger::WriteMemoryResponse> {
  static const Event enum_value = Event_WriteMemoryResponse;
};

template<> struct EventTraits<Debugger::ReadMemoryRequest> {
  static const Event enum_value = Event_ReadMemoryRequest;
};

template<> struct EventTraits<Debugger::ReadMemoryResponse> {
  static const Event enum_value = Event_ReadMemoryResponse;
};

template<> struct EventTraits<Debugger::WriteRegisterRequest> {
  static const Event enum_value = Event_WriteRegisterRequest;
};

template<> struct EventTraits<Debugger::WriteRegisterResponse> {
  static const Event enum_value = Event_WriteRegisterResponse;
};

template<> struct EventTraits<Debugger::ReadRegisterRequest> {
  static const Event enum_value = Event_ReadRegisterRequest;
};

template<> struct EventTraits<Debugger::ReadRegisterResponse> {
  static const Event enum_value = Event_ReadRegisterResponse;
};

template<> struct EventTraits<Debugger::ApplicationExit> {
  static const Event enum_value = Event_ApplicationExit;
};

template<> struct EventTraits<Debugger::EmulationStatus> {
  static const Event enum_value = Event_EmulationStatus;
};

template<typename T> struct EventUnionTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventUnionTraits<Debugger::PauseRequestT> {
  static const Event enum_value = Event_PauseRequest;
};

template<> struct EventUnionTraits<Debugger::RunRequestT> {
  static const Event enum_value = Event_RunRequest;
};

template<> struct EventUnionTraits<Debugger::GetStateRequestT> {
  static const Event enum_value = Event_GetStateRequest;
};

template<> struct EventUnionTraits<Debugger::GetStateResponseT> {
  static const Event enum_value = Event_GetStateResponse;
};

template<> struct EventUnionTraits<Debugger::WriteMemoryRequestT> {
  static const Event enum_value = Event_WriteMemoryRequest;
};

template<> struct EventUnionTraits<Debugger::WriteMemoryResponseT> {
  static const Event enum_value = Event_WriteMemoryResponse;
};

template<> struct EventUnionTraits<Debugger::ReadMemoryRequestT> {
  static const Event enum_value = Event_ReadMemoryRequest;
};

template<> struct EventUnionTraits<Debugger::ReadMemoryResponseT> {
  static const Event enum_value = Event_ReadMemoryResponse;
};

template<> struct EventUnionTraits<Debugger::WriteRegisterRequestT> {
  static const Event enum_value = Event_WriteRegisterRequest;
};

template<> struct EventUnionTraits<Debugger::WriteRegisterResponseT> {
  static const Event enum_value = Event_WriteRegisterResponse;
};

template<> struct EventUnionTraits<Debugger::ReadRegisterRequestT> {
  static const Event enum_value = Event_ReadRegisterRequest;
};

template<> struct EventUnionTraits<Debugger::ReadRegisterResponseT> {
  static const Event enum_value = Event_ReadRegisterResponse;
};

template<> struct EventUnionTraits<Debugger::ApplicationExitT> {
  static const Event enum_value = Event_ApplicationExit;
};

template<> struct EventUnionTraits<Debugger::EmulationStatusT> {
  static const Event enum_value = Event_EmulationStatus;
};

struct EventUnion {
  Event type;
  void *value;

  EventUnion() : type(Event_NONE), value(nullptr) {}
  EventUnion(EventUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Event_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventUnion(const EventUnion &);
  EventUnion &operator=(const EventUnion &u)
    { EventUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventUnion &operator=(EventUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = EventUnionTraits<RT>::enum_value;
    if (type != Event_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Debugger::PauseRequestT *AsPauseRequest() {
    return type == Event_PauseRequest ?
      reinterpret_cast<Debugger::PauseRequestT *>(value) : nullptr;
  }
  const Debugger::PauseRequestT *AsPauseRequest() const {
    return type == Event_PauseRequest ?
      reinterpret_cast<const Debugger::PauseRequestT *>(value) : nullptr;
  }
  Debugger::RunRequestT *AsRunRequest() {
    return type == Event_RunRequest ?
      reinterpret_cast<Debugger::RunRequestT *>(value) : nullptr;
  }
  const Debugger::RunRequestT *AsRunRequest() const {
    return type == Event_RunRequest ?
      reinterpret_cast<const Debugger::RunRequestT *>(value) : nullptr;
  }
  Debugger::GetStateRequestT *AsGetStateRequest() {
    return type == Event_GetStateRequest ?
      reinterpret_cast<Debugger::GetStateRequestT *>(value) : nullptr;
  }
  const Debugger::GetStateRequestT *AsGetStateRequest() const {
    return type == Event_GetStateRequest ?
      reinterpret_cast<const Debugger::GetStateRequestT *>(value) : nullptr;
  }
  Debugger::GetStateResponseT *AsGetStateResponse() {
    return type == Event_GetStateResponse ?
      reinterpret_cast<Debugger::GetStateResponseT *>(value) : nullptr;
  }
  const Debugger::GetStateResponseT *AsGetStateResponse() const {
    return type == Event_GetStateResponse ?
      reinterpret_cast<const Debugger::GetStateResponseT *>(value) : nullptr;
  }
  Debugger::WriteMemoryRequestT *AsWriteMemoryRequest() {
    return type == Event_WriteMemoryRequest ?
      reinterpret_cast<Debugger::WriteMemoryRequestT *>(value) : nullptr;
  }
  const Debugger::WriteMemoryRequestT *AsWriteMemoryRequest() const {
    return type == Event_WriteMemoryRequest ?
      reinterpret_cast<const Debugger::WriteMemoryRequestT *>(value) : nullptr;
  }
  Debugger::WriteMemoryResponseT *AsWriteMemoryResponse() {
    return type == Event_WriteMemoryResponse ?
      reinterpret_cast<Debugger::WriteMemoryResponseT *>(value) : nullptr;
  }
  const Debugger::WriteMemoryResponseT *AsWriteMemoryResponse() const {
    return type == Event_WriteMemoryResponse ?
      reinterpret_cast<const Debugger::WriteMemoryResponseT *>(value) : nullptr;
  }
  Debugger::ReadMemoryRequestT *AsReadMemoryRequest() {
    return type == Event_ReadMemoryRequest ?
      reinterpret_cast<Debugger::ReadMemoryRequestT *>(value) : nullptr;
  }
  const Debugger::ReadMemoryRequestT *AsReadMemoryRequest() const {
    return type == Event_ReadMemoryRequest ?
      reinterpret_cast<const Debugger::ReadMemoryRequestT *>(value) : nullptr;
  }
  Debugger::ReadMemoryResponseT *AsReadMemoryResponse() {
    return type == Event_ReadMemoryResponse ?
      reinterpret_cast<Debugger::ReadMemoryResponseT *>(value) : nullptr;
  }
  const Debugger::ReadMemoryResponseT *AsReadMemoryResponse() const {
    return type == Event_ReadMemoryResponse ?
      reinterpret_cast<const Debugger::ReadMemoryResponseT *>(value) : nullptr;
  }
  Debugger::WriteRegisterRequestT *AsWriteRegisterRequest() {
    return type == Event_WriteRegisterRequest ?
      reinterpret_cast<Debugger::WriteRegisterRequestT *>(value) : nullptr;
  }
  const Debugger::WriteRegisterRequestT *AsWriteRegisterRequest() const {
    return type == Event_WriteRegisterRequest ?
      reinterpret_cast<const Debugger::WriteRegisterRequestT *>(value) : nullptr;
  }
  Debugger::WriteRegisterResponseT *AsWriteRegisterResponse() {
    return type == Event_WriteRegisterResponse ?
      reinterpret_cast<Debugger::WriteRegisterResponseT *>(value) : nullptr;
  }
  const Debugger::WriteRegisterResponseT *AsWriteRegisterResponse() const {
    return type == Event_WriteRegisterResponse ?
      reinterpret_cast<const Debugger::WriteRegisterResponseT *>(value) : nullptr;
  }
  Debugger::ReadRegisterRequestT *AsReadRegisterRequest() {
    return type == Event_ReadRegisterRequest ?
      reinterpret_cast<Debugger::ReadRegisterRequestT *>(value) : nullptr;
  }
  const Debugger::ReadRegisterRequestT *AsReadRegisterRequest() const {
    return type == Event_ReadRegisterRequest ?
      reinterpret_cast<const Debugger::ReadRegisterRequestT *>(value) : nullptr;
  }
  Debugger::ReadRegisterResponseT *AsReadRegisterResponse() {
    return type == Event_ReadRegisterResponse ?
      reinterpret_cast<Debugger::ReadRegisterResponseT *>(value) : nullptr;
  }
  const Debugger::ReadRegisterResponseT *AsReadRegisterResponse() const {
    return type == Event_ReadRegisterResponse ?
      reinterpret_cast<const Debugger::ReadRegisterResponseT *>(value) : nullptr;
  }
  Debugger::ApplicationExitT *AsApplicationExit() {
    return type == Event_ApplicationExit ?
      reinterpret_cast<Debugger::ApplicationExitT *>(value) : nullptr;
  }
  const Debugger::ApplicationExitT *AsApplicationExit() const {
    return type == Event_ApplicationExit ?
      reinterpret_cast<const Debugger::ApplicationExitT *>(value) : nullptr;
  }
  Debugger::EmulationStatusT *AsEmulationStatus() {
    return type == Event_EmulationStatus ?
      reinterpret_cast<Debugger::EmulationStatusT *>(value) : nullptr;
  }
  const Debugger::EmulationStatusT *AsEmulationStatus() const {
    return type == Event_EmulationStatus ?
      reinterpret_cast<const Debugger::EmulationStatusT *>(value) : nullptr;
  }
};

template <bool B = false>
bool VerifyEvent(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, Event type);
template <bool B = false>
bool VerifyEventVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct GetStateRequestT : public ::flatbuffers::NativeTable {
  typedef GetStateRequest TableType;
};

struct GetStateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStateRequestT NativeTableType;
  typedef GetStateRequestBuilder Builder;
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GetStateRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetStateRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetStateRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetStateRequestBuilder {
  typedef GetStateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetStateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStateRequest> CreateGetStateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetStateRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<GetStateRequest> CreateGetStateRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetStateResponseT : public ::flatbuffers::NativeTable {
  typedef GetStateResponse TableType;
  Debugger::State state = Debugger::State_None;
};

struct GetStateResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStateResponseT NativeTableType;
  typedef GetStateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  Debugger::State state() const {
    return static_cast<Debugger::State>(GetField<uint32_t>(VT_STATE, 0));
  }
  bool mutate_state(Debugger::State _state = static_cast<Debugger::State>(0)) {
    return SetField<uint32_t>(VT_STATE, static_cast<uint32_t>(_state), 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
  GetStateResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetStateResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetStateResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetStateResponseBuilder {
  typedef GetStateResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(Debugger::State state) {
    fbb_.AddElement<uint32_t>(GetStateResponse::VT_STATE, static_cast<uint32_t>(state), 0);
  }
  explicit GetStateResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStateResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStateResponse> CreateGetStateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Debugger::State state = Debugger::State_None) {
  GetStateResponseBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

::flatbuffers::Offset<GetStateResponse> CreateGetStateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PauseRequestT : public ::flatbuffers::NativeTable {
  typedef PauseRequest TableType;
};

struct PauseRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PauseRequestT NativeTableType;
  typedef PauseRequestBuilder Builder;
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PauseRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PauseRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PauseRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PauseRequestBuilder {
  typedef PauseRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PauseRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PauseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PauseRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PauseRequest> CreatePauseRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PauseRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PauseRequest> CreatePauseRequest(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RunRequestT : public ::flatbuffers::NativeTable {
  typedef RunRequest TableType;
  bool single_step = false;
};

struct RunRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunRequestT NativeTableType;
  typedef RunRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SINGLE_STEP = 4
  };
  bool single_step() const {
    return GetField<uint8_t>(VT_SINGLE_STEP, 0) != 0;
  }
  bool mutate_single_step(bool _single_step = 0) {
    return SetField<uint8_t>(VT_SINGLE_STEP, static_cast<uint8_t>(_single_step), 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SINGLE_STEP, 1) &&
           verifier.EndTable();
  }
  RunRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RunRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RunRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RunRequestBuilder {
  typedef RunRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_single_step(bool single_step) {
    fbb_.AddElement<uint8_t>(RunRequest::VT_SINGLE_STEP, static_cast<uint8_t>(single_step), 0);
  }
  explicit RunRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunRequest> CreateRunRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool single_step = false) {
  RunRequestBuilder builder_(_fbb);
  builder_.add_single_step(single_step);
  return builder_.Finish();
}

::flatbuffers::Offset<RunRequest> CreateRunRequest(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteMemoryRequestT : public ::flatbuffers::NativeTable {
  typedef WriteMemoryRequest TableType;
  uint64_t address = 0;
  std::vector<uint8_t> data{};
};

struct WriteMemoryRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteMemoryRequestT NativeTableType;
  typedef WriteMemoryRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_DATA = 6
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  WriteMemoryRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteMemoryRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteMemoryRequestBuilder {
  typedef WriteMemoryRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(WriteMemoryRequest::VT_ADDRESS, address, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteMemoryRequest::VT_DATA, data);
  }
  explicit WriteMemoryRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteMemoryRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteMemoryRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteMemoryRequestBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateWriteMemoryRequest(
      _fbb,
      address,
      data__);
}

::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteMemoryResponseT : public ::flatbuffers::NativeTable {
  typedef WriteMemoryResponse TableType;
  uint64_t address = 0;
  uint32_t size = 0;
  bool success = false;
};

struct WriteMemoryResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteMemoryResponseT NativeTableType;
  typedef WriteMemoryResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6,
    VT_SUCCESS = 8
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success = 0) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  WriteMemoryResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteMemoryResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteMemoryResponseBuilder {
  typedef WriteMemoryResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(WriteMemoryResponse::VT_ADDRESS, address, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(WriteMemoryResponse::VT_SIZE, size, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(WriteMemoryResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit WriteMemoryResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteMemoryResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteMemoryResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteMemoryResponse> CreateWriteMemoryResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t size = 0,
    bool success = false) {
  WriteMemoryResponseBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_size(size);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<WriteMemoryResponse> CreateWriteMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadMemoryRequestT : public ::flatbuffers::NativeTable {
  typedef ReadMemoryRequest TableType;
  uint64_t address = 0;
  uint32_t size = 0;
};

struct ReadMemoryRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadMemoryRequestT NativeTableType;
  typedef ReadMemoryRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  ReadMemoryRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadMemoryRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadMemoryRequestBuilder {
  typedef ReadMemoryRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(ReadMemoryRequest::VT_ADDRESS, address, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(ReadMemoryRequest::VT_SIZE, size, 0);
  }
  explicit ReadMemoryRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadMemoryRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadMemoryRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadMemoryRequest> CreateReadMemoryRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t size = 0) {
  ReadMemoryRequestBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_size(size);
  return builder_.Finish();
}

::flatbuffers::Offset<ReadMemoryRequest> CreateReadMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadMemoryResponseT : public ::flatbuffers::NativeTable {
  typedef ReadMemoryResponse TableType;
  uint64_t address = 0;
  std::vector<uint8_t> data{};
};

struct ReadMemoryResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadMemoryResponseT NativeTableType;
  typedef ReadMemoryResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_DATA = 6
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ReadMemoryResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadMemoryResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadMemoryResponseBuilder {
  typedef ReadMemoryResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(ReadMemoryResponse::VT_ADDRESS, address, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ReadMemoryResponse::VT_DATA, data);
  }
  explicit ReadMemoryResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadMemoryResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadMemoryResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  ReadMemoryResponseBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateReadMemoryResponse(
      _fbb,
      address,
      data__);
}

::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteRegisterRequestT : public ::flatbuffers::NativeTable {
  typedef WriteRegisterRequest TableType;
  uint32_t register_ = 0;
  std::vector<uint8_t> data{};
};

struct WriteRegisterRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteRegisterRequestT NativeTableType;
  typedef WriteRegisterRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4,
    VT_DATA = 6
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  WriteRegisterRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteRegisterRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteRegisterRequestBuilder {
  typedef WriteRegisterRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(WriteRegisterRequest::VT_REGISTER_, register_, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteRegisterRequest::VT_DATA, data);
  }
  explicit WriteRegisterRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteRegisterRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteRegisterRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteRegisterRequestBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_register_(register_);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateWriteRegisterRequest(
      _fbb,
      register_,
      data__);
}

::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteRegisterResponseT : public ::flatbuffers::NativeTable {
  typedef WriteRegisterResponse TableType;
  uint32_t register_ = 0;
  uint32_t size = 0;
  bool success = false;
};

struct WriteRegisterResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteRegisterResponseT NativeTableType;
  typedef WriteRegisterResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4,
    VT_SIZE = 6,
    VT_SUCCESS = 8
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success = 0) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  WriteRegisterResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteRegisterResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteRegisterResponseBuilder {
  typedef WriteRegisterResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(WriteRegisterResponse::VT_REGISTER_, register_, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(WriteRegisterResponse::VT_SIZE, size, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(WriteRegisterResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit WriteRegisterResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteRegisterResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteRegisterResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteRegisterResponse> CreateWriteRegisterResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    uint32_t size = 0,
    bool success = false) {
  WriteRegisterResponseBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_register_(register_);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<WriteRegisterResponse> CreateWriteRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadRegisterRequestT : public ::flatbuffers::NativeTable {
  typedef ReadRegisterRequest TableType;
  uint32_t register_ = 0;
};

struct ReadRegisterRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadRegisterRequestT NativeTableType;
  typedef ReadRegisterRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           verifier.EndTable();
  }
  ReadRegisterRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadRegisterRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadRegisterRequestBuilder {
  typedef ReadRegisterRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(ReadRegisterRequest::VT_REGISTER_, register_, 0);
  }
  explicit ReadRegisterRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadRegisterRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadRegisterRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadRegisterRequest> CreateReadRegisterRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0) {
  ReadRegisterRequestBuilder builder_(_fbb);
  builder_.add_register_(register_);
  return builder_.Finish();
}

::flatbuffers::Offset<ReadRegisterRequest> CreateReadRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadRegisterResponseT : public ::flatbuffers::NativeTable {
  typedef ReadRegisterResponse TableType;
  uint32_t register_ = 0;
  std::vector<uint8_t> data{};
};

struct ReadRegisterResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadRegisterResponseT NativeTableType;
  typedef ReadRegisterResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4,
    VT_DATA = 6
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ReadRegisterResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadRegisterResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadRegisterResponseBuilder {
  typedef ReadRegisterResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(ReadRegisterResponse::VT_REGISTER_, register_, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ReadRegisterResponse::VT_DATA, data);
  }
  explicit ReadRegisterResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadRegisterResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadRegisterResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  ReadRegisterResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_register_(register_);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateReadRegisterResponse(
      _fbb,
      register_,
      data__);
}

::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplicationExitT : public ::flatbuffers::NativeTable {
  typedef ApplicationExit TableType;
  ::flatbuffers::Optional<uint32_t> exit_status = ::flatbuffers::nullopt;
};

struct ApplicationExit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ApplicationExitT NativeTableType;
  typedef ApplicationExitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXIT_STATUS = 4
  };
  ::flatbuffers::Optional<uint32_t> exit_status() const {
    return GetOptional<uint32_t, uint32_t>(VT_EXIT_STATUS);
  }
  bool mutate_exit_status(uint32_t _exit_status) {
    return SetField<uint32_t>(VT_EXIT_STATUS, _exit_status);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EXIT_STATUS, 4) &&
           verifier.EndTable();
  }
  ApplicationExitT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationExitT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ApplicationExit> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationExitBuilder {
  typedef ApplicationExit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_exit_status(uint32_t exit_status) {
    fbb_.AddElement<uint32_t>(ApplicationExit::VT_EXIT_STATUS, exit_status);
  }
  explicit ApplicationExitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ApplicationExit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ApplicationExit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ApplicationExit> CreateApplicationExit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint32_t> exit_status = ::flatbuffers::nullopt) {
  ApplicationExitBuilder builder_(_fbb);
  if(exit_status) { builder_.add_exit_status(*exit_status); }
  return builder_.Finish();
}

::flatbuffers::Offset<ApplicationExit> CreateApplicationExit(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmulationStatusT : public ::flatbuffers::NativeTable {
  typedef EmulationStatus TableType;
  uint32_t active_threads = 0;
  uint64_t reserved_memory = 0;
  uint64_t committed_memory = 0;
  uint64_t executed_instructions = 0;
};

struct EmulationStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmulationStatusT NativeTableType;
  typedef EmulationStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE_THREADS = 4,
    VT_RESERVED_MEMORY = 6,
    VT_COMMITTED_MEMORY = 8,
    VT_EXECUTED_INSTRUCTIONS = 10
  };
  uint32_t active_threads() const {
    return GetField<uint32_t>(VT_ACTIVE_THREADS, 0);
  }
  bool mutate_active_threads(uint32_t _active_threads = 0) {
    return SetField<uint32_t>(VT_ACTIVE_THREADS, _active_threads, 0);
  }
  uint64_t reserved_memory() const {
    return GetField<uint64_t>(VT_RESERVED_MEMORY, 0);
  }
  bool mutate_reserved_memory(uint64_t _reserved_memory = 0) {
    return SetField<uint64_t>(VT_RESERVED_MEMORY, _reserved_memory, 0);
  }
  uint64_t committed_memory() const {
    return GetField<uint64_t>(VT_COMMITTED_MEMORY, 0);
  }
  bool mutate_committed_memory(uint64_t _committed_memory = 0) {
    return SetField<uint64_t>(VT_COMMITTED_MEMORY, _committed_memory, 0);
  }
  uint64_t executed_instructions() const {
    return GetField<uint64_t>(VT_EXECUTED_INSTRUCTIONS, 0);
  }
  bool mutate_executed_instructions(uint64_t _executed_instructions = 0) {
    return SetField<uint64_t>(VT_EXECUTED_INSTRUCTIONS, _executed_instructions, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACTIVE_THREADS, 4) &&
           VerifyField<uint64_t>(verifier, VT_RESERVED_MEMORY, 8) &&
           VerifyField<uint64_t>(verifier, VT_COMMITTED_MEMORY, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXECUTED_INSTRUCTIONS, 8) &&
           verifier.EndTable();
  }
  EmulationStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmulationStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EmulationStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmulationStatusBuilder {
  typedef EmulationStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_active_threads(uint32_t active_threads) {
    fbb_.AddElement<uint32_t>(EmulationStatus::VT_ACTIVE_THREADS, active_threads, 0);
  }
  void add_reserved_memory(uint64_t reserved_memory) {
    fbb_.AddElement<uint64_t>(EmulationStatus::VT_RESERVED_MEMORY, reserved_memory, 0);
  }
  void add_committed_memory(uint64_t committed_memory) {
    fbb_.AddElement<uint64_t>(EmulationStatus::VT_COMMITTED_MEMORY, committed_memory, 0);
  }
  void add_executed_instructions(uint64_t executed_instructions) {
    fbb_.AddElement<uint64_t>(EmulationStatus::VT_EXECUTED_INSTRUCTIONS, executed_instructions, 0);
  }
  explicit EmulationStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmulationStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmulationStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmulationStatus> CreateEmulationStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t active_threads = 0,
    uint64_t reserved_memory = 0,
    uint64_t committed_memory = 0,
    uint64_t executed_instructions = 0) {
  EmulationStatusBuilder builder_(_fbb);
  builder_.add_executed_instructions(executed_instructions);
  builder_.add_committed_memory(committed_memory);
  builder_.add_reserved_memory(reserved_memory);
  builder_.add_active_threads(active_threads);
  return builder_.Finish();
}

::flatbuffers::Offset<EmulationStatus> CreateEmulationStatus(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugEventT : public ::flatbuffers::NativeTable {
  typedef DebugEvent TableType;
  Debugger::EventUnion event{};
};

struct DebugEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DebugEventT NativeTableType;
  typedef DebugEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  Debugger::Event event_type() const {
    return static_cast<Debugger::Event>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const Debugger::PauseRequest *event_as_PauseRequest() const {
    return event_type() == Debugger::Event_PauseRequest ? static_cast<const Debugger::PauseRequest *>(event()) : nullptr;
  }
  const Debugger::RunRequest *event_as_RunRequest() const {
    return event_type() == Debugger::Event_RunRequest ? static_cast<const Debugger::RunRequest *>(event()) : nullptr;
  }
  const Debugger::GetStateRequest *event_as_GetStateRequest() const {
    return event_type() == Debugger::Event_GetStateRequest ? static_cast<const Debugger::GetStateRequest *>(event()) : nullptr;
  }
  const Debugger::GetStateResponse *event_as_GetStateResponse() const {
    return event_type() == Debugger::Event_GetStateResponse ? static_cast<const Debugger::GetStateResponse *>(event()) : nullptr;
  }
  const Debugger::WriteMemoryRequest *event_as_WriteMemoryRequest() const {
    return event_type() == Debugger::Event_WriteMemoryRequest ? static_cast<const Debugger::WriteMemoryRequest *>(event()) : nullptr;
  }
  const Debugger::WriteMemoryResponse *event_as_WriteMemoryResponse() const {
    return event_type() == Debugger::Event_WriteMemoryResponse ? static_cast<const Debugger::WriteMemoryResponse *>(event()) : nullptr;
  }
  const Debugger::ReadMemoryRequest *event_as_ReadMemoryRequest() const {
    return event_type() == Debugger::Event_ReadMemoryRequest ? static_cast<const Debugger::ReadMemoryRequest *>(event()) : nullptr;
  }
  const Debugger::ReadMemoryResponse *event_as_ReadMemoryResponse() const {
    return event_type() == Debugger::Event_ReadMemoryResponse ? static_cast<const Debugger::ReadMemoryResponse *>(event()) : nullptr;
  }
  const Debugger::WriteRegisterRequest *event_as_WriteRegisterRequest() const {
    return event_type() == Debugger::Event_WriteRegisterRequest ? static_cast<const Debugger::WriteRegisterRequest *>(event()) : nullptr;
  }
  const Debugger::WriteRegisterResponse *event_as_WriteRegisterResponse() const {
    return event_type() == Debugger::Event_WriteRegisterResponse ? static_cast<const Debugger::WriteRegisterResponse *>(event()) : nullptr;
  }
  const Debugger::ReadRegisterRequest *event_as_ReadRegisterRequest() const {
    return event_type() == Debugger::Event_ReadRegisterRequest ? static_cast<const Debugger::ReadRegisterRequest *>(event()) : nullptr;
  }
  const Debugger::ReadRegisterResponse *event_as_ReadRegisterResponse() const {
    return event_type() == Debugger::Event_ReadRegisterResponse ? static_cast<const Debugger::ReadRegisterResponse *>(event()) : nullptr;
  }
  const Debugger::ApplicationExit *event_as_ApplicationExit() const {
    return event_type() == Debugger::Event_ApplicationExit ? static_cast<const Debugger::ApplicationExit *>(event()) : nullptr;
  }
  const Debugger::EmulationStatus *event_as_EmulationStatus() const {
    return event_type() == Debugger::Event_EmulationStatus ? static_cast<const Debugger::EmulationStatus *>(event()) : nullptr;
  }
  template<typename T> T *mutable_event_as();
  Debugger::PauseRequest *mutable_event_as_PauseRequest() {
    return event_type() == Debugger::Event_PauseRequest ? static_cast<Debugger::PauseRequest *>(mutable_event()) : nullptr;
  }
  Debugger::RunRequest *mutable_event_as_RunRequest() {
    return event_type() == Debugger::Event_RunRequest ? static_cast<Debugger::RunRequest *>(mutable_event()) : nullptr;
  }
  Debugger::GetStateRequest *mutable_event_as_GetStateRequest() {
    return event_type() == Debugger::Event_GetStateRequest ? static_cast<Debugger::GetStateRequest *>(mutable_event()) : nullptr;
  }
  Debugger::GetStateResponse *mutable_event_as_GetStateResponse() {
    return event_type() == Debugger::Event_GetStateResponse ? static_cast<Debugger::GetStateResponse *>(mutable_event()) : nullptr;
  }
  Debugger::WriteMemoryRequest *mutable_event_as_WriteMemoryRequest() {
    return event_type() == Debugger::Event_WriteMemoryRequest ? static_cast<Debugger::WriteMemoryRequest *>(mutable_event()) : nullptr;
  }
  Debugger::WriteMemoryResponse *mutable_event_as_WriteMemoryResponse() {
    return event_type() == Debugger::Event_WriteMemoryResponse ? static_cast<Debugger::WriteMemoryResponse *>(mutable_event()) : nullptr;
  }
  Debugger::ReadMemoryRequest *mutable_event_as_ReadMemoryRequest() {
    return event_type() == Debugger::Event_ReadMemoryRequest ? static_cast<Debugger::ReadMemoryRequest *>(mutable_event()) : nullptr;
  }
  Debugger::ReadMemoryResponse *mutable_event_as_ReadMemoryResponse() {
    return event_type() == Debugger::Event_ReadMemoryResponse ? static_cast<Debugger::ReadMemoryResponse *>(mutable_event()) : nullptr;
  }
  Debugger::WriteRegisterRequest *mutable_event_as_WriteRegisterRequest() {
    return event_type() == Debugger::Event_WriteRegisterRequest ? static_cast<Debugger::WriteRegisterRequest *>(mutable_event()) : nullptr;
  }
  Debugger::WriteRegisterResponse *mutable_event_as_WriteRegisterResponse() {
    return event_type() == Debugger::Event_WriteRegisterResponse ? static_cast<Debugger::WriteRegisterResponse *>(mutable_event()) : nullptr;
  }
  Debugger::ReadRegisterRequest *mutable_event_as_ReadRegisterRequest() {
    return event_type() == Debugger::Event_ReadRegisterRequest ? static_cast<Debugger::ReadRegisterRequest *>(mutable_event()) : nullptr;
  }
  Debugger::ReadRegisterResponse *mutable_event_as_ReadRegisterResponse() {
    return event_type() == Debugger::Event_ReadRegisterResponse ? static_cast<Debugger::ReadRegisterResponse *>(mutable_event()) : nullptr;
  }
  Debugger::ApplicationExit *mutable_event_as_ApplicationExit() {
    return event_type() == Debugger::Event_ApplicationExit ? static_cast<Debugger::ApplicationExit *>(mutable_event()) : nullptr;
  }
  Debugger::EmulationStatus *mutable_event_as_EmulationStatus() {
    return event_type() == Debugger::Event_EmulationStatus ? static_cast<Debugger::EmulationStatus *>(mutable_event()) : nullptr;
  }
  void *mutable_event() {
    return GetPointer<void *>(VT_EVENT);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvent(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  DebugEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DebugEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Debugger::PauseRequest *DebugEvent::event_as<Debugger::PauseRequest>() const {
  return event_as_PauseRequest();
}

template<> inline Debugger::PauseRequest *DebugEvent::mutable_event_as<Debugger::PauseRequest>() {
  return mutable_event_as_PauseRequest();
}

template<> inline const Debugger::RunRequest *DebugEvent::event_as<Debugger::RunRequest>() const {
  return event_as_RunRequest();
}

template<> inline Debugger::RunRequest *DebugEvent::mutable_event_as<Debugger::RunRequest>() {
  return mutable_event_as_RunRequest();
}

template<> inline const Debugger::GetStateRequest *DebugEvent::event_as<Debugger::GetStateRequest>() const {
  return event_as_GetStateRequest();
}

template<> inline Debugger::GetStateRequest *DebugEvent::mutable_event_as<Debugger::GetStateRequest>() {
  return mutable_event_as_GetStateRequest();
}

template<> inline const Debugger::GetStateResponse *DebugEvent::event_as<Debugger::GetStateResponse>() const {
  return event_as_GetStateResponse();
}

template<> inline Debugger::GetStateResponse *DebugEvent::mutable_event_as<Debugger::GetStateResponse>() {
  return mutable_event_as_GetStateResponse();
}

template<> inline const Debugger::WriteMemoryRequest *DebugEvent::event_as<Debugger::WriteMemoryRequest>() const {
  return event_as_WriteMemoryRequest();
}

template<> inline Debugger::WriteMemoryRequest *DebugEvent::mutable_event_as<Debugger::WriteMemoryRequest>() {
  return mutable_event_as_WriteMemoryRequest();
}

template<> inline const Debugger::WriteMemoryResponse *DebugEvent::event_as<Debugger::WriteMemoryResponse>() const {
  return event_as_WriteMemoryResponse();
}

template<> inline Debugger::WriteMemoryResponse *DebugEvent::mutable_event_as<Debugger::WriteMemoryResponse>() {
  return mutable_event_as_WriteMemoryResponse();
}

template<> inline const Debugger::ReadMemoryRequest *DebugEvent::event_as<Debugger::ReadMemoryRequest>() const {
  return event_as_ReadMemoryRequest();
}

template<> inline Debugger::ReadMemoryRequest *DebugEvent::mutable_event_as<Debugger::ReadMemoryRequest>() {
  return mutable_event_as_ReadMemoryRequest();
}

template<> inline const Debugger::ReadMemoryResponse *DebugEvent::event_as<Debugger::ReadMemoryResponse>() const {
  return event_as_ReadMemoryResponse();
}

template<> inline Debugger::ReadMemoryResponse *DebugEvent::mutable_event_as<Debugger::ReadMemoryResponse>() {
  return mutable_event_as_ReadMemoryResponse();
}

template<> inline const Debugger::WriteRegisterRequest *DebugEvent::event_as<Debugger::WriteRegisterRequest>() const {
  return event_as_WriteRegisterRequest();
}

template<> inline Debugger::WriteRegisterRequest *DebugEvent::mutable_event_as<Debugger::WriteRegisterRequest>() {
  return mutable_event_as_WriteRegisterRequest();
}

template<> inline const Debugger::WriteRegisterResponse *DebugEvent::event_as<Debugger::WriteRegisterResponse>() const {
  return event_as_WriteRegisterResponse();
}

template<> inline Debugger::WriteRegisterResponse *DebugEvent::mutable_event_as<Debugger::WriteRegisterResponse>() {
  return mutable_event_as_WriteRegisterResponse();
}

template<> inline const Debugger::ReadRegisterRequest *DebugEvent::event_as<Debugger::ReadRegisterRequest>() const {
  return event_as_ReadRegisterRequest();
}

template<> inline Debugger::ReadRegisterRequest *DebugEvent::mutable_event_as<Debugger::ReadRegisterRequest>() {
  return mutable_event_as_ReadRegisterRequest();
}

template<> inline const Debugger::ReadRegisterResponse *DebugEvent::event_as<Debugger::ReadRegisterResponse>() const {
  return event_as_ReadRegisterResponse();
}

template<> inline Debugger::ReadRegisterResponse *DebugEvent::mutable_event_as<Debugger::ReadRegisterResponse>() {
  return mutable_event_as_ReadRegisterResponse();
}

template<> inline const Debugger::ApplicationExit *DebugEvent::event_as<Debugger::ApplicationExit>() const {
  return event_as_ApplicationExit();
}

template<> inline Debugger::ApplicationExit *DebugEvent::mutable_event_as<Debugger::ApplicationExit>() {
  return mutable_event_as_ApplicationExit();
}

template<> inline const Debugger::EmulationStatus *DebugEvent::event_as<Debugger::EmulationStatus>() const {
  return event_as_EmulationStatus();
}

template<> inline Debugger::EmulationStatus *DebugEvent::mutable_event_as<Debugger::EmulationStatus>() {
  return mutable_event_as_EmulationStatus();
}

struct DebugEventBuilder {
  typedef DebugEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(Debugger::Event event_type) {
    fbb_.AddElement<uint8_t>(DebugEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(DebugEvent::VT_EVENT, event);
  }
  explicit DebugEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DebugEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DebugEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DebugEvent> CreateDebugEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Debugger::Event event_type = Debugger::Event_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  DebugEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

::flatbuffers::Offset<DebugEvent> CreateDebugEvent(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GetStateRequestT *GetStateRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetStateRequestT>(new GetStateRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetStateRequest::UnPackTo(GetStateRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<GetStateRequest> CreateGetStateRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return GetStateRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetStateRequest> GetStateRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetStateRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return Debugger::CreateGetStateRequest(
      _fbb);
}

inline GetStateResponseT *GetStateResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetStateResponseT>(new GetStateResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetStateResponse::UnPackTo(GetStateResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<GetStateResponse> CreateGetStateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return GetStateResponse::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetStateResponse> GetStateResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetStateResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state;
  return Debugger::CreateGetStateResponse(
      _fbb,
      _state);
}

inline PauseRequestT *PauseRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PauseRequestT>(new PauseRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PauseRequest::UnPackTo(PauseRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PauseRequest> CreatePauseRequest(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return PauseRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PauseRequest> PauseRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PauseRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return Debugger::CreatePauseRequest(
      _fbb);
}

inline RunRequestT *RunRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RunRequestT>(new RunRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RunRequest::UnPackTo(RunRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = single_step(); _o->single_step = _e; }
}

inline ::flatbuffers::Offset<RunRequest> CreateRunRequest(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return RunRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RunRequest> RunRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RunRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _single_step = _o->single_step;
  return Debugger::CreateRunRequest(
      _fbb,
      _single_step);
}

inline WriteMemoryRequestT *WriteMemoryRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteMemoryRequestT>(new WriteMemoryRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteMemoryRequest::UnPackTo(WriteMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return WriteMemoryRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteMemoryRequest> WriteMemoryRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteMemoryRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateWriteMemoryRequest(
      _fbb,
      _address,
      _data);
}

inline WriteMemoryResponseT *WriteMemoryResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteMemoryResponseT>(new WriteMemoryResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteMemoryResponse::UnPackTo(WriteMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<WriteMemoryResponse> CreateWriteMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return WriteMemoryResponse::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteMemoryResponse> WriteMemoryResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteMemoryResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _size = _o->size;
  auto _success = _o->success;
  return Debugger::CreateWriteMemoryResponse(
      _fbb,
      _address,
      _size,
      _success);
}

inline ReadMemoryRequestT *ReadMemoryRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadMemoryRequestT>(new ReadMemoryRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadMemoryRequest::UnPackTo(ReadMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline ::flatbuffers::Offset<ReadMemoryRequest> CreateReadMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ReadMemoryRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadMemoryRequest> ReadMemoryRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadMemoryRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _size = _o->size;
  return Debugger::CreateReadMemoryRequest(
      _fbb,
      _address,
      _size);
}

inline ReadMemoryResponseT *ReadMemoryResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadMemoryResponseT>(new ReadMemoryResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadMemoryResponse::UnPackTo(ReadMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ReadMemoryResponse::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadMemoryResponse> ReadMemoryResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadMemoryResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateReadMemoryResponse(
      _fbb,
      _address,
      _data);
}

inline WriteRegisterRequestT *WriteRegisterRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteRegisterRequestT>(new WriteRegisterRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteRegisterRequest::UnPackTo(WriteRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return WriteRegisterRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteRegisterRequest> WriteRegisterRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteRegisterRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateWriteRegisterRequest(
      _fbb,
      _register_,
      _data);
}

inline WriteRegisterResponseT *WriteRegisterResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteRegisterResponseT>(new WriteRegisterResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteRegisterResponse::UnPackTo(WriteRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<WriteRegisterResponse> CreateWriteRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return WriteRegisterResponse::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteRegisterResponse> WriteRegisterResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteRegisterResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  auto _size = _o->size;
  auto _success = _o->success;
  return Debugger::CreateWriteRegisterResponse(
      _fbb,
      _register_,
      _size,
      _success);
}

inline ReadRegisterRequestT *ReadRegisterRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadRegisterRequestT>(new ReadRegisterRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadRegisterRequest::UnPackTo(ReadRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
}

inline ::flatbuffers::Offset<ReadRegisterRequest> CreateReadRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ReadRegisterRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadRegisterRequest> ReadRegisterRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadRegisterRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  return Debugger::CreateReadRegisterRequest(
      _fbb,
      _register_);
}

inline ReadRegisterResponseT *ReadRegisterResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadRegisterResponseT>(new ReadRegisterResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadRegisterResponse::UnPackTo(ReadRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ReadRegisterResponse::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadRegisterResponse> ReadRegisterResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadRegisterResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateReadRegisterResponse(
      _fbb,
      _register_,
      _data);
}

inline ApplicationExitT *ApplicationExit::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplicationExitT>(new ApplicationExitT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplicationExit::UnPackTo(ApplicationExitT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exit_status(); _o->exit_status = _e; }
}

inline ::flatbuffers::Offset<ApplicationExit> CreateApplicationExit(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ApplicationExit::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ApplicationExit> ApplicationExit::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ApplicationExitT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exit_status = _o->exit_status;
  return Debugger::CreateApplicationExit(
      _fbb,
      _exit_status);
}

inline EmulationStatusT *EmulationStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmulationStatusT>(new EmulationStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmulationStatus::UnPackTo(EmulationStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = active_threads(); _o->active_threads = _e; }
  { auto _e = reserved_memory(); _o->reserved_memory = _e; }
  { auto _e = committed_memory(); _o->committed_memory = _e; }
  { auto _e = executed_instructions(); _o->executed_instructions = _e; }
}

inline ::flatbuffers::Offset<EmulationStatus> CreateEmulationStatus(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return EmulationStatus::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EmulationStatus> EmulationStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EmulationStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _active_threads = _o->active_threads;
  auto _reserved_memory = _o->reserved_memory;
  auto _committed_memory = _o->committed_memory;
  auto _executed_instructions = _o->executed_instructions;
  return Debugger::CreateEmulationStatus(
      _fbb,
      _active_threads,
      _reserved_memory,
      _committed_memory,
      _executed_instructions);
}

inline DebugEventT *DebugEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DebugEventT>(new DebugEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugEvent::UnPackTo(DebugEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); _o->event.type = _e; }
  { auto _e = event(); if (_e) _o->event.value = Debugger::EventUnion::UnPack(_e, event_type(), _resolver); }
}

inline ::flatbuffers::Offset<DebugEvent> CreateDebugEvent(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return DebugEvent::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DebugEvent> DebugEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DebugEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return Debugger::CreateDebugEvent(
      _fbb,
      _event_type,
      _event);
}

template <bool B>
inline bool VerifyEvent(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, Event type) {
  switch (type) {
    case Event_NONE: {
      return true;
    }
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<const Debugger::PauseRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<const Debugger::RunRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<const Debugger::GetStateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<const Debugger::GetStateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<const Debugger::ApplicationExit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<const Debugger::EmulationStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyEventVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvent(
        verifier,  values->Get(i), types->GetEnum<Event>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventUnion::UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<const Debugger::PauseRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<const Debugger::RunRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<const Debugger::GetStateRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<const Debugger::GetStateResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<const Debugger::ApplicationExit *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<const Debugger::EmulationStatus *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> EventUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<const Debugger::PauseRequestT *>(value);
      return CreatePauseRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<const Debugger::RunRequestT *>(value);
      return CreateRunRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<const Debugger::GetStateRequestT *>(value);
      return CreateGetStateRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<const Debugger::GetStateResponseT *>(value);
      return CreateGetStateResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryRequestT *>(value);
      return CreateWriteMemoryRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryResponseT *>(value);
      return CreateWriteMemoryResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryRequestT *>(value);
      return CreateReadMemoryRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryResponseT *>(value);
      return CreateReadMemoryResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterRequestT *>(value);
      return CreateWriteRegisterRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterResponseT *>(value);
      return CreateWriteRegisterResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterRequestT *>(value);
      return CreateReadRegisterRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterResponseT *>(value);
      return CreateReadRegisterResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<const Debugger::ApplicationExitT *>(value);
      return CreateApplicationExit(_fbb, ptr, _rehasher).Union();
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<const Debugger::EmulationStatusT *>(value);
      return CreateEmulationStatus(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventUnion::EventUnion(const EventUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Event_PauseRequest: {
      value = new Debugger::PauseRequestT(*reinterpret_cast<Debugger::PauseRequestT *>(u.value));
      break;
    }
    case Event_RunRequest: {
      value = new Debugger::RunRequestT(*reinterpret_cast<Debugger::RunRequestT *>(u.value));
      break;
    }
    case Event_GetStateRequest: {
      value = new Debugger::GetStateRequestT(*reinterpret_cast<Debugger::GetStateRequestT *>(u.value));
      break;
    }
    case Event_GetStateResponse: {
      value = new Debugger::GetStateResponseT(*reinterpret_cast<Debugger::GetStateResponseT *>(u.value));
      break;
    }
    case Event_WriteMemoryRequest: {
      value = new Debugger::WriteMemoryRequestT(*reinterpret_cast<Debugger::WriteMemoryRequestT *>(u.value));
      break;
    }
    case Event_WriteMemoryResponse: {
      value = new Debugger::WriteMemoryResponseT(*reinterpret_cast<Debugger::WriteMemoryResponseT *>(u.value));
      break;
    }
    case Event_ReadMemoryRequest: {
      value = new Debugger::ReadMemoryRequestT(*reinterpret_cast<Debugger::ReadMemoryRequestT *>(u.value));
      break;
    }
    case Event_ReadMemoryResponse: {
      value = new Debugger::ReadMemoryResponseT(*reinterpret_cast<Debugger::ReadMemoryResponseT *>(u.value));
      break;
    }
    case Event_WriteRegisterRequest: {
      value = new Debugger::WriteRegisterRequestT(*reinterpret_cast<Debugger::WriteRegisterRequestT *>(u.value));
      break;
    }
    case Event_WriteRegisterResponse: {
      value = new Debugger::WriteRegisterResponseT(*reinterpret_cast<Debugger::WriteRegisterResponseT *>(u.value));
      break;
    }
    case Event_ReadRegisterRequest: {
      value = new Debugger::ReadRegisterRequestT(*reinterpret_cast<Debugger::ReadRegisterRequestT *>(u.value));
      break;
    }
    case Event_ReadRegisterResponse: {
      value = new Debugger::ReadRegisterResponseT(*reinterpret_cast<Debugger::ReadRegisterResponseT *>(u.value));
      break;
    }
    case Event_ApplicationExit: {
      value = new Debugger::ApplicationExitT(*reinterpret_cast<Debugger::ApplicationExitT *>(u.value));
      break;
    }
    case Event_EmulationStatus: {
      value = new Debugger::EmulationStatusT(*reinterpret_cast<Debugger::EmulationStatusT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventUnion::Reset() {
  switch (type) {
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<Debugger::PauseRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<Debugger::RunRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<Debugger::GetStateRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<Debugger::GetStateResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<Debugger::WriteMemoryRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<Debugger::WriteMemoryResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<Debugger::ReadMemoryRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<Debugger::ReadMemoryResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<Debugger::WriteRegisterRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<Debugger::WriteRegisterResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<Debugger::ReadRegisterRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<Debugger::ReadRegisterResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<Debugger::ApplicationExitT *>(value);
      delete ptr;
      break;
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<Debugger::EmulationStatusT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Event_NONE;
}

inline const Debugger::DebugEvent *GetDebugEvent(const void *buf) {
  return ::flatbuffers::GetRoot<Debugger::DebugEvent>(buf);
}

inline const Debugger::DebugEvent *GetSizePrefixedDebugEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Debugger::DebugEvent>(buf);
}

inline DebugEvent *GetMutableDebugEvent(void *buf) {
  return ::flatbuffers::GetMutableRoot<DebugEvent>(buf);
}

inline Debugger::DebugEvent *GetMutableSizePrefixedDebugEvent(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Debugger::DebugEvent>(buf);
}

template <bool B = false>
inline bool VerifyDebugEventBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<Debugger::DebugEvent>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedDebugEventBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<Debugger::DebugEvent>(nullptr);
}

inline void FinishDebugEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Debugger::DebugEvent> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDebugEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Debugger::DebugEvent> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Debugger::DebugEventT> UnPackDebugEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Debugger::DebugEventT>(GetDebugEvent(buf)->UnPack(res));
}

inline std::unique_ptr<Debugger::DebugEventT> UnPackSizePrefixedDebugEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Debugger::DebugEventT>(GetSizePrefixedDebugEvent(buf)->UnPack(res));
}

}  // namespace Debugger

#endif  // FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_

```

`src/debugger/message_transmitter.cpp`:

```cpp
#include "message_transmitter.hpp"
#include <platform/compiler.hpp>

#include <thread>

#include <utils/finally.hpp>
#ifdef OS_EMSCRIPTEN
#include <emscripten.h>
#endif

using namespace std::literals;

namespace debugger
{
    void send_message(const std::string& message)
    {
#ifdef OS_EMSCRIPTEN
        // clang-format off
        EM_ASM_({
                handleMessage(UTF8ToString($0));
        }, message.c_str());
        // clang-format on
#else
        (void)message;
#endif
    }

    std::string receive_message()
    {
#ifdef OS_EMSCRIPTEN
        // clang-format off
        auto* ptr = EM_ASM_PTR({
            var message = getMessageFromQueue();
            if (!message || message.length == 0)
            {
                return 0;
            }

            const length = lengthBytesUTF8(message) + 1;
            const buffer = _malloc(length);
            stringToUTF8(message, buffer, length);
            return buffer;
        });
        // clang-format on

        if (!ptr)
        {
            return {};
        }

        const auto _ = utils::finally([&] {
            free(ptr); //
        });

        return {reinterpret_cast<const char*>(ptr)};
#else
        return {};
#endif
    }

    void suspend_execution(const std::chrono::milliseconds ms)
    {
#ifdef OS_EMSCRIPTEN
        emscripten_sleep(static_cast<uint32_t>(ms.count()));
#else
        if (ms > 0ms)
        {
            std::this_thread::sleep_for(ms);
        }
        else
        {
            std::this_thread::yield();
        }
#endif
    }
}

```

`src/debugger/message_transmitter.hpp`:

```hpp
#pragma once

#include <chrono>
#include <string>

namespace debugger
{
    void suspend_execution(std::chrono::milliseconds ms = std::chrono::milliseconds(0));
    void send_message(const std::string& message);
    std::string receive_message();
}

```

`src/emulator/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(emulator ${SRC_FILES})

target_link_libraries(emulator PUBLIC emulator-common)
target_include_directories(emulator INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

```

`src/emulator/address_utils.hpp`:

```hpp
#pragma once
#include <cstdint>

template <typename T>
T* offset_pointer(void* data, const size_t offset)
{
    return reinterpret_cast<T*>(static_cast<uint8_t*>(data) + offset);
}

template <typename T>
const T* offset_pointer(const void* data, const size_t offset)
{
    return reinterpret_cast<const T*>(static_cast<const uint8_t*>(data) + offset);
}

constexpr bool is_within_start_and_end(const uint64_t value, const uint64_t start, const uint64_t end)
{
    return value >= start && value < end;
}

constexpr bool is_within_start_and_length(const uint64_t value, const uint64_t start, const uint64_t length)
{
    return is_within_start_and_end(value, start, start + length);
}

constexpr bool regions_intersect(const uint64_t start1, const uint64_t end1, const uint64_t start2, const uint64_t end2)
{
    return start1 < end2 && start2 < end1;
}

constexpr bool regions_with_length_intersect(const uint64_t start1, const uint64_t length1, const uint64_t start2, const uint64_t length2)
{
    return regions_intersect(start1, start1 + length1, start2, start2 + length2);
}

constexpr uint64_t align_down(const uint64_t value, const uint64_t alignment)
{
    return value & ~(alignment - 1);
}

constexpr uint64_t align_up(const uint64_t value, const uint64_t alignment)
{
    return align_down(value + (alignment - 1), alignment);
}

constexpr uint64_t page_align_down(const uint64_t value, const uint64_t page_size = 0x1000)
{
    return align_down(value, page_size);
}

constexpr uint64_t page_align_up(const uint64_t value, const uint64_t page_size = 0x1000)
{
    return align_up(value, page_size);
}

constexpr uint64_t rva_to_file_offset(uint64_t va_base, uint64_t raw_base, uint64_t rva)
{
    return rva - (va_base - raw_base);
}

```

`src/emulator/arch_emulator.hpp`:

```hpp
/*
Design notes:

1. emulator:               the root interface (provides CPU, memory, and hook interfaces).
2. typed_emulator<Traits>: a template that adapts to architecture/bitness via the Traits struct.
3. arch_emulator<Traits>:  a thin layer for architecture-specific logic, things that are shared by all x86 (32/64), or
                           all ARM (32/64), etc.
X. x86_emulator<Traits>:   x86_emulator<Traits> are specialisations for
                           x86 and ARM, parameterised by their respective traits (e.g., x86_64_traits) and stuff :)

1. emulator (cpu_interface, memory_interface, hook_interface)
2.  â””â”€â”€ typed_emulator<address_t, register_t, ...>
3.         â””â”€â”€ arch_emulator<arch_traits>
              â”œâ”€â”€ x86_emulator<x86_32_traits>
              â”œâ”€â”€ x86_emulator<x86_64_traits>
              â”œâ”€â”€ arm_emulator<arm_32_traits>
              â””â”€â”€ arm_emulator<arm_64_traits>
*/

#pragma once
#include "typed_emulator.hpp"
#include "x86_register.hpp"

// --[Core]--------------------------------------------------------------------------

template <typename Traits>
struct arch_emulator : typed_emulator<Traits>
{
};

template <typename Traits>
struct x86_emulator : arch_emulator<Traits>
{
    using register_type = typename Traits::register_type;
    using pointer_type = typename Traits::pointer_type;

    virtual void set_segment_base(register_type base, pointer_type value) = 0;
    virtual pointer_type get_segment_base(register_type base) = 0;
    virtual void load_gdt(pointer_type address, uint32_t limit) = 0;
};

template <typename Traits>
struct arm_emulator : arch_emulator<Traits>
{
};

enum class x86_hookable_instructions
{
    invalid, // TODO: Get rid of that
    syscall,
    cpuid,
    rdtsc,
    rdtscp,
};

// --[x86_64]-------------------------------------------------------------------------

struct x86_64_traits
{
    using pointer_type = uint64_t;
    using register_type = x86_register;
    static constexpr register_type instruction_pointer = x86_register::rip;
    static constexpr register_type stack_pointer = x86_register::rsp;
    using hookable_instructions = x86_hookable_instructions;
};

using x86_64_emulator = x86_emulator<x86_64_traits>;

```

`src/emulator/binary_writer.hpp`:

```hpp
#pragma once

namespace utils
{
    template <typename Traits>
    class aligned_binary_writer;

    template <typename T, typename Traits>
    concept Writable = requires(const T ac, aligned_binary_writer<Traits>& writer) {
        { ac.write(writer) } -> std::same_as<void>;
    };

    template <typename Traits>
    class aligned_binary_writer
    {
      public:
        aligned_binary_writer(memory_interface& mem, uint64_t address)
            : memory(mem),
              base_address(address),
              current_position(address)
        {
        }

        void write(const void* data, size_t size, size_t alignment = 1)
        {
            align_to(alignment);
            memory.write_memory(current_position, data, size);
            current_position += size;
        }

        template <typename T>
            requires(!is_optional<T>::value)
        void write(const T& value)
        {
            constexpr auto is_trivially_copyable = std::is_trivially_copyable_v<T>;

            if constexpr (Writable<T, Traits>)
            {
                value.write(*this);
            }
            else if constexpr (is_trivially_copyable)
            {
                write(&value, sizeof(T), alignof(T));
            }
            else
            {
                static_assert(std::is_trivially_copyable_v<T>, "Type must be trivially copyable or be writable!");
                std::abort();
            }
        }

        void write_ndr_pointer(bool not_null)
        {
            write<typename Traits::PVOID>(not_null ? 0x20000 : 0);
        }

        void write_ndr_u16string(const std::u16string& str)
        {
            size_t char_count = str.size() + 1;
            size_t byte_length = char_count * sizeof(char16_t);

            write<typename Traits::SIZE_T>(char_count);
            write<typename Traits::SIZE_T>(0);
            write<typename Traits::SIZE_T>(char_count);
            write(str.c_str(), byte_length);
        }

        void pad(size_t count)
        {
            std::vector<uint8_t> padding(count, 0);
            write(padding.data(), count);
        }

        void align_to(size_t alignment)
        {
            size_t offset_val = static_cast<size_t>(current_position) % alignment;
            if (offset_val != 0)
            {
                pad(alignment - offset_val);
            }
        }

        uint64_t position() const
        {
            return current_position;
        }

        uint64_t offset() const
        {
            return current_position - base_address;
        }

      private:
        memory_interface& memory; // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
        uint64_t base_address;
        uint64_t current_position;
    };
}

```

`src/emulator/cpu_interface.hpp`:

```hpp
#pragma once

#include <chrono>
#include <cstdint>
#include <cstddef>
#include <vector>

struct cpu_interface
{
    virtual ~cpu_interface() = default;

    struct descriptor_table_register
    {
        uint64_t base{};
        uint32_t limit{};
    };

    virtual bool read_descriptor_table(int reg, descriptor_table_register& table) = 0;

    virtual void start(size_t count = 0) = 0;
    virtual void stop() = 0;

    virtual size_t read_raw_register(int reg, void* value, size_t size) = 0;
    virtual size_t write_raw_register(int reg, const void* value, size_t size) = 0;

    virtual std::vector<std::byte> save_registers() const = 0;
    virtual void restore_registers(const std::vector<std::byte>& register_data) = 0;

    // TODO: Remove this
    virtual bool has_violation() const = 0;
};

```

`src/emulator/emulator.hpp`:

```hpp
#pragma once

#include "cpu_interface.hpp"
#include "hook_interface.hpp"
#include "memory_interface.hpp"

#include "serialization.hpp"

class emulator : public cpu_interface, public memory_interface, public hook_interface
{
  public:
    emulator() = default;
    ~emulator() override = default;

    emulator(const emulator&) = delete;
    emulator& operator=(const emulator&) = delete;

    emulator(emulator&&) = delete;
    emulator& operator=(emulator&&) = delete;

    virtual std::string get_name() const = 0;

    virtual void serialize_state(utils::buffer_serializer& buffer, bool is_snapshot) const = 0;
    virtual void deserialize_state(utils::buffer_deserializer& buffer, bool is_snapshot) = 0;
};

```

`src/emulator/hook_interface.hpp`:

```hpp
#pragma once

#include "memory_permission.hpp"

#include <cstddef>
#include <cassert>
#include <functional>

struct emulator_hook;

using memory_operation = memory_permission;

enum class instruction_hook_continuation : bool
{
    run_instruction = false,
    skip_instruction = true,
};

enum class memory_violation_continuation : uint8_t
{
    stop,
    resume,
    restart,
};

enum class memory_violation_type : uint8_t
{
    unmapped,
    protection,
};

struct basic_block
{
    uint64_t address;
    size_t instruction_count;
    size_t size;
};

using edge_generation_hook_callback = std::function<void(const basic_block& current_block, const basic_block& previous_block)>;
using basic_block_hook_callback = std::function<void(const basic_block& block)>;

using simple_instruction_hook_callback = std::function<instruction_hook_continuation()>;
using instruction_hook_callback = std::function<instruction_hook_continuation(uint64_t data)>;
using interrupt_hook_callback = std::function<void(int interrupt)>;

using memory_access_hook_callback = std::function<void(uint64_t address, const void* data, size_t size)>;
using memory_execution_hook_callback = std::function<void(uint64_t address)>;

using memory_violation_hook_callback =
    std::function<memory_violation_continuation(uint64_t address, size_t size, memory_operation operation, memory_violation_type type)>;

class hook_interface
{
  public:
    virtual ~hook_interface() = default;

    virtual emulator_hook* hook_memory_execution(memory_execution_hook_callback callback) = 0;
    virtual emulator_hook* hook_memory_execution(uint64_t address, memory_execution_hook_callback callback) = 0;
    virtual emulator_hook* hook_memory_read(uint64_t address, uint64_t size, memory_access_hook_callback callback) = 0;
    virtual emulator_hook* hook_memory_write(uint64_t address, uint64_t size, memory_access_hook_callback callback) = 0;

    virtual emulator_hook* hook_instruction(int instruction_type, instruction_hook_callback callback) = 0;

    virtual emulator_hook* hook_interrupt(interrupt_hook_callback callback) = 0;
    virtual emulator_hook* hook_memory_violation(memory_violation_hook_callback callback) = 0;

    virtual emulator_hook* hook_basic_block(basic_block_hook_callback callback) = 0;

    virtual void delete_hook(emulator_hook* hook) = 0;
};

```

`src/emulator/memory_interface.hpp`:

```hpp
#pragma once
#include <vector>
#include <functional>

#include "memory_permission.hpp"

using mmio_read_callback = std::function<void(uint64_t addr, void* data, size_t size)>;
using mmio_write_callback = std::function<void(uint64_t addr, const void* data, size_t size)>;

class memory_manager;

class memory_interface
{
  public:
    friend memory_manager;

    virtual ~memory_interface() = default;

    virtual void read_memory(uint64_t address, void* data, size_t size) const = 0;
    virtual bool try_read_memory(uint64_t address, void* data, size_t size) const = 0;
    virtual void write_memory(uint64_t address, const void* data, size_t size) = 0;
    virtual bool try_write_memory(uint64_t address, const void* data, size_t size) = 0;

  private:
    virtual void map_mmio(uint64_t address, size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb) = 0;
    virtual void map_memory(uint64_t address, size_t size, memory_permission permissions) = 0;
    virtual void unmap_memory(uint64_t address, size_t size) = 0;

    virtual void apply_memory_protection(uint64_t address, size_t size, memory_permission permissions) = 0;

  public:
    template <typename T>
    T read_memory(const uint64_t address) const
    {
        T value{};
        this->read_memory(address, &value, sizeof(value));
        return value;
    }

    template <typename T>
    T read_memory(const void* address) const
    {
        return this->read_memory<T>(reinterpret_cast<uint64_t>(address));
    }

    std::vector<std::byte> read_memory(const uint64_t address, const size_t size) const
    {
        std::vector<std::byte> data{};
        data.resize(size);

        this->read_memory(address, data.data(), data.size());

        return data;
    }

    std::vector<std::byte> read_memory(const void* address, const size_t size) const
    {
        return this->read_memory(reinterpret_cast<uint64_t>(address), size);
    }

    template <typename T>
    void write_memory(const uint64_t address, const T& value)
    {
        this->write_memory(address, &value, sizeof(value));
    }

    template <typename T>
    void write_memory(void* address, const T& value)
    {
        this->write_memory(reinterpret_cast<uint64_t>(address), &value, sizeof(value));
    }

    void write_memory(void* address, const void* data, const size_t size)
    {
        this->write_memory(reinterpret_cast<uint64_t>(address), data, size);
    }
};

```

`src/emulator/memory_permission.hpp`:

```hpp
#pragma once
#include <cstdint>

enum class memory_permission : uint8_t
{
    none = 0,
    read = 1 << 0,
    write = 1 << 1,
    exec = 1 << 2,
    read_write = read | write,
    all = read | write | exec
};

/*****************************************************************************
 *
 ****************************************************************************/

constexpr memory_permission operator&(const memory_permission x, const memory_permission y)
{
    return static_cast<memory_permission>(static_cast<uint8_t>(x) & static_cast<uint8_t>(y));
}

constexpr memory_permission operator|(const memory_permission x, const memory_permission y)
{
    return static_cast<memory_permission>(static_cast<uint8_t>(x) | static_cast<uint8_t>(y));
}

constexpr memory_permission operator^(const memory_permission x, const memory_permission y)
{
    return static_cast<memory_permission>(static_cast<uint8_t>(x) ^ static_cast<uint8_t>(y));
}

constexpr memory_permission operator~(memory_permission x)
{
    return static_cast<memory_permission>(~static_cast<uint8_t>(x));
}

inline memory_permission& operator&=(memory_permission& x, const memory_permission y)
{
    x = x & y;
    return x;
}

inline memory_permission& operator|=(memory_permission& x, const memory_permission y)
{
    x = x | y;
    return x;
}

inline memory_permission& operator^=(memory_permission& x, const memory_permission y)
{
    x = x ^ y;
    return x;
}

/*****************************************************************************
 *
 ****************************************************************************/

inline bool is_executable(const memory_permission permission)
{
    return (permission & memory_permission::exec) != memory_permission::none;
}

inline bool is_readable(const memory_permission permission)
{
    return (permission & memory_permission::read) != memory_permission::none;
}

inline bool is_writable(const memory_permission permission)
{
    return (permission & memory_permission::write) != memory_permission::none;
}

```

`src/emulator/memory_region.hpp`:

```hpp
#pragma once
#include "memory_permission.hpp"
#include <cstddef>

template <typename PermissionType = memory_permission>
struct basic_memory_region
{
    uint64_t start{};
    size_t length{}; // uint64_t?
    PermissionType permissions{};
};

struct memory_region : basic_memory_region<>
{
    bool committed{};
};

```

`src/emulator/scoped_hook.hpp`:

```hpp
#pragma once
#include "emulator.hpp"

class scoped_hook
{
  public:
    scoped_hook() = default;

    scoped_hook(emulator& emu)
        : emu_(&emu)
    {
    }

    scoped_hook(emulator& emu, emulator_hook* hook)
        : scoped_hook(emu, std::vector{hook})
    {
    }

    scoped_hook(emulator& emu, std::vector<emulator_hook*> hooks)
        : emu_(&emu),
          hooks_(std::move(hooks))
    {
    }

    ~scoped_hook()
    {
        this->remove();
    }

    scoped_hook(const scoped_hook&) = delete;
    scoped_hook& operator=(const scoped_hook&) = delete;

    scoped_hook(scoped_hook&& obj) noexcept
    {
        this->operator=(std::move(obj));
    }

    scoped_hook& operator=(scoped_hook&& obj) noexcept
    {
        if (this != &obj)
        {
            this->remove();
            this->emu_ = obj.emu_;
            this->hooks_ = std::move(obj.hooks_);

            obj.hooks_ = {};
        }

        return *this;
    }

    scoped_hook& operator=(emulator_hook* hook)
    {
        this->replace({hook});
        return *this;
    }

    void replace(std::vector<emulator_hook*> hooks)
    {
        if (!this->emu_)
        {
            throw std::runtime_error("Invalid scoped hook");
        }

        this->remove();
        this->hooks_ = std::move(hooks);
    }

    void remove()
    {
        auto hooks = std::move(this->hooks_);
        this->hooks_ = {};

        for (auto* hook : hooks)
        {
            try
            {
                this->emu_->delete_hook(hook);
            }
            catch (...)
            {
            }
        }
    }

  private:
    emulator* emu_{};
    std::vector<emulator_hook*> hooks_{};
};

```

`src/emulator/serialization.hpp`:

```hpp
#pragma once

#include <list>
#include <span>
#include <vector>
#include <string>
#include <string_view>
#include <stdexcept>
#include <cstring>
#include <optional>
#include <functional>
#include <typeindex>

namespace utils
{
    class buffer_serializer;
    class buffer_deserializer;

    template <typename T>
    concept Serializable = requires(T a, const T ac, buffer_serializer& serializer, buffer_deserializer& deserializer) {
        { ac.serialize(serializer) } -> std::same_as<void>;
        { a.deserialize(deserializer) } -> std::same_as<void>;
    };

    template <typename T>
    struct is_optional : std::false_type
    {
    };

    template <typename T>
    struct is_optional<std::optional<T>> : std::true_type
    {
    };

    namespace detail
    {
        template <typename, typename = void>
        struct has_serialize_function : std::false_type
        {
        };

        template <typename T>
        struct has_serialize_function<
            T, std::void_t<decltype(serialize(std::declval<buffer_serializer&>(), std::declval<const std::remove_cvref_t<T>&>()))>>
            : std::true_type
        {
        };

        template <typename, typename = void>
        struct has_deserialize_function : std::false_type
        {
        };

        template <typename T>
        struct has_deserialize_function<
            T, std::void_t<decltype(deserialize(std::declval<buffer_deserializer&>(), std::declval<std::remove_cvref_t<T>&>()))>>
            : std::true_type
        {
        };

        template <typename T>
        struct has_deserializer_constructor : std::bool_constant<std::is_constructible_v<T, buffer_deserializer&>>
        {
        };
    }

    class buffer_serializer
    {
      public:
        buffer_serializer() = default;

        void write(const void* buffer, const size_t length)
        {
            const auto old_size_remainder = static_cast<uint8_t>(length);
            constexpr auto check_size = sizeof(old_size_remainder);

            if (this->break_offset_ && this->buffer_.size() <= *this->break_offset_ &&
                this->buffer_.size() + length + check_size > *this->break_offset_)
            {
                throw std::runtime_error("Break offset reached!");
            }

            const auto* security_buffer = reinterpret_cast<const std::byte*>(&old_size_remainder);
            this->buffer_.insert(this->buffer_.end(), security_buffer, security_buffer + check_size);

            const auto* byte_buffer = static_cast<const std::byte*>(buffer);
            this->buffer_.insert(this->buffer_.end(), byte_buffer, byte_buffer + length);
        }

        void write(const buffer_serializer& object)
        {
            const auto& buffer = object.get_buffer();
            this->write(buffer.data(), buffer.size());
        }

        template <typename T>
            requires(!is_optional<T>::value)
        void write(const T& object)
        {
            constexpr auto is_trivially_copyable = std::is_trivially_copyable_v<T>;

            if constexpr (Serializable<T>)
            {
                object.serialize(*this);
            }
            else if constexpr (detail::has_serialize_function<T>::value)
            {
                serialize(*this, object);
            }
            else if constexpr (is_trivially_copyable)
            {
                union
                {
                    const T* type_{};
                    const void* void_;
                } pointers;

                pointers.type_ = &object;

                this->write(pointers.void_, sizeof(object));
            }
            else
            {
                static_assert(is_trivially_copyable, "Key must be trivially copyable or implement serializable!");
                std::abort();
            }
        }

        template <typename T>
        void write_atomic(const std::atomic<T>& val)
        {
            this->write(val.load());
        }

        template <typename T>
        void write_optional(const std::optional<T>& val)
        {
            this->write(val.has_value());

            if (val.has_value())
            {
                this->write(*val);
            }
        }

        template <typename T>
        void write_span(const std::span<T> vec)
        {
            this->write(static_cast<uint64_t>(vec.size()));

            for (const auto& v : vec)
            {
                this->write(v);
            }
        }

        template <typename T>
        void write_vector(const std::vector<T>& vec)
        {
            this->write_span(std::span(vec));
        }

        void write_vector(const std::vector<bool>& vec)
        {
            this->write(static_cast<uint64_t>(vec.size()));

            uint8_t byte = 0;
            uint8_t bit_index = 0;

            for (const bool b : vec)
            {
                if (b)
                {
                    byte |= (1u << bit_index);
                }

                ++bit_index;

                if (bit_index == 8)
                {
                    this->write<uint8_t>(byte);
                    byte = 0;
                    bit_index = 0;
                }
            }

            if (bit_index != 0)
            {
                this->write<uint8_t>(byte);
            }
        }

        template <typename T>
        void write_list(const std::list<T>& vec)
        {
            this->write(static_cast<uint64_t>(vec.size()));

            for (const auto& v : vec)
            {
                this->write(v);
            }
        }

        template <typename T>
        void write_string(const std::basic_string_view<T> str)
        {
            this->write_span<const T>(str);
        }

        template <typename T>
        void write_string(const std::basic_string<T>& str)
        {
            this->write_string(std::basic_string_view<T>(str));
        }

        template <typename Map>
        void write_map(const Map& map)
        {
            this->write<uint64_t>(map.size());

            for (const auto& entry : map)
            {
                this->write(entry.first);
                this->write(entry.second);
            }
        }

        const std::vector<std::byte>& get_buffer() const
        {
            return this->buffer_;
        }

        std::vector<std::byte> move_buffer()
        {
            return std::move(this->buffer_);
        }

        void set_break_offset(const size_t break_offset)
        {
            this->break_offset_ = break_offset;
        }

        std::optional<size_t> get_diff(const buffer_serializer& other) const
        {
            const auto& b1 = this->get_buffer();
            const auto& b2 = other.get_buffer();

            const auto s1 = b1.size();
            const auto s2 = b2.size();

            for (size_t i = 0; i < s1 && i < s2; ++i)
            {
                if (b1.at(i) != b2.at(i))
                {
                    return i;
                }
            }

            if (s1 != s2)
            {
                return std::min(s1, s2);
            }

            return std::nullopt;
        }

        void print_diff(const buffer_serializer& other) const
        {
            const auto diff = this->get_diff(other);
            if (diff)
            {
                printf("Diff at %zd\n", *diff);
            }
        }

      private:
        std::vector<std::byte> buffer_{};
        std::optional<size_t> break_offset_{};
    };

    class buffer_deserializer
    {
      public:
        template <typename T>
        buffer_deserializer(const std::span<T> buffer)
            : buffer_(reinterpret_cast<const std::byte*>(buffer.data()), buffer.size() * sizeof(T))
        {
            static_assert(std::is_trivially_copyable_v<T>, "Type must be trivially copyable");
        }

        template <typename T>
        buffer_deserializer(const std::vector<T>& buffer)
            : buffer_deserializer(std::span(buffer))
        {
        }

        buffer_deserializer(const buffer_serializer& serializer)
            : buffer_deserializer(serializer.get_buffer())
        {
        }

        std::span<const std::byte> read_data(const size_t length)
        {
            const auto length_rest = static_cast<uint8_t>(length);
            constexpr auto check_size = sizeof(length_rest);

            if (this->offset_ + (length + check_size) > this->buffer_.size())
            {
                throw std::runtime_error("Out of bounds read from byte buffer");
            }

            if (static_cast<uint8_t>(this->buffer_[this->offset_]) != length_rest)
            {
                throw std::runtime_error("Reading from serialized buffer mismatches written data!");
            }

            this->offset_ += check_size;

            const std::span result(this->buffer_.data() + this->offset_, length);
            this->offset_ += length;

            return result;
        }

        void read(void* data, const size_t length)
        {
            const auto span = this->read_data(length);
            memcpy(data, span.data(), length);
        }

        template <typename T>
        void read(T& object)
        {
            constexpr auto is_trivially_copyable = std::is_trivially_copyable_v<T>;

            if constexpr (Serializable<T>)
            {
                object.deserialize(*this);
            }
            else if constexpr (detail::has_deserialize_function<T>::value)
            {
                deserialize(*this, object);
            }
            else if constexpr (is_trivially_copyable)
            {
                union
                {
                    T* type_{};
                    void* void_;
                } pointers;

                pointers.type_ = &object;

                this->read(pointers.void_, sizeof(object));
            }
            else
            {
                static_assert(!is_trivially_copyable, "Key must be trivially copyable or implement serializable!");
                std::abort();
            }
        }

        template <typename T>
        T read()
        {
            auto object = this->construct_object<T>();
            this->read(object);
            return object;
        }

        template <typename T>
        void read_atomic(std::atomic<T>& val)
        {
            val = this->read<T>();
        }

        template <typename T>
        void read_optional(std::optional<T>& val)
        {
            if (this->read<bool>())
            {
                val.emplace(this->read<T>());
            }
            else
            {
                val = std::nullopt;
            }
        }

        template <typename T, typename F>
            requires(std::is_invocable_r_v<T, F>)
        void read_optional(std::optional<T>& val, const F& factory)
        {
            if (this->read<bool>())
            {
                val.emplace(factory());
                this->read<T>(*val);
            }
            else
            {
                val = {};
            }
        }

        template <typename T>
        void read_vector(std::vector<T>& result)
        {
            const auto size = this->read<uint64_t>();
            result.clear();
            result.reserve(static_cast<size_t>(size));

            for (uint64_t i = 0; i < size; ++i)
            {
                result.emplace_back(this->read<T>());
            }
        }

        void read_vector(std::vector<bool>& result)
        {
            const auto bit_count = this->read<uint64_t>();
            result.clear();
            result.reserve(static_cast<size_t>(bit_count));

            const auto size = (bit_count + 7) / 8;

            for (uint64_t i = 0; i < size; ++i)
            {
                const auto byte = this->read<uint8_t>();

                for (uint8_t bit = 0; bit < 8 && result.size() < bit_count; ++bit)
                {
                    result.push_back((byte >> bit) & 1u);
                }
            }
        }

        template <typename T>
        std::vector<T> read_vector()
        {
            std::vector<T> result{};
            this->read_vector(result);
            return result;
        }

        template <typename T>
        void read_list(std::list<T>& result)
        {
            const auto size = this->read<uint64_t>();
            result.clear();

            for (uint64_t i = 0; i < size; ++i)
            {
                result.emplace_back(this->read<T>());
            }
        }

        template <typename T>
        std::list<T> read_list()
        {
            std::list<T> result{};
            this->read_list(result);
            return result;
        }

        template <typename Map>
        void read_map(Map& map)
        {
            using key_type = typename Map::key_type;
            using value_type = typename Map::mapped_type;

            map.clear();

            const auto size = this->read<uint64_t>();

            for (uint64_t i = 0; i < size; ++i)
            {
                auto key = this->read<key_type>();
                auto value = this->read<value_type>();

                map.emplace(std::move(key), std::move(value));
            }
        }

        template <typename Map>
        Map read_map()
        {
            Map map{};
            this->read_map(map);
            return map;
        }

        template <typename T = char>
        void read_string(std::basic_string<T>& result)
        {
            const auto size = this->read<uint64_t>();

            result.clear();
            result.reserve(static_cast<size_t>(size));

            for (uint64_t i = 0; i < size; ++i)
            {
                result.push_back(this->read<T>());
            }
        }

        template <typename T = char>
        std::basic_string<T> read_string()
        {
            std::basic_string<T> result{};
            this->read_string(result);
            return result;
        }

        size_t get_remaining_size() const
        {
            return this->buffer_.size() - offset_;
        }

        std::span<const std::byte> get_remaining_data()
        {
            return this->read_data(this->get_remaining_size());
        }

        size_t get_offset() const
        {
            return this->offset_;
        }

        template <typename T, typename F>
            requires(std::is_invocable_r_v<T, F>)
        void register_factory(F factory)
        {
            this->factories_[std::type_index(typeid(T))] = [f = std::move(factory)]() -> T* { return new T(f()); };
        }

      private:
        size_t offset_{0};
        std::span<const std::byte> buffer_{};
        std::unordered_map<std::type_index, std::function<void*()>> factories_{};

        template <typename T>
        T construct_object()
        {
            if constexpr (detail::has_deserializer_constructor<T>::value)
            {
                return T(*this);
            }
            else if constexpr (std::is_default_constructible_v<T>)
            {
                return {};
            }
            else
            {
                const auto factory = this->factories_.find(std::type_index(typeid(T)));
                if (factory == this->factories_.end())
                {
                    throw std::runtime_error("Object construction failed. Missing factory for type: " + std::string(typeid(T).name()));
                }

                auto* object = static_cast<T*>(factory->second());
                auto obj = std::move(*object);
                delete object;

                return obj;
            }
        }
    };

    template <>
    inline void buffer_deserializer::read<bool>(bool& object)
    {
        object = this->read<uint8_t>() != 0;
    }

    template <>
    inline void buffer_deserializer::read<std::string>(std::string& object)
    {
        object = this->read_string<char>();
    }

    template <>
    inline void buffer_deserializer::read<std::wstring>(std::wstring& object)
    {
        object = this->read_string<wchar_t>();
    }

    template <>
    inline void buffer_deserializer::read<std::u16string>(std::u16string& object)
    {
        object = this->read_string<char16_t>();
    }

    template <>
    inline void buffer_serializer::write<bool>(const bool& object)
    {
        this->write<uint8_t>(object ? 1 : 0);
    }

    template <>
    inline void buffer_serializer::write<std::string>(const std::string& object)
    {
        this->write_string(object);
    }

    template <>
    inline void buffer_serializer::write<std::wstring>(const std::wstring& object)
    {
        this->write_string(object);
    }

    template <>
    inline void buffer_serializer::write<std::u16string>(const std::u16string& object)
    {
        this->write_string(object);
    }
}

```

`src/emulator/serialization_helper.hpp`:

```hpp
#pragma once

#include "serialization.hpp"

#include <chrono>
#include <filesystem>
#include <utils/path_key.hpp>

namespace utils
{
    inline void serialize(buffer_serializer& buffer, const std::chrono::steady_clock::time_point& tp)
    {
        buffer.write(tp.time_since_epoch().count());
    }

    inline void deserialize(buffer_deserializer& buffer, std::chrono::steady_clock::time_point& tp)
    {
        using time_point = std::chrono::steady_clock::time_point;
        using duration = time_point::duration;

        const auto count = buffer.read<duration::rep>();
        tp = time_point{duration{count}};
    }

    inline void serialize(buffer_serializer& buffer, const std::chrono::system_clock::time_point& tp)
    {
        buffer.write(tp.time_since_epoch().count());
    }

    inline void deserialize(buffer_deserializer& buffer, std::chrono::system_clock::time_point& tp)
    {
        using time_point = std::chrono::system_clock::time_point;
        using duration = time_point::duration;

        const auto count = buffer.read<duration::rep>();
        tp = time_point{duration{count}};
    }

    inline void serialize(buffer_serializer& buffer, const std::filesystem::path& path)
    {
        buffer.write_string<char16_t>(path.u16string());
    }

    inline void deserialize(buffer_deserializer& buffer, std::filesystem::path& path)
    {
        path = buffer.read_string<char16_t>();
    }

    inline void serialize(buffer_serializer& buffer, const path_key& path)
    {
        buffer.write(path.get());
    }

    inline void deserialize(buffer_deserializer& buffer, path_key& path)
    {
        path = buffer.read<std::filesystem::path>();
    }
}

```

`src/emulator/typed_emulator.hpp`:

```hpp
#pragma once

#include "emulator.hpp"
#include <utility>

struct emulator_stack_allocation
{
    uint64_t address{};
    size_t size{};

    emulator_stack_allocation() = default;

    ~emulator_stack_allocation()
    {
        assert(address == 0 && "Emulator stack leak: allocation was not freed before destruction");
    }

    emulator_stack_allocation(const emulator_stack_allocation&) = delete;
    emulator_stack_allocation& operator=(const emulator_stack_allocation&) = delete;

    emulator_stack_allocation(emulator_stack_allocation&& other) noexcept
        : address(std::exchange(other.address, 0)),
          size(std::exchange(other.size, 0))
    {
    }

    emulator_stack_allocation& operator=(emulator_stack_allocation&& other) noexcept
    {
        if (this != &other)
        {
            address = std::exchange(other.address, 0);
            size = std::exchange(other.size, 0);
        }
        return *this;
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(address);
        buffer.write(size);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(address);
        buffer.read(size);
    }
};

template <typename Traits>
class typed_emulator : public emulator
{
  public:
    using registers = typename Traits::register_type;
    using pointer_type = typename Traits::pointer_type;
    using hookable_instructions = typename Traits::hookable_instructions;

    static constexpr size_t pointer_size = sizeof(pointer_type);
    static constexpr registers stack_pointer = Traits::stack_pointer;
    static constexpr registers instruction_pointer = Traits::instruction_pointer;

    size_t write_register(registers reg, const void* value, const size_t size)
    {
        return this->write_raw_register(static_cast<int>(reg), value, size);
    }

    size_t read_register(registers reg, void* value, const size_t size)
    {
        return this->read_raw_register(static_cast<int>(reg), value, size);
    }

    template <typename T = pointer_type>
    T reg(const registers regid)
    {
        T value{};
        this->read_register(regid, &value, sizeof(value));
        return value;
    }

    template <typename T = pointer_type, typename S>
    void reg(const registers regid, const S& maybe_value)
    {
        T value = static_cast<T>(maybe_value);
        this->write_register(regid, &value, sizeof(value));
    }

    pointer_type read_instruction_pointer()
    {
        return this->reg(instruction_pointer);
    }

    pointer_type read_stack_pointer()
    {
        return this->reg(stack_pointer);
    }

    pointer_type read_stack(const size_t index)
    {
        pointer_type result{};
        const auto sp = this->read_stack_pointer();

        this->read_memory(sp + (index * pointer_size), &result, sizeof(result));

        return result;
    }

    void write_stack(const size_t index, const pointer_type& value)
    {
        const auto sp = this->read_stack_pointer();
        this->write_memory(sp + (index * pointer_size), &value, sizeof(value));
    }

    void push_stack(const pointer_type& value)
    {
        const auto sp = this->read_stack_pointer() - pointer_size;
        this->reg(stack_pointer, sp);
        this->write_memory(sp, &value, sizeof(value));
    }

    pointer_type pop_stack()
    {
        pointer_type result{};
        const auto sp = this->read_stack_pointer();
        this->read_memory(sp, &result, sizeof(result));
        this->reg(stack_pointer, sp + pointer_size);

        return result;
    }

    template <typename T>
        requires std::is_trivially_copyable_v<T>
    emulator_stack_allocation push_stack(const T& data)
    {
        uint64_t old_rsp = read_stack_pointer();
        uint64_t new_rsp = (old_rsp - sizeof(T)) & ~0xF;

        reg(stack_pointer, new_rsp);
        write_memory(new_rsp, &data, sizeof(T));

        emulator_stack_allocation alloc{};
        alloc.address = new_rsp;
        alloc.size = static_cast<size_t>(old_rsp - new_rsp);

        return alloc;
    }

    void pop_stack(emulator_stack_allocation allocation)
    {
        uint64_t current_rsp = read_stack_pointer();
        assert(current_rsp == allocation.address && "Invalid stack deallocation");

        reg(stack_pointer, current_rsp + allocation.size);
        allocation = {};
    }

    emulator_hook* hook_instruction(hookable_instructions instruction_type, instruction_hook_callback callback)
    {
        return this->hook_instruction(static_cast<int>(instruction_type), std::move(callback));
    }

    emulator_hook* hook_instruction(hookable_instructions instruction_type, simple_instruction_hook_callback callback)
    {
        return this->hook_instruction(instruction_type, [c = std::move(callback)](const uint64_t) {
            return c(); //
        });
    }

  private:
    emulator_hook* hook_instruction(int instruction_type, instruction_hook_callback callback) override = 0;

    size_t read_raw_register(int reg, void* value, size_t size) override = 0;
    size_t write_raw_register(int reg, const void* value, size_t size) override = 0;
};

```

`src/emulator/x86_register.hpp`:

```hpp
#pragma once

// x86_64 and x86_32 register definitions
enum class x86_register
{
    invalid = 0,
    ah,
    al,
    ax,
    bh,
    bl,
    bp,
    bpl,
    bx,
    ch,
    cl,
    cs,
    cx,
    dh,
    di,
    dil,
    dl,
    ds,
    dx,
    eax,
    ebp,
    ebx,
    ecx,
    edi,
    edx,
    eflags,
    eip,
    es = eip + 2,
    esi,
    esp,
    fpsw,
    fs,
    gs,
    ip,
    rax,
    rbp,
    rbx,
    rcx,
    rdi,
    rdx,
    rip,
    rsi = rip + 2,
    rsp,
    si,
    sil,
    sp,
    spl,
    ss,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr8 = cr4 + 4,
    dr0 = cr8 + 8,
    dr1,
    dr2,
    dr3,
    dr4,
    dr5,
    dr6,
    dr7,
    fp0 = dr7 + 9,
    fp1,
    fp2,
    fp3,
    fp4,
    fp5,
    fp6,
    fp7,
    k0,
    k1,
    k2,
    k3,
    k4,
    k5,
    k6,
    k7,
    mm0,
    mm1,
    mm2,
    mm3,
    mm4,
    mm5,
    mm6,
    mm7,
    r8,
    r9,
    r10,
    r11,
    r12,
    r13,
    r14,
    r15,
    st0,
    st1,
    st2,
    st3,
    st4,
    st5,
    st6,
    st7,
    xmm0,
    xmm1,
    xmm2,
    xmm3,
    xmm4,
    xmm5,
    xmm6,
    xmm7,
    xmm8,
    xmm9,
    xmm10,
    xmm11,
    xmm12,
    xmm13,
    xmm14,
    xmm15,
    xmm16,
    xmm17,
    xmm18,
    xmm19,
    xmm20,
    xmm21,
    xmm22,
    xmm23,
    xmm24,
    xmm25,
    xmm26,
    xmm27,
    xmm28,
    xmm29,
    xmm30,
    xmm31,
    ymm0,
    ymm1,
    ymm2,
    ymm3,
    ymm4,
    ymm5,
    ymm6,
    ymm7,
    ymm8,
    ymm9,
    ymm10,
    ymm11,
    ymm12,
    ymm13,
    ymm14,
    ymm15,
    ymm16,
    ymm17,
    ymm18,
    ymm19,
    ymm20,
    ymm21,
    ymm22,
    ymm23,
    ymm24,
    ymm25,
    ymm26,
    ymm27,
    ymm28,
    ymm29,
    ymm30,
    ymm31,
    zmm0,
    zmm1,
    zmm2,
    zmm3,
    zmm4,
    zmm5,
    zmm6,
    zmm7,
    zmm8,
    zmm9,
    zmm10,
    zmm11,
    zmm12,
    zmm13,
    zmm14,
    zmm15,
    zmm16,
    zmm17,
    zmm18,
    zmm19,
    zmm20,
    zmm21,
    zmm22,
    zmm23,
    zmm24,
    zmm25,
    zmm26,
    zmm27,
    zmm28,
    zmm29,
    zmm30,
    zmm31,
    r8b,
    r9b,
    r10b,
    r11b,
    r12b,
    r13b,
    r14b,
    r15b,
    r8d,
    r9d,
    r10d,
    r11d,
    r12d,
    r13d,
    r14d,
    r15d,
    r8w,
    r9w,
    r10w,
    r11w,
    r12w,
    r13w,
    r14w,
    r15w,
    idtr,
    gdtr,
    ldtr,
    tr,
    fpcw,
    fptag,
    msr,
    mxcsr,
    fs_base,
    gs_base,
    flags,
    rflags,
    fip,
    fcs,
    fdp,
    fds,
    fop,
    end, // Must be last
};

```

`src/fuzzer/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(fuzzer ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

if(NOT MOMO_ENABLE_CLANG_TIDY)
  target_precompile_headers(fuzzer PRIVATE std_include.hpp)
endif()

target_link_libraries(fuzzer PRIVATE
  fuzzing-engine
  windows-emulator
)

if (MOMO_ENABLE_RUST)
  target_link_libraries(fuzzer PRIVATE
    icicle-emulator
  )
endif()

momo_strip_target(fuzzer)

```

`src/fuzzer/main.cpp`:

```cpp
#include "std_include.hpp"

#include <windows_emulator.hpp>
#include <fuzzer.hpp>

#include <utils/finally.hpp>

#if MOMO_ENABLE_RUST_CODE
#include <icicle_x86_64_emulator.hpp>
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4702)
#endif

bool use_gdb = false;

namespace
{
    std::unique_ptr<x86_64_emulator> create_emulator_backend()
    {
#if MOMO_ENABLE_RUST_CODE
        return icicle::create_x86_64_emulator();
#else
        throw std::runtime_error("Fuzzer requires rust code to be enabled");
#endif
    }

    void run_emulation(windows_emulator& win_emu)
    {
        bool has_exception = false;
        const auto _ = utils::finally([&] {
            win_emu.callbacks.on_exception = {}; //
        });

        try
        {
            win_emu.callbacks.on_exception = [&] {
                has_exception = true;
                win_emu.stop();
            };

            win_emu.log.disable_output(true);
            win_emu.start();

            if (has_exception)
            {
                throw std::runtime_error("Exception!");
            }
        }
        catch (...)
        {
            win_emu.log.disable_output(false);
            win_emu.log.error("Emulation failed at: 0x%" PRIx64 "\n", win_emu.emu().read_instruction_pointer());
            throw;
        }

        win_emu.log.disable_output(false);
    }

    void forward_emulator(windows_emulator& win_emu)
    {
        const auto target = win_emu.mod_manager.executable->find_export("vulnerable");
        win_emu.emu().hook_memory_execution(target, [&](uint64_t) {
            win_emu.emu().stop(); //
        });

        run_emulation(win_emu);
    }

    struct fuzzer_executer : fuzzer::executer
    {
        windows_emulator emu{create_emulator_backend()};
        std::span<const std::byte> emulator_data{};
        std::unordered_set<uint64_t> visited_blocks{};
        const std::function<fuzzer::coverage_functor>* handler{nullptr};

        fuzzer_executer(const std::span<const std::byte> data)
            : emulator_data(data)
        {
            emu.emu().hook_basic_block([&](const basic_block& block) {
                if (this->handler && visited_blocks.emplace(block.address).second)
                {
                    (*this->handler)(block.address);
                }
            });

            utils::buffer_deserializer deserializer{emulator_data};
            emu.deserialize(deserializer);
            emu.save_snapshot();

            const auto return_address = emu.emu().read_stack(0);
            emu.emu().hook_memory_execution(return_address, [&](const uint64_t) {
                emu.emu().stop(); //
            });
        }

        void restore_emulator()
        {
            /*utils::buffer_deserializer deserializer{ emulator_data };
            emu.deserialize(deserializer);*/
            emu.restore_snapshot();
        }

        fuzzer::execution_result execute(const std::span<const uint8_t> data,
                                         const std::function<fuzzer::coverage_functor>& coverage_handler) override
        {
            // printf("Input size: %zd\n", data.size());
            this->handler = &coverage_handler;
            this->visited_blocks.clear();

            restore_emulator();

            const auto memory = emu.memory.allocate_memory(
                static_cast<size_t>(page_align_up(std::max(data.size(), static_cast<size_t>(1)))), memory_permission::read_write);
            emu.emu().write_memory(memory, data.data(), data.size());

            emu.emu().reg(x86_register::rcx, memory);
            emu.emu().reg<uint64_t>(x86_register::rdx, data.size());

            try
            {
                run_emulation(emu);
                return fuzzer::execution_result::success;
            }
            catch (...)
            {
                return fuzzer::execution_result::error;
            }
        }
    };

    struct my_fuzzing_handler : fuzzer::fuzzing_handler
    {
        std::vector<std::byte> emulator_state{};
        std::atomic_bool stop_fuzzing{false};

        my_fuzzing_handler(std::vector<std::byte> emulator_state)
            : emulator_state(std::move(emulator_state))
        {
        }

        std::unique_ptr<fuzzer::executer> make_executer() override
        {
            return std::make_unique<fuzzer_executer>(emulator_state);
        }

        bool stop() override
        {
            return stop_fuzzing;
        }
    };

    void run_fuzzer(const windows_emulator& base_emulator)
    {
        const auto concurrency = std::thread::hardware_concurrency() + 4;

        utils::buffer_serializer serializer{};
        base_emulator.serialize(serializer);

        my_fuzzing_handler handler{serializer.move_buffer()};

        fuzzer::run(handler, concurrency);
    }

    void run(const std::string_view application)
    {
        application_settings settings{
            .application = application,
        };

        windows_emulator win_emu{create_emulator_backend(), std::move(settings)};

        forward_emulator(win_emu);
        run_fuzzer(win_emu);
    }

    int run_main(const int argc, char** argv)
    {
        if (argc <= 1)
        {
            puts("Application not specified!");
            return 1;
        }

        // setvbuf(stdout, nullptr, _IOFBF, 0x10000);
        if (argc > 2 && argv[1] == "-d"s)
        {
            use_gdb = true;
        }

        try
        {
            do
            {
                run(argv[use_gdb ? 2 : 1]);
            } while (use_gdb);

            return 0;
        }
        catch (std::exception& e)
        {
            puts(e.what());

#if defined(_WIN32) && 0
            MessageBoxA(nullptr, e.what(), "ERROR", MB_ICONERROR);
#endif
        }

        return 1;
    }
}

int main(const int argc, char** argv)
{
    return run_main(argc, argv);
}

#ifdef _WIN32
int WINAPI WinMain(HINSTANCE, HINSTANCE, PSTR, int)
{
    return run_main(__argc, __argv);
}
#endif

```

`src/fuzzer/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "Windows Emulator"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "emulator"
            VALUE "LegalCopyright", "All rights reserved."
            VALUE "OriginalFilename", "emulator.exe"
            VALUE "ProductName", "emulator"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

GLFW_ICON       ICON   "resources/icon.ico"


#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/fuzzer/std_include.hpp`:

```hpp
#pragma once

#include <map>
#include <set>
#include <list>
#include <array>
#include <deque>
#include <queue>
#include <thread>
#include <ranges>
#include <atomic>
#include <vector>
#include <mutex>
#include <string>
#include <chrono>
#include <memory>
#include <fstream>
#include <functional>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <string_view>
#include <unordered_set>
#include <condition_variable>

#include <cassert>

#include <platform/platform.hpp>

// NOLINTNEXTLINE(google-global-names-in-headers)
using namespace std::literals;

```

`src/fuzzing-engine/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(fuzzing-engine ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(fuzzing-engine PRIVATE
  emulator-common
)

target_include_directories(fuzzing-engine INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

momo_strip_target(fuzzing-engine)

```

`src/fuzzing-engine/fuzzer.cpp`:

```cpp
#include "fuzzer.hpp"
#include <cinttypes>

#include "input_generator.hpp"

#include <utils/timer.hpp>
#include <utils/string.hpp>
#include <utils/finally.hpp>

namespace fuzzer
{
    namespace
    {
        class fuzzing_context
        {
          public:
            fuzzing_context(input_generator& generator, fuzzing_handler& handler)
                : generator(generator),
                  handler(handler)
            {
            }

            void stop()
            {
                this->stop_ = true;
            }

            bool should_stop()
            {
                if (this->stop_)
                {
                    return true;
                }

                if (!handler.stop())
                {
                    return false;
                }

                this->stop_ = true;
                return true;
            }

            input_generator& generator;
            fuzzing_handler& handler;
            std::atomic_uint64_t executions{0};

          private:
            std::atomic_bool stop_{false};
        };

        std::string format_binary_data(const std::span<const uint8_t> input)
        {
            std::string data;
            std::string bytes;
            std::string text;

            const auto wrap_line = [&] {
                if (bytes.empty())
                {
                    return;
                }

                while (bytes.size() < 16 * 3)
                {
                    bytes.push_back(' ');
                }

                data += bytes;
                data += "| ";
                data += text;
                data += "\n";

                bytes.clear();
                text.clear();
            };

            for (size_t i = 0; i < input.size(); ++i)
            {
                if (i % 16 == 0)
                {
                    wrap_line();
                }

                const auto in = input[i];
                bytes += utils::string::va("%02X ", static_cast<uint32_t>(in));
                text.push_back(isprint(in) ? static_cast<char>(in) : '.');
            }

            wrap_line();

            return data;
        }

        void print_crash(const std::span<const uint8_t> input)
        {
            std::string text = utils::string::va("\nFound crash for input (length %zu):\n", input.size());
            text += format_binary_data(input);

            printf("%.*s\n", static_cast<int>(text.size()), text.c_str());
        }

        void perform_fuzzing_iteration(fuzzing_context& context, executer& executer)
        {
            ++context.executions;
            context.generator.access_input([&](const std::span<const uint8_t> input) {
                uint64_t score{0};
                const auto result = executer.execute(input, [&](uint64_t) {
                    ++score; //
                });

                if (result == execution_result::error)
                {
                    print_crash(input);
                }

                return score;
            });
        }

        void worker(fuzzing_context& context)
        {
            const auto executer = context.handler.make_executer();

            while (!context.should_stop())
            {
                perform_fuzzing_iteration(context, *executer);
            }
        }

        struct worker_pool
        {
            fuzzing_context* context_{nullptr};
            std::vector<std::thread> workers_{};

            worker_pool(fuzzing_context& context, const size_t concurrency)
                : context_(&context)
            {
                this->workers_.reserve(concurrency);

                for (size_t i = 0; i < concurrency; ++i)
                {
                    this->workers_.emplace_back([&context] {
                        worker(context); //
                    });
                }
            }

            ~worker_pool()
            {
                if (this->workers_.empty())
                {
                    return;
                }

                this->context_->stop();

                for (auto& w : this->workers_)
                {
                    w.join();
                }
            }
        };
    }

    void run(fuzzing_handler& handler, const size_t concurrency)
    {
        const utils::timer<> t{};
        input_generator generator{};
        fuzzing_context context{generator, handler};
        worker_pool pool{context, concurrency};

        while (!context.should_stop())
        {
            std::this_thread::sleep_for(std::chrono::seconds{1});

            const auto executions = context.executions.exchange(0);
            const auto highest_scorer = context.generator.get_highest_scorer();
            const auto avg_score = context.generator.get_average_score();
            printf("Executions/s: %" PRIu64 " - Score: %" PRIx64 " - Avg: %.3f\n", executions, highest_scorer.score, avg_score);
        }

        const auto duration = t.elapsed();
        const int64_t seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
        printf("Fuzzing stopped after %" PRIi64 "s\n", seconds);
    }
}

```

`src/fuzzing-engine/fuzzer.hpp`:

```hpp
#pragma once
#include <span>
#include <memory>
#include <thread>
#include <cstdint>
#include <functional>

namespace fuzzer
{
    using coverage_functor = void(uint64_t address);

    enum class execution_result
    {
        success,
        error,
    };

    struct executer
    {
        virtual ~executer() = default;

        virtual execution_result execute(std::span<const uint8_t> data, const std::function<coverage_functor>& coverage_handler) = 0;
    };

    struct fuzzing_handler
    {
        virtual ~fuzzing_handler() = default;

        virtual std::unique_ptr<executer> make_executer() = 0;

        virtual bool stop()
        {
            return false;
        }
    };

    void run(fuzzing_handler& handler, size_t concurrency = std::thread::hardware_concurrency());
}

```

`src/fuzzing-engine/input_generator.cpp`:

```cpp
#include "input_generator.hpp"

#include <cassert>

namespace fuzzer
{
    namespace
    {
        constexpr size_t MAX_TOP_SCORER = 20;

        void mutate_input(random_generator& rng, std::vector<uint8_t>& input)
        {
            if (input.empty() || rng.get(3) == 0)
            {
                const auto new_bytes = rng.get_geometric<size_t>() + 1;
                input.resize(input.size() + new_bytes);
            }
            else if (rng.get(10) == 0)
            {
                const auto remove_bytes = rng.get_geometric<size_t>() % input.size();
                input.resize(input.size() - remove_bytes);
            }

            const auto mutations = (rng.get_geometric<size_t>() + 1) % input.size();

            for (size_t i = 0; i < mutations; ++i)
            {
                const auto index = rng.get<size_t>(input.size());
                input[index] = rng.get<uint8_t>();
            }
        }
    }

    input_generator::input_generator() = default;

    std::vector<uint8_t> input_generator::generate_next_input()
    {
        std::vector<uint8_t> input{};
        std::unique_lock lock{this->mutex_};

        if (!this->top_scorer_.empty())
        {
            const auto index = this->rng.get<size_t>() % this->top_scorer_.size();
            input = this->top_scorer_[index].data;
        }

        mutate_input(this->rng, input);

        return input;
    }

    void input_generator::access_input(const std::function<input_handler>& handler)
    {
        auto next_input = this->generate_next_input();
        const auto score = handler(next_input);

        input_entry e{};
        e.data = std::move(next_input);
        e.score = score;

        this->store_input_entry(std::move(e));
    }

    input_entry input_generator::get_highest_scorer()
    {
        std::unique_lock lock{this->mutex_};
        return this->highest_scorer_;
    }

    double input_generator::get_average_score()
    {
        std::unique_lock lock{this->mutex_};

        if (this->top_scorer_.empty())
        {
            return 0.0;
        }

        double score{0.0};
        for (const auto& e : this->top_scorer_)
        {
            score += static_cast<double>(e.score);
        }

        return score / static_cast<double>(this->top_scorer_.size());
    }

    void input_generator::store_input_entry(input_entry entry)
    {
        std::unique_lock lock{this->mutex_};

        if (entry.score < this->lowest_score && this->rng.get(40) != 0)
        {
            return;
        }

        if (entry.score > this->highest_scorer_.score)
        {
            this->highest_scorer_ = entry;
        }

        if (this->top_scorer_.size() < MAX_TOP_SCORER)
        {
            this->top_scorer_.emplace_back(std::move(entry));
            return;
        }

        const auto insert_at_random = this->rng.get(10) == 0;
        const auto index = insert_at_random ? (this->rng.get<size_t>() % this->top_scorer_.size()) : this->lowest_scorer;

        this->top_scorer_[index] = std::move(entry);

        this->lowest_score = this->top_scorer_[0].score;
        this->lowest_scorer = 0;

        for (size_t i = 1; i < this->top_scorer_.size(); ++i)
        {
            if (this->top_scorer_[i].score < this->lowest_score)
            {
                this->lowest_score = this->top_scorer_[i].score;
                this->lowest_scorer = i;
            }
        }
    }
}

```

`src/fuzzing-engine/input_generator.hpp`:

```hpp
#pragma once
#include <mutex>
#include <vector>
#include <optional>
#include <functional>

#include "random_generator.hpp"

namespace fuzzer
{
    using input_score = uint64_t;
    using input_handler = input_score(std::span<const uint8_t>);

    struct input_entry
    {
        std::vector<uint8_t> data{};
        input_score score{};
    };

    class input_generator
    {
      public:
        input_generator();

        void access_input(const std::function<input_handler>& handler);

        input_entry get_highest_scorer();
        double get_average_score();

      private:
        std::mutex mutex_{};
        random_generator rng{};

        std::vector<input_entry> top_scorer_{};
        input_score lowest_score{0};
        size_t lowest_scorer{0};

        input_entry highest_scorer_{};

        std::vector<uint8_t> generate_next_input();

        void store_input_entry(input_entry entry);
    };
}

```

`src/fuzzing-engine/random_generator.cpp`:

```cpp
#include "random_generator.hpp"
#include <cstring>

namespace fuzzer
{
    random_generator::random_generator()
        : rng_(std::random_device()())
    {
    }

    std::mt19937::result_type random_generator::generate_number()
    {
        return this->distribution_(this->rng_);
    }

    void random_generator::fill(void* data, const size_t size)
    {
        this->fill(std::span(static_cast<uint8_t*>(data), size));
    }

    void random_generator::fill(std::span<uint8_t> data)
    {
        size_t i = 0;
        while (i < data.size())
        {
            const auto number = this->generate_number();

            const auto remaining_data = data.size() - i;
            const auto data_to_fill = std::min(remaining_data, sizeof(number));

            memcpy(data.data() + i, &number, data_to_fill);
            i += data_to_fill;
        }
    }
}

```

`src/fuzzing-engine/random_generator.hpp`:

```hpp
#pragma once
#include <span>
#include <random>
#include <cstdint>
#include <cstring>

namespace fuzzer
{
    class random_generator
    {
      public:
        random_generator();

        void fill(std::span<uint8_t> data);
        void fill(void* data, size_t size);

        template <typename T>
            requires(std::is_trivially_copyable_v<T>)
        T get()
        {
            T value{};
            this->fill(&value, sizeof(value));
            return value;
        }

        template <typename T>
        T get(const T& max)
        {
            return this->get<T>() % max;
        }

        template <typename T>
        T get(T min, T max)
        {
            if (max < min)
            {
                std::swap(max, min);
            }

            const auto diff = max - min;

            return (this->get<T>() % diff) + min;
        }

        template <typename T>
        T get_geometric()
        {
            T value{0};

            while (this->get<bool>())
            {
                ++value;
            }

            return value;
        }

      private:
        std::mt19937 rng_;
        std::uniform_int_distribution<std::mt19937::result_type> distribution_{};

        std::mt19937::result_type generate_number();
    };

    template <>
    inline bool random_generator::get<bool>()
    {
        return (this->generate_number() & 1) != 0;
    }
}

```

`src/gdb-stub/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(gdb-stub ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(gdb-stub PUBLIC
  emulator-common
)

target_include_directories(gdb-stub INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

momo_strip_target(gdb-stub)

```

`src/gdb-stub/async_handler.cpp`:

```cpp
#include "async_handler.hpp"
#include <utils/finally.hpp>
#include <chrono>

using namespace std::chrono_literals;

namespace gdb_stub
{
    async_handler::async_handler(handler_function h)
        : handler_(std::move(h))
    {
        this->stop_ = false;
        this->runner_ = std::thread([this] {
            this->work(); //
        });
    }

    async_handler::~async_handler()
    {
        this->stop_ = true;
        this->run_ = false;

        if (this->runner_.joinable())
        {
            this->runner_.join();
        }
    }

    void async_handler::pause()
    {
        this->run_ = false;

        while (this->is_running_ && !this->stop_)
        {
            std::this_thread::sleep_for(1ms);
        }
    }

    void async_handler::run()
    {
        if (this->stop_)
        {
            return;
        }

        this->run_ = true;

        while (!this->is_running_ && !this->stop_)
        {
            std::this_thread::sleep_for(1ms);
        }
    }

    bool async_handler::is_running() const
    {
        return this->is_running_;
    }

    void async_handler::work()
    {
        while (true)
        {
            while (!this->run_ && !this->stop_)
            {
                this->is_running_ = false;
                std::this_thread::sleep_for(10ms);
            }

            if (this->stop_)
            {
                break;
            }

            const auto _ = utils::finally([this] {
                this->is_running_ = false; //
            });

            this->is_running_ = true;
            this->handler_(this->run_);
        }
    }
}

```

`src/gdb-stub/async_handler.hpp`:

```hpp
#pragma once
#include <thread>
#include <atomic>
#include <functional>
#include <condition_variable>

namespace gdb_stub
{
    class async_handler
    {
      public:
        using handler = void(std::atomic_bool& should_run);
        using handler_function = std::function<handler>;

        async_handler(handler_function handler);
        ~async_handler();

        async_handler(async_handler&&) = delete;
        async_handler(const async_handler&) = delete;

        async_handler& operator=(async_handler&&) = delete;
        async_handler& operator=(const async_handler&) = delete;

        void run();
        void pause();
        bool is_running() const;

      private:
        std::atomic_bool run_{false};
        std::atomic_bool stop_{false};
        std::atomic_bool is_running_{false};

        handler_function handler_{};
        std::thread runner_{};

        void work();
    };
}

```

`src/gdb-stub/checksum.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace gdb_stub
{
    constexpr size_t CHECKSUM_SIZE = 2;

    inline uint8_t compute_checksum(const std::string_view data)
    {
        uint8_t checksum = 0;
        for (const auto c : data)
        {
            checksum += static_cast<uint8_t>(c);
        }

        return checksum;
    }
}

```

`src/gdb-stub/connection_handler.cpp`:

```cpp
#include "connection_handler.hpp"
#include "checksum.hpp"
#include <utils/string.hpp>

#include <thread>

using namespace std::literals;

namespace gdb_stub
{
    namespace
    {
        bool read_from_socket(stream_processor& processor, network::tcp_client_socket& client)
        {
            const auto data = client.receive();
            if (!data)
            {
                return false;
            }

            processor.push_stream_data(*data);
            return true;
        }
    }

    connection_handler::connection_handler(network::tcp_client_socket& client, utils::optional_function<bool()> should_stop)
        : should_stop_(std::move(should_stop)),
          client_(client)
    {
        this->client_.set_blocking(false);

        this->stop_ = false;

        this->output_thread_ = std::thread([this] {
            this->transmission_loop(); //
        });
    }

    connection_handler::~connection_handler()
    {
        this->stop_ = true;
        this->condition_variable_.notify_all();

        if (this->output_thread_.joinable())
        {
            this->output_thread_.join();
        }
    }

    std::optional<std::string> connection_handler::get_packet()
    {
        while (this->client_.is_valid() && !this->processor_.has_packet() && !this->should_stop_())
        {
            if (!read_from_socket(this->processor_, this->client_))
            {
                (void)this->client_.sleep(100ms, true);
            }
        }

        if (this->processor_.has_packet())
        {
            return this->processor_.get_next_packet();
        }

        return std::nullopt;
    }

    void connection_handler::send_reply(const std::string_view data)
    {
        const auto checksum = utils::string::to_hex_string(compute_checksum(data));
        this->send_raw_data("$" + std::string(data) + "#" + checksum);
    }

    void connection_handler::send_raw_data(const std::string_view data)
    {
        {
            std::lock_guard _{this->mutex_};
            this->output_stream_.append(data);
        }

        this->condition_variable_.notify_one();
    }

    bool connection_handler::should_stop() const
    {
        return this->stop_ || !this->client_.is_valid();
    }

    void connection_handler::close() const
    {
        this->client_.close();
    }

    void connection_handler::await_transmission(const std::function<void()>& handler)
    {
        std::unique_lock lock{this->mutex_};

        const auto can_run = [this] {
            return this->should_stop() //
                   || !this->output_stream_.empty();
        };

        const auto run = this->condition_variable_.wait_for(lock, 100ms, can_run);

        if (run && !this->should_stop())
        {
            handler();
        }
    }

    std::string connection_handler::get_next_data_to_transmit()
    {
        std::string transmit_data{};

        this->await_transmission([&] {
            transmit_data = std::move(this->output_stream_);
            this->output_stream_ = {};
        });

        return transmit_data;
    }

    void connection_handler::transmission_loop()
    {
        while (!this->should_stop())
        {
            const auto data = this->get_next_data_to_transmit();
            (void)this->client_.send(data);
        }
    }
}

```

`src/gdb-stub/connection_handler.hpp`:

```hpp
#pragma once
#include "stream_processor.hpp"

#include <utils/function.hpp>
#include <network/tcp_client_socket.hpp>

#include <thread>
#include <functional>
#include <condition_variable>

namespace gdb_stub
{
    class connection_handler
    {
      public:
        connection_handler(network::tcp_client_socket& client, utils::optional_function<bool()> should_stop = {});
        ~connection_handler();

        connection_handler(connection_handler&&) = delete;
        connection_handler(const connection_handler&) = delete;

        connection_handler& operator=(connection_handler&&) = delete;
        connection_handler& operator=(const connection_handler&) = delete;

        std::optional<std::string> get_packet();

        void send_reply(std::string_view data);
        void send_raw_data(std::string_view data);

        void close() const;

        bool should_stop() const;

      private:
        utils::optional_function<bool()> should_stop_{};
        network::tcp_client_socket& client_;
        stream_processor processor_{};

        std::mutex mutex_{};
        std::atomic_bool stop_{};
        std::string output_stream_{};
        std::thread output_thread_{};
        std::condition_variable condition_variable_{};

        void transmission_loop();
        void await_transmission(const std::function<void()>& handler);
        std::string get_next_data_to_transmit();
    };
}

```

`src/gdb-stub/gdb_stub.cpp`:

```cpp
#include "gdb_stub.hpp"

#include <cassert>
#include <cinttypes>

#include <utils/string.hpp>
#include <platform/compiler.hpp>
#include <network/tcp_server_socket.hpp>

#include "async_handler.hpp"
#include "connection_handler.hpp"

using namespace std::literals;

namespace gdb_stub
{
    namespace
    {
        void rt_assert(const bool condition)
        {
            (void)condition;
            assert(condition);
        }

        struct debugging_state
        {
            std::optional<uint32_t> continuation_thread{};
        };

        struct debugging_context
        {
            connection_handler& connection;
            debugging_handler& handler;
            debugging_state& state;
            async_handler& async;
        };

        network::tcp_client_socket accept_client(const network::address& bind_address, const utils::optional_function<bool()>& should_stop)
        {
            network::tcp_server_socket server{bind_address.get_family()};
            if (!server.bind(bind_address))
            {
                return false;
            }

            server.set_blocking(false);
            server.listen();

            while (true)
            {
                if (should_stop() || server.sleep(100ms))
                {
                    break;
                }
            }

            return server.accept();
        }

        std::pair<std::string_view, std::string_view> split_string(const std::string_view payload, const char separator)
        {
            auto name = payload;
            std::string_view args{};

            const auto separator_pos = payload.find_first_of(separator);
            if (separator_pos != std::string_view::npos)

            {
                name = payload.substr(0, separator_pos);
                args = payload.substr(separator_pos + 1);
            }

            return {name, args};
        }

        void send_xfer_data(connection_handler& connection, const std::string& args, const std::string_view data)
        {
            size_t offset{};
            size_t length{};

            rt_assert(sscanf_s(args.c_str(), "%zx,%zx", &offset, &length) == 2);

            if (offset >= data.size())
            {
                connection.send_reply("l");
                return;
            }

            const auto remaining = data.size() - offset;
            const auto real_length = std::min(remaining, length);
            const auto is_end = real_length == remaining;

            const auto sub_region = data.substr(offset, real_length);

            std::string reply = is_end ? "l" : "m";
            reply.append(sub_region);

            connection.send_reply(reply);
        }

        void handle_features(const debugging_context& c, const std::string_view payload)
        {
            const auto [command, args] = split_string(payload, ':');

            if (command != "read")
            {
                c.connection.send_reply({});
                return;
            }

            const auto [file, data] = split_string(args, ':');
            const auto target_description = c.handler.get_target_description(file);
            send_xfer_data(c.connection, std::string(data), target_description);
        }

        std::string escape_xml(const std::string& str)
        {
            std::string result;
            result.reserve(str.size());
            for (char c : str)
            {
                switch (c)
                {
                case '&':
                    result += "&amp;";
                    break;
                case '<':
                    result += "&lt;";
                    break;
                case '>':
                    result += "&gt;";
                    break;
                case '"':
                    result += "&quot;";
                    break;
                default:
                    result += c;
                    break;
                }
            }
            return result;
        }

        void handle_libraries(const debugging_context& c, const std::string_view payload)
        {
            const auto [command, args] = split_string(payload, ':');

            if (command != "read")
            {
                c.connection.send_reply({});
                return;
            }

            c.handler.reset_library_stop();

            const auto [annex, data] = split_string(args, ':');
            (void)annex; // annex is empty for libraries

            std::string xml = "<library-list version=\"1.0\">\n";

            for (const auto& library : c.handler.get_libraries())
            {
                xml += "<library name=\"";
                xml += escape_xml(library.name);
                xml += "\"><segment address=\"0x";
                xml += utils::string::to_hex_number(library.segment_address);
                xml += "\"/></library>\n";
            }

            xml += "</library-list>";

            send_xfer_data(c.connection, std::string(data), xml);
        }

        void handle_exec_file(const debugging_context& c, const std::string_view payload)
        {
            const auto [command, args] = split_string(payload, ':');

            if (command != "read")
            {
                c.connection.send_reply({});
                return;
            }

            const auto [annex, data] = split_string(args, ':');
            (void)annex; // we ignore the annex

            const auto exec_path = c.handler.get_executable_path();
            send_xfer_data(c.connection, std::string(data), exec_path);
        }

        void process_xfer(const debugging_context& c, const std::string_view payload)
        {
            auto [name, args] = split_string(payload, ':');

            if (name == "features")
            {
                handle_features(c, args);
            }
            else if (name == "libraries")
            {
                handle_libraries(c, args);
            }
            else if (name == "exec-file")
            {
                handle_exec_file(c, args);
            }
            else
            {
                c.connection.send_reply({});
            }
        }

        void process_query(const debugging_context& c, const std::string_view payload)
        {
            const auto [name, args] = split_string(payload, ':');

            if (name == "Supported")
            {
                c.connection.send_reply("PacketSize=1024;qXfer:features:read+;qXfer:libraries:read+;qXfer:exec-file:read+");
            }
            else if (name == "Attached")
            {
                c.connection.send_reply("1");
            }
            else if (name == "Xfer")
            {
                process_xfer(c, args);
            }
            else if (name == "Symbol")
            {
                c.connection.send_reply("OK");
            }
            else if (name == "C")
            {
                const auto thread_id = c.handler.get_current_thread_id();
                c.connection.send_reply("QC" + utils::string::to_hex_number(thread_id));
            }
            else if (name == "sThreadInfo")
            {
                c.connection.send_reply("l");
            }
            else if (name == "fThreadInfo")
            {
                std::string reply{};
                const auto ids = c.handler.get_thread_ids();

                for (const auto id : ids)
                {
                    reply.push_back(reply.empty() ? 'm' : ',');
                    reply.append(utils::string::to_hex_number(id));
                }

                c.connection.send_reply(reply);
            }
            else
            {
                c.connection.send_reply({});
            }
        }

        void process_action(const connection_handler& connection, const action a)
        {
            if (a == action::shutdown)
            {
                connection.close();
            }
        }

        breakpoint_type translate_breakpoint_type(const uint32_t type)
        {
            if (type >= static_cast<size_t>(breakpoint_type::END))
            {
                return breakpoint_type::software;
            }

            return static_cast<breakpoint_type>(type);
        }

        bool change_breakpoint(debugging_handler& handler, const bool set, const breakpoint_type type, const uint64_t address,
                               const size_t size)
        {
            if (set)
            {
                return handler.set_breakpoint(type, address, size);
            }

            return handler.delete_breakpoint(type, address, size);
        }

        void handle_breakpoint(const debugging_context& c, const std::string& data, const bool set)
        {
            uint32_t type{};
            uint64_t addr{};
            size_t kind{};
            rt_assert(sscanf_s(data.c_str(), "%x,%" PRIX64 ",%zx", &type, &addr, &kind) == 3);

            const auto res = change_breakpoint(c.handler, set, translate_breakpoint_type(type), addr, kind);
            c.connection.send_reply(res ? "OK" : "E01");
        }

        void signal_stop(const debugging_context& c)
        {
            const auto exit_status = c.handler.get_exit_code();
            if (exit_status)
            {
                c.connection.send_reply(*exit_status == 0 ? "W00" : "WFF");
                return;
            }

            const auto id = c.handler.get_current_thread_id();
            const auto hex_id = utils::string::to_hex_number(id);

            std::string reply = "T05";

            if (c.handler.should_signal_library())
            {
                reply += "library:;";
            }

            reply += "thread:" + hex_id + ";";

            c.connection.send_reply(reply);
        }

        void apply_continuation_thread(const debugging_context& c)
        {
            if (c.state.continuation_thread)
            {
                c.handler.switch_to_thread(*c.state.continuation_thread);
                c.state.continuation_thread = std::nullopt;
            }
        }

        void resume_execution(const debugging_context& c, const bool single_step)
        {
            apply_continuation_thread(c);

            action a{};

            if (single_step)
            {
                a = c.handler.singlestep();
            }
            else
            {
                c.async.run();
                a = c.handler.run();
                c.async.pause();
            }

            process_action(c.connection, a);
            signal_stop(c);
        }

        void store_continuation_thread(const debugging_context& c, const std::string_view thread_string)
        {
            if (thread_string.empty())
            {
                return;
            }

            uint32_t thread_id{};
            rt_assert(sscanf_s(std::string(thread_string).c_str(), "%x", &thread_id) == 1);
            c.state.continuation_thread = thread_id;
        }

        void handle_v_packet(const debugging_context& c, const std::string_view data)
        {
            const auto [name, args] = split_string(data, ':');

            if (name == "Cont?")
            {
                c.connection.send_reply("vCont;s;c");
            }
            else if (name == "Cont;s" || name == "Cont;c")
            {
                const auto singlestep = name[5] == 's';
                const auto [thread, _] = split_string(args, ':');

                store_continuation_thread(c, thread);
                resume_execution(c, singlestep);
            }
            else
            {
                c.connection.send_reply({});
            }
        }

        void read_registers(const debugging_context& c)
        {
            std::string response{};
            std::vector<std::byte> data{};
            data.resize(c.handler.get_max_register_size());

            const auto registers = c.handler.get_register_count();

            for (size_t i = 0; i < registers; ++i)
            {
                const auto size = c.handler.read_register(i, data.data(), data.size());

                if (!size)
                {
                    c.connection.send_reply("E01");
                    return;
                }

                const std::span register_data(data.data(), size);
                response.append(utils::string::to_hex_string(register_data));
            }

            c.connection.send_reply(response);
        }

        void write_registers(const debugging_context& c, const std::string_view payload)
        {
            const auto data = utils::string::from_hex_string(payload);

            const auto registers = c.handler.get_register_count();
            const auto register_size = c.handler.get_max_register_size();

            size_t offset = 0;
            for (size_t i = 0; i < registers; ++i)
            {
                if (offset >= data.size())
                {
                    c.connection.send_reply("E01");
                    return;
                }

                const auto max_size = std::min(register_size, data.size() - offset);
                const auto size = c.handler.write_register(i, data.data() + offset, max_size);

                offset += size;

                if (!size)
                {
                    c.connection.send_reply("E01");
                    return;
                }
            }

            c.connection.send_reply("OK");
        }

        void read_single_register(const debugging_context& c, const std::string& payload)
        {
            size_t reg{};
            rt_assert(sscanf_s(payload.c_str(), "%zx", &reg) == 1);

            std::vector<std::byte> data{};
            data.resize(c.handler.get_max_register_size());

            const auto size = c.handler.read_register(reg, data.data(), data.size());

            if (size)
            {
                const std::span register_data(data.data(), size);
                c.connection.send_reply(utils::string::to_hex_string(register_data));
            }
            else
            {
                c.connection.send_reply("E01");
            }
        }

        void write_single_register(const debugging_context& c, const std::string_view payload)
        {
            const auto [reg, hex_data] = split_string(payload, '=');

            size_t register_index{};
            rt_assert(sscanf_s(std::string(reg).c_str(), "%zx", &register_index) == 1);

            const auto data = utils::string::from_hex_string(hex_data);
            const auto res = c.handler.write_register(register_index, data.data(), data.size()) > 0;
            c.connection.send_reply(res ? "OK" : "E01");
        }

        void read_memory(const debugging_context& c, const std::string& payload)
        {
            uint64_t address{};
            size_t size{};
            rt_assert(sscanf_s(payload.c_str(), "%" PRIx64 ",%zx", &address, &size) == 2);

            if (size > 0x1000)
            {
                c.connection.send_reply("E01");
                return;
            }

            std::vector<std::byte> data{};
            data.resize(size);

            const auto res = c.handler.read_memory(address, data.data(), data.size());
            if (!res)
            {
                c.connection.send_reply("E01");
                return;
            }

            c.connection.send_reply(utils::string::to_hex_string(data));
        }

        void write_memory(const debugging_context& c, const std::string_view payload)
        {
            const auto [info, hex_data] = split_string(payload, ':');

            size_t size{};
            uint64_t address{};
            rt_assert(sscanf_s(std::string(info).c_str(), "%" PRIx64 ",%zx", &address, &size) == 2);

            if (size > 0x1000)
            {
                c.connection.send_reply("E01");
                return;
            }

            auto data = utils::string::from_hex_string(hex_data);
            data.resize(size);

            const auto res = c.handler.write_memory(address, data.data(), data.size());
            c.connection.send_reply(res ? "OK" : "E01");
        }

        std::string decode_x_memory(const std::string_view payload)
        {
            std::string result{};
            result.reserve(payload.size());

            bool xor_next = false;

            for (auto value : payload)
            {
                if (xor_next)
                {
                    value ^= 0x20;
                    xor_next = false;
                }
                else if (value == '}')
                {
                    xor_next = true;
                    continue;
                }

                result.push_back(value);
            }

            return result;
        }

        void write_x_memory(const debugging_context& c, const std::string_view payload)
        {
            const auto [info, encoded_data] = split_string(payload, ':');

            size_t size{};
            uint64_t address{};
            rt_assert(sscanf_s(std::string(info).c_str(), "%" PRIx64 ",%zx", &address, &size) == 2);

            if (size > 0x1000)
            {
                c.connection.send_reply("E01");
                return;
            }

            auto data = decode_x_memory(encoded_data);
            data.resize(size);

            const auto res = c.handler.write_memory(address, data.data(), data.size());
            if (!res)
            {
                c.connection.send_reply("E01");
                return;
            }

            c.connection.send_reply("OK");
        }

        void switch_to_thread(const debugging_context& c, const std::string_view payload)
        {
            if (payload.size() < 2)
            {
                c.connection.send_reply({});
                return;
            }

            uint32_t id{};
            rt_assert(sscanf_s(std::string(payload.substr(1)).c_str(), "%x", &id) == 1);

            const auto operation = payload[0];
            if (operation == 'c')
            {
                c.state.continuation_thread = id;
                c.connection.send_reply("OK");
            }
            else if (operation == 'g')
            {
                const auto res = id == 0 || c.handler.switch_to_thread(id);
                c.connection.send_reply(res ? "OK" : "E01");
            }
            else
            {
                c.connection.send_reply({});
            }
        }

        void handle_command(const debugging_context& c, const uint8_t command, const std::string_view data)
        {
            // printf("GDB command: %c -> %.*s\n", command, static_cast<int>(data.size()), data.data());

            switch (command)
            {
            case 'S':
            case 'c':
                resume_execution(c, false);
                break;

            case 's':
                resume_execution(c, true);
                break;

            case 'q':
                process_query(c, data);
                break;

            case 'D':
                c.connection.close();
                break;

            case 'z':
            case 'Z':
                handle_breakpoint(c, std::string(data), command == 'Z');
                break;

            case '?':
                signal_stop(c);
                break;

            case 'v':
                handle_v_packet(c, data);
                break;

            case 'g':
                read_registers(c);
                break;

            case 'G':
                write_registers(c, data);
                break;

            case 'p':
                read_single_register(c, std::string(data));
                break;

            case 'P':
                write_single_register(c, data);
                break;

            case 'm':
                read_memory(c, std::string(data));
                break;

            case 'M':
                write_memory(c, data);
                break;

            case 'X':
                write_x_memory(c, data);
                break;

            case 'H':
                switch_to_thread(c, data);
                break;

            default:
                c.connection.send_reply({});
                break;
            }
        }

        void process_packet(const debugging_context& c, const std::string_view packet)
        {
            c.connection.send_raw_data("+");

            if (packet.empty())
            {
                return;
            }

            const auto command = packet.front();
            handle_command(c, command, packet.substr(1));
        }

        bool is_interrupt_packet(const std::optional<std::string>& data)
        {
            return data && data->size() == 1 && data->front() == '\x03';
        }
    }

    bool run_gdb_stub(const network::address& bind_address, debugging_handler& handler)
    {
        const auto should_stop = [&] {
            return handler.should_stop(); //
        };

        auto client = accept_client(bind_address, should_stop);
        if (!client)
        {
            return false;
        }

        async_handler async{[&](std::atomic_bool& can_run) {
            while (can_run)
            {
                (void)client.sleep(100ms);
                const auto data = client.receive(1);

                if (is_interrupt_packet(data) || !client.is_valid() || should_stop())
                {
                    handler.on_interrupt();
                    can_run = false;
                }
            }
        }};

        debugging_state state{};
        connection_handler connection{client, should_stop};

        debugging_context c{
            .connection = connection,
            .handler = handler,
            .state = state,
            .async = async,
        };

        while (!should_stop())
        {
            const auto packet = connection.get_packet();
            if (!packet || should_stop())
            {
                break;
            }

            process_packet(c, *packet);
        }

        return true;
    }
}

```

`src/gdb-stub/gdb_stub.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <network/address.hpp>

namespace gdb_stub
{
    enum class action : uint8_t
    {
        none,
        resume,
        shutdown,
    };

    enum class breakpoint_type : uint8_t
    {
        software = 0,
        hardware_exec = 1,
        hardware_write = 2,
        hardware_read = 3,
        hardware_read_write = 4,
        END,
    };

    struct library_info
    {
        std::string name;
        uint64_t segment_address;
    };

    struct debugging_handler
    {
        virtual ~debugging_handler() = default;

        virtual action run() = 0;
        virtual action singlestep() = 0;

        virtual size_t get_register_count() = 0;
        virtual size_t get_max_register_size() = 0;

        virtual size_t read_register(size_t reg, void* data, size_t max_length) = 0;
        virtual size_t write_register(size_t reg, const void* data, size_t size) = 0;

        virtual bool read_memory(uint64_t address, void* data, size_t length) = 0;
        virtual bool write_memory(uint64_t address, const void* data, size_t length) = 0;

        virtual bool set_breakpoint(breakpoint_type type, uint64_t address, size_t size) = 0;
        virtual bool delete_breakpoint(breakpoint_type type, uint64_t address, size_t size) = 0;

        virtual void on_interrupt() = 0;

        virtual std::string get_target_description(std::string_view file) = 0;

        virtual bool switch_to_thread(uint32_t thread_id) = 0;

        virtual uint32_t get_current_thread_id() = 0;
        virtual std::vector<uint32_t> get_thread_ids() = 0;

        virtual std::optional<uint32_t> get_exit_code() = 0;

        virtual bool should_stop()
        {
            return false;
        }

        virtual std::vector<library_info> get_libraries()
        {
            return {};
        }

        virtual void reset_library_stop()
        {
        }

        virtual bool should_signal_library()
        {
            return false;
        }

        virtual std::string get_executable_path()
        {
            return {};
        }
    };

    bool run_gdb_stub(const network::address& bind_address, debugging_handler& handler);
}

```

`src/gdb-stub/stream_processor.cpp`:

```cpp
#include "stream_processor.hpp"
#include "checksum.hpp"

#include <cassert>
#include <stdexcept>

namespace gdb_stub
{
    namespace
    {
        void trim_data_stream_start(std::string& stream)
        {
            while (!stream.empty() && stream.front() != '$')
            {
                stream.erase(stream.begin());
            }
        }
    }

    bool stream_processor::has_packet() const
    {
        return !this->packets_.empty();
    }

    std::string stream_processor::get_next_packet()
    {
        if (this->packets_.empty())
        {
            throw std::runtime_error("No packet available");
        }

        auto packet = std::move(this->packets_.front());
        this->packets_.pop();

        return packet;
    }

    void stream_processor::push_stream_data(const std::string& data)
    {
        this->stream_.append(data);
        this->process_data_stream();
    }

    void stream_processor::process_data_stream()
    {
        while (true)
        {
            trim_data_stream_start(this->stream_);

            const auto end = this->stream_.find_first_of('#');
            if (end == std::string::npos)
            {
                break;
            }

            const auto packet_size = end + CHECKSUM_SIZE + 1;

            if (packet_size > this->stream_.size())
            {
                break;
            }

            auto packet = this->stream_.substr(0, packet_size);
            this->stream_.erase(0, packet_size);

            this->enqueue_packet(std::move(packet));
        }
    }

    void stream_processor::enqueue_packet(std::string packet)
    {
        constexpr auto END_BYTES = CHECKSUM_SIZE + 1;

        if (packet.size() < (END_BYTES + 1) //
            || packet.front() != '$'        //
            || packet[packet.size() - END_BYTES] != '#')
        {
            return;
        }

        const auto checksum = strtoul(packet.c_str() + packet.size() - CHECKSUM_SIZE, nullptr, 16);
        assert((checksum & 0xFF) == checksum);

        packet.erase(packet.begin());
        packet.erase(packet.size() - END_BYTES, END_BYTES);

        const auto computed_checksum = compute_checksum(packet);

        if (computed_checksum == checksum)
        {
            this->packets_.push(std::move(packet));
        }
    }
}

```

`src/gdb-stub/stream_processor.hpp`:

```hpp
#pragma once
#include <queue>
#include <string>

namespace gdb_stub
{
    class stream_processor
    {
      public:
        bool has_packet() const;
        std::string get_next_packet();
        void push_stream_data(const std::string& data);

      private:
        std::string stream_{};
        std::queue<std::string> packets_{};

        void process_data_stream();
        void enqueue_packet(std::string packet);
    };
}

```

`src/samples/CMakeLists.txt`:

```txt
momo_get_all_targets(EXISTING_TARGETS)

##########################################

add_subdirectory(bad-sample)
add_subdirectory(test-sample)

##########################################

momo_get_all_targets(ALL_TARGETS)
momo_list_difference("${ALL_TARGETS}" "${EXISTING_TARGETS}" SAMPLE_TARGETS)
momo_targets_remove_compile_options("${SAMPLE_TARGETS}" /arch:AVX2 -mavx2)
```

`src/samples/bad-sample/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(bad-sample ${SRC_FILES})
target_link_libraries(bad-sample PRIVATE emulator-common)

momo_assign_source_group(${SRC_FILES})

```

`src/samples/bad-sample/bad.cpp`:

```cpp
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <platform/compiler.hpp>

#define THE_SIZE 30

extern "C" NO_INLINE EXPORT_SYMBOL void vulnerable(const uint8_t* data, const size_t size)
{
    if (size < 10)
    {
        return;
    }

    if (data[9] != 'A')
    {
        return;
    }

    if (data[8] != 'B')
    {
        return;
    }

    if (data[7] != 'C')
    {
        return;
    }

    if (data[2] != 'V')
    {
        return;
    }

    if (data[4] != 'H')
    {
        return;
    }

    if (size < 100)
    {
        return;
    }

    *(int*)1 = 1;
}

uint8_t buffer[THE_SIZE] = {};

int main(int argc, const char* argv[])
{
    const void* input = buffer;
    auto size = sizeof(buffer);

    if (argc > 1)
    {
        input = argv[1];
        size = strlen(argv[1]);
    }

    vulnerable((uint8_t*)input, size);
    return 0;
}

```

`src/samples/minimal-32bit-sample/hello.asm`:

```asm
.386
.model flat, stdcall
option casemap:none

includelib ntdll.lib

extrn _imp__NtCreateFile@44:DWORD        ; 11 * 4 = 44
extrn _imp__NtWriteFile@36:DWORD         ; 9  * 4 = 36
extrn _imp__NtTerminateProcess@8:DWORD   ; 2  * 4 = 8

STATUS_SUCCESS          equ 0
GENERIC_WRITE          equ 40000000h
SYNCHRONIZE            equ 00100000h
FILE_ATTRIBUTE_NORMAL  equ 00000080h
FILE_SHARE_READ        equ 00000001h
FILE_SHARE_WRITE       equ 00000002h
FILE_OPEN              equ 00000001h
FILE_SYNCHRONOUS_IO_NONALERT equ 00000020h
OBJ_CASE_INSENSITIVE   equ 00000040h

UNICODE_STRING STRUCT
    Length1         WORD    ?
    MaximumLength   WORD    ?
    Buffer          DWORD   ?
UNICODE_STRING ENDS

OBJECT_ATTRIBUTES STRUCT
    Length1                 DWORD   ?
    RootDirectory          DWORD   ?
    ObjectName             DWORD   ?
    Attributes             DWORD   ?
    SecurityDescriptor     DWORD   ?
    SecurityQualityOfService DWORD ?
OBJECT_ATTRIBUTES ENDS

IO_STATUS_BLOCK STRUCT
    Status      DWORD   ?
    Information DWORD   ?
IO_STATUS_BLOCK ENDS

.data
    ConsoleName     dw 005Ch, 003Fh, 003Fh, 005Ch, 0043h, 004Fh, 004Eh, 004Fh, 0055h, 0054h, 0024h, 0000h
    
    HelloMsg        db 'hello', 0Dh, 0Ah
    HelloMsgLen     equ $ - HelloMsg
    
    DeviceName      UNICODE_STRING <22, 24, OFFSET ConsoleName>
    
    ObjAttr         OBJECT_ATTRIBUTES <18h, 0, OFFSET DeviceName, OBJ_CASE_INSENSITIVE, 0, 0>
    
    IoStatus        IO_STATUS_BLOCK <0, 0>
    
    hConsole        DWORD   0

.code
start:
    push    0                               ; EaLength
    push    0                               ; EaBuffer
    push    FILE_SYNCHRONOUS_IO_NONALERT    ; CreateOptions
    push    FILE_OPEN                       ; CreateDisposition
    push    FILE_SHARE_READ or FILE_SHARE_WRITE ; ShareAccess
    push    FILE_ATTRIBUTE_NORMAL           ; FileAttributes
    push    0                               ; AllocationSize
    push    OFFSET IoStatus                 ; IoStatusBlock
    push    OFFSET ObjAttr                  ; ObjectAttributes
    push    GENERIC_WRITE or SYNCHRONIZE    ; DesiredAccess
    push    OFFSET hConsole                 ; FileHandle
    call    dword ptr [_imp__NtCreateFile@44]
    
    test    eax, eax
    jnz     exit_error
    
    push    0                   ; Key
    push    0                   ; ByteOffset
    push    HelloMsgLen         ; Length
    push    OFFSET HelloMsg     ; Buffer
    push    OFFSET IoStatus     ; IoStatusBlock
    push    0                   ; ApcContext
    push    0                   ; ApcRoutine
    push    0                   ; Event
    push    hConsole            ; FileHandle
    call    dword ptr [_imp__NtWriteFile@36]
    
    push    0                   ; ExitStatus
    push    -1                  ; ProcessHandle
    call    dword ptr [_imp__NtTerminateProcess@8]
    
exit_error:
    push    1                   ; ExitStatus
    push    -1                  ; ProcessHandle
    call    dword ptr [_imp__NtTerminateProcess@8]

end start
```

`src/samples/test-sample/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(test-sample ${SRC_FILES})

if(WIN)
  target_link_libraries(test-sample PRIVATE ws2_32)
endif()

momo_assign_source_group(${SRC_FILES})

```

`src/samples/test-sample/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "Windows Emulator Test Sample"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "test-sample"
            VALUE "LegalCopyright", "All rights reserved."
            VALUE "OriginalFilename", "test-sample.exe"
            VALUE "ProductName", "test-sample"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

GLFW_ICON       ICON   "resources/icon.ico"


#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/samples/test-sample/test.cpp`:

```cpp
#include <cstdint>
#include <cinttypes>
#include <cstring>
#include <string>
#include <fstream>
#include <thread>
#include <atomic>
#include <vector>
#include <optional>
#include <filesystem>
#include <string_view>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#define WIN32_LEAN_AND_MEAN
#include <intrin.h>

#ifdef __MINGW64__
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <Windows.h>
#include <WinSock2.h>
#include <WS2tcpip.h>
#endif

using namespace std::literals;

// Externally visible and potentially modifiable state
// to trick compiler optimizations
__declspec(dllexport) bool do_the_task = true;

namespace
{
    struct tls_struct
    {
        DWORD num = 1337;

        tls_struct()
        {
            num = GetCurrentThreadId();
        }
    };

    thread_local tls_struct tls_var{};

    // getenv is broken right now :(
    std::string read_env(const char* env)
    {
        char buffer[0x1000] = {};
        if (!GetEnvironmentVariableA(env, buffer, sizeof(buffer)))
        {
            return {};
        }

        return buffer;
    }

    bool test_threads()
    {
        constexpr auto thread_count = 5ULL;

        std::atomic<uint64_t> counter{0};

        std::vector<std::thread> threads{};
        threads.reserve(thread_count);

        for (auto i = 0ULL; i < thread_count; ++i)
        {
            threads.emplace_back([&counter] {
                ++counter;
                std::this_thread::yield();
                ++counter;
                // Host scheduling/cpu performance can have impact on emulator scheduling
                // std::this_thread::sleep_for(std::chrono::milliseconds(100));
                ++counter;
            });
        }

        for (auto& t : threads)
        {
            t.join();
        }

        return counter == (thread_count * 3ULL);
    }

    bool test_threads_winapi()
    {
        struct ctx_t
        {
            int iterations;
            int result;
        };

        static LPTHREAD_START_ROUTINE thread_proc = [](LPVOID lpParameter) -> DWORD {
            ctx_t& c = *static_cast<ctx_t*>(lpParameter);
            c.result = 0;
            for (int i = 1; i <= c.iterations; i++)
            {
                ++c.result;
            }
            return 0;
        };

        constexpr int thread_count = 5;
        HANDLE threads[thread_count] = {nullptr};
        ctx_t ctxs[thread_count] = {};

        for (int i = 0; i < thread_count; i++)
        {
            ctxs[i] = {5 * (i + 1), 0};
            threads[i] = CreateThread(nullptr, 0, thread_proc, &ctxs[i], 0, nullptr);
            if (!threads[i])
            {
                return false;
            }
        }

        WaitForMultipleObjects(thread_count, threads, TRUE, INFINITE);

        const int expected_results[thread_count] = {5, 10, 15, 20, 25};
        for (int i = 0; i < thread_count; i++)
        {
            if (ctxs[i].result != expected_results[i])
            {
                return false;
            }
            CloseHandle(threads[i]);
        }

        return true;
    }

    bool test_tls()
    {
        std::atomic_bool kill{false};
        std::atomic_uint32_t successes{0};
        constexpr uint32_t thread_count = 2;

        std::vector<std::thread> ts{};
        kill = false;

        for (size_t i = 0; i < thread_count; ++i)
        {
            ts.emplace_back([&] {
                while (!kill)
                {
                    std::this_thread::yield();
                }

                if (tls_var.num == GetCurrentThreadId())
                {
                    ++successes;
                }
            });
        }

        LoadLibraryA("d3dcompiler_47.dll");
        LoadLibraryA("dsound.dll");
        LoadLibraryA("comctl32.dll");
        /*LoadLibraryA("d3d9.dll");
        LoadLibraryA("dxgi.dll");
        LoadLibraryA("wlanapi.dll");*/

        kill = true;

        for (auto& t : ts)
        {
            if (t.joinable())
            {
                t.join();
            }
        }

        return successes == thread_count;
    }

    bool test_env()
    {
        const auto computername = read_env("COMPUTERNAME");

        SetEnvironmentVariableA("BLUB", "LUL");

        const auto blub = read_env("BLUB");

        return !computername.empty() && blub == "LUL";
    }

    bool test_file_path_io(const std::filesystem::path& filename)
    {
        std::error_code ec{};
        const auto absolute_file = absolute(filename, ec);

        if (ec)
        {
            puts("Getting absolute path failed");
            return false;
        }

        const auto canonical_file = canonical(filename, ec);
        (void)canonical_file;

        if (ec)
        {
            puts("Getting canonical path failed");
            return false;
        }

        return true;
    }

    bool test_io()
    {
        const std::filesystem::path filename1 = "a.txt";
        const std::filesystem::path filename2 = "A.tXt";

        FILE* fp{};
        (void)fopen_s(&fp, filename1.string().c_str(), "wb");

        if (!fp)
        {
            puts("Bad file");
            return false;
        }

        const std::string text = "Blub";

        (void)fwrite(text.data(), 1, text.size(), fp);
        (void)fclose(fp);

        if (!test_file_path_io(filename1))
        {
            return false;
        }

        std::ifstream t(filename2);
        t.seekg(0, std::ios::end);
        const size_t size = t.tellg();
        std::string buffer(size, ' ');
        t.seekg(0);
        t.read(buffer.data(), static_cast<std::streamsize>(size));

        return text == buffer;
    }

    bool test_working_directory()
    {
        std::error_code ec{};

        const auto current_dir = std::filesystem::current_path(ec);
        if (ec)
        {
            puts("Failed to get current path");
            return false;
        }

        const std::filesystem::path sys32 = "C:/windows/system32";
        current_path(sys32, ec);

        if (ec)
        {
            puts("Failed to update working directory");
            return false;
        }

        const auto new_current_dir = std::filesystem::current_path();
        if (sys32 != new_current_dir)
        {
            puts("Updated directory is wrong!");
            return false;
        }

        if (!std::ifstream("ntdll.dll"))
        {
            puts("Working directory is not active!");
            return false;
        }

        current_path(current_dir);
        return std::filesystem::current_path() == current_dir;
    }

    bool test_dir_io()
    {
        size_t count = 0;

        for (auto i : std::filesystem::directory_iterator(R"(C:\Windows\System32\)"))
        {
            ++count;
            if (count > 30)
            {
                return true;
            }
        }

        return count > 30;
    }

    std::optional<std::string> read_registry_string(const HKEY root, const char* path, const char* value)
    {
        HKEY key{};
        if (RegOpenKeyExA(root, path, 0, KEY_READ, &key) != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        char data[MAX_PATH]{};
        DWORD length = sizeof(data);
        const auto res = RegQueryValueExA(key, value, nullptr, nullptr, reinterpret_cast<uint8_t*>(data), &length);

        if (RegCloseKey(key) != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        if (res != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        if (length == 0)
        {
            return "";
        }

        return {std::string(data, std::min(static_cast<size_t>(length - 1), sizeof(data)))};
    }

    std::optional<std::vector<std::string>> get_all_registry_keys(const HKEY root, const char* path)
    {
        HKEY key{};
        if (RegOpenKeyExA(root, path, 0, KEY_READ | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &key) != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        std::vector<std::string> keys;
        std::vector<char> name_buffer(MAX_PATH + 1);

        for (DWORD i = 0;; ++i)
        {
            auto name_buffer_len = static_cast<DWORD>(name_buffer.size());
            const LSTATUS status = RegEnumKeyExA(key, i, name_buffer.data(), &name_buffer_len, nullptr, nullptr, nullptr, nullptr);
            if (status == ERROR_SUCCESS)
            {
                keys.emplace_back(name_buffer.data(), name_buffer_len);
            }
            else if (status == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            else
            {
                keys.clear();
                break;
            }
        }

        if (keys.empty())
        {
            RegCloseKey(key);
            return std::nullopt;
        }

        if (RegCloseKey(key) != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        return keys;
    }

    std::optional<std::vector<std::string>> get_all_registry_values(const HKEY root, const char* path)
    {
        HKEY key{};
        if (RegOpenKeyExA(root, path, 0, KEY_READ | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &key) != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        std::vector<std::string> values;
        std::vector<char> name_buffer(MAX_PATH + 1);

        for (DWORD i = 0;; ++i)
        {
            auto name_buffer_len = static_cast<DWORD>(name_buffer.size());
            const auto status = RegEnumValueA(key, i, name_buffer.data(), &name_buffer_len, nullptr, nullptr, nullptr, nullptr);
            if (status == ERROR_SUCCESS)
            {
                values.emplace_back(name_buffer.data(), name_buffer_len);
            }
            else if (status == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            else
            {
                values.clear();
                break;
            }
        }

        if (values.empty())
        {
            RegCloseKey(key);
            return std::nullopt;
        }

        if (RegCloseKey(key) != ERROR_SUCCESS)
        {
            return std::nullopt;
        }

        return values;
    }

    bool test_registry()
    {
        // Basic Reading Test
        const auto prog_files_dir =
            read_registry_string(HKEY_LOCAL_MACHINE, R"(SOFTWARE\Microsoft\Windows\CurrentVersion)", "ProgramFilesDir");
        if (!prog_files_dir || *prog_files_dir != "C:\\Program Files")
        {
            return false;
        }

        // WOW64 Redirection Test
        const auto pst_display = read_registry_string(
            HKEY_LOCAL_MACHINE, R"(SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Time Zones\Pacific Standard Time)", "Display");
        if (!pst_display || pst_display->empty())
        {
            return false;
        }

        // Key Sub-keys Enumeration Test
        const auto subkeys_opt = get_all_registry_keys(HKEY_LOCAL_MACHINE, R"(SOFTWARE\Microsoft\Windows NT\CurrentVersion)");
        if (!subkeys_opt)
        {
            return false;
        }

        bool found_fonts = false;
        for (const auto& key_name : *subkeys_opt)
        {
            if (key_name == "Fonts")
            {
                found_fonts = true;
                break;
            }
        }
        if (!found_fonts)
        {
            return false;
        }

        // Key Values Enumeration Test
        const auto values_opt = get_all_registry_values(HKEY_LOCAL_MACHINE, R"(SOFTWARE\Microsoft\Windows NT\CurrentVersion)");
        if (!values_opt)
        {
            return false;
        }

        bool found_product_name = false;
        for (const auto& val_name : *values_opt)
        {
            if (val_name == "ProductName")
            {
                found_product_name = true;
                break;
            }
        }
        if (!found_product_name)
        {
            return false;
        }

        return true;
    }

    bool test_system_info()
    {
        char sys_dir[MAX_PATH];
        if (GetSystemDirectoryA(sys_dir, sizeof(sys_dir)) == 0)
        {
            return false;
        }
        if (strlen(sys_dir) != 19)
        {
            return false;
        }

        // TODO: This currently doesn't work.
        /*
        char username[256];
        DWORD username_len = sizeof(username);
        if (!GetUserNameA(username, &username_len))
        {
            return false;
        }
        if (username_len <= 1)
        {
            return false;
        }
        */

        return true;
    }

    bool validate_primary_monitor(MONITORINFOEXA& mi)
    {
        if (std::string_view(mi.szDevice) != R"(\\.\DISPLAY1)")
        {
            return false;
        }

        if (mi.rcMonitor.left != 0 || mi.rcMonitor.top != 0 || mi.rcMonitor.right != 1920 || mi.rcMonitor.bottom != 1080)
        {
            return false;
        }

        if (!(mi.dwFlags & MONITORINFOF_PRIMARY))
        {
            return false;
        }

        return true;
    }

    bool test_monitor_info()
    {
        const POINT pt = {0, 0};
        const auto hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
        if (!hMonitor)
        {
            return false;
        }

        MONITORINFOEXA mi;
        mi.cbSize = sizeof(mi);

        if (!GetMonitorInfoA(hMonitor, &mi))
        {
            return false;
        }

        return validate_primary_monitor(mi);
    }

    BOOL CALLBACK monitor_enum_proc(HMONITOR hMonitor, HDC, LPRECT, LPARAM dwData)
    {
        auto* valid = reinterpret_cast<bool*>(dwData);

        MONITORINFOEXA mi;
        mi.cbSize = sizeof(mi);

        if (!GetMonitorInfoA(hMonitor, &mi))
        {
            return FALSE;
        }

        *valid = validate_primary_monitor(mi);

        return *valid ? TRUE : FALSE;
    }

    bool test_user_callback()
    {
        bool valid = false;
        if (!EnumDisplayMonitors(nullptr, nullptr, monitor_enum_proc, reinterpret_cast<LPARAM>(&valid)))
        {
            return false;
        }

        return valid;
    }

    bool test_time_zone()
    {
        DYNAMIC_TIME_ZONE_INFORMATION current_dtzi = {};
        DWORD result = GetDynamicTimeZoneInformation(&current_dtzi);

        if (result == TIME_ZONE_ID_INVALID)
        {
            return false;
        }

        if (current_dtzi.Bias != -60 || current_dtzi.StandardBias != 0 || current_dtzi.DaylightBias != -60 ||
            current_dtzi.DynamicDaylightTimeDisabled != FALSE)
        {
            return false;
        }

        if (wcscmp(current_dtzi.StandardName, L"W. Europe Standard Time") != 0 ||
            wcscmp(current_dtzi.DaylightName, L"W. Europe Daylight Time") != 0 ||
            wcscmp(current_dtzi.TimeZoneKeyName, L"W. Europe Standard Time") != 0)
        {
            return false;
        }

        if (current_dtzi.StandardDate.wYear != 0 || current_dtzi.StandardDate.wMonth != 10 || current_dtzi.StandardDate.wDayOfWeek != 0 ||
            current_dtzi.StandardDate.wDay != 5 || current_dtzi.StandardDate.wHour != 3 || current_dtzi.StandardDate.wMinute != 0 ||
            current_dtzi.StandardDate.wSecond != 0 || current_dtzi.StandardDate.wMilliseconds != 0)
        {
            return false;
        }

        if (current_dtzi.DaylightDate.wYear != 0 || current_dtzi.DaylightDate.wMonth != 3 || current_dtzi.DaylightDate.wDayOfWeek != 0 ||
            current_dtzi.DaylightDate.wDay != 5 || current_dtzi.DaylightDate.wHour != 2 || current_dtzi.DaylightDate.wMinute != 0 ||
            current_dtzi.DaylightDate.wSecond != 0 || current_dtzi.DaylightDate.wMilliseconds != 0)
        {
            return false;
        }

        return true;
    }

    void throw_exception()
    {
        if (do_the_task)
        {
            throw std::runtime_error("OK");
        }
    }

    bool test_exceptions()
    {
        try
        {
            throw_exception();
            return false;
        }
        catch (const std::exception& e)
        {
            return e.what() == std::string("OK");
        }
    }

    struct wsa_initializer
    {
        wsa_initializer()
        {
            WSADATA wsa_data;
            if (WSAStartup(MAKEWORD(2, 2), &wsa_data))
            {
                throw std::runtime_error("Unable to initialize WSA");
            }
        }

        ~wsa_initializer()
        {
            WSACleanup();
        }
    };

    bool test_socket()
    {
        wsa_initializer _{};
        constexpr std::string_view send_data = "Hello World";

        const auto sender = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        const auto receiver = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if (sender == INVALID_SOCKET || receiver == INVALID_SOCKET)
        {
            puts("Socket creation failed");
            return false;
        }

        sockaddr_in destination{};
        destination.sin_family = AF_INET;
        destination.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        destination.sin_port = htons(28970);

        if (bind(receiver, reinterpret_cast<sockaddr*>(&destination), sizeof(destination)) == SOCKET_ERROR)
        {
            puts("Failed to bind socket!");
            return false;
        }

        const auto sent_bytes = sendto(sender, send_data.data(), static_cast<int>(send_data.size()), 0,
                                       reinterpret_cast<sockaddr*>(&destination), sizeof(destination));

        if (static_cast<size_t>(sent_bytes) != send_data.size())
        {
            puts("Failed to send data!");
            return false;
        }

        char buffer[100] = {};
        sockaddr_in sender_addr{};
        int sender_length = sizeof(sender_addr);

        const auto len = recvfrom(receiver, buffer, sizeof(buffer), 0, reinterpret_cast<sockaddr*>(&sender_addr), &sender_length);

        if (len != send_data.size())
        {
            puts("Failed to receive data!");
            return false;
        }

        return send_data == std::string_view(buffer, len);
    }

#ifndef __MINGW64__
    void throw_access_violation()
    {
        if (do_the_task)
        {
            *reinterpret_cast<int*>(1) = 1;
        }
    }

    bool test_access_violation_exception()
    {
        __try
        {
            throw_access_violation();
            return false;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return GetExceptionCode() == STATUS_ACCESS_VIOLATION;
        }
    }

    bool test_ud2_exception(void* address)
    {
        __try
        {
            reinterpret_cast<void (*)()>(address)();
            return false;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION;
        }
    }

    bool test_unhandled_exception()
    {
        thread_local bool caught{};
        caught = false;

        auto* old = SetUnhandledExceptionFilter(+[](struct _EXCEPTION_POINTERS* ExceptionInfo) -> LONG {
            caught = true;
            ExceptionInfo->ContextRecord->Rip += 1;
            return EXCEPTION_CONTINUE_EXECUTION; //
        });

        DebugBreak();
        SetUnhandledExceptionFilter(old);

        return caught;
    }

    bool test_illegal_instruction_exception()
    {
        const auto address = VirtualAlloc(nullptr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (!address)
        {
            return false;
        }

        memcpy(address, "\x0F\x0B", 2); // ud2

        const auto res = test_ud2_exception(address);

        VirtualFree(address, 0x1000, MEM_RELEASE);

        return res;
    }

    INT32 test_guard_page_seh_filter(LPVOID address, DWORD code, struct _EXCEPTION_POINTERS* ep)
    {
        // We are only looking for guard page exceptions.
        if (code != STATUS_GUARD_PAGE_VIOLATION)
        {
            return EXCEPTION_CONTINUE_SEARCH;
        }

        // The number of defined elements in the ExceptionInformation array for
        // a guard page violation should be 2.
        if (ep->ExceptionRecord->NumberParameters != 2)
        {
            return EXCEPTION_CONTINUE_SEARCH;
        }

        // The ExceptionInformation array specifies additional arguments that
        // describe the exception.
        auto* exception_information = ep->ExceptionRecord->ExceptionInformation;

        // If this value is zero, the thread attempted to read the inaccessible
        // data. If this value is 1, the thread attempted to write to an
        // inaccessible address.
        if (exception_information[0] != 1)
        {
            return EXCEPTION_CONTINUE_SEARCH;
        }

        // The second array element specifies the virtual address of the
        // inaccessible data.
        if (exception_information[1] != (ULONG_PTR)address)
        {
            return EXCEPTION_CONTINUE_SEARCH;
        }

        return EXCEPTION_EXECUTE_HANDLER;
    }

    bool test_guard_page_exception()
    {
        SYSTEM_INFO sys_info;
        GetSystemInfo(&sys_info);

        // Allocate a guarded memory region with the length of the system page
        // size.
        auto* addr = static_cast<LPBYTE>(VirtualAlloc(nullptr, sys_info.dwPageSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_GUARD));
        if (addr == nullptr)
        {
            puts("Failed to allocate guard page");
            return false;
        }

        bool success = false;

        // We want to access some arbitrary offset into the guarded page, to
        // ensure that ExceptionInformation correctly contains the virtual
        // address of the inaccessible data, not the base address of the region.
        constexpr size_t offset = 10;

        // Trigger a guard page violation
        __try
        {
            addr[offset] = 255;
        }
        // If the filter function returns EXCEPTION_CONTINUE_SEARCH, the
        // exception contains all of the correct information.
        __except (test_guard_page_seh_filter(addr + offset, GetExceptionCode(), GetExceptionInformation()))
        {
            success = true;
        }

        // The page guard should be lifted, so no exception should be raised.
        __try
        {
            // The previous write should not have went through, this is probably
            // superflous.
            if (addr[offset] == 255)
            {
                success = false;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            puts("Failed to read from page after guard exception!");
            success = false;
        }

        // Free the allocated memory
        if (!VirtualFree(addr, 0, MEM_RELEASE))
        {
            puts("Failed to free allocated region");
            success = false;
        }

        return success;
    }

    bool test_native_exceptions()
    {
        return test_access_violation_exception()       //
               && test_illegal_instruction_exception() //
               && test_unhandled_exception()           //
               && test_guard_page_exception();
    }
#endif

    bool trap_flag_cleared = false;
    constexpr DWORD TRAP_FLAG_MASK = 0x100;

    LONG NTAPI single_step_handler(PEXCEPTION_POINTERS exception_info)
    {
        if (exception_info->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP)
        {
            PCONTEXT context = exception_info->ContextRecord;
            trap_flag_cleared = (context->EFlags & TRAP_FLAG_MASK) == 0;
            return EXCEPTION_CONTINUE_EXECUTION;
        }

        return EXCEPTION_CONTINUE_SEARCH;
    }

    bool test_interrupts()
    {
        PVOID veh_handle = AddVectoredExceptionHandler(1, single_step_handler);
        if (!veh_handle)
            return false;

        __writeeflags(__readeflags() | TRAP_FLAG_MASK);

#ifdef __MINGW64__
        asm("nop");
#else
        __nop();
#endif

        RemoveVectoredExceptionHandler(veh_handle);

        return trap_flag_cleared;
    }

    void print_time()
    {
        const auto epoch_time = std::chrono::system_clock::now().time_since_epoch();
        printf("Time: %" PRId64 "\n", std::chrono::duration_cast<std::chrono::nanoseconds>(epoch_time).count());
    }

    bool test_apis()
    {
        if (VirtualProtect(nullptr, 0, 0, nullptr))
        {
            return false;
        }

        wchar_t buffer[0x100];
        DWORD size = sizeof(buffer) / 2;
        return GetComputerNameExW(ComputerNameNetBIOS, buffer, &size);
    }

    bool test_apc()
    {
        int executions = 0;

        auto* apc_func = +[](const ULONG_PTR param) {
            *reinterpret_cast<int*>(param) += 1; //
        };

        QueueUserAPC(apc_func, GetCurrentThread(), reinterpret_cast<ULONG_PTR>(&executions));
        QueueUserAPC(apc_func, GetCurrentThread(), reinterpret_cast<ULONG_PTR>(&executions));

        Sleep(1);

        if (executions != 0)
        {
            return false;
        }

        SleepEx(1, TRUE);
        return executions == 2;
    }

    bool test_message_queue()
    {
        static UINT wnd_proc_num = 0;
        static const UINT wnd_msg_id = WM_APP + 2;

        WNDCLASSEXA wc = {};
        wc.cbSize = sizeof(wc);
        wc.lpszClassName = "TestMsgQueueClass";
        wc.hInstance = GetModuleHandleA(nullptr);
        wc.lpfnWndProc = +[](HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) -> LRESULT {
            if (msg == WM_CREATE)
            {
                const auto cs = reinterpret_cast<CREATESTRUCTA*>(lp);
                if (cs->lpCreateParams == reinterpret_cast<void*>(0x1337))
                {
                    wnd_proc_num += 1;
                }
            }
            else if (msg == wnd_msg_id)
            {
                if (wp == 123 && lp == 456)
                {
                    wnd_proc_num += 1;
                    return 777;
                }
            }
            return DefWindowProcA(hwnd, msg, wp, lp);
        };

        if (!RegisterClassExA(&wc))
        {
            puts("Failed to register window class");
            return false;
        }

        HWND hwnd = CreateWindowExA(0, wc.lpszClassName, nullptr, 0, 0, 0, 0, 0, HWND_MESSAGE, nullptr, wc.hInstance,
                                    reinterpret_cast<void*>(0x1337));
        if (!hwnd || wnd_proc_num != 1)
        {
            puts("Failed to create message window");
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        const LRESULT send_res = SendMessageA(hwnd, wnd_msg_id, 123, 456);

        if (send_res != 777 || wnd_proc_num != 2)
        {
            puts("SendMessage failed");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        wnd_proc_num = 0;
        if (!PostMessageA(hwnd, wnd_msg_id, 123, 456))
        {
            puts("PostMessage failed");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        MSG msg = {};
        if (GetMessageA(&msg, hwnd, 0, 0) <= 0)
        {
            puts("GetMessage failed or returned WM_QUIT unexpectedly");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        if (msg.message != wnd_msg_id)
        {
            puts("Retrieved message is not the expected custom message");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        TranslateMessage(&msg);
        DispatchMessageA(&msg);

        if (wnd_proc_num != 1)
        {
            puts("Posted window message did not execute WndProc");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        constexpr int quit_code = 42;
        PostQuitMessage(quit_code);

        const BOOL quit_result = GetMessageA(&msg, nullptr, 0, 0);
        if (quit_result != 0)
        {
            puts("GetMessage did not return 0 for WM_QUIT");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        if (msg.message != WM_QUIT)
        {
            puts("Message is not WM_QUIT");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        if (msg.wParam != quit_code)
        {
            puts("WM_QUIT exit code mismatch");
            DestroyWindow(hwnd);
            UnregisterClassA(wc.lpszClassName, wc.hInstance);
            return false;
        }

        DestroyWindow(hwnd);
        UnregisterClassA(wc.lpszClassName, wc.hInstance);
        return true;
    }
}

#define RUN_TEST(func, name)                 \
    {                                        \
        printf("Running test '" name "': "); \
        const auto res = func();             \
        valid &= res;                        \
        puts(res ? "Success" : "Fail");      \
    }

int main(const int argc, const char* argv[])
{
    if (argc == 2 && argv[1] == "-time"sv)
    {
        print_time();
        return 0;
    }

    bool valid = true;

    RUN_TEST(test_io, "I/O")
    RUN_TEST(test_dir_io, "Dir I/O")
    RUN_TEST(test_apis, "APIs")
    RUN_TEST(test_working_directory, "Working Directory")
    RUN_TEST(test_registry, "Registry")
    RUN_TEST(test_system_info, "System Info")
    RUN_TEST(test_monitor_info, "Monitor Info")
    RUN_TEST(test_time_zone, "Time Zone")
    RUN_TEST(test_threads, "Threads")
    RUN_TEST(test_threads_winapi, "Threads WinAPI")
    RUN_TEST(test_env, "Environment")
    RUN_TEST(test_exceptions, "Exceptions")
#ifndef __MINGW64__
    RUN_TEST(test_native_exceptions, "Native Exceptions")
#endif
    if (!getenv("EMULATOR_ICICLE"))
    {
        RUN_TEST(test_interrupts, "Interrupts")
    }
    RUN_TEST(test_tls, "TLS")
    RUN_TEST(test_socket, "Socket")
    RUN_TEST(test_apc, "APC")
    RUN_TEST(test_user_callback, "User Callback")
    RUN_TEST(test_message_queue, "Message Queue")

    return valid ? 0 : 1;
}

```

`src/tools/CMakeLists.txt`:

```txt
add_subdirectory(dump-apiset)

```

`src/tools/create-root.bat`:

```bat
@ECHO OFF

NET SESSIONS > NUL 2>&1
IF %ERRORLEVEL% NEQ 0 (
	ECHO Error: This script requires administrative privileges.
	EXIT /B 1
)

SET SYSDIR="%WINDIR%\System32"
SET SYSDIR_WOW64="%WINDIR%\SysWOW64"

SET EMU_ROOT=root
SET EMU_FILESYS=%EMU_ROOT%\filesys
SET EMU_WINDIR=%EMU_FILESYS%\c\windows
SET EMU_SYSDIR=%EMU_WINDIR%\system32
SET EMU_SYSDIR_WOW64=%EMU_WINDIR%\syswow64
SET EMU_REGDIR=%EMU_ROOT%\registry

MKDIR %EMU_SYSDIR%
MKDIR %EMU_SYSDIR_WOW64%
MKDIR %EMU_REGDIR%

REG SAVE HKLM\HARDWARE %EMU_REGDIR%\HARDWARE /Y
REG SAVE HKLM\SAM %EMU_REGDIR%\SAM /Y
REG SAVE HKLM\SECURITY %EMU_REGDIR%\SECURITY /Y
REG SAVE HKLM\SOFTWARE %EMU_REGDIR%\SOFTWARE /Y
REG SAVE HKLM\SYSTEM %EMU_REGDIR%\SYSTEM /Y
COPY /B /Y C:\Users\Default\NTUSER.DAT "%EMU_REGDIR%\NTUSER.DAT"

CALL :collect advapi32.dll
CALL :collect bcrypt.dll
CALL :collect bcryptprimitives.dll
CALL :collect cabinet.dll
CALL :collect cfgmgr32.dll
CALL :collect ci.dll
CALL :collect coloradapterclient.dll
CALL :collect combase.dll
CALL :collect comctl32.dll
CALL :collect comdlg32.dll
CALL :collect crypt32.dll
CALL :collect cryptbase.dll
CALL :collect cryptsp.dll
CALL :collect d3d10.dll
CALL :collect d3d10core.dll
CALL :collect d3d11.dll
CALL :collect d3d12.dll
CALL :collect d3d9.dll
CALL :collect d3dcompiler_43.dll
CALL :collect d3dcompiler_47.dll
CALL :collect dbghelp.dll
CALL :collect dbgcore.dll
CALL :collect diagnosticdatasettings.dll
CALL :collect dinput8.dll
CALL :collect dsound.dll
CALL :collect dwmapi.dll
CALL :collect dxcore.dll
CALL :collect dxgi.dll
CALL :collect dxva2.dll
CALL :collect fwpuclnt.dll
CALL :collect gdi32.dll
CALL :collect gdi32full.dll
CALL :collect gdiplus.dll
CALL :collect glu32.dll
CALL :collect hal.dll
CALL :collect hid.dll
CALL :collect imm32.dll
CALL :collect imagehlp.dll
CALL :collect iphlpapi.dll
CALL :collect kdcom.dll
CALL :collect kernel.appcore.dll
CALL :collect kernel32.dll
CALL :collect kernelbase.dll
CALL :collect ktmw32.dll
CALL :collect mfplat.dll
CALL :collect mobilenetworking.dll
CALL :collect mpr.dll
CALL :collect msacm32.dll
CALL :collect msasn1.dll
CALL :collect mscms.dll
CALL :collect mscoree.dll
CALL :collect msdmo.dll
CALL :collect msvcp140.dll
CALL :collect msvcp140d.dll
CALL :collect msvcp60.dll
CALL :collect msvcp_win.dll
CALL :collect msvcr120_clr0400.dll
CALL :collect msvcrt.dll
CALL :collect mswsock.dll
CALL :collect ncrypt.dll
CALL :collect netapi32.dll
CALL :collect netmsg.dll
CALL :collect netutils.dll
CALL :collect nlsbres.dll
CALL :collect normaliz.dll
CALL :collect ntasn1.dll
CALL :collect ntdll.dll
CALL :collect ole32.dll
CALL :collect oleaut32.dll
CALL :collect opengl32.dll
CALL :collect pdh.dll
CALL :collect powrprof.dll
CALL :collect propsys.dll
CALL :collect psapi.dll
CALL :collect resampledmo.dll
CALL :collect rpcrt4.dll
CALL :collect rstrtmgr.dll
CALL :collect rsaenh.dll
CALL :collect sechost.dll
CALL :collect setupapi.dll
CALL :collect shcore.dll
CALL :collect shell32.dll
CALL :collect shlwapi.dll
CALL :collect slwga.dll
CALL :collect sppc.dll
CALL :collect srvcli.dll
CALL :collect sspicli.dll
CALL :collect ucrtbase.dll
CALL :collect ucrtbased.dll
CALL :collect uiautomationcore.dll
CALL :collect umpdc.dll
CALL :collect urlmon.dll
CALL :collect user32.dll
CALL :collect userenv.dll
CALL :collect uxtheme.dll
CALL :collect vcruntime140.dll
CALL :collect vcruntime140_1.dll
CALL :collect vcruntime140_1d.dll
CALL :collect vcruntime140d.dll
CALL :collect version.dll
CALL :collect wer.dll
CALL :collect win32u.dll
CALL :collect windows.storage.dll
CALL :collect windowscodecs.dll
CALL :collect winhttp.dll
CALL :collect wininet.dll
CALL :collect winmm.dll
CALL :collect winmmbase.dll
CALL :collect winnlsres.dll
CALL :collect wintrust.dll
CALL :collect wintypes.dll
CALL :collect wlanapi.dll
CALL :collect wldap32.dll
CALL :collect wow64.dll
CALL :collect wow64base.dll
CALL :collect wow64con.dll
CALL :collect wow64cpu.dll
CALL :collect wow64win.dll
CALL :collect ws2_32.dll
CALL :collect wsock32.dll
CALL :collect wtsapi32.dll
CALL :collect x3daudio1_7.dll
CALL :collect xapofx1_5.dll
CALL :collect xinput1_3.dll
CALL :collect xinput9_1_0.dll

CALL :collect locale.nls
CALL :collect c_1252.nls
CALL :collect c_437.nls
CALL :collect c_850.nls

EXIT /B 0

:normpath
SET %1=%~dpfn2
EXIT /B

:collect_file
CALL :normpath SRC, %~1\%~2
CALL :normpath DST, %~3\%~2

IF EXIST %SRC% (
	ECHO %SRC% -^> %DST%
	COPY /B /Y "%SRC%" "%DST%" >NUL
)
EXIT /B

:collect
CALL :collect_file %SYSDIR%, %~1, %EMU_SYSDIR%
CALL :collect_file %SYSDIR_WOW64%, %~1, %EMU_SYSDIR_WOW64%
EXIT /B


```

`src/tools/dump-apiset/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(dump-apiset ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(dump-apiset PRIVATE
  emulator-common
)

momo_strip_target(dump-apiset)

```

`src/tools/dump-apiset/dump-apiset.cpp`:

```cpp
#include <cstdio>
#include "platform/platform.hpp"
#include "utils/compression.hpp"
#include "utils/io.hpp"
#include <vector>

void print_apiset(PAPI_SET_NAMESPACE api_set_map);
void create_header_file(const std::vector<uint8_t>& data);

__forceinline PVOID GetCurrentProcessPeb()
{
#ifdef _WIN64
    return reinterpret_cast<PVOID>(__readgsqword(0x60));
#else
    return reinterpret_cast<PVOID>(__readfsdword(0x30));
#endif
}

int main()
{
    printf("Dump API-SET\n");
    printf("------------\n\n");

    const auto peb = static_cast<PPEB64>(GetCurrentProcessPeb());
    const auto api_set_map = reinterpret_cast<API_SET_NAMESPACE*>(peb->ApiSetMap);

    printf("APISET: 0x%p\n", static_cast<void*>(api_set_map));
    printf("Version: %lu\n", api_set_map->Version);
    printf("Size: %08lX\n", api_set_map->Size);
    printf("Flags: %08lX\n", api_set_map->Flags);
    printf("Count: %lu\n", api_set_map->Count);
    printf("EntryOffset: %08lX\n", api_set_map->EntryOffset);
    printf("HashOffset: %08lX\n", api_set_map->HashOffset);
    printf("HashFactor: %08lX\n", api_set_map->HashFactor);
    print_apiset(api_set_map);

    // Compress the API-SET binary blob
    const auto* data_ptr = reinterpret_cast<const std::byte*>(api_set_map);
    const std::span buffer(data_ptr, data_ptr + api_set_map->Size);
    const auto compressed = utils::compression::zstd::compress(buffer);
    if (compressed.empty())
    {
        printf("Failed to compress API-SET\n");
        return 1;
    }

    // Dump the API-SET binary blob to disk
    utils::io::write_file("api-set.bin", compressed, false);
    printf("\nWrote API-SET to api-set.bin\n");
    // create_header_file(compressed);

    return 0;
}

void print_apiset(PAPI_SET_NAMESPACE api_set_map)
{
    for (ULONG i = 0; i < api_set_map->Count; i++)
    {
        const auto entry = reinterpret_cast<PAPI_SET_NAMESPACE_ENTRY>(reinterpret_cast<ULONG_PTR>(api_set_map) + api_set_map->EntryOffset +
                                                                      i * sizeof(API_SET_NAMESPACE_ENTRY));

        // printf("  Flags: %08X\n", entry->Flags);
        // printf("  NameOffset: %08X\n", entry->NameOffset);
        // printf("  NameLength: %08X\n", entry->NameLength);
        // printf("  HashedLength: %08X\n", entry->HashedLength);
        // printf("  ValueOffset: %08X\n", entry->ValueOffset);
        // printf("  ValueCount: %08X\n", entry->ValueCount);

        std::wstring name(reinterpret_cast<wchar_t*>(reinterpret_cast<ULONG_PTR>(api_set_map) + entry->NameOffset),
                          entry->NameLength / sizeof(wchar_t));
        printf("-----------\n[%05lu]: Contract Name: %ls\n", i, name.data());

        for (ULONG x = 0; x < entry->ValueCount; x++)
        {
            const auto value = reinterpret_cast<PAPI_SET_VALUE_ENTRY>(reinterpret_cast<ULONG_PTR>(api_set_map) + entry->ValueOffset +
                                                                      x * sizeof(API_SET_VALUE_ENTRY));
            // printf("  Value %d\n", x);
            // printf("    Flags: %08X\n", value->Flags);
            // printf("    NameOffset: %08X\n", value->NameOffset);
            // printf("    NameLength: %08X\n", value->NameLength);
            // printf("    ValueOffset: %08X\n", value->ValueOffset);
            // printf("    ValueLength: %08X\n", value->ValueLength);

            std::wstring hostName(reinterpret_cast<wchar_t*>(reinterpret_cast<ULONG_PTR>(api_set_map) + value->NameOffset),
                                  value->NameLength / sizeof(wchar_t));
            std::wstring altName(reinterpret_cast<wchar_t*>(reinterpret_cast<ULONG_PTR>(api_set_map) + value->ValueOffset),
                                 value->ValueLength / sizeof(wchar_t));
            printf("    HostName: %ls - AltName: %ls\n", hostName.empty() ? L"<none>" : hostName.data(),
                   altName.empty() ? L"<none>" : altName.data());
        }
    }
}

// Internal
void create_header_file(const std::vector<uint8_t>& data)
{
    FILE* output;
    (void)fopen_s(&output, "api-set.h", "w");
    if (!output)
    {
        printf("Failed to create output file\n");
        return;
    }

    (void)fprintf(output, "#pragma once\n\n");
    (void)fprintf(output, "#include <stdint.h>\n\n");
    (void)fprintf(output, "const uint8_t api_set_blob[] = {\n");
    for (ULONG i = 0; i < data.size(); i++)
    {
        (void)fprintf(output, "0x%02X, ", data[i]);
        if (i % 16 == 15)
        {
            (void)fprintf(output, "\n");
        }
    }

    (void)fprintf(output, "};\n");
    (void)fclose(output);
}

```

`src/tools/grab-registry.bat`:

```bat
@echo off

NET SESSIONS > NUL 2>&1
IF %ERRORLEVEL% NEQ 0 (
	ECHO Error: This script requires administrative privileges.
	EXIT /B 1
)

SET REGDIR="registry"
MKDIR %REGDIR%

REG SAVE HKLM\SYSTEM %REGDIR%\SYSTEM /Y
REG SAVE HKLM\SECURITY %REGDIR%\SECURITY /Y
REG SAVE HKLM\SOFTWARE %REGDIR%\SOFTWARE /Y
REG SAVE HKLM\HARDWARE %REGDIR%\HARDWARE /Y
REG SAVE HKLM\SAM %REGDIR%\SAM /Y
COPY /B /Y C:\Users\Default\NTUSER.DAT "%REGDIR%\NTUSER.DAT"

```

`src/windows-emulator-test/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_executable(windows-emulator-test ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(windows-emulator-test PRIVATE
  gtest
  gtest_main
  windows-emulator
  backend-selection
)

if(WIN32 AND CMAKE_SIZEOF_VOID_P EQUAL 8)
  add_dependencies(windows-emulator-test test-sample)
endif()

add_test(NAME windows-emulator-test
         COMMAND ${CMAKE_COMMAND} -E env "LD_LIBRARY_PATH=." -- "${PYTHON3_EXE}" "${PROJECT_SOURCE_DIR}/deps/gtest-parallel/gtest_parallel.py" ./windows-emulator-test
         WORKING_DIRECTORY "$<TARGET_FILE_DIR:windows-emulator-test>")

momo_targets_set_folder("tests" windows-emulator-test)

momo_strip_target(windows-emulator-test)

```

`src/windows-emulator-test/emulation_test.cpp`:

```cpp
#include "emulation_test_utils.hpp"

namespace test
{
    TEST(EmulationTest, BasicEmulationWorks)
    {
        auto emu = create_sample_emulator();
        emu.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu);
    }

    TEST(EmulationTest, CountedEmulationWorks)
    {
        constexpr auto count = 200000;

        auto emu = create_sample_emulator();
        emu.start(count);

        ASSERT_EQ(emu.get_executed_instructions(), count);
    }

    TEST(EmulationTest, CountedEmulationIsAccurate)
    {
        auto emu = create_sample_emulator();
        emu.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu);

        const auto executedInstructions = emu.get_executed_instructions();

        auto new_emu = create_sample_emulator();

        constexpr auto offset = 1;
        const auto instructionsToExecute = executedInstructions - offset;

        new_emu.start(static_cast<size_t>(instructionsToExecute));

        ASSERT_EQ(new_emu.get_executed_instructions(), instructionsToExecute);
        ASSERT_NOT_TERMINATED(new_emu);

        new_emu.start(offset);

        ASSERT_TERMINATED_SUCCESSFULLY(new_emu);
        ASSERT_EQ(new_emu.get_executed_instructions(), executedInstructions);
    }
}

```

`src/windows-emulator-test/emulation_test_utils.hpp`:

```hpp
#pragma once

#ifdef __MINGW64__
#include <unistd.h>
#endif

#include <cstdlib>
#include <gtest/gtest.h>
#include <windows_emulator.hpp>
#include <backend_selection.hpp>

#include <network/static_socket_factory.hpp>

#define ASSERT_NOT_TERMINATED(win_emu)                           \
    do                                                           \
    {                                                            \
        ASSERT_FALSE((win_emu).process.exit_status.has_value()); \
    } while (false)

#define ASSERT_TERMINATED_WITH_STATUS(win_emu, status)          \
    do                                                          \
    {                                                           \
        ASSERT_TRUE((win_emu).process.exit_status.has_value()); \
        ASSERT_EQ(*(win_emu).process.exit_status, status);      \
    } while (false)

#define ASSERT_TERMINATED_SUCCESSFULLY(win_emu) ASSERT_TERMINATED_WITH_STATUS(win_emu, STATUS_SUCCESS)

namespace test
{
    inline bool enable_verbose_logging()
    {
        const auto* env = getenv("EMULATOR_VERBOSE");
        return env && (env == "1"sv || env == "true"sv);
    }

    inline std::filesystem::path get_emulator_root()
    {
        const auto* env = getenv("EMULATOR_ROOT");
        if (!env)
        {
            throw std::runtime_error("No EMULATOR_ROOT set!");
        }

        return env;
    }

    struct sample_configuration
    {
        bool print_time{false};
    };

    inline application_settings get_sample_app_settings(const sample_configuration& config)
    {
        application_settings settings{.application = "C:\\test-sample.exe"};

        if (config.print_time)
        {
            settings.arguments.emplace_back(u"-time");
        }

        return settings;
    }

    inline windows_emulator create_emulator(emulator_settings settings, emulator_callbacks callbacks = {})
    {
        const auto is_verbose = enable_verbose_logging();

        if (is_verbose)
        {
            callbacks.on_stdout = [](const std::string_view data) {
                std::cout << data; //
            };
        }

        settings.emulation_root = get_emulator_root();

        settings.path_mappings["C:\\a.txt"] =
            std::filesystem::temp_directory_path() / ("emulator-test-file-" + std::to_string(getpid()) + ".txt");

        return windows_emulator{
            create_x86_64_emulator(),
            settings,
            std::move(callbacks),
            emulator_interfaces{
                .socket_factory = network::create_static_socket_factory(),
            },
        };
    }

    inline windows_emulator create_sample_emulator(emulator_settings settings, const sample_configuration& config = {},
                                                   emulator_callbacks callbacks = {})
    {
        const auto is_verbose = enable_verbose_logging();

        if (is_verbose)
        {
            callbacks.on_stdout = [](const std::string_view data) {
                std::cout << data; //
            };
        }

        settings.emulation_root = get_emulator_root();

        settings.path_mappings["C:\\a.txt"] =
            std::filesystem::temp_directory_path() / ("emulator-test-file-" + std::to_string(getpid()) + ".txt");

        return windows_emulator{
            create_x86_64_emulator(),
            get_sample_app_settings(config),
            settings,
            std::move(callbacks),
            emulator_interfaces{
                .socket_factory = network::create_static_socket_factory(),
            },
        };
    }

    inline windows_emulator create_sample_emulator(const sample_configuration& config = {})
    {
        emulator_settings settings{
            .use_relative_time = true,
        };

        return create_sample_emulator(std::move(settings), config);
    }

    inline windows_emulator create_empty_emulator()
    {
        emulator_settings settings{
            .use_relative_time = true,
        };

        return create_emulator(std::move(settings));
    }

    inline void bisect_emulation(windows_emulator& emu)
    {
        utils::buffer_serializer start_state{};
        emu.serialize(start_state);

        emu.start();
        const auto limit = emu.get_executed_instructions();

        const auto reset_emulator = [&] {
            utils::buffer_deserializer deserializer{start_state};
            emu.deserialize(deserializer);
        };

        const auto get_state_for_count = [&](const size_t count) {
            reset_emulator();
            emu.start(count);

            utils::buffer_serializer state{};
            emu.serialize(state);
            return state;
        };

        const auto has_diff_after_count = [&](const size_t count) {
            const auto s1 = get_state_for_count(count);
            const auto s2 = get_state_for_count(count);

            return s1.get_diff(s2).has_value();
        };

        if (!has_diff_after_count(static_cast<size_t>(limit)))
        {
            puts("Emulation has no diff");
        }

        auto upper_bound = limit;
        decltype(upper_bound) lower_bound = 0;

        printf("Bounds: %" PRIx64 " - %" PRIx64 "\n", lower_bound, upper_bound);

        while (lower_bound + 1 < upper_bound)
        {
            const auto diff = (upper_bound - lower_bound);
            const auto pivot = lower_bound + (diff / 2);

            const auto has_diff = has_diff_after_count(static_cast<size_t>(pivot));

            auto* bound = has_diff ? &upper_bound : &lower_bound;
            *bound = pivot;

            printf("Bounds: %" PRIx64 " - %" PRIx64 "\n", lower_bound, upper_bound);
        }

        (void)get_state_for_count(static_cast<size_t>(lower_bound));

        const auto rip = emu.emu().read_instruction_pointer();

        printf("Diff detected after 0x%" PRIx64 " instructions at 0x%" PRIx64 " (%s)\n", lower_bound, rip, emu.mod_manager.find_name(rip));
    }
}

```

`src/windows-emulator-test/file_system_test.cpp`:

```cpp
#include <gtest/gtest.h>

#include <file_system.hpp>

namespace test
{
    TEST(FileSystemTest, PathTraversalIsNotPossible)
    {
        const auto current_dir = std::filesystem::current_path();

        const file_system fs{current_dir};

        EXPECT_EQ(current_dir / "a", fs.translate(windows_path('a', {u"..", u"..", u"..", u"..", u"a.txt"})));
        EXPECT_EQ(current_dir / "a", fs.translate(windows_path('a', {u"b", u"..", u"..", u"b", u"..", u"a.txt"})));
        EXPECT_EQ(current_dir / "a", fs.translate(windows_path('a', {u"..", u"b"})));
    }
}

```

`src/windows-emulator-test/serialization_test.cpp`:

```cpp
#include "emulation_test_utils.hpp"

namespace test
{
    TEST(SerializationTest, ResettingEmulatorWorks)
    {
        auto emu = create_sample_emulator();

        utils::buffer_serializer start_state{};
        emu.serialize(start_state);

        emu.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu);

        utils::buffer_serializer end_state1{};
        emu.serialize(end_state1);

        utils::buffer_deserializer deserializer{start_state};
        emu.deserialize(deserializer);

        emu.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu);

        utils::buffer_serializer end_state2{};
        emu.serialize(end_state2);

        ASSERT_EQ(end_state1.get_buffer(), end_state2.get_buffer());
    }

    TEST(SerializationTest, SerializedDataIsReproducible)
    {
        auto emu1 = create_sample_emulator();
        emu1.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu1);

        utils::buffer_serializer serializer1{};
        emu1.serialize(serializer1);

        utils::buffer_deserializer deserializer{serializer1};

        auto new_emu = create_empty_emulator();
        new_emu.deserialize(deserializer);

        utils::buffer_serializer serializer2{};
        new_emu.serialize(serializer2);

        auto buffer1 = serializer1.move_buffer();
        auto buffer2 = serializer2.move_buffer();

        ASSERT_EQ(serializer1.get_buffer(), serializer2.get_buffer());
    }

    TEST(SerializationTest, EmulationIsReproducible)
    {
        auto emu1 = create_sample_emulator();
        emu1.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu1);

        utils::buffer_serializer serializer1{};
        emu1.serialize(serializer1);

        auto emu2 = create_sample_emulator();
        emu2.start();

        ASSERT_TERMINATED_SUCCESSFULLY(emu2);

        utils::buffer_serializer serializer2{};
        emu2.serialize(serializer2);

        ASSERT_EQ(serializer1.get_buffer(), serializer2.get_buffer());
    }

    TEST(SerializationTest, DeserializedEmulatorBehavesLikeSource)
    {
        auto emu = create_sample_emulator();
        emu.start(100);

        utils::buffer_serializer serializer{};
        emu.serialize(serializer);

        utils::buffer_deserializer deserializer{serializer};

        auto new_emu = create_empty_emulator();
        new_emu.deserialize(deserializer);

        new_emu.start();
        ASSERT_TERMINATED_SUCCESSFULLY(new_emu);

        emu.start();
        ASSERT_TERMINATED_SUCCESSFULLY(emu);

        utils::buffer_serializer serializer1{};
        utils::buffer_serializer serializer2{};

        emu.serialize(serializer1);
        new_emu.serialize(serializer2);

        ASSERT_EQ(serializer1.get_buffer(), serializer2.get_buffer());
    }
}

```

`src/windows-emulator-test/time_test.cpp`:

```cpp
#include "emulation_test_utils.hpp"

namespace test
{
    TEST(TimeTest, SystemTimeIsAccurate)
    {
        std::string output_buffer{};

        emulator_callbacks callbacks{};
        callbacks.on_stdout = [&output_buffer](const std::string_view data) {
            output_buffer.append(data); //
        };

        const emulator_settings settings{
            .use_relative_time = false,
        };

        auto emu = create_sample_emulator(settings, {.print_time = true}, std::move(callbacks));
        emu.start();

        constexpr auto prefix = "Time: "sv;

        ASSERT_TERMINATED_SUCCESSFULLY(emu);
        ASSERT_TRUE(output_buffer.starts_with(prefix));

        output_buffer = output_buffer.substr(prefix.size());
        while (!output_buffer.empty() && (output_buffer.back() == '\n' || output_buffer.back() == '\r'))
        {
            output_buffer.pop_back();
        }

        const auto time = strtoll(output_buffer.c_str(), nullptr, 10);

        using time_point = std::chrono::system_clock::time_point;

        const time_point::duration time_duration(time);
        const time_point tp(time_duration);

        const auto now = std::chrono::system_clock::now();
        const auto diff = now - tp;

        ASSERT_LE(diff, std::chrono::hours(1));
    }
}

```

`src/windows-emulator-test/unicode_test.cpp`:

```cpp
#include <gtest/gtest.h>

#include "common/platform/platform.hpp"
#include <cstring>

namespace test
{
    const std::vector<std::pair<const char*, const char16_t*>> good_strings = {
        {"", u""},
        {"\x48\x65\x6c\x6c\x6f\x20\x7c\x20\x48\xc3\xa4\x6a\x20\xc4\x85\xcc\x8a\x20\x64\x69\x67\x20"
         "\x7c\x20\xce\x93\xce\xb5\xce\xb9\xce\xac\x20\xcf\x83\xce\xb1\xcf\x82\x20\x7c\x20\xd0\x9f"
         "\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82\x20\x7c\x20\xe1\x83\x92\xe1\x83\x90\xe1\x83\x9b"
         "\xe1\x83\x90\xe1\x83\xa0\xe1\x83\xaf\xe1\x83\x9d\xe1\x83\x91\xe1\x83\x90\x20\x7c\x20\xe0"
         "\xae\xb5\xe0\xae\xa3\xe0\xae\x95\xe0\xaf\x8d\xe0\xae\x95\xe0\xae\xae\xe0\xaf\x8d\x20\x7c"
         "\x20\xe4\xbb\x8a\xe6\x97\xa5\xe6\x8b\x9d\xe3\x81\xaa\xe3\x81\xb3\xe3\x82\x89\x20\x7c\x20"
         "\xe0\xa4\xb6\xe0\xa5\x81\xe0\xa4\xad\x20\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xaf\xe0\xa4\xbe"
         "\xe0\xa4\xb0\x20\x7c\x20\xe1\x83\x92\xe1\x83\x94\xe1\x83\x92\xe1\x83\x90\xe1\x83\xaf\xe1"
         "\x83\x92\xe1\x83\x98\xe1\x83\x9c\xe1\x83\x90\xe1\x83\xa1\x20\x7c\x20\xec\x95\x88\xeb\x85"
         "\x95\xed\x95\x98\xec\x8b\xad\xeb\x8b\x88\xea\xb9\x8c\x20\x7c\x20\xe5\x93\x88\xe5\x9b\x89"
         "\x20\x7c\x20\xe0\xaa\xa8\xe0\xaa\xae\xe0\xaa\xb8\xe0\xab\x8d\xe0\xaa\xa4\xe0\xab\x87",
         u"\u0048\u0065\u006c\u006c\u006f\u0020\u007c\u0020\u0048\u00e4\u006a\u0020\u0105\u030a\u0020"
         u"\u0064\u0069\u0067\u0020\u007c\u0020\u0393\u03b5\u03b9\u03ac\u0020\u03c3\u03b1\u03c2\u0020"
         u"\u007c\u0020\u041f\u0440\u0438\u0432\u0435\u0442\u0020\u007c\u0020\u10d2\u10d0\u10db\u10d0"
         u"\u10e0\u10ef\u10dd\u10d1\u10d0\u0020\u007c\u0020\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd"
         u"\u0020\u007c\u0020\u4eca\u65e5\u62dd\u306a\u3073\u3089\u0020\u007c\u0020\u0936\u0941\u092d"
         u"\u0020\u092a\u094d\u092f\u093e\u0930\u0020\u007c\u0020\u10d2\u10d4\u10d2\u10d0\u10ef\u10d2"
         u"\u10d8\u10dc\u10d0\u10e1\u0020\u007c\u0020\uc548\ub155\ud558\uc2ed\ub2c8\uae4c\u0020\u007c"
         u"\u0020\u54c8\u56c9\u0020\u007c\u0020\u0aa8\u0aae\u0ab8\u0acd\u0aa4\u0ac7"},
        {"\xf0\x9f\x98\xb5\xe2\x80\x8d\xf0\x9f\x92\xab\x20\x7c\x20\xe2\x9d\xa4\xef\xb8\x8f\xe2\x80\x8d"
         "\xf0\x9f\xa9\xb9\x20\x7c\x20\xf0\x9f\xa9\xb5\x20\x7c\x20\xf0\x9f\x91\x81\xef\xb8\x8f\xe2\x80"
         "\x8d\xf0\x9f\x97\xa8\xef\xb8\x8f\x20\x7c\x20\xf0\x9f\xa7\x8e\xe2\x80\x8d\xe2\x99\x82\xef\xb8"
         "\x8f\xe2\x80\x8d\xe2\x9e\xa1\xef\xb8\x8f",
         u"\U0001F635\U0000200D\U0001F4AB | \U00002764\U0000FE0F\U0000200D\U0001FA79 | \U0001FA75 | "
         u"\U0001F441\U0000FE0F\U0000200D\U0001F5E8\U0000FE0F | \U0001F9CE\U0000200D\U00002642\U0000FE0F"
         u"\U0000200D\U000027A1\U0000FE0F"},
        {"\x01\x1f\x7F\xc2\x80\xc2\xbf\xd0\xb0\xdf\xbf\xe0\xa0\x80\xe0\xbf\xbf\xe1\x80\x80\xec\xbf\xbf"
         "\xed\x80\x80\xed\x9f\xbf\xee\x80\x80\xef\xb0\xb1\xef\xbf\xbf\xf0\x90\x80\x80\xf0\xbf\xbf\xbf"
         "\xf1\x80\x80\x80\xf2\xbf\x80\xbf\xf3\xbf\xbf\xbf\xf4\x80\x80\x80\xf4\x85\x80\xbf\xf4\x8f\xbf\xbf",
         u"\U00000001\U0000001f\U0000007f\U00000080\U000000bf\U00000430\U000007ff\U00000800\U00000fff"
         u"\U00001000\U0000cfff\U0000d000\U0000d7ff\U0000e000\U0000fc31\U0000ffff\U00010000\U0003ffff"
         u"\U00040000\U000bf03f\U000fffff\U00100000\U0010503f\U0010ffff"},
    };

    const std::vector<std::pair<const char*, const char32_t*>> good_strings_u32 = {
        {"\x48\x65\x6c\x6c\x6f\x20\x7c\x20\x48\xc3\xa4\x6a\x20\xc4\x85\xcc\x8a\x20\x64\x69\x67\x20"
         "\x7c\x20\xce\x93\xce\xb5\xce\xb9\xce\xac\x20\xcf\x83\xce\xb1\xcf\x82\x20\x7c\x20\xd0\x9f"
         "\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82\x20\x7c\x20\xe1\x83\x92\xe1\x83\x90\xe1\x83\x9b"
         "\xe1\x83\x90\xe1\x83\xa0\xe1\x83\xaf\xe1\x83\x9d\xe1\x83\x91\xe1\x83\x90\x20\x7c\x20\xe0"
         "\xae\xb5\xe0\xae\xa3\xe0\xae\x95\xe0\xaf\x8d\xe0\xae\x95\xe0\xae\xae\xe0\xaf\x8d\x20\x7c"
         "\x20\xe4\xbb\x8a\xe6\x97\xa5\xe6\x8b\x9d\xe3\x81\xaa\xe3\x81\xb3\xe3\x82\x89\x20\x7c\x20"
         "\xe0\xa4\xb6\xe0\xa5\x81\xe0\xa4\xad\x20\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xaf\xe0\xa4\xbe"
         "\xe0\xa4\xb0\x20\x7c\x20\xe1\x83\x92\xe1\x83\x94\xe1\x83\x92\xe1\x83\x90\xe1\x83\xaf\xe1"
         "\x83\x92\xe1\x83\x98\xe1\x83\x9c\xe1\x83\x90\xe1\x83\xa1\x20\x7c\x20\xec\x95\x88\xeb\x85"
         "\x95\xed\x95\x98\xec\x8b\xad\xeb\x8b\x88\xea\xb9\x8c\x20\x7c\x20\xe5\x93\x88\xe5\x9b\x89"
         "\x20\x7c\x20\xe0\xaa\xa8\xe0\xaa\xae\xe0\xaa\xb8\xe0\xab\x8d\xe0\xaa\xa4\xe0\xab\x87",
         U"\u0048\u0065\u006c\u006c\u006f\u0020\u007c\u0020\u0048\u00e4\u006a\u0020\u0105\u030a\u0020"
         U"\u0064\u0069\u0067\u0020\u007c\u0020\u0393\u03b5\u03b9\u03ac\u0020\u03c3\u03b1\u03c2\u0020"
         U"\u007c\u0020\u041f\u0440\u0438\u0432\u0435\u0442\u0020\u007c\u0020\u10d2\u10d0\u10db\u10d0"
         U"\u10e0\u10ef\u10dd\u10d1\u10d0\u0020\u007c\u0020\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd"
         U"\u0020\u007c\u0020\u4eca\u65e5\u62dd\u306a\u3073\u3089\u0020\u007c\u0020\u0936\u0941\u092d"
         U"\u0020\u092a\u094d\u092f\u093e\u0930\u0020\u007c\u0020\u10d2\u10d4\u10d2\u10d0\u10ef\u10d2"
         U"\u10d8\u10dc\u10d0\u10e1\u0020\u007c\u0020\uc548\ub155\ud558\uc2ed\ub2c8\uae4c\u0020\u007c"
         U"\u0020\u54c8\u56c9\u0020\u007c\u0020\u0aa8\u0aae\u0ab8\u0acd\u0aa4\u0ac7"},
        {"\xf0\x9f\x98\xb5\xe2\x80\x8d\xf0\x9f\x92\xab\x20\x7c\x20\xe2\x9d\xa4\xef\xb8\x8f\xe2\x80\x8d"
         "\xf0\x9f\xa9\xb9\x20\x7c\x20\xf0\x9f\xa9\xb5\x20\x7c\x20\xf0\x9f\x91\x81\xef\xb8\x8f\xe2\x80"
         "\x8d\xf0\x9f\x97\xa8\xef\xb8\x8f\x20\x7c\x20\xf0\x9f\xa7\x8e\xe2\x80\x8d\xe2\x99\x82\xef\xb8"
         "\x8f\xe2\x80\x8d\xe2\x9e\xa1\xef\xb8\x8f",
         U"\U0001F635\U0000200D\U0001F4AB | \U00002764\U0000FE0F\U0000200D\U0001FA79 | \U0001FA75 | "
         U"\U0001F441\U0000FE0F\U0000200D\U0001F5E8\U0000FE0F | \U0001F9CE\U0000200D\U00002642\U0000FE0F"
         U"\U0000200D\U000027A1\U0000FE0F"},
        {"\x01\x1f\x7F\xc2\x80\xc2\xbf\xd0\xb0\xdf\xbf\xe0\xa0\x80\xe0\xbf\xbf\xe1\x80\x80\xec\xbf\xbf"
         "\xed\x80\x80\xed\x9f\xbf\xee\x80\x80\xef\xb0\xb1\xef\xbf\xbf\xf0\x90\x80\x80\xf0\xbf\xbf\xbf"
         "\xf1\x80\x80\x80\xf2\xbf\x80\xbf\xf3\xbf\xbf\xbf\xf4\x80\x80\x80\xf4\x85\x80\xbf\xf4\x8f\xbf\xbf",
         U"\U00000001\U0000001f\U0000007f\U00000080\U000000bf\U00000430\U000007ff\U00000800\U00000fff"
         U"\U00001000\U0000cfff\U0000d000\U0000d7ff\U0000e000\U0000fc31\U0000ffff\U00010000\U0003ffff"
         U"\U00040000\U000bf03f\U000fffff\U00100000\U0010503f\U0010ffff"},
    };

    const std::vector<std::pair<const char*, const wchar_t*>> good_strings_w = {
        {"\x48\x65\x6c\x6c\x6f\x20\x7c\x20\x48\xc3\xa4\x6a\x20\xc4\x85\xcc\x8a\x20\x64\x69\x67\x20"
         "\x7c\x20\xce\x93\xce\xb5\xce\xb9\xce\xac\x20\xcf\x83\xce\xb1\xcf\x82\x20\x7c\x20\xd0\x9f"
         "\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82\x20\x7c\x20\xe1\x83\x92\xe1\x83\x90\xe1\x83\x9b"
         "\xe1\x83\x90\xe1\x83\xa0\xe1\x83\xaf\xe1\x83\x9d\xe1\x83\x91\xe1\x83\x90\x20\x7c\x20\xe0"
         "\xae\xb5\xe0\xae\xa3\xe0\xae\x95\xe0\xaf\x8d\xe0\xae\x95\xe0\xae\xae\xe0\xaf\x8d\x20\x7c"
         "\x20\xe4\xbb\x8a\xe6\x97\xa5\xe6\x8b\x9d\xe3\x81\xaa\xe3\x81\xb3\xe3\x82\x89\x20\x7c\x20"
         "\xe0\xa4\xb6\xe0\xa5\x81\xe0\xa4\xad\x20\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xaf\xe0\xa4\xbe"
         "\xe0\xa4\xb0\x20\x7c\x20\xe1\x83\x92\xe1\x83\x94\xe1\x83\x92\xe1\x83\x90\xe1\x83\xaf\xe1"
         "\x83\x92\xe1\x83\x98\xe1\x83\x9c\xe1\x83\x90\xe1\x83\xa1\x20\x7c\x20\xec\x95\x88\xeb\x85"
         "\x95\xed\x95\x98\xec\x8b\xad\xeb\x8b\x88\xea\xb9\x8c\x20\x7c\x20\xe5\x93\x88\xe5\x9b\x89"
         "\x20\x7c\x20\xe0\xaa\xa8\xe0\xaa\xae\xe0\xaa\xb8\xe0\xab\x8d\xe0\xaa\xa4\xe0\xab\x87",
         L"\u0048\u0065\u006c\u006c\u006f\u0020\u007c\u0020\u0048\u00e4\u006a\u0020\u0105\u030a\u0020"
         L"\u0064\u0069\u0067\u0020\u007c\u0020\u0393\u03b5\u03b9\u03ac\u0020\u03c3\u03b1\u03c2\u0020"
         L"\u007c\u0020\u041f\u0440\u0438\u0432\u0435\u0442\u0020\u007c\u0020\u10d2\u10d0\u10db\u10d0"
         L"\u10e0\u10ef\u10dd\u10d1\u10d0\u0020\u007c\u0020\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd"
         L"\u0020\u007c\u0020\u4eca\u65e5\u62dd\u306a\u3073\u3089\u0020\u007c\u0020\u0936\u0941\u092d"
         L"\u0020\u092a\u094d\u092f\u093e\u0930\u0020\u007c\u0020\u10d2\u10d4\u10d2\u10d0\u10ef\u10d2"
         L"\u10d8\u10dc\u10d0\u10e1\u0020\u007c\u0020\uc548\ub155\ud558\uc2ed\ub2c8\uae4c\u0020\u007c"
         L"\u0020\u54c8\u56c9\u0020\u007c\u0020\u0aa8\u0aae\u0ab8\u0acd\u0aa4\u0ac7"},
        {"\xf0\x9f\x98\xb5\xe2\x80\x8d\xf0\x9f\x92\xab\x20\x7c\x20\xe2\x9d\xa4\xef\xb8\x8f\xe2\x80\x8d"
         "\xf0\x9f\xa9\xb9\x20\x7c\x20\xf0\x9f\xa9\xb5\x20\x7c\x20\xf0\x9f\x91\x81\xef\xb8\x8f\xe2\x80"
         "\x8d\xf0\x9f\x97\xa8\xef\xb8\x8f\x20\x7c\x20\xf0\x9f\xa7\x8e\xe2\x80\x8d\xe2\x99\x82\xef\xb8"
         "\x8f\xe2\x80\x8d\xe2\x9e\xa1\xef\xb8\x8f",
         L"\U0001F635\U0000200D\U0001F4AB | \U00002764\U0000FE0F\U0000200D\U0001FA79 | \U0001FA75 | "
         L"\U0001F441\U0000FE0F\U0000200D\U0001F5E8\U0000FE0F | \U0001F9CE\U0000200D\U00002642\U0000FE0F"
         L"\U0000200D\U000027A1\U0000FE0F"},
        {"\x01\x1f\x7F\xc2\x80\xc2\xbf\xd0\xb0\xdf\xbf\xe0\xa0\x80\xe0\xbf\xbf\xe1\x80\x80\xec\xbf\xbf"
         "\xed\x80\x80\xed\x9f\xbf\xee\x80\x80\xef\xb0\xb1\xef\xbf\xbf\xf0\x90\x80\x80\xf0\xbf\xbf\xbf"
         "\xf1\x80\x80\x80\xf2\xbf\x80\xbf\xf3\xbf\xbf\xbf\xf4\x80\x80\x80\xf4\x85\x80\xbf\xf4\x8f\xbf\xbf",
         L"\U00000001\U0000001f\U0000007f\U00000080\U000000bf\U00000430\U000007ff\U00000800\U00000fff"
         L"\U00001000\U0000cfff\U0000d000\U0000d7ff\U0000e000\U0000fc31\U0000ffff\U00010000\U0003ffff"
         L"\U00040000\U000bf03f\U000fffff\U00100000\U0010503f\U0010ffff"},
    };

    const std::vector<std::pair<const char*, const char16_t*>> bad_u8_to_u16_strings = {
        {"\x80", u"\ufffd"},
        {"\x80\x60", u"\ufffd\x60"},
        {"\xc1", u"\ufffd"},
        {"\xc1\x80", u"\ufffd\ufffd"},
        {"\xc1\x20", u"\ufffd "},
        {"\xc2\x7f", u"\ufffd\x7f"},
        {"\xe0\x9f", u"\ufffd\ufffd"},
        {"\xe0\x3f", u"\ufffd\x3f"},
        {"\xe0\xa0\x20", u"\ufffd "},
        {"\xe1\x80\x7f", u"\ufffd\x7f"},
        {"\xed\x7f\x80", u"\ufffd\x7f\ufffd"},
        {"\xed\x9f\x20", u"\ufffd "},
        {"\xee\x80\xc0", u"\ufffd\ufffd"},
        {"\xee\x80\x7f", u"\ufffd\x7f"},
        {"\xf0\x90\x80\xff", u"\ufffd\ufffd"},
        {"\xf0\x90\x7f\x20", u"\ufffd\x7f\x20"},
        {"\xf1\x80\x80\xc2\x80", u"\ufffd\x80"},
        {"\xf1\xf1\x80\x80\xaa\x80", u"\ufffd\U0004002a\ufffd"},
        {"\xf4\x80\xbf\xed\x80\x80", u"\ufffd\ud000"},
        {"\xf5\x30\xf6\xc2\xbf", u"\ufffd\x30\ufffd\xbf"},
        {"\xc0\xaf\xe0\x80\xbf\xf0\x81\x82\x41", u"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\x41"},
        {"\xed\xa0\x80\xed\xbf\xbf\xed\xaf\x41", u"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\x41"},
        {"\xf4\x91\x92\x93\xff\x41\x80\xbf\x42", u"\ufffd\ufffd\ufffd\ufffd\ufffd\x41\ufffd\ufffd\x42"},
        {"\xe1\x80\xe2\xf0\x91\x92\xf1\xbf\x41", u"\ufffd\ufffd\ufffd\ufffd\x41"},
    };

    const std::vector<std::pair<std::u16string, const char*>> bad_u16_to_u8_strings = {
        {{0xdbff, 0xe000, 0x20}, "\xef\xbf\xbd\xee\x80\x80 "},
        {{0xdc80, 0x20, 0xdcff}, "\xef\xbf\xbd \xef\xbf\xbd"},
        {{0xdddd}, "\xef\xbf\xbd"},
        {{0xd800}, "\xef\xbf\xbd"},
        {{0xd7ff, 0xe000, 0xd800, 0xdfff, 0xdbff, 0xdc00, 0xd900, 0xda00, 0xdcaa, 0x7f, 0x7ff, 0xffff, 0xdc00, 0xdaaa},
         "\xed\x9f\xbf\xee\x80\x80\xf0\x90\x8f\xbf\xf4\x8f\xb0\x80\xef\xbf\xbd\xf2\x90\x82\xaa\x7f"
         "\xdf\xbf\xef\xbf\xbf\xef\xbf\xbd\xef\xbf\xbd"},
    };

    const std::vector<std::pair<std::u32string, const char*>> bad_u32_to_u8_strings = {
        {{0xdbff, 0xe000, 0x20}, "\xef\xbf\xbd\xee\x80\x80 "},
        {{0xdc80, 0x20, 0xdcff}, "\xef\xbf\xbd \xef\xbf\xbd"},
        {{0xdddd}, "\xef\xbf\xbd"},
        {{0xd800}, "\xef\xbf\xbd"},
        {{0xd7ff, 0xe000, 0x10ffff, 0xd800, 0xdfff, 0xdbff, 0xdc00, 0xd900, 0xda00, 0xdcaa, 0x7f, 0x7ff, 0xffff, 0xdc00, 0xdaaa, 0xffffffff,
          0x110000},
         "\xed\x9f\xbf\xee\x80\x80\xf4\x8f\xbf\xbf\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd"
         "\xef\xbf\xbd\xef\xbf\xbd\x7f\xdf\xbf\xef\xbf\xbf\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd"},
    };

    TEST(UnicodeConversionsTest, test_u16_to_u8)
    {
        for (const auto& [u8_str, u16_str] : good_strings)
        {
            const auto u8_conv = u16_to_u8(u16_str);
            const auto u8_byte_len = std::strlen(u8_str);

            EXPECT_TRUE(u8_byte_len == u8_conv.length() && memcmp(u8_str, u8_conv.data(), u8_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u32_to_u8)
    {
        for (const auto& [u8_str, u32_str] : good_strings_u32)
        {
            const auto u8_conv = u32_to_u8(u32_str);
            const auto u8_byte_len = std::strlen(u8_str);

            EXPECT_TRUE(u8_byte_len == u8_conv.length() && memcmp(u8_str, u8_conv.data(), u8_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_w_to_u8)
    {
        for (const auto& [u8_str, w_str] : good_strings_w)
        {
            const auto u8_conv = w_to_u8(w_str);
            const auto u8_byte_len = std::strlen(u8_str);

            EXPECT_TRUE(u8_byte_len == u8_conv.length() && memcmp(u8_str, u8_conv.data(), u8_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u8_to_u16)
    {
        for (const auto& [u8_str, u16_str] : good_strings)
        {
            const auto u16_conv = u8_to_u16(u8_str);
            const auto u16_byte_len = std::char_traits<char16_t>::length(u16_str) * 2;

            EXPECT_TRUE(u16_byte_len == u16_conv.length() * 2 && memcmp(u16_str, u16_conv.data(), u16_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u8_to_u32)
    {
        for (const auto& [u8_str, u32_str] : good_strings_u32)
        {
            const auto u32_conv = u8_to_u32(u8_str);
            const auto u32_byte_len = std::char_traits<char32_t>::length(u32_str) * sizeof(char32_t);

            EXPECT_TRUE(u32_byte_len == u32_conv.length() * sizeof(char32_t) && memcmp(u32_str, u32_conv.data(), u32_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u8_to_w)
    {
        for (const auto& [u8_str, w_str] : good_strings_w)
        {
            const auto w_conv = u8_to_w(u8_str);
            const auto w_byte_len = std::char_traits<wchar_t>::length(w_str) * sizeof(wchar_t);

            EXPECT_TRUE(w_byte_len == w_conv.length() * sizeof(wchar_t) && memcmp(w_str, w_conv.data(), w_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u8_to_u16_bad)
    {
        for (const auto& [u8_str, u16_str] : bad_u8_to_u16_strings)
        {
            const auto u16_conv = u8_to_u16(u8_str);
            const auto u16_byte_len = std::char_traits<char16_t>::length(u16_str) * 2;

            EXPECT_TRUE(u16_byte_len == u16_conv.length() * 2 && memcmp(u16_str, u16_conv.data(), u16_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u16_to_u8_bad)
    {
        for (const auto& [u16_str, u8_str] : bad_u16_to_u8_strings)
        {
            const auto u8_conv = u16_to_u8(u16_str);
            const auto u8_byte_len = std::strlen(u8_str);

            EXPECT_TRUE(u8_byte_len == u8_conv.length() && memcmp(u8_str, u8_conv.data(), u8_byte_len) == 0);
        }
    }

    TEST(UnicodeConversionsTest, test_u32_to_u8_bad)
    {
        for (const auto& [u32_str, u8_str] : bad_u32_to_u8_strings)
        {
            const auto u8_conv = u32_to_u8(u32_str);
            const auto u8_byte_len = std::strlen(u8_str);

            EXPECT_TRUE(u8_byte_len == u8_conv.length() && memcmp(u8_str, u8_conv.data(), u8_byte_len) == 0);
        }
    }
}

```

`src/windows-emulator/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(windows-emulator ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

if(NOT MOMO_ENABLE_CLANG_TIDY)
  target_precompile_headers(windows-emulator PRIVATE std_include.hpp)
endif()

target_link_libraries(windows-emulator PUBLIC emulator minidump)

target_include_directories(windows-emulator INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

momo_strip_target(windows-emulator)

```

`src/windows-emulator/apiset/apiset.cpp`:

```cpp
#include "../std_include.hpp"

#include "apiset.hpp"
#include "default_apiset.hpp"

#include "../emulator_utils.hpp"

#include <arch_emulator.hpp>

#include <utils/io.hpp>
#include <utils/compression.hpp>

namespace apiset
{
    namespace
    {
        uint64_t copy_string(x86_64_emulator& emu, emulator_allocator& allocator, const void* base_ptr, const uint64_t offset,
                             const size_t length)
        {
            if (!length)
            {
                return 0;
            }

            const auto length_to_allocate = length + 2;
            const auto str_obj = allocator.reserve(length_to_allocate);
            emu.write_memory(str_obj, static_cast<const uint8_t*>(base_ptr) + offset, length);

            return str_obj;
        }

        ULONG copy_string_as_relative(x86_64_emulator& emu, emulator_allocator& allocator, const uint64_t result_base, const void* base_ptr,
                                      const uint64_t offset, const size_t length)
        {
            const auto address = copy_string(emu, allocator, base_ptr, offset, length);
            if (!address)
            {
                return 0;
            }

            assert(address > result_base);
            return static_cast<ULONG>(address - result_base);
        }

        std::vector<std::byte> decompress_apiset(const std::vector<std::byte>& apiset)
        {
            auto buffer = utils::compression::zstd::decompress(apiset);
            if (buffer.empty())
            {
                throw std::runtime_error("Failed to decompress API-SET");
            }

            return buffer;
        }

        std::vector<std::byte> obtain_data(const location location, const std::filesystem::path& root)
        {
            switch (location)
            {
#ifdef OS_WINDOWS_64
            case location::host: {
                const auto* teb = NtCurrentTeb64();
                const auto* peb = reinterpret_cast<PEB64*>(teb->ProcessEnvironmentBlock);
                const auto* api_set_map = reinterpret_cast<const API_SET_NAMESPACE*>(peb->ApiSetMap);
                const auto* data_ptr = reinterpret_cast<const std::byte*>(api_set_map);
                return {data_ptr, data_ptr + api_set_map->Size};
            }
#else
            case location::host:
                throw std::runtime_error("The APISET host location is not supported on this platform");
#endif
            case location::file: {
                const auto apiset = utils::io::read_file(root / "api-set.bin");
                if (apiset.empty())
                {
                    throw std::runtime_error("Failed to read file api-set.bin");
                }

                return decompress_apiset(apiset);
            }
            case location::default_windows_10: {
                const auto* byte_apiset = reinterpret_cast<const std::byte*>(apiset_w10);
                const std::vector<std::byte> apiset{byte_apiset, byte_apiset + sizeof(apiset_w10)};
                return decompress_apiset(apiset);
            }
            case location::default_windows_11: {
                const auto* byte_apiset = reinterpret_cast<const std::byte*>(apiset_w11);
                const std::vector<std::byte> apiset{byte_apiset, byte_apiset + sizeof(apiset_w11)};
                return decompress_apiset(apiset);
            }
            default:
                throw std::runtime_error("Bad API set location");
            }
        }
    }

    container obtain(const location location, const std::filesystem::path& root)
    {
        return {.data = obtain_data(location, root)};
    }

    container obtain(const std::filesystem::path& root)
    {
        auto apiset_loc = location::file;

        if (root.empty())
        {
#ifdef OS_WINDOWS
            apiset_loc = location::host;
#else
            apiset_loc = location::default_windows_11;
#endif
        }

        return obtain(apiset_loc, root);
    }

    emulator_object<API_SET_NAMESPACE> clone(x86_64_emulator& emu, emulator_allocator& allocator, const container& container)
    {
        return clone(emu, allocator, container.get());
    }

    emulator_object<API_SET_NAMESPACE> clone(x86_64_emulator& emu, emulator_allocator& allocator, const API_SET_NAMESPACE& orig_api_set_map)
    {
        const auto api_set_map_obj = allocator.reserve<API_SET_NAMESPACE>();
        const auto ns_entries_obj = allocator.reserve<API_SET_NAMESPACE_ENTRY>(orig_api_set_map.Count);
        const auto hash_entries_obj = allocator.reserve<API_SET_HASH_ENTRY>(orig_api_set_map.Count);

        api_set_map_obj.access([&](API_SET_NAMESPACE& api_set) {
            api_set = orig_api_set_map;
            api_set.EntryOffset = static_cast<ULONG>(ns_entries_obj.value() - api_set_map_obj.value());
            api_set.HashOffset = static_cast<ULONG>(hash_entries_obj.value() - api_set_map_obj.value());
        });

        const auto* orig_ns_entries = offset_pointer<API_SET_NAMESPACE_ENTRY>(&orig_api_set_map, orig_api_set_map.EntryOffset);
        const auto* orig_hash_entries = offset_pointer<API_SET_HASH_ENTRY>(&orig_api_set_map, orig_api_set_map.HashOffset);

        for (ULONG i = 0; i < orig_api_set_map.Count; ++i)
        {
            auto ns_entry = orig_ns_entries[i];
            const auto hash_entry = orig_hash_entries[i];

            ns_entry.NameOffset = copy_string_as_relative(emu, allocator, api_set_map_obj.value(), &orig_api_set_map, ns_entry.NameOffset,
                                                          ns_entry.NameLength);

            if (!ns_entry.ValueCount)
            {
                continue;
            }

            const auto values_obj = allocator.reserve<API_SET_VALUE_ENTRY>(ns_entry.ValueCount);
            const auto* orig_values = offset_pointer<API_SET_VALUE_ENTRY>(&orig_api_set_map, ns_entry.ValueOffset);

            ns_entry.ValueOffset = static_cast<ULONG>(values_obj.value() - api_set_map_obj.value());

            for (ULONG j = 0; j < ns_entry.ValueCount; ++j)
            {
                auto value = orig_values[j];

                value.ValueOffset = copy_string_as_relative(emu, allocator, api_set_map_obj.value(), &orig_api_set_map, value.ValueOffset,
                                                            value.ValueLength);

                if (value.NameLength)
                {
                    value.NameOffset = copy_string_as_relative(emu, allocator, api_set_map_obj.value(), &orig_api_set_map, value.NameOffset,
                                                               value.NameLength);
                }

                values_obj.write(value, j);
            }

            ns_entries_obj.write(ns_entry, i);
            hash_entries_obj.write(hash_entry, i);
        }

        return api_set_map_obj;
    }

    apiset_map get_namespace_table(const API_SET_NAMESPACE* apiset_ns_data)
    {
        std::map<std::u16string, std::u16string> apiset;

        for (size_t i = 0; i < apiset_ns_data->Count; i++)
        {
            const auto* entry = reinterpret_cast<const API_SET_NAMESPACE_ENTRY*>(
                reinterpret_cast<uint64_t>(apiset_ns_data) + apiset_ns_data->EntryOffset + i * sizeof(API_SET_NAMESPACE_ENTRY));

            std::u16string name(reinterpret_cast<const char16_t*>(reinterpret_cast<uint64_t>(apiset_ns_data) + entry->NameOffset),
                                entry->NameLength / sizeof(char16_t));

            if (!entry->ValueCount)
            {
                continue;
            }

            const auto* value = reinterpret_cast<const API_SET_VALUE_ENTRY*>(
                reinterpret_cast<uint64_t>(apiset_ns_data) + entry->ValueOffset + (entry->ValueCount - 1) * sizeof(API_SET_VALUE_ENTRY));
            std::u16string base_name(reinterpret_cast<const char16_t*>(reinterpret_cast<uint64_t>(apiset_ns_data) + value->ValueOffset),
                                     value->ValueLength / sizeof(char16_t));

            apiset[name + u".dll"] = base_name;
        }

        return apiset;
    }
}

```

`src/windows-emulator/apiset/apiset.hpp`:

```hpp
#pragma once

#include <vector>
#include <cstdint>
#include <filesystem>
#include <optional>
#include "../emulator_utils.hpp"

using apiset_map = std::map<std::u16string, std::u16string>;
namespace apiset
{
    enum class location : uint8_t
    {
        host,
        file,
        default_windows_10,
        default_windows_11
    };

    struct container
    {
        std::vector<std::byte> data{};

        const API_SET_NAMESPACE& get() const
        {
            return *reinterpret_cast<const API_SET_NAMESPACE*>(data.data());
        }
    };

    container obtain(location location, const std::filesystem::path& root);
    container obtain(const std::filesystem::path& root);

    emulator_object<API_SET_NAMESPACE> clone(x86_64_emulator& emu, emulator_allocator& allocator,
                                             const API_SET_NAMESPACE& orig_api_set_map);

    emulator_object<API_SET_NAMESPACE> clone(x86_64_emulator& emu, emulator_allocator& allocator, const container& container);

    apiset_map get_namespace_table(const API_SET_NAMESPACE* apiset_ns_data);
}

```

`src/windows-emulator/apiset/default_apiset.hpp`:

```hpp
#pragma once

#include <cstdint>

// Windows 11 - APISET-W11.24H2-26100.2605

// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
const uint8_t apiset_w11[] = {
    0x78, 0xDA, 0xCD, 0x7D, 0x0F, 0x7C, 0xCD, 0xD5, 0xFF, 0xFF, 0x9D, 0x26, 0xCA, 0xD2, 0xAA, 0x29, 0xA2, 0x52, 0x11, 0x0A, 0x6D, 0xD7,
    0xBF, 0x91, 0x24, 0xAD, 0xA2, 0x54, 0xF2, 0x2F, 0xB1, 0xD8, 0xFF, 0x3F, 0xDC, 0x6D, 0xD7, 0xBD, 0x77, 0x7F, 0x30, 0x2C, 0x46, 0x64,
    0xB4, 0x32, 0x4C, 0x8D, 0xD0, 0xB0, 0x18, 0x86, 0xC9, 0xB0, 0x32, 0x4C, 0xF9, 0x33, 0x8C, 0x56, 0xAD, 0x52, 0x4D, 0x56, 0x56, 0xAD,
    0x28, 0xAB, 0x8F, 0x6A, 0xD5, 0xEF, 0x75, 0xCE, 0x79, 0xBF, 0xF7, 0x7A, 0xDD, 0x7F, 0xEF, 0xF7, 0xFB, 0xFE, 0xF1, 0x7D, 0xFC, 0x3E,
    0x9F, 0x87, 0xCE, 0xDE, 0xCF, 0x7B, 0xCE, 0xEB, 0x75, 0xFE, 0x9F, 0xD7, 0x79, 0x9D, 0xD7, 0x79, 0x9D, 0x6B, 0x75, 0x3A, 0x5D, 0xE9,
    0x65, 0x1F, 0x1D, 0xFB, 0xDF, 0xA9, 0x6B, 0x74, 0xBA, 0x0E, 0x10, 0x86, 0x7C, 0xE2, 0xA3, 0xBB, 0x0B, 0x42, 0x86, 0x66, 0x4E, 0xD0,
    0xE9, 0x9E, 0x82, 0xF0, 0x09, 0xF8, 0x57, 0x39, 0x41, 0x60, 0xEC, 0x9F, 0x7F, 0xA8, 0x4E, 0x37, 0x02, 0xC2, 0xE1, 0xF0, 0x2F, 0x2C,
    0x14, 0xF1, 0xDC, 0x50, 0x11, 0x77, 0x08, 0xFC, 0xAB, 0x21, 0x78, 0x03, 0xFC, 0x3D, 0x5A, 0x27, 0xD2, 0x0C, 0x7D, 0x09, 0x71, 0x0B,
    0xFC, 0x3D, 0x0E, 0xC2, 0x91, 0xF0, 0xAF, 0x82, 0xE0, 0x35, 0xF0, 0x77, 0x08, 0x84, 0x83, 0xE1, 0x5F, 0xA7, 0x89, 0x88, 0x07, 0x4F,
    0x14, 0xD8, 0x40, 0xF8, 0x97, 0x46, 0xF0, 0x2C, 0x82, 0x57, 0x10, 0xBC, 0x66, 0xA2, 0xC8, 0xCB, 0x20, 0x46, 0x67, 0x12, 0xA1, 0x33,
    0x09, 0xF3, 0x93, 0x45, 0xF0, 0xAA, 0x49, 0x18, 0xBF, 0x6D, 0x18, 0xE2, 0x21, 0xF0, 0x77, 0x5F, 0x08, 0xF5, 0xF0, 0x2F, 0x9D, 0xE0,
    0xD9, 0x61, 0x22, 0xEF, 0xCF, 0xC2, 0xBF, 0x5A, 0x82, 0xFB, 0x87, 0xEB, 0x74, 0x63, 0xA5, 0x72, 0xC5, 0x85, 0x93, 0x7C, 0x86, 0x63,
    0x7D, 0x56, 0x13, 0xDC, 0x37, 0x02, 0xF1, 0x11, 0x11, 0x88, 0x47, 0x11, 0xBC, 0x88, 0xE0, 0xE5, 0x04, 0xF7, 0x8F, 0x44, 0xBC, 0x53,
    0x24, 0xE2, 0x46, 0x82, 0x67, 0x46, 0x62, 0x3E, 0xAB, 0x09, 0x5E, 0x0F, 0x7F, 0x43, 0xD3, 0xF0, 0x36, 0x18, 0x1A, 0x85, 0x78, 0x68,
    0x14, 0xE2, 0x25, 0x04, 0xAF, 0x88, 0x12, 0x75, 0x33, 0x00, 0xFE, 0xF9, 0x45, 0x23, 0xDE, 0x3B, 0x1A, 0x71, 0x0B, 0xC1, 0xF3, 0xA3,
    0xB1, 0x5D, 0x6A, 0x09, 0x7E, 0x25, 0x5A, 0x60, 0xC1, 0x2C, 0x6D, 0x8C, 0x4E, 0xD7, 0x4C, 0xEE, 0x0F, 0x31, 0x12, 0x06, 0xFF, 0x0A,
    0x63, 0x30, 0x7E, 0x59, 0x0C, 0x96, 0xCB, 0x2F, 0x16, 0xF1, 0x8E, 0xB1, 0xC8, 0x37, 0x8C, 0xE0, 0x19, 0x04, 0x2F, 0x23, 0x78, 0x23,
    0xC1, 0x07, 0xC6, 0x21, 0x3E, 0x22, 0x0E, 0xDB, 0x3D, 0x87, 0xE0, 0x05, 0x71, 0x18, 0xBF, 0x8E, 0xE0, 0x8D, 0x71, 0x22, 0x8F, 0x81,
    0xEC, 0x5F, 0x3C, 0xA9, 0xB7, 0x78, 0xC4, 0xB3, 0x09, 0x5E, 0x12, 0x8F, 0xE3, 0xA5, 0xE5, 0x64, 0xC4, 0x3B, 0x4C, 0xC6, 0x7E, 0x1E,
    0x46, 0x70, 0x0B, 0xC1, 0x4B, 0x08, 0x5E, 0x41, 0x70, 0xFF, 0x29, 0xA4, 0xDD, 0xA7, 0x60, 0xFF, 0x0C, 0x25, 0xB8, 0x71, 0x0A, 0xF2,
    0x2D, 0x23, 0x78, 0xD5, 0x14, 0x1C, 0xA7, 0x1D, 0x0C, 0x88, 0x07, 0x1A, 0x44, 0x1F, 0x61, 0x75, 0x9D, 0x41, 0xF0, 0x1C, 0x03, 0xB6,
    0x57, 0x25, 0xC1, 0x6B, 0x09, 0xDE, 0x31, 0x81, 0xF4, 0x87, 0x04, 0xC4, 0x8D, 0x04, 0xCF, 0x24, 0x78, 0x19, 0xC1, 0xAB, 0x08, 0xEE,
    0x9F, 0x48, 0xCA, 0x95, 0x88, 0x78, 0x18, 0xC1, 0x2D, 0x89, 0x58, 0xCF, 0x05, 0x04, 0x2F, 0x25, 0xF8, 0x25, 0x82, 0xFB, 0x26, 0x61,
    0x3B, 0x86, 0x24, 0x21, 0x3E, 0x2E, 0x09, 0xFB, 0x5B, 0x36, 0xC1, 0xF3, 0x93, 0xB0, 0xBF, 0x5D, 0x22, 0x78, 0x07, 0x23, 0xF6, 0xE7,
    0x50, 0x23, 0xA9, 0x67, 0x23, 0xE6, 0xB3, 0x90, 0xE0, 0x65, 0xF0, 0xF7, 0x50, 0x9D, 0x68, 0xB3, 0x96, 0x53, 0x09, 0x9D, 0xA9, 0x48,
    0x3F, 0x8E, 0xE0, 0xD9, 0x04, 0x3F, 0x4B, 0xF0, 0x4B, 0x53, 0x45, 0xDE, 0x59, 0x1B, 0x77, 0x37, 0x21, 0x3E, 0xD8, 0x84, 0x78, 0x3A,
    0xC1, 0xB3, 0x4D, 0x98, 0xCF, 0x4A, 0x82, 0xD7, 0x12, 0xBC, 0x93, 0x99, 0xCC, 0x87, 0x66, 0xEC, 0x0F, 0x19, 0x04, 0xCF, 0x31, 0x63,
    0xBF, 0xAA, 0x20, 0x78, 0x0D, 0xC1, 0xDB, 0x5A, 0x10, 0xEF, 0x6E, 0x41, 0x3C, 0x8A, 0xE0, 0x69, 0x16, 0xAC, 0xFF, 0x12, 0x82, 0x57,
    0x58, 0xB0, 0xFE, 0x7D, 0x93, 0x11, 0x6F, 0x9B, 0x8C, 0xE5, 0x1A, 0x4D, 0xF0, 0xB8, 0x64, 0xA4, 0xBF, 0x86, 0xE0, 0xC5, 0x04, 0xAF,
    0x27, 0xB8, 0x2E, 0x05, 0xF1, 0xE0, 0x14, 0xC4, 0x87, 0xA7, 0x60, 0xBB, 0xE4, 0x10, 0xBC, 0x20, 0x05, 0xC7, 0x57, 0x3D, 0xC1, 0x75,
    0xA9, 0x88, 0x87, 0xA4, 0x92, 0xFE, 0x93, 0x2A, 0x68, 0xF7, 0x64, 0x73, 0x7B, 0x2A, 0xCE, 0x63, 0xC5, 0xA9, 0x98, 0xFF, 0x4B, 0x24,
    0xBE, 0x6F, 0x1A, 0xF6, 0xCF, 0xE0, 0x34, 0x92, 0x1F, 0x82, 0x67, 0x10, 0x3C, 0x27, 0x0D, 0xD7, 0x91, 0x7A, 0x82, 0xEB, 0xA6, 0x89,
    0x31, 0xCD, 0xCA, 0x30, 0x7C, 0x1A, 0xE2, 0x61, 0xD3, 0x70, 0xFC, 0x16, 0x11, 0xBC, 0x9C, 0xE0, 0x01, 0xD3, 0x11, 0xEF, 0x3A, 0x1D,
    0xDB, 0xDD, 0x48, 0xF0, 0xCC, 0xE9, 0x58, 0x3F, 0x15, 0x04, 0xAF, 0x21, 0x78, 0xD7, 0x19, 0x88, 0x0F, 0x9C, 0x81, 0x78, 0x26, 0xC1,
    0x73, 0x67, 0x88, 0x35, 0x84, 0xAD, 0xB5, 0x97, 0x08, 0xEE, 0x9B, 0x8E, 0xF3, 0xD2, 0xE8, 0x74, 0xD2, 0xBE, 0xE9, 0x98, 0x9F, 0x22,
    0x82, 0x97, 0x13, 0xDC, 0x6F, 0x26, 0x99, 0xFF, 0x67, 0x22, 0x1E, 0x47, 0xF0, 0xF4, 0x99, 0xC8, 0xB7, 0x8A, 0xE0, 0x75, 0x04, 0x1F,
    0x3C, 0x0B, 0xF1, 0xD1, 0xB3, 0x10, 0x2F, 0x24, 0x78, 0xD9, 0x2C, 0xAC, 0xFF, 0xB6, 0xB3, 0x49, 0x3F, 0x9F, 0x8D, 0xE5, 0xB5, 0x10,
    0x7C, 0xC1, 0x6C, 0x9C, 0x07, 0xCA, 0x09, 0x5E, 0x3D, 0x1B, 0xFB, 0x43, 0x40, 0x06, 0xA9, 0xFF, 0x0C, 0xEC, 0x9F, 0x61, 0x04, 0xB7,
    0xC0, 0xDF, 0xE3, 0x75, 0x82, 0x77, 0x25, 0xC1, 0x1B, 0x32, 0x70, 0x7E, 0x18, 0xFC, 0x32, 0xC9, 0xFF, 0xCB, 0x38, 0xAE, 0x73, 0x08,
    0x5E, 0x40, 0xF0, 0x3A, 0x82, 0x37, 0xBE, 0x8C, 0x74, 0x86, 0xCE, 0x21, 0xEB, 0xD7, 0x1C, 0x8C, 0x9F, 0x47, 0xF0, 0xA2, 0x39, 0x58,
    0xDE, 0x2B, 0x04, 0xF7, 0x9B, 0x8B, 0xF9, 0x0F, 0x99, 0x4B, 0xC6, 0xC5, 0x5C, 0xEC, 0xCF, 0x59, 0x04, 0x5F, 0x33, 0x17, 0xDB, 0xAB,
    0x8E, 0xE0, 0x8D, 0x04, 0x0F, 0xC9, 0x24, 0x74, 0x32, 0x31, 0x9F, 0xF9, 0x04, 0x2F, 0xC9, 0x44, 0xF9, 0x24, 0x60, 0x1E, 0xA9, 0xCF,
    0x79, 0x28, 0xE7, 0xA4, 0x13, 0x3C, 0x9B, 0xE0, 0xB5, 0x04, 0xBF, 0x32, 0x0F, 0xC7, 0x51, 0xC8, 0x7C, 0x1C, 0xBF, 0x86, 0xF9, 0x88,
    0x97, 0xCC, 0x27, 0xF3, 0xD5, 0x7C, 0xCC, 0x4F, 0xDB, 0x57, 0x30, 0xFE, 0xE0, 0x57, 0x30, 0x7E, 0xD6, 0x2B, 0xA4, 0xBC, 0x04, 0xAF,
    0x27, 0xB8, 0x6E, 0x81, 0x4E, 0x07, 0xA2, 0x29, 0x6F, 0xE3, 0xB0, 0x05, 0xA4, 0xDD, 0x17, 0x60, 0xB9, 0x2A, 0x09, 0x5E, 0xBB, 0x80,
    0xAC, 0xB3, 0x0B, 0xC9, 0x3A, 0xBB, 0x10, 0xE5, 0x96, 0x34, 0x82, 0x67, 0x2D, 0xC4, 0x79, 0xB5, 0x9C, 0xE0, 0xD5, 0x0B, 0x31, 0xFF,
    0x9D, 0x5E, 0x25, 0xF3, 0xFF, 0xAB, 0x44, 0xAE, 0x26, 0x78, 0xD6, 0xAB, 0xC8, 0xF7, 0x08, 0xC1, 0xCF, 0xBE, 0x8A, 0xFD, 0xA1, 0xD3,
    0x22, 0x42, 0x67, 0x11, 0xCE, 0xF3, 0x69, 0x04, 0x2F, 0x58, 0x84, 0x74, 0x6A, 0x09, 0x7E, 0x85, 0xE0, 0xBD, 0xB3, 0x10, 0x1F, 0x9A,
    0x85, 0x78, 0x26, 0xC1, 0x73, 0x09, 0x5E, 0x45, 0xF0, 0xBA, 0x2C, 0xAC, 0x87, 0xEE, 0x8B, 0xC9, 0xFA, 0xB8, 0x98, 0xAC, 0x8F, 0x04,
    0xCF, 0x26, 0x78, 0x05, 0xC1, 0x6B, 0x16, 0x63, 0xFE, 0x3B, 0x2E, 0x21, 0xF5, 0xBC, 0x04, 0xE7, 0xCF, 0x4C, 0x82, 0x17, 0x2F, 0xC1,
    0xF8, 0x0D, 0x04, 0x6F, 0xF9, 0x1A, 0xE2, 0x43, 0x5F, 0x23, 0xE3, 0x8B, 0xE0, 0x79, 0x04, 0x2F, 0x22, 0xF8, 0x25, 0x82, 0xFB, 0x66,
    0x23, 0xDF, 0xD1, 0xD9, 0x64, 0x9E, 0xCC, 0xC6, 0x79, 0xA9, 0x8C, 0xE0, 0x55, 0xD9, 0x64, 0xFF, 0xF2, 0x3A, 0x99, 0xAF, 0x5E, 0x47,
    0xDC, 0x48, 0xF0, 0xCC, 0xD7, 0xC9, 0xFE, 0x8E, 0xE0, 0xB5, 0xAF, 0x23, 0xDF, 0xDE, 0x6F, 0x90, 0x76, 0x79, 0x03, 0xF1, 0x5C, 0x82,
    0x17, 0xBE, 0x81, 0xFD, 0xA1, 0x81, 0xE0, 0x2D, 0x97, 0x92, 0x7A, 0x58, 0x4A, 0xEA, 0x61, 0x29, 0x8E, 0x8B, 0x02, 0x82, 0x97, 0x2E,
    0xC5, 0x7C, 0xEA, 0x72, 0x10, 0x0F, 0xC8, 0xC1, 0xFE, 0x3C, 0x9C, 0xE0, 0x96, 0x1C, 0xE4, 0x5B, 0x4A, 0xF0, 0xCA, 0x1C, 0x6C, 0x5F,
    0xBF, 0x65, 0x64, 0xBD, 0x58, 0x86, 0x78, 0x28, 0xC1, 0x8D, 0xCB, 0x30, 0x3F, 0xA5, 0x04, 0xAF, 0x5C, 0x86, 0xF9, 0x09, 0x58, 0x4E,
    0xE6, 0x99, 0xE5, 0x64, 0xDD, 0x24, 0x78, 0xE6, 0x72, 0x8C, 0x7F, 0x84, 0xE0, 0x67, 0x97, 0x63, 0xFE, 0x03, 0x56, 0x10, 0x3A, 0x2B,
    0x10, 0x0F, 0x23, 0xB8, 0x65, 0x05, 0xF6, 0xF3, 0x22, 0x82, 0x97, 0x13, 0x5C, 0x97, 0x4B, 0xEA, 0x27, 0x17, 0xF1, 0x11, 0x04, 0x8F,
    0xCA, 0x25, 0xFB, 0x47, 0x82, 0x97, 0xE7, 0x12, 0x79, 0x60, 0x25, 0x59, 0x47, 0x56, 0x22, 0x9E, 0x4F, 0xF0, 0x92, 0x95, 0x58, 0xAE,
    0x46, 0x82, 0xFB, 0xBF, 0x89, 0xF8, 0xE8, 0x37, 0x49, 0xFF, 0x7C, 0x13, 0xD7, 0xF7, 0x12, 0x82, 0x57, 0xBC, 0x89, 0xF3, 0x70, 0xC7,
    0xB7, 0xC8, 0xF8, 0x7A, 0x8B, 0xEC, 0x1F, 0x09, 0xBE, 0xE0, 0x2D, 0xCC, 0x4F, 0x35, 0xC1, 0xEB, 0x49, 0xFC, 0xEE, 0x79, 0x64, 0xBC,
    0xE7, 0xE1, 0xBA, 0x63, 0x21, 0xF8, 0x02, 0x82, 0x97, 0x12, 0xBC, 0x32, 0x0F, 0xD7, 0xAF, 0x96, 0xAB, 0x70, 0x3E, 0x0F, 0x5C, 0x85,
    0xF5, 0x69, 0x58, 0x45, 0xF6, 0x95, 0xAB, 0xB0, 0x9F, 0x54, 0x10, 0xBC, 0x66, 0x15, 0xD1, 0x57, 0xAC, 0x26, 0xF3, 0xE1, 0x6A, 0xC4,
    0xD3, 0x09, 0x9E, 0xBD, 0x1A, 0xE5, 0x8D, 0x3A, 0x82, 0x37, 0x92, 0xF8, 0x83, 0xDF, 0x26, 0xED, 0xF2, 0x36, 0xD6, 0x5B, 0x01, 0xC1,
    0x4B, 0xDF, 0xC6, 0xFE, 0xD3, 0x40, 0xF0, 0x96, 0x6B, 0x70, 0x7D, 0x89, 0x5B, 0x43, 0xE4, 0xC9, 0x35, 0x48, 0xA7, 0x8E, 0xE0, 0x8D,
    0x6B, 0x88, 0x3C, 0xB0, 0x96, 0x8C, 0xD3, 0xB5, 0x48, 0xA7, 0x94, 0xE0, 0x95, 0x6B, 0xB1, 0xFF, 0xB7, 0x5D, 0x47, 0xE6, 0x99, 0x75,
    0x98, 0x9F, 0x28, 0x82, 0xA7, 0xAD, 0xC3, 0x71, 0x57, 0x4C, 0xF0, 0x23, 0x04, 0xF7, 0x7D, 0x87, 0xC8, 0xFF, 0xEF, 0xE0, 0xB8, 0x0E,
    0x23, 0xB8, 0xE5, 0x1D, 0xE4, 0x5B, 0x4A, 0xF0, 0xCA, 0x77, 0x48, 0x3B, 0xE6, 0x93, 0x7E, 0x95, 0x8F, 0xF4, 0x8D, 0x04, 0xCF, 0xCC,
    0x27, 0xE3, 0x94, 0xE0, 0x67, 0xF3, 0x71, 0x1D, 0xEC, 0xB0, 0x9E, 0xEC, 0x8B, 0xD7, 0x63, 0xFF, 0x89, 0x22, 0x78, 0xDA, 0x7A, 0x2C,
    0x6F, 0x11, 0xC1, 0xCB, 0x49, 0xFC, 0x2B, 0x04, 0xF7, 0xDB, 0x80, 0xFD, 0x76, 0xF8, 0x06, 0x22, 0xB7, 0x6F, 0xC0, 0x7C, 0xE6, 0x11,
    0xBC, 0x88, 0xE0, 0xF5, 0x04, 0xD7, 0x6D, 0x44, 0x7C, 0xE0, 0x46, 0xA2, 0xC7, 0xD8, 0x88, 0xF5, 0xB0, 0x80, 0xE0, 0x79, 0x1B, 0x31,
    0x9F, 0x55, 0x04, 0xAF, 0xDB, 0x88, 0xF9, 0xEC, 0x50, 0x40, 0xCA, 0x5B, 0x80, 0xF4, 0x0D, 0x04, 0xCF, 0x28, 0xC0, 0x71, 0x5D, 0x49,
    0xF0, 0x5A, 0x82, 0xF7, 0x7E, 0x97, 0xAC, 0x17, 0xEF, 0x22, 0x9E, 0x4B, 0xF0, 0xC2, 0x77, 0x51, 0xFF, 0xA6, 0xDB, 0x44, 0xE6, 0xB1,
    0x4D, 0x58, 0xFF, 0xA3, 0x09, 0x9E, 0xB1, 0x89, 0xE8, 0x73, 0x08, 0x5E, 0xB5, 0x09, 0xC7, 0x4B, 0xDB, 0xCD, 0xA4, 0x1F, 0x6E, 0x26,
    0xF2, 0x39, 0xC1, 0x17, 0x10, 0xBC, 0x92, 0xE0, 0x8D, 0x04, 0x0F, 0x29, 0x24, 0xEB, 0x42, 0x21, 0xE2, 0x25, 0x04, 0xAF, 0x20, 0x78,
    0xC0, 0x16, 0x32, 0x9F, 0x6F, 0x41, 0xDC, 0x48, 0xF0, 0x4C, 0x82, 0x57, 0x10, 0xBC, 0x66, 0x0B, 0xD1, 0x4F, 0x6E, 0x25, 0xF3, 0xC6,
    0x56, 0xB2, 0x1F, 0x27, 0x78, 0x0E, 0xC1, 0xCF, 0x12, 0xFC, 0x12, 0xC1, 0x83, 0xB7, 0x91, 0x7D, 0xE5, 0x36, 0xAC, 0x9F, 0x6C, 0x82,
    0xE7, 0x6F, 0xC3, 0xF8, 0xF5, 0x04, 0xD7, 0x15, 0x89, 0xBE, 0xD0, 0x9D, 0xF5, 0x81, 0x22, 0x22, 0x87, 0x17, 0x61, 0xBF, 0xCA, 0x26,
    0x78, 0x49, 0x11, 0xB6, 0xA3, 0xDF, 0x76, 0xB2, 0xCE, 0x6E, 0x27, 0xFB, 0x32, 0x82, 0xA7, 0x6F, 0xC7, 0x79, 0xE6, 0x08, 0xC1, 0xCF,
    0x6E, 0xC7, 0x7A, 0xE8, 0xB8, 0x83, 0x8C, 0xDF, 0x1D, 0x48, 0x27, 0x9D, 0xE0, 0xD9, 0x04, 0xAF, 0x26, 0x78, 0xFD, 0x0E, 0x9C, 0xB7,
    0xBB, 0xEE, 0x24, 0xF5, 0xB0, 0x13, 0xE9, 0x67, 0x13, 0x3C, 0x7F, 0x27, 0xE6, 0xFF, 0x0A, 0xC1, 0xFD, 0x8A, 0x11, 0x0F, 0x2B, 0x26,
    0xF2, 0x70, 0x31, 0x8E, 0x8B, 0x23, 0x04, 0xBF, 0x42, 0xF0, 0xDE, 0xBB, 0x48, 0xFF, 0xDF, 0x85, 0xF5, 0x9F, 0x45, 0xF0, 0xD2, 0x5D,
    0xD8, 0xCF, 0x1B, 0x09, 0xEE, 0xFF, 0x1E, 0x8E, 0xD3, 0xA1, 0xEF, 0x91, 0x79, 0xF8, 0x3D, 0xAC, 0xFF, 0x1C, 0x82, 0x17, 0xBC, 0x87,
    0xFB, 0x44, 0xDF, 0xDD, 0x64, 0xFE, 0xDC, 0x8D, 0xF4, 0xC7, 0x11, 0xDC, 0xB0, 0x1B, 0xF3, 0x59, 0x40, 0xF0, 0xCA, 0xDD, 0xD8, 0xEE,
    0xBA, 0x12, 0x32, 0x1E, 0x4B, 0x50, 0xBF, 0x31, 0x94, 0xE0, 0x69, 0x04, 0x2F, 0x24, 0x78, 0x59, 0x09, 0xD2, 0xB9, 0x44, 0x70, 0xDF,
    0x3D, 0xD8, 0x2E, 0x83, 0xF7, 0x90, 0x75, 0x6D, 0x0F, 0xD2, 0x59, 0x40, 0xF0, 0xBC, 0x3D, 0x38, 0xDE, 0xCF, 0x12, 0xDC, 0x7F, 0x2F,
    0xEE, 0x8F, 0x0C, 0x7B, 0x49, 0x3F, 0xDC, 0x8B, 0xFD, 0x41, 0xB7, 0x8F, 0xCC, 0x63, 0xFB, 0x10, 0x4F, 0x23, 0xF8, 0x9A, 0x7D, 0xD8,
    0x2E, 0xB5, 0x04, 0xBF, 0xB2, 0x0F, 0xFB, 0x67, 0x48, 0x29, 0xE9, 0xFF, 0xA5, 0x18, 0x3F, 0x8F, 0xE0, 0x45, 0x04, 0x6F, 0x20, 0x78,
    0xCB, 0xF7, 0x51, 0x6E, 0x19, 0xF7, 0x3E, 0xA9, 0xFF, 0xF7, 0xB1, 0x5D, 0x0A, 0x09, 0x5E, 0xF6, 0x3E, 0xD2, 0xF1, 0xFD, 0x80, 0xB4,
    0xE3, 0x07, 0x38, 0x3F, 0x0F, 0x27, 0xB8, 0xE5, 0x03, 0xB2, 0x0E, 0x12, 0xBC, 0xF2, 0x03, 0x22, 0xF7, 0xEE, 0x27, 0xE3, 0x71, 0x3F,
    0xF6, 0xAB, 0x71, 0x04, 0xCF, 0xDC, 0x8F, 0xF3, 0x73, 0x15, 0xC1, 0xEB, 0xF6, 0x63, 0xFD, 0x77, 0x2D, 0x23, 0x7A, 0x1E, 0xF8, 0x3B,
    0x8A, 0x8D, 0x09, 0x56, 0x87, 0x04, 0xAF, 0x2F, 0xC3, 0xFC, 0xF4, 0x3E, 0x40, 0xFA, 0xFF, 0x01, 0x32, 0xFF, 0x13, 0xBC, 0xF0, 0x00,
    0xC6, 0x6F, 0x20, 0x78, 0xCB, 0x83, 0x28, 0x9F, 0x84, 0x1E, 0x24, 0xF3, 0xF0, 0x41, 0x32, 0x0F, 0x13, 0xBC, 0xE2, 0x20, 0xCA, 0x27,
    0xDD, 0x0F, 0x11, 0x39, 0xF0, 0x90, 0xE0, 0xCB, 0xEA, 0x3F, 0x9B, 0xE0, 0xF9, 0x87, 0x88, 0x5E, 0x97, 0xE0, 0xBE, 0xE5, 0xE4, 0xFC,
    0xA5, 0x9C, 0xC8, 0xCF, 0xE5, 0x28, 0xEF, 0x15, 0x11, 0xBC, 0xBC, 0x1C, 0xCB, 0x15, 0x70, 0x98, 0xCC, 0xFF, 0x87, 0x89, 0xFE, 0x81,
    0xE0, 0xD9, 0x04, 0xAF, 0x25, 0xF8, 0x95, 0xC3, 0x48, 0x67, 0xE8, 0x87, 0x64, 0xBC, 0x7F, 0x48, 0xF4, 0x30, 0x04, 0x2F, 0xFA, 0x10,
    0xF3, 0xD9, 0x48, 0x70, 0xFF, 0x8F, 0x44, 0x9B, 0xB0, 0xB1, 0x61, 0xFC, 0x88, 0xB4, 0xEF, 0x47, 0xD8, 0x0F, 0xAB, 0x08, 0x5E, 0xF7,
    0x11, 0xD2, 0xEF, 0x7A, 0x84, 0xB4, 0xEF, 0x11, 0xA2, 0xC7, 0x23, 0x78, 0xEE, 0x11, 0xEC, 0x0F, 0xD5, 0x04, 0xAF, 0x27, 0x78, 0xF7,
    0xA3, 0xA4, 0xFE, 0x8F, 0x22, 0xDF, 0x6C, 0x82, 0xE7, 0x1F, 0x25, 0xF5, 0x4F, 0x70, 0xDF, 0x63, 0x44, 0x3F, 0x7F, 0x8C, 0x8C, 0xBB,
    0x63, 0x58, 0xFF, 0xF9, 0x04, 0x2F, 0x21, 0xB8, 0xEF, 0x71, 0x32, 0x5E, 0x8E, 0x13, 0xB9, 0x91, 0xE0, 0x59, 0xC7, 0x31, 0x7E, 0x35,
    0xC1, 0xEB, 0x8F, 0xA3, 0x1C, 0x1E, 0x52, 0x41, 0xF8, 0x56, 0x60, 0xFE, 0x0B, 0x08, 0x5E, 0x4A, 0x70, 0xBF, 0x13, 0x64, 0x7C, 0x9D,
    0xC0, 0xF5, 0xC2, 0x42, 0xF0, 0x05, 0x04, 0x3F, 0x4B, 0xF0, 0x4B, 0x27, 0x90, 0xEF, 0xD0, 0x93, 0x24, 0xFE, 0x49, 0x6C, 0x97, 0x23,
    0x04, 0x3F, 0x7B, 0x12, 0xFB, 0x4F, 0xE0, 0x29, 0x72, 0x2E, 0x79, 0x0A, 0xCB, 0x9B, 0x45, 0xF0, 0x35, 0x04, 0xAF, 0x23, 0x78, 0x23,
    0xC1, 0x43, 0x2A, 0x49, 0x79, 0x2B, 0xB1, 0x1F, 0x16, 0x10, 0xBC, 0xB4, 0x12, 0xC7, 0xA9, 0xEF, 0x69, 0x52, 0xCF, 0xA7, 0x49, 0x3D,
    0x13, 0xDC, 0x72, 0x1A, 0xDB, 0xB1, 0x98, 0xE0, 0x47, 0x4E, 0x63, 0xBD, 0xB5, 0x3D, 0x43, 0xE4, 0xB4, 0x33, 0xC8, 0x37, 0x9D, 0xE0,
    0xD9, 0x67, 0xB0, 0xDE, 0x6A, 0x09, 0x7E, 0xE5, 0x0C, 0xCE, 0x93, 0x03, 0x3F, 0x26, 0x72, 0xEF, 0xC7, 0x98, 0xCF, 0x5C, 0x82, 0x17,
    0x7E, 0x8C, 0xEB, 0x4E, 0x1D, 0xC1, 0x1B, 0x3F, 0xC6, 0x7A, 0x1E, 0x58, 0x45, 0xE8, 0x54, 0x61, 0xB9, 0x72, 0x09, 0x5E, 0x48, 0xF0,
    0x06, 0x82, 0xB7, 0xFC, 0x04, 0xE5, 0x8A, 0xE1, 0x9F, 0x10, 0x79, 0x9E, 0xE0, 0xF9, 0x04, 0x2F, 0xF9, 0x04, 0xF9, 0x5E, 0x21, 0xB8,
    0xDF, 0xA7, 0x88, 0x0F, 0xFF, 0x94, 0xD0, 0xF9, 0x14, 0xCB, 0x55, 0x40, 0xF0, 0xD2, 0x4F, 0x89, 0x9E, 0xE4, 0x33, 0xB2, 0x5E, 0x7F,
    0x86, 0xF3, 0xFF, 0x08, 0x82, 0x47, 0x7D, 0x86, 0xF1, 0x0B, 0x08, 0x5E, 0xFA, 0x19, 0x91, 0x43, 0x08, 0xEE, 0x5F, 0x8D, 0xED, 0x38,
    0xA2, 0x9A, 0xD0, 0xA9, 0x26, 0xFA, 0x04, 0x82, 0x97, 0x57, 0x23, 0x1D, 0xDF, 0xCF, 0x49, 0x3F, 0xF9, 0x1C, 0xF9, 0x86, 0x12, 0xDC,
    0xF8, 0x39, 0xD2, 0x2F, 0x22, 0x78, 0xF9, 0xE7, 0x58, 0xCF, 0x7E, 0x5F, 0x90, 0xF1, 0xF5, 0x05, 0xE2, 0x71, 0x04, 0xCF, 0x27, 0x78,
    0x3D, 0xC1, 0x75, 0x5F, 0x92, 0xF3, 0x9A, 0x2F, 0x49, 0x3F, 0xFF, 0x12, 0xF3, 0x93, 0x47, 0xF0, 0xA2, 0x2F, 0xB1, 0x9E, 0xAF, 0x10,
    0xDC, 0xEF, 0xAC, 0x4E, 0x17, 0xA1, 0x13, 0x6B, 0x8C, 0xF1, 0x2C, 0x99, 0x57, 0xCF, 0x62, 0x79, 0xCB, 0x09, 0x5E, 0x7D, 0x16, 0xF3,
    0xD3, 0xF1, 0x2B, 0x22, 0xC7, 0x7E, 0x85, 0xEB, 0xAF, 0x81, 0xE0, 0xB9, 0x5F, 0xE1, 0xB8, 0xA8, 0x23, 0x78, 0xE3, 0x57, 0x38, 0xDE,
    0x47, 0x7C, 0x4D, 0xEA, 0xFF, 0x6B, 0x1C, 0x17, 0x25, 0x04, 0xAF, 0x20, 0x78, 0xC7, 0x6F, 0x08, 0xDF, 0x6F, 0x88, 0x7E, 0x98, 0xE0,
    0x85, 0xDF, 0x60, 0x3B, 0x5E, 0x21, 0xF8, 0xE0, 0x1A, 0x94, 0xC7, 0x2C, 0x35, 0x44, 0x1E, 0x83, 0xBF, 0xBB, 0xB2, 0x3D, 0x0A, 0x2B,
    0x2F, 0xC1, 0xAB, 0x49, 0x7C, 0xBF, 0x73, 0x64, 0xDD, 0x3F, 0x87, 0x78, 0x3A, 0xC1, 0x8B, 0xCF, 0x61, 0xBB, 0x5C, 0x21, 0xB8, 0xDF,
    0xB7, 0x98, 0xCF, 0x11, 0xDF, 0x92, 0xF2, 0x7E, 0x8B, 0xF2, 0xC6, 0x11, 0x82, 0xFB, 0x9D, 0xC7, 0x7A, 0x0B, 0x3D, 0x4F, 0xFA, 0xD5,
    0x79, 0x2C, 0x57, 0x29, 0xC1, 0x2B, 0xCF, 0xA3, 0xBE, 0xB4, 0x6B, 0x2D, 0x59, 0xEF, 0x6A, 0xF9, 0x11, 0xA1, 0xCE, 0xC4, 0xF2, 0x46,
    0x70, 0xBF, 0xEF, 0xA0, 0x9F, 0xE9, 0x04, 0x6F, 0xCB, 0x77, 0x64, 0x1E, 0x83, 0xBF, 0x13, 0x21, 0x9C, 0xCC, 0xE6, 0x94, 0xEF, 0xC9,
    0xFE, 0xE2, 0x7B, 0xA4, 0x53, 0x4E, 0xF0, 0xEA, 0xEF, 0x91, 0x6F, 0xE0, 0x05, 0x52, 0xAE, 0x0B, 0x64, 0x1C, 0x11, 0xBC, 0xFC, 0x02,
    0xCA, 0xF9, 0x8D, 0x04, 0xEF, 0x54, 0x87, 0xEB, 0x97, 0xB1, 0x8E, 0xF4, 0xC3, 0x3A, 0x72, 0x9E, 0x4E, 0xF0, 0xAA, 0x3A, 0xA4, 0xE3,
    0xF7, 0x03, 0xE9, 0x0F, 0x3F, 0x10, 0x7D, 0x08, 0xC1, 0x0B, 0x7E, 0x20, 0xFA, 0x79, 0x82, 0x77, 0xF8, 0x11, 0xC7, 0x69, 0xE8, 0x8F,
    0xA4, 0x9E, 0x7F, 0xC4, 0xF6, 0x2A, 0x26, 0xF8, 0x91, 0x1F, 0xB1, 0xDE, 0x02, 0x7F, 0x22, 0xE5, 0xFD, 0x09, 0xC7, 0x45, 0x21, 0xC1,
    0xCB, 0x7E, 0xC2, 0x76, 0xF4, 0xAF, 0x27, 0xE5, 0xAD, 0xC7, 0x7C, 0x86, 0x11, 0xDC, 0x52, 0x8F, 0xEB, 0x45, 0x39, 0xC1, 0xAB, 0xEB,
    0x31, 0xFF, 0x01, 0x3F, 0x93, 0xFE, 0xFC, 0x33, 0xE6, 0x3F, 0x83, 0xE0, 0x85, 0x04, 0xAF, 0x27, 0xB8, 0xEE, 0x17, 0xA4, 0x3F, 0xE2,
    0x17, 0x92, 0x7F, 0x82, 0x17, 0x13, 0xFC, 0xC8, 0x2F, 0x38, 0x6F, 0xF8, 0x5F, 0x24, 0xF9, 0xBF, 0x88, 0xF5, 0x13, 0x47, 0xF0, 0xF4,
    0x8B, 0x18, 0xBF, 0x9C, 0xE0, 0xD5, 0x17, 0x49, 0xFE, 0x2F, 0x11, 0x79, 0xF2, 0x12, 0xE2, 0x51, 0x04, 0x4F, 0xBB, 0x84, 0xFD, 0xA7,
    0x9C, 0xE0, 0xD5, 0x97, 0x70, 0x7C, 0x75, 0xF8, 0x95, 0xEC, 0x83, 0x7E, 0x45, 0xDC, 0x42, 0xF0, 0x05, 0xBF, 0x62, 0x7E, 0x2A, 0x09,
    0x5E, 0xFB, 0x2B, 0xB1, 0x13, 0xF8, 0x8D, 0xE8, 0x25, 0x7E, 0x23, 0x7A, 0x09, 0x82, 0xE7, 0xFC, 0x86, 0xE5, 0xAD, 0x26, 0xB8, 0xEE,
    0x32, 0xE2, 0x21, 0x97, 0xC9, 0x3E, 0xE8, 0x32, 0xD2, 0x29, 0x26, 0x78, 0xCD, 0x65, 0xA2, 0x47, 0x6D, 0x20, 0xE3, 0xAB, 0x01, 0xCB,
    0x9B, 0x4B, 0xF0, 0xEA, 0x06, 0x32, 0xBE, 0x7E, 0x27, 0x72, 0xD1, 0xEF, 0x28, 0x5F, 0xE5, 0x11, 0xFC, 0x12, 0xFC, 0x6D, 0x64, 0xFC,
    0x59, 0xBF, 0xFA, 0x83, 0xF4, 0xAB, 0x3F, 0x88, 0xBD, 0x0D, 0xC1, 0x6B, 0xFF, 0x40, 0xBE, 0x81, 0xFF, 0x23, 0xF4, 0xFF, 0x47, 0xE8,
    0x13, 0xBC, 0xE8, 0x7F, 0xD8, 0x5E, 0xF5, 0x04, 0xEF, 0x78, 0x05, 0xE5, 0xF3, 0x8C, 0x2B, 0x44, 0xAE, 0x83, 0xBF, 0x2D, 0x3A, 0x91,
    0xA7, 0x11, 0x7F, 0x92, 0xFE, 0xF6, 0x27, 0x8E, 0x8B, 0x62, 0x82, 0x1F, 0xF9, 0x13, 0xC7, 0x91, 0xFF, 0x5F, 0xA4, 0xBF, 0xFD, 0x45,
    0xE6, 0x07, 0x82, 0x67, 0xFE, 0x85, 0xEB, 0x42, 0x35, 0xC1, 0xEB, 0xFF, 0xC2, 0x75, 0x6D, 0xC4, 0xDF, 0x84, 0xEF, 0xDF, 0x58, 0x3F,
    0x55, 0x04, 0xAF, 0xFB, 0x1B, 0xEB, 0x79, 0x70, 0x23, 0xD9, 0xBF, 0x37, 0xE2, 0xFC, 0x5C, 0x42, 0xF0, 0x96, 0xFF, 0x90, 0x73, 0x9F,
    0x7F, 0xC8, 0xBE, 0xE6, 0x1F, 0x5C, 0xD7, 0x8A, 0x08, 0x5E, 0xFE, 0x0F, 0x39, 0xDF, 0xFF, 0x97, 0xD4, 0xDB, 0xBF, 0x58, 0xFF, 0x06,
    0x82, 0xE7, 0xFC, 0x8B, 0xF4, 0xAB, 0x08, 0x5E, 0xF7, 0x2F, 0xD6, 0x7F, 0xA7, 0xFF, 0x88, 0x5C, 0xF7, 0x1F, 0xAE, 0xBF, 0x0B, 0x08,
    0x5E, 0xF4, 0x1F, 0x39, 0x77, 0x23, 0x78, 0x07, 0xF8, 0xAF, 0x3C, 0xDE, 0x0D, 0xF0, 0x77, 0x13, 0x5F, 0xF8, 0x6F, 0x93, 0xFE, 0x8D,
    0xE0, 0x97, 0x08, 0x1E, 0xEC, 0x83, 0x78, 0x9C, 0x0F, 0xE2, 0x45, 0x04, 0x2F, 0x87, 0xBF, 0xE5, 0x7A, 0x68, 0xDB, 0x0C, 0xF1, 0x11,
    0xF0, 0xB7, 0x3C, 0xEE, 0xB2, 0x09, 0x9E, 0xDF, 0x0C, 0xF3, 0xD3, 0x40, 0xF0, 0x96, 0xD7, 0x20, 0xFD, 0x11, 0xD7, 0x20, 0x9E, 0x4E,
    0xF0, 0x72, 0x82, 0x57, 0x5F, 0x83, 0xF4, 0xDB, 0xFA, 0x22, 0xDE, 0x1D, 0xFE, 0x6E, 0xD2, 0x97, 0x12, 0xBC, 0x04, 0xFE, 0x96, 0xC7,
    0x45, 0x23, 0xC1, 0xFD, 0x9B, 0xFB, 0xA0, 0x7C, 0xD8, 0x1C, 0xF1, 0x2C, 0x82, 0x57, 0x10, 0xFC, 0x0A, 0xFC, 0x2D, 0xCB, 0x03, 0xDD,
    0xAF, 0x45, 0x7C, 0x30, 0xFC, 0x2D, 0xB7, 0x57, 0x3A, 0xC1, 0xB3, 0xE1, 0x6F, 0x79, 0xBC, 0x5C, 0x22, 0xB8, 0x6F, 0x0B, 0x9F, 0xA6,
    0xF9, 0x64, 0x68, 0x0B, 0xC4, 0x2D, 0x2D, 0x30, 0x9F, 0x25, 0x04, 0xAF, 0x85, 0xBF, 0x65, 0xFD, 0x49, 0xDB, 0x96, 0x84, 0x6F, 0x4B,
    0xCC, 0x8F, 0x85, 0xE0, 0x45, 0xF0, 0xB7, 0x3C, 0x5E, 0x7C, 0xAF, 0x43, 0xBC, 0x2D, 0xFC, 0xDD, 0x64, 0x8F, 0x44, 0xF0, 0x0C, 0xF8,
    0x5B, 0x5E, 0x67, 0x4B, 0x08, 0x5E, 0x41, 0x70, 0xDF, 0xEB, 0x09, 0x9D, 0xEB, 0x11, 0x1F, 0x41, 0xF0, 0x28, 0x82, 0xE7, 0x11, 0xBC,
    0x88, 0xE0, 0x75, 0x04, 0x6F, 0xBC, 0x1E, 0xEB, 0x61, 0x70, 0x2B, 0xC4, 0x47, 0xB7, 0x42, 0x3C, 0x97, 0xE0, 0x85, 0x04, 0xBF, 0x44,
    0x70, 0x5F, 0x3F, 0xAC, 0x87, 0x60, 0x3F, 0xC4, 0x87, 0xC3, 0xDF, 0xF2, 0xFC, 0x93, 0x47, 0xF0, 0x22, 0x3F, 0xEC, 0x57, 0x57, 0x08,
    0xDE, 0xE9, 0x06, 0xEC, 0xCF, 0x69, 0x37, 0x90, 0xFE, 0x70, 0x03, 0xB6, 0x4B, 0x25, 0xC1, 0x1B, 0x6F, 0xC0, 0xFE, 0x16, 0xD2, 0x9A,
    0x8C, 0x97, 0xD6, 0x88, 0x17, 0x11, 0xBC, 0x9C, 0xE0, 0x7E, 0x37, 0x22, 0xDE, 0x11, 0xFE, 0x96, 0xE7, 0xA5, 0x34, 0x82, 0x97, 0xC3,
    0xDF, 0xB2, 0x5E, 0xB4, 0xA3, 0x3F, 0xE2, 0xBD, 0xE1, 0x6F, 0x59, 0x5F, 0x94, 0x43, 0xF0, 0x02, 0x7F, 0xCC, 0x7F, 0x23, 0xC1, 0xFD,
    0x6F, 0xF2, 0x69, 0x9A, 0x7F, 0x42, 0x6F, 0x42, 0xDC, 0x78, 0x13, 0x96, 0xAB, 0x98, 0xE0, 0x47, 0x48, 0xFC, 0x80, 0x9B, 0xC9, 0xB8,
    0xBE, 0x19, 0xDB, 0x71, 0x01, 0xC1, 0x8B, 0x6E, 0xC6, 0xF8, 0x8D, 0x04, 0xF7, 0xBF, 0x05, 0xC7, 0xC5, 0xF0, 0x5B, 0x10, 0x0F, 0xBB,
    0x05, 0xDB, 0x31, 0x9F, 0xE0, 0x55, 0xB7, 0x60, 0xFF, 0xF4, 0x0F, 0x40, 0x3C, 0x38, 0x00, 0x71, 0x0B, 0xC1, 0x17, 0x04, 0x60, 0x3D,
    0xD4, 0x11, 0xBC, 0x31, 0x00, 0xCB, 0x35, 0xB8, 0x0D, 0xE9, 0xE7, 0xF0, 0x77, 0xD3, 0xB9, 0x27, 0xC1, 0x6B, 0x08, 0xDE, 0xFD, 0x56,
    0x32, 0xBE, 0x6E, 0xC5, 0x72, 0x65, 0x11, 0xBC, 0xF2, 0x56, 0x6C, 0xAF, 0xAE, 0xB7, 0x21, 0x6E, 0xB8, 0x0D, 0xEB, 0xBF, 0x8C, 0xE0,
    0x55, 0xB7, 0x21, 0x9D, 0x8E, 0x6D, 0x49, 0x3D, 0xB4, 0x45, 0xBC, 0x90, 0xE0, 0x65, 0x6D, 0xB1, 0x9F, 0xB4, 0x6C, 0x87, 0x78, 0x60,
    0x3B, 0xA4, 0x9F, 0x49, 0xF0, 0xE2, 0x76, 0x98, 0x7F, 0xDD, 0xED, 0x88, 0x07, 0xDC, 0x8E, 0xF9, 0x34, 0x10, 0x3C, 0xEF, 0x76, 0x9C,
    0x1F, 0x2E, 0x11, 0xDC, 0xB7, 0x3D, 0xF6, 0xB7, 0xB0, 0xF6, 0x64, 0x5E, 0x6A, 0x8F, 0x7C, 0x8F, 0x10, 0xFC, 0x6C, 0x7B, 0x1C, 0x47,
    0x9D, 0x3A, 0x90, 0xF6, 0xEA, 0x80, 0xF9, 0xC9, 0x24, 0x78, 0x6E, 0x07, 0x8C, 0x5F, 0x43, 0xF0, 0x86, 0x0E, 0x98, 0xCF, 0xE1, 0x77,
    0x20, 0x9E, 0x76, 0x07, 0xB6, 0x63, 0x29, 0xC1, 0x2B, 0xEF, 0xC0, 0x7A, 0xEB, 0x70, 0x27, 0xA9, 0x9F, 0x3B, 0x49, 0xFD, 0x10, 0x3C,
    0xF7, 0x4E, 0xEC, 0x27, 0x57, 0x08, 0xEE, 0x77, 0x17, 0xF2, 0x8D, 0xBA, 0x8B, 0xF0, 0xBD, 0x0B, 0xE9, 0x97, 0x13, 0xBC, 0x9A, 0xE0,
    0x9D, 0x3A, 0x92, 0xF2, 0x76, 0x24, 0xE5, 0x25, 0x78, 0x6E, 0x47, 0x5C, 0xEF, 0xEA, 0x08, 0xDE, 0xD8, 0x11, 0xEB, 0x7F, 0xC4, 0xDD,
    0x64, 0xFE, 0xBC, 0x1B, 0xC7, 0x45, 0x01, 0xC1, 0x4B, 0xEF, 0xC6, 0x7A, 0xF3, 0xBD, 0x87, 0xCC, 0xC3, 0xF7, 0x20, 0xDF, 0x28, 0x82,
    0xA7, 0x11, 0xBC, 0x9C, 0xE0, 0xD5, 0xF7, 0x60, 0xBF, 0xEA, 0x78, 0x2F, 0x99, 0x4F, 0xEE, 0xC5, 0xF8, 0x19, 0x04, 0xCF, 0xB9, 0x17,
    0xEB, 0xB3, 0x8E, 0xE0, 0x8D, 0xF7, 0x62, 0x3F, 0x19, 0xD7, 0x89, 0xF4, 0xFF, 0x4E, 0x58, 0x3F, 0x25, 0x04, 0xAF, 0xE8, 0x84, 0x7C,
    0x03, 0x3A, 0x23, 0xDE, 0xB5, 0x33, 0xC6, 0xB7, 0x10, 0x7C, 0x41, 0x67, 0xCC, 0x4F, 0x15, 0xC1, 0xEB, 0x3A, 0x63, 0x7F, 0xE8, 0x7E,
    0x1F, 0x19, 0xA7, 0xF7, 0x61, 0x3E, 0x73, 0x08, 0x5E, 0x70, 0x1F, 0xD2, 0x69, 0x20, 0x78, 0x87, 0x2E, 0x58, 0x9F, 0x51, 0x5D, 0x48,
    0xBD, 0x75, 0xC1, 0x79, 0xA6, 0x98, 0xE0, 0xB5, 0x5D, 0xB0, 0x5D, 0xBA, 0x76, 0x45, 0x7C, 0x60, 0x57, 0x9C, 0x0F, 0x2D, 0x04, 0x5F,
    0x00, 0x7F, 0xCB, 0xE7, 0x47, 0x25, 0x04, 0xAF, 0xE8, 0x4A, 0xEA, 0xA1, 0x1B, 0xE2, 0x43, 0xBB, 0x21, 0xDF, 0x4C, 0x82, 0xE7, 0xC2,
    0xDF, 0xF2, 0x39, 0x51, 0x03, 0xC1, 0x7B, 0xDF, 0x8F, 0xF1, 0x8D, 0xF7, 0x23, 0x9E, 0x49, 0xF0, 0x32, 0x82, 0x57, 0xC1, 0xDF, 0xB2,
    0xDC, 0xE8, 0xF7, 0x00, 0x59, 0x67, 0x1F, 0x40, 0x39, 0x2A, 0x87, 0xE0, 0x15, 0x0F, 0x60, 0x3D, 0xFB, 0x77, 0x27, 0xEB, 0x69, 0x77,
    0xCC, 0x7F, 0x0E, 0xC1, 0xCB, 0xBA, 0x63, 0x7C, 0xDF, 0x1E, 0x24, 0x9F, 0x3D, 0x70, 0xFE, 0x37, 0x12, 0x3C, 0xAF, 0x07, 0xD6, 0x67,
    0x0D, 0xC1, 0x1B, 0x08, 0x1E, 0xDC, 0x93, 0xCC, 0x93, 0x3D, 0x31, 0xFF, 0xB9, 0x04, 0x2F, 0xEC, 0x89, 0xF9, 0xAF, 0x27, 0xB8, 0xEE,
    0x41, 0x94, 0x07, 0x7A, 0x3F, 0x88, 0xF8, 0xB8, 0x07, 0x31, 0x9F, 0x79, 0x04, 0x2F, 0x7F, 0x10, 0xE5, 0x3D, 0xDF, 0x40, 0x32, 0xBE,
    0x02, 0x51, 0xEE, 0x1A, 0x4E, 0x70, 0x4B, 0x20, 0xE6, 0xA7, 0x90, 0xE0, 0xD5, 0x81, 0x48, 0xA7, 0x6D, 0x10, 0xC9, 0x7F, 0x10, 0x59,
    0xEF, 0x08, 0x5E, 0x12, 0x84, 0xFD, 0xA4, 0x8E, 0xE0, 0x8D, 0x41, 0x58, 0xAE, 0x81, 0x7A, 0x22, 0x57, 0xE8, 0xB1, 0x7D, 0xF3, 0x09,
    0x5E, 0xA9, 0xC7, 0x7A, 0xF6, 0xEB, 0x45, 0xE6, 0xC3, 0x5E, 0x58, 0x5E, 0x0B, 0xC1, 0xF3, 0x09, 0x5E, 0x47, 0xF0, 0xC6, 0x5E, 0x38,
    0x2E, 0x42, 0x7A, 0x93, 0x7A, 0xEB, 0x8D, 0xF4, 0x73, 0x08, 0x5E, 0xD2, 0x1B, 0xE7, 0x4F, 0xFF, 0x3E, 0xA4, 0x9F, 0xF4, 0xC1, 0x79,
    0x2F, 0x8F, 0xE0, 0x47, 0xFA, 0xE0, 0x78, 0x0C, 0xE8, 0x4B, 0xE6, 0x81, 0xBE, 0x58, 0x3F, 0x06, 0x82, 0x17, 0xF6, 0xC5, 0x7A, 0xAE,
    0x25, 0x78, 0xDB, 0x7E, 0xD8, 0xBE, 0xC3, 0xFB, 0x11, 0x79, 0xA6, 0x1F, 0x8E, 0xC7, 0x02, 0x82, 0x57, 0x12, 0xBC, 0x65, 0x30, 0xA9,
    0x9F, 0x60, 0x2C, 0x6F, 0x1A, 0xC1, 0x0B, 0x82, 0xB1, 0xFE, 0xEB, 0x08, 0xDE, 0x18, 0x8C, 0xF5, 0x10, 0xDC, 0x9F, 0xB4, 0x6F, 0x7F,
    0xB2, 0x8E, 0x13, 0xBC, 0xAC, 0x3F, 0xD6, 0x83, 0xFF, 0x00, 0x22, 0x47, 0x0D, 0xC0, 0x71, 0x94, 0x4B, 0xF0, 0xCA, 0x01, 0xD8, 0x7F,
    0xFC, 0x1F, 0x22, 0xF3, 0xDB, 0x43, 0x64, 0x7F, 0x41, 0xF0, 0xEC, 0x87, 0x30, 0x7E, 0x25, 0xC1, 0x6B, 0x1F, 0xC2, 0x7E, 0x15, 0x30,
    0x90, 0xD4, 0xF3, 0x40, 0xEC, 0x3F, 0x51, 0x04, 0x4F, 0x1B, 0x88, 0xFD, 0xBC, 0x90, 0xE0, 0x65, 0x24, 0x7E, 0x23, 0xC1, 0xFD, 0x1F,
    0xC6, 0xF8, 0x21, 0x0F, 0x93, 0x7E, 0xF2, 0x30, 0xC6, 0xCF, 0x21, 0x78, 0xD9, 0xC3, 0xD8, 0xEE, 0x7E, 0x83, 0x88, 0xDC, 0x3B, 0x08,
    0xE5, 0x73, 0x23, 0xC1, 0x33, 0x07, 0x61, 0x79, 0xCB, 0x08, 0x5E, 0x35, 0x08, 0xF9, 0xB6, 0x7C, 0x84, 0xCC, 0xE7, 0x8F, 0x60, 0xFB,
    0x8E, 0x26, 0x78, 0xDC, 0x23, 0x64, 0xBC, 0x10, 0xBC, 0xE4, 0x11, 0xEC, 0x57, 0x97, 0x08, 0xEE, 0x3B, 0x98, 0xEC, 0x23, 0x06, 0x93,
    0xFE, 0x4C, 0xF0, 0x0C, 0x82, 0xE7, 0x0C, 0xC6, 0x76, 0xAF, 0x21, 0x78, 0xDB, 0x47, 0xB1, 0x5F, 0x85, 0x3D, 0x4A, 0xD6, 0x05, 0x82,
    0x57, 0x12, 0xFC, 0xCA, 0xA3, 0x98, 0xFF, 0xC0, 0x21, 0xA4, 0x3E, 0x87, 0x60, 0x79, 0xB3, 0x08, 0x5E, 0x34, 0x04, 0xF3, 0x5F, 0x47,
    0x70, 0xFF, 0xC7, 0x70, 0x1C, 0x8D, 0x7E, 0x8C, 0xD4, 0xC3, 0x63, 0xB8, 0x0F, 0x3D, 0x42, 0xF0, 0xB3, 0xF0, 0x37, 0xD3, 0x01, 0xC7,
    0xB0, 0xB6, 0x09, 0x41, 0x3C, 0x14, 0xFE, 0x96, 0xF5, 0x2A, 0x65, 0x12, 0xCE, 0xFE, 0x57, 0x15, 0x82, 0xE3, 0x22, 0xE0, 0x71, 0xC4,
    0xBB, 0x3E, 0x8E, 0x78, 0x1C, 0xC1, 0xD3, 0x1F, 0xC7, 0xF6, 0xAD, 0x20, 0x78, 0x0D, 0xC1, 0x03, 0x9F, 0x40, 0x3C, 0xE4, 0x09, 0x94,
    0x2B, 0xD6, 0x10, 0xBC, 0x98, 0xE0, 0xFE, 0x4F, 0x92, 0xFD, 0xDA, 0x93, 0x58, 0x0F, 0xA1, 0x4F, 0x62, 0xFC, 0xCC, 0x27, 0x71, 0x7C,
    0x55, 0x10, 0xDC, 0x77, 0x28, 0xD6, 0xFF, 0xF0, 0xA1, 0xA4, 0xBF, 0x0D, 0x25, 0xFD, 0x8D, 0xE0, 0x55, 0xF0, 0xF7, 0xFD, 0x10, 0xDE,
    0xC7, 0x12, 0x0F, 0x23, 0xE3, 0x68, 0x18, 0xD2, 0x37, 0x12, 0x3C, 0x73, 0x18, 0xD2, 0xAF, 0x20, 0x78, 0x0D, 0x89, 0xDF, 0xF5, 0x29,
    0x22, 0x3F, 0x3C, 0x85, 0xF3, 0x43, 0x16, 0xFC, 0x2D, 0xDB, 0x6D, 0x56, 0x3C, 0x85, 0xE3, 0xDA, 0xEF, 0x69, 0x32, 0x5E, 0x9E, 0x26,
    0xE3, 0x85, 0xE0, 0x99, 0x4F, 0xA3, 0x3C, 0x59, 0x4D, 0xF0, 0xFA, 0xA7, 0x71, 0x9E, 0x0F, 0x1C, 0x8E, 0x78, 0xC8, 0x70, 0xC4, 0x17,
    0x10, 0x3C, 0x6F, 0x38, 0x59, 0x97, 0x09, 0xDE, 0x30, 0x1C, 0xCB, 0x35, 0xF0, 0x19, 0x32, 0x8F, 0x3D, 0x83, 0xFD, 0x3F, 0x8F, 0xE0,
    0x45, 0x04, 0x6F, 0x24, 0xB8, 0xFF, 0xB3, 0x28, 0xA7, 0x45, 0x3D, 0x4B, 0xE6, 0x9F, 0x67, 0xB1, 0x7F, 0x56, 0x13, 0xBC, 0xFE, 0x59,
    0x2C, 0xD7, 0xE0, 0xE7, 0x88, 0xDC, 0xF2, 0x1C, 0xE2, 0x05, 0x04, 0x2F, 0x7D, 0x0E, 0xCB, 0xA5, 0x1B, 0x41, 0xF6, 0x41, 0xF0, 0x37,
    0x9B, 0x0B, 0xD9, 0xD9, 0xCF, 0x60, 0x82, 0x47, 0x8D, 0xC0, 0x76, 0x29, 0x24, 0xF8, 0xD9, 0x11, 0x38, 0x6F, 0xB4, 0x7D, 0x9E, 0xD4,
    0xDB, 0xF3, 0x38, 0x4E, 0xD3, 0x09, 0x5E, 0xF0, 0x3C, 0xE6, 0xA7, 0x91, 0xE0, 0xFE, 0x23, 0xB1, 0xDE, 0xC6, 0x8D, 0x24, 0x72, 0xF2,
    0x48, 0x9C, 0x9F, 0xF3, 0x08, 0x5E, 0x3E, 0x12, 0xEB, 0xCD, 0x7F, 0x14, 0x99, 0xFF, 0x47, 0x91, 0x7D, 0x28, 0xC1, 0xD7, 0x8C, 0xC2,
    0xFC, 0xD7, 0x11, 0xBC, 0x91, 0xE0, 0x21, 0xA3, 0xC9, 0x7C, 0x32, 0x1A, 0xF1, 0x35, 0x04, 0x2F, 0x26, 0x78, 0x23, 0xC1, 0xFD, 0xC7,
    0x60, 0xB9, 0xA2, 0xC6, 0x90, 0xF6, 0x22, 0x78, 0x05, 0xC1, 0x6B, 0xE0, 0x6F, 0x36, 0x47, 0xB2, 0x31, 0xE3, 0x3F, 0x96, 0x8C, 0xD3,
    0xB1, 0x38, 0x8F, 0x8D, 0x23, 0x78, 0xE6, 0x58, 0x22, 0xAF, 0x12, 0xBC, 0x66, 0x2C, 0x8E, 0xEB, 0xB6, 0x2F, 0x90, 0xFA, 0x7F, 0x01,
    0xE5, 0xE1, 0x35, 0x04, 0x2F, 0x7E, 0x01, 0xF7, 0x77, 0x01, 0xE3, 0xC8, 0x38, 0x1D, 0x87, 0xF3, 0x58, 0x16, 0xC1, 0xD7, 0xC0, 0xDF,
    0xB2, 0xDE, 0xFB, 0x0A, 0xC1, 0x3B, 0xBE, 0x88, 0xF5, 0x6C, 0x78, 0x91, 0xC8, 0xE1, 0x2F, 0x62, 0x7E, 0x2A, 0x09, 0x5E, 0xFB, 0x22,
    0x59, 0x67, 0xC7, 0x93, 0x7C, 0x8E, 0xC7, 0xF2, 0xA6, 0x11, 0x3C, 0x8B, 0xE0, 0x65, 0x04, 0xAF, 0x1D, 0x8F, 0xF3, 0x4F, 0xC7, 0x09,
    0x64, 0xDD, 0x99, 0x80, 0x7C, 0x33, 0x09, 0x5E, 0x34, 0x81, 0xE8, 0xD3, 0x08, 0xDE, 0x21, 0x14, 0xFB, 0x7F, 0x58, 0x28, 0xE1, 0x1B,
    0x8A, 0x74, 0xCA, 0x09, 0x5E, 0x1D, 0x8A, 0xF5, 0x1F, 0xF0, 0x12, 0xE9, 0x6F, 0x2F, 0x11, 0x79, 0x83, 0xE0, 0x05, 0x2F, 0x21, 0x9D,
    0x1A, 0x82, 0xB7, 0x9C, 0x88, 0xEB, 0xE3, 0xC0, 0x89, 0x64, 0x7E, 0x98, 0x88, 0xFD, 0x21, 0x83, 0xE0, 0x05, 0x13, 0x71, 0xDE, 0xBB,
    0x42, 0xF0, 0xAE, 0x93, 0xC8, 0x7E, 0x70, 0x12, 0x59, 0x37, 0x27, 0x91, 0x75, 0x93, 0xE0, 0xB5, 0x93, 0xB0, 0x1F, 0x06, 0x87, 0x91,
    0x7A, 0x0B, 0xC3, 0x79, 0x66, 0x0D, 0xC1, 0xEB, 0xC2, 0x90, 0x4E, 0x60, 0x38, 0xA9, 0x9F, 0x70, 0xC4, 0xAB, 0x08, 0xDE, 0x18, 0x8E,
    0xF9, 0x19, 0x1A, 0x41, 0xE4, 0xFF, 0x08, 0x1C, 0x2F, 0xA5, 0x04, 0xAF, 0x8B, 0xC0, 0x72, 0x05, 0x47, 0x92, 0xFC, 0x44, 0x62, 0x7F,
    0xCB, 0x27, 0x78, 0x49, 0x24, 0xCE, 0xF3, 0x57, 0x08, 0xEE, 0x17, 0x85, 0xED, 0x1B, 0x12, 0x85, 0xEB, 0x97, 0x11, 0xFE, 0x96, 0xCF,
    0x6D, 0x6B, 0x08, 0xDE, 0x10, 0x85, 0xEB, 0xE3, 0x88, 0x68, 0x32, 0xBF, 0x45, 0xE3, 0xB8, 0x28, 0x27, 0xF8, 0xA5, 0x68, 0x6C, 0xF7,
    0xEE, 0x31, 0x64, 0x5E, 0x8D, 0xC1, 0x76, 0x5C, 0x40, 0xF0, 0xBC, 0x18, 0xB2, 0x2E, 0x10, 0xDC, 0x3F, 0x96, 0xC8, 0x1B, 0xB1, 0x44,
    0xCF, 0x16, 0x8B, 0xF2, 0x40, 0x59, 0x2C, 0x91, 0x1F, 0x62, 0x89, 0xFC, 0x16, 0x47, 0xFA, 0x6D, 0x1C, 0x39, 0xA7, 0x20, 0x78, 0x46,
    0x1C, 0xA1, 0x43, 0xF0, 0xAA, 0x38, 0x94, 0x27, 0x3B, 0xC6, 0x93, 0xFD, 0x66, 0x3C, 0xE6, 0x3F, 0x2E, 0x1E, 0xF9, 0x2E, 0x88, 0xC7,
    0x7E, 0x5B, 0x46, 0xE2, 0x57, 0x11, 0xDC, 0x6F, 0x32, 0xD1, 0xE7, 0x4C, 0xC6, 0xFA, 0x37, 0x4E, 0x26, 0x72, 0xC5, 0x64, 0x8C, 0x5F,
    0x4A, 0xE2, 0x57, 0x4E, 0xC6, 0x7C, 0xFA, 0x4F, 0x21, 0xE3, 0x68, 0x0A, 0x19, 0x47, 0x04, 0xCF, 0x9E, 0x82, 0xE5, 0xAD, 0x21, 0x78,
    0xC3, 0x14, 0x2C, 0xD7, 0x60, 0x03, 0x69, 0x17, 0x03, 0xF2, 0xCD, 0x22, 0xF8, 0x1A, 0x03, 0x8E, 0xF7, 0x5A, 0x82, 0x5F, 0x31, 0x60,
    0xFB, 0xF6, 0x4E, 0x20, 0x7A, 0x86, 0x04, 0xA4, 0x93, 0x41, 0xF0, 0x1C, 0x82, 0x57, 0x10, 0xBC, 0x86, 0xE0, 0x6D, 0x13, 0xC9, 0x39,
    0x4B, 0x22, 0xE6, 0x33, 0x8D, 0xE0, 0x59, 0x89, 0xD8, 0x1F, 0x2A, 0x09, 0x5E, 0x4B, 0xF0, 0xAE, 0x49, 0x44, 0xFE, 0x49, 0x42, 0x3C,
    0x83, 0xE0, 0x39, 0x49, 0x98, 0xFF, 0x4A, 0x82, 0xD7, 0x26, 0x61, 0x3D, 0x77, 0x32, 0x92, 0xF6, 0x32, 0x12, 0xFD, 0x30, 0xC1, 0x17,
    0x10, 0xBC, 0x9C, 0xE0, 0xD5, 0x04, 0x0F, 0x98, 0x4A, 0xE6, 0x9F, 0xA9, 0x64, 0x7F, 0x44, 0xF0, 0x34, 0x82, 0x17, 0x13, 0xFC, 0x08,
    0xC1, 0x7D, 0x4D, 0x44, 0xFE, 0x37, 0x61, 0xBD, 0x8D, 0x20, 0x78, 0x94, 0x09, 0xFB, 0xC3, 0x1A, 0x82, 0x17, 0x9B, 0xB0, 0x3F, 0xF8,
    0x9A, 0x09, 0x1D, 0x33, 0x96, 0x77, 0x1C, 0xC1, 0x0D, 0x04, 0x2F, 0x24, 0x78, 0x19, 0xC1, 0x75, 0x16, 0x22, 0xFF, 0x58, 0x10, 0x1F,
    0x4D, 0xF0, 0x38, 0x82, 0x17, 0x10, 0xBC, 0x94, 0xE0, 0x8D, 0x04, 0xF7, 0x4F, 0x26, 0xE3, 0x3D, 0x99, 0xD0, 0x21, 0x78, 0x21, 0xC1,
    0xCB, 0x92, 0xC9, 0xBE, 0x2F, 0x85, 0xAC, 0xB3, 0x29, 0x58, 0x3F, 0xE3, 0x08, 0x6E, 0x20, 0x78, 0x3E, 0xC1, 0x4B, 0x52, 0xB0, 0x7E,
    0x5A, 0xA6, 0x92, 0x79, 0x23, 0x15, 0xE7, 0xCF, 0x50, 0x82, 0x1B, 0x09, 0x5E, 0x44, 0xF0, 0xF2, 0x54, 0xAC, 0x7F, 0x5D, 0x1A, 0xA9,
    0x9F, 0x34, 0xCC, 0x67, 0x18, 0xC1, 0x2D, 0x04, 0x2F, 0x23, 0x78, 0x15, 0xC1, 0x3B, 0x4E, 0x23, 0xF3, 0xCF, 0x34, 0xE4, 0x6B, 0x21,
    0xF8, 0x82, 0x69, 0xB8, 0x5E, 0x54, 0x12, 0xBC, 0x76, 0x1A, 0xEA, 0x4F, 0x06, 0x4E, 0x27, 0xEB, 0xE6, 0x74, 0xA4, 0x9F, 0x47, 0xF0,
    0xA2, 0xE9, 0xD8, 0xDF, 0xEA, 0x09, 0x1E, 0x30, 0x03, 0xF9, 0x8E, 0x9E, 0x41, 0xDA, 0x65, 0x06, 0x96, 0x37, 0x9F, 0xE0, 0x25, 0x33,
    0x70, 0x5D, 0xF3, 0x4D, 0x27, 0xFD, 0x2D, 0x1D, 0xE5, 0x99, 0xA1, 0x04, 0x37, 0xA6, 0x93, 0x73, 0x22, 0x82, 0x1F, 0x49, 0xC7, 0xF6,
    0xD2, 0xCD, 0x24, 0xF9, 0x99, 0x89, 0x72, 0x9A, 0x91, 0xE0, 0x99, 0x33, 0xB1, 0x1D, 0xAB, 0x08, 0xDE, 0x38, 0x93, 0xE8, 0x9D, 0x66,
    0x11, 0x79, 0x75, 0x16, 0xAE, 0xEF, 0x85, 0x04, 0xBF, 0x34, 0x0B, 0xFB, 0x5B, 0xEF, 0xD9, 0x44, 0x0F, 0x33, 0x1B, 0xF7, 0x47, 0x45,
    0x04, 0x3F, 0x3B, 0x1B, 0xF3, 0xDF, 0x31, 0x83, 0xB4, 0x57, 0x06, 0xE2, 0x69, 0x04, 0xCF, 0x22, 0x78, 0x25, 0xC1, 0x1B, 0x33, 0x88,
    0xFE, 0xE7, 0x65, 0xB2, 0xBE, 0xBF, 0x8C, 0xF9, 0xC9, 0x26, 0x78, 0x19, 0xC1, 0x7D, 0xE7, 0x10, 0xBD, 0xD3, 0x1C, 0xCC, 0x67, 0x06,
    0xC1, 0xCB, 0xE7, 0x20, 0xDF, 0x96, 0x73, 0x49, 0x3F, 0x9F, 0x8B, 0x7C, 0xC7, 0x11, 0x3C, 0x73, 0x2E, 0x59, 0x8F, 0x08, 0x5E, 0x4B,
    0xF0, 0x0E, 0x99, 0x44, 0x2E, 0xCD, 0x44, 0x3C, 0x9D, 0xE0, 0xF9, 0x99, 0x38, 0xDE, 0x6B, 0x09, 0x1E, 0x30, 0x8F, 0xF4, 0xAB, 0x79,
    0x84, 0xEF, 0x3C, 0x22, 0xB7, 0x13, 0xBC, 0x7E, 0x1E, 0xE6, 0xB3, 0xEB, 0x7C, 0xD2, 0x9F, 0xE7, 0x93, 0x7D, 0x22, 0xC1, 0x8B, 0xE6,
    0xA3, 0xFE, 0xA1, 0xC3, 0x2B, 0xA4, 0x7E, 0x5E, 0xC1, 0xF8, 0xE9, 0x04, 0xCF, 0x26, 0xF8, 0x59, 0x82, 0x5F, 0x7A, 0x05, 0xE5, 0xFC,
    0xD1, 0x0B, 0x48, 0xFF, 0x5F, 0x80, 0xFD, 0xA7, 0x94, 0xE0, 0x95, 0x04, 0xEF, 0xB4, 0x90, 0xAC, 0x23, 0x0B, 0xB1, 0x7F, 0x2E, 0x20,
    0x78, 0xDE, 0x42, 0x1C, 0x8F, 0x75, 0x04, 0x6F, 0xFB, 0x2A, 0x8E, 0x5F, 0xE3, 0xAB, 0x64, 0x3E, 0x7F, 0x15, 0xFB, 0x73, 0x23, 0xC1,
    0xFD, 0x17, 0x21, 0x9D, 0xD0, 0x45, 0xA4, 0xBF, 0x2D, 0xC2, 0x72, 0x55, 0x13, 0xDC, 0x2F, 0x0B, 0xE5, 0x99, 0xC1, 0x59, 0x44, 0x1E,
    0xC8, 0xC2, 0xF9, 0x24, 0x8F, 0xE0, 0x45, 0x59, 0xE4, 0x5C, 0x9B, 0xE0, 0x7E, 0x8B, 0xB1, 0x7D, 0x87, 0x2F, 0x26, 0xE3, 0x65, 0x31,
    0x96, 0xB7, 0x88, 0xE0, 0xE5, 0x8B, 0xC9, 0x3E, 0x74, 0x09, 0xD9, 0xC7, 0x2D, 0xC1, 0xFC, 0x1B, 0x09, 0x9E, 0xB9, 0x04, 0xE5, 0xED,
    0x6A, 0x82, 0xD7, 0x2F, 0x41, 0xB9, 0x37, 0xE4, 0x35, 0x32, 0xAE, 0xE1, 0x6F, 0xD9, 0xBE, 0xAE, 0x8C, 0xE0, 0x55, 0xAF, 0x91, 0x79,
    0x35, 0x9B, 0x8C, 0xD3, 0x6C, 0xA4, 0xBF, 0x80, 0xE0, 0x79, 0x04, 0xBF, 0x44, 0x70, 0xDF, 0xD7, 0x89, 0x9E, 0xE7, 0x75, 0x52, 0x5E,
    0x82, 0x17, 0x10, 0xBC, 0xF4, 0x75, 0xAC, 0x4F, 0xDF, 0x37, 0x48, 0xFB, 0xBE, 0x41, 0xF4, 0x78, 0x04, 0xB7, 0x10, 0xBC, 0x94, 0xE0,
    0x95, 0x6F, 0xE0, 0xBC, 0xD7, 0x7D, 0x29, 0x91, 0x03, 0x97, 0x62, 0x3F, 0xC9, 0x25, 0x78, 0xE1, 0x52, 0xAC, 0xFF, 0x46, 0x82, 0xFB,
    0xE7, 0x60, 0xBD, 0xC5, 0xE5, 0x10, 0x7B, 0x98, 0x1C, 0xA2, 0x4F, 0x23, 0x78, 0x0D, 0xC1, 0x03, 0x97, 0x91, 0xF1, 0xBE, 0x0C, 0xCB,
    0x95, 0x45, 0xF0, 0x35, 0xCB, 0xB0, 0x7D, 0xEB, 0x09, 0xAE, 0x5B, 0x8E, 0xFB, 0x85, 0xB0, 0xE5, 0xA4, 0xBC, 0xCB, 0x91, 0x7E, 0x39,
    0xC1, 0xAB, 0x97, 0x63, 0xFE, 0xBB, 0xAE, 0x20, 0x72, 0xDD, 0x0A, 0xA2, 0xD7, 0x22, 0xF8, 0x9A, 0x15, 0xD8, 0x5E, 0x0D, 0x04, 0x6F,
    0x99, 0x8B, 0x78, 0x68, 0x2E, 0x59, 0x77, 0x08, 0x5E, 0x4E, 0xF0, 0xEA, 0x5C, 0xAC, 0x9F, 0xC0, 0x95, 0xA4, 0xBC, 0x2B, 0xB1, 0x9E,
    0xF3, 0x08, 0x5E, 0xB4, 0x92, 0xD8, 0xC3, 0xBC, 0x49, 0xDA, 0xF7, 0x4D, 0x72, 0x7E, 0x4A, 0xF0, 0xB4, 0x37, 0x91, 0x7E, 0x25, 0xC1,
    0x6B, 0xDF, 0xC4, 0xFC, 0x04, 0xBF, 0x45, 0xE6, 0xFF, 0xB7, 0xC8, 0x7E, 0x93, 0xE0, 0xC5, 0x6F, 0x21, 0x1D, 0xBF, 0x3C, 0x22, 0xFF,
    0xE4, 0x11, 0x3D, 0x1E, 0xC1, 0x33, 0xF3, 0x88, 0xFE, 0x90, 0xE0, 0x35, 0x79, 0x38, 0x7E, 0x3B, 0xAE, 0x22, 0xE3, 0x62, 0x15, 0xB6,
    0x63, 0x06, 0xC1, 0x0B, 0x56, 0xE1, 0xBC, 0x5D, 0x47, 0x70, 0xFF, 0xD5, 0xC4, 0xDE, 0x69, 0x35, 0xE1, 0xBB, 0x9A, 0xAC, 0xCB, 0x04,
    0x6F, 0x5C, 0x8D, 0xF9, 0x1C, 0xFE, 0x36, 0xA9, 0x9F, 0xB7, 0xC9, 0xF9, 0x38, 0xC1, 0x1B, 0xDE, 0xC6, 0xF8, 0x21, 0x6B, 0x48, 0xFC,
    0x35, 0x88, 0x1F, 0x21, 0xF8, 0xD9, 0x35, 0xC4, 0x7E, 0x60, 0x2D, 0x59, 0x2F, 0xD6, 0x62, 0x3B, 0x16, 0x10, 0xFC, 0xEC, 0x5A, 0xE4,
    0xDB, 0x75, 0x1D, 0x99, 0x4F, 0xD6, 0x91, 0xF3, 0x29, 0x82, 0x97, 0xAE, 0x23, 0xE7, 0xE6, 0xEF, 0x90, 0x76, 0x7F, 0x07, 0xFB, 0x83,
    0x81, 0xE0, 0x79, 0xEF, 0x90, 0x7D, 0x2E, 0xC1, 0x5B, 0xE6, 0xFB, 0xF0, 0x35, 0x2A, 0x82, 0xDF, 0xBF, 0x26, 0xF5, 0x96, 0x8F, 0xEB,
    0xF5, 0x11, 0x82, 0x37, 0xE4, 0x23, 0xFD, 0xA1, 0xEB, 0x89, 0x5E, 0x7D, 0x3D, 0xE6, 0x27, 0x9F, 0xE0, 0x25, 0xEB, 0x31, 0xFF, 0x0D,
    0x04, 0xEF, 0xB0, 0x01, 0xF3, 0x13, 0xB6, 0x81, 0xC8, 0x93, 0x1B, 0x88, 0x3E, 0x84, 0xE0, 0x8D, 0x24, 0xFE, 0xE0, 0x8D, 0x64, 0x1D,
    0xDC, 0x88, 0xF5, 0x56, 0x4C, 0xF0, 0x23, 0x1B, 0xC9, 0x79, 0x5C, 0x01, 0xD9, 0x07, 0x15, 0x10, 0xFD, 0x36, 0xC1, 0xF3, 0x0A, 0xC8,
    0x3A, 0x48, 0xF0, 0x0E, 0xEF, 0x12, 0xF9, 0xE4, 0x5D, 0x32, 0x5F, 0x11, 0xBC, 0x84, 0xE0, 0x35, 0xEF, 0x62, 0x7F, 0x0B, 0xDC, 0x44,
    0xF2, 0xB9, 0x89, 0xD8, 0x19, 0x12, 0xFC, 0x2C, 0xC1, 0x3B, 0x6D, 0x26, 0xEB, 0xF5, 0x66, 0xC4, 0x33, 0x08, 0x5E, 0x48, 0xF0, 0x06,
    0x82, 0x77, 0x2C, 0xC4, 0xFC, 0x1B, 0x0A, 0xC9, 0x78, 0x29, 0xC4, 0xFE, 0xA6, 0xDB, 0x42, 0xE8, 0x6F, 0xC1, 0x71, 0x97, 0x46, 0xF0,
    0xA2, 0x2D, 0xA8, 0x6F, 0xF1, 0xDB, 0x4A, 0xC6, 0xE3, 0x56, 0x22, 0x4F, 0x12, 0xBC, 0x70, 0x2B, 0xB1, 0x5B, 0x23, 0x78, 0xC7, 0x6D,
    0x88, 0x47, 0x6D, 0x23, 0xE3, 0x65, 0x1B, 0xE6, 0xBF, 0x8C, 0xE0, 0xF5, 0x24, 0x7E, 0x60, 0x11, 0x59, 0xD7, 0x8A, 0xC8, 0xF9, 0x32,
    0xC1, 0x4B, 0x8A, 0x88, 0xDD, 0x23, 0xC1, 0x03, 0xB7, 0x13, 0x3B, 0x99, 0xED, 0x44, 0xCF, 0xB9, 0x1D, 0xCB, 0x5B, 0x4D, 0x70, 0xDD,
    0x0E, 0xA4, 0x13, 0xB2, 0x83, 0x8C, 0xBB, 0x1D, 0x44, 0x3E, 0x27, 0x78, 0xF5, 0x0E, 0xCC, 0x4F, 0x87, 0x9D, 0x84, 0xEF, 0x4E, 0xEC,
    0x0F, 0x06, 0x82, 0x67, 0xEC, 0x44, 0xFA, 0xE5, 0x04, 0xAF, 0xDE, 0x49, 0xF6, 0xE9, 0xC5, 0x64, 0x7D, 0x29, 0x46, 0xBE, 0xD9, 0x04,
    0xCF, 0x2F, 0xC6, 0x7A, 0xAB, 0x27, 0x78, 0xDB, 0x5D, 0xD8, 0xFF, 0xA3, 0x76, 0x91, 0x7A, 0xDE, 0x85, 0xE5, 0x2D, 0x21, 0x78, 0xC5,
    0x2E, 0x9C, 0xAF, 0x3A, 0xBC, 0x47, 0xF2, 0xFF, 0x1E, 0xC6, 0x37, 0x12, 0x3C, 0xEF, 0x3D, 0x32, 0x6F, 0x10, 0xBC, 0xE1, 0x3D, 0x2C,
    0x6F, 0xE0, 0x6E, 0x52, 0x6F, 0xBB, 0x89, 0x1E, 0x9E, 0xE0, 0x35, 0xBB, 0xC9, 0xB8, 0x28, 0x21, 0xF3, 0x46, 0x09, 0xE6, 0xA7, 0x90,
    0xE0, 0xBA, 0x3D, 0x38, 0x9F, 0x0F, 0xDE, 0x43, 0xF6, 0xD1, 0x04, 0x2F, 0x24, 0x78, 0x35, 0xC1, 0xDB, 0xEE, 0x25, 0xEB, 0xE6, 0x5E,
    0xC4, 0x33, 0x09, 0x9E, 0x4B, 0xF0, 0x6A, 0x82, 0xD7, 0x13, 0xBC, 0xFB, 0x3E, 0x22, 0xE7, 0xEC, 0x43, 0x3C, 0x83, 0xE0, 0x39, 0x04,
    0xAF, 0x22, 0x78, 0x1D, 0xC1, 0xBB, 0x96, 0x92, 0xF6, 0x2D, 0xC5, 0xFE, 0x90, 0x41, 0xF0, 0x9C, 0x52, 0x1C, 0xBF, 0x35, 0x04, 0x6F,
    0x20, 0xF8, 0xE0, 0xF7, 0x89, 0x9C, 0xFC, 0x3E, 0xD2, 0xC9, 0x25, 0x78, 0xF9, 0xFB, 0x58, 0xCF, 0x01, 0x1F, 0x90, 0xFC, 0x7F, 0x80,
    0xED, 0x98, 0x49, 0xF0, 0xE2, 0x0F, 0x50, 0x1F, 0x58, 0x4F, 0xF0, 0x80, 0xFD, 0x44, 0xAF, 0xB2, 0x9F, 0xCC, 0x7B, 0xFB, 0x91, 0x6F,
    0x19, 0xC1, 0xEB, 0xF7, 0x93, 0x7A, 0x2B, 0x23, 0x7C, 0xCB, 0x48, 0xBD, 0x11, 0x3C, 0xA7, 0x8C, 0xD8, 0x69, 0x13, 0x5C, 0x77, 0x80,
    0xB4, 0xFB, 0x01, 0xD2, 0xEE, 0x07, 0x88, 0x5E, 0x88, 0xE0, 0x65, 0x04, 0xD7, 0x1D, 0x24, 0xF9, 0x3F, 0x88, 0xE5, 0x1D, 0x47, 0x70,
    0xC3, 0x41, 0x62, 0xC7, 0x48, 0xF0, 0xAA, 0x83, 0xC4, 0x3E, 0xF3, 0x10, 0xC9, 0xFF, 0x21, 0xAC, 0x9F, 0x34, 0x82, 0x67, 0x11, 0xBC,
    0x9C, 0xE0, 0xD5, 0x87, 0xB0, 0x7E, 0x3A, 0x94, 0x93, 0x7E, 0x58, 0x4E, 0xCE, 0xD7, 0x08, 0x9E, 0x5F, 0x8E, 0x7C, 0x6B, 0x08, 0xEE,
    0x77, 0x18, 0xEB, 0x67, 0xF4, 0x61, 0xB2, 0x8E, 0x1C, 0xC6, 0x7D, 0x53, 0x1E, 0xC1, 0xAB, 0x0F, 0xE3, 0x78, 0x0C, 0xF8, 0x90, 0xE4,
    0xFF, 0x43, 0x3C, 0xA7, 0x30, 0x12, 0x3C, 0xF3, 0x43, 0x72, 0x8E, 0x4C, 0xF0, 0x96, 0x1F, 0x61, 0x7D, 0x0E, 0xFD, 0x88, 0xC8, 0xC9,
    0x04, 0x2F, 0x26, 0x78, 0xCD, 0x47, 0x44, 0x3E, 0x3F, 0x42, 0xCA, 0x7B, 0x84, 0x8C, 0x3B, 0x82, 0x17, 0x1C, 0x41, 0x3D, 0x4C, 0x35,
    0xC1, 0x75, 0x47, 0x89, 0x5D, 0xD3, 0x51, 0xA2, 0xD7, 0x3D, 0x8A, 0x7A, 0xF5, 0x74, 0x82, 0x67, 0x13, 0xBC, 0x9C, 0xE0, 0xD5, 0x47,
    0x49, 0xFD, 0x1F, 0x23, 0x74, 0x8E, 0x61, 0x79, 0xB3, 0x09, 0x5E, 0x46, 0xF0, 0x96, 0xC7, 0xC9, 0xBA, 0x7F, 0x9C, 0xD8, 0xD1, 0x11,
    0x3C, 0xED, 0x38, 0x91, 0x0F, 0x09, 0x7E, 0xE5, 0x38, 0x96, 0x37, 0xB8, 0x82, 0xC8, 0xCF, 0x15, 0x88, 0x67, 0x11, 0x7C, 0x4D, 0x05,
    0xAE, 0xCB, 0x57, 0x08, 0x1E, 0x72, 0x82, 0x9C, 0x5F, 0x9F, 0x20, 0xE3, 0xF4, 0x04, 0xF6, 0x93, 0x4B, 0x04, 0x6F, 0x7B, 0x92, 0xE8,
    0x63, 0x4F, 0x12, 0x7D, 0xEC, 0x49, 0xE4, 0x9B, 0x4F, 0xF0, 0xEA, 0x93, 0xA4, 0x9F, 0x9C, 0x22, 0x72, 0xD1, 0x29, 0xAC, 0xFF, 0x50,
    0x82, 0x67, 0x9C, 0xC2, 0xF2, 0x56, 0x10, 0xFC, 0xCA, 0x29, 0xA2, 0x87, 0xAF, 0x24, 0xF3, 0x79, 0x25, 0xF2, 0xCD, 0x23, 0x78, 0x51,
    0x25, 0xB1, 0xEB, 0x20, 0xB8, 0xFF, 0x69, 0x22, 0xB7, 0x9F, 0x26, 0xF3, 0xF3, 0x69, 0x6C, 0xDF, 0x0A, 0x82, 0xD7, 0x9C, 0xC6, 0x71,
    0xDD, 0xE9, 0x0C, 0x91, 0x67, 0xCE, 0x20, 0x9E, 0x4E, 0xF0, 0xEC, 0x33, 0xE4, 0x3C, 0x82, 0xE0, 0x0D, 0x67, 0xC8, 0xB9, 0xFF, 0xC7,
    0x44, 0x3E, 0xFF, 0x98, 0xD8, 0x2F, 0x49, 0x78, 0xB8, 0xCE, 0xA8, 0x8B, 0xD7, 0xF5, 0xD0, 0x25, 0xE8, 0xCC, 0xF0, 0xDF, 0x24, 0x5D,
    0xA2, 0x2E, 0x5A, 0x17, 0x09, 0xA1, 0x09, 0xC2, 0x64, 0xFE, 0x6B, 0x0F, 0xF8, 0x67, 0x82, 0x38, 0x89, 0x3A, 0x0B, 0xFC, 0xCD, 0xF0,
    0x44, 0x5D, 0x14, 0xFC, 0xD7, 0x04, 0x5F, 0x06, 0x5D, 0x10, 0xFC, 0x97, 0xFD, 0x0B, 0xD4, 0x59, 0xFF, 0xAF, 0x76, 0x82, 0x18, 0x07,
    0x98, 0x96, 0xA6, 0x14, 0x5C, 0xE3, 0x80, 0x8F, 0x19, 0x7E, 0xE9, 0x09, 0xA8, 0x01, 0xFE, 0x6F, 0x9D, 0x97, 0x54, 0x9E, 0xAE, 0x07,
    0x47, 0x8D, 0x80, 0x25, 0xF1, 0xB4, 0x06, 0x8E, 0x44, 0xE9, 0x52, 0x38, 0x1D, 0x0B, 0xC4, 0x31, 0xF3, 0x78, 0xB1, 0xF0, 0xDF, 0x28,
    0x85, 0x1C, 0x59, 0x42, 0xC5, 0xFD, 0xD1, 0x29, 0x3C, 0x5D, 0x22, 0xA7, 0xD4, 0x53, 0xA2, 0x2D, 0x97, 0xD7, 0xD5, 0x7C, 0xC4, 0xF3,
    0xBF, 0x12, 0x79, 0x2E, 0x2C, 0xBA, 0x69, 0x4D, 0xDC, 0xF5, 0x0E, 0xEA, 0x43, 0xE6, 0xAF, 0x95, 0xB6, 0x01, 0x7E, 0x89, 0xE1, 0x6D,
    0x31, 0x0D, 0xFE, 0x19, 0xE0, 0x2F, 0x23, 0xFC, 0xCA, 0xD0, 0x48, 0xC2, 0xC9, 0xBE, 0x9C, 0xA1, 0x2F, 0xC1, 0xB8, 0xE1, 0x77, 0x41,
    0x13, 0x78, 0xBA, 0x78, 0x29, 0x87, 0xAE, 0x96, 0xCD, 0x04, 0xAD, 0x2F, 0x4A, 0x96, 0x00, 0x48, 0x0F, 0xA9, 0x0D, 0x45, 0xDD, 0x85,
    0x4B, 0x39, 0x94, 0x73, 0x10, 0x04, 0xFF, 0xF7, 0xA4, 0xAC, 0xB6, 0xBC, 0x90, 0x72, 0x3F, 0x8F, 0xE8, 0xB2, 0xBE, 0x15, 0xCE, 0x73,
    0x4D, 0x69, 0xEA, 0xBD, 0x4C, 0x53, 0xEF, 0xB4, 0xAF, 0x69, 0xA5, 0xC9, 0x4A, 0x6F, 0x80, 0xEF, 0x48, 0xE8, 0x9D, 0x4A, 0x63, 0x4A,
    0x8D, 0x6E, 0x32, 0x50, 0x8C, 0xE7, 0x74, 0x44, 0x7F, 0x66, 0xB9, 0x35, 0xF2, 0xDC, 0xC6, 0x4B, 0x6D, 0x16, 0xC9, 0x47, 0x78, 0x0C,
    0x7C, 0xC7, 0x2A, 0x70, 0x5A, 0x33, 0x49, 0xAC, 0xE5, 0x82, 0x72, 0x14, 0xA4, 0x49, 0x05, 0x4A, 0x3D, 0x79, 0xEB, 0x44, 0x71, 0x5A,
    0x3D, 0x79, 0xDE, 0x53, 0x78, 0x6F, 0x8C, 0xE6, 0xBF, 0x89, 0xDE, 0xE5, 0x2C, 0x6F, 0x11, 0x80, 0x9B, 0x79, 0x8E, 0x22, 0x80, 0x5A,
    0x12, 0xE4, 0x48, 0x5B, 0x4E, 0x60, 0x0E, 0x09, 0x13, 0xFD, 0x59, 0x8C, 0x79, 0x41, 0xBD, 0x17, 0xE4, 0x4E, 0xB9, 0x3F, 0x23, 0xBF,
    0x64, 0x5E, 0x7A, 0x83, 0x46, 0x1E, 0x8E, 0x68, 0xB1, 0x9C, 0x26, 0xF0, 0xD1, 0x67, 0xE6, 0xE3, 0x3C, 0x9E, 0xE7, 0x5C, 0xCC, 0x84,
    0xAC, 0x36, 0x4C, 0x7C, 0x94, 0x22, 0xEE, 0x9C, 0xCF, 0x15, 0x89, 0x4F, 0x14, 0xD0, 0x4E, 0x20, 0xE9, 0x95, 0xCB, 0xE2, 0x8C, 0x3F,
    0x6D, 0x9D, 0x04, 0x48, 0xCB, 0xC6, 0x65, 0xAC, 0xEA, 0xBC, 0x9C, 0x1E, 0x0E, 0xEB, 0x12, 0x84, 0xC9, 0x52, 0x2E, 0xD4, 0x79, 0x27,
    0xF2, 0x1E, 0x1F, 0xCF, 0xE7, 0x4C, 0x13, 0xFF, 0x35, 0xD2, 0x66, 0x6E, 0xB1, 0x9E, 0x0B, 0xAC, 0xFF, 0x57, 0x1F, 0x2E, 0xCA, 0x1C,
    0xE9, 0xD2, 0x7C, 0xE4, 0x1A, 0x5F, 0x47, 0xF3, 0xAD, 0xCC, 0xD7, 0x1B, 0xF4, 0x7B, 0x5D, 0x65, 0xFA, 0xBD, 0xAF, 0x32, 0xFD, 0x3E,
    0xBC, 0x0C, 0xDE, 0xA1, 0x2F, 0xC6, 0x7F, 0xAC, 0xD3, 0xF6, 0xD7, 0x7B, 0x89, 0x8F, 0x99, 0x7F, 0x89, 0x19, 0x46, 0xAC, 0xEF, 0xDA,
    0x7A, 0xDC, 0xD5, 0xE5, 0xA7, 0xB7, 0x2B, 0xA1, 0x3A, 0x3F, 0x31, 0x13, 0x8B, 0xDF, 0xA7, 0xC2, 0xB8, 0x63, 0x7C, 0xA6, 0x29, 0x8E,
    0x99, 0x8E, 0xD1, 0x3A, 0xDD, 0xCD, 0x3A, 0x1D, 0xE7, 0x2C, 0x46, 0x89, 0xDA, 0xFC, 0xAA, 0xCC, 0x47, 0xEF, 0x64, 0x2E, 0x58, 0x10,
    0x2D, 0xDE, 0x5C, 0xA1, 0x32, 0x91, 0x3C, 0x73, 0xAA, 0x8F, 0x4F, 0xE4, 0x67, 0x6C, 0x9A, 0xA3, 0xC2, 0x15, 0xDB, 0x46, 0xE6, 0xA7,
    0x8D, 0x26, 0x43, 0xE3, 0x6D, 0xE8, 0xD9, 0xC8, 0x3A, 0x31, 0xA2, 0xEE, 0xE9, 0xDF, 0x8E, 0xCA, 0xA4, 0xBE, 0x5E, 0x50, 0xDE, 0x16,
    0x5E, 0x16, 0xB3, 0x06, 0xBE, 0x6A, 0xB4, 0x58, 0x5D, 0xB2, 0x35, 0x3D, 0x16, 0xBE, 0x93, 0xF8, 0x2A, 0x1F, 0xC5, 0xFB, 0x9E, 0x59,
    0x65, 0x9D, 0xD7, 0x5A, 0x4F, 0x11, 0xBC, 0xB7, 0x1A, 0x38, 0x4D, 0x11, 0x13, 0x69, 0xF6, 0xB5, 0x95, 0x1D, 0x62, 0x61, 0xDF, 0xCD,
    0x75, 0xE1, 0xF1, 0x9A, 0xEB, 0x82, 0xC5, 0x35, 0x42, 0xBC, 0x04, 0x07, 0xF4, 0xFB, 0xD8, 0xD0, 0xAF, 0x8A, 0x15, 0xF6, 0xD6, 0x16,
    0x89, 0x8E, 0x48, 0xE1, 0x4C, 0xC2, 0xD6, 0xB9, 0xCD, 0xDB, 0xD1, 0x5C, 0x2F, 0xF3, 0xD6, 0x46, 0xD3, 0xE2, 0xB4, 0xCE, 0xFA, 0xB9,
    0x49, 0x37, 0x92, 0x4B, 0x57, 0x62, 0x77, 0x13, 0xAE, 0xB2, 0xFE, 0x6A, 0xED, 0x3B, 0x62, 0x44, 0x51, 0x4A, 0xD6, 0x33, 0x78, 0x48,
    0xBC, 0x4E, 0x77, 0x2B, 0x5F, 0x57, 0x59, 0x3C, 0xDB, 0x51, 0xEB, 0x0A, 0x7D, 0xBD, 0xC3, 0xB1, 0x9A, 0x1F, 0x2F, 0xE6, 0x20, 0x11,
    0xCF, 0x40, 0x46, 0x90, 0x76, 0xDA, 0x09, 0x7C, 0x87, 0x64, 0xE0, 0x7B, 0xC0, 0x24, 0x5D, 0x1A, 0xCC, 0x46, 0x4C, 0x7A, 0x4E, 0x86,
    0xDC, 0x3A, 0xAF, 0x21, 0xB9, 0x5C, 0x5A, 0x79, 0x88, 0xFD, 0x65, 0x8A, 0x03, 0x39, 0x3F, 0xE8, 0x2A, 0xD0, 0xD5, 0x5F, 0xA5, 0xFC,
    0xF6, 0xF2, 0x30, 0xBF, 0x09, 0x8A, 0x6B, 0xB0, 0xD6, 0xF9, 0x44, 0xA6, 0x15, 0xCE, 0x7B, 0xB2, 0x41, 0x5A, 0x23, 0xD9, 0x7C, 0xC8,
    0x7A, 0x75, 0x2C, 0xE4, 0xDA, 0x79, 0xBB, 0xB9, 0xC2, 0x23, 0x11, 0x7E, 0x4B, 0xE2, 0x23, 0xA6, 0x07, 0xE7, 0x65, 0x96, 0xC6, 0xA1,
    0xDE, 0x0B, 0x63, 0x86, 0xD2, 0x56, 0xDA, 0xB3, 0x06, 0x7A, 0x50, 0x47, 0x94, 0x87, 0xB7, 0xEB, 0xC3, 0x99, 0x9C, 0xE1, 0x3E, 0x3D,
    0xBD, 0x97, 0xF3, 0xA7, 0x77, 0x38, 0x0E, 0xDC, 0xA7, 0xD7, 0xCB, 0xCB, 0xF9, 0xEB, 0xE5, 0x61, 0xFE, 0x4C, 0x8A, 0x32, 0x87, 0x2C,
    0x9B, 0x69, 0xA7, 0xE3, 0x59, 0xFD, 0x47, 0x49, 0x33, 0x85, 0x23, 0xED, 0x88, 0xBB, 0xE3, 0x9C, 0xED, 0xDD, 0x23, 0x60, 0x1E, 0x8E,
    0x55, 0xA0, 0xE6, 0x0E, 0xAD, 0x04, 0x49, 0x66, 0x8B, 0x82, 0xEF, 0x04, 0xAE, 0x39, 0x74, 0x3E, 0xDE, 0x7C, 0x8D, 0x62, 0x7E, 0x8B,
    0x82, 0xD4, 0xB1, 0x6E, 0xC8, 0x07, 0x42, 0x77, 0x12, 0x0E, 0x6B, 0x8A, 0x81, 0xCF, 0x4F, 0x51, 0x5E, 0x90, 0x3B, 0xD9, 0x0A, 0x1E,
    0xC9, 0xA9, 0xA6, 0x28, 0xAE, 0x25, 0xDA, 0xE9, 0x99, 0xF8, 0xCA, 0x67, 0xD2, 0xC5, 0x59, 0xCD, 0xA9, 0xB1, 0x0A, 0xEB, 0xBA, 0x56,
    0xDA, 0x4C, 0x37, 0x18, 0xCE, 0x57, 0x53, 0x13, 0xD7, 0xC0, 0x58, 0xF8, 0xAE, 0xCC, 0x9E, 0xBA, 0xED, 0xDE, 0x22, 0x7D, 0xAA, 0x4E,
    0x17, 0x00, 0xA1, 0x19, 0xF2, 0xA4, 0x4D, 0xEF, 0xE9, 0x8C, 0x27, 0x5B, 0x17, 0x62, 0xE1, 0xFF, 0x06, 0xCE, 0xDF, 0x1B, 0x73, 0x2B,
    0xD3, 0x06, 0x45, 0x34, 0xED, 0xCA, 0x3C, 0xEF, 0xE7, 0xB6, 0xF4, 0xF4, 0x4E, 0xEA, 0xC4, 0x15, 0x7A, 0xF6, 0xAB, 0x96, 0x67, 0x7B,
    0x04, 0xC7, 0x34, 0xF5, 0x5E, 0xA2, 0x19, 0xC3, 0xFB, 0x5F, 0x82, 0x24, 0x85, 0x7B, 0xAB, 0x8D, 0x0C, 0x8A, 0xA3, 0xC3, 0x7D, 0x5A,
    0x7A, 0xAE, 0x0B, 0xF1, 0x9C, 0x96, 0x5C, 0x7B, 0x9E, 0xD0, 0x62, 0xFA, 0xF3, 0x54, 0x2E, 0xF7, 0x44, 0x7B, 0x45, 0x9E, 0x8F, 0xE5,
    0xA7, 0x29, 0x26, 0xC5, 0x33, 0x0A, 0xAD, 0xF9, 0xC3, 0xD9, 0x24, 0xDA, 0x2B, 0x6D, 0x1A, 0xC7, 0xC7, 0xB5, 0xF1, 0xAA, 0xD0, 0xD2,
    0x7B, 0x89, 0x96, 0xDE, 0x6B, 0xF9, 0x4A, 0x82, 0x39, 0x41, 0x96, 0x17, 0x2C, 0x5E, 0x91, 0xE1, 0x50, 0xCE, 0x94, 0xB5, 0xF8, 0xD1,
    0x5E, 0x59, 0x8F, 0x94, 0xE9, 0xEA, 0x3D, 0xC8, 0x6F, 0x92, 0xE2, 0xF8, 0x55, 0xD2, 0xAB, 0x68, 0xA1, 0x6D, 0x72, 0xB0, 0x0E, 0xB9,
    0x3B, 0x87, 0x4F, 0xE6, 0xED, 0xE5, 0x79, 0x1B, 0x21, 0x1D, 0xC7, 0xAB, 0x80, 0xD6, 0x71, 0x6C, 0xAB, 0x57, 0xEA, 0xC1, 0xFB, 0x51,
    0x2C, 0xD7, 0xF4, 0x4C, 0xD3, 0xB4, 0x32, 0x78, 0x8F, 0x97, 0x33, 0x6D, 0x8F, 0xFB, 0xF4, 0x9D, 0xEF, 0xA6, 0xF5, 0x5E, 0x2B, 0x83,
    0xD6, 0x9D, 0xB5, 0x76, 0x1E, 0x06, 0x69, 0x7F, 0x1A, 0xDD, 0x34, 0x62, 0xD4, 0xCF, 0x41, 0xB4, 0xF6, 0x1B, 0x03, 0x97, 0x21, 0x4C,
    0x9C, 0x03, 0xCA, 0x9A, 0xB6, 0xD4, 0x83, 0xAE, 0x12, 0x6D, 0xBD, 0xDB, 0xF2, 0xA1, 0x32, 0x6D, 0xCF, 0xF6, 0x24, 0x4A, 0xB4, 0x9D,
    0xF7, 0x20, 0x77, 0x79, 0x25, 0x49, 0xFA, 0xB5, 0x78, 0xDD, 0x74, 0xE9, 0x2C, 0x33, 0x49, 0x3A, 0xEF, 0xF4, 0x96, 0x0C, 0xE6, 0x9C,
    0x87, 0x37, 0xFA, 0x8F, 0x32, 0x6D, 0x4F, 0x64, 0x1E, 0x25, 0xDA, 0xFA, 0xAB, 0x96, 0x6F, 0xEF, 0xAF, 0x9F, 0xAE, 0xF3, 0xD2, 0xFF,
    0x1F, 0xF2, 0xEA, 0x75, 0x15, 0x78, 0x69, 0x1D, 0x25, 0xEE, 0xF0, 0x32, 0xF1, 0xF9, 0x2F, 0x9E, 0xEF, 0x09, 0x4D, 0x8A, 0xB6, 0x22,
    0x5A, 0x69, 0x27, 0xF0, 0x91, 0x6E, 0xE6, 0x72, 0xA7, 0xC1, 0x0B, 0xBA, 0x5B, 0xA6, 0xC7, 0x48, 0xE0, 0x5F, 0xD6, 0xB9, 0xEB, 0xEF,
    0x66, 0xD9, 0x13, 0x78, 0x69, 0x23, 0xBD, 0x52, 0x8F, 0x09, 0x20, 0xA7, 0x1B, 0x78, 0x4B, 0x19, 0x25, 0xAB, 0x1B, 0xB6, 0x83, 0x4A,
    0x91, 0x6C, 0x7D, 0x4C, 0xD2, 0x49, 0x8E, 0x45, 0xDD, 0xFE, 0x29, 0x43, 0xA7, 0x6B, 0x0D, 0x61, 0x02, 0xA7, 0xA0, 0x5D, 0xAF, 0xC1,
    0x34, 0x95, 0xC2, 0xCE, 0xC2, 0xC8, 0xF3, 0xE0, 0x6C, 0xB7, 0x19, 0xE4, 0xE6, 0x5A, 0xE9, 0x88, 0xBE, 0xA7, 0xFD, 0xC3, 0x39, 0x4D,
    0xF7, 0xF5, 0x98, 0x32, 0x4D, 0x61, 0xC1, 0x12, 0xA9, 0x71, 0xD7, 0xED, 0x7A, 0x3D, 0x50, 0xFA, 0x9E, 0xD7, 0x43, 0x12, 0xDF, 0x37,
    0xBA, 0xB2, 0x92, 0x68, 0xA5, 0x2D, 0xCE, 0x56, 0xE3, 0xBC, 0xD2, 0xC7, 0xD9, 0x79, 0x5C, 0xAA, 0x57, 0xF2, 0xC4, 0x46, 0x41, 0x0C,
    0x47, 0x92, 0x9B, 0xF6, 0x2A, 0x66, 0x2F, 0xE5, 0x51, 0x99, 0xB6, 0xDE, 0x23, 0xDA, 0x74, 0xF6, 0x15, 0x23, 0x5C, 0x8B, 0x5E, 0x43,
    0x6B, 0xDF, 0x12, 0x14, 0x85, 0x65, 0x94, 0x99, 0x6B, 0x15, 0x53, 0xB8, 0x46, 0x81, 0xF5, 0x84, 0x84, 0x26, 0x8B, 0x02, 0xEF, 0xC9,
    0x2F, 0xDA, 0xF8, 0x79, 0xAE, 0xAF, 0x71, 0x85, 0x8F, 0xA7, 0xED, 0x83, 0x7C, 0xCC, 0xDC, 0xBE, 0x2A, 0x99, 0xB7, 0x99, 0x45, 0xD9,
    0xF6, 0xD1, 0x83, 0x7D, 0xAB, 0x2D, 0x4F, 0x71, 0x82, 0x6D, 0xE6, 0x36, 0xAA, 0x16, 0xAF, 0x8C, 0x15, 0x4A, 0x9F, 0x8D, 0x64, 0x13,
    0xD7, 0x48, 0x44, 0xD9, 0x8C, 0x97, 0x60, 0x2F, 0xEE, 0xC5, 0x6D, 0x79, 0x26, 0x49, 0x36, 0xA4, 0x4C, 0x6F, 0x3B, 0xED, 0x2A, 0x94,
    0xC9, 0x31, 0x7D, 0xFD, 0x55, 0xA3, 0xAF, 0x24, 0x89, 0x7A, 0x67, 0xEC, 0xDA, 0xF3, 0xF4, 0xF6, 0xFE, 0xC6, 0xF9, 0xEC, 0xE3, 0x2E,
    0x3D, 0x73, 0x53, 0x1C, 0x2D, 0xEB, 0xA5, 0x3B, 0x74, 0xBD, 0x99, 0x47, 0xED, 0xBB, 0x09, 0x77, 0xE8, 0xAB, 0xD7, 0x80, 0x2B, 0x34,
    0x13, 0x9A, 0x6C, 0x93, 0x9C, 0xD3, 0xD3, 0x6A, 0x33, 0x62, 0x4D, 0x2F, 0x91, 0xCF, 0x32, 0xCC, 0xE2, 0x5B, 0xC9, 0x32, 0xCC, 0x55,
    0xDA, 0xF1, 0xDC, 0xC2, 0x56, 0x59, 0xD7, 0x97, 0xB5, 0x08, 0xCB, 0xCF, 0xD2, 0x31, 0x5B, 0x6C, 0x59, 0xE6, 0xD5, 0x7A, 0x2E, 0x24,
    0xF3, 0x63, 0xBA, 0x9E, 0x69, 0x5E, 0x38, 0xDB, 0x92, 0xE9, 0x09, 0xFB, 0x1F, 0xE7, 0xF4, 0x5C, 0xAD, 0x0F, 0x6B, 0x7A, 0x7A, 0x8F,
    0xDB, 0xCE, 0x9A, 0x5E, 0x2F, 0x8F, 0xE9, 0x99, 0x9A, 0x4E, 0x79, 0x4D, 0x8A, 0x6D, 0xE6, 0x2A, 0x5D, 0x8B, 0xCD, 0xDE, 0xC8, 0x5D,
    0x7A, 0xCC, 0xAA, 0x90, 0xAD, 0xF7, 0x53, 0x6C, 0xD6, 0x2C, 0x77, 0xE5, 0x09, 0xB1, 0x02, 0x1A, 0xBC, 0x7A, 0xB6, 0x6D, 0xBF, 0xFB,
    0xD5, 0x7E, 0x06, 0x96, 0xBB, 0x44, 0xA7, 0xBB, 0x9D, 0xDF, 0x9D, 0x88, 0xE6, 0xE7, 0x35, 0xA9, 0x5C, 0xEA, 0x36, 0x12, 0x8B, 0x39,
    0x77, 0xF8, 0x5F, 0x8D, 0x32, 0x39, 0xD7, 0xEF, 0xA8, 0xDB, 0xB2, 0x2B, 0xD3, 0xD4, 0x5F, 0x05, 0x9A, 0xBD, 0xBC, 0x4A, 0x53, 0xBB,
    0xEE, 0xC4, 0x5D, 0x1E, 0xC9, 0x92, 0x35, 0xB0, 0x99, 0xEF, 0x42, 0x22, 0xF9, 0xBC, 0x1C, 0xEF, 0x25, 0xFD, 0x02, 0x1B, 0xE3, 0x06,
    0xF8, 0x2D, 0x99, 0xF7, 0xC6, 0x24, 0x3B, 0x6B, 0x13, 0x67, 0xB6, 0xC0, 0x9E, 0xD0, 0xD5, 0x3B, 0xE8, 0x7B, 0x5A, 0xE9, 0x32, 0x09,
    0xD8, 0xC0, 0x4F, 0x42, 0xE5, 0xB5, 0xDF, 0xF1, 0x09, 0x84, 0xBB, 0xF5, 0x61, 0x4B, 0xFF, 0x6A, 0xC8, 0x03, 0x5A, 0x79, 0xE8, 0x3D,
    0xE4, 0x91, 0xCC, 0xED, 0xB5, 0xD9, 0x7D, 0x0C, 0x6D, 0xFA, 0x69, 0xAD, 0xFD, 0xD3, 0x9E, 0xB6, 0xF3, 0xFE, 0xA2, 0x9D, 0x66, 0xBC,
    0x64, 0xBB, 0x33, 0xAD, 0xE9, 0x6F, 0x6F, 0xEE, 0x49, 0x1D, 0xD3, 0xF7, 0x46, 0x5B, 0x1A, 0x54, 0xE5, 0xD0, 0xB0, 0x1C, 0xD9, 0x76,
    0xD5, 0xC0, 0xF5, 0x51, 0x91, 0x2E, 0xCC, 0xDF, 0xF4, 0x7E, 0x57, 0x1C, 0x3F, 0xB5, 0x32, 0xAA, 0x6A, 0x35, 0xB4, 0xE7, 0xDD, 0xE2,
    0xF0, 0x6C, 0xD4, 0xFD, 0xBA, 0xB0, 0xA6, 0xE7, 0xA9, 0x7D, 0x8B, 0x35, 0x3D, 0xED, 0xBB, 0x2B, 0xED, 0x7D, 0x02, 0xE9, 0x7B, 0x73,
    0x6F, 0x42, 0xE9, 0x6A, 0x3B, 0xA1, 0x73, 0x85, 0xF6, 0x34, 0x6E, 0x15, 0x16, 0xE7, 0x65, 0xFD, 0x23, 0xA5, 0xEB, 0xE9, 0x39, 0xA2,
    0x3D, 0x2D, 0xBD, 0x47, 0xB4, 0xCC, 0x1A, 0x76, 0x0E, 0x9E, 0xD1, 0xD3, 0xDB, 0x59, 0xDB, 0xBB, 0x4F, 0x4F, 0xEF, 0xE1, 0xDC, 0x2A,
    0xAC, 0xD2, 0xD9, 0x89, 0x84, 0x92, 0x86, 0xC4, 0x5D, 0xD9, 0x8D, 0x51, 0x4E, 0xE3, 0x12, 0x6E, 0x22, 0xC4, 0x4C, 0xE6, 0xAB, 0xB2,
    0xD6, 0xBB, 0x73, 0x5D, 0x57, 0x8A, 0x3B, 0xD4, 0xF6, 0x34, 0x62, 0xF8, 0xE9, 0x2B, 0x93, 0x99, 0x53, 0x39, 0xA7, 0x29, 0x9A, 0xF7,
    0x6A, 0x5A, 0xF3, 0xE3, 0x68, 0x2D, 0x94, 0xF3, 0xA3, 0xCE, 0x03, 0xB5, 0x5B, 0x46, 0x7E, 0xDF, 0xD3, 0x3B, 0xB6, 0xD7, 0x4A, 0x74,
    0xF5, 0x57, 0x81, 0xAE, 0x16, 0x49, 0xC7, 0x33, 0x1E, 0xDE, 0x3F, 0x07, 0x94, 0xF7, 0x52, 0xD3, 0xA5, 0xBB, 0xFC, 0xDE, 0x98, 0x03,
    0xED, 0x69, 0x5E, 0x8D, 0x7C, 0x8B, 0x3A, 0x91, 0xD7, 0x5C, 0x6F, 0xE8, 0xF2, 0x92, 0xBD, 0x74, 0x8F, 0x2B, 0x99, 0x5B, 0x60, 0x79,
    0xDE, 0x07, 0x1C, 0xDD, 0x45, 0xF6, 0xA6, 0xED, 0x55, 0x8A, 0x24, 0xA9, 0xD8, 0x9F, 0x39, 0xB9, 0x37, 0x77, 0xDB, 0xD2, 0xF3, 0xB6,
    0xEE, 0xD3, 0x9A, 0xBE, 0xFA, 0x29, 0xA7, 0x56, 0xBA, 0xD6, 0xF7, 0xD6, 0x23, 0xB9, 0x5D, 0x90, 0xD1, 0x0B, 0xF9, 0xB5, 0xA6, 0x8B,
    0xD6, 0xDD, 0x26, 0xC9, 0x3B, 0x83, 0x49, 0x9A, 0x57, 0xBD, 0x61, 0xDF, 0x2D, 0x10, 0xB1, 0x8B, 0x43, 0x4E, 0x9E, 0xDF, 0x6F, 0x72,
    0x4C, 0x57, 0xEB, 0x2D, 0x2A, 0xF7, 0xF8, 0x78, 0x6A, 0x2F, 0x40, 0x69, 0x09, 0xDD, 0xA4, 0x51, 0xF2, 0xFE, 0x31, 0x8D, 0xB7, 0x83,
    0xC5, 0x85, 0xFC, 0xA7, 0xAF, 0x11, 0x63, 0x2A, 0x55, 0xB2, 0x15, 0x9B, 0xC6, 0x69, 0x99, 0x35, 0xAF, 0x9F, 0x34, 0x2F, 0xD6, 0x7A,
    0x03, 0x6D, 0x76, 0x43, 0xEE, 0x94, 0xD9, 0xC4, 0x65, 0xF1, 0x64, 0x58, 0xF5, 0x63, 0xD4, 0xEF, 0xF7, 0xAF, 0xD1, 0x36, 0xA7, 0xD9,
    0xD2, 0x37, 0x72, 0x1B, 0x0F, 0x21, 0x53, 0x88, 0xB3, 0x56, 0x76, 0x82, 0x2D, 0x3C, 0x14, 0x28, 0x7B, 0x56, 0x71, 0xAF, 0x4C, 0xCE,
    0xF6, 0x42, 0xEE, 0xF7, 0x37, 0x36, 0x2A, 0xFB, 0xF2, 0xBB, 0xF4, 0x9E, 0x8E, 0xBD, 0x34, 0x27, 0x9E, 0x43, 0x7A, 0xB9, 0xA9, 0x43,
    0xB1, 0xA5, 0xA7, 0xF7, 0x48, 0xA6, 0x4C, 0x90, 0xCE, 0xA6, 0xE8, 0x7D, 0x0F, 0xD9, 0x93, 0x8E, 0x52, 0x2B, 0x89, 0xFF, 0x29, 0xD3,
    0x4E, 0xE6, 0xBF, 0x89, 0x13, 0x57, 0xE7, 0x5E, 0x59, 0x1C, 0x53, 0x76, 0x4E, 0xDB, 0x24, 0x49, 0x99, 0x49, 0xFC, 0x76, 0x50, 0x92,
    0x22, 0xAD, 0x0E, 0xF9, 0xA2, 0xFF, 0x26, 0x4B, 0xE9, 0xB4, 0xDE, 0x47, 0xA7, 0x3C, 0x64, 0xDF, 0x40, 0x5A, 0xF8, 0x28, 0xD3, 0x53,
    0x3F, 0x4B, 0x77, 0x8F, 0xAE, 0x7C, 0xDE, 0x47, 0x77, 0x1F, 0xCE, 0xA9, 0x6A, 0xA3, 0xA9, 0x6E, 0xC5, 0xAF, 0x8D, 0x0E, 0x5A, 0x92,
    0x45, 0x7B, 0x4C, 0x2B, 0x41, 0xD5, 0x6A, 0x45, 0x2B, 0x1D, 0xD9, 0x2A, 0x8B, 0xE9, 0x93, 0xD4, 0x64, 0x4E, 0x6D, 0x34, 0xB5, 0xCB,
    0xB0, 0xDA, 0xE9, 0xE1, 0xC9, 0xB1, 0xE7, 0xF4, 0xB4, 0x8F, 0x3F, 0x6D, 0xF4, 0xCC, 0x5C, 0x83, 0xA8, 0x75, 0xFC, 0xA9, 0xD3, 0x52,
    0xD7, 0x64, 0x69, 0xA3, 0xA5, 0x5E, 0x42, 0x6D, 0x74, 0x64, 0xE9, 0x5A, 0xCD, 0x4A, 0x44, 0x8D, 0x5E, 0x94, 0x64, 0x13, 0x14, 0xCD,
    0x47, 0x81, 0x45, 0xBA, 0x73, 0x21, 0xE2, 0x9A, 0x9B, 0xBC, 0x8F, 0xA9, 0xE9, 0x20, 0x95, 0xE7, 0x44, 0x35, 0x1E, 0x5A, 0xB5, 0xEC,
    0xDE, 0xE6, 0xA1, 0xF7, 0x32, 0x0F, 0x6F, 0xD9, 0x0A, 0x5B, 0x7B, 0x9B, 0x72, 0xEE, 0xC7, 0xCA, 0x7A, 0x45, 0x8D, 0xDB, 0x24, 0xFB,
    0x1E, 0x8A, 0x81, 0x78, 0x09, 0xDC, 0x0F, 0x87, 0xBA, 0x2F, 0x10, 0x5B, 0x5E, 0xDA, 0x7C, 0xB6, 0xC8, 0xBC, 0xB4, 0xD1, 0x34, 0xC3,
    0x2F, 0x14, 0x73, 0x4E, 0x59, 0x8D, 0xAE, 0x38, 0x11, 0x30, 0x70, 0x5A, 0xD4, 0x3B, 0x1E, 0x7A, 0xCA, 0x72, 0xBF, 0xCE, 0xB5, 0xD1,
    0x76, 0xAC, 0x7F, 0xAB, 0xDD, 0x2C, 0xE4, 0x36, 0x21, 0x4B, 0xD8, 0x7A, 0xFA, 0xF3, 0x94, 0xA7, 0xE3, 0x3B, 0xE3, 0xE3, 0x0A, 0x05,
    0x4F, 0x36, 0x6B, 0x0A, 0x9B, 0x65, 0x8B, 0xE4, 0xAB, 0xCC, 0x1B, 0x3C, 0x7B, 0xBB, 0xA1, 0x67, 0x74, 0x44, 0xDB, 0xD1, 0xAD, 0x1E,
    0x6F, 0xB5, 0x8F, 0x23, 0xDA, 0xEE, 0xDC, 0x25, 0x75, 0x44, 0xDB, 0xD6, 0xBA, 0xD5, 0x9B, 0xF9, 0x16, 0x33, 0x84, 0x72, 0x6D, 0xA8,
    0xED, 0x05, 0x1C, 0xD1, 0x35, 0x4B, 0xFA, 0x24, 0x83, 0x2A, 0x6D, 0xF9, 0x5E, 0xB4, 0x6B, 0xB4, 0xAD, 0x4F, 0x46, 0xDD, 0xD3, 0x81,
    0x69, 0xA3, 0xAD, 0xF7, 0x5A, 0xBE, 0xE5, 0xD3, 0x6D, 0x6F, 0xF7, 0x3D, 0xE7, 0xDA, 0x27, 0x57, 0xEB, 0x23, 0xD5, 0xA1, 0xC7, 0x21,
    0x1B, 0xDD, 0x41, 0x91, 0x28, 0x37, 0x8D, 0xAD, 0x36, 0xAF, 0xA7, 0xF1, 0xFF, 0xF6, 0x82, 0x7F, 0x53, 0xB8, 0xB6, 0x5F, 0xC9, 0xEE,
    0x32, 0xBF, 0x48, 0xEC, 0xED, 0x62, 0xB9, 0xCC, 0xD4, 0x4B, 0x83, 0xFF, 0x1B, 0x51, 0x13, 0x89, 0x44, 0x07, 0x24, 0x7C, 0x09, 0x98,
    0x79, 0x9D, 0x44, 0xDA, 0xDD, 0x24, 0x70, 0xB7, 0xEE, 0x1D, 0xF1, 0x11, 0x3E, 0x30, 0x92, 0x1D, 0xD8, 0x0E, 0xD9, 0xEE, 0x31, 0xE5,
    0x79, 0xD9, 0x35, 0xDA, 0x16, 0x9E, 0x77, 0x03, 0x6F, 0x6F, 0xE5, 0x73, 0x35, 0x57, 0xE9, 0x6B, 0x95, 0x74, 0x94, 0xE7, 0x59, 0x7B,
    0xBA, 0xAE, 0xD8, 0x11, 0xB8, 0x9A, 0x67, 0xED, 0x2D, 0xE9, 0x7A, 0x5B, 0x32, 0x19, 0x3D, 0x4E, 0xA1, 0x05, 0x07, 0xEE, 0x14, 0xF7,
    0x4A, 0x44, 0x3C, 0xED, 0x7D, 0x52, 0x9C, 0x69, 0x79, 0xAB, 0xBE, 0x63, 0xB9, 0xA6, 0x48, 0xCE, 0x33, 0x95, 0x64, 0xE4, 0x93, 0x39,
    0x93, 0xB4, 0xF7, 0xF3, 0xEC, 0xFE, 0x83, 0x35, 0x1F, 0x76, 0x72, 0x65, 0x94, 0xEE, 0xBE, 0x33, 0x49, 0x53, 0x78, 0xBE, 0x48, 0xE2,
    0xFA, 0xF9, 0x48, 0x15, 0x2F, 0x14, 0x96, 0x62, 0x51, 0x9E, 0x58, 0x49, 0xC7, 0x25, 0xFB, 0x5F, 0x55, 0x9E, 0x33, 0xAC, 0xF9, 0x5B,
    0xB8, 0x1D, 0xBA, 0xF5, 0xAC, 0x64, 0x7B, 0x77, 0xEF, 0x6C, 0xB1, 0x28, 0x0F, 0x4D, 0x29, 0xA7, 0x53, 0xE3, 0x15, 0xC5, 0x51, 0x71,
    0x8B, 0xC6, 0xD1, 0x09, 0x6C, 0xA0, 0x93, 0x39, 0x4A, 0x99, 0x9E, 0xBD, 0x17, 0xA4, 0x64, 0x15, 0x3D, 0xC1, 0x9A, 0x5D, 0xC2, 0x0E,
    0x0E, 0xE7, 0xBE, 0x18, 0xBE, 0xFF, 0x56, 0xF7, 0x43, 0x18, 0xC7, 0x4B, 0x2D, 0x5B, 0xB5, 0xC6, 0x49, 0xBA, 0xD1, 0x24, 0x95, 0x7B,
    0x68, 0xB2, 0xCF, 0x62, 0x65, 0x9A, 0x22, 0xB4, 0xB7, 0x09, 0x75, 0x8D, 0x96, 0x85, 0x6B, 0x8B, 0x7B, 0x68, 0xDA, 0x57, 0x2B, 0xF7,
    0x4D, 0x7A, 0x82, 0x1A, 0x6F, 0x73, 0x5F, 0x3F, 0x9C, 0x78, 0x84, 0x95, 0x67, 0x50, 0x71, 0xEE, 0xEA, 0xBE, 0x1E, 0xCD, 0x7A, 0xE4,
    0x6A, 0x95, 0x3E, 0x94, 0xCB, 0x20, 0x3C, 0x87, 0xB1, 0xBB, 0xF1, 0x42, 0x0F, 0x15, 0xAF, 0xEA, 0x83, 0xB8, 0x74, 0xB7, 0xE8, 0x73,
    0x82, 0x42, 0x02, 0xF1, 0x20, 0xAB, 0xCC, 0x23, 0x81, 0xDB, 0xD1, 0x39, 0xA7, 0x2C, 0xD3, 0x55, 0xA6, 0x61, 0x7F, 0xCF, 0xCF, 0xEE,
    0xFC, 0xAC, 0x44, 0xF4, 0x5D, 0xCC, 0x9F, 0x56, 0xDF, 0x78, 0xF6, 0x3C, 0xF4, 0x2A, 0x75, 0xA0, 0x4C, 0x47, 0xB9, 0x77, 0xC9, 0xF9,
    0x54, 0xA2, 0x61, 0x94, 0x3C, 0x1C, 0x99, 0x9B, 0xBC, 0x47, 0x7A, 0x56, 0x7F, 0x5A, 0xFA, 0xBC, 0xF2, 0xBE, 0x40, 0xF8, 0x83, 0xEB,
    0xC1, 0xEB, 0x28, 0x89, 0xE7, 0xCE, 0xA2, 0x7A, 0xDA, 0xA8, 0xD3, 0x5D, 0xDA, 0xA3, 0xD3, 0xDD, 0xA9, 0xD3, 0x49, 0x7E, 0x55, 0xA2,
    0x79, 0xAF, 0xC5, 0x79, 0x50, 0xAD, 0x5D, 0x04, 0x4F, 0xD9, 0xCE, 0x41, 0x9E, 0x8B, 0x71, 0xAC, 0xC5, 0x48, 0xF7, 0xF7, 0xAC, 0xC7,
    0x99, 0xD2, 0x5A, 0x90, 0xB1, 0x57, 0xF8, 0xF6, 0x4F, 0x92, 0x56, 0x12, 0xD9, 0xE3, 0x9D, 0xA0, 0x90, 0x48, 0xEE, 0x78, 0x52, 0x0B,
    0x30, 0xF5, 0x7C, 0xC6, 0xF2, 0x7E, 0x63, 0x96, 0x4E, 0x4F, 0x94, 0x6F, 0x01, 0xDA, 0xD6, 0x51, 0xC0, 0x3E, 0x31, 0x4E, 0x05, 0x15,
    0x61, 0x49, 0xCF, 0x56, 0xEE, 0x64, 0x55, 0x1F, 0xCD, 0x89, 0xDC, 0x23, 0x93, 0x59, 0x92, 0x44, 0xE2, 0x9B, 0x6E, 0xD8, 0xCA, 0x67,
    0x04, 0xCA, 0xED, 0x9D, 0xB5, 0x4F, 0xC8, 0xD1, 0x74, 0x57, 0xE0, 0x3A, 0x3F, 0x7A, 0x32, 0xEA, 0x9C, 0x9B, 0xCC, 0xCB, 0x15, 0xBA,
    0xC2, 0xF3, 0x35, 0xB6, 0xB6, 0x96, 0xB2, 0x68, 0xA1, 0x2F, 0x7B, 0xED, 0x0E, 0x97, 0xAC, 0xC6, 0xA2, 0xBD, 0x94, 0x6F, 0xA1, 0xD1,
    0xC7, 0xD3, 0x34, 0xB3, 0xDB, 0x74, 0x1D, 0x49, 0xB0, 0xDE, 0xF6, 0x53, 0x60, 0xCF, 0xC3, 0xF3, 0x7B, 0x3E, 0xF6, 0x34, 0xBD, 0xB3,
    0x56, 0x51, 0x1D, 0x41, 0xBC, 0x62, 0x7B, 0x85, 0x7D, 0x20, 0xE6, 0x42, 0x4C, 0xA1, 0x36, 0x76, 0x93, 0x78, 0xAE, 0xE5, 0x3B, 0xBC,
    0x96, 0x26, 0x8B, 0x6F, 0x6D, 0x75, 0xAC, 0x3C, 0x67, 0xCA, 0x37, 0x59, 0xBD, 0x25, 0x7B, 0x1B, 0xF9, 0x28, 0x13, 0xBD, 0x0D, 0xFD,
    0xDC, 0x3B, 0xA3, 0x66, 0xD8, 0x2F, 0x68, 0x89, 0x54, 0xA6, 0xA6, 0xFB, 0x66, 0xCA, 0x63, 0x9C, 0xF2, 0x30, 0xF0, 0x55, 0x23, 0x9E,
    0xCF, 0xA9, 0xD4, 0xCF, 0xBC, 0xFA, 0x69, 0x98, 0xCC, 0x5B, 0x9D, 0x87, 0x38, 0xC5, 0xB7, 0x68, 0x38, 0x0F, 0x56, 0xA3, 0x29, 0x9F,
    0xE9, 0x88, 0x3A, 0x96, 0xCF, 0x35, 0xAD, 0x71, 0x6B, 0x6E, 0xE6, 0x26, 0x19, 0x55, 0xA9, 0x1E, 0x8B, 0xCB, 0xC4, 0xBB, 0x32, 0xAE,
    0x52, 0x54, 0xAE, 0x67, 0x13, 0x97, 0xF0, 0x65, 0x2B, 0x04, 0x79, 0x3F, 0x63, 0x90, 0xCE, 0x32, 0xD4, 0xD6, 0x0C, 0xE5, 0xB3, 0x7E,
    0x93, 0xF4, 0xCA, 0x02, 0xFA, 0x48, 0x48, 0x24, 0xF3, 0x94, 0x76, 0x8B, 0x09, 0x25, 0x99, 0xD4, 0x9A, 0x47, 0x22, 0xF7, 0x9C, 0x18,
    0xCF, 0xFB, 0xB8, 0x96, 0x71, 0xE3, 0x1A, 0x6D, 0x3A, 0xCB, 0xCA, 0x96, 0xDD, 0x11, 0x92, 0x6F, 0xDA, 0x28, 0x0F, 0xD6, 0x05, 0x25,
    0x3E, 0x51, 0x7C, 0x16, 0x77, 0x7F, 0x4D, 0x53, 0xA2, 0x8D, 0xFD, 0xDF, 0xB5, 0x51, 0xE5, 0x19, 0x4F, 0xE7, 0xAD, 0x1E, 0xE4, 0x25,
    0x1E, 0xA8, 0x73, 0xBD, 0x3A, 0x65, 0x70, 0x6C, 0x39, 0xED, 0x3D, 0xFA, 0xDE, 0x90, 0x65, 0xD4, 0xE9, 0xA3, 0x66, 0xE6, 0xEA, 0xF0,
    0x50, 0x92, 0x9B, 0x7A, 0x79, 0xB1, 0xAE, 0x9C, 0xF1, 0xD1, 0x7B, 0xD8, 0x26, 0x74, 0xB5, 0x57, 0x1E, 0xED, 0x41, 0x0E, 0xD7, 0x7E,
    0x2D, 0x3C, 0xCC, 0x92, 0x94, 0xAC, 0x75, 0xA6, 0x72, 0x4C, 0xD3, 0xDE, 0x3F, 0x01, 0x5B, 0x13, 0x64, 0x3B, 0x80, 0x38, 0xC9, 0xFF,
    0xB9, 0xFB, 0xFA, 0x47, 0xC7, 0xF4, 0x2D, 0x7C, 0x1C, 0x5B, 0xBF, 0x40, 0x23, 0xF4, 0x2C, 0xDA, 0xAC, 0xCB, 0x95, 0x65, 0x2D, 0x47,
    0x3C, 0x65, 0x3F, 0xFE, 0xD6, 0xEF, 0x67, 0xB8, 0x2F, 0x7B, 0x3A, 0xE2, 0x21, 0x5E, 0x30, 0x52, 0xCA, 0xB7, 0xAB, 0x75, 0x85, 0x12,
    0x92, 0xA7, 0xF7, 0xB1, 0x94, 0x68, 0xBB, 0x6B, 0x63, 0xAD, 0x4E, 0x53, 0xEF, 0xB2, 0x9D, 0x98, 0x12, 0x4D, 0xED, 0xFE, 0xFD, 0x5C,
    0xE5, 0x11, 0xC9, 0x63, 0x86, 0xF3, 0x37, 0x16, 0x1C, 0xD9, 0x60, 0x04, 0x79, 0xD8, 0xE7, 0xD9, 0xF9, 0x49, 0xAA, 0x47, 0xEF, 0x38,
    0x39, 0xA2, 0x29, 0xDE, 0x60, 0x92, 0x35, 0xF0, 0xE1, 0xFC, 0x06, 0xA5, 0x73, 0x0E, 0xAE, 0xE7, 0xD9, 0x19, 0x7D, 0xBD, 0x57, 0xFA,
    0x76, 0x24, 0x1F, 0xEF, 0x46, 0xC9, 0x43, 0xBF, 0xF2, 0xDE, 0xCA, 0x72, 0x5C, 0x7E, 0x2F, 0x42, 0x4E, 0xC3, 0x76, 0xA9, 0x6A, 0xFB,
    0x22, 0x7B, 0x9E, 0xF2, 0x5B, 0x26, 0x46, 0x8D, 0xEF, 0xD1, 0xB9, 0xDA, 0x8F, 0xA8, 0x66, 0x29, 0xBA, 0x49, 0x27, 0xE3, 0x6C, 0xC6,
    0x09, 0x72, 0xE1, 0x2C, 0x54, 0x99, 0x97, 0x6C, 0x83, 0xAE, 0x76, 0x96, 0xEB, 0x6A, 0x1B, 0xA9, 0xF1, 0xD0, 0x5F, 0x15, 0x1E, 0xDA,
    0xDA, 0xE6, 0xEA, 0xF0, 0xD1, 0x7B, 0xCC, 0xC7, 0x20, 0x9D, 0x25, 0x25, 0xF2, 0xDF, 0xC4, 0x8E, 0xD5, 0xA2, 0xF1, 0x95, 0xB5, 0xD0,
    0x93, 0xE2, 0x3D, 0x58, 0x75, 0x1A, 0xAE, 0xF7, 0x7D, 0x71, 0x86, 0xA6, 0xBC, 0x2B, 0x73, 0x75, 0x0E, 0x32, 0x70, 0x7D, 0x8B, 0x81,
    0x6B, 0x20, 0xA6, 0xF0, 0x71, 0xA5, 0xED, 0x4D, 0x0C, 0x6F, 0xF0, 0x71, 0x36, 0xFB, 0xBB, 0xDE, 0x5E, 0x8E, 0x68, 0xEB, 0xBD, 0x58,
    0x3F, 0xCE, 0xFA, 0xB3, 0x67, 0xF9, 0xB6, 0x3F, 0xC7, 0xF5, 0xBE, 0x8C, 0xE0, 0xCA, 0x59, 0xB1, 0x6C, 0xBF, 0xA4, 0x95, 0xB6, 0x19,
    0x68, 0x46, 0x49, 0xF6, 0x4A, 0xDE, 0xCE, 0x37, 0xD2, 0xF6, 0xDE, 0x5C, 0x88, 0x34, 0xB5, 0xDB, 0xDE, 0xBA, 0xCB, 0xC3, 0x28, 0xF9,
    0xAC, 0x94, 0xCF, 0x05, 0xA2, 0xBC, 0x28, 0x53, 0x52, 0xAB, 0xED, 0x18, 0x7E, 0x32, 0x83, 0xB3, 0x8A, 0xD9, 0x8B, 0x6D, 0x60, 0xE1,
    0x36, 0xC0, 0x82, 0x93, 0x92, 0xB4, 0xA6, 0x4E, 0xD7, 0x44, 0x2C, 0x0D, 0xE9, 0x5B, 0x67, 0xEA, 0x7E, 0x25, 0xDD, 0xA5, 0xED, 0xEC,
    0xA5, 0x30, 0xF5, 0xBA, 0x36, 0x59, 0x59, 0x45, 0x6A, 0xD1, 0x98, 0xBA, 0x96, 0x47, 0xD7, 0xB4, 0x2D, 0xAE, 0xE5, 0xD7, 0x19, 0x6D,
    0xBD, 0x17, 0x68, 0x3B, 0x1F, 0x33, 0x7D, 0x5C, 0x1E, 0x33, 0xEA, 0x74, 0xF5, 0x2E, 0xDB, 0x0E, 0xD9, 0xD2, 0x15, 0xB8, 0x19, 0x90,
    0x48, 0xAF, 0xD5, 0xAF, 0x23, 0x9A, 0xAE, 0xCB, 0x1B, 0x71, 0x76, 0x6F, 0x5E, 0x69, 0xF5, 0xF4, 0xA0, 0x2E, 0x63, 0xC6, 0x59, 0xE9,
    0x30, 0xB4, 0xDB, 0x20, 0xB9, 0x42, 0x57, 0x8B, 0x2F, 0x50, 0x57, 0xE8, 0x29, 0xF9, 0x2C, 0x0A, 0xF2, 0x80, 0xAE, 0xB9, 0xE9, 0xB4,
    0x4A, 0xF9, 0x35, 0x00, 0xD7, 0x68, 0x5A, 0xA4, 0x7B, 0xD4, 0x09, 0x5E, 0x2B, 0xBF, 0x35, 0x4D, 0x2D, 0x37, 0x17, 0x5D, 0xA5, 0xEF,
    0xCC, 0xA7, 0x42, 0xA0, 0xDB, 0x34, 0xE5, 0x77, 0x24, 0xB5, 0xDC, 0xAF, 0x77, 0x8D, 0x2E, 0xDE, 0x53, 0xF7, 0x16, 0xCD, 0x64, 0x7E,
    0xEF, 0x2B, 0x52, 0xB2, 0xB8, 0x52, 0x97, 0x55, 0xD4, 0x69, 0xCB, 0xFA, 0x65, 0x61, 0x5D, 0x99, 0xC4, 0x6D, 0x4B, 0xC2, 0x9D, 0xAC,
    0xC1, 0xD6, 0xDA, 0xCE, 0xF4, 0x2F, 0x84, 0xAF, 0x33, 0xDB, 0xB7, 0xAD, 0xE5, 0x13, 0x1B, 0x31, 0x77, 0xAB, 0xEF, 0x0D, 0x30, 0x0F,
    0x91, 0xD2, 0x7B, 0x2C, 0xB1, 0x7C, 0xBE, 0xD7, 0xE2, 0xC7, 0x4F, 0xCE, 0x83, 0x3A, 0x6D, 0xF1, 0xFA, 0x57, 0x38, 0x9F, 0x49, 0x26,
    0x4B, 0xBB, 0x17, 0x6F, 0xD0, 0x55, 0xF6, 0x7E, 0x6C, 0x37, 0xE6, 0x35, 0xD3, 0x65, 0x7F, 0xDB, 0x6B, 0x24, 0x3D, 0xEB, 0x47, 0x94,
    0x36, 0xDA, 0x72, 0xDB, 0x5B, 0x43, 0xB9, 0xC6, 0x57, 0x4D, 0xA7, 0xEB, 0x88, 0xAF, 0xFD, 0x9B, 0x9C, 0xAE, 0xE9, 0x3A, 0x1C, 0xD1,
    0x8C, 0xE1, 0xA3, 0x37, 0xCA, 0xC1, 0xCA, 0xE3, 0x6A, 0xDB, 0xD2, 0x13, 0x76, 0xE5, 0xF3, 0xF1, 0x8C, 0xAF, 0xE4, 0xBB, 0x19, 0x34,
    0x95, 0x96, 0x3E, 0x4F, 0x79, 0xD8, 0xDE, 0xE6, 0xC5, 0xD1, 0xA3, 0xD4, 0x97, 0x64, 0xDE, 0xCE, 0x78, 0xC8, 0xF7, 0x64, 0xC5, 0xAE,
    0x3D, 0xDC, 0xE6, 0x5E, 0xB5, 0xF3, 0x75, 0xDA, 0x55, 0xBD, 0xAB, 0x75, 0x7E, 0x85, 0x65, 0xA9, 0xB8, 0xC1, 0x6F, 0x96, 0xBE, 0x9D,
    0xBD, 0x1C, 0xA9, 0x77, 0xA9, 0x5D, 0x94, 0xF9, 0x68, 0x7F, 0xA1, 0xD2, 0x35, 0x3E, 0x26, 0xA9, 0x06, 0x4D, 0x76, 0x2F, 0xD9, 0xD9,
    0x9D, 0xC9, 0x7C, 0xA3, 0xD3, 0x75, 0xE4, 0x7D, 0x81, 0x52, 0x48, 0x6E, 0xB2, 0x1D, 0x52, 0x3E, 0xBF, 0xB6, 0xEE, 0x03, 0xD1, 0xBC,
    0xBD, 0xC4, 0xC9, 0x1C, 0xED, 0xD7, 0x4A, 0xED, 0xE4, 0x57, 0xA3, 0xE3, 0x36, 0xB4, 0x6A, 0xF3, 0x31, 0xA5, 0xAE, 0x96, 0x27, 0xB3,
    0xB4, 0x36, 0xA8, 0xDE, 0xCB, 0xA8, 0x11, 0x73, 0x4F, 0x2A, 0xF1, 0x2A, 0x26, 0xD3, 0x96, 0xAD, 0x35, 0x05, 0xED, 0x04, 0x6E, 0xBF,
    0x61, 0x6C, 0x6A, 0x23, 0xBD, 0xE2, 0x59, 0xB9, 0x75, 0x5A, 0xD9, 0x66, 0x4E, 0xBE, 0x9D, 0x6B, 0xE6, 0xF6, 0x14, 0x4A, 0xF9, 0xEA,
    0x78, 0x4E, 0xA7, 0xEB, 0xCA, 0xE9, 0x08, 0x1F, 0xD4, 0xC2, 0x6A, 0x2F, 0x8D, 0xDB, 0x7C, 0x47, 0xF3, 0x55, 0x5F, 0x78, 0x2A, 0x72,
    0x9C, 0x57, 0x99, 0x5F, 0x0A, 0xF7, 0x2B, 0xDB, 0x83, 0xAF, 0x8F, 0xCA, 0xB2, 0x62, 0x36, 0xF0, 0xBB, 0x07, 0x42, 0x91, 0x42, 0xC4,
    0x77, 0xCC, 0xC9, 0xB6, 0x6C, 0xC2, 0x1F, 0x8C, 0xFD, 0x6B, 0xE0, 0x71, 0x92, 0xCF, 0xCD, 0x68, 0xCD, 0xF7, 0x24, 0xB5, 0xD0, 0x65,
    0x79, 0x8A, 0xE1, 0xA7, 0x44, 0x06, 0x15, 0x0B, 0x3F, 0x1C, 0x2F, 0x5A, 0xE8, 0xCA, 0xB6, 0xE0, 0x86, 0xA6, 0x1B, 0x8D, 0x06, 0x6E,
    0x11, 0x8B, 0x3B, 0x38, 0xA5, 0x71, 0x6A, 0xDD, 0x07, 0xCE, 0x7E, 0xAB, 0xE3, 0x79, 0x11, 0x94, 0xD3, 0x1C, 0xD2, 0xA3, 0x27, 0x74,
    0x8E, 0xDB, 0x50, 0x3D, 0x9F, 0xD1, 0xDC, 0xA2, 0xD6, 0xF1, 0x49, 0x9F, 0xB3, 0xB5, 0xCE, 0x1D, 0x1E, 0x62, 0xAF, 0x65, 0xBE, 0x2A,
    0xF4, 0x85, 0xEC, 0x21, 0xF6, 0xCC, 0x57, 0xBB, 0x2C, 0xB8, 0xB2, 0xC8, 0xDE, 0x5A, 0xCC, 0x5C, 0xCF, 0x22, 0x4B, 0x0A, 0x22, 0x85,
    0x3C, 0xEF, 0x27, 0x6A, 0x3A, 0x15, 0x3E, 0x52, 0xAB, 0xD3, 0x0D, 0x71, 0x32, 0x77, 0x39, 0xE7, 0xE5, 0xA8, 0xF5, 0xBD, 0x5F, 0x9E,
    0x48, 0x5E, 0xB7, 0x71, 0x8A, 0x9A, 0x82, 0x05, 0xDF, 0xE9, 0x74, 0x83, 0xDC, 0xC8, 0xBF, 0xED, 0x5B, 0xAD, 0xDE, 0xCE, 0xBB, 0xD2,
    0x68, 0xEB, 0xE7, 0xA4, 0x0D, 0xBC, 0x9D, 0x07, 0x23, 0xCC, 0x7D, 0xB1, 0x6E, 0xF6, 0x07, 0x57, 0xF3, 0x62, 0xE1, 0x35, 0x99, 0xC0,
    0x2D, 0xA7, 0x4C, 0x1A, 0xED, 0x85, 0x43, 0x2E, 0x88, 0x75, 0xDB, 0x59, 0x5A, 0x6D, 0xF3, 0x8A, 0x90, 0x68, 0x8D, 0x4D, 0xB7, 0xEE,
    0x12, 0x24, 0x1F, 0x1D, 0x16, 0x3B, 0x6F, 0x43, 0xEE, 0x8D, 0xC3, 0x28, 0xC2, 0xC1, 0x39, 0x2D, 0xFF, 0x3A, 0x61, 0xB3, 0x81, 0xB1,
    0xB5, 0xF6, 0x2D, 0xEB, 0x15, 0x21, 0x4A, 0xB2, 0xDD, 0x4F, 0x92, 0xEE, 0x22, 0x4E, 0xF3, 0x78, 0xDD, 0x89, 0x93, 0xCE, 0xB5, 0x7B,
    0xF0, 0x79, 0x30, 0xC6, 0x0B, 0xF4, 0x84, 0x36, 0x44, 0xF9, 0x8E, 0x45, 0xC7, 0x1F, 0x44, 0x7D, 0x60, 0x6C, 0xAD, 0xF5, 0x11, 0x27,
    0xAD, 0xFE, 0xE2, 0xC6, 0xBB, 0x12, 0x8F, 0xCC, 0x1F, 0xC4, 0x9A, 0x6F, 0x9D, 0xC2, 0x9D, 0xB9, 0x29, 0x9E, 0x4B, 0x0D, 0x42, 0x23,
    0x65, 0x50, 0x6C, 0xE9, 0x2B, 0xC0, 0xB3, 0x13, 0x84, 0xB6, 0x29, 0x5C, 0x5F, 0x0F, 0x13, 0x78, 0x2A, 0xEB, 0x3B, 0x38, 0x9E, 0xF6,
    0x55, 0xF1, 0x6E, 0x65, 0xB4, 0x74, 0xDA, 0xEC, 0x8A, 0xFD, 0xA2, 0x32, 0x5D, 0x5B, 0x1D, 0x26, 0xBD, 0x2D, 0xE7, 0x68, 0xCF, 0x2A,
    0x6E, 0x8D, 0xC6, 0xAB, 0xD8, 0x8E, 0x87, 0xFC, 0x24, 0xC6, 0x7F, 0x14, 0x1F, 0x35, 0x34, 0x8D, 0x92, 0x1C, 0x6B, 0x9F, 0x37, 0xDC,
    0xDB, 0x2A, 0xC9, 0x6C, 0x7A, 0xB7, 0xCA, 0x2D, 0xD3, 0x16, 0x5E, 0x8B, 0xE2, 0xA5, 0xDB, 0x16, 0x26, 0x0D, 0x16, 0xE6, 0xAE, 0xF0,
    0xD0, 0x76, 0x07, 0x5B, 0xDE, 0x77, 0xAA, 0xD1, 0x33, 0x4A, 0xAD, 0x61, 0x92, 0xBC, 0x07, 0x0A, 0x5B, 0x43, 0xD7, 0xA4, 0x13, 0x6B,
    0x1E, 0xF2, 0xBE, 0x44, 0xB6, 0x0A, 0xA3, 0x7B, 0x93, 0x29, 0x8A, 0x3B, 0x81, 0xAE, 0x3F, 0x53, 0x5F, 0x65, 0x98, 0xBE, 0xA7, 0xA4,
    0x51, 0x74, 0xC6, 0x27, 0x4A, 0xD2, 0xAF, 0x59, 0xDB, 0x89, 0x29, 0xCB, 0x70, 0x39, 0x3F, 0xCB, 0x67, 0x28, 0xD6, 0x69, 0x1C, 0xF7,
    0x23, 0xCA, 0xCB, 0xDA, 0x4F, 0x42, 0x38, 0x1F, 0x8D, 0x71, 0x9A, 0xEC, 0x74, 0xB4, 0xD2, 0x14, 0xEF, 0xB2, 0xCB, 0x76, 0x2B, 0x2C,
    0x5F, 0xEA, 0xAF, 0x35, 0xB9, 0xCE, 0xC3, 0xF6, 0xA6, 0xAC, 0xF6, 0x33, 0x55, 0xF7, 0x79, 0x38, 0x1F, 0x61, 0xAE, 0xD2, 0x8E, 0xE3,
    0xAF, 0x15, 0x08, 0xDB, 0x7E, 0x6F, 0xD6, 0x7D, 0xBC, 0xF4, 0xCE, 0xB4, 0xAC, 0x6F, 0xF6, 0x26, 0x6D, 0x71, 0xB6, 0xEF, 0x5C, 0x57,
    0xEB, 0x2A, 0xBD, 0x04, 0x2F, 0xB7, 0x97, 0x58, 0x5B, 0xCC, 0x4D, 0x92, 0x68, 0x82, 0xC6, 0xF7, 0x06, 0xB4, 0xD3, 0xA7, 0x7E, 0x4A,
    0xBC, 0x97, 0x6F, 0x57, 0xDF, 0xAA, 0xD1, 0x4A, 0xD7, 0x95, 0x73, 0x22, 0x57, 0xF3, 0xCC, 0x7A, 0x82, 0x9A, 0x77, 0x43, 0xD7, 0x69,
    0x3A, 0xF7, 0x9B, 0xEF, 0x6A, 0xDB, 0xC9, 0xD6, 0xAF, 0x09, 0xD2, 0xE9, 0x1B, 0xC3, 0xC4, 0x6D, 0xF7, 0x14, 0xC5, 0x7A, 0xA8, 0xFF,
    0x4D, 0xB6, 0x47, 0x96, 0x63, 0x3B, 0x93, 0xAB, 0xD4, 0x78, 0x19, 0x55, 0xDF, 0xA0, 0x18, 0x77, 0x19, 0x79, 0x89, 0xD8, 0xEE, 0xF1,
    0x12, 0x77, 0xB7, 0xED, 0xFD, 0xF0, 0xDA, 0xCE, 0x51, 0x47, 0x2E, 0xA3, 0x2E, 0x17, 0x53, 0xB8, 0xC3, 0xD3, 0x28, 0xED, 0x57, 0x0D,
    0x8A, 0xE3, 0x37, 0xB8, 0x41, 0xE8, 0xEB, 0x68, 0x6C, 0xB5, 0xF5, 0xC9, 0x76, 0xAF, 0x85, 0xEB, 0x9B, 0x63, 0x19, 0xCF, 0xB6, 0x8C,
    0x85, 0x0D, 0xC2, 0x9E, 0xCC, 0x51, 0x3A, 0x7A, 0xDA, 0x6F, 0xD2, 0x58, 0x6E, 0xEB, 0xBC, 0x38, 0xB6, 0xA9, 0xD6, 0x72, 0xBE, 0xAB,
    0x26, 0x6B, 0x38, 0xE6, 0xC5, 0x62, 0x0B, 0x2B, 0x13, 0xB4, 0x46, 0x34, 0xF0, 0xB3, 0x33, 0xB3, 0x82, 0x9E, 0xA0, 0xE8, 0x77, 0x9D,
    0x6E, 0x70, 0x93, 0xEE, 0x59, 0xDC, 0x75, 0x42, 0x8F, 0x4E, 0xEA, 0x94, 0x5D, 0x6D, 0x23, 0xF9, 0xD4, 0x4B, 0xBC, 0x38, 0x6B, 0x6A,
    0xBA, 0x55, 0x65, 0x2D, 0x47, 0xDB, 0xEF, 0xCD, 0xCD, 0x1E, 0xC8, 0x66, 0x8E, 0xF2, 0x90, 0xE6, 0xD0, 0x9E, 0xC5, 0x7A, 0x8D, 0xAA,
    0xF8, 0x43, 0x8C, 0x01, 0x11, 0x5F, 0xAE, 0x05, 0xD7, 0xFB, 0x82, 0x63, 0xBD, 0xA3, 0xDA, 0xAD, 0x2C, 0xCF, 0xE8, 0xA7, 0x48, 0x77,
    0xCD, 0x12, 0xEC, 0x7C, 0x67, 0x04, 0x79, 0xC4, 0x2B, 0x49, 0xDA, 0x9D, 0x39, 0x6D, 0x8B, 0x2B, 0xE2, 0x3E, 0xB8, 0x88, 0x67, 0xDD,
    0xAE, 0x66, 0x37, 0xEA, 0xCE, 0x76, 0x5D, 0xA2, 0x73, 0x4B, 0xBC, 0x53, 0x8B, 0x74, 0xEB, 0x3C, 0xE5, 0x40, 0x9E, 0x86, 0xAA, 0xE8,
    0x6D, 0x1D, 0xF5, 0xB8, 0x9E, 0x9A, 0x74, 0xF2, 0xCA, 0x79, 0x97, 0xBD, 0x29, 0x46, 0x4A, 0xD2, 0xAD, 0xF3, 0xBB, 0x16, 0xDA, 0xCF,
    0x8B, 0x2C, 0xA1, 0x62, 0xAF, 0xAD, 0x35, 0x1F, 0xB8, 0x5B, 0xA3, 0x23, 0x39, 0xDA, 0x0D, 0x1D, 0xBB, 0x12, 0x0F, 0xF4, 0x82, 0x6B,
    0xED, 0x0D, 0x43, 0xEF, 0x71, 0xFE, 0x65, 0x39, 0xCD, 0x55, 0x6F, 0x1B, 0x5A, 0xE9, 0xA7, 0xF0, 0xFD, 0x5F, 0x6A, 0x93, 0x4D, 0x4B,
    0xB4, 0xE4, 0x77, 0x40, 0xAB, 0xA6, 0x4C, 0x89, 0x8F, 0xFA, 0x29, 0x81, 0xE3, 0x98, 0x4A, 0x23, 0x56, 0x3E, 0x87, 0xB8, 0x1A, 0x7C,
    0x6D, 0x77, 0xCD, 0x6A, 0x67, 0x21, 0xCE, 0xF2, 0x90, 0xDC, 0xE4, 0x8F, 0xD4, 0xDC, 0x34, 0x5A, 0xC3, 0xA5, 0x9E, 0x82, 0x16, 0x96,
    0x5A, 0xBC, 0x5F, 0xA8, 0xD7, 0xB3, 0xCC, 0xCB, 0x5A, 0xF7, 0x29, 0x2C, 0x5D, 0xE4, 0xDF, 0xA8, 0x95, 0xB1, 0xF5, 0xDA, 0xEE, 0x9C,
    0x73, 0x45, 0xA3, 0x4E, 0x37, 0x80, 0xDC, 0x0B, 0xD6, 0x42, 0x4D, 0xE4, 0x51, 0x7D, 0x9E, 0xB3, 0xCF, 0xB3, 0xD1, 0x6A, 0xD4, 0xEB,
    0xBD, 0x52, 0x0F, 0xDA, 0x4A, 0x1D, 0xE4, 0x31, 0x1F, 0xDB, 0x36, 0xF6, 0xA4, 0x2D, 0x99, 0xFC, 0x31, 0xDD, 0x4A, 0x57, 0x86, 0xA5,
    0x88, 0x57, 0xF1, 0x04, 0xA5, 0xD3, 0x65, 0xFC, 0x2B, 0xCB, 0xC9, 0x32, 0x25, 0x2D, 0x6D, 0x81, 0x3C, 0xB5, 0xCE, 0x30, 0x32, 0x1F,
    0x75, 0x9A, 0x26, 0xC9, 0x23, 0x95, 0xF2, 0x8C, 0x1B, 0xFC, 0x9F, 0xD8, 0xA3, 0xE0, 0x3D, 0x04, 0x2D, 0x32, 0x30, 0xBD, 0xFD, 0xA5,
    0xAE, 0x79, 0xCB, 0xFB, 0x4F, 0xE4, 0xD9, 0x68, 0xA7, 0x49, 0xD4, 0xA9, 0xD2, 0x37, 0x49, 0x2B, 0x99, 0x45, 0xF2, 0xB5, 0xAA, 0x54,
    0x37, 0xBE, 0x3A, 0x1F, 0x5E, 0x16, 0xDB, 0x34, 0x6A, 0x65, 0x89, 0x97, 0x74, 0x94, 0xF2, 0x8A, 0x89, 0xBF, 0x46, 0x48, 0x73, 0x89,
    0xA3, 0x79, 0xA9, 0xAF, 0x75, 0xBB, 0x00, 0xEF, 0x80, 0x26, 0xBD, 0x9A, 0x48, 0xE7, 0x39, 0x5F, 0x85, 0x7E, 0x20, 0xF1, 0xF3, 0x94,
    0xB6, 0xA3, 0xF1, 0x3E, 0xDC, 0xC7, 0x87, 0xF8, 0x3B, 0x12, 0xF1, 0xB5, 0xCD, 0x2F, 0xDA, 0xF9, 0xF6, 0x52, 0xE0, 0xEB, 0x8C, 0xB6,
    0x81, 0x7B, 0xCD, 0x15, 0xAF, 0xBA, 0x58, 0xA4, 0xD7, 0xB3, 0x64, 0xAF, 0xC0, 0xDA, 0xA5, 0x18, 0xD8, 0x97, 0x37, 0xF3, 0xE1, 0xE7,
    0x14, 0xF6, 0x14, 0x65, 0x7A, 0xEA, 0xE5, 0x54, 0xCA, 0x8B, 0x53, 0x5D, 0x83, 0xC4, 0xD7, 0x1D, 0x9A, 0x5A, 0x6F, 0x37, 0xA8, 0xF1,
    0x30, 0x49, 0x7E, 0x89, 0x64, 0xFB, 0x59, 0xB9, 0x6D, 0x64, 0x5C, 0x69, 0xDF, 0x1A, 0x75, 0x8D, 0x0F, 0xD1, 0x1D, 0x63, 0x1A, 0xB5,
    0x7E, 0xAE, 0x95, 0xA7, 0xA3, 0xBE, 0x28, 0xF3, 0x74, 0x4C, 0x3B, 0x92, 0xCF, 0x13, 0x16, 0x87, 0x5E, 0x03, 0xDD, 0x95, 0x9F, 0x6C,
    0x69, 0x0A, 0x0F, 0x39, 0x53, 0xB8, 0x94, 0x66, 0xE2, 0xB7, 0x26, 0x14, 0x7D, 0x0F, 0xFA, 0xFA, 0x40, 0x7D, 0xE8, 0xF8, 0xD9, 0x84,
    0xF0, 0xD9, 0x16, 0xDE, 0x64, 0x0B, 0x2C, 0x7C, 0x19, 0xA6, 0xB8, 0xB0, 0x5E, 0xDB, 0xE6, 0xC5, 0x96, 0x8A, 0xBB, 0xFB, 0x2B, 0x5B,
    0xBA, 0xDA, 0xFC, 0x2B, 0x44, 0x35, 0xF7, 0xE1, 0xB2, 0xB9, 0x75, 0x6A, 0x6B, 0x29, 0x5F, 0x4B, 0x99, 0xE2, 0x35, 0xDC, 0x98, 0xB0,
    0xF5, 0x27, 0x50, 0xD3, 0x5C, 0xF4, 0x03, 0x9A, 0x2E, 0x52, 0x75, 0x9D, 0x12, 0xBC, 0xD2, 0xF8, 0x2D, 0xFF, 0x34, 0x0F, 0xE4, 0x83,
    0x48, 0xDE, 0x0B, 0x92, 0xA5, 0x7D, 0x54, 0x0F, 0xE9, 0x0D, 0x09, 0x83, 0x07, 0x7D, 0x4C, 0xA6, 0x17, 0x25, 0xBD, 0x23, 0xCC, 0xF0,
    0xC9, 0x92, 0xD7, 0x03, 0xDC, 0x79, 0xB8, 0xEA, 0xC5, 0x43, 0x8D, 0xA7, 0x7C, 0xF3, 0xC7, 0x44, 0xBE, 0xED, 0x57, 0xEF, 0xBE, 0xB6,
    0xBE, 0x88, 0x5A, 0xF8, 0x48, 0xF7, 0x7C, 0x69, 0x0A, 0xF5, 0x76, 0xB6, 0xE6, 0x27, 0x76, 0xA5, 0xB2, 0x47, 0x7D, 0x25, 0x7B, 0xEA,
    0x8A, 0x16, 0xF2, 0x3A, 0x6E, 0x9D, 0x42, 0xAD, 0xAD, 0x13, 0xF8, 0x5C, 0xE2, 0xE8, 0x45, 0x2C, 0x9B, 0x39, 0xB2, 0xA5, 0x58, 0x3B,
    0x45, 0x0A, 0xEB, 0x5E, 0xEB, 0x8C, 0xB6, 0x3C, 0xFE, 0xD4, 0x7C, 0x09, 0x2D, 0x00, 0xDA, 0x5D, 0xF9, 0xDA, 0x82, 0xA7, 0x4B, 0x62,
    0xEE, 0x16, 0xFE, 0x8E, 0xC4, 0xC8, 0x55, 0x2F, 0x4B, 0x52, 0x93, 0xB6, 0x3D, 0x5C, 0x92, 0x64, 0xA2, 0x25, 0x9F, 0xB9, 0xD6, 0x7B,
    0x7B, 0xAD, 0x27, 0xCA, 0xCA, 0x7C, 0x58, 0x5B, 0x45, 0x48, 0xBE, 0xA9, 0xA6, 0x2A, 0x52, 0x8B, 0xBB, 0x0E, 0xFB, 0x02, 0xA6, 0x50,
    0xEF, 0x0B, 0x32, 0x1F, 0x16, 0x1A, 0x6C, 0xBC, 0x44, 0xDB, 0xD6, 0x61, 0x7E, 0xBC, 0x92, 0x8C, 0x2B, 0xD3, 0x72, 0xEC, 0xDF, 0xDB,
    0xF6, 0xDE, 0x92, 0xEC, 0xBB, 0xC3, 0x55, 0x5A, 0x8E, 0xD6, 0x22, 0x77, 0x69, 0xF5, 0xF2, 0x22, 0xAD, 0xDE, 0x6E, 0xD3, 0x12, 0x27,
    0x38, 0x54, 0xAF, 0xA5, 0x76, 0x77, 0x54, 0x59, 0x5F, 0xA2, 0x8D, 0xAE, 0xA3, 0x3B, 0x5F, 0xDE, 0xA0, 0xDB, 0xCB, 0x41, 0xBF, 0xD1,
    0x46, 0xD7, 0xAC, 0x72, 0x32, 0xA6, 0xB5, 0x3E, 0xCD, 0x7C, 0x76, 0x33, 0xF2, 0x71, 0x29, 0xFB, 0x0D, 0x8E, 0x6F, 0xD2, 0x73, 0x44,
    0x6A, 0xBC, 0x2B, 0xA0, 0xC4, 0x03, 0x2D, 0xC8, 0xE4, 0x51, 0x1E, 0xAB, 0xE9, 0x55, 0x26, 0xBF, 0x1B, 0xC4, 0xFC, 0x29, 0xEC, 0xAF,
    0x62, 0xED, 0x5E, 0x4A, 0x70, 0x8D, 0x67, 0x5C, 0xD3, 0xEB, 0xA5, 0x26, 0x3E, 0x1F, 0xC5, 0xA9, 0x9E, 0x19, 0xB9, 0x57, 0xB6, 0x78,
    0xC9, 0x4A, 0x4C, 0xE1, 0x5E, 0xDF, 0x0D, 0x3E, 0x92, 0x5E, 0x3C, 0x55, 0xB2, 0xFD, 0x88, 0xD7, 0x24, 0x6F, 0x58, 0xF3, 0x13, 0xBA,
    0x35, 0xB9, 0x4E, 0xD4, 0xBC, 0xC3, 0x8D, 0x6B, 0xED, 0xC3, 0x7D, 0x63, 0xC7, 0xF3, 0xDE, 0xE8, 0x4D, 0x5E, 0x7A, 0xA7, 0xBC, 0x3C,
    0xA7, 0x6D, 0x3F, 0xE3, 0xA8, 0xD3, 0x4E, 0x94, 0x34, 0x70, 0x78, 0xD6, 0x62, 0x91, 0xD6, 0x99, 0x08, 0x2B, 0xDF, 0x71, 0xEA, 0x76,
    0x31, 0x59, 0x37, 0xFA, 0x34, 0xF9, 0xB5, 0xD3, 0x46, 0x55, 0xC9, 0xBE, 0xC8, 0x3A, 0x8F, 0x54, 0x77, 0x6D, 0x56, 0xD4, 0x34, 0xD9,
    0x9F, 0xFC, 0x05, 0xB9, 0xDC, 0x4F, 0xA9, 0x75, 0xA5, 0x6C, 0x5B, 0x3C, 0xC5, 0xEA, 0x46, 0x84, 0xDA, 0x5B, 0x7D, 0xDE, 0xE6, 0x49,
    0xCF, 0x57, 0x3C, 0x1B, 0x83, 0xA8, 0xB1, 0x74, 0x74, 0x22, 0x10, 0xEF, 0x96, 0xFD, 0x9B, 0x3D, 0xFD, 0x28, 0x6E, 0xEF, 0x68, 0x04,
    0x99, 0xD2, 0x1B, 0xF6, 0x4E, 0x48, 0x37, 0xB6, 0xC9, 0x76, 0x82, 0xDE, 0xB4, 0x54, 0x7F, 0x07, 0xBD, 0xEB, 0xCD, 0x42, 0x3E, 0x8B,
    0x6D, 0xBA, 0xAD, 0x66, 0x9B, 0x5A, 0x9B, 0x3C, 0x88, 0x96, 0x8A, 0xE2, 0x76, 0xBD, 0x12, 0xCF, 0xBC, 0x9B, 0x7D, 0x24, 0x7F, 0xB8,
    0x26, 0x6E, 0x57, 0xEB, 0xDC, 0x96, 0xD6, 0x9E, 0xBE, 0xB5, 0xCF, 0x11, 0xE7, 0xBA, 0x54, 0xBD, 0x9B, 0xED, 0x93, 0x20, 0xF9, 0x34,
    0x88, 0xB3, 0xBB, 0x87, 0x12, 0xE8, 0xE2, 0x9A, 0x28, 0x6B, 0x7E, 0x85, 0x9F, 0x61, 0x7A, 0xAB, 0x4A, 0xA9, 0x6E, 0x4A, 0x6E, 0xF1,
    0xE1, 0x77, 0xAA, 0x1C, 0xA5, 0xD3, 0x5A, 0x47, 0xB2, 0x6D, 0x4A, 0x84, 0x4A, 0x3B, 0x74, 0x0A, 0xF0, 0xE1, 0x65, 0x88, 0xE0, 0x63,
    0xD6, 0xA4, 0xC1, 0x6E, 0x42, 0x99, 0x87, 0x5E, 0x81, 0x87, 0x56, 0x7A, 0x78, 0xFE, 0xE7, 0xF8, 0xFD, 0x01, 0xF9, 0xBC, 0xC8, 0x1B,
    0x63, 0x51, 0xE6, 0x69, 0xEF, 0x11, 0xC1, 0xF1, 0xCE, 0x6F, 0x74, 0x1B, 0x1F, 0x6E, 0xA7, 0x20, 0xD2, 0x59, 0xA7, 0x12, 0xBC, 0xEC,
    0xDF, 0x60, 0x52, 0xCB, 0x83, 0x7D, 0xF9, 0xB4, 0x9D, 0x89, 0xC8, 0x3E, 0xF8, 0xBD, 0x43, 0xDF, 0x7E, 0xED, 0x75, 0x97, 0xBE, 0x36,
    0x2F, 0x32, 0x3A, 0xDD, 0x9A, 0x5B, 0x7D, 0x78, 0x89, 0x94, 0xD2, 0xAB, 0xDB, 0x2C, 0xBB, 0x96, 0x1F, 0xBC, 0xAD, 0xA7, 0xAC, 0x29,
    0x1A, 0x78, 0x9B, 0x7A, 0xDE, 0x28, 0x2D, 0xAD, 0x79, 0x53, 0xBE, 0x79, 0xA9, 0xFD, 0xED, 0x02, 0x2D, 0x7C, 0xC4, 0xDF, 0x74, 0xB6,
    0x54, 0x5F, 0x0B, 0x7A, 0xB7, 0xF5, 0x71, 0xE0, 0xD7, 0xC9, 0xBA, 0xC7, 0x68, 0xD5, 0x75, 0xB8, 0x92, 0x17, 0xBD, 0x83, 0x36, 0x90,
    0xF3, 0xA2, 0x4E, 0x7F, 0x1A, 0x7F, 0x7F, 0x40, 0x6E, 0x19, 0xBC, 0x75, 0xAD, 0xF0, 0xD6, 0x61, 0x3B, 0xB1, 0xFE, 0x88, 0xF7, 0x5D,
    0x4C, 0x1A, 0xF5, 0x0F, 0xF4, 0x7D, 0x5D, 0xB6, 0x03, 0x9D, 0x62, 0x75, 0x2E, 0x43, 0x6F, 0x9D, 0x2A, 0xD5, 0x71, 0x6E, 0x3B, 0x31,
    0xBF, 0x53, 0x3A, 0xF8, 0x7A, 0x82, 0x92, 0xCD, 0xB1, 0x5A, 0x1E, 0xD4, 0xA5, 0x14, 0x99, 0xB7, 0x6B, 0xF4, 0x85, 0x9C, 0x9D, 0x20,
    0x49, 0x72, 0x5A, 0xCB, 0x99, 0x71, 0xBB, 0x7D, 0x39, 0xF1, 0x85, 0x13, 0x77, 0xCA, 0x69, 0x9D, 0x0F, 0x2D, 0xB7, 0x12, 0xE4, 0x3C,
    0x78, 0x87, 0x8F, 0x49, 0xF5, 0x4E, 0xA9, 0x37, 0xF8, 0xA1, 0xDF, 0x57, 0x6F, 0xF3, 0x71, 0x7C, 0x4F, 0xA8, 0x97, 0x93, 0xFE, 0xE9,
    0x2A, 0x6D, 0x71, 0x43, 0x22, 0xBE, 0xE9, 0x45, 0x1C, 0x67, 0xB3, 0xAB, 0xBB, 0x79, 0x4F, 0x73, 0x40, 0xD9, 0x5B, 0xF5, 0xC2, 0x68,
    0x4F, 0x71, 0xF1, 0xCC, 0x2C, 0xEC, 0x0E, 0x79, 0xEF, 0x2D, 0x52, 0x9B, 0xF8, 0x4B, 0x6D, 0x72, 0xCF, 0x76, 0x3F, 0x0F, 0x4E, 0xFD,
    0xED, 0x4B, 0xFC, 0x5C, 0xA3, 0x1B, 0x23, 0x79, 0xF5, 0xB5, 0x3F, 0x2B, 0x0E, 0x72, 0x52, 0x1E, 0x57, 0xE9, 0x27, 0x4B, 0xA7, 0x24,
    0xAE, 0xCE, 0x0B, 0xEE, 0xF2, 0x89, 0xE1, 0xBA, 0x97, 0x70, 0xE9, 0xB6, 0xF7, 0xFF, 0x05, 0x4F, 0x1C, 0x37, 0xEA, 0x2F, 0x01, 0xB8,
    0x3B, 0x7E, 0x90, 0x57, 0xEA, 0x55, 0x99, 0x63, 0x64, 0xFA, 0x57, 0x6B, 0x0C, 0xC9, 0xF4, 0xD5, 0x67, 0x2F, 0xEF, 0xD0, 0xB7, 0x7D,
    0x83, 0xFE, 0x6A, 0xF0, 0x50, 0x6F, 0x6D, 0xF7, 0xDA, 0x5A, 0xBD, 0x0D, 0xDC, 0xA3, 0xAB, 0xED, 0x9E, 0x9E, 0xA7, 0xB4, 0x13, 0xAE,
    0x8A, 0x8C, 0xA1, 0x7D, 0x95, 0x75, 0x8F, 0xBE, 0x7C, 0x33, 0x4E, 0x6D, 0x74, 0x69, 0x93, 0xAF, 0x1D, 0xD1, 0x76, 0xE5, 0x96, 0xA4,
    0x67, 0xF4, 0x13, 0xBC, 0xA6, 0x8B, 0xD2, 0xC2, 0xE7, 0xEA, 0xCD, 0x79, 0xB6, 0xAF, 0x65, 0x78, 0xBB, 0x3C, 0x49, 0xD2, 0xBA, 0xA7,
    0x3C, 0xDA, 0xDC, 0xCB, 0xBB, 0x99, 0xEF, 0x09, 0x63, 0xAE, 0xDA, 0xBA, 0x6A, 0xE1, 0x5E, 0x5E, 0xA3, 0xF9, 0xFD, 0x07, 0x65, 0x2B,
    0x2F, 0xF7, 0xE8, 0xAB, 0xD7, 0xBA, 0x7B, 0xF5, 0x22, 0xD3, 0x15, 0xB7, 0xC4, 0xE5, 0xB7, 0xD5, 0xBC, 0xDF, 0x77, 0x92, 0x9B, 0x5E,
    0x00, 0x53, 0xDB, 0xF3, 0xB4, 0xEC, 0x42, 0xED, 0xD0, 0x44, 0x7A, 0xD7, 0xF6, 0x1F, 0x42, 0xBA, 0xD0, 0x66, 0x3D, 0xE8, 0x6A, 0x5F,
    0x15, 0x5A, 0x37, 0x45, 0x7F, 0x07, 0x5D, 0xA8, 0xED, 0x99, 0x59, 0xD2, 0x39, 0xA4, 0xB9, 0xA4, 0x63, 0xB2, 0xE6, 0x95, 0xD0, 0xF4,
    0xD6, 0xA1, 0xA7, 0x65, 0x48, 0xE3, 0x36, 0x4B, 0x09, 0x5E, 0xD0, 0xEF, 0x27, 0xBB, 0xE1, 0xBF, 0xC6, 0x31, 0x0D, 0xF1, 0x3E, 0x8E,
    0xF6, 0x5B, 0x69, 0x5D, 0xBB, 0xF9, 0xF0, 0x7B, 0x12, 0x8E, 0xD3, 0xA9, 0xD7, 0x31, 0x7A, 0x87, 0xF7, 0x86, 0x5D, 0x8D, 0xE3, 0x1B,
    0x2A, 0xE2, 0xCE, 0x69, 0x14, 0xE4, 0x2C, 0x52, 0xD2, 0x8D, 0xCA, 0xAF, 0x10, 0x87, 0xAB, 0xDA, 0xC6, 0xB7, 0xBC, 0x5F, 0xD6, 0x59,
    0xAA, 0xD1, 0x50, 0x2B, 0xAB, 0xF5, 0x1D, 0x0C, 0xD9, 0x66, 0x5D, 0xC9, 0x6F, 0x88, 0x7C, 0x6F, 0xC7, 0x1D, 0x7A, 0x8E, 0xCE, 0xC9,
    0xD5, 0xE9, 0xA5, 0xF0, 0xF9, 0x52, 0xBC, 0x3B, 0x1D, 0x65, 0xD3, 0x33, 0xAD, 0x77, 0xBA, 0x1D, 0x1F, 0xF0, 0xE1, 0x3E, 0xB1, 0xA2,
    0x9A, 0x5E, 0xB6, 0x36, 0x4B, 0x1E, 0x44, 0xD3, 0xA4, 0x37, 0x1C, 0x8D, 0x92, 0x6F, 0x2D, 0xAD, 0xF7, 0x4E, 0x6C, 0xF9, 0x3B, 0xD3,
    0x84, 0x5A, 0xE7, 0xA3, 0xE0, 0x01, 0x61, 0x9F, 0xE8, 0xFC, 0xDC, 0x4E, 0xBD, 0x5D, 0xD0, 0xBF, 0x81, 0x9E, 0x5B, 0xFC, 0x58, 0xE7,
    0xDA, 0x79, 0xDF, 0xE8, 0xD4, 0x5D, 0xD8, 0xAF, 0xD9, 0x52, 0xD0, 0xE6, 0x97, 0x8A, 0xBE, 0x53, 0x6E, 0x6F, 0xB1, 0x25, 0x3C, 0x5E,
    0xE0, 0xB7, 0xB3, 0x3C, 0x14, 0x74, 0x17, 0xEB, 0x97, 0x75, 0x7C, 0x2D, 0x3C, 0x2D, 0xFC, 0x54, 0xD7, 0xD5, 0xB7, 0x12, 0xDA, 0xF6,
    0x10, 0xEB, 0x8D, 0x4C, 0x21, 0x56, 0xF2, 0x8D, 0xA1, 0xAE, 0x63, 0x8E, 0x92, 0x2C, 0x4E, 0xE9, 0x6B, 0x6A, 0xC9, 0x8A, 0xF5, 0x9B,
    0xD9, 0x43, 0xB6, 0x3B, 0x30, 0xF1, 0xB9, 0x45, 0x4E, 0xE1, 0x2E, 0x9F, 0x54, 0x08, 0x95, 0xE6, 0x5A, 0x99, 0x9F, 0x73, 0xBA, 0x29,
    0xD2, 0x4A, 0x60, 0x71, 0xA1, 0x97, 0xE8, 0x74, 0xC3, 0x7B, 0x8A, 0x35, 0x34, 0x91, 0xDF, 0xCE, 0x11, 0xFD, 0x5C, 0xAD, 0x0C, 0xF4,
    0x7D, 0x79, 0x7B, 0xCD, 0xB6, 0xF5, 0xC8, 0x96, 0xDF, 0x99, 0x57, 0xA7, 0x25, 0xF4, 0x24, 0x8E, 0x69, 0x06, 0xB9, 0x44, 0x13, 0xDF,
    0xA9, 0xEF, 0xAF, 0x58, 0xF6, 0xA1, 0x0F, 0xFA, 0xE8, 0xFC, 0x79, 0x1B, 0x8A, 0xB8, 0x6A, 0xE5, 0x46, 0xBA, 0x53, 0x9A, 0xE6, 0xA1,
    0x34, 0x0D, 0x3E, 0xBB, 0x8B, 0x1E, 0x14, 0x75, 0x4C, 0x63, 0xBB, 0xCE, 0x4B, 0x7D, 0x6F, 0x29, 0xBF, 0x67, 0xAD, 0x4C, 0x53, 0xFD,
    0x4D, 0xB6, 0xB0, 0x40, 0x1F, 0xC9, 0x9F, 0x90, 0x1C, 0x57, 0x7D, 0xCC, 0xA6, 0x49, 0xB3, 0x95, 0xBC, 0xC3, 0x08, 0x56, 0xA0, 0x5F,
    0x16, 0x28, 0xEB, 0xD7, 0x68, 0x7C, 0xAD, 0x3C, 0xD8, 0x5D, 0xAA, 0x08, 0xA7, 0x67, 0xAE, 0xB6, 0x3A, 0xCF, 0xEE, 0x41, 0x3E, 0xBC,
    0x47, 0xD2, 0x79, 0x30, 0xAD, 0xE9, 0x86, 0xAC, 0xBC, 0x03, 0x72, 0xFC, 0x4E, 0xAD, 0xF3, 0x7C, 0xD0, 0x33, 0x71, 0xED, 0x7A, 0x45,
    0xB9, 0x1F, 0x68, 0xA1, 0xEB, 0x8C, 0x8A, 0x32, 0x8D, 0x68, 0xFE, 0xFA, 0x39, 0x5A, 0x85, 0x6A, 0x3B, 0xB1, 0x1B, 0xA1, 0x97, 0xF7,
    0x19, 0x34, 0xB5, 0x5A, 0x3D, 0x44, 0x4B, 0x96, 0xAD, 0x22, 0x54, 0xCF, 0xB9, 0x4E, 0x57, 0xD2, 0xC4, 0x87, 0xA6, 0x50, 0xE7, 0x93,
    0xD2, 0xF4, 0x02, 0x90, 0x38, 0x59, 0x32, 0xF2, 0xB3, 0x1D, 0x85, 0xF5, 0xBF, 0x97, 0xB0, 0xFF, 0x11, 0xF1, 0x5C, 0xA7, 0x6F, 0x92,
    0xEE, 0xCB, 0xA9, 0xC9, 0x97, 0x0B, 0x7A, 0xC9, 0xFB, 0x1B, 0x0B, 0x7F, 0x1B, 0x94, 0xA6, 0x52, 0x1E, 0xDF, 0xF6, 0x3C, 0x2D, 0x52,
    0x99, 0xD4, 0x4E, 0x0A, 0x07, 0xEE, 0xD4, 0x29, 0xD8, 0x36, 0x39, 0xA7, 0x2B, 0xDF, 0xA9, 0x50, 0x6A, 0x1F, 0x57, 0x69, 0xA7, 0xAA,
    0xCC, 0x48, 0x05, 0xBD, 0x45, 0x3B, 0x88, 0x78, 0x6A, 0xED, 0x10, 0x23, 0xD9, 0xA5, 0x18, 0xF8, 0xFE, 0x4D, 0x78, 0xB3, 0x90, 0xDF,
    0x69, 0x8A, 0xE3, 0x78, 0x94, 0xE4, 0xC3, 0x47, 0xDC, 0x67, 0x54, 0xD6, 0x93, 0x74, 0xEA, 0x23, 0xE4, 0x1F, 0x67, 0x54, 0xB5, 0xED,
    0xB3, 0x62, 0xF8, 0x8C, 0x41, 0x6D, 0x79, 0xB4, 0xF9, 0xD2, 0xB1, 0xEE, 0x8F, 0x45, 0x7D, 0xC4, 0xDA, 0x6D, 0x4B, 0x4D, 0xB9, 0x8F,
    0x38, 0x7E, 0xED, 0xBB, 0x07, 0x7F, 0xF3, 0x32, 0x42, 0x92, 0xF9, 0xD3, 0x14, 0x6F, 0xB1, 0xCA, 0xEF, 0x86, 0x3B, 0xA3, 0x9F, 0x24,
    0x95, 0x49, 0xFE, 0x0B, 0xE5, 0x2D, 0x95, 0xFB, 0x7F, 0x7D, 0x7D, 0x74, 0xDD, 0x79, 0x79, 0xEC, 0xD3, 0xC9, 0xBE, 0xE3, 0x4C, 0xD2,
    0x8B, 0x2D, 0x6A, 0x65, 0x94, 0xF3, 0xA0, 0x45, 0xE6, 0xBA, 0x02, 0x7C, 0x3B, 0xF2, 0x7B, 0x11, 0xC9, 0xDC, 0x47, 0xB8, 0x48, 0xAB,
    0x55, 0xF6, 0x8A, 0xE1, 0x5F, 0x91, 0xDC, 0x67, 0xB4, 0x72, 0xF9, 0xC2, 0xFA, 0x09, 0xB9, 0x40, 0x8E, 0xAB, 0xAC, 0x53, 0x90, 0xE9,
    0x9A, 0x25, 0x5F, 0x77, 0xCA, 0x76, 0x78, 0xA5, 0xFD, 0x64, 0x7B, 0x7C, 0x8C, 0xAF, 0x25, 0xDF, 0x29, 0xD2, 0x7B, 0xE4, 0x6A, 0xF6,
    0x88, 0x1D, 0x82, 0x05, 0x7D, 0x1A, 0x5F, 0x9D, 0xBE, 0x3C, 0xE7, 0xCB, 0x31, 0xE2, 0xAD, 0x50, 0x45, 0xFB, 0xC7, 0x60, 0xA1, 0xC3,
    0xB0, 0xA7, 0xA2, 0x3E, 0xB6, 0xEC, 0xF9, 0x26, 0xF3, 0xD1, 0x11, 0xA1, 0xF4, 0xA6, 0x67, 0xB0, 0xD2, 0xBD, 0xB9, 0x18, 0xDE, 0xFB,
    0xE4, 0x5A, 0x9A, 0xCA, 0xEF, 0x98, 0x29, 0xFB, 0x31, 0x1C, 0xDE, 0x5F, 0xD4, 0x17, 0x4D, 0xA9, 0x5C, 0x5F, 0xB1, 0x56, 0xD6, 0x77,
    0xF4, 0x16, 0x16, 0x9D, 0x6B, 0xDC, 0xD7, 0x13, 0x58, 0xD3, 0x97, 0x6D, 0xF7, 0x84, 0x97, 0x7C, 0x4B, 0xD3, 0xF8, 0x52, 0xD3, 0xBE,
    0x75, 0x1A, 0x20, 0xC6, 0xA8, 0x72, 0x7A, 0x2D, 0xF6, 0x7F, 0xD6, 0xF9, 0x49, 0xE3, 0x77, 0xF7, 0xD0, 0xA2, 0x30, 0x5C, 0xC5, 0x43,
    0x76, 0x21, 0xE4, 0x83, 0xD9, 0xA9, 0x3B, 0x4E, 0xE7, 0x0E, 0x7F, 0x6D, 0xDA, 0xF8, 0x4E, 0x0F, 0x89, 0x7E, 0x42, 0xE3, 0x27, 0xF3,
    0xF6, 0x55, 0xEB, 0x97, 0xB2, 0x9C, 0x2D, 0xBF, 0x9A, 0x6A, 0x54, 0xB5, 0xAE, 0x59, 0xB3, 0x4B, 0xA7, 0xD0, 0x27, 0x65, 0x7A, 0x51,
    0xDC, 0x92, 0x3C, 0x52, 0xB2, 0xC0, 0x54, 0x7B, 0x3F, 0xD2, 0x15, 0x9A, 0xCE, 0x2C, 0x6D, 0xB4, 0xD2, 0x88, 0xE6, 0x3E, 0x8A, 0xC3,
    0x55, 0xE7, 0x7D, 0xAD, 0xF4, 0xEC, 0xF7, 0x17, 0xBD, 0xDC, 0xA0, 0xC3, 0xD6, 0xD6, 0x58, 0x6E, 0x75, 0x1C, 0xE5, 0x96, 0xAF, 0x43,
    0x5B, 0x7A, 0xB8, 0xD6, 0x78, 0x96, 0x2F, 0x11, 0x1A, 0xA5, 0xD3, 0x44, 0xA5, 0x7C, 0x15, 0x3C, 0x2C, 0xE4, 0x5D, 0xEB, 0x14, 0x5A,
    0xFB, 0x9F, 0xFD, 0xCE, 0xC2, 0xF9, 0xAE, 0xBE, 0xAF, 0x1B, 0xE5, 0xB0, 0xA7, 0x9F, 0x2C, 0xDD, 0xF8, 0xD3, 0x62, 0x13, 0xAD, 0x8D,
    0x47, 0x82, 0xE4, 0xF9, 0xCE, 0x91, 0x8C, 0xA4, 0x77, 0x83, 0x9E, 0xBA, 0x67, 0x27, 0xAD, 0x74, 0x4C, 0x52, 0xF9, 0x3D, 0x2F, 0xA3,
    0xF6, 0xB7, 0xD8, 0xB4, 0xD1, 0x33, 0x35, 0x59, 0xC8, 0x2A, 0xE9, 0x7E, 0x95, 0xF7, 0xFA, 0x48, 0x2B, 0x56, 0xE5, 0x3C, 0x40, 0x5B,
    0x9E, 0x52, 0x55, 0x7D, 0x98, 0xAB, 0xD1, 0x31, 0xF0, 0x37, 0x58, 0x84, 0x4F, 0xAB, 0xE9, 0x56, 0xF7, 0x07, 0x1C, 0xCF, 0xE7, 0xB6,
    0xFB, 0xF8, 0x86, 0xC1, 0x42, 0x97, 0x2A, 0x53, 0xC2, 0x54, 0x5A, 0xED, 0x72, 0x63, 0x25, 0x4D, 0x74, 0xBC, 0x1B, 0x9A, 0x45, 0x9D,
    0xCE, 0xF2, 0xA8, 0xD0, 0x89, 0x20, 0x15, 0x2D, 0xFC, 0xE4, 0x97, 0xB6, 0x5C, 0xE7, 0x57, 0x4B, 0xF8, 0x09, 0x2A, 0xEA, 0xFC, 0x92,
    0xA5, 0xF9, 0x97, 0x85, 0xFD, 0x80, 0xA2, 0x12, 0xFD, 0x90, 0x21, 0xB2, 0x8E, 0x47, 0x8E, 0xAD, 0x95, 0x7E, 0xBC, 0xEA, 0x99, 0xCE,
    0x9A, 0x21, 0x42, 0x7E, 0x96, 0x63, 0xAA, 0xAD, 0xEF, 0x82, 0x5A, 0xB2, 0xB4, 0x56, 0x2B, 0xBF, 0x5F, 0xDD, 0x38, 0x44, 0xBE, 0x5F,
    0x90, 0x66, 0x77, 0x2B, 0xCA, 0x31, 0xFD, 0x38, 0x6E, 0xBB, 0x16, 0xC7, 0x57, 0x5D, 0x83, 0x34, 0x7B, 0x38, 0xBE, 0x99, 0xEB, 0xDA,
    0xBA, 0x22, 0xF7, 0x3B, 0xF4, 0x6C, 0x27, 0x7C, 0x64, 0xD9, 0x5A, 0x61, 0x0B, 0x2B, 0xFA, 0x38, 0xE9, 0x75, 0x2C, 0xB5, 0xFD, 0xBD,
    0x6C, 0x87, 0xEE, 0x19, 0x4F, 0x99, 0x9B, 0xED, 0xDC, 0xA4, 0x6E, 0x87, 0xEC, 0x2D, 0xFE, 0xF2, 0x4D, 0xAD, 0x28, 0x62, 0x25, 0xAC,
    0xB4, 0x2F, 0x52, 0xB6, 0x49, 0x8F, 0xE3, 0xFB, 0xED, 0x68, 0xE9, 0x94, 0x53, 0xB6, 0xD9, 0xB2, 0xF7, 0xB0, 0x65, 0x4D, 0xB5, 0xE5,
    0x27, 0x4A, 0x7B, 0x05, 0x2D, 0x34, 0xF5, 0x76, 0xBA, 0xDC, 0xBA, 0x2A, 0x1F, 0x85, 0x3D, 0xB5, 0x12, 0xCD, 0x44, 0x49, 0x4F, 0xC4,
    0xEA, 0x62, 0x8A, 0x62, 0x5D, 0x14, 0x7E, 0xEC, 0xA3, 0x70, 0xB7, 0x53, 0x89, 0x87, 0xF3, 0x77, 0x84, 0x6C, 0xE5, 0x4B, 0x63, 0x95,
    0x76, 0x1E, 0x74, 0x8F, 0x93, 0xC2, 0xB5, 0x12, 0x42, 0x96, 0xB6, 0x9F, 0xCB, 0x9D, 0x97, 0xA9, 0xD3, 0x27, 0x62, 0xEF, 0x7E, 0x35,
    0xF8, 0x39, 0x3A, 0x4F, 0x74, 0x85, 0x5F, 0x1C, 0xF7, 0xEC, 0xE0, 0x7C, 0x54, 0x18, 0x9F, 0x14, 0x73, 0x65, 0x0A, 0x7F, 0xE9, 0x30,
    0x56, 0x83, 0x0C, 0x67, 0x4B, 0x3F, 0x85, 0x5B, 0x18, 0x24, 0x5B, 0xBD, 0xFD, 0xEC, 0x9C, 0x5F, 0xCD, 0x93, 0xA2, 0x6D, 0x04, 0x35,
    0xC7, 0xA9, 0xD5, 0xE6, 0x3C, 0x5B, 0xFE, 0x46, 0x29, 0x75, 0x0C, 0xEF, 0x1F, 0x09, 0xCA, 0xF7, 0xC8, 0x87, 0x8A, 0xB5, 0x16, 0xF9,
    0xDB, 0xA6, 0x56, 0x2B, 0x7F, 0xBC, 0xF4, 0x16, 0x9E, 0x7C, 0xE2, 0xEA, 0xA9, 0xFD, 0x54, 0x3C, 0xB7, 0xA2, 0x56, 0xEA, 0xCF, 0x01,
    0xC3, 0x44, 0x1B, 0x89, 0x98, 0xCC, 0x16, 0x44, 0x2D, 0x8F, 0x53, 0x24, 0xD9, 0x37, 0x5A, 0x7A, 0x11, 0xCD, 0xB1, 0x67, 0x55, 0xA7,
    0x77, 0x74, 0x62, 0x94, 0xE6, 0x2B, 0x7B, 0xDA, 0x51, 0xD2, 0x1C, 0x6C, 0x91, 0x5E, 0x23, 0x52, 0xAA, 0x09, 0x57, 0x69, 0x47, 0xF3,
    0x7E, 0x90, 0xA2, 0xA9, 0x6F, 0xB9, 0x4E, 0xDB, 0xC4, 0x65, 0x17, 0x93, 0xF4, 0x4A, 0x5F, 0x94, 0xC3, 0xF7, 0x28, 0x1D, 0xF3, 0xA0,
    0x7F, 0x17, 0x3F, 0x25, 0xEB, 0x40, 0xE5, 0xD7, 0x26, 0xC4, 0xBB, 0x21, 0xCA, 0xFD, 0xD8, 0x3E, 0x3F, 0x8E, 0x76, 0x12, 0x9E, 0xD6,
    0x9F, 0xF0, 0x7A, 0xA3, 0x3C, 0x9F, 0x79, 0xCA, 0xC3, 0xF6, 0x6E, 0xAB, 0x78, 0xA9, 0xD8, 0xA4, 0x7A, 0x47, 0x54, 0xF9, 0x9E, 0xBF,
    0x3A, 0x1F, 0x67, 0x23, 0xC6, 0x75, 0xBA, 0x26, 0x5E, 0x4B, 0xD1, 0x5C, 0xAF, 0xE8, 0xBD, 0xFE, 0x35, 0x95, 0x4B, 0x7F, 0x26, 0xEE,
    0x73, 0x48, 0x51, 0x3E, 0x70, 0x91, 0xAE, 0x92, 0xAF, 0x6D, 0x4F, 0xDB, 0xD2, 0x2C, 0xE9, 0xB6, 0x23, 0xA4, 0x77, 0x49, 0xA3, 0xBC,
    0xDC, 0x1F, 0x2D, 0x92, 0xB7, 0x28, 0xB3, 0x24, 0x67, 0x45, 0xAB, 0xF8, 0x6E, 0x74, 0x95, 0x7E, 0x32, 0x3F, 0x19, 0xC3, 0xD7, 0x7B,
    0xE8, 0x3D, 0x38, 0x6F, 0xF2, 0xB1, 0x7E, 0x17, 0x09, 0x67, 0x12, 0xF9, 0xC5, 0x20, 0x93, 0x06, 0x9F, 0x04, 0xDA, 0x79, 0x52, 0x3F,
    0x7D, 0xB4, 0xAF, 0x3A, 0x7B, 0x91, 0xB5, 0xD7, 0xFF, 0x01, 0x1F, 0xBD, 0xCB, 0xE3, 0x23, 0x9E, 0x4B, 0xCE, 0x53, 0xC8, 0x5D, 0x58,
    0x71, 0x6B, 0x3D, 0x86, 0xDF, 0xBF, 0x71, 0x77, 0xFD, 0x34, 0x38, 0xD0, 0xEE, 0x59, 0xD7, 0xF3, 0xE8, 0x11, 0x62, 0xCF, 0x26, 0xC7,
    0x54, 0x9E, 0x97, 0x0D, 0x3C, 0x37, 0x71, 0x56, 0xED, 0x17, 0x2E, 0xAD, 0x9A, 0x26, 0xDE, 0x7B, 0x95, 0xCE, 0xA5, 0xCA, 0x46, 0x08,
    0xB9, 0xDC, 0x3E, 0x8D, 0xDA, 0x9A, 0x9D, 0x40, 0xDE, 0x2C, 0xB4, 0x7E, 0x09, 0xC1, 0xA9, 0xFF, 0xBB, 0xE7, 0xD1, 0x97, 0x96, 0x51,
    0x9A, 0x0F, 0x92, 0xA1, 0x0D, 0x95, 0xCB, 0x97, 0x20, 0xBD, 0x2D, 0x13, 0xCE, 0xA5, 0x82, 0x14, 0x15, 0xFD, 0x63, 0xB6, 0xC4, 0x43,
    0xC4, 0x14, 0x2B, 0x14, 0x95, 0x40, 0xD4, 0x79, 0xC8, 0x6F, 0xFB, 0x46, 0x36, 0xCD, 0xDF, 0x3D, 0x78, 0x0F, 0x48, 0xB6, 0x3A, 0x6F,
    0x75, 0xAF, 0xED, 0xC5, 0xDB, 0x8B, 0x54, 0xA6, 0x96, 0x5F, 0x69, 0x11, 0x79, 0xF5, 0xC4, 0xBF, 0x89, 0xA0, 0xCD, 0x5E, 0x76, 0x52,
    0xB2, 0x27, 0x29, 0x1A, 0x29, 0x64, 0xB3, 0x04, 0x7E, 0xCA, 0x12, 0xA3, 0xC1, 0x9E, 0xC4, 0xDE, 0xEE, 0x5E, 0xAC, 0x97, 0x66, 0x49,
    0x12, 0x51, 0xF7, 0x0B, 0xD3, 0x69, 0x94, 0xE8, 0x63, 0xAE, 0xEB, 0x89, 0xEC, 0x79, 0xBB, 0xE7, 0x29, 0x5D, 0x3B, 0x7D, 0xFB, 0x3C,
    0x3A, 0x1F, 0x3B, 0x72, 0xB9, 0x3C, 0xA7, 0xAD, 0xBF, 0x8A, 0xB4, 0xED, 0x7D, 0xB2, 0x78, 0x8F, 0x76, 0x6F, 0x8F, 0x69, 0x53, 0xEF,
    0xC8, 0xCA, 0x75, 0xEF, 0x8A, 0x5F, 0x19, 0x77, 0xF9, 0xE8, 0x5D, 0xE6, 0x93, 0xC0, 0xEB, 0x47, 0xD9, 0x67, 0x6A, 0x68, 0x89, 0x4E,
    0xB1, 0x4E, 0x12, 0x24, 0x4C, 0xBC, 0x20, 0xE9, 0x9C, 0x92, 0x61, 0xAC, 0x38, 0xC3, 0xC0, 0xB8, 0x5A, 0xF6, 0x56, 0x09, 0x92, 0xF6,
    0x29, 0x5A, 0xB3, 0x6F, 0x8C, 0x2A, 0xE0, 0xE3, 0x27, 0xCD, 0x11, 0x6A, 0xF3, 0xA6, 0x78, 0x65, 0x3E, 0x81, 0x6B, 0x45, 0xD5, 0xAC,
    0x8E, 0xBA, 0xBF, 0x20, 0xF2, 0x6F, 0x1D, 0x5F, 0x3D, 0xFF, 0x49, 0x92, 0x06, 0x3E, 0x51, 0xC3, 0xFD, 0x70, 0x61, 0x03, 0xA1, 0x7C,
    0x4A, 0xA5, 0x7C, 0x6F, 0xCD, 0x75, 0x7E, 0x9E, 0xDF, 0x25, 0x76, 0x8D, 0xA7, 0x6C, 0x01, 0x91, 0xA8, 0x41, 0x9E, 0x96, 0xEF, 0x65,
    0x38, 0xE3, 0x6B, 0xE4, 0xF9, 0x4E, 0x90, 0xF6, 0x81, 0xE2, 0x64, 0x2C, 0x5A, 0x92, 0xA6, 0x52, 0x24, 0x79, 0xDA, 0x24, 0x69, 0xCC,
    0xD5, 0x3C, 0xB7, 0xF9, 0xBD, 0x28, 0x78, 0x09, 0xAA, 0x5A, 0xCE, 0x93, 0x13, 0xB8, 0x06, 0x43, 0x2E, 0x31, 0x7A, 0x6B, 0xD4, 0xEA,
    0x9D, 0x03, 0xEA, 0xF5, 0x45, 0x59, 0xA6, 0xB0, 0xA6, 0xA4, 0xC6, 0x57, 0xBC, 0xD6, 0xE4, 0x0D, 0xBF, 0xAD, 0x32, 0x2D, 0x65, 0x3D,
    0x7C, 0xD7, 0xF1, 0xA2, 0xFD, 0x45, 0x6C, 0xB9, 0xC7, 0x68, 0xAB, 0x23, 0x99, 0xBE, 0x59, 0xC5, 0xA3, 0x86, 0xCC, 0xC3, 0x39, 0x9D,
    0x78, 0x69, 0x6E, 0x34, 0x2B, 0x4A, 0x1A, 0x55, 0xE3, 0xC5, 0x9C, 0x27, 0x52, 0xA8, 0x8F, 0x4F, 0xE1, 0x7F, 0x0E, 0x5F, 0x6A, 0x54,
    0x7B, 0xBB, 0xAA, 0xF7, 0x04, 0xB9, 0xCD, 0xAC, 0x53, 0xAA, 0xD7, 0x43, 0x3C, 0xB7, 0xFB, 0xEF, 0xA1, 0xC1, 0x6E, 0x36, 0x77, 0x02,
    0xCE, 0x95, 0x22, 0x95, 0x96, 0xB9, 0x52, 0x7E, 0x6F, 0x3A, 0x92, 0xCF, 0x50, 0x46, 0x15, 0xBD, 0x43, 0xE3, 0x04, 0xA1, 0xD7, 0x8C,
    0x94, 0xD6, 0x14, 0x0B, 0xDF, 0xE7, 0xDA, 0xDF, 0xF4, 0x50, 0xE6, 0x15, 0xC7, 0x3D, 0x93, 0x19, 0x89, 0x15, 0x99, 0xDA, 0xC9, 0x80,
    0x25, 0x54, 0xD4, 0x1F, 0x4D, 0x99, 0x46, 0x4E, 0xA5, 0x94, 0xF9, 0xC5, 0x73, 0xC9, 0x4D, 0x8D, 0x87, 0xB2, 0xBD, 0x9A, 0x4C, 0x4B,
    0x84, 0x11, 0xD2, 0x4E, 0x49, 0xD1, 0xFF, 0xD5, 0x4B, 0xF4, 0xFE, 0x81, 0x9C, 0x42, 0x6B, 0x7B, 0x88, 0x50, 0x8B, 0xB7, 0xE0, 0xEC,
    0x97, 0x44, 0xDD, 0xD8, 0xA6, 0xD0, 0x56, 0x37, 0x6C, 0x6F, 0x17, 0xA5, 0x6A, 0x39, 0xD6, 0xF0, 0x92, 0x6C, 0xA7, 0x1F, 0xC5, 0x75,
    0x68, 0xEA, 0x76, 0x4A, 0xB6, 0xEF, 0x98, 0xBB, 0x2B, 0xAF, 0x26, 0x4A, 0x5A, 0x4B, 0x65, 0x79, 0x23, 0x67, 0xA2, 0x90, 0xF1, 0x31,
    0xB6, 0x9A, 0xBF, 0x04, 0x11, 0x13, 0x67, 0x7D, 0x7C, 0x21, 0xD8, 0xFA, 0x17, 0xE5, 0xBD, 0x85, 0xDF, 0x24, 0x21, 0xFB, 0xD9, 0xA7,
    0xD1, 0xD6, 0xCE, 0xF2, 0x79, 0x8C, 0xBC, 0xC7, 0x8A, 0xE7, 0x5E, 0x1F, 0x0D, 0xE4, 0xEC, 0xD6, 0xB3, 0x7A, 0xB3, 0xA5, 0x9F, 0xC0,
    0x29, 0x5F, 0x1D, 0xDA, 0x89, 0xFC, 0x94, 0x3E, 0xBE, 0x69, 0xD6, 0x16, 0xB5, 0x11, 0xE1, 0xC1, 0x3A, 0xE3, 0x98, 0x8F, 0x89, 0xEB,
    0x38, 0x84, 0xF7, 0x7B, 0xAD, 0xEF, 0x1D, 0x17, 0x87, 0x89, 0x3B, 0x59, 0xB6, 0x6F, 0x65, 0x5B, 0xEF, 0x4B, 0x7B, 0x12, 0xDA, 0x66,
    0x4D, 0xFD, 0xDB, 0x36, 0x6F, 0xB2, 0x4E, 0x2B, 0x4A, 0xA5, 0xBF, 0x86, 0x84, 0xFB, 0xE8, 0x9E, 0x70, 0x90, 0x1F, 0x47, 0x54, 0x7B,
    0xDA, 0x79, 0x77, 0x94, 0xCF, 0x3D, 0xDD, 0xEB, 0x63, 0xA9, 0xD2, 0xAB, 0xED, 0x6A, 0xB6, 0xA2, 0x75, 0xE1, 0xF2, 0xFD, 0x56, 0x8C,
    0xEF, 0x4E, 0x9D, 0xA4, 0x4A, 0x3B, 0x13, 0x23, 0xEF, 0x17, 0xCA, 0xFD, 0x2E, 0x34, 0x82, 0xFA, 0xBD, 0xC7, 0x34, 0xEE, 0xF1, 0x35,
    0x48, 0x32, 0x95, 0xB2, 0xD5, 0x6A, 0x65, 0x84, 0x2C, 0xA3, 0xD3, 0xF8, 0xEE, 0xD6, 0xAD, 0x41, 0xD2, 0x9D, 0x3A, 0x3B, 0x09, 0xF5,
    0xBC, 0xFF, 0x0B, 0x5B, 0x46, 0x67, 0x7D, 0xC2, 0x13, 0x5E, 0xF2, 0x0D, 0x2C, 0xE7, 0x5A, 0x3F, 0xBD, 0x93, 0xFB, 0x5B, 0xCE, 0x68,
    0xC6, 0xF0, 0xF6, 0x16, 0xBE, 0xBE, 0xD4, 0xDE, 0x14, 0x19, 0x17, 0x25, 0xDA, 0x1E, 0x63, 0x5B, 0x5B, 0x9E, 0x38, 0xE3, 0x61, 0xE1,
    0xA7, 0xFC, 0xE1, 0x76, 0x2F, 0xE6, 0xDA, 0xBE, 0xCD, 0x1C, 0xDE, 0xF4, 0x1E, 0x30, 0xD5, 0x95, 0x0A, 0x2B, 0xDD, 0x64, 0x8F, 0xEE,
    0x5E, 0x6B, 0xCF, 0x83, 0x33, 0x3F, 0x71, 0x7A, 0x37, 0xF9, 0x19, 0x1D, 0xBC, 0x14, 0x6C, 0xCB, 0xD3, 0x99, 0x37, 0x50, 0xDB, 0xF1,
    0x5E, 0x1D, 0x2D, 0xCB, 0x2B, 0x94, 0xBA, 0xFA, 0x38, 0xB0, 0x48, 0x92, 0x90, 0x6C, 0xB1, 0x6A, 0x56, 0xB9, 0xF3, 0x37, 0x38, 0x46,
    0xB6, 0x41, 0xC7, 0xF8, 0xCA, 0x36, 0xEE, 0xC8, 0x23, 0x4A, 0x93, 0x26, 0x52, 0x3D, 0xAF, 0xB2, 0x1D, 0x97, 0xB8, 0xA7, 0xAC, 0xBE,
    0xE7, 0x6A, 0x88, 0x11, 0xFB, 0x0C, 0x47, 0xE9, 0xB4, 0xE6, 0x7D, 0x4A, 0x93, 0xD4, 0x1C, 0xAF, 0xE9, 0x8D, 0xF7, 0xB8, 0x58, 0x31,
    0x1E, 0x44, 0xAA, 0x04, 0xBE, 0x46, 0x89, 0xBD, 0x93, 0x56, 0x7E, 0x66, 0xE9, 0x25, 0x38, 0x93, 0x83, 0xB9, 0x21, 0xC8, 0xAD, 0x7A,
    0x9B, 0xC2, 0xEF, 0xFA, 0x2B, 0x9D, 0xDE, 0x6B, 0xA3, 0x63, 0x7D, 0x76, 0x21, 0xFB, 0x2B, 0x4C, 0x90, 0xEE, 0x49, 0x9B, 0x3C, 0x78,
    0x0B, 0x12, 0x79, 0x88, 0x1B, 0x51, 0x06, 0xE9, 0xE6, 0x90, 0xC1, 0x2B, 0x34, 0x95, 0xFD, 0x2C, 0x7A, 0x4E, 0xDF, 0xA2, 0xE2, 0x45,
    0x26, 0x3D, 0x5E, 0xE8, 0xA9, 0x2C, 0xDC, 0x0A, 0x42, 0x5B, 0x3F, 0xB0, 0x48, 0xAF, 0xA3, 0x28, 0xCD, 0x70, 0x21, 0x9F, 0xF8, 0x68,
    0xCA, 0x5F, 0x72, 0xD3, 0x59, 0x81, 0x73, 0x5A, 0x1D, 0x27, 0xE3, 0x3C, 0x92, 0xD4, 0x94, 0x3F, 0x75, 0x79, 0x5C, 0xE6, 0x91, 0xC2,
    0x6F, 0x7C, 0x1B, 0xBC, 0x32, 0xCE, 0x53, 0xF8, 0x2F, 0xCA, 0xD2, 0x6E, 0x65, 0x95, 0xD2, 0xDD, 0x66, 0xA4, 0x95, 0xCA, 0x7B, 0x26,
    0x3D, 0x8B, 0x53, 0xD0, 0x93, 0x4F, 0x91, 0x7D, 0x6B, 0xD8, 0xA6, 0xD1, 0x52, 0x0F, 0xA8, 0xF7, 0x88, 0xE4, 0x3D, 0x2C, 0x5A, 0x71,
    0xDF, 0x9A, 0xB5, 0x4F, 0xA7, 0xB8, 0x06, 0x5B, 0xD3, 0x8B, 0x93, 0x5E, 0xB9, 0x90, 0xCF, 0x78, 0xB5, 0xD9, 0x04, 0xB9, 0xC2, 0x43,
    0xDC, 0x0A, 0x90, 0xDF, 0xBB, 0x37, 0x4B, 0xB7, 0x34, 0xD3, 0xBC, 0x56, 0x86, 0x28, 0x95, 0xFE, 0xE7, 0x1A, 0x2D, 0xF1, 0x9E, 0x1D,
    0xF3, 0xB9, 0x6F, 0xEF, 0x61, 0x43, 0xEF, 0x01, 0x5D, 0x7B, 0x6D, 0x8D, 0xED, 0x1A, 0xEF, 0x0A, 0xBD, 0x58, 0x3B, 0x5D, 0x5B, 0x90,
    0x97, 0x68, 0xE9, 0x3D, 0xAA, 0x3F, 0x6B, 0x5A, 0xBD, 0x3C, 0xCA, 0x97, 0xF0, 0x4A, 0x1D, 0xC1, 0x7D, 0xF0, 0x99, 0xF8, 0x29, 0x76,
    0xB8, 0x74, 0xE6, 0xE5, 0x9D, 0xB6, 0xB6, 0xA7, 0xEF, 0x7C, 0x35, 0xF4, 0x06, 0x5D, 0x47, 0x3E, 0xAB, 0xBD, 0x41, 0xB7, 0x97, 0x87,
    0x7D, 0x29, 0x41, 0xF2, 0xD1, 0xA2, 0x64, 0xEF, 0xEE, 0x2A, 0x3D, 0x71, 0xDB, 0x2F, 0x56, 0xF1, 0x1E, 0xAA, 0x6B, 0x34, 0xD5, 0x34,
    0xB6, 0x9E, 0xD1, 0xD3, 0x7B, 0x99, 0x5E, 0x2F, 0x2F, 0xD3, 0xEB, 0xE3, 0x61, 0x9F, 0xB4, 0xA5, 0xD7, 0xD7, 0xCB, 0xF9, 0xEB, 0xE7,
    0x05, 0x7A, 0xDE, 0x5A, 0x0F, 0x84, 0xA5, 0x82, 0x59, 0xD1, 0x16, 0xDB, 0x15, 0x7A, 0x46, 0xAE, 0x8D, 0x71, 0xFD, 0x4D, 0x30, 0xD7,
    0x78, 0x38, 0xBB, 0xB5, 0x13, 0xE4, 0x65, 0x9A, 0xFA, 0xAB, 0x90, 0xCF, 0x5E, 0x1E, 0x8D, 0x6D, 0xC7, 0x34, 0x7B, 0x5F, 0x85, 0x7C,
    0xF6, 0xB9, 0x0A, 0x34, 0xFB, 0x7A, 0x54, 0x76, 0x21, 0x15, 0x68, 0xB3, 0x48, 0xF6, 0x06, 0x5D, 0xBD, 0xC7, 0x74, 0x85, 0x26, 0x21,
    0x9C, 0xEB, 0x9E, 0x0C, 0x9A, 0x6E, 0x71, 0xB8, 0x46, 0x3F, 0x5E, 0xD1, 0xB2, 0xDA, 0x7D, 0x5A, 0x7A, 0x8F, 0xC6, 0x92, 0x89, 0xFB,
    0x70, 0x42, 0xC9, 0x58, 0xEB, 0x6B, 0x20, 0xAE, 0xF0, 0xD0, 0xFA, 0x66, 0x80, 0x6B, 0x34, 0x2D, 0xD2, 0xDD, 0xC2, 0x58, 0xAF, 0xF5,
    0x2D, 0x59, 0x6B, 0x16, 0xE7, 0xA5, 0x36, 0x17, 0xFB, 0x1F, 0xDC, 0xF3, 0x9B, 0x35, 0xF8, 0x5C, 0x72, 0x85, 0xBE, 0x85, 0xAF, 0x07,
    0x22, 0xBF, 0x71, 0x7C, 0x9D, 0x91, 0xEF, 0xA6, 0x78, 0x27, 0xFF, 0xC9, 0xFC, 0xBC, 0xC0, 0xFA, 0x15, 0x69, 0x6F, 0x8E, 0x09, 0x7A,
    0x26, 0xA0, 0xF4, 0x56, 0xA4, 0xBB, 0x34, 0xC5, 0xAB, 0xDB, 0xB6, 0x76, 0xD4, 0x7A, 0xAF, 0xD0, 0x36, 0x5B, 0x8D, 0x1A, 0xC7, 0x12,
    0x7C, 0x90, 0x97, 0xCA, 0x61, 0xCB, 0xCB, 0xBD, 0xB2, 0x24, 0x71, 0x7F, 0x4E, 0x91, 0xE4, 0x2F, 0x35, 0x9B, 0x4E, 0xDD, 0x0C, 0xA1,
    0xBF, 0xA4, 0xF1, 0x95, 0x75, 0xD4, 0xF4, 0x6D, 0xC1, 0x08, 0xA9, 0x04, 0xC2, 0x13, 0x94, 0xFB, 0x6F, 0xE3, 0x51, 0x9A, 0xF1, 0x9A,
    0xE6, 0x65, 0xED, 0xF4, 0xC4, 0xDF, 0xE2, 0x85, 0x73, 0xE1, 0x81, 0x4F, 0x8B, 0x86, 0x4B, 0x0B, 0x7D, 0xA1, 0x15, 0x70, 0xDE, 0x56,
    0xA1, 0xE9, 0x72, 0xDD, 0x62, 0x6C, 0xB5, 0xBA, 0x15, 0x67, 0x20, 0xF8, 0x6A, 0x87, 0x56, 0xFF, 0x9C, 0x55, 0xB1, 0x3A, 0xEE, 0xA3,
    0xC7, 0x19, 0x5D, 0xF9, 0xEC, 0x52, 0x8B, 0x1F, 0x0F, 0x65, 0x7D, 0x94, 0xF5, 0xAD, 0x08, 0xA5, 0x3B, 0x65, 0x5A, 0x5F, 0xA7, 0x57,
    0xF6, 0x57, 0x69, 0x94, 0xB4, 0x46, 0xE2, 0xB5, 0x31, 0x43, 0x13, 0x55, 0x13, 0xAF, 0x57, 0xB3, 0x46, 0x7F, 0x37, 0x75, 0x33, 0xE5,
    0xF3, 0x3F, 0xA3, 0x46, 0x5F, 0x31, 0x46, 0xE9, 0x35, 0xB8, 0x68, 0xEE, 0x9D, 0x48, 0xEE, 0x31, 0xCE, 0x2C, 0x8E, 0x5C, 0xF3, 0xE7,
    0x6A, 0x94, 0x5E, 0x4D, 0x4B, 0x94, 0x4A, 0x61, 0x20, 0x12, 0xB9, 0x63, 0xD4, 0x59, 0x1F, 0x2B, 0x9B, 0x25, 0xDE, 0x8D, 0x76, 0x4E,
    0xD1, 0x15, 0x7F, 0x6C, 0x78, 0x97, 0x1F, 0xA5, 0x46, 0xF6, 0x95, 0xC2, 0xEB, 0x40, 0x49, 0xFF, 0x33, 0x74, 0xB6, 0xD0, 0x93, 0x5A,
    0xA7, 0x70, 0x95, 0x9F, 0xEC, 0x81, 0xD7, 0xC8, 0x7B, 0xAC, 0xC1, 0xE6, 0x45, 0x33, 0x67, 0xBD, 0xB5, 0x7C, 0x36, 0x3D, 0x67, 0xC5,
    0xD4, 0x3D, 0x25, 0x5F, 0x8E, 0xEE, 0xF2, 0x46, 0x8E, 0xBD, 0x1D, 0xF2, 0xF3, 0x8C, 0xAE, 0xBD, 0x34, 0xAB, 0x4E, 0x37, 0x89, 0xDC,
    0xD9, 0xB2, 0x7E, 0x01, 0x4C, 0xE9, 0xC4, 0xA7, 0x36, 0x43, 0xB4, 0x0D, 0x5A, 0xAD, 0x25, 0x6A, 0x78, 0xC3, 0xCC, 0x96, 0x9F, 0x78,
    0x4F, 0x22, 0xCA, 0x83, 0x79, 0xC3, 0x9A, 0x9E, 0xFC, 0xAD, 0x6E, 0xBF, 0x91, 0xFF, 0xB2, 0xFC, 0xD6, 0x1B, 0x4D, 0xA1, 0xC5, 0xF6,
    0xCE, 0x96, 0xA7, 0x75, 0x0D, 0x28, 0x8D, 0xDF, 0xB6, 0x73, 0xB0, 0x3F, 0x27, 0x71, 0x6F, 0x63, 0x69, 0x1A, 0xFB, 0xB3, 0xB5, 0x05,
    0x0E, 0xFA, 0xD9, 0x73, 0x7E, 0x67, 0xD4, 0x76, 0x2C, 0xE5, 0xCC, 0x91, 0xC7, 0xB4, 0xA0, 0x66, 0x9B, 0xD6, 0x35, 0xBF, 0xB3, 0xCE,
    0xF3, 0x94, 0xCA, 0xE7, 0x68, 0x77, 0xDB, 0xD3, 0xC4, 0xE5, 0x2E, 0x39, 0x74, 0x7C, 0x83, 0xC4, 0xBA, 0x64, 0x86, 0xB9, 0xF2, 0xFB,
    0xDC, 0xD6, 0x29, 0x94, 0xDB, 0xD0, 0x9A, 0x4F, 0x14, 0xF7, 0x7C, 0xA4, 0x70, 0xFE, 0x31, 0x57, 0xCC, 0xF3, 0x34, 0xB6, 0x2B, 0xF4,
    0xC5, 0xDE, 0xC8, 0x39, 0xFD, 0xC0, 0x4C, 0x4A, 0x5F, 0xC4, 0xD6, 0x46, 0xDF, 0xE2, 0xA4, 0x8E, 0xAC, 0x7B, 0x5E, 0x76, 0xA6, 0xFC,
    0xE6, 0x96, 0x6B, 0xF5, 0x23, 0xCE, 0x42, 0x8C, 0x44, 0x86, 0x0F, 0x57, 0xF6, 0xFF, 0x96, 0x29, 0xC6, 0x94, 0xA3, 0xD4, 0x5A, 0xF8,
    0x59, 0xF8, 0xDA, 0xAB, 0x95, 0x9B, 0x4E, 0x17, 0x37, 0x4F, 0x9C, 0x21, 0xD9, 0xA7, 0x56, 0xEB, 0xBF, 0x26, 0x3E, 0x8B, 0x8B, 0x5B,
    0xBF, 0x29, 0x92, 0x3D, 0x99, 0x8A, 0xFD, 0xFB, 0x3C, 0xD9, 0x27, 0x2A, 0x4D, 0xA1, 0xCE, 0x47, 0xBC, 0x0D, 0x16, 0xC3, 0xAD, 0x9D,
    0xB4, 0xC8, 0x49, 0x03, 0xE7, 0xCB, 0x7D, 0x01, 0x53, 0xAA, 0xD5, 0x1D, 0x7A, 0xC7, 0x4F, 0xE5, 0xF6, 0x02, 0xD1, 0x2A, 0x73, 0x83,
    0x6B, 0x67, 0x85, 0x6A, 0xAF, 0x18, 0xDA, 0xFA, 0x9A, 0x88, 0xE4, 0x6B, 0x92, 0x49, 0xF2, 0x1E, 0xEB, 0xC8, 0x4B, 0xBA, 0x6B, 0xBE,
    0x25, 0xD4, 0xF8, 0x47, 0xAA, 0x96, 0xCF, 0x9B, 0xF4, 0xF5, 0x57, 0x8D, 0xBE, 0xB7, 0x7D, 0x81, 0xA8, 0xF1, 0x95, 0x7D, 0xBD, 0xA9,
    0xBF, 0xEA, 0xE9, 0x59, 0xF9, 0x9C, 0xF1, 0x71, 0xF5, 0xDD, 0x4B, 0xF5, 0xD7, 0x34, 0xE3, 0x25, 0xAD, 0xB9, 0xD9, 0x6B, 0x65, 0x31,
    0x3B, 0x7D, 0x17, 0xC0, 0x19, 0xFD, 0xC6, 0x85, 0x62, 0x4E, 0x4A, 0x68, 0x5A, 0x55, 0xE5, 0xB4, 0x5A, 0xE6, 0x0A, 0x5B, 0xDE, 0x06,
    0x49, 0xAF, 0x98, 0x2C, 0x95, 0xD3, 0xB9, 0x77, 0x41, 0x5B, 0xFF, 0xFF, 0x99, 0xAF, 0x8A, 0xF5, 0x5E, 0x99, 0x82, 0x56, 0x5F, 0xC2,
    0x26, 0x3E, 0x7F, 0x59, 0x9A, 0xBC, 0x56, 0x88, 0x9C, 0x1A, 0xAC, 0xDE, 0xE2, 0x76, 0x3E, 0xBE, 0xD3, 0xD7, 0x28, 0xD7, 0x79, 0x52,
    0x93, 0x1F, 0x32, 0xD9, 0xEF, 0x73, 0x8F, 0xA6, 0x57, 0x4C, 0xE4, 0x97, 0x30, 0x95, 0x66, 0x67, 0xE3, 0x22, 0x79, 0xDD, 0xB1, 0xA7,
    0xA4, 0x36, 0x77, 0x1A, 0xB9, 0xB4, 0x62, 0xEB, 0xCB, 0x55, 0xBE, 0xFD, 0x9C, 0xAC, 0xFA, 0xFE, 0x4E, 0xFD, 0x22, 0xE1, 0x6F, 0x46,
    0x50, 0x32, 0x49, 0x7E, 0x13, 0xE4, 0xF9, 0x58, 0xBD, 0x5E, 0x8D, 0x92, 0xFD, 0x9F, 0x59, 0xC5, 0x9E, 0x43, 0xE6, 0xE3, 0x8C, 0x8E,
    0xC5, 0xEA, 0x3D, 0x6A, 0x35, 0xCF, 0x81, 0x41, 0x2E, 0xF8, 0x2A, 0x73, 0x4C, 0x9B, 0xED, 0xFD, 0x27, 0x4B, 0xBA, 0x6F, 0xF7, 0x7D,
    0x9E, 0x3B, 0xA6, 0x6D, 0xEF, 0x15, 0xCD, 0xFD, 0xFC, 0xDA, 0xBE, 0x74, 0xA4, 0xFD, 0x75, 0x1C, 0xE5, 0x35, 0x51, 0x89, 0x87, 0x96,
    0xFB, 0xAF, 0x9E, 0xD0, 0x77, 0x7C, 0x3A, 0xD2, 0xDB, 0xAB, 0xF4, 0xB5, 0xFA, 0x4C, 0xF7, 0x84, 0x8F, 0xFA, 0x8A, 0xD7, 0xCB, 0x6D,
    0x5E, 0xB6, 0x56, 0x3D, 0x54, 0xBF, 0x63, 0x68, 0x2A, 0x5B, 0x0A, 0xB7, 0xDF, 0xD5, 0xA2, 0x23, 0x55, 0xBE, 0xC3, 0xAA, 0xCC, 0x1B,
    0x6F, 0x46, 0xBB, 0xAB, 0xBF, 0x57, 0xA2, 0xEF, 0xC8, 0x9A, 0xC8, 0x5D, 0x5D, 0xB2, 0x32, 0x1F, 0x25, 0x4B, 0x20, 0x4F, 0xFA, 0x85,
    0x2D, 0x1F, 0x35, 0x1F, 0xCA, 0x9E, 0x94, 0xC1, 0x68, 0x63, 0xD9, 0xA3, 0xF7, 0x22, 0x6D, 0xB5, 0xFB, 0x67, 0xEE, 0xD7, 0x89, 0x9A,
    0x75, 0x93, 0x27, 0xB4, 0xE3, 0x25, 0x5F, 0x74, 0xEE, 0xDA, 0x61, 0x29, 0xD3, 0x4E, 0x6C, 0x7A, 0xB1, 0x40, 0x9E, 0x53, 0x64, 0xED,
    0xA7, 0xBB, 0x67, 0x41, 0x6A, 0xFC, 0xE8, 0x8D, 0x3B, 0x75, 0x9D, 0xBC, 0xFB, 0xBC, 0x94, 0xAC, 0xA5, 0xBC, 0x55, 0x1E, 0x5B, 0xCB,
    0x21, 0x4F, 0xED, 0xBD, 0x5C, 0xE1, 0x75, 0x35, 0xEA, 0x0C, 0xEF, 0xE0, 0xC7, 0x7B, 0x71, 0x7D, 0x74, 0xDD, 0x32, 0xCA, 0x7D, 0xDA,
    0x49, 0x1A, 0x64, 0x42, 0xF7, 0xE9, 0xBB, 0x6B, 0x59, 0xE3, 0x19, 0x4F, 0x6D, 0x96, 0x36, 0x9E, 0xF0, 0x50, 0xB2, 0xEA, 0xF0, 0xD6,
    0x3A, 0xA8, 0xDD, 0xC2, 0xC3, 0x7D, 0x1E, 0xF4, 0xA4, 0x5F, 0x7D, 0x7F, 0xEE, 0x19, 0x1F, 0xF1, 0x02, 0x8B, 0x81, 0xC7, 0x30, 0x5F,
    0x55, 0x3E, 0xD6, 0x96, 0x06, 0x57, 0x83, 0x8F, 0xFC, 0x97, 0xD2, 0x7D, 0x0B, 0x6F, 0xB5, 0x91, 0xB5, 0x75, 0x80, 0xFA, 0x8C, 0xE9,
    0x3D, 0x5E, 0x9E, 0xD9, 0x68, 0x68, 0xE7, 0x73, 0xB5, 0xEA, 0x0C, 0x5F, 0x90, 0xF1, 0xD4, 0x5E, 0x43, 0x9D, 0x97, 0xB0, 0x4D, 0xF0,
    0xF4, 0x3D, 0x4C, 0x65, 0x3E, 0x09, 0x7C, 0x3E, 0xA5, 0xE7, 0x66, 0x57, 0xA7, 0x0F, 0xD8, 0xF2, 0xD1, 0x5A, 0x2A, 0x2D, 0xBC, 0xA8,
    0xD5, 0x41, 0x94, 0x74, 0x5F, 0x32, 0x8A, 0xEF, 0x63, 0x8C, 0x1E, 0xD8, 0x1A, 0x38, 0xE7, 0xA1, 0x65, 0xF5, 0x74, 0x85, 0xB6, 0x78,
    0x0D, 0x27, 0x85, 0x5B, 0x60, 0xB8, 0x2F, 0x1B, 0x9B, 0xA5, 0xD9, 0x49, 0xF8, 0x4B, 0xB5, 0x7E, 0x65, 0x48, 0x9B, 0xFF, 0xE2, 0x9C,
    0x55, 0x42, 0xAF, 0x4E, 0x29, 0x29, 0xEB, 0x86, 0xCC, 0xD2, 0x7E, 0x4A, 0xF0, 0x74, 0x66, 0x8B, 0x66, 0xE7, 0xFF, 0xA1, 0x89, 0x0F,
    0xA6, 0x56, 0xE3, 0x13, 0xCD, 0xE7, 0x5F, 0xB1, 0xAA, 0xC4, 0xF0, 0xD6, 0x88, 0x52, 0xB5, 0x79, 0x8B, 0x5A, 0x2D, 0xFC, 0x4C, 0xD0,
    0xD4, 0x34, 0xAD, 0x2B, 0x3C, 0x0D, 0xDC, 0xD3, 0x18, 0xFA, 0x3E, 0xD5, 0xEA, 0x69, 0xA5, 0x6E, 0xB5, 0xEC, 0xDB, 0xC5, 0xCC, 0x4B,
    0x1A, 0x49, 0x5E, 0xF3, 0x72, 0xCE, 0x57, 0xCC, 0xFF, 0xB6, 0x9E, 0x14, 0x0D, 0x92, 0xFC, 0x91, 0x28, 0x69, 0x8B, 0x15, 0xFB, 0xDF,
    0xDB, 0xE2, 0x2C, 0xC6, 0x9A, 0x9A, 0x9A, 0xAE, 0xCD, 0x7E, 0xED, 0x09, 0x6F, 0x7A, 0x3D, 0x24, 0x46, 0x83, 0xF7, 0x0B, 0x9D, 0xAE,
    0xFA, 0x6D, 0xA1, 0x67, 0x74, 0x94, 0x4E, 0x6B, 0xB9, 0x91, 0xB7, 0xF0, 0x35, 0x15, 0xC1, 0xC7, 0xB2, 0xB8, 0xFF, 0xA4, 0xF6, 0x12,
    0xEF, 0xB8, 0x35, 0xA2, 0xCD, 0x9D, 0xA5, 0x75, 0x37, 0x0F, 0xD3, 0xB9, 0xCE, 0x4A, 0x9B, 0x1F, 0x28, 0xB5, 0x71, 0x6A, 0xCB, 0x43,
    0x68, 0x1F, 0x29, 0x27, 0xE7, 0x7D, 0x3A, 0x78, 0xAD, 0x7C, 0x9F, 0xD3, 0x3A, 0x8D, 0xAB, 0xE5, 0x8A, 0x94, 0x74, 0xBF, 0x42, 0x57,
    0xD1, 0xC3, 0xEE, 0x35, 0x41, 0xA5, 0xF2, 0x95, 0xAE, 0x15, 0x7A, 0x56, 0x7C, 0x43, 0x4C, 0x50, 0xD3, 0xE6, 0xE3, 0xDF, 0x51, 0x5E,
    0xA2, 0xF9, 0x8C, 0x68, 0x94, 0x66, 0x59, 0x35, 0xBB, 0xD3, 0x81, 0xEB, 0x44, 0x1F, 0x73, 0x94, 0xCE, 0xF5, 0x7A, 0x88, 0xB1, 0xD1,
    0xDE, 0x59, 0xEF, 0xEC, 0x0B, 0xD6, 0xC9, 0xF7, 0x8C, 0x63, 0x9A, 0xDE, 0x2F, 0x73, 0x9D, 0x87, 0xF0, 0x65, 0x1F, 0xE1, 0xE0, 0x56,
    0x6A, 0x90, 0xC7, 0x7D, 0x47, 0x78, 0x8A, 0x48, 0x76, 0xF2, 0x1E, 0x8A, 0x33, 0x4E, 0x19, 0xEF, 0xD0, 0x77, 0xBB, 0x29, 0x15, 0x77,
    0xDA, 0x8F, 0xE6, 0xC1, 0x79, 0xD9, 0x1A, 0xDE, 0x91, 0xEB, 0xD2, 0x9E, 0x9B, 0x2B, 0xBC, 0x92, 0xF8, 0x5C, 0x2A, 0xEB, 0x2B, 0xC3,
    0x25, 0xB9, 0xCC, 0xD4, 0x34, 0x1A, 0xAE, 0xDE, 0x38, 0x95, 0xFB, 0xBB, 0x72, 0x49, 0xCF, 0xE6, 0x8B, 0xB9, 0xD7, 0x3A, 0xBE, 0xEB,
    0xF5, 0x1A, 0xD5, 0x74, 0xEB, 0x38, 0x49, 0x2A, 0x8D, 0xB8, 0x8B, 0x9C, 0x24, 0x79, 0xD7, 0x74, 0x57, 0x4E, 0x70, 0xCC, 0x47, 0xD8,
    0xD6, 0xC5, 0x6B, 0xB2, 0x34, 0xD2, 0x4E, 0x3B, 0xDA, 0xEE, 0xA5, 0x3A, 0x9B, 0xF7, 0x0D, 0x36, 0xC8, 0xBE, 0x1F, 0x62, 0xEC, 0x2C,
    0x13, 0x5C, 0xE3, 0x91, 0xCA, 0xE7, 0x02, 0x25, 0x6D, 0xBF, 0xC5, 0x8A, 0x97, 0x88, 0xEF, 0x2A, 0x2F, 0xB1, 0x92, 0x88, 0x91, 0xAC,
    0xE6, 0xBB, 0xA9, 0x76, 0x83, 0x98, 0xAB, 0x6D, 0xD3, 0xB8, 0xCA, 0xD3, 0xC0, 0x25, 0x32, 0x76, 0x5E, 0xA7, 0x72, 0xD6, 0xBD, 0x51,
    0x94, 0x8F, 0xC6, 0xF7, 0x84, 0x97, 0x96, 0xF7, 0x36, 0x65, 0x9E, 0xAE, 0xD2, 0x4F, 0xE6, 0xBA, 0x72, 0x4B, 0xD3, 0xE9, 0x9E, 0xD3,
    0xB7, 0x44, 0x5C, 0xA4, 0xCF, 0xD6, 0x80, 0x48, 0x2B, 0x7F, 0xE8, 0x0A, 0xEF, 0x5F, 0x17, 0xC8, 0x3E, 0xAF, 0x62, 0xB9, 0x3D, 0xBB,
    0x9C, 0xC2, 0xD5, 0x3A, 0xB3, 0xB5, 0x16, 0x56, 0x93, 0x92, 0x1A, 0x0B, 0xC4, 0xFA, 0xE9, 0x38, 0x9D, 0xEB, 0xF3, 0x84, 0x99, 0x5B,
    0xE7, 0x2A, 0xF8, 0xBF, 0x7C, 0x57, 0xF8, 0xA5, 0x13, 0xF1, 0xDC, 0xA1, 0x6F, 0xB2, 0xD9, 0x49, 0x59, 0x8F, 0xE1, 0x8A, 0x77, 0x65,
    0x79, 0xDE, 0x64, 0xF7, 0xB2, 0x90, 0x56, 0x1E, 0x16, 0x49, 0x4A, 0x4B, 0x74, 0x41, 0xDA, 0x0B, 0xD9, 0x24, 0xDE, 0x78, 0x70, 0x9E,
    0xD6, 0xF5, 0xB2, 0xA6, 0x34, 0xF9, 0xF6, 0x8F, 0xE4, 0xFE, 0x4B, 0x14, 0xED, 0x5F, 0x37, 0x89, 0xFE, 0x63, 0x9B, 0xC6, 0xD5, 0xB2,
    0x3B, 0xE3, 0xA9, 0x57, 0xE0, 0xE9, 0x0E, 0x6D, 0x83, 0xCA, 0xFA, 0x9C, 0xB3, 0xD9, 0xBE, 0x3C, 0x06, 0x37, 0xDA, 0x52, 0xD6, 0x5E,
    0x44, 0x6A, 0xB8, 0x23, 0xDD, 0xB2, 0xD0, 0xDA, 0x86, 0x58, 0x4E, 0xA3, 0xCE, 0x33, 0x51, 0x3A, 0x2F, 0x34, 0x5B, 0x59, 0x2B, 0x3B,
    0xD7, 0xD4, 0x5A, 0x5B, 0x7F, 0x64, 0x00, 0xDF, 0xAE, 0xD2, 0xFE, 0x08, 0x29, 0x25, 0x4A, 0x27, 0x22, 0x5A, 0xDF, 0xD1, 0xB4, 0xCD,
    0x87, 0x6C, 0x2B, 0x12, 0xCF, 0xC3, 0xE8, 0x26, 0x2F, 0x25, 0x8E, 0x73, 0x64, 0xEB, 0xF5, 0x24, 0x60, 0x8B, 0x78, 0x33, 0xC5, 0x9A,
    0x2A, 0xBE, 0xF3, 0x94, 0xA2, 0x6A, 0x93, 0x28, 0xEF, 0xC0, 0xE3, 0xB9, 0x67, 0x6C, 0x21, 0x47, 0x27, 0x3B, 0xF0, 0x5D, 0x65, 0x73,
    0xB7, 0x65, 0x8B, 0x18, 0x47, 0xF6, 0xA9, 0x93, 0x35, 0xFA, 0xEF, 0x31, 0x4B, 0xE7, 0x22, 0xF2, 0x59, 0x52, 0xA4, 0xF4, 0xCE, 0x46,
    0x7C, 0x93, 0x8F, 0x7E, 0x6B, 0x7D, 0x84, 0xBA, 0x1F, 0xA7, 0x8E, 0x5B, 0x65, 0x59, 0x51, 0xEC, 0x75, 0xB5, 0xC9, 0x05, 0x34, 0x0F,
    0xB2, 0xF6, 0x49, 0xFD, 0x24, 0x25, 0x6B, 0xAB, 0x98, 0x8F, 0x6D, 0x53, 0x68, 0x9F, 0x8F, 0x1D, 0xF1, 0x55, 0x2F, 0xA3, 0xEF, 0x36,
    0xB1, 0x8F, 0xB1, 0x4E, 0xA1, 0x75, 0xCC, 0xA9, 0xF3, 0xD4, 0x2B, 0xF0, 0x74, 0x8D, 0x2E, 0xCE, 0xB0, 0x8A, 0xF6, 0x9F, 0xDB, 0xE4,
    0xB1, 0x6C, 0x71, 0xC1, 0xCE, 0xD8, 0x96, 0x67, 0xAA, 0xD3, 0xF3, 0x2F, 0xDB, 0xB9, 0x23, 0xA4, 0x48, 0x94, 0xC5, 0x3A, 0x85, 0x3B,
    0x7D, 0xC5, 0x31, 0x4F, 0x47, 0xF5, 0x27, 0xF3, 0x74, 0x85, 0xAE, 0xD8, 0x63, 0x2B, 0xDB, 0x4E, 0xF8, 0x6F, 0x17, 0x7D, 0xD0, 0x36,
    0x85, 0x7B, 0x7D, 0xD0, 0x9E, 0x6F, 0x22, 0xB7, 0xB6, 0x62, 0x3A, 0xAC, 0x69, 0x1E, 0xCA, 0xF7, 0xF6, 0x7C, 0xCC, 0x92, 0x3D, 0x9A,
    0xB3, 0x99, 0xAD, 0x7E, 0xBB, 0x7C, 0x07, 0x08, 0x63, 0xBB, 0xDA, 0x3E, 0x16, 0xA7, 0xB6, 0xEE, 0x41, 0x0E, 0xFB, 0xA0, 0x73, 0xBA,
    0xE2, 0xC6, 0x92, 0x3C, 0x27, 0xE2, 0x3D, 0x46, 0xCC, 0x9B, 0x6C, 0xFD, 0xA2, 0x74, 0xB7, 0xB1, 0x6C, 0x07, 0xFA, 0x99, 0xA3, 0x14,
    0xD5, 0xCB, 0x65, 0xCD, 0x5F, 0xEC, 0xBD, 0x84, 0xA5, 0x98, 0x67, 0xED, 0x62, 0x4D, 0x57, 0x68, 0xDE, 0x14, 0xDE, 0xAF, 0xD8, 0xE1,
    0x5A, 0x3D, 0x89, 0xBE, 0x14, 0xAB, 0x7A, 0x2B, 0x58, 0x8D, 0x2E, 0x7A, 0xA2, 0x0D, 0xE7, 0x75, 0xAF, 0xA6, 0xCF, 0xEB, 0x5A, 0x2C,
    0x7C, 0xB2, 0x62, 0x6C, 0xF5, 0xB1, 0x80, 0x3C, 0x84, 0x3C, 0x98, 0x4A, 0x4E, 0xD6, 0x2C, 0x4D, 0x6F, 0x51, 0xC8, 0xE7, 0x94, 0xEE,
    0xEF, 0xA3, 0x91, 0x8F, 0x78, 0x6F, 0x2B, 0x92, 0xDB, 0xD7, 0xE3, 0x5B, 0x59, 0x8A, 0x94, 0x77, 0xC9, 0x7A, 0x3C, 0xEB, 0x94, 0x6A,
    0xFD, 0x47, 0x89, 0xA7, 0x96, 0x39, 0x53, 0xE6, 0xEB, 0x0E, 0x7D, 0xA7, 0xA5, 0xF1, 0x80, 0xA6, 0xB6, 0x53, 0x3B, 0xD7, 0x79, 0x88,
    0x1B, 0x28, 0xCA, 0x73, 0x45, 0xE6, 0x7B, 0xB4, 0x0D, 0x30, 0x85, 0xF6, 0x36, 0xB0, 0xF7, 0x93, 0xA8, 0xE8, 0x77, 0xED, 0x0B, 0xA5,
    0xBB, 0xA2, 0x94, 0xAE, 0xD0, 0x50, 0x84, 0x73, 0x1D, 0x99, 0xC2, 0xFE, 0x67, 0x37, 0xD5, 0x67, 0x88, 0xD8, 0xDA, 0xF3, 0x1E, 0x2D,
    0x69, 0x24, 0x85, 0x27, 0xAC, 0x28, 0x0D, 0x36, 0xEE, 0xC5, 0xBB, 0xC5, 0x7B, 0xEC, 0xCE, 0x52, 0x9A, 0x9B, 0x2C, 0x69, 0xE3, 0x5D,
    0xCA, 0x47, 0x5A, 0x93, 0x2D, 0xB1, 0xD9, 0x25, 0x1D, 0x66, 0x48, 0x89, 0x7C, 0xC6, 0x21, 0x53, 0xD3, 0x76, 0xC6, 0x81, 0xBC, 0xE5,
    0x1B, 0x6A, 0xC2, 0xD6, 0x35, 0x92, 0xBF, 0xF5, 0xE0, 0xF8, 0x6C, 0xC9, 0xB6, 0x2D, 0xCB, 0x80, 0xF7, 0x20, 0x07, 0xBE, 0x77, 0x65,
    0x8A, 0xA2, 0x54, 0x06, 0xE2, 0x57, 0x5F, 0xF4, 0xB2, 0x04, 0xAB, 0x97, 0x0F, 0xB5, 0xE4, 0x31, 0x51, 0xF2, 0xC7, 0xAD, 0x7E, 0xF6,
    0x31, 0x7A, 0x0F, 0xFA, 0xCC, 0xC3, 0x14, 0xAE, 0xF0, 0x32, 0x4A, 0xA7, 0xA6, 0xC2, 0xE6, 0x41, 0x69, 0x1E, 0x29, 0xDB, 0x43, 0xEF,
    0xE9, 0xC9, 0x29, 0x5C, 0xE1, 0xC5, 0xFE, 0x8E, 0xE2, 0x3A, 0x97, 0x14, 0x95, 0xB1, 0xDF, 0x7D, 0x2F, 0xB6, 0x33, 0xA6, 0x70, 0x95,
    0x17, 0xF6, 0x10, 0x2A, 0xDF, 0xD9, 0x5A, 0xCF, 0xCA, 0x7D, 0xCA, 0x5D, 0x9A, 0x8E, 0x7C, 0x38, 0x79, 0x4A, 0xB3, 0xF7, 0x55, 0xA0,
    0xD9, 0xC7, 0x63, 0x9A, 0x06, 0x7E, 0x13, 0x40, 0x79, 0x67, 0x09, 0xFB, 0xEC, 0xAF, 0x74, 0x1E, 0xD1, 0xD4, 0x3B, 0xE8, 0x7B, 0x5A,
    0x69, 0xCA, 0x2F, 0xDD, 0xC9, 0xDF, 0x62, 0x04, 0x3A, 0xEF, 0x69, 0x5A, 0xE7, 0x67, 0x5B, 0xBA, 0xF4, 0x4C, 0x59, 0x69, 0xD4, 0x78,
    0x97, 0xBE, 0xDE, 0x65, 0xFA, 0x6C, 0xD6, 0x36, 0x4B, 0xBE, 0x1B, 0xA3, 0xED, 0xA4, 0x23, 0xE7, 0xF5, 0x52, 0xF8, 0xBE, 0xE8, 0x17,
    0xD6, 0xF1, 0xD5, 0xC7, 0x9F, 0x32, 0x3F, 0x67, 0x1E, 0x85, 0x6D, 0xDE, 0xFF, 0xF8, 0xC0, 0x9A, 0xB7, 0xF5, 0xEE, 0x58, 0x3B, 0x6F,
    0xF9, 0xC4, 0x48, 0xED, 0x4E, 0x7B, 0xEE, 0x07, 0xE2, 0x5C, 0x8C, 0xC6, 0xD7, 0xBA, 0x07, 0x33, 0x36, 0x49, 0xDD, 0xF6, 0xD2, 0xB7,
    0x9D, 0x3C, 0xB3, 0x5F, 0xC8, 0xB5, 0x98, 0x4A, 0x9D, 0xBE, 0xB5, 0x37, 0xF0, 0x38, 0x7E, 0x56, 0xAB, 0xE6, 0x81, 0x3D, 0x6E, 0xBF,
    0x90, 0x11, 0x68, 0x6C, 0xB5, 0xB5, 0xD9, 0x9A, 0x8F, 0xB0, 0x75, 0x31, 0x4B, 0xEF, 0x60, 0x2B, 0xBE, 0x7F, 0xB2, 0x5F, 0xC8, 0x53,
    0xB6, 0x29, 0x5C, 0xE3, 0x67, 0x6E, 0xBA, 0xCF, 0xA4, 0x68, 0x8B, 0xF4, 0x8D, 0x4E, 0xE1, 0x6D, 0x64, 0x75, 0x9A, 0x7A, 0x07, 0xFA,
    0x37, 0x35, 0x9A, 0x69, 0xFC, 0xDB, 0x3D, 0xBF, 0x26, 0x97, 0xCA, 0x64, 0x1D, 0x7C, 0x9A, 0xA6, 0x75, 0x72, 0x9A, 0x74, 0xCB, 0x59,
    0xBE, 0x4B, 0x1E, 0xA3, 0xC1, 0xD7, 0xFE, 0xE8, 0x03, 0xA2, 0xFE, 0x8D, 0xDC, 0x63, 0x3A, 0x8E, 0x2E, 0xB5, 0xFA, 0xB7, 0xE7, 0x65,
    0x56, 0xF5, 0x77, 0x2F, 0xF3, 0xD2, 0x4A, 0xD3, 0xA0, 0xE1, 0xB5, 0x00, 0xD7, 0x68, 0x9A, 0xF9, 0x89, 0xBC, 0x45, 0x43, 0xBD, 0xA8,
    0xED, 0xE3, 0xF0, 0x85, 0xB3, 0x1E, 0xD2, 0xDD, 0x38, 0x13, 0xD7, 0x81, 0x8A, 0xD6, 0x4E, 0x91, 0x5E, 0x72, 0xB2, 0x7F, 0x23, 0xD5,
    0x35, 0x3E, 0x16, 0x49, 0xA7, 0xAC, 0xFD, 0xEE, 0x76, 0xA7, 0x43, 0xB2, 0xAE, 0x29, 0x9C, 0x9F, 0x22, 0x47, 0x6B, 0xBE, 0x2B, 0x8E,
    0xBE, 0xAA, 0x44, 0xE9, 0x82, 0x3C, 0xD0, 0x2D, 0xD8, 0xD2, 0xD2, 0x7B, 0x44, 0xCB, 0xDC, 0x34, 0x3F, 0x0A, 0x0B, 0x64, 0xEB, 0x3D,
    0xB9, 0xC2, 0xFD, 0xFF, 0x72, 0xF9, 0x6D, 0x6C, 0x39, 0xA5, 0xDA, 0x18, 0x92, 0x79, 0x25, 0xF0, 0x39, 0xC8, 0x62, 0x33, 0x1F, 0xDB,
    0x9E, 0x0D, 0x67, 0x97, 0xCB, 0xEF, 0x3B, 0xCA, 0xB1, 0xD5, 0xE9, 0xBB, 0x7A, 0x17, 0xBF, 0xA1, 0x5C, 0xAC, 0x65, 0x16, 0x97, 0xEE,
    0xE1, 0x0B, 0xA9, 0x5F, 0xB6, 0x0E, 0xF4, 0xAE, 0xCD, 0x7B, 0x32, 0xBF, 0xD9, 0xE2, 0x68, 0x5D, 0xB4, 0x95, 0x8B, 0x8B, 0x0E, 0x8B,
    0xF3, 0x12, 0x91, 0xC2, 0x7E, 0xEE, 0xB3, 0x7D, 0x95, 0xCE, 0x19, 0x3F, 0x61, 0x07, 0x2A, 0xFF, 0x2A, 0x7F, 0x2B, 0xAC, 0xFF, 0x1F,
    0xCA, 0x3E, 0x54, 0x68, 0x4A, 0xF5, 0x3A, 0x63, 0xEB, 0x6A, 0x10, 0xD0, 0x52, 0xAA, 0x9B, 0x35, 0xBB, 0x94, 0xDE, 0x17, 0x4C, 0x86,
    0xBF, 0x62, 0x9C, 0x9C, 0xA9, 0xC8, 0xEF, 0xB0, 0x3A, 0x9F, 0x0D, 0x6A, 0x20, 0xDF, 0xF7, 0xF1, 0x7C, 0xA7, 0x4A, 0x96, 0x0D, 0xD6,
    0x34, 0xB4, 0x9D, 0xAB, 0x24, 0x73, 0x34, 0x4E, 0x6A, 0xEB, 0x1E, 0xE4, 0x6F, 0xB3, 0xD2, 0x3B, 0xC0, 0x1F, 0xC9, 0x75, 0x46, 0x53,
    0xAB, 0xF1, 0x4A, 0xE1, 0x32, 0x53, 0x32, 0xC7, 0xE2, 0xE0, 0xCB, 0x2C, 0xD9, 0x99, 0x28, 0xFB, 0x0D, 0x3F, 0xF2, 0x91, 0xFC, 0xA6,
    0x96, 0x75, 0x0A, 0x65, 0xBF, 0xF2, 0xC2, 0xE2, 0x15, 0x4F, 0x15, 0x58, 0xCF, 0x11, 0x9E, 0x1F, 0xC4, 0x4C, 0x83, 0x2F, 0xF8, 0xB9,
    0xDF, 0xB7, 0x53, 0x89, 0xF7, 0x49, 0xE7, 0x2F, 0x35, 0xDB, 0xF6, 0xF3, 0xDC, 0x23, 0x62, 0x9D, 0x4E, 0xD5, 0x24, 0xE3, 0xA6, 0x12,
    0x6F, 0x7E, 0xCE, 0xFB, 0x42, 0xFD, 0x11, 0x31, 0xB7, 0xA4, 0x6A, 0x3E, 0x97, 0x4E, 0x6D, 0xB2, 0x9B, 0x56, 0xBB, 0x3B, 0x2C, 0xE7,
    0x57, 0x99, 0x4E, 0x9A, 0x83, 0xDB, 0x88, 0xBD, 0xDC, 0xA8, 0x4B, 0x5B, 0x3A, 0x7A, 0x17, 0xDF, 0x80, 0x48, 0xE5, 0xDA, 0x6E, 0x5C,
    0xB3, 0xD1, 0x9A, 0x5E, 0xB6, 0x43, 0x74, 0x96, 0xBF, 0xC0, 0x63, 0xF2, 0xFB, 0x3A, 0x94, 0x82, 0x7A, 0x3D, 0xA2, 0x76, 0x46, 0x6E,
    0x7B, 0xD9, 0x7F, 0x93, 0xFA, 0xCD, 0xDD, 0xFC, 0x63, 0xF4, 0x7C, 0x09, 0x75, 0x3C, 0xEA, 0x76, 0x6B, 0x8E, 0xF8, 0xBA, 0x7E, 0x63,
    0x58, 0x89, 0x36, 0x3D, 0xDB, 0x49, 0xB0, 0xB2, 0xE1, 0x33, 0x7B, 0x34, 0x66, 0xE2, 0xF9, 0x68, 0xB4, 0xD8, 0x79, 0x5C, 0x73, 0x76,
    0x77, 0xD6, 0xCE, 0xFE, 0xF7, 0xB8, 0xB0, 0xBF, 0xA5, 0xA9, 0x69, 0x5A, 0x2D, 0xF5, 0x66, 0x92, 0xA4, 0x0D, 0xAD, 0xAF, 0x1F, 0x29,
    0xEF, 0x7B, 0xD5, 0x69, 0x3A, 0xD2, 0x03, 0xB9, 0x4F, 0x13, 0xE7, 0x2E, 0x6A, 0x8D, 0xA2, 0x94, 0x7F, 0xBF, 0x13, 0x3E, 0xDC, 0x2F,
    0xA7, 0x6D, 0x3F, 0xB3, 0xA6, 0xDC, 0xD3, 0xC6, 0x4B, 0xA1, 0x7A, 0xDF, 0x37, 0x48, 0x3E, 0x95, 0x62, 0xA5, 0x77, 0x48, 0x8D, 0x92,
    0xA5, 0x2C, 0x6B, 0x15, 0x25, 0x4D, 0x75, 0xDE, 0x09, 0xF9, 0x1C, 0x97, 0x69, 0xC4, 0x8D, 0x7C, 0x2F, 0xA1, 0xBE, 0x8F, 0x40, 0x7E,
    0xF2, 0xB9, 0xA5, 0x9A, 0xBE, 0xD2, 0xF7, 0xA4, 0xEC, 0xA7, 0x11, 0xE3, 0x6B, 0xE5, 0xE1, 0xD8, 0xBA, 0x24, 0xD0, 0xA1, 0x6D, 0x89,
    0x33, 0x5A, 0xC2, 0xF2, 0x4C, 0xAC, 0x45, 0x31, 0xD2, 0x8B, 0x9A, 0x6A, 0x6D, 0x55, 0x72, 0x52, 0xF4, 0x6F, 0x91, 0xDA, 0x3E, 0xAD,
    0x5A, 0xFE, 0x8D, 0xD2, 0x7E, 0x28, 0x4E, 0x2A, 0xB5, 0xBA, 0x45, 0xBD, 0xF2, 0x78, 0x15, 0x96, 0x59, 0x66, 0xE9, 0x8D, 0x2C, 0xE7,
    0x54, 0x8C, 0xA7, 0xE4, 0xFD, 0x67, 0x8C, 0x06, 0x1B, 0xB0, 0x54, 0x5E, 0xBF, 0x54, 0x3F, 0x23, 0xC6, 0xB3, 0x41, 0x1A, 0xD1, 0x89,
    0x2A, 0x9E, 0xD2, 0x41, 0xFE, 0x39, 0x25, 0xF7, 0x21, 0xB3, 0x0B, 0x7B, 0xD1, 0x54, 0xAE, 0xFF, 0xC3, 0xDF, 0xD4, 0xEF, 0xD9, 0x0C,
    0xAD, 0x94, 0xCF, 0x96, 0x31, 0xA5, 0x6B, 0x3C, 0x92, 0xF8, 0xB9, 0x89, 0x41, 0x65, 0x8E, 0x91, 0xF9, 0x28, 0xD1, 0xC4, 0xBF, 0x6C,
    0x77, 0xA4, 0xD6, 0xB3, 0x4B, 0x63, 0xA5, 0x2C, 0x0F, 0xA4, 0x6A, 0x5C, 0xC7, 0xD2, 0xB8, 0x15, 0x8C, 0xC1, 0xCE, 0x4B, 0x83, 0xF2,
    0x5C, 0x1C, 0x75, 0xDA, 0x87, 0xEB, 0x63, 0x1D, 0xAF, 0x5F, 0x32, 0xCD, 0x9E, 0xA4, 0x37, 0x6A, 0xCF, 0x87, 0xD1, 0xA3, 0x35, 0x2C,
    0xAD, 0xC9, 0x02, 0x34, 0xC9, 0xAB, 0x7E, 0xB8, 0xC4, 0xAB, 0x76, 0xB2, 0x1D, 0xB8, 0x5C, 0x5B, 0x66, 0x49, 0x67, 0xE3, 0x19, 0x5D,
    0x26, 0xF7, 0x18, 0x24, 0xDB, 0x30, 0x44, 0x12, 0x25, 0x5F, 0x3A, 0x62, 0x3F, 0x90, 0xE2, 0xF6, 0x79, 0xB2, 0xAC, 0xF3, 0x4D, 0xE6,
    0x7A, 0x4B, 0xAA, 0x91, 0x70, 0xC5, 0x73, 0xAC, 0x63, 0xDA, 0x72, 0xCB, 0xE3, 0x3E, 0xCF, 0xDA, 0xE2, 0x5B, 0xF6, 0xBD, 0xA6, 0x46,
    0x5D, 0xE8, 0xCF, 0x8D, 0xD2, 0x8B, 0xD6, 0xD6, 0xEF, 0x0A, 0xCA, 0x3D, 0xC7, 0x3A, 0x8E, 0xFD, 0x5A, 0x65, 0xFD, 0xBB, 0xED, 0x0A,
    0x27, 0x62, 0xA5, 0x48, 0x2F, 0x52, 0x63, 0x3C, 0x4C, 0x9F, 0x22, 0x79, 0x8C, 0x92, 0x73, 0x2F, 0xFB, 0x91, 0xF9, 0xFF, 0x85, 0x3F,
    0xBE, 0x15, 0x65, 0xFD, 0x62, 0x95, 0x5A, 0xBE, 0x3C, 0xE1, 0xF9, 0xF6, 0xDF, 0xF5, 0xBA, 0xFB, 0x7D, 0x74, 0xBA, 0xC2, 0x16, 0x35,
    0x3E, 0xD3, 0x9A, 0xE9, 0x74, 0x23, 0x1F, 0xF8, 0xA2, 0x19, 0x7B, 0xDF, 0xEB, 0xCD, 0x65, 0x19, 0xD7, 0xF8, 0x01, 0x5E, 0xB5, 0xFE,
    0xED, 0x6B, 0xCE, 0x42, 0xD8, 0xF9, 0x95, 0x20, 0x5F, 0xB6, 0x87, 0x9F, 0x7A, 0x6E, 0xA8, 0xEF, 0x2F, 0xF0, 0x7D, 0xC7, 0xC5, 0xF5,
    0xBE, 0xCD, 0x21, 0x5C, 0x1B, 0xF0, 0xA5, 0x6F, 0x06, 0xE0, 0xEB, 0x07, 0xB5, 0x69, 0xFE, 0x13, 0x84, 0x4B, 0x3F, 0x5B, 0xDC, 0x3C,
    0xE8, 0x1A, 0x9D, 0xEE, 0xB1, 0xBB, 0x97, 0x36, 0xFF, 0x1F, 0xFC, 0x5E, 0xFF, 0x6B, 0x61, 0xF3, 0x72, 0xA0, 0xBB, 0x6F, 0xF9, 0x4D,
    0x2D, 0x06, 0xC0, 0xF7, 0x53, 0x77, 0x8F, 0x6A, 0x51, 0x04, 0xDF, 0x75, 0xEB, 0x0C, 0x2D, 0xB6, 0x43, 0xD8, 0x29, 0xA9, 0x7D, 0xCB,
    0x09, 0x10, 0xFF, 0xC5, 0x47, 0x06, 0xB7, 0xEC, 0x07, 0xDF, 0x5F, 0xDF, 0xBD, 0xA6, 0xE5, 0x24, 0xF8, 0x9E, 0x13, 0x7D, 0xDB, 0x75,
    0x81, 0x10, 0xFF, 0xB1, 0xF8, 0xDB, 0xAE, 0x0B, 0x82, 0xF0, 0xEB, 0xDA, 0xD5, 0xD7, 0x6D, 0x00, 0xFC, 0xFE, 0xF7, 0xF6, 0x5E, 0x77,
    0x01, 0xBE, 0x1F, 0x80, 0xB0, 0x0E, 0xC2, 0xAF, 0x1E, 0xFF, 0xE2, 0xFA, 0x93, 0x90, 0xEE, 0xED, 0xD6, 0x0D, 0xD7, 0xAF, 0x87, 0xF0,
    0xFE, 0x17, 0xFA, 0xB4, 0xBA, 0xC8, 0xE2, 0x87, 0x45, 0xB4, 0xDA, 0x01, 0xDF, 0x6F, 0xDE, 0x60, 0x6C, 0x55, 0x05, 0xE1, 0x5B, 0x10,
    0x7E, 0x02, 0x61, 0x1E, 0x84, 0x9F, 0x42, 0xB8, 0x1A, 0xC2, 0xCF, 0x58, 0x3A, 0x08, 0xAB, 0x21, 0x5C, 0x03, 0xE1, 0xE7, 0x10, 0xDE,
    0xF1, 0xC7, 0x99, 0x56, 0x0F, 0x41, 0xD8, 0x7F, 0xC3, 0xE3, 0x7E, 0x0B, 0x80, 0x4E, 0xF0, 0xE6, 0x25, 0x7E, 0xCB, 0x80, 0xEF, 0x8F,
    0x7D, 0x37, 0xFA, 0xAD, 0x05, 0x7C, 0x59, 0xDA, 0x7E, 0xBF, 0x29, 0x80, 0x9F, 0x0B, 0xFD, 0xC1, 0xEF, 0x08, 0x7C, 0xB7, 0x5D, 0xF8,
    0xF5, 0x0D, 0x66, 0x08, 0xD7, 0x25, 0x35, 0x6F, 0xDD, 0x07, 0xF0, 0x77, 0x20, 0xEC, 0x0B, 0x61, 0xFC, 0x5F, 0x3D, 0x5B, 0xFF, 0x01,
    0x78, 0xF8, 0xC4, 0x4F, 0x5B, 0xB3, 0x77, 0x56, 0x23, 0x20, 0x7C, 0x12, 0xC2, 0x7B, 0x22, 0x3E, 0x6D, 0x3D, 0x14, 0xC2, 0x67, 0xF3,
    0xFC, 0x6E, 0x5C, 0x07, 0x74, 0x93, 0x6E, 0x9E, 0x71, 0x63, 0x37, 0x08, 0xA7, 0x4C, 0xDA, 0x73, 0x63, 0x2F, 0x08, 0x9F, 0xD1, 0x1D,
    0xBE, 0xF1, 0x09, 0x08, 0x07, 0x5C, 0xBA, 0x78, 0x23, 0x5B, 0x17, 0xFF, 0xBE, 0x7C, 0xF1, 0x46, 0x36, 0x0F, 0x5F, 0x0C, 0x7B, 0xC4,
    0xFF, 0x3E, 0xA0, 0xB7, 0x6B, 0x66, 0xB4, 0x7F, 0x2C, 0xFC, 0xFE, 0x1E, 0x84, 0x71, 0x10, 0xB6, 0xFB, 0x7B, 0x9A, 0x3F, 0xC0, 0xBA,
    0x7F, 0x97, 0x57, 0xFB, 0xE7, 0xC3, 0x1F, 0x77, 0xB6, 0x5F, 0x74, 0xD3, 0x25, 0x08, 0x07, 0x97, 0xB4, 0xBA, 0xB9, 0x1B, 0x84, 0x6F,
    0x34, 0x1B, 0x75, 0xF3, 0x7B, 0x10, 0x1E, 0x3C, 0x98, 0x77, 0xF3, 0xAB, 0x10, 0x6F, 0xD8, 0xBB, 0xAB, 0x6E, 0x3E, 0x0C, 0xE9, 0xB2,
    0x8E, 0x06, 0xDF, 0x72, 0x05, 0xF0, 0x6B, 0x62, 0x9E, 0xB9, 0xA5, 0x98, 0x95, 0xF3, 0x96, 0x57, 0x6F, 0x59, 0x0F, 0xE1, 0x85, 0x03,
    0x75, 0xB7, 0xAC, 0x03, 0x7C, 0xCE, 0xDA, 0x17, 0x02, 0xEE, 0x85, 0xF0, 0x1B, 0x63, 0x51, 0x40, 0x33, 0x88, 0x3F, 0x6E, 0xF6, 0xBE,
    0x80, 0x5E, 0xF0, 0x5D, 0xD1, 0xFD, 0x8B, 0x80, 0x68, 0x88, 0xB7, 0xE9, 0x7F, 0xD7, 0xB6, 0x49, 0x00, 0x3C, 0x38, 0x3D, 0xBA, 0x4D,
    0x2C, 0xD0, 0xED, 0x0F, 0x61, 0x1C, 0xCB, 0xEF, 0xDA, 0x45, 0x6D, 0x16, 0x40, 0x78, 0x68, 0xCD, 0xE6, 0x36, 0xD1, 0x10, 0xF6, 0x48,
    0xD9, 0xD5, 0x66, 0x3C, 0xA4, 0x3B, 0x76, 0xD7, 0xE7, 0x6D, 0x8A, 0x20, 0xFE, 0xFC, 0xA4, 0xBA, 0x36, 0xF3, 0xE0, 0x3B, 0x73, 0xD4,
    0x7F, 0x6D, 0xEE, 0x03, 0x3A, 0x05, 0xDB, 0x9A, 0xDD, 0xBA, 0x00, 0xF0, 0x2F, 0xC6, 0x3F, 0x70, 0xEB, 0x5F, 0x80, 0xDF, 0x74, 0x25,
    0xF4, 0xD6, 0x1C, 0x26, 0x73, 0xAC, 0xAE, 0xB9, 0xF5, 0x28, 0x2B, 0x77, 0xF8, 0xB8, 0xDB, 0x7E, 0x06, 0xBC, 0xFA, 0x97, 0xD4, 0xDB,
    0x6E, 0x81, 0xF8, 0x43, 0x06, 0xCF, 0xBC, 0x6D, 0x0A, 0xE0, 0xCF, 0x4C, 0x7B, 0xA8, 0xED, 0x3C, 0x48, 0x57, 0xB0, 0xEF, 0xC5, 0x76,
    0x2F, 0xB2, 0xF2, 0xA7, 0xC5, 0xB5, 0xBB, 0x8B, 0xF5, 0x87, 0x8F, 0x96, 0xB5, 0xEB, 0x09, 0xF8, 0xD8, 0xDF, 0xBE, 0x69, 0xD7, 0x1D,
    0xC2, 0xFC, 0x73, 0x77, 0xDF, 0xAE, 0x83, 0x70, 0x3D, 0x84, 0x3E, 0x10, 0x3E, 0xFC, 0x67, 0xE7, 0xDB, 0x9F, 0x03, 0x7A, 0xE3, 0xBB,
    0x3F, 0x7A, 0xFB, 0x2F, 0x90, 0xAE, 0xDF, 0xAF, 0x5F, 0xDE, 0xFE, 0x04, 0x7C, 0xD7, 0x4C, 0x9D, 0xDE, 0xFE, 0x81, 0x66, 0xAC, 0x5F,
    0x2D, 0x6D, 0xFF, 0x12, 0xD0, 0xE9, 0xD1, 0xAD, 0xB8, 0x7D, 0x2F, 0x08, 0xBB, 0xCC, 0xEB, 0xD7, 0x61, 0x38, 0xC4, 0xFB, 0xC9, 0x94,
    0xD4, 0x61, 0x11, 0x7C, 0xDF, 0xD5, 0x2A, 0xA3, 0x03, 0xDB, 0x4B, 0xD6, 0xB4, 0xCE, 0xE8, 0x70, 0x1B, 0x84, 0x9B, 0xDB, 0xCD, 0xED,
    0x30, 0x1C, 0xE8, 0x76, 0x3B, 0x3C, 0xF8, 0x8E, 0xE7, 0xE1, 0xF7, 0x81, 0x3D, 0xF6, 0xDC, 0xC1, 0x64, 0x97, 0x31, 0x77, 0x1E, 0xBF,
    0x23, 0x0C, 0xBE, 0x4B, 0xAE, 0x6F, 0x76, 0xE7, 0x5F, 0x10, 0xAE, 0xBF, 0x31, 0xE8, 0xCE, 0x61, 0x80, 0xEB, 0xEB, 0x4C, 0x77, 0x66,
    0x42, 0xFC, 0x87, 0xF6, 0x9D, 0xBE, 0xF3, 0x3B, 0xC0, 0x4F, 0xEE, 0xFF, 0xE5, 0xCE, 0xE3, 0xAC, 0x5F, 0xF7, 0xFC, 0xFC, 0xAE, 0x47,
    0x21, 0x2C, 0xCC, 0xFB, 0xDF, 0x5D, 0x29, 0x90, 0x8F, 0x66, 0x61, 0x61, 0x1D, 0x97, 0x43, 0x18, 0xE5, 0x9F, 0xDB, 0x71, 0x37, 0xE0,
    0x25, 0x19, 0x5F, 0x76, 0x8C, 0x67, 0xF9, 0x9D, 0xDA, 0xE3, 0xEE, 0x4B, 0xAC, 0xBD, 0x20, 0xFC, 0x15, 0xC2, 0x1F, 0xFB, 0x3D, 0x7E,
    0xF7, 0x5A, 0xF8, 0x3D, 0xA0, 0xF9, 0x0D, 0xF7, 0xA4, 0xC3, 0xEF, 0x37, 0xBF, 0xD6, 0xF5, 0x9E, 0x7F, 0x99, 0xFE, 0xE6, 0xE8, 0xF0,
    0x7B, 0xDE, 0x86, 0xDF, 0x83, 0xBE, 0x1E, 0x79, 0x4F, 0x0C, 0xFC, 0xBE, 0xA2, 0x24, 0xE3, 0x9E, 0x3A, 0xA0, 0xF7, 0xFD, 0xA1, 0x8C,
    0x7B, 0xDE, 0x82, 0xEF, 0x0B, 0x10, 0xE6, 0x41, 0x18, 0x14, 0x79, 0xFD, 0xBD, 0x0F, 0x41, 0x68, 0x1E, 0xD0, 0xEA, 0xDE, 0xF7, 0xE1,
    0xF7, 0x99, 0x43, 0xB3, 0xEF, 0xBD, 0x04, 0xE9, 0x47, 0xB5, 0x5D, 0x7A, 0xEF, 0xEB, 0x10, 0xCE, 0x6A, 0xF3, 0x40, 0xA7, 0x7E, 0x40,
    0x67, 0x36, 0x84, 0xC1, 0x10, 0x96, 0xDD, 0x30, 0xB7, 0xD3, 0x24, 0x08, 0x5F, 0x1B, 0x95, 0xD9, 0x69, 0x27, 0x84, 0x63, 0xE6, 0x96,
    0x75, 0x3A, 0x02, 0xE1, 0x27, 0xFF, 0x7C, 0xDE, 0xE9, 0x7E, 0xA0, 0xF3, 0x29, 0x84, 0x0F, 0x40, 0x38, 0xA2, 0x57, 0x5D, 0xA7, 0x34,
    0x08, 0x07, 0x7F, 0xF1, 0x47, 0xA7, 0xE7, 0x20, 0xDC, 0xDB, 0xB2, 0x65, 0xE7, 0x3F, 0x80, 0xDE, 0xC8, 0xF7, 0x5E, 0xEC, 0xFC, 0x2E,
    0xA3, 0x0F, 0xE1, 0x26, 0x08, 0x7D, 0xA2, 0xE6, 0x74, 0x9E, 0x0D, 0xE9, 0x33, 0x75, 0xDB, 0x3A, 0x37, 0xB2, 0x7E, 0xD1, 0x70, 0xDD,
    0x7D, 0xA3, 0x20, 0x9C, 0xDB, 0x73, 0xDF, 0x7D, 0xCD, 0x21, 0x7C, 0xE9, 0xC4, 0xB9, 0xFB, 0x06, 0xB3, 0xF6, 0xB8, 0x12, 0xD3, 0xE5,
    0x5B, 0xF6, 0x44, 0x60, 0x8B, 0xD8, 0x2E, 0x5F, 0x41, 0x70, 0xE0, 0xFA, 0xD8, 0x2E, 0x5F, 0x43, 0x38, 0xA7, 0x75, 0x6C, 0x97, 0x6F,
    0x20, 0x7C, 0xEC, 0xE6, 0xD8, 0x2E, 0x35, 0xFC, 0x1C, 0x60, 0x56, 0x97, 0x67, 0x20, 0xDD, 0x2B, 0x65, 0x6F, 0x75, 0x39, 0xC2, 0xCA,
    0xB9, 0xB9, 0xBC, 0x4B, 0x05, 0xA4, 0x6B, 0x7E, 0xEE, 0x4C, 0x97, 0x51, 0x10, 0x5E, 0x1B, 0xFD, 0x4B, 0x97, 0x27, 0x20, 0x8C, 0xFB,
    0xE1, 0xEE, 0xAE, 0xD3, 0x21, 0xDE, 0xEB, 0xDD, 0xA6, 0x77, 0xCD, 0x82, 0x78, 0x6F, 0x40, 0xB8, 0x18, 0xC2, 0xA5, 0x10, 0x2E, 0x81,
    0x30, 0x07, 0xC2, 0xD7, 0x20, 0x3C, 0xFC, 0x55, 0x70, 0xB7, 0x47, 0x21, 0xDE, 0xA0, 0xC6, 0x61, 0xDD, 0x5A, 0x41, 0xBA, 0x6F, 0x0B,
    0xDE, 0xE8, 0xF6, 0x1B, 0x7C, 0x47, 0x3C, 0xBC, 0xB5, 0xDB, 0xB3, 0xC0, 0xEF, 0xDE, 0x47, 0xB7, 0x76, 0x7B, 0x0E, 0xC2, 0x45, 0xDF,
    0x97, 0x75, 0xBB, 0x9E, 0xDD, 0x21, 0xFD, 0xE9, 0x70, 0xB7, 0x3C, 0xC6, 0xEF, 0x7E, 0x9F, 0xFB, 0x27, 0x42, 0xBC, 0xCA, 0x1D, 0xCB,
    0x1F, 0xD8, 0x0C, 0x74, 0x74, 0xC7, 0xD3, 0xBB, 0x8F, 0x61, 0xED, 0xF8, 0xDA, 0x9C, 0xEE, 0xFD, 0x21, 0xDC, 0x03, 0xE1, 0x00, 0x08,
    0x97, 0x7D, 0xF2, 0x57, 0xF7, 0x1F, 0x21, 0xDE, 0xDA, 0x7E, 0x2D, 0x7A, 0xDC, 0x09, 0xDF, 0x77, 0x6F, 0xD9, 0xDE, 0x63, 0x26, 0x84,
    0x1F, 0x3C, 0x76, 0xB2, 0x47, 0xE0, 0x35, 0x6C, 0x7F, 0xD7, 0xA1, 0xE7, 0x1B, 0x40, 0xAF, 0x66, 0xD3, 0x9D, 0x3D, 0xB7, 0x40, 0xF8,
    0xCB, 0x8D, 0xED, 0x1F, 0xBC, 0x8E, 0x8D, 0xE3, 0x6F, 0xDE, 0x7E, 0xF0, 0x19, 0xF8, 0xFD, 0xC8, 0x6B, 0xBB, 0x1E, 0xAC, 0x80, 0x70,
    0xE3, 0xDE, 0x83, 0x0F, 0xCE, 0x06, 0x3A, 0x91, 0x87, 0x7E, 0x7D, 0x70, 0x27, 0x7C, 0x6F, 0xFF, 0x39, 0x2B, 0x30, 0x0B, 0xE2, 0x7F,
    0xB9, 0x69, 0x69, 0xE0, 0x1C, 0xF8, 0x8E, 0xD1, 0xAF, 0x0C, 0x9C, 0x0E, 0xDF, 0x07, 0xF2, 0xE2, 0x82, 0x40, 0xB4, 0xD3, 0x1D, 0x84,
    0xF0, 0x0C, 0x84, 0x87, 0x20, 0xFC, 0x18, 0xC2, 0x94, 0xC9, 0xC5, 0x41, 0x65, 0x40, 0xB7, 0xD9, 0x53, 0xE5, 0x41, 0xB9, 0x40, 0xE7,
    0xBA, 0xD2, 0x7F, 0x83, 0x3E, 0x84, 0x74, 0xDF, 0x8E, 0x6F, 0xA6, 0x8F, 0x64, 0xE5, 0xBE, 0xF6, 0x05, 0xFD, 0x83, 0xF0, 0x3D, 0x3D,
    0x60, 0xB1, 0x3E, 0x00, 0x7E, 0xBF, 0x3B, 0xA7, 0x56, 0xEF, 0x0B, 0xF8, 0x45, 0xFF, 0x8B, 0xFA, 0x57, 0x18, 0xDF, 0x67, 0x56, 0xF7,
    0xBA, 0x06, 0xBE, 0x03, 0x5B, 0x84, 0xF7, 0x6E, 0x04, 0x3A, 0x97, 0xFD, 0xBF, 0xEE, 0xFD, 0x07, 0xA3, 0xBF, 0x77, 0x58, 0x9F, 0xEF,
    0xE0, 0xF7, 0xB1, 0xFF, 0x4C, 0xE9, 0xF3, 0x14, 0x7C, 0xDF, 0xE6, 0x63, 0xE8, 0xF3, 0x34, 0x84, 0xE1, 0xB1, 0x3B, 0xFA, 0x44, 0x41,
    0xBC, 0x15, 0xD7, 0xED, 0xEC, 0x13, 0xD4, 0x8C, 0x8D, 0x8F, 0x9E, 0x7D, 0xFF, 0x84, 0xEF, 0x0F, 0xEA, 0xC6, 0xF4, 0x6D, 0xCE, 0xFC,
    0xFD, 0x3D, 0xBE, 0xA2, 0xEF, 0x61, 0x88, 0xB7, 0x3B, 0xBA, 0x84, 0x4D, 0xA7, 0xBA, 0x56, 0xF3, 0x3F, 0xEC, 0x6B, 0x02, 0xFE, 0x07,
    0x6F, 0xAA, 0xEE, 0xBB, 0x19, 0x80, 0xC7, 0xB7, 0x77, 0xEC, 0x77, 0x1B, 0x84, 0xDB, 0x1F, 0x79, 0xBE, 0x5F, 0x21, 0xE0, 0x96, 0xF6,
    0x79, 0xFD, 0xD2, 0xD8, 0xB8, 0xFE, 0xE2, 0xB7, 0x7E, 0x99, 0x10, 0x76, 0xBE, 0x67, 0x4A, 0x70, 0x17, 0x08, 0xEF, 0x6D, 0x6D, 0x09,
    0xFE, 0x12, 0xD2, 0x4F, 0xFC, 0x77, 0x6E, 0xB0, 0x1E, 0xBE, 0x07, 0x84, 0xAC, 0x0B, 0x6E, 0x0F, 0xDF, 0x3F, 0xCF, 0xFF, 0x32, 0xB8,
    0x13, 0x2B, 0xF7, 0x12, 0x7D, 0xFF, 0xBD, 0x90, 0xBE, 0xCF, 0xB2, 0x27, 0xFA, 0x27, 0xB3, 0x76, 0x1D, 0x33, 0xB4, 0xFF, 0x2B, 0x6C,
    0x7C, 0xDE, 0x91, 0xD1, 0xFF, 0x23, 0x26, 0xFF, 0x16, 0x6C, 0xEB, 0xFF, 0x0C, 0x84, 0xBD, 0x16, 0x7D, 0xDB, 0x7F, 0x31, 0xC4, 0x3F,
    0x61, 0xF8, 0xB5, 0xFF, 0x72, 0xF8, 0x7D, 0x4D, 0xD7, 0xEB, 0x07, 0x8C, 0x81, 0xF8, 0x93, 0x12, 0xA6, 0x0E, 0x78, 0x98, 0x8D, 0x9F,
    0xBE, 0x19, 0x03, 0xEE, 0x82, 0x78, 0x5F, 0x8E, 0xB9, 0x30, 0xE0, 0x77, 0x88, 0xF7, 0x71, 0x65, 0xF0, 0x43, 0x53, 0xE1, 0xFB, 0xE8,
    0x80, 0x01, 0x0F, 0x3D, 0x08, 0xF1, 0x6E, 0x1B, 0x33, 0xF5, 0xA1, 0xEF, 0xE0, 0xFB, 0x11, 0xBF, 0x3D, 0x0F, 0x6D, 0x85, 0xDF, 0x7F,
    0x1E, 0x73, 0xE8, 0xA1, 0x28, 0xD6, 0x4E, 0xDF, 0xDF, 0x3C, 0xF0, 0x55, 0xF8, 0xEE, 0xFA, 0xE7, 0xDD, 0x03, 0xEF, 0x80, 0xF0, 0xF8,
    0xC3, 0xFA, 0x81, 0x0F, 0x43, 0xFC, 0xF3, 0x21, 0xF7, 0x3D, 0xFC, 0x0F, 0xAB, 0xF7, 0xFE, 0x73, 0x1F, 0x5E, 0x05, 0xF1, 0x7E, 0xA9,
    0x58, 0xFB, 0xF0, 0x6C, 0x08, 0x9B, 0xEF, 0x1C, 0x3E, 0x68, 0x32, 0xFC, 0xDE, 0xA7, 0xD5, 0xFB, 0x83, 0xBA, 0x31, 0xBB, 0x8B, 0xFE,
    0xCD, 0x1F, 0xB9, 0x87, 0xD5, 0x07, 0x84, 0xF7, 0xB2, 0xF6, 0xFE, 0xE8, 0xDE, 0x47, 0x22, 0xE0, 0xF7, 0xAD, 0x73, 0x0D, 0x8F, 0xF4,
    0x81, 0xF8, 0xF7, 0xEC, 0x98, 0xFF, 0xC8, 0x12, 0xC0, 0xDF, 0x0A, 0x6D, 0x3F, 0xF8, 0x1F, 0x88, 0xFF, 0x4F, 0xE6, 0xE6, 0xC1, 0x43,
    0x01, 0x9F, 0x39, 0x7F, 0xF3, 0xE0, 0x89, 0x80, 0xFF, 0x7B, 0xEA, 0xD0, 0xA3, 0xF7, 0xC0, 0xF7, 0x1F, 0x95, 0xBF, 0x3C, 0xBA, 0x0F,
    0xC2, 0xFF, 0x41, 0x58, 0x0A, 0xE1, 0x5B, 0x43, 0x75, 0x43, 0x12, 0x20, 0xFE, 0xE9, 0x41, 0x63, 0x86, 0x64, 0x42, 0x78, 0x06, 0xC2,
    0x79, 0x10, 0x7E, 0x0C, 0xE1, 0x7C, 0x76, 0x5E, 0x7B, 0x78, 0xE2, 0x90, 0x97, 0xD9, 0x3C, 0xBB, 0x68, 0xD1, 0x90, 0x4D, 0x10, 0x4E,
    0x38, 0x98, 0x35, 0x24, 0x0F, 0xF8, 0x9E, 0x9B, 0xB1, 0x74, 0xC8, 0x14, 0xD6, 0x7F, 0xDB, 0x85, 0x3D, 0xF6, 0x39, 0x33, 0xBD, 0x5B,
    0x74, 0x43, 0xC8, 0x40, 0xF8, 0xBE, 0xFC, 0xCC, 0x84, 0x90, 0x14, 0xF8, 0xFE, 0x6E, 0x40, 0x4A, 0x88, 0x1E, 0xF8, 0xB6, 0x9E, 0x95,
    0x1E, 0xB2, 0x1D, 0xC2, 0xBF, 0xE7, 0x9D, 0x0F, 0x19, 0x07, 0xF8, 0xE1, 0x6B, 0x9F, 0x7E, 0x7C, 0x38, 0xA4, 0x8F, 0x19, 0x3C, 0xF6,
    0xF1, 0xEB, 0xD8, 0x3C, 0x32, 0x79, 0xD2, 0xE3, 0xED, 0x59, 0xBD, 0x9E, 0x9F, 0xF9, 0xF8, 0x9B, 0x10, 0x1E, 0xBF, 0xA9, 0xEA, 0xF1,
    0x10, 0x08, 0xFD, 0x47, 0x97, 0x3D, 0x51, 0x0E, 0x61, 0xD4, 0xBF, 0xC7, 0x9E, 0x58, 0xCF, 0x64, 0x56, 0x08, 0x37, 0x40, 0xD8, 0xB9,
    0xD9, 0xF1, 0x27, 0x36, 0x42, 0x78, 0x53, 0xC2, 0x99, 0x27, 0x76, 0xB2, 0xF9, 0xA3, 0x22, 0xE5, 0xC9, 0x67, 0x21, 0xDE, 0x8E, 0x7F,
    0xD7, 0x3D, 0xC9, 0x76, 0x50, 0x9D, 0x2D, 0xEF, 0x3F, 0xB9, 0x0D, 0xBE, 0xF5, 0x55, 0x9F, 0x0E, 0x4D, 0x87, 0xDF, 0x9F, 0x3F, 0xDA,
    0x6B, 0xD8, 0x6A, 0x36, 0x4E, 0x5B, 0x0E, 0x1D, 0xD6, 0x02, 0xBE, 0x2F, 0x07, 0x6C, 0x19, 0x36, 0x16, 0xC2, 0xF9, 0xCD, 0x4E, 0x0F,
    0xFB, 0x17, 0xF0, 0xA8, 0xD6, 0xB1, 0x4F, 0x5D, 0x81, 0x30, 0x71, 0xEB, 0xDA, 0xA7, 0xDA, 0x41, 0xFA, 0x57, 0xF7, 0x8C, 0x7A, 0xFA,
    0x05, 0xF8, 0xBD, 0x75, 0x61, 0xE8, 0xD3, 0x85, 0x80, 0xBF, 0x5E, 0x18, 0xF6, 0x74, 0x18, 0x7C, 0xA7, 0xDD, 0x77, 0xD7, 0xF0, 0x83,
    0x6C, 0x3C, 0x4D, 0x7E, 0x74, 0xF8, 0x49, 0x88, 0xF7, 0xC3, 0xBC, 0xED, 0xC3, 0x5F, 0x86, 0xEF, 0x56, 0xB7, 0xD7, 0x0C, 0x2F, 0x66,
    0xFB, 0xB5, 0xB9, 0x17, 0x86, 0x57, 0xB1, 0x33, 0xDC, 0x8E, 0x27, 0x9E, 0x99, 0x09, 0xF1, 0x7F, 0x85, 0x70, 0x16, 0x84, 0xAF, 0x6E,
    0x18, 0xFE, 0x6C, 0x47, 0x08, 0x97, 0x76, 0x58, 0xFF, 0xEC, 0xBD, 0xF0, 0x7B, 0x9F, 0x9F, 0x4E, 0x3D, 0xFB, 0x3C, 0x1B, 0xFF, 0x1D,
    0xBA, 0x3E, 0x57, 0x00, 0xE1, 0x6D, 0xE7, 0xC6, 0x3C, 0xF7, 0x0B, 0xFC, 0x3E, 0x74, 0xF8, 0xEC, 0xE7, 0x86, 0xC0, 0xF7, 0xA5, 0x91,
    0x77, 0x8E, 0xD8, 0xC9, 0xEC, 0x0E, 0x37, 0x74, 0x19, 0xD1, 0x05, 0xBE, 0xD7, 0x96, 0x0E, 0x1D, 0x31, 0x8E, 0xF5, 0xB3, 0xEC, 0xAF,
    0x46, 0xAC, 0x80, 0x78, 0x47, 0x96, 0xD5, 0x8E, 0x88, 0x86, 0xF0, 0x85, 0xA0, 0x3F, 0x46, 0xDC, 0x0E, 0xE1, 0xFB, 0xF5, 0xEF, 0x3E,
    0xCF, 0xCE, 0x27, 0xFE, 0xBA, 0x7C, 0xD3, 0xC8, 0x89, 0x10, 0xFF, 0x54, 0xD2, 0x2D, 0x23, 0x2B, 0xE0, 0xFB, 0xE1, 0x4E, 0x5D, 0x47,
    0x1E, 0x87, 0xF0, 0xDB, 0x5E, 0xC3, 0x46, 0x46, 0x41, 0xFA, 0xDB, 0x4F, 0x04, 0x8D, 0x6A, 0x60, 0xED, 0xB1, 0x65, 0xDC, 0xA8, 0x1B,
    0x99, 0xDC, 0x15, 0x3C, 0x6F, 0xD4, 0x93, 0xF0, 0xED, 0x7B, 0xDB, 0xEB, 0xA3, 0x76, 0x40, 0xBC, 0xE9, 0x2B, 0xD7, 0x8E, 0x3E, 0x03,
    0xE1, 0xE0, 0x73, 0xDB, 0x47, 0x8F, 0x82, 0xDF, 0x27, 0x9E, 0x3F, 0x33, 0xE6, 0x4F, 0xF8, 0x7D, 0x6F, 0xEA, 0xEF, 0x63, 0x98, 0x6F,
    0xDC, 0xA9, 0x87, 0xFE, 0x1C, 0x73, 0x03, 0xE0, 0xAD, 0xAB, 0x74, 0x63, 0xB3, 0x01, 0xF7, 0x7B, 0xA8, 0xD9, 0xD8, 0xDB, 0xE1, 0x7B,
    0x68, 0x97, 0xA7, 0xC7, 0x96, 0x41, 0x3E, 0xFA, 0x56, 0xCF, 0x1C, 0x7B, 0x99, 0xCD, 0x17, 0x47, 0x32, 0xC7, 0x7E, 0xC9, 0xD6, 0xD7,
    0x53, 0xDF, 0x8F, 0xFD, 0x0F, 0xD2, 0x5D, 0x73, 0x3C, 0xFD, 0x85, 0xD7, 0x59, 0x3D, 0x76, 0xB8, 0xF4, 0x42, 0x1C, 0x5B, 0x1F, 0x5F,
    0x6B, 0x31, 0xEE, 0x5A, 0xC0, 0x37, 0x40, 0xD8, 0x82, 0xE9, 0x6C, 0xEF, 0xBE, 0x77, 0x5C, 0x21, 0xC4, 0xFF, 0x7C, 0x59, 0xE8, 0xB8,
    0xBF, 0xE1, 0xF7, 0x80, 0x9B, 0xE3, 0xC7, 0xC5, 0x32, 0xB9, 0xCE, 0x6F, 0xC3, 0xB8, 0x16, 0x40, 0xBF, 0xCB, 0xB9, 0x67, 0x5E, 0xFC,
    0x01, 0xBE, 0x8F, 0xFD, 0xF8, 0xE1, 0x8B, 0xDB, 0x20, 0xDE, 0x3B, 0xBB, 0x8E, 0xBE, 0xF8, 0x03, 0x93, 0xEF, 0xFE, 0xAB, 0x78, 0x71,
    0x31, 0x84, 0xAB, 0x20, 0x5C, 0x02, 0x61, 0x88, 0xF9, 0xFC, 0x8B, 0xBE, 0xAC, 0x5D, 0x8C, 0x9D, 0xC7, 0xAF, 0x85, 0xF0, 0xFD, 0x1B,
    0xFA, 0x4D, 0xB8, 0x83, 0xCD, 0x33, 0x10, 0x32, 0x9B, 0xF9, 0x8B, 0x2F, 0x3C, 0x3C, 0x61, 0x10, 0xD0, 0x8B, 0x6C, 0x97, 0x3B, 0x21,
    0x07, 0xE2, 0xB7, 0x0B, 0x3C, 0x3B, 0x61, 0x18, 0x93, 0x13, 0x1E, 0xCB, 0x0E, 0x6D, 0xCF, 0xE6, 0x87, 0x89, 0xD9, 0xA1, 0xBD, 0x21,
    0x5C, 0xF9, 0xEC, 0xC3, 0x2F, 0x35, 0x40, 0xFC, 0x07, 0x1E, 0xFF, 0xF0, 0xA5, 0xF6, 0x6C, 0xDD, 0x38, 0xD9, 0x7C, 0xE2, 0x7E, 0x88,
    0xD7, 0xF5, 0x9A, 0xEB, 0x26, 0xB2, 0x7B, 0x37, 0xDD, 0x20, 0xEC, 0x0C, 0xE1, 0xFD, 0x10, 0x32, 0xDD, 0xDF, 0x75, 0x41, 0xED, 0x27,
    0x5A, 0x20, 0x5E, 0xCF, 0x70, 0xE3, 0xC4, 0xAE, 0x6C, 0x5C, 0x77, 0x32, 0x4D, 0x4C, 0xBC, 0x86, 0xAD, 0x1B, 0x3E, 0x93, 0x74, 0x3E,
    0x6C, 0xDD, 0xF0, 0x99, 0xE4, 0x03, 0xE1, 0x1B, 0xA1, 0xC3, 0x27, 0xBD, 0xC4, 0xE4, 0x66, 0x08, 0x27, 0xB2, 0x7B, 0x54, 0x10, 0x4E,
    0x82, 0xF0, 0xBF, 0x99, 0x0B, 0x26, 0x7D, 0x0C, 0xE9, 0x03, 0x1B, 0x4E, 0x4F, 0xB2, 0x30, 0xDD, 0xD1, 0x8F, 0xE6, 0xB0, 0x1A, 0x88,
    0x3F, 0x69, 0xF1, 0x77, 0x61, 0x5F, 0xB0, 0xF9, 0x31, 0xEE, 0xEF, 0xB0, 0xC7, 0x98, 0xDC, 0xF5, 0xFE, 0x4D, 0xE1, 0xCD, 0x58, 0x3D,
    0x5C, 0x7B, 0x77, 0xF8, 0xDB, 0xAC, 0x7F, 0x1C, 0x78, 0x38, 0x7C, 0x25, 0xEB, 0x37, 0x8F, 0xB5, 0x89, 0xA8, 0x65, 0xF3, 0xE7, 0xDE,
    0x6E, 0x11, 0x23, 0xF8, 0xFA, 0x38, 0x30, 0xA2, 0x2F, 0x9B, 0xFF, 0x76, 0x3C, 0x1A, 0x91, 0xCD, 0xE4, 0xA5, 0x86, 0xC3, 0x11, 0x93,
    0xE1, 0xF7, 0xEB, 0x06, 0xCE, 0x89, 0xEC, 0xC4, 0xC6, 0xDB, 0xD1, 0x5D, 0x91, 0x83, 0x21, 0xCC, 0xE8, 0x70, 0x5D, 0xD4, 0x7C, 0x36,
    0xDF, 0x1C, 0xFE, 0x21, 0xAA, 0x8A, 0xA5, 0x2F, 0x6C, 0x8C, 0xEA, 0x01, 0xDF, 0x77, 0x8E, 0x7C, 0x3A, 0xFA, 0x6E, 0x48, 0xF7, 0xCD,
    0x98, 0xA7, 0xA3, 0xD9, 0x7D, 0x9F, 0x8D, 0xC1, 0x11, 0xD1, 0xBB, 0x20, 0x7C, 0x74, 0x66, 0x5A, 0x8C, 0x2F, 0xD0, 0xFD, 0x2C, 0x3D,
    0x33, 0xE6, 0x7B, 0xD6, 0xFE, 0xB1, 0x79, 0x31, 0x83, 0xE0, 0xFB, 0xBD, 0xB6, 0xBA, 0xD8, 0x55, 0xF0, 0x5D, 0xD1, 0xDE, 0x3F, 0xB6,
    0x25, 0xA4, 0x3F, 0xD6, 0x5D, 0x1F, 0xFB, 0x01, 0x7C, 0xBF, 0xFF, 0xE6, 0xC2, 0xD8, 0x56, 0x90, 0xAE, 0x4D, 0xFB, 0xD7, 0x62, 0x4D,
    0x10, 0xEF, 0x89, 0x99, 0x4B, 0x63, 0x73, 0x01, 0x6F, 0x3F, 0xFB, 0xC7, 0xD8, 0x02, 0x26, 0x57, 0x4C, 0x9E, 0x1F, 0xF7, 0x37, 0xE0,
    0x8F, 0x35, 0xDB, 0x1E, 0x97, 0xCF, 0xC6, 0x7B, 0x52, 0xBB, 0xF8, 0x61, 0x80, 0x37, 0xEE, 0x5A, 0x1A, 0xBF, 0x1B, 0xF0, 0x2D, 0xFF,
    0x7B, 0x27, 0xDE, 0x0C, 0xF8, 0x56, 0x08, 0x2D, 0x10, 0xCE, 0x6B, 0x1F, 0x38, 0x79, 0x36, 0xBB, 0x37, 0xFD, 0x48, 0x9F, 0xC9, 0x07,
    0x20, 0x5E, 0x6D, 0xFC, 0xC0, 0xC9, 0xB7, 0xB1, 0xF5, 0x3C, 0x7F, 0xF8, 0xE4, 0x27, 0x21, 0xFE, 0xB7, 0x5F, 0x44, 0x4F, 0x5E, 0x0F,
    0xDF, 0xB1, 0xEB, 0x5B, 0x4E, 0x79, 0x94, 0xED, 0x63, 0x5A, 0x4E, 0x98, 0x12, 0x0A, 0xDF, 0x45, 0x8B, 0xB7, 0x4D, 0xF9, 0x08, 0xC2,
    0xD1, 0x7E, 0x95, 0x53, 0x12, 0x01, 0x1F, 0xDF, 0x3A, 0xCA, 0xF0, 0x2B, 0x93, 0xE3, 0xC7, 0x2E, 0x31, 0x8C, 0x61, 0xFD, 0x5B, 0x77,
    0xD9, 0xE0, 0x07, 0xBF, 0xBF, 0xBA, 0xEE, 0xA6, 0x84, 0x73, 0x40, 0xFF, 0xE9, 0x0D, 0x37, 0x25, 0x7C, 0xCB, 0xE4, 0x97, 0x8E, 0xDD,
    0x12, 0x5A, 0xB2, 0x7D, 0xD5, 0x47, 0x96, 0x84, 0x48, 0x88, 0x9F, 0x0A, 0x61, 0x14, 0x5B, 0xE7, 0x9F, 0xDC, 0x9F, 0xF0, 0x29, 0xE0,
    0x9F, 0xFF, 0xEE, 0x97, 0xF8, 0x13, 0xA4, 0xFF, 0x02, 0xC2, 0x7A, 0x08, 0x1B, 0x42, 0x47, 0x27, 0xB6, 0x85, 0xDF, 0x8D, 0x31, 0xD9,
    0x89, 0xD3, 0x81, 0xDE, 0xB3, 0xCF, 0x1F, 0x4D, 0x2C, 0x86, 0xF0, 0x39, 0x08, 0x77, 0x41, 0xB8, 0xFB, 0x58, 0xE7, 0xA4, 0xA5, 0x4C,
    0x2E, 0x80, 0x30, 0x07, 0xC2, 0xD4, 0x8B, 0x9D, 0x93, 0xAA, 0x21, 0x5D, 0xD8, 0xBB, 0xB3, 0x92, 0xF6, 0x40, 0xBA, 0x96, 0x77, 0x6D,
    0x4A, 0xFA, 0x1A, 0xBE, 0x4F, 0x1D, 0x29, 0x4D, 0xBA, 0x16, 0x7E, 0xEF, 0xB5, 0xA1, 0x95, 0xD1, 0x08, 0xDF, 0x83, 0xB6, 0x3D, 0x69,
    0x6C, 0x80, 0xDF, 0x7F, 0xBE, 0xC5, 0x6C, 0xEC, 0x0E, 0x61, 0xC1, 0x83, 0x6B, 0x8D, 0x23, 0x21, 0x2C, 0x6B, 0xB9, 0xD3, 0x78, 0x0F,
    0xDB, 0xDF, 0x14, 0xD6, 0x1A, 0x8F, 0x41, 0x7E, 0x5E, 0xCA, 0xB8, 0x64, 0xDC, 0x0E, 0xE9, 0x5E, 0x5E, 0x78, 0xFD, 0xD4, 0xA9, 0x6C,
    0x9D, 0xD9, 0x7A, 0xEB, 0xD4, 0x97, 0xE0, 0x77, 0xFD, 0x85, 0xAE, 0x53, 0xB3, 0x21, 0xEC, 0x1D, 0x3B, 0x68, 0xEA, 0x8D, 0x10, 0xFA,
    0xEC, 0x19, 0x62, 0xBA, 0x9B, 0xF1, 0x4B, 0x3F, 0x6D, 0x2A, 0x87, 0x78, 0x7F, 0xF4, 0xF8, 0xC9, 0xB4, 0x87, 0xE9, 0x73, 0xFF, 0xCB,
    0xB1, 0xEC, 0x82, 0xEF, 0xC9, 0xA7, 0xD6, 0x58, 0x52, 0xD8, 0xB8, 0x1B, 0x7F, 0x63, 0xF2, 0x66, 0x76, 0xB6, 0x0A, 0x61, 0x21, 0xB3,
    0xEB, 0x4D, 0x1A, 0x99, 0xFC, 0x16, 0x93, 0xEF, 0x37, 0x8F, 0x4B, 0x1E, 0x08, 0xF1, 0x16, 0x6D, 0x1B, 0x97, 0xFC, 0x30, 0x84, 0xFF,
    0x5D, 0x93, 0x97, 0x3C, 0x8F, 0xC9, 0xCB, 0x4F, 0xE4, 0x25, 0xD7, 0xC3, 0xEF, 0xF3, 0x6A, 0x7A, 0xA6, 0xAC, 0x86, 0xF4, 0x27, 0xF2,
    0x1F, 0x4C, 0xD9, 0xC2, 0xE6, 0xB7, 0x8C, 0x57, 0x53, 0xC2, 0xD9, 0x5D, 0xAD, 0xE6, 0x3F, 0xA6, 0x7C, 0x04, 0xBF, 0x97, 0xEF, 0xBC,
    0x92, 0x32, 0x19, 0xBE, 0xD7, 0x0E, 0x8C, 0x4F, 0x3D, 0x01, 0xE1, 0xF3, 0xE7, 0x4A, 0x52, 0x3B, 0x42, 0xFA, 0x57, 0x6A, 0xF7, 0xA6,
    0x0E, 0x85, 0xDF, 0x73, 0xD6, 0x76, 0x4B, 0x5B, 0x08, 0xE9, 0xAA, 0x22, 0x5E, 0x4A, 0x1B, 0x0F, 0xBF, 0x7F, 0x02, 0xE1, 0x04, 0x08,
    0x97, 0xC5, 0xBC, 0x94, 0x16, 0x0A, 0xE1, 0xBA, 0xFF, 0xE6, 0xA4, 0x4D, 0x80, 0xF8, 0x7B, 0x6A, 0x0F, 0xA4, 0x6D, 0x84, 0x78, 0x29,
    0xE5, 0x27, 0xD2, 0x3E, 0x80, 0x74, 0x0D, 0xD9, 0x17, 0xD2, 0xB6, 0x31, 0xB9, 0x79, 0x5D, 0xF0, 0xB4, 0xF9, 0xF0, 0x7D, 0xB2, 0xDF,
    0xC4, 0x69, 0x09, 0x4C, 0xFE, 0x6B, 0x16, 0x3B, 0x6D, 0x35, 0x7C, 0xFB, 0x8D, 0x7E, 0x65, 0xDA, 0x9F, 0x10, 0x9E, 0x79, 0xF9, 0xEF,
    0x69, 0xAF, 0xB3, 0x79, 0xF4, 0xE2, 0x90, 0x19, 0x47, 0xE1, 0xF7, 0xE4, 0x63, 0x4F, 0xCF, 0x78, 0x15, 0xE8, 0x8C, 0xDC, 0x91, 0x3E,
    0xE3, 0x66, 0x08, 0x47, 0x41, 0x78, 0x0B, 0xEB, 0x77, 0xF7, 0x65, 0xCE, 0x78, 0x93, 0xC9, 0x91, 0x9F, 0xE7, 0xCD, 0x78, 0x9B, 0xC9,
    0x89, 0xE3, 0x03, 0xD3, 0x57, 0x32, 0x39, 0xF6, 0x93, 0x09, 0xE9, 0xFB, 0x59, 0xFE, 0x5F, 0xDE, 0x9A, 0x1E, 0xC1, 0xE4, 0x80, 0x7F,
    0xBE, 0x4A, 0xBF, 0x13, 0xE2, 0xFD, 0x16, 0x31, 0x7A, 0xE6, 0x3F, 0x40, 0xF7, 0xA9, 0xBB, 0x26, 0xCC, 0x5C, 0x09, 0xDF, 0x0F, 0xAE,
    0x48, 0x9F, 0xB9, 0x0C, 0xBE, 0x8F, 0x7F, 0x78, 0x64, 0xE6, 0x01, 0x08, 0xBB, 0xDE, 0x77, 0xFD, 0xAC, 0x43, 0x6C, 0xFD, 0x4E, 0xC8,
    0x9C, 0xB5, 0x9C, 0xED, 0xC3, 0x6F, 0x5E, 0x3F, 0x2B, 0x92, 0xC9, 0x91, 0x77, 0x6E, 0x98, 0xF5, 0x22, 0xEB, 0x07, 0x01, 0x5B, 0x66,
    0xE5, 0x43, 0x58, 0x97, 0x3B, 0x68, 0xF6, 0xFB, 0x4C, 0x9E, 0x98, 0xF5, 0xEA, 0x6C, 0x13, 0x84, 0xC7, 0x20, 0x64, 0x6F, 0x38, 0xD7,
    0x6F, 0x39, 0x38, 0xFB, 0x41, 0xF8, 0xBD, 0x7B, 0xAB, 0xC3, 0xB3, 0xAF, 0x83, 0x70, 0x46, 0xF2, 0xF9, 0xD9, 0x23, 0xD9, 0x19, 0x04,
    0x84, 0xA3, 0xD8, 0xFC, 0x76, 0xFD, 0x9F, 0xB3, 0xB7, 0x70, 0x1F, 0xD1, 0x33, 0x33, 0x3A, 0x01, 0xBF, 0xFD, 0x4F, 0xCE, 0xCB, 0x78,
    0x8C, 0xED, 0x4B, 0x5A, 0x54, 0x67, 0x2C, 0x64, 0x72, 0xCD, 0x9A, 0xCB, 0x2F, 0x3F, 0x04, 0xDF, 0x2D, 0x12, 0xEE, 0x9D, 0x73, 0x86,
    0xED, 0x1F, 0x47, 0x3D, 0x30, 0x67, 0x0A, 0x84, 0x7F, 0x3D, 0x33, 0x9D, 0x89, 0x8D, 0xBA, 0xF6, 0x1D, 0xE7, 0xCE, 0x61, 0x1B, 0xCC,
    0xFB, 0xCB, 0xAF, 0xCC, 0x09, 0x81, 0xF0, 0x3B, 0x9F, 0x76, 0x73, 0x1F, 0x07, 0xFC, 0x64, 0x42, 0xCA, 0xDC, 0xCF, 0x20, 0x3C, 0x05,
    0x61, 0x35, 0x84, 0x7B, 0xFF, 0x38, 0x96, 0xF9, 0x3C, 0xFC, 0x7E, 0x4F, 0xCF, 0x1B, 0xE7, 0x7D, 0xC8, 0xD6, 0xC3, 0xBE, 0xC3, 0xE7,
    0xFD, 0xC6, 0xF6, 0x1F, 0x9B, 0x62, 0xE6, 0xFD, 0x8F, 0xAD, 0x93, 0xB9, 0xCD, 0xE7, 0x7F, 0x0C, 0xF1, 0xDE, 0xFA, 0x64, 0xD1, 0x2B,
    0x31, 0xF0, 0xDD, 0x78, 0xA1, 0xE0, 0x95, 0x71, 0x10, 0x6E, 0x5F, 0xF9, 0xE7, 0x2B, 0x3F, 0x02, 0xFE, 0xBF, 0xF5, 0x99, 0x0B, 0xE2,
    0x21, 0xFE, 0x8E, 0xAF, 0xDE, 0x5A, 0xB0, 0x94, 0xCD, 0x9B, 0xFF, 0x14, 0x2D, 0xB8, 0x19, 0xBE, 0x47, 0x05, 0x7C, 0xB3, 0x20, 0x98,
    0xAD, 0x9B, 0x2F, 0x2C, 0x5D, 0x38, 0x06, 0xE2, 0xFD, 0x06, 0xE1, 0x58, 0x08, 0x77, 0x4C, 0x58, 0xBA, 0xF0, 0x05, 0xA6, 0x77, 0x48,
    0xCB, 0x59, 0x58, 0x0A, 0xF1, 0x36, 0x40, 0xF8, 0x3E, 0x84, 0x0F, 0x1D, 0xA9, 0x5D, 0x98, 0xCE, 0xE4, 0x98, 0x7F, 0xEB, 0x16, 0xDE,
    0x0A, 0xDF, 0x3F, 0xA5, 0x6F, 0x7A, 0xF5, 0x43, 0x48, 0x9F, 0xB5, 0xED, 0x9B, 0x57, 0x97, 0xC1, 0xF7, 0x5F, 0x9D, 0x06, 0x2E, 0x7A,
    0x07, 0x7E, 0x7F, 0x7E, 0xA2, 0x29, 0xAB, 0x8C, 0xD5, 0xC3, 0xA0, 0xE4, 0xAC, 0x97, 0xD9, 0x19, 0x74, 0xC7, 0x39, 0x59, 0x6F, 0x32,
    0x5B, 0x8E, 0xAF, 0xEF, 0x5C, 0x3C, 0x17, 0x7E, 0xAF, 0xEB, 0x79, 0xEF, 0xE2, 0x73, 0xF0, 0x7B, 0xE4, 0xBC, 0x7E, 0x8B, 0xF7, 0x41,
    0xFA, 0x61, 0xD7, 0xCE, 0x5B, 0xFC, 0x2E, 0x84, 0x7F, 0xFF, 0xF3, 0xCE, 0xE2, 0xB5, 0x2C, 0x9F, 0xC5, 0x3B, 0x17, 0x97, 0x40, 0xBC,
    0xEC, 0x7B, 0xEB, 0x16, 0x5F, 0x0B, 0xF8, 0x6B, 0x35, 0x91, 0x4B, 0xC6, 0xC2, 0xF7, 0xF2, 0xB6, 0x1F, 0x2E, 0xE9, 0x09, 0xBF, 0xCF,
    0xEA, 0x78, 0x6A, 0xC9, 0x38, 0xF8, 0xBE, 0x23, 0xBF, 0x6A, 0xC9, 0x48, 0xB6, 0x7F, 0xF1, 0xAF, 0x5E, 0x52, 0xC2, 0xCA, 0xFD, 0xEE,
    0x85, 0x25, 0x3E, 0x4C, 0xCE, 0xD8, 0xF3, 0xC2, 0x6B, 0xD1, 0xF0, 0xFB, 0x8C, 0x7B, 0xA7, 0xBE, 0xF6, 0x06, 0x5B, 0x3F, 0x0F, 0x6E,
    0x78, 0x6D, 0x34, 0x9B, 0xA7, 0x9E, 0x6C, 0x97, 0xDD, 0x12, 0x7E, 0x3F, 0xFA, 0x51, 0x51, 0xF6, 0xDF, 0x6C, 0x1D, 0x48, 0x3A, 0x96,
    0x1D, 0x01, 0xE9, 0xCB, 0xF7, 0x5E, 0xF7, 0xFA, 0x21, 0xD6, 0x7F, 0x6F, 0x99, 0xFD, 0xFA, 0x0D, 0xF0, 0xDD, 0x2E, 0xED, 0xAD, 0xD7,
    0xB7, 0x42, 0xFC, 0xFD, 0xF7, 0x7E, 0xF1, 0xFA, 0x41, 0x36, 0x2E, 0x77, 0xFE, 0xFD, 0xFA, 0x59, 0xB6, 0xEF, 0x3E, 0x7C, 0xCB, 0x1B,
    0x1D, 0x98, 0xBC, 0xB7, 0xF9, 0xC9, 0xA5, 0xD3, 0x20, 0x5C, 0x68, 0x1C, 0xBF, 0x74, 0x3C, 0xFC, 0x1E, 0x5E, 0x3C, 0x61, 0x69, 0x29,
    0x3B, 0x37, 0x79, 0x75, 0xC6, 0xD2, 0xF7, 0x98, 0xDC, 0x03, 0xE1, 0x6E, 0xD6, 0x8F, 0x21, 0x2C, 0x81, 0xF0, 0xE6, 0xC7, 0x5E, 0x59,
    0x3A, 0x88, 0x8D, 0xDF, 0xBE, 0x8B, 0x96, 0x06, 0x02, 0x9F, 0x05, 0x17, 0x7A, 0xE7, 0x3C, 0x00, 0xF1, 0x17, 0x42, 0xC8, 0xEC, 0xF6,
    0x87, 0xFD, 0xD4, 0x3B, 0xA7, 0x07, 0x84, 0x4F, 0x41, 0xC8, 0xFC, 0x9E, 0x5F, 0x7F, 0xB1, 0x77, 0xCE, 0x83, 0x4C, 0x2E, 0x87, 0x90,
    0x69, 0xFC, 0x2E, 0x1E, 0x48, 0xCE, 0x79, 0x01, 0xD2, 0xA7, 0xC5, 0x65, 0xE6, 0xEC, 0x62, 0xED, 0xFD, 0xCC, 0x5D, 0xCB, 0x12, 0xD9,
    0x7C, 0xB2, 0x6E, 0xD9, 0xB2, 0x00, 0xB6, 0x3F, 0x99, 0xFF, 0xEE, 0xB2, 0x09, 0x4C, 0x3E, 0xBF, 0x75, 0xCC, 0xF2, 0xCD, 0x10, 0x26,
    0xBE, 0x53, 0xB8, 0xBC, 0x05, 0x9B, 0x1F, 0xDE, 0x2C, 0x5A, 0xFE, 0x36, 0xD3, 0x43, 0xCC, 0x2A, 0x59, 0xDE, 0x0D, 0xBE, 0xFB, 0xAD,
    0xBA, 0xB0, 0xFC, 0x13, 0xB6, 0x3E, 0x4F, 0xF8, 0x75, 0x79, 0x0E, 0x1B, 0xFF, 0x1B, 0x46, 0xAE, 0xE8, 0x01, 0x61, 0xE9, 0x2A, 0xC3,
    0x8A, 0x0C, 0x08, 0xCF, 0xF6, 0xF4, 0xCD, 0x6D, 0xC5, 0xF4, 0x26, 0x4F, 0xB6, 0xCA, 0x0D, 0x66, 0xF5, 0x37, 0xF6, 0x96, 0xDC, 0x45,
    0x10, 0xAE, 0x7E, 0x71, 0x7E, 0x6E, 0x47, 0x08, 0x17, 0x0F, 0x38, 0x9A, 0xCB, 0x9E, 0x92, 0xFF, 0xA8, 0xF3, 0x9D, 0x2B, 0xDF, 0x62,
    0xF2, 0x6D, 0xAB, 0xD2, 0x95, 0x45, 0x40, 0x6F, 0x55, 0xC2, 0x57, 0x2B, 0xDB, 0xC2, 0xEF, 0xCD, 0x72, 0xEF, 0x78, 0xB3, 0x0F, 0x6B,
    0xAF, 0x09, 0xD3, 0xDF, 0xEC, 0x0C, 0xDF, 0x03, 0x5B, 0x8D, 0x7A, 0xAB, 0x0E, 0x7E, 0x5F, 0xD9, 0xCD, 0xFC, 0x56, 0x31, 0xD3, 0x17,
    0xE5, 0xBF, 0xFB, 0xD6, 0x71, 0x48, 0x57, 0xBC, 0xBC, 0x5B, 0xDE, 0xEF, 0xF0, 0x7D, 0xF1, 0xAE, 0x98, 0xBC, 0xA7, 0x21, 0xDE, 0x2B,
    0xDD, 0xE6, 0xE4, 0x7D, 0x03, 0xF8, 0xA5, 0x1B, 0x9A, 0xAF, 0xEA, 0x0D, 0xDF, 0xD7, 0x3C, 0xF2, 0xE2, 0xAA, 0xBB, 0xE1, 0x7B, 0x7A,
    0x68, 0xFA, 0xAA, 0xFE, 0x10, 0x2F, 0xFF, 0xB1, 0xD5, 0xAB, 0x5E, 0x84, 0x70, 0xCA, 0xF3, 0x17, 0x56, 0x6D, 0x64, 0xEB, 0x74, 0xE7,
    0x5F, 0x57, 0x0D, 0x61, 0xE5, 0xBC, 0xB5, 0xCB, 0xEA, 0x1F, 0x98, 0xFC, 0xD8, 0xFF, 0xB5, 0xD5, 0xEB, 0x20, 0x84, 0x55, 0xEE, 0xED,
    0x97, 0xD9, 0x7C, 0xFD, 0xC1, 0x5B, 0x6B, 0xFA, 0xC3, 0x77, 0xD0, 0x75, 0x2D, 0xD6, 0x8E, 0x65, 0xFB, 0xA8, 0x23, 0x83, 0xD6, 0xA6,
    0x32, 0xBD, 0xCC, 0x6F, 0x69, 0x6B, 0x47, 0xB0, 0xF5, 0xE9, 0x93, 0x4F, 0xD7, 0xB6, 0x66, 0xE5, 0x09, 0xB8, 0x6D, 0x5D, 0x5F, 0xB6,
    0x9F, 0x5E, 0xDF, 0x7B, 0xDD, 0x11, 0x36, 0xCF, 0x0D, 0x1E, 0xF6, 0x4E, 0x08, 0x9B, 0x9F, 0x7F, 0xBD, 0x31, 0xBF, 0x2B, 0xD0, 0x89,
    0xEF, 0xD3, 0x7B, 0xFD, 0x7E, 0xB6, 0x3E, 0xD4, 0xCC, 0x5E, 0xFF, 0x3E, 0xC4, 0x4B, 0xD8, 0xD0, 0x61, 0xC3, 0x42, 0xC6, 0x17, 0xC2,
    0x57, 0x21, 0x4C, 0x82, 0x70, 0x11, 0x5B, 0x7F, 0x20, 0xCC, 0x62, 0xFB, 0xE2, 0x73, 0xF3, 0x37, 0xC4, 0x33, 0xB9, 0x3A, 0x65, 0xC0,
    0xC6, 0x36, 0x90, 0x6E, 0xC2, 0xDE, 0x79, 0x1B, 0x1F, 0x01, 0x7C, 0x77, 0x48, 0xC9, 0xC6, 0x5C, 0x26, 0x97, 0x9D, 0x6D, 0xDC, 0x78,
    0x94, 0xC9, 0x69, 0xD1, 0x81, 0x05, 0x4F, 0x31, 0xBD, 0x51, 0xEC, 0x43, 0x05, 0x8F, 0x33, 0x3D, 0xD0, 0xD6, 0x11, 0x05, 0x77, 0x40,
    0x58, 0x74, 0x72, 0x6E, 0x41, 0x26, 0xA4, 0xDB, 0x3F, 0xEB, 0x54, 0xC1, 0x23, 0x4C, 0x9F, 0xF7, 0xC6, 0xA6, 0x77, 0x73, 0x81, 0x5E,
    0xFB, 0x27, 0x2B, 0xDF, 0xED, 0x01, 0xBF, 0x8F, 0xEB, 0xF8, 0xC3, 0xBB, 0x6F, 0x40, 0x38, 0x70, 0xCC, 0xEB, 0x9B, 0xE6, 0xC3, 0xEF,
    0x3F, 0xF4, 0x0D, 0xDB, 0xBC, 0x83, 0xE9, 0xCB, 0xD6, 0xCC, 0xD9, 0x7C, 0x03, 0xDB, 0x5F, 0x86, 0xAF, 0xD9, 0x9C, 0xC6, 0xF4, 0x4C,
    0x89, 0x1F, 0x6F, 0xFE, 0x8C, 0xC9, 0x75, 0xC1, 0x03, 0x0A, 0xB7, 0x33, 0x39, 0x79, 0xCA, 0xE8, 0xC2, 0xFF, 0x20, 0xDD, 0x17, 0xB3,
    0xEF, 0xD9, 0x32, 0x83, 0xF5, 0x87, 0xE0, 0x27, 0xB6, 0x1C, 0x86, 0xF0, 0xDD, 0x7B, 0x86, 0x6D, 0x69, 0xC9, 0xFA, 0xFB, 0xA3, 0xA3,
    0xB6, 0x24, 0xB0, 0x7D, 0xF8, 0xEC, 0xC8, 0x2D, 0xBF, 0x31, 0xB9, 0x23, 0xE8, 0xCA, 0x96, 0x2E, 0x10, 0x7E, 0x36, 0xF1, 0x9E, 0xAD,
    0xAF, 0x40, 0xB8, 0xE0, 0xB3, 0xCE, 0x5B, 0x93, 0x59, 0xBD, 0x64, 0x65, 0x6D, 0x65, 0xE7, 0xA1, 0x09, 0xF5, 0x3B, 0xB7, 0xEE, 0x80,
    0x7C, 0xCD, 0x5E, 0xB4, 0x6E, 0xDB, 0x29, 0x48, 0x97, 0x01, 0x61, 0x25, 0x84, 0x2F, 0x43, 0x78, 0x9A, 0xC9, 0x8B, 0x63, 0xFF, 0xDB,
    0xF6, 0x2F, 0xD3, 0x0B, 0xFA, 0x34, 0x2B, 0xEA, 0xCD, 0xE4, 0xC6, 0xD6, 0x9D, 0x8A, 0xF6, 0x41, 0xFA, 0x8C, 0xFF, 0xBA, 0x14, 0x9D,
    0x82, 0xF4, 0x7F, 0xE4, 0x3D, 0x56, 0x34, 0x9A, 0xCD, 0x97, 0x97, 0x5E, 0x28, 0x6A, 0x04, 0xDC, 0xD8, 0x7F, 0x6A, 0xD1, 0x2D, 0x4C,
    0x9F, 0x76, 0xD3, 0xD2, 0xA2, 0xBD, 0xF0, 0xFD, 0xE1, 0x47, 0xCB, 0x8B, 0x9A, 0xB1, 0x7D, 0xD6, 0x7F, 0xCB, 0x8B, 0xE6, 0x30, 0xFD,
    0x45, 0xE7, 0xD2, 0xA2, 0x0E, 0x6C, 0xBF, 0xB1, 0xF5, 0xE7, 0xED, 0x65, 0x6C, 0xBF, 0xD2, 0xFB, 0xD9, 0x1D, 0xD7, 0x43, 0xD8, 0x63,
    0xFE, 0x1D, 0xC5, 0x6F, 0x32, 0x7D, 0x5C, 0xFA, 0x90, 0xE2, 0x9F, 0xD9, 0xBC, 0x7D, 0xDD, 0x98, 0xE2, 0xB6, 0x4C, 0xAE, 0xBC, 0x6F,
    0x6A, 0xF1, 0x0C, 0xF8, 0xDE, 0x13, 0xBF, 0xAA, 0xD8, 0xC4, 0xD6, 0xE5, 0x4F, 0x5B, 0xEE, 0x62, 0x36, 0xA5, 0x59, 0x87, 0xDB, 0xEF,
    0x7A, 0x87, 0xAD, 0x87, 0x35, 0x77, 0xEC, 0x8A, 0x81, 0xEF, 0xE7, 0xBE, 0x0F, 0xDE, 0x75, 0x3D, 0x7C, 0xDF, 0xBE, 0xAF, 0x64, 0xD7,
    0x87, 0xF0, 0xFD, 0xE0, 0x98, 0xA3, 0xBB, 0x6E, 0x82, 0xEF, 0x47, 0xEF, 0x3A, 0xF1, 0xDE, 0x32, 0xF8, 0x1E, 0x02, 0xE1, 0x72, 0xB6,
    0xEF, 0xB9, 0xF5, 0xDC, 0x7B, 0x07, 0x99, 0xBE, 0xF1, 0xD9, 0xCE, 0xBB, 0x53, 0x99, 0xBE, 0x11, 0xC2, 0x34, 0x08, 0xE7, 0x1D, 0x48,
    0xD9, 0x9D, 0xCD, 0xF4, 0x6E, 0x10, 0xBE, 0xCE, 0xE4, 0x8D, 0xB7, 0x3F, 0xD8, 0x3D, 0x97, 0xCD, 0xF3, 0xE7, 0xFE, 0xDE, 0x6D, 0x80,
    0xF0, 0xB4, 0xF1, 0xD7, 0x92, 0xC1, 0x6C, 0x7F, 0x07, 0xE1, 0xA3, 0x10, 0xBE, 0x61, 0xF9, 0xB5, 0x64, 0x08, 0xD3, 0xAF, 0xCD, 0xFC,
    0xBB, 0xE4, 0x5A, 0xA6, 0xE7, 0xCB, 0xEE, 0xB2, 0xE7, 0x10, 0xD3, 0x4B, 0x3D, 0x35, 0x60, 0x4F, 0x24, 0xD3, 0x33, 0xAD, 0x1F, 0xB5,
    0xE7, 0x28, 0x84, 0x8F, 0xCC, 0x1E, 0xBB, 0x67, 0x05, 0xFC, 0x7E, 0xD3, 0x37, 0x96, 0x3D, 0xE7, 0xD9, 0xFA, 0x71, 0x32, 0x6B, 0x4F,
    0x1B, 0xC0, 0x5B, 0x42, 0x78, 0x2B, 0xD3, 0x63, 0xFE, 0x56, 0xBE, 0xE7, 0x3A, 0xA0, 0xBF, 0x32, 0x2C, 0x7D, 0xEF, 0x4F, 0x10, 0xDE,
    0x98, 0x98, 0xB3, 0xB7, 0x1D, 0x84, 0x13, 0xF7, 0xFD, 0xB9, 0xF7, 0x5D, 0x88, 0xBF, 0xBA, 0xCB, 0x03, 0xFB, 0xCE, 0xC2, 0x77, 0xAB,
    0x59, 0xE6, 0x7D, 0x5B, 0x21, 0xDC, 0xFB, 0xDD, 0xDE, 0x7D, 0x6B, 0x20, 0xDD, 0xD1, 0xA7, 0xCE, 0xEE, 0xDB, 0x03, 0xE1, 0xA0, 0xC0,
    0x66, 0xA5, 0x6F, 0x31, 0x9B, 0xBD, 0xE9, 0xE1, 0xA5, 0x9B, 0xD8, 0x3E, 0x7F, 0xC4, 0xB4, 0xD2, 0xF7, 0x98, 0x0F, 0x03, 0x9F, 0xC7,
    0xDE, 0x7F, 0x0C, 0x7E, 0x7F, 0x60, 0xFD, 0x8C, 0xF7, 0xD9, 0x99, 0x64, 0x77, 0x08, 0x6F, 0x64, 0x7A, 0x46, 0x08, 0xFD, 0x21, 0xEC,
    0x09, 0xE1, 0x4D, 0xAC, 0x9E, 0x20, 0x64, 0xE7, 0x64, 0x0B, 0xFF, 0x99, 0xFD, 0xC1, 0xF5, 0x90, 0x3E, 0x7A, 0xCC, 0xDC, 0x0F, 0x56,
    0xB2, 0x7D, 0xEE, 0xF7, 0xED, 0xF6, 0x27, 0x01, 0xBF, 0x43, 0x85, 0x8B, 0xF6, 0x87, 0x33, 0x79, 0xF0, 0xBF, 0xB7, 0xF7, 0xFF, 0xCA,
    0xFA, 0xCB, 0xA3, 0x6B, 0xF6, 0xAF, 0x60, 0x7A, 0x92, 0x19, 0xF5, 0xFB, 0xB9, 0xCD, 0x48, 0xAF, 0xCE, 0x65, 0x59, 0x10, 0xFE, 0xDA,
    0xB7, 0x73, 0xD9, 0x62, 0xB6, 0xEE, 0x40, 0xB8, 0x84, 0xE9, 0x35, 0x20, 0x7C, 0x0D, 0xC2, 0xD5, 0xA7, 0xFB, 0x95, 0xDD, 0xC1, 0xF4,
    0x8B, 0xE6, 0x98, 0xB2, 0x19, 0x4C, 0x3F, 0x53, 0x55, 0x54, 0xD6, 0x95, 0xED, 0x2F, 0xEB, 0x0F, 0x97, 0x3D, 0xCE, 0xF2, 0x3B, 0x3F,
    0xE9, 0x40, 0x4F, 0xE0, 0x53, 0x7B, 0x7F, 0xFA, 0x81, 0xE6, 0xAC, 0xBE, 0x22, 0x4F, 0x1C, 0xF8, 0x8F, 0xF5, 0x9B, 0x99, 0xBD, 0x0F,
    0xEE, 0x67, 0xED, 0x1B, 0x54, 0x7F, 0xF0, 0x03, 0xC0, 0x77, 0x7D, 0x31, 0xF2, 0xD0, 0xB3, 0x80, 0xBF, 0x07, 0xE1, 0x73, 0x10, 0x66,
    0xAD, 0x88, 0x3B, 0xD4, 0x05, 0xC2, 0x11, 0xFD, 0xD3, 0x0E, 0xC5, 0xB2, 0x7D, 0x2A, 0x84, 0x71, 0x10, 0x6E, 0x1B, 0xB6, 0xE4, 0xD0,
    0xE3, 0x10, 0xFF, 0xD6, 0x97, 0x97, 0x1F, 0xFA, 0x94, 0xAD, 0xAB, 0xBF, 0x15, 0x1E, 0xDA, 0x0A, 0xF9, 0x48, 0x5B, 0x7B, 0x5D, 0xF9,
    0x1A, 0xF8, 0xEE, 0x30, 0xA8, 0xC7, 0xE1, 0x39, 0x4C, 0x3D, 0xF6, 0x68, 0xF8, 0x61, 0x23, 0x84, 0x31, 0xE3, 0xB3, 0x0F, 0x3F, 0x04,
    0x61, 0x97, 0x89, 0xD9, 0x87, 0x07, 0x32, 0xBF, 0x57, 0x2B, 0x76, 0x1C, 0xFE, 0x1C, 0xE2, 0x3D, 0x0C, 0xE1, 0x17, 0x4C, 0x7E, 0x84,
    0xF0, 0x4B, 0x08, 0xCF, 0xAF, 0xFE, 0xE7, 0xF0, 0x5C, 0x26, 0xDF, 0xE5, 0xF4, 0xFF, 0x70, 0x3C, 0x93, 0x9F, 0xDF, 0xDF, 0xFD, 0xA1,
    0x05, 0xC2, 0x4E, 0x19, 0x47, 0x3F, 0x7C, 0x92, 0xE9, 0x39, 0x4A, 0x6B, 0x3E, 0xBC, 0x06, 0xC2, 0x25, 0x91, 0x05, 0x1F, 0xE9, 0x98,
    0x9E, 0xE6, 0xAE, 0xA2, 0x8F, 0xA6, 0x01, 0xBD, 0x5B, 0xCB, 0x17, 0x1C, 0xC9, 0x63, 0xEB, 0xC0, 0x90, 0x8D, 0x47, 0x46, 0xB3, 0xF9,
    0x6D, 0xC6, 0x98, 0xA3, 0x8F, 0xC1, 0xEF, 0xE9, 0x37, 0x1F, 0x3D, 0x7A, 0x2F, 0xD3, 0x2F, 0x5C, 0x6C, 0x73, 0x6C, 0x04, 0x93, 0xAF,
    0x7E, 0x4E, 0x38, 0xF6, 0x3D, 0xFC, 0x7E, 0xE2, 0x52, 0xC2, 0xB1, 0x0B, 0x10, 0xB6, 0x3E, 0x90, 0x71, 0x2C, 0x00, 0xE8, 0x0F, 0xBF,
    0xBF, 0xE2, 0x18, 0xB3, 0xA3, 0x2C, 0x6D, 0x7D, 0xE1, 0xD8, 0x3B, 0xF0, 0xDD, 0xFF, 0xD8, 0xD6, 0xE3, 0xEC, 0x8C, 0x74, 0x00, 0x84,
    0x6D, 0xD8, 0x3E, 0x23, 0x66, 0x58, 0xC5, 0xAD, 0x90, 0xFE, 0x54, 0xC7, 0x89, 0x15, 0xEC, 0xCC, 0x7C, 0xC2, 0xCE, 0xBF, 0x2A, 0xFE,
    0x82, 0xF0, 0xB5, 0xAD, 0xB7, 0x9D, 0xB8, 0x13, 0xF0, 0x6C, 0x08, 0xEF, 0x62, 0xEB, 0x61, 0x4C, 0xF4, 0x89, 0x97, 0x98, 0x9E, 0x6E,
    0xF3, 0xA6, 0x13, 0x29, 0x40, 0xC7, 0x3C, 0x22, 0xF6, 0x64, 0x38, 0x7C, 0x6F, 0x1B, 0xFA, 0xF2, 0xC9, 0xCB, 0x4C, 0x6E, 0xEF, 0xB3,
    0xE9, 0xE4, 0x71, 0x88, 0x37, 0x1C, 0xC2, 0x0A, 0x08, 0x9F, 0x81, 0xF0, 0x04, 0x84, 0x3D, 0xF2, 0xB6, 0x9C, 0x3C, 0xC0, 0xF4, 0xD5,
    0x2B, 0x75, 0xA7, 0xDA, 0xB1, 0x7A, 0x1F, 0x3B, 0xF4, 0x54, 0x32, 0xD3, 0xAB, 0xEF, 0xA9, 0x3B, 0xB5, 0x8A, 0xCD, 0x33, 0xC3, 0x7F,
    0x39, 0x65, 0x64, 0xF3, 0xC2, 0xE7, 0x37, 0x54, 0xAE, 0x62, 0x72, 0xF4, 0x57, 0x37, 0x54, 0xAE, 0x66, 0xE3, 0x6C, 0xF5, 0x3F, 0x95,
    0x37, 0x30, 0xB9, 0xB2, 0xE6, 0xB6, 0xD3, 0xA5, 0x10, 0x76, 0x6F, 0xD9, 0xFB, 0x74, 0x32, 0xE0, 0x23, 0x3E, 0x98, 0x74, 0xFA, 0x7B,
    0xD6, 0x5E, 0x10, 0x5E, 0x80, 0xF0, 0x96, 0xA7, 0xE7, 0x9F, 0x7E, 0x81, 0xAD, 0x7B, 0x93, 0x6F, 0x3B, 0xF3, 0x08, 0xD3, 0x83, 0x1C,
    0xCF, 0x3E, 0x73, 0xBB, 0x0F, 0x9B, 0x47, 0xBF, 0x3E, 0xE3, 0xCB, 0xD6, 0xAD, 0x36, 0x3F, 0x9D, 0xD9, 0xC2, 0xF4, 0xBB, 0x87, 0xFE,
    0x3E, 0xD3, 0x9F, 0xD5, 0xBF, 0x6E, 0xD8, 0xC7, 0xF7, 0x01, 0x7E, 0xD7, 0xED, 0xC7, 0x3E, 0xAE, 0x65, 0xF7, 0x54, 0xCE, 0xA7, 0x55,
    0x1D, 0x83, 0xEF, 0xB0, 0x73, 0x6B, 0xAB, 0xDA, 0x40, 0xBC, 0x67, 0x8F, 0xFD, 0xF4, 0xC9, 0x17, 0x7C, 0x9D, 0x59, 0xF1, 0xE9, 0x79,
    0xD6, 0x0E, 0x10, 0xD6, 0xB2, 0x71, 0x73, 0xB8, 0xDD, 0x67, 0x43, 0xD9, 0x3A, 0x3E, 0xF1, 0xE4, 0x67, 0x8B, 0x20, 0xDD, 0x85, 0x5B,
    0x3A, 0x54, 0x9F, 0x60, 0xF2, 0x22, 0x84, 0x27, 0xD9, 0xFC, 0x0B, 0xE1, 0x29, 0xA6, 0x27, 0x86, 0xB0, 0x92, 0xC9, 0xA3, 0x47, 0xC7,
    0x56, 0xB7, 0x63, 0xF3, 0xD4, 0x23, 0xF3, 0xAA, 0xDF, 0x81, 0xF8, 0x3B, 0x21, 0xCC, 0x67, 0x7A, 0x94, 0x3F, 0xDE, 0xAE, 0x7E, 0x9E,
    0x9D, 0xF1, 0xBF, 0xF2, 0xD8, 0xE7, 0x25, 0x4C, 0x1E, 0x6B, 0x36, 0xED, 0x73, 0x66, 0xBF, 0xF4, 0xE9, 0x88, 0xFF, 0x7D, 0x6E, 0x60,
    0x7A, 0xC0, 0xC5, 0x13, 0xBF, 0xF8, 0x8A, 0xAD, 0x7F, 0x57, 0xCA, 0xBF, 0xD8, 0xC3, 0xCE, 0x7D, 0x72, 0xAE, 0xFF, 0xF2, 0x30, 0xB3,
    0xED, 0xEC, 0x1B, 0xF8, 0xE5, 0x2B, 0x8C, 0x6E, 0xF7, 0xF1, 0x5F, 0x06, 0xB3, 0xF9, 0x6A, 0xE6, 0xF4, 0x2F, 0x6F, 0x82, 0xF8, 0xD7,
    0xDE, 0xD5, 0xE2, 0xEC, 0x5E, 0x76, 0xDE, 0xB1, 0xA0, 0xD3, 0xD9, 0xBD, 0x4C, 0xEF, 0xFC, 0xC7, 0x7D, 0x67, 0x3F, 0x82, 0x78, 0xA1,
    0x07, 0x5E, 0x3A, 0x7B, 0x85, 0xE9, 0x4D, 0x2F, 0xDC, 0xF1, 0xD5, 0x5C, 0xB6, 0xCE, 0x87, 0x96, 0x7F, 0x35, 0x02, 0xF0, 0x97, 0x1B,
    0xCE, 0x7E, 0x75, 0x99, 0xED, 0x37, 0x3B, 0xB5, 0xFB, 0x7A, 0x1A, 0xA4, 0x6F, 0xB3, 0xB2, 0xD3, 0xD7, 0x2F, 0x42, 0x78, 0x43, 0x49,
    0xE6, 0xD7, 0x03, 0x58, 0xBB, 0x0D, 0xBE, 0xE9, 0x9B, 0x8B, 0x6C, 0xFF, 0xB5, 0xF9, 0xF8, 0x37, 0x9D, 0xD9, 0x3E, 0xB6, 0xF9, 0xC3,
    0x35, 0x21, 0x6C, 0xBC, 0x8F, 0x8C, 0xA9, 0xD9, 0x08, 0xDF, 0xFD, 0xBE, 0x4D, 0xAB, 0x79, 0x8D, 0x9D, 0x0F, 0x7C, 0x56, 0x5C, 0x73,
    0x10, 0xF0, 0x3F, 0x97, 0xEC, 0xAE, 0x99, 0x01, 0xE9, 0xDF, 0xFC, 0xF4, 0x60, 0xCD, 0xB3, 0xF0, 0xFB, 0xBF, 0x37, 0x76, 0x3E, 0x37,
    0x8B, 0xE9, 0xC7, 0x97, 0x3F, 0x7E, 0xEE, 0x11, 0xC0, 0x5F, 0x1B, 0x71, 0xE5, 0x5C, 0x18, 0x93, 0x23, 0x06, 0x7D, 0xFB, 0xAD, 0x3F,
    0x84, 0xDF, 0x7F, 0x73, 0xC7, 0xF9, 0x1F, 0x21, 0xFD, 0x0D, 0xAD, 0x07, 0x9D, 0x5F, 0xC7, 0xE6, 0xF3, 0xDA, 0x15, 0xE7, 0x8F, 0x31,
    0xBD, 0xC8, 0x94, 0x55, 0xE7, 0xCF, 0x33, 0x7D, 0x7F, 0x5A, 0xC5, 0xF9, 0x5B, 0x20, 0x7C, 0x39, 0x65, 0x7C, 0x2D, 0xF3, 0x06, 0x72,
    0xE0, 0xD6, 0x03, 0xB5, 0x03, 0x99, 0x7E, 0x62, 0xEB, 0x8A, 0xEF, 0x9E, 0x82, 0xEF, 0x2F, 0x20, 0x7C, 0x9A, 0xCD, 0xC7, 0xE9, 0xE7,
    0xBF, 0x3B, 0xC6, 0xE4, 0xE4, 0x0C, 0xBF, 0xEF, 0xEF, 0x87, 0xF0, 0xD6, 0x4F, 0x47, 0x7C, 0xBF, 0x0D, 0xE8, 0xF4, 0xFC, 0xEB, 0xBD,
    0xEF, 0x5B, 0x43, 0x38, 0x6D, 0xC2, 0xF7, 0xDF, 0x1F, 0x00, 0x7E, 0x2B, 0x8D, 0xD7, 0x5C, 0x58, 0xC0, 0xE6, 0xBF, 0xFB, 0xBB, 0x5C,
    0xB8, 0x11, 0xF0, 0x6D, 0x37, 0x06, 0x5E, 0xF0, 0x67, 0xF2, 0x53, 0xC2, 0x13, 0x17, 0x92, 0x98, 0xFE, 0x71, 0x54, 0xE8, 0x85, 0x70,
    0xB6, 0xEF, 0xB9, 0x71, 0xF7, 0x85, 0x43, 0xEC, 0x3C, 0xE1, 0x96, 0xDD, 0x17, 0xCA, 0xD9, 0xFA, 0x1C, 0xF3, 0xC5, 0x85, 0xAF, 0x00,
    0xF7, 0x85, 0xF0, 0x6B, 0x08, 0x9B, 0x43, 0xF8, 0x0D, 0x84, 0xD7, 0x42, 0x58, 0x03, 0x61, 0x0B, 0x08, 0xCF, 0x31, 0xB9, 0x0B, 0xC2,
    0x6F, 0x21, 0x7C, 0x7A, 0xCE, 0x57, 0x17, 0x4E, 0x33, 0x39, 0xF9, 0xB5, 0xFF, 0x2E, 0xAC, 0x60, 0xF5, 0x7E, 0xE6, 0xD7, 0x3A, 0x3F,
    0x36, 0x9F, 0xBC, 0x33, 0xFE, 0x87, 0xD7, 0x20, 0xDC, 0xF3, 0xFB, 0xFC, 0x1F, 0x0A, 0xD8, 0x7C, 0xD4, 0x39, 0xE7, 0x87, 0x01, 0x6C,
    0x3C, 0x37, 0x7F, 0xE7, 0x87, 0x4D, 0xF0, 0x3D, 0xB5, 0xF9, 0x47, 0x3F, 0xE8, 0x21, 0x1F, 0xE7, 0x7F, 0x5B, 0xFE, 0xE3, 0x68, 0xC8,
    0xD7, 0xE7, 0x7E, 0x2B, 0x7E, 0x3C, 0xC1, 0xF6, 0x41, 0xEB, 0xCA, 0x7E, 0x5C, 0xCA, 0xF4, 0x97, 0xD3, 0xAE, 0xFF, 0x29, 0x11, 0xE2,
    0xFF, 0x02, 0x61, 0x12, 0xD3, 0xE7, 0xCF, 0x7D, 0xEA, 0xA7, 0x74, 0x36, 0xBF, 0x25, 0x3C, 0xF3, 0x53, 0x0C, 0x5B, 0xD7, 0xF7, 0x3E,
    0xFB, 0x53, 0x25, 0xCB, 0xEF, 0xEA, 0x93, 0x3F, 0xED, 0x63, 0xED, 0xBC, 0xF1, 0x78, 0xFD, 0x1A, 0xA0, 0x3B, 0x79, 0xC5, 0xE9, 0xFA,
    0x59, 0x4C, 0xBE, 0xFE, 0xCE, 0xF7, 0xE7, 0x99, 0x6C, 0xFC, 0x2F, 0x0E, 0xFE, 0xF9, 0x66, 0xC0, 0xDB, 0x3F, 0x9E, 0xF4, 0x73, 0x28,
    0xA4, 0xBB, 0xFE, 0xAB, 0xA3, 0x3F, 0xF7, 0x83, 0xDF, 0x77, 0x46, 0x9E, 0xFD, 0x79, 0x21, 0x7C, 0x2F, 0xC8, 0x6D, 0xF5, 0xCB, 0x1B,
    0x6C, 0x1E, 0x87, 0x70, 0x29, 0x93, 0xFB, 0xDB, 0xDD, 0xF1, 0x4B, 0x06, 0xC4, 0x1F, 0xFD, 0x65, 0xD6, 0x2F, 0x4F, 0xB1, 0xF6, 0x7B,
    0x70, 0xFD, 0x2F, 0x11, 0x10, 0x7E, 0xFD, 0xCF, 0xF6, 0x5F, 0xC2, 0xD8, 0x3C, 0xE4, 0x77, 0xEE, 0x97, 0x59, 0x4C, 0xEF, 0xFC, 0xC1,
    0x3D, 0x17, 0x3B, 0x40, 0xBC, 0x9F, 0xF2, 0x6B, 0x2E, 0x6E, 0x80, 0xEF, 0xE7, 0xB6, 0xB6, 0xBF, 0x94, 0x0A, 0xE1, 0xBC, 0x98, 0x03,
    0x97, 0x3E, 0x60, 0xF9, 0x9A, 0x79, 0xEE, 0x92, 0x01, 0xBE, 0x8F, 0x1C, 0xAA, 0xBD, 0xC4, 0xCE, 0x49, 0x7B, 0x9F, 0xE9, 0xF7, 0xEB,
    0x24, 0x88, 0xFF, 0xE2, 0xF2, 0xF9, 0xBF, 0xDE, 0xC6, 0xE4, 0x38, 0x3F, 0xFF, 0xDF, 0xA6, 0x33, 0x3B, 0xA0, 0x9D, 0x39, 0xBF, 0x6D,
    0x60, 0x7A, 0xCD, 0x97, 0x5B, 0x5C, 0x7E, 0x97, 0xE9, 0x0B, 0x7E, 0xEF, 0x75, 0xF9, 0x67, 0x48, 0x77, 0x5F, 0xCE, 0x33, 0x97, 0x47,
    0xC2, 0x77, 0xFF, 0x36, 0xC6, 0xCB, 0x6B, 0x98, 0x7A, 0xFF, 0xFC, 0x7F, 0x97, 0x1F, 0x66, 0xEB, 0xF7, 0x85, 0xFF, 0x2E, 0xB3, 0xBB,
    0x9D, 0x01, 0xF3, 0x47, 0x34, 0x5C, 0x03, 0xE9, 0xEE, 0x3B, 0x59, 0xDA, 0x90, 0x04, 0xF1, 0xC7, 0x56, 0x9C, 0x6B, 0xB8, 0x0B, 0xE2,
    0x7F, 0x56, 0xF9, 0xF0, 0xEF, 0x33, 0xE1, 0x7B, 0x66, 0xF9, 0x81, 0xDF, 0x1F, 0x60, 0xFB, 0x04, 0x08, 0xBB, 0x33, 0x3D, 0xC9, 0xE0,
    0x9F, 0x7E, 0x37, 0xB2, 0xFD, 0x31, 0x84, 0x53, 0x21, 0xEC, 0x79, 0xEA, 0x9F, 0xDF, 0xA7, 0x42, 0xFA, 0x03, 0xBB, 0xC7, 0xFD, 0xF1,
    0x1E, 0x7C, 0x3F, 0x98, 0x70, 0xF1, 0x8F, 0x02, 0xA6, 0x27, 0x7A, 0xB9, 0xCD, 0xFF, 0xEA, 0xD9, 0x7C, 0x72, 0x47, 0xF4, 0x95, 0x21,
    0x6C, 0xDF, 0x67, 0x2C, 0xBF, 0x72, 0x92, 0xE9, 0x5B, 0x7F, 0x39, 0x7C, 0x65, 0x30, 0xC4, 0x5F, 0x7C, 0xE0, 0xFA, 0x3F, 0x9F, 0x66,
    0xFD, 0xEE, 0xE7, 0xBB, 0xFF, 0xBC, 0x08, 0xE1, 0x85, 0xE2, 0x84, 0x3F, 0x3B, 0xB3, 0xF1, 0xBA, 0xF1, 0xB7, 0x3F, 0xCD, 0x6C, 0xBD,
    0xFE, 0xCC, 0xF7, 0xAF, 0x22, 0xB6, 0x9F, 0xF8, 0xE3, 0xB6, 0xBF, 0x76, 0x33, 0x7D, 0x51, 0x99, 0xFE, 0xAF, 0xBB, 0x19, 0xBF, 0xDD,
    0x17, 0xFE, 0x9A, 0xCC, 0xE4, 0xC2, 0x51, 0x43, 0xFE, 0x6E, 0x05, 0xE9, 0x3E, 0x9D, 0x3A, 0xFE, 0xEF, 0x39, 0x6C, 0xBF, 0xB3, 0xB5,
    0xE0, 0xEF, 0x0C, 0x36, 0x0F, 0x85, 0x8E, 0x68, 0x6C, 0xCD, 0xF4, 0x35, 0xAB, 0xF6, 0x36, 0xDE, 0xC4, 0xD6, 0x8D, 0x19, 0x7F, 0x36,
    0xFE, 0x0E, 0xE9, 0x5F, 0x2F, 0xEE, 0xFF, 0xCF, 0xFF, 0xD8, 0x78, 0xDB, 0xB3, 0xFD, 0x9F, 0x78, 0xA6, 0xAF, 0xBA, 0x79, 0xE5, 0xBF,
    0xC3, 0xD9, 0xFA, 0x04, 0xE1, 0x33, 0x6C, 0x5E, 0x3F, 0xB0, 0xF2, 0xDF, 0x61, 0x6C, 0xDF, 0x13, 0x58, 0xFC, 0x6F, 0x2A, 0xD3, 0x6B,
    0x1F, 0x3E, 0xF3, 0x6F, 0x28, 0x84, 0xFF, 0x0F, 0xBF, 0xEB, 0xA5, 0x0F,
};

// Windows 10 - APISET-W10.22H2-19045.5247

// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
const uint8_t apiset_w10[] = {
    0x78, 0xDA, 0xCD, 0x7D, 0x0B, 0x5C, 0x94, 0x45, 0xF7, 0xFF, 0x62, 0x58, 0x98, 0x64, 0x64, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x5A, 0x6A,
    0x88, 0x37, 0x2C, 0x53, 0xF2, 0x52, 0x5A, 0x54, 0xE6, 0x2D, 0x2F, 0xA4, 0xDC, 0x2F, 0xBA, 0x0B, 0xEB, 0xEE, 0x72, 0x51, 0x51, 0x51,
    0x51, 0x29, 0x51, 0x29, 0x49, 0x51, 0xD1, 0xD0, 0x50, 0x51, 0xC9, 0xA8, 0xA8, 0xD0, 0x78, 0x0B, 0x13, 0x0B, 0x8D, 0x94, 0xCA, 0x8A,
    0x8A, 0x0A, 0x93, 0x92, 0x92, 0x94, 0xCA, 0x8C, 0x8A, 0xF2, 0x7F, 0xE6, 0x99, 0xE7, 0xE1, 0x9C, 0xBD, 0x3D, 0xCF, 0xB3, 0x17, 0x7F,
    0x9F, 0xFF, 0xFB, 0x7E, 0x6C, 0x78, 0xBE, 0x3B, 0x73, 0xCE, 0x5C, 0xCE, 0xCC, 0x9C, 0x39, 0x33, 0x73, 0xE6, 0x7A, 0x8D, 0x46, 0x53,
    0x50, 0xE9, 0xA1, 0x61, 0xFF, 0x5B, 0x72, 0x9D, 0x46, 0xE3, 0x07, 0x61, 0x55, 0x91, 0x87, 0xA6, 0x07, 0x84, 0x0C, 0x2D, 0x98, 0xAA,
    0xD1, 0x3C, 0x02, 0xE1, 0x43, 0xF0, 0xAF, 0x69, 0x2A, 0xC7, 0xD8, 0xBF, 0x80, 0x69, 0x1C, 0x1B, 0x0B, 0xFF, 0x52, 0xA7, 0x21, 0x5E,
    0x0C, 0x7F, 0xCF, 0x80, 0x70, 0x0A, 0xFC, 0xF3, 0x9A, 0x8E, 0xB8, 0x1F, 0xFC, 0x3D, 0x1E, 0xC2, 0x60, 0xF8, 0x17, 0x46, 0x70, 0xD3,
    0x74, 0x8E, 0x8D, 0x82, 0x7F, 0x25, 0x04, 0xAF, 0x24, 0xB8, 0xD7, 0x0C, 0x42, 0x67, 0x06, 0xE7, 0x39, 0x9A, 0xD1, 0x21, 0xB8, 0x89,
    0xE0, 0xA5, 0x04, 0xAF, 0x87, 0xBF, 0x87, 0x43, 0x18, 0xC8, 0xD2, 0x3E, 0x45, 0xF2, 0xFF, 0x14, 0xCF, 0xE3, 0xE3, 0xF0, 0x2F, 0x83,
    0xE0, 0xC5, 0x4F, 0x91, 0xFC, 0xCF, 0x44, 0x7C, 0xC0, 0x4C, 0xAC, 0x87, 0x54, 0x82, 0x17, 0x10, 0xBC, 0x89, 0xE0, 0x9E, 0xB3, 0x90,
    0xFE, 0xCC, 0x59, 0x88, 0x6B, 0xE1, 0xEF, 0x50, 0x86, 0xB1, 0x32, 0x12, 0xBC, 0x76, 0x16, 0xCF, 0xFB, 0x7D, 0x2C, 0x9F, 0xB3, 0x11,
    0x1F, 0x3F, 0x1B, 0xF1, 0x0C, 0x82, 0x97, 0xCC, 0xC6, 0xFA, 0xB9, 0x4C, 0x70, 0xAF, 0x39, 0x1C, 0x0B, 0x62, 0x69, 0xE1, 0xEF, 0x36,
    0x22, 0x9E, 0x31, 0x87, 0x63, 0x43, 0xE1, 0x5F, 0xD9, 0x1C, 0x8C, 0x5F, 0x3D, 0x07, 0xF3, 0xEF, 0x17, 0x4A, 0xEA, 0x27, 0x14, 0xF9,
    0xEA, 0x09, 0x9E, 0x4D, 0xF0, 0x6A, 0x82, 0x7B, 0x3F, 0x8D, 0xF5, 0x3F, 0xF9, 0x69, 0xC4, 0xA3, 0x9E, 0xC6, 0xF8, 0x05, 0x04, 0x2F,
    0x7D, 0x9A, 0xE7, 0x25, 0x00, 0xFE, 0x35, 0x12, 0xBC, 0xCB, 0x5C, 0xC4, 0x43, 0xE6, 0x92, 0xF6, 0x85, 0xBF, 0x27, 0x33, 0x0C, 0xFE,
    0x55, 0x10, 0xBC, 0x66, 0x2E, 0xCA, 0x95, 0xDF, 0x3C, 0x92, 0xFF, 0x79, 0x88, 0x9B, 0x08, 0x9E, 0x49, 0xF0, 0x2A, 0x82, 0xD7, 0xCD,
    0x43, 0x39, 0xE9, 0x12, 0x46, 0xDA, 0x3D, 0x0C, 0xE5, 0xDC, 0x44, 0xF0, 0xCC, 0x30, 0xDE, 0xB6, 0xAC, 0xEE, 0x6A, 0x08, 0xDE, 0x18,
    0x86, 0xF5, 0xDF, 0x2F, 0x1C, 0xF1, 0x51, 0xE1, 0x88, 0xA7, 0x12, 0x3C, 0x8B, 0xE0, 0x95, 0x04, 0xAF, 0x25, 0x78, 0x97, 0x08, 0x92,
    0x9F, 0x08, 0xC4, 0xE3, 0x08, 0x9E, 0x46, 0xF0, 0x52, 0x82, 0x57, 0x45, 0x60, 0x7D, 0x6A, 0x22, 0x11, 0xF7, 0x8D, 0x44, 0x7C, 0x22,
    0xC1, 0x43, 0x23, 0xB1, 0xBD, 0xF2, 0x08, 0x5E, 0x1C, 0x89, 0xF2, 0xD3, 0x40, 0xF0, 0x96, 0x48, 0x94, 0x9F, 0x89, 0x51, 0xA4, 0xBD,
    0xA2, 0x48, 0xBF, 0x26, 0x78, 0x65, 0x14, 0xE6, 0xD3, 0x33, 0x9A, 0xB4, 0x3B, 0xFC, 0x3D, 0x51, 0xC3, 0xDB, 0x26, 0x8C, 0xE0, 0xA6,
    0x68, 0xA4, 0x5F, 0x4E, 0xF0, 0x86, 0x68, 0x9E, 0x47, 0xD6, 0x66, 0xFE, 0x31, 0x88, 0x07, 0xC5, 0x20, 0x6E, 0x22, 0x78, 0x66, 0x0C,
    0xE6, 0xA7, 0x92, 0xE0, 0xB5, 0x04, 0xF7, 0x8B, 0x25, 0xF2, 0x13, 0x4B, 0xC6, 0x37, 0x82, 0x57, 0xC4, 0xA2, 0x9C, 0xB4, 0x10, 0xDC,
    0x27, 0x0E, 0xF1, 0x89, 0x71, 0xA4, 0x3E, 0x09, 0x9E, 0x43, 0xF0, 0xC2, 0x38, 0xAC, 0xE7, 0x06, 0x82, 0xB7, 0xC4, 0x61, 0x3D, 0x0F,
    0x8D, 0x47, 0x7C, 0x62, 0x3C, 0x96, 0x2B, 0x83, 0xE0, 0xB9, 0xF1, 0x48, 0xBF, 0x9A, 0xE0, 0xF5, 0x04, 0xF7, 0x9B, 0x4F, 0xCA, 0x35,
    0x1F, 0xF1, 0x38, 0x82, 0xA7, 0xCD, 0xC7, 0xFA, 0xAF, 0x20, 0x78, 0xCD, 0x7C, 0xD2, 0xBF, 0x16, 0x10, 0x3A, 0x0B, 0x48, 0xFF, 0x22,
    0x78, 0xE6, 0x02, 0x4E, 0x7B, 0x10, 0x1B, 0x67, 0x16, 0xE0, 0xF8, 0x53, 0xBF, 0x00, 0xE5, 0xAD, 0x8B, 0x96, 0xC8, 0xB3, 0x16, 0xF1,
    0x30, 0x82, 0x9B, 0xB4, 0x38, 0x0E, 0x57, 0x11, 0xBC, 0x4E, 0xCB, 0xC7, 0x00, 0x96, 0xD7, 0x01, 0x3A, 0xC4, 0x83, 0x75, 0xD8, 0x1F,
    0xB3, 0x09, 0x5E, 0xA0, 0xC3, 0x76, 0x6C, 0x24, 0xB8, 0x26, 0x01, 0xCB, 0x3B, 0x31, 0x81, 0xB4, 0x17, 0xC1, 0x0B, 0x08, 0x5E, 0x4A,
    0x70, 0x4D, 0x22, 0xE9, 0x47, 0x89, 0x7C, 0x2C, 0x9F, 0xC6, 0xC6, 0x76, 0x82, 0xA7, 0x27, 0xE2, 0x78, 0x55, 0x4D, 0xF0, 0xFA, 0x44,
    0xCC, 0xCF, 0x00, 0x3D, 0xC9, 0xBF, 0x1E, 0xF1, 0x4C, 0x82, 0xE7, 0x11, 0xBC, 0x9E, 0xE0, 0xCD, 0x7A, 0xE4, 0x3B, 0x79, 0x21, 0x19,
    0x6F, 0x17, 0x22, 0x5E, 0x46, 0xF0, 0x6A, 0x82, 0xF7, 0x33, 0x90, 0x71, 0xC9, 0x80, 0xF5, 0x9C, 0x43, 0xF0, 0x42, 0x03, 0x96, 0xB7,
    0x89, 0xE0, 0x9E, 0x46, 0xEC, 0xBF, 0xC1, 0x46, 0xC4, 0xA7, 0x19, 0x51, 0x3E, 0xB3, 0x09, 0x5E, 0x60, 0x44, 0x79, 0xAB, 0x25, 0x78,
    0x13, 0xFC, 0x0D, 0xD3, 0x96, 0xC0, 0x3B, 0xC4, 0x84, 0xB8, 0xDE, 0x84, 0xFD, 0xBD, 0x8C, 0xE0, 0xD5, 0x26, 0xEC, 0xA7, 0x3E, 0x49,
    0x88, 0xFB, 0x27, 0x21, 0x1E, 0x45, 0xF0, 0xD4, 0x24, 0xA4, 0x53, 0x41, 0xF0, 0x1A, 0x12, 0xBF, 0x4B, 0x32, 0x91, 0xC3, 0x64, 0x2C,
    0xAF, 0x89, 0xE0, 0x99, 0xC9, 0x98, 0xFF, 0x72, 0x82, 0x9F, 0x49, 0x46, 0xB9, 0xF5, 0x4A, 0x21, 0xFA, 0x49, 0x0A, 0xB6, 0x57, 0x14,
    0xC1, 0x53, 0x09, 0x5E, 0x4E, 0xF0, 0x33, 0x29, 0x98, 0xCF, 0x9E, 0xA9, 0x88, 0x0F, 0x4D, 0x45, 0x3D, 0x21, 0x9B, 0xE0, 0x05, 0xA9,
    0xA8, 0x57, 0x34, 0x13, 0xDC, 0x7B, 0x11, 0xE2, 0x61, 0x8B, 0x48, 0x3F, 0x5A, 0x84, 0xFD, 0xA5, 0x7C, 0x11, 0xF6, 0xC7, 0x06, 0x82,
    0x0F, 0x5D, 0x4C, 0xC6, 0x99, 0xC5, 0x98, 0x9F, 0x9C, 0xC5, 0x18, 0xBF, 0x6C, 0x31, 0xC6, 0xF7, 0x5A, 0x42, 0xCA, 0xBB, 0x04, 0xF1,
    0x38, 0x82, 0xA7, 0xC1, 0xDF, 0x30, 0x35, 0x0B, 0x6D, 0x5C, 0x4B, 0xF0, 0xA6, 0x25, 0x58, 0xAE, 0x90, 0x34, 0xC4, 0xC3, 0xD2, 0x50,
    0xAE, 0xF2, 0x08, 0x5E, 0x9C, 0x86, 0x7A, 0xC5, 0x65, 0x82, 0x7B, 0x2D, 0xC5, 0x71, 0x32, 0x78, 0x29, 0x91, 0xC3, 0xA5, 0x98, 0xFF,
    0x7C, 0x82, 0x97, 0x2C, 0x25, 0xFA, 0x12, 0xC1, 0xBD, 0x96, 0x11, 0x7D, 0x69, 0x19, 0xE2, 0x33, 0x97, 0xA1, 0x3C, 0xE4, 0x13, 0xBC,
    0x64, 0x19, 0x8E, 0xDB, 0x97, 0x09, 0xEE, 0xBF, 0x1C, 0xE9, 0x84, 0x2D, 0x27, 0xF5, 0x4F, 0xF0, 0x62, 0x82, 0x57, 0x10, 0x5C, 0x93,
    0x4E, 0xC6, 0x93, 0x74, 0xC4, 0x27, 0x13, 0x3C, 0x2A, 0x1D, 0xEB, 0xA1, 0x90, 0xE0, 0x65, 0xE9, 0xD8, 0xEF, 0x9A, 0x09, 0xEE, 0xBD,
    0x02, 0xF1, 0x89, 0x2B, 0xC8, 0xF8, 0xB6, 0x82, 0xCC, 0xEF, 0x04, 0x2F, 0x5E, 0x81, 0xE3, 0xA7, 0x66, 0x25, 0x19, 0xE7, 0x57, 0x12,
    0x3D, 0x90, 0xE0, 0x19, 0x04, 0xAF, 0x20, 0x78, 0x0D, 0xC1, 0xBB, 0xAC, 0x22, 0xFD, 0x6B, 0x15, 0xE2, 0x5A, 0x82, 0xA7, 0xAF, 0x42,
    0xBE, 0xD5, 0x04, 0xAF, 0x5F, 0x85, 0xE3, 0xD2, 0xA8, 0x0C, 0xC4, 0x27, 0x67, 0x60, 0x3D, 0xE4, 0x10, 0xBC, 0x90, 0xE0, 0x8D, 0x04,
    0xD7, 0xAC, 0x46, 0x79, 0x08, 0x59, 0x4D, 0xE4, 0x6D, 0x35, 0xF2, 0x2D, 0x26, 0x78, 0x05, 0xC1, 0x7D, 0xD7, 0x20, 0xDE, 0x6F, 0x0D,
    0xCA, 0x83, 0x9E, 0xE0, 0x19, 0x6B, 0x48, 0x3D, 0x10, 0xBC, 0x66, 0x0D, 0xF6, 0x0B, 0xFF, 0xB5, 0x44, 0x3F, 0x59, 0x8B, 0xF9, 0x4C,
    0x23, 0x78, 0xF6, 0x5A, 0x94, 0xE7, 0x4A, 0x82, 0x37, 0xAD, 0x45, 0xBE, 0x41, 0x99, 0x88, 0x87, 0x64, 0x62, 0xFB, 0x66, 0x12, 0x3C,
    0x8F, 0xE0, 0x35, 0x04, 0x6F, 0xCC, 0xC4, 0xFC, 0x04, 0x3D, 0x43, 0xE8, 0x3C, 0x83, 0xF9, 0xC9, 0x26, 0x78, 0xC1, 0x33, 0x64, 0xDE,
    0x24, 0xB8, 0xE6, 0x59, 0x8C, 0x3F, 0xFE, 0x59, 0xD2, 0x5F, 0x9E, 0xC5, 0xFC, 0x67, 0x13, 0xBC, 0x80, 0xE0, 0xB5, 0x04, 0x6F, 0x7A,
    0x16, 0xE5, 0x7C, 0xC0, 0x3A, 0x32, 0x0F, 0xAE, 0x43, 0x3C, 0x8D, 0xE0, 0xD9, 0x04, 0xAF, 0x22, 0x78, 0xDD, 0x3A, 0x6C, 0xDF, 0x01,
    0x59, 0x84, 0x4E, 0x16, 0xD1, 0x07, 0x08, 0x5E, 0x9D, 0x85, 0xF9, 0xF7, 0x5D, 0x4F, 0xDA, 0x77, 0x3D, 0xE2, 0x5A, 0x82, 0xA7, 0xAF,
    0x27, 0xF3, 0x38, 0xC1, 0xEB, 0xD7, 0xE3, 0x78, 0x1B, 0xB4, 0x81, 0xD4, 0xE7, 0x06, 0x94, 0x87, 0x2C, 0x82, 0xE7, 0x6F, 0xC0, 0xFC,
    0x34, 0x11, 0xDC, 0x73, 0x23, 0xC6, 0x1F, 0xBF, 0x91, 0xD4, 0xE7, 0x46, 0x9C, 0x5F, 0xB2, 0x08, 0x9E, 0x4F, 0xF0, 0x33, 0x04, 0x6F,
    0xD8, 0x88, 0xF3, 0x54, 0xCF, 0x6C, 0x1C, 0xB7, 0x27, 0x66, 0x63, 0xBD, 0x65, 0x64, 0x13, 0xBD, 0x31, 0x1B, 0xE5, 0xA1, 0x9E, 0xE0,
    0xCD, 0xD9, 0xA8, 0xD7, 0x8D, 0x7A, 0x8E, 0xF4, 0xBB, 0xE7, 0x10, 0xCF, 0x21, 0x78, 0xE1, 0x73, 0xA8, 0x57, 0x68, 0x9E, 0x27, 0xE3,
    0xD8, 0xF3, 0x18, 0x7F, 0x26, 0xC1, 0xB5, 0xCF, 0x63, 0xBD, 0x95, 0x13, 0xFC, 0xCC, 0xF3, 0x28, 0x27, 0xDE, 0x9B, 0x10, 0xEF, 0xB9,
    0x09, 0xE7, 0x91, 0x74, 0x82, 0x17, 0x6D, 0x42, 0x3A, 0x9A, 0x1C, 0xC2, 0x37, 0x07, 0xE5, 0x21, 0x8C, 0xE0, 0xA6, 0x1C, 0xA4, 0x73,
    0x86, 0xE0, 0x0D, 0x39, 0x28, 0xE7, 0x01, 0x2F, 0x90, 0x75, 0xF7, 0x0B, 0x98, 0x9F, 0x34, 0x82, 0x67, 0xBF, 0x80, 0xFD, 0xAB, 0x8A,
    0xE0, 0x75, 0x04, 0xF7, 0xDB, 0x4C, 0xC6, 0xCF, 0xCD, 0xD8, 0x7F, 0x53, 0x09, 0x9E, 0xB5, 0x19, 0xF9, 0x9E, 0x21, 0x78, 0xC3, 0x66,
    0xD2, 0x8E, 0x5B, 0x88, 0x5C, 0x6D, 0x21, 0xFD, 0x9D, 0xE0, 0x79, 0x5B, 0x50, 0x6E, 0xEB, 0x08, 0x7E, 0x79, 0x0B, 0xCE, 0x77, 0x43,
    0x73, 0xC9, 0xFC, 0x9E, 0x8B, 0xF2, 0x93, 0x46, 0xF0, 0xEC, 0x5C, 0x32, 0xFE, 0x10, 0xBC, 0x96, 0xC4, 0xF7, 0xD9, 0x4A, 0xE6, 0xBB,
    0xAD, 0x28, 0xB7, 0x51, 0x04, 0x4F, 0xDD, 0x8A, 0xF9, 0x2C, 0x21, 0x78, 0x25, 0xC1, 0x3D, 0xB7, 0x91, 0x75, 0xDF, 0x36, 0xC4, 0xA7,
    0x11, 0x3C, 0x6E, 0x1B, 0xD6, 0x43, 0x3E, 0xC1, 0x4B, 0xB6, 0x61, 0x3E, 0x1B, 0x09, 0xAE, 0xD9, 0x8E, 0xF9, 0x1C, 0xBA, 0x9D, 0x94,
    0x77, 0x3B, 0x59, 0x37, 0x11, 0x3C, 0x77, 0x3B, 0xF6, 0xEB, 0x06, 0x82, 0xB7, 0x10, 0x3C, 0x24, 0x8F, 0xCC, 0x17, 0x79, 0x88, 0x17,
    0x13, 0xBC, 0x22, 0x4F, 0xD4, 0xC1, 0x59, 0x59, 0x76, 0x90, 0xF9, 0x6E, 0x07, 0xD6, 0xBF, 0x96, 0xE0, 0xB9, 0x3B, 0xB0, 0xDE, 0x6A,
    0x08, 0xDE, 0xB8, 0x03, 0xFB, 0x4B, 0xC0, 0x4E, 0x22, 0x87, 0x3B, 0x51, 0x7E, 0xB2, 0x08, 0x9E, 0x4F, 0xF0, 0x06, 0x82, 0xFB, 0xBE,
    0x88, 0x78, 0xE8, 0x8B, 0x44, 0x8F, 0x25, 0x78, 0x35, 0xC1, 0xEB, 0x09, 0x3E, 0x20, 0x9F, 0x8C, 0x9F, 0xF9, 0x88, 0x67, 0x12, 0x3C,
    0x8F, 0xE0, 0xF5, 0x04, 0x6F, 0xCE, 0x47, 0x39, 0x1C, 0xB5, 0x8B, 0x8C, 0x1B, 0xBB, 0x50, 0xCE, 0x73, 0x09, 0x5E, 0x44, 0xF0, 0xCB,
    0x04, 0xF7, 0xDA, 0x8D, 0xF8, 0xE4, 0xDD, 0x44, 0xFF, 0xD9, 0x8D, 0xF5, 0x53, 0x48, 0xF0, 0x32, 0x12, 0xDF, 0xF3, 0x25, 0x22, 0x57,
    0x2F, 0x71, 0x59, 0x18, 0xC0, 0x64, 0x80, 0xE0, 0xFA, 0x97, 0x50, 0xAE, 0x0A, 0x09, 0x5E, 0xFD, 0x12, 0xB6, 0xA3, 0x7F, 0x01, 0x99,
    0xAF, 0x0B, 0x90, 0x7E, 0x3A, 0xC1, 0x73, 0x0A, 0x70, 0x9C, 0xA9, 0x23, 0xF8, 0xE5, 0x02, 0xAC, 0x87, 0xA0, 0x3D, 0xA4, 0xFF, 0xEE,
    0x41, 0x3A, 0x39, 0x04, 0x2F, 0x24, 0x78, 0x13, 0xC1, 0x3D, 0xF7, 0x92, 0x75, 0xD6, 0x5E, 0x52, 0x0F, 0x7B, 0x89, 0x1E, 0x48, 0xF0,
    0xB2, 0xBD, 0x58, 0x3F, 0x9A, 0x7D, 0x44, 0x1E, 0xF6, 0x61, 0xB9, 0xE2, 0x08, 0x9E, 0x46, 0xF0, 0x6A, 0x82, 0xB7, 0xEC, 0xC3, 0xFE,
    0x12, 0x54, 0x48, 0xFA, 0x63, 0x21, 0xE2, 0x05, 0x04, 0x2F, 0x2D, 0x44, 0xBE, 0x2D, 0x04, 0x1F, 0xB0, 0x9F, 0xC8, 0xFF, 0x7E, 0x22,
    0xFF, 0xFB, 0x89, 0xBD, 0x82, 0xE0, 0xF5, 0xFB, 0x71, 0x3D, 0x18, 0x7C, 0x80, 0xE8, 0xF3, 0x07, 0x90, 0x4E, 0x0E, 0xC1, 0x0B, 0x0F,
    0x60, 0x7E, 0xEA, 0x09, 0xEE, 0x7D, 0x10, 0xDB, 0x7D, 0xD4, 0x41, 0x22, 0x87, 0x07, 0xD1, 0x2E, 0x91, 0x41, 0xF0, 0x12, 0x82, 0x37,
    0x10, 0xBC, 0x85, 0xD0, 0x19, 0x50, 0x44, 0xFA, 0x45, 0x11, 0xD1, 0x4F, 0x08, 0x9E, 0x5D, 0x84, 0x74, 0x2A, 0x08, 0x5E, 0x53, 0x44,
    0xF4, 0xE1, 0x97, 0x89, 0x3C, 0xBC, 0x8C, 0xEB, 0xA0, 0x42, 0x82, 0x5F, 0x7E, 0x19, 0xE5, 0x61, 0xD4, 0x21, 0x32, 0x6F, 0x1E, 0x42,
    0xBC, 0x84, 0xE0, 0xB5, 0x87, 0xB0, 0xFE, 0x7B, 0xBE, 0x42, 0xD6, 0x8F, 0xAF, 0xA0, 0x7C, 0xA6, 0x13, 0x3C, 0xE7, 0x15, 0x8C, 0x5F,
    0x43, 0xF0, 0x46, 0x82, 0x07, 0x14, 0x93, 0xF1, 0xA7, 0x18, 0xF5, 0x96, 0x1C, 0x82, 0x17, 0x16, 0x63, 0xBB, 0x34, 0x10, 0xBC, 0xA5,
    0x18, 0xE9, 0x04, 0xBF, 0x4A, 0xDA, 0xF1, 0x55, 0x1C, 0x9F, 0x33, 0x09, 0x5E, 0xFC, 0x2A, 0x96, 0xAB, 0x99, 0xE0, 0xDE, 0xAF, 0x91,
    0xF5, 0xCB, 0x6B, 0x64, 0xFD, 0xF2, 0x1A, 0x8E, 0xFF, 0x39, 0x04, 0x2F, 0x7F, 0x0D, 0xC7, 0x67, 0x9F, 0xD7, 0xC9, 0x3C, 0xF5, 0x3A,
    0x99, 0xA7, 0x08, 0x9E, 0xFA, 0x3A, 0x59, 0x8F, 0x13, 0xFC, 0xCC, 0xEB, 0x48, 0xC7, 0xBF, 0x84, 0x8C, 0x03, 0x25, 0x64, 0x1C, 0x20,
    0x78, 0x4E, 0x09, 0xEA, 0x21, 0x0D, 0x04, 0x6F, 0x29, 0xC1, 0x71, 0x72, 0xFC, 0x1B, 0x44, 0xAF, 0x7B, 0x03, 0xF5, 0x90, 0x52, 0x82,
    0x57, 0xBD, 0xC1, 0xF9, 0xB2, 0x7A, 0xF6, 0x7B, 0x93, 0xE8, 0x0F, 0x6F, 0x62, 0x3B, 0xA6, 0x11, 0x3C, 0x9B, 0xE0, 0xB5, 0x04, 0x6F,
    0x7A, 0x13, 0xF5, 0xBA, 0x51, 0x6F, 0x11, 0xF9, 0x7F, 0x0B, 0xCB, 0x95, 0x4F, 0xF0, 0x92, 0xB7, 0x30, 0xFF, 0x5E, 0xA5, 0x64, 0x5D,
    0x5F, 0x8A, 0xB8, 0x9E, 0xE0, 0x19, 0xA5, 0x48, 0xE7, 0x0C, 0xC1, 0x1B, 0x4A, 0x51, 0x1E, 0xFA, 0x1D, 0x26, 0xF6, 0xA5, 0xC3, 0x88,
    0xA7, 0x11, 0x3C, 0xFB, 0x30, 0xC9, 0x3F, 0xC1, 0x9B, 0xE0, 0xEF, 0x30, 0x0D, 0xEF, 0x1B, 0x93, 0x8F, 0x90, 0x71, 0xEF, 0x08, 0xCA,
    0x61, 0x09, 0xC1, 0x2B, 0x8F, 0x90, 0x7D, 0xA2, 0xB7, 0x49, 0xFE, 0xDF, 0xC6, 0xFA, 0x8F, 0x22, 0x78, 0xEA, 0xDB, 0x28, 0x0F, 0xA5,
    0x04, 0xAF, 0x22, 0xB8, 0x77, 0x19, 0xD1, 0x3F, 0xCB, 0x90, 0xAF, 0x9E, 0xE0, 0x19, 0x65, 0x98, 0xFF, 0x6A, 0x82, 0xD7, 0x97, 0x21,
    0x1D, 0xFF, 0xFF, 0x11, 0xF9, 0xF9, 0x1F, 0xB6, 0x4B, 0x06, 0xC1, 0x73, 0x09, 0x5E, 0x4F, 0xF0, 0xE6, 0xFF, 0x61, 0xFE, 0x83, 0xDF,
    0x21, 0xE3, 0xC0, 0x3B, 0x18, 0xBF, 0x94, 0xE0, 0x55, 0xEF, 0xA0, 0x1E, 0xEE, 0xFF, 0x2E, 0xE1, 0xFB, 0x2E, 0xE6, 0x3F, 0x93, 0xE0,
    0x79, 0x04, 0x6F, 0x24, 0xB8, 0xA6, 0x1C, 0xE7, 0x85, 0x69, 0xE5, 0x64, 0xFC, 0x27, 0x78, 0x19, 0xC1, 0xAB, 0xCB, 0x89, 0x5D, 0xEE,
    0x28, 0xE9, 0x77, 0x47, 0x51, 0x7E, 0x52, 0x09, 0x9E, 0x75, 0x14, 0xCB, 0x75, 0x86, 0xE0, 0x0D, 0x04, 0x0F, 0x78, 0x8F, 0x8C, 0x3F,
    0xEF, 0x11, 0xFD, 0x87, 0xE0, 0xF9, 0xEF, 0xA1, 0x1C, 0x36, 0x11, 0xDC, 0xF3, 0x18, 0xF6, 0xD3, 0x90, 0x63, 0x44, 0x7F, 0x3B, 0x86,
    0x74, 0x0A, 0x09, 0x5E, 0x76, 0x0C, 0xDB, 0xAB, 0x85, 0xE0, 0x3E, 0x15, 0x58, 0x3F, 0x61, 0x15, 0x64, 0x1D, 0x51, 0x41, 0xF6, 0xA1,
    0x08, 0x5E, 0x53, 0x81, 0xF5, 0x33, 0xE0, 0x38, 0x99, 0x2F, 0x8E, 0xE3, 0x78, 0x98, 0x41, 0xF0, 0xDC, 0xE3, 0x98, 0xCF, 0x3A, 0x82,
    0x5F, 0x3E, 0x8E, 0xF3, 0x4B, 0xC0, 0xFB, 0xA4, 0x1E, 0xDE, 0x27, 0xF5, 0x40, 0xF0, 0x7C, 0x82, 0x37, 0x10, 0xBC, 0xE5, 0x7D, 0xD4,
    0x13, 0x82, 0x3F, 0x20, 0xE3, 0xF0, 0x07, 0x88, 0xE7, 0x12, 0xBC, 0xE8, 0x03, 0x6C, 0xC7, 0x46, 0x82, 0x6B, 0x2A, 0x11, 0x0F, 0xAE,
    0x24, 0x74, 0x2A, 0x31, 0xFF, 0x79, 0x04, 0x2F, 0xAE, 0x24, 0xF6, 0x3A, 0x82, 0x7B, 0x9D, 0xC0, 0xF1, 0x7C, 0xFC, 0x09, 0x32, 0x1E,
    0x9E, 0xC0, 0xF8, 0x79, 0x04, 0x2F, 0x3E, 0x81, 0x7C, 0x9B, 0x08, 0xEE, 0x79, 0x92, 0xAC, 0x97, 0x4F, 0x12, 0x3A, 0x27, 0xB1, 0x3F,
    0x16, 0x10, 0xBC, 0xF4, 0x24, 0xD2, 0x69, 0x26, 0xB8, 0xF7, 0x87, 0x64, 0xBF, 0xF2, 0x43, 0x32, 0xCE, 0x7C, 0x48, 0xF6, 0x2B, 0x09,
    0x5E, 0xFA, 0x21, 0xB1, 0xFF, 0x57, 0x11, 0xFD, 0xAA, 0x8A, 0xE8, 0xDB, 0x04, 0xCF, 0x25, 0x78, 0x1D, 0xC1, 0x2F, 0x57, 0xA1, 0x3C,
    0x04, 0x7D, 0x44, 0xF4, 0x81, 0x8F, 0x88, 0x1D, 0x86, 0xE0, 0x05, 0x1F, 0x11, 0x3B, 0x0C, 0xC1, 0x35, 0xA7, 0x34, 0x9A, 0x08, 0x0D,
    0x9F, 0x4B, 0xA2, 0x4E, 0x91, 0xF1, 0xED, 0x14, 0x96, 0xB7, 0x94, 0xE0, 0x55, 0xA7, 0x30, 0x3F, 0xBE, 0xA7, 0x89, 0xDD, 0xE3, 0x34,
    0xCE, 0xA7, 0x61, 0x04, 0xCF, 0x3A, 0x8D, 0xF2, 0x5F, 0x4B, 0xF0, 0xA6, 0xD3, 0xD8, 0xAF, 0xC7, 0x57, 0x93, 0xFA, 0xAF, 0x46, 0xF9,
    0x2F, 0x22, 0x78, 0x39, 0xC1, 0x7D, 0x3F, 0x26, 0x7C, 0x3F, 0xC6, 0xF6, 0x32, 0x11, 0xBC, 0xEC, 0x63, 0xD4, 0xA3, 0x9A, 0x08, 0xDE,
    0xE5, 0x13, 0x48, 0xC3, 0xC6, 0x15, 0x56, 0x77, 0x9F, 0x10, 0x39, 0xFC, 0x04, 0xE3, 0x67, 0x12, 0xBC, 0x82, 0xE0, 0xCD, 0x04, 0x0F,
    0xF8, 0x94, 0xEC, 0x5B, 0x7D, 0x4A, 0xD6, 0x47, 0x9F, 0x62, 0xFD, 0x57, 0x11, 0xBC, 0xEE, 0x53, 0xAC, 0x87, 0x80, 0x33, 0xA4, 0x3F,
    0x9E, 0xC1, 0xFC, 0x67, 0x13, 0xBC, 0xE0, 0x0C, 0xDA, 0x2D, 0x5B, 0x08, 0xEE, 0xF3, 0x19, 0x8C, 0xA1, 0xAC, 0xAD, 0x58, 0x1B, 0x7D,
    0x46, 0xDA, 0xE5, 0x33, 0x61, 0x2B, 0x4A, 0x33, 0x9F, 0xB5, 0xD9, 0xE7, 0x44, 0xAF, 0xF8, 0x1C, 0xE9, 0x34, 0x12, 0xBC, 0xE7, 0x17,
    0xC8, 0x57, 0xFB, 0x05, 0xB1, 0x53, 0x7D, 0x81, 0x7A, 0x75, 0x29, 0xC1, 0xEB, 0xBE, 0x20, 0xFB, 0x65, 0x35, 0x64, 0x5C, 0xAA, 0x21,
    0x7A, 0x2C, 0xC1, 0xF3, 0x6B, 0x90, 0x4E, 0x0D, 0xC1, 0x35, 0x5F, 0x62, 0xFF, 0x1D, 0xF5, 0x25, 0x19, 0x0F, 0xBF, 0x24, 0xF6, 0x6D,
    0x82, 0x37, 0x7C, 0x89, 0xFD, 0xA8, 0xDF, 0x57, 0x64, 0x1E, 0xF9, 0x0A, 0xEB, 0xB9, 0x88, 0xE0, 0xE5, 0x5F, 0x11, 0xFD, 0xED, 0x6B,
    0x32, 0x8F, 0x7C, 0x8D, 0xF5, 0x93, 0x43, 0xF0, 0xEA, 0xAF, 0xB1, 0x3E, 0x83, 0x6A, 0xC9, 0xFC, 0x58, 0x8B, 0x72, 0x5E, 0x42, 0xF0,
    0xCA, 0x5A, 0x6C, 0xC7, 0x2E, 0xDF, 0x90, 0x75, 0xCA, 0x37, 0x58, 0xAE, 0x38, 0x82, 0xA7, 0x7D, 0x83, 0xF9, 0xA9, 0x22, 0xB8, 0xF7,
    0xB7, 0x58, 0xAE, 0x90, 0x6F, 0x49, 0xBF, 0x23, 0x78, 0x29, 0xC1, 0xAB, 0xBE, 0x45, 0x3A, 0x7E, 0xDF, 0x11, 0x39, 0xFC, 0x0E, 0xF1,
    0x74, 0x82, 0xE7, 0x7C, 0x87, 0xFD, 0xBD, 0x96, 0xE0, 0x4D, 0xDF, 0x61, 0xBD, 0x0D, 0xAD, 0x23, 0xF6, 0x8D, 0x3A, 0x8C, 0x9F, 0x4D,
    0xF0, 0x82, 0x3A, 0x6C, 0x97, 0x3A, 0x82, 0x5F, 0x26, 0x78, 0xC0, 0x59, 0x22, 0xCF, 0x67, 0x89, 0x3C, 0x13, 0xBC, 0xE0, 0x2C, 0xF6,
    0x97, 0x06, 0x82, 0xB7, 0x10, 0x3C, 0xF8, 0x7B, 0xD2, 0x1F, 0xBF, 0x27, 0xF3, 0x02, 0xC1, 0x8B, 0xBF, 0x27, 0xE3, 0x39, 0xC1, 0x3D,
    0xCF, 0x91, 0xF9, 0xFA, 0x1C, 0x99, 0xAF, 0xCF, 0x61, 0x79, 0x0B, 0x08, 0x5E, 0x45, 0x70, 0x9F, 0x7A, 0xA2, 0xE7, 0xD4, 0x13, 0xFD,
    0x9C, 0xE0, 0x45, 0xF5, 0x98, 0xCF, 0x26, 0x82, 0x77, 0xF9, 0x01, 0xCB, 0x1B, 0xF5, 0x03, 0x29, 0xEF, 0x0F, 0xA4, 0xFF, 0x12, 0xDC,
    0xE7, 0x47, 0xD4, 0xAF, 0xE2, 0x7E, 0x24, 0xE3, 0x15, 0xFC, 0xAD, 0x67, 0x72, 0xC7, 0x64, 0xE9, 0x3C, 0xE9, 0x5F, 0xE7, 0xC9, 0xBC,
    0x4F, 0xF0, 0xE2, 0xF3, 0xC8, 0xB7, 0x85, 0xE0, 0x3E, 0x0D, 0x84, 0x7E, 0x03, 0x91, 0xC3, 0x06, 0x72, 0xAE, 0x83, 0xE0, 0x8D, 0xF0,
    0xB7, 0x49, 0xC3, 0x79, 0x87, 0xFD, 0x44, 0xFA, 0xE3, 0x4F, 0x28, 0xFF, 0x65, 0x04, 0xAF, 0xFE, 0x09, 0xC7, 0x01, 0xBF, 0x9F, 0x89,
    0x1C, 0xFE, 0x8C, 0xE3, 0x73, 0x06, 0xC1, 0x73, 0x7F, 0xC6, 0xF9, 0xA5, 0x85, 0xE0, 0xC1, 0x17, 0xB0, 0xBC, 0xC5, 0x17, 0xC8, 0x78,
    0x7B, 0x81, 0xF7, 0x45, 0xA6, 0xBB, 0xF7, 0x6B, 0x24, 0xFD, 0xA2, 0x91, 0xF4, 0x0B, 0x82, 0x57, 0x35, 0xE2, 0x3C, 0xD2, 0xF3, 0x17,
    0xB2, 0x6E, 0xFD, 0x05, 0xDB, 0x31, 0x8D, 0xE0, 0xD9, 0xBF, 0x90, 0xF5, 0x02, 0xC1, 0x3D, 0x2F, 0x12, 0x7D, 0xE0, 0x22, 0x99, 0x8F,
    0x2E, 0x62, 0xBD, 0xE5, 0x10, 0xBC, 0xFC, 0x22, 0xCE, 0x77, 0xCD, 0x04, 0xEF, 0x79, 0x09, 0xE9, 0x84, 0x5D, 0x22, 0xF3, 0xE0, 0x25,
    0xEC, 0xA7, 0xB5, 0x04, 0xF7, 0x6C, 0x22, 0x72, 0xDB, 0x44, 0xE4, 0x96, 0xE0, 0x85, 0x04, 0xAF, 0x21, 0x78, 0xCF, 0x5F, 0x49, 0x79,
    0x7F, 0xC5, 0x7E, 0x61, 0x22, 0x78, 0xD1, 0xAF, 0xC8, 0xB7, 0x85, 0xE0, 0x3E, 0xBF, 0x21, 0x9D, 0x99, 0xBF, 0x91, 0xF5, 0x08, 0xC1,
    0xAB, 0x08, 0x5E, 0xF7, 0x1B, 0xD2, 0xEF, 0xF9, 0x3B, 0xE1, 0xFB, 0x3B, 0xCA, 0x49, 0x1A, 0xC1, 0xCB, 0x7F, 0x47, 0xB9, 0xF5, 0xBC,
    0x4C, 0xE4, 0xE4, 0x32, 0xD9, 0x07, 0x24, 0x78, 0x11, 0xC1, 0x1B, 0x09, 0xDE, 0xE5, 0x0F, 0x9C, 0x7F, 0x43, 0xFE, 0x20, 0xF5, 0xF3,
    0x07, 0xD9, 0xE7, 0x25, 0x78, 0xF1, 0x1F, 0xB8, 0xEE, 0xF3, 0xB9, 0x42, 0xC6, 0xFF, 0x2B, 0xD8, 0xDF, 0xE3, 0x08, 0x9E, 0x73, 0x85,
    0xD8, 0x31, 0x08, 0xEE, 0xF9, 0x27, 0xDA, 0x19, 0x82, 0xFE, 0x24, 0x7C, 0xFF, 0xC4, 0xFC, 0xE4, 0x10, 0xBC, 0xFA, 0x4F, 0x62, 0xF7,
    0x6B, 0x26, 0xE3, 0x49, 0x33, 0x39, 0x47, 0x44, 0xF0, 0xFC, 0x66, 0x32, 0x3F, 0x12, 0xBC, 0x91, 0xE0, 0xFE, 0x7F, 0x11, 0x3A, 0x7F,
    0x21, 0xAE, 0x27, 0x78, 0xC6, 0x5F, 0x58, 0xAE, 0x4A, 0x82, 0xD7, 0x12, 0xBC, 0xE7, 0xDF, 0xA4, 0xBD, 0xFE, 0x46, 0x3C, 0x95, 0xE0,
    0x59, 0x7F, 0x13, 0x3D, 0x8D, 0xE0, 0x4D, 0x7F, 0xA3, 0x3C, 0x04, 0xFD, 0x43, 0xF4, 0xDB, 0x7F, 0xB0, 0xDF, 0x95, 0x12, 0xBC, 0xEA,
    0x1F, 0xAC, 0x4F, 0x9F, 0x16, 0xB2, 0x7E, 0x6F, 0x41, 0x39, 0xC9, 0x20, 0x78, 0x21, 0xC1, 0x9B, 0x08, 0xEE, 0xF9, 0x2F, 0xDA, 0xF1,
    0xC2, 0xFE, 0x25, 0xE3, 0xD2, 0xBF, 0x64, 0xFF, 0x85, 0xE0, 0x0D, 0xFF, 0x62, 0x7E, 0x46, 0xFD, 0x47, 0xEC, 0x15, 0xFF, 0x61, 0x7F,
    0xCF, 0x23, 0x78, 0xF1, 0x7F, 0x98, 0xCF, 0xCB, 0x04, 0xF7, 0xBA, 0x8A, 0xF1, 0xA7, 0x5D, 0x25, 0xE3, 0xC6, 0x55, 0xAC, 0xFF, 0x4A,
    0x82, 0x37, 0x91, 0xF8, 0xA3, 0x00, 0x69, 0xE5, 0x0B, 0xFF, 0x6D, 0xDD, 0x5F, 0x26, 0x78, 0x05, 0xFC, 0x57, 0x92, 0x07, 0x8D, 0x07,
    0xE2, 0xFD, 0xE0, 0x6F, 0xA9, 0x5C, 0x99, 0x04, 0xCF, 0x83, 0xBF, 0xA5, 0x7C, 0xD6, 0x11, 0xBC, 0x67, 0x1B, 0x8F, 0xD6, 0x71, 0x58,
    0xDB, 0x06, 0xF1, 0x74, 0x82, 0x57, 0x11, 0xBC, 0x0E, 0xFE, 0x6E, 0xDD, 0xDF, 0xBC, 0x0E, 0x71, 0x3D, 0xFC, 0x2D, 0xCD, 0x53, 0x95,
    0x04, 0xF7, 0xF6, 0xF4, 0xC0, 0x73, 0x20, 0x9E, 0x88, 0x9B, 0x3C, 0x91, 0x4E, 0x39, 0xC1, 0x35, 0x6D, 0x11, 0x0F, 0x69, 0x8B, 0x78,
    0x58, 0x5B, 0xA4, 0x53, 0x42, 0xF0, 0xFA, 0xB6, 0x98, 0xCF, 0x80, 0xEB, 0x11, 0x1F, 0x7F, 0x3D, 0xE6, 0x27, 0x8F, 0xE0, 0x55, 0xF0,
    0xB7, 0xD4, 0xBF, 0x7A, 0xDE, 0x80, 0xF8, 0x50, 0xF8, 0x5B, 0x92, 0x93, 0x6C, 0x82, 0x17, 0xDC, 0x80, 0x7C, 0x9B, 0x09, 0xEE, 0xED,
    0xE5, 0xD1, 0x2A, 0xCF, 0xD3, 0xBC, 0x10, 0x8F, 0xF3, 0xC2, 0xFC, 0x94, 0x10, 0xBC, 0x92, 0xC4, 0xF7, 0x69, 0x87, 0xB8, 0x7F, 0x3B,
    0x6C, 0x97, 0x38, 0x82, 0xE7, 0xB4, 0xC3, 0x7A, 0xA8, 0x23, 0xF8, 0xE5, 0x76, 0x98, 0x9F, 0x89, 0x37, 0x22, 0x1E, 0x7A, 0x23, 0xB6,
    0x7B, 0x19, 0xC1, 0xAB, 0x6F, 0xC4, 0x7A, 0xE8, 0xD7, 0x1E, 0xF1, 0x51, 0xED, 0x91, 0x7E, 0x26, 0xC1, 0xF3, 0x08, 0xDE, 0x40, 0xF0,
    0x96, 0xF6, 0x58, 0xAE, 0x89, 0xDE, 0x84, 0x2F, 0xFC, 0x2D, 0xCD, 0x0B, 0x45, 0x04, 0x2F, 0xF7, 0xC6, 0x7A, 0xF6, 0xBD, 0x89, 0xC8,
    0xE7, 0x4D, 0x28, 0xCF, 0x5A, 0x82, 0xA7, 0xDF, 0x84, 0xF5, 0x53, 0x49, 0xF0, 0xDA, 0x9B, 0x90, 0x6F, 0xBF, 0x0E, 0x24, 0xFF, 0x1D,
    0x10, 0xCF, 0x24, 0x78, 0x1E, 0xFC, 0xDD, 0xBA, 0x1F, 0x44, 0xF0, 0x66, 0x12, 0x7F, 0xFC, 0xCD, 0x88, 0xCF, 0xBC, 0x19, 0xEB, 0xB3,
    0x88, 0xE0, 0xE5, 0x37, 0xA3, 0x3C, 0xF8, 0xF9, 0x20, 0x1E, 0xE0, 0x83, 0xF5, 0x93, 0x46, 0xF0, 0x6C, 0x1F, 0xE4, 0x5B, 0x43, 0xF0,
    0x46, 0x12, 0x3F, 0xE8, 0x16, 0xC4, 0x43, 0x6E, 0xC1, 0xFC, 0xE4, 0x12, 0xBC, 0xE8, 0x16, 0x94, 0x87, 0x26, 0x82, 0x7B, 0x76, 0xC4,
    0x7C, 0xCE, 0xEC, 0x88, 0xB8, 0xB6, 0x23, 0xD2, 0x29, 0x25, 0x78, 0x5D, 0x47, 0xAC, 0xCF, 0x7E, 0xB7, 0x92, 0x7A, 0xBB, 0x15, 0xC7,
    0x8D, 0x54, 0x82, 0x17, 0xDE, 0x8A, 0xED, 0xD2, 0x48, 0x70, 0x8D, 0xAF, 0x47, 0xEB, 0x78, 0x15, 0xE4, 0x4B, 0xF2, 0x0F, 0x7F, 0x4B,
    0xFB, 0x11, 0x69, 0x04, 0xCF, 0xF6, 0x25, 0xF5, 0x40, 0x70, 0xEF, 0x4E, 0xC8, 0x77, 0x62, 0x27, 0x22, 0x3F, 0xF0, 0xB7, 0xB4, 0xEF,
    0x50, 0x4A, 0xF0, 0x66, 0x12, 0x7F, 0xE8, 0x6D, 0x88, 0x4F, 0x84, 0xBF, 0x25, 0x7D, 0x29, 0x9D, 0xE0, 0x95, 0xF0, 0x77, 0xAB, 0xDD,
    0xB5, 0x33, 0xE2, 0xC1, 0x9D, 0xB1, 0x3E, 0x33, 0x08, 0x5E, 0xDE, 0x19, 0xF3, 0xE9, 0xD5, 0x85, 0x8C, 0x03, 0x5D, 0x30, 0x7E, 0x2A,
    0xC1, 0x0B, 0xE1, 0x6F, 0x49, 0x4F, 0xA8, 0x27, 0xB8, 0x4F, 0x57, 0xAC, 0xB7, 0x69, 0x5D, 0x11, 0x4F, 0xEB, 0x8A, 0xF9, 0x2C, 0x21,
    0x78, 0x65, 0x57, 0x92, 0xCF, 0xDB, 0x11, 0xF7, 0x83, 0xBF, 0x25, 0x7D, 0x60, 0x32, 0xC1, 0x4D, 0xB7, 0x63, 0x7E, 0x4A, 0x09, 0x5E,
    0x07, 0x7F, 0x4B, 0x7A, 0x4E, 0xCF, 0x6E, 0x24, 0xFF, 0xF0, 0xB7, 0xA4, 0x6F, 0xC4, 0x11, 0x3C, 0xBB, 0x1B, 0xE6, 0xA7, 0x92, 0xE0,
    0x97, 0xBB, 0x61, 0xFE, 0x83, 0xFC, 0x48, 0xFB, 0xFA, 0x91, 0xF6, 0x25, 0x78, 0xB6, 0x1F, 0xE6, 0xBF, 0x9A, 0xE0, 0x2D, 0x7E, 0xD8,
    0x5E, 0x41, 0xDD, 0x11, 0x8F, 0xEA, 0x8E, 0xF5, 0x96, 0x4F, 0xF0, 0x8A, 0xEE, 0x58, 0x2E, 0xAF, 0x3B, 0x10, 0x0F, 0xBA, 0x03, 0xF1,
    0x34, 0x82, 0x67, 0xDF, 0x81, 0xF2, 0x5C, 0x43, 0xF0, 0xC6, 0x3B, 0x70, 0x7C, 0x1B, 0xDF, 0x83, 0x8C, 0x27, 0x3D, 0x70, 0x5C, 0xAA,
    0x26, 0x78, 0x4B, 0x0F, 0x32, 0x8E, 0xF5, 0x24, 0x72, 0xD8, 0x13, 0xEB, 0x21, 0x9F, 0xE0, 0x75, 0x3D, 0xB1, 0x5D, 0x7C, 0x7B, 0x91,
    0x7C, 0xF6, 0xC2, 0x7E, 0xA1, 0x27, 0x78, 0x2E, 0xC1, 0xAB, 0x09, 0xDE, 0xDC, 0x0B, 0xF3, 0x1F, 0x7C, 0x27, 0x99, 0x37, 0xEF, 0xC4,
    0xFA, 0x2C, 0x26, 0x78, 0xC5, 0x9D, 0x58, 0x6F, 0x9A, 0xDE, 0x64, 0xFC, 0xEC, 0x8D, 0xE5, 0x4A, 0x25, 0x78, 0x69, 0x6F, 0x94, 0x67,
    0x8D, 0x3F, 0xC9, 0xA7, 0x3F, 0xCA, 0x49, 0x2A, 0xC1, 0x0B, 0xFD, 0x89, 0x3C, 0x13, 0xBC, 0x99, 0xC4, 0x0F, 0xEA, 0x43, 0xE4, 0xA1,
    0x0F, 0x91, 0x07, 0x82, 0x67, 0xF7, 0xC1, 0x76, 0xAF, 0x22, 0x78, 0x5D, 0x1F, 0x94, 0x43, 0xDF, 0xBB, 0x48, 0xFE, 0xEF, 0x42, 0x3C,
    0x94, 0xE0, 0xFA, 0xBB, 0x90, 0x4E, 0x11, 0xC1, 0x6B, 0xEE, 0xC2, 0xF6, 0xF2, 0xEF, 0x4B, 0xCA, 0x05, 0x7F, 0xB7, 0xEE, 0x23, 0x10,
    0x3C, 0xAF, 0x2F, 0x96, 0xAB, 0x86, 0xE0, 0x8D, 0x7D, 0x91, 0x6F, 0xCF, 0x7E, 0xA4, 0xBF, 0xF4, 0xC3, 0xF6, 0xD2, 0x12, 0x3C, 0xBD,
    0x1F, 0xE6, 0xA7, 0x8C, 0xE0, 0xD5, 0xFD, 0xB0, 0x1F, 0x79, 0xF5, 0x27, 0xFD, 0xB7, 0x3F, 0xE9, 0xBF, 0x04, 0x8F, 0x22, 0x78, 0x2E,
    0xC1, 0x8B, 0xFA, 0xE3, 0xBC, 0xD0, 0x4C, 0xF0, 0x80, 0xBB, 0x51, 0x4E, 0x52, 0xEF, 0x46, 0x3C, 0x9F, 0xE0, 0x0D, 0x04, 0xF7, 0xB9,
    0x07, 0xF3, 0x3F, 0xF1, 0x1E, 0x52, 0x9F, 0xF7, 0x60, 0x79, 0x0B, 0x08, 0x5E, 0x79, 0x0F, 0xE6, 0x5F, 0x33, 0x80, 0xB4, 0x0B, 0xFC,
    0x2D, 0xAD, 0xAF, 0xB3, 0x44, 0x9C, 0xFD, 0x2F, 0x7F, 0x00, 0xCA, 0x67, 0x1D, 0xC1, 0x2F, 0x13, 0x7C, 0xE8, 0x40, 0xC4, 0x27, 0x0E,
    0xC4, 0x76, 0xC9, 0x25, 0x78, 0x11, 0xC1, 0x5B, 0x08, 0xEE, 0x33, 0x08, 0xE7, 0x59, 0xED, 0x20, 0xC4, 0xD3, 0x09, 0x5E, 0x3B, 0x08,
    0xF3, 0xD9, 0x34, 0x08, 0xF3, 0xDF, 0xEF, 0x5E, 0x8C, 0x3F, 0xF9, 0x5E, 0x94, 0xFF, 0x5C, 0x82, 0x57, 0xDF, 0x8B, 0xF5, 0xD6, 0x25,
    0x80, 0xE8, 0xD5, 0x01, 0x28, 0x27, 0x59, 0x04, 0xCF, 0x87, 0xBF, 0xEF, 0x86, 0xF0, 0x2E, 0x26, 0xCF, 0x04, 0xBF, 0x1C, 0x80, 0xF4,
    0x47, 0x0D, 0x26, 0x74, 0x06, 0x23, 0xFD, 0x5C, 0x82, 0x17, 0x0D, 0xC6, 0xF8, 0x97, 0x09, 0xEE, 0x15, 0x88, 0xFD, 0x77, 0x26, 0xFC,
    0x2D, 0x9D, 0x8B, 0xCB, 0x0D, 0xC4, 0x7E, 0x57, 0x13, 0x48, 0xE4, 0x36, 0x10, 0xEB, 0x6D, 0xD4, 0x10, 0xC2, 0x77, 0x08, 0xEA, 0x57,
    0x05, 0x04, 0x2F, 0x1D, 0x82, 0xE3, 0x67, 0x0B, 0xC1, 0x7D, 0x86, 0x22, 0x3E, 0x6D, 0x28, 0xD1, 0x57, 0x87, 0xE2, 0xB8, 0x57, 0x44,
    0xF0, 0xF2, 0xA1, 0x58, 0x2E, 0xAF, 0x61, 0x44, 0xCE, 0x87, 0xA1, 0xDC, 0xC6, 0x11, 0x3C, 0x8D, 0xE0, 0x95, 0x04, 0xAF, 0x85, 0xBF,
    0xA5, 0x75, 0xF4, 0xA8, 0xE1, 0x24, 0xFF, 0xC3, 0x49, 0xFE, 0x09, 0x5E, 0x3A, 0x9C, 0xE4, 0x9F, 0xE0, 0x3E, 0x23, 0x3C, 0x84, 0xB1,
    0x87, 0xD9, 0xDC, 0x47, 0x8D, 0x20, 0xEB, 0x82, 0x11, 0xD8, 0x4F, 0xF3, 0x08, 0x5E, 0x39, 0x02, 0xFB, 0x85, 0x26, 0x08, 0xF1, 0x01,
    0x41, 0x38, 0x8E, 0x85, 0x12, 0x3C, 0x23, 0x08, 0xF3, 0x5F, 0x4D, 0x70, 0xCD, 0x48, 0xB2, 0x1E, 0x19, 0x49, 0xF8, 0x8E, 0xC4, 0xF6,
    0x2D, 0x24, 0x78, 0x19, 0xC1, 0x3D, 0xEF, 0x43, 0xBC, 0xCB, 0x7D, 0x88, 0x87, 0x11, 0xDC, 0x74, 0x1F, 0xD6, 0x43, 0x25, 0xC1, 0x6B,
    0xE1, 0x6F, 0x36, 0x66, 0x30, 0x59, 0xF4, 0xBE, 0x9F, 0xAC, 0xD7, 0xEE, 0xC7, 0x7E, 0x3D, 0x8D, 0xE0, 0xE9, 0xF7, 0x93, 0xF1, 0x8A,
    0xE0, 0xB5, 0xF7, 0x63, 0x7F, 0xF1, 0x1D, 0x45, 0xF4, 0xA2, 0x51, 0xA8, 0x77, 0xE5, 0x11, 0xBC, 0x78, 0x14, 0xAE, 0x23, 0x7C, 0x1E,
    0x20, 0xEB, 0x94, 0x07, 0x70, 0x7C, 0xC8, 0x24, 0x78, 0x1E, 0xFC, 0x2D, 0xD9, 0x09, 0x2F, 0x13, 0xDC, 0x6F, 0x34, 0x91, 0x93, 0xD1,
    0x64, 0x5D, 0x33, 0x1A, 0xF3, 0x53, 0x45, 0xF0, 0xBA, 0xD1, 0xD8, 0x2E, 0x3E, 0x63, 0x48, 0x3E, 0xC7, 0x60, 0x79, 0x4D, 0x04, 0xCF,
    0x24, 0x78, 0x19, 0xC1, 0xEB, 0xC6, 0x60, 0xBF, 0xF6, 0x0B, 0x26, 0x7A, 0x63, 0x30, 0xD1, 0x1B, 0x09, 0x5E, 0x14, 0x8C, 0x72, 0x52,
    0x4F, 0xF0, 0x2E, 0x0F, 0xA2, 0x1C, 0x86, 0x3E, 0x48, 0xF8, 0x3E, 0x88, 0x74, 0xCA, 0x09, 0x7E, 0xE6, 0x41, 0xAC, 0x7F, 0x9F, 0xB1,
    0x44, 0xDF, 0x1E, 0x8B, 0xF9, 0x49, 0x25, 0x78, 0xC1, 0x58, 0xA4, 0x53, 0x4B, 0x70, 0xCF, 0x71, 0x38, 0x5F, 0x04, 0x8D, 0x23, 0xF3,
    0xEF, 0x38, 0x1C, 0x37, 0xF2, 0x08, 0x5E, 0x35, 0x0E, 0xEB, 0xB9, 0xCB, 0x78, 0x22, 0xE7, 0xE3, 0xB1, 0xFF, 0x9A, 0x08, 0x9E, 0x39,
    0x1E, 0xE5, 0xAD, 0x96, 0xE0, 0x4D, 0x24, 0x7E, 0xD0, 0x04, 0x22, 0xE7, 0x13, 0xC8, 0xBA, 0x9B, 0xE0, 0x2D, 0x13, 0x30, 0xFE, 0xF8,
    0x87, 0xC8, 0xF8, 0xF9, 0x10, 0x99, 0xA7, 0x08, 0xEE, 0xF3, 0x30, 0xE6, 0x33, 0xF4, 0x61, 0x92, 0x9F, 0x87, 0xB1, 0x5F, 0x54, 0x13,
    0xBC, 0xE5, 0x61, 0x2C, 0x6F, 0xC8, 0x44, 0x92, 0x9F, 0x89, 0x28, 0x6F, 0xA5, 0x04, 0xAF, 0x9A, 0x88, 0xE3, 0xA7, 0xF7, 0x24, 0xD2,
    0x5F, 0x26, 0x61, 0xFB, 0xCE, 0x24, 0x78, 0xC6, 0x24, 0x9C, 0x5F, 0xEA, 0x08, 0xEE, 0xF5, 0x08, 0xCA, 0x7F, 0xDC, 0x23, 0x44, 0x6E,
    0x1F, 0xC1, 0xF6, 0xAD, 0x26, 0x78, 0xF3, 0x23, 0xD8, 0x5E, 0x03, 0x1E, 0x25, 0x72, 0xFB, 0x28, 0x8E, 0xAB, 0x19, 0x04, 0x2F, 0x7E,
    0x14, 0xE7, 0xCD, 0xA6, 0x47, 0x71, 0x9E, 0xF2, 0x0C, 0x41, 0x79, 0x0E, 0x0A, 0x21, 0xED, 0x1E, 0x42, 0xDA, 0x9D, 0xE0, 0xC5, 0x21,
    0xA8, 0x17, 0xB5, 0x10, 0xDC, 0xE7, 0x31, 0xCC, 0xCF, 0xF8, 0xC7, 0x90, 0x7E, 0xD4, 0x63, 0x28, 0x6F, 0x79, 0x8F, 0x11, 0x3A, 0x04,
    0x6F, 0x20, 0xF1, 0x7D, 0x1F, 0x47, 0x3C, 0xE4, 0x71, 0x52, 0xFF, 0x8F, 0x63, 0xFE, 0xF3, 0x09, 0x5E, 0xFD, 0x38, 0xCA, 0xB9, 0xF7,
    0x13, 0xA4, 0xFE, 0x9F, 0xC0, 0xFC, 0xEB, 0x09, 0x9E, 0xF1, 0x04, 0xE6, 0xBF, 0x9A, 0xE0, 0xF5, 0x4F, 0x60, 0xBF, 0xEB, 0x37, 0x99,
    0xF4, 0xA3, 0xC9, 0x64, 0xDD, 0x4A, 0xF0, 0xAC, 0xC9, 0x98, 0xCF, 0x0A, 0x82, 0xD7, 0x10, 0xDC, 0xE7, 0x49, 0x32, 0x8E, 0x3D, 0x89,
    0x78, 0x28, 0xC1, 0xF5, 0x4F, 0x62, 0x7B, 0x95, 0x10, 0xBC, 0x92, 0xE0, 0xDE, 0x53, 0x48, 0xB9, 0xA6, 0x20, 0x1E, 0x45, 0xF0, 0xD4,
    0x29, 0x98, 0xCF, 0x12, 0x82, 0x57, 0x4E, 0x21, 0xEB, 0xBE, 0xA9, 0x64, 0x9C, 0x9C, 0x8A, 0xF1, 0x67, 0x12, 0x5C, 0x4B, 0xF0, 0x42,
    0x82, 0x97, 0x11, 0xBC, 0x99, 0xE0, 0xDE, 0xD3, 0xC8, 0xFA, 0x7A, 0x1A, 0x59, 0xD7, 0x10, 0x3C, 0x97, 0xE0, 0x45, 0xD3, 0xB0, 0x1E,
    0xEA, 0x09, 0xDE, 0x3C, 0x0D, 0xDB, 0x71, 0xE8, 0x74, 0x32, 0x7E, 0x4E, 0xC7, 0x76, 0xCC, 0x25, 0x78, 0xD1, 0x74, 0x2C, 0x57, 0x23,
    0xC1, 0x35, 0x33, 0x10, 0x0F, 0x9E, 0x81, 0xF8, 0x34, 0x82, 0xE7, 0x10, 0xBC, 0x90, 0xE0, 0x0D, 0x04, 0x6F, 0x21, 0xF8, 0xA8, 0xA7,
    0x88, 0xFE, 0xF0, 0x14, 0xB1, 0x8B, 0x12, 0xBC, 0xF0, 0x29, 0x94, 0xAB, 0xCB, 0x04, 0xF7, 0x9A, 0x89, 0xE5, 0x0D, 0x9E, 0x49, 0xF2,
    0x43, 0xF0, 0x2C, 0x82, 0xE7, 0xCF, 0xC4, 0xF2, 0x36, 0x11, 0xDC, 0x73, 0x16, 0x8E, 0x33, 0xE3, 0x67, 0x11, 0x3B, 0x12, 0xC1, 0x73,
    0x09, 0x5E, 0x34, 0x0B, 0xEB, 0xB3, 0x81, 0xE0, 0x2D, 0xB3, 0xC8, 0x3A, 0x74, 0x36, 0x69, 0xAF, 0xD9, 0x88, 0x17, 0x12, 0xBC, 0x8C,
    0xE0, 0x5E, 0x73, 0x88, 0xFC, 0xCC, 0x41, 0xBE, 0xA1, 0x04, 0xD7, 0xCF, 0xC1, 0x71, 0xB5, 0x94, 0xE0, 0x55, 0x73, 0x70, 0xBD, 0xEC,
    0x1F, 0x4A, 0xD6, 0x53, 0xA1, 0x48, 0x3F, 0x83, 0xE0, 0xB9, 0xA1, 0x28, 0x3F, 0x67, 0x08, 0xDE, 0x12, 0x8A, 0x7C, 0x47, 0x3D, 0x4D,
    0xDA, 0xE5, 0x69, 0xA2, 0x57, 0x13, 0x3C, 0xFF, 0x69, 0x1C, 0xFF, 0x1B, 0x09, 0xAE, 0x99, 0x8B, 0xF3, 0x7E, 0xC0, 0x5C, 0x52, 0x9F,
    0x73, 0x71, 0x1C, 0xC8, 0x23, 0x78, 0xF1, 0x5C, 0x32, 0x5E, 0x11, 0xBC, 0x65, 0x2E, 0x99, 0x2F, 0xE6, 0x11, 0xFD, 0x6A, 0x1E, 0xCE,
    0x47, 0x65, 0x04, 0x6F, 0x9E, 0x87, 0xF3, 0x60, 0x48, 0x18, 0x59, 0xCF, 0x86, 0xA1, 0x5C, 0x9D, 0x21, 0xB8, 0x26, 0x1C, 0xF5, 0xF0,
    0xC9, 0xE1, 0x44, 0xEF, 0x0D, 0xC7, 0x7C, 0x96, 0x13, 0xFC, 0x0C, 0xC1, 0xBB, 0x44, 0x90, 0x79, 0x39, 0x02, 0x71, 0x3D, 0xC1, 0xF3,
    0x22, 0xC8, 0xBA, 0x95, 0xE0, 0x8D, 0x11, 0x98, 0x9F, 0x80, 0x48, 0x32, 0x0E, 0x47, 0x22, 0x5E, 0x40, 0xF0, 0xEA, 0x48, 0xCC, 0x67,
    0xCF, 0x28, 0xB2, 0x0E, 0x8D, 0x22, 0x76, 0x18, 0x82, 0x57, 0x45, 0x61, 0x7D, 0x7A, 0x46, 0x93, 0x7C, 0x46, 0x23, 0x1E, 0x45, 0xF0,
    0x2C, 0x82, 0x57, 0x10, 0xBC, 0x31, 0x1A, 0xFB, 0xE9, 0x80, 0x18, 0x22, 0xCF, 0x31, 0x28, 0x27, 0x79, 0x04, 0xAF, 0x8A, 0x41, 0xB9,
    0xF2, 0x8A, 0x25, 0xEB, 0xF1, 0x58, 0xCC, 0xA7, 0x9E, 0xE0, 0xB9, 0xB1, 0x28, 0x3F, 0xF5, 0x04, 0x6F, 0x26, 0xF8, 0xF8, 0x38, 0x22,
    0x3F, 0x71, 0x88, 0x17, 0x10, 0xBC, 0x34, 0x0E, 0xDB, 0xDD, 0x3B, 0x9E, 0x8C, 0xE7, 0xF1, 0x88, 0x9B, 0x08, 0x9E, 0x19, 0x8F, 0xFD,
    0xE2, 0x0C, 0xC1, 0x3D, 0xE7, 0x63, 0x3F, 0x0A, 0x9D, 0x4F, 0xE4, 0x7C, 0x3E, 0xD1, 0x7F, 0x08, 0xDE, 0x32, 0x9F, 0xF4, 0xF7, 0x05,
    0x64, 0xBE, 0x58, 0x80, 0xF9, 0xAC, 0x20, 0x78, 0xF3, 0x02, 0xA2, 0x57, 0x68, 0x89, 0x5E, 0xA1, 0xC5, 0x7E, 0x9D, 0x49, 0xF0, 0x3C,
    0x2D, 0xF2, 0xAD, 0x27, 0x78, 0xB3, 0x16, 0xDB, 0x25, 0x48, 0x47, 0xF4, 0x0A, 0x1D, 0xD1, 0x2B, 0x08, 0x5E, 0xAC, 0xC3, 0xFC, 0xB4,
    0x10, 0xDC, 0x27, 0x01, 0xF3, 0x1F, 0x9A, 0x40, 0xC6, 0x99, 0x04, 0xD4, 0x0F, 0x2B, 0x08, 0x5E, 0x93, 0x80, 0x7A, 0x5A, 0x40, 0x22,
    0xD9, 0x97, 0x81, 0xBF, 0xA5, 0x73, 0x32, 0x45, 0x04, 0x2F, 0x4F, 0x44, 0xFA, 0xDE, 0x7A, 0xD2, 0x2E, 0x7A, 0xA4, 0x6F, 0x22, 0x78,
    0x26, 0xC1, 0x6B, 0x09, 0xDE, 0xA4, 0x27, 0x7A, 0xEC, 0x42, 0x52, 0xDE, 0x85, 0x88, 0xE7, 0x10, 0xBC, 0x70, 0x21, 0xD6, 0x67, 0x13,
    0xC1, 0x3D, 0x0D, 0x18, 0x3F, 0xC4, 0x40, 0xFA, 0x1D, 0xC1, 0x0B, 0x09, 0x5E, 0x66, 0xC0, 0xF5, 0x54, 0x17, 0x23, 0xE9, 0x47, 0x46,
    0x94, 0x93, 0x0C, 0x82, 0xE7, 0x1A, 0xB1, 0xFE, 0x1B, 0x08, 0xDE, 0x62, 0xC4, 0x7A, 0x9B, 0x66, 0x22, 0xEB, 0x74, 0x13, 0xF6, 0xEB,
    0x52, 0x82, 0x57, 0x11, 0xDC, 0x2F, 0x89, 0xD8, 0x91, 0x92, 0xB0, 0x5C, 0xA9, 0x04, 0xCF, 0x4A, 0xC2, 0xF6, 0xAD, 0x21, 0x78, 0x63,
    0x12, 0xEA, 0xBD, 0x21, 0xC9, 0xA4, 0xBC, 0xC9, 0x48, 0xBF, 0x98, 0xE0, 0x15, 0xC9, 0x98, 0x7F, 0xDF, 0x14, 0x62, 0x47, 0x4A, 0xC1,
    0x76, 0x49, 0x23, 0x78, 0x36, 0xC1, 0xEB, 0x09, 0xDE, 0x4C, 0xF0, 0x90, 0x54, 0xC2, 0x37, 0x95, 0xE8, 0xF9, 0x04, 0xAF, 0x4A, 0x25,
    0xF3, 0xD7, 0x22, 0x32, 0x7F, 0x2D, 0xC2, 0xFE, 0x9B, 0x45, 0xF0, 0xFC, 0x45, 0x28, 0x57, 0x8D, 0x04, 0xD7, 0x2C, 0x46, 0xFA, 0x33,
    0x17, 0x13, 0xBD, 0x6B, 0x31, 0xE6, 0xA7, 0x9C, 0xE0, 0x67, 0x08, 0xDE, 0x6F, 0x09, 0xD1, 0x4B, 0x97, 0x20, 0x9D, 0x1C, 0x82, 0x17,
    0x2E, 0xC1, 0x7A, 0xBE, 0x4C, 0x70, 0xBF, 0x34, 0x32, 0x5F, 0xA7, 0x11, 0x7D, 0x98, 0xE0, 0x15, 0x04, 0x6F, 0x4E, 0xC3, 0xFA, 0x9F,
    0xB8, 0x94, 0xCC, 0x6B, 0x4B, 0xC9, 0xFE, 0x29, 0xC1, 0x9B, 0x96, 0x62, 0xFC, 0xE0, 0x65, 0x24, 0xFE, 0x32, 0xC4, 0x2B, 0x08, 0xDE,
    0xB2, 0x8C, 0xAC, 0xE3, 0x96, 0x93, 0x7E, 0xBD, 0x9C, 0xEC, 0xE7, 0x12, 0xBC, 0x65, 0x39, 0xF2, 0x9D, 0x98, 0x4E, 0xC6, 0xB1, 0x74,
    0x1C, 0xB7, 0x4B, 0x08, 0x5E, 0x9B, 0x8E, 0xF4, 0xFD, 0x57, 0x90, 0xF6, 0x5A, 0x41, 0xDA, 0x8B, 0xE0, 0x65, 0x2B, 0x70, 0x5E, 0xD3,
    0xAC, 0x24, 0x72, 0x05, 0x7F, 0xC7, 0x68, 0xF8, 0x19, 0xA0, 0x6C, 0x82, 0x17, 0xAC, 0xC4, 0xF9, 0xB4, 0x81, 0xE0, 0xBE, 0xAB, 0x90,
    0x7E, 0xDC, 0x2A, 0x32, 0x5F, 0xAF, 0xC2, 0xFC, 0x54, 0x10, 0xBC, 0x66, 0x15, 0xE6, 0xDF, 0x37, 0x83, 0xB4, 0x6F, 0x06, 0xE6, 0x27,
    0x9D, 0xE0, 0x85, 0x19, 0x48, 0xA7, 0x89, 0xE0, 0x7E, 0xAB, 0xB1, 0xDF, 0x45, 0xAD, 0x26, 0xF2, 0xBF, 0x1A, 0xE5, 0xB0, 0x96, 0xE0,
    0x3E, 0x6B, 0x90, 0x6F, 0xC8, 0x1A, 0x52, 0xFF, 0x04, 0x2F, 0x22, 0xF8, 0x99, 0x35, 0xD8, 0xEF, 0xFC, 0xD7, 0x92, 0x79, 0x76, 0x2D,
    0xE6, 0xA7, 0x80, 0xE0, 0xD5, 0x04, 0xEF, 0x92, 0x49, 0xC6, 0xA5, 0x4C, 0x62, 0x1F, 0x20, 0x78, 0x3E, 0xC1, 0x1B, 0x08, 0xEE, 0xFB,
    0x0C, 0xE6, 0x3F, 0xEC, 0x19, 0x32, 0xEF, 0x3C, 0x83, 0x72, 0x72, 0x99, 0xE0, 0x03, 0x9E, 0xC5, 0x79, 0x47, 0xFB, 0x2C, 0x69, 0xAF,
    0x67, 0x71, 0xDD, 0xAD, 0x59, 0x47, 0xC6, 0xAB, 0x75, 0xD8, 0x8E, 0x26, 0x82, 0x17, 0xAE, 0x23, 0xFB, 0x92, 0x04, 0xD7, 0x64, 0x21,
    0x3E, 0x3E, 0x8B, 0xCC, 0xFB, 0x59, 0x98, 0xFF, 0x7C, 0x82, 0x57, 0x91, 0xF8, 0x3E, 0xEB, 0xC9, 0x7C, 0xBA, 0x9E, 0xEC, 0x0F, 0x12,
    0xBC, 0x74, 0x3D, 0xE6, 0xBF, 0x99, 0xE0, 0x3D, 0x37, 0x60, 0xFC, 0xA8, 0x0D, 0x44, 0xFE, 0x37, 0xA0, 0xBC, 0x55, 0x11, 0xBC, 0x79,
    0x03, 0x59, 0x4F, 0x6D, 0x24, 0xEB, 0xA9, 0x8D, 0x48, 0x27, 0x8B, 0xE0, 0xF9, 0x1B, 0x51, 0x2F, 0xAA, 0x25, 0xB8, 0x67, 0x36, 0xD2,
    0x9F, 0x99, 0x4D, 0xC6, 0xAB, 0x6C, 0x2C, 0x6F, 0x09, 0xC1, 0xEB, 0xB2, 0xC9, 0x39, 0x8D, 0xE7, 0x48, 0x79, 0x9F, 0xC3, 0x72, 0xA5,
    0x13, 0x3C, 0xE7, 0x39, 0x1C, 0x1F, 0xEA, 0x09, 0xDE, 0x4C, 0xE2, 0x07, 0x3D, 0x4F, 0xF4, 0xC9, 0xE7, 0xB1, 0x3E, 0x0B, 0x09, 0x5E,
    0xF6, 0x3C, 0x96, 0xB7, 0x99, 0xE0, 0x3D, 0x37, 0x61, 0xBF, 0x88, 0xDB, 0x44, 0xDA, 0x77, 0x13, 0xCA, 0x73, 0x33, 0xC1, 0xFD, 0x73,
    0x30, 0x3F, 0xA6, 0x1C, 0xB2, 0x8E, 0xCE, 0x41, 0x39, 0xF4, 0x7D, 0x81, 0x8C, 0x0F, 0x2F, 0xE0, 0xF8, 0x19, 0x47, 0xF0, 0x1C, 0x82,
    0x9F, 0x21, 0xB8, 0x66, 0x33, 0xE2, 0xC1, 0x9B, 0x49, 0x7D, 0x12, 0xBC, 0x88, 0xE0, 0xE5, 0x04, 0xD7, 0x6C, 0x21, 0xFD, 0x62, 0x0B,
    0xE2, 0xD3, 0x08, 0x1E, 0x47, 0xF0, 0x42, 0x82, 0x97, 0x6D, 0xC1, 0x76, 0xD7, 0xE4, 0x12, 0x3A, 0xB9, 0xA4, 0x7F, 0x11, 0xDC, 0x44,
    0xF0, 0x72, 0x82, 0x9F, 0xC9, 0x25, 0xEB, 0x8B, 0xAD, 0x44, 0xBF, 0xDA, 0x8A, 0xF5, 0x99, 0x43, 0xF0, 0xF2, 0xAD, 0xD8, 0x5E, 0x9E,
    0xDB, 0x88, 0xBE, 0xBD, 0x8D, 0xEC, 0x7F, 0x11, 0x3C, 0x67, 0x1B, 0xB6, 0xFB, 0x19, 0x82, 0xB7, 0x6C, 0x43, 0xBE, 0xC1, 0xDB, 0x49,
    0xBD, 0x6D, 0x27, 0xF5, 0x46, 0xF0, 0x3A, 0x82, 0xF7, 0xCC, 0x23, 0x7C, 0xF3, 0x50, 0x6E, 0xD3, 0x08, 0x9E, 0x9F, 0x47, 0xE4, 0x9F,
    0xE0, 0xDE, 0x3B, 0x30, 0x9F, 0xE3, 0x77, 0x90, 0xFE, 0x4E, 0xF0, 0x6C, 0x82, 0x17, 0xEC, 0x20, 0xF3, 0x02, 0xC1, 0x7D, 0x76, 0x92,
    0xFD, 0xB2, 0x9D, 0x64, 0xBC, 0xDD, 0x49, 0xF6, 0x1F, 0x09, 0x5E, 0xB3, 0x13, 0xF3, 0xD9, 0xF3, 0x45, 0x92, 0xFF, 0x17, 0x51, 0x3F,
    0x8F, 0x23, 0x78, 0xC1, 0x8B, 0x28, 0xFF, 0x75, 0x04, 0xF7, 0xCE, 0x47, 0x7B, 0xFE, 0xA8, 0x7C, 0xB2, 0x5E, 0xCE, 0x27, 0xFB, 0x56,
    0x04, 0x3F, 0x93, 0x8F, 0xF5, 0xEF, 0xBB, 0x8B, 0xF4, 0xDF, 0x5D, 0xD8, 0x2F, 0xB2, 0x09, 0x5E, 0xB0, 0x0B, 0xEB, 0xB9, 0x9E, 0xE0,
    0x5E, 0xBB, 0x71, 0x7D, 0x1D, 0xB4, 0x9B, 0xE8, 0x57, 0xBB, 0x31, 0xFF, 0x39, 0x04, 0x2F, 0xDC, 0x8D, 0x76, 0xC8, 0x5A, 0x82, 0x37,
    0xED, 0xC6, 0xFA, 0x1C, 0xFA, 0x12, 0xA1, 0xF3, 0x12, 0xD1, 0x87, 0x09, 0x5E, 0xF6, 0x12, 0x8E, 0x3F, 0x5E, 0x05, 0x64, 0x3E, 0x2D,
    0xC0, 0x7C, 0xA6, 0x11, 0x3C, 0x9B, 0xE0, 0xD5, 0x04, 0xAF, 0x2F, 0x20, 0xF6, 0xC0, 0x3D, 0xC4, 0x6E, 0xB3, 0x07, 0xDB, 0x2B, 0x9B,
    0xE0, 0xA5, 0x7B, 0x70, 0x7D, 0xDA, 0x44, 0x70, 0xCF, 0xBD, 0xC4, 0x6E, 0xB3, 0x97, 0x8C, 0xDB, 0x7B, 0x89, 0xDE, 0x42, 0xF0, 0xCA,
    0xBD, 0x58, 0x3F, 0x2D, 0x04, 0xEF, 0xB9, 0x0F, 0xCB, 0xA5, 0xDD, 0x47, 0xF4, 0xF9, 0x7D, 0xC4, 0x4E, 0x42, 0xF0, 0x96, 0x7D, 0xC4,
    0x4E, 0x52, 0x48, 0xDA, 0xBD, 0x10, 0xF3, 0x99, 0x49, 0xF0, 0xE2, 0x42, 0x8C, 0xDF, 0x44, 0xF0, 0xA0, 0xFD, 0xD8, 0x2E, 0xDA, 0xFD,
    0x64, 0xDF, 0x67, 0x3F, 0xF6, 0xEB, 0x0A, 0x82, 0xD7, 0x10, 0xDC, 0xEF, 0x00, 0x99, 0x67, 0x0F, 0xE0, 0xF8, 0x90, 0x4E, 0xF0, 0x9C,
    0x03, 0xD8, 0x8E, 0xB5, 0x04, 0x6F, 0x3A, 0x80, 0xF2, 0x19, 0x74, 0x90, 0xE3, 0xE1, 0x1A, 0xBD, 0x26, 0x5E, 0x33, 0x50, 0xA3, 0xD3,
    0x18, 0xE1, 0xBF, 0x89, 0x9A, 0x04, 0x4D, 0xB4, 0x26, 0x12, 0x42, 0x03, 0x84, 0x49, 0xC2, 0xAF, 0x03, 0xE1, 0x9F, 0x01, 0xE2, 0x24,
    0x68, 0x4C, 0xF0, 0x37, 0xC3, 0x13, 0x60, 0xC5, 0x17, 0x0D, 0x7F, 0x0D, 0xD4, 0x68, 0x35, 0x83, 0xE1, 0xBF, 0xEC, 0x5F, 0x80, 0xC6,
    0xFC, 0x7F, 0x9E, 0xD3, 0xB8, 0x9C, 0x62, 0x5A, 0x9A, 0x92, 0x73, 0x8D, 0x03, 0x3E, 0x46, 0xF8, 0x65, 0x10, 0xA0, 0x5A, 0xF8, 0xBF,
    0x79, 0x5E, 0x52, 0x84, 0x74, 0x03, 0x05, 0x54, 0x0F, 0x58, 0xA2, 0x90, 0x56, 0x0B, 0x48, 0xBC, 0xF0, 0x17, 0xA3, 0x19, 0x0F, 0xFF,
    0x16, 0xB5, 0xE6, 0x23, 0xD0, 0x46, 0x3E, 0xB2, 0xA6, 0xF1, 0x7B, 0x3D, 0x0B, 0x04, 0xBE, 0x09, 0x02, 0x85, 0x41, 0x22, 0x4D, 0xA9,
    0x9C, 0x8E, 0xF2, 0x37, 0x40, 0xCD, 0x70, 0xEE, 0x3A, 0x40, 0x06, 0x8A, 0xE5, 0xE3, 0xF4, 0xC3, 0x85, 0x18, 0x58, 0x2F, 0x23, 0xEC,
    0xE4, 0xC7, 0x59, 0x5E, 0x48, 0x79, 0x88, 0x4B, 0x74, 0x59, 0xBD, 0x87, 0x0B, 0xB9, 0xA6, 0x34, 0x03, 0xDD, 0x4C, 0xD3, 0xBA, 0x45,
    0x1C, 0xA5, 0xC9, 0x4A, 0xAF, 0x85, 0xEF, 0x48, 0x68, 0x41, 0x39, 0x79, 0x93, 0xA7, 0x1B, 0x01, 0xB8, 0x51, 0xC8, 0x57, 0x04, 0xD0,
    0x4A, 0x84, 0x3C, 0x46, 0x0A, 0xB2, 0x1E, 0x03, 0xBF, 0xC7, 0xCA, 0xD2, 0xAD, 0x02, 0xE5, 0xB6, 0x8B, 0x40, 0x37, 0x4A, 0x93, 0x2C,
    0x52, 0x1F, 0x02, 0xE5, 0x92, 0x97, 0x19, 0xE4, 0x97, 0x24, 0xB4, 0x9D, 0x56, 0x25, 0x0F, 0x5B, 0xB4, 0x58, 0x4E, 0x75, 0xF0, 0x0B,
    0xEB, 0x2B, 0xF1, 0x02, 0xB5, 0x44, 0x01, 0x67, 0x92, 0x1B, 0x05, 0x5F, 0x06, 0xA1, 0xC7, 0x22, 0x6E, 0x9F, 0x4F, 0xEE, 0x53, 0x9C,
    0x4F, 0x14, 0xD0, 0xD6, 0x91, 0xF4, 0xF2, 0x65, 0xB1, 0xC7, 0x9F, 0xFF, 0x1E, 0x05, 0x5F, 0x8C, 0x5A, 0xB8, 0x20, 0xFB, 0xB1, 0x8A,
    0xE3, 0x82, 0x1F, 0x2C, 0xB0, 0x7D, 0x20, 0x4C, 0x12, 0x73, 0xA1, 0xCC, 0x3B, 0x41, 0x90, 0xAA, 0x78, 0xA1, 0xEF, 0x1A, 0x84, 0x5F,
    0x23, 0x21, 0x56, 0x24, 0xA4, 0x89, 0x17, 0x47, 0x01, 0xCA, 0x6F, 0xB0, 0xA5, 0x5C, 0xCC, 0xE4, 0x65, 0xB6, 0x4C, 0xE3, 0x4E, 0xBE,
    0x36, 0xC7, 0x9D, 0x99, 0x4A, 0x6D, 0x6A, 0x9B, 0x3E, 0x6B, 0x11, 0x56, 0x8F, 0xF6, 0xCA, 0xE7, 0x2E, 0x3E, 0x46, 0xE1, 0x2B, 0x19,
    0xF0, 0x48, 0xE1, 0x37, 0xB5, 0x1C, 0x95, 0xF9, 0x19, 0x04, 0xB9, 0xE7, 0xBF, 0x2F, 0x84, 0x76, 0x66, 0x7C, 0x16, 0xC9, 0xB6, 0x51,
    0x00, 0x2C, 0x22, 0x3B, 0x0A, 0x6E, 0x33, 0x4D, 0x62, 0xAB, 0x48, 0xAD, 0xE3, 0x1C, 0x9F, 0x40, 0x7B, 0xF2, 0x3F, 0x9B, 0xFB, 0xA0,
    0xA6, 0x73, 0x81, 0xD4, 0x53, 0x95, 0xE5, 0x01, 0xF9, 0xE9, 0x5B, 0xFB, 0x44, 0xB8, 0xAC, 0xF4, 0x49, 0xFC, 0xD4, 0xD1, 0x64, 0x68,
    0xBC, 0x6C, 0xDD, 0x6B, 0xE7, 0xF0, 0xBA, 0xA7, 0x7F, 0xDB, 0x2A, 0x93, 0xF2, 0xF8, 0x44, 0x79, 0x9B, 0x84, 0xB2, 0x18, 0x55, 0xF0,
    0x55, 0xA2, 0xC5, 0xEA, 0x92, 0x8D, 0xD3, 0xB1, 0xF0, 0x9D, 0x28, 0x8C, 0xDC, 0x51, 0x82, 0xEC, 0x19, 0x15, 0xC6, 0x6E, 0xB5, 0xF5,
    0x14, 0x21, 0x48, 0xAB, 0x56, 0xA0, 0xC9, 0x63, 0x22, 0xCD, 0x61, 0x16, 0x34, 0x33, 0x42, 0x41, 0x4F, 0x17, 0x6C, 0x4C, 0xF1, 0xAA,
    0xEB, 0x82, 0xC5, 0xD5, 0x43, 0x3C, 0x9D, 0x0A, 0xFA, 0xF5, 0xA1, 0xFC, 0x5C, 0x99, 0x49, 0xA4, 0xC3, 0x53, 0xD8, 0xD3, 0x2C, 0x34,
    0x2A, 0x79, 0x9B, 0xEC, 0x96, 0x6F, 0x84, 0x1D, 0xFE, 0x4A, 0x74, 0x23, 0x05, 0x8D, 0x84, 0x6B, 0x5E, 0xE1, 0x0A, 0x63, 0xB3, 0xDA,
    0x76, 0xE6, 0xD2, 0x6F, 0x5F, 0x17, 0x61, 0xC6, 0xE7, 0xDB, 0x84, 0x31, 0x97, 0xC5, 0xB3, 0xEC, 0x61, 0x8E, 0xD0, 0x0F, 0xB4, 0xD9,
    0xAF, 0xC2, 0xE6, 0xF2, 0xF1, 0x82, 0xC7, 0xD3, 0x12, 0x69, 0x57, 0x4F, 0x5B, 0x27, 0x68, 0x91, 0x5A, 0x41, 0x3F, 0x4D, 0xD4, 0xA4,
    0xC2, 0xC8, 0xC1, 0xB4, 0x97, 0x24, 0xC8, 0xAD, 0x4C, 0x0D, 0x89, 0xE5, 0x52, 0xCB, 0x83, 0xEB, 0xBE, 0xC9, 0x36, 0xF4, 0xAC, 0xC1,
    0xD7, 0x80, 0x6E, 0xE0, 0x35, 0xCA, 0xEF, 0x10, 0x17, 0xE9, 0xEA, 0x64, 0x34, 0x4C, 0xF5, 0x7D, 0x9F, 0xCF, 0x64, 0x46, 0xF8, 0xAF,
    0x56, 0x1C, 0xB7, 0x12, 0x04, 0x7D, 0x44, 0x6E, 0xBC, 0x77, 0x44, 0x9E, 0x29, 0x6D, 0x39, 0x7D, 0x3E, 0xC0, 0x4D, 0xF9, 0xB7, 0x47,
    0xD1, 0x35, 0x7A, 0x81, 0x4E, 0xCF, 0x41, 0xD6, 0xF4, 0x02, 0xDD, 0x9C, 0xBF, 0x40, 0x9B, 0x32, 0xEA, 0x3C, 0xBD, 0x21, 0x6E, 0xCE,
    0xDF, 0x10, 0x17, 0xF3, 0x67, 0x90, 0x9D, 0xBB, 0x25, 0x1D, 0x47, 0x3D, 0x1D, 0xD7, 0xEA, 0x3F, 0x4A, 0xEC, 0xC5, 0xB6, 0x56, 0x8E,
    0xCE, 0xF6, 0x41, 0xB6, 0x26, 0x8B, 0x80, 0x31, 0x32, 0x56, 0x86, 0x9A, 0x33, 0xB4, 0x74, 0xA2, 0xEE, 0x13, 0x05, 0xDF, 0x3A, 0xC1,
    0xE2, 0x60, 0xBF, 0xBF, 0x85, 0x46, 0xF1, 0xB1, 0x27, 0x0A, 0x52, 0xC7, 0x3A, 0x31, 0xCF, 0xF2, 0x75, 0x65, 0x38, 0x8C, 0xF7, 0x6C,
    0x55, 0xC9, 0x56, 0x75, 0xAE, 0xEB, 0x6F, 0x6C, 0x76, 0x8D, 0x14, 0xA8, 0x26, 0xCB, 0x8E, 0xF3, 0xEA, 0xE9, 0x19, 0x84, 0x59, 0xC9,
    0xA0, 0x89, 0x13, 0xC6, 0xB9, 0x28, 0x41, 0x33, 0x4F, 0xB0, 0xA8, 0xF7, 0x21, 0x4E, 0xD1, 0x8E, 0x81, 0xFF, 0x86, 0x0B, 0x33, 0x1D,
    0xFB, 0xE6, 0x2B, 0xF6, 0x58, 0x1B, 0xD4, 0x2D, 0x75, 0xF4, 0x33, 0xD1, 0x1A, 0x8D, 0x2F, 0x84, 0x46, 0xC8, 0x93, 0x3A, 0xBB, 0x09,
    0xE5, 0x19, 0x0F, 0xAD, 0x25, 0xAD, 0x3E, 0xEC, 0xF3, 0x50, 0x5F, 0x06, 0x73, 0x7A, 0x81, 0x6E, 0xA0, 0x67, 0x3D, 0xAB, 0xB8, 0xA6,
    0x0B, 0xDB, 0xA6, 0x19, 0xE8, 0x26, 0x9A, 0x31, 0x82, 0x7C, 0xE8, 0x44, 0x6D, 0x53, 0x76, 0x7D, 0x28, 0xBE, 0x29, 0x41, 0x57, 0xEB,
    0x46, 0x68, 0x39, 0xA3, 0xA0, 0xF7, 0x1B, 0xC4, 0x35, 0xFB, 0x20, 0x0B, 0xCB, 0x9F, 0xFA, 0xFE, 0x84, 0x79, 0x72, 0x4F, 0xBB, 0x5A,
    0xCE, 0x66, 0x43, 0xDC, 0x40, 0x2B, 0xD0, 0xB6, 0x96, 0xEA, 0x10, 0x2D, 0x03, 0xFC, 0x9A, 0x22, 0x68, 0xD0, 0xD1, 0x6E, 0xD1, 0xA1,
    0x63, 0x05, 0xEB, 0xAA, 0xC1, 0x62, 0xFC, 0x71, 0x6E, 0xAC, 0xC7, 0x51, 0x22, 0xDA, 0x2D, 0xBA, 0x4A, 0x9C, 0x30, 0x46, 0xE8, 0xAF,
    0x09, 0xAD, 0x40, 0x37, 0xD1, 0x0A, 0x74, 0x5B, 0xBE, 0x12, 0x61, 0x2C, 0x91, 0xF4, 0x00, 0x93, 0x6C, 0x0D, 0xAA, 0x6D, 0x5B, 0xD4,
    0x1F, 0x25, 0xCB, 0x65, 0xB4, 0x5B, 0xE6, 0x19, 0x79, 0xBA, 0xCE, 0xEB, 0x2E, 0xCC, 0xA2, 0x27, 0xD7, 0x7F, 0xE5, 0xEC, 0x0E, 0x4A,
    0xB4, 0xE7, 0x0B, 0xF5, 0xEB, 0xBA, 0x8C, 0x23, 0x1D, 0xDB, 0xA3, 0xBD, 0xDA, 0xB6, 0xB1, 0xB4, 0x93, 0x0C, 0x14, 0xDA, 0x3D, 0x56,
    0xB0, 0x5C, 0x2C, 0x52, 0x35, 0x03, 0xB8, 0x8F, 0x17, 0x72, 0x18, 0xEE, 0x26, 0xFA, 0xF6, 0x57, 0x9C, 0x81, 0x4E, 0x96, 0x41, 0x2B,
    0x8C, 0x52, 0x6C, 0x8E, 0x90, 0xA4, 0x4F, 0xD9, 0xC6, 0xAB, 0xB6, 0x4D, 0xB5, 0xC2, 0x3C, 0x6E, 0x10, 0x38, 0xA0, 0x3E, 0x66, 0x49,
    0x7D, 0xF0, 0x35, 0xA2, 0x1D, 0xE8, 0xB4, 0xEE, 0x2A, 0x4F, 0xDB, 0x35, 0xBD, 0x5D, 0x8E, 0xB6, 0xFD, 0xD6, 0x75, 0x96, 0x57, 0xA2,
    0x68, 0x1F, 0x8A, 0xD7, 0x2C, 0x16, 0xA8, 0x4A, 0xB6, 0x7D, 0xF7, 0xE9, 0x41, 0xF6, 0x79, 0xB8, 0x43, 0x7E, 0xE4, 0x69, 0xB3, 0x96,
    0x18, 0x7A, 0x0D, 0x68, 0x07, 0x5E, 0xB3, 0x7C, 0xAB, 0x9F, 0x8B, 0xAE, 0x1D, 0xAF, 0xC0, 0xFF, 0x43, 0x5E, 0x43, 0xAE, 0x01, 0x2F,
    0xB5, 0xBD, 0xC4, 0x19, 0x5E, 0x06, 0x61, 0xFC, 0x8B, 0x17, 0xB4, 0x67, 0xCB, 0x5D, 0x0D, 0xE7, 0xCA, 0xA1, 0x13, 0x7A, 0xBA, 0x51,
    0xD0, 0xE1, 0xB4, 0x6E, 0xB0, 0x3D, 0xB2, 0xB5, 0xBE, 0x4E, 0xF8, 0x5A, 0x24, 0x6B, 0x3F, 0x56, 0x9F, 0x3F, 0x56, 0xDA, 0x48, 0xB7,
    0xD4, 0xA3, 0x0E, 0x74, 0x5E, 0xAD, 0xD0, 0x52, 0x7A, 0x41, 0x12, 0xB8, 0xED, 0x35, 0x59, 0xDC, 0xCF, 0x37, 0x88, 0xBB, 0x06, 0x26,
    0xC5, 0xF9, 0x25, 0xCC, 0xA4, 0xD1, 0x74, 0x80, 0x50, 0x27, 0x50, 0x50, 0xBF, 0x56, 0x61, 0xD6, 0x3C, 0x9D, 0xA0, 0x33, 0xE9, 0x85,
    0x3C, 0xD8, 0x5B, 0xF1, 0x0D, 0x76, 0x72, 0xAE, 0xB4, 0x45, 0xDF, 0x55, 0xF9, 0xB0, 0x4F, 0xD3, 0xF9, 0xF9, 0x4B, 0xA2, 0x69, 0x14,
    0x76, 0xB0, 0x22, 0x55, 0xAE, 0x7C, 0x1D, 0xAF, 0x07, 0x4A, 0xDF, 0xF5, 0x7A, 0x48, 0x14, 0xD6, 0x60, 0x8E, 0xCC, 0x24, 0x6A, 0x69,
    0xF3, 0x7D, 0xBC, 0x38, 0xB7, 0xC8, 0x38, 0xDB, 0xFB, 0x49, 0x71, 0x4B, 0x9E, 0x58, 0x2F, 0x88, 0x11, 0x90, 0xA4, 0x56, 0xBD, 0xDF,
    0xE8, 0xA6, 0x3C, 0xCA, 0xD3, 0x0E, 0x74, 0x89, 0x36, 0x1D, 0x7D, 0x79, 0x0F, 0x57, 0x63, 0x23, 0x50, 0x2B, 0x5B, 0x9C, 0x62, 0xA4,
    0x20, 0x5D, 0x46, 0xC1, 0xF2, 0x96, 0x2C, 0xAC, 0xCE, 0x99, 0x24, 0xE8, 0x5A, 0x77, 0xAF, 0xDD, 0xA7, 0xBF, 0xA8, 0xE3, 0xE7, 0xBA,
    0xED, 0xC3, 0x11, 0x3E, 0xAE, 0xB6, 0x0F, 0xF2, 0x31, 0x0A, 0x36, 0x9F, 0x24, 0xA1, 0xCD, 0x4C, 0xB2, 0xF3, 0x99, 0x2B, 0x6B, 0x40,
    0x4B, 0x9E, 0x7C, 0xB7, 0xD4, 0x28, 0x9C, 0xFF, 0x32, 0xB9, 0xA5, 0xAF, 0x50, 0xFA, 0xAC, 0x27, 0x1B, 0x84, 0xD5, 0x7D, 0x94, 0x45,
    0x7F, 0x19, 0xEA, 0xC6, 0x75, 0xAD, 0x25, 0xCF, 0x44, 0xE1, 0x84, 0x0C, 0xD3, 0x14, 0x62, 0xDD, 0xA2, 0x17, 0xA8, 0xA3, 0x1F, 0x78,
    0xCD, 0xE8, 0xCB, 0x69, 0xA2, 0xEE, 0xE9, 0xBB, 0xD6, 0x3C, 0xDD, 0xBD, 0xBE, 0xB1, 0x3F, 0xFA, 0x38, 0x4B, 0xCF, 0xD8, 0x1A, 0x47,
    0xCD, 0x7C, 0xE9, 0x0C, 0x5D, 0x77, 0xE6, 0x51, 0xFD, 0x6A, 0xC2, 0x19, 0xFA, 0xCA, 0x35, 0xE0, 0x08, 0x4D, 0x5D, 0xEB, 0x39, 0x18,
    0xFB, 0xF4, 0xD4, 0x9E, 0x79, 0x30, 0xA7, 0x97, 0x20, 0x8C, 0x32, 0xF1, 0x20, 0x07, 0x72, 0xA7, 0x90, 0x1C, 0xA5, 0x1D, 0x2F, 0x9C,
    0x1E, 0x94, 0xB7, 0x9B, 0x79, 0x2D, 0xC7, 0xF2, 0xB3, 0x74, 0xEC, 0x2C, 0xA7, 0xA4, 0xF3, 0xAA, 0xDD, 0x3B, 0x91, 0xF8, 0x31, 0x5B,
    0xCF, 0x22, 0x37, 0xEC, 0xBB, 0x49, 0xF4, 0xF8, 0x39, 0x17, 0xFB, 0xFB, 0x49, 0x8E, 0xD6, 0x87, 0x39, 0xBD, 0x40, 0x97, 0xDB, 0xCE,
    0x9C, 0xDE, 0x10, 0x97, 0xE9, 0x19, 0x5A, 0x77, 0x42, 0x0D, 0xB2, 0x6D, 0xE6, 0x28, 0x5D, 0x93, 0xC5, 0xDA, 0xC8, 0x59, 0x7A, 0xEC,
    0x04, 0x1B, 0x9B, 0xEF, 0x17, 0xB8, 0x69, 0x8F, 0x8C, 0xCF, 0x80, 0x5A, 0xB7, 0xEE, 0xFF, 0x5A, 0xAF, 0x7E, 0xD5, 0xEF, 0x43, 0xF9,
    0xAE, 0xD4, 0x68, 0x6E, 0x87, 0x90, 0xD3, 0x48, 0x02, 0xEA, 0xFA, 0xD6, 0x33, 0x53, 0x6A, 0xD7, 0x6F, 0x72, 0xAB, 0x6F, 0xF7, 0x95,
    0xC9, 0xBE, 0x7D, 0x47, 0xF9, 0x9C, 0xAE, 0x3C, 0xCD, 0xC0, 0x6B, 0x40, 0x73, 0x88, 0x5B, 0x69, 0xAA, 0xB7, 0x9D, 0x38, 0xCB, 0x23,
    0x49, 0x3C, 0x79, 0x6A, 0x14, 0x56, 0x21, 0x91, 0xC2, 0xB8, 0x1C, 0xEF, 0x26, 0xFB, 0x02, 0xEB, 0xE3, 0x5A, 0xF8, 0x2D, 0x49, 0x90,
    0xC6, 0x44, 0xAB, 0x13, 0x19, 0xF6, 0xCE, 0x9D, 0xBA, 0x42, 0x37, 0xD0, 0x05, 0xBA, 0x4C, 0x03, 0xD6, 0x0A, 0xBB, 0x8A, 0xD2, 0xDC,
    0x6F, 0x7B, 0x77, 0xC0, 0xD9, 0xFA, 0xB0, 0xA4, 0x7F, 0x2D, 0xF4, 0x01, 0xB5, 0x3C, 0x02, 0x5D, 0xE4, 0x91, 0x24, 0x9C, 0x0D, 0x66,
    0xBB, 0xD7, 0xEA, 0xEC, 0xD3, 0x6A, 0xE5, 0xD3, 0x9A, 0xB6, 0x7D, 0x79, 0x51, 0x4F, 0x33, 0x5E, 0x3C, 0xDF, 0xB2, 0xA8, 0xF5, 0x6F,
    0x77, 0xAE, 0x49, 0x6D, 0xD3, 0x77, 0x47, 0x5B, 0x6A, 0x15, 0xF5, 0xD0, 0xDA, 0xB5, 0xD2, 0xD9, 0x4B, 0xAD, 0x60, 0x8F, 0x8A, 0x74,
    0x60, 0xFC, 0xA6, 0xF7, 0x43, 0xE2, 0x84, 0x5D, 0x2B, 0xBD, 0xA2, 0x55, 0x43, 0x7D, 0xDE, 0x4D, 0xE2, 0x4D, 0xA3, 0x58, 0x37, 0xD5,
    0x85, 0x39, 0x3D, 0x57, 0xCF, 0x98, 0x98, 0xD3, 0x53, 0xBF, 0xBA, 0x52, 0x2F, 0x13, 0x48, 0xDF, 0x9D, 0x6B, 0x13, 0x4A, 0x57, 0xDD,
    0x0E, 0x9D, 0x23, 0xB4, 0x17, 0x09, 0x27, 0xA7, 0xE2, 0xDC, 0x6C, 0x7F, 0xA4, 0x74, 0x5D, 0xDD, 0x47, 0xB4, 0xA6, 0x15, 0xE8, 0x12,
    0x2D, 0xA3, 0x8A, 0x95, 0x83, 0x6B, 0xF4, 0x02, 0xAD, 0xF6, 0x93, 0x9D, 0xA7, 0x17, 0xE8, 0xE2, 0xD8, 0xCA, 0x4F, 0x55, 0xB3, 0x1D,
    0x09, 0x39, 0x0B, 0x89, 0xB3, 0xF2, 0xC3, 0x28, 0xA7, 0x0A, 0x1A, 0x6E, 0x02, 0xC4, 0x4C, 0x12, 0x66, 0x65, 0xB5, 0xF7, 0x82, 0x0A,
    0xB2, 0xF8, 0xFD, 0x44, 0x6B, 0x1A, 0x31, 0xC2, 0xEE, 0x2B, 0xD3, 0x99, 0x53, 0x04, 0x4E, 0x0B, 0x54, 0xAF, 0xD5, 0xA8, 0xE5, 0x49,
    0x2F, 0xDC, 0x33, 0x73, 0xCF, 0xD9, 0x61, 0x39, 0xBA, 0x81, 0xD7, 0x80, 0xAE, 0x1A, 0x2D, 0xC4, 0x35, 0x1E, 0xEE, 0xDF, 0xA3, 0x93,
    0xD6, 0x39, 0x8B, 0xC5, 0x93, 0x6C, 0xEE, 0x91, 0x2F, 0x4B, 0x9A, 0xD7, 0x22, 0xDF, 0xBC, 0x4E, 0xA4, 0xF9, 0xD0, 0x1D, 0x76, 0xB6,
    0x24, 0x37, 0xDD, 0xE7, 0x49, 0x12, 0x4E, 0x1A, 0xB9, 0x2E, 0x03, 0xB6, 0xEE, 0x40, 0xBA, 0xF3, 0x8C, 0x51, 0xB2, 0xA8, 0x45, 0x58,
    0xEF, 0x07, 0x39, 0x37, 0xAE, 0x5A, 0xD2, 0x73, 0xB7, 0x5D, 0xD2, 0x9C, 0xBE, 0xF2, 0x0E, 0xA4, 0x5A, 0xBA, 0xE6, 0x67, 0x3C, 0x23,
    0x85, 0x33, 0x3B, 0x7A, 0x37, 0xE4, 0xD7, 0x9C, 0x2E, 0x9E, 0x4E, 0x36, 0x08, 0x3B, 0x3C, 0x89, 0xA2, 0x6D, 0xC5, 0x3D, 0xE7, 0x93,
    0x39, 0xC2, 0x57, 0x58, 0xC8, 0xC9, 0xF5, 0xBB, 0x33, 0xB6, 0xE9, 0xAA, 0xBE, 0xA1, 0xE3, 0x14, 0x1F, 0x57, 0xF7, 0xF2, 0x29, 0x2D,
    0x6E, 0x37, 0xE4, 0xFA, 0xB2, 0x49, 0x98, 0x57, 0x99, 0xE6, 0xA8, 0x3E, 0xFF, 0x39, 0x9B, 0x78, 0x9F, 0x4A, 0x11, 0xCF, 0x71, 0x2D,
    0x12, 0x68, 0x19, 0x55, 0xCF, 0x6D, 0x34, 0x2F, 0xE6, 0x6B, 0x7A, 0x75, 0x67, 0x7A, 0x9C, 0x29, 0xB3, 0x41, 0xD0, 0x93, 0x93, 0x60,
    0x46, 0x8E, 0x51, 0x3C, 0x13, 0x20, 0x95, 0xCF, 0x51, 0xFA, 0x7A, 0xE1, 0xFC, 0x05, 0x9F, 0xEF, 0xF9, 0x3E, 0x28, 0xDB, 0x5D, 0xE6,
    0x37, 0xA3, 0xE3, 0x65, 0x4F, 0xE7, 0x3A, 0x57, 0x26, 0x7B, 0xEB, 0x14, 0xE7, 0xE5, 0x8D, 0xF5, 0xCA, 0xE1, 0x9A, 0xA1, 0x6E, 0xE8,
    0x7B, 0xA9, 0x76, 0xBC, 0x02, 0x0C, 0x71, 0xD2, 0xBE, 0x61, 0x49, 0xCF, 0xB5, 0x35, 0x94, 0x4E, 0xDC, 0x37, 0xA2, 0xF7, 0x15, 0x24,
    0x0F, 0x12, 0xB2, 0xAD, 0x24, 0xFC, 0x4F, 0x9E, 0x76, 0x92, 0xF0, 0x1B, 0xDF, 0x0D, 0xB5, 0xEF, 0x71, 0xC1, 0x36, 0x65, 0xFB, 0xB4,
    0x0D, 0xA2, 0x46, 0x9A, 0x28, 0xDC, 0x6E, 0x49, 0x94, 0xA5, 0x35, 0x74, 0x0B, 0x97, 0xDF, 0x24, 0x31, 0x9D, 0xDA, 0x7B, 0xC9, 0x94,
    0x47, 0xB2, 0x38, 0x3A, 0xA8, 0xE1, 0x23, 0x4F, 0x4F, 0x79, 0x9F, 0xDB, 0x39, 0xBA, 0xD2, 0x5E, 0x1C, 0x5D, 0x19, 0xD8, 0xA7, 0xAA,
    0x8E, 0xA6, 0xF2, 0x69, 0x75, 0x75, 0x74, 0xF0, 0x94, 0x57, 0xB4, 0xCB, 0xB4, 0x74, 0x8A, 0x27, 0x4A, 0xD4, 0xD2, 0x91, 0x4E, 0x4C,
    0x31, 0x5B, 0x8F, 0x92, 0xCE, 0xA9, 0x8E, 0xA6, 0x7A, 0x1D, 0x56, 0x3D, 0x3D, 0xDC, 0xD5, 0x75, 0x9D, 0x9E, 0xFA, 0xFE, 0xA7, 0x8E,
    0x9E, 0x51, 0xB0, 0xEE, 0xA9, 0xED, 0x7F, 0xCA, 0xB4, 0x94, 0xAD, 0x4C, 0xEA, 0x68, 0x29, 0x97, 0x50, 0x1D, 0x1D, 0x49, 0xBB, 0x56,
    0x3A, 0xC1, 0xA1, 0x44, 0x2F, 0x4A, 0x3C, 0xAF, 0x13, 0x2D, 0xF4, 0x02, 0x93, 0x78, 0xB7, 0x80, 0xC7, 0x35, 0x0A, 0x7F, 0xA1, 0x07,
    0x14, 0x67, 0xC7, 0x5B, 0x25, 0x1E, 0x6A, 0x2D, 0xE0, 0xEE, 0xE6, 0x11, 0xE8, 0x66, 0x1E, 0xEE, 0x3A, 0xC7, 0xCB, 0xF8, 0x70, 0x1F,
    0x1D, 0xD1, 0xA2, 0xE7, 0x0E, 0xDB, 0x5E, 0x6B, 0xCC, 0x77, 0xBF, 0xD2, 0x77, 0x48, 0x3E, 0x4F, 0x62, 0x20, 0x9E, 0x4E, 0xF0, 0xC7,
    0xA0, 0xEC, 0x13, 0xC2, 0x92, 0x97, 0x3A, 0xDF, 0x1D, 0x12, 0x2F, 0x75, 0x34, 0x8D, 0xF0, 0x0B, 0xC5, 0xEC, 0x53, 0x56, 0xA2, 0xCB,
    0xAD, 0xF5, 0x5A, 0x81, 0x16, 0xF7, 0x14, 0x64, 0xE9, 0xA1, 0xC7, 0xF9, 0x3A, 0x57, 0x47, 0xDB, 0xB6, 0x6D, 0xAC, 0x65, 0x27, 0xD7,
    0xDB, 0xB8, 0x2E, 0x61, 0xE9, 0xE1, 0xCA, 0x55, 0x9E, 0xB6, 0xEF, 0x3C, 0xEB, 0x5F, 0xE4, 0x3C, 0xD9, 0xA8, 0xC9, 0xCF, 0x13, 0x33,
    0xAD, 0xCB, 0x5D, 0x3C, 0x87, 0x3A, 0x61, 0x03, 0xB4, 0x45, 0xDB, 0xD6, 0x6D, 0x18, 0x77, 0xB5, 0x8F, 0x2D, 0xDA, 0xCE, 0xDC, 0xB5,
    0xB4, 0x45, 0xDB, 0xF2, 0xE4, 0xA9, 0x3B, 0xF3, 0xCD, 0x47, 0x08, 0xF9, 0xDA, 0x50, 0x5A, 0x0B, 0xD8, 0xA2, 0x6B, 0x14, 0xED, 0x49,
    0x5A, 0x45, 0xDA, 0xD2, 0xBD, 0x5E, 0xC7, 0x68, 0x9B, 0xEF, 0x5A, 0x3A, 0x67, 0x03, 0x53, 0x47, 0x3B, 0xD0, 0x6D, 0xF9, 0x96, 0x76,
    0x9E, 0xDD, 0x2D, 0x7B, 0xF6, 0xAD, 0x4F, 0x8E, 0xD6, 0x47, 0x8A, 0x4D, 0xCF, 0x33, 0xE6, 0x54, 0x42, 0x5F, 0xE2, 0xE5, 0xA6, 0xB1,
    0x95, 0xC6, 0xF5, 0x54, 0xE1, 0xBF, 0x43, 0xE0, 0xDF, 0x02, 0xC1, 0x12, 0x6F, 0xFF, 0xE6, 0x19, 0xF3, 0xF5, 0xC8, 0xD7, 0x76, 0xB1,
    0x82, 0xCE, 0x34, 0x44, 0x85, 0x6F, 0x15, 0x5E, 0x13, 0x09, 0xC4, 0x06, 0xC4, 0xEF, 0xC2, 0x1B, 0x85, 0x3A, 0x89, 0xB4, 0x3A, 0xE5,
    0xEF, 0x6C, 0xDD, 0xDB, 0xE2, 0xC3, 0x7D, 0x38, 0x24, 0xA9, 0x38, 0xD7, 0x23, 0x8D, 0xCB, 0x8E, 0xD1, 0x36, 0x09, 0x79, 0xD7, 0x0A,
    0xED, 0x2D, 0x6F, 0x7F, 0x70, 0x94, 0xBE, 0x5A, 0x4D, 0x47, 0x7E, 0x9C, 0xB5, 0xA6, 0xEB, 0xC8, 0x1E, 0xBF, 0xA3, 0x79, 0x56, 0xDF,
    0x92, 0x8E, 0xB7, 0x25, 0xD3, 0xD1, 0xE5, 0xF6, 0xEB, 0xA6, 0xED, 0xE5, 0x77, 0x3E, 0x78, 0x3C, 0xF5, 0x32, 0xC9, 0xF7, 0x9B, 0xDC,
    0x5F, 0xDF, 0x12, 0x5D, 0xB5, 0xAB, 0x29, 0x79, 0xBA, 0xB1, 0x82, 0x05, 0x4A, 0xAA, 0x0B, 0xAA, 0x21, 0x49, 0xBB, 0x71, 0x06, 0x71,
    0x4D, 0xE9, 0xDA, 0x9D, 0x07, 0x73, 0x3E, 0x6C, 0xE7, 0x4B, 0x2F, 0xDE, 0x1D, 0x67, 0x1A, 0x2C, 0xF7, 0x08, 0x91, 0x28, 0xD8, 0xFD,
    0x25, 0x8D, 0xCD, 0xEE, 0x59, 0xCC, 0x7D, 0xBC, 0x3C, 0xB1, 0xA2, 0xED, 0x4C, 0xF2, 0xD9, 0x28, 0x3F, 0x16, 0x99, 0xF3, 0x37, 0x09,
    0x67, 0xCF, 0xE3, 0x65, 0xCF, 0x68, 0x87, 0x14, 0xF2, 0xF2, 0xD0, 0x94, 0x52, 0x3A, 0x25, 0x5E, 0x51, 0x02, 0xCA, 0x6F, 0xCE, 0xD8,
    0xDA, 0x75, 0x0D, 0xB0, 0x33, 0xF6, 0xC9, 0xD3, 0xB3, 0xF6, 0x0E, 0x94, 0xA4, 0x60, 0x7F, 0xF0, 0xD9, 0xCF, 0xCF, 0xBE, 0xE1, 0x98,
    0x1A, 0x23, 0xAC, 0xEB, 0x95, 0xFD, 0xDC, 0xC5, 0x09, 0xA5, 0x96, 0x4E, 0xB2, 0xC6, 0x89, 0x36, 0xD7, 0x44, 0x85, 0xBB, 0x67, 0xE9,
    0xFB, 0x79, 0xDB, 0x18, 0x1C, 0xF2, 0x79, 0x18, 0x07, 0x31, 0x4C, 0x42, 0x39, 0xD4, 0xAC, 0xBD, 0xE5, 0xE5, 0x8C, 0xEE, 0xC8, 0xC6,
    0x5B, 0xDC, 0x5D, 0x0F, 0x27, 0xDE, 0x2A, 0xA5, 0x51, 0x96, 0xEF, 0xC1, 0x3A, 0x6F, 0x6B, 0x33, 0xEF, 0xDD, 0x6A, 0x35, 0x14, 0xF9,
    0x32, 0x70, 0xCF, 0x55, 0xEC, 0xDE, 0x39, 0xB7, 0x55, 0xC5, 0x2B, 0xFA, 0x20, 0x6D, 0x3E, 0xC0, 0xE5, 0x87, 0x53, 0xD0, 0x11, 0xEF,
    0x96, 0xF2, 0x3C, 0x74, 0xC2, 0x39, 0x38, 0xFB, 0x94, 0x25, 0xBA, 0xF2, 0x34, 0xAC, 0xEF, 0xE9, 0x59, 0xD9, 0x59, 0x0F, 0x72, 0x39,
    0xC4, 0xFC, 0xA9, 0xF5, 0xCD, 0x66, 0xCD, 0x23, 0x50, 0xA1, 0x0E, 0xE4, 0xE9, 0xC8, 0x4B, 0x97, 0x94, 0x4F, 0x39, 0x1A, 0x7A, 0xD1,
    0x8B, 0x8F, 0xB1, 0xD5, 0xD3, 0xA0, 0x6B, 0xF5, 0xA7, 0x46, 0xE6, 0xE5, 0xD7, 0x0E, 0x09, 0xC2, 0x8C, 0x3B, 0x50, 0xA8, 0xA3, 0x44,
    0x21, 0x77, 0x26, 0xC5, 0x1D, 0x49, 0x8D, 0x66, 0xC0, 0xCB, 0x1A, 0xCD, 0x1D, 0x10, 0xC6, 0x88, 0x9E, 0x5C, 0x53, 0x84, 0x31, 0x45,
    0xAB, 0xF2, 0x6C, 0x2C, 0xE7, 0x29, 0x9D, 0x53, 0x90, 0xC6, 0x55, 0xEC, 0x6B, 0x31, 0xE2, 0xFD, 0x3B, 0xF3, 0x7E, 0x26, 0x37, 0xAE,
    0x97, 0xBD, 0xCC, 0xFD, 0xC5, 0x24, 0x8A, 0xB3, 0x82, 0x4E, 0x9C, 0x1F, 0x38, 0x85, 0x04, 0x72, 0x47, 0x93, 0x9E, 0xE0, 0x52, 0xCE,
    0x67, 0xAC, 0x20, 0x37, 0x46, 0x71, 0x87, 0x45, 0xFE, 0x16, 0x9F, 0x65, 0x1D, 0x4D, 0x3E, 0xC4, 0xFB, 0x29, 0xA7, 0xC2, 0x4F, 0xC2,
    0xB3, 0x11, 0x2D, 0x49, 0xD1, 0x7F, 0x6C, 0x82, 0xE0, 0xE9, 0xC8, 0x28, 0x6A, 0x2B, 0xF1, 0xAD, 0x37, 0x64, 0xA5, 0x7D, 0x04, 0xF9,
    0xF6, 0xAE, 0x3C, 0xC4, 0x75, 0x6D, 0xBA, 0x72, 0x70, 0x9C, 0x1F, 0xDD, 0x3D, 0xB5, 0xCF, 0x4D, 0xE2, 0xE5, 0x08, 0x5D, 0xEE, 0x95,
    0x17, 0x5B, 0x5B, 0x4D, 0x59, 0xD4, 0xD0, 0x97, 0x3C, 0x0A, 0x87, 0x8B, 0xA7, 0xBE, 0xA2, 0xDD, 0x94, 0x6F, 0x6E, 0xF5, 0xC7, 0x1D,
    0x37, 0xA3, 0xD3, 0x74, 0x6D, 0x69, 0xB9, 0xEE, 0xF6, 0x33, 0x60, 0xCD, 0xC3, 0xF5, 0x7B, 0x3A, 0xD6, 0x34, 0xDD, 0x33, 0x57, 0x51,
    0x3B, 0x42, 0xBC, 0x6C, 0x7B, 0xE5, 0xBD, 0xCA, 0xC7, 0x42, 0x4C, 0xA1, 0xD4, 0x77, 0x13, 0x85, 0x5C, 0x4B, 0x77, 0x70, 0x4D, 0xAD,
    0x27, 0xB6, 0xD5, 0xD5, 0xB1, 0xFC, 0x98, 0x29, 0xDD, 0x44, 0x75, 0x97, 0x7E, 0xAE, 0x17, 0x7A, 0x19, 0x97, 0x36, 0xF4, 0xC1, 0x6D,
    0x8F, 0x5A, 0xE1, 0x6B, 0x9C, 0x16, 0x4F, 0x65, 0x68, 0xBD, 0x2F, 0x26, 0xDF, 0xC7, 0x29, 0x0F, 0xAD, 0x30, 0x6B, 0xC4, 0x0B, 0x63,
    0x2A, 0xF5, 0x81, 0xAD, 0xBC, 0x63, 0x26, 0xF1, 0x56, 0xE6, 0xC1, 0x77, 0xFA, 0x4D, 0x2A, 0xF6, 0x8C, 0xE5, 0x69, 0x1A, 0x04, 0xED,
    0x57, 0xDA, 0xF9, 0x97, 0x74, 0x7D, 0xAD, 0xB8, 0x7F, 0xA0, 0x34, 0x06, 0xCB, 0xEF, 0xAF, 0x1B, 0x44, 0x8F, 0xEA, 0xE8, 0x33, 0x20,
    0x81, 0xF4, 0x7B, 0x07, 0x4E, 0x59, 0xC8, 0xE8, 0x78, 0xE6, 0x3C, 0x12, 0x04, 0x6F, 0x7B, 0xF1, 0x82, 0xCC, 0xA8, 0x3A, 0x7F, 0xE0,
    0x10, 0x6D, 0x3A, 0x6A, 0x49, 0x27, 0x9D, 0x23, 0x84, 0xD3, 0xAF, 0x06, 0x85, 0x33, 0x01, 0xF2, 0xE3, 0x96, 0x1C, 0x9F, 0x28, 0x61,
    0x54, 0x74, 0x7E, 0x8E, 0x90, 0xA3, 0x8D, 0xF2, 0xE4, 0x98, 0x94, 0xBA, 0xC6, 0xD3, 0x7E, 0xAB, 0xBB, 0xAB, 0x5C, 0x68, 0xE7, 0xBC,
    0x36, 0x65, 0xB0, 0x7D, 0x92, 0xD8, 0x7D, 0xF4, 0xDD, 0xA1, 0x1B, 0x28, 0xD3, 0x47, 0xAB, 0xC5, 0xB5, 0xE1, 0x21, 0xA7, 0x87, 0x0C,
    0x71, 0x63, 0x5D, 0xD9, 0xE3, 0x13, 0xE8, 0x62, 0x9B, 0xD0, 0xD9, 0x53, 0xBE, 0xB7, 0x0F, 0xB6, 0x39, 0x97, 0xAA, 0xE1, 0x61, 0x14,
    0xB5, 0x4E, 0xE5, 0x91, 0x56, 0xFD, 0x38, 0x65, 0x9B, 0xA6, 0xA3, 0x7B, 0x99, 0xD6, 0x3E, 0x00, 0xD8, 0x2C, 0x2C, 0xED, 0xE7, 0xC7,
    0x89, 0x3E, 0xB2, 0x9D, 0xB7, 0x23, 0xDA, 0xA6, 0x6F, 0x12, 0xC6, 0x06, 0xF3, 0x17, 0x2C, 0xB8, 0x5D, 0x43, 0xDD, 0x09, 0x6E, 0x79,
    0x7D, 0xC8, 0x16, 0x4F, 0xC9, 0x2F, 0xBB, 0xF9, 0x7B, 0x08, 0xCE, 0xEB, 0x87, 0xB6, 0x78, 0x24, 0x09, 0xE5, 0x91, 0xCB, 0xB7, 0xA3,
    0x75, 0x85, 0x5A, 0x8C, 0xAB, 0x77, 0x9E, 0xE4, 0x68, 0x3B, 0x7B, 0x56, 0x5A, 0x99, 0x66, 0xA0, 0xC3, 0x77, 0x33, 0xE5, 0x68, 0xAA,
    0xD7, 0x24, 0x1C, 0xE5, 0x11, 0x29, 0xC4, 0x0C, 0x17, 0xFC, 0xF0, 0xDB, 0x3A, 0x4B, 0x31, 0xD8, 0x45, 0x99, 0x67, 0xFB, 0x20, 0x29,
    0x2E, 0xBD, 0x03, 0x63, 0x8B, 0x26, 0x7F, 0xC3, 0x45, 0xB2, 0xA4, 0x87, 0x0B, 0xB7, 0x14, 0xED, 0x73, 0x70, 0x3C, 0xCF, 0xF6, 0xE8,
    0x07, 0xBA, 0x45, 0xB6, 0x23, 0x85, 0xFE, 0xAE, 0x17, 0x7A, 0xBE, 0xD2, 0xFA, 0x67, 0xDA, 0x3B, 0xD2, 0x9B, 0x02, 0x52, 0x1A, 0xB6,
    0x92, 0x54, 0x5A, 0xBB, 0x58, 0xF3, 0x94, 0xDE, 0xA6, 0xD0, 0x8B, 0xB7, 0x51, 0xE2, 0x5D, 0xBA, 0xE7, 0x60, 0x4D, 0x9F, 0x5A, 0x7F,
    0xA2, 0x5B, 0xED, 0x26, 0xF6, 0x46, 0x9C, 0xC1, 0x0E, 0xEC, 0x69, 0xCA, 0xF3, 0x92, 0xCE, 0x92, 0x2B, 0xED, 0xC9, 0x3A, 0xDA, 0x46,
    0x4A, 0x3C, 0x02, 0xAF, 0x09, 0x0F, 0x75, 0x6D, 0x73, 0x6D, 0xF8, 0x04, 0xBA, 0xCC, 0x87, 0xEF, 0x0D, 0xC9, 0xCF, 0xF3, 0x8E, 0xF6,
    0x75, 0xAD, 0x60, 0x7B, 0xD0, 0x0A, 0xAB, 0xF1, 0x05, 0x82, 0xFC, 0xAA, 0x7B, 0x03, 0xC1, 0x1D, 0x7C, 0xEC, 0x9D, 0x33, 0x72, 0xBC,
    0x5E, 0x6C, 0xD1, 0x0E, 0x74, 0x63, 0xFD, 0xD8, 0x93, 0x1B, 0xD7, 0xC6, 0x29, 0xEB, 0x7D, 0x4F, 0xF7, 0xCF, 0xC5, 0x8E, 0xEC, 0xAD,
    0x4A, 0xE7, 0x7D, 0xD4, 0xD2, 0x36, 0x02, 0xCD, 0x28, 0xF1, 0x7C, 0x8F, 0xBB, 0xF3, 0x8D, 0xB4, 0xDD, 0x37, 0xE6, 0x20, 0x4D, 0xF5,
    0x67, 0x55, 0x9D, 0xE5, 0xA1, 0x17, 0xFD, 0x2F, 0x4A, 0x36, 0xF2, 0x28, 0x37, 0x8E, 0x37, 0xF4, 0x94, 0x73, 0x8C, 0xB0, 0x4B, 0x81,
    0x3B, 0x5F, 0x46, 0x37, 0xB6, 0x81, 0x49, 0x38, 0x33, 0xCB, 0x39, 0xC9, 0x79, 0xFA, 0x50, 0xA6, 0x6B, 0x20, 0x27, 0xF3, 0xE8, 0x1B,
    0x51, 0xCA, 0x3E, 0x12, 0x9D, 0xA5, 0x6D, 0x6F, 0xE7, 0x57, 0xB9, 0xAE, 0x29, 0x3D, 0xC7, 0xAC, 0x1A, 0xEE, 0xA1, 0x1D, 0xE8, 0x06,
    0xDA, 0xF6, 0xE5, 0x7B, 0x98, 0xC3, 0xF2, 0xAD, 0x4C, 0xD7, 0xB9, 0xB9, 0x9A, 0xD2, 0xE5, 0xB8, 0x11, 0x90, 0x48, 0xB7, 0xD5, 0xAF,
    0x2D, 0x9A, 0x8E, 0xCF, 0xC1, 0x71, 0x56, 0xEF, 0x0E, 0xA9, 0xF5, 0x30, 0xA0, 0xAC, 0x77, 0xC5, 0x99, 0xD9, 0x0A, 0xD4, 0x9F, 0xAF,
    0x71, 0x84, 0xAE, 0x1A, 0x1F, 0x94, 0x8E, 0xD0, 0x93, 0xF3, 0x95, 0x33, 0xD8, 0x05, 0xBA, 0xC6, 0xD6, 0x5D, 0x96, 0x04, 0xD9, 0x33,
    0xC8, 0x8E, 0xD1, 0x34, 0x89, 0x77, 0x84, 0x75, 0x6E, 0x2B, 0xBF, 0x39, 0x4D, 0x55, 0xB7, 0xF2, 0x1C, 0xA4, 0x6F, 0xEF, 0x2E, 0x7F,
    0x80, 0xD3, 0x34, 0xA5, 0xB7, 0xF2, 0xD4, 0xDC, 0x1D, 0x77, 0x8C, 0x2E, 0xDE, 0xC1, 0x76, 0x17, 0xCD, 0x24, 0xE1, 0x4E, 0x53, 0xA4,
    0x78, 0xEA, 0x47, 0x59, 0xAF, 0x50, 0xA6, 0x2D, 0xD9, 0x71, 0xF9, 0xC9, 0xC1, 0x44, 0xE1, 0x4C, 0x44, 0xB8, 0x9D, 0xF9, 0xD2, 0x5C,
    0x82, 0xF5, 0x55, 0xDC, 0xC7, 0x96, 0xD2, 0x1B, 0x27, 0x4A, 0x6B, 0x45, 0xCC, 0x43, 0xA4, 0xF8, 0xA6, 0x46, 0xAC, 0x30, 0xDE, 0xDB,
    0xF6, 0x1F, 0x17, 0x60, 0x33, 0x0F, 0xCA, 0xB4, 0xF9, 0xCB, 0x4C, 0xE1, 0xC2, 0x48, 0x32, 0x5F, 0xB4, 0x7C, 0xB9, 0x83, 0xAE, 0x23,
    0x5E, 0x77, 0x1D, 0xA1, 0xCB, 0xFE, 0xB6, 0xB6, 0xD2, 0xB9, 0x26, 0x47, 0x94, 0x36, 0x9E, 0x53, 0xB6, 0x3E, 0xC5, 0xE3, 0x18, 0x5F,
    0x25, 0x3B, 0xA7, 0x2D, 0xBE, 0xD6, 0x6F, 0x19, 0x3A, 0xB6, 0xFE, 0xB7, 0x45, 0x33, 0x46, 0xE8, 0xBD, 0x51, 0x8A, 0x33, 0x8F, 0x72,
    0x1B, 0xD0, 0x9D, 0x61, 0xF9, 0x7D, 0x5D, 0xD3, 0x69, 0xE9, 0xDE, 0x01, 0x4D, 0xA5, 0x46, 0xE6, 0x29, 0x0F, 0xCB, 0x9B, 0xAA, 0xD8,
    0x7B, 0xE4, 0xE6, 0x0F, 0x89, 0xB7, 0x3D, 0x1E, 0xD2, 0x1D, 0x50, 0xA3, 0x70, 0x6B, 0x26, 0xDC, 0xE2, 0xCE, 0xB0, 0xFA, 0x79, 0x5A,
    0xA9, 0x2D, 0xCC, 0xF3, 0xCB, 0x4F, 0x37, 0xF2, 0xDB, 0xE9, 0x46, 0xF1, 0xDB, 0xDE, 0xAB, 0x7E, 0x83, 0x1D, 0x6A, 0x17, 0x79, 0x3E,
    0xEA, 0x5F, 0x0F, 0x94, 0xE7, 0x63, 0xDE, 0x16, 0xD1, 0x42, 0xBD, 0xF1, 0x9D, 0x28, 0x2A, 0x5F, 0x72, 0xF5, 0x95, 0xF9, 0x31, 0x7F,
    0x93, 0x5E, 0x69, 0x5C, 0xA4, 0xD4, 0xE5, 0xF7, 0xBE, 0x53, 0x04, 0x1F, 0x51, 0x03, 0x55, 0xD8, 0x99, 0x3C, 0x3F, 0xE1, 0x63, 0x40,
    0x0A, 0xF1, 0x2A, 0x25, 0xD1, 0x96, 0x4E, 0xFB, 0x71, 0xDA, 0x3A, 0x61, 0xFF, 0x5F, 0xDF, 0x5A, 0x57, 0x81, 0xB2, 0xFB, 0x22, 0xE6,
    0x69, 0xA5, 0x33, 0x57, 0xD2, 0x0D, 0x50, 0xA3, 0xB0, 0x1F, 0x2F, 0x97, 0xAF, 0x3C, 0xC8, 0x57, 0x3F, 0x81, 0x0E, 0xF7, 0x41, 0xCC,
    0x4F, 0x7D, 0xA5, 0x0A, 0xE7, 0x8A, 0xA3, 0x85, 0xD9, 0x97, 0x7B, 0xAA, 0xB1, 0x9D, 0x57, 0x89, 0x5F, 0xB2, 0xE0, 0x57, 0x74, 0xA0,
    0x30, 0x4F, 0xC9, 0xEB, 0x6C, 0xDE, 0x9F, 0x6A, 0x34, 0x77, 0x42, 0xC8, 0x53, 0xF0, 0xF8, 0xB6, 0x39, 0x59, 0x96, 0xCD, 0xFC, 0x45,
    0x2E, 0xDC, 0xC1, 0x88, 0x13, 0x7D, 0x2E, 0x46, 0xAB, 0xBE, 0x8B, 0xA7, 0x86, 0x2E, 0xCB, 0x53, 0x8C, 0xB0, 0x83, 0xA1, 0x55, 0x38,
    0x21, 0x86, 0x72, 0xAB, 0x86, 0x2E, 0x7D, 0xCB, 0x3D, 0x5A, 0xE6, 0xDD, 0x6E, 0x7B, 0x63, 0xB9, 0x33, 0x3C, 0xF8, 0x5A, 0xC2, 0x78,
    0x4D, 0xE8, 0xF3, 0xB9, 0x95, 0xAF, 0x09, 0xAF, 0x75, 0x59, 0x70, 0xE4, 0x94, 0x3C, 0x6D, 0xF0, 0x17, 0xD8, 0xA5, 0x99, 0x30, 0x52,
    0xC8, 0x4B, 0x9C, 0xEC, 0x9A, 0x3F, 0xEB, 0x33, 0x8D, 0x66, 0xB4, 0x9D, 0x31, 0xC0, 0x3E, 0x6D, 0xEB, 0x77, 0xE0, 0xDC, 0x9D, 0x77,
    0xB9, 0x51, 0xD2, 0xF2, 0x0C, 0xF8, 0xE4, 0xCF, 0x35, 0x9A, 0xB1, 0x4E, 0x94, 0xC1, 0xFA, 0xE4, 0xB3, 0xE3, 0xE5, 0xE0, 0x2F, 0x92,
    0xEB, 0x84, 0x93, 0x26, 0x06, 0x95, 0xE7, 0x15, 0x35, 0x5F, 0x68, 0x34, 0x3D, 0xC5, 0xBB, 0x0A, 0xB6, 0xD2, 0xDA, 0x1E, 0x5B, 0x2C,
    0xF3, 0x22, 0xBD, 0x31, 0x2E, 0xDD, 0x0C, 0xD2, 0x89, 0x7E, 0x04, 0x4C, 0x56, 0x1E, 0x51, 0x9C, 0x93, 0xB7, 0x28, 0xC2, 0x41, 0x66,
    0x4F, 0xEA, 0x0B, 0xBE, 0xC7, 0x8D, 0xB1, 0xD5, 0xD6, 0xA5, 0xF9, 0x88, 0x12, 0x25, 0x9E, 0x1D, 0x4E, 0x14, 0xEF, 0x4B, 0x2D, 0x72,
    0x79, 0xDC, 0x8A, 0x13, 0xF7, 0xEC, 0x06, 0x0A, 0xFD, 0x3D, 0x46, 0x86, 0x5E, 0x76, 0x0D, 0xBF, 0x3B, 0xC2, 0xE3, 0xA9, 0xCD, 0x7F,
    0x9C, 0xB8, 0xCA, 0x95, 0x3F, 0xF3, 0xDD, 0x58, 0xC3, 0xEB, 0x07, 0x63, 0xAB, 0xA7, 0xCF, 0x67, 0x13, 0x7E, 0x4B, 0x57, 0x8E, 0xC7,
    0xE4, 0x2F, 0xF9, 0x1C, 0x62, 0x9E, 0xC2, 0x19, 0xF9, 0x8E, 0x17, 0x66, 0x21, 0x6E, 0x69, 0xD0, 0xCA, 0xB6, 0x7C, 0x05, 0xF0, 0xF4,
    0x87, 0xD0, 0x32, 0x85, 0x2D, 0xAE, 0xF2, 0x3C, 0x75, 0x42, 0x2A, 0xF3, 0x3B, 0x01, 0xF6, 0xCB, 0x3A, 0xEA, 0x2B, 0xEE, 0x97, 0x2D,
    0xAE, 0xD5, 0x57, 0x1C, 0x3F, 0x2B, 0x2A, 0x49, 0x1F, 0xED, 0xE3, 0xEA, 0xF8, 0x27, 0x0A, 0xB6, 0xB0, 0x68, 0x71, 0x17, 0xCE, 0x91,
    0xB3, 0x62, 0xF2, 0x74, 0x6D, 0xED, 0xFF, 0xF3, 0x7D, 0x52, 0x93, 0x30, 0x26, 0xC7, 0xA8, 0x9A, 0x15, 0x94, 0x79, 0x50, 0x5B, 0x19,
    0xBD, 0x19, 0x64, 0x6B, 0x6D, 0xE4, 0x58, 0x0E, 0x0A, 0xBF, 0xE6, 0xF3, 0x78, 0x94, 0xD0, 0xBB, 0xAD, 0xD3, 0x5A, 0xAE, 0x21, 0xDC,
    0x9B, 0x57, 0x7E, 0x4B, 0x30, 0x5E, 0xE1, 0x1C, 0x70, 0x48, 0x2D, 0x1F, 0x4B, 0x79, 0x1E, 0x69, 0x1A, 0x39, 0x9D, 0xD2, 0x3A, 0x6F,
    0xB8, 0xDE, 0x93, 0xD3, 0x9F, 0x02, 0x9D, 0x6A, 0x23, 0x89, 0x36, 0xF7, 0x52, 0x13, 0x2F, 0x9E, 0x9C, 0x37, 0xA8, 0x38, 0x2D, 0xEC,
    0x08, 0x0F, 0x75, 0x77, 0x6E, 0xA5, 0xB5, 0x98, 0x12, 0x3D, 0xBD, 0xD8, 0x1A, 0x06, 0xD1, 0x5B, 0x1C, 0x3F, 0xE7, 0xA6, 0x4E, 0xA3,
    0xA9, 0xFB, 0x86, 0xF7, 0x51, 0x35, 0x54, 0x6C, 0xB7, 0x8F, 0xB4, 0x9E, 0xE0, 0x6F, 0x74, 0xC4, 0x5B, 0x9D, 0x09, 0x92, 0xD7, 0xDD,
    0xC2, 0xBE, 0x95, 0xF6, 0x1A, 0xCC, 0xD3, 0x28, 0xF3, 0x32, 0xBF, 0xDB, 0x1E, 0x2E, 0x8C, 0x46, 0x71, 0xAA, 0xCE, 0x64, 0xA8, 0xA5,
    0xC9, 0xDF, 0x82, 0x96, 0xCE, 0x28, 0xB0, 0x7C, 0x29, 0xBF, 0x7E, 0xE3, 0x38, 0x0F, 0xCB, 0x5B, 0x88, 0xEA, 0xF7, 0xF5, 0x9C, 0xE7,
    0xA1, 0xBC, 0xF7, 0xA3, 0x96, 0x76, 0x9C, 0xE0, 0xFD, 0x9D, 0x9F, 0xB5, 0x76, 0x67, 0xDD, 0xC7, 0x8B, 0x6F, 0xE0, 0x4A, 0x76, 0x54,
    0x77, 0xD2, 0xE6, 0xFB, 0xCB, 0xCA, 0x7B, 0x6B, 0x6A, 0xE9, 0xE9, 0xDC, 0xDC, 0x5E, 0x7C, 0x6E, 0x35, 0xB6, 0x6A, 0xD4, 0x3A, 0x95,
    0xFE, 0xDB, 0xD5, 0xD3, 0xA7, 0xBE, 0x25, 0xDC, 0x97, 0x6F, 0x47, 0xDF, 0xFE, 0x50, 0x4B, 0xD7, 0x91, 0xFD, 0x0F, 0x47, 0xF3, 0xCC,
    0x24, 0x41, 0xC9, 0x23, 0x9D, 0xE3, 0x34, 0xED, 0xFB, 0x21, 0x77, 0xB4, 0xED, 0xA4, 0x93, 0x8E, 0x3A, 0x71, 0x57, 0x89, 0x61, 0xFC,
    0x26, 0x71, 0xB2, 0x2C, 0xDD, 0xD2, 0x73, 0xD2, 0x79, 0x56, 0x29, 0xB6, 0xBD, 0xB9, 0x5F, 0x89, 0x97, 0x5E, 0xD1, 0xA7, 0xBF, 0x7F,
    0x3D, 0xF2, 0xE2, 0xB1, 0x9D, 0xE3, 0xC5, 0xEF, 0xC5, 0x5A, 0xFB, 0x4E, 0xB5, 0x9C, 0xC9, 0x73, 0xEA, 0xD1, 0x46, 0x89, 0x29, 0x9C,
    0xE1, 0xA9, 0x17, 0xD7, 0xDD, 0x5A, 0xD9, 0xFE, 0xEB, 0xF9, 0x03, 0xB7, 0x7F, 0xD1, 0xD8, 0x4A, 0xF3, 0x93, 0xE5, 0xDA, 0x13, 0xE7,
    0x37, 0x75, 0xEB, 0xCE, 0x54, 0xE0, 0x79, 0xB7, 0xD9, 0xBC, 0x88, 0xE9, 0xE8, 0x2E, 0xB6, 0x41, 0x65, 0xB9, 0xCD, 0xF3, 0x62, 0xFB,
    0xFC, 0xAC, 0x9A, 0x7D, 0x4B, 0xDB, 0x3A, 0x8E, 0x12, 0x2F, 0x16, 0x9B, 0x6B, 0xD8, 0x78, 0xF2, 0x4C, 0x2B, 0xEC, 0x09, 0x19, 0x65,
    0x5A, 0x3A, 0xED, 0x47, 0x8D, 0x26, 0xB8, 0xD5, 0xA6, 0xCA, 0xEF, 0xCE, 0xA0, 0x17, 0x1E, 0x65, 0xCA, 0x8E, 0xB6, 0x91, 0xB4, 0x9B,
    0xC3, 0x5F, 0xF0, 0x94, 0x7C, 0x83, 0x59, 0xEA, 0xC2, 0x92, 0xED, 0x39, 0xA1, 0xF5, 0xB4, 0xB6, 0xD1, 0xE1, 0xB5, 0x81, 0x7C, 0x1E,
    0x52, 0x6D, 0x9E, 0xA9, 0xB0, 0xF0, 0x03, 0x79, 0x9E, 0xF7, 0x01, 0x1E, 0x5F, 0xAA, 0x05, 0xC7, 0x65, 0x81, 0x7B, 0xBF, 0xD2, 0x0A,
    0x37, 0xA3, 0xD5, 0xBC, 0x81, 0xE7, 0x78, 0x79, 0xAC, 0xE9, 0x27, 0x8B, 0x77, 0x95, 0x74, 0x56, 0x7E, 0x09, 0x06, 0xBB, 0xC4, 0x2B,
    0x51, 0x5C, 0x9D, 0xDA, 0x1D, 0xC7, 0x1B, 0xF8, 0xFD, 0x5C, 0x1E, 0xCF, 0xBC, 0x5D, 0x8D, 0x4E, 0xD4, 0x1D, 0xBF, 0x77, 0xC5, 0xBD,
    0xC8, 0x45, 0x8A, 0x1A, 0xA2, 0xFD, 0xB3, 0xE9, 0xEA, 0xF7, 0x12, 0xB2, 0xA6, 0xF1, 0xF5, 0xBA, 0xDA, 0x7C, 0x50, 0xCF, 0x9C, 0xE6,
    0xB7, 0xEF, 0x03, 0x5D, 0xA6, 0x2D, 0xE9, 0x21, 0x8E, 0xDE, 0xEE, 0x57, 0x4B, 0x3F, 0x59, 0x58, 0x5D, 0xA4, 0xB4, 0x9E, 0x45, 0x88,
    0x16, 0xEF, 0x39, 0xAB, 0xB5, 0x8C, 0xC9, 0xF1, 0x49, 0xB5, 0x29, 0x7D, 0xE6, 0xEB, 0x22, 0x5B, 0x31, 0xE5, 0x24, 0xD2, 0xE7, 0x82,
    0x46, 0xC8, 0x89, 0x5A, 0x0E, 0x6A, 0xC6, 0x20, 0x67, 0xF3, 0x69, 0xB9, 0x12, 0xB4, 0x97, 0x6B, 0x29, 0xCF, 0xF6, 0xF2, 0x90, 0x24,
    0xFA, 0x54, 0x34, 0xB7, 0x57, 0xF2, 0x53, 0x06, 0xD2, 0x6F, 0xF4, 0x34, 0xA6, 0xF9, 0xFC, 0x63, 0xBF, 0x8D, 0x46, 0x35, 0x6A, 0x34,
    0xF7, 0x09, 0xE7, 0xBC, 0xD5, 0x53, 0xE3, 0x79, 0x54, 0xEE, 0x8B, 0xD6, 0x79, 0xD6, 0x9B, 0xF5, 0xAA, 0x40, 0x27, 0xE6, 0x2E, 0x5B,
    0x34, 0x1D, 0x2F, 0xB5, 0x33, 0x7C, 0x8C, 0xE2, 0xDC, 0x1B, 0xAF, 0xF4, 0x72, 0xB4, 0x0A, 0xDA, 0x6C, 0x8E, 0x5C, 0x6C, 0x66, 0x93,
    0xC1, 0x52, 0xC4, 0x2B, 0x78, 0x82, 0xD1, 0x68, 0x9A, 0x7E, 0x91, 0x74, 0x39, 0x89, 0x92, 0x9A, 0xB6, 0x40, 0x9E, 0x6A, 0x47, 0x09,
    0x89, 0x8F, 0x32, 0x4D, 0x83, 0xE8, 0x91, 0x46, 0xFE, 0x84, 0x56, 0xE1, 0x45, 0xAE, 0x47, 0xE3, 0x79, 0x6D, 0x35, 0x7A, 0x1A, 0xBD,
    0x8D, 0xA2, 0x6C, 0xE1, 0xF1, 0xBE, 0xC4, 0xF3, 0xAC, 0xB7, 0xB2, 0x58, 0x69, 0x14, 0xE9, 0x1B, 0xC4, 0x99, 0xC2, 0x24, 0xFA, 0x70,
    0x94, 0xB5, 0xFB, 0x5C, 0x92, 0x7C, 0xBE, 0x98, 0xA7, 0x51, 0x2A, 0x4B, 0xBC, 0x68, 0x0B, 0x93, 0x66, 0x24, 0xFC, 0x35, 0x42, 0xF4,
    0x99, 0xAA, 0x7C, 0x56, 0xB3, 0xE9, 0x92, 0xB4, 0xD7, 0x8B, 0xE9, 0x5C, 0xE7, 0x2B, 0x23, 0x07, 0x22, 0x3F, 0x57, 0x69, 0xDB, 0xEA,
    0xEF, 0x65, 0x4D, 0xD4, 0x47, 0x0A, 0x8F, 0xAF, 0x6E, 0x7C, 0x51, 0xCF, 0x77, 0x88, 0x0C, 0x5F, 0x7B, 0xB4, 0xB5, 0x82, 0x37, 0x4E,
    0xFE, 0x5A, 0x84, 0x49, 0x7C, 0x31, 0x07, 0x3D, 0x9A, 0xDA, 0xAE, 0xA9, 0xCC, 0x5F, 0xF9, 0xBE, 0x81, 0x75, 0x6A, 0x29, 0xAD, 0x72,
    0x99, 0xE4, 0xF8, 0xAA, 0x3D, 0x9D, 0x2D, 0xE5, 0xC3, 0x1E, 0x0F, 0x83, 0xE8, 0x63, 0x44, 0x3A, 0x53, 0x28, 0xD5, 0x99, 0x84, 0xCB,
    0xAD, 0xEB, 0xB4, 0xBF, 0x51, 0xBF, 0xF6, 0x98, 0x46, 0x49, 0xFE, 0xD4, 0xF2, 0xB4, 0x25, 0x23, 0x12, 0x4F, 0xDB, 0xB4, 0x23, 0x85,
    0xFE, 0x6B, 0xB2, 0xE9, 0xCD, 0xCB, 0x59, 0xDD, 0xC4, 0x92, 0x26, 0xF7, 0x76, 0xB1, 0x40, 0xD0, 0x80, 0x0C, 0xC2, 0xA9, 0x6F, 0x39,
    0x8B, 0x41, 0xF6, 0xEF, 0x1A, 0xA8, 0x0F, 0x8D, 0x60, 0x9B, 0xE6, 0xFE, 0x97, 0xC2, 0x5B, 0xCF, 0x47, 0x72, 0x1F, 0x63, 0xC9, 0x0E,
    0xCC, 0xA3, 0x96, 0x79, 0xB1, 0xA4, 0x62, 0x5F, 0xA7, 0xE8, 0x72, 0x99, 0xD7, 0x1B, 0xB3, 0x74, 0x44, 0x08, 0x1E, 0xBC, 0xCC, 0x39,
    0xAA, 0xE3, 0xA7, 0xEE, 0xCE, 0x77, 0xC6, 0x65, 0x6E, 0x2F, 0x32, 0x4F, 0x8D, 0x69, 0xD5, 0x96, 0x35, 0x5E, 0xC5, 0xE9, 0x72, 0xAB,
    0x15, 0xC8, 0x1F, 0xBC, 0x9C, 0x34, 0x5D, 0xA4, 0xE2, 0xBC, 0xC2, 0x79, 0xA5, 0x0A, 0x37, 0x8F, 0x53, 0x5D, 0x98, 0xCF, 0x23, 0x05,
    0xE9, 0x48, 0x12, 0xD7, 0x15, 0x03, 0x45, 0x5F, 0xF2, 0x5A, 0x17, 0x64, 0x4F, 0xA2, 0x17, 0x25, 0xBE, 0xF5, 0xC9, 0xF0, 0xF9, 0xE2,
    0x4D, 0x6C, 0xD4, 0xF6, 0x1D, 0xF5, 0x2C, 0xA0, 0xC4, 0x53, 0xBA, 0xD1, 0x60, 0x20, 0xDF, 0xD6, 0xB3, 0xAD, 0xE5, 0x59, 0x81, 0xB4,
    0x2B, 0xD2, 0x3D, 0x41, 0x9A, 0x42, 0xB9, 0x9D, 0xCD, 0xF9, 0xF1, 0x55, 0x9A, 0xE4, 0x59, 0x5B, 0x6E, 0xBD, 0xD9, 0x78, 0x45, 0x9A,
    0x77, 0xCD, 0x53, 0x28, 0xB5, 0xB5, 0x4E, 0x18, 0x63, 0x6C, 0xBD, 0x8C, 0x63, 0xB1, 0xFF, 0xF5, 0x27, 0x9F, 0xEB, 0x78, 0x0A, 0x75,
    0xFD, 0x45, 0xEA, 0x97, 0x8A, 0xFE, 0x42, 0xFE, 0xE4, 0x67, 0xA1, 0x22, 0xC8, 0x8E, 0x05, 0x1F, 0xD3, 0xB9, 0x4F, 0x13, 0xDE, 0xA3,
    0x95, 0xCB, 0x92, 0xD8, 0x6A, 0xC1, 0x0D, 0x17, 0x35, 0x8F, 0x68, 0xD1, 0x77, 0xA6, 0xF9, 0x5A, 0x57, 0xED, 0xCE, 0xAB, 0x3C, 0x1F,
    0xD6, 0x56, 0x11, 0xA2, 0xFF, 0x99, 0x85, 0xF2, 0xE7, 0xDF, 0x9A, 0x51, 0x16, 0x30, 0x85, 0xB2, 0x2C, 0x48, 0x7C, 0x58, 0xA8, 0xB5,
    0xF0, 0x16, 0x6B, 0x59, 0x87, 0x61, 0x73, 0xE5, 0x74, 0x52, 0x89, 0x96, 0x6D, 0x3F, 0xBF, 0x96, 0x77, 0x3C, 0x24, 0x7F, 0x02, 0x8E,
    0xD2, 0xB2, 0x35, 0x47, 0xA9, 0xA3, 0xC5, 0xAD, 0xEF, 0xD4, 0x56, 0xAE, 0xB4, 0x4E, 0x91, 0xB7, 0x05, 0xA8, 0xA3, 0x6B, 0xEB, 0x4E,
    0xB8, 0x3B, 0xE8, 0x0E, 0x71, 0x3A, 0xBF, 0x46, 0xA1, 0xF7, 0xEB, 0x05, 0xB9, 0x95, 0xFC, 0x60, 0xC6, 0xB7, 0xAE, 0xA5, 0x23, 0x55,
    0x9E, 0x3B, 0x96, 0xE3, 0x81, 0x27, 0x17, 0xA4, 0x5E, 0x10, 0xAB, 0xEA, 0xF5, 0x92, 0x90, 0x7F, 0xF8, 0xF8, 0xC2, 0xCF, 0x00, 0xC5,
    0x5A, 0x79, 0x14, 0x77, 0x8C, 0xA7, 0xF9, 0xA9, 0x0A, 0xEE, 0x51, 0x32, 0x52, 0xD5, 0x79, 0x0C, 0xC7, 0xF8, 0xC4, 0x8B, 0x27, 0x95,
    0xEC, 0x53, 0xF6, 0x6F, 0x91, 0x6C, 0x91, 0x29, 0xE2, 0x9E, 0x79, 0xBC, 0xAA, 0xF9, 0xD8, 0xFA, 0x14, 0x08, 0xBE, 0x02, 0xA3, 0xE4,
    0x21, 0x29, 0xB7, 0x85, 0x9F, 0x03, 0x8A, 0x17, 0xA4, 0xC8, 0x9D, 0xBC, 0x02, 0xED, 0xF2, 0xB2, 0x4F, 0xDB, 0xDC, 0xD6, 0x67, 0x94,
    0xB5, 0x1C, 0x28, 0xED, 0x36, 0xA8, 0x91, 0x41, 0x7A, 0xC2, 0x4D, 0x3A, 0xC7, 0xB8, 0xA0, 0xF5, 0x14, 0xB3, 0x9A, 0x37, 0x9D, 0x06,
    0xBB, 0x99, 0x27, 0xB5, 0xE9, 0xBA, 0xA3, 0x6C, 0xF6, 0x2C, 0xA8, 0xF1, 0x4E, 0x9D, 0xCF, 0xB4, 0xA6, 0x1F, 0x25, 0x9C, 0x39, 0xD3,
    0x6B, 0x86, 0x3B, 0x78, 0xF2, 0x53, 0x89, 0x6E, 0x6C, 0xEB, 0x7E, 0x2D, 0xBD, 0xB5, 0xA4, 0xFC, 0x96, 0x6D, 0xDC, 0x55, 0x3E, 0x7F,
    0xC7, 0xB6, 0xDE, 0xFC, 0xB0, 0x4C, 0xAD, 0x4E, 0x5F, 0xC0, 0xD3, 0x61, 0xFC, 0x34, 0x93, 0x1C, 0xCF, 0xDA, 0xAB, 0x92, 0x4F, 0x44,
    0x83, 0x70, 0xB6, 0xD1, 0xFE, 0x79, 0x46, 0x6B, 0xFA, 0x5A, 0x71, 0x15, 0x94, 0x20, 0x68, 0x8C, 0xEE, 0xB2, 0x8D, 0x51, 0xCB, 0x1B,
    0xF7, 0x0D, 0x49, 0x6F, 0x14, 0xC8, 0x9E, 0x7F, 0xD2, 0x78, 0x08, 0xF7, 0x09, 0x6C, 0xA5, 0x53, 0x5B, 0x26, 0x69, 0xFF, 0x3A, 0x42,
    0xA1, 0xDE, 0x7C, 0x3D, 0x3C, 0x84, 0xF9, 0x38, 0x42, 0xE8, 0x63, 0x06, 0x15, 0x7B, 0xAB, 0xD6, 0x3C, 0x70, 0x17, 0xC9, 0xB6, 0xBF,
    0x66, 0xC9, 0x46, 0xEE, 0x9E, 0xBA, 0x34, 0x8A, 0x33, 0xA3, 0xF9, 0x4E, 0x96, 0x3D, 0xED, 0xE5, 0x32, 0x94, 0xEF, 0x6E, 0xD1, 0xCE,
    0xA5, 0xB3, 0x48, 0xC5, 0x79, 0x59, 0xBF, 0x85, 0xA1, 0x94, 0x07, 0xEB, 0xF2, 0xA9, 0x93, 0x18, 0xC9, 0xFF, 0xB1, 0x7B, 0xE8, 0x5B,
    0x8F, 0xED, 0xCE, 0xD2, 0xB7, 0xE7, 0x9D, 0xC0, 0x52, 0x17, 0x0A, 0xBE, 0xCE, 0x43, 0x28, 0x91, 0x5C, 0x7A, 0xF5, 0xFB, 0x05, 0xEA,
    0xF2, 0x23, 0xB5, 0x98, 0x92, 0x1F, 0xFD, 0x5A, 0x15, 0x79, 0xA3, 0xB4, 0xD4, 0xE6, 0x4D, 0xFE, 0x96, 0x90, 0x7A, 0xFF, 0xD0, 0x6A,
    0xF8, 0xF0, 0xBF, 0xE9, 0x68, 0xA4, 0x3C, 0xD6, 0x9E, 0xF1, 0xE4, 0xF2, 0x2D, 0x37, 0x86, 0xA9, 0x5D, 0x6B, 0x3A, 0x92, 0x97, 0x40,
    0x99, 0xBC, 0x28, 0xD1, 0xE7, 0x08, 0x5B, 0x29, 0x2C, 0x30, 0xB3, 0x2B, 0xD3, 0x1B, 0x4B, 0xB2, 0x7E, 0xED, 0xDA, 0xF2, 0xF1, 0x91,
    0xD2, 0x41, 0x8F, 0xD1, 0x46, 0xB1, 0xA5, 0x9D, 0xC9, 0x83, 0xF2, 0xAC, 0x2C, 0xF1, 0x76, 0x8C, 0x3E, 0xD7, 0xD9, 0x74, 0xA2, 0xE6,
    0xA2, 0xB6, 0x9C, 0xC5, 0xD7, 0x5B, 0x97, 0x13, 0x3D, 0xB4, 0x3B, 0x53, 0x4E, 0xF3, 0x7C, 0xA8, 0x39, 0xF9, 0x2C, 0xE5, 0xC1, 0x3D,
    0x7C, 0x0C, 0x8A, 0xF7, 0xA0, 0xDC, 0xC1, 0x0F, 0x7D, 0xF3, 0xB9, 0x9B, 0x8F, 0xBA, 0xBB, 0x09, 0xCE, 0xC9, 0x88, 0x74, 0x92, 0x38,
    0xBE, 0xD5, 0xA3, 0xBF, 0x7B, 0xDB, 0x84, 0xBD, 0xB7, 0xA2, 0x44, 0xD9, 0x35, 0xDA, 0x72, 0x27, 0x1B, 0xD3, 0xDA, 0x79, 0x88, 0xEB,
    0x2A, 0x1E, 0xD3, 0x20, 0xBC, 0x56, 0x23, 0x49, 0xB1, 0xA3, 0xFC, 0x62, 0x44, 0x6F, 0x88, 0xCA, 0xFB, 0x4F, 0x12, 0x5F, 0x47, 0xE9,
    0x27, 0x89, 0x96, 0x5C, 0x47, 0xFB, 0xAA, 0xB3, 0x7C, 0x62, 0x84, 0xF5, 0x6F, 0xB8, 0x78, 0x6B, 0xF0, 0xFF, 0x82, 0x27, 0xCA, 0xB2,
    0xB2, 0x47, 0x62, 0x67, 0x65, 0x1A, 0x79, 0xA5, 0x5C, 0x93, 0x7E, 0x2F, 0xD1, 0xBF, 0x56, 0x72, 0x2D, 0xD1, 0x57, 0x1E, 0x51, 0xDC,
    0x43, 0xDF, 0xF2, 0xBD, 0xDC, 0x6B, 0xC1, 0x43, 0xB9, 0xB5, 0x9D, 0x6B, 0x6B, 0xE5, 0x36, 0x70, 0x8E, 0xAE, 0xBA, 0xFB, 0x39, 0xAE,
    0xD2, 0xD6, 0x5D, 0x93, 0x79, 0x5F, 0xFD, 0xCC, 0xE7, 0x1C, 0x7D, 0xE9, 0x56, 0x87, 0x52, 0xEF, 0x52, 0xA7, 0x83, 0xDA, 0xA2, 0xAD,
    0xAE, 0xF6, 0xDD, 0x41, 0x5F, 0xE7, 0x36, 0x7B, 0x88, 0x1A, 0x3E, 0xD7, 0x6E, 0xCC, 0xB3, 0xF4, 0x32, 0xEE, 0xEE, 0xF2, 0x24, 0x8A,
    0xF3, 0x9E, 0x7C, 0x6F, 0x73, 0x2E, 0xEF, 0x46, 0x61, 0xDD, 0x14, 0x73, 0xCD, 0xE6, 0x55, 0x93, 0xE0, 0x61, 0x2F, 0x5A, 0x38, 0xF7,
    0x2B, 0xCF, 0xC1, 0x39, 0xFA, 0xCA, 0xB5, 0xEE, 0x5C, 0xBD, 0x48, 0x74, 0xF9, 0x6D, 0x51, 0xE9, 0x8D, 0x17, 0xF7, 0xCB, 0x4E, 0x52,
    0xEB, 0x4B, 0x24, 0x4A, 0xEB, 0x90, 0xAA, 0x8E, 0x1E, 0xE4, 0x6C, 0x0B, 0x4F, 0xEF, 0xD8, 0x9A, 0x40, 0x7A, 0xD5, 0x58, 0xCD, 0x89,
    0x24, 0x47, 0x65, 0x95, 0x5B, 0x92, 0x64, 0xF7, 0x6B, 0x6E, 0xF5, 0x20, 0xE7, 0x59, 0x8C, 0xE2, 0xBA, 0x3C, 0xD5, 0x21, 0x3B, 0x8C,
    0x39, 0x2F, 0x5D, 0xEB, 0x9B, 0x4B, 0xAE, 0x96, 0x21, 0x55, 0x38, 0x6F, 0xA1, 0x73, 0x83, 0x8D, 0x39, 0xC9, 0x09, 0x3F, 0x08, 0xB6,
    0x69, 0xF0, 0x77, 0x05, 0xD4, 0xDF, 0xC6, 0x68, 0xF4, 0xF5, 0x10, 0xCE, 0x07, 0xDB, 0x4E, 0xA7, 0x5C, 0xC7, 0xE8, 0x01, 0xD7, 0x1D,
    0x7B, 0xFF, 0xB6, 0x4F, 0x66, 0xF3, 0xBB, 0x56, 0x51, 0xC2, 0xDB, 0xF2, 0xA6, 0xD6, 0x97, 0x73, 0xA2, 0x45, 0x0B, 0x8B, 0xFC, 0x99,
    0xD9, 0xAA, 0x4E, 0x92, 0x5D, 0x4F, 0x89, 0x86, 0x52, 0x59, 0xCD, 0xBD, 0x5E, 0x48, 0x67, 0x53, 0xE5, 0xDE, 0xA2, 0x94, 0xCE, 0xAB,
    0xDB, 0xA7, 0x97, 0x2C, 0x8C, 0x6F, 0xFC, 0x4D, 0xCB, 0x28, 0x0B, 0x49, 0x32, 0xB7, 0xAA, 0xE5, 0xDC, 0xE6, 0x21, 0x9C, 0x15, 0x88,
    0x6A, 0x7D, 0x35, 0xD3, 0x28, 0x7A, 0x70, 0x4B, 0x15, 0xDF, 0x7E, 0xD2, 0x8B, 0x3E, 0x55, 0x94, 0x7C, 0x80, 0xD8, 0xE3, 0x6F, 0xCF,
    0xBA, 0x67, 0x7E, 0x06, 0xDF, 0xAF, 0xB3, 0x87, 0x70, 0x16, 0xCA, 0xFE, 0x5E, 0x8F, 0x72, 0x3D, 0xE2, 0x5D, 0xDA, 0x40, 0xE1, 0x14,
    0x81, 0x79, 0xAE, 0x65, 0x7C, 0x19, 0x01, 0x6F, 0x7E, 0xDF, 0xD7, 0x9C, 0x82, 0x3A, 0x7F, 0x24, 0xF4, 0x0D, 0x54, 0xEB, 0x53, 0x20,
    0xFC, 0x66, 0x3A, 0x7E, 0xDB, 0xCB, 0x83, 0x5F, 0x17, 0x0F, 0xF1, 0xAD, 0x62, 0x1A, 0x5F, 0x0D, 0x4F, 0x93, 0xB0, 0xBF, 0xEB, 0xA8,
    0xFF, 0xE6, 0xAC, 0x2E, 0x7C, 0x7E, 0x90, 0x28, 0xC4, 0x8A, 0x77, 0xD8, 0x95, 0xED, 0xA6, 0x51, 0xE2, 0xE9, 0x36, 0xFA, 0x0A, 0x4B,
    0x92, 0x6C, 0xFD, 0x36, 0x03, 0x2F, 0xBE, 0x57, 0x6B, 0x10, 0xC6, 0x02, 0x29, 0x85, 0x32, 0x9F, 0x64, 0x71, 0x84, 0x35, 0x39, 0xD0,
    0x9A, 0x1A, 0x4D, 0x5C, 0x57, 0x3E, 0x37, 0x25, 0x08, 0xA7, 0xE1, 0xB9, 0x3C, 0x2A, 0xF1, 0xA2, 0x6F, 0xCC, 0x5A, 0x5B, 0x55, 0xCD,
    0xFB, 0x8C, 0xF4, 0xD6, 0xAC, 0x32, 0x2D, 0x6E, 0x6D, 0xB0, 0x4D, 0x73, 0xB0, 0x43, 0x34, 0xF1, 0xAD, 0xDA, 0x91, 0xB2, 0x65, 0x8F,
    0xBA, 0xDD, 0x43, 0xE3, 0x23, 0xD4, 0x35, 0x8F, 0xAB, 0x54, 0x6E, 0xEB, 0x37, 0x70, 0xA3, 0xEC, 0xDC, 0x99, 0xB1, 0xB8, 0x9B, 0x7B,
    0xBB, 0x87, 0xF8, 0xDE, 0x6E, 0xAA, 0x95, 0x57, 0x14, 0xF5, 0xBC, 0x94, 0xD7, 0x6C, 0xD2, 0xDB, 0x93, 0xF2, 0x34, 0x95, 0xDF, 0x88,
    0x49, 0xEB, 0xE6, 0x21, 0xFA, 0xEB, 0x90, 0xE2, 0x2A, 0xF7, 0xAD, 0x54, 0x71, 0x54, 0x91, 0x34, 0xF7, 0x20, 0x19, 0xFA, 0xB5, 0xDD,
    0x24, 0xFB, 0x12, 0x8D, 0xAF, 0x86, 0x07, 0xDD, 0x67, 0x54, 0x7B, 0xAB, 0x05, 0xEB, 0x5F, 0x0D, 0x5D, 0xBB, 0x73, 0x98, 0x2C, 0x8D,
    0x68, 0xE1, 0x85, 0x50, 0x3C, 0x89, 0xA5, 0x6E, 0x97, 0xA6, 0xDE, 0x4F, 0xD2, 0x9B, 0x69, 0x6A, 0xA5, 0x7A, 0x88, 0x16, 0x4F, 0x93,
    0xF1, 0x50, 0x39, 0xE7, 0x1A, 0x4D, 0x48, 0x77, 0x89, 0x0F, 0x4D, 0xA1, 0xCC, 0xC7, 0xFA, 0xED, 0x5E, 0xF9, 0xF7, 0x75, 0x4B, 0x80,
    0x4F, 0x07, 0x61, 0x5E, 0x32, 0x7F, 0x5F, 0x57, 0x2D, 0x7D, 0x83, 0xF8, 0x0A, 0xA3, 0x92, 0xBE, 0xE4, 0x77, 0x87, 0xA4, 0xAF, 0x9B,
    0x84, 0x37, 0xB7, 0x68, 0x2A, 0xF9, 0x7E, 0x65, 0xFF, 0xCD, 0x60, 0xA5, 0xDD, 0x21, 0xE9, 0xED, 0x60, 0x47, 0xE9, 0x4A, 0xE7, 0x9B,
    0xE5, 0xDA, 0x47, 0x9E, 0x76, 0x8C, 0xB8, 0x17, 0xAF, 0x15, 0xD6, 0x0B, 0xFC, 0xD6, 0xB0, 0xF4, 0xF6, 0x41, 0x9C, 0x80, 0x47, 0x89,
    0xAF, 0xAD, 0xF0, 0x57, 0x2C, 0xE5, 0xD7, 0xE5, 0x33, 0x7B, 0xF0, 0xF9, 0xDB, 0x1E, 0x55, 0x75, 0x7A, 0x7D, 0x8C, 0x30, 0xF3, 0xD3,
    0xF3, 0x0B, 0xEA, 0x7C, 0x16, 0x98, 0xEB, 0x31, 0xF5, 0x3D, 0xF8, 0x5C, 0x67, 0x49, 0x4D, 0xBE, 0x0D, 0x6D, 0xBF, 0x72, 0x39, 0x50,
    0x78, 0x9B, 0x2A, 0x42, 0xD4, 0x31, 0x53, 0x65, 0x6F, 0x53, 0x49, 0xEF, 0x65, 0xDA, 0xA3, 0x9F, 0x28, 0x96, 0x49, 0xFA, 0x0B, 0xF5,
    0x05, 0xF9, 0x3B, 0x2C, 0x25, 0x3D, 0x3D, 0x84, 0x73, 0x4E, 0xB6, 0xD2, 0x49, 0x3E, 0x8B, 0x0C, 0xA2, 0x77, 0x76, 0xA5, 0x32, 0x1A,
    0xC5, 0x53, 0x8A, 0x31, 0x0A, 0x3C, 0xFB, 0xF5, 0xE2, 0x73, 0x98, 0x14, 0x57, 0x7E, 0x5D, 0x29, 0xD1, 0x35, 0x8A, 0x7E, 0x8F, 0xE4,
    0xFD, 0x71, 0x67, 0xF4, 0xF2, 0x10, 0xCF, 0x8D, 0x62, 0x7C, 0x35, 0xF9, 0x4E, 0x16, 0xDF, 0xC6, 0x54, 0xF2, 0x33, 0x52, 0x2F, 0xD2,
    0xA7, 0xF1, 0x95, 0xE9, 0x4B, 0xE3, 0xA4, 0x14, 0x23, 0xDE, 0x0C, 0x95, 0xED, 0x67, 0x77, 0xF2, 0x75, 0xAC, 0x35, 0x15, 0x65, 0x79,
    0xB7, 0xE6, 0x9B, 0x24, 0x48, 0x6C, 0x84, 0xDC, 0x98, 0x21, 0xF2, 0xB3, 0x47, 0x33, 0x99, 0xF8, 0x8F, 0x59, 0x28, 0xDC, 0x91, 0x90,
    0xF7, 0x69, 0xE5, 0xDB, 0x9B, 0xD7, 0x17, 0x4D, 0x29, 0x5F, 0x5F, 0xE6, 0x6F, 0x65, 0x4B, 0x67, 0x7C, 0xB8, 0x67, 0x5A, 0x53, 0xAB,
    0x4C, 0x2A, 0x59, 0x48, 0xB2, 0x7A, 0x73, 0xB9, 0x96, 0x4F, 0xAF, 0xE6, 0x9C, 0x90, 0x79, 0x7E, 0x52, 0x85, 0xBB, 0x21, 0x78, 0xF2,
    0x28, 0x5C, 0xA0, 0x27, 0x53, 0x7E, 0x7F, 0x0F, 0xE1, 0x1C, 0xA6, 0xED, 0x74, 0xCE, 0xF0, 0x57, 0x67, 0x31, 0xCD, 0xF2, 0xE7, 0xED,
    0x48, 0xE3, 0xF3, 0xF7, 0xBA, 0x95, 0xE4, 0x46, 0xD2, 0xD9, 0xA4, 0x17, 0xC1, 0xF4, 0x8A, 0xA7, 0x04, 0xA4, 0x77, 0xBE, 0xE5, 0xE9,
    0x45, 0x09, 0x27, 0x2E, 0x23, 0xC5, 0x93, 0x5A, 0x26, 0x59, 0xEF, 0x7D, 0x8E, 0xD1, 0xB4, 0x77, 0x5E, 0x45, 0x2D, 0x8D, 0x68, 0xC1,
    0x6F, 0x62, 0xB8, 0xE2, 0x58, 0xA9, 0x96, 0x9E, 0xB5, 0xAE, 0x3A, 0xC4, 0x09, 0x3A, 0x38, 0xA6, 0xBB, 0x46, 0x87, 0x87, 0x7A, 0x71,
    0x87, 0x46, 0xAE, 0x7C, 0xE5, 0x77, 0x71, 0x9D, 0xCB, 0x3C, 0x85, 0x5A, 0x79, 0xB1, 0xD6, 0x6E, 0xED, 0xAF, 0xE8, 0x86, 0x3A, 0x51,
    0x0E, 0xFB, 0xEF, 0xCF, 0xAB, 0x39, 0xEB, 0xA8, 0x8E, 0x87, 0x4E, 0xF4, 0xA2, 0x63, 0x4B, 0x0F, 0x08, 0x74, 0x82, 0x9E, 0xB2, 0x97,
    0x08, 0xB5, 0x74, 0x0C, 0x62, 0xF9, 0x5D, 0x2F, 0xA3, 0xFA, 0xB7, 0x45, 0xD4, 0xD1, 0x33, 0xB4, 0x9E, 0xCC, 0x93, 0xB3, 0xA7, 0xC9,
    0xAF, 0xF3, 0x90, 0x56, 0xAC, 0x82, 0x8D, 0x55, 0x5D, 0x9E, 0x52, 0x14, 0xFD, 0xA0, 0x2A, 0xD1, 0xD1, 0x0A, 0x7E, 0xCA, 0x6D, 0xBD,
    0xAB, 0x6C, 0x7B, 0xFC, 0xB5, 0x1C, 0xBF, 0xBC, 0xEF, 0xE6, 0xF6, 0x2E, 0x89, 0x12, 0xA6, 0x52, 0x7B, 0x1E, 0x30, 0x56, 0xB4, 0x16,
    0xC6, 0x3B, 0x61, 0xFD, 0x81, 0xF1, 0xFF, 0x6E, 0xBE, 0x1E, 0x46, 0x2A, 0x6A, 0xF8, 0x49, 0xAF, 0x51, 0x38, 0xCE, 0xAF, 0x85, 0xF0,
    0xE3, 0x54, 0x94, 0xF9, 0x25, 0x89, 0xE3, 0x25, 0x0B, 0x47, 0x00, 0x45, 0x39, 0xFA, 0xA1, 0xF7, 0x48, 0xEB, 0x7B, 0x29, 0xB6, 0x5A,
    0xFA, 0xF1, 0x8A, 0x76, 0xF2, 0xD2, 0x7B, 0xB8, 0x3E, 0x2A, 0xC5, 0x54, 0x9A, 0x8F, 0x39, 0xB5, 0x24, 0x71, 0x6E, 0x95, 0x7F, 0xF7,
    0xD0, 0x77, 0x80, 0x87, 0x78, 0x6E, 0x38, 0xD5, 0xEA, 0xB4, 0xBF, 0x6D, 0xFA, 0x92, 0x7C, 0xA0, 0x37, 0x1B, 0xEE, 0x67, 0xD1, 0xF2,
    0x94, 0x26, 0x9E, 0xC8, 0x8F, 0x22, 0x27, 0xEA, 0xE4, 0xEA, 0x50, 0xFE, 0xFC, 0x66, 0x5C, 0xEB, 0x0B, 0xC9, 0xC9, 0xE4, 0x16, 0x40,
    0x92, 0xC2, 0x8B, 0x83, 0xD9, 0x45, 0x72, 0xFA, 0xA2, 0x1A, 0x9A, 0xD6, 0xF3, 0xB6, 0xBE, 0xC8, 0x43, 0x66, 0xAD, 0x23, 0x47, 0x33,
    0x41, 0x5C, 0x5F, 0xB3, 0xBA, 0x90, 0xF7, 0x83, 0x16, 0x72, 0xD0, 0x43, 0xE6, 0x7E, 0x8C, 0x1C, 0x0F, 0xFB, 0xFE, 0xE1, 0xAD, 0xC6,
    0x98, 0x22, 0xF5, 0x3C, 0xE8, 0x6D, 0xD9, 0x64, 0x61, 0xB5, 0xC8, 0xF5, 0x35, 0xB9, 0x77, 0xDD, 0x2D, 0xD7, 0x3E, 0x45, 0xC0, 0xAF,
    0xE7, 0x35, 0xE2, 0x67, 0xEB, 0x3C, 0xA6, 0x23, 0xFC, 0xE2, 0x84, 0x5B, 0xA8, 0x32, 0xFE, 0x2F, 0xEE, 0xE5, 0xFD, 0x3B, 0x59, 0x78,
    0xC1, 0x26, 0x56, 0x85, 0xDE, 0x61, 0x49, 0x3F, 0x59, 0xD8, 0x69, 0x4C, 0x32, 0x7B, 0xE7, 0xCE, 0x3E, 0xBF, 0xA2, 0x7B, 0x79, 0xDB,
    0x70, 0x6A, 0xB6, 0x53, 0x2B, 0xF5, 0x53, 0x4B, 0xFE, 0x7A, 0x31, 0x75, 0x8C, 0x20, 0x1F, 0x3A, 0xD9, 0xF7, 0x80, 0x07, 0x04, 0xF0,
    0xF9, 0x01, 0xF9, 0x5B, 0xA6, 0x56, 0x2A, 0x7F, 0xBC, 0xF8, 0xC6, 0x89, 0xB4, 0x93, 0xE3, 0xEA, 0x39, 0x8A, 0x78, 0xE1, 0x84, 0xA3,
    0x9C, 0x7C, 0xD5, 0x05, 0xF0, 0x36, 0xE2, 0x31, 0xD9, 0x9E, 0xB0, 0x52, 0x1E, 0x17, 0x88, 0xFA, 0x5A, 0xB4, 0xF8, 0xD2, 0x85, 0x6D,
    0xCF, 0x62, 0xF6, 0xF2, 0xAB, 0x9D, 0x23, 0x37, 0x5E, 0x59, 0xD3, 0x8E, 0x12, 0x75, 0x1A, 0x93, 0xE8, 0xDD, 0x5E, 0xAE, 0x26, 0x1C,
    0xA5, 0x1D, 0x2D, 0xC8, 0x41, 0xB2, 0x2A, 0xD9, 0x72, 0x9C, 0xB6, 0x41, 0x98, 0x6F, 0x0D, 0xE2, 0xEB, 0x2B, 0x51, 0x36, 0xDF, 0x19,
    0xB2, 0xCD, 0x83, 0xFE, 0x9D, 0x1E, 0x28, 0xD9, 0xA6, 0x24, 0xEF, 0xD3, 0xDC, 0x3F, 0xB8, 0xBC, 0x1C, 0x5B, 0xE7, 0xC7, 0x96, 0xF6,
    0xEB, 0x6A, 0xFD, 0xF1, 0x9B, 0xFB, 0xF2, 0xE3, 0x99, 0xAB, 0x3C, 0x2C, 0xEF, 0x59, 0x71, 0x2F, 0xC5, 0x06, 0xC5, 0xFB, 0x4A, 0xF2,
    0x77, 0x25, 0x95, 0xF9, 0xD8, 0xF5, 0x41, 0xEF, 0x30, 0x5D, 0x83, 0x50, 0x4B, 0xFC, 0x05, 0x6A, 0xF7, 0xC9, 0xD7, 0x42, 0x41, 0x63,
    0x31, 0x08, 0x7E, 0x13, 0xE4, 0xFA, 0xB7, 0xA3, 0x74, 0xE5, 0x7C, 0x4D, 0xBA, 0xDA, 0x96, 0x46, 0xD1, 0xE6, 0x18, 0x21, 0xBE, 0x37,
    0x15, 0xE5, 0x66, 0x79, 0x34, 0x89, 0x1E, 0x2F, 0x8C, 0xA2, 0x9E, 0x15, 0xAD, 0xF0, 0x46, 0x94, 0xA3, 0xF4, 0xCD, 0x7D, 0xF6, 0x63,
    0x0F, 0x97, 0x3C, 0xF6, 0x1B, 0x54, 0xDC, 0xDB, 0x54, 0xCF, 0xD3, 0xFC, 0xA5, 0x68, 0x94, 0x21, 0x7B, 0x2F, 0x60, 0x39, 0xC6, 0x27,
    0x5E, 0xD0, 0x34, 0x17, 0x90, 0x7B, 0x56, 0xFC, 0xC6, 0x61, 0x8C, 0x70, 0x96, 0xDC, 0xD9, 0xF9, 0x46, 0xAB, 0x68, 0x71, 0x99, 0x3C,
    0x82, 0xEB, 0xE5, 0x52, 0x4C, 0xF9, 0x71, 0x4C, 0x47, 0xDE, 0x6E, 0x31, 0xF7, 0x60, 0x6B, 0xF7, 0xCC, 0xEE, 0x08, 0x8F, 0x56, 0x7F,
    0x15, 0x7A, 0x51, 0x8E, 0x99, 0x87, 0x0E, 0x25, 0x3E, 0xDC, 0xAF, 0x77, 0xB8, 0x30, 0x9B, 0x25, 0x2B, 0xDD, 0x7F, 0x0B, 0xF2, 0x10,
    0x7D, 0x36, 0x27, 0x0B, 0x56, 0xDF, 0x78, 0x51, 0x42, 0x94, 0x78, 0xC4, 0x08, 0x36, 0xE9, 0x18, 0xD9, 0x3D, 0x4F, 0x7D, 0x10, 0x9F,
    0x8F, 0x75, 0x82, 0x75, 0x35, 0x46, 0xC5, 0x9E, 0xA7, 0xF5, 0x99, 0x4B, 0x3E, 0x46, 0x1A, 0xC5, 0xD9, 0x47, 0xF9, 0x5E, 0x76, 0x7D,
    0x10, 0xD7, 0xF7, 0x1D, 0x5F, 0xCF, 0x5A, 0xF3, 0x76, 0xCE, 0x3B, 0xA4, 0x7A, 0xFA, 0xD6, 0x79, 0xB4, 0xDF, 0x07, 0xA4, 0x72, 0xB9,
    0x4E, 0xDB, 0x5A, 0x53, 0x76, 0x1F, 0xED, 0x21, 0x2E, 0xD3, 0xA6, 0x6F, 0xB3, 0xCA, 0xD7, 0x4F, 0x80, 0x03, 0xF7, 0xBA, 0xB9, 0xE6,
    0xA8, 0xE4, 0xBF, 0x2A, 0xF7, 0xA0, 0x46, 0x36, 0xAF, 0x3A, 0x11, 0xE3, 0x2F, 0xCD, 0xD8, 0xA7, 0x14, 0x77, 0x3F, 0xB7, 0x53, 0x62,
    0x5C, 0x35, 0xBA, 0xA8, 0x4E, 0xF4, 0xA4, 0x10, 0xAD, 0xFA, 0x9E, 0x6C, 0x35, 0xF0, 0xF1, 0x16, 0xFB, 0x97, 0x52, 0x7F, 0xE5, 0xAF,
    0x2D, 0xEA, 0x04, 0xCB, 0x87, 0xD2, 0x4A, 0xBC, 0xDF, 0x28, 0x9E, 0x7F, 0xF3, 0xF8, 0xCA, 0xF9, 0x4F, 0x14, 0xAD, 0x6C, 0x09, 0x2A,
    0xEE, 0xBA, 0xF1, 0xBD, 0x3C, 0x57, 0xEE, 0xF9, 0x38, 0xCE, 0xCF, 0xF5, 0x7B, 0x51, 0x8E, 0xF1, 0x94, 0x76, 0x0D, 0x13, 0x54, 0xE8,
    0x1F, 0xD2, 0x79, 0x56, 0x7B, 0x7C, 0xF5, 0x42, 0xBE, 0x75, 0xA2, 0xDE, 0xCC, 0xAD, 0xDF, 0xD1, 0x56, 0xAF, 0x53, 0x73, 0xAB, 0x98,
    0x92, 0xB7, 0x10, 0xAF, 0xD1, 0x9C, 0x17, 0xA7, 0xAA, 0x66, 0x8F, 0x47, 0x27, 0xAC, 0xF8, 0xA4, 0x12, 0xA3, 0x27, 0x1E, 0xF5, 0x77,
    0xC5, 0xD3, 0x46, 0x4B, 0x73, 0x99, 0x39, 0x25, 0x25, 0xBE, 0xDC, 0xBB, 0xBB, 0x3B, 0x7C, 0x75, 0x49, 0xB4, 0xE4, 0x6D, 0x6D, 0xFE,
    0x63, 0x78, 0xFB, 0xF3, 0xD8, 0x92, 0xC4, 0xA8, 0xAB, 0x23, 0x89, 0xBE, 0x51, 0xE1, 0xB6, 0xAE, 0xC4, 0xC3, 0x3E, 0x9D, 0x78, 0x71,
    0x6C, 0x34, 0xCA, 0x7A, 0x01, 0xA9, 0x1E, 0xC3, 0xCF, 0x86, 0xF0, 0x14, 0xCA, 0xFD, 0x93, 0xFB, 0x4E, 0xC1, 0x97, 0x6D, 0x94, 0x7C,
    0xDD, 0x07, 0x04, 0x4B, 0x6D, 0x66, 0x9E, 0x52, 0xB9, 0x1E, 0xE2, 0x85, 0xF3, 0x97, 0x03, 0x55, 0x9C, 0x8B, 0xCA, 0x09, 0xC6, 0xB1,
    0x92, 0xA7, 0x52, 0x33, 0x56, 0x4A, 0xEF, 0xBD, 0x45, 0x0A, 0x23, 0x94, 0x5E, 0x61, 0x9D, 0xD6, 0x1C, 0xCC, 0xED, 0x40, 0x91, 0xE2,
    0x9C, 0x62, 0x12, 0xD6, 0x05, 0xD6, 0x27, 0x64, 0xE5, 0x79, 0xC5, 0xC1, 0x7F, 0x4D, 0x82, 0x75, 0x40, 0x3A, 0x0D, 0xA1, 0x74, 0xBE,
    0x45, 0xFF, 0xA0, 0x87, 0xE8, 0x57, 0x0D, 0x53, 0xA6, 0x12, 0xCB, 0xB3, 0x3C, 0xBF, 0x78, 0x41, 0xEB, 0x51, 0xE2, 0x21, 0x7F, 0xEE,
    0x42, 0xA2, 0xC5, 0xC3, 0x08, 0x51, 0x53, 0x96, 0xF5, 0xFF, 0x3E, 0x96, 0x9E, 0x03, 0x95, 0x52, 0xA8, 0x6D, 0x0F, 0x1E, 0xAA, 0xF1,
    0x04, 0x97, 0x35, 0x96, 0xD7, 0x8D, 0x65, 0x0A, 0x75, 0x75, 0xC3, 0x74, 0xFB, 0x28, 0xC5, 0xD3, 0x10, 0x4D, 0x63, 0xA5, 0x73, 0x98,
    0x51, 0x82, 0xCD, 0x41, 0x79, 0x6F, 0xDF, 0xF2, 0x1D, 0x41, 0x67, 0x75, 0x3D, 0x4E, 0x07, 0x47, 0x67, 0x63, 0xAB, 0x35, 0xC1, 0xFC,
    0x17, 0x79, 0xFD, 0xB9, 0x78, 0x1C, 0xD7, 0x9D, 0xAC, 0xD3, 0xA8, 0x6B, 0x0F, 0xC9, 0xCE, 0x2C, 0xAD, 0xE3, 0xE2, 0x05, 0xCF, 0x42,
    0x5A, 0xB2, 0x8F, 0xE2, 0x5A, 0xF9, 0x2C, 0xE9, 0xEB, 0x04, 0xCA, 0xD7, 0x86, 0x76, 0x82, 0xB0, 0x63, 0x16, 0xDF, 0x3A, 0xBA, 0xF2,
    0xDA, 0x88, 0x70, 0x61, 0x3E, 0xB0, 0xC7, 0x87, 0xAD, 0xE6, 0x94, 0xCF, 0xD9, 0x84, 0x4C, 0x90, 0x64, 0x0B, 0xE3, 0xAB, 0x91, 0x2D,
    0x4B, 0x7E, 0x06, 0x61, 0xED, 0xCB, 0x3D, 0x94, 0xAA, 0x7D, 0x47, 0xAE, 0x72, 0x82, 0x87, 0xCD, 0xF7, 0x43, 0xE9, 0x2C, 0xC9, 0xBE,
    0x91, 0xB6, 0xD1, 0xA9, 0xBC, 0x49, 0x2F, 0xF8, 0x45, 0x29, 0xE8, 0xCD, 0x33, 0x1F, 0xF2, 0xD0, 0x3C, 0x64, 0x23, 0x3F, 0xB6, 0xA8,
    0x0E, 0x12, 0xD7, 0xE6, 0x09, 0xE2, 0x39, 0x77, 0xDC, 0x3F, 0x72, 0x4E, 0xA6, 0x53, 0xC4, 0x57, 0x1F, 0x95, 0xCE, 0x5D, 0xB5, 0x3C,
    0x24, 0xDD, 0x17, 0xC2, 0xF8, 0xCE, 0xD4, 0x49, 0x8A, 0xB8, 0x62, 0xD1, 0x8B, 0xEF, 0x8C, 0xC9, 0xBE, 0xC7, 0xF9, 0xB0, 0x07, 0xF1,
    0x81, 0x8A, 0x69, 0x9C, 0xE3, 0xAB, 0x15, 0x75, 0x2D, 0x79, 0xC9, 0xAC, 0x7F, 0x58, 0xD2, 0xDD, 0x69, 0x7C, 0x67, 0xEB, 0x56, 0x2B,
    0xDA, 0xA0, 0xD4, 0xEE, 0x28, 0x39, 0xDE, 0xDF, 0xF8, 0xB9, 0x23, 0x7B, 0x32, 0xE1, 0x0A, 0x2F, 0xE9, 0xE4, 0xBD, 0x7D, 0x6B, 0xD0,
    0x10, 0x3B, 0xE7, 0xF6, 0xED, 0xD1, 0x8C, 0x11, 0xDA, 0x9B, 0xFB, 0x17, 0x51, 0xBA, 0x1F, 0xA8, 0x9D, 0xC4, 0xDB, 0x1E, 0x63, 0x9B,
    0xEF, 0x3A, 0xDB, 0xE3, 0x61, 0x12, 0x76, 0x4B, 0xC3, 0xAD, 0x5E, 0xDE, 0xB2, 0x7C, 0xA7, 0xCD, 0x9E, 0x5F, 0x18, 0xCB, 0x7C, 0x5C,
    0x9E, 0xC4, 0x6D, 0x30, 0x48, 0x59, 0x59, 0x16, 0xA4, 0x98, 0x7A, 0x1B, 0x2F, 0x80, 0x59, 0xE6, 0xC3, 0x9E, 0xC7, 0x2D, 0xCB, 0xFE,
    0x97, 0xF6, 0x88, 0xA4, 0x57, 0x50, 0xEA, 0x6A, 0xF2, 0x92, 0xD8, 0x7A, 0x6E, 0x93, 0xF7, 0x20, 0xF9, 0xBB, 0x17, 0xF5, 0x8F, 0x48,
    0xE7, 0x2B, 0x31, 0xBE, 0xFC, 0xF9, 0x4D, 0xE4, 0x11, 0xA5, 0xCA, 0x5A, 0xA8, 0x9C, 0xD7, 0x05, 0xAD, 0x9A, 0x66, 0xBC, 0xAA, 0x77,
    0x24, 0x73, 0x1F, 0xE5, 0xB2, 0xC2, 0x53, 0xE9, 0x84, 0xF1, 0x9B, 0xAF, 0x37, 0xD4, 0xE5, 0x7B, 0x81, 0x8D, 0x37, 0x0F, 0x9D, 0x7B,
    0x87, 0xC3, 0x9C, 0xA6, 0x41, 0xB6, 0xB7, 0xA8, 0xA3, 0x63, 0x6E, 0xEF, 0x95, 0xFC, 0x07, 0xE9, 0xC4, 0x3B, 0x5E, 0x06, 0x17, 0xDE,
    0x5B, 0x41, 0x1E, 0x4A, 0x2F, 0x99, 0xBB, 0x4A, 0xDF, 0xA4, 0x70, 0xBB, 0x7C, 0xE6, 0x63, 0xDC, 0x0E, 0x63, 0x12, 0x76, 0x45, 0xD5,
    0xB5, 0x99, 0x49, 0xF4, 0xF8, 0x2C, 0x7B, 0x3F, 0xA2, 0xC8, 0x43, 0x55, 0xFE, 0x92, 0x84, 0x11, 0x4E, 0x7E, 0x07, 0xA2, 0xE5, 0x31,
    0xEC, 0x7F, 0x89, 0xAD, 0xF9, 0x53, 0xF2, 0x3F, 0x82, 0x3C, 0x92, 0x5B, 0xDF, 0x6F, 0x76, 0xBD, 0x3E, 0x53, 0x84, 0x96, 0xA7, 0xFB,
    0x03, 0x32, 0xF7, 0x1F, 0x1E, 0x97, 0xEE, 0xC9, 0x5A, 0xA6, 0x51, 0x93, 0x77, 0x5C, 0x8B, 0x47, 0x0A, 0x52, 0x11, 0x2D, 0xEF, 0xE3,
    0xE0, 0x90, 0x46, 0x76, 0xFC, 0x37, 0xA7, 0x17, 0x27, 0x7A, 0xD5, 0x95, 0xF6, 0x69, 0xD4, 0xED, 0xEB, 0x3B, 0xC2, 0x83, 0x9F, 0x1E,
    0xE5, 0xF7, 0x10, 0xA4, 0x3D, 0x37, 0xA5, 0xF5, 0xA0, 0x63, 0xF4, 0xF9, 0x1B, 0x15, 0xCC, 0xEF, 0xA8, 0xF5, 0x0D, 0xD7, 0x21, 0x2E,
    0xD0, 0xB5, 0x5E, 0xF5, 0x5B, 0x9E, 0x3F, 0x73, 0x84, 0x5E, 0xAC, 0x95, 0xCD, 0x66, 0xB0, 0x9B, 0x68, 0x05, 0xBA, 0x54, 0x7F, 0xE6,
    0xB4, 0x86, 0xB8, 0x94, 0x2F, 0xEE, 0xE9, 0x30, 0x42, 0xF0, 0x81, 0x63, 0x90, 0xDD, 0x0D, 0x73, 0x0F, 0x5D, 0x5B, 0xE7, 0x65, 0xDC,
    0x41, 0x77, 0x88, 0x8B, 0x74, 0x75, 0xE2, 0x1D, 0x66, 0xB9, 0x99, 0xC7, 0x51, 0x7A, 0xFC, 0x26, 0x44, 0xAC, 0xEC, 0xBD, 0x19, 0xC7,
    0x68, 0x2A, 0x59, 0xE6, 0x5C, 0xA3, 0x17, 0xE8, 0x66, 0x7A, 0x43, 0xDC, 0x4C, 0x6F, 0x98, 0x8B, 0x32, 0x69, 0x49, 0x6F, 0xB8, 0x1B,
    0xF2, 0xE7, 0xAE, 0x31, 0x51, 0x27, 0x58, 0xD0, 0x8D, 0xB2, 0x67, 0x0A, 0x1D, 0xA1, 0xA7, 0x17, 0x56, 0xC3, 0x8E, 0xFB, 0xE1, 0x77,
    0x8C, 0x87, 0xBD, 0x13, 0xD3, 0x83, 0xDD, 0x4C, 0x33, 0xF0, 0x1A, 0xE4, 0x73, 0x88, 0x4B, 0x7D, 0xD1, 0x36, 0xCD, 0xA1, 0xD7, 0x20,
    0x9F, 0xC3, 0x5C, 0xA2, 0xC9, 0x67, 0x44, 0x95, 0xBE, 0x9C, 0x1C, 0xA2, 0xCB, 0x57, 0x63, 0xE1, 0xC2, 0x7A, 0x5A, 0x6B, 0xE3, 0xDD,
    0xB8, 0xC1, 0x2E, 0xE6, 0x3B, 0x5E, 0xD6, 0x7F, 0x83, 0xF3, 0xB4, 0x02, 0x5D, 0xCC, 0x57, 0xA2, 0xD9, 0xBB, 0xF1, 0xF6, 0x77, 0xA2,
    0x9C, 0xCF, 0xAF, 0x5A, 0xDF, 0xAB, 0x8E, 0xD1, 0x34, 0xB5, 0xBE, 0x46, 0xE9, 0x2E, 0x19, 0x90, 0xDE, 0xF7, 0x8E, 0x73, 0x53, 0x9B,
    0x73, 0xBD, 0x1A, 0xD7, 0x6A, 0x46, 0x15, 0xFE, 0x03, 0x1C, 0xA1, 0x6F, 0x12, 0xC6, 0x58, 0x9E, 0xDF, 0x38, 0x61, 0xEC, 0x96, 0xCE,
    0x2D, 0xBB, 0x27, 0xFF, 0x49, 0x82, 0x0D, 0xD4, 0xFC, 0xF5, 0x32, 0x77, 0xF6, 0x09, 0x6A, 0xE7, 0x94, 0x7B, 0xF3, 0xC4, 0x59, 0x9A,
    0xFC, 0xB5, 0x37, 0xA3, 0xEC, 0x7B, 0xAA, 0xCE, 0xD2, 0x36, 0x9A, 0xF5, 0x1A, 0xDB, 0x2F, 0x94, 0x0F, 0x76, 0x53, 0x39, 0x2C, 0x79,
    0x39, 0x57, 0x16, 0xB6, 0xB2, 0x8D, 0x10, 0xB4, 0x05, 0xE9, 0x2F, 0xA5, 0x73, 0x53, 0x0D, 0xA1, 0xDC, 0x06, 0x44, 0xE3, 0xCB, 0xDB,
    0xDD, 0xE8, 0xDB, 0x1D, 0x11, 0x62, 0x09, 0xD8, 0xA8, 0x2A, 0xEF, 0xF3, 0x47, 0xFE, 0x2D, 0x0F, 0x4A, 0x33, 0x5E, 0xD5, 0xB8, 0xAC,
    0x9E, 0x1E, 0xFF, 0x9B, 0xBF, 0xAC, 0xC7, 0xBD, 0xBE, 0xA8, 0xB1, 0x76, 0xA8, 0xA1, 0xCF, 0x57, 0x9B, 0xF6, 0xDB, 0x6A, 0xFC, 0x5C,
    0xA9, 0x6E, 0x31, 0xB6, 0x52, 0xDD, 0x9A, 0xBF, 0x6C, 0xA9, 0xDE, 0x87, 0x93, 0xFC, 0xDB, 0xE2, 0x89, 0xAD, 0xFB, 0x3F, 0x6A, 0xEE,
    0xF9, 0xCA, 0xDB, 0x26, 0xF4, 0xA2, 0x75, 0x80, 0xBF, 0x52, 0xA0, 0x6D, 0x1D, 0x3D, 0x0C, 0x42, 0x39, 0x8D, 0x2A, 0xFD, 0xCC, 0x84,
    0xCD, 0x93, 0xF6, 0x18, 0xF4, 0x2A, 0xEF, 0x76, 0xEB, 0xC5, 0x57, 0x24, 0xA2, 0x85, 0x1B, 0xFE, 0x52, 0x0B, 0xDA, 0x3B, 0xED, 0x60,
    0xD9, 0x2F, 0xAB, 0x81, 0x5F, 0x3F, 0xC1, 0x37, 0x84, 0x35, 0x15, 0x4A, 0x43, 0x29, 0x0F, 0xFC, 0x55, 0x86, 0x04, 0xB1, 0xB4, 0x5A,
    0xA2, 0x9D, 0xDA, 0x46, 0xED, 0xC9, 0x46, 0x58, 0x98, 0x87, 0xF0, 0x9E, 0x99, 0x7D, 0x8A, 0xB6, 0x3C, 0xF9, 0xDB, 0x6F, 0x13, 0x03,
    0xB9, 0x53, 0xC9, 0xBF, 0xF9, 0x8B, 0xC3, 0x7A, 0x85, 0xBB, 0x6D, 0x0D, 0x61, 0xDC, 0xD6, 0x65, 0x9E, 0xC2, 0x51, 0x7E, 0x92, 0x77,
    0x35, 0xBD, 0x20, 0x69, 0x5A, 0x3B, 0x2F, 0x2E, 0x5A, 0xF9, 0xBF, 0x09, 0xA7, 0x7B, 0x3E, 0x98, 0x7A, 0x90, 0xE8, 0x4F, 0xC8, 0x59,
    0xDE, 0xF6, 0x66, 0x19, 0x89, 0x9F, 0x6B, 0x74, 0xAD, 0x75, 0x31, 0x65, 0xBA, 0x89, 0xE4, 0x1C, 0xBE, 0xF9, 0x0B, 0x08, 0x72, 0x3B,
    0x12, 0x19, 0x11, 0xBC, 0x6D, 0xF0, 0x64, 0x8D, 0x9A, 0xF7, 0xEC, 0x2D, 0xF9, 0x71, 0x5F, 0xC1, 0x51, 0x2E, 0xF4, 0x77, 0x73, 0x7A,
    0xD2, 0xB7, 0xB2, 0x85, 0x73, 0x7C, 0xA4, 0xF4, 0x36, 0x05, 0x4D, 0xA1, 0xE6, 0x7C, 0x90, 0x25, 0x4F, 0xF3, 0x1A, 0x90, 0xEB, 0xE7,
    0xA5, 0x91, 0x28, 0xCF, 0x89, 0x82, 0x67, 0x8F, 0x54, 0x95, 0xF2, 0x6C, 0x7E, 0xFA, 0x00, 0x7D, 0xCE, 0xD8, 0xBF, 0x07, 0x64, 0xD9,
    0x97, 0x86, 0x46, 0x49, 0x7D, 0x9A, 0x53, 0xB3, 0x4C, 0xEB, 0x98, 0x8F, 0x32, 0x83, 0xF8, 0x4A, 0x3C, 0x0F, 0x6D, 0x9F, 0x82, 0x36,
    0xCF, 0x41, 0x49, 0x94, 0x87, 0xF8, 0x8E, 0x9B, 0x79, 0x0A, 0xF9, 0xBA, 0x36, 0xE7, 0x13, 0x25, 0x78, 0x36, 0xB0, 0xDF, 0xAA, 0x5D,
    0xA2, 0xF9, 0xB8, 0x4D, 0x63, 0x3B, 0x42, 0x9F, 0xAF, 0x3D, 0xEC, 0xD3, 0x4F, 0x35, 0xA3, 0xCF, 0x63, 0xAB, 0xA3, 0x6F, 0xB2, 0x53,
    0x47, 0xE6, 0x12, 0x52, 0x23, 0xD2, 0x37, 0x39, 0x58, 0x3F, 0x91, 0xE2, 0x8B, 0xA3, 0xA8, 0x23, 0x87, 0xCB, 0xCE, 0x6F, 0xC1, 0x31,
    0x5C, 0xF6, 0x6D, 0xA5, 0x56, 0xC3, 0xCF, 0x24, 0xCC, 0xA5, 0x6A, 0xB9, 0x69, 0x34, 0xC5, 0x31, 0xDC, 0xF6, 0x6F, 0x9D, 0x5A, 0x59,
    0xCE, 0xA2, 0x44, 0x4B, 0x34, 0x3B, 0xD7, 0xCE, 0xCF, 0xBC, 0xC8, 0xEF, 0x93, 0xFA, 0xC5, 0x4A, 0xFE, 0xB3, 0x68, 0x0A, 0x65, 0x3E,
    0xFC, 0xCD, 0x84, 0x18, 0xE1, 0x84, 0x84, 0x1A, 0x3D, 0x24, 0x23, 0x56, 0x92, 0x05, 0x4C, 0xA9, 0x54, 0x77, 0xE8, 0xA1, 0x34, 0x45,
    0xD8, 0xD3, 0x8C, 0x56, 0xE8, 0xC3, 0x8E, 0xED, 0x5B, 0x2A, 0xBD, 0xB6, 0x12, 0xA9, 0x48, 0x5F, 0xFE, 0xDE, 0xAE, 0x63, 0xF4, 0x03,
    0xDD, 0x4E, 0x5F, 0xF2, 0x69, 0xA2, 0xFC, 0x0A, 0xCF, 0xB5, 0xE1, 0xE3, 0xE8, 0x3B, 0x35, 0x96, 0x7C, 0x8C, 0x76, 0xFD, 0x87, 0xDA,
    0x2B, 0x47, 0x43, 0x3C, 0xEF, 0x37, 0xBA, 0xD6, 0x11, 0x5A, 0x4A, 0xAB, 0x46, 0x9E, 0x2D, 0x79, 0x6B, 0x45, 0xDB, 0x52, 0x92, 0x58,
    0x56, 0xFB, 0x1E, 0x6E, 0x2C, 0xED, 0xF4, 0xFA, 0xF9, 0x7C, 0xEE, 0x90, 0xA7, 0xA0, 0xD6, 0x47, 0x9B, 0x41, 0xE8, 0x63, 0xA6, 0xD6,
    0x5B, 0xAD, 0x3C, 0xA7, 0x5A, 0x31, 0xBD, 0xD2, 0xDD, 0xE3, 0x9C, 0x4D, 0xF2, 0x75, 0x9E, 0xD8, 0xEA, 0x5B, 0x83, 0xDF, 0xD2, 0x0C,
    0x17, 0xF7, 0xC7, 0xA4, 0xD7, 0x07, 0x95, 0x4E, 0x8E, 0x87, 0x2E, 0x90, 0xC6, 0x46, 0x6B, 0x4A, 0x4A, 0xFD, 0x5B, 0x2F, 0xE8, 0x1C,
    0x96, 0x3E, 0xB8, 0xA4, 0x5B, 0x58, 0x49, 0x8A, 0x7E, 0xBA, 0x6B, 0x16, 0xF0, 0xFB, 0xE8, 0x9C, 0x92, 0x41, 0xBC, 0x57, 0x29, 0x8D,
    0x19, 0xCA, 0xF5, 0xAA, 0x17, 0xCF, 0xB5, 0x18, 0x15, 0x7C, 0x3D, 0x49, 0x7C, 0xEC, 0xD1, 0x31, 0x99, 0xBD, 0x9D, 0xA6, 0xE4, 0xBD,
    0x66, 0xB0, 0x03, 0xFE, 0x37, 0x6C, 0xD3, 0x66, 0xEB, 0xBF, 0xF9, 0xA2, 0xFD, 0xD3, 0x79, 0x1F, 0x8E, 0xB6, 0x69, 0x5B, 0x7B, 0xFA,
    0x70, 0x3E, 0xBF, 0x96, 0x1E, 0xD1, 0xD5, 0x7B, 0xD1, 0x96, 0x1F, 0xB7, 0xE5, 0x78, 0xA8, 0xB9, 0x2B, 0xE5, 0x0A, 0x7D, 0xDB, 0x96,
    0xEC, 0xA1, 0x6E, 0xA5, 0xAF, 0xD6, 0x17, 0xA5, 0x2B, 0x7C, 0x2C, 0x6D, 0xFD, 0x4A, 0x76, 0x4E, 0x47, 0x78, 0x59, 0x9E, 0x18, 0xA0,
    0x36, 0x05, 0x6D, 0x6B, 0xD9, 0x92, 0x85, 0x73, 0x69, 0x6A, 0x3C, 0x28, 0xC8, 0xDF, 0xA5, 0x92, 0xE7, 0x8D, 0xB7, 0xE8, 0x9C, 0xB5,
    0xE1, 0xCA, 0xD1, 0xB7, 0x75, 0x52, 0xC1, 0x59, 0x7B, 0xA2, 0x3C, 0x1F, 0xB9, 0x13, 0x0B, 0xAE, 0xC8, 0x85, 0x25, 0x1F, 0xA5, 0xF3,
    0xBF, 0xAE, 0x94, 0x41, 0x6F, 0x71, 0x02, 0x21, 0xD0, 0x8D, 0xB4, 0x95, 0xEE, 0x5B, 0x38, 0x5F, 0x27, 0xB1, 0x2A, 0xBD, 0xB9, 0x3B,
    0x43, 0x3B, 0x5E, 0xD0, 0x9D, 0xAE, 0x8D, 0xCC, 0xE0, 0x48, 0x85, 0x63, 0x8A, 0x64, 0x2B, 0x73, 0x76, 0x3F, 0x40, 0x89, 0x1F, 0xBD,
    0x61, 0xA2, 0x6C, 0x97, 0x75, 0x9E, 0x97, 0xDC, 0xA9, 0x11, 0x77, 0x95, 0xC7, 0xF2, 0x04, 0x85, 0xAD, 0x1D, 0x83, 0x6B, 0xC5, 0xEB,
    0x5A, 0xD4, 0x19, 0xDE, 0x39, 0x8D, 0x77, 0xE3, 0xFC, 0xE8, 0xF8, 0x09, 0x11, 0xE7, 0x69, 0x27, 0xAA, 0xD0, 0x09, 0x9D, 0xA7, 0xEF,
    0xEC, 0x89, 0x05, 0xD7, 0x78, 0xAA, 0xF5, 0xF9, 0xE6, 0x3C, 0x0F, 0xB9, 0x1D, 0x78, 0x77, 0xCD, 0x83, 0x74, 0x27, 0x56, 0xF9, 0x6D,
    0x4C, 0xD7, 0xF8, 0x70, 0xAF, 0xD3, 0x5A, 0x21, 0x86, 0xF1, 0x9A, 0xF2, 0x31, 0xDF, 0x09, 0xBE, 0x16, 0x7C, 0xA4, 0xBF, 0xE4, 0xCE,
    0x31, 0xBB, 0x6B, 0x8C, 0x31, 0xDF, 0xBD, 0x55, 0x1E, 0xCD, 0xDC, 0xC7, 0xCB, 0xB5, 0x3D, 0x74, 0xF5, 0x7C, 0xAE, 0x55, 0x9D, 0xA1,
    0x47, 0x6E, 0x57, 0xF7, 0xD3, 0x95, 0x79, 0xF1, 0xBD, 0x63, 0x57, 0xDF, 0xB4, 0x91, 0xE7, 0xC3, 0x5F, 0x91, 0xA7, 0xFB, 0x23, 0xD7,
    0x46, 0x06, 0x2C, 0xF9, 0xA8, 0x2D, 0x95, 0x6D, 0x5E, 0x46, 0xB1, 0x27, 0x72, 0xBF, 0x5E, 0xE6, 0x5E, 0xCA, 0x6D, 0xFB, 0xD9, 0xB3,
    0xD4, 0xA5, 0xBC, 0xD2, 0xB8, 0x0D, 0x92, 0x52, 0x92, 0xB7, 0x51, 0x18, 0x45, 0xBD, 0x9E, 0xF3, 0x54, 0x7B, 0xF7, 0x44, 0xDF, 0xCA,
    0x07, 0x53, 0x2B, 0xF1, 0x89, 0x16, 0xC6, 0x1A, 0x3E, 0x82, 0xC6, 0x08, 0xE3, 0x5B, 0x94, 0x22, 0x9F, 0x9A, 0x34, 0x7E, 0xBF, 0x97,
    0xA6, 0xA6, 0x69, 0x95, 0x79, 0xF2, 0x31, 0xC7, 0xD2, 0xF3, 0x8E, 0x56, 0x9C, 0x8F, 0x12, 0x5A, 0xDF, 0x81, 0x97, 0xF1, 0xFF, 0xB8,
    0x94, 0xDB, 0x8F, 0xCD, 0xA9, 0x29, 0xD9, 0x5E, 0xAC, 0xC7, 0xBB, 0xF0, 0x56, 0x8F, 0xC6, 0x31, 0x2A, 0x6E, 0xFF, 0x6A, 0x34, 0x67,
    0x96, 0x72, 0xBB, 0x93, 0xAD, 0x74, 0x6A, 0xCB, 0x8D, 0xBC, 0xB9, 0xAF, 0x8D, 0x08, 0x61, 0x8D, 0xCA, 0xCF, 0xDA, 0x2B, 0xE9, 0xFC,
    0xD3, 0x96, 0xF1, 0xBA, 0xB7, 0x97, 0xD6, 0xD9, 0x3C, 0x2C, 0x16, 0x6C, 0x18, 0xEA, 0xFC, 0x60, 0xD4, 0x2C, 0xE3, 0xBE, 0xF2, 0xA4,
    0xB4, 0xD2, 0xAB, 0x01, 0x91, 0xAA, 0x7D, 0xE5, 0x59, 0xE7, 0x83, 0x5B, 0xAC, 0x68, 0x6E, 0xEC, 0xF7, 0xA7, 0x99, 0xCB, 0xA5, 0xFB,
    0x3B, 0xE6, 0x69, 0x9C, 0xE1, 0x69, 0x6A, 0x5D, 0xDF, 0x0E, 0x6C, 0xB5, 0x1F, 0xAA, 0x79, 0xAB, 0xAF, 0x76, 0x39, 0xB7, 0xCD, 0xE1,
    0x7B, 0x01, 0x9C, 0x9A, 0x3A, 0x5F, 0xA7, 0xB6, 0xF2, 0x12, 0x2D, 0x8C, 0x6A, 0x7A, 0xF1, 0xA4, 0x87, 0xD2, 0x79, 0xB5, 0xD0, 0x74,
    0x2E, 0x87, 0xB6, 0xD2, 0x39, 0x5E, 0x0F, 0x31, 0xB2, 0x77, 0x42, 0x2A, 0xD3, 0xA5, 0x3B, 0x5E, 0x31, 0xAD, 0x6F, 0x15, 0x38, 0xCE,
    0x23, 0x4E, 0xE8, 0xD5, 0x11, 0x36, 0x6E, 0x21, 0x39, 0xF6, 0xD6, 0x99, 0x2D, 0xDA, 0xFC, 0xD6, 0x6C, 0x92, 0x1D, 0xBF, 0xD0, 0xF6,
    0x6A, 0x31, 0x7F, 0x05, 0x7D, 0x13, 0x8E, 0x52, 0x71, 0xA6, 0xFD, 0x68, 0x1E, 0xEC, 0x97, 0xCD, 0x77, 0xA5, 0x54, 0x97, 0xD6, 0xDC,
    0x1C, 0xE1, 0x95, 0x28, 0xAC, 0xDB, 0x24, 0x1B, 0x57, 0xB8, 0xA8, 0x2F, 0x18, 0x5A, 0x7B, 0x83, 0xDA, 0xBE, 0xEC, 0x4C, 0x5D, 0x73,
    0x79, 0x97, 0x2F, 0x69, 0xCB, 0x4A, 0x3E, 0x3E, 0x9B, 0xC7, 0x77, 0xBC, 0x5E, 0xA3, 0x44, 0x2D, 0x48, 0x2B, 0xEC, 0x77, 0x47, 0x8B,
    0x2F, 0xA5, 0x70, 0xEF, 0x81, 0x0B, 0x5C, 0x98, 0xD3, 0x6D, 0xF3, 0xE1, 0xE7, 0x77, 0xE2, 0x55, 0x9D, 0x74, 0x50, 0x4F, 0x3B, 0xDA,
    0xEA, 0x05, 0x0C, 0xF3, 0xBA, 0xEA, 0x97, 0x21, 0xDD, 0x83, 0x8D, 0xB1, 0xDA, 0x71, 0x75, 0x8C, 0x47, 0x8A, 0xD5, 0x1B, 0xCE, 0x96,
    0x7B, 0x44, 0x39, 0x66, 0xBC, 0x78, 0x7C, 0x47, 0x79, 0x2D, 0x10, 0xDF, 0xF5, 0x8D, 0x16, 0xE5, 0x50, 0xAE, 0xAE, 0x3C, 0x57, 0xF3,
    0xB1, 0xDA, 0x32, 0x8D, 0xA3, 0x3C, 0xD9, 0xB8, 0x16, 0x69, 0xE6, 0x37, 0x52, 0x66, 0xFF, 0x7F, 0xB5, 0xE4, 0xEB, 0x22, 0x56, 0x38,
    0xDB, 0x29, 0xA5, 0x70, 0x94, 0xA7, 0xE5, 0xC9, 0x39, 0x25, 0xED, 0xA0, 0x69, 0x35, 0x9F, 0x13, 0x6C, 0xA7, 0x73, 0x5C, 0xF6, 0x8D,
    0xC2, 0xC9, 0x38, 0x99, 0xF3, 0x6F, 0x6B, 0xB8, 0x3F, 0x1A, 0x1E, 0xCF, 0x19, 0xFA, 0x06, 0x8B, 0x13, 0x01, 0xE6, 0x72, 0x59, 0xBE,
    0x46, 0xD2, 0x27, 0x0D, 0x56, 0x5E, 0xC3, 0xD5, 0xF2, 0xC0, 0x17, 0x58, 0xD5, 0x6B, 0x39, 0x41, 0x6B, 0xB9, 0x2F, 0x5C, 0xFB, 0x69,
    0x1D, 0x2F, 0x6B, 0x72, 0xAB, 0x0F, 0xD4, 0x48, 0xE1, 0x3E, 0xB4, 0x9C, 0xCC, 0x96, 0xAE, 0xE5, 0xF2, 0x63, 0x99, 0xC6, 0xD1, 0xB2,
    0xDB, 0xE3, 0x19, 0x28, 0xC3, 0xD3, 0x19, 0xDA, 0x5A, 0x85, 0x39, 0x27, 0x33, 0xD3, 0xBA, 0x3C, 0x5A, 0x27, 0xDA, 0x52, 0x5A, 0x29,
    0x46, 0xAA, 0xB8, 0x33, 0xD7, 0x92, 0x69, 0x7E, 0x2E, 0x4F, 0x4A, 0xA3, 0xCC, 0x33, 0x41, 0xDC, 0x37, 0x31, 0x9A, 0x9D, 0x00, 0xB4,
    0x6F, 0xB1, 0x1A, 0x66, 0xC6, 0xD7, 0xF4, 0x0C, 0x3F, 0xA3, 0x69, 0x4E, 0x29, 0x41, 0xD4, 0x4C, 0xD5, 0xBE, 0x39, 0x63, 0x99, 0x0F,
    0x69, 0xCF, 0x3C, 0x5E, 0x08, 0xA3, 0x5B, 0x6F, 0x5A, 0xDB, 0xCE, 0x91, 0xE5, 0x98, 0xEB, 0xF5, 0x2C, 0xD7, 0x97, 0xCD, 0xA9, 0x4A,
    0x34, 0x99, 0xC6, 0x18, 0xA8, 0x22, 0x3F, 0x06, 0x71, 0x7E, 0x92, 0x4E, 0x95, 0x25, 0x29, 0xFA, 0xA6, 0x48, 0x7F, 0x96, 0xF7, 0x23,
    0xEB, 0xD4, 0x49, 0x2A, 0xFD, 0x01, 0x18, 0x45, 0xFB, 0xB0, 0x64, 0x53, 0x8F, 0x14, 0xFD, 0x11, 0xC7, 0xB7, 0xFA, 0x56, 0x36, 0x5F,
    0x0F, 0x2B, 0xFB, 0x69, 0xF0, 0x5D, 0xC7, 0xF5, 0x56, 0x69, 0xBD, 0xCE, 0x53, 0xA8, 0x95, 0x47, 0x9A, 0x17, 0xF5, 0x6F, 0x17, 0x67,
    0xAE, 0xE3, 0xE3, 0xB2, 0x65, 0x0A, 0xF5, 0xE3, 0xB2, 0x2D, 0xBE, 0xEA, 0xCB, 0xEA, 0x0A, 0xDD, 0x40, 0xB7, 0xD1, 0xC5, 0xD1, 0x54,
    0xF6, 0xFD, 0xAF, 0x2C, 0xA9, 0xDF, 0x9A, 0x1C, 0x38, 0xFF, 0x67, 0xC9, 0x33, 0xC5, 0xAE, 0xCD, 0xDF, 0x72, 0x9C, 0xF0, 0x5F, 0xCF,
    0xCB, 0x62, 0x9E, 0x42, 0xAD, 0x0E, 0x64, 0xCD, 0x93, 0xAF, 0xE5, 0xE4, 0xEF, 0x3F, 0xE4, 0xAE, 0xE7, 0xF2, 0x60, 0x99, 0xC2, 0x39,
    0x79, 0xA0, 0xF6, 0x33, 0xFB, 0x7B, 0xF3, 0xDE, 0x1B, 0xE8, 0xFB, 0xD9, 0x46, 0x15, 0xE7, 0x54, 0xAC, 0xF9, 0x98, 0xEC, 0x9E, 0xE1,
    0x1C, 0x6C, 0xB3, 0x0D, 0xED, 0xD3, 0xE5, 0x27, 0xEB, 0xA5, 0xF1, 0x03, 0xEF, 0xBF, 0x60, 0xDE, 0xA4, 0x1D, 0x73, 0xB9, 0x3B, 0x31,
    0x75, 0x1B, 0xD0, 0xE7, 0x0A, 0xA5, 0xA8, 0x5C, 0x2E, 0x73, 0xFE, 0xDC, 0x8A, 0x62, 0xBF, 0x3C, 0x12, 0x1F, 0xB5, 0xF4, 0x78, 0x8B,
    0xC6, 0x2A, 0xDE, 0xFA, 0x52, 0xA2, 0x8B, 0x5E, 0xD5, 0xC2, 0x85, 0x3A, 0x52, 0xB2, 0xCD, 0x34, 0x6D, 0xE4, 0xBE, 0x5F, 0x30, 0xB6,
    0xB2, 0x2C, 0x21, 0x0F, 0xAE, 0xE3, 0xA4, 0x10, 0xCB, 0xBC, 0xA9, 0xD5, 0x27, 0xB4, 0xB4, 0xCF, 0xE1, 0xFC, 0x7A, 0x07, 0xF9, 0x70,
    0x5F, 0xFB, 0x91, 0xC2, 0xF9, 0x4E, 0xF4, 0x93, 0x2F, 0x6B, 0x8B, 0xCD, 0x96, 0xEC, 0x2D, 0xE6, 0x29, 0x95, 0xDA, 0x59, 0x8E, 0xA7,
    0x9A, 0xB1, 0x41, 0xE2, 0xEB, 0x0C, 0x7D, 0xBB, 0x76, 0x72, 0x17, 0x68, 0xAA, 0xB3, 0xFA, 0x3B, 0xCE, 0x83, 0x9F, 0x80, 0x96, 0xEF,
    0xD3, 0x21, 0xCF, 0xD3, 0x36, 0xC0, 0x14, 0xEA, 0xDB, 0xC0, 0xDA, 0x97, 0x90, 0xAC, 0x2D, 0xB9, 0x4A, 0xEE, 0x2E, 0x10, 0xA5, 0xCB,
    0x57, 0x92, 0xE1, 0x82, 0x2D, 0xC3, 0x3E, 0x45, 0xEF, 0x4D, 0x74, 0xDD, 0xC9, 0x63, 0xAB, 0xCF, 0x7B, 0xB4, 0x68, 0x39, 0xE2, 0x6F,
    0x74, 0x47, 0xA9, 0x38, 0x5B, 0x9A, 0xB6, 0x89, 0xBF, 0xF7, 0x67, 0x2F, 0xA5, 0xB1, 0xF5, 0x94, 0x5C, 0xBC, 0x43, 0xF9, 0x48, 0x6D,
    0x3D, 0x27, 0x68, 0x74, 0xC8, 0xD6, 0xE4, 0x9D, 0x23, 0xD9, 0xAB, 0x25, 0x6A, 0xEA, 0xEC, 0xD5, 0xC8, 0x5B, 0xBA, 0xC9, 0xC0, 0xCF,
    0xB1, 0x45, 0x0A, 0x7E, 0x8B, 0xD5, 0xD9, 0xEB, 0x33, 0x81, 0xF7, 0x68, 0x1B, 0xFE, 0xE2, 0x24, 0x8A, 0xBC, 0x54, 0x5A, 0xE2, 0x23,
    0x96, 0x4B, 0x99, 0xCE, 0xCC, 0x92, 0xAB, 0x26, 0x8F, 0x0B, 0x00, 0xE1, 0x6B, 0x5E, 0xBA, 0x1F, 0xA0, 0x6C, 0x55, 0x57, 0x3B, 0x76,
    0x25, 0x88, 0xBE, 0x2B, 0x95, 0xED, 0xE4, 0x69, 0x2F, 0xA0, 0xFF, 0x1D, 0x4C, 0xE1, 0x48, 0x59, 0xF8, 0x0D, 0x0C, 0xBD, 0xB8, 0x27,
    0x2B, 0x7B, 0xFF, 0xF1, 0x05, 0x7A, 0x5F, 0x44, 0x4A, 0xE1, 0x08, 0x2F, 0xF6, 0x77, 0x94, 0x60, 0xA7, 0x48, 0x56, 0x18, 0x5B, 0xA6,
    0x6D, 0x46, 0x39, 0xC2, 0x14, 0x8E, 0xF2, 0x42, 0x09, 0xA4, 0x7A, 0xA6, 0xE5, 0xBA, 0x45, 0x92, 0x59, 0x67, 0x69, 0xDA, 0xF2, 0x83,
    0xE1, 0x18, 0x4D, 0xAD, 0x70, 0x3A, 0xD7, 0x72, 0x95, 0x63, 0x79, 0x7E, 0xCB, 0x74, 0x5A, 0xE3, 0x12, 0xCD, 0x40, 0x1B, 0x73, 0x8F,
    0x5A, 0x9A, 0xD2, 0xEB, 0x14, 0xD2, 0x37, 0xEF, 0x39, 0x32, 0x3E, 0x6A, 0x55, 0x8E, 0xAB, 0x96, 0x74, 0x69, 0x7F, 0x92, 0xB3, 0x25,
    0xBA, 0x97, 0x7E, 0xA0, 0xC3, 0xF9, 0x67, 0xA3, 0xAD, 0x51, 0xF4, 0xD5, 0x14, 0x6D, 0xA5, 0xD5, 0xC8, 0xF8, 0xD5, 0xDD, 0xCA, 0xE5,
    0xC2, 0x3C, 0xBE, 0xB2, 0x5C, 0xCB, 0xF3, 0xB3, 0xE7, 0x2D, 0xCF, 0x9C, 0x77, 0xA1, 0x05, 0x6F, 0xF3, 0xD5, 0xA8, 0x7A, 0xDE, 0x46,
    0x95, 0x6F, 0x99, 0x77, 0xD9, 0xC6, 0xF7, 0x1D, 0x68, 0x7C, 0xB5, 0x6B, 0x0F, 0x7D, 0xAB, 0xB6, 0x6C, 0xAD, 0x35, 0x5B, 0xDD, 0xE3,
    0xD8, 0xC6, 0xF5, 0x51, 0x4C, 0xA5, 0x4C, 0xDF, 0xDC, 0xF3, 0x64, 0x9C, 0xB0, 0x17, 0xA6, 0x64, 0x67, 0x68, 0xD8, 0xC6, 0xE7, 0x76,
    0x1A, 0x5B, 0x69, 0x4E, 0x35, 0xE7, 0xC3, 0x4F, 0x6F, 0x19, 0xC5, 0xB7, 0xEB, 0xE4, 0xF4, 0xDC, 0x69, 0xDB, 0xB9, 0x1E, 0x64, 0x99,
    0xC2, 0x31, 0x7E, 0xC6, 0xD6, 0x3B, 0x06, 0xB2, 0xEF, 0x9F, 0x6E, 0x97, 0xF6, 0xB9, 0x69, 0xEA, 0xA4, 0xD6, 0xF3, 0x72, 0xAE, 0xF2,
    0xB4, 0x35, 0xEE, 0x48, 0x3C, 0xED, 0xD1, 0x4C, 0x15, 0xBE, 0x9D, 0xBB, 0x8F, 0x9E, 0x9D, 0x27, 0xD9, 0x8B, 0x53, 0x55, 0xCC, 0x4F,
    0x26, 0xD1, 0x56, 0xA6, 0xFE, 0xFE, 0x58, 0x53, 0x9E, 0x64, 0x97, 0x08, 0x17, 0x5F, 0x50, 0x57, 0x7B, 0x5F, 0x0D, 0xFD, 0x51, 0xF0,
    0xB9, 0x73, 0xB0, 0x0B, 0xFB, 0x2F, 0x96, 0xB4, 0x02, 0x5D, 0xA2, 0x65, 0x6C, 0xED, 0x6B, 0xFC, 0x14, 0x9B, 0xF9, 0xBA, 0x4C, 0xC6,
    0xFF, 0xDF, 0x0E, 0xE9, 0x6D, 0x34, 0x29, 0xA5, 0x72, 0x7D, 0x73, 0x5E, 0x3A, 0x41, 0x9E, 0x4D, 0x16, 0x7D, 0xDB, 0x72, 0x6E, 0x0E,
    0xDD, 0x29, 0xBD, 0xF5, 0x22, 0xC5, 0x56, 0xA6, 0xEF, 0xE8, 0x7D, 0xC0, 0xF2, 0x9D, 0x7C, 0x5C, 0x34, 0x39, 0x74, 0x17, 0x90, 0x6B,
    0x66, 0xC9, 0xC2, 0xB8, 0x9B, 0xE2, 0xE6, 0x33, 0x8D, 0x49, 0xC2, 0xC9, 0x65, 0x5B, 0x63, 0xAC, 0x65, 0xFD, 0xA4, 0xBD, 0xC8, 0xED,
    0xC0, 0x3C, 0x85, 0x75, 0x3F, 0xB1, 0x7C, 0x65, 0xC3, 0x1E, 0x3F, 0x7E, 0x96, 0x08, 0xDF, 0x4B, 0xE7, 0xDF, 0xF6, 0x4B, 0x70, 0xF9,
    0x45, 0xE9, 0xBE, 0x35, 0x4D, 0xA9, 0x5C, 0x67, 0x6C, 0x8C, 0x1E, 0xAC, 0xF0, 0xE6, 0xA9, 0xFC, 0x1B, 0xB5, 0x49, 0xF0, 0x57, 0x8C,
    0x1D, 0x5B, 0xB1, 0xF4, 0x9E, 0x91, 0x7D, 0xBD, 0xA1, 0x28, 0xDF, 0x43, 0x98, 0xD7, 0x39, 0x15, 0x6B, 0x1A, 0xEA, 0xEC, 0xC5, 0x49,
    0x02, 0x1A, 0x27, 0xB6, 0xF5, 0x40, 0xF2, 0xB7, 0x9C, 0x1D, 0xA9, 0xDF, 0x2E, 0xA9, 0xCE, 0x68, 0x6A, 0x25, 0x5E, 0x72, 0xAF, 0x54,
    0x5A, 0x7A, 0xA3, 0x91, 0xF1, 0x05, 0x7B, 0x5E, 0x4E, 0xCF, 0x4B, 0x21, 0x5E, 0x9F, 0xEC, 0xBF, 0xD2, 0x65, 0x29, 0x7B, 0xCD, 0xBB,
    0xF8, 0x38, 0x9B, 0xA2, 0x4A, 0x87, 0x49, 0x21, 0x5E, 0x74, 0x64, 0xD6, 0xFF, 0xBB, 0x79, 0x7F, 0x4F, 0x51, 0xBD, 0x07, 0x96, 0xD2,
    0x7A, 0x1E, 0x4E, 0xE9, 0xBE, 0x96, 0x94, 0x5F, 0x79, 0x3A, 0xA9, 0x36, 0x6E, 0x80, 0x38, 0x72, 0x57, 0x27, 0x45, 0xD8, 0x61, 0x37,
    0xB5, 0x6A, 0x13, 0x78, 0xBA, 0x51, 0x3A, 0x7F, 0x63, 0xAF, 0x46, 0x27, 0xBE, 0x24, 0xF9, 0xD8, 0xA6, 0x14, 0x94, 0xCB, 0x6F, 0x69,
    0x0F, 0xD6, 0x99, 0x9D, 0xF3, 0x70, 0xE5, 0x6D, 0x29, 0x1E, 0xF2, 0xBD, 0x76, 0x73, 0xEF, 0x21, 0xF6, 0xEE, 0xE4, 0x58, 0xDD, 0x7F,
    0x2E, 0xE0, 0xF3, 0x3C, 0x4D, 0x4D, 0xD3, 0xCA, 0x8F, 0x4B, 0x94, 0xBF, 0x7A, 0x6F, 0xE1, 0xF2, 0xBA, 0xBB, 0x32, 0x4D, 0x5B, 0x6B,
    0x44, 0x25, 0x9A, 0x5A, 0xF1, 0xAE, 0xBE, 0xA3, 0x2F, 0x48, 0x8F, 0xDA, 0x23, 0xED, 0x43, 0x68, 0x85, 0x37, 0xA4, 0x99, 0x4E, 0x9E,
    0xA0, 0xA8, 0x47, 0x20, 0x3F, 0xC9, 0x9E, 0xAF, 0x64, 0x27, 0x28, 0xD8, 0x23, 0xF9, 0xD7, 0xC1, 0xF8, 0x6A, 0x79, 0xD8, 0xDE, 0x09,
    0x0D, 0xB0, 0xB9, 0x0F, 0x6A, 0x8F, 0x16, 0xBF, 0x0B, 0x9A, 0x22, 0xBC, 0x6C, 0x18, 0x23, 0xBE, 0xFA, 0xA2, 0x64, 0xCF, 0x99, 0xB9,
    0x97, 0xCB, 0x0E, 0x4F, 0x6D, 0x9D, 0x56, 0x29, 0xFF, 0x7A, 0xD1, 0x5F, 0x45, 0x9C, 0x58, 0x6A, 0xD7, 0xEC, 0x33, 0x29, 0xE2, 0x29,
    0x02, 0xA3, 0xE8, 0xAF, 0x5D, 0x66, 0xFE, 0xDA, 0x27, 0xE9, 0x9F, 0x31, 0x2A, 0xCE, 0x2B, 0xA4, 0x08, 0xF5, 0x4B, 0xD7, 0x6F, 0xBC,
    0xAF, 0x68, 0xC5, 0xDE, 0x92, 0xA0, 0xE0, 0x35, 0x12, 0xD6, 0x3F, 0xFB, 0x24, 0x19, 0x32, 0xA7, 0xA4, 0x54, 0x3F, 0xCC, 0x3E, 0x80,
    0xBF, 0x29, 0xDF, 0x2C, 0x69, 0xD8, 0x27, 0xED, 0xED, 0x60, 0x4A, 0xC7, 0x78, 0x24, 0x0A, 0xF6, 0x50, 0xA5, 0x37, 0x56, 0x25, 0x3E,
    0x72, 0x34, 0xF1, 0x2F, 0xCB, 0x35, 0x9B, 0x79, 0xCF, 0xCD, 0x2B, 0x94, 0xE6, 0x93, 0x14, 0x95, 0xE3, 0x69, 0xAA, 0x70, 0x7E, 0x4F,
    0x6B, 0x75, 0xB3, 0x52, 0xE1, 0xFC, 0xCF, 0x7E, 0x0F, 0x61, 0xB6, 0xB7, 0xB4, 0x3D, 0xF2, 0x7E, 0x26, 0xD1, 0x1C, 0x44, 0xA4, 0x51,
    0x7D, 0x3E, 0xF4, 0x2A, 0x6F, 0xAA, 0xDA, 0xA7, 0x93, 0x24, 0xBE, 0xD7, 0xE1, 0x4E, 0xFF, 0x0E, 0xFC, 0x85, 0x05, 0xE9, 0x1C, 0x9E,
    0x54, 0x5B, 0x46, 0x71, 0xCD, 0xE6, 0x1A, 0x5D, 0x36, 0xFF, 0x6A, 0xC5, 0x73, 0x0C, 0x88, 0x24, 0x88, 0xF7, 0xDF, 0xB9, 0x8E, 0xE7,
    0xBC, 0xCF, 0x70, 0xC9, 0x26, 0x94, 0x24, 0xD8, 0x35, 0xF0, 0x5D, 0x40, 0xC7, 0x3C, 0x7E, 0xD9, 0xA6, 0x2D, 0xB5, 0x3C, 0xEA, 0xEE,
    0xE6, 0x27, 0xEE, 0x24, 0x9F, 0x1E, 0x4A, 0xD4, 0xE5, 0xDE, 0x77, 0x97, 0x24, 0xC7, 0x3C, 0x8E, 0xF5, 0x7B, 0x7A, 0x72, 0xEF, 0xB7,
    0x4B, 0xB1, 0x92, 0xC5, 0x57, 0xD3, 0x30, 0x1E, 0xA6, 0x4F, 0x16, 0xBD, 0x3C, 0x48, 0xB9, 0xB7, 0x7C, 0xF1, 0xF2, 0xFF, 0x77, 0xFE,
    0xAE, 0xD0, 0x7E, 0xF1, 0x9F, 0x46, 0x4D, 0x77, 0x0F, 0x58, 0x2F, 0xDC, 0x50, 0xE7, 0x31, 0xB9, 0x8D, 0x46, 0x33, 0xE5, 0x9E, 0xAF,
    0xDA, 0xB4, 0x83, 0x74, 0xDB, 0x5E, 0x48, 0xBF, 0xEE, 0x2A, 0x84, 0x0B, 0xCF, 0x4E, 0xF4, 0xFC, 0x18, 0x7E, 0xEF, 0x7E, 0x69, 0x8F,
    0x67, 0x33, 0x7C, 0xEF, 0xF2, 0xFD, 0xDA, 0xD3, 0x04, 0xE1, 0x9E, 0xD1, 0x9D, 0xDA, 0x7E, 0x0B, 0xE1, 0xA6, 0x2F, 0xD6, 0xB7, 0xFD,
    0x1D, 0xD2, 0x8D, 0xEB, 0xB5, 0xA9, 0xED, 0x97, 0x10, 0xAF, 0xF1, 0xD7, 0xA2, 0xB6, 0xD9, 0xF0, 0xFD, 0xF6, 0xE6, 0x5B, 0x6E, 0x18,
    0x00, 0xDF, 0x8F, 0xF4, 0x9A, 0x7A, 0x43, 0x3A, 0x7C, 0x37, 0xEC, 0xD6, 0xDE, 0xB0, 0x02, 0x42, 0xFF, 0xC4, 0x6E, 0x5E, 0x5D, 0xAE,
    0xD3, 0x68, 0x66, 0x8D, 0x09, 0xF6, 0xEA, 0x04, 0xDF, 0x2B, 0xA3, 0x3B, 0xB7, 0xEB, 0x0D, 0xF1, 0xC6, 0xC5, 0x77, 0x6E, 0xE7, 0x0F,
    0xE1, 0xB7, 0xF5, 0x3B, 0xDB, 0x3D, 0x05, 0xBF, 0xDF, 0xFD, 0xE6, 0x91, 0x76, 0x1F, 0xC2, 0xF7, 0xDD, 0x4F, 0x0D, 0x6B, 0xFF, 0x09,
    0xC3, 0xC3, 0x22, 0xDA, 0xAF, 0x84, 0xF8, 0xDB, 0x6E, 0xD2, 0xB7, 0xDF, 0x09, 0xE1, 0x76, 0x08, 0x5F, 0x84, 0x30, 0x0F, 0xC2, 0x7C,
    0x08, 0x77, 0x42, 0xB8, 0x0B, 0xC2, 0x17, 0x21, 0xDC, 0x0D, 0x61, 0xF7, 0x2B, 0x9F, 0xB4, 0xEF, 0x02, 0xE1, 0xC8, 0xBD, 0x13, 0xBC,
    0x93, 0x21, 0x7D, 0xD0, 0xC1, 0x0D, 0xDE, 0x8F, 0x02, 0xDD, 0x9F, 0x87, 0xEF, 0xF3, 0x5E, 0x08, 0xF8, 0x0B, 0xA9, 0xEF, 0x7A, 0xCF,
    0x01, 0x5C, 0x7B, 0xFC, 0xD3, 0x9B, 0xC2, 0x00, 0xEF, 0xF2, 0xCC, 0xB7, 0x37, 0x3D, 0x02, 0xF8, 0xEE, 0xC4, 0xB6, 0x1D, 0xFA, 0x01,
    0xFE, 0x12, 0x84, 0xFD, 0x21, 0x8C, 0xFF, 0x7B, 0x50, 0x87, 0xFF, 0x01, 0x1E, 0x3E, 0xF7, 0xF3, 0x0E, 0xA3, 0x98, 0x4D, 0x11, 0xC2,
    0x07, 0x20, 0xBC, 0x33, 0xE2, 0xF3, 0x0E, 0x6C, 0x0F, 0x26, 0xB1, 0xE3, 0x92, 0x9B, 0x2F, 0xC0, 0xEF, 0x0B, 0xE6, 0x1D, 0xBE, 0xF9,
    0x0F, 0x08, 0xEF, 0x6B, 0xBA, 0x74, 0x33, 0x5B, 0xA7, 0xFE, 0xF3, 0xFB, 0xA5, 0x9B, 0xFB, 0x43, 0xF8, 0xC6, 0xD2, 0x68, 0x9F, 0x5E,
    0x40, 0xFF, 0x4D, 0x08, 0xEF, 0x84, 0xB0, 0xEB, 0x3F, 0x8B, 0x7C, 0xD8, 0xAB, 0x04, 0xFF, 0x6D, 0xAE, 0xF1, 0x31, 0x41, 0xFC, 0x3B,
    0xBA, 0xAD, 0xBB, 0xE5, 0x2D, 0x08, 0x83, 0x4B, 0xDB, 0x77, 0xF4, 0x82, 0xF0, 0xF9, 0x36, 0x53, 0x3B, 0xAE, 0x86, 0xF0, 0xBD, 0xF7,
    0xF2, 0x3A, 0x2E, 0x83, 0x78, 0x93, 0xF6, 0xEF, 0xE8, 0xB8, 0x10, 0xD2, 0x65, 0x9D, 0x08, 0xBA, 0xF5, 0x5D, 0xC0, 0xAF, 0x8B, 0x79,
    0xEC, 0x56, 0x58, 0x92, 0x6A, 0xCE, 0x1F, 0x6D, 0xB8, 0xD5, 0xC0, 0xEA, 0x6F, 0xD7, 0x53, 0xBE, 0xD7, 0x41, 0xF8, 0x9D, 0xBE, 0xD8,
    0xB7, 0xB2, 0x0D, 0x3B, 0x4B, 0xFF, 0xB6, 0xEF, 0x2D, 0x10, 0x56, 0x0D, 0xF8, 0xCA, 0x77, 0x06, 0xC4, 0x3B, 0xF0, 0xE7, 0xF5, 0x9D,
    0xFA, 0x42, 0xFA, 0xA0, 0xB4, 0xE8, 0x4E, 0x73, 0x80, 0xDE, 0x48, 0x08, 0x43, 0x59, 0xFE, 0x76, 0xAD, 0xEB, 0x94, 0x06, 0xE1, 0xB1,
    0xFC, 0x83, 0x9D, 0x66, 0x41, 0x38, 0x30, 0xF9, 0x8D, 0x4E, 0x43, 0x21, 0x5D, 0xC6, 0xD4, 0xAB, 0x9D, 0xBA, 0x42, 0xBA, 0xC2, 0x57,
    0xDA, 0xDC, 0x36, 0x06, 0xD2, 0xDD, 0xD2, 0x1C, 0x7A, 0x5B, 0x26, 0xD3, 0x0B, 0x77, 0xD6, 0xDD, 0x56, 0x06, 0xE1, 0xA5, 0xF0, 0x99,
    0x9D, 0x4B, 0x20, 0x5E, 0xCD, 0xC5, 0x94, 0xCE, 0xD7, 0x43, 0xBC, 0xB1, 0xC1, 0x4B, 0x3B, 0xCF, 0x03, 0xFC, 0xB1, 0x45, 0xF7, 0x77,
    0x19, 0x05, 0xF1, 0x0B, 0xDF, 0x9E, 0xD5, 0xF5, 0x31, 0x56, 0xBE, 0xD4, 0xB8, 0xAE, 0xB7, 0xC0, 0xEF, 0xDF, 0x7C, 0xF0, 0x42, 0xD7,
    0x26, 0x88, 0x3F, 0xE3, 0xB7, 0xEF, 0xBA, 0x5E, 0x84, 0xB0, 0xE0, 0x6C, 0xAF, 0xDB, 0xDF, 0x87, 0x70, 0x0F, 0x84, 0x1F, 0x40, 0xF8,
    0xC0, 0x5F, 0x7D, 0x6E, 0xEF, 0x0F, 0xE1, 0xEC, 0x01, 0x0F, 0xDE, 0x7E, 0x16, 0xD2, 0x8D, 0xF8, 0xF5, 0xEB, 0xDB, 0x7B, 0xC1, 0x77,
    0xDD, 0xC2, 0xC5, 0xDD, 0x6E, 0x84, 0xF0, 0x9E, 0x37, 0x37, 0x75, 0x7B, 0x1C, 0xE8, 0x0C, 0xEC, 0x5F, 0xD2, 0xED, 0x2E, 0x08, 0xFB,
    0xAE, 0x1E, 0xE1, 0x37, 0x16, 0xE2, 0x5D, 0x30, 0x24, 0xFA, 0x2D, 0x82, 0xEF, 0x1E, 0xED, 0xD3, 0xFD, 0x6E, 0x66, 0x7B, 0xFF, 0x1D,
    0xD2, 0xFD, 0xD8, 0x5B, 0xC2, 0xFD, 0x8F, 0x07, 0x77, 0x1F, 0x0B, 0xF8, 0xA8, 0x81, 0x87, 0xBB, 0xDF, 0x02, 0xDF, 0xD3, 0xEF, 0xF8,
    0xB0, 0xFB, 0x93, 0xF0, 0x5D, 0x7A, 0x63, 0x9B, 0x3B, 0x6A, 0x21, 0xDC, 0x73, 0xF3, 0xE0, 0x3B, 0xC6, 0x00, 0x1E, 0xD8, 0x60, 0xB8,
    0xE3, 0x7E, 0xC8, 0xEF, 0xA9, 0x77, 0x2F, 0xDE, 0x91, 0xC2, 0xE4, 0x6D, 0xD0, 0x97, 0x3D, 0xDA, 0x40, 0x58, 0x94, 0xF7, 0x67, 0x8F,
    0xC7, 0x80, 0x6F, 0x9B, 0xB0, 0xB0, 0x9E, 0x31, 0x10, 0x96, 0xA6, 0x7F, 0xDD, 0xF3, 0x69, 0x96, 0xAF, 0x85, 0x03, 0x7B, 0x7D, 0xCA,
    0xE4, 0x08, 0xC2, 0x33, 0x10, 0xFA, 0xB6, 0xBD, 0xE9, 0x4E, 0x3D, 0xE0, 0x1D, 0x37, 0xF6, 0xBB, 0xF3, 0x57, 0xB6, 0xD6, 0x3D, 0x11,
    0x72, 0xE7, 0x7A, 0xC0, 0x07, 0x7F, 0x3B, 0xE5, 0xCE, 0x9E, 0x40, 0x67, 0x4B, 0x69, 0xFA, 0x9D, 0xAF, 0x40, 0xFA, 0x1F, 0x8F, 0xA5,
    0xDF, 0xF9, 0x24, 0x7C, 0x9F, 0x87, 0x70, 0x0A, 0x84, 0x83, 0x23, 0x6F, 0xEC, 0xDD, 0x02, 0xF8, 0xD2, 0x89, 0xD9, 0xBD, 0xCF, 0x41,
    0xBA, 0xA9, 0x5D, 0x36, 0xF5, 0x5E, 0x0D, 0xE1, 0xB2, 0x4E, 0xF7, 0xF8, 0xDF, 0x0D, 0xE9, 0x97, 0x43, 0x78, 0x0F, 0x84, 0xE5, 0x37,
    0xAD, 0xF2, 0x9F, 0x0C, 0xE1, 0xC6, 0xA9, 0x19, 0xFE, 0x3B, 0x21, 0x9C, 0xBE, 0xAA, 0xDC, 0xFF, 0x35, 0x08, 0x3F, 0xFB, 0xF7, 0x4B,
    0xFF, 0x46, 0x48, 0xFF, 0x39, 0x84, 0xBF, 0x40, 0x38, 0x79, 0x48, 0x83, 0x7F, 0x00, 0xD0, 0x0D, 0xFE, 0xEA, 0x8A, 0xBF, 0x37, 0x84,
    0x47, 0xBC, 0xBC, 0xFA, 0xFC, 0x0C, 0xF4, 0xA6, 0xBC, 0x39, 0xAB, 0xCF, 0x0E, 0x08, 0x3D, 0xA2, 0x56, 0xF6, 0xD1, 0x42, 0xBA, 0x0C,
    0xCD, 0x2B, 0x7D, 0xDE, 0x63, 0xED, 0x7B, 0xB9, 0xDD, 0x5D, 0x03, 0x21, 0x5C, 0x35, 0xE8, 0xED, 0xBB, 0x7E, 0x04, 0xFC, 0xE9, 0x8F,
    0xCE, 0xDE, 0x15, 0xC8, 0xEA, 0xB7, 0x39, 0xA6, 0xEF, 0x07, 0x4C, 0x30, 0x6F, 0x88, 0xED, 0x5B, 0x0D, 0xC1, 0xD1, 0x1B, 0x63, 0xFB,
    0x7E, 0x0C, 0xE1, 0xCA, 0x0E, 0xB1, 0x7D, 0x3F, 0x81, 0x70, 0x5C, 0xC7, 0xD8, 0xBE, 0x9F, 0x42, 0xB8, 0xB6, 0x7C, 0x7B, 0x5F, 0x13,
    0x2B, 0xCF, 0xC1, 0x8A, 0xBE, 0x6F, 0x42, 0xFC, 0xB6, 0x67, 0x3F, 0xE9, 0x3B, 0x1E, 0xC2, 0xEB, 0xA3, 0x2F, 0xF6, 0x0D, 0x82, 0x30,
    0xEE, 0xA7, 0x5E, 0xFD, 0x9E, 0x04, 0xFA, 0xCF, 0xF5, 0x5F, 0xDC, 0x6F, 0x3C, 0xC4, 0x7B, 0x1E, 0xC2, 0x09, 0x10, 0x1E, 0xFF, 0x26,
    0xA8, 0x7F, 0x77, 0xC0, 0x47, 0xB7, 0x4C, 0xEA, 0xFF, 0x1F, 0xD0, 0xF9, 0xBE, 0xF0, 0xF9, 0xFE, 0x87, 0xE1, 0x3B, 0xE2, 0x81, 0x43,
    0xFD, 0xC7, 0xC1, 0x77, 0xEF, 0x07, 0x0F, 0xF5, 0x1F, 0x0F, 0xE1, 0xBA, 0x1F, 0xCB, 0xFB, 0xDF, 0xC0, 0x74, 0xE2, 0x0B, 0xC7, 0xFB,
    0x3F, 0xCB, 0xE8, 0xDF, 0xED, 0x71, 0x77, 0x10, 0xC4, 0xAB, 0x7E, 0x6D, 0xF3, 0x3D, 0xA1, 0x40, 0x47, 0xF3, 0x61, 0xDA, 0x80, 0x8E,
    0x10, 0x96, 0x6E, 0x5C, 0x39, 0xE0, 0x1F, 0xD6, 0x8F, 0x3F, 0xFB, 0x7B, 0xC0, 0xAB, 0x10, 0xEE, 0x1A, 0x71, 0xC3, 0xC0, 0x3A, 0x08,
    0x7B, 0xBD, 0xFC, 0xEA, 0xC0, 0xA1, 0xF0, 0xFB, 0x3B, 0xE3, 0x4E, 0x0D, 0xFC, 0x0D, 0xBE, 0xBD, 0x3F, 0xF2, 0x1B, 0x94, 0x0E, 0x74,
    0xEA, 0x0E, 0xDC, 0x31, 0x28, 0x17, 0xC2, 0x49, 0xDF, 0xBD, 0x78, 0xEF, 0x8D, 0xF0, 0x7B, 0xE5, 0xC6, 0x37, 0xEE, 0x4D, 0x85, 0x70,
    0xDF, 0x91, 0xF7, 0xEE, 0x9D, 0x06, 0xF1, 0x22, 0x8F, 0xFD, 0x7A, 0x6F, 0x24, 0x7C, 0xBF, 0xFA, 0x4B, 0x56, 0xC0, 0x62, 0x88, 0xF7,
    0xF5, 0x81, 0x4D, 0x01, 0x23, 0xE1, 0x3B, 0x26, 0x70, 0x6B, 0x40, 0x2C, 0x7C, 0x1F, 0xCD, 0x8B, 0x1B, 0x7C, 0x18, 0xC2, 0xF7, 0x20,
    0x3C, 0x02, 0xE1, 0x31, 0x08, 0xDF, 0x86, 0x30, 0x79, 0x7E, 0xC9, 0xE0, 0xD7, 0x21, 0x5B, 0x6D, 0x1E, 0xA9, 0x18, 0x1C, 0x07, 0x74,
    0xDA, 0x95, 0xFD, 0x37, 0xD8, 0x00, 0xE9, 0xBE, 0x9F, 0xDD, 0x26, 0x70, 0x1A, 0xFC, 0xFE, 0xFD, 0xF5, 0x4F, 0x05, 0xFE, 0x0A, 0xF8,
    0x62, 0xDF, 0xF5, 0x81, 0x7F, 0xC0, 0x77, 0xAF, 0x9C, 0xFA, 0xC0, 0x3F, 0x59, 0x3F, 0xF2, 0xB9, 0x14, 0x38, 0x8B, 0xF1, 0x7D, 0x6C,
    0xE7, 0x90, 0x2B, 0xEC, 0xAD, 0xC8, 0x1B, 0xC2, 0x87, 0x5E, 0x82, 0xF0, 0x77, 0x9F, 0x6F, 0x87, 0xD6, 0x30, 0xFA, 0x47, 0x26, 0x0D,
    0x2B, 0x62, 0xFD, 0xE6, 0xDF, 0x05, 0xC3, 0xEE, 0x87, 0xEF, 0xCE, 0x1E, 0xDA, 0x61, 0xA3, 0x20, 0x0C, 0x8F, 0x7D, 0x6D, 0xD8, 0x4C,
    0x88, 0xB7, 0xA5, 0xDD, 0xEB, 0xC3, 0x6E, 0x66, 0xFD, 0xE8, 0xE6, 0x41, 0xC3, 0x7F, 0x81, 0xEF, 0x77, 0x1A, 0xA6, 0x0F, 0x67, 0xD5,
    0x63, 0x98, 0xB0, 0x65, 0xF8, 0x2B, 0x10, 0xAF, 0xFD, 0x9A, 0xF7, 0x87, 0x0F, 0x00, 0x60, 0xC2, 0xAB, 0x3D, 0x47, 0xB4, 0x83, 0xEF,
    0x57, 0xC7, 0x3C, 0x39, 0xE2, 0x69, 0xF8, 0x36, 0x75, 0xCB, 0x1B, 0xF1, 0x04, 0xA4, 0xEB, 0x73, 0xE7, 0x82, 0xA0, 0xEB, 0x21, 0xEC,
    0xDD, 0xC1, 0x14, 0x74, 0x0A, 0xD2, 0xCD, 0xFD, 0x6F, 0x55, 0x90, 0x0F, 0x1B, 0xBF, 0xC6, 0xEF, 0x0E, 0x62, 0x3A, 0xE9, 0x2F, 0x6B,
    0xBE, 0x0E, 0xBA, 0x8D, 0x95, 0x6F, 0x43, 0xE0, 0xC8, 0x58, 0x48, 0x37, 0xEC, 0x85, 0x87, 0x46, 0x86, 0xB0, 0xF6, 0x9A, 0x3E, 0x71,
    0xE4, 0x68, 0xF8, 0xBE, 0xBF, 0x7B, 0xFA, 0xC8, 0x23, 0x10, 0x6F, 0xC8, 0xBA, 0xEF, 0x47, 0x2E, 0x81, 0x78, 0x1F, 0x69, 0x7F, 0x1D,
    0x19, 0x02, 0x78, 0x7E, 0xBF, 0x1B, 0xEF, 0xBB, 0x17, 0xE2, 0xCD, 0xD3, 0x2D, 0xBC, 0xEF, 0x3F, 0x08, 0x8D, 0xC3, 0xD3, 0xEF, 0xEB,
    0x0C, 0xF1, 0xBE, 0x9E, 0x7E, 0xFE, 0xBE, 0x2F, 0x20, 0xDE, 0xA7, 0xD5, 0x41, 0xF7, 0x47, 0xC3, 0x77, 0xE7, 0xE9, 0x0B, 0xEF, 0xAF,
    0x81, 0x70, 0x8C, 0xF7, 0xE1, 0xFB, 0xB7, 0x02, 0xFE, 0xCB, 0xF4, 0x63, 0xF7, 0xDF, 0xC1, 0xEA, 0xFF, 0xC7, 0x8E, 0xA3, 0x52, 0xE1,
    0xBB, 0xDF, 0x5F, 0xBD, 0x46, 0xDD, 0x0C, 0xE1, 0xB9, 0xF1, 0x77, 0x3D, 0xF0, 0x2D, 0xAB, 0xC7, 0x91, 0xAB, 0x1E, 0x98, 0x0A, 0xBF,
    0x5F, 0xAC, 0xDA, 0xF5, 0x00, 0x2B, 0x68, 0xDB, 0xD7, 0x43, 0x46, 0x3F, 0x08, 0xF4, 0x87, 0xB5, 0xFF, 0xDF, 0x68, 0xB6, 0x76, 0x1A,
    0x3F, 0xB2, 0xED, 0x18, 0x5F, 0x88, 0x37, 0x01, 0xC2, 0x4E, 0xAC, 0xFD, 0x3E, 0xE8, 0x3D, 0x66, 0x24, 0xFC, 0x7E, 0x68, 0x95, 0x76,
    0xCC, 0x9F, 0x10, 0xDE, 0xF9, 0xDA, 0x9A, 0x31, 0x69, 0x80, 0x6F, 0x0F, 0xED, 0x16, 0xDC, 0x04, 0xF1, 0x97, 0xAE, 0x39, 0x18, 0xFC,
    0x04, 0x7C, 0xFF, 0x77, 0xFA, 0xD8, 0x83, 0xF5, 0xF0, 0xFB, 0x95, 0xEA, 0x8B, 0x0F, 0xC6, 0x01, 0xDD, 0x3F, 0x21, 0x8C, 0x87, 0x70,
    0xFB, 0x44, 0xCD, 0xD8, 0x70, 0x88, 0xF7, 0xF1, 0xE8, 0xE9, 0x63, 0x53, 0x21, 0xFC, 0x04, 0xC2, 0x45, 0x10, 0x7E, 0x0A, 0xE1, 0x62,
    0x76, 0x6F, 0xEC, 0xF8, 0xDC, 0xB1, 0x41, 0x10, 0x6F, 0xC6, 0xBA, 0x75, 0x63, 0xE7, 0x40, 0x38, 0xE7, 0xBD, 0xAC, 0xB1, 0x5A, 0xA0,
    0x73, 0x76, 0xC9, 0xA6, 0xB1, 0x7D, 0x98, 0xFC, 0x75, 0x0D, 0x1B, 0x57, 0xC5, 0xC6, 0xFF, 0x75, 0x37, 0x8D, 0xFF, 0x17, 0xF0, 0xDF,
    0x1F, 0x9B, 0x33, 0x7E, 0x3E, 0x7C, 0xFF, 0x70, 0x5F, 0xF2, 0xF8, 0x3E, 0xC0, 0xB7, 0xC3, 0xB2, 0xB4, 0xF1, 0x79, 0x10, 0xFE, 0xB3,
    0xFA, 0xDC, 0xF8, 0x10, 0xC0, 0x8F, 0x5F, 0xFF, 0xE8, 0x84, 0xBE, 0x10, 0x2F, 0x26, 0x78, 0xC6, 0x84, 0x53, 0xAC, 0x7F, 0xCF, 0x9F,
    0x37, 0xE1, 0x1B, 0x56, 0x7F, 0xE7, 0x96, 0x4E, 0x98, 0x0C, 0xF4, 0x3E, 0xBC, 0xE5, 0xCC, 0x84, 0xB6, 0x10, 0x2E, 0xD4, 0x0E, 0x78,
    0xE8, 0x3C, 0x5B, 0x7B, 0x4D, 0x2B, 0x7F, 0x48, 0x0F, 0xDF, 0x51, 0xFF, 0x9D, 0x7C, 0x68, 0x2B, 0xD3, 0xD1, 0x20, 0xDC, 0x06, 0x61,
    0x9F, 0x36, 0x1F, 0x3E, 0xB4, 0x1D, 0xC2, 0x55, 0x55, 0xC9, 0x0F, 0xB7, 0x87, 0xDF, 0x5F, 0xFB, 0x6F, 0xF7, 0xC3, 0x77, 0xB3, 0xF1,
    0xEE, 0xCC, 0xE7, 0x13, 0xA7, 0x00, 0xBD, 0x27, 0x4F, 0x0C, 0x99, 0x94, 0xC5, 0xFA, 0x95, 0xD7, 0xC4, 0x49, 0x0D, 0x10, 0xFE, 0xEE,
    0xFB, 0xF2, 0xA4, 0x00, 0xC0, 0xD7, 0xB4, 0xF9, 0x78, 0xD2, 0x77, 0xF0, 0x1D, 0xD5, 0x21, 0xF6, 0x91, 0xAF, 0x20, 0x4C, 0x38, 0xB4,
    0xEB, 0x11, 0xB6, 0x9E, 0x78, 0xF6, 0xF0, 0xD4, 0x47, 0x07, 0xC3, 0xEF, 0x1D, 0x8A, 0x42, 0x1F, 0xDD, 0x02, 0x78, 0xEA, 0x5D, 0x3D,
    0x42, 0xD8, 0xB3, 0x3A, 0xEF, 0xCD, 0x7F, 0x30, 0xE4, 0x28, 0xFC, 0xFE, 0xD3, 0xEA, 0x57, 0x43, 0x12, 0x98, 0xBC, 0xDD, 0x5E, 0x17,
    0xB2, 0x8F, 0xAD, 0x8F, 0x57, 0x9D, 0x0F, 0xF9, 0x80, 0xED, 0x1D, 0xF4, 0xFC, 0xE8, 0xB1, 0xA9, 0x90, 0xEE, 0xD9, 0xBD, 0x21, 0x8F,
    0x6B, 0x20, 0xDC, 0xE4, 0xB7, 0xE7, 0xF1, 0x6E, 0x80, 0x0F, 0xBB, 0x70, 0xFA, 0xF1, 0x0E, 0x90, 0xAF, 0x5E, 0x7E, 0xFD, 0x9E, 0x98,
    0x05, 0x61, 0xE7, 0xB3, 0xD3, 0x9F, 0x78, 0x03, 0x7E, 0x9F, 0x18, 0xB2, 0xFC, 0x89, 0xEB, 0xE0, 0xBB, 0x69, 0xCA, 0x1D, 0x93, 0xF7,
    0x32, 0x3F, 0x6F, 0x7B, 0xFB, 0x4E, 0xFE, 0x89, 0xF5, 0xEB, 0xB2, 0x89, 0x93, 0x27, 0x31, 0xB9, 0xC9, 0xFE, 0x66, 0x72, 0x2C, 0x7C,
    0x57, 0xBE, 0x50, 0x3F, 0x79, 0x14, 0x84, 0x4F, 0x0D, 0xBE, 0x32, 0xF9, 0x1F, 0xC0, 0xFF, 0xD7, 0xB8, 0xFF, 0xC9, 0x5B, 0x21, 0xFE,
    0xDF, 0xBF, 0xDF, 0x32, 0xA5, 0x1B, 0xA4, 0x3F, 0x9D, 0x78, 0xEB, 0x94, 0x77, 0xE1, 0xFB, 0x01, 0xFF, 0x7E, 0x53, 0xDE, 0x61, 0xE3,
    0xCC, 0x90, 0x49, 0x53, 0xA6, 0x43, 0xBC, 0xDB, 0x3F, 0x1A, 0x3C, 0xF5, 0x73, 0x56, 0xEF, 0x2F, 0xCF, 0x9C, 0x7A, 0x86, 0xCD, 0x9B,
    0x41, 0xAB, 0xA7, 0x8E, 0x84, 0x6F, 0xCF, 0xCE, 0xCF, 0x4D, 0xDD, 0x03, 0xF1, 0x16, 0x6F, 0xDD, 0x35, 0xED, 0x38, 0xF3, 0xD1, 0x77,
    0xF6, 0xD5, 0x69, 0x3E, 0x40, 0x67, 0xEE, 0xB9, 0x4F, 0xA6, 0x7F, 0x0D, 0xBF, 0x1F, 0x49, 0xF9, 0x63, 0x7A, 0x2F, 0xA6, 0x07, 0x1D,
    0xFB, 0x6B, 0xFA, 0x27, 0xAC, 0x1E, 0xCE, 0x68, 0x66, 0x2C, 0x03, 0xDC, 0xFB, 0xFE, 0x36, 0x33, 0x6A, 0x59, 0xBE, 0xFB, 0x3E, 0x3A,
    0x63, 0x3D, 0x84, 0xC3, 0x6B, 0x96, 0xCE, 0x38, 0xC2, 0xC6, 0x9F, 0xCA, 0x8C, 0x19, 0x05, 0x6C, 0xDE, 0x3A, 0xFD, 0xE3, 0x8C, 0xDF,
    0x20, 0xDD, 0x75, 0x1F, 0xA6, 0x3D, 0xB5, 0x9C, 0xCD, 0x3B, 0x1B, 0x6F, 0x98, 0xE9, 0x09, 0xDF, 0x7B, 0x21, 0x6C, 0xCB, 0xFA, 0x7B,
    0xAF, 0xDE, 0x33, 0xD3, 0x20, 0xDE, 0x97, 0x2F, 0x84, 0xCE, 0xFC, 0x86, 0xCD, 0x27, 0x1D, 0xE3, 0x67, 0xCE, 0x64, 0xF3, 0xDB, 0xD9,
    0xC7, 0x66, 0x55, 0x41, 0x78, 0xF2, 0xE7, 0xF7, 0x67, 0x2D, 0x87, 0xDF, 0x5F, 0x7A, 0xE3, 0xC4, 0xAC, 0x62, 0xA6, 0xE7, 0x5C, 0xAD,
    0x9A, 0x35, 0x17, 0xC2, 0xF1, 0xC6, 0x73, 0x6C, 0xD8, 0xD0, 0xFC, 0xA4, 0xEF, 0x33, 0xFB, 0x05, 0x08, 0xFF, 0x77, 0xD3, 0x88, 0x39,
    0xCC, 0x96, 0x76, 0xE9, 0xA9, 0x07, 0xE6, 0x5C, 0x65, 0xE3, 0x49, 0xD7, 0xDC, 0x39, 0x51, 0x10, 0x76, 0x0D, 0xA8, 0x9D, 0x73, 0x03,
    0x94, 0xE3, 0x81, 0x71, 0xD9, 0xA1, 0x37, 0xB1, 0x7E, 0x3C, 0x37, 0x3B, 0xB4, 0x2F, 0x84, 0x5B, 0x1F, 0x7F, 0xE0, 0xE9, 0x06, 0x88,
    0x7F, 0xCF, 0x84, 0xF7, 0x9F, 0x6E, 0x81, 0xEF, 0xE7, 0x4E, 0xB5, 0x9D, 0xBB, 0x00, 0xE2, 0xF5, 0xBB, 0xAE, 0xDD, 0x5C, 0xB6, 0xD7,
    0xD3, 0x1F, 0xC2, 0xEE, 0x10, 0xDE, 0x0D, 0x21, 0x3B, 0x53, 0xD9, 0x6E, 0x70, 0xB7, 0xB9, 0x8F, 0x02, 0xBD, 0x41, 0xE1, 0xFA, 0xB9,
    0xDD, 0x20, 0xFE, 0x87, 0xFE, 0x86, 0xB9, 0xFD, 0xAE, 0x63, 0xE3, 0xB6, 0xC7, 0xBC, 0xDF, 0x85, 0x71, 0xDB, 0x63, 0xDE, 0x65, 0x08,
    0x9F, 0x0F, 0x0D, 0x99, 0xF7, 0x24, 0xD3, 0x07, 0x21, 0x9C, 0xC2, 0xEE, 0xA5, 0x40, 0x38, 0x15, 0xC2, 0xAB, 0x4B, 0x33, 0xE7, 0xED,
    0x80, 0xF4, 0x01, 0x97, 0x3F, 0x9E, 0x17, 0xC7, 0xCE, 0xC5, 0xFF, 0x6C, 0x0C, 0x3B, 0x0E, 0x74, 0xE6, 0xAD, 0xFF, 0x21, 0xEC, 0x23,
    0x36, 0x5E, 0xC5, 0xFD, 0x13, 0x36, 0x92, 0xE9, 0x25, 0xFF, 0xBB, 0x25, 0xFC, 0x0F, 0x08, 0x4F, 0x5E, 0xDF, 0x2B, 0x7C, 0x13, 0x6B,
    0xFF, 0xA3, 0x0F, 0x84, 0xC7, 0xB3, 0xFA, 0x1D, 0xD7, 0x29, 0xE2, 0x04, 0xC4, 0x7F, 0xEB, 0x48, 0xFF, 0x88, 0x09, 0xC2, 0x3C, 0x34,
    0x2A, 0xC2, 0x97, 0x8D, 0x53, 0xAF, 0x3D, 0x18, 0x91, 0xC1, 0xF4, 0x8C, 0xCB, 0xC7, 0x23, 0x66, 0xC3, 0xEF, 0xED, 0x46, 0xAD, 0x8C,
    0xFC, 0x91, 0xF5, 0x9B, 0x13, 0x6F, 0x44, 0x7A, 0x40, 0xFE, 0xD2, 0xFD, 0xDA, 0x45, 0x3D, 0x00, 0xE1, 0x5B, 0x45, 0x2D, 0x51, 0x97,
    0x98, 0x9E, 0x35, 0xE5, 0xD1, 0xE8, 0xAE, 0x10, 0xFF, 0xBB, 0xE9, 0x8F, 0x46, 0x33, 0x9B, 0xFB, 0xBE, 0xA0, 0x88, 0xE8, 0x42, 0x08,
    0x1F, 0x5C, 0x9A, 0x1A, 0xF3, 0x03, 0xA4, 0xFF, 0x22, 0x2D, 0x23, 0xE6, 0x24, 0x6B, 0xD7, 0xD8, 0xBC, 0x98, 0xDB, 0x21, 0xFE, 0x9B,
    0x5D, 0x34, 0xB1, 0xEB, 0xE0, 0xBB, 0xAA, 0x9B, 0x4F, 0xEC, 0x47, 0xF0, 0x7D, 0x72, 0x40, 0x60, 0x6C, 0x21, 0x93, 0xB7, 0x6D, 0xCF,
    0xC4, 0x7A, 0x41, 0xBA, 0x4E, 0xDD, 0x36, 0xC6, 0x4E, 0x02, 0xFC, 0xA1, 0xA5, 0x9B, 0x62, 0xD7, 0x00, 0xDE, 0x6D, 0xF9, 0xCF, 0xB1,
    0x39, 0x6C, 0xBE, 0x9E, 0xBF, 0x26, 0xEE, 0x28, 0xD3, 0x87, 0xDB, 0xBC, 0x1A, 0x37, 0x1D, 0xF8, 0xB7, 0xBC, 0xB1, 0x29, 0x7E, 0x0D,
    0x7C, 0xBF, 0xFC, 0xE7, 0x4B, 0xF1, 0x03, 0xE1, 0x7B, 0x75, 0xB7, 0x80, 0xF9, 0xEC, 0xCD, 0xA5, 0xDA, 0x31, 0xC3, 0xE6, 0x1F, 0x84,
    0xF8, 0xCF, 0x17, 0x84, 0xCC, 0xBF, 0x13, 0x7E, 0xFF, 0xFE, 0xAB, 0xE8, 0xF9, 0x33, 0xE0, 0xF7, 0xD8, 0x3D, 0x5E, 0x0B, 0x86, 0x00,
    0xDE, 0xC7, 0x6B, 0xCE, 0x82, 0xAE, 0xF0, 0x5D, 0xBC, 0xFE, 0x95, 0x05, 0x46, 0x08, 0xA7, 0x79, 0x57, 0x2F, 0x98, 0x0B, 0xF8, 0xEC,
    0x0E, 0x51, 0xDA, 0x52, 0xA6, 0xA7, 0xCE, 0xD8, 0xA0, 0x7D, 0x88, 0xC9, 0xA7, 0xE6, 0x77, 0xED, 0xC7, 0xAC, 0x9F, 0xED, 0xBE, 0x45,
    0x77, 0x06, 0xE8, 0x3E, 0xBA, 0xF7, 0x16, 0xDD, 0x67, 0x6C, 0xFE, 0xEF, 0xD9, 0x5F, 0x77, 0x3D, 0xD3, 0xFF, 0x3F, 0x30, 0xE9, 0xEE,
    0x83, 0xDF, 0x53, 0x20, 0xBC, 0x9F, 0xCD, 0xA3, 0x0F, 0xBF, 0xAB, 0x3B, 0x01, 0xF8, 0x97, 0x7F, 0x78, 0x27, 0x9C, 0x82, 0xF4, 0x5F,
    0x41, 0x78, 0x1A, 0xC2, 0xCB, 0xA1, 0xD3, 0x12, 0xFE, 0x82, 0xF0, 0xF1, 0x27, 0x4F, 0x24, 0x44, 0xB1, 0x7A, 0x3B, 0xD9, 0x27, 0x71,
    0x12, 0x9B, 0x67, 0x21, 0x7C, 0x04, 0xC2, 0x94, 0x4B, 0x7D, 0x12, 0xDF, 0x85, 0xDF, 0xC3, 0xF6, 0x2F, 0x4B, 0x5C, 0x0B, 0x74, 0xBC,
    0x7A, 0x1C, 0x48, 0x3C, 0x06, 0xDF, 0xA7, 0x2B, 0xCB, 0x12, 0xAB, 0xD8, 0xBC, 0xFE, 0xCA, 0xC3, 0xFA, 0xB7, 0x21, 0xFC, 0xE5, 0x56,
    0xA3, 0xBE, 0x3D, 0x84, 0x85, 0xF7, 0xEE, 0xD2, 0x0F, 0x80, 0xB0, 0xDC, 0xEB, 0x75, 0x7D, 0x1B, 0xA6, 0x9F, 0x17, 0xD5, 0xEB, 0xFF,
    0x07, 0x7C, 0x9F, 0x4E, 0x6F, 0xD2, 0x87, 0x03, 0xBD, 0x15, 0xCF, 0xDC, 0xB8, 0x30, 0x8C, 0x8D, 0xF3, 0x87, 0x6E, 0x5B, 0x38, 0x02,
    0x7E, 0x0F, 0x3C, 0xDF, 0x6F, 0x61, 0x18, 0x84, 0x43, 0x63, 0x47, 0x2F, 0x6C, 0x02, 0xDC, 0xE3, 0xF0, 0x58, 0x83, 0x07, 0xE3, 0x93,
    0xF6, 0xB1, 0xE1, 0x10, 0x7C, 0x5F, 0x19, 0x78, 0xC1, 0x50, 0xC4, 0xEC, 0x1C, 0x57, 0x73, 0x4C, 0xF9, 0xAC, 0x9F, 0xCC, 0xBE, 0x39,
    0x69, 0x27, 0xDB, 0x6B, 0x80, 0xF0, 0x45, 0x76, 0x46, 0x36, 0x71, 0x4A, 0xD2, 0x02, 0xD6, 0x4E, 0x07, 0x67, 0x26, 0x0D, 0x82, 0xDF,
    0xD7, 0xBD, 0x32, 0x33, 0xE9, 0x5E, 0x08, 0xAF, 0x5E, 0x97, 0x97, 0x64, 0x62, 0x7A, 0xE2, 0x43, 0x79, 0x49, 0xAF, 0xC3, 0xEF, 0x1F,
    0x15, 0xDC, 0x9B, 0x3C, 0x97, 0x8D, 0x3B, 0xE9, 0xCF, 0x26, 0x4F, 0x87, 0x74, 0x3D, 0xDB, 0xFE, 0x9C, 0xBC, 0x09, 0xF0, 0x8A, 0xD7,
    0x9B, 0x93, 0xE7, 0xB2, 0xF5, 0xCD, 0xA8, 0xF8, 0x94, 0x72, 0x08, 0x9F, 0x3C, 0x5B, 0x9A, 0xD2, 0x11, 0xD2, 0xAD, 0xAD, 0x3F, 0x92,
    0xD2, 0x1B, 0x7E, 0xCF, 0xD9, 0xD5, 0x3F, 0xF5, 0x41, 0x48, 0x77, 0x26, 0xE2, 0xE9, 0xD4, 0xC7, 0xE1, 0xF7, 0xCF, 0x20, 0x7C, 0x02,
    0xC2, 0x17, 0x62, 0x9E, 0x4E, 0x9D, 0x0C, 0xE1, 0xEE, 0xAB, 0x2B, 0x53, 0x43, 0x20, 0xFE, 0xE1, 0xFA, 0xA3, 0xA9, 0x33, 0x21, 0x5E,
    0x72, 0xC5, 0x47, 0xA9, 0xEB, 0x20, 0xDD, 0xE5, 0xEC, 0xF3, 0xA9, 0xBB, 0xD9, 0x38, 0x70, 0xF4, 0x42, 0x6A, 0x22, 0xFC, 0x3E, 0x62,
    0x77, 0xD0, 0xA2, 0x99, 0x80, 0x9F, 0x1A, 0x31, 0x77, 0xD1, 0xD3, 0x4C, 0x5F, 0x6A, 0x13, 0xBB, 0x28, 0x81, 0xE9, 0x29, 0xD3, 0xD6,
    0x2E, 0x2A, 0x87, 0xF0, 0x93, 0x15, 0xFF, 0x2C, 0x0A, 0x67, 0xE3, 0xDC, 0xA5, 0xB1, 0x4B, 0x5E, 0x87, 0xDF, 0x93, 0x4E, 0x3E, 0xBA,
    0x64, 0x2C, 0xD0, 0x9B, 0xF2, 0x5A, 0xDA, 0x92, 0xCF, 0x01, 0x9F, 0x0A, 0xE1, 0x17, 0x6C, 0x5E, 0xBB, 0x2B, 0x63, 0x49, 0x26, 0xFC,
    0x9E, 0x33, 0x3B, 0x20, 0x6D, 0x3D, 0xD3, 0xF3, 0x3E, 0x9B, 0x93, 0xF6, 0x1A, 0xCB, 0xFF, 0x8A, 0x43, 0x69, 0x33, 0xD8, 0x7C, 0xFB,
    0xEF, 0x37, 0x69, 0x6C, 0xA1, 0xF1, 0x5B, 0xC4, 0xB4, 0xA5, 0xC7, 0x20, 0xFE, 0x23, 0x3D, 0xE6, 0x2C, 0x5D, 0x0B, 0xDF, 0xF7, 0x6E,
    0x49, 0x5B, 0x1A, 0x0D, 0xDF, 0x1F, 0xBE, 0x5F, 0xB9, 0x74, 0x03, 0x84, 0xFD, 0xEE, 0xBA, 0x71, 0xD9, 0xCB, 0x6C, 0xDE, 0xD4, 0x65,
    0x2C, 0xCB, 0x60, 0xEB, 0xC0, 0x8E, 0x7B, 0x96, 0x3D, 0xC5, 0xF4, 0xAF, 0x3B, 0xF6, 0x2E, 0x7B, 0x84, 0xB5, 0xB7, 0xEF, 0xCB, 0xCB,
    0x9E, 0x83, 0xB0, 0x21, 0x77, 0xF4, 0xF2, 0x62, 0xC0, 0x4F, 0x2C, 0x7B, 0x76, 0x79, 0x0C, 0xEB, 0xA7, 0x10, 0xC6, 0x42, 0xD8, 0xF8,
    0xF2, 0x7B, 0xCB, 0xEF, 0x84, 0xDF, 0x07, 0xB4, 0x3F, 0xBE, 0xBC, 0x05, 0xBE, 0x97, 0x24, 0x9D, 0x5B, 0xFE, 0x30, 0x1B, 0x8F, 0x6E,
    0xFC, 0x6B, 0x79, 0x3E, 0xDB, 0xB7, 0xCB, 0x5F, 0x9A, 0xEE, 0x09, 0x7C, 0xDE, 0x7D, 0x78, 0x75, 0xFA, 0x30, 0xA6, 0x87, 0xDF, 0x50,
    0x93, 0xBE, 0x94, 0xE9, 0x0D, 0xF9, 0xBF, 0xAF, 0x18, 0x08, 0xDF, 0x37, 0xE8, 0x7A, 0xAF, 0xCC, 0x63, 0xFD, 0x73, 0xEA, 0x3D, 0x2B,
    0xC7, 0x42, 0xD8, 0xAD, 0xE7, 0xAA, 0x95, 0xBF, 0x02, 0xFE, 0x83, 0x47, 0xD7, 0x55, 0xF7, 0x43, 0xBC, 0x53, 0xBA, 0xE4, 0x55, 0x27,
    0x21, 0x3C, 0x0D, 0xE1, 0x87, 0x10, 0x1E, 0xB9, 0x72, 0x32, 0xE3, 0x1E, 0x36, 0x9F, 0x0F, 0xBA, 0x79, 0x75, 0x31, 0xD3, 0xB7, 0x0F,
    0xC4, 0xAC, 0x7E, 0x07, 0xBE, 0x53, 0x73, 0xDB, 0xAE, 0x79, 0x1F, 0x7E, 0xDF, 0xFE, 0xD9, 0xBA, 0xB5, 0x0F, 0xC0, 0x77, 0xCB, 0xF9,
    0xC2, 0xB5, 0x81, 0x10, 0xBE, 0xBA, 0xF5, 0xAF, 0xB5, 0xDF, 0x00, 0xFE, 0xE7, 0x9E, 0x8C, 0xCC, 0x59, 0x10, 0xFF, 0xB5, 0x6F, 0xB6,
    0x67, 0x46, 0xB2, 0xF1, 0xEC, 0xDF, 0xE2, 0xCC, 0xB6, 0xF0, 0xFD, 0xEB, 0x53, 0x9B, 0x9E, 0x99, 0x04, 0xBF, 0xFF, 0x06, 0xE1, 0x23,
    0x10, 0xBE, 0x36, 0x67, 0xD3, 0x33, 0x8F, 0xB2, 0xF5, 0x6D, 0x6A, 0xCE, 0x33, 0x7B, 0xE1, 0xF7, 0xBD, 0x10, 0xEE, 0x83, 0xF0, 0xFE,
    0xCA, 0xFA, 0x67, 0x86, 0x40, 0x3B, 0x5C, 0x48, 0x3B, 0xF0, 0xEC, 0xF3, 0x90, 0x3E, 0xEB, 0x95, 0xEF, 0x9E, 0x5D, 0x05, 0xF8, 0xDF,
    0xFE, 0xA3, 0xD6, 0x4D, 0x03, 0xFC, 0xC9, 0xB9, 0x86, 0xAC, 0x03, 0xAC, 0x7C, 0xA3, 0x93, 0xB2, 0x92, 0xD8, 0xD9, 0x89, 0x9E, 0x2B,
    0xB3, 0x36, 0xB0, 0x3D, 0xFA, 0x6F, 0xEF, 0x58, 0x7F, 0x1F, 0xFC, 0xDE, 0x30, 0xA8, 0xF7, 0xFA, 0xF7, 0xE1, 0xF7, 0xC8, 0xD5, 0x23,
    0xD6, 0x3F, 0x03, 0xE9, 0x27, 0x5D, 0xBF, 0x7A, 0x7D, 0x2A, 0x84, 0xFF, 0xFC, 0xFB, 0xD2, 0xFA, 0x8D, 0x80, 0x67, 0xF7, 0x6E, 0x58,
    0x7F, 0x9E, 0x8D, 0x1F, 0x75, 0x91, 0x1B, 0x6E, 0x85, 0xF8, 0x9B, 0xBB, 0xBC, 0xBF, 0xA1, 0x17, 0x7C, 0x2F, 0xEB, 0x79, 0x7A, 0x43,
    0x27, 0xF8, 0xEE, 0x5E, 0x70, 0x66, 0xC3, 0x38, 0xF8, 0x6E, 0xD9, 0x7F, 0x7E, 0xC3, 0xF7, 0x10, 0xAE, 0x39, 0xFC, 0xD4, 0xC6, 0x1E,
    0x80, 0x2F, 0xE9, 0xBD, 0x70, 0xE3, 0x44, 0x08, 0x3B, 0xBC, 0xB7, 0x77, 0xE3, 0x2D, 0x6C, 0xFC, 0x78, 0xB8, 0x6B, 0xF6, 0x4F, 0xF0,
    0xFB, 0x89, 0x0F, 0x8A, 0xB3, 0x2F, 0xB2, 0xF1, 0x37, 0xF1, 0x64, 0xF6, 0x54, 0xF8, 0xAE, 0x38, 0xD2, 0xEE, 0xB9, 0x8D, 0x4C, 0xEE,
    0x6E, 0x5D, 0xFE, 0x9C, 0x06, 0xBE, 0xBB, 0xA6, 0x6E, 0x7F, 0x6E, 0x1E, 0xC4, 0x7F, 0xB7, 0xF7, 0x57, 0xCF, 0x25, 0x40, 0xD8, 0xF7,
    0xF5, 0x7F, 0x9E, 0x3B, 0xCD, 0xD6, 0x83, 0xC7, 0x6F, 0x7D, 0xBE, 0x03, 0xD3, 0x93, 0x0E, 0x3E, 0xBC, 0x29, 0x06, 0xC2, 0x67, 0xF4,
    0xB3, 0x37, 0x75, 0x86, 0xDF, 0xC3, 0x4B, 0xE6, 0x6C, 0x7A, 0x85, 0xD9, 0xFF, 0x9E, 0x5D, 0xB2, 0x69, 0x17, 0xD3, 0x1F, 0x20, 0xDC,
    0xCD, 0xF4, 0x7E, 0x08, 0x5F, 0x82, 0xB0, 0xE3, 0xB8, 0xB5, 0x9B, 0x02, 0x58, 0xBF, 0x1B, 0xBE, 0x6E, 0x53, 0x07, 0xE0, 0x93, 0x79,
    0x7E, 0x68, 0x0E, 0xBB, 0xAB, 0xF2, 0x0C, 0x84, 0xBD, 0xD9, 0x3A, 0xF6, 0xC2, 0xD0, 0x1C, 0x76, 0x67, 0xE6, 0x11, 0x08, 0xFB, 0x40,
    0x78, 0xE3, 0xA5, 0xA1, 0x39, 0x6C, 0x9F, 0xA1, 0x3D, 0x84, 0x7D, 0x99, 0xBC, 0x1C, 0x4D, 0xCA, 0x99, 0xC8, 0xF4, 0x8B, 0xB8, 0x8C,
    0x9C, 0x0C, 0xD6, 0x9E, 0x8F, 0xF5, 0x78, 0x61, 0x02, 0x84, 0xFB, 0xD6, 0xEC, 0x7F, 0x61, 0x18, 0x5B, 0x1F, 0xDE, 0x36, 0x7D, 0xF3,
    0x12, 0x08, 0x13, 0x5E, 0x2A, 0xDA, 0xFC, 0x37, 0xC4, 0xEF, 0xB1, 0xAD, 0x78, 0x73, 0x22, 0x5B, 0x0F, 0x2F, 0x2B, 0xDD, 0xEC, 0xC7,
    0xFA, 0xD5, 0x8E, 0xF3, 0x9B, 0x2B, 0x99, 0x1E, 0x3C, 0xE7, 0xD7, 0xCD, 0x2B, 0x59, 0xBF, 0xDD, 0x3B, 0x65, 0x4B, 0x4F, 0x08, 0xCB,
    0x76, 0x68, 0xB7, 0xE8, 0x20, 0xAC, 0x1D, 0xE4, 0x99, 0x5B, 0x0D, 0xF1, 0x13, 0x1F, 0x6E, 0x9F, 0xFB, 0x37, 0x84, 0x4B, 0x66, 0xDC,
    0x9A, 0x3B, 0x0E, 0xCA, 0xB5, 0x73, 0xD6, 0x9A, 0xDC, 0xEF, 0xE1, 0x7B, 0xFD, 0x7D, 0x27, 0x72, 0xCB, 0x20, 0xDE, 0x07, 0x7D, 0xEE,
    0xD8, 0xFA, 0x0C, 0xD3, 0x0B, 0xDB, 0x97, 0x6D, 0x7D, 0x09, 0xE8, 0xED, 0xD0, 0x7D, 0xB3, 0xF5, 0x2B, 0xB6, 0x1E, 0xCC, 0xED, 0xBE,
    0xED, 0x56, 0x08, 0x37, 0xCE, 0x59, 0xBC, 0xED, 0x3C, 0x84, 0xA3, 0xDA, 0x4F, 0xDD, 0xFE, 0x35, 0xFC, 0xBE, 0xB5, 0xBF, 0x71, 0xFB,
    0x2A, 0x66, 0x97, 0x28, 0xD8, 0xBF, 0xFD, 0x0D, 0x48, 0x57, 0xB2, 0xB9, 0x7F, 0x5E, 0x19, 0x7C, 0x5F, 0xEA, 0x11, 0x93, 0xD7, 0x0E,
    0xE8, 0xAF, 0xED, 0xBF, 0x32, 0xAF, 0x02, 0xF0, 0xA6, 0x9B, 0xDA, 0xEE, 0xB8, 0xC2, 0xF2, 0x3B, 0x66, 0xD6, 0x8E, 0x5B, 0xE1, 0x7B,
    0x71, 0x68, 0xDA, 0x8E, 0xDB, 0xD8, 0x7A, 0x78, 0xDC, 0xCE, 0x1D, 0x43, 0x98, 0xFD, 0xE0, 0xC9, 0xF3, 0x3B, 0x36, 0xB1, 0x79, 0xB1,
    0xCF, 0xAF, 0x3B, 0xEE, 0x60, 0xE5, 0xBC, 0xAD, 0xEF, 0xCE, 0x5A, 0xA6, 0x7F, 0x8D, 0xDC, 0xB8, 0x73, 0x33, 0x3B, 0xD3, 0xF4, 0xCE,
    0xF6, 0x7C, 0x66, 0x41, 0x1B, 0xDC, 0xEE, 0x86, 0x5D, 0x0F, 0x43, 0xBC, 0x4B, 0x95, 0xA3, 0x77, 0xDD, 0xCB, 0xEC, 0x02, 0xBF, 0xA5,
    0xEE, 0xBA, 0x89, 0xCD, 0x13, 0x9F, 0x7D, 0xBE, 0xEB, 0x53, 0x56, 0x0E, 0xDF, 0xCE, 0xBB, 0x9B, 0xD9, 0xBA, 0x70, 0xCF, 0xD0, 0xDD,
    0x6F, 0xB3, 0x71, 0x29, 0x78, 0xD2, 0x4B, 0xC3, 0xD9, 0xF8, 0xF9, 0xEB, 0xCD, 0x05, 0x37, 0x00, 0x1E, 0x3F, 0x6C, 0xE8, 0x9E, 0xFD,
    0xF0, 0xAD, 0xDB, 0xEB, 0xB7, 0x77, 0x0E, 0xE3, 0x03, 0x61, 0x28, 0xAB, 0x17, 0x08, 0x9F, 0x86, 0x70, 0xED, 0xD9, 0x35, 0x7B, 0x7B,
    0x03, 0x3D, 0x63, 0xF2, 0x7D, 0xFB, 0xBC, 0x20, 0xDE, 0x9C, 0x23, 0xAB, 0xF7, 0x75, 0x03, 0xFC, 0xAD, 0xF1, 0xA5, 0xFB, 0xB2, 0xD8,
    0x38, 0x56, 0xDB, 0xB2, 0x2F, 0x87, 0xE9, 0x37, 0xD1, 0x01, 0x85, 0x7D, 0x98, 0x9D, 0x22, 0xF6, 0xFE, 0xC2, 0x9E, 0xCC, 0xFE, 0x70,
    0x68, 0x72, 0xE1, 0x7F, 0x10, 0xBF, 0xF8, 0xD4, 0xAA, 0x42, 0x23, 0x84, 0xEF, 0x2E, 0x3B, 0x5D, 0x38, 0x98, 0xD9, 0x7F, 0x9E, 0x3F,
    0xB0, 0xFF, 0x71, 0xA0, 0xD7, 0xED, 0xE1, 0xEA, 0xFD, 0xDE, 0xCC, 0x3E, 0xD1, 0xF3, 0xA7, 0xFD, 0x11, 0xAC, 0xFE, 0xA6, 0x3F, 0x77,
    0x20, 0x09, 0x7E, 0xFF, 0x69, 0x78, 0xD8, 0xC1, 0x1D, 0x10, 0x9E, 0xCD, 0x5F, 0x79, 0xF0, 0x46, 0xB6, 0x8E, 0x0A, 0xCF, 0x3F, 0x18,
    0xCD, 0xEC, 0x1B, 0x09, 0x9F, 0x1E, 0x7C, 0x87, 0xE9, 0x45, 0x41, 0xF7, 0x15, 0x15, 0x30, 0xBD, 0x72, 0xC1, 0xB4, 0xA2, 0xE3, 0xAC,
    0xFE, 0x82, 0x1E, 0x7A, 0xF9, 0x39, 0x08, 0xF7, 0xDF, 0x39, 0xE9, 0xE5, 0x7F, 0x00, 0xEF, 0xFA, 0xE0, 0xD4, 0x97, 0xC7, 0xB3, 0xF9,
    0x67, 0x79, 0xE4, 0xCB, 0x3F, 0xB0, 0xF9, 0x7C, 0x70, 0xF3, 0xCB, 0x3D, 0x20, 0xFC, 0x62, 0xEE, 0x9D, 0x87, 0x96, 0xB0, 0xB3, 0xB2,
    0x5F, 0xF4, 0x39, 0x14, 0xC9, 0xCA, 0x9F, 0x95, 0x75, 0x68, 0x20, 0x3B, 0x5F, 0xD1, 0xF8, 0xFA, 0xA1, 0x08, 0xC8, 0xCF, 0xF2, 0x75,
    0xBB, 0x5F, 0xD9, 0x0A, 0xE9, 0xD2, 0x21, 0xDC, 0x06, 0xE1, 0x0A, 0x08, 0xB7, 0x33, 0x7D, 0x6B, 0xC6, 0xD5, 0x57, 0x2A, 0x98, 0x7D,
    0xC9, 0xA3, 0x4D, 0x71, 0x47, 0xA6, 0x77, 0x75, 0xF0, 0x2F, 0xDE, 0x03, 0xE9, 0xD3, 0xAF, 0xF6, 0x2D, 0x7E, 0x0F, 0xD2, 0x5F, 0xC9,
    0x1B, 0x57, 0x3C, 0x08, 0x70, 0xFD, 0xC8, 0x85, 0xC5, 0x97, 0xD9, 0xFC, 0x7D, 0xCB, 0xA6, 0xE2, 0x02, 0x08, 0xDF, 0xFF, 0x60, 0x73,
    0xF1, 0x39, 0x08, 0x0F, 0x5D, 0xDD, 0x5C, 0xBC, 0x90, 0xAD, 0xB7, 0xFB, 0x94, 0x15, 0x7F, 0x0B, 0xF1, 0x5E, 0x3B, 0xF4, 0xCB, 0xAB,
    0x5A, 0xA6, 0xBF, 0x0F, 0x7D, 0xFC, 0xB5, 0xD3, 0xF0, 0x3D, 0x70, 0x4D, 0xF7, 0x92, 0xF9, 0xCC, 0xDE, 0x93, 0x36, 0xB6, 0xA4, 0x8E,
    0x8D, 0xA3, 0xED, 0xA6, 0x97, 0xDC, 0xC8, 0xF4, 0xB3, 0xBB, 0x16, 0x96, 0x24, 0xC2, 0xF7, 0xE1, 0xF8, 0x1D, 0x25, 0xE1, 0x6C, 0x5E,
    0xFC, 0xDC, 0xEB, 0x0D, 0x76, 0xDE, 0x39, 0xEB, 0x78, 0xB7, 0x37, 0x8C, 0x6C, 0x7E, 0xAA, 0xEB, 0xFE, 0xC6, 0x6C, 0xF8, 0x7E, 0xE2,
    0xC7, 0xA0, 0x37, 0x2E, 0x30, 0x7D, 0xF6, 0xED, 0xD2, 0x37, 0x0E, 0xC3, 0xF7, 0xBD, 0xD3, 0x4F, 0xBC, 0xF1, 0x1B, 0x7C, 0x3F, 0xD8,
    0xE3, 0xA3, 0x37, 0x9F, 0x81, 0xEF, 0xB1, 0x10, 0x3E, 0xCB, 0xEE, 0x2C, 0x3C, 0xDE, 0xE7, 0xAD, 0x05, 0xCC, 0x5E, 0x05, 0x21, 0xB3,
    0x03, 0xAE, 0x3E, 0x9A, 0xFC, 0xD6, 0x43, 0x90, 0x8F, 0x35, 0x10, 0x3E, 0xCC, 0xE6, 0xF7, 0x17, 0xDF, 0x79, 0xEB, 0x29, 0x36, 0xEE,
    0x9E, 0xFD, 0xE7, 0xAD, 0x71, 0x10, 0x7E, 0xAC, 0xFF, 0xB5, 0x74, 0x38, 0x5B, 0xE7, 0x40, 0x38, 0x82, 0xE9, 0x73, 0xA6, 0x5F, 0x4B,
    0x83, 0x98, 0x5D, 0x67, 0xE9, 0x3F, 0xA5, 0x7F, 0x41, 0x78, 0x20, 0xBB, 0xEF, 0xE1, 0x44, 0x66, 0x1F, 0x79, 0xE4, 0xBE, 0xC3, 0xDD,
    0x21, 0xF4, 0xDD, 0x33, 0xF5, 0x70, 0x12, 0x84, 0x63, 0x96, 0xCF, 0x38, 0xBC, 0x1A, 0xF8, 0xDF, 0xF2, 0x9D, 0xE9, 0x70, 0x25, 0x1B,
    0xCF, 0x4F, 0x65, 0x1D, 0xAE, 0x61, 0xF3, 0x36, 0x84, 0x5F, 0x42, 0xF8, 0xD8, 0x6F, 0x15, 0x87, 0x7F, 0x66, 0x7A, 0x67, 0x58, 0xDA,
    0x91, 0xD7, 0xE0, 0xFB, 0xE6, 0x84, 0x9C, 0x23, 0x7F, 0xC3, 0xF7, 0xDC, 0xB7, 0xFF, 0x3A, 0xF2, 0x02, 0x84, 0x3B, 0xFB, 0xDE, 0xF3,
    0xF6, 0x1E, 0xC0, 0xDB, 0x2F, 0x33, 0xBE, 0xBD, 0x0C, 0xC2, 0x13, 0x8F, 0xD4, 0xBE, 0x1D, 0x03, 0x74, 0x47, 0x07, 0xB4, 0x29, 0xDB,
    0xC8, 0xCE, 0xDB, 0x2C, 0x0E, 0x2F, 0xDB, 0xCC, 0xD6, 0xAF, 0x93, 0x17, 0x95, 0xED, 0x87, 0xEF, 0x0A, 0x8F, 0x71, 0xFF, 0xF3, 0x84,
    0xDF, 0xEF, 0xD9, 0xB3, 0xE4, 0x7F, 0xED, 0xD9, 0x39, 0x43, 0x08, 0xD9, 0xDB, 0xA1, 0xCF, 0xFC, 0xBB, 0xFC, 0x9D, 0x7F, 0xD9, 0x3A,
    0x68, 0xFA, 0xAA, 0x77, 0x9E, 0x80, 0xDF, 0xAF, 0xFC, 0xD8, 0xF5, 0xDD, 0x87, 0x80, 0x9E, 0x61, 0x67, 0xEA, 0xBB, 0x8B, 0x20, 0x3C,
    0x56, 0xB4, 0xEE, 0xDD, 0x29, 0x4C, 0xAF, 0xBA, 0xFA, 0xE2, 0xBB, 0xF5, 0x4C, 0x0E, 0x1E, 0xCC, 0x7F, 0xF7, 0x31, 0xB6, 0xBE, 0x5F,
    0xD2, 0xC8, 0x96, 0x0B, 0x9A, 0x80, 0x21, 0x7D, 0xCA, 0xD3, 0x21, 0xFC, 0x75, 0x78, 0x9F, 0xF2, 0x15, 0x6C, 0x3E, 0x80, 0x70, 0x25,
    0x5B, 0x8F, 0x43, 0xB8, 0x0A, 0xC2, 0x9D, 0x1F, 0x8F, 0x28, 0xFF, 0x8E, 0xF5, 0x57, 0x63, 0x4C, 0x79, 0x1C, 0xB3, 0x27, 0x9C, 0x29,
    0x2E, 0xFF, 0x99, 0xE9, 0x2D, 0x8D, 0xC7, 0xCB, 0x47, 0xB0, 0xFC, 0xAD, 0x49, 0x3C, 0x7A, 0x13, 0x7C, 0xD7, 0xDF, 0x9D, 0x76, 0xF4,
    0x43, 0x08, 0xC7, 0x44, 0x7E, 0x74, 0xB4, 0x8E, 0xC9, 0xC5, 0xD2, 0xA1, 0xEF, 0x65, 0xB1, 0xF6, 0x1B, 0xDC, 0xF8, 0xDE, 0x7C, 0xE0,
    0xF7, 0xC6, 0x57, 0x53, 0x8E, 0x8D, 0x01, 0xFC, 0x4D, 0x08, 0x83, 0x21, 0xCC, 0xDA, 0x12, 0x77, 0xEC, 0x76, 0x08, 0x27, 0x8F, 0x4C,
    0x3D, 0x36, 0x9A, 0xAD, 0xCF, 0x20, 0x1C, 0x03, 0xE1, 0x2B, 0x93, 0x36, 0x1C, 0xBB, 0x1E, 0xE2, 0xDF, 0xB6, 0x62, 0xF3, 0xB1, 0xFF,
    0xB1, 0x79, 0xEE, 0xB7, 0xA2, 0x63, 0xBB, 0xD8, 0x5D, 0xE8, 0x5D, 0xED, 0x2A, 0x36, 0xC0, 0xB7, 0xDF, 0xE8, 0x81, 0xC7, 0x93, 0x99,
    0xB9, 0xE6, 0xC1, 0xF0, 0xE3, 0x51, 0x10, 0xC6, 0xCC, 0xCE, 0x3E, 0xCE, 0xF6, 0xCB, 0xFA, 0xCE, 0xCD, 0x3E, 0xCE, 0xF6, 0x67, 0x46,
    0x6D, 0x79, 0xED, 0x78, 0x39, 0xC4, 0x7B, 0x00, 0xC2, 0xA3, 0x6C, 0x1D, 0xBD, 0xF3, 0xDF, 0xE3, 0x06, 0x08, 0xE7, 0xE7, 0x8C, 0x7C,
    0xFF, 0x51, 0x08, 0xF3, 0xCB, 0xEA, 0xDE, 0x3F, 0x01, 0x7C, 0x36, 0x44, 0x16, 0x7E, 0x70, 0x96, 0xAD, 0x4F, 0x7A, 0x14, 0x7F, 0xA0,
    0x63, 0xEB, 0x89, 0x66, 0x43, 0x65, 0x30, 0xE3, 0x5B, 0x91, 0x59, 0x99, 0xCD, 0xC6, 0xE9, 0xB1, 0xFB, 0x2A, 0x27, 0xB2, 0x71, 0x68,
    0xC9, 0xF4, 0x13, 0x3D, 0x20, 0x7E, 0x5A, 0xC7, 0x13, 0x27, 0x7E, 0x60, 0xF6, 0xAB, 0x4B, 0x9D, 0x4E, 0xDE, 0xCD, 0xF4, 0x96, 0x5F,
    0x74, 0x27, 0xBF, 0x84, 0xDF, 0x3F, 0x6A, 0xD2, 0x9D, 0xFC, 0x0A, 0xC2, 0x0E, 0x47, 0xD3, 0x4F, 0xDE, 0x00, 0xF4, 0x42, 0xEE, 0xAE,
    0x3A, 0x79, 0x0F, 0xD3, 0xEB, 0x4F, 0x1E, 0xFA, 0x90, 0xED, 0x11, 0x7E, 0x17, 0x33, 0xA9, 0xEA, 0x4F, 0xA6, 0x2F, 0xF6, 0x9C, 0x5B,
    0xC5, 0xF6, 0xF0, 0x36, 0x1E, 0xEA, 0xFC, 0xD1, 0x55, 0xF8, 0x3E, 0x15, 0x13, 0xFD, 0xD1, 0xED, 0xCC, 0x3E, 0x74, 0xF0, 0xC0, 0x47,
    0x51, 0xF0, 0xFD, 0xCA, 0xC4, 0x15, 0xA7, 0x7E, 0x64, 0x7A, 0xEC, 0xB0, 0x03, 0xA7, 0x36, 0x03, 0xFD, 0x10, 0x08, 0xB7, 0x30, 0x39,
    0x82, 0x30, 0x97, 0xF5, 0x9F, 0xBC, 0x97, 0x4F, 0x95, 0x30, 0xFB, 0xE5, 0x56, 0xCD, 0xE9, 0xF6, 0xAC, 0xFE, 0x66, 0x4C, 0x3C, 0x3D,
    0x88, 0xD9, 0x57, 0x0F, 0x37, 0x9C, 0xD6, 0xB1, 0x71, 0x20, 0xE4, 0xE2, 0xE9, 0x87, 0x59, 0xBF, 0xFD, 0xF2, 0xA6, 0xEA, 0xE7, 0x98,
    0xBE, 0xF9, 0xCD, 0x4D, 0xD5, 0xCF, 0x43, 0x78, 0xCB, 0xCE, 0x7F, 0xAB, 0x2F, 0x32, 0x3D, 0xB7, 0xAE, 0xF3, 0xC7, 0xCF, 0xC2, 0xEF,
    0x03, 0xBC, 0x86, 0x7E, 0x1C, 0x0F, 0xF8, 0xE4, 0x77, 0xE6, 0x7D, 0xFC, 0x32, 0xAB, 0x77, 0x08, 0x0F, 0x41, 0x78, 0xEB, 0xA3, 0x6B,
    0x3E, 0xF6, 0x65, 0x76, 0xA1, 0xF9, 0x9D, 0x3F, 0x61, 0x37, 0x51, 0xDF, 0xF8, 0x30, 0xFB, 0x13, 0x6F, 0x0F, 0x36, 0xBE, 0x7D, 0xFB,
    0xC9, 0x49, 0x36, 0x6F, 0x74, 0xBA, 0xF0, 0xC9, 0x52, 0x08, 0xE7, 0x6B, 0x26, 0x7D, 0xDA, 0x00, 0x61, 0x8F, 0xDB, 0x4F, 0x7E, 0xFA,
    0x05, 0xDB, 0x9B, 0x3C, 0x97, 0x7A, 0x26, 0x19, 0xD2, 0x85, 0x9D, 0xDD, 0x75, 0xE6, 0x0A, 0xD3, 0xA3, 0x4F, 0x5E, 0xF8, 0xEC, 0x25,
    0x61, 0x7C, 0xDF, 0xF2, 0xF9, 0x41, 0x08, 0x8F, 0x1C, 0xEF, 0xFA, 0xC5, 0x7D, 0x6C, 0xBE, 0x9C, 0x7B, 0xEA, 0x8B, 0xE5, 0x10, 0xFF,
    0xFC, 0xAD, 0x7E, 0x35, 0x6F, 0x31, 0xBD, 0x0A, 0xC2, 0x52, 0xA6, 0xA7, 0x9D, 0x98, 0x51, 0xF3, 0x35, 0x1B, 0x2F, 0xC6, 0xAC, 0xAE,
    0xD9, 0x02, 0xBF, 0xBF, 0x0E, 0x61, 0x2E, 0x93, 0xE7, 0x2B, 0x2F, 0xD6, 0xB0, 0xB7, 0xE1, 0x8D, 0x6B, 0xC7, 0x7D, 0x79, 0x90, 0xE9,
    0x31, 0x6D, 0x16, 0x7D, 0xD9, 0x09, 0xC2, 0xCF, 0x27, 0xFF, 0xF9, 0xE5, 0x5D, 0xCC, 0xCE, 0xB4, 0x7E, 0xEE, 0x57, 0xEF, 0x41, 0xFA,
    0x5D, 0x39, 0x37, 0x7E, 0x5D, 0xCA, 0xE4, 0x76, 0xC0, 0xEC, 0xAF, 0xEF, 0x85, 0xF0, 0xFA, 0x1E, 0x37, 0xD4, 0xBE, 0xCC, 0xEC, 0xD4,
    0x99, 0xFE, 0xB5, 0x99, 0xCC, 0x0E, 0x79, 0xE5, 0xAE, 0xDA, 0x57, 0x21, 0x5E, 0xE8, 0xD1, 0xA7, 0x6B, 0x1B, 0x59, 0x7B, 0x2E, 0x7E,
    0xBB, 0x56, 0x0F, 0xDF, 0xBD, 0xCF, 0x77, 0xFF, 0x26, 0x85, 0xCD, 0x9B, 0xA1, 0x15, 0xDF, 0x3C, 0x08, 0xDF, 0x2B, 0x2E, 0xD7, 0x7E,
    0xF3, 0x19, 0x5B, 0x6F, 0xF9, 0x77, 0xFD, 0x76, 0x30, 0xD0, 0xEF, 0xB4, 0xD5, 0xFF, 0xDB, 0xDB, 0x20, 0xBC, 0xA9, 0x34, 0xE3, 0xDB,
    0xCE, 0xAC, 0x1D, 0x82, 0x6F, 0xF9, 0xEE, 0x7B, 0xB6, 0xBE, 0x38, 0xF8, 0xE1, 0x77, 0x6D, 0xD9, 0x3A, 0xAC, 0xED, 0x03, 0x75, 0xF7,
    0xC1, 0xF7, 0xA0, 0x29, 0x31, 0x75, 0xC9, 0xF0, 0x3D, 0xE2, 0xFB, 0xD4, 0xBA, 0xA5, 0xCC, 0x2E, 0xFC, 0x45, 0x49, 0xDD, 0x1B, 0x80,
    0xFF, 0xB5, 0xE1, 0xAD, 0xBA, 0x40, 0x48, 0xBF, 0xED, 0xF3, 0xF7, 0xEA, 0xFA, 0xC1, 0xEF, 0xFF, 0xDD, 0xDC, 0xE7, 0xAC, 0x81, 0xD9,
    0x4D, 0x37, 0x4F, 0x38, 0xAB, 0x01, 0x3C, 0x71, 0xF4, 0xF7, 0xDF, 0x7F, 0xC6, 0xF2, 0xF7, 0x5D, 0xF7, 0x73, 0x1F, 0x41, 0xBA, 0x9B,
    0x3A, 0x8C, 0x3E, 0x97, 0xCD, 0xC6, 0xCF, 0xFA, 0x2D, 0xE7, 0x4A, 0xD8, 0x7A, 0x7D, 0xC1, 0x8E, 0x73, 0x9F, 0x33, 0xFB, 0x6E, 0x6A,
    0xD5, 0xB9, 0x9B, 0x20, 0x5C, 0x91, 0x3C, 0xBB, 0x9E, 0xF9, 0xC4, 0x3E, 0x7A, 0xDB, 0xD1, 0xFA, 0xAE, 0x6C, 0xFD, 0x7C, 0x68, 0xCB,
    0x0F, 0xC1, 0xF0, 0xFD, 0x15, 0x84, 0x0F, 0xB2, 0xF1, 0x2F, 0xED, 0xDC, 0x0F, 0x2F, 0x00, 0xFE, 0x43, 0xBA, 0xF7, 0x8F, 0xED, 0x20,
    0xBC, 0xED, 0xF3, 0xC9, 0x3F, 0x6E, 0x03, 0x3A, 0x83, 0xFE, 0x7E, 0xF3, 0x47, 0x0F, 0x08, 0x17, 0xCD, 0xF9, 0xF1, 0x47, 0x1D, 0xF0,
    0xDD, 0xAA, 0xBF, 0xEE, 0xFC, 0x6C, 0x36, 0xEE, 0xDC, 0xDD, 0xF7, 0x7C, 0x1B, 0x26, 0x77, 0x37, 0x07, 0x9C, 0xBF, 0x8E, 0xE9, 0x1F,
    0xBA, 0x87, 0xCE, 0xF7, 0x87, 0xDF, 0x73, 0x6E, 0x7E, 0xEB, 0xFC, 0x9B, 0xCC, 0x7E, 0x7C, 0xEB, 0x5B, 0xE7, 0xDF, 0x62, 0xF3, 0x5E,
    0xCC, 0x57, 0xE7, 0xF7, 0x42, 0x7C, 0x4F, 0x08, 0xF7, 0x41, 0xD8, 0x16, 0xC2, 0x42, 0x08, 0xAF, 0x87, 0x70, 0x3F, 0x84, 0x37, 0x40,
    0x78, 0x00, 0xC2, 0x47, 0x57, 0x7E, 0x73, 0xBE, 0x82, 0xE9, 0x8F, 0x1B, 0xAF, 0x9E, 0x5F, 0xC7, 0xD6, 0xC7, 0x9F, 0xFC, 0xDA, 0xF0,
    0x0B, 0xA3, 0xFF, 0xD2, 0xEC, 0x9F, 0xE6, 0xC1, 0xEF, 0x87, 0xFF, 0x58, 0xF3, 0x53, 0x0A, 0x84, 0x37, 0xB6, 0x7D, 0xE9, 0xA7, 0xC5,
    0x10, 0x2E, 0x6C, 0xFB, 0xC1, 0x4F, 0x97, 0x21, 0x3C, 0xF7, 0xDB, 0xE6, 0x9F, 0x27, 0x40, 0xBC, 0x2F, 0xBD, 0xB7, 0xFC, 0xBC, 0x08,
    0xF8, 0x4F, 0xDD, 0x5D, 0xFE, 0xF3, 0x0A, 0x66, 0x17, 0x5B, 0x74, 0xE3, 0x85, 0x08, 0xA0, 0x73, 0x11, 0xC2, 0x48, 0x66, 0x2F, 0x5E,
    0xF5, 0xC8, 0x85, 0x78, 0x36, 0xAE, 0xE8, 0x1E, 0xBB, 0xF0, 0x14, 0x9B, 0x1F, 0x8F, 0x3C, 0x7E, 0xE1, 0x18, 0xCB, 0xDF, 0xCE, 0x53,
    0x17, 0x0E, 0xB1, 0x76, 0xDC, 0xF7, 0x61, 0xA3, 0x9E, 0xC9, 0xE7, 0x96, 0x8F, 0x1B, 0x87, 0x31, 0xBD, 0xF3, 0x07, 0xCF, 0x5F, 0x16,
    0x32, 0x7F, 0xCB, 0xEB, 0x83, 0x7E, 0xF9, 0x9D, 0xAD, 0x53, 0x27, 0x24, 0xFE, 0xF2, 0x18, 0x84, 0x37, 0x7E, 0x73, 0xE2, 0x97, 0xBF,
    0x20, 0xDE, 0xEB, 0x91, 0xB5, 0xBF, 0xA4, 0xC0, 0x77, 0x66, 0x6E, 0xFB, 0x8B, 0x6B, 0xD8, 0x38, 0x0A, 0xE1, 0x5A, 0xA6, 0x07, 0x77,
    0xED, 0x7E, 0x71, 0x3A, 0xFC, 0x3E, 0xED, 0xEB, 0xAC, 0x8B, 0x5E, 0xAC, 0x9D, 0xEE, 0xDD, 0x73, 0xD1, 0x0F, 0xC2, 0x6F, 0xFF, 0x7D,
    0xF5, 0xE2, 0x34, 0x26, 0x3F, 0xDE, 0x67, 0x2F, 0x2E, 0x60, 0x76, 0xCA, 0x77, 0xEE, 0xBC, 0xF4, 0x2F, 0x84, 0x17, 0x0A, 0xEA, 0x2E,
    0x3D, 0x0F, 0xE1, 0xEA, 0x98, 0xA3, 0x4D, 0xAF, 0xB2, 0xFC, 0x2C, 0x3D, 0xDB, 0x14, 0x0A, 0xDF, 0x95, 0xC7, 0xEA, 0x9B, 0xC2, 0xE0,
    0x7B, 0xD6, 0xE6, 0x35, 0xBF, 0x36, 0xC3, 0xF7, 0x02, 0x6F, 0x9F, 0xDF, 0x12, 0xD8, 0x1D, 0xEA, 0xD7, 0x73, 0x7E, 0x4B, 0x62, 0xF6,
    0xB2, 0x15, 0x37, 0xFC, 0x3E, 0x9B, 0xAD, 0x6F, 0xFF, 0x18, 0xF2, 0x7B, 0x35, 0xFC, 0x7E, 0x57, 0xCE, 0x63, 0xBF, 0xDF, 0x0C, 0xDF,
    0x23, 0x3B, 0xE9, 0x7F, 0xCF, 0x61, 0xE6, 0xDE, 0x73, 0x57, 0x7F, 0x67, 0x3B, 0xDD, 0x59, 0xE7, 0xAF, 0xFE, 0xCE, 0x6E, 0x60, 0xFA,
    0xAE, 0x99, 0x7C, 0xB9, 0x9E, 0xC5, 0x3B, 0x55, 0x76, 0x79, 0x1E, 0x84, 0x33, 0xAA, 0xCE, 0x5E, 0x3E, 0x0B, 0x74, 0xBE, 0xA8, 0x7E,
    0xE0, 0x8F, 0xF9, 0xF0, 0xBD, 0xB4, 0xE2, 0xE8, 0x1F, 0x77, 0x30, 0xBD, 0x19, 0xC2, 0x1E, 0x6C, 0xFD, 0x1E, 0x7C, 0xE1, 0x8F, 0xBB,
    0x81, 0xDE, 0x47, 0x10, 0xDE, 0x03, 0xE1, 0xA0, 0xD3, 0xFF, 0xFE, 0x31, 0x11, 0xE2, 0x1F, 0x7D, 0x6B, 0xE6, 0x95, 0x68, 0xF8, 0xBE,
    0x57, 0x77, 0xE9, 0x4A, 0x1E, 0xB3, 0x5B, 0xAC, 0xE8, 0xF4, 0xE7, 0x77, 0xAC, 0xBF, 0x77, 0x8F, 0x6E, 0x1E, 0xCA, 0xD6, 0x33, 0xFA,
    0x8A, 0xE6, 0xC5, 0xCC, 0x8E, 0x77, 0xF1, 0x78, 0xB3, 0x1F, 0xD3, 0xAB, 0x8E, 0xDE, 0xF8, 0xD7, 0x5D, 0x4C, 0x9E, 0x7E, 0xE9, 0xF5,
    0xD7, 0x9B, 0x10, 0x9E, 0x2F, 0xD1, 0xFD, 0xD5, 0x99, 0xF5, 0x5F, 0x08, 0xBB, 0xB0, 0xFE, 0xB7, 0xEF, 0xB7, 0xBF, 0x22, 0xD8, 0x3C,
    0xF8, 0x85, 0xE7, 0xDF, 0xDB, 0x99, 0xBE, 0x7D, 0xA5, 0xF3, 0xDF, 0x07, 0x98, 0x1D, 0xA3, 0x3C, 0xF0, 0xEF, 0x73, 0x6C, 0xBD, 0xF1,
    0xD6, 0xF9, 0xBF, 0xFD, 0x99, 0x5E, 0x35, 0x75, 0xEC, 0x3F, 0x8D, 0xF0, 0xFB, 0xE7, 0x0B, 0x67, 0xFF, 0x33, 0x83, 0xE9, 0xFF, 0x87,
    0x0A, 0xFF, 0x19, 0xC1, 0xC6, 0x8D, 0xD0, 0xC9, 0x2D, 0x97, 0x00, 0x7F, 0x68, 0xC7, 0x91, 0x16, 0x4F, 0x36, 0x5E, 0x2F, 0xF9, 0xAB,
    0xE5, 0x27, 0x48, 0xFF, 0x5C, 0xC9, 0xC8, 0x7F, 0x2F, 0xB0, 0x7E, 0x74, 0xF8, 0xD5, 0x7F, 0x83, 0x99, 0x1D, 0xA5, 0xE3, 0xD6, 0xFF,
    0x1E, 0x60, 0xF3, 0x01, 0x84, 0xA3, 0x21, 0x1C, 0x79, 0x74, 0xEB, 0x7F, 0xFE, 0x6C, 0xBD, 0x13, 0x50, 0xF2, 0xDF, 0xE3, 0x4C, 0x8E,
    0x8E, 0x7F, 0xF2, 0xDF, 0x70, 0x08, 0xFF, 0x1F, 0x71, 0xE8, 0x12, 0x7F,
};

```

`src/windows-emulator/cpu_context.cpp`:

```cpp
#include "std_include.hpp"
#include "cpu_context.hpp"

namespace cpu_context
{
    void restore(x86_64_emulator& emu, const CONTEXT64& context)
    {
        if ((context.ContextFlags & CONTEXT_DEBUG_REGISTERS_64) == CONTEXT_DEBUG_REGISTERS_64)
        {
            emu.reg(x86_register::dr0, context.Dr0);
            emu.reg(x86_register::dr1, context.Dr1);
            emu.reg(x86_register::dr2, context.Dr2);
            emu.reg(x86_register::dr3, context.Dr3);
            emu.reg(x86_register::dr6, context.Dr6);
            emu.reg(x86_register::dr7, context.Dr7);
        }

        if ((context.ContextFlags & CONTEXT_CONTROL_64) == CONTEXT_CONTROL_64)
        {
            emu.reg<uint16_t>(x86_register::ss, context.SegSs);
            emu.reg<uint16_t>(x86_register::cs, context.SegCs);

            emu.reg(x86_register::rip, context.Rip);
            emu.reg(x86_register::rsp, context.Rsp);

            emu.reg<uint32_t>(x86_register::eflags, context.EFlags);
        }

        if ((context.ContextFlags & CONTEXT_INTEGER_64) == CONTEXT_INTEGER_64)
        {
            emu.reg(x86_register::rax, context.Rax);
            emu.reg(x86_register::rbx, context.Rbx);
            emu.reg(x86_register::rcx, context.Rcx);
            emu.reg(x86_register::rdx, context.Rdx);
            emu.reg(x86_register::rbp, context.Rbp);
            emu.reg(x86_register::rsi, context.Rsi);
            emu.reg(x86_register::rdi, context.Rdi);
            emu.reg(x86_register::r8, context.R8);
            emu.reg(x86_register::r9, context.R9);
            emu.reg(x86_register::r10, context.R10);
            emu.reg(x86_register::r11, context.R11);
            emu.reg(x86_register::r12, context.R12);
            emu.reg(x86_register::r13, context.R13);
            emu.reg(x86_register::r14, context.R14);
            emu.reg(x86_register::r15, context.R15);
        }

        /*if ((context.ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS)
        {
            emu.reg<uint16_t>(x86_register::ds, context.SegDs);
            emu.reg<uint16_t>(x86_register::es, context.SegEs);
            emu.reg<uint16_t>(x86_register::fs, context.SegFs);
            emu.reg<uint16_t>(x86_register::gs, context.SegGs);
        }*/

        if ((context.ContextFlags & CONTEXT_FLOATING_POINT_64) == CONTEXT_FLOATING_POINT_64)
        {
            emu.reg<uint16_t>(x86_register::fpcw, context.FltSave.ControlWord);
            emu.reg<uint16_t>(x86_register::fpsw, context.FltSave.StatusWord);
            emu.reg<uint16_t>(x86_register::fptag, context.FltSave.TagWord);

            for (int i = 0; i < 8; i++)
            {
                const auto reg = static_cast<x86_register>(static_cast<int>(x86_register::st0) + i);
                emu.reg<M128A>(reg, context.FltSave.FloatRegisters[i]);
            }
        }

        if ((context.ContextFlags & CONTEXT_XSTATE_64) == CONTEXT_XSTATE_64)
        {
            emu.reg<uint32_t>(x86_register::mxcsr, context.MxCsr);

            for (int i = 0; i < 16; i++)
            {
                const auto reg = static_cast<x86_register>(static_cast<int>(x86_register::xmm0) + i);
                emu.reg<M128A>(reg, (&context.Xmm0)[i]);
            }
        }
    }

    void save(x86_64_emulator& emu, CONTEXT64& context)
    {
        if ((context.ContextFlags & CONTEXT_DEBUG_REGISTERS_64) == CONTEXT_DEBUG_REGISTERS_64)
        {
            context.Dr0 = emu.reg(x86_register::dr0);
            context.Dr1 = emu.reg(x86_register::dr1);
            context.Dr2 = emu.reg(x86_register::dr2);
            context.Dr3 = emu.reg(x86_register::dr3);
            context.Dr6 = emu.reg(x86_register::dr6);
            context.Dr7 = emu.reg(x86_register::dr7);
        }

        if ((context.ContextFlags & CONTEXT_CONTROL_64) == CONTEXT_CONTROL_64)
        {
            context.SegSs = emu.reg<uint16_t>(x86_register::ss);
            context.SegCs = emu.reg<uint16_t>(x86_register::cs);
            context.Rip = emu.reg(x86_register::rip);
            context.Rsp = emu.reg(x86_register::rsp);
            context.EFlags = emu.reg<uint32_t>(x86_register::eflags);
        }

        if ((context.ContextFlags & CONTEXT_INTEGER_64) == CONTEXT_INTEGER_64)
        {
            context.Rax = emu.reg(x86_register::rax);
            context.Rbx = emu.reg(x86_register::rbx);
            context.Rcx = emu.reg(x86_register::rcx);
            context.Rdx = emu.reg(x86_register::rdx);
            context.Rbp = emu.reg(x86_register::rbp);
            context.Rsi = emu.reg(x86_register::rsi);
            context.Rdi = emu.reg(x86_register::rdi);
            context.R8 = emu.reg(x86_register::r8);
            context.R9 = emu.reg(x86_register::r9);
            context.R10 = emu.reg(x86_register::r10);
            context.R11 = emu.reg(x86_register::r11);
            context.R12 = emu.reg(x86_register::r12);
            context.R13 = emu.reg(x86_register::r13);
            context.R14 = emu.reg(x86_register::r14);
            context.R15 = emu.reg(x86_register::r15);
        }

        if ((context.ContextFlags & CONTEXT_SEGMENTS_64) == CONTEXT_SEGMENTS_64)
        {
            context.SegDs = emu.reg<uint16_t>(x86_register::ds);
            context.SegEs = emu.reg<uint16_t>(x86_register::es);
            context.SegFs = emu.reg<uint16_t>(x86_register::fs);
            context.SegGs = emu.reg<uint16_t>(x86_register::gs);
        }

        if ((context.ContextFlags & CONTEXT_FLOATING_POINT_64) == CONTEXT_FLOATING_POINT_64)
        {
            context.FltSave.ControlWord = emu.reg<uint16_t>(x86_register::fpcw);
            context.FltSave.StatusWord = emu.reg<uint16_t>(x86_register::fpsw);
            context.FltSave.TagWord = static_cast<BYTE>(emu.reg<uint16_t>(x86_register::fptag));
            for (int i = 0; i < 8; i++)
            {
                const auto reg = static_cast<x86_register>(static_cast<int>(x86_register::st0) + i);
                context.FltSave.FloatRegisters[i] = emu.reg<M128A>(reg);
            }
        }

        if ((context.ContextFlags & CONTEXT_INTEGER_64) == CONTEXT_INTEGER_64)
        {
            context.MxCsr = emu.reg<uint32_t>(x86_register::mxcsr);
            for (int i = 0; i < 16; i++)
            {
                const auto reg = static_cast<x86_register>(static_cast<int>(x86_register::xmm0) + i);
                (&context.Xmm0)[i] = emu.reg<M128A>(reg);
            }
        }
    }
}

```

`src/windows-emulator/cpu_context.hpp`:

```hpp
#pragma once
#include "arch_emulator.hpp"

namespace cpu_context
{
    void save(x86_64_emulator& emu, CONTEXT64& context);
    void restore(x86_64_emulator& emu, const CONTEXT64& context);
}

```

`src/windows-emulator/devices/afd_endpoint.cpp`:

```cpp
#include "../std_include.hpp"
#include "afd_endpoint.hpp"
#include "afd_types.hpp"

#include "../windows_emulator.hpp"
#include "../network/socket_factory.hpp"

#include <network/address.hpp>
#include <network/socket.hpp>

#include <utils/finally.hpp>
#include <utils/time.hpp>

namespace
{
    // NOLINTBEGIN(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

    struct afd_creation_data
    {
        uint64_t unk1;
        char afd_open_packet_xx[0x10];
        uint64_t unk2;
        int address_family;
        int type;
        int protocol;
        // ...
    };

    struct win_sockaddr
    {
        int16_t sa_family;
        uint8_t sa_data[14];
    };

    struct win_sockaddr_in
    {
        int16_t sin_family;
        uint16_t sin_port;
        in_addr sin_addr;
        uint8_t sin_zero[8];
    };

    struct win_sockaddr_in6
    {
        int16_t sin6_family;
        uint16_t sin6_port;
        uint32_t sin6_flowinfo;
        in6_addr sin6_addr;
        uint32_t sin6_scope_id;
    };

    // NOLINTEND(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

    static_assert(sizeof(win_sockaddr) == 16);
    static_assert(sizeof(win_sockaddr_in) == 16);
    static_assert(sizeof(win_sockaddr_in6) == 28);

    static_assert(sizeof(win_sockaddr_in::sin_addr) == 4);
    static_assert(sizeof(win_sockaddr_in6::sin6_addr) == 16);
    static_assert(sizeof(win_sockaddr_in6::sin6_flowinfo) == sizeof(sockaddr_in6::sin6_flowinfo));
    static_assert(sizeof(win_sockaddr_in6::sin6_scope_id) == sizeof(sockaddr_in6::sin6_scope_id));

    const std::map<int, int> address_family_map{
        {0, AF_UNSPEC}, //
        {2, AF_INET},   //
        {23, AF_INET6}, //
    };

    const std::map<int, int> socket_type_map{
        {0, 0},           //
        {1, SOCK_STREAM}, //
        {2, SOCK_DGRAM},  //
        {3, SOCK_RAW},    //
        {4, SOCK_RDM},    //
    };

    const std::map<int, int> socket_protocol_map{
        {0, 0},             //
        {6, IPPROTO_TCP},   //
        {17, IPPROTO_UDP},  //
        {255, IPPROTO_RAW}, //
    };

    int16_t translate_host_to_win_address_family(const int host_af)
    {
        for (const auto& entry : address_family_map)
        {
            if (entry.second == host_af)
            {
                return static_cast<int16_t>(entry.first);
            }
        }

        throw std::runtime_error("Unknown host address family: " + std::to_string(host_af));
    }

    int translate_win_to_host_address_family(const int win_af)
    {
        const auto entry = address_family_map.find(win_af);
        if (entry != address_family_map.end())
        {
            return entry->second;
        }

        throw std::runtime_error("Unknown address family: " + std::to_string(win_af));
    }

    int translate_win_to_host_type(const int win_type)
    {
        const auto entry = socket_type_map.find(win_type);
        if (entry != socket_type_map.end())
        {
            return entry->second;
        }

        throw std::runtime_error("Unknown socket type: " + std::to_string(win_type));
    }

    int translate_win_to_host_protocol(const int win_protocol)
    {
        const auto entry = socket_protocol_map.find(win_protocol);
        if (entry != socket_protocol_map.end())
        {
            return entry->second;
        }

        throw std::runtime_error("Unknown socket protocol: " + std::to_string(win_protocol));
    }

    std::vector<std::byte> convert_to_win_address(const windows_emulator& win_emu, const network::address& a)
    {
        if (a.is_ipv4())
        {
            win_sockaddr_in win_addr{};
            win_addr.sin_family = translate_host_to_win_address_family(a.get_family());
            win_addr.sin_port = htons(win_emu.get_emulator_port(a.get_port()));
            memcpy(&win_addr.sin_addr, &a.get_in_addr().sin_addr, sizeof(win_addr.sin_addr));

            const auto* ptr = reinterpret_cast<std::byte*>(&win_addr);
            return {ptr, ptr + sizeof(win_addr)};
        }

        if (a.is_ipv6())
        {
            win_sockaddr_in6 win_addr{};
            win_addr.sin6_family = translate_host_to_win_address_family(a.get_family());
            win_addr.sin6_port = htons(win_emu.get_emulator_port(a.get_port()));

            const auto& addr = a.get_in6_addr();
            memcpy(&win_addr.sin6_addr, &addr.sin6_addr, sizeof(win_addr.sin6_addr));
            win_addr.sin6_flowinfo = addr.sin6_flowinfo;
            win_addr.sin6_scope_id = addr.sin6_scope_id;

            const auto* ptr = reinterpret_cast<std::byte*>(&win_addr);
            return {ptr, ptr + sizeof(win_addr)};
        }

        throw std::runtime_error("Unsupported host address family for conversion: " + std::to_string(a.get_family()));
    }

    network::address convert_to_host_address(const windows_emulator& win_emu, const std::span<const std::byte> data)
    {
        if (data.size() < sizeof(win_sockaddr))
        {
            throw std::runtime_error("Bad address size");
        }

        win_sockaddr win_addr{};
        memcpy(&win_addr, data.data(), sizeof(win_addr));

        const auto family = translate_win_to_host_address_family(win_addr.sa_family);

        network::address a{};

        if (family == AF_INET)
        {
            if (data.size() < sizeof(win_sockaddr_in))
            {
                throw std::runtime_error("Bad IPv4 address size");
            }

            win_sockaddr_in win_addr4{};
            memcpy(&win_addr4, data.data(), sizeof(win_addr4));

            a.set_ipv4(win_addr4.sin_addr);
            a.set_port(win_emu.get_host_port(ntohs(win_addr4.sin_port)));

            return a;
        }

        if (family == AF_INET6)
        {
            if (data.size() < sizeof(win_sockaddr_in6))
            {
                throw std::runtime_error("Bad IPv6 address size");
            }

            win_sockaddr_in6 win_addr6{};
            memcpy(&win_addr6, data.data(), sizeof(win_addr6));

            a.set_ipv6(win_addr6.sin6_addr);
            a.set_port(ntohs(win_addr6.sin6_port));

            auto& addr = a.get_in6_addr();
            addr.sin6_flowinfo = win_addr6.sin6_flowinfo;
            addr.sin6_scope_id = win_addr6.sin6_scope_id;

            return a;
        }

        throw std::runtime_error("Unsupported win address family for conversion: " + std::to_string(family));
    }

    afd_creation_data get_creation_data(windows_emulator& win_emu, const io_device_creation_data& data)
    {
        if (!data.buffer || data.length < sizeof(afd_creation_data))
        {
            throw std::runtime_error("Bad AFD creation data");
        }

        return win_emu.emu().read_memory<afd_creation_data>(data.buffer);
    }

    std::pair<AFD_POLL_INFO64, std::vector<AFD_POLL_HANDLE_INFO64>> get_poll_info(windows_emulator& win_emu, const io_device_context& c)
    {
        constexpr auto info_size = offsetof(AFD_POLL_INFO64, Handles);
        if (!c.input_buffer || c.input_buffer_length < info_size || c.input_buffer != c.output_buffer)
        {
            throw std::runtime_error("Bad AFD poll data");
        }

        AFD_POLL_INFO64 poll_info{};
        win_emu.emu().read_memory(c.input_buffer, &poll_info, info_size);

        std::vector<AFD_POLL_HANDLE_INFO64> handle_info{};

        const emulator_object<AFD_POLL_HANDLE_INFO64> handle_info_obj{win_emu.emu(), c.input_buffer + info_size};

        if (c.input_buffer_length < (info_size + sizeof(AFD_POLL_HANDLE_INFO64) * poll_info.NumberOfHandles))
        {
            throw std::runtime_error("Bad AFD poll handle data");
        }

        for (ULONG i = 0; i < poll_info.NumberOfHandles; ++i)
        {
            handle_info.emplace_back(handle_info_obj.read(i));
        }

        return {poll_info, std::move(handle_info)};
    }

    int16_t map_afd_request_events_to_socket(const ULONG poll_events)
    {
        int16_t socket_events{};

        if (poll_events & (AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT | AFD_POLL_RECEIVE))
        {
            socket_events |= POLLRDNORM;
        }

        if (poll_events & AFD_POLL_RECEIVE_EXPEDITED)
        {
            socket_events |= POLLRDBAND;
        }

        if (poll_events & (AFD_POLL_CONNECT | AFD_POLL_CONNECT_FAIL | AFD_POLL_SEND))
        {
            socket_events |= POLLWRNORM;
        }

        return socket_events;
    }

    ULONG map_socket_response_events_to_afd(const int16_t socket_events, const ULONG afd_poll_events, const bool is_listening,
                                            const bool is_connecting)
    {
        ULONG afd_events = 0;

        if (socket_events & POLLRDNORM)
        {
            if (!is_listening && afd_poll_events & AFD_POLL_RECEIVE)
            {
                afd_events |= AFD_POLL_RECEIVE;
            }
            else if (is_listening && afd_poll_events & AFD_POLL_ACCEPT)
            {
                afd_events |= AFD_POLL_ACCEPT;
            }
        }

        if (socket_events & POLLRDBAND && afd_poll_events & AFD_POLL_RECEIVE_EXPEDITED)
        {
            afd_events |= AFD_POLL_RECEIVE_EXPEDITED;
        }

        if (socket_events & POLLWRNORM)
        {
            if (!is_connecting && afd_poll_events & AFD_POLL_SEND)
            {
                afd_events |= AFD_POLL_SEND;
            }
            else if (is_connecting && afd_poll_events & AFD_POLL_CONNECT)
            {
                afd_events |= AFD_POLL_CONNECT;
            }
        }

        if ((socket_events & (POLLHUP | POLLERR)) == (POLLHUP | POLLERR) && afd_poll_events & (AFD_POLL_CONNECT_FAIL | AFD_POLL_ABORT))
        {
            afd_events |= (AFD_POLL_CONNECT_FAIL | AFD_POLL_ABORT);
        }
        else if (socket_events & POLLHUP && afd_poll_events & AFD_POLL_DISCONNECT)
        {
            afd_events |= AFD_POLL_DISCONNECT;
        }

        if (socket_events & POLLNVAL && afd_poll_events & AFD_POLL_LOCAL_CLOSE)
        {
            afd_events |= AFD_POLL_LOCAL_CLOSE;
        }

        return afd_events;
    }

    struct afd_endpoint : io_device
    {
        struct pending_connection
        {
            network::address remote_address;
            std::unique_ptr<network::i_socket> accepted_socket;
        };

        std::unique_ptr<network::i_socket> s_{};

        bool executing_delayed_ioctl_{};
        std::optional<afd_creation_data> creation_data{};
        std::optional<bool> require_poll_{};
        std::optional<io_device_context> delayed_ioctl_{};
        std::optional<std::chrono::steady_clock::time_point> timeout_{};
        std::optional<std::function<void(windows_emulator&, const io_device_context&)>> timeout_callback_{};

        std::unordered_map<LONG, pending_connection> pending_connections_{};
        LONG next_sequence_{0};

        std::optional<handle> event_select_event_{};
        ULONG event_select_mask_{0};
        ULONG triggered_events_{0};

        afd_endpoint()
        {
            network::initialize_wsa();
        }

        afd_endpoint(afd_endpoint&&) = delete;
        afd_endpoint& operator=(afd_endpoint&&) = delete;

        ~afd_endpoint() override = default;

        void create(windows_emulator& win_emu, const io_device_creation_data& data) override
        {
            this->creation_data = get_creation_data(win_emu, data);
            this->setup(win_emu.socket_factory());
        }

        void setup(network::socket_factory& factory)
        {
            if (!this->creation_data)
            {
                return;
            }

            const auto& data = *this->creation_data;

            const auto af = translate_win_to_host_address_family(data.address_family);
            const auto type = translate_win_to_host_type(data.type);
            const auto protocol = translate_win_to_host_protocol(data.protocol);

            this->s_ = factory.create_socket(af, type, protocol);
            if (!this->s_)
            {
                throw std::runtime_error("Failed to create socket!");
            }

            this->s_->set_blocking(false);
        }

        void delay_ioctrl(const io_device_context& c, const std::optional<bool> require_poll = {},
                          const std::optional<std::chrono::steady_clock::time_point> timeout = {},
                          const std::optional<std::function<void(windows_emulator&, const io_device_context&)>>& timeout_callback = {})
        {
            if (this->executing_delayed_ioctl_)
            {
                return;
            }

            this->timeout_callback_ = timeout_callback;
            this->timeout_ = timeout;
            this->require_poll_ = require_poll;
            this->delayed_ioctl_ = c;
        }

        void clear_pending_state()
        {
            this->timeout_callback_ = {};
            this->timeout_ = {};
            this->require_poll_ = {};
            this->delayed_ioctl_ = {};
        }

        void work(windows_emulator& win_emu) override
        {
            if (!this->s_ || (!this->delayed_ioctl_ && !this->event_select_mask_))
            {
                return;
            }

            network::poll_entry pfd{};
            pfd.s = this->s_.get();

            if (this->delayed_ioctl_ && this->require_poll_.has_value())
            {
                pfd.events |= *this->require_poll_ ? POLLIN : POLLOUT;
            }
            if (this->event_select_mask_)
            {
                pfd.events = static_cast<int16_t>(pfd.events | map_afd_request_events_to_socket(this->event_select_mask_));
            }
            pfd.revents = pfd.events;

            if (pfd.events != 0)
            {
                win_emu.socket_factory().poll_sockets(std::span{&pfd, 1});
            }

            const auto socket_events = pfd.revents;

            if (socket_events && this->event_select_mask_)
            {
                const bool is_connecting = this->delayed_ioctl_ && _AFD_REQUEST(this->delayed_ioctl_->io_control_code) == AFD_CONNECT;
                ULONG current_events =
                    map_socket_response_events_to_afd(socket_events, this->event_select_mask_, pfd.s->is_listening(), is_connecting);

                if ((current_events & ~this->triggered_events_) != 0)
                {
                    this->triggered_events_ |= current_events;

                    if (auto* event = win_emu.process.events.get(*this->event_select_event_))
                    {
                        event->signaled = true;
                    }
                }
            }

            if (this->delayed_ioctl_)
            {
                this->executing_delayed_ioctl_ = true;
                const auto _ = utils::finally([&] { this->executing_delayed_ioctl_ = false; });

                if (this->require_poll_.has_value())
                {
                    const auto is_ready = socket_events & ((*this->require_poll_ ? POLLIN : POLLOUT) | POLLHUP | POLLERR);
                    if (!is_ready)
                    {
                        return;
                    }
                }

                const auto status = this->execute_ioctl(win_emu, *this->delayed_ioctl_);
                if (status == STATUS_PENDING)
                {
                    if (!this->timeout_ || this->timeout_ > win_emu.clock().steady_now())
                    {
                        return;
                    }

                    write_io_status(this->delayed_ioctl_->io_status_block, STATUS_TIMEOUT);

                    if (this->timeout_callback_)
                    {
                        (*this->timeout_callback_)(win_emu, *this->delayed_ioctl_);
                    }
                }

                auto* e = win_emu.process.events.get(this->delayed_ioctl_->event);
                if (e)
                {
                    e->signaled = true;
                }

                this->clear_pending_state();
            }
        }

        void deserialize_object(utils::buffer_deserializer& buffer) override
        {
            buffer.read_optional(this->creation_data);
            this->setup(buffer.read<socket_factory_wrapper>());

            buffer.read_optional(this->require_poll_);
            buffer.read_optional(this->delayed_ioctl_);
            buffer.read_optional(this->timeout_);
        }

        void serialize_object(utils::buffer_serializer& buffer) const override
        {
            buffer.write_optional(this->creation_data);
            buffer.write_optional(this->require_poll_);
            buffer.write_optional(this->delayed_ioctl_);
            buffer.write_optional(this->timeout_);
        }

        NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& c) override
        {
            if (_AFD_BASE(c.io_control_code) != FSCTL_AFD_BASE)
            {
                win_emu.log.error("Bad AFD IOCTL: 0x%X\n", static_cast<uint32_t>(c.io_control_code));
                return STATUS_NOT_SUPPORTED;
            }

            const auto request = _AFD_REQUEST(c.io_control_code);

            switch (request)
            {
            case AFD_BIND:
                return this->ioctl_bind(win_emu, c);
            case AFD_CONNECT:
                return this->ioctl_connect(win_emu, c);
            case AFD_START_LISTEN:
                return this->ioctl_listen(win_emu, c);
            case AFD_WAIT_FOR_LISTEN:
                return this->ioctl_wait_for_listen(win_emu, c);
            case AFD_ACCEPT:
                return this->ioctl_accept(win_emu, c);
            case AFD_SEND:
                return this->ioctl_send(win_emu, c);
            case AFD_RECEIVE:
                return this->ioctl_receive(win_emu, c);
            case AFD_SEND_DATAGRAM:
                return this->ioctl_send_datagram(win_emu, c);
            case AFD_RECEIVE_DATAGRAM:
                return this->ioctl_receive_datagram(win_emu, c);
            case AFD_POLL:
                return this->ioctl_poll(win_emu, c);
            case AFD_GET_ADDRESS:
                return this->ioctl_get_address(win_emu, c);
            case AFD_EVENT_SELECT:
                return this->ioctl_event_select(win_emu, c);
            case AFD_ENUM_NETWORK_EVENTS:
                return this->ioctl_enum_network_events(win_emu, c);
            case AFD_SET_CONTEXT:
            case AFD_GET_INFORMATION:
            case AFD_SET_INFORMATION:
            case AFD_QUERY_HANDLES:
            case AFD_TRANSPORT_IOCTL:
            case AFD_PARTIAL_DISCONNECT:
                return STATUS_SUCCESS;
            default:
                win_emu.log.error("Unsupported AFD IOCTL: 0x%X (%u)\n", static_cast<uint32_t>(c.io_control_code),
                                  static_cast<uint32_t>(request));
                return STATUS_NOT_SUPPORTED;
            }
        }

        NTSTATUS ioctl_connect(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            auto data = win_emu.emu().read_memory(c.input_buffer, c.input_buffer_length);

            constexpr auto address_offset = 24;

            if (data.size() < address_offset)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto addr = convert_to_host_address(win_emu, std::span(data).subspan(address_offset));

            if (!this->s_->connect(addr))
            {
                const auto error = this->s_->get_last_error();
                if (error == SERR(EWOULDBLOCK))
                {
                    this->delay_ioctrl(c, false);
                    return STATUS_PENDING;
                }

                if (this->executing_delayed_ioctl_ && error == SERR(EISCONN))
                {
                    return STATUS_SUCCESS;
                }

                return STATUS_UNSUCCESSFUL;
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_bind(windows_emulator& win_emu, const io_device_context& c) const
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            auto data = win_emu.emu().read_memory(c.input_buffer, c.input_buffer_length);

            constexpr auto address_offset = 4;

            if (data.size() < address_offset)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto addr = convert_to_host_address(win_emu, std::span(data).subspan(address_offset));

            if (!this->s_->bind(addr))
            {
                return STATUS_ADDRESS_ALREADY_ASSOCIATED;
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_listen(windows_emulator& win_emu, const io_device_context& c) const
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            if (c.input_buffer_length < sizeof(AFD_LISTEN_INFO))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto listen_info = win_emu.emu().read_memory<AFD_LISTEN_INFO>(c.input_buffer);

            if (!this->s_->listen(static_cast<int>(listen_info.MaximumConnectionQueue)))
            {
                return STATUS_INVALID_PARAMETER;
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_wait_for_listen(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            if (c.output_buffer_length < sizeof(AFD_LISTEN_RESPONSE_INFO))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            network::address remote_address{};
            auto accepted_socket_ptr = this->s_->accept(remote_address);

            if (!accepted_socket_ptr)
            {
                const auto error = this->s_->get_last_error();
                if (error == SERR(EWOULDBLOCK))
                {
                    this->delay_ioctrl(c, true);
                    return STATUS_PENDING;
                }

                return STATUS_UNSUCCESSFUL;
            }

            if (!remote_address.is_ipv4())
            {
                throw std::runtime_error("Unsupported address family");
            }

            pending_connection pending{};
            pending.remote_address = remote_address;
            pending.accepted_socket = std::move(accepted_socket_ptr);

            LONG sequence = next_sequence_++;
            pending_connections_.try_emplace(sequence, std::move(pending));

            AFD_LISTEN_RESPONSE_INFO response{};
            response.Sequence = sequence;

            auto transport_buffer = convert_to_win_address(win_emu, remote_address);
            memcpy(&response.RemoteAddress, transport_buffer.data(), sizeof(win_sockaddr));

            win_emu.emu().write_memory<AFD_LISTEN_RESPONSE_INFO>(c.output_buffer, response);

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = sizeof(AFD_LISTEN_RESPONSE_INFO);
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_accept(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            if (c.input_buffer_length < sizeof(AFD_ACCEPT_INFO))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto accept_info = win_emu.emu().read_memory<AFD_ACCEPT_INFO>(c.input_buffer);

            const auto it = pending_connections_.find(accept_info.Sequence);
            if (it == pending_connections_.end())
            {
                return STATUS_INVALID_PARAMETER;
            }

            auto& accepted_socket = it->second.accepted_socket;

            auto* target_device = win_emu.process.devices.get(accept_info.AcceptHandle);
            if (!target_device)
            {
                return STATUS_INVALID_HANDLE;
            }

            auto* target_endpoint = target_device->get_internal_device<afd_endpoint>();
            if (!target_endpoint)
            {
                return STATUS_INVALID_HANDLE;
            }

            target_endpoint->s_ = std::move(accepted_socket);

            pending_connections_.erase(it);

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_receive(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            auto& emu = win_emu.emu();

            if (c.input_buffer_length < sizeof(AFD_RECV_INFO<EmulatorTraits<Emu64>>))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto receive_info = emu.read_memory<AFD_RECV_INFO<EmulatorTraits<Emu64>>>(c.input_buffer);

            if (!receive_info.BufferArray || receive_info.BufferCount == 0)
            {
                return STATUS_INVALID_PARAMETER;
            }

            if (receive_info.BufferCount > 1)
            {
                // TODO: Scatter/Gather
                return STATUS_NOT_SUPPORTED;
            }

            const auto wsabuf = emu.read_memory<EMU_WSABUF<EmulatorTraits<Emu64>>>(receive_info.BufferArray);
            if (!wsabuf.buf || wsabuf.len == 0)
            {
                return STATUS_INVALID_PARAMETER;
            }

            std::vector<std::byte> host_buffer;
            host_buffer.resize(wsabuf.len);

            const auto bytes_received = this->s_->recv(host_buffer);

            if (bytes_received < 0)
            {
                const auto error = this->s_->get_last_error();
                if (error == SERR(EWOULDBLOCK))
                {
                    this->delay_ioctrl(c, true);
                    return STATUS_PENDING;
                }

                if (error == SERR(ECONNRESET))
                {
                    return STATUS_CONNECTION_RESET;
                }

                return STATUS_UNSUCCESSFUL;
            }

            emu.write_memory(wsabuf.buf, host_buffer.data(), static_cast<size_t>(bytes_received));

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = static_cast<uint32_t>(bytes_received);
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_send(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            auto& emu = win_emu.emu();

            if (c.input_buffer_length < sizeof(AFD_SEND_INFO<EmulatorTraits<Emu64>>))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto send_info = emu.read_memory<AFD_SEND_INFO<EmulatorTraits<Emu64>>>(c.input_buffer);

            if (!send_info.BufferArray || send_info.BufferCount == 0)
            {
                return STATUS_INVALID_PARAMETER;
            }

            if (send_info.BufferCount > 1)
            {
                // TODO: Scatter/Gather
                return STATUS_NOT_SUPPORTED;
            }

            const auto wsabuf = emu.read_memory<EMU_WSABUF<EmulatorTraits<Emu64>>>(send_info.BufferArray);
            if (!wsabuf.buf || wsabuf.len == 0)
            {
                return STATUS_INVALID_PARAMETER;
            }

            std::vector<std::byte> host_buffer;
            host_buffer.resize(wsabuf.len);

            emu.read_memory(wsabuf.buf, host_buffer.data(), host_buffer.size());

            const auto bytes_sent = this->s_->send(host_buffer);

            if (bytes_sent < 0)
            {
                const auto error = this->s_->get_last_error();
                if (error == SERR(EWOULDBLOCK))
                {
                    this->delay_ioctrl(c, false);
                    return STATUS_PENDING;
                }

                if (error == SERR(ECONNRESET))
                {
                    return STATUS_CONNECTION_RESET;
                }

                return STATUS_UNSUCCESSFUL;
            }

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = static_cast<uint32_t>(bytes_sent);
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        static std::vector<const afd_endpoint*> resolve_endpoints(windows_emulator& win_emu,
                                                                  const std::span<const AFD_POLL_HANDLE_INFO64> handles)
        {
            auto& proc = win_emu.process;

            std::vector<const afd_endpoint*> endpoints{};
            endpoints.reserve(handles.size());

            for (const auto& handle : handles)
            {
                auto* device = proc.devices.get(handle.Handle);
                if (!device)
                {
                    throw std::runtime_error("Bad device!");
                }

                const auto* endpoint = device->get_internal_device<afd_endpoint>();
                if (!endpoint || !endpoint->s_)
                {
                    throw std::runtime_error("Invalid AFD endpoint!");
                }

                endpoints.push_back(endpoint);
            }

            return endpoints;
        }

        static NTSTATUS perform_poll(windows_emulator& win_emu, const io_device_context& c,
                                     const std::span<const afd_endpoint* const> endpoints,
                                     const std::span<const AFD_POLL_HANDLE_INFO64> handles)
        {
            std::vector<network::poll_entry> poll_data{};
            poll_data.resize(endpoints.size());

            for (size_t i = 0; i < endpoints.size() && i < handles.size(); ++i)
            {
                auto& pfd = poll_data.at(i);
                const auto& handle = handles[i];

                pfd.s = endpoints[i]->s_.get();
                pfd.events = map_afd_request_events_to_socket(handle.PollEvents);
                pfd.revents = pfd.events;
            }

            const auto count = win_emu.socket_factory().poll_sockets(poll_data);
            if (count <= 0)
            {
                return STATUS_PENDING;
            }

            constexpr auto info_size = offsetof(AFD_POLL_INFO64, Handles);
            const emulator_object<AFD_POLL_HANDLE_INFO64> handle_info_obj{win_emu.emu(), c.input_buffer + info_size};

            size_t current_index = 0;

            for (size_t i = 0; i < endpoints.size(); ++i)
            {
                const auto& pfd = poll_data.at(i);
                if (pfd.revents == 0)
                {
                    continue;
                }

                const auto& handle = handles[i];
                const auto& endpoint = endpoints[i];

                const bool is_connecting =
                    endpoint->delayed_ioctl_ && _AFD_REQUEST(endpoint->delayed_ioctl_->io_control_code) == AFD_CONNECT;

                auto entry = handle_info_obj.read(i);
                entry.PollEvents = map_socket_response_events_to_afd(pfd.revents, handle.PollEvents, pfd.s->is_listening(), is_connecting);
                entry.Status = STATUS_SUCCESS;

                handle_info_obj.write(entry, current_index++);
            }

            assert(current_index == static_cast<size_t>(count));

            const emulator_object<AFD_POLL_INFO64> info_obj{win_emu.emu(), c.input_buffer};
            info_obj.access([&](AFD_POLL_INFO64& info) {
                info.NumberOfHandles = static_cast<ULONG>(current_index); //
            });

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = info_size + sizeof(AFD_POLL_HANDLE_INFO64) * current_index;
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_poll(windows_emulator& win_emu, const io_device_context& c)
        {
            const auto [info, handles] = get_poll_info(win_emu, c);
            const auto endpoints = resolve_endpoints(win_emu, handles);

            const auto status = perform_poll(win_emu, c, endpoints, handles);
            if (status != STATUS_PENDING)
            {
                return status;
            }

            if (!this->executing_delayed_ioctl_)
            {
                const auto timeout_callback = [](windows_emulator& win_emu, const io_device_context& c) {
                    const emulator_object<AFD_POLL_INFO64> info_obj{win_emu.emu(), c.input_buffer};
                    info_obj.access([&](AFD_POLL_INFO64& poll_info) {
                        poll_info.NumberOfHandles = 0; //
                    });
                };

                if (!info.Timeout.QuadPart)
                {
                    if (status == STATUS_PENDING)
                    {
                        timeout_callback(win_emu, c);
                        return STATUS_TIMEOUT;
                    }
                    return STATUS_SUCCESS;
                }

                std::optional<std::chrono::steady_clock::time_point> timeout{};
                if (info.Timeout.QuadPart != std::numeric_limits<int64_t>::max())
                {
                    timeout = utils::convert_delay_interval_to_time_point(win_emu.clock(), info.Timeout,
                                                                          {.QuadPart = std::numeric_limits<int64_t>::max()});
                }

                this->delay_ioctrl(c, {}, timeout, timeout_callback);
            }

            return STATUS_PENDING;
        }

        NTSTATUS ioctl_receive_datagram(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            auto& emu = win_emu.emu();

            if (c.input_buffer_length < sizeof(AFD_RECV_DATAGRAM_INFO<EmulatorTraits<Emu64>>))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto receive_info = emu.read_memory<AFD_RECV_DATAGRAM_INFO<EmulatorTraits<Emu64>>>(c.input_buffer);
            const auto buffer = emu.read_memory<EMU_WSABUF<EmulatorTraits<Emu64>>>(receive_info.BufferArray);

            if (!buffer.len || buffer.len > 0x10000 || !buffer.buf)
            {
                return STATUS_INVALID_PARAMETER;
            }

            network::address from{};
            std::vector<std::byte> data{};
            data.resize(buffer.len);

            const auto recevied_data = this->s_->recvfrom(from, data);

            if (recevied_data < 0)
            {
                const auto error = this->s_->get_last_error();
                if (error == SERR(EWOULDBLOCK))
                {
                    this->delay_ioctrl(c, true);
                    return STATUS_PENDING;
                }

                return STATUS_UNSUCCESSFUL;
            }

            const auto data_size = std::min(data.size(), static_cast<size_t>(recevied_data));
            emu.write_memory(buffer.buf, data.data(), data_size);

            const auto win_from = convert_to_win_address(win_emu, from);

            if (receive_info.Address && receive_info.AddressLength)
            {
                const emulator_object<ULONG> address_length{emu, receive_info.AddressLength};
                const auto address_size = std::min(win_from.size(), static_cast<size_t>(address_length.read()));

                emu.write_memory(receive_info.Address, win_from.data(), address_size);
                address_length.write(static_cast<ULONG>(address_size));
            }

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = static_cast<uint32_t>(recevied_data);
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_send_datagram(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            const auto& emu = win_emu.emu();

            if (c.input_buffer_length < sizeof(AFD_SEND_DATAGRAM_INFO<EmulatorTraits<Emu64>>))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto send_info = emu.read_memory<AFD_SEND_DATAGRAM_INFO<EmulatorTraits<Emu64>>>(c.input_buffer);
            const auto buffer = emu.read_memory<EMU_WSABUF<EmulatorTraits<Emu64>>>(send_info.BufferArray);

            auto address_buffer =
                emu.read_memory(send_info.TdiConnInfo.RemoteAddress, static_cast<size_t>(send_info.TdiConnInfo.RemoteAddressLength));

            const auto target = convert_to_host_address(win_emu, address_buffer);
            const auto data = emu.read_memory(buffer.buf, buffer.len);

            const auto sent_data = this->s_->sendto(target, data);
            if (sent_data < 0)
            {
                const auto error = this->s_->get_last_error();
                if (error == SERR(EWOULDBLOCK))
                {
                    this->delay_ioctrl(c, false);
                    return STATUS_PENDING;
                }

                return STATUS_UNSUCCESSFUL;
            }

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = static_cast<uint32_t>(sent_data);
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_get_address(windows_emulator& win_emu, const io_device_context& c) const
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            const auto local_address = this->s_->get_local_address();
            if (!local_address)
            {
                return STATUS_INVALID_PARAMETER;
            }

            std::vector<std::byte> win_addr_bytes = convert_to_win_address(win_emu, *local_address);

            if (c.output_buffer_length < win_addr_bytes.size())
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            win_emu.emu().write_memory(c.output_buffer, win_addr_bytes.data(), win_addr_bytes.size());

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = static_cast<ULONG>(win_addr_bytes.size());
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_event_select(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            if (c.input_buffer_length < sizeof(AFD_EVENT_SELECT_INFO))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto select_info = win_emu.emu().read_memory<AFD_EVENT_SELECT_INFO>(c.input_buffer);

            this->event_select_event_ = select_info.Event;
            this->event_select_mask_ = select_info.PollEvents;
            this->triggered_events_ = 0;

            if (auto* event = win_emu.process.events.get(select_info.Event))
            {
                event->signaled = false;
            }

            return STATUS_SUCCESS;
        }

        NTSTATUS ioctl_enum_network_events(windows_emulator& win_emu, const io_device_context& c)
        {
            if (!this->s_)
            {
                throw std::runtime_error("Invalid AFD endpoint socket!");
            }

            if (c.output_buffer_length < 56)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            if (c.input_buffer)
            {
                if (c.input_buffer_length == 0)
                {
                    handle h{};
                    h.bits = c.input_buffer;

                    if (auto* event = win_emu.process.events.get(h))
                    {
                        event->signaled = false;
                    }
                }
                else
                {
                    return STATUS_NOT_SUPPORTED;
                }
            }

            win_emu.emu().write_memory(c.output_buffer, this->triggered_events_);
            this->triggered_events_ = 0;

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = 56;
                c.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }
    };

    struct afd_async_connect_hlp : stateless_device
    {
        NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& c) override
        {
            if (c.io_control_code != 0x12007)
            {
                return STATUS_NOT_SUPPORTED;
            }

            if (c.input_buffer_length < 40)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const auto target_handle = win_emu.emu().read_memory<handle>(c.input_buffer + 16);

            auto* target_device = win_emu.process.devices.get(target_handle);
            if (!target_device)
            {
                return STATUS_INVALID_HANDLE;
            }

            auto* target_endpoint = target_device->get_internal_device<afd_endpoint>();
            if (!target_endpoint)
            {
                return STATUS_INVALID_HANDLE;
            }

            return target_endpoint->execute_ioctl(win_emu, c);
        }
    };
}

std::unique_ptr<io_device> create_afd_endpoint()
{
    return std::make_unique<afd_endpoint>();
}

std::unique_ptr<io_device> create_afd_async_connect_hlp()
{
    return std::make_unique<afd_async_connect_hlp>();
}

```

`src/windows-emulator/devices/afd_endpoint.hpp`:

```hpp
#pragma once
#include "../io_device.hpp"

std::unique_ptr<io_device> create_afd_endpoint();
std::unique_ptr<io_device> create_afd_async_connect_hlp();

```

`src/windows-emulator/devices/afd_types.hpp`:

```hpp
#pragma once

#include "../std_include.hpp"

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

typedef LONG TDI_STATUS;

struct win_sockaddr
{
    USHORT sa_family;
    CHAR sa_data[14];
};

struct AFD_LISTEN_INFO
{
    BOOLEAN SanActive;
    ULONG MaximumConnectionQueue;
    BOOLEAN UseDelayedAcceptance;
};

struct AFD_LISTEN_RESPONSE_INFO
{
    LONG Sequence;
    win_sockaddr RemoteAddress;
};

struct AFD_ACCEPT_INFO
{
    BOOLEAN SanActive;
    LONG Sequence;
    handle AcceptHandle;
};

template <typename Traits>
struct TDI_CONNECTION_INFORMATION
{
    LONG UserDataLength;
    typename Traits::PVOID UserData;
    LONG OptionsLength;
    typename Traits::PVOID Options;
    LONG RemoteAddressLength;
    typename Traits::PVOID RemoteAddress;
};

template <typename Traits>
struct TDI_REQUEST
{
    union
    {
        typename Traits::HANDLE AddressHandle;
        EMULATOR_CAST(typename Traits::PVOID, CONNECTION_CONTEXT) ConnectionContext;
        typename Traits::HANDLE ControlChannel;
    } Handle;

    typename Traits::PVOID RequestNotifyObject;
    typename Traits::PVOID RequestContext;
    TDI_STATUS TdiStatus;
};

template <typename Traits>
struct TDI_REQUEST_SEND_DATAGRAM
{
    TDI_REQUEST<Traits> Request;
    EMULATOR_CAST(typename Traits::PVOID, PTDI_CONNECTION_INFORMATION) SendDatagramInformation;
};

template <typename Traits>
struct AFD_SEND_INFO
{
    EMULATOR_CAST(typename Traits::PVOID, LPWSABUF) BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
};

template <typename Traits>
struct AFD_SEND_DATAGRAM_INFO
{
    EMULATOR_CAST(typename Traits::PVOID, LPWSABUF) BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    TDI_REQUEST_SEND_DATAGRAM<Traits> TdiRequest;
    TDI_CONNECTION_INFORMATION<Traits> TdiConnInfo;
};

template <typename Traits>
struct AFD_RECV_INFO
{
    EMULATOR_CAST(typename Traits::PVOID, LPWSABUF) BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
};

template <typename Traits>
struct AFD_RECV_DATAGRAM_INFO
{
    EMULATOR_CAST(typename Traits::PVOID, LPWSABUF) BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
    typename Traits::PVOID Address;
    EMULATOR_CAST(typename Traits::PVOID, PULONG) AddressLength;
};

struct AFD_POLL_HANDLE_INFO64
{
    EmulatorTraits<Emu64>::HANDLE Handle;
    ULONG PollEvents;
    NTSTATUS Status;
};

struct AFD_POLL_INFO64
{
    LARGE_INTEGER Timeout;
    ULONG NumberOfHandles;
    BOOLEAN Unique;
    AFD_POLL_HANDLE_INFO64 Handles[1];
};

#define AFD_POLL_RECEIVE_BIT           0
#define AFD_POLL_RECEIVE               (1 << AFD_POLL_RECEIVE_BIT)
#define AFD_POLL_RECEIVE_EXPEDITED_BIT 1
#define AFD_POLL_RECEIVE_EXPEDITED     (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)
#define AFD_POLL_SEND_BIT              2
#define AFD_POLL_SEND                  (1 << AFD_POLL_SEND_BIT)
#define AFD_POLL_DISCONNECT_BIT        3
#define AFD_POLL_DISCONNECT            (1 << AFD_POLL_DISCONNECT_BIT)
#define AFD_POLL_ABORT_BIT             4
#define AFD_POLL_ABORT                 (1 << AFD_POLL_ABORT_BIT)
#define AFD_POLL_LOCAL_CLOSE_BIT       5
#define AFD_POLL_LOCAL_CLOSE           (1 << AFD_POLL_LOCAL_CLOSE_BIT)
#define AFD_POLL_CONNECT_BIT           6
#define AFD_POLL_CONNECT               (1 << AFD_POLL_CONNECT_BIT)
#define AFD_POLL_ACCEPT_BIT            7
#define AFD_POLL_ACCEPT                (1 << AFD_POLL_ACCEPT_BIT)
#define AFD_POLL_CONNECT_FAIL_BIT      8
#define AFD_POLL_CONNECT_FAIL          (1 << AFD_POLL_CONNECT_FAIL_BIT)
#define AFD_POLL_QOS_BIT               9
#define AFD_POLL_QOS                   (1 << AFD_POLL_QOS_BIT)
#define AFD_POLL_GROUP_QOS_BIT         10
#define AFD_POLL_GROUP_QOS             (1 << AFD_POLL_GROUP_QOS_BIT)

#define AFD_NUM_POLL_EVENTS            11
#define AFD_POLL_ALL                   ((1 << AFD_NUM_POLL_EVENTS) - 1)

struct AFD_EVENT_SELECT_INFO
{
    handle Event;
    ULONG PollEvents;
};

#define _AFD_REQUEST(ioctl)             ((((ULONG)(ioctl)) >> 2) & 0x03FF)
#define _AFD_BASE(ioctl)                ((((ULONG)(ioctl)) >> 12) & 0xFFFFF)

#define FSCTL_AFD_BASE                  FILE_DEVICE_NETWORK

#define AFD_BIND                        0
#define AFD_CONNECT                     1
#define AFD_START_LISTEN                2
#define AFD_WAIT_FOR_LISTEN             3
#define AFD_ACCEPT                      4
#define AFD_RECEIVE                     5
#define AFD_RECEIVE_DATAGRAM            6
#define AFD_SEND                        7
#define AFD_SEND_DATAGRAM               8
#define AFD_POLL                        9
#define AFD_PARTIAL_DISCONNECT          10

#define AFD_GET_ADDRESS                 11
#define AFD_QUERY_RECEIVE_INFO          12
#define AFD_QUERY_HANDLES               13
#define AFD_SET_INFORMATION             14
#define AFD_GET_CONTEXT_LENGTH          15
#define AFD_GET_CONTEXT                 16
#define AFD_SET_CONTEXT                 17

#define AFD_SET_CONNECT_DATA            18
#define AFD_SET_CONNECT_OPTIONS         19
#define AFD_SET_DISCONNECT_DATA         20
#define AFD_SET_DISCONNECT_OPTIONS      21

#define AFD_GET_CONNECT_DATA            22
#define AFD_GET_CONNECT_OPTIONS         23
#define AFD_GET_DISCONNECT_DATA         24
#define AFD_GET_DISCONNECT_OPTIONS      25

#define AFD_SIZE_CONNECT_DATA           26
#define AFD_SIZE_CONNECT_OPTIONS        27
#define AFD_SIZE_DISCONNECT_DATA        28
#define AFD_SIZE_DISCONNECT_OPTIONS     29

#define AFD_GET_INFORMATION             30
#define AFD_TRANSMIT_FILE               31
#define AFD_SUPER_ACCEPT                32

#define AFD_EVENT_SELECT                33
#define AFD_ENUM_NETWORK_EVENTS         34

#define AFD_DEFER_ACCEPT                35
#define AFD_WAIT_FOR_LISTEN_LIFO        36
#define AFD_SET_QOS                     37
#define AFD_GET_QOS                     38
#define AFD_NO_OPERATION                39
#define AFD_VALIDATE_GROUP              40
#define AFD_GET_UNACCEPTED_CONNECT_DATA 41
#define AFD_ROUTING_INTERFACE_QUERY     42
#define AFD_ROUTING_INTERFACE_CHANGE    43
#define AFD_ADDRESS_LIST_QUERY          44
#define AFD_ADDRESS_LIST_CHANGE         45
#define AFD_JOIN_LEAF                   46
#define AFD_TRANSPORT_IOCTL             47

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/windows-emulator/devices/mount_point_manager.cpp`:

```cpp
#include "../std_include.hpp"
#include "mount_point_manager.hpp"

#include "../windows_emulator.hpp"
#include "mountmgr.hpp"

namespace
{
    std::pair<ULONG, USHORT> write_data(std::vector<uint8_t>& buffer, const std::span<const uint8_t> data)
    {
        const auto offset = buffer.size();
        buffer.insert(buffer.end(), data.begin(), data.end());
        return std::make_pair(static_cast<ULONG>(offset), static_cast<USHORT>(data.size()));
    }

    template <typename Char>
    std::pair<ULONG, USHORT> write_string(std::vector<uint8_t>& buffer, const std::basic_string_view<Char> str)
    {
        std::span data(reinterpret_cast<const uint8_t*>(str.data()), str.size() * sizeof(Char));
        return write_data(buffer, data);
    }

    std::string make_drive_id(const uint64_t low = 0, const uint64_t high = 0)
    {
        std::string id = "DMIO:ID:";
        id.append(reinterpret_cast<const char*>(&low), sizeof(low));
        id.append(reinterpret_cast<const char*>(&high), sizeof(high));

        return id;
    }

    std::u16string make_volume(const uint64_t low = 0, const uint64_t high = 0)
    {
        auto str = utils::string::to_hex_string(low) + utils::string::to_hex_string(high);
        str.insert(str.begin() + 20, '-');
        str.insert(str.begin() + 16, '-');
        str.insert(str.begin() + 12, '-');
        str.insert(str.begin() + 8, '-');

        const std::string volume = utils::string::va("\\??\\Volume{%s}", str.c_str());
        return u8_to_u16(volume);
    }

    struct mount_point_manager : stateless_device
    {
        static NTSTATUS query_points(windows_emulator& win_emu, const io_device_context& c)
        {
            const auto drives = win_emu.file_sys.list_drives();
            const auto struct_size = sizeof(MOUNTMGR_MOUNT_POINTS) + sizeof(MOUNTMGR_MOUNT_POINT) * drives.size();

            std::vector<MOUNTMGR_MOUNT_POINT> mount_points{};

            std::vector<uint8_t> buffer{};
            buffer.resize(struct_size);

            {
                MOUNTMGR_MOUNT_POINT point{};
                const auto symlink = write_string<char16_t>(buffer, u"\\DosDevices\\");
                const auto id = write_string<char>(buffer, make_drive_id(0, 1));
                const auto name = write_string<char16_t>(buffer, u"\\Device\\HarddiskVolume0");

                point.SymbolicLinkNameOffset = symlink.first;
                point.SymbolicLinkNameLength = symlink.second;

                point.UniqueIdOffset = id.first;
                point.UniqueIdLength = id.second;

                point.DeviceNameOffset = name.first;
                point.DeviceNameLength = name.second;

                mount_points.push_back(point);
            }

            for (const auto drive : drives)
            {
                MOUNTMGR_MOUNT_POINT point{};
                const auto symlink = write_string<char16_t>(buffer, make_volume(drive, 0));
                const auto id = write_string<char>(buffer, make_drive_id(drive, 0));
                const auto name = write_string<char16_t>(buffer, u"\\Device\\HarddiskVolume" + u8_to_u16(std::to_string(drive - 'a' + 1)));

                point.SymbolicLinkNameOffset = symlink.first;
                point.SymbolicLinkNameLength = symlink.second;

                point.UniqueIdOffset = id.first;
                point.UniqueIdLength = id.second;

                point.DeviceNameOffset = name.first;
                point.DeviceNameLength = name.second;

                mount_points.push_back(point);
            }

            MOUNTMGR_MOUNT_POINTS points{};
            points.Size = static_cast<ULONG>(buffer.size());
            points.NumberOfMountPoints = static_cast<ULONG>(mount_points.size());

            memcpy(buffer.data(), &points, sizeof(points));
            memcpy(buffer.data() + offsetof(MOUNTMGR_MOUNT_POINTS, MountPoints), mount_points.data(),
                   mount_points.size() * sizeof(MOUNTMGR_MOUNT_POINT));

            const auto length = std::min(static_cast<size_t>(c.output_buffer_length), buffer.size());

            win_emu.emu().write_memory(c.output_buffer, buffer.data(), length);

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = buffer.size();
                c.io_status_block.write(block);
            }

            return length < buffer.size() ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
        }

        static NTSTATUS get_drive_letter(windows_emulator& win_emu, const io_device_context& c)
        {
            if (c.input_buffer_length < 2)
            {
                return STATUS_NOT_SUPPORTED;
            }

            const auto data = win_emu.emu().read_memory(c.input_buffer, c.input_buffer_length);

            const std::u16string_view file(reinterpret_cast<const char16_t*>(data.data()), (data.size() / 2) - 1);

            constexpr std::u16string_view volume_prefix = u".\\Device\\HarddiskVolume";
            if (!file.starts_with(volume_prefix))
            {
                return STATUS_NOT_SUPPORTED;
            }

            const auto drive_number = file.substr(volume_prefix.size());
            const auto drive_number_u8 = u16_to_u8(drive_number);
            const auto drive_letter = static_cast<char>('A' + atoi(drive_number_u8.c_str()) - 1);

            std::string response{};
            response.push_back(drive_letter);
            response.push_back(':');
            response.push_back(0);
            response.push_back(0);

            const auto u16_response = u8_to_u16(response);

            const auto length = static_cast<uint32_t>(u16_response.size() * 2);
            const auto total_length = sizeof(length) + length;

            if (c.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = total_length;
                c.io_status_block.write(block);
            }

            if (c.output_buffer_length < total_length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            win_emu.emu().write_memory(c.output_buffer, length);
            win_emu.emu().write_memory(c.output_buffer + sizeof(length), u16_response.data(), length);

            return STATUS_SUCCESS;
        }

        NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& c) override
        {
            if (c.io_control_code == IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH)
            {
                return get_drive_letter(win_emu, c);
            }

            if (c.io_control_code == IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS)
            {
                return get_drive_letter(win_emu, c);
            }

            if (c.io_control_code == IOCTL_MOUNTMGR_QUERY_POINTS)
            {
                return query_points(win_emu, c);
            }

            win_emu.log.error("Unsupported mount point IOCTL: %X\n", static_cast<uint32_t>(c.io_control_code));
            return STATUS_NOT_SUPPORTED;
        }
    };
}

std::unique_ptr<io_device> create_mount_point_manager()
{
    return std::make_unique<mount_point_manager>();
}

```

`src/windows-emulator/devices/mount_point_manager.hpp`:

```hpp
#pragma once
#include "../io_device.hpp"

std::unique_ptr<io_device> create_mount_point_manager();

```

`src/windows-emulator/devices/mountmgr.hpp`:

```hpp
#pragma once

// NOLINTBEGIN(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

#define MOUNTMGRCONTROLTYPE                        0x0000006D // 'm'
#define MOUNTDEVCONTROLTYPE                        0x0000004D // 'M'

#define IOCTL_MOUNTMGR_CREATE_POINT                CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS               CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS                CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY        CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER           CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS         CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED  CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED  CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY               CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE     CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES   CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH       CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS      CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_SCRUB_REGISTRY              CTL_CODE(MOUNTMGRCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT            CTL_CODE(MOUNTMGRCONTROLTYPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_SET_AUTO_MOUNT              CTL_CODE(MOUNTMGRCONTROLTYPE, 16, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT \
    CTL_CODE(MOUNTMGRCONTROLTYPE, 17, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // since WIN7
#define IOCTL_MOUNTMGR_TRACELOG_CACHE        CTL_CODE(MOUNTMGRCONTROLTYPE, 18, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_PREPARE_VOLUME_DELETE CTL_CODE(MOUNTMGRCONTROLTYPE, 19, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CANCEL_VOLUME_DELETE \
    CTL_CODE(MOUNTMGRCONTROLTYPE, 20, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // since WIN8
#define IOCTL_MOUNTMGR_SILO_ARRIVAL      CTL_CODE(MOUNTMGRCONTROLTYPE, 21, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // since RS1

#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _MOUNTMGR_MOUNT_POINT
{
    ULONG SymbolicLinkNameOffset;
    USHORT SymbolicLinkNameLength;
    ULONG UniqueIdOffset;
    USHORT UniqueIdLength;
    ULONG DeviceNameOffset;
    USHORT DeviceNameLength;
} MOUNTMGR_MOUNT_POINT, *PMOUNTMGR_MOUNT_POINT;

//
// Output structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINTS
{
    ULONG Size;
    ULONG NumberOfMountPoints;
    MOUNTMGR_MOUNT_POINT MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

// NOLINTEND(modernize-use-using,cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

```

`src/windows-emulator/devices/named_pipe.hpp`:

```hpp
#pragma once
#include "../io_device.hpp"

class named_pipe : public io_device_container
{
  public:
    std::u16string name;
    std::deque<std::string> write_queue;
    ACCESS_MASK access = 0;
    ULONG pipe_type;
    ULONG read_mode;
    ULONG completion_mode;
    ULONG max_instances;
    ULONG inbound_quota;
    ULONG outbound_quota;
    LARGE_INTEGER default_timeout;

    void create(windows_emulator&, const io_device_creation_data&) override
    {
    }
    void work(windows_emulator&) override
    {
    }
    NTSTATUS io_control(windows_emulator&, const io_device_context&) override
    {
        return STATUS_NOT_SUPPORTED;
    }

    void serialize_object(utils::buffer_serializer&) const override
    {
    }
    void deserialize_object(utils::buffer_deserializer&) override
    {
    }
};

```

`src/windows-emulator/devices/security_support_provider.cpp`:

```cpp
#include "../std_include.hpp"
#include "security_support_provider.hpp"

#include "../windows_emulator.hpp"

namespace
{
    struct security_support_provider : stateless_device
    {
        // RNG Microsoft Primitive Provider
        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        std::uint8_t rng_output_data[216] = //
            {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
             0xFF, 0xFF, 0xFF, 0xFF, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
             0x52, 0x00, 0x4E, 0x00, 0x47, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73, 0x00,
             0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00,
             0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x76, 0x00, 0x69, 0x00, 0x64, 0x00,
             0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x00, 0x72, 0x00, 0x79, 0x00, 0x70, 0x00, 0x74, 0x00,
             0x70, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x73, 0x00,
             0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        // SHA256 Microsoft Primitive Provider
        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        std::uint8_t sha256_output_data[224] = //
            {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x32, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
             0xFF, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x53, 0x00, 0x48, 0x00,
             0x41, 0x00, 0x32, 0x00, 0x35, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x72, 0x00, 0x6F,
             0x00, 0x73, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00,
             0x74, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x76, 0x00, 0x69, 0x00, 0x64,
             0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x00, 0x72, 0x00, 0x79, 0x00, 0x70, 0x00, 0x74, 0x00, 0x70,
             0x00, 0x72, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x73, 0x00, 0x2E, 0x00,
             0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& c) override
        {
            if (c.io_control_code != 0x390400)
            {
                return STATUS_NOT_SUPPORTED;
            }

            const auto operation = win_emu.emu().read_memory<USHORT>(c.input_buffer + 6);

            if (operation == 2)
            {
                std::array<char16_t, 8> alg_name_buffer{};
                win_emu.emu().read_memory(c.input_buffer + 0x30, alg_name_buffer.data(), sizeof(alg_name_buffer));

                const std::u16string algorithm_name(alg_name_buffer.data());

                if (algorithm_name == u"SHA256")
                {
                    win_emu.emu().write_memory(c.output_buffer, sha256_output_data);

                    if (c.io_status_block)
                    {
                        IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                        block.Information = sizeof(sha256_output_data);
                        c.io_status_block.write(block);
                    }
                }
                else
                {
                    win_emu.emu().write_memory(c.output_buffer, rng_output_data);

                    if (c.io_status_block)
                    {
                        IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                        block.Information = sizeof(rng_output_data);
                        c.io_status_block.write(block);
                    }
                }
            }

            return STATUS_SUCCESS;
        }
    };
}

std::unique_ptr<io_device> create_security_support_provider()
{
    return std::make_unique<security_support_provider>();
}

```

`src/windows-emulator/devices/security_support_provider.hpp`:

```hpp
#pragma once
#include "../io_device.hpp"

std::unique_ptr<io_device> create_security_support_provider();

```

`src/windows-emulator/emulator_thread.cpp`:

```cpp
#include "std_include.hpp"
#include "emulator_thread.hpp"

#include "cpu_context.hpp"
#include "process_context.hpp"
#include "io_completion_wait.hpp"
#include "syscall_utils.hpp"

namespace
{
    void setup_wow64_fs_segment(memory_manager& memory, uint64_t teb32_addr)
    {
        const uint64_t base = teb32_addr;
        const uint32_t limit = 0xFFF; // 4KB - size of TEB32 (matching Windows)

        // Build the GDT descriptor matching Windows format exactly
        // Format: | Base[31:24] | G|D|L|AVL | Limit[19:16] | P|DPL|S|Type | Base[23:16] | Base[15:0] | Limit[15:0] |
        uint64_t descriptor = 0;
        descriptor |= (limit & 0xFFFF);                                       // Limit[15:0]
        descriptor |= ((base & 0xFFFF) << 16);                                // Base[15:0]
        descriptor |= ((base & 0xFF0000) << 16);                              // Base[23:16]
        descriptor |= (0xF3ULL << 40);                                        // P=1, DPL=3, S=1, Type=3 (Data RW Accessed)
        descriptor |= (static_cast<uint64_t>((limit & 0xF0000) >> 16) << 48); // Limit[19:16]
        descriptor |= (0x40ULL << 48);                                        // G=0 (byte), D=1 (32-bit), L=0, AVL=0
        descriptor |= ((base & 0xFF000000) << 32);                            // Base[31:24]

        // Write the updated descriptor to GDT index 10 (selector 0x53)
        constexpr uint64_t fs_gdt_offset = GDT_ADDR + 10 * sizeof(uint64_t);
        memory.write_memory(fs_gdt_offset, &descriptor, sizeof(descriptor));
    }

    template <typename T>
    emulator_object<T> allocate_object_on_stack(x86_64_emulator& emu)
    {
        const auto old_sp = emu.reg(x86_register::rsp);
        const auto new_sp = align_down(old_sp - sizeof(T), std::max(alignof(T), alignof(x86_64_emulator::pointer_type)));
        emu.reg(x86_register::rsp, new_sp);
        return {emu, new_sp};
    }

    void unalign_stack(x86_64_emulator& emu)
    {
        auto sp = emu.reg(x86_register::rsp);
        sp = align_down(sp - 0x10, 0x10) + 8;
        emu.reg(x86_register::rsp, sp);
    }

    void setup_stack(x86_64_emulator& emu, const process_context& context, const uint64_t stack_base, const size_t stack_size)
    {
        if (!context.is_wow64_process)
        {
            const uint64_t stack_end = stack_base + stack_size;
            emu.reg(x86_register::rsp, stack_end);
        }
        else
        {
            const uint64_t stack_end = stack_base + stack_size - sizeof(WOW64_CPURESERVED) - 0x1578;
            emu.reg(x86_register::rsp, stack_end);
        }
    }

    bool is_object_signaled(process_context& c, const handle h, const uint32_t current_thread_id)
    {
        const auto type = h.value.type;

        switch (type)
        {
        default:
            break;

        case handle_types::event: {
            if (h.value.is_pseudo)
            {
                return true;
            }

            auto* e = c.events.get(h);
            if (e)
            {
                return e->is_signaled();
            }

            break;
        }

        case handle_types::mutant: {
            auto* e = c.mutants.get(h);
            return !e || e->try_lock(current_thread_id);
        }

        case handle_types::timer: {
            return true; // TODO
        }

        case handle_types::semaphore: {
            auto* s = c.semaphores.get(h);
            if (s)
            {
                return s->try_lock();
            }

            break;
        }

        case handle_types::thread: {
            const auto* t = c.threads.get(h);
            if (t)
            {
                return t->is_terminated();
            }

            break;
        }
        }

        throw std::runtime_error("Bad object: " + std::to_string(h.value.type));
    }
}

emulator_thread::emulator_thread(memory_manager& memory, const process_context& context, const uint64_t start_address,
                                 const uint64_t argument, const uint64_t stack_size, const uint32_t create_flags, const uint32_t id,
                                 const bool initial_thread)
    : memory_ptr(&memory),
      // stack_size(page_align_up(std::max(stack_size, static_cast<uint64_t>(STACK_SIZE)))),
      start_address(start_address),
      argument(argument),
      id(id),
      create_flags(create_flags),
      last_registers(context.default_register_set)
{
    this->suspended = create_flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED;

    // native 64-bit
    if (!context.is_wow64_process)
    {
        this->stack_size = page_align_up(std::max(stack_size, static_cast<uint64_t>(STACK_SIZE)));
        this->stack_base = memory.allocate_memory(static_cast<size_t>(this->stack_size), memory_permission::read_write);

        this->gs_segment = emulator_allocator{
            memory,
            memory.allocate_memory(GS_SEGMENT_SIZE, memory_permission::read_write),
            GS_SEGMENT_SIZE,
        };

        this->teb64 = this->gs_segment->reserve<TEB64>();

        this->teb64->access([&](TEB64& teb_obj) {
            // Skips GetCurrentNlsCache
            // This hack can be removed once this is fixed:
            // https://github.com/momo5502/emulator/issues/128
            reinterpret_cast<uint8_t*>(&teb_obj)[0x179C] = 1;

            teb_obj.ClientId.UniqueProcess = 1ul;
            teb_obj.ClientId.UniqueThread = static_cast<uint64_t>(this->id);
            teb_obj.NtTib.StackLimit = this->stack_base;
            teb_obj.NtTib.StackBase = this->stack_base + this->stack_size;
            teb_obj.NtTib.Self = this->teb64->value();
            teb_obj.CurrentLocale = 0x409;
            teb_obj.ProcessEnvironmentBlock = context.peb64.value();
            teb_obj.SameTebFlags.InitialThread = initial_thread;
            teb_obj.SameTebFlags.SkipThreadAttach = (create_flags & THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH) ? 1 : 0;
            teb_obj.SameTebFlags.LoaderWorker = (create_flags & THREAD_CREATE_FLAGS_LOADER_WORKER) ? 1 : 0;
            teb_obj.SameTebFlags.SkipLoaderInit = (create_flags & THREAD_CREATE_FLAGS_SKIP_LOADER_INIT) ? 1 : 0;

            const auto desktop_info_obj = this->gs_segment->reserve<USER_DESKTOPINFO>();
            teb_obj.Win32ClientInfo.arr[4] = desktop_info_obj.value();
        });

        return;
    }

    // Default native size of wow64 is 256KB
    this->stack_size = WOW64_NATIVE_STACK_SIZE;
    this->wow64_stack_size = page_align_up(std::max(stack_size, static_cast<uint64_t>(STACK_SIZE)));

    // Set the default memory allocation address to the specified 32-bit address
    memory.set_default_allocation_address(DEFAULT_ALLOCATION_ADDRESS_32BIT);

    // Calculate required GS segment size for WOW64 (64-bit TEB + 32-bit TEB)
    constexpr auto teb64_size = sizeof(TEB64);
    constexpr auto teb32_size = sizeof(TEB32); // 4120 bytes
    constexpr auto wow_teb_offset = page_align_up(teb64_size);
    const uint64_t required_gs_size = teb64_size + wow_teb_offset + teb32_size; // Need space for both TEBs
    const auto actual_gs_size =
        static_cast<size_t>((required_gs_size > GS_SEGMENT_SIZE) ? page_align_up(required_gs_size) : GS_SEGMENT_SIZE);

    // Allocate GS segment to hold both TEB32 and TEB64 for WOW64 process
    this->gs_segment = emulator_allocator{
        memory,
        memory.allocate_memory(actual_gs_size, memory_permission::read_write),
        actual_gs_size,
    };

    // Reserve and initialize 64-bit TEB first
    this->teb64 = this->gs_segment->reserve<TEB64>();

    // Allocate memory for native stack + WOW64_CPURESERVED structure
    this->stack_base = memory.allocate_memory(WOW64_NATIVE_STACK_SIZE, memory_permission::read_write);
    if (this->stack_base == 0)
    {
        throw std::runtime_error("Failed to allocate native stack + WOW64_CPURESERVED memory region");
        return;
    }

    const uint64_t wow64_cpureserved_base = this->stack_base + this->stack_size - sizeof(WOW64_CPURESERVED) - 0x1030;

    // Initialize 64-bit TEB first
    this->teb64->access([&](TEB64& teb_obj) {
        // Skips GetCurrentNlsCache
        // This hack can be removed once this is fixed:
        // https://github.com/momo5502/emulator/issues/128
        reinterpret_cast<uint8_t*>(&teb_obj)[0x179C] = 1;

        teb_obj.ClientId.UniqueProcess = 1ul;
        teb_obj.ClientId.UniqueThread = static_cast<uint64_t>(this->id);

        // Native 64-bit stack
        teb_obj.NtTib.StackLimit = this->stack_base;
        teb_obj.NtTib.StackBase = wow64_cpureserved_base;
        teb_obj.NtTib.Self = this->teb64->value();
        teb_obj.CurrentLocale = 0x409;

        teb_obj.ProcessEnvironmentBlock = context.peb64.value();
        teb_obj.SameTebFlags.InitialThread = initial_thread;
        teb_obj.SameTebFlags.SkipThreadAttach = (create_flags & THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH) ? 1 : 0;
        teb_obj.SameTebFlags.LoaderWorker = (create_flags & THREAD_CREATE_FLAGS_LOADER_WORKER) ? 1 : 0;
        teb_obj.SameTebFlags.SkipLoaderInit = (create_flags & THREAD_CREATE_FLAGS_SKIP_LOADER_INIT) ? 1 : 0;
        teb_obj.StaticUnicodeString.MaximumLength = sizeof(teb_obj.StaticUnicodeBuffer);
        teb_obj.StaticUnicodeString.Buffer = this->teb64->value() + offsetof(TEB64, StaticUnicodeBuffer);

        // Set WowTebOffset to point to 32-bit TEB offset
        teb_obj.WowTebOffset = static_cast<int32_t>(wow_teb_offset); // 0x2000

        // Set TLS slot [1] to point to WOW64_CPURESERVED structure
        teb_obj.TlsSlots.arr[1 /* WOW64_TLS_CPURESERVED */] = wow64_cpureserved_base;

        // Note: TLS slot [10] (WOW64_INFO_PTR) will be set by wow64.dll during initialization
    });

    // Allocate dynamic 32-bit stack for WOW64 thread
    this->wow64_stack_base = memory.allocate_memory(static_cast<size_t>(this->wow64_stack_size.value()), memory_permission::read_write);

    // Create and initialize 32-bit TEB for WOW64
    // According to WinDbg: 32-bit TEB = 64-bit TEB + WowTebOffset (0x2000)
    const uint64_t teb64_addr = this->teb64->value(); // Base address of the 64-bit TEB.
    const uint64_t teb32_addr = teb64_addr + wow_teb_offset;
    uint64_t teb32_peb = 0;
    uint64_t nttib32_stack_base = this->wow64_stack_base.value() + this->wow64_stack_size.value();
    uint64_t nttib32_stack_limit = this->wow64_stack_base.value();

    // Create 32-bit TEB at the calculated offset within GS segment
    // We need to create it as an emulator_object at a specific address
    this->teb32 = emulator_object<TEB32>{memory, teb32_addr};

    // Initialize 32-bit TEB
    this->teb32->access([&](TEB32& teb32_obj) {
        // Set NT_TIB32 fields
        teb32_obj.NtTib.Self = static_cast<uint32_t>(teb32_addr);                // Self pointer to 32-bit TEB
        teb32_obj.NtTib.StackBase = static_cast<uint32_t>(nttib32_stack_base);   // Top of 32-bit stack (High address)
        teb32_obj.NtTib.StackLimit = static_cast<uint32_t>(nttib32_stack_limit); // Bottom of 32-bit stack (Low address)
        teb32_obj.NtTib.ExceptionList = static_cast<uint32_t>(0xffffffff);       // Must be 0xffffffff on 32-bit TEB
        teb32_obj.NtTib.SubSystemTib = static_cast<uint32_t>(0x0);
        teb32_obj.NtTib.FiberData = static_cast<uint32_t>(0x1e00);
        teb32_obj.NtTib.ArbitraryUserPointer = static_cast<uint32_t>(0x0);

        // Set ClientId for 32-bit TEB
        teb32_obj.ClientId.UniqueProcess = 1;
        teb32_obj.ClientId.UniqueThread = this->id;

        // Set 32-bit PEB pointer
        if (context.peb32.has_value())
        {
            teb32_obj.ProcessEnvironmentBlock = static_cast<uint32_t>(context.peb32->value());
            teb32_peb = teb32_obj.ProcessEnvironmentBlock;
        }
        else
        {
            // Fallback: WOW64 initialization will set this
            teb32_obj.ProcessEnvironmentBlock = 0;
        }

        teb32_obj.WowTebOffset = -static_cast<int32_t>(wow_teb_offset);
        teb32_obj.InitialThread = initial_thread;
        teb32_obj.SkipThreadAttach = (create_flags & THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH) ? 1 : 0;
        teb32_obj.LoaderWorker = (create_flags & THREAD_CREATE_FLAGS_LOADER_WORKER) ? 1 : 0;
        teb32_obj.SkipLoaderInit = (create_flags & THREAD_CREATE_FLAGS_SKIP_LOADER_INIT) ? 1 : 0;

        // Note: CurrentLocale and other fields will be initialized by WOW64 runtime
    });

    this->teb64->access([&](TEB64& teb_obj) {
        // teb64.ExceptionList initially points to teb32
        teb_obj.NtTib.ExceptionList = teb32_addr;
    });

    // Use the allocator to reserve memory for CONTEXT64
    this->wow64_cpu_reserved = emulator_object<WOW64_CPURESERVED>{memory, wow64_cpureserved_base};

    // Initialize with a WOW64_CONTEXT that represents the WOW64 initial state
    this->wow64_cpu_reserved->access([&](WOW64_CPURESERVED& ctx) {
        memset(&ctx, 0, sizeof(ctx));

        ctx.Flags = 0;
        ctx.MachineType = IMAGE_FILE_MACHINE_I386;

        // Set context flags for all state
        ctx.Context.ContextFlags = CONTEXT32_ALL;

        // Debug registers - all zero for initial state
        ctx.Context.Dr0 = 0;
        ctx.Context.Dr1 = 0;
        ctx.Context.Dr2 = 0;
        ctx.Context.Dr3 = 0;
        ctx.Context.Dr6 = 0;
        ctx.Context.Dr7 = 0;

        // Segment registers - WOW64 values
        ctx.Context.SegGs = 0x2b; // Standard 32-bit data segment
        ctx.Context.SegFs = 0x53; // WOW64 FS selector pointing to TEB32
        ctx.Context.SegEs = 0x2b; // Standard 32-bit data segment
        ctx.Context.SegDs = 0x2b; // Standard 32-bit data segment
        ctx.Context.SegCs = 0x23; // Standard 32-bit code segment
        ctx.Context.SegSs = 0x2b; // Standard 32-bit stack segment

        // General purpose registers - zero-extended 32-bit values
        ctx.Context.Edi = 0;
        ctx.Context.Esi = 0;
        ctx.Context.Edx = 0;
        ctx.Context.Ecx = 0;
        ctx.Context.Ebp = 0;

        // EBX - 32-bit PEB address
        ctx.Context.Ebx = static_cast<uint32_t>(teb32_peb);

        // EAX - thread entry point
        ctx.Context.Eax = static_cast<uint32_t>(this->start_address);

        // ESP - Fixed stack pointer at top of allocated stack
        ctx.Context.Esp = static_cast<uint32_t>(nttib32_stack_base - 0x10); // Leaving 0x10 bytes at top as per WinDbg

        // EIP - will be set to RtlUserThreadStart during setup_registers()
        ctx.Context.Eip = 0;

        // EFlags - standard initial flags
        ctx.Context.EFlags = 0x202; // IF (Interrupt Flag) set

        // Extended state - initialize to zero
        memset(&ctx.Context.FloatSave, 0, sizeof(ctx.Context.FloatSave));
        memset(&ctx.Context.ExtendedRegisters, 0, sizeof(ctx.Context.ExtendedRegisters));
    });
}

void emulator_thread::mark_as_ready(const NTSTATUS status)
{
    this->pending_status = status;
    this->await_time = {};
    this->await_objects = {};
    this->await_msg = {};
    this->await_io_completion = {};

    // TODO: Find out if this is correct
    if (this->waiting_for_alert)
    {
        this->alerted = false;
    }

    this->waiting_for_alert = false;
}

std::optional<msg> emulator_thread::peek_pending_message(hwnd hwnd_filter, UINT filter_min, UINT filter_max, bool remove)
{
    for (auto it = message_queue.begin(); it != message_queue.end(); ++it)
    {
        if (hwnd_filter != 0 && hwnd_filter != static_cast<hwnd>(-1) && it->window != hwnd_filter)
        {
            continue;
        }

        if (hwnd_filter == static_cast<hwnd>(-1) && it->window != 0)
        {
            continue;
        }

        if ((filter_min != 0 || filter_max != 0) && (it->message < filter_min || it->message > filter_max))
        {
            continue;
        }

        auto msg = *it;
        if (remove)
        {
            message_queue.erase(it);
        }
        return msg;
    }
    return std::nullopt;
}

void emulator_thread::post_message(const msg& msg)
{
    message_queue.push_back(msg);
}

bool emulator_thread::is_terminated() const
{
    return this->exit_status.has_value();
}

bool emulator_thread::is_thread_ready(process_context& process, utils::clock& clock)
{
    if (this->is_terminated() || this->suspended > 0)
    {
        return false;
    }

    if (this->waiting_for_alert)
    {
        if (this->alerted)
        {
            this->mark_as_ready(STATUS_ALERTED);
            return true;
        }
        if (this->is_await_time_over(clock))
        {
            this->mark_as_ready(STATUS_TIMEOUT);
            return true;
        }

        return false;
    }

    if (!this->await_objects.empty())
    {
        bool all_signaled = true;
        for (uint32_t i = 0; i < this->await_objects.size(); ++i)
        {
            const auto& obj = this->await_objects[i];

            const auto signaled = is_object_signaled(process, obj, this->id);
            all_signaled &= signaled;

            if (signaled && this->await_any)
            {
                this->mark_as_ready(STATUS_WAIT_0 + i);
                return true;
            }
        }

        if (!this->await_any && all_signaled)
        {
            this->mark_as_ready(STATUS_SUCCESS);
            return true;
        }

        if (this->is_await_time_over(clock))
        {
            this->mark_as_ready(STATUS_TIMEOUT);
            return true;
        }

        return false;
    }

    if (this->await_time.has_value())
    {
        if (this->is_await_time_over(clock))
        {
            this->mark_as_ready(STATUS_SUCCESS);
            return true;
        }

        return false;
    }

    if (this->await_io_completion.has_value())
    {
        auto timeout_expired = [&](const pending_io_completion_wait& wait) {
            constexpr auto infinite = std::chrono::steady_clock::time_point::min();
            return wait.timeout.has_value() && wait.timeout.value() != infinite && wait.timeout.value() < clock.steady_now();
        };

        const auto& wait = *this->await_io_completion;
        if (!process.io_completions.get(wait.io_completion_handle))
        {
            this->mark_as_ready(STATUS_INVALID_HANDLE);
            return true;
        }

        if (wait.type == io_completion_wait_type::remove_single)
        {
            io_completion_message message{};
            if (io_completion_wait::dequeue_io_completion_message(process, wait.io_completion_handle, message))
            {
                emulator_object<emulator_pointer>{*this->memory_ptr, wait.key_context_ptr}.write_if_valid(message.key_context);
                emulator_object<emulator_pointer>{*this->memory_ptr, wait.apc_context_ptr}.write_if_valid(message.apc_context);
                emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>>{*this->memory_ptr, wait.io_status_block_ptr}.write_if_valid(
                    message.io_status_block);

                this->mark_as_ready(STATUS_SUCCESS);
                return true;
            }

            if (timeout_expired(wait))
            {
                this->mark_as_ready(STATUS_TIMEOUT);
                return true;
            }

            return false;
        }

        if (wait.type == io_completion_wait_type::remove_multiple)
        {
            const auto removed = io_completion_wait::dequeue_io_completion_entries(
                process, wait.io_completion_handle,
                emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>>{*this->memory_ptr, wait.completion_entries_ptr},
                wait.max_entries);

            if (removed > 0)
            {
                emulator_object<ULONG>{*this->memory_ptr, wait.entries_removed_ptr}.write_if_valid(removed);
                this->mark_as_ready(STATUS_SUCCESS);
                return true;
            }

            if (timeout_expired(wait))
            {
                emulator_object<ULONG>{*this->memory_ptr, wait.entries_removed_ptr}.write_if_valid(0);
                this->mark_as_ready(STATUS_TIMEOUT);
                return true;
            }

            return false;
        }

        this->mark_as_ready(STATUS_INVALID_PARAMETER);
        return true;
    }

    if (this->await_msg.has_value())
    {
        if (const auto m =
                this->peek_pending_message(this->await_msg->hwnd_filter, this->await_msg->filter_min, this->await_msg->filter_max, true))
        {
            this->await_msg->message.write(*m);
            this->mark_as_ready(m->message != WM_QUIT ? TRUE : FALSE);
            return true;
        }

        return false;
    }

    return true;
}

void emulator_thread::setup_registers(x86_64_emulator& emu, const process_context& context) const
{
    if (!this->gs_segment)
    {
        throw std::runtime_error("Missing GS segment");
    }

    // Handle WOW64 process setup
    if (context.is_wow64_process && this->wow64_cpu_reserved.has_value())
    {
        // Set up WOW64 context with proper EIP
        this->wow64_cpu_reserved->access([&](WOW64_CPURESERVED& ctx) {
            // Set EIP to RtlUserThreadStart in 32-bit ntdll if available
            if (context.rtl_user_thread_start32.has_value())
            {
                ctx.Context.Eip = static_cast<uint32_t>(context.rtl_user_thread_start32.value());
                ctx.Context.Ebx = static_cast<uint32_t>(this->argument);
            }
        });

        // For WOW64, also set FS segment base to point to 32-bit TEB
        // Windows kernel sets both GDT descriptor and FS_BASE MSR during thread creation
        if (this->teb32.has_value())
        {
            emu.set_segment_base(x86_register::fs, this->teb32->value());
        }
    }

    // Native 64-bit process setup
    setup_stack(emu, context, this->stack_base, static_cast<size_t>(this->stack_size));
    emu.set_segment_base(x86_register::gs, this->gs_segment->get_base());

    CONTEXT64 ctx{};
    ctx.ContextFlags = CONTEXT64_ALL;

    unalign_stack(emu);
    cpu_context::save(emu, ctx);

    ctx.Rip = context.rtl_user_thread_start;
    ctx.Rcx = this->start_address;
    ctx.Rdx = this->argument;

    const auto ctx_obj = allocate_object_on_stack<CONTEXT64>(emu);
    ctx_obj.write(ctx);

    unalign_stack(emu);

    emu.reg(x86_register::rcx, ctx_obj.value());
    emu.reg(x86_register::rdx, context.ntdll_image_base);
    emu.reg(x86_register::rip, context.ldr_initialize_thunk);
}

void emulator_thread::refresh_execution_context(x86_64_emulator& emu) const
{
    (void)emu;

    if (this->teb32.has_value())
    {
        // Refresh GDT entry for FS selector on context switch
        setup_wow64_fs_segment(*this->memory_ptr, this->teb32->value());
    }
}

callback_frame::callback_frame() = default;

callback_frame::callback_frame(callback_id callback_id, std::unique_ptr<completion_state> completion_state)
{
    this->handler_id = callback_id;
    this->state = std::move(completion_state);
}

callback_frame::callback_frame(callback_frame&& obj) noexcept = default;
callback_frame& callback_frame::operator=(callback_frame&& obj) noexcept = default;

callback_frame::~callback_frame() = default;

void callback_frame::save_registers(x86_64_emulator& emu)
{
    if (this->rip != 0)
    {
        throw std::runtime_error("Attempt to overwrite callback frame register snapshot");
    }

    this->rip = emu.reg(x86_register::rip);
    this->rsp = emu.reg(x86_register::rsp);
    this->r10 = emu.reg(x86_register::r10);
    this->rcx = emu.reg(x86_register::rcx);
    this->rdx = emu.reg(x86_register::rdx);
    this->r8 = emu.reg(x86_register::r8);
    this->r9 = emu.reg(x86_register::r9);
    this->cs = emu.reg<uint16_t>(x86_register::cs);
    this->ss = emu.reg<uint16_t>(x86_register::ss);
    this->ds = emu.reg<uint16_t>(x86_register::ds);
    this->es = emu.reg<uint16_t>(x86_register::es);
    this->fs = emu.reg<uint16_t>(x86_register::fs);
    this->gs = emu.reg<uint16_t>(x86_register::gs);
}

void callback_frame::restore_registers(x86_64_emulator& emu) const
{
    if (this->rip == 0)
    {
        throw std::runtime_error("Attempt to restore registers from an uninitialized callback frame");
    }

    emu.reg<uint16_t>(x86_register::cs, this->cs);
    emu.reg<uint16_t>(x86_register::ss, this->ss);
    emu.reg<uint16_t>(x86_register::ds, this->ds);
    emu.reg<uint16_t>(x86_register::es, this->es);
    emu.reg<uint16_t>(x86_register::fs, this->fs);
    emu.reg<uint16_t>(x86_register::gs, this->gs);
    emu.reg(x86_register::rip, this->rip);
    emu.reg(x86_register::rsp, this->rsp);
    emu.reg(x86_register::r10, this->r10);
    emu.reg(x86_register::rcx, this->rcx);
    emu.reg(x86_register::rdx, this->rdx);
    emu.reg(x86_register::r8, this->r8);
    emu.reg(x86_register::r9, this->r9);
}

void callback_frame::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write(this->handler_id);
    buffer.write(this->rip);
    buffer.write(this->rsp);
    buffer.write(this->r10);
    buffer.write(this->rcx);
    buffer.write(this->rdx);
    buffer.write(this->r8);
    buffer.write(this->r9);
    buffer.write(this->cs);
    buffer.write(this->ss);
    buffer.write(this->ds);
    buffer.write(this->es);
    buffer.write(this->fs);
    buffer.write(this->gs);

    buffer.write(static_cast<bool>(this->state));
    if (this->state)
    {
        buffer.write(*this->state);
    }
}

void callback_frame::deserialize(utils::buffer_deserializer& buffer)
{
    buffer.read(this->handler_id);
    buffer.read(this->rip);
    buffer.read(this->rsp);
    buffer.read(this->r10);
    buffer.read(this->rcx);
    buffer.read(this->rdx);
    buffer.read(this->r8);
    buffer.read(this->r9);
    buffer.read(this->cs);
    buffer.read(this->ss);
    buffer.read(this->ds);
    buffer.read(this->es);
    buffer.read(this->fs);
    buffer.read(this->gs);

    bool has_state{};
    buffer.read(has_state);

    if (has_state)
    {
        this->state = syscall_dispatcher::create_completion_state(this->handler_id);
        if (!this->state)
        {
            throw std::runtime_error(
                "Serialized data indicates a completion state is present, but state creation failed for this callback id");
        }
        buffer.read(*this->state);
    }
}

```

`src/windows-emulator/emulator_thread.hpp`:

```hpp
#pragma once

#include "handles.hpp"
#include "emulator_utils.hpp"
#include "memory_manager.hpp"

#include <utils/moved_marker.hpp>

struct completion_state;
struct process_context;

struct pending_apc
{
    uint32_t flags{};
    uint64_t apc_routine{};
    uint64_t apc_argument1{};
    uint64_t apc_argument2{};
    uint64_t apc_argument3{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->flags);
        buffer.write(this->apc_routine);
        buffer.write(this->apc_argument1);
        buffer.write(this->apc_argument2);
        buffer.write(this->apc_argument3);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->flags);
        buffer.read(this->apc_routine);
        buffer.read(this->apc_argument1);
        buffer.read(this->apc_argument2);
        buffer.read(this->apc_argument3);
    }
};

struct pending_msg
{
    emulator_object<msg> message;
    hwnd hwnd_filter{};
    UINT filter_min{};
    UINT filter_max{};

    pending_msg(memory_interface& memory)
        : message(memory)
    {
    }

    pending_msg(emulator_object<msg> message, hwnd hwnd_filter, UINT filter_min, UINT filter_max)
        : message(message),
          hwnd_filter(hwnd_filter),
          filter_min(filter_min),
          filter_max(filter_max)
    {
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->message);
        buffer.write(this->hwnd_filter);
        buffer.write(this->filter_min);
        buffer.write(this->filter_max);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->message);
        buffer.read(this->hwnd_filter);
        buffer.read(this->filter_min);
        buffer.read(this->filter_max);
    }
};

enum class io_completion_wait_type : uint8_t
{
    remove_single = 0,
    remove_multiple = 1,
};

struct pending_io_completion_wait
{
    io_completion_wait_type type{io_completion_wait_type::remove_single};
    handle io_completion_handle{};
    emulator_pointer key_context_ptr{};
    emulator_pointer apc_context_ptr{};
    emulator_pointer io_status_block_ptr{};
    emulator_pointer completion_entries_ptr{};
    emulator_pointer entries_removed_ptr{};
    ULONG max_entries{};
    std::optional<std::chrono::steady_clock::time_point> timeout{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(static_cast<uint8_t>(this->type));
        buffer.write(this->io_completion_handle);
        buffer.write(this->key_context_ptr);
        buffer.write(this->apc_context_ptr);
        buffer.write(this->io_status_block_ptr);
        buffer.write(this->completion_entries_ptr);
        buffer.write(this->entries_removed_ptr);
        buffer.write(this->max_entries);
        buffer.write_optional(this->timeout);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        const auto raw_type = buffer.read<uint8_t>();
        this->type = static_cast<io_completion_wait_type>(raw_type);
        buffer.read(this->io_completion_handle);
        buffer.read(this->key_context_ptr);
        buffer.read(this->apc_context_ptr);
        buffer.read(this->io_status_block_ptr);
        buffer.read(this->completion_entries_ptr);
        buffer.read(this->entries_removed_ptr);
        buffer.read(this->max_entries);
        buffer.read_optional(this->timeout);
    }
};

enum class callback_id : uint32_t
{
    Invalid = 0,
    NtUserCreateWindowEx,
    NtUserDestroyWindow,
    NtUserShowWindow,
    NtUserMessageCall,
    NtUserEnumDisplayMonitors,
};

enum class wow64_callback_postprocess : uint8_t
{
    none = 0,
    bool_result_to_status = 1,
};

struct pending_wow64_callback
{
    uint32_t callback_id{};
    wow64_callback_postprocess postprocess{wow64_callback_postprocess::none};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->callback_id);
        buffer.write(static_cast<uint8_t>(this->postprocess));
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->callback_id);
        this->postprocess = static_cast<wow64_callback_postprocess>(buffer.read<uint8_t>());
    }
};

struct callback_frame
{
    callback_id handler_id{};
    uint64_t rip{};
    uint64_t rsp{};
    uint64_t r10{};
    uint64_t rcx{};
    uint64_t rdx{};
    uint64_t r8{};
    uint64_t r9{};
    uint16_t cs{};
    uint16_t ss{};
    uint16_t ds{};
    uint16_t es{};
    uint16_t fs{};
    uint16_t gs{};
    std::unique_ptr<completion_state> state{};

    callback_frame();
    callback_frame(callback_id callback_id, std::unique_ptr<completion_state> completion_state);

    callback_frame(const callback_frame&) = delete;
    callback_frame& operator=(const callback_frame&) = delete;

    callback_frame(callback_frame&& obj) noexcept;
    callback_frame& operator=(callback_frame&& obj) noexcept;

    ~callback_frame();

    void save_registers(x86_64_emulator& emu);
    void restore_registers(x86_64_emulator& emu) const;

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);
};

class emulator_thread : public ref_counted_object
{
  public:
    emulator_thread(memory_manager& memory)
        : memory_ptr(&memory)
    {
    }

    emulator_thread(utils::buffer_deserializer& buffer)
        : emulator_thread(buffer.read<memory_manager_wrapper>().get())
    {
    }

    emulator_thread(memory_manager& memory, const process_context& context, uint64_t start_address, uint64_t argument, uint64_t stack_size,
                    uint32_t create_flags, uint32_t id, bool initial_thread);

    emulator_thread(const emulator_thread&) = delete;
    emulator_thread& operator=(const emulator_thread&) = delete;

    emulator_thread(emulator_thread&& obj) noexcept = default;
    emulator_thread& operator=(emulator_thread&& obj) noexcept = default;

    ~emulator_thread() override
    {
        this->release();
    }

    utils::moved_marker marker{};

    memory_manager* memory_ptr{};

    uint64_t stack_base{};                    // Native 64-bit stack base
    uint64_t stack_size{};                    // Native 64-bit stack size
    std::optional<uint64_t> wow64_stack_base; // WOW64 32-bit stack base
    std::optional<uint64_t> wow64_stack_size; // WOW64 32-bit stack size
    uint64_t start_address{};
    uint64_t argument{};
    uint64_t executed_instructions{0};

    uint32_t id{};

    uint64_t current_ip{0};
    uint64_t previous_ip{0};

    std::u16string name{};

    std::optional<NTSTATUS> exit_status{};
    std::vector<handle> await_objects{};
    bool await_any{false};
    bool waiting_for_alert{false};
    bool alerted{false};
    uint32_t create_flags{0};
    uint32_t suspended{0};
    std::optional<std::chrono::steady_clock::time_point> await_time{};
    std::optional<pending_msg> await_msg{};
    std::optional<pending_io_completion_wait> await_io_completion{};

    bool apc_alertable{false};
    std::vector<pending_apc> pending_apcs{};

    std::optional<NTSTATUS> pending_status{};

    uint64_t win32k_thread_info{0};
    handle win32k_desktop{};
    uint64_t win32k_callback_buffer{0};
    std::optional<pending_wow64_callback> win32k_pending_wow64_callback{};
    bool win32k_thread_setup_pending{false};
    bool win32k_thread_setup_done{false};

    std::optional<emulator_allocator> gs_segment;
    std::optional<emulator_object<TEB64>> teb64;                          // Native 64-bit TEB
    std::optional<emulator_object<TEB32>> teb32;                          // WOW64 32-bit TEB
    std::optional<emulator_allocator> wow64_context_segment;              // For WOW64 context (CONTEXT64) allocation
    std::optional<emulator_object<WOW64_CPURESERVED>> wow64_cpu_reserved; // Persistent WOW64 thread context for ThreadWow64Context queries

    std::vector<std::byte> last_registers{};

    bool debugger_hide{false};

    std::vector<callback_frame> callback_stack;
    std::optional<uint64_t> callback_return_rax{};

    std::vector<msg> message_queue;

    void mark_as_ready(NTSTATUS status);

    bool is_await_time_over(utils::clock& clock) const
    {
        constexpr auto infinite = std::chrono::steady_clock::time_point::min();
        return this->await_time.has_value() && this->await_time.value() != infinite && this->await_time.value() < clock.steady_now();
    }

    std::optional<msg> peek_pending_message(hwnd hwnd_filter, UINT filter_min, UINT filter_max, bool remove = false);
    void post_message(const msg& msg);

    bool is_terminated() const;

    bool is_thread_ready(process_context& process, utils::clock& clock);

    void save(x86_64_emulator& emu)
    {
        this->last_registers = emu.save_registers();
    }

    void restore(x86_64_emulator& emu) const
    {
        emu.restore_registers(this->last_registers);
        this->refresh_execution_context(emu);
    }

    void setup_if_necessary(x86_64_emulator& emu, const process_context& context)
    {
        if (!this->executed_instructions)
        {
            this->setup_registers(emu, context);
        }

        if (this->pending_status.has_value())
        {
            const auto status = *this->pending_status;
            this->pending_status = {};

            emu.reg<uint64_t>(x86_register::rax, static_cast<uint64_t>(status));
        }
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        if (this->marker.was_moved())
        {
            throw std::runtime_error("Object was moved!");
        }

        buffer.write(this->stack_base);
        buffer.write(this->stack_size);
        buffer.write(this->start_address);
        buffer.write(this->argument);
        buffer.write(this->executed_instructions);
        buffer.write(this->id);
        buffer.write(this->current_ip);
        buffer.write(this->previous_ip);

        buffer.write_string(this->name);

        buffer.write_optional(this->exit_status);
        buffer.write_vector(this->await_objects);
        buffer.write(this->await_any);

        buffer.write(this->waiting_for_alert);
        buffer.write(this->alerted);

        buffer.write(this->create_flags);
        buffer.write(this->suspended);
        buffer.write_optional(this->await_time);
        buffer.write_optional(this->await_msg);
        buffer.write_optional(this->await_io_completion);

        buffer.write(this->apc_alertable);
        buffer.write_vector(this->pending_apcs);

        buffer.write_optional(this->pending_status);
        buffer.write(this->win32k_thread_info);
        buffer.write(this->win32k_desktop);
        buffer.write(this->win32k_callback_buffer);
        buffer.write_optional(this->win32k_pending_wow64_callback);
        buffer.write(this->win32k_thread_setup_pending);
        buffer.write(this->win32k_thread_setup_done);
        buffer.write_optional(this->gs_segment);
        buffer.write_optional(this->teb64);
        buffer.write_optional(this->wow64_stack_base);
        buffer.write_optional(this->wow64_stack_size);
        buffer.write_optional(this->teb32);
        buffer.write_optional(this->wow64_context_segment);
        buffer.write_optional(this->wow64_cpu_reserved);

        buffer.write_vector(this->last_registers);

        buffer.write(this->debugger_hide);

        buffer.write_vector(this->callback_stack);
        buffer.write_optional(this->callback_return_rax);

        buffer.write_vector(this->message_queue);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        if (this->marker.was_moved())
        {
            throw std::runtime_error("Object was moved!");
        }

        this->release();

        buffer.read(this->stack_base);
        buffer.read(this->stack_size);
        buffer.read(this->start_address);
        buffer.read(this->argument);
        buffer.read(this->executed_instructions);
        buffer.read(this->id);
        buffer.read(this->current_ip);
        buffer.read(this->previous_ip);

        buffer.read_string(this->name);

        buffer.read_optional(this->exit_status);
        buffer.read_vector(this->await_objects);
        buffer.read(this->await_any);

        buffer.read(this->waiting_for_alert);
        buffer.read(this->alerted);

        buffer.read(this->create_flags);
        buffer.read(this->suspended);
        buffer.read_optional(this->await_time);
        buffer.read_optional(this->await_msg, [this] { return pending_msg{*this->memory_ptr}; });
        buffer.read_optional(this->await_io_completion, [] { return pending_io_completion_wait{}; });

        buffer.read(this->apc_alertable);
        buffer.read_vector(this->pending_apcs);

        buffer.read_optional(this->pending_status);
        buffer.read(this->win32k_thread_info);
        buffer.read(this->win32k_desktop);
        buffer.read(this->win32k_callback_buffer);
        buffer.read_optional(this->win32k_pending_wow64_callback, [] { return pending_wow64_callback{}; });
        buffer.read(this->win32k_thread_setup_pending);
        buffer.read(this->win32k_thread_setup_done);
        buffer.read_optional(this->gs_segment, [this] { return emulator_allocator(*this->memory_ptr); });
        buffer.read_optional(this->teb64, [this] { return emulator_object<TEB64>(*this->memory_ptr); });
        buffer.read_optional(this->wow64_stack_base);
        buffer.read_optional(this->wow64_stack_size);
        buffer.read_optional(this->teb32, [this] { return emulator_object<TEB32>(*this->memory_ptr); });
        buffer.read_optional(this->wow64_context_segment, [this] { return emulator_allocator(*this->memory_ptr); });
        buffer.read_optional(this->wow64_cpu_reserved, [this] { return emulator_object<WOW64_CPURESERVED>(*this->memory_ptr); });

        buffer.read_vector(this->last_registers);

        buffer.read(this->debugger_hide);

        buffer.read_vector(this->callback_stack);
        buffer.read_optional(this->callback_return_rax);

        buffer.read_vector(this->message_queue);
    }

    void leak_memory()
    {
        this->marker.mark_as_moved();
    }

    static bool deleter(emulator_thread& t)
    {
        return ref_counted_object::deleter(t) && t.is_terminated();
    }

  private:
    void setup_registers(x86_64_emulator& emu, const process_context& context) const;
    void refresh_execution_context(x86_64_emulator& emu) const;

    void release()
    {
        if (this->marker.was_moved())
        {
            return;
        }

        if (this->stack_base)
        {
            if (!this->memory_ptr)
            {
                throw std::runtime_error("Emulator was never assigned!");
            }

            this->memory_ptr->release_memory(this->stack_base, static_cast<size_t>(this->stack_size));
            this->stack_base = 0;
        }

        if (this->gs_segment)
        {
            this->gs_segment->release(*this->memory_ptr);
            this->gs_segment = {};
        }
    }
};

```

`src/windows-emulator/emulator_utils.hpp`:

```hpp
#pragma once

#include <arch_emulator.hpp>

#include "memory_manager.hpp"
#include "memory_utils.hpp"
#include "address_utils.hpp"
#include "x86_register.hpp"
#include "common/segment_utils.hpp"

#include <utils/time.hpp>

namespace network
{
    struct socket_factory;
}

// TODO: Replace with pointer handling structure for future 32 bit support
using emulator_pointer = uint64_t;

template <typename T>
class object_wrapper
{
    T* obj_;

  public:
    object_wrapper(T& obj)
        : obj_(&obj)
    {
    }

    T& get() const
    {
        return *this->obj_;
    }

    operator T&() const
    {
        return this->get();
    }

    void serialize(utils::buffer_serializer&) const
    {
    }

    void deserialize(utils::buffer_deserializer&)
    {
    }
};

class windows_emulator;
class module_manager;
struct process_context;

using clock_wrapper = object_wrapper<utils::clock>;
using x64_emulator_wrapper = object_wrapper<x86_64_emulator>;
using memory_manager_wrapper = object_wrapper<memory_manager>;
using module_manager_wrapper = object_wrapper<module_manager>;
using process_context_wrapper = object_wrapper<process_context>;
using windows_emulator_wrapper = object_wrapper<windows_emulator>;
using socket_factory_wrapper = object_wrapper<network::socket_factory>;

template <typename T>
class emulator_object
{
  public:
    using value_type = T;

    emulator_object(const x64_emulator_wrapper& wrapper, const uint64_t address = 0)
        : emulator_object(wrapper.get(), address)
    {
    }

    emulator_object(memory_interface& memory, const uint64_t address = 0)
        : memory_(&memory),
          address_(address)
    {
    }

    emulator_object(emulator& emu, const void* address)
        : emulator_object(emu, reinterpret_cast<uint64_t>(address))
    {
    }

    emulator_object(utils::buffer_deserializer& buffer)
        : emulator_object(buffer.read<memory_manager_wrapper>().get())
    {
    }

    uint64_t value() const
    {
        return this->address_;
    }

    constexpr uint64_t size() const
    {
        return sizeof(T);
    }

    uint64_t end() const
    {
        return this->value() + this->size();
    }

    explicit operator bool() const
    {
        return this->address_ != 0;
    }

    std::optional<T> try_read(const size_t index = 0) const
    {
        T obj{};
        if (this->memory_->try_read_memory(this->address_ + index * this->size(), &obj, sizeof(obj)))
        {
            return obj;
        }
        return std::nullopt;
    }

    T read(const size_t index = 0) const
    {
        T obj{};
        this->memory_->read_memory(this->address_ + index * this->size(), &obj, sizeof(obj));
        return obj;
    }

    bool try_write(const T& value, const size_t index = 0) const
    {
        return this->memory_->try_write_memory(this->address_ + index * this->size(), &value, sizeof(value));
    }

    void write(const T& value, const size_t index = 0) const
    {
        this->memory_->write_memory(this->address_ + index * this->size(), &value, sizeof(value));
    }

    void write_if_valid(const T& value, const size_t index = 0) const
    {
        if (this->operator bool())
        {
            this->write(value, index);
        }
    }

    template <typename F>
    void access_safe(const F& accessor, const size_t index = 0) const
    {
        auto obj = std::make_unique<T>();
        this->access_object(accessor, *obj, index);
    }

    template <typename F>
    void access(const F& accessor, const size_t index = 0) const
    {
        if constexpr (sizeof(T) < 0x4000)
        {
            T obj{};
            this->access_object(accessor, obj, index);
        }
        else
        {
            this->access_safe(accessor, index);
        }
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->address_);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->address_);
    }

    void set_address(const uint64_t address)
    {
        this->address_ = address;
    }

    emulator_object<T> shift(const int64_t offset) const
    {
        return emulator_object<T>(*this->memory_, this->address_ + offset);
    }

    memory_interface* get_memory_interface() const
    {
        return this->memory_;
    }

  private:
    memory_interface* memory_{};
    uint64_t address_{};

    template <typename F>
    void access_object(const F& accessor, T& obj, const size_t index = 0) const
    {
        this->memory_->read_memory(this->address_ + index * this->size(), &obj, sizeof(obj));

        accessor(obj);

        this->write(obj, index);
    }
};

// TODO: warning emulator_utils is hardcoded for 64bit unicode_string usage
class emulator_allocator
{
  public:
    emulator_allocator(memory_interface& memory)
        : memory_(&memory)
    {
    }

    emulator_allocator(memory_interface& memory, const uint64_t address, const uint64_t size)
        : memory_(&memory),
          address_(address),
          size_(size),
          active_address_(address)
    {
    }

    uint64_t reserve(const uint64_t count, const uint64_t alignment = 1)
    {
        const auto potential_start = align_up(this->active_address_, alignment);
        const auto potential_end = potential_start + count;
        const auto total_end = this->address_ + this->size_;

        if (potential_end > total_end)
        {
            throw std::runtime_error("Out of memory");
        }

        this->active_address_ = potential_end;

        return potential_start;
    }

    template <typename T>
    emulator_object<T> reserve(const size_t count = 1)
    {
        const auto potential_start = this->reserve(sizeof(T) * count, alignof(T));
        return emulator_object<T>(*this->memory_, potential_start);
    }

    template <typename T>
    emulator_object<T> reserve_page_aligned(const size_t count = 1)
    {
        constexpr auto page_aligned_size = page_align_up(sizeof(T));
        const auto potential_start = this->reserve(page_aligned_size * count, 0x1000);
        return emulator_object<T>(*this->memory_, potential_start);
    }

    uint64_t copy_string(const std::u16string_view str)
    {
        UNICODE_STRING<EmulatorTraits<Emu64>> uc_str{};
        this->make_unicode_string(uc_str, str);
        return uc_str.Buffer;
    }

    template <typename EMU = Emu64>
    void make_unicode_string(UNICODE_STRING<EmulatorTraits<EMU>>& result, const std::u16string_view str,
                             const std::optional<size_t> maximum_length = std::nullopt)
    {
        constexpr auto element_size = sizeof(str[0]);
        constexpr auto required_alignment = alignof(decltype(str[0]));
        const auto total_length = str.size() * element_size;
        const auto total_buffer_length = total_length + element_size;

        const auto max_length = std::max(maximum_length.value_or(total_buffer_length), total_buffer_length);

        const auto string_buffer = this->reserve(max_length, required_alignment);

        this->memory_->write_memory(string_buffer, str.data(), total_length);

        constexpr std::array<char, element_size> nullbyte{};
        this->memory_->write_memory(string_buffer + total_length, nullbyte.data(), nullbyte.size());

        result.Buffer = static_cast<EmulatorTraits<EMU>::PVOID>(string_buffer);
        result.Length = static_cast<USHORT>(total_length);
        result.MaximumLength = static_cast<USHORT>(max_length);
    }

    template <typename EMU = Emu64>
    emulator_object<UNICODE_STRING<EmulatorTraits<EMU>>> make_unicode_string(const std::u16string_view str,
                                                                             const std::optional<size_t> maximum_length = std::nullopt)
    {
        const auto unicode_string = this->reserve<UNICODE_STRING<EmulatorTraits<Emu64>>>();

        unicode_string.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& unicode_str) {
            this->make_unicode_string(unicode_str, str, maximum_length); //
        });

        return unicode_string;
    }

    uint64_t get_base() const
    {
        return this->address_;
    }

    uint64_t get_size() const
    {
        return this->size_;
    }

    uint64_t get_next_address() const
    {
        return this->active_address_;
    }

    memory_interface& get_memory() const
    {
        return *this->memory_;
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->address_);
        buffer.write(this->size_);
        buffer.write(this->active_address_);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->address_);
        buffer.read(this->size_);
        buffer.read(this->active_address_);
    }

    void release(memory_manager& manager)
    {
        if (this->address_ && this->size_)
        {
            // TODO: Make all sizes uint64_t
            manager.release_memory(this->address_, static_cast<size_t>(this->size_));
            this->address_ = 0;
            this->size_ = 0;
        }
    }

    void skip(const uint64_t bytes)
    {
        this->active_address_ += bytes;
    }

    void skip_until(const uint64_t offset)
    {
        this->active_address_ = this->address_ + offset;
    }

  private:
    memory_interface* memory_{};
    uint64_t address_{};
    uint64_t size_{};
    uint64_t active_address_{0};
};

template <typename Element>
std::basic_string<Element> read_string(memory_interface& mem, const uint64_t address, const std::optional<size_t> size = {})
{
    std::basic_string<Element> result{};

    for (size_t i = 0;; ++i)
    {
        if (size && i >= *size)
        {
            break;
        }

        Element element{};
        mem.read_memory(address + (i * sizeof(element)), &element, sizeof(element));

        if (!size && !element)
        {
            break;
        }

        result.push_back(element);
    }

    return result;
}

inline std::u16string read_unicode_string(const emulator& emu, const UNICODE_STRING<EmulatorTraits<Emu64>> ucs)
{
    static_assert(offsetof(UNICODE_STRING<EmulatorTraits<Emu64>>, Length) == 0);
    static_assert(offsetof(UNICODE_STRING<EmulatorTraits<Emu64>>, MaximumLength) == 2);
    static_assert(offsetof(UNICODE_STRING<EmulatorTraits<Emu64>>, Buffer) == 8);
    static_assert(sizeof(UNICODE_STRING<EmulatorTraits<Emu64>>) == 16);

    std::u16string result{};
    result.resize(ucs.Length / 2);

    emu.read_memory(ucs.Buffer, result.data(), ucs.Length);

    return result;
}

inline std::u16string read_unicode_string(const emulator& emu, const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> uc_string)
{
    const auto ucs = uc_string.read();
    return read_unicode_string(emu, ucs);
}

inline std::u16string read_unicode_string(emulator& emu, const uint64_t uc_string)
{
    return read_unicode_string(emu, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>>{emu, uc_string});
}

/// Retrieves function arguments from registers or stack memory. This function assumes the stack pointer currently points to the
/// return address.
inline uint64_t get_function_argument(x86_64_emulator& emu, const size_t index, const bool is_syscall = false)
{
    bool use_32bit_stack = false;

    if (!is_syscall)
    {
        const auto cs_selector = emu.reg<uint16_t>(x86_register::cs);
        const auto bitness = segment_utils::get_segment_bitness(emu, cs_selector);
        use_32bit_stack = bitness && *bitness == segment_utils::segment_bitness::bit32;
    }

    if (use_32bit_stack)
    {
        const auto esp = emu.reg<uint32_t>(x86_register::esp);
        const auto address = static_cast<uint64_t>(esp) + static_cast<uint64_t>((index + 1) * sizeof(uint32_t));
        return static_cast<uint64_t>(emu.read_memory<uint32_t>(address));
    }

    switch (index)
    {
    case 0:
        return emu.reg(is_syscall ? x86_register::r10 : x86_register::rcx);
    case 1:
        return emu.reg(x86_register::rdx);
    case 2:
        return emu.reg(x86_register::r8);
    case 3:
        return emu.reg(x86_register::r9);
    default:
        return emu.read_stack(index + 1);
    }
}

/// Sets function arguments in registers or stack memory. This function does not modify RSP and assumes the caller has already allocated
/// stack space and that RSP currently points to the return address.
inline void set_function_argument(x86_64_emulator& emu, const size_t index, const uint64_t value, const bool is_syscall = false)
{
    bool use_32bit_stack = false;
    if (!is_syscall)
    {
        const auto cs_selector = emu.reg<uint16_t>(x86_register::cs);
        const auto bitness = segment_utils::get_segment_bitness(emu, cs_selector);
        use_32bit_stack = bitness && *bitness == segment_utils::segment_bitness::bit32;
    }

    if (use_32bit_stack)
    {
        const auto esp = emu.reg<uint32_t>(x86_register::esp);
        const auto address = static_cast<uint64_t>(esp) + static_cast<uint64_t>((index + 1) * sizeof(uint32_t));
        emu.write_memory<uint32_t>(address, static_cast<uint32_t>(value));
        return;
    }

    switch (index)
    {
    case 0:
        emu.reg(is_syscall ? x86_register::r10 : x86_register::rcx, value);
        break;
    case 1:
        emu.reg(x86_register::rdx, value);
        break;
    case 2:
        emu.reg(x86_register::r8, value);
        break;
    case 3:
        emu.reg(x86_register::r9, value);
        break;
    default:
        emu.write_stack(index + 1, value);
        break;
    }
}

constexpr size_t aligned_stack_space(const size_t arg_count)
{
    const size_t slots = (arg_count < 4) ? 4 : arg_count;
    const size_t bytes = slots * sizeof(uint64_t);
    return (bytes + 15) & ~15;
}

```

`src/windows-emulator/exception_dispatch.cpp`:

```cpp
#include "std_include.hpp"
#include "exception_dispatch.hpp"
#include "process_context.hpp"
#include "cpu_context.hpp"
#include "windows_emulator.hpp"

#include "common/segment_utils.hpp"
#include "wow64_heaven_gate.hpp"

namespace
{
    using exception_record = EMU_EXCEPTION_RECORD<EmulatorTraits<Emu64>>;
    using exception_record_map = std::unordered_map<const exception_record*, emulator_object<exception_record>>;

    emulator_object<exception_record> save_exception_record(emulator_allocator& allocator, const exception_record& record,
                                                            exception_record_map& record_mapping)
    {
        const auto record_obj = allocator.reserve<exception_record>();
        record_obj.write(record);

        if (record.ExceptionRecord)
        {
            record_mapping.emplace(&record, record_obj);

            emulator_object<exception_record> nested_record_obj{allocator.get_memory()};
            const auto nested_record = record_mapping.find(reinterpret_cast<exception_record*>(record.ExceptionRecord));

            if (nested_record != record_mapping.end())
            {
                nested_record_obj = nested_record->second;
            }
            else
            {
                nested_record_obj =
                    save_exception_record(allocator, *reinterpret_cast<exception_record*>(record.ExceptionRecord), record_mapping);
            }

            record_obj.access([&](exception_record& r) {
                r.ExceptionRecord = nested_record_obj.value(); //
            });
        }

        return record_obj;
    }

    emulator_object<exception_record> save_exception_record(emulator_allocator& allocator, const exception_record& record)
    {
        exception_record_map record_mapping{};
        return save_exception_record(allocator, record, record_mapping);
    }

    uint32_t map_violation_operation_to_parameter(const memory_operation operation)
    {
        switch (operation)
        {
        default:
        case memory_operation::read:
            return 0;
        case memory_operation::write:
        case memory_operation::exec:
            return 1;
        }
    }

    size_t calculate_exception_record_size(const exception_record& record)
    {
        std::unordered_set<const exception_record*> records{};
        size_t total_size = 0;

        const exception_record* current_record = &record;
        while (current_record)
        {
            if (!records.insert(current_record).second)
            {
                break;
            }

            total_size += sizeof(*current_record);
            current_record = reinterpret_cast<exception_record*>(record.ExceptionRecord);
        }

        return total_size;
    }

    struct machine_frame
    {
        uint64_t rip;
        uint64_t cs;
        uint64_t eflags;
        uint64_t rsp;
        uint64_t ss;
    };

    void dispatch_exception_pointers(x86_64_emulator& emu, const uint64_t dispatcher,
                                     const EMU_EXCEPTION_POINTERS<EmulatorTraits<Emu64>> pointers)
    {
        constexpr auto mach_frame_size = 0x40;
        constexpr auto context_record_size = 0x4F0;
        const auto exception_record_size = calculate_exception_record_size(*reinterpret_cast<exception_record*>(pointers.ExceptionRecord));
        const auto combined_size = align_up(exception_record_size + context_record_size, 0x10);

        assert(combined_size == 0x590);

        const auto allocation_size = combined_size + mach_frame_size;

        const auto initial_sp = emu.reg(x86_register::rsp);
        const auto new_sp = align_down(initial_sp - allocation_size, 0x100);

        const auto total_size = initial_sp - new_sp;
        assert(total_size >= allocation_size);

        std::vector<uint8_t> zero_memory{};
        zero_memory.resize(static_cast<size_t>(total_size), 0);

        emu.write_memory(new_sp, zero_memory.data(), zero_memory.size());

        const emulator_object<CONTEXT64> context_record_obj{emu, new_sp};
        context_record_obj.write(*reinterpret_cast<CONTEXT64*>(pointers.ContextRecord));

        emulator_allocator allocator{emu, new_sp + context_record_size, exception_record_size};
        const auto exception_record_obj = save_exception_record(allocator, *reinterpret_cast<exception_record*>(pointers.ExceptionRecord));

        if (exception_record_obj.value() != allocator.get_base())
        {
            throw std::runtime_error("Bad exception record position on stack");
        }

        const emulator_object<machine_frame> machine_frame_obj{emu, new_sp + combined_size};
        machine_frame_obj.access([&](machine_frame& frame) {
            const auto& record = *reinterpret_cast<CONTEXT64*>(pointers.ContextRecord);
            frame.rip = record.Rip;
            frame.rsp = record.Rsp;
            frame.ss = record.SegSs;
            frame.cs = record.SegCs;
            frame.eflags = record.EFlags;
        });

        const auto cs_selector = emu.reg<uint16_t>(x86_register::cs);
        const auto bitness = segment_utils::get_segment_bitness(emu, cs_selector);

        if (!bitness || *bitness != segment_utils::segment_bitness::bit32)
        {
            emu.reg(x86_register::rsp, new_sp);
            emu.reg(x86_register::rip, dispatcher);
            return;
        }

        emu.reg(x86_register::rax, dispatcher);
        emu.reg(x86_register::rbx, new_sp);
        emu.reg(x86_register::rcx, static_cast<uint64_t>(wow64::heaven_gate::kUserCodeSelector));
        emu.reg(x86_register::rdx, static_cast<uint64_t>(wow64::heaven_gate::kUserStackSelector));
        emu.reg(x86_register::rsp, wow64::heaven_gate::kStackTop);
        emu.reg(x86_register::rip, wow64::heaven_gate::kCodeBase);
    }
}

bool dispatch_debug_exception(windows_emulator& win_emu, CONTEXT64& ctx, EMU_EXCEPTION_RECORD<EmulatorTraits<Emu64>>& record)
{
    std::array<uint8_t, 2> ins = {0};

    // CD 2D int 2dh
    if (win_emu.memory.try_read_memory(ctx.Rip, &ins, sizeof(ins)) && ins[0] == 0xCD && ins[1] == 0x2D)
    {
        // skip 2 bytes int 2dh
        ctx.Rip += 2;

        record.NumberParameters = 3;

        record.ExceptionInformation[0] = ctx.Rax;
        record.ExceptionInformation[1] = ctx.Rcx;
        record.ExceptionInformation[2] = ctx.Rdx;

        // https://github.com/ayoubfaouzi/al-khaser/issues/223

        // inc qword ptr [rbp + KTRAP_FRAME_Rip]
        ctx.Rip++;

        switch (ctx.Rax)
        {
        case BREAKPOINT_BREAK:
            // just drops straight into the debugger trap handler. Doesn't increment the instruction pointer.
            break;
        case BREAKPOINT_PRINT:
            // calls BREAKPOINT_PRINT service, which is implemented by KdpPrint, increments the instruction pointer.
            ctx.Rip += 3;
            break;
        case BREAKPOINT_PROMPT:
            // calls BREAKPOINT_PROMPT service, which is implemented by KdpPrompt, doesn't increment the instruction pointer.
            break;
        case BREAKPOINT_LOAD_SYMBOLS:
            // calls BREAKPOINT_LOAD_SYMBOLS, which is implemented by KdpSymbol, increments the instruction pointer.
            ctx.Rip += 3;
            break;
        case BREAKPOINT_UNLOAD_SYMBOLS:
            // calls BREAKPOINT_UNLOAD_SYMBOLS, which is also implemented by KdpSymbol, increments the instruction pointer.
            ctx.Rip += 3;
            break;
        case BREAKPOINT_COMMAND_STRING:
            // calls BREAKPOINT_COMMAND_STRING, which is implemented in KdpCommandString, increments the instruction pointer.
            ctx.Rip += 3;
            break;
        default:
            break;
        }

        return true;
    }

    return false;
}

void dispatch_exception(windows_emulator& win_emu, const DWORD status, const std::vector<EmulatorTraits<Emu64>::ULONG_PTR>& parameters)
{
    CONTEXT64 ctx{};
    ctx.ContextFlags = CONTEXT64_ALL;
    cpu_context::save(win_emu.emu(), ctx);
    ctx.Rip = win_emu.current_thread().current_ip;

    exception_record record{};
    memset(&record, 0, sizeof(record));
    record.ExceptionCode = status;
    record.ExceptionFlags = 0;
    record.ExceptionRecord = 0;
    record.NumberParameters = 0;

    bool is_debug_exception = false;
    if (status == STATUS_BREAKPOINT)
    {
        is_debug_exception = dispatch_debug_exception(win_emu, ctx, record);
    }

    if (!is_debug_exception)
    {
        record.NumberParameters = static_cast<DWORD>(parameters.size());

        if (parameters.size() > 15)
        {
            throw std::runtime_error("Too many exception parameters");
        }

        for (size_t i = 0; i < parameters.size(); ++i)
        {
            record.ExceptionInformation[i] = parameters[i];
        }
    }

    record.ExceptionAddress = ctx.Rip;

    EMU_EXCEPTION_POINTERS<EmulatorTraits<Emu64>> pointers{};
    pointers.ContextRecord = reinterpret_cast<EmulatorTraits<Emu64>::PVOID>(&ctx);
    pointers.ExceptionRecord = reinterpret_cast<EmulatorTraits<Emu64>::PVOID>(&record);

    dispatch_exception_pointers(win_emu.emu(), win_emu.process.ki_user_exception_dispatcher, pointers);
}

void dispatch_access_violation(windows_emulator& win_emu, const uint64_t address, const memory_operation operation)
{
    dispatch_exception(win_emu, STATUS_ACCESS_VIOLATION,
                       {
                           map_violation_operation_to_parameter(operation),
                           address,
                       });
}

void dispatch_guard_page_violation(windows_emulator& win_emu, const uint64_t address, const memory_operation operation)
{
    dispatch_exception(win_emu, STATUS_GUARD_PAGE_VIOLATION,
                       {
                           map_violation_operation_to_parameter(operation),
                           address,
                       });
}

void dispatch_illegal_instruction_violation(windows_emulator& win_emu)
{
    dispatch_exception(win_emu, STATUS_ILLEGAL_INSTRUCTION, {});
}

void dispatch_integer_division_by_zero(windows_emulator& win_emu)
{
    dispatch_exception(win_emu, STATUS_INTEGER_DIVIDE_BY_ZERO, {});
}

void dispatch_single_step(windows_emulator& win_emu)
{
    dispatch_exception(win_emu, STATUS_SINGLE_STEP, {});
}

void dispatch_breakpoint(windows_emulator& win_emu)
{
    dispatch_exception(win_emu, STATUS_BREAKPOINT, {});
}

```

`src/windows-emulator/exception_dispatch.hpp`:

```hpp
#pragma once

#include <arch_emulator.hpp>

#include <platform/traits.hpp>
#include <platform/primitives.hpp>

//
// DebugService Control Types
//
#define BREAKPOINT_BREAK          0
#define BREAKPOINT_PRINT          1
#define BREAKPOINT_PROMPT         2
#define BREAKPOINT_LOAD_SYMBOLS   3
#define BREAKPOINT_UNLOAD_SYMBOLS 4
#define BREAKPOINT_COMMAND_STRING 5

class windows_emulator;

void dispatch_exception(windows_emulator& win_emu, DWORD status, const std::vector<EmulatorTraits<Emu64>::ULONG_PTR>& parameters);
template <typename T>
    requires(std::is_integral_v<T> && !std::is_same_v<T, DWORD>)
void dispatch_exception(windows_emulator& win_emu, const T status, const std::vector<EmulatorTraits<Emu64>::ULONG_PTR>& parameters)
{
    dispatch_exception(win_emu, static_cast<DWORD>(status), parameters);
}

bool dispatch_debug_exception(windows_emulator& win_emu, CONTEXT64& ctx, EMU_EXCEPTION_RECORD<EmulatorTraits<Emu64>>& record);
void dispatch_access_violation(windows_emulator& win_emu, uint64_t address, memory_operation operation);
void dispatch_guard_page_violation(windows_emulator& win_emu, uint64_t address, memory_operation operation);
void dispatch_illegal_instruction_violation(windows_emulator& win_emu);
void dispatch_integer_division_by_zero(windows_emulator& win_emu);
void dispatch_single_step(windows_emulator& win_emu);
void dispatch_breakpoint(windows_emulator& win_emu);

```

`src/windows-emulator/file_system.hpp`:

```hpp
#pragma once
#include "std_include.hpp"
#include "windows_path.hpp"

class file_system
{
  public:
    file_system(const std::filesystem::path& root)
        : root_(canonical(root))
    {
    }

    static bool is_escaping_relative_path(const std::filesystem::path& p)
    {
        return p.empty() || *p.begin() == "..";
    }

    static bool is_subpath(const std::filesystem::path& normal_root, const std::filesystem::path& normal_target)
    {
        const auto relative_path = relative(normal_target, normal_root);
        return !is_escaping_relative_path(relative_path);
    }

    std::set<char> list_drives() const
    {
        std::set<char> drives{};

#ifdef OS_WINDOWS
        if (this->root_.empty())
        {
            const auto drive_bits = GetLogicalDrives();

            for (char drive = 'a'; drive <= 'z'; ++drive)
            {
                const auto drive_index = drive - 'a';
                if (drive_bits & (1 << drive_index))
                {
                    drives.insert(drive);
                }
            }

            return drives;
        }
#endif

        std::error_code ec{};
        for (const auto& file : std::filesystem::directory_iterator(this->root_, ec))
        {
            const auto filename = file.path().filename().string();
            if (filename.size() == 1)
            {
                drives.insert(utils::string::char_to_lower(filename.front()));
            }
        }

        return drives;
    }

    std::filesystem::path translate(const windows_path& win_path) const
    {
        if (!win_path.is_absolute())
        {
            throw std::runtime_error("Only absolute paths can be translated: " + win_path.string());
        }

        const auto mapping = this->mappings_.find(win_path);
        if (mapping != this->mappings_.end())
        {
            return mapping->second;
        }

#ifdef OS_WINDOWS
        if (this->root_.empty())
        {
            return win_path.u16string();
        }
#endif

        const std::array<char, 2> root_drive{win_path.get_drive().value_or('c'), 0};
        auto root = this->root_ / root_drive.data();

        auto path = this->root_ / win_path.to_portable_path();
        path = weakly_canonical(path);
        if (is_subpath(root, path))
        {
            return path;
        }

        return root;
    }

    template <typename F>
    void access_mapped_entries(const windows_path& win_path, const F& accessor) const
    {
        for (const auto& mapping : this->mappings_)
        {
            const auto& mapped_path = mapping.first;
            if (!mapped_path.empty() && mapped_path.parent() == win_path)
            {
                accessor(mapping);
            }
        }
    }

    void map(windows_path src, std::filesystem::path dest)
    {
        this->mappings_[std::move(src)] = std::move(dest);
    }

  private:
    std::filesystem::path root_{};
    std::unordered_map<windows_path, std::filesystem::path> mappings_{};
};

```

`src/windows-emulator/generic_logger.hpp`:

```hpp
#pragma once
#include <utils/object.hpp>

#if (defined(__clang__) || defined(__GNUC__)) && !defined(__MINGW64__)
#define FORMAT_ATTRIBUTE(fmt_pos, var_pos) __attribute__((format(printf, fmt_pos, var_pos)))
#else
#define FORMAT_ATTRIBUTE(fmt_pos, var_pos)
#endif

enum class color
{
    black,
    red,
    green,
    yellow,
    blue,
    cyan,
    pink,
    white,
    gray,
    dark_gray,
};

struct generic_logger : utils::object
{
    virtual void print(color c, std::string_view message) = 0;
    virtual void print(color c, const char* message, ...) FORMAT_ATTRIBUTE(3, 4) = 0;
};

```

`src/windows-emulator/handles.hpp`:

```hpp
#pragma once

#include <serialization.hpp>

struct handle_types
{
    enum type : uint16_t
    {
        reserved = 0,
        file,
        device,
        event,
        section,
        symlink,
        directory,
        semaphore,
        port,
        thread,
        registry,
        mutant,
        token,
        window,
        timer,
        monitor,
        desktop,
        io_completion,
        wait_completion_packet,
        worker_factory,
    };
};

#pragma pack(push)
#pragma pack(1)
struct handle_value
{
    uint64_t id : 23;
    uint64_t type : 7;
    uint64_t is_system : 1;
    uint64_t is_pseudo : 1;
    uint64_t high_bits : 32;
};
#pragma pack(pop)

static_assert(sizeof(handle_value) == 8);

// TODO: this is a concrete 64bit handle
union handle
{
    handle_value value;
    uint64_t bits;
    std::uint64_t h;
};

namespace utils
{
    inline void serialize(buffer_serializer& buffer, const handle& h)
    {
        buffer.write(h.bits);
    }

    inline void deserialize(buffer_deserializer& buffer, handle& h)
    {
        buffer.read(h.bits);
    }
}

inline bool operator==(const handle& h1, const handle& h2)
{
    uint64_t h1_bits = (h1.bits & 0x00000000FFFFFFFF);
    uint64_t h2_bits = (h2.bits & 0x00000000FFFFFFFF);
    return h1_bits == h2_bits;
}

inline bool operator==(const handle& h1, const uint64_t& h2)
{
    uint64_t h1_bits = (h1.bits & 0x00000000FFFFFFFF);
    uint64_t h2_bits = (h2 & 0x00000000FFFFFFFF);
    return h1_bits == h2_bits;
}

inline handle_value get_handle_value(const uint64_t h)
{
    handle hh{};
    hh.bits = h;
    return hh.value;
}

constexpr handle make_handle(const uint32_t id, const handle_types::type type, const bool is_pseudo)
{
    handle_value value{};

    // value.padding = 0;
    value.id = id;
    value.type = type;
    value.is_system = false;
    value.is_pseudo = is_pseudo;

    return {value};
}

constexpr handle make_handle(const uint64_t value)
{
    handle h{};
    h.bits = value;
    return h;
}

constexpr handle make_pseudo_handle(const uint32_t id, const handle_types::type type)
{
    return make_handle(id, type, true);
}

namespace handle_detail
{
    template <typename, typename = void>
    struct has_deleter_function : std::false_type
    {
    };

    template <typename T>
    struct has_deleter_function<T, std::void_t<decltype(T::deleter(std::declval<T&>()))>>
        : std::is_same<decltype(T::deleter(std::declval<T&>())), bool>
    {
    };
}

class ref_counted_object
{
  public:
    virtual ~ref_counted_object() = default;

    uint32_t ref_count{1};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->ref_count);
        this->serialize_object(buffer);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->ref_count);
        this->deserialize_object(buffer);
    }

    static bool deleter(ref_counted_object& e)
    {
        if (e.ref_count == 0)
        {
            return true;
        }

        return --e.ref_count == 0;
    }

  private:
    virtual void serialize_object(utils::buffer_serializer& buffer) const = 0;
    virtual void deserialize_object(utils::buffer_deserializer& buffer) = 0;
};

struct generic_handle_store
{
    virtual ~generic_handle_store() = default;
    virtual bool erase(handle h) = 0;
    virtual std::optional<handle> duplicate(handle h) = 0;
};

template <handle_types::type Type, typename T, uint32_t IndexShift = 0>
    requires(utils::Serializable<T> && std::is_base_of_v<ref_counted_object, T>)
class handle_store : public generic_handle_store
{
  public:
    using index_type = uint32_t;
    using value_map = std::map<index_type, T>;

    bool block_mutation(bool blocked)
    {
        std::swap(this->block_mutation_, blocked);
        return blocked;
    }

    std::pair<handle, T*> store_and_get(T value)
    {
        if (this->block_mutation_)
        {
            throw std::runtime_error("Mutation of handle store is blocked!");
        }

        auto index = this->find_free_index();
        const auto it = this->store_.emplace(index, std::move(value)).first;

        return {make_handle(index), &it->second};
    }

    handle store(T value)
    {
        return this->store_and_get(std::move(value)).first;
    }

    handle make_handle(const index_type index) const
    {
        handle h{};
        h.bits = 0;
        h.value.is_pseudo = false;
        h.value.type = Type;
        h.value.id = index << IndexShift;

        return h;
    }

    T* get_by_index(const uint32_t index)
    {
        return this->get(this->make_handle(index));
    }

    T* get(const handle_value h)
    {
        const auto entry = this->get_iterator(h);
        if (entry == this->store_.end())
        {
            return nullptr;
        }

        return &entry->second;
    }

    T* get(const handle h)
    {
        return this->get(h.value);
    }

    T* get(const uint64_t h)
    {
        handle hh{};
        hh.bits = h;

        return this->get(hh);
    }

    size_t size() const
    {
        return this->store_.size();
    }

    std::optional<handle> duplicate(const handle h) override
    {
        auto* entry = this->get(h);
        if (!entry)
        {
            return std::nullopt;
        }

        ++static_cast<ref_counted_object*>(entry)->ref_count;
        return h;
    }

    std::pair<typename value_map::iterator, bool> erase(const typename value_map::iterator& entry)
    {
        if (this->block_mutation_)
        {
            throw std::runtime_error("Mutation of handle store is blocked!");
        }

        if (entry == this->store_.end())
        {
            return {entry, false};
        }

        if constexpr (handle_detail::has_deleter_function<T>())
        {
            if (!T::deleter(entry->second))
            {
                return {entry, true};
            }
        }

        auto new_iter = this->store_.erase(entry);
        return {new_iter, true};
    }

    bool erase(const handle_value h)
    {
        const auto entry = this->get_iterator(h);
        return this->erase(entry).second;
    }

    bool erase(const handle h) override
    {
        return this->erase(h.value);
    }

    bool erase(const uint64_t h)
    {
        handle hh{};
        hh.bits = h;

        return this->erase(hh);
    }

    bool erase(const T& value)
    {
        const auto entry = this->find(value);
        return this->erase(entry);
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->block_mutation_);
        buffer.write_map(this->store_);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->block_mutation_);
        buffer.read_map(this->store_);
    }

    typename value_map::iterator find(const T& value)
    {
        auto i = this->store_.begin();
        for (; i != this->store_.end(); ++i)
        {
            if (&i->second == &value)
            {
                break;
            }
        }

        return i;
    }

    typename value_map::const_iterator find(const T& value) const
    {
        auto i = this->store_.begin();
        for (; i != this->store_.end(); ++i)
        {
            if (&i->second == &value)
            {
                break;
            }
        }

        return i;
    }

    handle find_handle(const T& value) const
    {
        const auto entry = this->find(value);
        if (entry == this->end())
        {
            return {};
        }

        return this->make_handle(entry->first);
    }

    handle find_handle(const T* value) const
    {
        if (!value)
        {
            return {};
        }

        return this->find_handle(*value);
    }

    typename value_map::iterator begin()
    {
        return this->store_.begin();
    }

    typename value_map::const_iterator begin() const
    {
        return this->store_.begin();
    }

    typename value_map::iterator end()
    {
        return this->store_.end();
    }

    typename value_map::const_iterator end() const
    {
        return this->store_.end();
    }

  private:
    typename value_map::iterator get_iterator(const handle_value h)
    {
        if (h.type != Type || h.is_pseudo)
        {
            return this->store_.end();
        }

        return this->store_.find(static_cast<uint32_t>(h.id) >> IndexShift);
    }

    uint32_t find_free_index()
    {
        uint32_t index = 1;
        for (; index > 0; ++index)
        {
            if (!this->store_.contains(index))
            {
                break;
            }
        }

        return index;
    }

    bool block_mutation_{false};
    value_map store_{};
};

constexpr auto NULL_HANDLE = make_handle(0ULL);

constexpr auto KNOWN_DLLS_DIRECTORY = make_pseudo_handle(0x1, handle_types::directory);
constexpr auto BASE_NAMED_OBJECTS_DIRECTORY = make_pseudo_handle(0x2, handle_types::directory);
constexpr auto RPC_CONTROL_DIRECTORY = make_pseudo_handle(0x3, handle_types::directory);
constexpr auto KNOWN_DLLS32_DIRECTORY = make_pseudo_handle(0x4, handle_types::directory);

constexpr auto KNOWN_DLLS_SYMLINK = make_pseudo_handle(0x1, handle_types::symlink);
constexpr auto KNOWN_DLLS32_SYMLINK = make_pseudo_handle(0x2, handle_types::symlink);
constexpr auto SHARED_SECTION = make_pseudo_handle(0x1, handle_types::section);
constexpr auto DBWIN_BUFFER = make_pseudo_handle(0x2, handle_types::section);

constexpr auto WER_PORT_READY = make_pseudo_handle(0x1, handle_types::event);
constexpr auto DBWIN_DATA_READY = make_pseudo_handle(0x2, handle_types::event);
constexpr auto DBWIN_BUFFER_READY = make_pseudo_handle(0x3, handle_types::event);
constexpr auto SVCCTRL_START_EVENT = make_pseudo_handle(0x4, handle_types::event);
constexpr auto LSA_AUTHENTICATION_INITIALIZED = make_pseudo_handle(0x5, handle_types::event);

constexpr auto CONSOLE_HANDLE = make_pseudo_handle(0x1, handle_types::file);
constexpr auto STDOUT_HANDLE = make_pseudo_handle(0x2, handle_types::file);
constexpr auto STDIN_HANDLE = make_pseudo_handle(0x3, handle_types::file);

constexpr auto DUMMY_IMPERSONATION_TOKEN = make_pseudo_handle(0x1, handle_types::token);

constexpr auto CURRENT_PROCESS = make_handle(~0ULL);
constexpr auto CURRENT_THREAD = make_handle(~1ULL);

constexpr auto CURRENT_PROCESS_TOKEN = make_handle(~3ULL);
constexpr auto CURRENT_THREAD_TOKEN = make_handle(~4ULL);
constexpr auto CURRENT_THREAD_EFFECTIVE_TOKEN = make_handle(~5ULL);

```

`src/windows-emulator/io_completion_wait.cpp`:

```cpp
#include "std_include.hpp"
#include "io_completion_wait.hpp"

namespace io_completion_wait
{
    namespace
    {
        bool is_wait_completion_target_signaled(process_context& process, const handle target_object_handle)
        {
            switch (target_object_handle.value.type)
            {
            case handle_types::event: {
                const auto* e = process.events.get(target_object_handle);
                return e && e->signaled;
            }
            case handle_types::thread: {
                const auto* thread = process.threads.get(target_object_handle);
                return thread && thread->is_terminated();
            }

            case handle_types::semaphore: {
                const auto* semaphore = process.semaphores.get(target_object_handle);
                return semaphore && semaphore->current_count > 0;
            }

            case handle_types::mutant: {
                const auto* mutant = process.mutants.get(target_object_handle);
                return mutant && mutant->locked_count == 0;
            }

            case handle_types::timer:
                return false;

            default:
                return false;
            }
        }

        void release_wait_packet_association(process_context& process, wait_completion_packet& wait_packet)
        {
            release_handle_reference(process, wait_packet.io_completion_handle);
            release_handle_reference(process, wait_packet.target_object_handle);
            wait_packet.associated = false;
        }

        void enqueue_wait_packet_completion(process_context& process, io_completion& completion, const handle wait_packet_handle,
                                            const wait_completion_packet& wait_packet)
        {
            io_completion_message message{};
            message.key_context = wait_packet.key_context;
            message.apc_context = wait_packet.apc_context;
            message.io_status_block = wait_packet.io_status_block;
            message.io_status_block.Information = wait_packet.io_status_information;

            if (wait_packet_handle.bits != 0)
            {
                if (const auto retained_wait_packet = process.wait_completion_packets.duplicate(wait_packet_handle))
                {
                    message.wait_packet_handle = *retained_wait_packet;
                }
            }

            completion.enqueue(message);
        }
    }

    bool is_wait_completion_target_type(const handle target_object_handle)
    {
        switch (target_object_handle.value.type)
        {
        case handle_types::event:
        case handle_types::thread:
        case handle_types::semaphore:
        case handle_types::mutant:
        case handle_types::timer:
            return true;
        default:
            return false;
        }
    }

    bool retain_handle_reference(process_context& process, const handle source_handle, handle& retained_handle)
    {
        if (source_handle.bits == 0)
        {
            retained_handle = {};
            return true;
        }

        if (source_handle.value.is_pseudo)
        {
            retained_handle = source_handle;
            return true;
        }

        auto* store = process.get_handle_store(source_handle);
        if (!store)
        {
            return false;
        }

        const auto duplicated = store->duplicate(source_handle);
        if (!duplicated)
        {
            return false;
        }

        retained_handle = *duplicated;
        return true;
    }

    void release_handle_reference(process_context& process, handle& retained_handle)
    {
        if (retained_handle.bits == 0)
        {
            return;
        }

        if (retained_handle.value.is_pseudo)
        {
            retained_handle = {};
            return;
        }

        if (auto* store = process.get_handle_store(retained_handle))
        {
            (void)store->erase(retained_handle);
        }

        retained_handle = {};
    }

    void clear_wait_packet_completion_state(process_context& process, const handle wait_packet_handle)
    {
        if (wait_packet_handle.bits == 0)
        {
            return;
        }

        auto* wait_packet = process.wait_completion_packets.get(wait_packet_handle);
        if (!wait_packet)
        {
            (void)process.wait_completion_packets.erase(wait_packet_handle);
            return;
        }

        release_wait_packet_association(process, *wait_packet);
        wait_packet->queued_completion = false;

        // Each queued completion keeps an extra packet reference.
        (void)process.wait_completion_packets.erase(wait_packet_handle);
    }

    void cleanup_wait_packet_on_close(process_context& process, const handle wait_packet_handle)
    {
        auto* wait_packet = process.wait_completion_packets.get(wait_packet_handle);
        if (!wait_packet)
        {
            return;
        }

        if (wait_packet->queued_completion)
        {
            if (auto* completion = process.io_completions.get(wait_packet->io_completion_handle))
            {
                if (completion->remove_by_wait_packet(wait_packet_handle))
                {
                    (void)process.wait_completion_packets.erase(wait_packet_handle);
                }
            }
        }

        release_wait_packet_association(process, *wait_packet);
        wait_packet->queued_completion = false;
    }

    void materialize_signaled_wait_packets(process_context& process, const handle io_completion_handle)
    {
        auto* completion = process.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return;
        }

        for (auto& [packet_id, wait_packet] : process.wait_completion_packets)
        {
            if (!wait_packet.associated || wait_packet.queued_completion)
            {
                continue;
            }

            if (wait_packet.io_completion_handle != io_completion_handle)
            {
                continue;
            }

            if (!is_wait_completion_target_signaled(process, wait_packet.target_object_handle))
            {
                continue;
            }

            enqueue_wait_packet_completion(process, *completion, process.wait_completion_packets.make_handle(packet_id), wait_packet);
            wait_packet.queued_completion = true;
        }
    }

    bool dequeue_io_completion_message(process_context& process, const handle io_completion_handle, io_completion_message& out_message)
    {
        auto* completion = process.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return false;
        }

        materialize_signaled_wait_packets(process, io_completion_handle);

        if (!completion->dequeue(out_message))
        {
            return false;
        }

        clear_wait_packet_completion_state(process, out_message.wait_packet_handle);
        return true;
    }

    ULONG dequeue_io_completion_entries(process_context& process, const handle io_completion_handle,
                                        const emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>> out_entries,
                                        const ULONG max_count)
    {
        if (max_count == 0 || !out_entries)
        {
            return 0;
        }

        auto* completion = process.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return 0;
        }

        materialize_signaled_wait_packets(process, io_completion_handle);

        ULONG removed = 0;
        for (; removed < max_count; ++removed)
        {
            io_completion_message message{};
            if (!completion->dequeue(message))
            {
                break;
            }

            FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>> entry{};
            entry.KeyContext = message.key_context;
            entry.ApcContext = message.apc_context;
            entry.IoStatusBlock = message.io_status_block;
            out_entries.write(entry, removed);

            clear_wait_packet_completion_state(process, message.wait_packet_handle);
        }

        return removed;
    }
}

```

`src/windows-emulator/io_completion_wait.hpp`:

```hpp
#pragma once

#include "process_context.hpp"

namespace io_completion_wait
{
    bool is_wait_completion_target_type(handle target_object_handle);

    bool retain_handle_reference(process_context& process, handle source_handle, handle& retained_handle);
    void release_handle_reference(process_context& process, handle& retained_handle);

    void cleanup_wait_packet_on_close(process_context& process, handle wait_packet_handle);
    void clear_wait_packet_completion_state(process_context& process, handle wait_packet_handle);
    void materialize_signaled_wait_packets(process_context& process, handle io_completion_handle);

    bool dequeue_io_completion_message(process_context& process, handle io_completion_handle, io_completion_message& out_message);
    ULONG dequeue_io_completion_entries(process_context& process, handle io_completion_handle,
                                        emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>> out_entries,
                                        ULONG max_count);
}

```

`src/windows-emulator/io_device.cpp`:

```cpp
#include "std_include.hpp"
#include "io_device.hpp"
#include "windows_emulator.hpp"
#include "devices/afd_endpoint.hpp"
#include "devices/mount_point_manager.hpp"
#include "devices/security_support_provider.hpp"
#include "devices/named_pipe.hpp"
#include <iostream>

namespace
{
    struct dummy_device : stateless_device
    {
        NTSTATUS io_control(windows_emulator&, const io_device_context&) override
        {
            return STATUS_SUCCESS;
        }
    };

    struct transport_stub_device : stateless_device
    {
        NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& context) override
        {
            if (context.output_buffer && context.output_buffer_length)
            {
                std::vector<std::byte> output(context.output_buffer_length, std::byte{0});
                win_emu.emu().write_memory(context.output_buffer, output.data(), output.size());
            }

            if (context.io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = context.output_buffer_length;
                context.io_status_block.write(block);
            }

            return STATUS_SUCCESS;
        }
    };
}

std::unique_ptr<io_device> create_device(const std::u16string_view device)
{
    if (device == u"CNG"                    //
        || device == u"Nsi"                 //
        || device == u"RasAcd"              //
        || device == u"PcwDrv"              //
        || device == u"DeviceApi\\CMApi"    //
        || device == u"DeviceApi\\CMNotify" //
        || device == u"ConDrv\\Server")
    {
        return std::make_unique<dummy_device>();
    }

    if (device == u"Afd\\Endpoint")
    {
        return create_afd_endpoint();
    }

    if (device == u"Afd\\AsyncConnectHlp")
    {
        return create_afd_async_connect_hlp();
    }

    if (device == u"MountPointManager")
    {
        return create_mount_point_manager();
    }

    if (device == u"KsecDD")
    {
        return create_security_support_provider();
    }

    if (device == u"NamedPipe")
    {
        return std::make_unique<named_pipe>();
    }

    if (device == u"Tcp" || device == u"Tcp6" || device == u"Udp" || device == u"RawIp")
    {
        return std::make_unique<transport_stub_device>();
    }

    throw std::runtime_error("Unsupported device: " + u16_to_u8(device));
}

NTSTATUS io_device_container::io_control(windows_emulator& win_emu, const io_device_context& context)
{
    this->assert_validity();
    win_emu.callbacks.on_ioctrl(*this->device_, this->device_name_, context.io_control_code);
    return this->device_->io_control(win_emu, context);
}

void io_device_container::work(windows_emulator& win_emu)
{
    this->assert_validity();
    this->device_->work(win_emu);
}

void io_device_container::serialize_object(utils::buffer_serializer& buffer) const
{
    this->assert_validity();

    buffer.write_string(this->device_name_);
    this->device_->serialize(buffer);
}

void io_device_container::deserialize_object(utils::buffer_deserializer& buffer)
{
    buffer.read_string(this->device_name_);
    this->setup();
    this->device_->deserialize(buffer);
}

```

`src/windows-emulator/io_device.hpp`:

```hpp
#pragma once

#include <memory>
#include <arch_emulator.hpp>
#include <serialization.hpp>

#include "emulator_utils.hpp"
#include "handles.hpp"

class windows_emulator;
struct process_context;

struct io_device_context
{
    handle event{};
    emulator_pointer /*PIO_APC_ROUTINE*/ apc_routine{};
    emulator_pointer apc_context{};
    emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block;
    ULONG io_control_code{};
    emulator_pointer input_buffer{};
    ULONG input_buffer_length{};
    emulator_pointer output_buffer{};
    ULONG output_buffer_length{};

    io_device_context(x86_64_emulator& emu)
        : io_status_block(emu)
    {
    }

    io_device_context(utils::buffer_deserializer& buffer)
        : io_device_context(buffer.read<x64_emulator_wrapper>().get())
    {
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(event);
        buffer.write(apc_routine);
        buffer.write(apc_context);
        buffer.write(io_status_block);
        buffer.write(io_control_code);
        buffer.write(input_buffer);
        buffer.write(input_buffer_length);
        buffer.write(output_buffer);
        buffer.write(output_buffer_length);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(event);
        buffer.read(apc_routine);
        buffer.read(apc_context);
        buffer.read(io_status_block);
        buffer.read(io_control_code);
        buffer.read(input_buffer);
        buffer.read(input_buffer_length);
        buffer.read(output_buffer);
        buffer.read(output_buffer_length);
    }
};

struct io_device_creation_data
{
    uint64_t buffer;
    uint32_t length;
};

inline NTSTATUS write_io_status(const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, const NTSTATUS status,
                                const bool clear_struct = false)
{
    io_status_block.access([=](IO_STATUS_BLOCK<EmulatorTraits<Emu64>>& status_block) {
        if (clear_struct)
        {
            status_block = {};
        }

        status_block.Status = status;
    });

    return status;
}

struct io_device : ref_counted_object
{
    io_device() = default;
    ~io_device() override = default;

    io_device(io_device&&) = default;
    io_device& operator=(io_device&&) = default;

    io_device(const io_device&) = delete;
    io_device& operator=(const io_device&) = delete;

    virtual NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& context) = 0;

    virtual void create(windows_emulator& win_emu, const io_device_creation_data& data)
    {
        (void)win_emu;
        (void)data;
    }

    virtual void work(windows_emulator& win_emu)
    {
        (void)win_emu;
    }

    NTSTATUS execute_ioctl(windows_emulator& win_emu, const io_device_context& c)
    {
        if (c.io_status_block)
        {
            c.io_status_block.write({});
        }

        const auto result = this->io_control(win_emu, c);
        write_io_status(c.io_status_block, result);
        return result;
    }
};

struct stateless_device : io_device
{
    void create(windows_emulator&, const io_device_creation_data&) final
    {
    }

    void serialize_object(utils::buffer_serializer&) const override
    {
    }

    void deserialize_object(utils::buffer_deserializer&) override
    {
    }
};

std::unique_ptr<io_device> create_device(std::u16string_view device);

class io_device_container : public io_device
{
  public:
    io_device_container() = default;

    io_device_container(std::u16string device, windows_emulator& win_emu, const io_device_creation_data& data)
        : device_name_(std::move(device))
    {
        this->setup();
        this->device_->create(win_emu, data);
    }

    void work(windows_emulator& win_emu) override;
    NTSTATUS io_control(windows_emulator& win_emu, const io_device_context& context) override;

    void serialize_object(utils::buffer_serializer& buffer) const override;
    void deserialize_object(utils::buffer_deserializer& buffer) override;

    template <typename T = io_device>
        requires(std::is_base_of_v<io_device, T> || std::is_same_v<io_device, T>)
    T* get_internal_device() const
    {
        this->assert_validity();
        auto* value = this->device_.get();
        return dynamic_cast<T*>(value);
    }

    std::u16string_view get_device_name() const
    {
        this->assert_validity();
        return this->device_name_;
    }

    std::u16string get_device_path() const
    {
        this->assert_validity();
        return u"\\Device\\" + this->device_name_;
    }

  private:
    std::u16string device_name_{};
    std::unique_ptr<io_device> device_{};

    void setup()
    {
        this->device_ = create_device(this->device_name_);
    }

    void assert_validity() const
    {
        if (!this->device_)
        {
            throw std::runtime_error("Device not created!");
        }
    }
};

```

`src/windows-emulator/kusd_mmio.cpp`:

```cpp
#include "std_include.hpp"
#include "kusd_mmio.hpp"
#include <utils/time.hpp>
#include <utils/string.hpp>
#include "windows_emulator.hpp"
#include "version/windows_version_manager.hpp"

#include <address_utils.hpp>

constexpr auto KUSD_ADDRESS = 0x7ffe0000ULL;
constexpr auto KUSD_SIZE = sizeof(KUSER_SHARED_DATA64);
constexpr auto KUSD_BUFFER_SIZE = page_align_up(KUSD_SIZE);

namespace
{
    void setup_kusd(KUSER_SHARED_DATA64& kusd, const windows_version_manager& version)
    {
        memset(reinterpret_cast<void*>(&kusd), 0, sizeof(kusd));

        kusd.TickCountMultiplier = 0x0fa00000;
        kusd.InterruptTime.LowPart = 0x17bd9547;
        kusd.InterruptTime.High1Time = 0x0000004b;
        kusd.InterruptTime.High2Time = 0x0000004b;
        kusd.SystemTime.LowPart = 0x7af9da99;
        kusd.SystemTime.High1Time = 0x01db27b9;
        kusd.SystemTime.High2Time = 0x01db27b9;
        kusd.TimeZoneBias.LowPart = 0x3c773000;
        kusd.TimeZoneBias.High1Time = -17;
        kusd.TimeZoneBias.High2Time = -17;
        kusd.TimeZoneId = 0x00000002;
        kusd.LargePageMinimum = 0x00200000;
        kusd.RNGSeedVersion = 0;
        kusd.TimeZoneBiasStamp = 0x00000004;
        kusd.NtBuildNumber = version.get_windows_build_number();
        kusd.NtProductType = NtProductWinNt;
        kusd.ProductTypeIsValid = 0x01;
        kusd.NativeProcessorArchitecture = 0x0009;
        kusd.NtMajorVersion = version.get_major_version();
        kusd.NtMinorVersion = version.get_minor_version();
        kusd.BootId = 0;
        kusd.SystemExpirationDate.QuadPart = 0;
        kusd.SuiteMask = 0;
        kusd.MitigationPolicies.MitigationPolicies = 0x0a;
        kusd.MitigationPolicies.NXSupportPolicy = 0x02;
        kusd.MitigationPolicies.SEHValidationPolicy = 0x02;
        kusd.CyclesPerYield = 0x0064;
        kusd.DismountCount = 0x00000006;
        kusd.ComPlusPackage = 0x00000001;
        kusd.LastSystemRITEventTickCount = 0x01ec1fd3;
        kusd.NumberOfPhysicalPages = 0x00bf0958;
        kusd.FullNumberOfPhysicalPages = 0x0000000000bf0958;
        kusd.TickCount.TickCount.LowPart = 0x001f7f05;
        kusd.TickCount.TickCountQuad = 0x00000000001f7f05;
        kusd.Cookie = 0;
        kusd.ConsoleSessionForegroundProcessId = 0x00000000000028f4;
        kusd.TimeUpdateLock = 0x0000000002b28586;
        // This is the QPC time when `SystemTime` is set
        // We set it to UINT64_MAX, so `SystemTime` won't get adjusted in `RtlGetSystemTimePrecise`
        kusd.BaselineSystemTimeQpc = 0xFFFFFFFFFFFFFFFF;
        kusd.BaselineInterruptTimeQpc = 0xFFFFFFFFFFFFFFFF;
        kusd.QpcSystemTimeIncrement = 0x8000000000000000;
        kusd.QpcInterruptTimeIncrement = 0x8000000000000000;
        kusd.QpcSystemTimeIncrementShift = 0x01;
        kusd.QpcInterruptTimeIncrementShift = 0x01;
        kusd.UnparkedProcessorCount = 0x000c;
        kusd.TelemetryCoverageRound = 0x00000001;
        kusd.LangGenerationCount = 0x00000003;
        kusd.InterruptTimeBias = 0x00000015a5d56406;
        kusd.ActiveProcessorCount = 0x00000004;
        kusd.ActiveGroupCount = 0x01;
        kusd.TimeZoneBiasEffectiveStart.QuadPart = 0x01db276e654cb2ff;
        kusd.TimeZoneBiasEffectiveEnd.QuadPart = 0x01db280b8c3b2800;
        kusd.XState.EnabledFeatures = 0x000000000000001f;
        kusd.XState.EnabledVolatileFeatures = 0x000000000000000f;
        kusd.XState.Size = 0x000003c0;
        kusd.QpcData.QpcData = 0x0083;
        kusd.QpcData.QpcBypassEnabled = 0x83;
        kusd.QpcBias = 0x000000159530c4af;
        kusd.QpcFrequency = utils::clock::steady_duration::period::den;
        kusd.Reserved1 = 0x7ffeffff;
        kusd.Reserved3 = 0x80000000;
        kusd.ProcessorFeatures.arr[PF_RDTSC_INSTRUCTION_AVAILABLE] = 1;
        kusd.ProcessorFeatures.arr[PF_RDTSCP_INSTRUCTION_AVAILABLE] = 1;
        kusd.ProcessorFeatures.arr[PF_RDPID_INSTRUCTION_AVAILABLE] = 0;

        const auto& system_root = version.get_system_root();
        utils::string::copy(kusd.NtSystemRoot.arr, std::u16string_view{system_root.u16string()});

        kusd.ImageNumberLow = IMAGE_FILE_MACHINE_AMD64;
        kusd.ImageNumberHigh = IMAGE_FILE_MACHINE_AMD64;
    }
}

namespace utils
{
    static void serialize(buffer_serializer& buffer, const KUSER_SHARED_DATA64& kusd)
    {
        static_assert(KUSD_SIZE == sizeof(kusd));
        buffer.write(&kusd, KUSD_SIZE);
    }

    static void deserialize(buffer_deserializer& buffer, KUSER_SHARED_DATA64& kusd)
    {
        buffer.read(&kusd, KUSD_SIZE);
    }
}

kusd_mmio::kusd_mmio(memory_manager& memory, utils::clock& clock)
    : memory_(&memory),
      clock_(&clock)
{
}

kusd_mmio::~kusd_mmio()
{
    this->deregister_mmio();
}

kusd_mmio::kusd_mmio(utils::buffer_deserializer& buffer)
    : kusd_mmio(buffer.read<memory_manager_wrapper>(), buffer.read<clock_wrapper>())
{
}

void kusd_mmio::setup(const windows_version_manager& version)
{
    setup_kusd(this->kusd_, version);
    this->register_mmio();
}

void kusd_mmio::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write(this->kusd_);
}

void kusd_mmio::deserialize(utils::buffer_deserializer& buffer)
{
    buffer.read(this->kusd_);

    this->deregister_mmio();
    this->register_mmio();
}

void kusd_mmio::read(const uint64_t addr, void* data, const size_t size)
{
    this->update();

    if (addr >= KUSD_SIZE)
    {
        return;
    }

    const auto end = addr + size;
    const auto valid_end = std::min(end, static_cast<uint64_t>(KUSD_SIZE));
    const auto real_size = valid_end - addr;

    const auto* kusd_buffer = reinterpret_cast<uint8_t*>(&this->kusd_);
    memcpy(data, kusd_buffer + addr, static_cast<size_t>(real_size));
}

uint64_t kusd_mmio::address()
{
    return KUSD_ADDRESS;
}

void kusd_mmio::update()
{
    const auto time = this->clock_->system_now();
    utils::convert_to_ksystem_time(&this->kusd_.SystemTime, time);

    const auto ticks = this->clock_->steady_now();
    const auto duration_100ns =
        std::chrono::duration_cast<std::chrono::duration<uint64_t, std::ratio<1, 10000000>>>(ticks.time_since_epoch()).count();

    this->kusd_.TickCount.TickCountQuad = (duration_100ns << 24) / this->kusd_.TickCountMultiplier;
    this->kusd_.TickCount.TickCount.High2Time = this->kusd_.TickCount.TickCount.High1Time;

    this->kusd_.InterruptTime.High2Time = static_cast<int32_t>(duration_100ns >> 32);
    this->kusd_.InterruptTime.LowPart = static_cast<uint32_t>(duration_100ns & 0xFFFFFFFF);
    this->kusd_.InterruptTime.High1Time = static_cast<int32_t>(duration_100ns >> 32);
}

void kusd_mmio::register_mmio()
{
    if (this->registered_)
    {
        return;
    }

    this->registered_ = true;

    this->memory_->allocate_mmio(
        KUSD_ADDRESS, KUSD_BUFFER_SIZE,
        [this](const uint64_t addr, void* data, const size_t size) {
            this->read(addr, data, size); //
        },
        [](const uint64_t, const void*, const size_t) {
            // Writing not supported!
        });
}

void kusd_mmio::deregister_mmio()
{
    if (this->registered_)
    {
        this->registered_ = false;
        this->memory_->release_memory(KUSD_ADDRESS, KUSD_BUFFER_SIZE);
    }
}

```

`src/windows-emulator/kusd_mmio.hpp`:

```hpp
#pragma once

#include "std_include.hpp"
#include <serialization.hpp>

#include "arch_emulator.hpp"

#include <utils/time.hpp>

struct process_context;
class windows_emulator;
class windows_version_manager;

class kusd_mmio
{
  public:
    kusd_mmio(memory_manager& memory, utils::clock& clock);
    ~kusd_mmio();

    kusd_mmio(utils::buffer_deserializer& buffer);

    kusd_mmio(kusd_mmio&&) = delete;
    kusd_mmio(const kusd_mmio&) = delete;
    kusd_mmio& operator=(kusd_mmio&& obj) = delete;
    kusd_mmio& operator=(const kusd_mmio&) = delete;

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);

    KUSER_SHARED_DATA64& get()
    {
        return this->kusd_;
    }

    const KUSER_SHARED_DATA64& get() const
    {
        return this->kusd_;
    }

    static uint64_t address();

    void setup(const windows_version_manager& version);

  private:
    memory_manager* memory_{};
    utils::clock* clock_{};

    bool registered_{};

    KUSER_SHARED_DATA64 kusd_{};

    void read(uint64_t addr, void* data, size_t size);

    void update();

    void register_mmio();
    void deregister_mmio();
};

```

`src/windows-emulator/logger.cpp`:

```cpp
#include "std_include.hpp"
#include "logger.hpp"

#include <utils/finally.hpp>

namespace
{
#ifdef _WIN32
#define COLOR(win, posix, web) win
    using color_type = WORD;
#elif defined(__EMSCRIPTEN__) && !defined(MOMO_EMSCRIPTEN_SUPPORT_NODEJS)
#define COLOR(win, posix, web) web
    using color_type = const char*;
#else
#define COLOR(win, posix, web) posix
    using color_type = const char*;
#endif

    color_type get_reset_color()
    {
        return COLOR(7, "\033[0m", "</span>");
    }

    color_type get_color_type(const color c)
    {
        using enum color;

        switch (c)
        {
        case black:
            return COLOR(0x8, "\033[0;90m", "<span class=\"terminal-black\">");
        case red:
            return COLOR(0xC, "\033[0;91m", "<span class=\"terminal-red\">");
        case green:
            return COLOR(0xA, "\033[0;92m", "<span class=\"terminal-green\">");
        case yellow:
            return COLOR(0xE, "\033[0;93m", "<span class=\"terminal-yellow\">");
        case blue:
            return COLOR(0x9, "\033[0;94m", "<span class=\"terminal-blue\">");
        case cyan:
            return COLOR(0xB, "\033[0;96m", "<span class=\"terminal-cyan\">");
        case pink:
            return COLOR(0xD, "\033[0;95m", "<span class=\"terminal-pink\">");
        case white:
            return COLOR(0xF, "\033[0;97m", "<span class=\"terminal-white\">");
        case dark_gray:
            return COLOR(0x8, "\033[0;90m", "<span class=\"terminal-dark-gray\">");
        case gray:
        default:
            return get_reset_color();
        }
    }

#ifdef _WIN32
    HANDLE get_console_handle()
    {
        return GetStdHandle(STD_OUTPUT_HANDLE);
    }
#endif

    void set_color(const color_type color)
    {
#ifdef _WIN32
        SetConsoleTextAttribute(get_console_handle(), color);
#else
        printf("%s", color);
#endif
    }

    void reset_color()
    {
        (void)fflush(stdout);
        set_color(get_reset_color());
        (void)fflush(stdout);
    }

    int format_internal(const char* message, std::span<char> buffer, va_list* ap)
    {
        return vsnprintf(buffer.data(), buffer.size(), message, *ap);
    }

    std::string_view format(const char* message, std::string& reserve_buffer, va_list* ap1, va_list* ap2)
    {
        thread_local std::array<char, 0x1000> buffer{};

        auto count = format_internal(message, buffer, ap1);

        if (count < 0)
        {
            return {};
        }

        if (static_cast<size_t>(count) < buffer.size())
        {
            return {buffer.data(), static_cast<size_t>(count)};
        }

        reserve_buffer.resize(count + 1);
        count = format_internal(message, reserve_buffer, ap2);

        if (count < 0)
        {
            return {};
        }

        return {reserve_buffer.data(), std::min(static_cast<size_t>(count), reserve_buffer.size() - 1)};
    }

#define format_to_string(msg, str)                 \
    std::string buf{};                             \
    va_list ap1;                                   \
    va_list ap2;                                   \
    va_start(ap1, msg);                            \
    va_start(ap2, msg);                            \
    const auto str = format(msg, buf, &ap1, &ap2); \
    va_end(ap2);                                   \
    va_end(ap1)

    void print_colored(const std::string_view& line, const color_type base_color)
    {
        const auto _ = utils::finally(&reset_color);
        set_color(base_color);
        (void)fwrite(line.data(), 1, line.size(), stdout);
    }
}

#ifdef OS_WINDOWS
logger::logger()
{
    old_cp = GetConsoleOutputCP();
    SetConsoleOutputCP(CP_UTF8);
}

logger::~logger()
{
    SetConsoleOutputCP(old_cp);
}
#endif

void logger::print_message(const color c, const std::string_view message, const bool force) const
{
    if (!force && this->disable_output_)
    {
        return;
    }

    print_colored(message, get_color_type(c));
}

void logger::print(const color c, const std::string_view message)
{
    this->print_message(c, message);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::print(const color c, const char* message, ...)
{
    format_to_string(message, data);
    this->print_message(c, data);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::force_print(const color c, const char* message, ...)
{
    format_to_string(message, data);
    this->print_message(c, data, true);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::info(const char* message, ...) const
{
    format_to_string(message, data);
    this->print_message(color::cyan, data);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::warn(const char* message, ...) const
{
    format_to_string(message, data);
    this->print_message(color::yellow, data);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::error(const char* message, ...) const
{
    format_to_string(message, data);
    this->print_message(color::red, data, true);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::success(const char* message, ...) const
{
    format_to_string(message, data);
    this->print_message(color::green, data);
}

// NOLINTNEXTLINE(cert-dcl50-cpp)
void logger::log(const char* message, ...) const
{
    format_to_string(message, data);
    this->print_message(color::gray, data);
}

```

`src/windows-emulator/logger.hpp`:

```hpp
#pragma once
#include "generic_logger.hpp"

class logger : public generic_logger
{
  public:
#ifdef OS_WINDOWS
    logger();
    ~logger() override;
#endif
    void print(color c, std::string_view message) override;
    void print(color c, const char* message, ...) override FORMAT_ATTRIBUTE(3, 4);
    void force_print(color c, const char* message, ...) FORMAT_ATTRIBUTE(3, 4);
    void info(const char* message, ...) const FORMAT_ATTRIBUTE(2, 3);
    void warn(const char* message, ...) const FORMAT_ATTRIBUTE(2, 3);
    void error(const char* message, ...) const FORMAT_ATTRIBUTE(2, 3);
    void success(const char* message, ...) const FORMAT_ATTRIBUTE(2, 3);
    void log(const char* message, ...) const FORMAT_ATTRIBUTE(2, 3);

    void disable_output(const bool value)
    {
        this->disable_output_ = value;
    }

    bool is_output_disabled() const
    {
        return this->disable_output_;
    }

  private:
#ifdef OS_WINDOWS
    UINT old_cp{};
#endif
    bool disable_output_{false};
    void print_message(color c, std::string_view message, bool force = false) const;
};

```

`src/windows-emulator/memory_manager.cpp`:

```cpp
#include "std_include.hpp"
#include "memory_manager.hpp"

#include "memory_region.hpp"
#include "address_utils.hpp"
#include "memory_permission_ext.hpp"

#include <vector>
#include <optional>
#include <stdexcept>
#include <cassert>

namespace
{
    void split_regions(memory_manager::committed_region_map& regions, const std::vector<uint64_t>& split_points)
    {
        for (auto i = regions.begin(); i != regions.end(); ++i)
        {
            for (const auto split_point : split_points)
            {
                if (is_within_start_and_length(split_point, i->first, i->second.length) && i->first != split_point)
                {
                    const auto first_length = split_point - i->first;
                    const auto second_length = i->second.length - first_length;

                    i->second.length = static_cast<size_t>(first_length);

                    regions[split_point] = memory_manager::committed_region{static_cast<size_t>(second_length), i->second.permissions};
                }
            }
        }
    }

    void merge_regions(memory_manager::committed_region_map& regions)
    {
        for (auto i = regions.begin(); i != regions.end();)
        {
            assert(i->second.length > 0);

            auto next = i;
            std::advance(next, 1);

            if (next == regions.end())
            {
                break;
            }

            assert(next->second.length > 0);

            const auto end = i->first + i->second.length;
            assert(end <= next->first);

            if (end != next->first || i->second.permissions != next->second.permissions)
            {
                ++i;
                continue;
            }

            i->second.length += next->second.length;
            regions.erase(next);
        }
    }
}

namespace utils
{
    static void serialize(buffer_serializer& buffer, const memory_manager::committed_region& region)
    {
        buffer.write<uint64_t>(region.length);
        buffer.write(region.permissions);
    }

    static void deserialize(buffer_deserializer& buffer, memory_manager::committed_region& region)
    {
        region.length = static_cast<size_t>(buffer.read<uint64_t>());
        region.permissions = buffer.read<nt_memory_permission>();
    }

    static void serialize(buffer_serializer& buffer, const memory_manager::reserved_region& region)
    {
        buffer.write(region.kind);
        buffer.write(region.initial_permission);
        buffer.write<uint64_t>(region.length);
        buffer.write_map(region.committed_regions);
    }

    static void deserialize(buffer_deserializer& buffer, memory_manager::reserved_region& region)
    {
        buffer.read(region.kind);
        buffer.read(region.initial_permission);
        region.length = static_cast<size_t>(buffer.read<uint64_t>());
        buffer.read_map(region.committed_regions);
    }
}

void memory_manager::update_layout_version()
{
#if MOMO_REFLECTION_LEVEL > 0
    this->layout_version_.fetch_add(1, std::memory_order_relaxed);
#endif
}

memory_stats memory_manager::compute_memory_stats() const
{
    memory_stats stats{};
    stats.reserved_memory = 0;
    stats.committed_memory = 0;

    for (const auto& reserved_region : this->reserved_regions_ | std::views::values)
    {
        stats.reserved_memory += reserved_region.length;

        for (const auto& committed_region : reserved_region.committed_regions | std::views::values)
        {
            stats.committed_memory += committed_region.length;
        }
    }

    return stats;
}

void memory_manager::serialize_memory_state(utils::buffer_serializer& buffer, const bool is_snapshot) const
{
    buffer.write_atomic(this->layout_version_);
    buffer.write(this->default_allocation_address_);
    buffer.write_map(this->reserved_regions_);

    if (is_snapshot)
    {
        return;
    }

    std::vector<uint8_t> data{};

    for (const auto& reserved_region : this->reserved_regions_)
    {
        if (reserved_region.second.kind == memory_region_kind::mmio)
        {
            continue;
        }

        for (const auto& region : reserved_region.second.committed_regions)
        {
            data.resize(region.second.length);

            this->read_memory(region.first, data.data(), region.second.length);

            buffer.write(data.data(), region.second.length);
        }
    }
}

void memory_manager::deserialize_memory_state(utils::buffer_deserializer& buffer, const bool is_snapshot)
{
    if (!is_snapshot)
    {
        assert(this->reserved_regions_.empty());
    }

    buffer.read_atomic(this->layout_version_);
    buffer.read(this->default_allocation_address_);
    buffer.read_map(this->reserved_regions_);

    if (is_snapshot)
    {
        return;
    }

    std::vector<uint8_t> data{};

    for (auto i = this->reserved_regions_.begin(); i != this->reserved_regions_.end();)
    {
        auto& reserved_region = i->second;
        if (reserved_region.kind == memory_region_kind::mmio)
        {
            i = this->reserved_regions_.erase(i);
            continue;
        }

        ++i;

        for (const auto& region : reserved_region.committed_regions)
        {
            data.resize(region.second.length);

            buffer.read(data.data(), region.second.length);

            const auto effective_permission =
                region.second.permissions.is_guarded() ? memory_permission::none : region.second.permissions.common;
            this->map_memory(region.first, region.second.length, effective_permission);
            this->write_memory(region.first, data.data(), region.second.length);
        }
    }
}

bool memory_manager::protect_memory(const uint64_t address, const size_t size, const nt_memory_permission permissions,
                                    nt_memory_permission* old_permissions)
{
    const auto entry = this->find_reserved_region(address);
    if (entry == this->reserved_regions_.end())
    {
        return false;
    }

    const auto end = address + size;
    const auto region_end = entry->first + entry->second.length;

    if (region_end < end)
    {
        throw std::runtime_error("Cross region protect not supported yet!");
    }

    std::optional<memory_permission> old_first_permissions{};

    auto& committed_regions = entry->second.committed_regions;
    split_regions(committed_regions, {address, end});

    const auto effective_permission = permissions.is_guarded() ? memory_permission::none : permissions.common;

    for (auto& sub_region : committed_regions)
    {
        if (sub_region.first >= end)
        {
            break;
        }

        const auto sub_region_end = sub_region.first + sub_region.second.length;
        if (sub_region.first >= address && sub_region_end <= end)
        {
            if (!old_first_permissions.has_value())
            {
                old_first_permissions = sub_region.second.permissions;
            }

            this->apply_memory_protection(sub_region.first, sub_region.second.length, effective_permission);
            sub_region.second.permissions = permissions;
        }
    }

    if (old_permissions)
    {
        *old_permissions = old_first_permissions.value_or(memory_permission::none);
    }

    merge_regions(committed_regions);

    this->update_layout_version();

    return true;
}

bool memory_manager::allocate_mmio(const uint64_t address, const size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb)
{
    if (this->overlaps_reserved_region(address, size))
    {
        return false;
    }

    this->map_mmio(address, size, std::move(read_cb), std::move(write_cb));

    const auto entry = this->reserved_regions_
                           .try_emplace(address,
                                        reserved_region{
                                            .length = size,
                                            .kind = memory_region_kind::mmio,
                                        })
                           .first;

    entry->second.committed_regions[address] = committed_region{size, memory_permission::read_write};

    this->update_layout_version();

    return true;
}

bool memory_manager::allocate_memory(const uint64_t address, const size_t size, const nt_memory_permission permissions,
                                     const bool reserve_only, const memory_region_kind kind)
{
    if (this->overlaps_reserved_region(address, size))
    {
        return false;
    }

    const auto entry = this->reserved_regions_
                           .try_emplace(address,
                                        reserved_region{
                                            .length = size,
                                            .initial_permission = permissions,
                                            .kind = kind,
                                        })
                           .first;

    if (!reserve_only)
    {
        this->map_memory(address, size, permissions.is_guarded() ? memory_permission::none : permissions.common);
        entry->second.committed_regions[address] = committed_region{size, permissions};
    }

    this->update_layout_version();

    return true;
}

bool memory_manager::commit_memory(const uint64_t address, const size_t size, const nt_memory_permission permissions)
{
    const auto entry = this->find_reserved_region(address);
    if (entry == this->reserved_regions_.end())
    {
        return false;
    }

    if (memory_region_policy::is_section_kind(entry->second.kind))
    {
        return false;
    }

    const auto end = address + size;
    const auto region_end = entry->first + entry->second.length;

    if (region_end < end)
    {
        throw std::runtime_error("Cross region commit not supported yet!");
    }

    auto& committed_regions = entry->second.committed_regions;
    split_regions(committed_regions, {address, end});

    uint64_t last_region_start{};
    const committed_region* last_region{nullptr};

    const auto effective_permission = permissions.is_guarded() ? memory_permission::none : permissions.common;

    for (auto& sub_region : committed_regions)
    {
        if (sub_region.first >= end)
        {
            break;
        }

        const auto sub_region_end = sub_region.first + sub_region.second.length;
        if (sub_region.first >= address && sub_region_end <= end)
        {
            const auto map_start = last_region ? (last_region_start + last_region->length) : address;
            const auto map_length = sub_region.first - map_start;

            if (map_length > 0)
            {
                this->map_memory(map_start, static_cast<size_t>(map_length), effective_permission);
                committed_regions[map_start] = committed_region{static_cast<size_t>(map_length), permissions};
            }

            // Update protection for existing committed region when re-committing
            this->apply_memory_protection(sub_region.first, sub_region.second.length, effective_permission);
            sub_region.second.permissions = permissions;

            last_region_start = sub_region.first;
            last_region = &sub_region.second;
        }
    }

    if (!last_region || (last_region_start + last_region->length) < end)
    {
        const auto map_start = last_region ? (last_region_start + last_region->length) : address;
        const auto map_length = end - map_start;

        this->map_memory(map_start, static_cast<size_t>(map_length), effective_permission);
        committed_regions[map_start] = committed_region{static_cast<size_t>(map_length), permissions};
    }

    merge_regions(committed_regions);

    this->update_layout_version();

    return true;
}

bool memory_manager::decommit_memory(const uint64_t address, const size_t size)
{
    const auto entry = this->find_reserved_region(address);
    if (entry == this->reserved_regions_.end())
    {
        return false;
    }

    if (entry->second.kind == memory_region_kind::mmio)
    {
        throw std::runtime_error("Not allowed to decommit MMIO!");
    }

    const auto end = address + size;
    const auto region_end = entry->first + entry->second.length;

    if (region_end < end)
    {
        throw std::runtime_error("Cross region decommit not supported yet!");
    }

    auto& committed_regions = entry->second.committed_regions;

    split_regions(committed_regions, {address, end});

    for (auto i = committed_regions.begin(); i != committed_regions.end();)
    {
        if (i->first >= end)
        {
            break;
        }

        const auto sub_region_end = i->first + i->second.length;
        if (i->first >= address && sub_region_end <= end)
        {
            this->unmap_memory(i->first, i->second.length);
            i = committed_regions.erase(i);
            continue;
        }

        ++i;
    }

    this->update_layout_version();

    return true;
}

bool memory_manager::release_memory(const uint64_t address, size_t size)
{
    if (!size)
    {
        const auto entry = this->reserved_regions_.find(address);
        if (entry == this->reserved_regions_.end())
        {
            return false;
        }

        auto& committed_regions = entry->second.committed_regions;
        for (auto i = committed_regions.begin(); i != committed_regions.end();)
        {
            this->unmap_memory(i->first, i->second.length);
            i = committed_regions.erase(i);
        }

        this->reserved_regions_.erase(entry);
        this->update_layout_version();
        return true;
    }

    const auto aligned_start = page_align_down(address);
    const auto aligned_end = page_align_up(address + size);
    size = static_cast<size_t>(aligned_end - aligned_start);

    const auto entry = this->find_reserved_region(aligned_start);
    if (entry == this->reserved_regions_.end())
    {
        return false;
    }

    const auto reserved_start = entry->first;
    const auto reserved_end = entry->first + entry->second.length;

    if (reserved_end < aligned_end)
    {
        throw std::runtime_error("Cross region release not supported yet!");
    }

    reserved_region region = std::move(entry->second);
    this->reserved_regions_.erase(entry);

    auto& committed_regions = region.committed_regions;
    split_regions(committed_regions, {aligned_start, aligned_end});

    for (auto i = committed_regions.begin(); i != committed_regions.end();)
    {
        if (i->first >= aligned_end)
        {
            break;
        }

        const auto sub_region_end = i->first + i->second.length;
        if (i->first >= aligned_start && sub_region_end <= aligned_end)
        {
            this->unmap_memory(i->first, i->second.length);
            i = committed_regions.erase(i);
        }
        else
        {
            ++i;
        }
    }

    committed_region_map left_committed{};
    committed_region_map right_committed{};

    for (const auto& sub_region : committed_regions)
    {
        if (sub_region.first < aligned_start)
        {
            left_committed.emplace(sub_region.first, sub_region.second);
        }
        else if (sub_region.first >= aligned_end)
        {
            right_committed.emplace(sub_region.first, sub_region.second);
        }
    }

    if (reserved_start < aligned_start)
    {
        reserved_region left_region{};
        left_region.length = static_cast<size_t>(aligned_start - reserved_start);
        left_region.initial_permission = region.initial_permission;
        left_region.kind = region.kind;
        left_region.committed_regions = std::move(left_committed);
        this->reserved_regions_.try_emplace(reserved_start, std::move(left_region));
    }

    if (aligned_end < reserved_end)
    {
        reserved_region right_region{};
        right_region.length = static_cast<size_t>(reserved_end - aligned_end);
        right_region.initial_permission = region.initial_permission;
        right_region.kind = region.kind;
        right_region.committed_regions = std::move(right_committed);
        this->reserved_regions_.try_emplace(aligned_end, std::move(right_region));
    }

    this->update_layout_version();
    return true;
}

void memory_manager::unmap_all_memory()
{
    for (const auto& reserved_region : this->reserved_regions_)
    {
        for (const auto& region : reserved_region.second.committed_regions)
        {
            this->unmap_memory(region.first, region.second.length);
        }
    }

    this->reserved_regions_.clear();
}

uint64_t memory_manager::allocate_memory(const size_t size, const nt_memory_permission permissions, const bool reserve_only, uint64_t start,
                                         const memory_region_kind kind)
{
    const auto allocation_base = this->find_free_allocation_base(size, start);
    if (!allocate_memory(allocation_base, size, permissions, reserve_only, kind))
    {
        return 0;
    }

    return allocation_base;
}

uint64_t memory_manager::find_free_allocation_base(const size_t size, const uint64_t start) const
{
    uint64_t start_address = std::max(static_cast<uint64_t>(MIN_ALLOCATION_ADDRESS), start ? start : this->default_allocation_address_);
    start_address = align_up(start_address, ALLOCATION_GRANULARITY);

    // Since reserved_regions_ is a sorted map, we can iterate through it
    // and find gaps between regions
    while (start_address + size <= MAX_ALLOCATION_END_EXCL)
    {
        bool conflict = false;

        // Check if the proposed range [start_address, start_address+size) conflicts with any existing region
        for (const auto& region : this->reserved_regions_)
        {
            // If this region ends before our start, skip it
            if (region.first + region.second.length <= start_address)
            {
                continue;
            }

            // If this region starts after our end, we're done checking (map is sorted)
            if (region.first >= start_address + size)
            {
                break;
            }

            // Otherwise, we have a conflict
            conflict = true;
            // Move start_address past this conflicting region
            start_address = align_up(region.first + region.second.length, ALLOCATION_GRANULARITY);
            break;
        }

        // If no conflict was found, we have our address
        if (!conflict)
        {
            return start_address;
        }
    }

    return 0;
}

region_info memory_manager::get_region_info(const uint64_t address)
{
    region_info result{};
    result.start = MIN_ALLOCATION_ADDRESS;
    result.length = static_cast<size_t>(MAX_ALLOCATION_END_EXCL - result.start);
    result.permissions = nt_memory_permission();
    result.initial_permissions = nt_memory_permission();
    result.allocation_base = {};
    result.allocation_length = result.length;
    result.is_committed = false;
    result.is_reserved = false;

    if (this->reserved_regions_.empty())
    {
        return result;
    }

    auto upper_bound = this->reserved_regions_.upper_bound(address);
    if (upper_bound == this->reserved_regions_.begin())
    {
        result.length = static_cast<size_t>(upper_bound->first - result.start);
        return result;
    }

    const auto entry = --upper_bound;
    const auto lower_end = entry->first + entry->second.length;
    if (lower_end <= address)
    {
        result.start = lower_end;
        result.length = static_cast<size_t>(MAX_ALLOCATION_END_EXCL - result.start);
        return result;
    }

    // We have a reserved region
    const auto& reserved_region = entry->second;
    const auto& committed_regions = reserved_region.committed_regions;

    result.is_reserved = true;
    result.allocation_base = entry->first;
    result.allocation_length = reserved_region.length;
    result.start = result.allocation_base;
    result.length = result.allocation_length;
    result.initial_permissions = entry->second.initial_permission;
    result.kind = reserved_region.kind;

    if (committed_regions.empty())
    {
        return result;
    }

    auto committed_bound = committed_regions.upper_bound(address);
    if (committed_bound == committed_regions.begin())
    {
        result.length = static_cast<size_t>(committed_bound->first - result.start);
        return result;
    }

    const auto committed_entry = --committed_bound;
    const auto committed_lower_end = committed_entry->first + committed_entry->second.length;
    if (committed_lower_end <= address)
    {
        result.start = committed_lower_end;
        result.length = static_cast<size_t>(lower_end - result.start);
        return result;
    }

    result.is_committed = true;
    result.start = committed_entry->first;
    result.length = committed_entry->second.length;
    result.permissions = committed_entry->second.permissions;

    return result;
}

memory_manager::reserved_region_map::iterator memory_manager::find_reserved_region(const uint64_t address)
{
    if (this->reserved_regions_.empty())
    {
        return this->reserved_regions_.end();
    }

    auto upper_bound = this->reserved_regions_.upper_bound(address);
    if (upper_bound == this->reserved_regions_.begin())
    {
        return this->reserved_regions_.end();
    }

    const auto entry = --upper_bound;
    if (entry->first + entry->second.length <= address)
    {
        return this->reserved_regions_.end();
    }

    return entry;
}

bool memory_manager::overlaps_reserved_region(const uint64_t address, const size_t size) const
{
    for (const auto& region : this->reserved_regions_)
    {
        if (regions_with_length_intersect(address, size, region.first, region.second.length))
        {
            return true;
        }
    }

    return false;
}

memory_region_kind memory_manager::get_region_kind(const uint64_t address) const
{
    if (this->reserved_regions_.empty())
    {
        return memory_region_kind::free;
    }

    auto upper_bound = this->reserved_regions_.upper_bound(address);
    if (upper_bound == this->reserved_regions_.begin())
    {
        return memory_region_kind::free;
    }

    const auto entry = --upper_bound;
    if (entry->first + entry->second.length <= address)
    {
        return memory_region_kind::free;
    }

    return entry->second.kind;
}

void memory_manager::read_memory(const uint64_t address, void* data, const size_t size) const
{
    this->memory_->read_memory(address, data, size);
}

bool memory_manager::try_read_memory(const uint64_t address, void* data, const size_t size) const
{
    try
    {
        return this->memory_->try_read_memory(address, data, size);
    }
    catch (...)
    {
        return false;
    }
}

void memory_manager::write_memory(const uint64_t address, const void* data, const size_t size)
{
    this->memory_->write_memory(address, data, size);
}

bool memory_manager::try_write_memory(const uint64_t address, const void* data, const size_t size)
{
    try
    {
        return this->memory_->try_write_memory(address, data, size);
    }
    catch (...)
    {
        return false;
    }
}

void memory_manager::map_mmio(const uint64_t address, const size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb)
{
    this->memory_->map_mmio(address, size, std::move(read_cb), std::move(write_cb));
}

void memory_manager::map_memory(const uint64_t address, const size_t size, const memory_permission permissions)
{
    this->memory_->map_memory(address, size, permissions);
}

void memory_manager::unmap_memory(const uint64_t address, const size_t size)
{
    this->memory_->unmap_memory(address, size);
}

void memory_manager::apply_memory_protection(const uint64_t address, const size_t size, const memory_permission permissions)
{
    this->memory_->apply_memory_protection(address, size, permissions);
}

```

`src/windows-emulator/memory_manager.hpp`:

```hpp
#pragma once
#include "std_include.hpp"
#include <map>
#include <atomic>
#include <cstdint>

#include "memory_permission_ext.hpp"
#include "memory_region.hpp"
#include "serialization.hpp"

#include <memory_interface.hpp>

constexpr auto ALLOCATION_GRANULARITY = 0x0000000000010000ULL;
constexpr auto MIN_ALLOCATION_ADDRESS = 0x0000000000010000ULL;
constexpr auto MAX_ALLOCATION_ADDRESS = 0x00007ffffffeffffULL;
constexpr auto MAX_ALLOCATION_END_EXCL = MAX_ALLOCATION_ADDRESS + 1ULL;
constexpr auto DEFAULT_ALLOCATION_ADDRESS_64BIT = 0x100000000ULL;
constexpr auto DEFAULT_ALLOCATION_ADDRESS_32BIT = 0x10000ULL;

enum class memory_region_kind : uint8_t
{
    free = 0,
    private_allocation,
    section_view,
    section_image,
    mmio,
};

// This maps to the `basic_memory_region` struct defined in
// emulator\memory_region.hpp
struct region_info : basic_memory_region<nt_memory_permission>
{
    uint64_t allocation_base{};
    size_t allocation_length{};
    bool is_reserved{};
    bool is_committed{};
    nt_memory_permission initial_permissions{};
    memory_region_kind kind{memory_region_kind::free};
};

using mmio_read_callback = std::function<void(uint64_t addr, void* data, size_t size)>;
using mmio_write_callback = std::function<void(uint64_t addr, const void* data, size_t size)>;

struct memory_stats
{
    uint64_t reserved_memory = 0;
    uint64_t committed_memory = 0;
};

class memory_manager : public memory_interface
{
  public:
    memory_manager(memory_interface& memory)
        : memory_(&memory)
    {
    }

    struct committed_region
    {
        size_t length{};
        nt_memory_permission permissions{};
    };

    using committed_region_map = std::map<uint64_t, committed_region>;

    struct reserved_region
    {
        size_t length{};
        memory_permission initial_permission{};
        committed_region_map committed_regions{};
        memory_region_kind kind{memory_region_kind::private_allocation};
    };

    using reserved_region_map = std::map<uint64_t, reserved_region>;

    void read_memory(uint64_t address, void* data, size_t size) const final;
    bool try_read_memory(uint64_t address, void* data, size_t size) const final;
    void write_memory(uint64_t address, const void* data, size_t size) final;
    bool try_write_memory(uint64_t address, const void* data, size_t size) final;

    bool protect_memory(uint64_t address, size_t size, nt_memory_permission permissions, nt_memory_permission* old_permissions = nullptr);

    bool allocate_mmio(uint64_t address, size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb);
    bool allocate_memory(uint64_t address, size_t size, nt_memory_permission permissions, bool reserve_only = false,
                         memory_region_kind kind = memory_region_kind::private_allocation);

    bool commit_memory(uint64_t address, size_t size, nt_memory_permission permissions);
    bool decommit_memory(uint64_t address, size_t size);

    bool release_memory(uint64_t address, size_t size);

    void unmap_all_memory();

    uint64_t allocate_memory(size_t size, nt_memory_permission permissions, bool reserve_only = false, uint64_t start = 0,
                             memory_region_kind kind = memory_region_kind::private_allocation);

    uint64_t find_free_allocation_base(size_t size, uint64_t start = 0) const;

    region_info get_region_info(uint64_t address);

    reserved_region_map::iterator find_reserved_region(uint64_t address);

    bool overlaps_reserved_region(uint64_t address, size_t size) const;

    memory_region_kind get_region_kind(uint64_t address) const;

    const reserved_region_map& get_reserved_regions() const
    {
        return this->reserved_regions_;
    }

    std::uint64_t get_layout_version() const
    {
        return this->layout_version_.load(std::memory_order_relaxed);
    }

    std::uint64_t get_default_allocation_address() const
    {
        return this->default_allocation_address_;
    }

    void set_default_allocation_address(std::uint64_t address)
    {
        this->default_allocation_address_ = address;
    }

    void serialize_memory_state(utils::buffer_serializer& buffer, bool is_snapshot) const;
    void deserialize_memory_state(utils::buffer_deserializer& buffer, bool is_snapshot);

    memory_stats compute_memory_stats() const;

  private:
    memory_interface* memory_{};
    reserved_region_map reserved_regions_{};
    std::atomic<std::uint64_t> layout_version_{0};
    std::uint64_t default_allocation_address_{0x100000000ULL};

    void map_mmio(uint64_t address, size_t size, mmio_read_callback read_cb, mmio_write_callback write_cb) final;
    void map_memory(uint64_t address, size_t size, memory_permission permissions) final;
    void unmap_memory(uint64_t address, size_t size) final;
    void apply_memory_protection(uint64_t address, size_t size, memory_permission permissions) final;

    void update_layout_version();
};

namespace memory_region_policy
{
    constexpr bool is_section_kind(const memory_region_kind kind)
    {
        return kind == memory_region_kind::section_view || kind == memory_region_kind::section_image;
    }

    constexpr bool is_mapped_memory_kind(const memory_region_kind kind)
    {
        return is_section_kind(kind) || kind == memory_region_kind::mmio;
    }

    constexpr uint32_t to_memory_basic_information_type(const memory_region_kind kind)
    {
        switch (kind)
        {
        case memory_region_kind::section_image:
            return MEM_IMAGE;
        case memory_region_kind::section_view:
            return MEM_MAPPED;
        case memory_region_kind::mmio:
            return MEM_MAPPED;
        default:
            return MEM_PRIVATE;
        }
    }

    constexpr NTSTATUS nt_free_virtual_memory_denied_status(const memory_region_kind kind)
    {
        if (is_section_kind(kind))
        {
            return STATUS_UNABLE_TO_DELETE_SECTION;
        }

        if (kind == memory_region_kind::mmio)
        {
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/memory_permission_ext.hpp`:

```hpp
#pragma once
#include "memory_permission.hpp"

enum class memory_permission_ext : uint8_t
{
    none = 0,
    guard = 1 << 0,
};

/*****************************************************************************
 *
 ****************************************************************************/

constexpr memory_permission_ext operator&(const memory_permission_ext x, const memory_permission_ext y)
{
    return static_cast<memory_permission_ext>(static_cast<uint8_t>(x) & static_cast<uint8_t>(y));
}

constexpr memory_permission_ext operator|(const memory_permission_ext x, const memory_permission_ext y)
{
    return static_cast<memory_permission_ext>(static_cast<uint8_t>(x) | static_cast<uint8_t>(y));
}

constexpr memory_permission_ext operator^(const memory_permission_ext x, const memory_permission_ext y)
{
    return static_cast<memory_permission_ext>(static_cast<uint8_t>(x) ^ static_cast<uint8_t>(y));
}

constexpr memory_permission_ext operator~(memory_permission_ext x)
{
    return static_cast<memory_permission_ext>(~static_cast<uint8_t>(x));
}

inline memory_permission_ext& operator&=(memory_permission_ext& x, const memory_permission_ext y)
{
    x = x & y;
    return x;
}

inline memory_permission_ext& operator|=(memory_permission_ext& x, const memory_permission_ext y)
{
    x = x | y;
    return x;
}

inline memory_permission_ext& operator^=(memory_permission_ext& x, const memory_permission_ext y)
{
    x = x ^ y;
    return x;
}

/*****************************************************************************
 *
 ****************************************************************************/

struct nt_memory_permission
{
    memory_permission common;
    memory_permission_ext extended;

    constexpr nt_memory_permission()
        : common(memory_permission::none),
          extended(memory_permission_ext::none)
    {
    }
    constexpr nt_memory_permission(memory_permission common)
        : common(common),
          extended(memory_permission_ext::none)
    {
    }
    constexpr nt_memory_permission(memory_permission common, memory_permission_ext ext)
        : common(common),
          extended(ext)
    {
    }

    // Implicit coercions
    operator memory_permission() const
    {
        return common;
    }
    operator memory_permission_ext() const
    {
        return extended;
    }

    // This just does memberwise equality on each of the members in declaration order
    bool operator==(nt_memory_permission const&) const = default;

    nt_memory_permission& operator=(memory_permission const& y)
    {
        this->common = y;
        this->extended = memory_permission_ext::none;
        return *this;
    }

    constexpr bool is_guarded() const
    {
        return (this->extended & memory_permission_ext::guard) == memory_permission_ext::guard;
    }
};

/*****************************************************************************
 *
 ****************************************************************************/

constexpr nt_memory_permission operator&(const nt_memory_permission x, const memory_permission y)
{
    return nt_memory_permission{x.common & y, x.extended};
}

constexpr nt_memory_permission operator&(const nt_memory_permission x, const memory_permission_ext y)
{
    return nt_memory_permission{x.common, x.extended & y};
}

constexpr nt_memory_permission operator|(const nt_memory_permission x, const memory_permission y)
{
    return nt_memory_permission{x.common | y, x.extended};
}

constexpr nt_memory_permission operator|(const nt_memory_permission x, const memory_permission_ext y)
{
    return nt_memory_permission{x.common, x.extended | y};
}

constexpr nt_memory_permission operator^(const nt_memory_permission x, const memory_permission y)
{
    return nt_memory_permission{x.common ^ y, x.extended};
}

constexpr nt_memory_permission operator^(const nt_memory_permission x, const memory_permission_ext y)
{
    return nt_memory_permission{x.common, x.extended ^ y};
}

inline nt_memory_permission& operator&=(nt_memory_permission& x, const memory_permission y)
{
    x = x & y;
    return x;
}

inline nt_memory_permission& operator&=(nt_memory_permission& x, const memory_permission_ext y)
{
    x = x & y;
    return x;
}

inline nt_memory_permission& operator|=(nt_memory_permission& x, const memory_permission y)
{
    x.common | y;
    return x;
}

inline nt_memory_permission& operator|=(nt_memory_permission& x, const nt_memory_permission y)
{
    x.extended | y;
    return x;
}

inline nt_memory_permission& operator^=(nt_memory_permission& x, const memory_permission y)
{
    x.common ^ y;
    return x;
}

inline nt_memory_permission& operator^=(nt_memory_permission& x, const nt_memory_permission y)
{
    x.extended ^ y;
    return x;
}

/*****************************************************************************
 *
 ****************************************************************************/

inline bool is_guarded(const memory_permission_ext permission)
{
    return (permission & memory_permission_ext::guard) != memory_permission_ext::none;
}

```

`src/windows-emulator/memory_utils.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <string>
#include <emulator.hpp>
#include "memory_permission_ext.hpp"

inline std::string get_permission_string(const memory_permission permission)
{
    const bool has_exec = (permission & memory_permission::exec) != memory_permission::none;
    const bool has_read = (permission & memory_permission::read) != memory_permission::none;
    const bool has_write = (permission & memory_permission::write) != memory_permission::none;

    std::string res = {};
    res.reserve(3);

    res.push_back(has_read ? 'r' : '-');
    res.push_back(has_write ? 'w' : '-');
    res.push_back(has_exec ? 'x' : '-');

    return res;
}

inline std::optional<nt_memory_permission> try_map_nt_to_emulator_protection(uint32_t nt_protection)
{
    memory_permission_ext ext = memory_permission_ext::none;
    // TODO: Check for invalid combinations
    if (nt_protection & PAGE_GUARD)
    {
        // Unset the guard flag so the following switch statement will still work
        nt_protection &= ~static_cast<uint32_t>(PAGE_GUARD);
        ext = memory_permission_ext::guard;
    }

    // Remove the highest nibble since we are not currently handling those memory protection constants
    // https://github.com/winsiderss/phnt/blob/master/ntmmapi.h#L26
    nt_protection &= ~0xF0000000;

    memory_permission common = memory_permission::none;
    switch (nt_protection)
    {
    case PAGE_NOACCESS:
        common = memory_permission::none;
        break;
    case PAGE_READONLY:
        common = memory_permission::read;
        break;
    case PAGE_READWRITE:
    case PAGE_WRITECOPY:
        common = memory_permission::read | memory_permission::write;
        break;
    case PAGE_EXECUTE:
    case PAGE_EXECUTE_READ:
        common = memory_permission::read | memory_permission::exec;
        break;
    case PAGE_EXECUTE_READWRITE:
        common = memory_permission::all;
        break;
    case PAGE_EXECUTE_WRITECOPY:
        common = memory_permission::all;
        break;
    case 0:
    default:
        return std::nullopt;
    }

    return nt_memory_permission{common, ext};
}

inline nt_memory_permission map_nt_to_emulator_protection(uint32_t nt_protection)
{
    const auto protection = try_map_nt_to_emulator_protection(nt_protection);
    if (protection.has_value())
    {
        return *protection;
    }

    throw std::runtime_error("Failed to map protection: " + std::to_string(nt_protection));
}

inline uint32_t map_emulator_to_nt_protection(const memory_permission permission)
{
    const bool has_exec = (permission & memory_permission::exec) != memory_permission::none;
    const bool has_read = (permission & memory_permission::read) != memory_permission::none;
    const bool has_write = (permission & memory_permission::write) != memory_permission::none;

    if (!has_read)
    {
        return PAGE_NOACCESS;
    }

    if (has_exec && has_write)
    {
        return PAGE_EXECUTE_READWRITE;
    }

    if (has_exec)
    {
        return PAGE_EXECUTE_READ;
    }

    if (has_write)
    {
        return PAGE_READWRITE;
    }

    return PAGE_READONLY;
}

```

`src/windows-emulator/minidump_loader.cpp`:

```cpp
#include "std_include.hpp"

#include "minidump_loader.hpp"
#include "windows_emulator.hpp"
#include "windows_objects.hpp"
#include "emulator_thread.hpp"
#include "memory_utils.hpp"

#include <platform/platform.hpp>

#include <minidump/minidump.hpp>

namespace minidump_loader
{
    struct dump_statistics
    {
        size_t thread_count = 0;
        size_t module_count = 0;
        size_t memory_region_count = 0;
        size_t memory_segment_count = 0;
        size_t handle_count = 0;
        uint64_t total_memory_size = 0;
        bool has_exception = false;
        bool has_system_info = false;
    };

    std::string get_architecture_string(const minidump::minidump_file* dump_file)
    {
        if (!dump_file)
        {
            return "Unknown";
        }

        const auto* sys_info = dump_file->get_system_info();
        if (!sys_info)
        {
            return "Unknown";
        }

        const auto arch = static_cast<minidump::processor_architecture>(sys_info->processor_architecture);
        switch (arch)
        {
        case minidump::processor_architecture::amd64:
            return "x64 (AMD64)";
        case minidump::processor_architecture::intel:
            return "x86 (Intel)";
        case minidump::processor_architecture::arm64:
            return "ARM64";
        default:
            return "Unknown (" + std::to_string(static_cast<int>(arch)) + ")";
        }
    }

    bool parse_minidump_file(windows_emulator& win_emu, const std::filesystem::path& minidump_path,
                             std::unique_ptr<minidump::minidump_file>& dump_file, std::unique_ptr<minidump::minidump_reader>& dump_reader)
    {
        win_emu.log.info("Parsing minidump file\n");

        if (!std::filesystem::exists(minidump_path))
        {
            win_emu.log.error("Minidump file does not exist: %s\n", minidump_path.string().c_str());
            return false;
        }

        const auto file_size = std::filesystem::file_size(minidump_path);
        win_emu.log.info("File size: %ju bytes\n", file_size);

        auto parsed_file = minidump::minidump_file::parse(minidump_path.string());
        if (!parsed_file)
        {
            win_emu.log.error("Failed to parse minidump file\n");
            return false;
        }

        win_emu.log.info("Minidump header parsed successfully\n");

        auto reader = parsed_file->get_reader();
        if (!reader)
        {
            win_emu.log.error("Failed to create minidump reader\n");
            return false;
        }

        dump_file = std::move(parsed_file);
        dump_reader = std::move(reader);

        win_emu.log.info("Minidump reader created successfully\n");
        return true;
    }

    bool validate_dump_compatibility(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        win_emu.log.info("Validating dump compatibility\n");

        if (!dump_file)
        {
            win_emu.log.error("Dump file not loaded\n");
            return false;
        }

        const auto& header = dump_file->header();

        if (!header.is_valid())
        {
            win_emu.log.error("Invalid minidump signature or header\n");
            return false;
        }

        win_emu.log.info("Minidump signature: 0x%08X (valid)\n", header.signature);
        win_emu.log.info("Version: %u.%u\n", header.version, header.implementation_version);
        win_emu.log.info("Number of streams: %u\n", header.number_of_streams);
        win_emu.log.info("Flags: 0x%016" PRIx64 "\n", header.flags);

        const auto* sys_info = dump_file->get_system_info();
        if (sys_info)
        {
            const auto arch = static_cast<minidump::processor_architecture>(sys_info->processor_architecture);
            const bool is_x64 = (arch == minidump::processor_architecture::amd64);

            win_emu.log.info("Processor architecture: %s\n", get_architecture_string(dump_file).c_str());

            if (!is_x64)
            {
                win_emu.log.error("Only x64 minidumps are currently supported\n");
                return false;
            }

            win_emu.log.info("Architecture compatibility: OK (x64)\n");
        }
        else
        {
            win_emu.log.warn("No system info stream found - proceeding with caution\n");
        }

        return true;
    }

    void log_dump_summary(windows_emulator& win_emu, const minidump::minidump_file* dump_file, dump_statistics& stats)
    {
        win_emu.log.info("Generating dump summary\n");

        stats = {};

        if (!dump_file)
        {
            win_emu.log.error("Dump file not loaded\n");
            return;
        }

        stats.thread_count = dump_file->threads().size();
        stats.module_count = dump_file->modules().size();
        stats.memory_region_count = dump_file->memory_regions().size();
        stats.memory_segment_count = dump_file->memory_segments().size();
        stats.handle_count = dump_file->handles().size();
        stats.has_exception = (dump_file->get_exception_info() != nullptr);
        stats.has_system_info = (dump_file->get_system_info() != nullptr);

        for (const auto& segment : dump_file->memory_segments())
        {
            stats.total_memory_size += segment.size;
        }

        win_emu.log.info("Summary: %s, %zu threads, %zu modules, %zu regions, %zu segments, %zu handles, %" PRIu64 " bytes memory\n",
                         get_architecture_string(dump_file).c_str(), stats.thread_count, stats.module_count, stats.memory_region_count,
                         stats.memory_segment_count, stats.handle_count, stats.total_memory_size);
    }

    void process_streams(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        if (!dump_file)
        {
            return;
        }

        // Process system info
        const auto* sys_info = dump_file->get_system_info();
        if (sys_info)
        {
            win_emu.log.info("System: OS %u.%u.%u, %u processors, type %u, platform %u\n", sys_info->major_version, sys_info->minor_version,
                             sys_info->build_number, sys_info->number_of_processors, sys_info->product_type, sys_info->platform_id);
        }

        // Process memory info
        const auto& memory_regions = dump_file->memory_regions();
        uint64_t total_reserved = 0;
        uint64_t total_committed = 0;
        size_t guard_pages = 0;
        for (const auto& region : memory_regions)
        {
            total_reserved += region.region_size;
            if (region.state & MEM_COMMIT)
            {
                total_committed += region.region_size;
            }
            if (region.protect & PAGE_GUARD)
            {
                guard_pages++;
            }
        }
        win_emu.log.info("Memory: %zu regions, %" PRIu64 " bytes reserved, %" PRIu64 " bytes committed, %zu guard pages\n",
                         memory_regions.size(), total_reserved, total_committed, guard_pages);

        // Process memory content
        const auto& memory_segments = dump_file->memory_segments();
        uint64_t min_addr = UINT64_MAX;
        uint64_t max_addr = 0;
        for (const auto& segment : memory_segments)
        {
            min_addr = std::min(min_addr, segment.start_virtual_address);
            max_addr = std::max(max_addr, segment.end_virtual_address());
        }
        if (!memory_segments.empty())
        {
            win_emu.log.info("Content: %zu segments, range 0x%" PRIx64 "-0x%" PRIx64 " (%" PRIu64 " bytes span)\n", memory_segments.size(),
                             min_addr, max_addr, max_addr - min_addr);
        }

        // Process modules
        const auto& modules = dump_file->modules();
        for (const auto& mod : modules)
        {
            win_emu.log.info("Module: %s at 0x%" PRIx64 " (%u bytes)\n", mod.module_name.c_str(), mod.base_of_image, mod.size_of_image);
        }

        // Process threads
        const auto& threads = dump_file->threads();
        for (const auto& thread : threads)
        {
            win_emu.log.info("Thread %u: TEB 0x%" PRIx64 ", stack 0x%" PRIx64 " (%u bytes), context %u bytes\n", thread.thread_id,
                             thread.teb, thread.stack_start_of_memory_range, thread.stack_data_size, thread.context_data_size);
        }

        // Process handles
        const auto& handles = dump_file->handles();
        if (!handles.empty())
        {
            std::map<std::string, size_t> handle_type_counts;
            for (const auto& handle : handles)
            {
                handle_type_counts[handle.type_name]++;
            }
            win_emu.log.info("Handles: %zu total\n", handles.size());
            for (const auto& [type, count] : handle_type_counts)
            {
                win_emu.log.info("  %s: %zu\n", type.c_str(), count);
            }
        }

        // Process exception info
        const auto* exception = dump_file->get_exception_info();
        if (exception)
        {
            win_emu.log.info("Exception: thread %u, code 0x%08X at 0x%" PRIx64 "\n", exception->thread_id,
                             exception->exception_record.exception_code, exception->exception_record.exception_address);
        }
    }

    void reconstruct_memory_state(windows_emulator& win_emu, const minidump::minidump_file* dump_file,
                                  minidump::minidump_reader* dump_reader)
    {
        if (!dump_file || !dump_reader)
        {
            win_emu.log.error("Dump file or reader not loaded\n");
            return;
        }

        const auto& memory_regions = dump_file->memory_regions();
        const auto& memory_segments = dump_file->memory_segments();

        win_emu.log.info("Reconstructing memory: %zu regions, %zu data segments\n", memory_regions.size(), memory_segments.size());
        size_t reserved_count = 0;
        size_t committed_count = 0;
        size_t failed_count = 0;

        for (const auto& region : memory_regions)
        {
            // Log the memory region details
            win_emu.log.info("Region: 0x%" PRIx64 ", size=%" PRIu64 ", state=0x%08X, protect=0x%08X\n", region.base_address,
                             region.region_size, region.state, region.protect);

            const bool is_reserved = (region.state & MEM_RESERVE) != 0;
            const bool is_committed = (region.state & MEM_COMMIT) != 0;
            const bool is_free = (region.state & MEM_FREE) != 0;

            if (is_free)
            {
                continue;
            }

            auto protect_value = region.protect;
            if (protect_value == 0)
            {
                protect_value = PAGE_READONLY;
                win_emu.log.warn("  Region 0x%" PRIx64 " has zero protection, using PAGE_READONLY\n", region.base_address);
            }

            memory_permission perms = map_nt_to_emulator_protection(protect_value);

            try
            {
                if (is_committed)
                {
                    if (win_emu.memory.allocate_memory(region.base_address, static_cast<size_t>(region.region_size), perms, false))
                    {
                        committed_count++;
                        win_emu.log.info("  Allocated committed 0x%" PRIx64 ": size=%" PRIu64 ", state=0x%08X, protect=0x%08X\n",
                                         region.base_address, region.region_size, region.state, region.protect);
                    }
                    else
                    {
                        failed_count++;
                        win_emu.log.warn("  Failed to allocate committed 0x%" PRIx64 ": size=%" PRIu64 "\n", region.base_address,
                                         region.region_size);
                    }
                }
                else if (is_reserved)
                {
                    if (win_emu.memory.allocate_memory(region.base_address, static_cast<size_t>(region.region_size), perms, true))
                    {
                        reserved_count++;
                        win_emu.log.info("  Reserved 0x%" PRIx64 ": size=%" PRIu64 ", state=0x%08X, protect=0x%08X\n", region.base_address,
                                         region.region_size, region.state, region.protect);
                    }
                    else
                    {
                        failed_count++;
                        win_emu.log.warn("  Failed to reserve 0x%" PRIx64 ": size=%" PRIu64 "\n", region.base_address, region.region_size);
                    }
                }
            }
            catch (const std::exception& e)
            {
                failed_count++;
                win_emu.log.error("  Exception allocating 0x%" PRIx64 ": %s\n", region.base_address, e.what());
            }
        }

        win_emu.log.info("Regions: %zu reserved, %zu committed, %zu failed\n", reserved_count, committed_count, failed_count);
        size_t written_count = 0;
        size_t write_failed_count = 0;
        uint64_t total_bytes_written = 0;

        for (const auto& segment : memory_segments)
        {
            try
            {
                auto memory_data = dump_reader->read_memory(segment.start_virtual_address, static_cast<size_t>(segment.size));
                win_emu.memory.write_memory(segment.start_virtual_address, memory_data.data(), static_cast<size_t>(memory_data.size()));
                written_count++;
                total_bytes_written += memory_data.size();
                win_emu.log.info("  Written segment 0x%" PRIx64 ": %zu bytes\n", segment.start_virtual_address, memory_data.size());
            }
            catch (const std::exception& e)
            {
                write_failed_count++;
                win_emu.log.error("  Failed to write segment 0x%" PRIx64 ": %s\n", segment.start_virtual_address, e.what());
            }
        }

        win_emu.log.info("Content: %zu segments written (%" PRIu64 " bytes), %zu failed\n", written_count, total_bytes_written,
                         write_failed_count);
    }

    bool is_main_executable(const minidump::module_info& mod)
    {
        const auto name = mod.module_name;
        return name.find(".exe") != std::string::npos;
    }

    bool is_ntdll(const minidump::module_info& mod)
    {
        const auto name = mod.module_name;
        return name == "ntdll.dll" || name == "NTDLL.DLL";
    }

    bool is_win32u(const minidump::module_info& mod)
    {
        const auto name = mod.module_name;
        return name == "win32u.dll" || name == "WIN32U.DLL";
    }

    void reconstruct_module_state(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        if (!dump_file)
        {
            win_emu.log.error("Dump file not loaded\n");
            return;
        }

        const auto& modules = dump_file->modules();
        win_emu.log.info("Reconstructing module state: %zu modules\n", modules.size());

        size_t mapped_count = 0;
        size_t failed_count = 0;
        size_t identified_count = 0;

        for (const auto& mod : modules)
        {
            try
            {
                auto* mapped_module =
                    win_emu.mod_manager.map_memory_module(mod.base_of_image, mod.size_of_image, mod.module_name, win_emu.log);

                if (mapped_module)
                {
                    mapped_count++;
                    win_emu.log.info("  Mapped %s at 0x%" PRIx64 " (%u bytes, %zu sections, %zu exports)\n", mod.module_name.c_str(),
                                     mod.base_of_image, mod.size_of_image, mapped_module->sections.size(), mapped_module->exports.size());

                    if (is_main_executable(mod))
                    {
                        win_emu.mod_manager.executable = mapped_module;
                        identified_count++;
                        win_emu.log.info("    Identified as main executable\n");
                    }
                    else if (is_ntdll(mod))
                    {
                        win_emu.mod_manager.ntdll = mapped_module;
                        identified_count++;
                        win_emu.log.info("    Identified as ntdll\n");
                    }
                    else if (is_win32u(mod))
                    {
                        win_emu.mod_manager.win32u = mapped_module;
                        identified_count++;
                        win_emu.log.info("    Identified as win32u\n");
                    }
                }
                else
                {
                    failed_count++;
                    win_emu.log.warn("  Failed to map %s at 0x%" PRIx64 "\n", mod.module_name.c_str(), mod.base_of_image);
                }
            }
            catch (const std::exception& e)
            {
                failed_count++;
                win_emu.log.error("  Exception mapping %s: %s\n", mod.module_name.c_str(), e.what());
            }
        }

        win_emu.log.info("Module reconstruction: %zu mapped, %zu failed, %zu system modules identified\n", mapped_count, failed_count,
                         identified_count);
    }

    void setup_kusd_from_dump(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        const auto* sys_info = dump_file->get_system_info();
        if (!sys_info)
        {
            win_emu.log.warn("No system info available - using default KUSD\n");
            return;
        }

        win_emu.log.info("Setting up KUSER_SHARED_DATA from dump system info\n");

        auto& kusd = win_emu.process.kusd.get();
        kusd.NtMajorVersion = sys_info->major_version;
        kusd.NtMinorVersion = sys_info->minor_version;
        kusd.NtBuildNumber = sys_info->build_number;
        kusd.NativeProcessorArchitecture = sys_info->processor_architecture;
        kusd.ActiveProcessorCount = sys_info->number_of_processors;
        kusd.UnparkedProcessorCount = sys_info->number_of_processors;
        kusd.NtProductType = static_cast<NT_PRODUCT_TYPE>(sys_info->product_type);
        kusd.ProductTypeIsValid = 1;

        win_emu.log.info("KUSD updated: Windows %u.%u.%u, %u processors, product type %u\n", sys_info->major_version,
                         sys_info->minor_version, sys_info->build_number, sys_info->number_of_processors, sys_info->product_type);
    }

    bool load_thread_context(const std::filesystem::path& minidump_path, const minidump::thread_info& thread_info,
                             std::vector<std::byte>& context_buffer)
    {
        if (thread_info.context_data_size == 0)
        {
            return false;
        }

        std::ifstream context_file(minidump_path, std::ios::binary);
        if (!context_file.is_open())
        {
            return false;
        }

        context_file.seekg(thread_info.context_rva);
        context_buffer.resize(thread_info.context_data_size);
        context_file.read(reinterpret_cast<char*>(context_buffer.data()), thread_info.context_data_size);

        return context_file.good();
    }

    void reconstruct_threads(windows_emulator& win_emu, const minidump::minidump_file* dump_file,
                             const std::filesystem::path& minidump_path)
    {
        const auto& threads = dump_file->threads();
        if (threads.empty())
        {
            win_emu.log.warn("No threads found in minidump\n");
            return;
        }

        win_emu.log.info("Reconstructing threads: %zu threads\n", threads.size());

        size_t success_count = 0;
        size_t context_loaded_count = 0;

        for (const auto& thread_info : threads)
        {
            try
            {
                emulator_thread thread(win_emu.memory);
                thread.id = thread_info.thread_id;
                thread.stack_base = thread_info.stack_start_of_memory_range;
                thread.stack_size = thread_info.stack_data_size;

                // Load CPU context if available
                const bool context_loaded = load_thread_context(minidump_path, thread_info, thread.last_registers);
                if (context_loaded)
                {
                    context_loaded_count++;
                }

                // Set TEB address if valid
                if (thread_info.teb != 0)
                {
                    thread.teb64 = emulator_object<TEB64>(win_emu.memory);
                    thread.teb64->set_address(thread_info.teb);
                }

                win_emu.log.info("  Thread %u: TEB=0x%" PRIx64 ", stack=0x%" PRIx64 " (%u bytes), context=%s\n", thread_info.thread_id,
                                 thread_info.teb, thread.stack_base, thread_info.stack_data_size,
                                 context_loaded ? "loaded" : "unavailable");

                win_emu.process.threads.store(std::move(thread));
                success_count++;
            }
            catch (const std::exception& e)
            {
                win_emu.log.error("  Failed to reconstruct thread %u: %s\n", thread_info.thread_id, e.what());
            }
        }

        // Set active thread to first available thread
        if (success_count > 0)
        {
            auto& first_thread = win_emu.process.threads.begin()->second;
            win_emu.process.active_thread = &first_thread;
        }

        win_emu.log.info("Thread reconstruction: %zu/%zu threads created, %zu with context\n", success_count, threads.size(),
                         context_loaded_count);
    }

    void setup_peb_from_teb(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        const auto& threads = dump_file->threads();
        if (threads.empty())
        {
            win_emu.log.warn("No threads available for PEB setup\n");
            return;
        }

        const auto& first_thread = threads[0];
        if (first_thread.teb == 0)
        {
            win_emu.log.warn("Thread %u has null TEB address\n", first_thread.thread_id);
            return;
        }

        try
        {
            constexpr uint64_t teb_peb_offset = offsetof(TEB64, ProcessEnvironmentBlock);
            uint64_t peb_address = 0;

            win_emu.memory.read_memory(first_thread.teb + teb_peb_offset, &peb_address, sizeof(peb_address));

            if (peb_address == 0)
            {
                win_emu.log.warn("PEB address is null in TEB at 0x%" PRIx64 "\n", first_thread.teb);
                return;
            }

            win_emu.process.peb64.set_address(peb_address);
            win_emu.log.info("PEB address: 0x%" PRIx64 " (from TEB 0x%" PRIx64 ")\n", peb_address, first_thread.teb);
        }
        catch (const std::exception& e)
        {
            win_emu.log.error("Failed to read PEB from TEB: %s\n", e.what());
        }
    }

    void reconstruct_handle_table(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        const auto& handles = dump_file->handles();
        if (handles.empty())
        {
            return;
        }

        win_emu.log.info("Reconstructing handle table: %zu handles\n", handles.size());

        std::map<std::string, size_t> handle_type_counts;
        size_t created_count = 0;

        for (const auto& handle_info : handles)
        {
            handle_type_counts[handle_info.type_name]++;

            try
            {
                if (handle_info.type_name == "Event")
                {
                    event evt{};
                    evt.name = u8_to_u16(handle_info.object_name);
                    win_emu.process.events.store(std::move(evt));
                    created_count++;
                }
                else if (handle_info.type_name == "File")
                {
                    file f{};
                    f.name = u8_to_u16(handle_info.object_name);
                    win_emu.process.files.store(std::move(f));
                    created_count++;
                }
                else if (handle_info.type_name == "Mutant")
                {
                    mutant m{};
                    m.name = u8_to_u16(handle_info.object_name);
                    win_emu.process.mutants.store(std::move(m));
                    created_count++;
                }
                // Other handle types can be added here as needed
            }
            catch (const std::exception& e)
            {
                win_emu.log.error("  Failed to create %s handle '%s': %s\n", handle_info.type_name.c_str(), handle_info.object_name.c_str(),
                                  e.what());
            }
        }

        // Log summary by type
        for (const auto& [type, count] : handle_type_counts)
        {
            win_emu.log.info("  %s: %zu handles\n", type.c_str(), count);
        }

        win_emu.log.info("Handle table: %zu/%zu handles reconstructed\n", created_count, handles.size());
    }

    void setup_exception_context(windows_emulator& win_emu, const minidump::minidump_file* dump_file)
    {
        const auto* exception_info = dump_file->get_exception_info();
        if (!exception_info)
        {
            return;
        }

        win_emu.log.info("Exception context: address=0x%" PRIx64 ", code=0x%08X, thread=%u\n",
                         exception_info->exception_record.exception_address, exception_info->exception_record.exception_code,
                         exception_info->thread_id);
    }

    void load_minidump_into_emulator(windows_emulator& win_emu, const std::filesystem::path& minidump_path)
    {
        win_emu.log.info("Starting minidump loading process\n");
        win_emu.log.info("Minidump file: %s\n", minidump_path.string().c_str());

        try
        {
            std::unique_ptr<minidump::minidump_file> dump_file;
            std::unique_ptr<minidump::minidump_reader> dump_reader;

            if (!parse_minidump_file(win_emu, minidump_path, dump_file, dump_reader))
            {
                throw std::runtime_error("Failed to parse minidump file");
            }

            if (!validate_dump_compatibility(win_emu, dump_file.get()))
            {
                throw std::runtime_error("Minidump compatibility validation failed");
            }

            setup_kusd_from_dump(win_emu, dump_file.get());

            dump_statistics stats;
            log_dump_summary(win_emu, dump_file.get(), stats);
            process_streams(win_emu, dump_file.get());

            // Existing phases
            reconstruct_memory_state(win_emu, dump_file.get(), dump_reader.get());
            reconstruct_module_state(win_emu, dump_file.get());

            // Process state reconstruction phases
            setup_peb_from_teb(win_emu, dump_file.get());
            reconstruct_threads(win_emu, dump_file.get(), minidump_path);
            reconstruct_handle_table(win_emu, dump_file.get());
            setup_exception_context(win_emu, dump_file.get());

            win_emu.log.info("Process state reconstruction completed\n");
        }
        catch (const std::exception& e)
        {
            win_emu.log.error("Minidump loading failed: %s\n", e.what());
            throw;
        }
    }
} // namespace minidump_loader

```

`src/windows-emulator/minidump_loader.hpp`:

```hpp
#pragma once
#include <filesystem>

class windows_emulator;

namespace minidump_loader
{
    void load_minidump_into_emulator(windows_emulator& win_emu, const std::filesystem::path& minidump_path);
}

```

`src/windows-emulator/module/mapped_module.hpp`:

```hpp
#pragma once
#include <memory_region.hpp>
#include "../windows_path.hpp"

struct exported_symbol
{
    std::string name{};
    uint64_t ordinal{};
    uint64_t rva{};
    uint64_t address{};
};

struct imported_symbol
{
    std::string name{};
    size_t module_index{};
};

using exported_symbols = std::vector<exported_symbol>;
using imported_symbols = std::unordered_map<uint64_t, imported_symbol>;
using imported_module_list = std::vector<std::string>;
using address_name_mapping = std::map<uint64_t, std::string>;

struct mapped_section
{
    uint64_t first_execute = UINT64_MAX;
    std::string name{};
    basic_memory_region<> region{};
};

struct mapped_module
{
    std::string name{};
    std::filesystem::path path{};
    windows_path module_path{};

    uint64_t image_base{};
    uint64_t image_base_file{};
    uint64_t size_of_image{};
    uint64_t entry_point{};

    // PE header fields
    uint16_t machine{};               // Machine type from file header
    uint64_t size_of_stack_reserve{}; // Stack reserve size from optional header
    uint64_t size_of_stack_commit{};  // Stack commit size from optional header
    uint64_t size_of_heap_reserve{};  // Heap reserve size from optional header
    uint64_t size_of_heap_commit{};   // Heap commit size from optional header

    exported_symbols exports{};
    imported_symbols imports{};
    imported_module_list imported_modules{};
    address_name_mapping address_names{};

    std::vector<mapped_section> sections{};

    bool is_static{false};

    bool contains(const uint64_t address) const
    {
        return (address - this->image_base) < this->size_of_image;
    }

    uint64_t find_export(const std::string_view export_name) const
    {
        for (const auto& symbol : this->exports)
        {
            if (symbol.name == export_name)
            {
                return symbol.address;
            }
        }

        return 0;
    }

    uint64_t get_image_base_file() const
    {
        return this->image_base_file;
    }
};

```

`src/windows-emulator/module/module_manager.cpp`:

```cpp
#include "../std_include.hpp"
#include "module_manager.hpp"
#include "module_mapping.hpp"
#include "platform/win_pefile.hpp"
#include "windows-emulator/logger.hpp"
#include "../wow64_heaven_gate.hpp"
#include "../version/windows_version_manager.hpp"
#include "../process_context.hpp"

#include <serialization_helper.hpp>
#include <cinttypes>
#include <vector>

namespace
{
    uint64_t get_system_dll_init_block_size(const windows_version_manager& version)
    {
        if (version.is_build_after_or_equal(WINDOWS_VERSION::WINDOWS_11_24H2))
        {
            return PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V3;
        }
        if (version.is_build_after_or_equal(WINDOWS_VERSION::WINDOWS_10_2004))
        {
            return PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V3_2004;
        }
        if (version.is_build_after_or_equal(WINDOWS_VERSION::WINDOWS_10_1709))
        {
            return PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V2;
        }
        if (version.is_build_after_or_equal(WINDOWS_VERSION::WINDOWS_10_1703))
        {
            return PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V2_1703;
        }
        return PS_SYSTEM_DLL_INIT_BLOCK_SIZE_V1;
    }
}

namespace utils
{
    static void serialize(buffer_serializer& buffer, const exported_symbol& sym)
    {
        buffer.write(sym.name);
        buffer.write(sym.ordinal);
        buffer.write(sym.rva);
        buffer.write(sym.address);
    }

    static void deserialize(buffer_deserializer& buffer, exported_symbol& sym)
    {
        buffer.read(sym.name);
        buffer.read(sym.ordinal);
        buffer.read(sym.rva);
        buffer.read(sym.address);
    }

    static void serialize(buffer_serializer& buffer, const basic_memory_region<>& region)
    {
        buffer.write(region.start);
        buffer.write<uint64_t>(region.length);
        buffer.write(region.permissions);
    }

    static void deserialize(buffer_deserializer& buffer, basic_memory_region<>& region)
    {
        buffer.read(region.start);
        region.length = static_cast<size_t>(buffer.read<uint64_t>());
        buffer.read(region.permissions);
    }

    static void serialize(buffer_serializer& buffer, const mapped_section& mod)
    {
        buffer.write(mod.name);
        buffer.write(mod.region);
    }

    static void deserialize(buffer_deserializer& buffer, mapped_section& mod)
    {
        buffer.read(mod.name);
        buffer.read(mod.region);
    }

    static void serialize(buffer_serializer& buffer, const mapped_module& mod)
    {
        buffer.write(mod.name);
        buffer.write(mod.path);
        buffer.write(mod.module_path);

        buffer.write(mod.image_base);
        buffer.write(mod.image_base_file);
        buffer.write(mod.size_of_image);
        buffer.write(mod.entry_point);

        buffer.write(mod.machine);
        buffer.write(mod.size_of_stack_reserve);
        buffer.write(mod.size_of_stack_commit);
        buffer.write(mod.size_of_heap_reserve);
        buffer.write(mod.size_of_heap_commit);

        buffer.write_vector(mod.exports);
        buffer.write_map(mod.address_names);

        buffer.write_vector(mod.sections);

        buffer.write(mod.is_static);
    }

    static void deserialize(buffer_deserializer& buffer, mapped_module& mod)
    {
        buffer.read(mod.name);
        buffer.read(mod.path);
        buffer.read(mod.module_path);

        buffer.read(mod.image_base);
        buffer.read(mod.image_base_file);
        buffer.read(mod.size_of_image);
        buffer.read(mod.entry_point);

        buffer.read(mod.machine);
        buffer.read(mod.size_of_stack_reserve);
        buffer.read(mod.size_of_stack_commit);
        buffer.read(mod.size_of_heap_reserve);
        buffer.read(mod.size_of_heap_commit);

        buffer.read_vector(mod.exports);
        buffer.read_map(mod.address_names);

        buffer.read_vector(mod.sections);

        buffer.read(mod.is_static);
    }
}

pe_detection_result pe_architecture_detector::detect_from_file(const std::filesystem::path& file)
{
    auto variant_result = winpe::get_pe_arch(file);

    if (std::holds_alternative<std::error_code>(variant_result))
    {
        pe_detection_result result;
        result.error_message = "Failed to detect PE architecture from file: " + file.string();
        return result;
    }

    auto arch = std::get<winpe::pe_arch>(variant_result);
    pe_detection_result result;
    result.architecture = arch;
    result.suggested_mode = determine_execution_mode(arch);
    return result;
}

pe_detection_result pe_architecture_detector::detect_from_memory(uint64_t base_address, uint64_t image_size)
{
    auto variant_result = winpe::get_pe_arch(base_address, image_size);

    if (std::holds_alternative<std::error_code>(variant_result))
    {
        pe_detection_result result;
        result.error_message = "Failed to detect PE architecture from memory at 0x" + std::to_string(base_address);
        return result;
    }

    auto arch = std::get<winpe::pe_arch>(variant_result);
    pe_detection_result result;
    result.architecture = arch;
    result.suggested_mode = determine_execution_mode(arch);
    return result;
}

execution_mode pe_architecture_detector::determine_execution_mode(winpe::pe_arch executable_arch)
{
    switch (executable_arch)
    {
    case winpe::pe_arch::pe32:
        return execution_mode::wow64_32bit;
    case winpe::pe_arch::pe64:
        return execution_mode::native_64bit;
    default:
        return execution_mode::unknown;
    }
}

// PE32 Mapping Strategy Implementation
mapped_module pe32_mapping_strategy::map_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path)
{
    return map_module_from_file<std::uint32_t>(memory, std::move(file), std::move(module_path));
}

mapped_module pe32_mapping_strategy::map_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size,
                                                     windows_path module_path)
{
    return map_module_from_memory<std::uint32_t>(memory, base_address, image_size, std::move(module_path));
}

// PE64 Mapping Strategy Implementation
mapped_module pe64_mapping_strategy::map_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path)
{
    return map_module_from_file<std::uint64_t>(memory, std::move(file), std::move(module_path));
}

mapped_module pe64_mapping_strategy::map_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size,
                                                     windows_path module_path)
{
    return map_module_from_memory<std::uint64_t>(memory, base_address, image_size, module_path);
}

mapping_strategy_factory::mapping_strategy_factory()
    : pe32_strategy_(std::make_unique<pe32_mapping_strategy>()),
      pe64_strategy_(std::make_unique<pe64_mapping_strategy>())
{
}

module_mapping_strategy& mapping_strategy_factory::get_strategy(winpe::pe_arch arch)
{
    switch (arch)
    {
    case winpe::pe_arch::pe32:
        return *pe32_strategy_;
    case winpe::pe_arch::pe64:
        return *pe64_strategy_;
    default:
        throw std::runtime_error("Unsupported PE architecture");
    }
}

module_manager::module_manager(memory_manager& memory, file_system& file_sys, callbacks& cb)
    : memory_(&memory),
      file_sys_(&file_sys),
      callbacks_(&cb)
{
}

mapped_module* module_manager::map_module_core(const pe_detection_result& detection_result, const std::function<mapped_module()>& mapper,
                                               const logger& logger, bool is_static)
{
    if (!detection_result.is_valid())
    {
        logger.error("%s", detection_result.error_message.c_str());
        return nullptr;
    }

    try
    {
        [[maybe_unused]] auto& strategy = strategy_factory_.get_strategy(detection_result.architecture);
        mapped_module mod = mapper();
        mod.is_static = is_static;

        if (!mod.path.empty())
        {
            this->modules_load_count[mod.path]++;
        }

        const auto image_base = mod.image_base;
        const auto entry = this->modules_.try_emplace(image_base, std::move(mod));
        this->last_module_cache_ = this->modules_.end();
        this->callbacks_->on_module_load(entry.first->second);
        return &entry.first->second;
    }
    catch (const std::exception& e)
    {
        logger.error("Failed to map module: %s", e.what());
        return nullptr;
    }
}

execution_mode module_manager::detect_execution_mode(const windows_path& executable_path, const logger& logger)
{
    auto detection_result = pe_architecture_detector::detect_from_file(this->file_sys_->translate(executable_path));

    if (!detection_result.is_valid())
    {
        logger.error("Failed to detect executable architecture: %s", detection_result.error_message.c_str());
        return execution_mode::unknown;
    }

    return detection_result.suggested_mode;
}

void module_manager::load_native_64bit_modules(const windows_path& executable_path, const windows_path& ntdll_path,
                                               const windows_path& win32u_path, const logger& logger)
{
    this->executable = this->map_module(executable_path, logger, true);
    this->ntdll = this->map_module(ntdll_path, logger, true);
    this->win32u = this->map_module(win32u_path, logger, true);
}

void module_manager::load_wow64_modules(const windows_path& executable_path, const windows_path& ntdll_path,
                                        const windows_path& win32u_path, const windows_path& ntdll32_path, windows_version_manager& version,
                                        const logger& logger)
{
    logger.info("Loading WOW64 modules for 32-bit application\n");

    this->executable = this->map_module(executable_path, logger, true);
    this->ntdll = this->map_module(ntdll_path, logger, true);
    this->win32u = this->map_module(win32u_path, logger, true);

    this->wow64_modules_.ntdll32 = this->map_module(ntdll32_path, logger, true);

    const auto ntdll32_original_imagebase = this->wow64_modules_.ntdll32->get_image_base_file();
    const auto ntdll64_original_imagebase = this->ntdll->get_image_base_file();

    if (ntdll32_original_imagebase == 0 || ntdll64_original_imagebase == 0)
    {
        logger.error("Failed to get PE ImageBase values for WOW64 setup\n");
        return;
    }

    PS_SYSTEM_DLL_INIT_BLOCK init_block = {};
    const auto init_block_size = get_system_dll_init_block_size(version);

    init_block.Size = static_cast<ULONG>(init_block_size);

    // Calculate relocation values
    // SystemDllWowRelocation = mapped_base - original_imagebase for 32-bit ntdll
    init_block.SystemDllWowRelocation = this->wow64_modules_.ntdll32->image_base - ntdll32_original_imagebase;

    // SystemDllNativeRelocation = mapped_base - original_imagebase for 64-bit ntdll
    init_block.SystemDllNativeRelocation = this->ntdll->image_base - ntdll64_original_imagebase;

    // Fill Wow64SharedInformation array with 32-bit ntdll export addresses
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32LdrInitializeThunk)] =
        this->wow64_modules_.ntdll32->find_export("LdrInitializeThunk");
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32KiUserExceptionDispatcher)] =
        this->wow64_modules_.ntdll32->find_export("KiUserExceptionDispatcher");
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32KiUserApcDispatcher)] =
        this->wow64_modules_.ntdll32->find_export("KiUserApcDispatcher");
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32KiUserCallbackDispatcher)] =
        this->wow64_modules_.ntdll32->find_export("KiUserCallbackDispatcher");
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32RtlUserThreadStart)] =
        this->wow64_modules_.ntdll32->find_export("RtlUserThreadStart");
    init_block
        .Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32pQueryProcessDebugInformationRemote)] =
        this->wow64_modules_.ntdll32->find_export("RtlpQueryProcessDebugInformationRemote");
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32BaseAddress)] =
        this->wow64_modules_.ntdll32->image_base;
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32LdrSystemDllInitBlock)] =
        this->wow64_modules_.ntdll32->find_export("LdrSystemDllInitBlock");
    init_block.Wow64SharedInformation[static_cast<uint64_t>(WOW64_SHARED_INFORMATION_V5::SharedNtdll32RtlpFreezeTimeBias)] =
        this->wow64_modules_.ntdll32->find_export("RtlpFreezeTimeBias");

    // Set RngData to a random non-zero value for early randomization
    init_block.RngData = 0x11111111;

    // Set flags and mitigation options based on WinDbg data
    init_block.Flags = 0x22222022;
    init_block.MitigationOptionsMap.Map[0] = 0x20002000;
    init_block.MitigationOptionsMap.Map[1] = 0x00000002;
    init_block.MitigationOptionsMap.Map[2] = 0x00000000;

    // CFG and audit options (set to zero as per WinDbg data)
    init_block.CfgBitMap = 0;
    init_block.CfgBitMapSize = 0;
    init_block.Wow64CfgBitMap = 0;
    init_block.Wow64CfgBitMapSize = 0;
    init_block.MitigationAuditOptionsMap.Map[0] = 0;
    init_block.MitigationAuditOptionsMap.Map[1] = 0;
    init_block.MitigationAuditOptionsMap.Map[2] = 0;

    // Find LdrSystemDllInitBlock export address in 64-bit ntdll and write the structure
    const auto ldr_init_block_addr = this->ntdll->find_export("LdrSystemDllInitBlock");
    if (ldr_init_block_addr == 0)
    {
        logger.error("Failed to find LdrSystemDllInitBlock export in 64-bit ntdll\n");
        return;
    }

    this->memory_->write_memory(ldr_init_block_addr, &init_block, static_cast<size_t>(init_block_size));

    logger.info("Successfully initialized LdrSystemDllInitBlock at 0x%" PRIx64 "\n", ldr_init_block_addr);

    // Install the WOW64 Heaven's Gate trampoline used for compat-mode -> 64-bit transitions.
    this->install_wow64_heaven_gate(logger);
}

void module_manager::install_wow64_heaven_gate(const logger& logger)
{
    using wow64::heaven_gate::kCodeBase;
    using wow64::heaven_gate::kCodeSize;
    using wow64::heaven_gate::kStackBase;
    using wow64::heaven_gate::kStackSize;
    using wow64::heaven_gate::kTrampolineBytes;

    auto allocate_or_validate = [&](uint64_t base, size_t size, memory_permission perms, const char* name) {
        if (!this->memory_->allocate_memory(base, size, perms))
        {
            const auto region = this->memory_->get_region_info(base);
            if (!region.is_reserved || region.allocation_length < size)
            {
                logger.error("Failed to allocate %s at 0x%" PRIx64 " (size 0x%zx)\n", name, base, size);
                return false;
            }
        }
        return true;
    };

    bool code_initialized = false;
    if (allocate_or_validate(kCodeBase, kCodeSize, memory_permission::read_write, "WOW64 heaven gate code"))
    {
        if (!this->memory_->protect_memory(kCodeBase, kCodeSize, nt_memory_permission(memory_permission::read_write)))
        {
            logger.error("Failed to change protection for WOW64 heaven gate code at 0x%" PRIx64 "\n", kCodeBase);
        }
        else
        {
            std::vector<uint8_t> buffer(kCodeSize, 0);
            this->memory_->write_memory(kCodeBase, buffer.data(), buffer.size());
            this->memory_->write_memory(kCodeBase, kTrampolineBytes.data(), kTrampolineBytes.size());
            this->memory_->protect_memory(kCodeBase, kCodeSize, nt_memory_permission(memory_permission::read | memory_permission::exec));
            code_initialized = true;
        }

        if (code_initialized && this->modules_.find(kCodeBase) == this->modules_.end())
        {
            mapped_module module{};
            module.name = "wow64_heaven_gate";
            module.path = "<wow64-heaven-gate>";
            module.image_base = kCodeBase;
            module.image_base_file = kCodeBase;
            module.size_of_image = kCodeSize;
            module.entry_point = kCodeBase;
            constexpr uint16_t kMachineAmd64 = 0x8664;
            module.machine = kMachineAmd64;
            module.is_static = true;

            mapped_section section{};
            section.name = ".gate";
            section.region.start = kCodeBase;
            section.region.length = kCodeSize;
            section.region.permissions = memory_permission::read | memory_permission::exec;
            module.sections.emplace_back(std::move(section));

            this->modules_.emplace(module.image_base, std::move(module));
            this->last_module_cache_ = this->modules_.end();
        }
    }

    if (allocate_or_validate(kStackBase, kStackSize, memory_permission::read_write, "WOW64 heaven gate stack"))
    {
        std::vector<uint8_t> buffer(kStackSize, 0);
        this->memory_->write_memory(kStackBase, buffer.data(), buffer.size());
    }
}

void module_manager::map_main_modules(const windows_path& executable_path, windows_version_manager& version, process_context& context,
                                      const logger& logger)
{
    const auto& system_root = version.get_system_root();
    const auto system32_path = system_root / "System32";
    const auto syswow64_path = system_root / "SysWOW64";

    current_execution_mode_ = detect_execution_mode(executable_path, logger);
    context.is_wow64_process = (current_execution_mode_ == execution_mode::wow64_32bit);

    switch (current_execution_mode_)
    {
    case execution_mode::native_64bit:
        load_native_64bit_modules(executable_path, system32_path / "ntdll.dll", system32_path / "win32u.dll", logger);
        break;

    case execution_mode::wow64_32bit:
        load_wow64_modules(executable_path, system32_path / "ntdll.dll", system32_path / "win32u.dll", syswow64_path / "ntdll.dll", version,
                           logger);
        break;

    case execution_mode::unknown:
    default:
        throw std::runtime_error("Unknown or unsupported execution mode detected");
    }
}

std::optional<uint64_t> module_manager::get_module_load_count_by_path(const windows_path& path)
{
    auto local_file = std::filesystem::weakly_canonical(std::filesystem::absolute(this->file_sys_->translate(path)));

    if (auto load_count_entry = modules_load_count.find(local_file); load_count_entry != modules_load_count.end())
    {
        return load_count_entry->second;
    }

    return {};
}

mapped_module* module_manager::map_module(windows_path file, const logger& logger, const bool is_static, bool allow_duplicate)
{
    auto local_file = this->file_sys_->translate(file);

    if (local_file.filename() == "win32u.dll")
    {
        return this->map_local_module(local_file, std::move(file), logger, is_static, false);
    }

    return this->map_local_module(local_file, std::move(file), logger, is_static, allow_duplicate);
}

mapped_module* module_manager::map_local_module(const std::filesystem::path& file, windows_path module_path, const logger& logger,
                                                const bool is_static, bool allow_duplicate)
{
    auto local_file = weakly_canonical(absolute(file));

    if (!allow_duplicate)
    {
        for (auto& mod : this->modules_ | std::views::values)
        {
            if (mod.path == local_file)
            {
                return &mod;
            }
        }
    }

    auto detection_result = pe_architecture_detector::detect_from_file(local_file);

    return map_module_core(
        detection_result,
        [&]() {
            auto& strategy = strategy_factory_.get_strategy(detection_result.architecture);
            return strategy.map_from_file(*this->memory_, std::move(local_file), std::move(module_path));
        },
        logger, is_static);
}

mapped_module* module_manager::map_memory_module(uint64_t base_address, uint64_t image_size, windows_path module_path, const logger& logger,
                                                 bool is_static, bool allow_duplicate)
{
    if (!allow_duplicate)
    {
        for (auto& mod : this->modules_ | std::views::values)
        {
            if (mod.image_base == base_address)
            {
                return &mod;
            }
        }
    }

    auto detection_result = pe_architecture_detector::detect_from_memory(base_address, image_size);

    return map_module_core(
        detection_result,
        [&]() {
            auto& strategy = strategy_factory_.get_strategy(detection_result.architecture);
            return strategy.map_from_memory(*this->memory_, base_address, image_size, std::move(module_path));
        },
        logger, is_static);
}

void module_manager::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write_map(this->modules_);
    buffer.write_map(this->modules_load_count);

    buffer.write(this->executable ? this->executable->image_base : 0);
    buffer.write(this->ntdll ? this->ntdll->image_base : 0);
    buffer.write(this->win32u ? this->win32u->image_base : 0);

    // Serialize execution mode
    buffer.write(static_cast<uint32_t>(this->current_execution_mode_));

    // Serialize WOW64 module pointers
    buffer.write(this->wow64_modules_.ntdll32 ? this->wow64_modules_.ntdll32->image_base : 0);
    buffer.write(this->wow64_modules_.wow64_dll ? this->wow64_modules_.wow64_dll->image_base : 0);
    buffer.write(this->wow64_modules_.wow64win_dll ? this->wow64_modules_.wow64win_dll->image_base : 0);
}

void module_manager::deserialize(utils::buffer_deserializer& buffer)
{
    buffer.read_map(this->modules_);
    buffer.read_map(this->modules_load_count);
    this->last_module_cache_ = this->modules_.end();

    const auto executable_base = buffer.read<uint64_t>();
    const auto ntdll_base = buffer.read<uint64_t>();
    const auto win32u_base = buffer.read<uint64_t>();

    this->executable = executable_base ? this->find_by_address(executable_base) : nullptr;
    this->ntdll = ntdll_base ? this->find_by_address(ntdll_base) : nullptr;
    this->win32u = win32u_base ? this->find_by_address(win32u_base) : nullptr;

    // Deserialize execution mode
    this->current_execution_mode_ = static_cast<execution_mode>(buffer.read<uint32_t>());

    // Deserialize WOW64 module pointers
    const auto ntdll32_base = buffer.read<uint64_t>();
    const auto wow64_dll_base = buffer.read<uint64_t>();
    const auto wow64win_dll_base = buffer.read<uint64_t>();

    this->wow64_modules_.ntdll32 = ntdll32_base ? this->find_by_address(ntdll32_base) : nullptr;
    this->wow64_modules_.wow64_dll = wow64_dll_base ? this->find_by_address(wow64_dll_base) : nullptr;
    this->wow64_modules_.wow64win_dll = wow64win_dll_base ? this->find_by_address(wow64win_dll_base) : nullptr;
}

bool module_manager::unmap(const uint64_t address)
{
    const auto mod = this->modules_.find(address);
    if (mod == this->modules_.end())
    {
        return false;
    }

    if (mod->second.is_static)
    {
        return true;
    }

    this->callbacks_->on_module_unload(mod->second);
    unmap_module(*this->memory_, mod->second);

    auto module_load_count = this->modules_load_count[mod->second.path] - 1;
    if (module_load_count == 0)
    {
        this->modules_load_count.erase(mod->second.path);
    }
    else
    {
        this->modules_load_count[mod->second.path] = module_load_count;
    }

    this->modules_.erase(mod);
    this->last_module_cache_ = this->modules_.end();

    return true;
}

```

`src/windows-emulator/module/module_manager.hpp`:

```hpp
#pragma once
#include <emulator.hpp>

#include "mapped_module.hpp"
#include "../file_system.hpp"
#include <utils/function.hpp>
#include "platform/win_pefile.hpp"

class logger;
class registry_manager;
class windows_version_manager;
struct process_context;

// Execution mode for the emulated process
enum class execution_mode
{
    native_64bit, // Native 64-bit execution
    wow64_32bit,  // WOW64 mode for 32-bit applications
    unknown       // Detection failed or unsupported
};

// PE architecture detection result
struct pe_detection_result
{
    winpe::pe_arch architecture;
    execution_mode suggested_mode;
    std::string error_message;

    bool is_valid() const
    {
        return error_message.empty();
    }
};

class module_mapping_strategy
{
  public:
    virtual ~module_mapping_strategy() = default;
    virtual mapped_module map_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path) = 0;
    virtual mapped_module map_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size, windows_path module_path) = 0;
};

class pe32_mapping_strategy : public module_mapping_strategy
{
  public:
    mapped_module map_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path) override;
    mapped_module map_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size, windows_path module_path) override;
};

class pe64_mapping_strategy : public module_mapping_strategy
{
  public:
    mapped_module map_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path) override;
    mapped_module map_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size, windows_path module_path) override;
};

class mapping_strategy_factory
{
  private:
    std::unique_ptr<pe32_mapping_strategy> pe32_strategy_;
    std::unique_ptr<pe64_mapping_strategy> pe64_strategy_;

  public:
    mapping_strategy_factory();
    module_mapping_strategy& get_strategy(winpe::pe_arch arch);
};

class pe_architecture_detector
{
  public:
    static pe_detection_result detect_from_file(const std::filesystem::path& file);
    static pe_detection_result detect_from_memory(uint64_t base_address, uint64_t image_size);
    static execution_mode determine_execution_mode(winpe::pe_arch executable_arch);
};

class module_manager
{
  public:
    struct callbacks
    {
        utils::callback_list<void(mapped_module& mod)> on_module_load{};
        utils::callback_list<void(mapped_module& mod)> on_module_unload{};
    };

    using module_map = std::map<uint64_t, mapped_module>;

    module_manager(memory_manager& memory, file_system& file_sys, callbacks& cb);

    void map_main_modules(const windows_path& executable_path, windows_version_manager& version, process_context& context,
                          const logger& logger);

    std::optional<uint64_t> get_module_load_count_by_path(const windows_path& path);
    mapped_module* map_module(windows_path file, const logger& logger, bool is_static = false, bool allow_duplicate = false);
    mapped_module* map_local_module(const std::filesystem::path& file, windows_path module_path, const logger& logger,
                                    bool is_static = false, bool allow_duplicate = false);
    mapped_module* map_memory_module(uint64_t base_address, uint64_t image_size, windows_path module_path, const logger& logger,
                                     bool is_static = false, bool allow_duplicate = false);

    mapped_module* find_by_address(const uint64_t address)
    {
        const auto entry = this->get_module(address);
        if (entry != this->modules_.end())
        {
            return &entry->second;
        }

        return nullptr;
    }

    mapped_module* find_by_name(const std::string_view name)
    {
        for (auto& mod : this->modules_ | std::views::values)
        {
            if (mod.name == name)
            {
                return &mod;
            }
        }

        return nullptr;
    }

    const char* find_name(const uint64_t address)
    {
        const auto* mod = this->find_by_address(address);
        if (!mod)
        {
            return "<N/A>";
        }

        return mod->name.c_str();
    }

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);

    bool unmap(uint64_t address);
    const module_map& modules() const
    {
        return modules_;
    }

    // Execution mode accessors
    execution_mode get_execution_mode() const
    {
        return current_execution_mode_;
    }
    bool is_wow64_process() const
    {
        return current_execution_mode_ == execution_mode::wow64_32bit;
    }

    // TODO: These should be properly encapsulated. A good mechanism for quick module access is needed.
    mapped_module* executable{};
    mapped_module* ntdll{};
    mapped_module* win32u{};
    std::map<std::filesystem::path, uint64_t> modules_load_count;

    // WOW64-specific modules (for validation and future use)
    struct wow64_modules
    {
        mapped_module* ntdll32 = nullptr;      // 32-bit ntdll.dll
        mapped_module* wow64_dll = nullptr;    // wow64.dll (loaded by system)
        mapped_module* wow64win_dll = nullptr; // wow64win.dll (loaded by system)
        // Note: wow64cpu.dll is loaded by ntdll via registry lookup, not managed here
    } wow64_modules_;

  private:
    memory_manager* memory_{};
    file_system* file_sys_{};
    callbacks* callbacks_{};

    module_map modules_{};
    mutable module_map::iterator last_module_cache_{modules_.end()};

    mapping_strategy_factory strategy_factory_;
    execution_mode current_execution_mode_ = execution_mode::unknown;

    mapped_module* map_module_core(const pe_detection_result& detection_result, const std::function<mapped_module()>& mapper,
                                   const logger& logger, bool is_static);

    execution_mode detect_execution_mode(const windows_path& executable_path, const logger& logger);

    void load_native_64bit_modules(const windows_path& executable_path, const windows_path& ntdll_path, const windows_path& win32u_path,
                                   const logger& logger);
    void load_wow64_modules(const windows_path& executable_path, const windows_path& ntdll_path, const windows_path& win32u_path,
                            const windows_path& ntdll32_path, windows_version_manager& version, const logger& logger);

    void install_wow64_heaven_gate(const logger& logger);

    module_map::iterator get_module(const uint64_t address)
    {
        if (last_module_cache_ != this->modules_.end() && last_module_cache_->second.contains(address))
        {
            return last_module_cache_;
        }

        if (this->modules_.empty())
        {
            return this->modules_.end();
        }

        auto upper_bound = this->modules_.upper_bound(address);
        if (upper_bound == this->modules_.begin())
        {
            return this->modules_.end();
        }

        std::advance(upper_bound, -1);

        if (upper_bound->second.contains(address))
        {
            last_module_cache_ = upper_bound;
            return upper_bound;
        }

        return this->modules_.end();
    }
};

```

`src/windows-emulator/module/module_mapping.cpp`:

```cpp
#include "../std_include.hpp"
#include "module_mapping.hpp"
#include <address_utils.hpp>

#include <utils/io.hpp>
#include <utils/buffer_accessor.hpp>
#include <utils/string.hpp>
#include <platform/win_pefile.hpp>

#if defined(__clang__) || defined(__GNUC__)
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

namespace
{
    bool must_map_module_below_4gb(const std::string& module_name, const PEMachineType machine, const uint64_t image_base)
    {
        if (machine != PEMachineType::AMD64)
        {
            return false;
        }

        // wow64 startup needs wow64cpu.dll to be reachable through 32-bit address
        if (!utils::string::equals_ignore_case(std::string_view{module_name}, std::string_view{"wow64cpu.dll"}))
        {
            return false;
        }

        return image_base > std::numeric_limits<uint32_t>::max();
    }

    template <typename T>
    std::vector<std::byte> read_mapped_memory(const memory_manager& memory, const mapped_module& binary)
    {
        std::vector<std::byte> mem{};
        mem.resize(static_cast<size_t>(binary.size_of_image));
        memory.read_memory(binary.image_base, mem.data(), mem.size());

        return mem;
    }

    template <typename T>
    void collect_imports(mapped_module& binary, const utils::safe_buffer_accessor<const std::byte> buffer,
                         const PEOptionalHeader_t<T>& optional_header)
    {
        const auto& import_directory_entry = optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
        if (import_directory_entry.VirtualAddress == 0 || import_directory_entry.Size == 0)
        {
            return;
        }

        const auto import_descriptors = buffer.as<IMAGE_IMPORT_DESCRIPTOR>(import_directory_entry.VirtualAddress);

        for (size_t i = 0;; ++i)
        {
            const auto descriptor = import_descriptors.get(i);
            if (!descriptor.Name)
            {
                break;
            }

            // Use architecture-specific thunk data type
            using thunk_traits = thunk_data_traits<T>;
            using thunk_type = typename thunk_traits::type;

            const auto module_index = binary.imported_modules.size();
            binary.imported_modules.push_back(buffer.as_string(descriptor.Name));

            auto original_thunk_data = buffer.as<thunk_type>(descriptor.FirstThunk);
            if (descriptor.OriginalFirstThunk)
            {
                original_thunk_data = buffer.as<thunk_type>(descriptor.OriginalFirstThunk);
            }

            for (size_t j = 0;; ++j)
            {
                const auto original_thunk = original_thunk_data.get(j);
                if (!original_thunk.u1.AddressOfData)
                {
                    break;
                }

                static_assert(sizeof(thunk_type) == sizeof(T));
                const auto thunk_rva = descriptor.FirstThunk + sizeof(thunk_type) * j;
                const auto thunk_address = thunk_rva + binary.image_base;

                auto& sym = binary.imports[thunk_address];
                sym.module_index = module_index;

                // Use architecture-specific ordinal checking
                if (thunk_traits::snap_by_ordinal(original_thunk.u1.Ordinal))
                {
                    sym.name = "#" + std::to_string(thunk_traits::ordinal_mask(original_thunk.u1.Ordinal));
                }
                else
                {
                    sym.name =
                        buffer.as_string(static_cast<size_t>(original_thunk.u1.AddressOfData + offsetof(IMAGE_IMPORT_BY_NAME, Name)));
                }
            }
        }
    }

    template <typename T>
    void collect_exports(mapped_module& binary, const utils::safe_buffer_accessor<const std::byte> buffer,
                         const PEOptionalHeader_t<T>& optional_header)
    {
        const auto& export_directory_entry = optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
        if (export_directory_entry.VirtualAddress == 0 || export_directory_entry.Size == 0)
        {
            return;
        }

        const auto export_directory = buffer.as<IMAGE_EXPORT_DIRECTORY>(export_directory_entry.VirtualAddress).get();

        const auto names_count = export_directory.NumberOfNames;
        // const auto function_count = export_directory.NumberOfFunctions;

        const auto names = buffer.as<DWORD>(export_directory.AddressOfNames);
        const auto ordinals = buffer.as<WORD>(export_directory.AddressOfNameOrdinals);
        const auto functions = buffer.as<DWORD>(export_directory.AddressOfFunctions);

        binary.exports.reserve(names_count);

        for (DWORD i = 0; i < names_count; i++)
        {
            const auto ordinal = ordinals.get(i);

            exported_symbol symbol{};
            symbol.ordinal = export_directory.Base + ordinal;
            symbol.rva = functions.get(ordinal);
            symbol.address = binary.image_base + symbol.rva;
            symbol.name = buffer.as_string(names.get(i));

            binary.exports.push_back(std::move(symbol));
        }

        for (const auto& symbol : binary.exports)
        {
            binary.address_names.try_emplace(symbol.address, symbol.name);
        }
    }

    template <typename T>
        requires(std::is_integral_v<T>)
    void apply_relocation(const utils::safe_buffer_accessor<std::byte> buffer, const uint64_t offset, const uint64_t delta)
    {
        const auto obj = buffer.as<T>(static_cast<size_t>(offset));
        const auto value = obj.get();
        const auto new_value = value + static_cast<T>(delta);
        obj.set(new_value);
    }

    template <typename T>
    void apply_relocations(const mapped_module& binary, const utils::safe_buffer_accessor<std::byte> buffer,
                           const PEOptionalHeader_t<T>& optional_header)
    {
        const auto delta = binary.image_base - optional_header.ImageBase;
        if (delta == 0)
        {
            return;
        }

        const auto* directory = &optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
        if (directory->Size == 0)
        {
            return;
        }

        auto relocation_offset = directory->VirtualAddress;
        const auto relocation_end = relocation_offset + directory->Size;

        while (relocation_offset < relocation_end)
        {
            const auto relocation = buffer.as<IMAGE_BASE_RELOCATION>(relocation_offset).get();

            if (relocation.VirtualAddress <= 0 || relocation.SizeOfBlock <= sizeof(IMAGE_BASE_RELOCATION))
            {
                break;
            }

            const auto data_size = relocation.SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION);
            const auto entry_count = data_size / sizeof(uint16_t);

            const auto entries = buffer.as<uint16_t>(relocation_offset + sizeof(IMAGE_BASE_RELOCATION));

            relocation_offset += relocation.SizeOfBlock;

            for (size_t i = 0; i < entry_count; ++i)
            {
                const auto entry = entries.get(i);

                const int type = entry >> 12;
                const auto offset = static_cast<uint16_t>(entry & 0xfff);
                const auto total_offset = relocation.VirtualAddress + offset;

                switch (type)
                {
                case IMAGE_REL_BASED_ABSOLUTE:
                    break;

                case IMAGE_REL_BASED_HIGHLOW:
                    apply_relocation<DWORD>(buffer, total_offset, delta);
                    break;

                case IMAGE_REL_BASED_DIR64:
                    apply_relocation<ULONGLONG>(buffer, total_offset, delta);
                    break;

                default:
                    throw std::runtime_error("Unknown relocation type: " + std::to_string(type));
                }
            }
        }
    }

    template <typename T>
    void map_sections(memory_manager& memory, mapped_module& binary, const utils::safe_buffer_accessor<const std::byte> buffer,
                      const PENTHeaders_t<T>& nt_headers, const uint64_t nt_headers_offset)
    {
        const auto first_section_offset = winpe::get_first_section_offset(nt_headers, nt_headers_offset);
        const auto sections = buffer.as<IMAGE_SECTION_HEADER>(static_cast<size_t>(first_section_offset));

        for (size_t i = 0; i < nt_headers.FileHeader.NumberOfSections; ++i)
        {
            const auto section = sections.get(i);
            const auto target_ptr = binary.image_base + section.VirtualAddress;

            if (section.SizeOfRawData > 0)
            {
                const auto size_of_data = std::min(section.SizeOfRawData, section.Misc.VirtualSize);
                const auto* source_ptr = buffer.get_pointer_for_range(section.PointerToRawData, size_of_data);
                memory.write_memory(target_ptr, source_ptr, size_of_data);
            }

            auto permissions = memory_permission::none;

            if (section.Characteristics & IMAGE_SCN_MEM_EXECUTE)
            {
                permissions |= memory_permission::exec;
            }

            if (section.Characteristics & IMAGE_SCN_MEM_READ)
            {
                permissions |= memory_permission::read;
            }

            if (section.Characteristics & IMAGE_SCN_MEM_WRITE)
            {
                permissions |= memory_permission::write;
            }

            const auto size_of_section = page_align_up(std::max(section.SizeOfRawData, section.Misc.VirtualSize));

            memory.protect_memory(target_ptr, static_cast<size_t>(size_of_section), permissions, nullptr);

            mapped_section section_info{};
            section_info.region.start = target_ptr;
            section_info.region.length = static_cast<size_t>(size_of_section);
            section_info.region.permissions = permissions;

            for (size_t j = 0; j < sizeof(section.Name) && section.Name[j]; ++j)
            {
                section_info.name.push_back(static_cast<char>(section.Name[j]));
            }

            binary.sections.push_back(std::move(section_info));
        }
    }
}

template <typename T>
mapped_module map_module_from_data(memory_manager& memory, const std::span<const std::byte> data, std::filesystem::path file,
                                   windows_path module_path)
{
    mapped_module binary{};
    binary.path = std::move(file);
    binary.name = u16_to_u8(module_path.leaf());
    binary.module_path = std::move(module_path);

    utils::safe_buffer_accessor buffer{data};

    const auto dos_header = buffer.as<PEDosHeader_t>(0).get();
    const auto nt_headers_offset = dos_header.e_lfanew;

    const auto nt_headers = buffer.as<PENTHeaders_t<T>>(nt_headers_offset).get();
    const auto& optional_header = nt_headers.OptionalHeader;

    if (nt_headers.FileHeader.Machine != PEMachineType::I386 && nt_headers.FileHeader.Machine != PEMachineType::AMD64)
    {
        throw std::runtime_error("Unsupported architecture!");
    }

    binary.image_base = optional_header.ImageBase;
    binary.image_base_file = optional_header.ImageBase;
    binary.size_of_image = page_align_up(optional_header.SizeOfImage); // TODO: Sanitize

    const bool force_wow64cpu_32bit_va = must_map_module_below_4gb(binary.name, nt_headers.FileHeader.Machine, binary.image_base);

    if (force_wow64cpu_32bit_va)
    {
        binary.image_base = memory.find_free_allocation_base(static_cast<size_t>(binary.size_of_image), DEFAULT_ALLOCATION_ADDRESS_32BIT);
    }

    // Store PE header fields
    binary.machine = static_cast<uint16_t>(nt_headers.FileHeader.Machine);
    binary.size_of_stack_reserve = optional_header.SizeOfStackReserve;
    binary.size_of_stack_commit = optional_header.SizeOfStackCommit;
    binary.size_of_heap_reserve = optional_header.SizeOfHeapReserve;
    binary.size_of_heap_commit = optional_header.SizeOfHeapCommit;

    if (!memory.allocate_memory(binary.image_base, static_cast<size_t>(binary.size_of_image), memory_permission::all))
    {
        // Check if this is a 32-bit module (WOW64)
        const bool is_32bit = (nt_headers.FileHeader.Machine == PEMachineType::I386);

        if (force_wow64cpu_32bit_va)
        {
            binary.image_base =
                memory.find_free_allocation_base(static_cast<size_t>(binary.size_of_image), DEFAULT_ALLOCATION_ADDRESS_32BIT);
        }
        else if (is_32bit)
        {
            // Use 32-bit allocation for WOW64 modules
            binary.image_base =
                memory.find_free_allocation_base(static_cast<size_t>(binary.size_of_image), DEFAULT_ALLOCATION_ADDRESS_32BIT);
        }
        else
        {
            // Use 64-bit allocation for native modules
            binary.image_base =
                memory.find_free_allocation_base(static_cast<size_t>(binary.size_of_image), DEFAULT_ALLOCATION_ADDRESS_64BIT);
        }

        const auto is_dll = nt_headers.FileHeader.Characteristics & IMAGE_FILE_DLL;
        const auto has_dynamic_base = optional_header.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;
        const auto is_relocatable = is_dll || has_dynamic_base;

        if (!is_relocatable ||
            !memory.allocate_memory(binary.image_base, static_cast<size_t>(binary.size_of_image), memory_permission::all))
        {
            throw std::runtime_error("Memory range not allocatable");
        }
    }

    // TODO: Make sure to match kernel allocation patterns to attain correct initial permissions!
    memory.protect_memory(binary.image_base, static_cast<size_t>(binary.size_of_image), memory_permission::read);

    binary.entry_point = binary.image_base + optional_header.AddressOfEntryPoint;

    const auto* header_buffer = buffer.get_pointer_for_range(0, optional_header.SizeOfHeaders);
    memory.write_memory(binary.image_base, header_buffer, optional_header.SizeOfHeaders);

    const auto image_base = static_cast<T>(binary.image_base);
    const auto image_base_address =
        binary.image_base + nt_headers_offset + offsetof(PENTHeaders_t<T>, OptionalHeader) + offsetof(PEOptionalHeader_t<T>, ImageBase);
    memory.write_memory(image_base_address, &image_base, sizeof(image_base));

    map_sections(memory, binary, buffer, nt_headers, nt_headers_offset);

    auto mapped_memory = read_mapped_memory<T>(memory, binary);
    utils::safe_buffer_accessor<std::byte> mapped_buffer{mapped_memory};

    apply_relocations(binary, mapped_buffer, optional_header);
    collect_exports(binary, mapped_buffer, optional_header);
    collect_imports(binary, mapped_buffer, optional_header);

    memory.write_memory(binary.image_base, mapped_memory.data(), mapped_memory.size());

    return binary;
}

template <typename T>
mapped_module map_module_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path)
{
    const auto data = utils::io::read_file(file);
    if (data.empty())
    {
        throw std::runtime_error("Bad file data: " + file.string());
    }

    return map_module_from_data<T>(memory, data, std::move(file), std::move(module_path));
}

template <typename T>
mapped_module map_module_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size, windows_path module_path)
{
    mapped_module binary{};
    binary.name = u16_to_u8(module_path.leaf());
    binary.path = module_path.to_portable_path();
    binary.module_path = std::move(module_path);
    binary.image_base = base_address;
    binary.image_base_file = base_address;
    binary.size_of_image = image_size;

    auto mapped_memory = read_mapped_memory<T>(memory, binary);
    utils::safe_buffer_accessor<const std::byte> buffer{mapped_memory};

    try
    {
        const auto dos_header = buffer.as<PEDosHeader_t>(0).get();
        const auto nt_headers_offset = dos_header.e_lfanew;
        const auto nt_headers = buffer.as<PENTHeaders_t<std::uint64_t>>(nt_headers_offset).get();
        const auto& optional_header = nt_headers.OptionalHeader;

        binary.entry_point = binary.image_base + optional_header.AddressOfEntryPoint;

        // Store PE header fields
        binary.machine = static_cast<uint16_t>(nt_headers.FileHeader.Machine);
        binary.size_of_stack_reserve = optional_header.SizeOfStackReserve;
        binary.size_of_stack_commit = optional_header.SizeOfStackCommit;
        binary.size_of_heap_reserve = optional_header.SizeOfHeapReserve;
        binary.size_of_heap_commit = optional_header.SizeOfHeapCommit;

        const auto section_offset = winpe::get_first_section_offset(nt_headers, nt_headers_offset);
        const auto sections = buffer.as<IMAGE_SECTION_HEADER>(static_cast<size_t>(section_offset));

        for (size_t i = 0; i < nt_headers.FileHeader.NumberOfSections; ++i)
        {
            const auto section = sections.get(i);

            mapped_section section_info{};
            section_info.region.start = binary.image_base + section.VirtualAddress;
            section_info.region.length = static_cast<size_t>(page_align_up(std::max(section.SizeOfRawData, section.Misc.VirtualSize)));

            auto permissions = memory_permission::none;
            if (section.Characteristics & IMAGE_SCN_MEM_EXECUTE)
            {
                permissions |= memory_permission::exec;
            }
            if (section.Characteristics & IMAGE_SCN_MEM_READ)
            {
                permissions |= memory_permission::read;
            }
            if (section.Characteristics & IMAGE_SCN_MEM_WRITE)
            {
                permissions |= memory_permission::write;
            }

            section_info.region.permissions = permissions;

            for (size_t j = 0; j < sizeof(section.Name) && section.Name[j]; ++j)
            {
                section_info.name.push_back(static_cast<char>(section.Name[j]));
            }

            binary.sections.push_back(std::move(section_info));
        }

        collect_exports(binary, buffer, optional_header);
    }
    catch (const std::exception&)
    {
        // bad!
        throw std::runtime_error("Failed to map module from memory at " + std::to_string(base_address) + " with size " +
                                 std::to_string(image_size) + " for module " + binary.name);
    }

    return binary;
}

bool unmap_module(memory_manager& memory, const mapped_module& mod)
{
    return memory.release_memory(mod.image_base, static_cast<size_t>(mod.size_of_image));
}

template mapped_module map_module_from_data<std::uint32_t>(memory_manager& memory, const std::span<const std::byte> data,
                                                           std::filesystem::path file, windows_path module_path);
template mapped_module map_module_from_data<std::uint64_t>(memory_manager& memory, const std::span<const std::byte> data,
                                                           std::filesystem::path file, windows_path module_path);
template mapped_module map_module_from_file<std::uint32_t>(memory_manager& memory, std::filesystem::path file, windows_path module_path);
template mapped_module map_module_from_file<std::uint64_t>(memory_manager& memory, std::filesystem::path file, windows_path module_path);

template mapped_module map_module_from_memory<std::uint32_t>(memory_manager& memory, uint64_t base_address, uint64_t image_size,
                                                             windows_path module_path);
template mapped_module map_module_from_memory<std::uint64_t>(memory_manager& memory, uint64_t base_address, uint64_t image_size,
                                                             windows_path module_path);

```

`src/windows-emulator/module/module_mapping.hpp`:

```hpp
#pragma once

#include "mapped_module.hpp"
#include "../memory_manager.hpp"

mapped_module map_module_from_data(memory_manager& memory, std::span<const uint8_t> data, std::filesystem::path file,
                                   windows_path module_path);
template <typename T>
mapped_module map_module_from_file(memory_manager& memory, std::filesystem::path file, windows_path module_path);
template <typename T>
mapped_module map_module_from_memory(memory_manager& memory, uint64_t base_address, uint64_t image_size, windows_path module_path);

bool unmap_module(memory_manager& memory, const mapped_module& mod);

```

`src/windows-emulator/network/i_socket.hpp`:

```hpp
#pragma once

#include <span>
#include <network/socket.hpp>

namespace network
{
    struct i_socket
    {
        virtual ~i_socket() = default;

        virtual void set_blocking(bool blocking) = 0;

        virtual int get_last_error() = 0;

        virtual bool is_ready(bool in_poll) = 0;
        virtual bool is_listening() = 0;

        virtual std::optional<address> get_local_address() = 0;

        virtual bool bind(const address& addr) = 0;
        virtual bool connect(const address& addr) = 0;
        virtual bool listen(int backlog) = 0;
        virtual std::unique_ptr<i_socket> accept(address& address) = 0;

        virtual sent_size send(std::span<const std::byte> data) = 0;
        virtual sent_size sendto(const address& destination, std::span<const std::byte> data) = 0;

        virtual sent_size recv(std::span<std::byte> data) = 0;
        virtual sent_size recvfrom(address& source, std::span<std::byte> data) = 0;
    };
}

```

`src/windows-emulator/network/socket_factory.cpp`:

```cpp
#include "socket_factory.hpp"
#include "socket_wrapper.hpp"

namespace network
{
    socket_factory::socket_factory()
    {
        initialize_wsa();
    }

    std::unique_ptr<i_socket> socket_factory::create_socket(int af, int type, int protocol)
    {
        return std::make_unique<socket_wrapper>(af, type, protocol);
    }

    int socket_factory::poll_sockets(const std::span<poll_entry> entries)
    {
        std::vector<pollfd> poll_data{};
        poll_data.reserve(entries.size());

        for (const auto& entry : entries)
        {
            if (!entry.s)
            {
                throw std::runtime_error("Bad socket given!");
            }

            const auto* wrapper = dynamic_cast<socket_wrapper*>(entry.s);
            if (!wrapper)
            {
                throw std::runtime_error("Socket was not created using the given factory");
            }

            pollfd fd{};
            fd.fd = wrapper->get().get_socket();
            fd.events = entry.events;
            fd.revents = entry.revents;

            poll_data.push_back(fd);
        }

        const auto res = poll(poll_data.data(), static_cast<uint32_t>(poll_data.size()), 0);

        for (size_t i = 0; i < poll_data.size() && i < entries.size(); ++i)
        {
            auto& entry = entries[i];
            const auto& fd = poll_data[i];

            entry.events = fd.events;
            entry.revents = fd.revents;
        }

        return res;
    }
}

```

`src/windows-emulator/network/socket_factory.hpp`:

```hpp
#pragma once

#include "i_socket.hpp"

#include <memory>

namespace network
{
    struct poll_entry
    {
        i_socket* s{};
        int16_t events{};
        int16_t revents{};
    };

    struct socket_factory
    {
        socket_factory();
        virtual ~socket_factory() = default;

        virtual std::unique_ptr<i_socket> create_socket(int af, int type, int protocol);
        virtual int poll_sockets(std::span<poll_entry> entries);
    };
}

```

`src/windows-emulator/network/socket_wrapper.cpp`:

```cpp
#include "socket_wrapper.hpp"
#include <cassert>

namespace network
{
    socket_wrapper::socket_wrapper(SOCKET s)
        : socket_(s)
    {
    }

    socket_wrapper::socket_wrapper(const int af, const int type, const int protocol)
        : socket_(af, type, protocol)
    {
    }

    void socket_wrapper::set_blocking(const bool blocking)
    {
        this->socket_.set_blocking(blocking);
    }

    int socket_wrapper::get_last_error()
    {
        return GET_SOCKET_ERROR();
    }

    bool socket_wrapper::is_ready(const bool in_poll)
    {
        return this->socket_.is_ready(in_poll);
    }

    bool socket_wrapper::is_listening()
    {
        if (!this->socket_.is_valid())
        {
            return false;
        }

        int val{};
        socklen_t len = sizeof(val);
        const auto res = getsockopt(this->socket_.get_socket(), SOL_SOCKET, SO_ACCEPTCONN, reinterpret_cast<char*>(&val), &len);

        return res != SOCKET_ERROR && val == 1;
    }

    std::optional<address> socket_wrapper::get_local_address()
    {
        sockaddr_storage addr{};
        socklen_t addrlen = sizeof(sockaddr_storage);
        const auto res = ::getsockname(this->socket_.get_socket(), reinterpret_cast<sockaddr*>(&addr), &addrlen);

        if (res != 0)
        {
            return {};
        }

        address address{};
        address.set_address(reinterpret_cast<sockaddr*>(&addr), addrlen);
        return address;
    }

    bool socket_wrapper::bind(const address& addr)
    {
        return this->socket_.bind(addr);
    }

    bool socket_wrapper::connect(const address& addr)
    {
        return ::connect(this->socket_.get_socket(), &addr.get_addr(), addr.get_size()) == 0;
    }

    bool socket_wrapper::listen(int backlog)
    {
        return ::listen(this->socket_.get_socket(), backlog) == 0;
    }

    std::unique_ptr<i_socket> socket_wrapper::accept(address& address)
    {
        sockaddr addr{};
        socklen_t addrlen = sizeof(sockaddr);
        const auto s = ::accept(this->socket_.get_socket(), &addr, &addrlen);

        if (s == INVALID_SOCKET)
        {
            return nullptr;
        }

        address.set_address(&addr, addrlen);

        return std::make_unique<socket_wrapper>(s);
    }

    sent_size socket_wrapper::send(const std::span<const std::byte> data)
    {
        return ::send(this->socket_.get_socket(), reinterpret_cast<const char*>(data.data()), static_cast<send_size>(data.size()), 0);
    }

    sent_size socket_wrapper::sendto(const address& destination, const std::span<const std::byte> data)
    {
        return ::sendto(this->socket_.get_socket(), reinterpret_cast<const char*>(data.data()), static_cast<send_size>(data.size()), 0,
                        &destination.get_addr(), destination.get_size());
    }

    sent_size socket_wrapper::recv(std::span<std::byte> data)
    {
        return ::recv(this->socket_.get_socket(), reinterpret_cast<char*>(data.data()), static_cast<send_size>(data.size()), 0);
    }

    sent_size socket_wrapper::recvfrom(address& source, std::span<std::byte> data)
    {
        auto source_length = source.get_max_size();
        const auto res = ::recvfrom(this->socket_.get_socket(), reinterpret_cast<char*>(data.data()), static_cast<send_size>(data.size()),
                                    0, &source.get_addr(), &source_length);

        assert(res < 0 || source.get_size() == source_length);

        return res;
    }
}

```

`src/windows-emulator/network/socket_wrapper.hpp`:

```hpp
#pragma once

#include "i_socket.hpp"

namespace network
{
    class socket_wrapper : public i_socket
    {
      public:
        socket_wrapper(SOCKET s);
        socket_wrapper(int af, int type, int protocol);
        ~socket_wrapper() override = default;

        void set_blocking(bool blocking) override;

        int get_last_error() override;

        bool is_ready(bool in_poll) override;
        bool is_listening() override;

        std::optional<address> get_local_address() override;

        bool bind(const address& addr) override;
        bool connect(const address& addr) override;
        bool listen(int backlog) override;
        std::unique_ptr<i_socket> accept(address& address) override;

        sent_size send(std::span<const std::byte> data) override;
        sent_size sendto(const address& destination, std::span<const std::byte> data) override;

        sent_size recv(std::span<std::byte> data) override;
        sent_size recvfrom(address& source, std::span<std::byte> data) override;

        const socket& get() const
        {
            return this->socket_;
        }

      private:
        socket socket_{};
    };
}

```

`src/windows-emulator/network/static_socket_factory.cpp`:

```cpp
#include "static_socket_factory.hpp"

#include <queue>
#include <stdexcept>
#include <unordered_map>

#include <network/socket.hpp>

namespace network
{
    namespace
    {
        struct static_socket_factory : socket_factory
        {
            using packet_data = std::vector<std::byte>;
            using packet = std::pair<address, packet_data>;
            using packet_queue = std::queue<packet>;
            using packet_mapping = std::unordered_map<address, packet_queue>;
            std::shared_ptr<packet_mapping> packets = std::make_shared<packet_mapping>();

            uint16_t port{0};

            struct static_socket : i_socket
            {
                int error{0};
                address a{};
                std::shared_ptr<packet_mapping> packets{};

                static_socket(static_socket_factory& f, const int af)
                    : packets(f.packets)
                {
                    if (af == AF_INET)
                    {
                        a.set_ipv4(0);
                    }
                    else if (af == AF_INET6)
                    {
                        a.set_ipv6({});
                    }
                    else
                    {
                        throw std::runtime_error("Invalid address family");
                    }

                    a.set_port(++f.port);
                }

                ~static_socket() override = default;

                void set_blocking(const bool blocking) override
                {
                    if (blocking)
                    {
                        throw std::runtime_error("Blocking sockets not supported yet!");
                    }
                }

                int get_last_error() override
                {
                    return this->error;
                }

                bool is_ready(const bool) override
                {
                    return true;
                }

                bool is_listening() override
                {
                    return false;
                }

                std::optional<address> get_local_address() override
                {
                    return this->a;
                }

                bool bind(const address& addr) override
                {
                    this->a = addr;
                    return true;
                }

                bool connect(const address& addr) override
                {
                    this->a = addr;
                    return true;
                }

                bool listen(int) override
                {
                    throw std::runtime_error("Not implemented");
                }

                std::unique_ptr<i_socket> accept(address&) override
                {
                    throw std::runtime_error("Not implemented");
                }

                sent_size send(std::span<const std::byte>) override
                {
                    throw std::runtime_error("Not implemented");
                }

                sent_size sendto(const address& destination, std::span<const std::byte> data) override
                {
                    this->error = 0;
                    (*this->packets)[destination].emplace(this->a, packet_data{data.begin(), data.end()});
                    return static_cast<int>(data.size());
                }

                sent_size recv(std::span<std::byte>) override
                {
                    throw std::runtime_error("Not implemented");
                }

                sent_size recvfrom(address& source, std::span<std::byte> data) override
                {
                    this->error = 0;

                    auto& q = (*this->packets)[this->a];

                    if (q.empty())
                    {
                        this->error = SERR(EWOULDBLOCK);
                        return -1;
                    }

                    const auto p = std::move(q.front());
                    q.pop();

                    memcpy(data.data(), p.second.data(), std::min(data.size(), p.second.size()));

                    source = p.first;
                    return static_cast<int>(p.second.size());
                }
            };

            std::unique_ptr<i_socket> create_socket(const int af, const int, const int) override
            {
                return std::make_unique<static_socket>(*this, af);
            }

            int poll_sockets(std::span<poll_entry>) override
            {
                throw std::runtime_error("Not implemented");
            }
        };
    }

    std::unique_ptr<socket_factory> create_static_socket_factory()
    {
        return std::make_unique<static_socket_factory>();
    }
}

```

`src/windows-emulator/network/static_socket_factory.hpp`:

```hpp
#pragma once

#include "socket_factory.hpp"

namespace network
{
    std::unique_ptr<socket_factory> create_static_socket_factory();
}

```

`src/windows-emulator/port.cpp`:

```cpp
#include "std_include.hpp"
#include "port.hpp"
#include "logger.hpp"
#include "windows_emulator.hpp"
#include "ports/api_port.hpp"
#include "ports/dns_resolver.hpp"
#include "ports/lsa_policy_lookup.hpp"

namespace
{
    struct dummy_port : port
    {
        NTSTATUS handle_request(windows_emulator& win_emu, const lpc_request_context&) override
        {
            win_emu.log.error("!!! BAD PORT\n");
            return STATUS_NOT_SUPPORTED;
        }
    };

    struct noop_port : port
    {
        NTSTATUS handle_request(windows_emulator& /*win_emu*/, const lpc_request_context& c) override
        {
            c.recv_buffer_length = 0;
            return STATUS_SUCCESS;
        }
    };
}

std::unique_ptr<port> create_port(const std::u16string_view port)
{
    if (port == u"\\Windows\\ApiPort")
    {
        return create_api_port();
    }

    if (port == u"\\RPC Control\\DNSResolver")
    {
        return create_dns_resolver();
    }

    if (port == u"\\RPC Control\\LSARPC_ENDPOINT" || port == u"\\RPC Control\\lsapolicylookup")
    {
        return create_lsa_policy_lookup_port();
    }

    if (port == u"\\WindowsErrorReportingServicePort")
    {
        return std::make_unique<noop_port>();
    }

    return std::make_unique<dummy_port>();
}

NTSTATUS port::handle_message(windows_emulator& win_emu, const lpc_message_context& c)
{
    const auto send_header = c.send_message.read();

    auto recv_header = send_header;
    recv_header.u2.s2.Type = LPC_REPLY;

    if (send_header.u2.s2.Type == LPC_NO_IMPERSONATE)
    {
        recv_header.u2.s2.Type |= LPC_NO_IMPERSONATE;
    }

    lpc_request_context context{};
    context.send_buffer = c.send_message.value() + sizeof(PORT_MESSAGE64);
    context.send_buffer_length = send_header.u1.s1.DataLength;
    context.recv_buffer = c.receive_message.value() + sizeof(PORT_MESSAGE64);
    context.recv_buffer_length = recv_header.u1.s1.DataLength;

    NTSTATUS status = this->handle_request(win_emu, context);

    recv_header.u1.s1.DataLength = static_cast<CSHORT>(context.recv_buffer_length);
    recv_header.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(PORT_MESSAGE64) + context.recv_buffer_length);
    c.receive_message.write(recv_header);

    return status;
}

NTSTATUS rpc_port::handle_request(windows_emulator& win_emu, const lpc_request_context& c)
{
    constexpr ULONG rpc_op_size = sizeof(uint32_t);
    if (c.send_buffer_length < rpc_op_size)
    {
        return STATUS_INVALID_PARAMETER;
    }

    const auto operation = win_emu.emu().read_memory<uint32_t>(c.send_buffer);

    switch (operation)
    {
    case 1: // Handshake
        return handle_handshake(win_emu, c);
    case 0: // Call
        return handle_rpc_call(win_emu, c);
    default:
        win_emu.log.print(color::gray, "Unexpected RPC operation: 0x%X\n", operation);
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS rpc_port::handle_handshake(windows_emulator& win_emu, const lpc_request_context& c)
{
    constexpr ULONG rpc_handshake_state_offset = 32;
    constexpr ULONG required_handshake_read_bytes = rpc_handshake_state_offset + sizeof(uint32_t);
    constexpr ULONG required_handshake_reply_status_bytes = 8 + sizeof(uint32_t);

    if (c.send_buffer_length < required_handshake_read_bytes)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (c.recv_buffer_length < required_handshake_reply_status_bytes)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    win_emu.emu().write_memory<uint32_t>(c.recv_buffer + 8, 0);

    if (win_emu.emu().read_memory<uint32_t>(c.send_buffer + rpc_handshake_state_offset) == 3)
    {
        if (c.recv_buffer_length < required_handshake_read_bytes)
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        win_emu.emu().write_memory<uint32_t>(c.recv_buffer + rpc_handshake_state_offset, 2);
    }

    return STATUS_SUCCESS;
}

NTSTATUS rpc_port::handle_rpc_call(windows_emulator& win_emu, const lpc_request_context& c)
{
    constexpr ULONG rpc_call_header_size = 0x40;
    constexpr ULONG rpc_call_proc_id_offset = 12;

    if (c.send_buffer_length < rpc_call_header_size)
    {
        return STATUS_INVALID_PARAMETER;
    }

    constexpr auto rpc_header_size = static_cast<ULONG>(sizeof(std::array<uint8_t, 24>));
    if (c.recv_buffer_length < rpc_header_size)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    const auto procedure_id = win_emu.emu().read_memory<uint8_t>(c.send_buffer + rpc_call_proc_id_offset);

    std::array<uint8_t, 24> header = {0x03,         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                      procedure_id, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    win_emu.emu().write_memory(c.recv_buffer, header);

    const auto max_payload_length = c.recv_buffer_length - rpc_header_size;

    lpc_request_context rpc_context{};
    rpc_context.send_buffer = c.send_buffer + rpc_call_header_size;
    rpc_context.send_buffer_length = c.send_buffer_length - rpc_call_header_size;
    rpc_context.recv_buffer = c.recv_buffer + sizeof(header);
    rpc_context.recv_buffer_length = max_payload_length;

    NTSTATUS status = this->handle_rpc(win_emu, procedure_id, rpc_context);
    if (rpc_context.recv_buffer_length > max_payload_length)
    {
        win_emu.log.warn("RPC reply payload too large: %u > %u\n", rpc_context.recv_buffer_length, max_payload_length);
        return STATUS_BUFFER_TOO_SMALL;
    }

    c.recv_buffer_length = rpc_header_size + rpc_context.recv_buffer_length;

    return status;
}

```

`src/windows-emulator/port.hpp`:

```hpp
#pragma once

#include <memory>
#include <arch_emulator.hpp>
#include <serialization.hpp>

#include "emulator_utils.hpp"
#include "handles.hpp"

class windows_emulator;
struct process_context;

struct lpc_message_context
{
    emulator_object<PORT_MESSAGE64> send_message;
    emulator_object<PORT_MESSAGE64> receive_message;

    lpc_message_context(x86_64_emulator& emu)
        : send_message(emu),
          receive_message(emu)
    {
    }

    lpc_message_context(utils::buffer_deserializer& buffer)
        : lpc_message_context(buffer.read<x64_emulator_wrapper>().get())
    {
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(send_message);
        buffer.write(receive_message);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(send_message);
        buffer.read(receive_message);
    }
};

struct lpc_request_context
{
    emulator_pointer send_buffer{};
    ULONG send_buffer_length{};
    emulator_pointer recv_buffer{};
    mutable ULONG recv_buffer_length{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(send_buffer);
        buffer.write(send_buffer_length);
        buffer.write(recv_buffer);
        buffer.write(recv_buffer_length);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(send_buffer);
        buffer.read(send_buffer_length);
        buffer.read(recv_buffer);
        buffer.read(recv_buffer_length);
    }
};

struct port_creation_data
{
    uint64_t view_base;
    int64_t view_size;
};

struct port : ref_counted_object
{
    uint64_t view_base{};
    int64_t view_size{};

    port() = default;
    ~port() override = default;

    port(port&&) = default;
    port& operator=(port&&) = default;

    port(const port&) = delete;
    port& operator=(const port&) = delete;

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->view_base);
        buffer.write(this->view_size);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->view_base);
        buffer.read(this->view_size);
    }

    virtual void create(windows_emulator& win_emu, const port_creation_data& data)
    {
        (void)win_emu;
        view_base = data.view_base;
        view_size = data.view_size;
    }

    NTSTATUS handle_message(windows_emulator& win_emu, const lpc_message_context& c);

    virtual NTSTATUS handle_request(windows_emulator& win_emu, const lpc_request_context& c) = 0;
};

struct rpc_port : port
{
    NTSTATUS handle_request(windows_emulator& win_emu, const lpc_request_context& c) override;

    virtual NTSTATUS handle_rpc(windows_emulator& win_emu, uint32_t procedure_id, const lpc_request_context& c) = 0;

  private:
    static NTSTATUS handle_handshake(windows_emulator& win_emu, const lpc_request_context& c);
    NTSTATUS handle_rpc_call(windows_emulator& win_emu, const lpc_request_context& c);
};

std::unique_ptr<port> create_port(std::u16string_view port);

class port_container : public port
{
  public:
    port_container() = default;

    port_container(std::u16string port, windows_emulator& win_emu, const port_creation_data& data)
        : port_name_(std::move(port))
    {
        this->setup();
        this->port_->create(win_emu, data);
    }

    NTSTATUS handle_request(windows_emulator& win_emu, const lpc_request_context& c) override
    {
        this->assert_validity();
        return this->port_->handle_request(win_emu, c);
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        this->assert_validity();

        buffer.write_string(this->port_name_);
        this->port_->serialize(buffer);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read_string(this->port_name_);
        this->setup();
        this->port_->deserialize(buffer);
    }

    template <typename T = port>
        requires(std::is_base_of_v<port, T> || std::is_same_v<port, T>)
    T* get_internal_port() const
    {
        this->assert_validity();
        auto* value = this->port_.get();
        return dynamic_cast<T*>(value);
    }

    std::u16string_view get_port_name() const
    {
        this->assert_validity();
        return this->port_name_;
    }

  private:
    std::u16string port_name_{};
    std::unique_ptr<port> port_{};

    void setup()
    {
        this->port_ = create_port(this->port_name_);
    }

    void assert_validity() const
    {
        if (!this->port_)
        {
            throw std::runtime_error("Port not created!");
        }
    }
};

```

`src/windows-emulator/ports/api_port.cpp`:

```cpp
#include "../std_include.hpp"
#include "api_port.hpp"

#include "../win32k_userconnect.hpp"
#include "../windows_emulator.hpp"

namespace
{
    bool is_user_server_dll_index(const uint64_t server_dll_index)
    {
        return server_dll_index <= std::numeric_limits<uint32_t>::max() &&
               static_cast<uint32_t>(server_dll_index) == win32k_userconnect::k_user_server_dll_index;
    }

    struct wow64_userconnect_payload
    {
        uint64_t request_capture_handle{};
        uint64_t request_reserved0{};
        uint64_t capture_buffer_ptr{};
        uint64_t server_dll_index{};
        uint64_t user_connect_ptr{};
        uint64_t user_connect_length{};
    };

    static_assert(sizeof(wow64_userconnect_payload) == 0x30);
    static_assert(offsetof(wow64_userconnect_payload, capture_buffer_ptr) == 0x10);
    static_assert(offsetof(wow64_userconnect_payload, server_dll_index) == 0x18);
    static_assert(offsetof(wow64_userconnect_payload, user_connect_ptr) == 0x20);
    static_assert(offsetof(wow64_userconnect_payload, user_connect_length) == 0x28);

    bool try_read_wow64_payload(windows_emulator& win_emu, const lpc_request_context& c, wow64_userconnect_payload& payload)
    {
        if (c.send_buffer_length < sizeof(payload))
        {
            return false;
        }

        if (!win_emu.memory.try_read_memory(c.send_buffer, &payload, sizeof(payload)))
        {
            return false;
        }

        if (!is_user_server_dll_index(payload.server_dll_index))
        {
            return false;
        }

        if (payload.user_connect_ptr == 0 || payload.user_connect_ptr > std::numeric_limits<uint32_t>::max())
        {
            return false;
        }

        if (payload.user_connect_length != sizeof(WIN32K_USERCONNECT32) &&
            payload.user_connect_length != (sizeof(WIN32K_USERCONNECT32) + win32k_userconnect::k_wow64_userconnect_header_size))
        {
            return false;
        }

        return true;
    }

    bool try_read_reply_server_dll_index(windows_emulator& win_emu, const lpc_request_context& c, uint32_t& server_dll_index)
    {
        server_dll_index = 0;
        return win_emu.memory.try_read_memory(c.recv_buffer + 0x18, &server_dll_index, sizeof(server_dll_index));
    }

    NTSTATUS try_write_wow64_userconnect_response(windows_emulator& win_emu, const wow64_userconnect_payload& payload)
    {
        uint32_t destination{};
        const auto destination_status =
            win32k_userconnect::resolve_wow64_destination(payload.user_connect_ptr, payload.user_connect_length, destination);
        if (destination_status != STATUS_SUCCESS)
        {
            return destination_status;
        }

        WIN32K_USERCONNECT32 connect{};
        const auto connect_status = win32k_userconnect::build_wow64_userconnect(win_emu.process, connect);
        if (connect_status != STATUS_SUCCESS)
        {
            return connect_status;
        }

        if (!win32k_userconnect::try_write_wow64_userconnect(win_emu.memory, destination, connect))
        {
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }

    struct api_port : port
    {
        static bool resolve_reply_base(windows_emulator& win_emu, const lpc_request_context& c, uint64_t& base)
        {
            base = 0;

            // CSRSS ApiPort connect reply has PORT_DATA_ENTRY @ +0x20.
            if (c.recv_buffer_length < (0x20 + sizeof(PORT_DATA_ENTRY<EmulatorTraits<Emu64>>)))
            {
                return false;
            }

            PORT_DATA_ENTRY<EmulatorTraits<Emu64>> direct_entry{};
            if (!win_emu.memory.try_read_memory(c.recv_buffer + 0x20, &direct_entry, sizeof(direct_entry)))
            {
                return false;
            }

            if (direct_entry.Base == 0)
            {
                return false;
            }

            base = direct_entry.Base;
            return true;
        }

        NTSTATUS handle_request(windows_emulator& win_emu, const lpc_request_context& c) override
        {
            wow64_userconnect_payload payload{};
            if (try_read_wow64_payload(win_emu, c, payload))
            {
                const auto status = try_write_wow64_userconnect_response(win_emu, payload);
                if (status != STATUS_SUCCESS)
                {
                    win_emu.log.warn("ApiPort WOW64 userconnect write failed: status=0x%X, ptr=0x%llX, len=0x%llX\n", status,
                                     static_cast<unsigned long long>(payload.user_connect_ptr),
                                     static_cast<unsigned long long>(payload.user_connect_length));
                    return status;
                }

                if (!win32k_userconnect::try_bootstrap_client_pfn_arrays_from_ntdll(win_emu))
                {
                    win_emu.log.warn("ApiPort userconnect callback-table bootstrap failed\n");
                }

                return STATUS_SUCCESS;
            }

            uint32_t server_dll_index{};
            if (!try_read_reply_server_dll_index(win_emu, c, server_dll_index) ||
                server_dll_index != win32k_userconnect::k_user_server_dll_index)
            {
                return STATUS_SUCCESS;
            }

            uint64_t base{};
            if (!resolve_reply_base(win_emu, c, base))
            {
                win_emu.log.warn("ApiPort userconnect reply base resolution failed\n");
                return STATUS_INVALID_PARAMETER;
            }

            if (!win32k_userconnect::try_write_api_port_userconnect_reply(win_emu.memory, base, win_emu.process))
            {
                win_emu.log.warn("ApiPort userconnect shared info write failed\n");
                return STATUS_INVALID_PARAMETER;
            }

            if (!win32k_userconnect::try_bootstrap_client_pfn_arrays_from_ntdll(win_emu))
            {
                win_emu.log.warn("ApiPort userconnect callback-table bootstrap failed\n");
            }

            return STATUS_SUCCESS;
        }
    };
}

std::unique_ptr<port> create_api_port()
{
    return std::make_unique<api_port>();
}

```

`src/windows-emulator/ports/api_port.hpp`:

```hpp
#pragma once
#include "../port.hpp"

std::unique_ptr<port> create_api_port();

```

`src/windows-emulator/ports/dns_resolver.cpp`:

```cpp
#include "../std_include.hpp"
#include "dns_resolver.hpp"

#include "binary_writer.hpp"
#include "../windows_emulator.hpp"

#define DNS_TYPE_A     0x01
#define DNS_TYPE_CNAME 0x05
#define DNS_TYPE_AAAA  0x1C

#ifndef OS_WINDOWS
#define ERROR_SUCCESS              0x0
#define DNS_ERROR_RCODE_NAME_ERROR 0x232B
#endif

namespace
{
    using IP4_ADDRESS = DWORD;

    struct DNS_A_DATA
    {
        IP4_ADDRESS IpAddress;
    };

    struct IP6_ADDRESS
    {
        std::array<uint64_t, 2> IP6Qword;
    };

    struct DNS_AAAA_DATA
    {
        IP6_ADDRESS Ip6Address;
    };

    template <typename Traits>
    struct DNS_RECORDW
    {
        EMULATOR_CAST(Traits::PVOID, DNS_RECORDW*) pNext;
        EMULATOR_CAST(Traits::PVOID, const char16_t*) pName;
        WORD wType;
        WORD wDataLength;
        DWORD Flags;
        DWORD dwTtl;
        DWORD dwReserved;
        union
        {
            DNS_A_DATA A;
            DNS_AAAA_DATA AAAA;
        } Data;

        void write(utils::aligned_binary_writer<Traits>& writer) const
        {
            writer.write_ndr_pointer(this->pNext);
            writer.write_ndr_pointer(this->pName);
            writer.write(this->wType);
            writer.write(this->wDataLength);
            writer.write(this->Flags);
            writer.write(this->dwTtl);
            writer.write(this->dwReserved);

            writer.write(this->wType); // union identifier
            writer.write(&this->Data, this->wDataLength, sizeof(typename Traits::PVOID));

            writer.write_ndr_u16string(reinterpret_cast<const char16_t*>(this->pName));
        }
    };
    static_assert(sizeof(DNS_RECORDW<EmulatorTraits<Emu64>>) == 48);

    template <typename Traits>
    struct DNS_QUERY_RESPONSE
    {
        std::optional<DNS_RECORDW<Traits>> dns_record;
        uint64_t error_code{};

        void write(utils::aligned_binary_writer<Traits>& writer) const
        {
            // NOTE: The response is pretty much just an array of DNS_RECORD, marshalled using NDR64.
            if (!this->dns_record)
            {
                writer.write_ndr_pointer(false);
            }
            else
            {
                writer.write_ndr_pointer(true);
                writer.write(*this->dns_record);
            }

            writer.align_to(sizeof(typename Traits::PVOID));
            writer.pad(24);
            writer.write(error_code);
            writer.pad(64);
        }
    };

    WORD convert_socket_famity_to_dns_type(const int family)
    {
        switch (family)
        {
        case AF_INET:
            return DNS_TYPE_A;
        case AF_INET6:
            return DNS_TYPE_AAAA;
        default:
            throw std::runtime_error("Unexpected DNS type!");
        }
    }

    template <typename Traits>
    std::optional<DNS_RECORDW<Traits>> resolve_host_address(const std::u16string& host, const WORD dns_type)
    {
        addrinfo hints{};
        hints.ai_family = AF_UNSPEC;

        DNS_RECORDW<Traits> result{};
        result.pName = reinterpret_cast<Traits::PVOID>(host.c_str());
        result.Flags = 0x2009;
        result.dwTtl = 0x708;

        addrinfo* res = nullptr;
        int status = getaddrinfo(u16_to_u8(host).c_str(), nullptr, &hints, &res);
        if (status == 0)
        {
            for (addrinfo* p = res; p != nullptr && dns_type != result.wType; p = p->ai_next)
            {
                if (p->ai_family == AF_INET)
                {
                    auto* ipv4 = reinterpret_cast<sockaddr_in*>(p->ai_addr);
                    memset(&result.Data, 0, 16);
                    memcpy(&result.Data, &ipv4->sin_addr, sizeof(ipv4->sin_addr));
                    result.wDataLength = sizeof(ipv4->sin_addr);
                }
                else if (p->ai_family == AF_INET6)
                {
                    auto* ipv6 = reinterpret_cast<sockaddr_in6*>(p->ai_addr);
                    memset(&result.Data, 0, 16);
                    memcpy(&result.Data, &ipv6->sin6_addr, sizeof(ipv6->sin6_addr));
                    result.wDataLength = sizeof(ipv6->sin6_addr);
                }
                else
                {
                    continue;
                }
                result.wType = convert_socket_famity_to_dns_type(p->ai_family);
            }

            freeaddrinfo(res);
        }

        if (result.wType == DNS_TYPE_A && dns_type == DNS_TYPE_AAAA)
        {
            auto* addr = reinterpret_cast<uint8_t*>(&result.Data);
            addr[10] = 0xff;
            addr[11] = 0xff;
            memcpy(addr + 12, addr, 4);
            memset(addr, 0, 10);
            result.wType = DNS_TYPE_AAAA;
        }

        if (result.wType != dns_type || result.wType == 0)
        {
            return {};
        }

        return result;
    }

    struct dns_resolver : rpc_port
    {
        NTSTATUS handle_rpc(windows_emulator& win_emu, const uint32_t procedure_id, const lpc_request_context& c) override
        {
            std::array<uint8_t, 8> request_cookie;
            win_emu.emu().read_memory(c.send_buffer + c.send_buffer_length - 8, request_cookie.data(), request_cookie.size());

            utils::aligned_binary_writer<EmulatorTraits<Emu64>> writer(win_emu.emu(), c.recv_buffer);
            writer.write(request_cookie);

            switch (procedure_id)
            {
            case 2:
                handle_dns_query(win_emu, c, writer);
                break;
            case 3:
                return STATUS_NOT_SUPPORTED;
            default:
                throw std::runtime_error("Unimplemented procedure!");
            }

            return STATUS_SUCCESS;
        }

        template <typename Traits>
        static void handle_dns_query(windows_emulator& win_emu, const lpc_request_context& c, utils::aligned_binary_writer<Traits>& writer)
        {
            auto& emu = win_emu.emu();

            const auto hostname_length = static_cast<size_t>(emu.read_memory<uint64_t>(c.send_buffer + 0x08));
            const auto hostname_offset = c.send_buffer + 0x20;

            std::u16string hostname;
            hostname.resize(hostname_length - 1);
            emu.read_memory(hostname_offset, hostname.data(), (hostname_length - 1) * sizeof(char16_t));

            const auto query_type = emu.read_memory<uint16_t>(hostname_offset + hostname_length * sizeof(char16_t));

            if (query_type != DNS_TYPE_A && query_type != DNS_TYPE_AAAA)
            {
                throw std::runtime_error("Unexpected DNS query type!");
            }

            win_emu.callbacks.on_generic_activity("DNS query: " + u16_to_u8(hostname));

            DNS_QUERY_RESPONSE<Traits> response{};
            response.dns_record = resolve_host_address<Traits>(hostname, query_type);
            response.error_code = response.dns_record ? ERROR_SUCCESS : DNS_ERROR_RCODE_NAME_ERROR;
            writer.write(response);

            c.recv_buffer_length = static_cast<ULONG>(writer.offset());
        }
    };
}

std::unique_ptr<port> create_dns_resolver()
{
    return std::make_unique<dns_resolver>();
}

```

`src/windows-emulator/ports/dns_resolver.hpp`:

```hpp
#pragma once
#include "../port.hpp"

std::unique_ptr<port> create_dns_resolver();

```

`src/windows-emulator/ports/lsa_policy_lookup.cpp`:

```cpp
#include "../std_include.hpp"
#include "lsa_policy_lookup.hpp"

#include "../windows_emulator.hpp"

namespace
{
    constexpr NTSTATUS k_status_none_mapped = static_cast<NTSTATUS>(0xC0000073);
    constexpr ULONG k_request_cookie_size = 8;
    constexpr ULONG k_open_policy_reply_size = 0x20;
    constexpr ULONG k_lookup_names_reply_size = 0x18;
    constexpr ULONG k_close_policy_reply_size = 0x0C;
    constexpr ULONG k_open_policy_context_attr_offset = 0x08;
    constexpr ULONG k_open_policy_ntstatus_offset = 0x1C;
    constexpr ULONG k_lookup_names_status_offset = 0x14;
    constexpr ULONG k_close_policy_status_offset = 0x08;

    struct lsa_policy_lookup_port : rpc_port
    {
        NTSTATUS handle_rpc(windows_emulator& win_emu, const uint32_t procedure_id, const lpc_request_context& c) override
        {
            if (!write_request_cookie(win_emu, c))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            switch (procedure_id)
            {
            case 4:
                return handle_open_policy(win_emu, c);
            case 2:
                return handle_lookup_names(win_emu, c);
            case 3:
                return handle_close_policy(win_emu, c);
            default:
                win_emu.log.warn("Unsupported lsapolicylookup procedure: %u\n", procedure_id);
                return STATUS_NOT_SUPPORTED;
            }
        }

      private:
        static bool ensure_recv_capacity(windows_emulator& win_emu, const lpc_request_context& c, const ULONG required,
                                         const char* operation)
        {
            if (c.recv_buffer_length >= required)
            {
                return true;
            }

            win_emu.log.warn("lsapolicylookup %s reply buffer too small: have 0x%X need 0x%X\n", operation, c.recv_buffer_length, required);
            return false;
        }

        static bool write_request_cookie(windows_emulator& win_emu, const lpc_request_context& c)
        {
            if (!ensure_recv_capacity(win_emu, c, k_request_cookie_size, "cookie"))
            {
                return false;
            }

            std::array<uint8_t, 8> request_cookie{};
            if (c.send_buffer_length >= k_request_cookie_size)
            {
                win_emu.emu().read_memory(c.send_buffer + c.send_buffer_length - k_request_cookie_size, request_cookie.data(),
                                          request_cookie.size());
            }
            win_emu.emu().write_memory(c.recv_buffer, request_cookie.data(), request_cookie.size());
            return true;
        }

        static NTSTATUS handle_open_policy(windows_emulator& win_emu, const lpc_request_context& c)
        {
            if (!ensure_recv_capacity(win_emu, c, k_open_policy_reply_size, "open_policy"))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            std::array<std::byte, k_open_policy_reply_size> zeros{};
            win_emu.emu().write_memory(c.recv_buffer, zeros.data(), zeros.size());

            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + k_open_policy_context_attr_offset, 0);
            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + k_open_policy_ntstatus_offset, STATUS_SUCCESS);
            c.recv_buffer_length = k_open_policy_reply_size;
            return STATUS_SUCCESS;
        }

        static NTSTATUS handle_lookup_names(windows_emulator& win_emu, const lpc_request_context& c)
        {
            if (!ensure_recv_capacity(win_emu, c, k_lookup_names_reply_size, "lookup_names"))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + 0x08, 0);
            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + 0x0C, 0);
            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + 0x10, 0);
            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + k_lookup_names_status_offset, k_status_none_mapped);
            c.recv_buffer_length = k_lookup_names_reply_size;
            return STATUS_SUCCESS;
        }

        static NTSTATUS handle_close_policy(windows_emulator& win_emu, const lpc_request_context& c)
        {
            if (!ensure_recv_capacity(win_emu, c, k_close_policy_reply_size, "close_policy"))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            win_emu.emu().write_memory<uint32_t>(c.recv_buffer + k_close_policy_status_offset, STATUS_SUCCESS);
            c.recv_buffer_length = k_close_policy_reply_size;
            return STATUS_SUCCESS;
        }
    };
}

std::unique_ptr<port> create_lsa_policy_lookup_port()
{
    return std::make_unique<lsa_policy_lookup_port>();
}

```

`src/windows-emulator/ports/lsa_policy_lookup.hpp`:

```hpp
#pragma once

#include "../port.hpp"

std::unique_ptr<port> create_lsa_policy_lookup_port();

```

`src/windows-emulator/process_context.cpp`:

```cpp
#include "std_include.hpp"
#include "process_context.hpp"

#include "emulator_utils.hpp"
#include "syscall_utils.hpp"
#include "windows_emulator.hpp"
#include "version/windows_version_manager.hpp"

#include <utils/io.hpp>
#include <utils/buffer_accessor.hpp>
#include <regex>

namespace
{
    emulator_allocator create_allocator(memory_manager& memory, const size_t size, const bool is_wow64_process)
    {
        uint64_t default_allocation_base = (is_wow64_process == true) ? DEFAULT_ALLOCATION_ADDRESS_32BIT : DEFAULT_ALLOCATION_ADDRESS_64BIT;
        uint64_t base = memory.find_free_allocation_base(size, default_allocation_base);
        bool allocated = memory.allocate_memory(base, size, memory_permission::read_write);

        if (!allocated)
        {
            throw std::runtime_error("Failed to allocate memory for process structure");
        }

        return emulator_allocator{memory, base, size};
    }

    void setup_gdt(x86_64_emulator& emu, memory_manager& memory)
    {
        // Allocate GDT with read-write permissions for segment descriptor setup
        memory.allocate_memory(GDT_ADDR, static_cast<size_t>(page_align_up(GDT_LIMIT)), memory_permission::read_write);
        emu.load_gdt(GDT_ADDR, GDT_LIMIT);

        // Index 1 (selector 0x08) - 64-bit kernel code segment (Ring 0)
        // P=1, DPL=0, S=1, Type=0xA (Code, Execute/Read), L=1 (Long mode)
        emu.write_memory<uint64_t>(GDT_ADDR + 1 * sizeof(uint64_t), 0x00AF9B000000FFFF);

        // Index 2 (selector 0x10) - 64-bit kernel data segment (Ring 0)
        // P=1, DPL=0, S=1, Type=0x2 (Data, Read/Write), L=1 (64-bit)
        emu.write_memory<uint64_t>(GDT_ADDR + 2 * sizeof(uint64_t), 0x00CF93000000FFFF);

        // Index 3 (selector 0x18) - 32-bit compatibility mode segment (Ring 0)
        // P=1, DPL=0, S=1, Type=0xA (Code, Execute/Read), DB=1, G=1
        emu.write_memory<uint64_t>(GDT_ADDR + 3 * sizeof(uint64_t), 0x00CF9B000000FFFF);

        // Index 4 (selector 0x23) - 32-bit code segment for WOW64 (Ring 3)
        // Real Windows: Code RE Ac 3 Bg Pg P Nl 00000cfb
        // P=1, DPL=3, S=1, Type=0xA (Code, Execute/Read), DB=1, G=1
        emu.write_memory<uint64_t>(GDT_ADDR + 4 * sizeof(uint64_t), 0x00CFFB000000FFFF);

        // Index 5 (selector 0x2B) - Data segment for user mode (Ring 3)
        // Real Windows: Data RW Ac 3 Bg Pg P Nl 00000cf3
        // P=1, DPL=3, S=1, Type=0x2 (Data, Read/Write), G=1
        emu.write_memory<uint64_t>(GDT_ADDR + 5 * sizeof(uint64_t), 0x00CFF3000000FFFF);
        emu.reg<uint16_t>(x86_register::ss, 0x2B);
        emu.reg<uint16_t>(x86_register::ds, 0x2B);
        emu.reg<uint16_t>(x86_register::es, 0x2B);
        emu.reg<uint16_t>(x86_register::gs, 0x2B); // Initial GS value, will be overridden with proper base later

        // Index 6 (selector 0x33) - 64-bit code segment (Ring 3)
        // P=1, DPL=3, S=1, Type=0xA (Code, Execute/Read), L=1 (Long mode)
        emu.write_memory<uint64_t>(GDT_ADDR + 6 * sizeof(uint64_t), 0x00AFFB000000FFFF);
        emu.reg<uint16_t>(x86_register::cs, 0x33);

        // Index 10 (selector 0x53) - FS segment for WOW64 TEB access
        // Real Windows: Data RW Ac 3 Bg By P Nl 000004f3 (base=0x002c1000, limit=0xfff)
        // Initially set with base=0, will be updated during thread creation
        // P=1, DPL=3, S=1, Type=0x3 (Data, Read/Write, Accessed), G=0 (byte granularity), DB=1
        emu.write_memory<uint64_t>(GDT_ADDR + 10 * sizeof(uint64_t), 0x0040F3000000FFFF);
        emu.reg<uint16_t>(x86_register::fs, 0x53);
    }

    std::u16string expand_environment_string(const std::u16string& input,
                                             const utils::unordered_insensitive_u16string_map<std::u16string>& env_map)
    {
        std::u16string result;
        result.reserve(input.length());
        size_t pos = 0;

        while (pos < input.length())
        {
            size_t start = input.find(u'%', pos);
            if (start == std::u16string::npos)
            {
                result.append(input.substr(pos));
                break;
            }

            result.append(input.substr(pos, start - pos));

            size_t end = input.find(u'%', start + 1);
            if (end == std::u16string::npos)
            {
                result.append(input.substr(start));
                break;
            }

            std::u16string var_name = input.substr(start + 1, end - start - 1);

            if (var_name.empty())
            {
                result.append(u"%%");
            }
            else
            {
                auto it = env_map.find(var_name);
                result.append(it != env_map.end() ? it->second : input.substr(start, end - start + 1));
            }

            pos = end + 1;
        }
        return result;
    }

    utils::unordered_insensitive_u16string_map<std::u16string> get_environment_variables(registry_manager& registry,
                                                                                         const windows_version_manager& version)
    {
        utils::unordered_insensitive_u16string_map<std::u16string> env_map;
        std::unordered_set<std::u16string_view> keys_to_expand;

        const auto env_key = registry.get_key({R"(\Registry\Machine\System\CurrentControlSet\Control\Session Manager\Environment)"});
        if (env_key)
        {
            for (size_t i = 0; const auto value_opt = registry.get_value(*env_key, i); i++)
            {
                const auto& value = *value_opt;

                if (value.type != REG_SZ && value.type != REG_EXPAND_SZ)
                {
                    continue;
                }

                if (value.data.empty() || value.data.size() % 2 != 0)
                {
                    continue;
                }

                const auto char_count = value.data.size() / sizeof(char16_t);
                const auto* data_ptr = reinterpret_cast<const char16_t*>(value.data.data());
                if (data_ptr[char_count - 1] != u'\0')
                {
                    continue;
                }

                const auto [it, inserted] = env_map.emplace(u8_to_u16(value.name), std::u16string(data_ptr, char_count - 1));
                if (inserted && value.type == REG_EXPAND_SZ)
                {
                    keys_to_expand.insert(it->first);
                }
            }
        }

        env_map[u"EMULATOR"] = u"1";

        const auto* env = getenv("EMULATOR_ICICLE");
        if (env && (env == "1"sv || env == "true"sv))
        {
            env_map[u"EMULATOR_ICICLE"] = u"1";
        }

        const auto system_root = version.get_system_root().u16string();

        std::u16string system_drive = u"C:";
        if (system_root.size() >= 2 && system_root[1] == u':')
        {
            system_drive = system_root.substr(0, 2);
        }

        auto system_temp = system_root;
        if (!system_temp.empty() && system_temp.back() != u'\\')
        {
            system_temp.push_back(u'\\');
        }
        system_temp += u"SystemTemp";

        env_map[u"COMPUTERNAME"] = u"momo";
        env_map[u"USERNAME"] = u"momo";
        env_map[u"SystemDrive"] = system_drive;
        env_map[u"SystemRoot"] = system_root;
        env_map[u"SystemTemp"] = system_temp;
        env_map[u"TMP"] = u"C:\\Users\\momo\\AppData\\Temp";
        env_map[u"TEMP"] = u"C:\\Users\\momo\\AppData\\Temp";
        env_map[u"USERPROFILE"] = u"C:\\Users\\momo";

        for (const auto& key : keys_to_expand)
        {
            auto it = env_map.find(key);
            if (it != env_map.end())
            {
                std::u16string expanded = expand_environment_string(it->second, env_map);
                if (expanded != it->second)
                {
                    it->second = expanded;
                }
            }
        }

        return env_map;
    }
}

void process_context::setup(x86_64_emulator& emu, memory_manager& memory, registry_manager& registry, file_system& file_system,
                            windows_version_manager& version, const application_settings& app_settings, const mapped_module& executable,
                            const mapped_module& ntdll, const apiset::container& apiset_container, const mapped_module* ntdll32)
{
    setup_gdt(emu, memory);

    this->kusd.setup(version);

    this->base_allocator = create_allocator(memory, PEB_SEGMENT_SIZE, this->is_wow64_process);
    auto& allocator = this->base_allocator;

    this->peb64 = allocator.reserve_page_aligned<PEB64>();

    /* Values of the following fields must be
     * allocated relative to the process_params themselves
     * and included in the length:
     *
     * CurrentDirectory
     * DllPath
     * ImagePathName
     * CommandLine
     * WindowTitle
     * DesktopInfo
     * ShellInfo
     * RuntimeData
     * RedirectionDllName
     */

    this->process_params64 = allocator.reserve<RTL_USER_PROCESS_PARAMETERS64>();

    // Clone the API set for PEB64 and PEB32
    uint64_t apiset_map_address_32 = 0;
    [[maybe_unused]] const auto apiset_map_address = apiset::clone(emu, allocator, apiset_container).value();
    if (this->is_wow64_process)
    {
        apiset_map_address_32 = apiset::clone(emu, allocator, apiset_container).value();
    }

    this->process_params64.access([&](RTL_USER_PROCESS_PARAMETERS64& proc_params) {
        proc_params.Flags = 0x6001; //| 0x80000000; // Prevent CsrClientConnectToServer

        proc_params.ConsoleHandle = CONSOLE_HANDLE.h;
        proc_params.StandardOutput = STDOUT_HANDLE.h;
        proc_params.StandardInput = STDIN_HANDLE.h;
        proc_params.StandardError = proc_params.StandardOutput;

        proc_params.Environment = allocator.copy_string(u"=::=::\\");

        const auto env_map = get_environment_variables(registry, version);
        for (const auto& [name, value] : env_map)
        {
            std::u16string entry;
            entry += name;
            entry += u"=";
            entry += value;
            allocator.copy_string(entry);
        }

        allocator.copy_string(u"");

        const auto application_str = app_settings.application.u16string();

        std::u16string command_line = u"\"" + application_str + u"\"";

        for (const auto& arg : app_settings.arguments)
        {
            command_line.push_back(u' ');
            command_line.append(arg);
        }

        allocator.make_unicode_string(proc_params.CommandLine, command_line);
        allocator.make_unicode_string(proc_params.CurrentDirectory.DosPath, app_settings.working_directory.u16string() + u"\\", 1024);
        allocator.make_unicode_string(proc_params.ImagePathName, application_str);

        const auto total_length = allocator.get_next_address() - this->process_params64.value();

        proc_params.Length = static_cast<uint32_t>(std::max(static_cast<uint64_t>(sizeof(proc_params)), total_length));
        proc_params.MaximumLength = proc_params.Length;
    });

    this->peb64.access([&](PEB64& p) {
        p.BeingDebugged = 0;
        p.ImageBaseAddress = executable.image_base;
        p.ProcessParameters = this->process_params64.value();
        p.ApiSetMap = apiset::clone(emu, allocator, apiset_container).value();

        p.ProcessHeap = 0;
        p.ProcessHeaps = 0;
        p.HeapSegmentReserve = executable.size_of_heap_reserve;
        p.HeapSegmentCommit = executable.size_of_heap_commit;
        p.HeapDeCommitTotalFreeThreshold = 0x0000000000010000;
        p.HeapDeCommitFreeBlockThreshold = 0x0000000000001000;
        p.NumberOfHeaps = 0x00000000;
        p.MaximumNumberOfHeaps = 0x00000010;
        p.NumberOfProcessors = 4;
        p.ImageSubsystemMajorVersion = 6;

        p.OSPlatformId = 2;
        p.OSMajorVersion = version.get_major_version();
        p.OSMinorVersion = version.get_minor_version();
        p.OSBuildNumber = static_cast<USHORT>(version.get_windows_build_number());

        // p.AnsiCodePageData = allocator.reserve<CPTABLEINFO>().value();
        // p.OemCodePageData = allocator.reserve<CPTABLEINFO>().value();
        p.UnicodeCaseTableData = allocator.reserve<NLSTABLEINFO>().value();
    });

    if (this->is_wow64_process)
    {
        this->peb32 = allocator.reserve_page_aligned<PEB32>();

        // Initialize RTL_USER_PROCESS_PARAMETERS32 structure
        this->process_params32 = allocator.reserve<RTL_USER_PROCESS_PARAMETERS32>();

        this->process_params32->access([&](RTL_USER_PROCESS_PARAMETERS32& params32) {
            params32.Flags = RTL_USER_PROCESS_PARAMETERS_IMAGE_KEY_MISSING | RTL_USER_PROCESS_PARAMETERS_APP_MANIFEST_PRESENT |
                             RTL_USER_PROCESS_PARAMETERS_NORMALIZED;

            params32.ConsoleHandle = static_cast<uint32_t>(CONSOLE_HANDLE.h);
            params32.StandardOutput = static_cast<uint32_t>(STDOUT_HANDLE.h);
            params32.StandardInput = static_cast<uint32_t>(STDIN_HANDLE.h);
            params32.StandardError = params32.StandardOutput;

            this->process_params64.access([&](const RTL_USER_PROCESS_PARAMETERS64& params64) {
                // Copy strings from params64
                allocator.make_unicode_string(params32.ImagePathName, read_unicode_string(emu, params64.ImagePathName));
                allocator.make_unicode_string(params32.CommandLine, read_unicode_string(emu, params64.CommandLine));
                allocator.make_unicode_string(params32.DllPath, read_unicode_string(emu, params64.DllPath));
                allocator.make_unicode_string(params32.CurrentDirectory.DosPath,
                                              read_unicode_string(emu, params64.CurrentDirectory.DosPath));
                allocator.make_unicode_string(params32.WindowTitle, read_unicode_string(emu, params64.WindowTitle));
                allocator.make_unicode_string(params32.DesktopInfo, read_unicode_string(emu, params64.DesktopInfo));
                allocator.make_unicode_string(params32.ShellInfo, read_unicode_string(emu, params64.ShellInfo));
                allocator.make_unicode_string(params32.RuntimeData, read_unicode_string(emu, params64.RuntimeData));
                allocator.make_unicode_string(params32.RedirectionDllName, read_unicode_string(emu, params64.RedirectionDllName));

                // Copy other fields
                params32.CurrentDirectory.Handle = static_cast<uint32_t>(params64.CurrentDirectory.Handle);
                params32.ShowWindowFlags = params64.ShowWindowFlags;
                params32.ConsoleHandle = static_cast<uint32_t>(params64.ConsoleHandle);
                params32.ConsoleFlags = params64.ConsoleFlags;
                params32.StandardInput = static_cast<uint32_t>(params64.StandardInput);
                params32.StandardOutput = static_cast<uint32_t>(params64.StandardOutput);
                params32.StandardError = static_cast<uint32_t>(params64.StandardError);
                params32.StartingX = params64.StartingX;
                params32.StartingY = params64.StartingY;
                params32.CountX = params64.CountX;
                params32.CountY = params64.CountY;
                params32.CountCharsX = params64.CountCharsX;
                params32.CountCharsY = params64.CountCharsY;
                params32.FillAttribute = params64.FillAttribute;
                params32.WindowFlags = params64.WindowFlags;
                params32.DebugFlags = params64.DebugFlags;
                params32.ProcessGroupId = params64.ProcessGroupId;
                params32.LoaderThreads = params64.LoaderThreads;

                // Environment - copy the pointer value (both processes share the same environment)
                params32.Environment = static_cast<uint32_t>(params64.Environment);
                params32.EnvironmentSize = static_cast<uint32_t>(params64.EnvironmentSize);
                params32.EnvironmentVersion = static_cast<uint32_t>(params64.EnvironmentVersion);

                const auto total_length = allocator.get_next_address() - this->process_params32->value();

                params32.Length = static_cast<uint32_t>(std::max(static_cast<uint64_t>(sizeof(params32)), total_length));
                params32.MaximumLength = params32.Length;
            });
        });

        // Update PEB32 to point to the ProcessParameters32
        this->peb32->access([&](PEB32& p32) {
            p32.BeingDebugged = 0;
            p32.ImageBaseAddress = static_cast<uint32_t>(executable.image_base);
            p32.ProcessParameters = static_cast<uint32_t>(this->process_params32->value());

            // Use the dedicated 32-bit ApiSetMap for PEB32
            p32.ApiSetMap = static_cast<uint32_t>(apiset_map_address_32);

            // Copy similar settings from PEB64
            p32.ProcessHeap = 0;
            p32.ProcessHeaps = 0;
            p32.HeapSegmentReserve = static_cast<uint32_t>(executable.size_of_heap_reserve);
            p32.HeapSegmentCommit = static_cast<uint32_t>(executable.size_of_heap_commit);
            p32.HeapDeCommitTotalFreeThreshold = 0x00010000;
            p32.HeapDeCommitFreeBlockThreshold = 0x00001000;
            p32.NumberOfHeaps = 0;
            p32.MaximumNumberOfHeaps = 0x10;
            p32.NumberOfProcessors = 4;
            p32.ImageSubsystemMajorVersion = 6;

            p32.OSPlatformId = 2;
            p32.OSMajorVersion = version.get_major_version();
            p32.OSMinorVersion = version.get_minor_version();
            p32.OSBuildNumber = static_cast<USHORT>(version.get_windows_build_number());

            // Initialize NLS tables for 32-bit processes
            // These need to be in 32-bit addressable space
            p32.UnicodeCaseTableData = static_cast<uint32_t>(allocator.reserve<NLSTABLEINFO>().value());

            // TODO: Initialize other PEB32 fields as needed
        });

        if (ntdll32 != nullptr)
        {
            this->rtl_user_thread_start32 = ntdll32->find_export("RtlUserThreadStart");
        }
    }

    this->apiset = apiset::get_namespace_table(reinterpret_cast<const API_SET_NAMESPACE*>(apiset_container.data.data()));
    const auto& system_root = version.get_system_root();
    this->build_knowndlls_section_table<uint64_t>(registry, file_system, apiset, system_root, false);
    this->build_knowndlls_section_table<uint32_t>(registry, file_system, apiset, system_root, true);

    this->ntdll_image_base = ntdll.image_base;
    this->ldr_initialize_thunk = ntdll.find_export("LdrInitializeThunk");
    this->rtl_user_thread_start = ntdll.find_export("RtlUserThreadStart");
    this->ki_user_apc_dispatcher = ntdll.find_export("KiUserApcDispatcher");
    this->ki_user_exception_dispatcher = ntdll.find_export("KiUserExceptionDispatcher");
    this->instrumentation_callback = 0;
    this->wow64_ki_user_callback_dispatcher = 0;
    this->zw_callback_return = ntdll.find_export("ZwCallbackReturn");
    this->gdi_default_dc_handle = 0;
    this->etw_notification_event.reset();

    const auto gdi_shared_table = this->base_allocator.reserve<GDI_SHARED_MEMORY64>();
    gdi_shared_table.access([](GDI_SHARED_MEMORY64& table) { memset(&table, 0, sizeof(table)); });

    this->peb64.access([&](PEB64& peb64) {
        peb64.GdiSharedHandleTable = gdi_shared_table.value();
        peb64.GdiDCAttributeList = 0;
    });

    if (this->peb32)
    {
        uint32_t gdi_shared_table32 = 0;
        if (gdi_shared_table.value() <= std::numeric_limits<uint32_t>::max())
        {
            gdi_shared_table32 = static_cast<uint32_t>(gdi_shared_table.value());
        }

        this->peb32->access([&](PEB32& peb32) {
            peb32.GdiSharedHandleTable = gdi_shared_table32;
            peb32.GdiDCAttributeList = 0;
        });
    }

    this->default_register_set = emu.save_registers();

    this->user_handles.setup(is_wow64_process);

    auto [h, monitor_obj] = this->user_handles.allocate_object<USER_MONITOR>(handle_types::monitor);
    this->default_monitor_handle = h;
    monitor_obj.access([&](USER_MONITOR& monitor) {
        monitor.hmon = h.bits;
        monitor.rcMonitor = {.left = 0, .top = 0, .right = 1920, .bottom = 1080};
        monitor.rcWork = monitor.rcMonitor;
        if (version.is_build_before(26040))
        {
            monitor.b20.monitorDpi = 96;
            monitor.b20.nativeDpi = monitor.b20.monitorDpi;
            monitor.b20.cachedDpi = monitor.b20.monitorDpi;
            monitor.b20.rcMonitorDpiAware = monitor.rcMonitor;
        }
        else
        {
            monitor.b26.monitorDpi = 96;
            monitor.b26.nativeDpi = monitor.b26.monitorDpi;
        }
    });

    const auto user_display_info = this->user_handles.get_display_info();
    user_display_info.access([&](USER_DISPINFO& display_info) {
        display_info.dwMonitorCount = 1;
        display_info.pPrimaryMonitor = monitor_obj.value();
    });
}

void process_context::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write(this->shared_section_address);
    buffer.write(this->shared_section_size);
    buffer.write(this->dbwin_buffer);
    buffer.write(this->dbwin_buffer_size);
    buffer.write_optional(this->exit_status);
    buffer.write(this->base_allocator);
    buffer.write(this->peb64);
    buffer.write_optional(this->peb32);
    buffer.write(this->process_params64);
    buffer.write_optional(this->process_params32);
    buffer.write(this->kusd);

    buffer.write(this->is_wow64_process);
    buffer.write(this->ntdll_image_base);
    buffer.write(this->ldr_initialize_thunk);
    buffer.write(this->rtl_user_thread_start);
    buffer.write_optional(this->rtl_user_thread_start32);
    buffer.write(this->ki_user_apc_dispatcher);
    buffer.write(this->ki_user_exception_dispatcher);
    buffer.write(this->instrumentation_callback);
    buffer.write(this->wow64_ki_user_callback_dispatcher);
    buffer.write(this->zw_callback_return);
    buffer.write(this->dispatch_client_message);
    buffer.write(this->gdi_default_dc_handle);
    buffer.write_optional(this->etw_notification_event);

    buffer.write(this->user_handles);
    buffer.write(this->default_monitor_handle);
    buffer.write(this->events);
    buffer.write(this->files);
    buffer.write(this->sections);
    buffer.write(this->devices);
    buffer.write(this->semaphores);
    buffer.write(this->io_completions);
    buffer.write(this->wait_completion_packets);
    buffer.write(this->worker_factories);
    buffer.write(this->ports);
    buffer.write(this->mutants);
    buffer.write(this->default_desktop);
    buffer.write(this->desktops);
    buffer.write(this->windows);
    buffer.write(this->timers);
    buffer.write(this->registry_keys);
    buffer.write_map(this->atoms);
    buffer.write_map(this->classes);

    buffer.write_map(this->apiset);
    buffer.write_map(this->knowndlls32_sections);
    buffer.write_map(this->knowndlls64_sections);

    buffer.write(this->last_extended_params_numa_node);
    buffer.write(this->last_extended_params_attributes);
    buffer.write(this->last_extended_params_image_machine);

    buffer.write_vector(this->default_register_set);
    buffer.write(this->spawned_thread_count);
    buffer.write(this->threads);

    buffer.write(this->threads.find_handle(this->active_thread).bits);
}

void process_context::deserialize(utils::buffer_deserializer& buffer)
{
    buffer.read(this->shared_section_address);
    buffer.read(this->shared_section_size);
    buffer.read(this->dbwin_buffer);
    buffer.read(this->dbwin_buffer_size);
    buffer.read_optional(this->exit_status);
    buffer.read(this->base_allocator);
    buffer.read(this->peb64);
    buffer.read_optional(this->peb32);
    buffer.read(this->process_params64);
    buffer.read_optional(this->process_params32);
    buffer.read(this->kusd);

    buffer.read(this->is_wow64_process);
    buffer.read(this->ntdll_image_base);
    buffer.read(this->ldr_initialize_thunk);
    buffer.read(this->rtl_user_thread_start);
    buffer.read_optional(this->rtl_user_thread_start32);
    buffer.read(this->ki_user_apc_dispatcher);
    buffer.read(this->ki_user_exception_dispatcher);
    buffer.read(this->instrumentation_callback);
    buffer.read(this->wow64_ki_user_callback_dispatcher);
    buffer.read(this->zw_callback_return);
    buffer.read(this->dispatch_client_message);
    buffer.read(this->gdi_default_dc_handle);
    buffer.read_optional(this->etw_notification_event);

    buffer.read(this->user_handles);
    buffer.read(this->default_monitor_handle);
    buffer.read(this->events);
    buffer.read(this->files);
    buffer.read(this->sections);
    buffer.read(this->devices);
    buffer.read(this->semaphores);
    buffer.read(this->io_completions);
    buffer.read(this->wait_completion_packets);
    buffer.read(this->worker_factories);
    buffer.read(this->ports);
    buffer.read(this->mutants);
    buffer.read(this->default_desktop);
    buffer.read(this->desktops);
    buffer.read(this->windows);
    buffer.read(this->timers);
    buffer.read(this->registry_keys);
    buffer.read_map(this->atoms);
    buffer.read_map(this->classes);

    buffer.read_map(this->apiset);
    buffer.read_map(this->knowndlls32_sections);
    buffer.read_map(this->knowndlls64_sections);

    buffer.read(this->last_extended_params_numa_node);
    buffer.read(this->last_extended_params_attributes);
    buffer.read(this->last_extended_params_image_machine);

    buffer.read_vector(this->default_register_set);
    buffer.read(this->spawned_thread_count);

    for (auto& thread : this->threads | std::views::values)
    {
        thread.leak_memory();
    }

    buffer.read(this->threads);

    this->active_thread = this->threads.get(buffer.read<uint64_t>());
}

generic_handle_store* process_context::get_handle_store(const handle handle)
{
    switch (handle.value.type)
    {
    case handle_types::thread:
        return &threads;
    case handle_types::event:
        return &events;
    case handle_types::file:
        return &files;
    case handle_types::device:
        return &devices;
    case handle_types::semaphore:
        return &semaphores;
    case handle_types::io_completion:
        return &io_completions;
    case handle_types::wait_completion_packet:
        return &wait_completion_packets;
    case handle_types::worker_factory:
        return &worker_factories;
    case handle_types::registry:
        return &registry_keys;
    case handle_types::mutant:
        return &mutants;
    case handle_types::timer:
        return &timers;
    case handle_types::desktop:
        return &desktops;
    case handle_types::port:
        return &ports;
    case handle_types::section:
        return &sections;
    default:
        return nullptr;
    }
}

handle process_context::create_thread(memory_manager& memory, const uint64_t start_address, const uint64_t argument,
                                      const uint64_t stack_size, const uint32_t create_flags, const bool initial_thread)
{
    emulator_thread t{memory, *this, start_address, argument, stack_size, create_flags, ++this->spawned_thread_count, initial_thread};
    auto [h, thr] = this->threads.store_and_get(std::move(t));
    this->callbacks_->on_thread_create(h, *thr);
    return h;
}

std::optional<uint16_t> process_context::find_atom(const std::u16string_view name)
{
    for (auto& entry : this->atoms)
    {
        if (utils::string::equals_ignore_case(std::u16string_view{entry.second.name}, name))
        {
            ++entry.second.ref_count;
            return entry.first;
        }
    }

    return {};
}

uint16_t process_context::add_or_find_atom(std::u16string name)
{
    uint16_t index = 1;
    if (!this->atoms.empty())
    {
        auto i = this->atoms.end();
        --i;
        index = i->first + 1;
    }

    std::optional<uint16_t> last_entry{};
    for (auto& entry : this->atoms)
    {
        if (utils::string::equals_ignore_case(entry.second.name, name))
        {
            ++entry.second.ref_count;
            return entry.first;
        }

        if (entry.first > 0)
        {
            if (!last_entry)
            {
                index = 1;
            }
            else
            {
                const auto diff = entry.first - *last_entry;
                if (diff > 1)
                {
                    index = *last_entry + 1;
                }
            }
        }

        last_entry = entry.first;
    }

    atoms[index] = {std::move(name), 1};

    return index;
}

bool process_context::delete_atom(const std::u16string& name)
{
    for (auto it = atoms.begin(); it != atoms.end(); ++it)
    {
        if (utils::string::equals_ignore_case(it->second.name, name))
        {
            if (--it->second.ref_count == 0)
            {
                atoms.erase(it);
            }
            return true;
        }
    }

    return false;
}

bool process_context::delete_atom(const uint16_t atom_id)
{
    const auto it = atoms.find(atom_id);
    if (it == atoms.end())
    {
        return false;
    }

    if (--it->second.ref_count == 0)
    {
        atoms.erase(it);
    }

    return true;
}

const std::u16string* process_context::get_atom_name(const uint16_t atom_id) const
{
    const auto it = atoms.find(atom_id);
    if (it == atoms.end())
    {
        return nullptr;
    }

    return &it->second.name;
}

template <typename T>
void process_context::build_knowndlls_section_table(registry_manager& registry, const file_system& file_system, const apiset_map& apiset,
                                                    const windows_path& system_root, bool is_32bit)
{
    windows_path system_root_path;
    std::set<std::u16string> visisted;
    std::queue<std::u16string> q;

    system_root_path = is_32bit ? (system_root / "SysWOW64") : (system_root / "System32");

    std::optional<registry_key> knowndlls_key =
        registry.get_key({R"(\Registry\Machine\System\CurrentControlSet\Control\Session Manager\KnownDLLs)"});
    if (!knowndlls_key)
    {
        return;
    }

    size_t i = 0;
    for (;;)
    {
        auto known_dll_name_opt = registry.read_u16string(knowndlls_key.value(), i++);

        if (!known_dll_name_opt)
        {
            break;
        }

        auto known_dll_name = known_dll_name_opt.value();
        utils::string::to_lower_inplace(known_dll_name);

        q.push(known_dll_name);
        visisted.insert(known_dll_name);
    }

    while (!q.empty())
    {
        auto knowndll_filename = q.front();
        q.pop();

        std::vector<std::byte> file;
        if (!utils::io::read_file(file_system.translate(system_root_path / knowndll_filename), &file))
        {
            continue;
        }

        section s;
        s.file_name = (system_root_path / knowndll_filename).u16string();
        s.maximum_size = 0;
        s.allocation_attributes = SEC_IMAGE;
        s.section_page_protection = PAGE_EXECUTE;
        s.cache_image_info_from_filedata(file);
        add_knowndll_section(knowndll_filename, s, is_32bit);

        utils::safe_buffer_accessor<const std::byte> buffer{file};
        const auto dos_header = buffer.as<PEDosHeader_t>(0).get();
        const auto nt_headers_offset = dos_header.e_lfanew;
        const auto nt_headers = buffer.as<PENTHeaders_t<T>>(static_cast<size_t>(nt_headers_offset)).get();

        const auto& import_directory_entry = winpe::get_data_directory_by_index(nt_headers, IMAGE_DIRECTORY_ENTRY_IMPORT);
        if (!import_directory_entry.VirtualAddress)
        {
            continue;
        }

        const auto section_with_import_descs =
            winpe::get_section_header_by_rva(buffer, nt_headers, nt_headers_offset, import_directory_entry.VirtualAddress);
        auto import_directory_vbase = section_with_import_descs.VirtualAddress;
        auto import_directory_rbase = section_with_import_descs.PointerToRawData;

        uint64_t import_directory_raw =
            rva_to_file_offset(import_directory_vbase, import_directory_rbase, import_directory_entry.VirtualAddress);
        auto import_descriptors = buffer.as<IMAGE_IMPORT_DESCRIPTOR>(static_cast<size_t>(import_directory_raw));

        for (size_t import_desc_index = 0;; import_desc_index++)
        {
            const auto descriptor = import_descriptors.get(import_desc_index);
            if (!descriptor.Name)
            {
                break;
            }

            auto known_dll_dep_name = u8_to_u16(
                buffer.as_string(static_cast<size_t>(rva_to_file_offset(import_directory_vbase, import_directory_rbase, descriptor.Name))));
            utils::string::to_lower_inplace(known_dll_dep_name);

            if (known_dll_dep_name.starts_with(u"api-") || known_dll_dep_name.starts_with(u"ext-"))
            {
                if (auto apiset_entry = apiset.find(known_dll_dep_name); apiset_entry != apiset.end())
                {
                    known_dll_dep_name = apiset_entry->second;
                }
                else
                {
                    continue;
                }
            }

            if (!visisted.contains(known_dll_dep_name))
            {
                q.push(known_dll_dep_name);
                visisted.insert(known_dll_dep_name);
            }
        }
    }
}

bool process_context::has_knowndll_section(const std::u16string& name, bool is_32bit) const
{
    auto lname = utils::string::to_lower(name);

    if (is_32bit)
    {
        return knowndlls32_sections.contains(lname);
    }

    return knowndlls64_sections.contains(lname);
}

std::optional<section> process_context::get_knowndll_section_by_name(const std::u16string& name, bool is_32bit) const
{
    auto lname = utils::string::to_lower(name);

    if (is_32bit)
    {
        if (auto section = knowndlls32_sections.find(lname); section != knowndlls32_sections.end())
        {
            return section->second;
        }
    }
    else
    {
        if (auto section = knowndlls64_sections.find(lname); section != knowndlls64_sections.end())
        {
            return section->second;
        }
    }

    return {};
}

void process_context::add_knowndll_section(const std::u16string& name, const section& section, bool is_32bit)
{
    auto lname = utils::string::to_lower(name);

    if (is_32bit)
    {
        knowndlls32_sections[lname] = section;
    }
    else
    {
        knowndlls64_sections[lname] = section;
    }
}

```

`src/windows-emulator/process_context.hpp`:

```hpp
#pragma once

#include "emulator_utils.hpp"
#include "handles.hpp"
#include "registry/registry_manager.hpp"

#include "module/module_manager.hpp"
#include <utils/nt_handle.hpp>

#include <arch_emulator.hpp>

#include "io_device.hpp"
#include "kusd_mmio.hpp"
#include "windows_objects.hpp"
#include "emulator_thread.hpp"
#include "port.hpp"
#include "user_handle_table.hpp"

#include "apiset/apiset.hpp"

#define PEB_SEGMENT_SIZE        (20 << 20) // 20 MB
#define GS_SEGMENT_SIZE         (1 << 20)  // 1 MB

#define STACK_SIZE              0x40000ULL // 256KB

#define GDT_ADDR                0x35000
#define GDT_LIMIT               0x1000
#define GDT_ENTRY_SIZE          0x8

// TODO: Get rid of that
#define WOW64_NATIVE_STACK_SIZE 0x8000
#define WOW64_32BIT_STACK_SIZE  (1 << 20)

struct emulator_settings;
struct application_settings;
class windows_version_manager;

using knowndlls_map = std::map<std::u16string, section>;
struct process_context
{
    struct callbacks
    {
        utils::optional_function<void(handle h, emulator_thread& thr)> on_thread_create{};
        utils::optional_function<void(handle h, emulator_thread& thr)> on_thread_terminated{};
        utils::optional_function<void(emulator_thread& current_thread, emulator_thread& new_thread)> on_thread_switch{};
        utils::optional_function<void(emulator_thread& current_thread)> on_thread_set_name{};
    };

    struct atom_entry
    {
        std::u16string name{};
        uint32_t ref_count = 0;

        void serialize(utils::buffer_serializer& buffer) const
        {
            buffer.write(this->name);
            buffer.write(this->ref_count);
        }

        void deserialize(utils::buffer_deserializer& buffer)
        {
            buffer.read(this->name);
            buffer.read(this->ref_count);
        }
    };

    struct class_entry
    {
        emulator_pointer guest_obj_addr{};
        EMU_WNDCLASSEX wnd_class{};
        CLSMENUNAME<EmulatorTraits<Emu64>> menu_name{};

        class_entry() = default;

        class_entry(const emulator_pointer guest_obj, const EMU_WNDCLASSEX& wnd_class, const CLSMENUNAME<EmulatorTraits<Emu64>>& menu_name)
            : guest_obj_addr(guest_obj),
              wnd_class(wnd_class),
              menu_name(menu_name)
        {
        }
    };

    process_context(x86_64_emulator& emu, memory_manager& memory, utils::clock& clock, callbacks& cb)
        : callbacks_(&cb),
          base_allocator(emu),
          peb64(emu),
          process_params64(emu),
          kusd(memory, clock),
          user_handles(memory)
    {
    }

    void setup(x86_64_emulator& emu, memory_manager& memory, registry_manager& registry, file_system& file_system,
               windows_version_manager& version, const application_settings& app_settings, const mapped_module& executable,
               const mapped_module& ntdll, const apiset::container& apiset_container, const mapped_module* ntdll32 = nullptr);

    handle create_thread(memory_manager& memory, uint64_t start_address, uint64_t argument, uint64_t stack_size, uint32_t create_flags,
                         bool initial_thread = false);

    std::optional<uint16_t> find_atom(std::u16string_view name);
    uint16_t add_or_find_atom(std::u16string name);
    bool delete_atom(const std::u16string& name);
    bool delete_atom(uint16_t atom_id);
    const std::u16string* get_atom_name(uint16_t atom_id) const;

    template <typename T>
    void build_knowndlls_section_table(registry_manager& registry, const file_system& file_system, const apiset_map& apiset,
                                       const windows_path& system_root, bool is_32bit);

    std::optional<section> get_knowndll_section_by_name(const std::u16string& name, bool is_32bit) const;
    void add_knowndll_section(const std::u16string& name, const section& section, bool is_32bit);
    bool has_knowndll_section(const std::u16string& name, bool is_32bit) const;

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);

    generic_handle_store* get_handle_store(handle handle);

    // WOW64 support flag - set during process setup based on executable architecture
    bool is_wow64_process{false};

    callbacks* callbacks_{};

    uint64_t shared_section_address{0};
    uint64_t shared_section_size{0};
    uint64_t dbwin_buffer{0};
    uint64_t dbwin_buffer_size{0};

    std::optional<NTSTATUS> exit_status{};

    emulator_allocator base_allocator;

    emulator_object<PEB64> peb64;
    emulator_object<RTL_USER_PROCESS_PARAMETERS64> process_params64;
    kusd_mmio kusd;

    uint64_t ntdll_image_base{};
    uint64_t ldr_initialize_thunk{};
    uint64_t rtl_user_thread_start{};
    uint64_t ki_user_apc_dispatcher{};
    uint64_t ki_user_exception_dispatcher{};
    uint64_t instrumentation_callback{};
    uint64_t wow64_ki_user_callback_dispatcher{};
    uint64_t zw_callback_return{};
    uint64_t dispatch_client_message{};
    uint32_t gdi_default_dc_handle{};
    std::optional<handle> etw_notification_event{};

    // For WOW64 processes
    std::optional<emulator_object<PEB32>> peb32;
    std::optional<emulator_object<RTL_USER_PROCESS_PARAMETERS32>> process_params32;
    std::optional<uint64_t> rtl_user_thread_start32{};

    user_handle_table user_handles;
    handle default_monitor_handle{};
    handle_store<handle_types::event, event> events{};
    handle_store<handle_types::file, file> files{};
    handle_store<handle_types::section, section> sections{};
    handle_store<handle_types::device, io_device_container> devices{};
    handle_store<handle_types::semaphore, semaphore> semaphores{};
    handle_store<handle_types::io_completion, io_completion> io_completions{};
    handle_store<handle_types::wait_completion_packet, wait_completion_packet> wait_completion_packets{};
    handle_store<handle_types::worker_factory, worker_factory> worker_factories{};
    handle_store<handle_types::port, port_container> ports{};
    handle_store<handle_types::mutant, mutant> mutants{};
    handle default_desktop{};
    handle_store<handle_types::desktop, desktop> desktops{};
    user_handle_store<handle_types::window, window> windows{user_handles};
    handle_store<handle_types::timer, timer> timers{};
    handle_store<handle_types::registry, registry_key, 2> registry_keys{};
    std::map<uint16_t, atom_entry> atoms{};
    utils::insensitive_u16string_map<class_entry> classes{};

    apiset_map apiset;
    knowndlls_map knowndlls32_sections;
    knowndlls_map knowndlls64_sections;

    std::vector<std::byte> default_register_set{};

    uint32_t spawned_thread_count{0};
    handle_store<handle_types::thread, emulator_thread> threads{};
    emulator_thread* active_thread{nullptr};

    // Extended parameters from last NtMapViewOfSectionEx call
    // These can be used by other syscalls like NtAllocateVirtualMemoryEx
    uint64_t last_extended_params_numa_node{0};
    uint32_t last_extended_params_attributes{0};
    uint16_t last_extended_params_image_machine{IMAGE_FILE_MACHINE_UNKNOWN};
};

```

`src/windows-emulator/registry/hive_parser.cpp`:

```cpp
#include "../std_include.hpp"
#include "hive_parser.hpp"
#include <utils/string.hpp>

// Based on this implementation: https://github.com/reahly/windows-hive-parser

namespace
{
    constexpr uint64_t MAIN_ROOT_OFFSET = 0x1000;
    constexpr uint64_t MAIN_KEY_BLOCK_OFFSET = MAIN_ROOT_OFFSET + 0x20;

    // NOLINTBEGIN(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

    struct offset_entry_t
    {
        int32_t offset;
        int32_t hash;
    };

    struct offsets_t
    {
        int32_t block_size;
        char block_type[2];
        int16_t count;
        offset_entry_t entries[1];
    };

    struct key_block_t
    {
        int32_t block_size;
        char block_type[2];
        uint8_t dummya[18];
        int32_t subkey_count;
        uint8_t dummyb[4];
        int32_t subkeys;
        uint8_t dummyc[4];
        int32_t value_count;
        int32_t offsets;
        uint8_t dummyd[28];
        int16_t len;
        int16_t du;
        char name[255];
    };

    struct value_block_t
    {
        int32_t block_size;
        char block_type[2];
        int16_t name_len;
        int32_t size;
        int32_t offset;
        int32_t value_type;
        int16_t flags;
        int16_t dummy;
        char name[255];
    };

    // NOLINTEND(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)

    bool read_file_data_safe(std::ifstream& file, const uint64_t offset, void* buffer, const size_t size)
    {
        if (file.bad())
        {
            return false;
        }

        file.clear();

        if (!file.good())
        {
            return false;
        }

        file.seekg(static_cast<std::streamoff>(offset));

        if (!file.good())
        {
            return false;
        }

        file.read(static_cast<char*>(buffer), static_cast<std::streamsize>(size));

        return file.good();
    }

    void read_file_data(std::ifstream& file, const uint64_t offset, void* buffer, const size_t size)
    {
        if (!read_file_data_safe(file, offset, buffer, size))
        {
            throw std::runtime_error("Failed to read file data");
        }
    }

    std::vector<std::byte> read_file_data(std::ifstream& file, const uint64_t offset, const size_t size)
    {
        std::vector<std::byte> result{};
        result.resize(size);

        read_file_data(file, offset, result.data(), size);
        return result;
    }

    std::string read_file_data_string(std::ifstream& file, const uint64_t offset, const size_t size)
    {
        std::string result{};
        result.resize(size);

        read_file_data(file, offset, result.data(), size);
        return result;
    }

    template <typename T>
        requires(std::is_trivially_copyable_v<T>)
    T read_file_object(std::ifstream& file, const uint64_t offset, const size_t array_index = 0)
    {
        T obj{};
        read_file_data(file, offset + (array_index * sizeof(T)), &obj, sizeof(T));
        return obj;
    }

    hive_key parse_root_block(std::ifstream& file, const std::filesystem::path& file_path)
    {
        try
        {
            if (read_file_data_string(file, 0, 4) != "regf")
            {
                throw std::runtime_error("Invalid signature");
            }

            const auto key_block = read_file_object<key_block_t>(file, MAIN_KEY_BLOCK_OFFSET);

            return {key_block.subkeys, key_block.value_count, key_block.offsets};
        }
        catch (const std::exception& e)
        {
            throw std::runtime_error("Bad hive file '" + file_path.string() + "': " + e.what());
        }
    }
}

const hive_value* hive_key::get_value(std::ifstream& file, const std::string_view name)
{
    this->parse(file);

    const auto entry = this->values_.find(name);
    if (entry == this->values_.end())
    {
        return nullptr;
    }

    auto& value = entry->second;

    if (!value.parsed)
    {
        value.data = read_file_data(file, MAIN_ROOT_OFFSET + value.data_offset, value.data_length);
        value.parsed = true;
    }

    return &value;
}

const hive_value* hive_key::get_value(std::ifstream& file, const size_t index)
{
    this->parse(file);

    if (index >= values_by_index_.size())
    {
        return nullptr;
    }

    return get_value(file, values_by_index_[index]);
}

void hive_key::parse(std::ifstream& file)
{
    if (this->parsed_)
    {
        return;
    }

    this->parsed_ = true;

    // Values

    for (auto i = 0; i < this->value_count_; i++)
    {
        const auto offset = read_file_object<int>(file, MAIN_ROOT_OFFSET + this->value_offsets_ + 4, i);
        const auto value = read_file_object<value_block_t>(file, MAIN_ROOT_OFFSET + offset);

        std::string value_name(value.name, std::min(value.name_len, static_cast<int16_t>(sizeof(value.name))));

        raw_hive_value raw_value{};
        raw_value.parsed = false;
        raw_value.type = value.value_type;
        raw_value.name = value_name;
        raw_value.data_length = value.size & 0xffff;
        raw_value.data_offset = value.offset + 4;

        if (value.size & 1 << 31)
        {
            raw_value.data_offset = offset + static_cast<int>(offsetof(value_block_t, offset));
        }

        const auto [it, inserted] = this->values_.emplace(std::move(value_name), std::move(raw_value));
        if (inserted)
        {
            this->values_by_index_.emplace_back(it->first);
        }
    }

    // Subkeys

    const auto item = read_file_object<offsets_t>(file, MAIN_ROOT_OFFSET + this->subkey_block_offset_);

    if (item.block_type[1] != 'f' && item.block_type[1] != 'h')
    {
        return;
    }

    const auto entry_offsets = this->subkey_block_offset_ + offsetof(offsets_t, entries);

    for (int16_t i = 0; i < item.count; ++i)
    {
        const auto offset_entry = read_file_object<offset_entry_t>(file, MAIN_ROOT_OFFSET + entry_offsets, i);

        const auto subkey_block_offset = MAIN_ROOT_OFFSET + offset_entry.offset;
        const auto subkey = read_file_object<key_block_t>(file, subkey_block_offset);

        std::string subkey_name(subkey.name, std::min(subkey.len, static_cast<int16_t>(sizeof(subkey.name))));

        const auto [it, inserted] =
            this->sub_keys_.emplace(std::move(subkey_name), hive_key{subkey.subkeys, subkey.value_count, subkey.offsets});
        if (inserted)
        {
            this->sub_keys_by_index_.emplace_back(it->first);
        }
    }
}

hive_parser::hive_parser(const std::filesystem::path& file_path)
    : file_(file_path, std::ios::binary),
      root_key_(parse_root_block(file_, file_path))
{
}

```

`src/windows-emulator/registry/hive_parser.hpp`:

```hpp
#pragma once

#include <ranges>
#include <fstream>
#include <algorithm>

#include <utils/container.hpp>
#include <platform/unicode.hpp>

struct hive_value
{
    uint32_t type{};
    std::string name{};
    std::vector<std::byte> data{};
};

class hive_key
{
  public:
    hive_key(const int subkey_block_offset, const int value_count, const int value_offsets)
        : subkey_block_offset_(subkey_block_offset),
          value_count_(value_count),
          value_offsets_(value_offsets)
    {
    }

    utils::unordered_insensitive_string_map<hive_key>& get_sub_keys(std::ifstream& file)
    {
        this->parse(file);
        return this->sub_keys_;
    }

    const std::string_view* get_sub_key_name(std::ifstream& file, size_t index)
    {
        this->parse(file);

        if (index >= sub_keys_by_index_.size())
        {
            return nullptr;
        }

        return &sub_keys_by_index_[index];
    }

    hive_key* get_sub_key(std::ifstream& file, const std::string_view name)
    {
        auto& sub_keys = this->get_sub_keys(file);
        const auto entry = sub_keys.find(name);

        if (entry == sub_keys.end())
        {
            return nullptr;
        }

        return &entry->second;
    }

    hive_key* get_sub_key(std::ifstream& file, size_t index)
    {
        return get_sub_key(file, *this->get_sub_key_name(file, index));
    }

    const hive_value* get_value(std::ifstream& file, std::string_view name);
    const hive_value* get_value(std::ifstream& file, size_t index);

    size_t get_sub_key_count(std::ifstream& file)
    {
        this->parse(file);
        return this->sub_keys_.size();
    }

    size_t get_value_count(std::ifstream& file)
    {
        this->parse(file);
        return this->values_.size();
    }

  private:
    struct raw_hive_value : hive_value
    {
        bool parsed{false};
        int data_offset{};
        size_t data_length{};
    };

    bool parsed_{false};
    utils::unordered_insensitive_string_map<hive_key> sub_keys_{};
    std::vector<std::string_view> sub_keys_by_index_{};
    utils::unordered_insensitive_string_map<raw_hive_value> values_{};
    std::vector<std::string_view> values_by_index_{};

    const int subkey_block_offset_{};
    const int value_count_{};
    const int value_offsets_{};

    void parse(std::ifstream& file);
};

class hive_parser
{
  public:
    explicit hive_parser(const std::filesystem::path& file_path);

    [[nodiscard]] hive_key* get_sub_key(const std::filesystem::path& key)
    {
        hive_key* current_key = &this->root_key_;

        for (const auto& key_part : key)
        {
            if (key_part.empty())
            {
                continue;
            }

            if (!current_key)
            {
                return nullptr;
            }

            current_key = current_key->get_sub_key(this->file_, u16_to_u8(key_part.u16string()));
        }

        return current_key;
    }

    [[nodiscard]] const std::string_view* get_sub_key_name(const std::filesystem::path& key, size_t index)
    {
        auto* target_key = this->get_sub_key(key);
        if (!target_key)
        {
            return nullptr;
        }

        return target_key->get_sub_key_name(this->file_, index);
    }

    [[nodiscard]] const hive_value* get_value(const std::filesystem::path& key, const std::string_view name)
    {
        auto* sub_key = this->get_sub_key(key);
        if (!sub_key)
        {
            return nullptr;
        }

        return sub_key->get_value(this->file_, name);
    }

    [[nodiscard]] const hive_value* get_value(const std::filesystem::path& key, size_t index)
    {
        auto* sub_key = this->get_sub_key(key);
        if (!sub_key)
        {
            return nullptr;
        }

        return sub_key->get_value(this->file_, index);
    }

    std::ifstream& get_file()
    {
        return this->file_;
    }

  private:
    std::ifstream file_{};
    hive_key root_key_;
};

```

`src/windows-emulator/registry/registry_manager.cpp`:

```cpp
#include "../std_include.hpp"
#include "registry_manager.hpp"

#include <serialization_helper.hpp>

#include "hive_parser.hpp"

namespace
{
    bool is_subpath(const utils::path_key& root, const utils::path_key& p)
    {
        auto root_it = root.get().begin();
        auto p_it = p.get().begin();

        for (; root_it != root.get().end(); ++root_it, ++p_it)
        {
            if (p_it == p.get().end() || *root_it != *p_it)
            {
                return false;
            }
        }

        return true;
    }

    void register_hive(registry_manager::hive_map& hives, const utils::path_key& key, const std::filesystem::path& file)
    {
        hives[key] = std::make_unique<hive_parser>(file);
    }

    void register_optional_hive(registry_manager::hive_map& hives, const utils::path_key& key, const std::filesystem::path& file)
    {
        if (!std::filesystem::is_regular_file(file))
        {
            return;
        }

        hives[key] = std::make_unique<hive_parser>(file);
    }

    std::pair<utils::path_key, bool> perform_path_substitution(const std::unordered_map<utils::path_key, utils::path_key>& path_mapping,
                                                               utils::path_key path)
    {
        for (const auto& mapping : path_mapping)
        {
            if (path == mapping.first)
            {
                return {mapping.second, true};
            }

            if (is_subpath(mapping.first.get(), path.get()))
            {
                return {mapping.second.get() / path.get().lexically_relative(mapping.first.get()), true};
            }
        }

        return {std::move(path), false};
    }
}

registry_manager::registry_manager() = default;
registry_manager::~registry_manager() = default;
registry_manager::registry_manager(registry_manager&&) noexcept = default;
registry_manager& registry_manager::operator=(registry_manager&&) noexcept = default;

registry_manager::registry_manager(const std::filesystem::path& hive_path)
    : hive_path_(absolute(hive_path))
{
    this->setup();
}

void registry_manager::setup()
{
    this->path_mapping_.clear();
    this->hives_.clear();

    const std::filesystem::path root = R"(\registry)";
    const std::filesystem::path machine = root / "machine";

    register_hive(this->hives_, machine / "system", this->hive_path_ / "SYSTEM");
    register_hive(this->hives_, machine / "security", this->hive_path_ / "SECURITY");
    register_hive(this->hives_, machine / "sam", this->hive_path_ / "SAM");
    register_hive(this->hives_, machine / "software", this->hive_path_ / "SOFTWARE");
    register_hive(this->hives_, machine / "system", this->hive_path_ / "SYSTEM");
    register_optional_hive(this->hives_, machine / "hardware", this->hive_path_ / "HARDWARE");

    register_hive(this->hives_, root / "user", this->hive_path_ / "NTUSER.DAT");

    this->add_path_mapping(machine / "system" / "CurrentControlSet", machine / "system" / "ControlSet001");
    this->add_path_mapping(machine / "system" / "ControlSet001" / "Control" / "ComputerName" / "ActiveComputerName",
                           machine / "system" / "ControlSet001" / "Control" / "ComputerName" / "ComputerName");
}

utils::path_key registry_manager::normalize_path(utils::path_key path) const
{
    for (size_t i = 0; i < 10; ++i)
    {
        auto [new_path, changed] = perform_path_substitution(this->path_mapping_, std::move(path));
        path = std::move(new_path);

        if (!changed)
        {
            break;
        }
    }

    return path;
}

void registry_manager::add_path_mapping(const utils::path_key& key, const utils::path_key& value)
{
    this->path_mapping_[key] = value;
}

std::optional<registry_key> registry_manager::get_key(const utils::path_key& key)
{
    const auto normal_key = this->normalize_path(key);

    if (is_subpath(normal_key, utils::path_key{"\\registry\\machine"}))
    {
        registry_key reg_key{};
        reg_key.hive = normal_key;
        return {std::move(reg_key)};
    }

    const auto iterator = this->find_hive(normal_key);
    if (iterator == this->hives_.end())
    {
        return {};
    }

    registry_key reg_key{};
    reg_key.hive = iterator->first.get();
    reg_key.path = normal_key.get().lexically_relative(reg_key.hive.get());

    if (reg_key.path.get().empty())
    {
        return {std::move(reg_key)};
    }

    auto path = reg_key.path.get();
    const auto* entry = iterator->second->get_sub_key(path);

    if (!entry)
    {
        constexpr std::wstring_view wowPrefix = L"wow6432node";

        const auto pathStr = path.wstring();
        if (pathStr.starts_with(wowPrefix))
        {
            path = pathStr.substr(wowPrefix.size() + 1);
            reg_key.path = path;
            entry = iterator->second->get_sub_key(path);
        }
    }

    if (!entry)
    {
        return std::nullopt;
    }

    return {std::move(reg_key)};
}

std::optional<registry_value> registry_manager::get_value(const registry_key& key, const std::string_view name)
{
    const auto iterator = this->hives_.find(key.hive);
    if (iterator == this->hives_.end())
    {
        return std::nullopt;
    }

    const auto* entry = iterator->second->get_value(key.path.get(), name);
    if (!entry)
    {
        return std::nullopt;
    }

    registry_value v{};
    v.type = entry->type;
    v.name = entry->name;
    v.data = entry->data;

    return v;
}

std::optional<registry_value> registry_manager::get_value(const registry_key& key, const size_t index)
{
    const auto iterator = this->hives_.find(key.hive);
    if (iterator == this->hives_.end())
    {
        return std::nullopt;
    }

    const auto* entry = iterator->second->get_value(key.path.get(), index);
    if (!entry)
    {
        return std::nullopt;
    }

    registry_value v{};
    v.type = entry->type;
    v.name = entry->name;
    v.data = entry->data;

    return v;
}

registry_manager::hive_map::iterator registry_manager::find_hive(const utils::path_key& key)
{
    for (auto i = this->hives_.begin(); i != this->hives_.end(); ++i)
    {
        if (is_subpath(i->first, key))
        {
            return i;
        }
    }

    return this->hives_.end();
}

std::optional<exposed_hive_key> registry_manager::get_hive_key(const registry_key& key)
{
    const auto iterator = this->hives_.find(key.hive);
    if (iterator == this->hives_.end())
    {
        return std::nullopt;
    }

    auto* hive_key = iterator->second->get_sub_key(key.path.get());
    if (!hive_key)
    {
        return std::nullopt;
    }

    return exposed_hive_key{
        .key = *hive_key,
        .file = iterator->second->get_file(),
    };
}

std::optional<std::string_view> registry_manager::get_sub_key_name(const registry_key& key, const size_t index)
{
    const auto iterator = this->hives_.find(key.hive);
    if (iterator == this->hives_.end())
    {
        return std::nullopt;
    }

    const auto* name = iterator->second->get_sub_key_name(key.path.get(), index);
    if (!name)
    {
        return std::nullopt;
    }

    return *name;
}

std::optional<std::u16string> registry_manager::read_u16string(const registry_key& key, size_t index)
{
    const auto value_opt = this->get_value(key, index);
    if (!value_opt)
    {
        return {};
    }

    const auto& value = value_opt.value();

    if (value.type != REG_SZ && value.type != REG_EXPAND_SZ)
    {
        return {};
    }

    if (value.data.empty() || value.data.size() % 2 != 0)
    {
        return {};
    }

    const auto char_count = value.data.size() / sizeof(char16_t);
    const auto* data_ptr = reinterpret_cast<const char16_t*>(value.data.data());
    if (data_ptr[char_count - 1] != u'\0')
    {
        return {};
    }

    auto s = std::u16string(data_ptr, char_count - 1);
    return s;
}

```

`src/windows-emulator/registry/registry_manager.hpp`:

```hpp
#pragma once

#include "../std_include.hpp"
#include "hive_parser.hpp"
#include "serialization_helper.hpp"
#include "../handles.hpp"

#ifndef OS_WINDOWS
#define REG_NONE (0ul) // No value type
#define REG_SZ   (1ul) // Unicode nul terminated string
#define REG_EXPAND_SZ \
    (2ul)                                    // Unicode nul terminated string
                                             // (with environment variable references)
#define REG_BINARY                     (3ul) // Free form binary
#define REG_DWORD                      (4ul) // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN        (4ul) // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN           (5ul) // 32-bit number
#define REG_LINK                       (6ul) // Symbolic Link (unicode)
#define REG_MULTI_SZ                   (7ul) // Multiple Unicode strings
#define REG_RESOURCE_LIST              (8ul) // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR   (9ul) // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST (10ul)
#define REG_QWORD                      (11ul) // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN        (11ul) // 64-bit number (same as REG_QWORD)
#endif

struct registry_key : ref_counted_object
{
    utils::path_key hive{};
    utils::path_key path{};

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->hive);
        buffer.write(this->path);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->hive);
        buffer.read(this->path);
    }

    std::u16string to_string() const
    {
        return this->hive.get().u16string() + u"\\" + this->path.get().u16string();
    }
};

struct registry_value
{
    uint32_t type;
    std::string_view name;
    std::span<const std::byte> data;
};

struct exposed_hive_key
{
    hive_key& key;
    std::ifstream& file;
};

class registry_manager
{
  public:
    using hive_ptr = std::unique_ptr<hive_parser>;
    using hive_map = std::unordered_map<utils::path_key, hive_ptr>;

    registry_manager();
    registry_manager(const std::filesystem::path& hive_path);
    ~registry_manager();

    registry_manager(registry_manager&&) noexcept;
    registry_manager& operator=(registry_manager&&) noexcept;

    registry_manager(const registry_manager&) = delete;
    registry_manager& operator=(const registry_manager&) = delete;

    std::optional<registry_key> get_key(const utils::path_key& key);
    std::optional<registry_value> get_value(const registry_key& key, std::string_view name);
    std::optional<registry_value> get_value(const registry_key& key, size_t index);

    std::optional<std::string_view> get_sub_key_name(const registry_key& key, size_t index);

    std::optional<exposed_hive_key> get_hive_key(const registry_key& key);

    std::optional<std::u16string> read_u16string(const registry_key& key, size_t index);

  private:
    std::filesystem::path hive_path_{};
    hive_map hives_{};
    std::unordered_map<utils::path_key, utils::path_key> path_mapping_{};

    utils::path_key normalize_path(utils::path_key path) const;
    void add_path_mapping(const utils::path_key& key, const utils::path_key& value);

    hive_map::iterator find_hive(const utils::path_key& key);

    void setup();
};

```

`src/windows-emulator/std_include.hpp`:

```hpp
#pragma once

#include <map>
#include <set>
#include <list>
#include <span>
#include <array>
#include <deque>
#include <queue>
#include <thread>
#include <ranges>
#include <atomic>
#include <vector>
#include <mutex>
#include <string>
#include <chrono>
#include <memory>
#include <fstream>
#include <functional>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <string_view>
#include <unordered_set>
#include <unordered_map>
#include <condition_variable>

#include <cassert>
#include <cstdarg>
#include <cinttypes>

#include "platform/platform.hpp"

// NOLINTNEXTLINE(google-global-names-in-headers)
using namespace std::literals;

```

`src/windows-emulator/syscall_dispatcher.cpp`:

```cpp
#include "std_include.hpp"
#include "syscall_dispatcher.hpp"
#include "syscall_utils.hpp"

static void serialize(utils::buffer_serializer& buffer, const syscall_handler_entry& obj)
{
    buffer.write(obj.name);
}

static void deserialize(utils::buffer_deserializer& buffer, syscall_handler_entry& obj)
{
    buffer.read(obj.name);
    obj.handler = nullptr;
}

void syscall_dispatcher::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write_map(this->handlers_);
}

void syscall_dispatcher::deserialize(utils::buffer_deserializer& buffer)
{
    buffer.read_map(this->handlers_);
    this->add_handlers();
    this->add_callbacks();
}

void syscall_dispatcher::setup(const exported_symbols& ntdll_exports, const std::span<const std::byte> ntdll_data,
                               const exported_symbols& win32u_exports, const std::span<const std::byte> win32u_data)
{
    this->handlers_ = {};

    const auto ntdll_syscalls = find_syscalls(ntdll_exports, ntdll_data);
    const auto win32u_syscalls = find_syscalls(win32u_exports, win32u_data);

    map_syscalls(this->handlers_, ntdll_syscalls);
    map_syscalls(this->handlers_, win32u_syscalls);

    this->add_handlers();
    this->add_callbacks();
}

void syscall_dispatcher::add_handlers()
{
    std::map<std::string, syscall_handler> handler_mapping{};
    syscall_dispatcher::add_handlers(handler_mapping);

    for (auto& entry : this->handlers_ | std::views::values)
    {
        const auto handler = handler_mapping.find(entry.name);
        if (handler == handler_mapping.end())
        {
            continue;
        }

        entry.handler = handler->second;

#ifndef NDEBUG
        handler_mapping.erase(handler);
#endif
    }
}

void syscall_dispatcher::dispatch(windows_emulator& win_emu)
{
    auto& emu = win_emu.emu();
    auto& context = win_emu.process;

    const auto address = emu.read_instruction_pointer();
    const auto raw_syscall_id = emu.reg<uint32_t>(x86_register::eax);
    const auto syscall_id = raw_syscall_id & 0xFFFF; // Only take low bits for WOW64 compatibility

    const auto entry = this->handlers_.find(syscall_id);
    const auto* syscall_name = (entry != this->handlers_.end()) ? entry->second.name.c_str() : "<unknown>";

    const syscall_context c{
        .win_emu = win_emu,
        .emu = emu,
        .proc = context,
        .write_status = true,
    };

    try
    {
        if (entry == this->handlers_.end())
        {
            win_emu.log.error("Unknown syscall: 0x%X (raw: 0x%X)\n", syscall_id, raw_syscall_id);
            c.emu.reg<uint64_t>(x86_register::rax, STATUS_NOT_SUPPORTED);
            c.emu.stop();
            return;
        }

        const auto res = win_emu.callbacks.on_syscall(syscall_id, entry->second.name);
        if (res == instruction_hook_continuation::skip_instruction)
        {
            return;
        }

        if (!entry->second.handler)
        {
            win_emu.log.error("Unimplemented syscall: %s - 0x%X (raw: 0x%X)\n", entry->second.name.c_str(), syscall_id, raw_syscall_id);
            c.emu.reg<uint64_t>(x86_register::rax, STATUS_NOT_SUPPORTED);
            c.emu.stop();
            return;
        }

        entry->second.handler(c);

        dispatch_callback(win_emu, entry->second.name);
    }
    catch (std::exception& e)
    {
        win_emu.log.error("Syscall %s threw an exception: 0x%X (raw: 0x%X) (0x%" PRIx64 ") - %s\n", syscall_name, syscall_id,
                          raw_syscall_id, address, e.what());
        emu.reg<uint64_t>(x86_register::rax, STATUS_UNSUCCESSFUL);
        emu.stop();
    }
    catch (...)
    {
        win_emu.log.error("Syscall %s threw an unknown exception: 0x%X (raw: 0x%X) (0x%" PRIx64 ")\n", syscall_name, syscall_id,
                          raw_syscall_id, address);
        emu.reg<uint64_t>(x86_register::rax, STATUS_UNSUCCESSFUL);
        emu.stop();
    }
}

void syscall_dispatcher::dispatch_callback(windows_emulator& win_emu, std::string& syscall_name)
{
    auto& emu = win_emu.emu();
    auto& context = win_emu.process;

    if (context.instrumentation_callback != 0 && syscall_name != "NtContinue")
    {
        auto rip_old = emu.reg<uint64_t>(x86_register::rip);

        // The increase in RIP caused by executing the syscall here has not yet occurred.
        // If RIP is set directly, it will lead to an incorrect address, so the length of
        // the syscall instruction needs to be subtracted.
        emu.reg<uint64_t>(x86_register::rip, context.instrumentation_callback - 2);

        emu.reg<uint64_t>(x86_register::r10, rip_old);
    }
}

dispatch_result syscall_dispatcher::dispatch_completion(windows_emulator& win_emu, callback_id callback_id,
                                                        completion_state* completion_state, uint64_t callback_result)
{
    auto& emu = win_emu.emu();

    const syscall_context c{.win_emu = win_emu,
                            .emu = emu,
                            .proc = win_emu.process,
                            .write_status = true,
                            .is_callback_completion = true,
                            .current_completion_state = completion_state,
                            .previous_callback_result = callback_result};

    const auto entry = this->completion_handlers_.find(callback_id);

    if (entry == this->completion_handlers_.end())
    {
        win_emu.log.error("Unknown callback: 0x%X\n", static_cast<uint32_t>(callback_id));
        c.emu.stop();
        return dispatch_result::error;
    }

    try
    {
        entry->second(c);
        return c.run_callback ? dispatch_result::new_callback : dispatch_result::completed;
    }
    catch (std::exception& e)
    {
        win_emu.log.error("Completion for callback 0x%X threw an exception - %s\n", static_cast<int>(callback_id), e.what());
        emu.stop();
        return dispatch_result::error;
    }
    catch (...)
    {
        win_emu.log.error("Completion for callback 0x%X threw an unknown exception\n", static_cast<int>(callback_id));
        emu.stop();
        return dispatch_result::error;
    }
}

syscall_dispatcher::syscall_dispatcher(const exported_symbols& ntdll_exports, const std::span<const std::byte> ntdll_data,
                                       const exported_symbols& win32u_exports, const std::span<const std::byte> win32u_data)
{
    this->setup(ntdll_exports, ntdll_data, win32u_exports, win32u_data);
}

std::map<callback_id, std::function<std::unique_ptr<completion_state>()>> syscall_dispatcher::completion_state_factories_{};

```

`src/windows-emulator/syscall_dispatcher.hpp`:

```hpp
#pragma once

#include "process_context.hpp"

struct syscall_context;
using syscall_handler = void (*)(const syscall_context& c);

struct syscall_handler_entry
{
    syscall_handler handler{};
    std::string name{};
};

enum class dispatch_result
{
    completed,
    new_callback,
    error
};

struct completion_state
{
    virtual ~completion_state() = default;

    void serialize(utils::buffer_serializer& buffer) const
    {
        this->serialize_object(buffer);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        this->deserialize_object(buffer);
    }

  private:
    virtual void serialize_object(utils::buffer_serializer&) const
    {
    }

    virtual void deserialize_object(utils::buffer_deserializer&)
    {
    }
};

struct window_create_state : completion_state
{
    hwnd handle{};

    emulator_stack_allocation min_max_info_alloc{};
    emulator_stack_allocation window_rect_alloc{};
    emulator_stack_allocation create_struct_alloc{};
    emulator_stack_allocation window_pos_alloc{};

    std::vector<qmsg> message_queue{};

  private:
    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->handle);
        buffer.write(this->min_max_info_alloc);
        buffer.write(this->window_rect_alloc);
        buffer.write(this->create_struct_alloc);
        buffer.write(this->window_pos_alloc);
        buffer.write_vector(this->message_queue);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->handle);
        buffer.read(this->min_max_info_alloc);
        buffer.read(this->window_rect_alloc);
        buffer.read(this->create_struct_alloc);
        buffer.read(this->window_pos_alloc);
        buffer.read_vector(this->message_queue);
    }
};

struct window_destroy_state : completion_state
{
    emulator_stack_allocation window_pos_alloc{};
    std::vector<qmsg> message_queue{};

  private:
    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->window_pos_alloc);
        buffer.write_vector(this->message_queue);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->window_pos_alloc);
        buffer.read_vector(this->message_queue);
    }
};

struct window_show_state : completion_state
{
    bool was_visible{};
    emulator_stack_allocation window_pos_alloc{};
    std::vector<qmsg> message_queue{};

  private:
    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->was_visible);
        buffer.write(this->window_pos_alloc);
        buffer.write_vector(this->message_queue);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->was_visible);
        buffer.read(this->window_pos_alloc);
        buffer.read_vector(this->message_queue);
    }
};

class windows_emulator;

class syscall_dispatcher
{
  public:
    syscall_dispatcher() = default;
    syscall_dispatcher(const exported_symbols& ntdll_exports, std::span<const std::byte> ntdll_data, const exported_symbols& win32u_exports,
                       std::span<const std::byte> win32u_data);

    void dispatch(windows_emulator& win_emu);
    static void dispatch_callback(windows_emulator& win_emu, std::string& syscall_name);
    dispatch_result dispatch_completion(windows_emulator& win_emu, callback_id callback_id, completion_state* completion_state,
                                        uint64_t callback_result);

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);

    void setup(const exported_symbols& ntdll_exports, std::span<const std::byte> ntdll_data, const exported_symbols& win32u_exports,
               std::span<const std::byte> win32u_data);

    std::string get_syscall_name(const uint64_t id)
    {
        return this->handlers_.at(id).name;
    }

    static std::unique_ptr<completion_state> create_completion_state(callback_id id)
    {
        if (auto it = completion_state_factories_.find(id); it != completion_state_factories_.end())
        {
            return it->second();
        }
        return {};
    }

  private:
    std::map<uint64_t, syscall_handler_entry> handlers_{};
    std::map<callback_id, syscall_handler> completion_handlers_;
    static std::map<callback_id, std::function<std::unique_ptr<completion_state>()>> completion_state_factories_;

    static void add_handlers(std::map<std::string, syscall_handler>& handler_mapping);
    void add_handlers();
    void add_callbacks();
};

```

`src/windows-emulator/syscall_utils.hpp`:

```hpp
#pragma once

#include "windows_emulator.hpp"
#include <ctime>
#include <platform/primitives.hpp>
#include "devices/named_pipe.hpp"

struct completion_state;

struct syscall_context
{
    windows_emulator& win_emu;
    x86_64_emulator& emu;
    process_context& proc;
    mutable bool write_status{true};
    mutable bool retrigger_syscall{false};

    mutable bool run_callback{false};
    bool is_callback_completion{false};
    completion_state* current_completion_state{};
    uint64_t previous_callback_result{};

    template <typename T>
    T get_callback_result() const
    {
        if (!this->is_callback_completion)
        {
            throw std::runtime_error("Attempted to get callback result in a non-completion context");
        }
        return static_cast<T>(this->previous_callback_result);
    }

    template <typename T>
    T& get_completion_state() const
    {
        if (!this->is_callback_completion)
        {
            throw std::runtime_error("Attempted to get callback state in a non-completion context");
        }
        if (!this->current_completion_state)
        {
            throw std::runtime_error("No state object was assigned to this completion");
        }
        return dynamic_cast<T&>(*this->current_completion_state);
    }
};

inline uint64_t get_syscall_argument(x86_64_emulator& emu, const size_t index)
{
    return get_function_argument(emu, index, true);
}

inline bool is_uppercase(const char character)
{
    return toupper(character) == character;
}

inline bool is_syscall(const std::string_view name)
{
    return name.starts_with("Nt") && name.size() > 3 && is_uppercase(name[2]);
}

inline bool is_named_pipe_path(const std::u16string_view& filename)
{
    return filename == u"\\Device\\NamedPipe\\" || filename.starts_with(u"\\Device\\NamedPipe\\") || filename.starts_with(u"\\??\\pipe\\");
}

inline std::optional<uint32_t> extract_syscall_id(const exported_symbol& symbol, std::span<const std::byte> data)
{
    if (!is_syscall(symbol.name))
    {
        return std::nullopt;
    }

    constexpr auto instruction_size = 5;
    constexpr auto instruction_offset = 3;
    constexpr auto instruction_operand_offset = 1;
    constexpr auto instruction_opcode = static_cast<std::byte>(0xB8);

    const auto instruction_rva = symbol.rva + instruction_offset;

    if (data.size() < (instruction_rva + instruction_size) || data[static_cast<size_t>(instruction_rva)] != instruction_opcode)
    {
        return std::nullopt;
    }

    uint32_t syscall_id{0};
    static_assert(sizeof(syscall_id) <= (instruction_size - instruction_operand_offset));
    memcpy(&syscall_id, data.data() + instruction_rva + instruction_operand_offset, sizeof(syscall_id));

    return syscall_id;
}

inline std::map<uint64_t, std::string> find_syscalls(const exported_symbols& exports, std::span<const std::byte> data)
{
    std::map<uint64_t, std::string> syscalls{};

    for (const auto& symbol : exports)
    {
        const auto id = extract_syscall_id(symbol, data);
        if (id)
        {
            auto& entry = syscalls[*id];

            if (!entry.empty())
            {
                throw std::runtime_error("Syscall with id " + std::to_string(*id) + ", which is mapping to " + symbol.name +
                                         ", was already mapped to " + entry);
            }

            entry = symbol.name;
        }
    }

    return syscalls;
}

inline void map_syscalls(std::map<uint64_t, syscall_handler_entry>& handlers, std::map<uint64_t, std::string> syscalls)
{
    for (auto& [id, name] : syscalls)
    {
        auto& entry = handlers[id];

        if (!entry.name.empty())
        {
            throw std::runtime_error("Syscall with id " + std::to_string(id) + ", which is mapping to " + name +
                                     ", was previously mapped to " + entry.name);
        }

        entry.name = std::move(name);
        entry.handler = nullptr;
    }
}

template <typename T>
    requires(std::is_integral_v<T> || std::is_enum_v<T>)
T resolve_argument(x86_64_emulator& emu, const size_t index)
{
    const auto arg = get_syscall_argument(emu, index);
    return static_cast<T>(arg);
}

template <typename T>
    requires(std::is_same_v<std::remove_cvref_t<T>, handle>)
handle resolve_argument(x86_64_emulator& emu, const size_t index)
{
    handle h{};
    h.bits = resolve_argument<uint64_t>(emu, index);
    return h;
}

template <typename T>
    requires(std::is_same_v<T, emulator_object<typename T::value_type>>)
T resolve_argument(x86_64_emulator& emu, const size_t index)
{
    const auto arg = get_syscall_argument(emu, index);
    return T(emu, arg);
}

template <typename T>
T resolve_indexed_argument(x86_64_emulator& emu, size_t& index)
{
    return resolve_argument<T>(emu, index++);
}

inline void write_syscall_result(const syscall_context& c, const uint64_t result, const uint64_t initial_ip)
{
    if (c.write_status && !c.retrigger_syscall && !c.run_callback)
    {
        c.emu.reg<uint64_t>(x86_register::rax, result);
    }

    const auto new_ip = c.emu.read_instruction_pointer();
    if ((initial_ip != new_ip || c.retrigger_syscall || c.run_callback) && !c.is_callback_completion)
    {
        c.emu.reg(x86_register::rip, new_ip - 2);
    }
}

template <typename Result>
void forward_syscall(const syscall_context& c, Result (*handler)())
{
    const auto ip = c.emu.read_instruction_pointer();

    const auto ret = handler();
    write_syscall_result(c, static_cast<uint64_t>(ret), ip);
}

template <typename Result, typename... Args>
void forward_syscall(const syscall_context& c, Result (*handler)(const syscall_context&, Args...))
{
    const auto ip = c.emu.read_instruction_pointer();

    size_t index = 0;
    std::tuple<const syscall_context&, Args...> func_args{
        c, resolve_indexed_argument<std::remove_cv_t<std::remove_reference_t<Args>>>(c.emu, index)...};

    (void)index;

    const auto ret = std::apply(handler, std::move(func_args));
    write_syscall_result(c, ret, ip);
}

template <auto Handler>
syscall_handler make_syscall_handler()
{
    return +[](const syscall_context& c) { forward_syscall(c, Handler); };
}

template <typename T, typename Traits>
void write_attribute(emulator& emu, const PS_ATTRIBUTE<Traits>& attribute, const T& value)
{
    if (attribute.ReturnLength)
    {
        emulator_object<typename Traits::SIZE_T>{emu, attribute.ReturnLength}.write(sizeof(T));
    }

    if (attribute.Size >= sizeof(T))
    {
        emulator_object<T>{emu, attribute.Value}.write(value);
    }
}

template <typename ResponseType, typename Action, typename ReturnLengthSetter>
NTSTATUS handle_query_internal(x86_64_emulator& emu, const uint64_t buffer, const uint32_t length,
                               const ReturnLengthSetter& return_length_setter, const Action& action)
{
    constexpr auto required_size = sizeof(ResponseType);
    return_length_setter(required_size);

    if (length < required_size)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ResponseType obj{};
    NTSTATUS result = STATUS_SUCCESS;

    using action_result = std::invoke_result_t<Action, ResponseType&>;

    if constexpr (std::is_same_v<NTSTATUS, action_result>)
    {
        result = action(obj);
    }
    else
    {
        action(obj);
    }

    if (result == STATUS_SUCCESS)
    {
        emu.write_memory(buffer, obj);
    }

    return result;
}

template <typename ResponseType, typename Action, typename LengthType>
    requires(std::is_integral_v<LengthType>)
NTSTATUS handle_query(x86_64_emulator& emu, const uint64_t buffer, const uint32_t length, const emulator_object<LengthType> return_length,
                      const Action& action)
{
    const auto length_setter = [&](const size_t required_size) {
        if (return_length)
        {
            return_length.try_write(static_cast<LengthType>(required_size));
        }
    };

    return handle_query_internal<ResponseType>(emu, buffer, length, length_setter, action);
}

template <typename ResponseType, typename Action>
NTSTATUS handle_query(x86_64_emulator& emu, const uint64_t buffer, const uint32_t length,
                      const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, const Action& action)
{
    IO_STATUS_BLOCK<EmulatorTraits<Emu64>> status_block{};

    const auto length_setter = [&](const EmulatorTraits<Emu64>::ULONG_PTR required_size) {
        status_block.Information = required_size; //
    };

    status_block.Status = handle_query_internal<ResponseType>(emu, buffer, length, length_setter, action);

    if (io_status_block)
    {
        io_status_block.write(status_block);
    }

    return status_block.Status;
}

```

`src/windows-emulator/syscalls.cpp`:

```cpp
#include "std_include.hpp"
#include "syscall_dispatcher.hpp"
#include "cpu_context.hpp"
#include "emulator_utils.hpp"
#include "syscall_utils.hpp"

#include <numeric>
#include <cwctype>
#include <algorithm>
#include <utils/time.hpp>
#include <utils/finally.hpp>

namespace syscalls
{
    // syscalls/event.cpp:
    NTSTATUS handle_NtSetEvent(const syscall_context& c, uint64_t handle, emulator_object<LONG> previous_state);
    NTSTATUS handle_NtTraceEvent();
    NTSTATUS handle_NtQueryEvent(const syscall_context& c, handle event_handle, uint32_t event_information_class,
                                 emulator_object<EVENT_BASIC_INFORMATION> event_information, uint32_t event_information_length,
                                 emulator_object<uint32_t> return_length);
    NTSTATUS handle_NtClearEvent(const syscall_context& c, handle event_handle);
    NTSTATUS handle_NtCreateEvent(const syscall_context& c, emulator_object<handle> event_handle, ACCESS_MASK desired_access,
                                  emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, EVENT_TYPE event_type,
                                  BOOLEAN initial_state);
    NTSTATUS handle_NtOpenEvent(const syscall_context& c, emulator_object<uint64_t> event_handle, ACCESS_MASK desired_access,
                                emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);

    // syscalls/exception.cpp
    NTSTATUS handle_NtRaiseHardError(const syscall_context& c, NTSTATUS error_status, ULONG number_of_parameters,
                                     emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> unicode_string_parameter_mask,
                                     uint64_t parameters, HARDERROR_RESPONSE_OPTION valid_response_option,
                                     emulator_object<HARDERROR_RESPONSE> response);
    NTSTATUS handle_NtRaiseException(const syscall_context& c,
                                     emulator_object<EMU_EXCEPTION_RECORD<EmulatorTraits<Emu64>>> exception_record,
                                     emulator_object<CONTEXT64> thread_context, BOOLEAN handle_exception);

    // syscalls/file.cpp
    NTSTATUS handle_NtSetInformationFile(const syscall_context& c, handle file_handle,
                                         emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, uint64_t file_information,
                                         ULONG length, FILE_INFORMATION_CLASS info_class);
    NTSTATUS handle_NtQueryVolumeInformationFile(const syscall_context& c, handle file_handle,
                                                 emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                                 uint64_t fs_information, ULONG length, FS_INFORMATION_CLASS fs_information_class);
    NTSTATUS handle_NtQueryDirectoryFileEx(const syscall_context& c, handle file_handle, handle event_handle,
                                           EMULATOR_CAST(emulator_pointer, PIO_APC_ROUTINE) apc_routine, emulator_pointer apc_context,
                                           emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                           uint64_t file_information, uint32_t length, uint32_t info_class, ULONG query_flags,
                                           emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> file_name);
    NTSTATUS handle_NtQueryDirectoryFile(const syscall_context& c, handle file_handle, handle event_handle,
                                         EMULATOR_CAST(emulator_pointer, PIO_APC_ROUTINE) apc_routine, emulator_pointer apc_context,
                                         emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, uint64_t file_information,
                                         uint32_t length, uint32_t info_class, BOOLEAN return_single_entry,
                                         emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> file_name, BOOLEAN restart_scan);
    NTSTATUS handle_NtQueryInformationFile(const syscall_context& c, handle file_handle,
                                           emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                           uint64_t file_information, uint32_t length, uint32_t info_class);
    NTSTATUS handle_NtQueryInformationByName(const syscall_context& c,
                                             emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                             emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                             uint64_t file_information, uint32_t length, uint32_t info_class);
    NTSTATUS handle_NtReadFile(const syscall_context& c, handle file_handle, uint64_t /*event*/, uint64_t /*apc_routine*/,
                               uint64_t /*apc_context*/, emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                               uint64_t buffer, ULONG length, emulator_object<LARGE_INTEGER> /*byte_offset*/,
                               emulator_object<ULONG> /*key*/);
    NTSTATUS handle_NtWriteFile(const syscall_context& c, handle file_handle, uint64_t /*event*/, uint64_t /*apc_routine*/,
                                uint64_t /*apc_context*/, emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                uint64_t buffer, ULONG length, emulator_object<LARGE_INTEGER> /*byte_offset*/,
                                emulator_object<ULONG> /*key*/);
    NTSTATUS handle_NtCreateFile(const syscall_context& c, emulator_object<handle> file_handle, ACCESS_MASK desired_access,
                                 emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                 emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> /*io_status_block*/,
                                 emulator_object<LARGE_INTEGER> /*allocation_size*/, ULONG /*file_attributes*/, ULONG /*share_access*/,
                                 ULONG create_disposition, ULONG create_options, uint64_t ea_buffer, ULONG ea_length);
    NTSTATUS handle_NtQueryAttributesFile(const syscall_context& c,
                                          emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                          emulator_object<FILE_BASIC_INFORMATION> file_information);
    NTSTATUS handle_NtQueryFullAttributesFile(const syscall_context& c,
                                              emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                              emulator_object<FILE_NETWORK_OPEN_INFORMATION> file_information);
    NTSTATUS handle_NtOpenFile(const syscall_context& c, emulator_object<handle> file_handle, ACCESS_MASK desired_access,
                               emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                               emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, ULONG share_access,
                               ULONG open_options);
    NTSTATUS handle_NtOpenDirectoryObject(const syscall_context& c, emulator_object<handle> directory_handle,
                                          ACCESS_MASK /*desired_access*/,
                                          emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtCreateDirectoryObject(const syscall_context& /*c*/, emulator_object<handle> /*directory_handle*/,
                                            ACCESS_MASK /*desired_access*/,
                                            emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtOpenSymbolicLinkObject(const syscall_context& c, emulator_object<handle> link_handle, ACCESS_MASK /*desired_access*/,
                                             emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtQuerySymbolicLinkObject(const syscall_context& c, handle link_handle,
                                              emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> link_target,
                                              emulator_object<ULONG> returned_length);
    NTSTATUS handle_NtCreateNamedPipeFile(const syscall_context& c, emulator_object<handle> file_handle, ULONG desired_access,
                                          emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                          emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, ULONG share_access,
                                          ULONG create_disposition, ULONG create_options, ULONG named_pipe_type, ULONG read_mode,
                                          ULONG completion_mode, ULONG maximum_instances, ULONG inbound_quota, ULONG outbound_quota,
                                          emulator_object<LARGE_INTEGER> default_timeout);
    NTSTATUS handle_NtFsControlFile(const syscall_context& c, handle event_handle, uint64_t apc_routine, uint64_t app_context,
                                    emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, ULONG fs_control_code,
                                    uint64_t input_buffer, ULONG input_buffer_length, uint64_t output_buffer, ULONG output_buffer_length);
    NTSTATUS handle_NtFlushBuffersFile(const syscall_context& c, handle file_handle,
                                       emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> /*io_status_block*/);

    // syscalls/locale.cpp:
    NTSTATUS handle_NtInitializeNlsFiles(const syscall_context& c, emulator_object<uint64_t> base_address,
                                         emulator_object<LCID> default_locale_id,
                                         emulator_object<LARGE_INTEGER> /*default_casing_table_size*/);
    NTSTATUS handle_NtQueryDefaultLocale(const syscall_context&, BOOLEAN /*user_profile*/, emulator_object<LCID> default_locale_id);
    NTSTATUS handle_NtGetNlsSectionPtr(const syscall_context& c, ULONG section_type, ULONG section_data, emulator_pointer /*context_data*/,
                                       emulator_object<uint64_t> section_pointer, emulator_object<ULONG> section_size);
    NTSTATUS handle_NtGetMUIRegistryInfo();
    NTSTATUS handle_NtIsUILanguageComitted();
    NTSTATUS handle_NtUserGetKeyboardLayout();
    NTSTATUS handle_NtQueryDefaultUILanguage(const syscall_context&, emulator_object<LANGID> language_id);
    NTSTATUS handle_NtQueryInstallUILanguage(const syscall_context&, emulator_object<LANGID> language_id);

    // syscalls/memory.cpp:
    NTSTATUS handle_NtQueryVirtualMemory(const syscall_context& c, handle process_handle, uint64_t base_address, uint32_t info_class,
                                         uint64_t memory_information, uint64_t memory_information_length,
                                         emulator_object<uint64_t> return_length);
    NTSTATUS handle_NtProtectVirtualMemory(const syscall_context& c, handle process_handle, emulator_object<uint64_t> base_address,
                                           emulator_object<uint32_t> bytes_to_protect, uint32_t protection,
                                           emulator_object<uint32_t> old_protection);
    NTSTATUS handle_NtAllocateVirtualMemoryEx(const syscall_context& c, handle process_handle, emulator_object<uint64_t> base_address,
                                              emulator_object<uint64_t> bytes_to_allocate, uint32_t allocation_type,
                                              uint32_t page_protection);
    NTSTATUS handle_NtAllocateVirtualMemory(const syscall_context& c, handle process_handle, emulator_object<uint64_t> base_address,
                                            uint64_t zero_bits, emulator_object<uint64_t> bytes_to_allocate, uint32_t allocation_type,
                                            uint32_t page_protection);
    NTSTATUS handle_NtFreeVirtualMemory(const syscall_context& c, handle process_handle, emulator_object<uint64_t> base_address,
                                        emulator_object<uint64_t> bytes_to_allocate, uint32_t free_type);
    NTSTATUS handle_NtReadVirtualMemory(const syscall_context& c, handle process_handle, emulator_pointer base_address,
                                        emulator_pointer buffer, ULONG number_of_bytes_to_read,
                                        emulator_object<ULONG> number_of_bytes_read);
    NTSTATUS handle_NtWriteVirtualMemory(const syscall_context& c, handle process_handle, emulator_pointer base_address,
                                         emulator_pointer buffer, ULONG number_of_bytes_to_write,
                                         emulator_object<ULONG> number_of_bytes_write);
    NTSTATUS handle_NtSetInformationVirtualMemory();
    BOOL handle_NtLockVirtualMemory();

    // syscalls/mutant.cpp:
    NTSTATUS handle_NtReleaseMutant(const syscall_context& c, handle mutant_handle, emulator_object<LONG> previous_count);
    NTSTATUS handle_NtOpenMutant(const syscall_context& c, emulator_object<handle> mutant_handle, ACCESS_MASK desired_access,
                                 emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtCreateMutant(const syscall_context& c, emulator_object<handle> mutant_handle, ACCESS_MASK desired_access,
                                   emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, BOOLEAN initial_owner);

    // syscalls/object.cpp:
    NTSTATUS handle_NtClose(const syscall_context& c, handle h);
    NTSTATUS handle_NtDuplicateObject(const syscall_context& c, handle source_process_handle, handle source_handle,
                                      handle target_process_handle, emulator_object<handle> target_handle, ACCESS_MASK desired_access,
                                      ULONG handle_attributes, ULONG options);
    NTSTATUS handle_NtQueryObject(const syscall_context& c, handle handle, OBJECT_INFORMATION_CLASS object_information_class,
                                  emulator_pointer object_information, ULONG object_information_length,
                                  emulator_object<ULONG> return_length);
    NTSTATUS handle_NtCompareObjects(const syscall_context& c, handle first, handle second);
    NTSTATUS handle_NtWaitForMultipleObjects(const syscall_context& c, ULONG count, emulator_object<handle> handles, WAIT_TYPE wait_type,
                                             BOOLEAN alertable, emulator_object<LARGE_INTEGER> timeout);
    NTSTATUS handle_NtWaitForMultipleObjects32(const syscall_context& c, ULONG count, emulator_object<uint32_t> handles,
                                               WAIT_TYPE wait_type, BOOLEAN alertable, emulator_object<LARGE_INTEGER> timeout);
    NTSTATUS handle_NtWaitForSingleObject(const syscall_context& c, handle h, BOOLEAN alertable, emulator_object<LARGE_INTEGER> timeout);
    NTSTATUS handle_NtSetInformationObject();
    NTSTATUS handle_NtQuerySecurityObject(const syscall_context& c, handle /*h*/, SECURITY_INFORMATION /*security_information*/,
                                          emulator_pointer security_descriptor, ULONG length, emulator_object<ULONG> length_needed);
    NTSTATUS handle_NtSetSecurityObject();

    // syscalls/port.cpp:
    NTSTATUS handle_NtConnectPort(const syscall_context& c, emulator_object<handle> client_port_handle,
                                  emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> server_port_name,
                                  emulator_object<SECURITY_QUALITY_OF_SERVICE> /*security_qos*/,
                                  emulator_object<PORT_VIEW64> client_shared_memory,
                                  emulator_object<REMOTE_PORT_VIEW64> /*server_shared_memory*/,
                                  emulator_object<ULONG> /*maximum_message_length*/, emulator_pointer connection_info,
                                  emulator_object<ULONG> connection_info_length);
    NTSTATUS handle_NtSecureConnectPort(const syscall_context& c, emulator_object<handle> client_port_handle,
                                        emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> server_port_name,
                                        emulator_object<SECURITY_QUALITY_OF_SERVICE> security_qos,
                                        emulator_object<PORT_VIEW64> client_shared_memory, emulator_pointer /*server_sid*/,
                                        emulator_object<REMOTE_PORT_VIEW64> server_shared_memory,
                                        emulator_object<ULONG> maximum_message_length, emulator_pointer connection_info,
                                        emulator_object<ULONG> connection_info_length);
    NTSTATUS handle_NtAlpcConnectPort(const syscall_context& c, emulator_object<handle> port_handle,
                                      emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> server_port_name,
                                      emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> /*object_attributes*/,
                                      emulator_pointer /*port_attributes*/, ULONG /*flags*/, emulator_pointer /*required_server_sid*/,
                                      emulator_pointer /*connection_message*/,
                                      emulator_object<EmulatorTraits<Emu64>::SIZE_T> /*buffer_length*/,
                                      emulator_pointer /*out_message_attributes*/, emulator_pointer /*in_message_attributes*/,
                                      emulator_object<LARGE_INTEGER> /*timeout*/);
    NTSTATUS handle_NtAlpcConnectPortEx(const syscall_context& c, emulator_object<handle> port_handle,
                                        emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> connection_port_object_attributes,
                                        emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> /*client_port_object_attributes*/,
                                        emulator_pointer port_attributes, ULONG flags, emulator_pointer /*server_security_requirements*/,
                                        emulator_pointer connection_message, emulator_object<EmulatorTraits<Emu64>::SIZE_T> buffer_length,
                                        emulator_pointer out_message_attributes, emulator_pointer in_message_attributes,
                                        emulator_object<LARGE_INTEGER> timeout);
    NTSTATUS handle_NtAlpcSendWaitReceivePort(const syscall_context& c, handle port_handle, ULONG /*flags*/,
                                              emulator_object<PORT_MESSAGE64> send_message,
                                              emulator_object<ALPC_MESSAGE_ATTRIBUTES>
                                              /*send_message_attributes*/,
                                              emulator_object<PORT_MESSAGE64> receive_message,
                                              emulator_object<EmulatorTraits<Emu64>::SIZE_T> /*buffer_length*/,
                                              emulator_object<ALPC_MESSAGE_ATTRIBUTES>
                                              /*receive_message_attributes*/,
                                              emulator_object<LARGE_INTEGER> /*timeout*/);
    NTSTATUS handle_NtAlpcQueryInformation();
    NTSTATUS handle_NtAlpcSetInformation();
    NTSTATUS handle_NtAlpcCreateSecurityContext();
    NTSTATUS handle_NtAlpcDeleteSecurityContext();

    // syscalls/process.cpp:
    NTSTATUS handle_NtQueryInformationProcess(const syscall_context& c, handle process_handle, uint32_t info_class,
                                              uint64_t process_information, uint32_t process_information_length,
                                              emulator_object<uint32_t> return_length);
    NTSTATUS handle_NtSetInformationProcess(const syscall_context& c, handle process_handle, uint32_t info_class,
                                            uint64_t process_information, uint32_t process_information_length);
    NTSTATUS handle_NtOpenProcess();
    NTSTATUS handle_NtOpenProcessToken(const syscall_context&, handle process_handle, ACCESS_MASK /*desired_access*/,
                                       emulator_object<handle> token_handle);
    NTSTATUS handle_NtOpenProcessTokenEx(const syscall_context& c, handle process_handle, ACCESS_MASK desired_access,
                                         ULONG /*handle_attributes*/, emulator_object<handle> token_handle);
    NTSTATUS handle_NtTerminateProcess(const syscall_context& c, handle process_handle, NTSTATUS exit_status);

    // syscalls/registry.cpp:
    NTSTATUS handle_NtOpenKey(const syscall_context& c, emulator_object<handle> key_handle, ACCESS_MASK /*desired_access*/,
                              emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtOpenKeyEx(const syscall_context& c, emulator_object<handle> key_handle, ACCESS_MASK desired_access,
                                emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG /*open_options*/);
    NTSTATUS handle_NtQueryKey(const syscall_context& c, handle key_handle, KEY_INFORMATION_CLASS key_information_class,
                               uint64_t key_information, ULONG length, emulator_object<ULONG> result_length);
    NTSTATUS handle_NtQueryValueKey(const syscall_context& c, handle key_handle,
                                    emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> value_name,
                                    KEY_VALUE_INFORMATION_CLASS key_value_information_class, uint64_t key_value_information, ULONG length,
                                    emulator_object<ULONG> result_length);
    NTSTATUS handle_NtQueryMultipleValueKey(const syscall_context& c, handle key_handle, emulator_object<KEY_VALUE_ENTRY> value_entries,
                                            ULONG entry_count, uint64_t value_buffer, emulator_object<ULONG> buffer_length,
                                            emulator_object<ULONG> required_buffer_length);
    NTSTATUS handle_NtCreateKey(const syscall_context& c, emulator_object<handle> key_handle, ACCESS_MASK desired_access,
                                emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG /*title_index*/,
                                emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> /*class*/, ULONG /*create_options*/,
                                emulator_object<ULONG> /*disposition*/);
    NTSTATUS handle_NtNotifyChangeKey();
    NTSTATUS handle_NtSetInformationKey();
    NTSTATUS handle_NtEnumerateKey(const syscall_context& c, handle key_handle, ULONG index, KEY_INFORMATION_CLASS key_information_class,
                                   uint64_t key_information, ULONG length, emulator_object<ULONG> result_length);
    NTSTATUS handle_NtEnumerateValueKey(const syscall_context& c, handle key_handle, ULONG index,
                                        KEY_VALUE_INFORMATION_CLASS key_value_information_class, uint64_t key_value_information,
                                        ULONG length, emulator_object<ULONG> result_length);

    // syscalls/section.cpp:
    NTSTATUS handle_NtCreateSection(const syscall_context& c, emulator_object<handle> section_handle, ACCESS_MASK /*desired_access*/,
                                    emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                    emulator_object<ULARGE_INTEGER> maximum_size, ULONG section_page_protection,
                                    ULONG allocation_attributes, handle file_handle);
    NTSTATUS handle_NtOpenSection(const syscall_context& c, emulator_object<handle> section_handle, ACCESS_MASK /*desired_access*/,
                                  emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtQuerySection(const syscall_context& c, handle section_handle, SECTION_INFORMATION_CLASS section_information_class,
                                   uint64_t section_information, EmulatorTraits<Emu64>::SIZE_T section_information_length,
                                   emulator_object<EmulatorTraits<Emu64>::SIZE_T> result_length);
    NTSTATUS handle_NtMapViewOfSection(const syscall_context& c, handle section_handle, handle process_handle,
                                       emulator_object<uint64_t> base_address,
                                       EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) /*zero_bits*/,
                                       EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T) /*commit_size*/,
                                       emulator_object<LARGE_INTEGER> /*section_offset*/,
                                       emulator_object<EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T)> view_size,
                                       SECTION_INHERIT /*inherit_disposition*/, ULONG /*allocation_type*/, ULONG /*win32_protect*/);
    NTSTATUS handle_NtMapViewOfSectionEx(const syscall_context& c, handle section_handle, handle process_handle,
                                         emulator_object<uint64_t> base_address, emulator_object<LARGE_INTEGER> section_offset,
                                         emulator_object<EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T)> view_size,
                                         ULONG allocation_type, ULONG page_protection,
                                         uint64_t extended_parameters, // PMEM_EXTENDED_PARAMETER
                                         ULONG extended_parameter_count);
    NTSTATUS handle_NtUnmapViewOfSection(const syscall_context& c, handle process_handle, uint64_t base_address);
    NTSTATUS handle_NtUnmapViewOfSectionEx(const syscall_context& c, handle process_handle, uint64_t base_address, ULONG /*flags*/);
    NTSTATUS handle_NtAreMappedFilesTheSame();

    // syscalls/semaphore.cpp:
    NTSTATUS handle_NtOpenSemaphore(const syscall_context& c, emulator_object<handle> semaphore_handle, ACCESS_MASK /*desired_access*/,
                                    emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtReleaseSemaphore(const syscall_context& c, handle semaphore_handle, ULONG release_count,
                                       emulator_object<LONG> previous_count);
    NTSTATUS handle_NtCreateSemaphore(const syscall_context& c, emulator_object<handle> semaphore_handle, ACCESS_MASK /*desired_access*/,
                                      emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG initial_count,
                                      ULONG maximum_count);

    // syscalls/system.cpp:
    NTSTATUS handle_NtQuerySystemInformation(const syscall_context& c, uint32_t info_class, uint64_t system_information,
                                             uint32_t system_information_length, emulator_object<uint32_t> return_length);
    NTSTATUS handle_NtQuerySystemInformationEx(const syscall_context& c, uint32_t info_class, uint64_t input_buffer,
                                               uint32_t input_buffer_length, uint64_t system_information,
                                               uint32_t system_information_length, emulator_object<uint32_t> return_length);
    NTSTATUS handle_NtSetSystemInformation();

    // syscalls/thread.cpp:
    NTSTATUS handle_NtSetInformationThread(const syscall_context& c, handle thread_handle, THREADINFOCLASS info_class,
                                           uint64_t thread_information, uint32_t thread_information_length);

    NTSTATUS handle_NtQueryInformationThread(const syscall_context& c, handle thread_handle, uint32_t info_class,
                                             uint64_t thread_information, uint32_t thread_information_length,
                                             emulator_object<uint32_t> return_length);
    NTSTATUS handle_NtOpenThread(const syscall_context&, emulator_object<handle> thread_handle, ACCESS_MASK desired_access,
                                 emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                 emulator_object<CLIENT_ID64> client_id);
    NTSTATUS handle_NtOpenThreadToken(const syscall_context&, handle thread_handle, ACCESS_MASK /*desired_access*/,
                                      BOOLEAN /*open_as_self*/, emulator_object<handle> token_handle);
    NTSTATUS handle_NtOpenThreadTokenEx(const syscall_context& c, handle thread_handle, ACCESS_MASK desired_access, BOOLEAN open_as_self,
                                        ULONG /*handle_attributes*/, emulator_object<handle> token_handle);
    NTSTATUS handle_NtTerminateThread(const syscall_context& c, handle thread_handle, NTSTATUS exit_status);
    NTSTATUS handle_NtDelayExecution(const syscall_context& c, BOOLEAN alertable, emulator_object<LARGE_INTEGER> delay_interval);
    NTSTATUS handle_NtAlertThreadByThreadId(const syscall_context& c, uint64_t thread_id);
    NTSTATUS handle_NtAlertThreadByThreadIdEx(const syscall_context& c, uint64_t thread_id,
                                              emulator_object<EMU_RTL_SRWLOCK<EmulatorTraits<Emu64>>> lock);
    NTSTATUS handle_NtWaitForAlertByThreadId(const syscall_context& c, uint64_t, emulator_object<LARGE_INTEGER> timeout);
    NTSTATUS handle_NtYieldExecution(const syscall_context& c);
    NTSTATUS handle_NtSuspendThread(const syscall_context& c, handle thread_handle, emulator_object<ULONG> previous_suspend_count);
    NTSTATUS handle_NtResumeThread(const syscall_context& c, handle thread_handle, emulator_object<ULONG> previous_suspend_count);
    NTSTATUS handle_NtContinue(const syscall_context& c, emulator_object<CONTEXT64> thread_context, BOOLEAN raise_alert);
    NTSTATUS handle_NtContinueEx(const syscall_context& c, emulator_object<CONTEXT64> thread_context, uint64_t continue_argument);
    NTSTATUS handle_NtGetNextThread(const syscall_context& c, handle process_handle, handle thread_handle, ACCESS_MASK /*desired_access*/,
                                    ULONG /*handle_attributes*/, ULONG flags, emulator_object<handle> new_thread_handle);
    NTSTATUS handle_NtGetContextThread(const syscall_context& c, handle thread_handle, emulator_object<CONTEXT64> thread_context);
    NTSTATUS handle_NtSetContextThread(const syscall_context& c, handle thread_handle, emulator_object<CONTEXT64> thread_context);
    NTSTATUS handle_NtCreateThreadEx(const syscall_context& c, emulator_object<handle> thread_handle, ACCESS_MASK /*desired_access*/,
                                     emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>>
                                     /*object_attributes*/,
                                     handle process_handle, uint64_t start_routine, uint64_t argument, ULONG create_flags,
                                     EmulatorTraits<Emu64>::SIZE_T /*zero_bits*/, EmulatorTraits<Emu64>::SIZE_T stack_size,
                                     EmulatorTraits<Emu64>::SIZE_T maximum_stack_size,
                                     emulator_object<PS_ATTRIBUTE_LIST<EmulatorTraits<Emu64>>> attribute_list);
    NTSTATUS handle_NtGetCurrentProcessorNumberEx(const syscall_context&, emulator_object<PROCESSOR_NUMBER> processor_number);
    ULONG handle_NtGetCurrentProcessorNumber();
    NTSTATUS handle_NtQueueApcThreadEx2(const syscall_context& c, handle thread_handle, handle reserve_handle, uint32_t apc_flags,
                                        uint64_t apc_routine, uint64_t apc_argument1, uint64_t apc_argument2, uint64_t apc_argument3);
    NTSTATUS handle_NtQueueApcThreadEx(const syscall_context& c, handle thread_handle, handle reserve_handle, uint64_t apc_routine,
                                       uint64_t apc_argument1, uint64_t apc_argument2, uint64_t apc_argument3);
    NTSTATUS handle_NtQueueApcThread(const syscall_context& c, handle thread_handle, uint64_t apc_routine, uint64_t apc_argument1,
                                     uint64_t apc_argument2, uint64_t apc_argument3);
    NTSTATUS handle_NtCallbackReturn(const syscall_context& c, emulator_pointer callback_result, ULONG callback_result_length,
                                     NTSTATUS callback_status);

    // syscalls/timer.cpp:
    NTSTATUS handle_NtQueryTimerResolution(const syscall_context&, emulator_object<ULONG> maximum_time, emulator_object<ULONG> minimum_time,
                                           emulator_object<ULONG> current_time);
    NTSTATUS handle_NtSetTimerResolution(const syscall_context&, ULONG /*desired_resolution*/, BOOLEAN set_resolution,
                                         emulator_object<ULONG> current_resolution);
    NTSTATUS handle_NtCreateTimer2(const syscall_context& c, emulator_object<handle> timer_handle, uint64_t reserved,
                                   emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG attributes,
                                   ACCESS_MASK desired_access);
    NTSTATUS handle_NtCreateTimer(const syscall_context& c, emulator_object<handle> timer_handle, ACCESS_MASK desired_access,
                                  emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG timer_type);
    NTSTATUS handle_NtSetTimer();
    NTSTATUS handle_NtSetTimer2();
    NTSTATUS handle_NtSetTimerEx(const syscall_context& c, handle timer_handle, uint32_t timer_set_info_class,
                                 uint64_t timer_set_information, ULONG timer_set_information_length);
    NTSTATUS handle_NtCancelTimer();

    // syscalls/token.cpp:
    NTSTATUS
    handle_NtDuplicateToken(const syscall_context&, handle existing_token_handle, ACCESS_MASK /*desired_access*/,
                            emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>>
                            /*object_attributes*/,
                            BOOLEAN /*effective_only*/, TOKEN_TYPE type, emulator_object<handle> new_token_handle);
    NTSTATUS handle_NtQueryInformationToken(const syscall_context& c, handle token_handle, TOKEN_INFORMATION_CLASS token_information_class,
                                            uint64_t token_information, ULONG token_information_length,
                                            emulator_object<ULONG> return_length);
    NTSTATUS handle_NtQuerySecurityAttributesToken();
    NTSTATUS handle_NtAdjustPrivilegesToken();
    NTSTATUS handle_NtFlushInstructionCache(const syscall_context& c, handle process_handle, emulator_object<uint64_t> base_address,
                                            uint64_t region_size);

    // syscalls/user.cpp:
    NTSTATUS handle_NtUserDisplayConfigGetDeviceInfo();
    NTSTATUS handle_NtUserRegisterWindowMessage();
    NTSTATUS handle_NtUserGetThreadState(const syscall_context& c, ULONG routine);
    NTSTATUS handle_NtUserProcessConnect(const syscall_context& c, handle process_handle, ULONG length, emulator_pointer user_connect);
    NTSTATUS handle_NtUserInitializeClientPfnArrays(const syscall_context& c, emulator_pointer apfn_client_a,
                                                    emulator_pointer apfn_client_w, emulator_pointer apfn_client_worker,
                                                    emulator_pointer hmod_user);
    uint64_t handle_NtUserRemoteConnectState(const syscall_context& c);
    hdesk handle_NtUserGetThreadDesktop(const syscall_context& c, ULONG thread_id);
    hdc handle_NtUserGetDCEx(const syscall_context& c, hwnd window, uint64_t clip_region, ULONG flags);
    hdc handle_NtUserGetDC(const syscall_context& c, hwnd window);
    hdc handle_NtUserGetWindowDC(const syscall_context& c, hwnd window);
    BOOL handle_NtUserReleaseDC();
    NTSTATUS handle_NtUserGetCursorPos();
    NTSTATUS handle_NtUserSetCursor();
    NTSTATUS handle_NtUserFindExistingCursorIcon();
    NTSTATUS handle_NtUserFindWindowEx(const syscall_context& c, hwnd parent, hwnd child_after,
                                       emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                       emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> window_name);
    NTSTATUS handle_NtUserMoveWindow();
    NTSTATUS handle_NtUserGetProcessWindowStation();
    NTSTATUS handle_NtUserRegisterClassExWOW(const syscall_context& c, emulator_object<EMU_WNDCLASSEX> wnd_class_ex,
                                             emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                             emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_version,
                                             emulator_object<CLSMENUNAME<EmulatorTraits<Emu64>>> class_menu_name, DWORD function_id,
                                             DWORD flags, emulator_pointer wow);
    NTSTATUS handle_NtUserUnregisterClass(const syscall_context& c, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                          emulator_pointer instance, emulator_object<CLSMENUNAME<EmulatorTraits<Emu64>>> class_menu_name);
    BOOL handle_NtUserGetClassInfoEx(const syscall_context& c, hinstance /*instance*/,
                                     emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                     emulator_object<EMU_WNDCLASSEX> wnd_class_ex, emulator_pointer menu_name, BOOL /*ansi*/);
    NTSTATUS handle_NtUserSetWindowsHookEx();
    NTSTATUS handle_NtUserUnhookWindowsHookEx();
    hwnd handle_NtUserCreateWindowEx(const syscall_context& c, DWORD ex_style, emulator_object<LARGE_STRING> class_name,
                                     emulator_object<LARGE_STRING> cls_version, emulator_object<LARGE_STRING> window_name, DWORD style,
                                     int x, int y, int width, int height, hwnd parent, hmenu menu, hinstance instance, pointer l_param,
                                     DWORD flags, pointer acbi_buffer);
    hwnd completion_NtUserCreateWindowEx(const syscall_context& c, DWORD ex_style, emulator_object<LARGE_STRING> class_name,
                                         emulator_object<LARGE_STRING> cls_version, emulator_object<LARGE_STRING> window_name, DWORD style,
                                         int x, int y, int width, int height, hwnd parent, hmenu menu, hinstance instance, pointer l_param,
                                         DWORD flags, pointer acbi_buffer);
    BOOL handle_NtUserDestroyWindow(const syscall_context& c, hwnd window);
    BOOL completion_NtUserDestroyWindow(const syscall_context& c, hwnd window);
    BOOL handle_NtUserSetProp(const syscall_context& c, hwnd window, uint16_t atom, uint64_t data);
    BOOL handle_NtUserSetProp2(const syscall_context& c, hwnd window, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> str,
                               uint64_t data);
    uint64_t handle_NtUserChangeWindowMessageFilterEx();
    BOOL handle_NtUserShowWindow(const syscall_context& c, hwnd hwnd, LONG cmd_show);
    BOOL completion_NtUserShowWindow(const syscall_context& c, hwnd hwnd, LONG cmd_show);
    uint64_t handle_NtUserMessageCall(const syscall_context& c, hwnd hwnd, UINT msg, uint64_t w_param, uint64_t l_param,
                                      uint64_t result_info, DWORD type, BOOL ansi);
    uint64_t completion_NtUserMessageCall(const syscall_context& c, hwnd hwnd, UINT msg, uint64_t w_param, uint64_t l_param,
                                          uint64_t result_info, DWORD type, BOOL ansi);
    BOOL handle_NtUserGetMessage(const syscall_context& c, emulator_object<msg> message, hwnd hwnd, UINT msg_filter_min,
                                 UINT msg_filter_max);
    BOOL handle_NtUserPeekMessage(const syscall_context& c, emulator_object<msg> message, hwnd hwnd, UINT msg_filter_min,
                                  UINT msg_filter_max, UINT remove_message);
    BOOL handle_NtUserPostMessage(const syscall_context& c, hwnd hwnd, UINT msg, uint64_t wParam, uint64_t lParam);
    BOOL handle_NtUserPostQuitMessage(const syscall_context& c, int exit_code);
    NTSTATUS handle_NtUserEnumDisplayDevices(const syscall_context& c, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> str_device,
                                             DWORD dev_num, emulator_object<EMU_DISPLAY_DEVICEW> display_device, DWORD flags);
    NTSTATUS handle_NtUserEnumDisplaySettings(const syscall_context& c, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> device_name,
                                              DWORD mode_num, emulator_object<EMU_DEVMODEW> dev_mode, DWORD flags);
    BOOL handle_NtUserEnumDisplayMonitors(const syscall_context& c, hdc hdc_in, uint64_t clip_rect_ptr, uint64_t callback, uint64_t param);
    BOOL completion_NtUserEnumDisplayMonitors(const syscall_context& c, hdc hdc_in, uint64_t clip_rect_ptr, uint64_t callback,
                                              uint64_t param);
    BOOL handle_NtUserGetHDevName(const syscall_context& c, handle hdev, emulator_pointer device_name);
    emulator_pointer handle_NtUserMapDesktopObject(const syscall_context& c, handle handle);
    NTSTATUS handle_NtUserTransformRect();
    NTSTATUS handle_NtUserSetWindowPos();
    NTSTATUS handle_NtUserSetForegroundWindow();
    emulator_pointer handle_NtUserSetWindowLongPtr(const syscall_context& c, handle hWnd, int nIndex, emulator_pointer dwNewLong,
                                                   BOOL Ansi);
    uint32_t handle_NtUserSetWindowLong(const syscall_context& c, handle hWnd, int nIndex, uint32_t dwNewLong, BOOL Ansi);
    NTSTATUS handle_NtUserRedrawWindow();
    NTSTATUS handle_NtUserGetCPD();
    NTSTATUS handle_NtUserSetWindowFNID();
    NTSTATUS handle_NtUserEnableWindow();
    NTSTATUS handle_NtUserGetSystemMenu();
    NTSTATUS handle_NtQueryLicenseValue(const syscall_context& c, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> value_name,
                                        emulator_object<uint32_t> type, uint64_t data, uint64_t data_size,
                                        emulator_object<uint32_t> result_data_size);
    NTSTATUS handle_NtGdiInit(const syscall_context& c);
    NTSTATUS handle_NtGdiInit2(const syscall_context& c);
    uint32_t handle_NtGdiGetDeviceCaps(const syscall_context& c, hdc dc, uint32_t index);
    uint32_t handle_NtGdiGetDeviceCapsAll(const syscall_context& c, hdc dc, emulator_pointer caps);
    uint32_t handle_NtGdiComputeXformCoefficients(const syscall_context& c, hdc dc);
    uint64_t handle_NtGdiCreateSolidBrush(const syscall_context& c, uint32_t color, uint64_t unused);
    uint64_t handle_NtGdiCreatePatternBrushInternal(const syscall_context& c, handle bitmap, uint32_t unused);
    uint64_t handle_NtGdiCreatePen(const syscall_context& c, uint32_t style, uint32_t width, uint32_t color);
    uint64_t handle_NtGdiCreateCompatibleDC(const syscall_context& c, hdc dc);
    uint64_t handle_NtGdiCreateCompatibleBitmap(const syscall_context& c, hdc dc, uint32_t width, uint32_t height);
    uint64_t handle_NtGdiCreateDIBitmapInternal(const syscall_context& c, hdc dc, uint32_t width, uint32_t height, uint32_t usage,
                                                emulator_pointer bits, emulator_pointer info, uint32_t info_header_size, uint32_t init,
                                                uint32_t offset, uint32_t cj, uint32_t i_usage);
    uint32_t handle_NtGdiDeleteObjectApp(const syscall_context& c, uint32_t handle_value);
    uint64_t handle_NtGdiSelectBitmap(const syscall_context& c, hdc dc, handle bitmap);
    hdc handle_NtGdiGetDCforBitmap(const syscall_context& c, handle bitmap);
    uint64_t handle_NtGdiHfontCreate(const syscall_context& c, emulator_pointer logfont, uint32_t angle);
    uint32_t handle_NtGdiExtGetObjectW(const syscall_context& c, uint32_t handle_value, uint32_t size, emulator_pointer buffer);
    uint32_t handle_NtGdiEnumFonts();
    uint32_t handle_NtGdiGetTextCharsetInfo(const syscall_context& c, hdc dc, emulator_pointer sig, uint32_t flags);
    uint32_t handle_NtGdiQueryFontAssocInfo(const syscall_context& c, hdc dc);
    uint32_t handle_NtGdiGetTextMetricsW(const syscall_context& c, hdc dc, emulator_pointer ptm, uint32_t cj);
    NTSTATUS handle_NtGdiGetEntry(const syscall_context& c, uint32_t handle_value, emulator_pointer entry_ptr);

    // syscalls/trace.cpp:
    NTSTATUS handle_NtTraceControl(const syscall_context& c, ULONG function_code, uint64_t input_buffer, ULONG input_buffer_length,
                                   uint64_t output_buffer, ULONG output_buffer_length, emulator_object<ULONG> return_length);

    // syscalls/io_completion.cpp:
    NTSTATUS handle_NtCreateIoCompletion(const syscall_context& c, emulator_object<handle> io_completion_handle, ACCESS_MASK desired_access,
                                         emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                         ULONG number_of_concurrent_threads);
    NTSTATUS handle_NtSetIoCompletion(const syscall_context& c, handle io_completion_handle, emulator_pointer key_context,
                                      emulator_pointer apc_context, NTSTATUS io_status,
                                      EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) io_status_information);
    NTSTATUS handle_NtSetIoCompletionEx(const syscall_context& c, handle io_completion_handle, handle io_completion_packet_handle,
                                        emulator_pointer key_context, emulator_pointer apc_context, NTSTATUS io_status,
                                        EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) io_status_information);
    NTSTATUS handle_NtRemoveIoCompletion(const syscall_context& c, handle io_completion_handle,
                                         emulator_object<emulator_pointer> key_context, emulator_object<emulator_pointer> apc_context,
                                         emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                         emulator_object<LARGE_INTEGER> timeout);
    NTSTATUS handle_NtRemoveIoCompletionEx(const syscall_context& c, handle io_completion_handle,
                                           emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>> io_completion_information,
                                           ULONG count, emulator_object<ULONG> num_entries_removed, emulator_object<LARGE_INTEGER> timeout,
                                           BOOLEAN alertable);
    NTSTATUS handle_NtCreateWaitCompletionPacket(const syscall_context& c, emulator_object<handle> wait_packet_handle,
                                                 ACCESS_MASK desired_access,
                                                 emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes);
    NTSTATUS handle_NtAssociateWaitCompletionPacket(const syscall_context& c, handle wait_completion_packet_handle,
                                                    handle io_completion_handle, handle target_object_handle, emulator_pointer key_context,
                                                    emulator_pointer apc_context, NTSTATUS io_status,
                                                    EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) io_status_information,
                                                    emulator_object<BOOLEAN> already_signaled);
    NTSTATUS handle_NtCancelWaitCompletionPacket(const syscall_context& c, handle wait_completion_packet_handle,
                                                 BOOLEAN remove_signaled_packet);

    // syscalls/worker_factory.cpp:
    NTSTATUS handle_NtCreateWorkerFactory(const syscall_context& c, emulator_object<handle> worker_factory_handle,
                                          ACCESS_MASK desired_access,
                                          emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                          handle io_completion_handle, handle worker_process_handle, emulator_pointer start_routine,
                                          emulator_pointer start_parameter, ULONG max_thread_count,
                                          EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T) stack_reserve,
                                          EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T) stack_commit);
    NTSTATUS handle_NtWorkerFactoryWorkerReady(const syscall_context& c, handle worker_factory_handle);
    NTSTATUS handle_NtSetInformationWorkerFactory(const syscall_context& c, handle worker_factory_handle, WORKERFACTORYINFOCLASS info_class,
                                                  emulator_pointer worker_factory_information, ULONG worker_factory_information_length);
    NTSTATUS handle_NtShutdownWorkerFactory(const syscall_context& c, handle worker_factory_handle,
                                            emulator_object<LONG> pending_worker_count);
    NTSTATUS handle_NtReleaseWorkerFactoryWorker(const syscall_context& c, handle worker_factory_handle);
    NTSTATUS handle_NtWaitForWorkViaWorkerFactory(const syscall_context& c, handle worker_factory_handle,
                                                  emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>> mini_packets,
                                                  ULONG count, emulator_object<ULONG> packets_returned, emulator_pointer deferred_work);

    NTSTATUS handle_NtQueryPerformanceCounter(const syscall_context& c, const emulator_object<LARGE_INTEGER> performance_counter,
                                              const emulator_object<LARGE_INTEGER> performance_frequency)
    {
        try
        {
            if (performance_counter)
            {
                performance_counter.access([&](LARGE_INTEGER& value) {
                    value.QuadPart = c.win_emu.clock().steady_now().time_since_epoch().count(); //
                });
            }

            if (performance_frequency)
            {
                performance_frequency.access([&](LARGE_INTEGER& value) {
                    value.QuadPart = c.proc.kusd.get().QpcFrequency; //
                });
            }

            return STATUS_SUCCESS;
        }
        catch (...)
        {
            return STATUS_ACCESS_VIOLATION;
        }
    }

    NTSTATUS handle_NtManageHotPatch()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtApphelpCacheControl()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtDeviceIoControlFile(const syscall_context& c, const handle file_handle, const handle event,
                                          const emulator_pointer /*PIO_APC_ROUTINE*/ apc_routine, const emulator_pointer apc_context,
                                          const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                          const ULONG io_control_code, const emulator_pointer input_buffer, const ULONG input_buffer_length,
                                          const emulator_pointer output_buffer, const ULONG output_buffer_length)
    {
        auto* device = c.proc.devices.get(file_handle);
        if (!device)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (auto* e = c.proc.events.get(event))
        {
            e->signaled = false;
        }

        io_device_context context{c.emu};
        context.event = event;
        context.apc_routine = apc_routine;
        context.apc_context = apc_context;
        context.io_status_block = io_status_block;
        context.io_control_code = io_control_code;
        context.input_buffer = input_buffer;
        context.input_buffer_length = input_buffer_length;
        context.output_buffer = output_buffer;
        context.output_buffer_length = output_buffer_length;

        return device->execute_ioctl(c.win_emu, context);
    }

    NTSTATUS handle_NtQueryWnfStateData()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryWnfStateNameInformation()
    {
        // puts("NtQueryWnfStateNameInformation not supported");
        // return STATUS_NOT_SUPPORTED;
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtTestAlert(const syscall_context& c)
    {
        c.win_emu.yield_thread(true);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserSystemParametersInfo()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtDxgkIsFeatureEnabled()
    {
        // puts("NtDxgkIsFeatureEnabled not supported");
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUpdateWnfStateData()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryInformationJobObject()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtAccessCheck()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtCreateUserProcess()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtCreateDebugObject()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtAddAtomEx(const syscall_context& c, const uint64_t atom_name, const ULONG length,
                                const emulator_object<RTL_ATOM> atom, const ULONG /*flags*/)
    {
        std::u16string name{};
        name.resize(length / 2);

        c.emu.read_memory(atom_name, name.data(), length);

        uint16_t index = c.proc.add_or_find_atom(name);
        atom.write(index);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtAddAtom(const syscall_context& c, const uint64_t atom_name, const ULONG length, const emulator_object<RTL_ATOM> atom)
    {
        return handle_NtAddAtomEx(c, atom_name, length, atom, 0);
    }

    NTSTATUS handle_NtDeleteAtom(const syscall_context& c, const RTL_ATOM atom)
    {
        c.proc.delete_atom(atom);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtFindAtom(const syscall_context& c, const uint64_t atom_name, const ULONG length, const emulator_object<uint16_t> atom)
    {
        const auto name = read_string<char16_t>(c.emu, atom_name, length / 2);
        const auto index = c.proc.find_atom(name);
        if (!index)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        if (atom)
        {
            atom.write(*index);
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserGetAtomName(const syscall_context& c, const RTL_ATOM atom,
                                      const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> atom_name)
    {
        const auto* name = c.proc.get_atom_name(atom);
        if (!name)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const size_t name_length = name->size() * 2;
        const size_t max_length = name_length + 2;

        bool too_small = false;
        atom_name.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& str) {
            if (str.MaximumLength < max_length)
            {
                too_small = true;
                return;
            }

            str.Length = static_cast<USHORT>(name_length);
            c.emu.write_memory(str.Buffer, name->data(), max_length);
        });

        return too_small ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryDebugFilterState()
    {
        return FALSE;
    }

    NTSTATUS handle_NtUserGetDpiForCurrentProcess()
    {
        return 96;
    }

    NTSTATUS handle_NtUserModifyUserStartupInfoFlags()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSystemDebugControl()
    {
        return STATUS_DEBUGGER_INACTIVE;
    }

    NTSTATUS handle_NtRequestWaitReplyPort()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserGetProcessUIContextInformation()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserMapVirtualKeyEx()
    {
        return 0;
    }

    NTSTATUS handle_NtUserToUnicodeEx()
    {
        return 0;
    }

    NTSTATUS handle_NtUserSetProcessDpiAwarenessContext()
    {
        return 0;
    }

    ULONG handle_NtUserGetRawInputDeviceList()
    {
        return 0;
    }

    ULONG handle_NtUserGetKeyboardType()
    {
        return 0;
    }

    NTSTATUS handle_NtSubscribeWnfStateChange()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUnsubscribeWnfStateChange()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetWnfProcessNotificationEvent()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetInformationDebugObject()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtRemoveProcessDebug()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtNotifyChangeDirectoryFileEx()
    {
        return STATUS_NOT_SUPPORTED;
    }
}

void syscall_dispatcher::add_handlers(std::map<std::string, syscall_handler>& handler_mapping)
{
#define add_handler(syscall)                                                            \
    do                                                                                  \
    {                                                                                   \
        handler_mapping[#syscall] = make_syscall_handler<syscalls::handle_##syscall>(); \
    } while (0)

    add_handler(NtSetInformationThread);
    add_handler(NtSetEvent);
    add_handler(NtClose);
    add_handler(NtOpenKey);
    add_handler(NtAllocateVirtualMemory);
    add_handler(NtQueryInformationProcess);
    add_handler(NtSetInformationProcess);
    add_handler(NtSetInformationVirtualMemory);
    add_handler(NtFreeVirtualMemory);
    add_handler(NtQueryVirtualMemory);
    add_handler(NtOpenThread);
    add_handler(NtOpenThreadToken);
    add_handler(NtOpenThreadTokenEx);
    add_handler(NtQueryPerformanceCounter);
    add_handler(NtQuerySystemInformation);
    add_handler(NtCreateEvent);
    add_handler(NtProtectVirtualMemory);
    add_handler(NtLockVirtualMemory);
    add_handler(NtOpenDirectoryObject);
    add_handler(NtCreateDirectoryObject);
    add_handler(NtTraceEvent);
    add_handler(NtAllocateVirtualMemoryEx);
    add_handler(NtCreateIoCompletion);
    add_handler(NtSetIoCompletion);
    add_handler(NtSetIoCompletionEx);
    add_handler(NtRemoveIoCompletion);
    add_handler(NtCreateWaitCompletionPacket);
    add_handler(NtCreateWorkerFactory);
    add_handler(NtWorkerFactoryWorkerReady);
    add_handler(NtSetInformationWorkerFactory);
    add_handler(NtShutdownWorkerFactory);
    add_handler(NtWaitForWorkViaWorkerFactory);
    add_handler(NtManageHotPatch);
    add_handler(NtOpenSection);
    add_handler(NtMapViewOfSection);
    add_handler(NtMapViewOfSectionEx);
    add_handler(NtOpenSymbolicLinkObject);
    add_handler(NtQuerySymbolicLinkObject);
    add_handler(NtQuerySystemInformationEx);
    add_handler(NtOpenFile);
    add_handler(NtQueryVolumeInformationFile);
    add_handler(NtApphelpCacheControl);
    add_handler(NtCreateSection);
    add_handler(NtQuerySection);
    add_handler(NtConnectPort);
    add_handler(NtSecureConnectPort);
    add_handler(NtCreateFile);
    add_handler(NtDeviceIoControlFile);
    add_handler(NtQueryWnfStateData);
    add_handler(NtSubscribeWnfStateChange);
    add_handler(NtOpenProcess);
    add_handler(NtOpenProcessToken);
    add_handler(NtOpenProcessTokenEx);
    add_handler(NtQuerySecurityAttributesToken);
    add_handler(NtAdjustPrivilegesToken);
    add_handler(NtQueryLicenseValue);
    add_handler(NtTestAlert);
    add_handler(NtContinue);
    add_handler(NtContinueEx);
    add_handler(NtTerminateProcess);
    add_handler(NtWriteFile);
    add_handler(NtRaiseHardError);
    add_handler(NtCreateSemaphore);
    add_handler(NtOpenSemaphore);
    add_handler(NtReadVirtualMemory);
    add_handler(NtWriteVirtualMemory);
    add_handler(NtQueryInformationToken);
    add_handler(NtDxgkIsFeatureEnabled);
    add_handler(NtAddAtomEx);
    add_handler(NtAddAtom);
    add_handler(NtFindAtom);
    add_handler(NtDeleteAtom);
    add_handler(NtUserGetAtomName);
    add_handler(NtInitializeNlsFiles);
    add_handler(NtUnmapViewOfSection);
    add_handler(NtUnmapViewOfSectionEx);
    add_handler(NtDuplicateObject);
    add_handler(NtQueryInformationThread);
    add_handler(NtQueryWnfStateNameInformation);
    add_handler(NtAlpcSendWaitReceivePort);
    add_handler(NtGdiInit);
    add_handler(NtGdiGetDeviceCaps);
    add_handler(NtGdiGetDeviceCapsAll);
    add_handler(NtGdiComputeXformCoefficients);
    add_handler(NtGdiCreateSolidBrush);
    add_handler(NtGdiCreatePatternBrushInternal);
    add_handler(NtGdiCreatePen);
    add_handler(NtGdiCreateCompatibleDC);
    add_handler(NtGdiCreateCompatibleBitmap);
    add_handler(NtGdiCreateDIBitmapInternal);
    add_handler(NtGdiDeleteObjectApp);
    add_handler(NtGdiSelectBitmap);
    add_handler(NtGdiGetDCforBitmap);
    add_handler(NtGdiHfontCreate);
    add_handler(NtGdiExtGetObjectW);
    add_handler(NtGdiEnumFonts);
    add_handler(NtGdiGetTextCharsetInfo);
    add_handler(NtGdiQueryFontAssocInfo);
    add_handler(NtGdiGetTextMetricsW);
    add_handler(NtGdiGetEntry);
    add_handler(NtGdiInit2);
    add_handler(NtUserGetThreadState);
    add_handler(NtUserProcessConnect);
    add_handler(NtUserInitializeClientPfnArrays);
    add_handler(NtUserRemoteConnectState);
    add_handler(NtUserGetThreadDesktop);
    add_handler(NtOpenKeyEx);
    add_handler(NtUserDisplayConfigGetDeviceInfo);
    add_handler(NtOpenEvent);
    add_handler(NtGetMUIRegistryInfo);
    add_handler(NtIsUILanguageComitted);
    add_handler(NtQueryDefaultUILanguage);
    add_handler(NtQueryInstallUILanguage);
    add_handler(NtUpdateWnfStateData);
    add_handler(NtRaiseException);
    add_handler(NtQueryInformationJobObject);
    add_handler(NtSetSystemInformation);
    add_handler(NtQueryInformationFile);
    add_handler(NtCreateThreadEx);
    add_handler(NtQueryDebugFilterState);
    add_handler(NtWaitForSingleObject);
    add_handler(NtTerminateThread);
    add_handler(NtDelayExecution);
    add_handler(NtWaitForAlertByThreadId);
    add_handler(NtAlertThreadByThreadIdEx);
    add_handler(NtAlertThreadByThreadId);
    add_handler(NtReadFile);
    add_handler(NtSetInformationFile);
    add_handler(NtUserRegisterWindowMessage);
    add_handler(NtQueryValueKey);
    add_handler(NtQueryMultipleValueKey);
    add_handler(NtQueryKey);
    add_handler(NtGetNlsSectionPtr);
    add_handler(NtAccessCheck);
    add_handler(NtCreateKey);
    add_handler(NtNotifyChangeKey);
    add_handler(NtGetCurrentProcessorNumberEx);
    add_handler(NtGetCurrentProcessorNumber);
    add_handler(NtQueryObject);
    add_handler(NtCompareObjects);
    add_handler(NtQueryAttributesFile);
    add_handler(NtWaitForMultipleObjects);
    add_handler(NtWaitForMultipleObjects32);
    add_handler(NtCreateMutant);
    add_handler(NtReleaseMutant);
    add_handler(NtDuplicateToken);
    add_handler(NtQueryTimerResolution);
    add_handler(NtSetInformationKey);
    add_handler(NtUserGetKeyboardLayout);
    add_handler(NtQueryDirectoryFileEx);
    add_handler(NtQueryDirectoryFile);
    add_handler(NtUserSystemParametersInfo);
    add_handler(NtGetContextThread);
    add_handler(NtYieldExecution);
    add_handler(NtUserModifyUserStartupInfoFlags);
    add_handler(NtUserGetDCEx);
    add_handler(NtUserGetDC);
    add_handler(NtUserGetWindowDC);
    add_handler(NtUserGetDpiForCurrentProcess);
    add_handler(NtReleaseSemaphore);
    add_handler(NtEnumerateKey);
    add_handler(NtEnumerateValueKey);
    add_handler(NtAlpcConnectPortEx);
    add_handler(NtAlpcConnectPort);
    add_handler(NtAlpcQueryInformation);
    add_handler(NtGetNextThread);
    add_handler(NtSetInformationObject);
    add_handler(NtUserGetCursorPos);
    add_handler(NtUserReleaseDC);
    add_handler(NtUserFindExistingCursorIcon);
    add_handler(NtSetContextThread);
    add_handler(NtUserFindWindowEx);
    add_handler(NtUserMoveWindow);
    add_handler(NtSystemDebugControl);
    add_handler(NtRequestWaitReplyPort);
    add_handler(NtQueryDefaultLocale);
    add_handler(NtSetTimerResolution);
    add_handler(NtSuspendThread);
    add_handler(NtResumeThread);
    add_handler(NtClearEvent);
    add_handler(NtTraceControl);
    add_handler(NtUserGetProcessUIContextInformation);
    add_handler(NtQueueApcThreadEx2);
    add_handler(NtQueueApcThreadEx);
    add_handler(NtQueueApcThread);
    add_handler(NtCreateUserProcess);
    add_handler(NtCreateNamedPipeFile);
    add_handler(NtFsControlFile);
    add_handler(NtQueryFullAttributesFile);
    add_handler(NtFlushBuffersFile);
    add_handler(NtAreMappedFilesTheSame);
    add_handler(NtUserGetProcessWindowStation);
    add_handler(NtUserRegisterClassExWOW);
    add_handler(NtUserUnregisterClass);
    add_handler(NtUserSetWindowsHookEx);
    add_handler(NtUserUnhookWindowsHookEx);
    add_handler(NtUserCreateWindowEx);
    add_handler(NtUserShowWindow);
    add_handler(NtUserMessageCall);
    add_handler(NtUserGetMessage);
    add_handler(NtUserPeekMessage);
    add_handler(NtUserMapVirtualKeyEx);
    add_handler(NtUserToUnicodeEx);
    add_handler(NtUserSetProcessDpiAwarenessContext);
    add_handler(NtUserGetRawInputDeviceList);
    add_handler(NtUserGetKeyboardType);
    add_handler(NtUserEnumDisplayDevices);
    add_handler(NtUserEnumDisplaySettings);
    add_handler(NtUserEnumDisplayMonitors);
    add_handler(NtUserSetProp);
    add_handler(NtUserSetProp2);
    add_handler(NtUserChangeWindowMessageFilterEx);
    add_handler(NtUserDestroyWindow);
    add_handler(NtQueryInformationByName);
    add_handler(NtUserSetCursor);
    add_handler(NtOpenMutant);
    add_handler(NtCreateTimer);
    add_handler(NtCreateTimer2);
    add_handler(NtSetTimer);
    add_handler(NtSetTimer2);
    add_handler(NtSetTimerEx);
    add_handler(NtCancelTimer);
    add_handler(NtAssociateWaitCompletionPacket);
    add_handler(NtCancelWaitCompletionPacket);
    add_handler(NtSetWnfProcessNotificationEvent);
    add_handler(NtUnsubscribeWnfStateChange);
    add_handler(NtQuerySecurityObject);
    add_handler(NtQueryEvent);
    add_handler(NtRemoveIoCompletionEx);
    add_handler(NtCreateDebugObject);
    add_handler(NtReleaseWorkerFactoryWorker);
    add_handler(NtAlpcCreateSecurityContext);
    add_handler(NtAlpcDeleteSecurityContext);
    add_handler(NtSetSecurityObject);
    add_handler(NtSetInformationDebugObject);
    add_handler(NtRemoveProcessDebug);
    add_handler(NtNotifyChangeDirectoryFileEx);
    add_handler(NtUserGetHDevName);
    add_handler(NtFlushInstructionCache);
    add_handler(NtUserMapDesktopObject);
    add_handler(NtAlpcSetInformation);
    add_handler(NtUserTransformRect);
    add_handler(NtUserSetWindowPos);
    add_handler(NtUserSetForegroundWindow);
    add_handler(NtUserSetWindowLongPtr);
    add_handler(NtUserSetWindowLong);
    add_handler(NtUserPostMessage);
    add_handler(NtUserRedrawWindow);
    add_handler(NtUserGetCPD);
    add_handler(NtUserSetWindowFNID);
    add_handler(NtUserEnableWindow);
    add_handler(NtUserGetSystemMenu);
    add_handler(NtCallbackReturn);
    add_handler(NtUserPostQuitMessage);
    add_handler(NtUserGetClassInfoEx);

#undef add_handler
}

void syscall_dispatcher::add_callbacks()
{
#define add_callback(syscall, completion_state)                                                                                      \
    do                                                                                                                               \
    {                                                                                                                                \
        this->completion_handlers_[callback_id::syscall] = make_syscall_handler<syscalls::completion_##syscall>();                   \
        syscall_dispatcher::completion_state_factories_[callback_id::syscall] = [] { return std::make_unique<completion_state>(); }; \
    } while (0)

#define add_stateless_callback(syscall)                                                                            \
    do                                                                                                             \
    {                                                                                                              \
        this->completion_handlers_[callback_id::syscall] = make_syscall_handler<syscalls::completion_##syscall>(); \
    } while (0)

    add_callback(NtUserCreateWindowEx, window_create_state);
    add_callback(NtUserDestroyWindow, window_destroy_state);
    add_callback(NtUserShowWindow, window_show_state);
    add_stateless_callback(NtUserMessageCall);
    add_stateless_callback(NtUserEnumDisplayMonitors);

#undef add_callback
#undef add_stateless_callback
}

```

`src/windows-emulator/syscalls/event.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtSetEvent(const syscall_context& c, const uint64_t handle, const emulator_object<LONG> previous_state)
    {
        if (handle == DBWIN_DATA_READY)
        {
            if (c.proc.dbwin_buffer && c.win_emu.callbacks.on_debug_string)
            {
                constexpr auto pid_length = 4;
                const auto debug_data = read_string<char>(c.win_emu.memory, c.proc.dbwin_buffer + pid_length);
                c.win_emu.callbacks.on_debug_string(debug_data);
            }

            return STATUS_SUCCESS;
        }

        auto* entry = c.proc.events.get(handle);
        if (!entry)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (previous_state.value())
        {
            previous_state.write(entry->signaled ? 1ULL : 0ULL);
        }

        entry->signaled = true;
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtTraceEvent()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryEvent(const syscall_context& c, const handle event_handle, const uint32_t event_information_class,
                                 const emulator_object<EVENT_BASIC_INFORMATION> event_information, const uint32_t event_information_length,
                                 const emulator_object<uint32_t> return_length)
    {
        if (event_information_class != 0) // EventBasicInformation
        {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (event_information_length < sizeof(EVENT_BASIC_INFORMATION))
        {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        EVENT_TYPE type = NotificationEvent;
        bool is_signaled = false;

        if (auto* entry = c.proc.events.get(event_handle))
        {
            type = entry->type;
            is_signaled = entry->signaled;
        }

        event_information.access([&](EVENT_BASIC_INFORMATION& info) {
            info.EventType = type;
            info.EventState = is_signaled ? 1 : 0;
        });

        if (return_length)
        {
            return_length.write(sizeof(EVENT_BASIC_INFORMATION));
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtClearEvent(const syscall_context& c, const handle event_handle)
    {
        auto* e = c.proc.events.get(event_handle);
        if (!e)
        {
            return STATUS_INVALID_HANDLE;
        }

        e->signaled = false;
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCreateEvent(const syscall_context& c, const emulator_object<handle> event_handle,
                                  const ACCESS_MASK /*desired_access*/,
                                  const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                  const EVENT_TYPE event_type, const BOOLEAN initial_state)
    {
        std::u16string name{};
        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName)
            {
                name = read_unicode_string(c.emu, attributes.ObjectName);
                c.win_emu.callbacks.on_generic_access("Opening event", name);
            }
        }

        if (!name.empty())
        {
            for (auto& entry : c.proc.events)
            {
                if (entry.second.name == name)
                {
                    ++entry.second.ref_count;
                    event_handle.write(c.proc.events.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        event e{};
        e.type = event_type;
        e.signaled = initial_state != FALSE;
        e.name = std::move(name);

        const auto handle = c.proc.events.store(std::move(e));
        event_handle.write(handle);

        static_assert(sizeof(EVENT_TYPE) == sizeof(uint32_t));
        static_assert(sizeof(ACCESS_MASK) == sizeof(uint32_t));

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtOpenEvent(const syscall_context& c, const emulator_object<uint64_t> event_handle,
                                const ACCESS_MASK /*desired_access*/,
                                const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        const auto attributes = object_attributes.read();
        const auto name = read_unicode_string(c.emu, attributes.ObjectName);
        c.win_emu.callbacks.on_generic_access("Opening event", name);

        if (name == u"\\KernelObjects\\SystemErrorPortReady")
        {
            event_handle.write(WER_PORT_READY.bits);
            return STATUS_SUCCESS;
        }

        if (name == u"Global\\SvcctrlStartEvent_A3752DX")
        {
            event_handle.write(SVCCTRL_START_EVENT.bits);
            return STATUS_SUCCESS;
        }

        if (name == u"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED")
        {
            event_handle.write(LSA_AUTHENTICATION_INITIALIZED.bits);
            return STATUS_SUCCESS;
        }

        if (name == u"DBWIN_DATA_READY")
        {
            event_handle.write(DBWIN_DATA_READY.bits);
            return STATUS_SUCCESS;
        }

        if (name == u"DBWIN_BUFFER_READY")
        {
            event_handle.write(DBWIN_BUFFER_READY.bits);
            return STATUS_SUCCESS;
        }

        for (auto& entry : c.proc.events)
        {
            if (entry.second.name == name)
            {
                ++entry.second.ref_count;
                event_handle.write(c.proc.events.make_handle(entry.first).bits);
                return STATUS_SUCCESS;
            }
        }

        return STATUS_NOT_FOUND;
    }
}

```

`src/windows-emulator/syscalls/exception.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtRaiseHardError(const syscall_context& c, const NTSTATUS error_status, const ULONG number_of_parameters,
                                     const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> /*unicode_string_parameter_mask*/,
                                     const uint64_t parameters, const HARDERROR_RESPONSE_OPTION /*valid_response_option*/,
                                     const emulator_object<HARDERROR_RESPONSE> response)
    {
        if (response)
        {
            response.write(ResponseAbort);
        }

        if (error_status & STATUS_SERVICE_NOTIFICATION && number_of_parameters >= 3)
        {
            std::array<uint64_t, 3> params = {0, 0, 0};

            if (c.emu.try_read_memory(parameters, &params, sizeof(params)))
            {
                std::u16string message =
                    read_unicode_string(c.emu, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>>{c.emu, params[0]});
                c.win_emu.log.error("Error Message: %s\n", u16_to_u8(message).c_str());
            }
        }

        c.proc.exit_status = error_status;
        c.win_emu.callbacks.on_exception();
        c.emu.stop();

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtRaiseException(const syscall_context& c,
                                     const emulator_object<EMU_EXCEPTION_RECORD<EmulatorTraits<Emu64>>> /*exception_record*/,
                                     const emulator_object<CONTEXT64> /*thread_context*/, const BOOLEAN handle_exception)
    {
        if (handle_exception)
        {
            c.win_emu.log.error("Unhandled exceptions not supported yet!\n");
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        c.win_emu.callbacks.on_exception();
        c.emu.stop();

        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/file.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"
#include "utils/io.hpp"

#include <iostream>
#include <utils/finally.hpp>
#include <utils/wildcard.hpp>

#include <sys/stat.h>

#include "../devices/named_pipe.hpp"

#if defined(OS_WINDOWS)
#define fstat64 _fstat64
#elif defined(OS_MAC)
#define fstat64 fstat
#endif

namespace syscalls
{
    namespace
    {
        std::pair<utils::file_handle, NTSTATUS> open_file(const file_system& file_sys, const windows_path& path, const std::u16string& mode)
        {
            FILE* file{};
            const auto error = open_unicode(&file, file_sys.translate(path), mode);

            if (file)
            {
                return {file, STATUS_SUCCESS};
            }

            using fh = utils::file_handle;

            switch (error)
            {
            case ENOENT:
                return {fh{}, STATUS_OBJECT_NAME_NOT_FOUND};
            case EACCES:
                return {fh{}, STATUS_ACCESS_DENIED};
            case EISDIR:
                return {fh{}, STATUS_FILE_IS_A_DIRECTORY};
            default:
                return {fh{}, STATUS_NOT_SUPPORTED};
            }
        }
    }

    NTSTATUS handle_NtSetInformationFile(const syscall_context& c, const handle file_handle,
                                         const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                         const uint64_t file_information, const ULONG length, const FILE_INFORMATION_CLASS info_class)
    {
        auto* f = c.proc.files.get(file_handle);
        if (!f)
        {
            if (c.proc.devices.get(file_handle))
            {
                return STATUS_SUCCESS;
            }

            return STATUS_INVALID_HANDLE;
        }

        if (info_class == FileRenameInformation)
        {
            if (length < sizeof(FILE_RENAME_INFORMATION))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto info = c.emu.read_memory<FILE_RENAME_INFORMATION>(file_information);
            auto new_name =
                read_string<char16_t>(c.emu, file_information + offsetof(FILE_RENAME_INFORMATION, FileName), info.FileNameLength / 2);

            if (info.RootDirectory)
            {
                const auto* root = c.proc.files.get(info.RootDirectory);
                if (!root)
                {
                    return STATUS_INVALID_HANDLE;
                }

                const auto has_separator = root->name.ends_with(u"\\") || root->name.ends_with(u"/");
                new_name = root->name + (has_separator ? u"" : u"\\") + new_name;
            }

            c.win_emu.log.warn("--> File rename requested: %s --> %s\n", u16_to_u8(f->name).c_str(), u16_to_u8(new_name).c_str());

            std::error_code ec{};
            bool file_exists = std::filesystem::exists(new_name, ec);

            if (ec)
            {
                return STATUS_ACCESS_DENIED;
            }

            if (!info.ReplaceIfExists && file_exists)
            {
                return STATUS_OBJECT_NAME_EXISTS;
            }

            f->handle.defer_rename(c.win_emu.file_sys.translate(f->name), c.win_emu.file_sys.translate(new_name));

            return STATUS_SUCCESS;
        }

        if (info_class == FileDispositionInformation)
        {
            if (length < sizeof(FILE_DISPOSITION_INFORMATION))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto info = c.emu.read_memory<FILE_DISPOSITION_INFORMATION>(file_information);

            f->handle.defer_delete(info.DeleteFile ? c.win_emu.file_sys.translate(f->name) : std::filesystem::path{});

            return STATUS_SUCCESS;
        }

        if (info_class == FileBasicInformation)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (info_class == FilePositionInformation)
        {
            if (!f->handle)
            {
                return STATUS_NOT_SUPPORTED;
            }

            if (io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = sizeof(FILE_POSITION_INFORMATION);
                io_status_block.write(block);
            }

            if (length != sizeof(FILE_POSITION_INFORMATION))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<FILE_POSITION_INFORMATION> info{c.emu, file_information};
            const auto i = info.read();

            if (!f->handle.seek_to(i.CurrentByteOffset.QuadPart))
            {
                return STATUS_INVALID_PARAMETER;
            }

            return STATUS_SUCCESS;
        }

        if (info_class == FileEndOfFileInformation)
        {
            if (!f->handle)
            {
                return STATUS_NOT_SUPPORTED;
            }

            if (length < sizeof(FILE_END_OF_FILE_INFORMATION))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto info = c.emu.read_memory<FILE_END_OF_FILE_INFORMATION>(file_information);

            if (!f->handle.resize(info.EndOfFile.QuadPart))
            {
                return STATUS_INVALID_PARAMETER;
            }

            return STATUS_SUCCESS;
        }

        if (info_class == FileAllocationInformation)
        {
            return STATUS_SUCCESS;
        }

        c.win_emu.log.error("Unsupported set file info class: 0x%X\n", info_class);
        c.emu.stop();

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryVolumeInformationFile(const syscall_context& c, const handle file_handle,
                                                 const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                                 const uint64_t fs_information, const ULONG length,
                                                 const FS_INFORMATION_CLASS fs_information_class)
    {
        switch (fs_information_class)
        {
        case FileFsDeviceInformation:
            return handle_query<FILE_FS_DEVICE_INFORMATION>(c.emu, fs_information, length, io_status_block,
                                                            [&](FILE_FS_DEVICE_INFORMATION& info) {
                                                                if (file_handle == STDOUT_HANDLE)
                                                                {
                                                                    info.DeviceType = FILE_DEVICE_CONSOLE;
                                                                    info.Characteristics = 0x20000;
                                                                }
                                                                else
                                                                {
                                                                    info.DeviceType = FILE_DEVICE_DISK;
                                                                    info.Characteristics = 0x20020;
                                                                }
                                                            });

        case FileFsSizeInformation:
            return handle_query<FILE_FS_SIZE_INFORMATION>(c.emu, fs_information, length, io_status_block,
                                                          [&](FILE_FS_SIZE_INFORMATION& info) {
                                                              info.BytesPerSector = 0x1000;
                                                              info.SectorsPerAllocationUnit = 0x1000;
                                                              info.TotalAllocationUnits.QuadPart = 0x10000;
                                                              info.AvailableAllocationUnits.QuadPart = 0x1000;
                                                          });

        case FileFsVolumeInformation:
            return handle_query<FILE_FS_VOLUME_INFORMATION>(c.emu, fs_information, length, io_status_block,
                                                            [&](FILE_FS_VOLUME_INFORMATION&) {});

        case FileFsAttributeInformation:
            return handle_query<_FILE_FS_ATTRIBUTE_INFORMATION>(
                c.emu, fs_information, length, io_status_block, [&](_FILE_FS_ATTRIBUTE_INFORMATION& info) {
                    info.FileSystemAttributes = 0x40006; // FILE_CASE_PRESERVED_NAMES | FILE_UNICODE_ON_DISK | FILE_NAMED_STREAMS
                    info.MaximumComponentNameLength = 255;
                    constexpr auto name = u"NTFS"sv;
                    info.FileSystemNameLength = static_cast<ULONG>(name.size() * sizeof(char16_t));
                    memcpy(info.FileSystemName, name.data(), info.FileSystemNameLength);
                });

        default:
            c.win_emu.log.error("Unsupported fs info class: 0x%X\n", fs_information_class);
            c.emu.stop();
            return write_io_status(io_status_block, STATUS_NOT_SUPPORTED, true);
        }
    }

    std::vector<file_entry> scan_directory(const file_system& file_sys, const windows_path& win_path, const std::u16string_view file_mask)
    {
        std::vector<file_entry> files{};

        const auto dir = file_sys.translate(win_path);

        if (file_mask.empty() || file_mask == u"*")
        {
            files.emplace_back(file_entry{.file_path = ".", .is_directory = true});
            files.emplace_back(file_entry{.file_path = "..", .is_directory = true});
        }

        std::error_code ec{};
        for (const auto& file : std::filesystem::directory_iterator(dir, ec))
        {
            if (!file_mask.empty() && !utils::wildcard::match_filename(file.path().filename().u16string(), file_mask))
            {
                continue;
            }

            files.emplace_back(file_entry{
                .file_path = file.path().filename(),
                .file_size = file.is_directory() ? 0 : file.file_size(),
                .is_directory = file.is_directory(),
            });
        }

        file_sys.access_mapped_entries(win_path, [&](const std::pair<windows_path, std::filesystem::path>& entry) {
            const auto filename = entry.first.leaf();

            if (!file_mask.empty() && !utils::wildcard::match_filename(filename, file_mask))
            {
                return;
            }

            const std::filesystem::directory_entry dir_entry(entry.second, ec);
            if (ec || !dir_entry.exists())
            {
                return;
            }

            files.emplace_back(file_entry{
                .file_path = filename,
                .file_size = dir_entry.is_directory() ? 0 : dir_entry.file_size(),
                .is_directory = dir_entry.is_directory(),
            });
        });

        return files;
    }

    template <typename T>
    NTSTATUS handle_file_enumeration(const syscall_context& c,
                                     const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                     const uint64_t file_information, const uint32_t length, const ULONG query_flags,
                                     const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> file_mask, file* f)
    {
        if (!f->enumeration_state || query_flags & SL_RESTART_SCAN)
        {
            const auto mask = file_mask ? read_unicode_string(c.emu, file_mask) : u"";
            c.win_emu.callbacks.on_generic_access("Enumerating directory", f->name);

            f->enumeration_state.emplace(file_enumeration_state{});
            f->enumeration_state->files = scan_directory(c.win_emu.file_sys, f->name, mask);
        }

        auto& enum_state = *f->enumeration_state;

        uint64_t current_offset{0};
        emulator_object<T> object{c.emu};

        size_t current_index = enum_state.current_index;

        if (current_index >= enum_state.files.size())
        {
            IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
            block.Information = 0;
            io_status_block.write(block);

            return STATUS_NO_MORE_FILES;
        }

        do
        {
            const auto new_offset = align_up(current_offset, 8);
            const auto& current_file = enum_state.files[current_index];
            const auto file_name = current_file.file_path.u16string();
            const auto required_size = sizeof(T) + (file_name.size() * 2) - 2;
            const auto end_offset = new_offset + required_size;

            if (end_offset > length)
            {
                if (current_offset == 0)
                {
                    IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                    block.Information = end_offset;
                    io_status_block.write(block);

                    return STATUS_BUFFER_OVERFLOW;
                }

                break;
            }

            if (object)
            {
                const auto object_offset = object.value() - file_information;

                object.access([&](T& dir_info) {
                    dir_info.NextEntryOffset = static_cast<ULONG>(new_offset - object_offset); //
                });
            }

            T info{};
            info.NextEntryOffset = 0;
            info.FileIndex = static_cast<ULONG>(current_index);
            info.FileAttributes = current_file.is_directory ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL;
            info.FileNameLength = static_cast<ULONG>(file_name.size() * 2);
            info.EndOfFile.QuadPart = current_file.file_size;

            object.set_address(file_information + new_offset);
            object.write(info);

            c.emu.write_memory(object.value() + offsetof(T, FileName), file_name.data(), info.FileNameLength);

            ++current_index;
            current_offset = end_offset;
        } while ((query_flags & SL_RETURN_SINGLE_ENTRY) == 0 && current_index < enum_state.files.size());

        if ((query_flags & SL_NO_CURSOR_UPDATE) == 0)
        {
            enum_state.current_index = current_index;
        }

        IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
        block.Information = current_offset;
        io_status_block.write(block);

        return current_index <= enum_state.files.size() ? STATUS_SUCCESS : STATUS_NO_MORE_FILES;
    }

    NTSTATUS handle_NtQueryDirectoryFileEx(const syscall_context& c, const handle file_handle, const handle /*event_handle*/,
                                           const EMULATOR_CAST(emulator_pointer, PIO_APC_ROUTINE) /*apc_routine*/,
                                           const emulator_pointer /*apc_context*/,
                                           const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                           const uint64_t file_information, const uint32_t length, const uint32_t info_class,
                                           const ULONG query_flags, const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> file_name)
    {
        auto* f = c.proc.files.get(file_handle);
        if (!f || !f->is_directory())
        {
            return STATUS_INVALID_HANDLE;
        }

        if (info_class == FileDirectoryInformation)
        {
            return handle_file_enumeration<FILE_DIRECTORY_INFORMATION>(c, io_status_block, file_information, length, query_flags, file_name,
                                                                       f);
        }

        if (info_class == FileFullDirectoryInformation)
        {
            return handle_file_enumeration<FILE_FULL_DIR_INFORMATION>(c, io_status_block, file_information, length, query_flags, file_name,
                                                                      f);
        }

        if (info_class == FileBothDirectoryInformation)
        {
            return handle_file_enumeration<FILE_BOTH_DIR_INFORMATION>(c, io_status_block, file_information, length, query_flags, file_name,
                                                                      f);
        }

        c.win_emu.log.error("Unsupported query directory file info class: %X\n", info_class);
        c.emu.stop();

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryDirectoryFile(const syscall_context& c, const handle file_handle, const handle event_handle,
                                         const EMULATOR_CAST(emulator_pointer, PIO_APC_ROUTINE) apc_routine,
                                         const emulator_pointer apc_context,
                                         const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                         const uint64_t file_information, const uint32_t length, const uint32_t info_class,
                                         const BOOLEAN return_single_entry,
                                         const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> file_name, const BOOLEAN restart_scan)
    {
        ULONG query_flags = 0;
        if (return_single_entry)
        {
            query_flags |= SL_RETURN_SINGLE_ENTRY;
        }
        if (restart_scan)
        {
            query_flags |= SL_RESTART_SCAN;
        }
        return handle_NtQueryDirectoryFileEx(c, file_handle, event_handle, apc_routine, apc_context, io_status_block, file_information,
                                             length, info_class, query_flags, file_name);
    }

    NTSTATUS handle_NtQueryInformationFile(const syscall_context& c, const handle file_handle,
                                           const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                           const uint64_t file_information, const uint32_t length, const uint32_t info_class)
    {
        IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
        block.Status = STATUS_SUCCESS;
        block.Information = 0;

        const auto _ = utils::finally([&] {
            if (io_status_block)
            {
                io_status_block.write(block);
            }
        });

        const auto ret = [&](const NTSTATUS status) {
            block.Status = status;
            return status;
        };

        const auto* f = c.proc.files.get(file_handle);
        if (!f)
        {
            return ret(STATUS_INVALID_HANDLE);
        }

        if (info_class == FileNameInformation || info_class == FileNormalizedNameInformation)
        {
            const auto relative_path = u"\\" + windows_path(f->name).without_drive().u16string();
            const auto required_length = sizeof(FILE_NAME_INFORMATION) + (relative_path.size() * 2);

            block.Information = required_length;

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            c.emu.write_memory(file_information, FILE_NAME_INFORMATION{
                                                     .FileNameLength = static_cast<ULONG>(relative_path.size() * 2),
                                                     .FileName = {},
                                                 });

            c.emu.write_memory(file_information + offsetof(FILE_NAME_INFORMATION, FileName), relative_path.c_str(),
                               (relative_path.size() + 1) * 2);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileStandardInformation)
        {
            block.Information = sizeof(FILE_STANDARD_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            const emulator_object<FILE_STANDARD_INFORMATION> info{c.emu, file_information};
            FILE_STANDARD_INFORMATION i{};
            i.Directory = f->is_directory() ? TRUE : FALSE;

            if (f->handle)
            {
                i.EndOfFile.QuadPart = f->handle.size();
            }

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileBasicInformation)
        {
            block.Information = sizeof(FILE_BASIC_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            struct _stat64 file_stat{};
            if (fstat64(f->handle.file_descriptor(), &file_stat) != 0)
            {
                return STATUS_INVALID_HANDLE;
            }

            const emulator_object<FILE_BASIC_INFORMATION> info{c.emu, file_information};
            FILE_BASIC_INFORMATION i{};

            i.CreationTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            i.LastAccessTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            i.LastWriteTime = utils::convert_unix_to_windows_time(file_stat.st_mtime);
            i.ChangeTime = i.LastWriteTime;
            i.FileAttributes = (file_stat.st_mode & S_IFDIR) != 0 ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL;

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FilePositionInformation)
        {
            if (!f->handle)
            {
                return ret(STATUS_NOT_SUPPORTED);
            }

            block.Information = sizeof(FILE_POSITION_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            const emulator_object<FILE_POSITION_INFORMATION> info{c.emu, file_information};
            FILE_POSITION_INFORMATION i{};

            i.CurrentByteOffset.QuadPart = f->handle.tell();

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileAttributeTagInformation)
        {
            if (!f->handle)
            {
                return ret(STATUS_NOT_SUPPORTED);
            }

            block.Information = sizeof(FILE_ATTRIBUTE_TAG_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            const emulator_object<FILE_ATTRIBUTE_TAG_INFORMATION> info{c.emu, file_information};
            FILE_ATTRIBUTE_TAG_INFORMATION i{};

            i.FileAttributes = f->is_directory() ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL;

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileIsRemoteDeviceInformation)
        {
            if (!f->handle)
            {
                return ret(STATUS_NOT_SUPPORTED);
            }

            block.Information = sizeof(FILE_IS_REMOTE_DEVICE_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            const emulator_object<FILE_IS_REMOTE_DEVICE_INFORMATION> info{c.emu, file_information};
            FILE_IS_REMOTE_DEVICE_INFORMATION i{};

            i.IsRemote = FALSE;

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileIdInformation)
        {
            if (!f->handle)
            {
                return ret(STATUS_NOT_SUPPORTED);
            }

            block.Information = sizeof(FILE_ID_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            struct _stat64 file_stat{};
            if (fstat64(f->handle.file_descriptor(), &file_stat) != 0)
            {
                return ret(STATUS_INVALID_HANDLE);
            }

            const emulator_object<FILE_ID_INFORMATION> info{c.emu, file_information};
            FILE_ID_INFORMATION i{};

            i.VolumeSerialNumber = file_stat.st_dev;
            memset(&i.FileId, 0, sizeof(i.FileId));
            memcpy(&i.FileId.Identifier[0], &file_stat.st_ino, sizeof(file_stat.st_ino));

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileStreamInformation)
        {
            const std::u16string stream_name = u"::$DATA";
            const auto stream_name_len = static_cast<uint32_t>(stream_name.size() * sizeof(char16_t));

            const uint32_t required_length = offsetof(FILE_STREAM_INFORMATION, StreamName) + stream_name_len;
            block.Information = required_length;

            if (length < required_length)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            struct _stat64 file_stat{};
            if (f->handle)
            {
                if (fstat64(f->handle.file_descriptor(), &file_stat) != 0)
                {
                    return ret(STATUS_INVALID_HANDLE);
                }
            }

            FILE_STREAM_INFORMATION info{};
            info.NextEntryOffset = 0;
            info.StreamNameLength = stream_name_len;

            if (f->is_directory())
            {
                info.StreamSize.QuadPart = 0;
                info.StreamAllocationSize.QuadPart = 0;
            }
            else
            {
                info.StreamSize.QuadPart = file_stat.st_size;
                info.StreamAllocationSize.QuadPart = file_stat.st_size;
            }

            c.emu.write_memory(file_information, info);
            c.emu.write_memory(file_information + offsetof(FILE_STREAM_INFORMATION, StreamName), stream_name.c_str(), stream_name_len);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileEaInformation)
        {
            block.Information = sizeof(FILE_EA_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            const emulator_object<FILE_EA_INFORMATION> info{c.emu, file_information};
            FILE_EA_INFORMATION i{};

            i.EaSize = 0;

            info.write(i);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileVolumeNameInformation)
        {
            const std::u16string volume_name = u"\\Device\\HarddiskVolume1";
            const auto name_bytes = static_cast<uint32_t>(volume_name.size() * sizeof(char16_t));

            const uint32_t required_length = offsetof(FILE_VOLUME_NAME_INFORMATION, DeviceName) + name_bytes;
            block.Information = required_length;

            if (length < required_length)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            FILE_VOLUME_NAME_INFORMATION vni{};
            vni.DeviceNameLength = name_bytes;

            c.emu.write_memory(file_information, vni);
            c.emu.write_memory(file_information + offsetof(FILE_VOLUME_NAME_INFORMATION, DeviceName), volume_name.c_str(), name_bytes);

            return ret(STATUS_SUCCESS);
        }

        if (info_class == FileAllInformation)
        {
            return ret(STATUS_NOT_SUPPORTED);
        }

        c.win_emu.log.error("Unsupported query file info class: 0x%X\n", info_class);
        c.emu.stop();

        return ret(STATUS_NOT_SUPPORTED);
    }

    NTSTATUS handle_NtQueryInformationByName(const syscall_context& c,
                                             const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                             const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                             const uint64_t file_information, const uint32_t length, const uint32_t info_class)
    {
        IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
        block.Status = STATUS_SUCCESS;
        block.Information = 0;

        const auto _ = utils::finally([&] {
            if (io_status_block)
            {
                io_status_block.write(block);
            }
        });

        const auto attributes = object_attributes.read();
        auto filename = read_unicode_string(c.emu, attributes.ObjectName);

        c.win_emu.callbacks.on_generic_access("Query file info", filename);

        const auto ret = [&](const NTSTATUS status) {
            block.Status = status;
            return status;
        };

        if (info_class == FileStatBasicInformation)
        {
            block.Information = sizeof(EMU_FILE_STAT_BASIC_INFORMATION);

            if (length < block.Information)
            {
                return ret(STATUS_BUFFER_OVERFLOW);
            }

            auto [native_file_handle, status] = open_file(c.win_emu.file_sys, filename, u"r");
            if (status != STATUS_SUCCESS)
            {
                return ret(status);
            }

            struct _stat64 file_stat{};
            if (fstat64(native_file_handle.file_descriptor(), &file_stat) != 0)
            {
                return STATUS_INVALID_HANDLE;
            }

            EMU_FILE_STAT_BASIC_INFORMATION i{};

            i.CreationTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            i.LastAccessTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            i.LastWriteTime = utils::convert_unix_to_windows_time(file_stat.st_mtime);
            i.ChangeTime = i.LastWriteTime;
            i.FileAttributes = (file_stat.st_mode & S_IFDIR) != 0 ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL;

            c.emu.write_memory(file_information, i);

            return ret(STATUS_SUCCESS);
        }

        c.win_emu.log.error("Unsupported query name info class: %X\n", info_class);
        c.emu.stop();

        return ret(STATUS_NOT_SUPPORTED);
    }

    void commit_file_data(const std::string_view data, emulator& emu,
                          const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, const uint64_t buffer)
    {
        if (io_status_block)
        {
            IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
            block.Information = data.size();
            io_status_block.write(block);
        }

        emu.write_memory(buffer, data.data(), data.size());
    }

    NTSTATUS handle_NtReadFile(const syscall_context& c, const handle file_handle, const uint64_t /*event*/, const uint64_t /*apc_routine*/,
                               const uint64_t /*apc_context*/,
                               const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, const uint64_t buffer,
                               const ULONG length, const emulator_object<LARGE_INTEGER> /*byte_offset*/,
                               const emulator_object<ULONG> /*key*/)
    {
        std::string temp_buffer{};
        temp_buffer.resize(length);

        if (file_handle == STDIN_HANDLE)
        {
            char chr{};
            if (std::cin.readsome(&chr, 1) <= 0)
            {
                std::cin.read(&chr, 1);
            }

            std::cin.putback(chr);

            const auto read_count = std::cin.readsome(temp_buffer.data(), static_cast<std::streamsize>(temp_buffer.size()));
            const auto count = std::max(read_count, static_cast<std::streamsize>(0));

            commit_file_data(std::string_view(temp_buffer.data(), static_cast<size_t>(count)), c.emu, io_status_block, buffer);
            return STATUS_SUCCESS;
        }

        const auto* container = c.proc.devices.get(file_handle);
        if (container)
        {
            if (auto* pipe = container->get_internal_device<named_pipe>())
            {
                if (!pipe->write_queue.empty())
                {
                    std::string_view data = pipe->write_queue.front();
                    const size_t to_copy = std::min<size_t>(data.size(), length);

                    commit_file_data(data.substr(0, to_copy), c.emu, io_status_block, buffer);

                    if (to_copy == data.size())
                    {
                        pipe->write_queue.pop_front();
                    }
                    else
                    {
                        pipe->write_queue.front().erase(0, to_copy);
                    }

                    return STATUS_SUCCESS;
                }

                return STATUS_PIPE_EMPTY;
            }
        }

        const auto* f = c.proc.files.get(file_handle);
        if (!f)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto bytes_read = fread(temp_buffer.data(), 1, temp_buffer.size(), f->handle);
        commit_file_data(std::string_view(temp_buffer.data(), bytes_read), c.emu, io_status_block, buffer);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtWriteFile(const syscall_context& c, const handle file_handle, const uint64_t /*event*/,
                                const uint64_t /*apc_routine*/, const uint64_t /*apc_context*/,
                                const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, const uint64_t buffer,
                                const ULONG length, const emulator_object<LARGE_INTEGER> /*byte_offset*/,
                                const emulator_object<ULONG> /*key*/)
    {
        std::string temp_buffer{};
        temp_buffer.resize(length);
        c.emu.read_memory(buffer, temp_buffer.data(), temp_buffer.size());

        if (file_handle == STDOUT_HANDLE)
        {
            if (io_status_block)
            {
                IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                block.Information = length;
                io_status_block.write(block);
            }

            c.win_emu.callbacks.on_stdout(temp_buffer);

            return STATUS_SUCCESS;
        }

        const auto* container = c.proc.devices.get(file_handle);
        if (container)
        {
            if (auto* pipe = container->get_internal_device<named_pipe>())
            {
                (void)pipe; // For future use: suppressing compiler issues
                // TODO c.win_emu.callbacks.on_named_pipe_write(pipe->name, temp_buffer);

                // TODO pipe->write_queue.push_back(temp_buffer);

                if (io_status_block)
                {
                    IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
                    block.Information = static_cast<ULONG>(temp_buffer.size());
                    io_status_block.write(block);
                }

                return STATUS_SUCCESS;
            }
        }

        const auto* f = c.proc.files.get(file_handle);
        if (!f)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto bytes_written = fwrite(temp_buffer.data(), 1, temp_buffer.size(), f->handle);

        if (io_status_block)
        {
            IO_STATUS_BLOCK<EmulatorTraits<Emu64>> block{};
            block.Information = bytes_written;
            io_status_block.write(block);
        }

        return STATUS_SUCCESS;
    }

    constexpr std::u16string map_mode(const ACCESS_MASK desired_access, const ULONG create_disposition)
    {
        std::u16string mode{};

        switch (create_disposition)
        {
        case FILE_CREATE:
        case FILE_SUPERSEDE:
            if (desired_access & GENERIC_WRITE)
            {
                mode = u"wb";
            }
            break;

        case FILE_OPEN:
        case FILE_OPEN_IF:
            if (desired_access & GENERIC_WRITE)
            {
                mode = u"r+b";
            }
            else if (desired_access & GENERIC_READ || desired_access & SYNCHRONIZE)
            {
                mode = u"rb";
            }
            break;

        case FILE_OVERWRITE:
        case FILE_OVERWRITE_IF:
            if (desired_access & GENERIC_WRITE)
            {
                mode = u"w+b";
            }
            break;

        default:
            mode = u"";
            break;
        }

        if (desired_access & FILE_APPEND_DATA)
        {
            mode = u"a+b";
        }

        return mode;
    }

    std::optional<std::u16string_view> get_io_device_name(const std::u16string_view filename)
    {
        constexpr std::u16string_view device_prefix = u"\\Device\\";
        if (filename.starts_with(device_prefix))
        {
            return filename.substr(device_prefix.size());
        }

        constexpr std::u16string_view unc_prefix = u"\\??\\";
        if (!filename.starts_with(unc_prefix))
        {
            return std::nullopt;
        }

        const auto path = filename.substr(unc_prefix.size());

        const std::set<std::u16string, std::less<>> devices{
            u"Nsi",
            u"MountPointManager",
        };

        if (devices.contains(path))
        {
            return path;
        }

        return std::nullopt;
    }

    NTSTATUS handle_named_pipe_create(const syscall_context& c, const emulator_object<handle>& out_handle,
                                      const std::u16string_view filename, const OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>& attributes,
                                      ACCESS_MASK desired_access)
    {
        (void)attributes; // This isn't being consumed atm, suppressing errors

        c.win_emu.callbacks.on_generic_access("Creating/opening named pipe", filename);

        io_device_creation_data data{};

        std::u16string device_name = u"NamedPipe";

        io_device_container container{device_name, c.win_emu, data};

        if (auto* pipe_device = container.get_internal_device<named_pipe>())
        {
            pipe_device->name = std::u16string(filename);
            pipe_device->access = desired_access;
        }

        const auto handle = c.proc.devices.store(std::move(container));
        out_handle.write(handle);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCreateFile(const syscall_context& c, const emulator_object<handle> file_handle, ACCESS_MASK desired_access,
                                 const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                 const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> /*io_status_block*/,
                                 const emulator_object<LARGE_INTEGER> /*allocation_size*/, ULONG /*file_attributes*/,
                                 ULONG /*share_access*/, ULONG create_disposition, ULONG create_options, uint64_t ea_buffer,
                                 ULONG ea_length)
    {
        const auto attributes = object_attributes.read();
        auto filename = read_unicode_string(c.emu, attributes.ObjectName);

        // Check for console device paths
        // Convert to uppercase for case-insensitive comparison
        std::u16string filename_upper = filename;
        std::transform(filename_upper.begin(), filename_upper.end(), filename_upper.begin(), ::towupper);

        // Handle console output device
        if (filename_upper == u"\\??\\CONOUT$" || filename_upper == u"\\DEVICE\\CONOUT$" || filename_upper == u"CONOUT$" ||
            filename_upper == u"\\??\\CON" || filename_upper == u"\\DEVICE\\CONSOLE" || filename_upper == u"CON")
        {
            c.win_emu.callbacks.on_generic_access("Opening console output", filename);
            file_handle.write(STDOUT_HANDLE);
            return STATUS_SUCCESS;
        }

        // Handle console input device
        if (filename_upper == u"\\??\\CONIN$" || filename_upper == u"\\DEVICE\\CONIN$" || filename_upper == u"CONIN$")
        {
            c.win_emu.callbacks.on_generic_access("Opening console input", filename);
            file_handle.write(STDIN_HANDLE);
            return STATUS_SUCCESS;
        }

        if (is_named_pipe_path(filename))
        {
            return handle_named_pipe_create(c, file_handle, filename, attributes, desired_access);
        }

        auto printer = utils::finally([&] {
            c.win_emu.callbacks.on_generic_access("Opening file", filename); //
        });

        const auto io_device_name = get_io_device_name(filename);
        if (io_device_name.has_value())
        {
            const io_device_creation_data data{
                .buffer = ea_buffer,
                .length = ea_length,
            };

            io_device_container container{std::u16string(*io_device_name), c.win_emu, data};

            const auto handle = c.proc.devices.store(std::move(container));
            file_handle.write(handle);

            return STATUS_SUCCESS;
        }

        handle root_handle{};
        root_handle.bits = attributes.RootDirectory;
        if (root_handle.value.is_pseudo && (filename == u"\\Reference" || filename == u"\\Connect"))
        {
            file_handle.write(root_handle);
            return STATUS_SUCCESS;
        }

        if (filename == u"\\??\\CONOUT$")
        {
            file_handle.write(STDOUT_HANDLE);
            return STATUS_SUCCESS;
        }

        file f{};
        f.name = std::move(filename);

        if (attributes.RootDirectory)
        {
            const auto* root = c.proc.files.get(attributes.RootDirectory);
            if (!root)
            {
                return STATUS_INVALID_HANDLE;
            }

            const auto has_separator = root->name.ends_with(u"\\") || root->name.ends_with(u"/");
            f.name = root->name + (has_separator ? u"" : u"\\") + f.name;
        }

        printer.cancel();

        std::error_code ec{};

        const windows_path path = f.name;

        if (!path.is_absolute())
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        const auto host_path = c.win_emu.file_sys.translate(path);
        const bool is_directory = std::filesystem::is_directory(host_path, ec);

        if (is_directory || create_options & FILE_DIRECTORY_FILE)
        {
            c.win_emu.callbacks.on_generic_access("Opening folder", f.name);

            if (create_disposition == FILE_CREATE || create_disposition == FILE_OPEN_IF)
            {
                if (create_disposition == FILE_CREATE && std::filesystem::exists(host_path))
                {
                    return STATUS_OBJECT_NAME_COLLISION;
                }

                if (!std::filesystem::is_directory(host_path.parent_path()))
                {
                    return STATUS_OBJECT_PATH_NOT_FOUND;
                }

                create_directory(host_path, ec);

                if (ec)
                {
                    return STATUS_ACCESS_DENIED;
                }
            }
            else if (!is_directory)
            {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            const auto handle = c.proc.files.store(std::move(f));
            file_handle.write(handle);

            return STATUS_SUCCESS;
        }

        c.win_emu.callbacks.on_generic_access("Opening file", f.name);

        const bool file_exists = std::filesystem::exists(host_path, ec);

        if (create_disposition == FILE_CREATE && file_exists)
        {
            return STATUS_OBJECT_NAME_COLLISION;
        }

        if ((create_disposition == FILE_OVERWRITE || create_disposition == FILE_OPEN) && !file_exists)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        if (create_disposition == FILE_OPEN_IF && !file_exists)
        {
            std::ofstream touch(host_path, std::ios::binary | std::ios::app);
            if (!touch)
            {
                return STATUS_ACCESS_DENIED;
            }
        }

        std::u16string mode = map_mode(desired_access, create_disposition);

        if (mode.empty() || path.is_relative())
        {
            return STATUS_NOT_SUPPORTED;
        }

        auto [native_file_handle, status] = open_file(c.win_emu.file_sys, path, mode);
        if (status != STATUS_SUCCESS)
        {
            return status;
        }

        f.handle = std::move(native_file_handle);
        f.open_mode = mode;
        f.host_path = host_path;

        const auto handle = c.proc.files.store(std::move(f));
        file_handle.write(handle);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryFullAttributesFile(const syscall_context& c,
                                              const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                              const emulator_object<FILE_NETWORK_OPEN_INFORMATION> file_information)
    {
        if (!object_attributes)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto attributes = object_attributes.read();
        if (!attributes.ObjectName)
        {
            return STATUS_INVALID_PARAMETER;
        }

        auto filename = read_unicode_string(c.emu, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>>{c.emu, attributes.ObjectName});

        if (attributes.RootDirectory)
        {
            const auto* root = c.proc.files.get(attributes.RootDirectory);
            if (!root)
            {
                return STATUS_INVALID_HANDLE;
            }

            const auto has_separator = root->name.ends_with(u"\\") || root->name.ends_with(u"/");
            filename = root->name + (has_separator ? u"" : u"\\") + filename;
        }

        c.win_emu.callbacks.on_generic_access("Querying file attributes", filename);

        const auto local_filename = c.win_emu.file_sys.translate(filename).u8string();

        struct _stat64 file_stat{};
        if (_stat64(reinterpret_cast<const char*>(local_filename.c_str()), &file_stat) != 0)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        file_information.access([&](FILE_NETWORK_OPEN_INFORMATION& info) {
            info.CreationTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            info.LastAccessTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            info.LastWriteTime = utils::convert_unix_to_windows_time(file_stat.st_mtime);
            info.AllocationSize.QuadPart = file_stat.st_size;
            info.EndOfFile.QuadPart = file_stat.st_size;
            info.ChangeTime = info.LastWriteTime;
            info.FileAttributes = (file_stat.st_mode & S_IFDIR) != 0 ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL;
        });

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryAttributesFile(const syscall_context& c,
                                          const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                          const emulator_object<FILE_BASIC_INFORMATION> file_information)
    {
        if (!object_attributes)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto attributes = object_attributes.read();
        if (!attributes.ObjectName)
        {
            return STATUS_INVALID_PARAMETER;
        }

        auto filename = read_unicode_string(c.emu, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>>{c.emu, attributes.ObjectName});

        if (attributes.RootDirectory)
        {
            const auto* root = c.proc.files.get(attributes.RootDirectory);
            if (!root)
            {
                return STATUS_INVALID_HANDLE;
            }

            const auto has_separator = root->name.ends_with(u"\\") || root->name.ends_with(u"/");
            filename = root->name + (has_separator ? u"" : u"\\") + filename;
        }

        c.win_emu.callbacks.on_generic_access("Querying file attributes", filename);

        windows_path filepath(filename);
        if (filepath.is_relative())
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        const auto local_filename = c.win_emu.file_sys.translate(filepath).u8string();

        struct _stat64 file_stat{};
        if (_stat64(reinterpret_cast<const char*>(local_filename.c_str()), &file_stat) != 0)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        file_information.access([&](FILE_BASIC_INFORMATION& info) {
            info.CreationTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            info.LastAccessTime = utils::convert_unix_to_windows_time(file_stat.st_atime);
            info.LastWriteTime = utils::convert_unix_to_windows_time(file_stat.st_mtime);
            info.ChangeTime = info.LastWriteTime;
            info.FileAttributes = (file_stat.st_mode & S_IFDIR) != 0 ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL;
        });

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtOpenFile(const syscall_context& c, const emulator_object<handle> file_handle, const ACCESS_MASK desired_access,
                               const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                               const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, const ULONG share_access,
                               const ULONG open_options)
    {
        return handle_NtCreateFile(c, file_handle, desired_access, object_attributes, io_status_block, {c.emu}, 0, share_access, FILE_OPEN,
                                   open_options, 0, 0);
    }

    NTSTATUS handle_NtOpenDirectoryObject(const syscall_context& c, const emulator_object<handle> directory_handle,
                                          const ACCESS_MASK /*desired_access*/,
                                          const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        const auto attributes = object_attributes.read();
        const auto object_name = read_unicode_string(c.emu, attributes.ObjectName);

        if (object_name == u"\\KnownDlls")
        {
            directory_handle.write(KNOWN_DLLS_DIRECTORY);
            return STATUS_SUCCESS;
        }

        if (object_name == u"\\KnownDlls32")
        {
            directory_handle.write(KNOWN_DLLS32_DIRECTORY);
            return STATUS_SUCCESS;
        }

        if (object_name == u"\\Sessions\\1\\BaseNamedObjects")
        {
            directory_handle.write(BASE_NAMED_OBJECTS_DIRECTORY);
            return STATUS_SUCCESS;
        }

        if (object_name == u"\\RPC Control")
        {
            directory_handle.write(RPC_CONTROL_DIRECTORY);
            return STATUS_SUCCESS;
        }

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtCreateDirectoryObject(const syscall_context& /*c*/, const emulator_object<handle> /*directory_handle*/,
                                            const ACCESS_MASK /*desired_access*/,
                                            const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        const auto attributes = object_attributes.read();

        if (attributes.ObjectName == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtOpenSymbolicLinkObject(const syscall_context& c, const emulator_object<handle> link_handle,
                                             ACCESS_MASK /*desired_access*/,
                                             const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        const auto attributes = object_attributes.read();
        const auto object_name = read_unicode_string(c.emu, attributes.ObjectName);

        if (object_name == u"KnownDllPath")
        {
            link_handle.write(KNOWN_DLLS_SYMLINK);
            return STATUS_SUCCESS;
        }

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQuerySymbolicLinkObject(const syscall_context& c, const handle link_handle,
                                              const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> link_target,
                                              const emulator_object<ULONG> returned_length)
    {
        auto write_target = [&](const std::u16string& target) -> NTSTATUS {
            const auto str_length = static_cast<uint16_t>(target.size() * sizeof(char16_t));
            const auto max_length = static_cast<ULONG>(str_length + sizeof(char16_t));

            returned_length.write(max_length);

            bool too_small = false;
            link_target.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& str) {
                if (str.MaximumLength < max_length)
                {
                    too_small = true;
                    return;
                }

                str.Length = str_length;
                c.emu.write_memory(str.Buffer, target.data(), max_length);
            });

            return too_small ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
        };

        const auto& system_root = c.win_emu.version.get_system_root();

        if (link_handle == KNOWN_DLLS_SYMLINK)
        {
            return write_target((system_root / "System32").u16string());
        }

        if (link_handle == KNOWN_DLLS32_SYMLINK)
        {
            return write_target((system_root / "SysWOW64").u16string());
        }

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtCreateNamedPipeFile(const syscall_context& c, emulator_object<handle> file_handle, ULONG desired_access,
                                          emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                          emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block, ULONG share_access,
                                          ULONG create_disposition, ULONG create_options, ULONG named_pipe_type, ULONG read_mode,
                                          ULONG completion_mode, ULONG maximum_instances, ULONG inbound_quota, ULONG outbound_quota,
                                          emulator_object<LARGE_INTEGER> default_timeout)
    {
        (void)desired_access;
        (void)share_access;
        (void)create_disposition;
        (void)create_options;

        const auto attributes = object_attributes.read();
        const auto filename = read_unicode_string(c.emu, attributes.ObjectName);

        if (!filename.starts_with(u"\\Device\\NamedPipe"))
        {
            return STATUS_NOT_SUPPORTED;
        }

        c.win_emu.callbacks.on_generic_access("Creating named pipe", filename);

        io_device_creation_data data{};
        io_device_container container{u"NamedPipe", c.win_emu, data};

        if (auto* pipe_device = container.get_internal_device<named_pipe>())
        {
            pipe_device->name = filename;
            pipe_device->pipe_type = named_pipe_type;
            pipe_device->read_mode = read_mode;
            pipe_device->completion_mode = completion_mode;
            pipe_device->max_instances = maximum_instances;
            pipe_device->inbound_quota = inbound_quota;
            pipe_device->outbound_quota = outbound_quota;
            pipe_device->default_timeout = default_timeout.read();
        }
        else
        {
            return STATUS_NOT_SUPPORTED;
        }

        handle pipe_handle = c.proc.devices.store(std::move(container));
        file_handle.write(pipe_handle);

        IO_STATUS_BLOCK<EmulatorTraits<Emu64>> iosb{};
        iosb.Status = STATUS_SUCCESS;
        iosb.Information = 0;
        io_status_block.write(iosb);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtFsControlFile(const syscall_context& c, const handle /*event_handle*/, const uint64_t /*apc_routine*/,
                                    const uint64_t /*app_context*/,
                                    const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> /*io_status_block*/,
                                    const ULONG /*fs_control_code*/, const uint64_t /*input_buffer*/, const ULONG /*input_buffer_length*/,
                                    const uint64_t /*output_buffer*/, const ULONG /*output_buffer_length*/)
    {
        c.win_emu.log.error("Unimplemented syscall NtFsControlFile!");
        c.emu.stop();

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtFlushBuffersFile(const syscall_context& c, const handle file_handle,
                                       const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> /*io_status_block*/)
    {
        if (file_handle == STDOUT_HANDLE)
        {
            return STATUS_SUCCESS;
        }

        const auto* f = c.proc.files.get(file_handle);
        if (!f)
        {
            return STATUS_INVALID_HANDLE;
        }

        (void)fflush(f->handle);
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/gdi.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

#include <array>
#include <bit>
#include <limits>

namespace syscalls
{
    namespace
    {
        struct GDI_HANDLE_ENTRY32
        {
            uint32_t Object;
            uint32_t OwnerValue;
            USHORT Unique;
            UCHAR Type;
            UCHAR Flags;
            uint32_t UserPointer;
        };
        static_assert(sizeof(GDI_HANDLE_ENTRY32) == 0x10);

        constexpr uint8_t k_gdi_dc_type = 0x01;
        constexpr uint8_t k_gdi_bitmap_type = 0x05;
        constexpr uint8_t k_gdi_font_type = 0x0A;
        constexpr uint8_t k_gdi_brush_type = 0x10;
        constexpr uint8_t k_gdi_pen_type = 0x30;

        constexpr uint32_t k_gdi_dc_attr_size = 0x130;
        constexpr uint32_t k_gdi_brush_attr_size = 0x20;
        constexpr uint32_t k_gdi_pen_attr_size = 0x20;
        constexpr uint32_t k_gdi_bitmap_attr_size = 0x20;
        constexpr uint32_t k_gdi_font_attr_size = 0x40;

        constexpr uint32_t k_gdi_dc_attr_font_offset = 0x128;

        constexpr uint32_t k_stock_white_brush_index = 0x00;
        constexpr uint32_t k_stock_black_pen_index = 0x06;
        constexpr uint32_t k_stock_system_font_index = 0x0D;
        constexpr uint32_t k_stock_default_gui_font_index = 0x11;
        constexpr uint32_t k_stock_dc_brush_index = 0x12;
        constexpr uint32_t k_stock_dc_pen_index = 0x13;
        constexpr uint32_t k_default_gui_font_data_index = 0x07;
        constexpr uint32_t k_user_client_drawing_brush_index = USER_NUM_SYSCOLORS;
        static_assert(k_user_client_drawing_brush_index < USER_SERVERINFO_BRUSH_SLOT_COUNT,
                      "client drawing brush index must be inside server info brush table");

        constexpr uint32_t k_logfontw_size = 0x5C;
        constexpr uint32_t k_logbrush_size = 0x0C;
        constexpr uint32_t k_logpen_size = 0x10;
        constexpr uint32_t k_bitmap_size = 0x18;

        constexpr uint32_t k_textmetric_size = 0x3C;
        constexpr uint32_t k_default_font_height = 16;
        constexpr uint32_t k_default_font_ascent = 12;
        constexpr uint32_t k_default_font_descent = 4;
        constexpr uint32_t k_default_font_width = 8;
        constexpr uint32_t k_default_font_weight = 400;

        constexpr uint32_t k_default_dpi = 96;
        constexpr uint32_t k_default_width = 1920;
        constexpr uint32_t k_default_height = 1080;

        constexpr uint32_t k_gdi_first_dynamic_handle = 0x2000;
        constexpr uint32_t k_gdi_default_cookie = STATUS_WAIT_1;

        uint64_t ensure_gdi_shared_table(const syscall_context& c)
        {
            uint64_t table = 0;
            c.proc.peb64.access([&](const PEB64& peb) { table = peb.GdiSharedHandleTable; });

            if (table != 0)
            {
                return table;
            }

            const auto shared = c.proc.base_allocator.reserve<GDI_SHARED_MEMORY64>();
            shared.access([](GDI_SHARED_MEMORY64& mem) { mem = {}; });
            table = shared.value();

            c.proc.peb64.access([&](PEB64& peb) { peb.GdiSharedHandleTable = table; });

            if (c.proc.peb32 && table <= std::numeric_limits<uint32_t>::max())
            {
                c.proc.peb32->access([&](PEB32& peb32) { peb32.GdiSharedHandleTable = static_cast<uint32_t>(table); });
            }

            return table;
        }

        uint64_t ensure_gdi_cookie(const syscall_context& c)
        {
            uint64_t cookie = 0;
            c.proc.peb64.access([&](PEB64& peb) {
                if (peb.GdiDCAttributeList == 0)
                {
                    peb.GdiDCAttributeList = k_gdi_default_cookie;
                }

                cookie = peb.GdiDCAttributeList;
            });

            if (c.proc.peb32)
            {
                c.proc.peb32->access([&](PEB32& peb32) {
                    if (peb32.GdiDCAttributeList == 0)
                    {
                        peb32.GdiDCAttributeList = static_cast<uint32_t>(cookie);
                    }
                });
            }

            return cookie;
        }

        uint64_t encode_gdi_user_pointer(const syscall_context& c, const uint64_t pointer, const uint64_t cookie)
        {
            if (pointer == 0)
            {
                return 0;
            }

            if (c.proc.is_wow64_process)
            {
                if (pointer > std::numeric_limits<uint32_t>::max())
                {
                    return 0;
                }

                // wow64 gdi32full decodes low 32 bits: ror.d(encoded, 32 - (cookie & 0x1f)) ^ cookie
                const auto pointer32 = static_cast<uint32_t>(pointer);
                const auto cookie32 = static_cast<uint32_t>(cookie);
                const uint32_t decoded = pointer32 ^ cookie32;
                const auto rotate = static_cast<int>(32 - (cookie32 & 0x1F));
                return std::rotl(decoded, rotate);
            }

            // x64 gdi32full decodes UserPointer: ror.q(encoded, 64 - (cookie & 0x3f)) ^ cookie
            const uint64_t decoded = pointer ^ cookie;
            const auto rotate = static_cast<int>(64 - (cookie & 0x3F));
            return std::rotl(decoded, rotate);
        }

        uint64_t read_gdi_shared_value(const syscall_context& c, const uint64_t offset)
        {
            const auto table = ensure_gdi_shared_table(c);
            if (table == 0)
            {
                return 0;
            }

            uint64_t value = 0;
            c.emu.read_memory(table + offset, &value, sizeof(value));
            return value;
        }

        uint64_t read_gdi_object_slot(const syscall_context& c, const uint32_t index)
        {
            if (index >= 0x20)
            {
                return 0;
            }

            return read_gdi_shared_value(c, offsetof(GDI_SHARED_MEMORY64, Objects) + (sizeof(uint64_t) * index));
        }

        bool write_gdi_object_slot(const syscall_context& c, const uint32_t index, const uint64_t value)
        {
            if (index >= 0x20)
            {
                return false;
            }

            const auto table = ensure_gdi_shared_table(c);
            if (table == 0)
            {
                return false;
            }

            const auto slot = table + offsetof(GDI_SHARED_MEMORY64, Objects) + (sizeof(uint64_t) * index);
            c.emu.write_memory(slot, &value, sizeof(value));
            return true;
        }

        uint64_t read_gdi_data_slot(const syscall_context& c, const uint32_t index)
        {
            if (index >= 0x200)
            {
                return 0;
            }

            return read_gdi_shared_value(c, offsetof(GDI_SHARED_MEMORY64, Data) + (sizeof(uint64_t) * index));
        }

        bool write_gdi_data_slot(const syscall_context& c, const uint32_t index, const uint64_t value)
        {
            if (index >= 0x200)
            {
                return false;
            }

            const auto table = ensure_gdi_shared_table(c);
            if (table == 0)
            {
                return false;
            }

            const auto slot = table + offsetof(GDI_SHARED_MEMORY64, Data) + (sizeof(uint64_t) * index);
            c.emu.write_memory(slot, &value, sizeof(value));
            return true;
        }

        uint64_t allocate_gdi_user_block(const syscall_context& c, const uint32_t size)
        {
            const auto aligned_size = static_cast<size_t>(page_align_up(size));
            const uint64_t base =
                c.win_emu.memory.allocate_memory(aligned_size, memory_permission::read_write, false, DEFAULT_ALLOCATION_ADDRESS_32BIT);
            if (base == 0)
            {
                return 0;
            }

            if (base > std::numeric_limits<uint32_t>::max())
            {
                c.win_emu.memory.release_memory(base, 0);
                return 0;
            }

            std::vector<uint8_t> zeroed(size, 0);
            c.emu.write_memory(base, zeroed.data(), zeroed.size());
            return base;
        }

        uint32_t allocate_gdi_handle(const syscall_context& c, const uint8_t type, const uint64_t user_ptr, const uint64_t object_ptr)
        {
            const auto table = ensure_gdi_shared_table(c);
            if (table == 0)
            {
                return 0;
            }

            const uint64_t cookie = ensure_gdi_cookie(c);
            const uint64_t encoded_user_ptr = encode_gdi_user_pointer(c, user_ptr, cookie);

            for (uint32_t index = k_gdi_first_dynamic_handle; index < GDI_MAX_HANDLE_COUNT; ++index)
            {
                const uint64_t entry_addr = table + (static_cast<uint64_t>(index) * sizeof(GDI_HANDLE_ENTRY64));
                const emulator_object<GDI_HANDLE_ENTRY64> entry_obj{c.emu, entry_addr};
                const auto current = entry_obj.read();

                if (current.Type != 0)
                {
                    continue;
                }

                auto generation = static_cast<uint16_t>((current.Unique + 0x100u) & 0xFF00u);
                if (generation == 0)
                {
                    generation = 0x100;
                }

                const auto unique = static_cast<uint16_t>(generation | (type & 0x7Fu));
                const uint32_t handle_value = (static_cast<uint32_t>(unique) << 16) | index;

                entry_obj.access([&](GDI_HANDLE_ENTRY64& writable) {
                    writable = {};
                    writable.Object = object_ptr;
                    writable.Owner.Value = 0;
                    writable.Unique = unique;
                    writable.Type = type;
                    writable.Flags = 0;
                    writable.UserPointer = encoded_user_ptr;
                });

                return handle_value;
            }

            return 0;
        }

        uint32_t allocate_gdi_object(const syscall_context& c, const uint8_t type, const uint32_t attr_size)
        {
            const uint64_t attr = allocate_gdi_user_block(c, attr_size);
            if (attr == 0)
            {
                return 0;
            }

            const uint64_t user_ptr = (type == k_gdi_font_type) ? 0 : attr;
            return allocate_gdi_handle(c, type, user_ptr, attr);
        }

        void seed_user_system_color_brushes(const syscall_context& c)
        {
            constexpr size_t k_brush_seed_count =
                USER_NUM_SYSCOLORS < USER_SERVERINFO_BRUSH_SLOT_COUNT ? USER_NUM_SYSCOLORS : USER_SERVERINFO_BRUSH_SLOT_COUNT;

            std::array<uint64_t, k_brush_seed_count> system_brushes{};
            uint64_t client_drawing_brush = 0;
            bool needs_seed = false;

            c.proc.user_handles.get_server_info().access([&](const USER_SERVERINFO& server_info) {
                for (size_t i = 0; i < system_brushes.size(); ++i)
                {
                    system_brushes[i] = server_info.ahbrSystem[i];
                    if (system_brushes[i] == 0)
                    {
                        needs_seed = true;
                    }
                }

                client_drawing_brush = server_info.ahbrSystem[k_user_client_drawing_brush_index];
                if (client_drawing_brush == 0)
                {
                    needs_seed = true;
                }
            });

            if (!needs_seed)
            {
                return;
            }

            for (auto& brush : system_brushes)
            {
                if (brush != 0)
                {
                    continue;
                }

                const uint32_t handle = allocate_gdi_object(c, k_gdi_brush_type, k_gdi_brush_attr_size);
                if (handle != 0)
                {
                    brush = handle;
                }
            }

            if (client_drawing_brush == 0)
            {
                const uint32_t handle = allocate_gdi_object(c, k_gdi_brush_type, k_gdi_brush_attr_size);
                if (handle != 0)
                {
                    client_drawing_brush = handle;
                }
            }

            c.proc.user_handles.get_server_info().access([&](USER_SERVERINFO& server_info) {
                for (size_t i = 0; i < system_brushes.size(); ++i)
                {
                    if (server_info.ahbrSystem[i] == 0)
                    {
                        server_info.ahbrSystem[i] = system_brushes[i];
                    }
                }

                if (server_info.ahbrSystem[k_user_client_drawing_brush_index] == 0)
                {
                    server_info.ahbrSystem[k_user_client_drawing_brush_index] = client_drawing_brush;
                }
            });
        }

        void seed_gdi_stock_objects(const syscall_context& c)
        {
            struct stock_seed
            {
                uint32_t index;
                uint8_t type;
                uint32_t attr_size;
                bool mirror_to_default_gui_slot;
            };

            constexpr std::array<stock_seed, 6> seeds = {
                stock_seed{k_stock_white_brush_index, k_gdi_brush_type, k_gdi_brush_attr_size, false},
                stock_seed{k_stock_black_pen_index, k_gdi_pen_type, k_gdi_pen_attr_size, false},
                stock_seed{k_stock_system_font_index, k_gdi_font_type, k_gdi_font_attr_size, false},
                stock_seed{k_stock_default_gui_font_index, k_gdi_font_type, k_gdi_font_attr_size, true},
                stock_seed{k_stock_dc_brush_index, k_gdi_brush_type, k_gdi_brush_attr_size, false},
                stock_seed{k_stock_dc_pen_index, k_gdi_pen_type, k_gdi_pen_attr_size, false},
            };

            for (const auto& seed : seeds)
            {
                if (read_gdi_object_slot(c, seed.index) != 0)
                {
                    continue;
                }

                const uint32_t handle = allocate_gdi_object(c, seed.type, seed.attr_size);
                if (handle == 0)
                {
                    continue;
                }

                const uint64_t handle64 = handle;
                write_gdi_object_slot(c, seed.index, handle64);

                if (seed.mirror_to_default_gui_slot)
                {
                    write_gdi_data_slot(c, k_default_gui_font_data_index, handle64);
                }
            }

            if (read_gdi_data_slot(c, k_default_gui_font_data_index) == 0)
            {
                const auto default_gui_font = read_gdi_object_slot(c, k_stock_default_gui_font_index);
                if (default_gui_font != 0)
                {
                    write_gdi_data_slot(c, k_default_gui_font_data_index, default_gui_font);
                }
            }

            seed_user_system_color_brushes(c);
        }

        void initialize_dc_attr(const syscall_context& c, const uint64_t dc_attr)
        {
            std::array<uint8_t, k_gdi_dc_attr_size> zeroed{};
            c.emu.write_memory(dc_attr, zeroed.data(), zeroed.size());

            const uint64_t system_font = read_gdi_object_slot(c, k_stock_system_font_index);
            if (system_font != 0)
            {
                const auto handle_value = static_cast<uint32_t>(system_font);
                c.emu.write_memory(dc_attr + k_gdi_dc_attr_font_offset, &handle_value, sizeof(handle_value));
            }
        }

        uint32_t allocate_gdi_dc(const syscall_context& c, uint64_t& dc_attr)
        {
            seed_gdi_stock_objects(c);

            dc_attr = allocate_gdi_user_block(c, k_gdi_dc_attr_size);
            if (dc_attr == 0)
            {
                return 0;
            }

            initialize_dc_attr(c, dc_attr);
            return allocate_gdi_handle(c, k_gdi_dc_type, dc_attr, dc_attr);
        }

        hdc ensure_default_hdc(const syscall_context& c)
        {
            if (c.proc.gdi_default_dc_handle != 0)
            {
                return c.proc.gdi_default_dc_handle;
            }

            uint64_t dc_attr = 0;
            const uint32_t handle_value = allocate_gdi_dc(c, dc_attr);
            if (handle_value == 0)
            {
                return 0;
            }

            c.proc.gdi_default_dc_handle = handle_value;
            return handle_value;
        }

        uint32_t get_device_caps_value(const uint32_t index)
        {
            switch (index)
            {
            case 4: // HORZSIZE
                return (k_default_width * 254) / (k_default_dpi * 10);
            case 6: // VERTSIZE
                return (k_default_height * 254) / (k_default_dpi * 10);
            case 8:    // HORZRES
            case 0x76: // DESKTOPHORZRES
                return k_default_width;
            case 0xA:  // VERTRES
            case 0x75: // DESKTOPVERTRES
                return k_default_height;
            case 0x28: // PLANES
            case 0x2A: // NUMBRUSHES
            case 0x2C: // NUMPENS
                return 1;
            case 0x58: // LOGPIXELSX
            case 0x5A: // LOGPIXELSY
                return k_default_dpi;
            default:
                return 0;
            }
        }

        void write_device_caps(const syscall_context& c, const emulator_pointer caps_ptr, const size_t count)
        {
            std::vector<uint32_t> caps(count, 0);
            const auto set_cap = [&](const size_t idx, const uint32_t value) {
                if (idx < caps.size())
                {
                    caps[idx] = value;
                }
            };

            set_cap(4, get_device_caps_value(4));
            set_cap(6, get_device_caps_value(6));
            set_cap(8, get_device_caps_value(8));
            set_cap(0xA, get_device_caps_value(0xA));
            set_cap(0x28, get_device_caps_value(0x28));
            set_cap(0x2A, get_device_caps_value(0x2A));
            set_cap(0x2C, get_device_caps_value(0x2C));
            set_cap(0x58, get_device_caps_value(0x58));
            set_cap(0x5A, get_device_caps_value(0x5A));

            if (caps_ptr != 0)
            {
                c.emu.write_memory(caps_ptr, caps.data(), caps.size() * sizeof(uint32_t));
            }
        }

        uint32_t get_gdi_object_size(const uint8_t type)
        {
            switch (type)
            {
            case k_gdi_brush_type:
                return k_logbrush_size;
            case k_gdi_pen_type:
                return k_logpen_size;
            case k_gdi_font_type:
                return k_logfontw_size;
            case k_gdi_bitmap_type:
                return k_bitmap_size;
            default:
                return 0;
            }
        }

        bool read_gdi_entry_for_handle(const syscall_context& c, const uint32_t handle_value, GDI_HANDLE_ENTRY64& entry,
                                       uint64_t& entry_addr)
        {
            const auto table = ensure_gdi_shared_table(c);
            if (table == 0)
            {
                return false;
            }

            const uint32_t index = handle_value & 0xFFFF;
            if (index >= GDI_MAX_HANDLE_COUNT)
            {
                return false;
            }

            entry_addr = table + (static_cast<uint64_t>(index) * sizeof(GDI_HANDLE_ENTRY64));
            const emulator_object<GDI_HANDLE_ENTRY64> entry_obj{c.emu, entry_addr};
            entry = entry_obj.read();

            const auto unique = static_cast<uint16_t>(handle_value >> 16);
            return entry.Type != 0 && entry.Unique == unique;
        }
    }

    NTSTATUS handle_NtGdiInit(const syscall_context& c)
    {
        if (ensure_gdi_shared_table(c) == 0)
        {
            return STATUS_UNSUCCESSFUL;
        }

        const auto cookie = ensure_gdi_cookie(c);
        seed_gdi_stock_objects(c);

        return static_cast<NTSTATUS>(cookie);
    }

    NTSTATUS handle_NtGdiInit2(const syscall_context& c)
    {
        return handle_NtGdiInit(c);
    }

    uint32_t handle_NtGdiGetDeviceCaps(const syscall_context&, const hdc /*dc*/, const uint32_t index)
    {
        return get_device_caps_value(index);
    }

    uint32_t handle_NtGdiGetDeviceCapsAll(const syscall_context& c, const hdc /*dc*/, const emulator_pointer caps)
    {
        write_device_caps(c, caps, 0x24);
        return 1;
    }

    uint32_t handle_NtGdiComputeXformCoefficients(const syscall_context&, const hdc dc)
    {
        return dc ? 1 : 0;
    }

    uint64_t handle_NtGdiCreateSolidBrush(const syscall_context& c, const uint32_t /*color*/, const uint64_t /*unused*/)
    {
        return allocate_gdi_object(c, k_gdi_brush_type, k_gdi_brush_attr_size);
    }

    uint64_t handle_NtGdiCreatePatternBrushInternal(const syscall_context& c, const handle /*bitmap*/, const uint32_t /*unused*/)
    {
        return allocate_gdi_object(c, k_gdi_brush_type, k_gdi_brush_attr_size);
    }

    uint64_t handle_NtGdiCreatePen(const syscall_context& c, const uint32_t /*style*/, const uint32_t /*width*/, const uint32_t /*color*/)
    {
        return allocate_gdi_object(c, k_gdi_pen_type, k_gdi_pen_attr_size);
    }

    uint64_t handle_NtGdiCreateCompatibleDC(const syscall_context& c, const hdc /*dc*/)
    {
        uint64_t dc_attr = 0;
        return allocate_gdi_dc(c, dc_attr);
    }

    uint64_t handle_NtGdiCreateCompatibleBitmap(const syscall_context& c, const hdc /*dc*/, const uint32_t /*width*/,
                                                const uint32_t /*height*/)
    {
        return allocate_gdi_object(c, k_gdi_bitmap_type, k_gdi_bitmap_attr_size);
    }

    uint64_t handle_NtGdiCreateDIBitmapInternal(const syscall_context& c, const hdc /*dc*/, const uint32_t /*width*/,
                                                const uint32_t /*height*/, const uint32_t /*usage*/, const emulator_pointer /*bits*/,
                                                const emulator_pointer /*info*/, const uint32_t /*info_header_size*/,
                                                const uint32_t /*init*/, const uint32_t /*offset*/, const uint32_t /*cj*/,
                                                const uint32_t /*i_usage*/)
    {
        return allocate_gdi_object(c, k_gdi_bitmap_type, k_gdi_bitmap_attr_size);
    }

    uint32_t handle_NtGdiDeleteObjectApp(const syscall_context& c, const uint32_t handle_value)
    {
        GDI_HANDLE_ENTRY64 entry{};
        uint64_t entry_addr = 0;
        if (!read_gdi_entry_for_handle(c, handle_value, entry, entry_addr))
        {
            return 0;
        }

        const emulator_object<GDI_HANDLE_ENTRY64> entry_obj{c.emu, entry_addr};
        entry_obj.access([&](GDI_HANDLE_ENTRY64& writable) {
            const auto unique = writable.Unique;
            writable = {};
            writable.Unique = unique;
        });

        if (handle_value == c.proc.gdi_default_dc_handle)
        {
            c.proc.gdi_default_dc_handle = 0;
        }

        return 1;
    }

    uint64_t handle_NtGdiSelectBitmap(const syscall_context&, const hdc /*dc*/, const handle bitmap)
    {
        return bitmap.bits;
    }

    hdc handle_NtGdiGetDCforBitmap(const syscall_context& c, const handle /*bitmap*/)
    {
        return ensure_default_hdc(c);
    }

    uint64_t handle_NtGdiHfontCreate(const syscall_context& c, const emulator_pointer /*logfont*/, const uint32_t /*angle*/)
    {
        return allocate_gdi_object(c, k_gdi_font_type, k_gdi_font_attr_size);
    }

    uint32_t handle_NtGdiExtGetObjectW(const syscall_context& c, const uint32_t handle_value, const uint32_t size,
                                       const emulator_pointer buffer)
    {
        GDI_HANDLE_ENTRY64 entry{};
        uint64_t entry_addr = 0;
        if (!read_gdi_entry_for_handle(c, handle_value, entry, entry_addr))
        {
            return 0;
        }

        const uint32_t object_size = get_gdi_object_size(entry.Type);
        if (object_size == 0)
        {
            return 0;
        }

        if (buffer == 0)
        {
            return object_size;
        }

        if (size < object_size)
        {
            return 0;
        }

        std::vector<uint8_t> zeroed(object_size, 0);
        c.emu.write_memory(buffer, zeroed.data(), zeroed.size());
        return object_size;
    }

    uint32_t handle_NtGdiEnumFonts()
    {
        return 0;
    }

    uint32_t handle_NtGdiGetTextCharsetInfo(const syscall_context& c, const hdc /*dc*/, const emulator_pointer sig,
                                            const uint32_t /*flags*/)
    {
        if (sig != 0)
        {
            std::array<uint8_t, 0x18> zeroed{};
            c.emu.write_memory(sig, zeroed.data(), zeroed.size());
        }

        return 1;
    }

    uint32_t handle_NtGdiQueryFontAssocInfo(const syscall_context&, const hdc /*dc*/)
    {
        return 0;
    }

    uint32_t handle_NtGdiGetTextMetricsW(const syscall_context& c, const hdc dc, const emulator_pointer ptm, const uint32_t cj)
    {
        if (dc == 0 || ptm == 0 || cj < k_textmetric_size)
        {
            return 0;
        }

        std::array<uint8_t, k_textmetric_size> zeroed{};
        c.emu.write_memory(ptm, zeroed.data(), zeroed.size());

        const auto write_u32 = [&](const uint32_t offset, const uint32_t value) {
            if (offset + sizeof(uint32_t) <= cj)
            {
                c.emu.write_memory(ptm + offset, &value, sizeof(value));
            }
        };

        const auto write_u16 = [&](const uint32_t offset, const uint16_t value) {
            if (offset + sizeof(uint16_t) <= cj)
            {
                c.emu.write_memory(ptm + offset, &value, sizeof(value));
            }
        };

        const auto write_u8 = [&](const uint32_t offset, const uint8_t value) {
            if (offset + sizeof(uint8_t) <= cj)
            {
                c.emu.write_memory(ptm + offset, &value, sizeof(value));
            }
        };

        write_u32(0x00, k_default_font_height);
        write_u32(0x04, k_default_font_ascent);
        write_u32(0x08, k_default_font_descent);
        write_u32(0x14, k_default_font_width);
        write_u32(0x18, k_default_font_width);
        write_u32(0x1C, k_default_font_weight);
        write_u16(0x2C, 0x20);
        write_u16(0x2E, 0x7E);
        write_u16(0x30, 0x3F);
        write_u16(0x32, 0x20);
        write_u8(0x38, 0x01);

        return 1;
    }

    NTSTATUS handle_NtGdiGetEntry(const syscall_context& c, const uint32_t handle_value, const emulator_pointer entry_ptr)
    {
        if (entry_ptr == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        GDI_HANDLE_ENTRY64 entry{};
        uint64_t entry_addr = 0;
        if (!read_gdi_entry_for_handle(c, handle_value, entry, entry_addr))
        {
            return STATUS_INVALID_HANDLE;
        }

        if (c.proc.is_wow64_process)
        {
            GDI_HANDLE_ENTRY32 entry32{};
            entry32.Object = static_cast<uint32_t>(entry.Object & std::numeric_limits<uint32_t>::max());
            entry32.OwnerValue = entry.Owner.Value;
            entry32.Unique = entry.Unique;
            entry32.Type = entry.Type;
            entry32.Flags = entry.Flags;
            entry32.UserPointer = static_cast<uint32_t>(entry.UserPointer & std::numeric_limits<uint32_t>::max());
            c.emu.write_memory(entry_ptr, &entry32, sizeof(entry32));
            return STATUS_SUCCESS;
        }

        c.emu.write_memory(entry_ptr, &entry, sizeof(entry));
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/io_completion.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../io_completion_wait.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    namespace
    {
        void release_wait_packet_association(const syscall_context& c, wait_completion_packet& wait_packet)
        {
            io_completion_wait::release_handle_reference(c.proc, wait_packet.io_completion_handle);
            io_completion_wait::release_handle_reference(c.proc, wait_packet.target_object_handle);
            wait_packet.associated = false;
        }
    }

    NTSTATUS handle_NtCreateIoCompletion(const syscall_context& c, const emulator_object<handle> io_completion_handle,
                                         const ACCESS_MASK /*desired_access*/,
                                         const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                         const ULONG number_of_concurrent_threads)
    {
        std::u16string name{};
        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName != 0)
            {
                name = read_unicode_string(c.emu, attributes.ObjectName);
            }
        }

        if (!name.empty())
        {
            for (auto& entry : c.proc.io_completions)
            {
                if (entry.second.name == name)
                {
                    ++entry.second.ref_count;
                    io_completion_handle.write(c.proc.io_completions.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        io_completion completion{};
        completion.name = std::move(name);
        completion.number_of_concurrent_threads = number_of_concurrent_threads;

        io_completion_handle.write(c.proc.io_completions.store(std::move(completion)));
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetIoCompletion(const syscall_context& c, const handle io_completion_handle, const emulator_pointer key_context,
                                      const emulator_pointer apc_context, const NTSTATUS io_status,
                                      const EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) io_status_information)
    {
        auto* completion = c.proc.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return STATUS_INVALID_HANDLE;
        }

        io_completion_message message{};
        message.key_context = key_context;
        message.apc_context = apc_context;
        message.io_status_block.Status = io_status;
        message.io_status_block.Information = io_status_information;

        completion->enqueue(message);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetIoCompletionEx(const syscall_context& c, const handle io_completion_handle,
                                        const handle io_completion_packet_handle, const emulator_pointer key_context,
                                        const emulator_pointer apc_context, const NTSTATUS io_status,
                                        const EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) io_status_information)
    {
        auto* completion = c.proc.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return STATUS_INVALID_HANDLE;
        }

        handle wait_packet_handle{};
        if (io_completion_packet_handle.bits != 0)
        {
            auto* wait_packet = c.proc.wait_completion_packets.get(io_completion_packet_handle);
            if (!wait_packet)
            {
                return STATUS_INVALID_HANDLE;
            }

            if (wait_packet->associated || wait_packet->queued_completion)
            {
                return STATUS_INVALID_PARAMETER;
            }

            handle retained_io_completion_handle{};
            if (!io_completion_wait::retain_handle_reference(c.proc, io_completion_handle, retained_io_completion_handle))
            {
                return STATUS_INVALID_HANDLE;
            }

            if (!io_completion_wait::retain_handle_reference(c.proc, io_completion_packet_handle, wait_packet_handle))
            {
                io_completion_wait::release_handle_reference(c.proc, retained_io_completion_handle);
                return STATUS_INVALID_HANDLE;
            }

            wait_packet->queued_completion = true;
            wait_packet->associated = false;
            wait_packet->io_completion_handle = retained_io_completion_handle;
            wait_packet->target_object_handle = {};
            wait_packet->key_context = key_context;
            wait_packet->apc_context = apc_context;
            wait_packet->io_status_block.Status = io_status;
            wait_packet->io_status_block.Information = io_status_information;
            wait_packet->io_status_information = io_status_information;
        }

        io_completion_message message{};
        message.key_context = key_context;
        message.apc_context = apc_context;
        message.io_status_block.Status = io_status;
        message.io_status_block.Information = io_status_information;
        message.wait_packet_handle = wait_packet_handle;

        completion->enqueue(message);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtRemoveIoCompletion(const syscall_context& c, const handle io_completion_handle,
                                         const emulator_object<emulator_pointer> key_context,
                                         const emulator_object<emulator_pointer> apc_context,
                                         const emulator_object<IO_STATUS_BLOCK<EmulatorTraits<Emu64>>> io_status_block,
                                         const emulator_object<LARGE_INTEGER> timeout)
    {
        auto* completion = c.proc.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return STATUS_INVALID_HANDLE;
        }

        io_completion_message message{};
        if (io_completion_wait::dequeue_io_completion_message(c.proc, io_completion_handle, message))
        {
            key_context.write_if_valid(message.key_context);
            apc_context.write_if_valid(message.apc_context);
            io_status_block.write_if_valid(message.io_status_block);
            return STATUS_SUCCESS;
        }

        if (timeout && timeout.read().QuadPart == 0)
        {
            return STATUS_TIMEOUT;
        }

        auto& t = c.win_emu.current_thread();
        t.await_objects = {};
        t.await_any = false;
        t.await_time = {};
        t.await_msg = {};
        t.waiting_for_alert = false;
        t.await_io_completion = pending_io_completion_wait{};

        auto& wait = *t.await_io_completion;
        wait.type = io_completion_wait_type::remove_single;
        wait.io_completion_handle = io_completion_handle;
        wait.key_context_ptr = key_context.value();
        wait.apc_context_ptr = apc_context.value();
        wait.io_status_block_ptr = io_status_block.value();

        if (timeout)
        {
            wait.timeout = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout.read());

            constexpr auto infinite = std::chrono::steady_clock::time_point::min();
            if (wait.timeout.has_value() && wait.timeout.value() != infinite && wait.timeout.value() < c.win_emu.clock().steady_now())
            {
                t.await_io_completion = {};
                return STATUS_TIMEOUT;
            }
        }

        c.win_emu.yield_thread(false);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtRemoveIoCompletionEx(
        const syscall_context& c, const handle io_completion_handle,
        const emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>> io_completion_information, const ULONG count,
        const emulator_object<ULONG> num_entries_removed, const emulator_object<LARGE_INTEGER> timeout, const BOOLEAN alertable)
    {
        if (count == 0 || !io_completion_information)
        {
            return STATUS_INVALID_PARAMETER;
        }

        auto* completion = c.proc.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto removed =
            io_completion_wait::dequeue_io_completion_entries(c.proc, io_completion_handle, io_completion_information, count);
        num_entries_removed.write_if_valid(removed);
        if (removed > 0)
        {
            return STATUS_SUCCESS;
        }

        if (timeout && timeout.read().QuadPart == 0)
        {
            return STATUS_TIMEOUT;
        }

        auto& t = c.win_emu.current_thread();
        t.await_objects = {};
        t.await_any = false;
        t.await_time = {};
        t.await_msg = {};
        t.waiting_for_alert = false;
        t.await_io_completion = pending_io_completion_wait{};

        auto& wait = *t.await_io_completion;
        wait.type = io_completion_wait_type::remove_multiple;
        wait.io_completion_handle = io_completion_handle;
        wait.completion_entries_ptr = io_completion_information.value();
        wait.entries_removed_ptr = num_entries_removed.value();
        wait.max_entries = count;

        if (timeout)
        {
            wait.timeout = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout.read());

            constexpr auto infinite = std::chrono::steady_clock::time_point::min();
            if (wait.timeout.has_value() && wait.timeout.value() != infinite && wait.timeout.value() < c.win_emu.clock().steady_now())
            {
                num_entries_removed.write_if_valid(0);
                t.await_io_completion = {};
                return STATUS_TIMEOUT;
            }
        }

        c.win_emu.yield_thread(alertable);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCreateWaitCompletionPacket(const syscall_context& c, const emulator_object<handle> wait_packet_handle,
                                                 const ACCESS_MASK /*desired_access*/,
                                                 const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        std::u16string name{};
        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName != 0)
            {
                name = read_unicode_string(c.emu, attributes.ObjectName);
            }
        }

        if (!name.empty())
        {
            for (auto& entry : c.proc.wait_completion_packets)
            {
                if (entry.second.name == name)
                {
                    ++entry.second.ref_count;
                    wait_packet_handle.write(c.proc.wait_completion_packets.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        wait_completion_packet packet{};
        packet.name = std::move(name);
        wait_packet_handle.write(c.proc.wait_completion_packets.store(std::move(packet)));
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtAssociateWaitCompletionPacket(const syscall_context& c, const handle wait_completion_packet_handle,
                                                    const handle io_completion_handle, const handle target_object_handle,
                                                    const emulator_pointer key_context, const emulator_pointer apc_context,
                                                    const NTSTATUS io_status,
                                                    const EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) io_status_information,
                                                    const emulator_object<BOOLEAN> already_signaled)
    {
        auto* wait_packet = c.proc.wait_completion_packets.get(wait_completion_packet_handle);
        if (!wait_packet)
        {
            return STATUS_INVALID_HANDLE;
        }

        auto* completion = c.proc.io_completions.get(io_completion_handle);
        if (!completion)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (!io_completion_wait::is_wait_completion_target_type(target_object_handle))
        {
            return STATUS_OBJECT_TYPE_MISMATCH;
        }

        const auto target_exists = [&]() -> bool {
            switch (target_object_handle.value.type)
            {
            case handle_types::event:
                return c.proc.events.get(target_object_handle) != nullptr;
            case handle_types::thread:
                return c.proc.threads.get(target_object_handle) != nullptr;
            case handle_types::semaphore:
                return c.proc.semaphores.get(target_object_handle) != nullptr;
            case handle_types::mutant:
                return c.proc.mutants.get(target_object_handle) != nullptr;
            case handle_types::timer:
                return c.proc.timers.get(target_object_handle) != nullptr;
            default:
                return false;
            }
        }();

        if (!target_exists)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (wait_packet->associated || wait_packet->queued_completion)
        {
            return STATUS_INVALID_PARAMETER;
        }

        handle retained_io_completion_handle{};
        if (!io_completion_wait::retain_handle_reference(c.proc, io_completion_handle, retained_io_completion_handle))
        {
            return STATUS_INVALID_HANDLE;
        }

        handle retained_target_handle{};
        if (!io_completion_wait::retain_handle_reference(c.proc, target_object_handle, retained_target_handle))
        {
            io_completion_wait::release_handle_reference(c.proc, retained_io_completion_handle);
            return STATUS_INVALID_HANDLE;
        }

        wait_packet->io_completion_handle = retained_io_completion_handle;
        wait_packet->target_object_handle = retained_target_handle;
        wait_packet->key_context = key_context;
        wait_packet->apc_context = apc_context;
        wait_packet->io_status_block.Status = io_status;
        wait_packet->io_status_block.Information = io_status_information;
        wait_packet->io_status_information = io_status_information;
        wait_packet->associated = true;

        io_completion_wait::materialize_signaled_wait_packets(c.proc, io_completion_handle);
        already_signaled.write_if_valid(wait_packet->queued_completion ? TRUE : FALSE);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCancelWaitCompletionPacket(const syscall_context& c, const handle wait_completion_packet_handle,
                                                 const BOOLEAN remove_signaled_packet)
    {
        auto* wait_packet = c.proc.wait_completion_packets.get(wait_completion_packet_handle);
        if (!wait_packet)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (remove_signaled_packet && wait_packet->queued_completion)
        {
            if (auto* completion = c.proc.io_completions.get(wait_packet->io_completion_handle))
            {
                if (completion->remove_by_wait_packet(wait_completion_packet_handle))
                {
                    (void)c.proc.wait_completion_packets.erase(wait_completion_packet_handle);
                }
            }
        }

        release_wait_packet_association(c, *wait_packet);
        wait_packet->queued_completion = false;
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/license.cpp`:

```cpp
#include "../std_include.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    namespace
    {
        constexpr std::u16string_view k_product_options_key = u"\\registry\\machine\\system\\CurrentControlSet\\Control\\ProductOptions";
        constexpr std::string_view k_product_policy_value_name = "ProductPolicy";

        struct product_policy_header
        {
            uint32_t total_size;
            uint32_t data_size;
            uint32_t end_marker_size;
            uint32_t touched;
            uint32_t reserved;
        };

        struct product_policy_entry
        {
            uint16_t size;
            uint16_t name_size;
            uint16_t type;
            uint16_t data_size;
            uint32_t flags;
            uint32_t reserved;
        };

        struct product_policy_match
        {
            uint16_t type{};
            std::span<const std::byte> data{};
        };

        template <typename T>
        bool read_struct(const std::span<const std::byte> blob, const size_t offset, T& out)
        {
            if (offset + sizeof(T) > blob.size())
            {
                return false;
            }

            std::memcpy(&out, blob.data() + offset, sizeof(T));
            return true;
        }

        NTSTATUS find_product_policy_value(const syscall_context& c, const std::u16string_view value_name, product_policy_match& out)
        {
            const auto key = c.win_emu.registry.get_key({std::u16string{k_product_options_key}});
            if (!key)
            {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            const auto product_policy = c.win_emu.registry.get_value(*key, k_product_policy_value_name);
            if (!product_policy || product_policy->type != REG_BINARY)
            {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            const auto blob = product_policy->data;
            if (blob.size() < sizeof(product_policy_header))
            {
                return STATUS_UNSUCCESSFUL;
            }

            product_policy_header header{};
            if (!read_struct(blob, 0, header))
            {
                return STATUS_UNSUCCESSFUL;
            }

            constexpr size_t header_size = sizeof(product_policy_header);
            if (header.data_size > blob.size() - header_size)
            {
                return STATUS_UNSUCCESSFUL;
            }

            size_t offset = header_size;
            const size_t end = header_size + header.data_size;
            while (offset + sizeof(product_policy_entry) <= end)
            {
                product_policy_entry entry{};
                if (!read_struct(blob, offset, entry))
                {
                    return STATUS_UNSUCCESSFUL;
                }

                if (entry.size < sizeof(product_policy_entry) || offset + entry.size > end)
                {
                    return STATUS_UNSUCCESSFUL;
                }

                if ((entry.name_size % sizeof(char16_t)) != 0)
                {
                    return STATUS_UNSUCCESSFUL;
                }

                const size_t name_offset = offset + sizeof(product_policy_entry);
                const size_t data_offset = name_offset + entry.name_size;
                if (data_offset + entry.data_size > offset + entry.size)
                {
                    return STATUS_UNSUCCESSFUL;
                }

                std::u16string entry_name(entry.name_size / sizeof(char16_t), u'\0');
                if (!entry_name.empty())
                {
                    std::memcpy(entry_name.data(), blob.data() + name_offset, entry.name_size);
                }

                if (!entry_name.empty() && entry_name.back() == u'\0')
                {
                    entry_name.pop_back();
                }

                if (entry_name == value_name)
                {
                    out.type = entry.type;
                    out.data = blob.subspan(data_offset, entry.data_size);
                    return STATUS_SUCCESS;
                }

                offset += entry.size;
            }

            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    NTSTATUS handle_NtQueryLicenseValue(const syscall_context& c, const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> value_name,
                                        emulator_object<uint32_t> type, uint64_t data, uint64_t data_size,
                                        emulator_object<uint32_t> result_data_size)
    {
        const auto name = read_unicode_string(c.emu, value_name);

        if (name == u"Kernel-VMDetection-Private")
        {
            c.win_emu.callbacks.on_suspicious_activity("Anti-vm check with NtQueryLicenseValue Kernel-VMDetection-Private");
        }

        if (name == u"TerminalServices-RemoteConnectionManager-AllowAppServerMode")
        {
            c.win_emu.callbacks.on_generic_activity(
                "Env check with NtQueryLicenseValue TerminalServices-RemoteConnectionManager-AllowAppServerMode");
        }

        product_policy_match policy_value{};
        const auto status = find_product_policy_value(c, name, policy_value);
        if (status != STATUS_SUCCESS)
        {
            return status;
        }

        if (type)
        {
            type.write(policy_value.type);
        }

        if (result_data_size)
        {
            result_data_size.write(static_cast<uint32_t>(policy_value.data.size()));
        }

        if (data_size < policy_value.data.size())
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        if (!policy_value.data.empty())
        {
            if (data == 0)
            {
                return STATUS_INVALID_PARAMETER;
            }

            c.emu.write_memory(data, policy_value.data.data(), policy_value.data.size());
        }

        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/locale.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

#include <utils/io.hpp>

namespace syscalls
{
    NTSTATUS handle_NtInitializeNlsFiles(const syscall_context& c, const emulator_object<uint64_t> base_address,
                                         const emulator_object<LCID> default_locale_id,
                                         const emulator_object<LARGE_INTEGER> /*default_casing_table_size*/)
    {
        const auto locale_file = utils::io::read_file(c.win_emu.file_sys.translate(R"(C:\Windows\System32\locale.nls)"));
        if (locale_file.empty())
        {
            return STATUS_FILE_INVALID;
        }

        const auto size = static_cast<size_t>(page_align_up(locale_file.size()));
        const auto base = c.win_emu.memory.allocate_memory(size, memory_permission::read);
        c.emu.write_memory(base, locale_file.data(), locale_file.size());

        base_address.write(base);
        default_locale_id.write(0x407);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryDefaultLocale(const syscall_context&, BOOLEAN /*user_profile*/, const emulator_object<LCID> default_locale_id)
    {
        default_locale_id.write(0x407);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtGetNlsSectionPtr(const syscall_context& c, const ULONG section_type, const ULONG section_data,
                                       emulator_pointer /*context_data*/, const emulator_object<uint64_t> section_pointer,
                                       const emulator_object<ULONG> section_size)
    {
        if (section_type == 11)
        {
            const auto file_path = R"(C:\Windows\System32\C_)" + std::to_string(section_data) + ".NLS";
            const auto locale_file = utils::io::read_file(c.win_emu.file_sys.translate(file_path));
            if (locale_file.empty())
            {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            const auto size = static_cast<size_t>(page_align_up(locale_file.size()));
            const auto section_memory = c.win_emu.memory.allocate_memory(size, memory_permission::read);
            c.emu.write_memory(section_memory, locale_file.data(), locale_file.size());

            section_pointer.write_if_valid(section_memory);
            section_size.write_if_valid(static_cast<ULONG>(size));

            return STATUS_SUCCESS;
        }

        c.win_emu.log.warn("Unsupported section type: %X\n", static_cast<uint32_t>(section_type));
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtGetMUIRegistryInfo()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtIsUILanguageComitted()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserGetKeyboardLayout()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryDefaultUILanguage(const syscall_context&, const emulator_object<LANGID> language_id)
    {
        language_id.write(0x407);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryInstallUILanguage(const syscall_context&, const emulator_object<LANGID> language_id)
    {
        language_id.write(0x407);
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/memory.cpp`:

```cpp
#include "../std_include.hpp"
#include "../syscall_dispatcher.hpp"
#include "../cpu_context.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"
#include "../memory_manager.hpp"

namespace syscalls
{
    NTSTATUS handle_NtQueryVirtualMemory(const syscall_context& c, const handle process_handle, const uint64_t base_address,
                                         const uint32_t info_class, const uint64_t memory_information,
                                         const uint64_t memory_information_length, const emulator_object<uint64_t> return_length)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (info_class == MemoryWorkingSetExInformation || info_class == MemoryImageExtensionInformation)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (base_address < MIN_ALLOCATION_ADDRESS || base_address >= MAX_ALLOCATION_END_EXCL)
        {
            if (return_length)
            {
                return_length.write(0);
            }
            return STATUS_INVALID_PARAMETER;
        }

        // https://www.exploit-db.com/exploits/44464
        // Both information classes appear to return the same output structure, MEMORY_BASIC_INFORMATION
        if (info_class == MemoryBasicInformation || info_class == MemoryPrivilegedBasicInformation)
        {
            if (return_length)
            {
                return_length.write(sizeof(EMU_MEMORY_BASIC_INFORMATION64));
            }

            if (memory_information_length < sizeof(EMU_MEMORY_BASIC_INFORMATION64))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            const emulator_object<EMU_MEMORY_BASIC_INFORMATION64> info{c.emu, memory_information};

            info.access([&](EMU_MEMORY_BASIC_INFORMATION64& image_info) {
                const auto region_info = c.win_emu.memory.get_region_info(base_address);

                assert(!region_info.is_committed || region_info.is_reserved);
                const auto state = region_info.is_reserved ? MEM_RESERVE : MEM_FREE;
                image_info.State = region_info.is_committed ? MEM_COMMIT : state;
                image_info.BaseAddress = region_info.start;
                image_info.AllocationBase = region_info.allocation_base;
                image_info.PartitionId = 0;
                image_info.RegionSize = static_cast<int64_t>(region_info.length);

                image_info.Protect = map_emulator_to_nt_protection(region_info.permissions);
                image_info.AllocationProtect = map_emulator_to_nt_protection(region_info.initial_permissions);

                if (!region_info.is_reserved)
                {
                    image_info.Type = 0;
                }
                else
                {
                    image_info.Type = memory_region_policy::to_memory_basic_information_type(region_info.kind);
                }
            });

            return STATUS_SUCCESS;
        }

        if (info_class == MemoryImageInformation)
        {
            if (return_length)
            {
                return_length.write(sizeof(MEMORY_IMAGE_INFORMATION64));
            }

            if (memory_information_length != sizeof(MEMORY_IMAGE_INFORMATION64))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto* mod = base_address == 0 //
                                  ? c.win_emu.mod_manager.executable
                                  : c.win_emu.mod_manager.find_by_address(base_address);

            if (!mod)
            {
                c.win_emu.log.error("Bad address for memory image request: 0x%" PRIx64 "\n", base_address);
                return STATUS_INVALID_ADDRESS;
            }

            const emulator_object<MEMORY_IMAGE_INFORMATION64> info{c.emu, memory_information};

            info.access([&](MEMORY_IMAGE_INFORMATION64& image_info) {
                image_info.ImageBase = mod->image_base;
                image_info.SizeOfImage = static_cast<int64_t>(mod->size_of_image);
                image_info.ImageFlags = 0;
            });

            return STATUS_SUCCESS;
        }

        if (info_class == MemoryRegionInformation)
        {
            if (return_length)
            {
                return_length.write(sizeof(MEMORY_REGION_INFORMATION64));
            }

            if (memory_information_length < sizeof(MEMORY_REGION_INFORMATION64))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto region_info = c.win_emu.memory.get_region_info(base_address);
            if (!region_info.is_reserved)
            {
                return STATUS_INVALID_ADDRESS;
            }

            const emulator_object<MEMORY_REGION_INFORMATION64> info{c.emu, memory_information};

            info.access([&](MEMORY_REGION_INFORMATION64& image_info) {
                memset(&image_info, 0, sizeof(image_info));

                image_info.AllocationBase = region_info.allocation_base;
                image_info.AllocationProtect = map_emulator_to_nt_protection(region_info.initial_permissions);
                // image_info.PartitionId = 0;
                image_info.RegionSize = static_cast<int64_t>(region_info.allocation_length);
                image_info.Reserved = 0x10;
            });

            return STATUS_SUCCESS;
        }

        c.win_emu.log.error("Unsupported memory info class: %X\n", info_class);
        c.emu.stop();
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtProtectVirtualMemory(const syscall_context& c, const handle process_handle,
                                           const emulator_object<uint64_t> base_address, const emulator_object<uint32_t> bytes_to_protect,
                                           const uint32_t protection, const emulator_object<uint32_t> old_protection)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        const auto orig_start = base_address.read();
        const auto orig_length = bytes_to_protect.read();

        const auto aligned_start = page_align_down(orig_start);
        const auto aligned_length = page_align_up(orig_start + orig_length) - aligned_start;

        base_address.write(aligned_start);
        bytes_to_protect.write(static_cast<uint32_t>(aligned_length));

        const auto requested_protection = try_map_nt_to_emulator_protection(protection);
        if (!requested_protection.has_value())
        {
            return STATUS_INVALID_PAGE_PROTECTION;
        }

        c.win_emu.callbacks.on_memory_protect(aligned_start, aligned_length, *requested_protection);

        nt_memory_permission old_protection_value{};

        try
        {
            c.win_emu.memory.protect_memory(aligned_start, static_cast<size_t>(aligned_length), *requested_protection,
                                            &old_protection_value);
        }
        catch (...)
        {
            return STATUS_INVALID_ADDRESS;
        }

        const auto current_protection = map_emulator_to_nt_protection(old_protection_value);
        old_protection.write(current_protection);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtAllocateVirtualMemoryEx(const syscall_context& c, const handle process_handle,
                                              const emulator_object<uint64_t> base_address,
                                              const emulator_object<uint64_t> bytes_to_allocate, const uint32_t allocation_type,
                                              const uint32_t page_protection)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        auto allocation_bytes = bytes_to_allocate.read();

        if (allocation_bytes == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        allocation_bytes = page_align_up(allocation_bytes);
        bytes_to_allocate.write(allocation_bytes);

        const auto base_protection = page_protection & ~static_cast<uint32_t>(PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE);
        if (base_protection == PAGE_WRITECOPY || base_protection == PAGE_EXECUTE_WRITECOPY)
        {
            return STATUS_INVALID_PAGE_PROTECTION;
        }

        const auto protection = try_map_nt_to_emulator_protection(page_protection);
        if (!protection.has_value())
        {
            return STATUS_INVALID_PAGE_PROTECTION;
        }

        auto potential_base = base_address.read();
        if (!potential_base)
        {
            potential_base = c.win_emu.memory.find_free_allocation_base(static_cast<size_t>(allocation_bytes));
        }
        else
        {
            // https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory
            // BaseAddress
            // A pointer to a variable that will receive the base address of the allocated region of pages. If the
            // initial value of BaseAddress is non-NULL, the region is allocated starting at the specified virtual
            // address rounded down to the next host page size address boundary. If the initial value of BaseAddress
            // is NULL, the operating system will determine where to allocate the region.
            potential_base = page_align_down(potential_base);
        }

        if (!potential_base)
        {
            return STATUS_MEMORY_NOT_ALLOCATED;
        }

        base_address.write(potential_base);

        const bool reserve = allocation_type & MEM_RESERVE;
        const bool commit = allocation_type & MEM_COMMIT;

        if ((allocation_type & ~(MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN | MEM_WRITE_WATCH)) || (!commit && !reserve))
        {
            throw std::runtime_error("Unsupported allocation type!");
        }

        if (commit && !reserve && c.win_emu.memory.commit_memory(potential_base, static_cast<size_t>(allocation_bytes), *protection))
        {
            c.win_emu.callbacks.on_memory_allocate(potential_base, allocation_bytes, *protection, true);
            return STATUS_SUCCESS;
        }

        c.win_emu.callbacks.on_memory_allocate(potential_base, allocation_bytes, *protection, false);

        return c.win_emu.memory.allocate_memory(potential_base, static_cast<size_t>(allocation_bytes), *protection, !commit)
                   ? STATUS_SUCCESS
                   : STATUS_MEMORY_NOT_ALLOCATED;
    }

    NTSTATUS handle_NtAllocateVirtualMemory(const syscall_context& c, const handle process_handle,
                                            const emulator_object<uint64_t> base_address, const uint64_t /*zero_bits*/,
                                            const emulator_object<uint64_t> bytes_to_allocate, const uint32_t allocation_type,
                                            const uint32_t page_protection)
    {
        return handle_NtAllocateVirtualMemoryEx(c, process_handle, base_address, bytes_to_allocate, allocation_type, page_protection);
    }

    NTSTATUS handle_NtFreeVirtualMemory(const syscall_context& c, const handle process_handle, const emulator_object<uint64_t> base_address,
                                        const emulator_object<uint64_t> bytes_to_allocate, const uint32_t free_type)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (free_type == 0)
        {
            return STATUS_INVALID_PARAMETER_4;
        }

        const auto allocation_base = base_address.read();
        const auto allocation_size = bytes_to_allocate.read();

        if (free_type & MEM_RELEASE)
        {
            if (!allocation_size)
            {
                const auto region_info = c.win_emu.memory.get_region_info(allocation_base);
                if (!region_info.is_reserved)
                {
                    return STATUS_MEMORY_NOT_ALLOCATED;
                }

                if (region_info.allocation_base != allocation_base)
                {
                    return STATUS_FREE_VM_NOT_AT_BASE;
                }
            }

            const auto region_kind = c.win_emu.memory.get_region_kind(allocation_base);
            const auto denied_status = memory_region_policy::nt_free_virtual_memory_denied_status(region_kind);
            if (denied_status != STATUS_SUCCESS)
            {
                return denied_status;
            }

            const bool success = c.win_emu.memory.release_memory(allocation_base, static_cast<size_t>(allocation_size));
            if (success)
            {
                return STATUS_SUCCESS;
            }

            const auto region_info = c.win_emu.memory.get_region_info(allocation_base);
            if (!region_info.is_reserved)
            {
                return STATUS_MEMORY_NOT_ALLOCATED;
            }

            return STATUS_FREE_VM_NOT_AT_BASE;
        }

        if (free_type & MEM_DECOMMIT)
        {
            const auto region_kind = c.win_emu.memory.get_region_kind(allocation_base);
            const auto denied_status = memory_region_policy::nt_free_virtual_memory_denied_status(region_kind);
            if (denied_status != STATUS_SUCCESS)
            {
                return denied_status;
            }

            auto decommit_size = static_cast<size_t>(allocation_size);
            if (!decommit_size)
            {
                const auto region_info = c.win_emu.memory.get_region_info(allocation_base);
                if (!region_info.is_reserved)
                {
                    return STATUS_MEMORY_NOT_ALLOCATED;
                }

                if (region_info.allocation_base != allocation_base)
                {
                    return STATUS_FREE_VM_NOT_AT_BASE;
                }

                decommit_size = region_info.allocation_length;
            }

            const bool success = c.win_emu.memory.decommit_memory(allocation_base, decommit_size);
            return success ? STATUS_SUCCESS : STATUS_MEMORY_NOT_ALLOCATED;
        }

        throw std::runtime_error("Bad free type");
    }

    NTSTATUS handle_NtReadVirtualMemory(const syscall_context& c, const handle process_handle, const emulator_pointer base_address,
                                        const emulator_pointer buffer, const ULONG number_of_bytes_to_read,
                                        const emulator_object<ULONG> number_of_bytes_read)
    {
        number_of_bytes_read.try_write(0);

        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        std::vector<uint8_t> memory(number_of_bytes_to_read, 0);

        if (!c.emu.try_read_memory(base_address, memory.data(), number_of_bytes_to_read))
        {
            return STATUS_INVALID_ADDRESS;
        }

        if (!c.emu.try_write_memory(buffer, memory.data(), number_of_bytes_to_read))
        {
            return STATUS_INVALID_ADDRESS;
        }

        number_of_bytes_read.try_write(number_of_bytes_to_read);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtWriteVirtualMemory(const syscall_context& c, const handle process_handle, const emulator_pointer base_address,
                                         const emulator_pointer buffer, const ULONG number_of_bytes_to_write,
                                         const emulator_object<ULONG> number_of_bytes_write)
    {
        number_of_bytes_write.try_write(0);

        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        std::vector<uint8_t> memory(number_of_bytes_to_write, 0);

        if (!c.emu.try_read_memory(buffer, memory.data(), number_of_bytes_to_write))
        {
            return STATUS_INVALID_ADDRESS;
        }

        if (!c.emu.try_write_memory(base_address, memory.data(), number_of_bytes_to_write))
        {
            return STATUS_INVALID_ADDRESS;
        }

        number_of_bytes_write.try_write(number_of_bytes_to_write);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetInformationVirtualMemory()
    {
        return STATUS_NOT_SUPPORTED;
    }

    BOOL handle_NtLockVirtualMemory()
    {
        return TRUE;
    }
}

```

`src/windows-emulator/syscalls/mutant.cpp`:

```cpp
#include "../std_include.hpp"
#include "../syscall_dispatcher.hpp"
#include "../cpu_context.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtReleaseMutant(const syscall_context& c, const handle mutant_handle, const emulator_object<LONG> previous_count)
    {
        if (mutant_handle.value.type != handle_types::mutant)
        {
            c.win_emu.log.error("Bad handle type for NtReleaseMutant\n");
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        auto* mutant = c.proc.mutants.get(mutant_handle);
        if (!mutant)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto [old_count, succeeded] = mutant->release(c.win_emu.current_thread().id);

        if (previous_count)
        {
            previous_count.write(static_cast<LONG>(old_count));
        }

        return succeeded ? STATUS_SUCCESS : STATUS_MUTANT_NOT_OWNED;
    }

    NTSTATUS handle_NtOpenMutant(const syscall_context& c, const emulator_object<handle> mutant_handle,
                                 const ACCESS_MASK /*desired_access*/,
                                 const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        std::u16string name{};
        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName)
            {
                name = read_unicode_string(c.emu, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>>{c.emu, attributes.ObjectName});
                c.win_emu.callbacks.on_generic_access("Opening mutant", name);
            }
        }

        if (name.empty())
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        for (auto& entry : c.proc.mutants)
        {
            if (entry.second.name == name)
            {
                ++entry.second.ref_count;
                mutant_handle.write(c.proc.mutants.make_handle(entry.first));
                return STATUS_SUCCESS;
            }
        }

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    NTSTATUS handle_NtCreateMutant(const syscall_context& c, const emulator_object<handle> mutant_handle,
                                   const ACCESS_MASK /*desired_access*/,
                                   const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                   const BOOLEAN initial_owner)
    {
        std::u16string name{};
        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName)
            {
                name = read_unicode_string(c.emu, attributes.ObjectName);
                c.win_emu.callbacks.on_generic_access("Opening mutant", name);
            }
        }

        if (!name.empty())
        {
            for (auto& entry : c.proc.mutants)
            {
                if (entry.second.name == name)
                {
                    ++entry.second.ref_count;
                    mutant_handle.write(c.proc.mutants.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        mutant e{};
        e.name = std::move(name);

        if (initial_owner)
        {
            e.try_lock(c.win_emu.current_thread().id);
        }

        const auto handle = c.proc.mutants.store(std::move(e));
        mutant_handle.write(handle);

        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/object.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../io_completion_wait.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtClose(const syscall_context& c, const handle h)
    {
        const auto value = h.value;

        if (h.h == 0xDEADC0DE || h.h == 0xDEADBEEF)
        {
            c.win_emu.callbacks.on_suspicious_activity("Anti-debug check with invalid handle");

            return STATUS_INVALID_HANDLE;
        }

        if (value.is_pseudo)
        {
            return STATUS_SUCCESS;
        }

        if (value.type == handle_types::wait_completion_packet)
        {
            auto* wait_packet = c.proc.wait_completion_packets.get(h);
            if (wait_packet && wait_packet->ref_count == 1)
            {
                io_completion_wait::cleanup_wait_packet_on_close(c.proc, h);
            }
        }

        if (value.type == handle_types::worker_factory)
        {
            auto* factory = c.proc.worker_factories.get(h);
            if (factory && factory->ref_count == 1)
            {
                io_completion_wait::release_handle_reference(c.proc, factory->io_completion_handle);
            }
        }

        auto* handle_store = c.proc.get_handle_store(h);
        if (handle_store && handle_store->erase(h))
        {
            return STATUS_SUCCESS;
        }

        return STATUS_INVALID_HANDLE;
    }

    NTSTATUS handle_NtDuplicateObject(const syscall_context& c, const handle source_process_handle, const handle source_handle,
                                      const handle target_process_handle, const emulator_object<handle> target_handle,
                                      const ACCESS_MASK /*desired_access*/, const ULONG /*handle_attributes*/, const ULONG /*options*/)
    {
        if (source_process_handle != CURRENT_PROCESS || target_process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (source_handle.value.is_pseudo)
        {
            target_handle.write(source_handle);
            return STATUS_SUCCESS;
        }

        auto* store = c.proc.get_handle_store(source_handle);
        if (!store)
        {
            return STATUS_NOT_SUPPORTED;
        }

        const auto new_handle = store->duplicate(source_handle);
        if (!new_handle)
        {
            return STATUS_INVALID_HANDLE;
        }

        target_handle.write(*new_handle);
        return STATUS_SUCCESS;
    }

    std::u16string get_type_name(const handle_types::type type)
    {
        switch (type)
        {
        case handle_types::file:
            return u"File";
        case handle_types::device:
            return u"Device";
        case handle_types::event:
            return u"Event";
        case handle_types::section:
            return u"Section";
        case handle_types::symlink:
            return u"Symlink";
        case handle_types::directory:
            return u"Directory";
        case handle_types::semaphore:
            return u"Semaphore";
        case handle_types::port:
            return u"Port";
        case handle_types::thread:
            return u"Thread";
        case handle_types::registry:
            return u"Registry";
        case handle_types::mutant:
            return u"Mutant";
        case handle_types::token:
            return u"Token";
        case handle_types::window:
            return u"Window";
        case handle_types::timer:
            return u"Timer";
        case handle_types::desktop:
            return u"Desktop";
        case handle_types::io_completion:
            return u"IoCompletion";
        case handle_types::wait_completion_packet:
            return u"WaitCompletionPacket";
        case handle_types::worker_factory:
            return u"TpWorkerFactory";
        default:
            return u"";
        }
    }

    NTSTATUS handle_NtQueryObject(const syscall_context& c, const handle handle, const OBJECT_INFORMATION_CLASS object_information_class,
                                  const emulator_pointer object_information, const ULONG object_information_length,
                                  const emulator_object<ULONG> return_length)
    {
        if (object_information_class == ObjectNameInformation)
        {
            std::u16string device_path;
            switch (handle.value.type)
            {
            case handle_types::reserved: {
                return STATUS_NOT_SUPPORTED;
            }

            case handle_types::file: {
                const auto* file = c.proc.files.get(handle);
                if (!file)
                {
                    return STATUS_INVALID_HANDLE;
                }

                device_path = windows_path(file->name).to_device_path();
                break;
            }
            case handle_types::device: {
                const auto* device = c.proc.devices.get(handle);
                if (!device)
                {
                    return STATUS_INVALID_HANDLE;
                }

                device_path = device->get_device_path();
                break;
            }
            case handle_types::directory: {
                // Directory handles are pseudo handles representing specific object directories
                if (handle == KNOWN_DLLS_DIRECTORY)
                {
                    device_path = u"\\KnownDlls";
                }
                else if (handle == KNOWN_DLLS32_DIRECTORY)
                {
                    device_path = u"\\KnownDlls32";
                }
                else if (handle == BASE_NAMED_OBJECTS_DIRECTORY)
                {
                    device_path = u"\\Sessions\\1\\BaseNamedObjects";
                }
                else if (handle == RPC_CONTROL_DIRECTORY)
                {
                    device_path = u"\\RPC Control";
                }
                else
                {
                    // Unknown directory handle
                    return STATUS_INVALID_HANDLE;
                }
                break;
            }
            case handle_types::registry: {
                const auto* registry = c.proc.registry_keys.get(handle);
                if (!registry)
                {
                    return STATUS_INVALID_HANDLE;
                }

                // Build the full registry path in device format
                auto registry_path = (registry->hive.get() / registry->path.get()).u16string();

                // Convert backslashes to forward slashes for consistency
                std::ranges::replace(registry_path, u'/', u'\\');

                // Convert to uppercase as Windows registry paths are case-insensitive
                std::ranges::transform(registry_path, registry_path.begin(), std::towupper);

                device_path = registry_path;
                break;
            }
            case handle_types::desktop: {
                const auto* desk = c.proc.desktops.get(handle);
                if (!desk)
                {
                    return STATUS_INVALID_HANDLE;
                }

                device_path = u"\\Windows\\Desktop\\";
                device_path.append(desk->name);
                break;
            }
            case handle_types::io_completion: {
                const auto* io = c.proc.io_completions.get(handle);
                if (!io)
                {
                    return STATUS_INVALID_HANDLE;
                }

                device_path = io->name;
                break;
            }
            case handle_types::wait_completion_packet: {
                const auto* packet = c.proc.wait_completion_packets.get(handle);
                if (!packet)
                {
                    return STATUS_INVALID_HANDLE;
                }

                device_path = packet->name;
                break;
            }
            case handle_types::worker_factory: {
                const auto* factory = c.proc.worker_factories.get(handle);
                if (!factory)
                {
                    return STATUS_INVALID_HANDLE;
                }

                device_path = factory->name;
                break;
            }
            default:
                c.win_emu.log.error("Unsupported handle type for name information query: %X\n", handle.value.type);
                c.emu.stop();
                return STATUS_NOT_SUPPORTED;
            }

            const auto required_size = sizeof(UNICODE_STRING<EmulatorTraits<Emu64>>) + (device_path.size() + 1) * 2;
            return_length.write_if_valid(static_cast<ULONG>(required_size));

            if (required_size > object_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_allocator allocator(c.emu, object_information, object_information_length);
            allocator.make_unicode_string(device_path);

            return STATUS_SUCCESS;
        }

        if (object_information_class == ObjectTypeInformation)
        {
            const auto name = get_type_name(static_cast<handle_types::type>(handle.value.type));

            const auto required_size = sizeof(OBJECT_TYPE_INFORMATION) + (name.size() + 1) * 2;
            return_length.write_if_valid(static_cast<ULONG>(required_size));

            if (required_size > object_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_allocator allocator(c.emu, object_information, object_information_length);
            const auto info = allocator.reserve<OBJECT_TYPE_INFORMATION>();
            info.access([&](OBJECT_TYPE_INFORMATION& i) {
                allocator.make_unicode_string(i.TypeName, name); //
            });

            return STATUS_SUCCESS;
        }

        if (object_information_class == ObjectTypesInformation)
        {
            const auto name = get_type_name(static_cast<handle_types::type>(handle.value.type));
            constexpr auto type_start_offset = align_up(sizeof(OBJECT_TYPES_INFORMATION), sizeof(uint64_t));

            const auto required_size = type_start_offset + sizeof(OBJECT_TYPE_INFORMATION) + (name.size() + 1) * 2;
            return_length.write_if_valid(static_cast<ULONG>(required_size));

            if (required_size > object_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_allocator allocator(c.emu, object_information, object_information_length);
            const auto types_info = allocator.reserve<OBJECT_TYPES_INFORMATION>();
            types_info.access([&](OBJECT_TYPES_INFORMATION& i) {
                i.NumberOfTypes = 1; //
            });

            allocator.skip_until(type_start_offset);

            const auto info = allocator.reserve<OBJECT_TYPE_INFORMATION>();
            info.access([&](OBJECT_TYPE_INFORMATION& i) {
                allocator.make_unicode_string(i.TypeName, name); //
            });

            return STATUS_SUCCESS;
        }

        if (object_information_class == ObjectHandleFlagInformation)
        {
            return handle_query<OBJECT_HANDLE_FLAG_INFORMATION>(c.emu, object_information, object_information_length, return_length,
                                                                [&](OBJECT_HANDLE_FLAG_INFORMATION& info) {
                                                                    info.Inherit = 0;
                                                                    info.ProtectFromClose = 0;
                                                                });
        }

        c.win_emu.log.error("Unsupported object info class: %X\n", object_information_class);
        c.emu.stop();
        return STATUS_NOT_SUPPORTED;
    }

    template <typename Store>
    void collect_wait32_candidate(Store& store, const uint32_t id, std::optional<handle>& resolved, uint32_t& candidate_count)
    {
        if (!store.get_by_index(id))
        {
            return;
        }

        ++candidate_count;
        if (!resolved)
        {
            resolved = store.make_handle(id);
        }
    }

    std::optional<handle> resolve_wait32_handle(const syscall_context& c, const uint32_t raw_handle)
    {
        const auto decoded = make_handle(static_cast<uint64_t>(raw_handle));
        if (decoded.value.type != handle_types::reserved)
        {
            return decoded;
        }

        // wait32 can give raw 32 bit handles without type bits
        const auto id = static_cast<uint32_t>(decoded.value.id);
        if (id == 0)
        {
            return std::nullopt;
        }

        std::optional<handle> resolved{};
        uint32_t candidate_count = 0;

        collect_wait32_candidate(c.proc.events, id, resolved, candidate_count);
        collect_wait32_candidate(c.proc.threads, id, resolved, candidate_count);
        collect_wait32_candidate(c.proc.mutants, id, resolved, candidate_count);
        collect_wait32_candidate(c.proc.semaphores, id, resolved, candidate_count);
        collect_wait32_candidate(c.proc.timers, id, resolved, candidate_count);

        if (candidate_count == 1)
        {
            return resolved;
        }

        return std::nullopt;
    }

    NTSTATUS validate_wait_handle(const syscall_context& c, const handle h)
    {
        const auto validate_handle_in_store = [&](auto& store) -> NTSTATUS {
            return store.get(h) ? STATUS_SUCCESS : STATUS_INVALID_HANDLE;
        };

        switch (h.value.type)
        {
        case handle_types::event:
            if (h.value.is_pseudo)
            {
                return STATUS_SUCCESS;
            }

            return validate_handle_in_store(c.proc.events);

        case handle_types::thread:
            return validate_handle_in_store(c.proc.threads);

        case handle_types::mutant:
            return validate_handle_in_store(c.proc.mutants);

        case handle_types::semaphore:
            return validate_handle_in_store(c.proc.semaphores);

        case handle_types::timer:
            if (h.value.is_pseudo)
            {
                return STATUS_SUCCESS;
            }

            return validate_handle_in_store(c.proc.timers);

        default:
            return STATUS_OBJECT_TYPE_MISMATCH;
        }
    }

    NTSTATUS handle_NtCompareObjects(const syscall_context&, const handle first, const handle second)
    {
        return (first == second) ? STATUS_SUCCESS : STATUS_NOT_SAME_OBJECT;
    }

    NTSTATUS handle_NtWaitForMultipleObjects(const syscall_context& c, const ULONG count, const emulator_object<handle> handles,
                                             const WAIT_TYPE wait_type, const BOOLEAN alertable,
                                             const emulator_object<LARGE_INTEGER> timeout)
    {
        if (wait_type != WaitAny && wait_type != WaitAll)
        {
            c.win_emu.log.error("Wait type not supported!\n");
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        auto& t = c.win_emu.current_thread();
        t.await_objects = {};
        t.await_any = false;

        std::vector<handle> wait_handles{};
        wait_handles.reserve(count);

        for (ULONG i = 0; i < count; ++i)
        {
            const auto h = handles.read(i);

            const auto validation_status = validate_wait_handle(c, h);
            if (!NT_SUCCESS(validation_status))
            {
                t.await_time = {};
                return validation_status;
            }

            wait_handles.push_back(h);
        }

        t.await_objects = std::move(wait_handles);
        t.await_any = wait_type == WaitAny;

        if (timeout.value() && !t.await_time.has_value())
        {
            t.await_time = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout.read());
        }

        c.win_emu.yield_thread(alertable);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtWaitForMultipleObjects32(const syscall_context& c, const ULONG count, const emulator_object<uint32_t> handles,
                                               const WAIT_TYPE wait_type, const BOOLEAN alertable,
                                               const emulator_object<LARGE_INTEGER> timeout)
    {
        if (wait_type != WaitAny && wait_type != WaitAll)
        {
            c.win_emu.log.error("Wait type not supported!\n");
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        auto& t = c.win_emu.current_thread();
        t.await_objects = {};
        t.await_any = false;

        std::vector<handle> wait_handles{};
        wait_handles.reserve(count);

        for (ULONG i = 0; i < count; ++i)
        {
            const auto raw_handle = handles.read(i);
            const auto h = resolve_wait32_handle(c, raw_handle);
            if (!h)
            {
                t.await_time = {};
                return STATUS_INVALID_HANDLE;
            }

            const auto validation_status = validate_wait_handle(c, *h);
            if (!NT_SUCCESS(validation_status))
            {
                t.await_time = {};
                return validation_status;
            }

            wait_handles.push_back(*h);
        }

        t.await_objects = std::move(wait_handles);
        t.await_any = wait_type == WaitAny;

        if (timeout.value() && !t.await_time.has_value())
        {
            t.await_time = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout.read());
        }

        c.win_emu.yield_thread(alertable);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtWaitForSingleObject(const syscall_context& c, const handle h, const BOOLEAN alertable,
                                          const emulator_object<LARGE_INTEGER> timeout)
    {
        const auto validation_status = validate_wait_handle(c, h);
        if (!NT_SUCCESS(validation_status))
        {
            return validation_status;
        }

        auto& t = c.win_emu.current_thread();
        t.await_objects = {h};
        t.await_any = false;

        if (timeout.value() && !t.await_time.has_value())
        {
            t.await_time = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout.read());
        }

        c.win_emu.yield_thread(alertable);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetInformationObject()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQuerySecurityObject(const syscall_context& c, const handle /*h*/, const SECURITY_INFORMATION security_information,
                                          const emulator_pointer security_descriptor, const ULONG length,
                                          const emulator_object<ULONG> length_needed)
    {
        if ((security_information &
             (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION | LABEL_SECURITY_INFORMATION)) == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        // Owner SID: S-1-5-32-544 (Administrators)
        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        const uint8_t owner_sid[] = {0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00};

        // Group SID: S-1-5-18 (Local System)
        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        const uint8_t group_sid[] = {0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x12, 0x00, 0x00, 0x00};

        // DACL structure
        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        const uint8_t dacl_data[] = {
            0x02, 0x00, 0x9C, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x01, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x01, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x05, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x01, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x00, 0x0B, 0x14, 0x00, 0x00, 0x00, 0x00, 0xE0,
            0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x14, 0x00, 0x00, 0x00, 0x00, 0xE0,
            0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x18, 0x00, 0x00, 0x00, 0x00, 0x10,
            0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x00, 0x0B, 0x14, 0x00,
            0x00, 0x00, 0x00, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00};

        // SACL structure
        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        const uint8_t sacl_data[] = {0x02, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x14, 0x00, 0x01, 0x00,
                                     0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00};

        ULONG total_size = sizeof(SECURITY_DESCRIPTOR_RELATIVE);

        if (security_information & OWNER_SECURITY_INFORMATION)
        {
            total_size += sizeof(owner_sid);
        }

        if (security_information & GROUP_SECURITY_INFORMATION)
        {
            total_size += sizeof(group_sid);
        }

        if (security_information & DACL_SECURITY_INFORMATION)
        {
            total_size += sizeof(dacl_data);
        }

        if (security_information & LABEL_SECURITY_INFORMATION)
        {
            total_size += sizeof(sacl_data);
        }

        length_needed.write(total_size);

        if (length < total_size)
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        if (!security_descriptor)
        {
            return STATUS_INVALID_PARAMETER;
        }

        SECURITY_DESCRIPTOR_RELATIVE sd = {};
        sd.Revision = SECURITY_DESCRIPTOR_REVISION;
        sd.Control = SE_SELF_RELATIVE;

        ULONG current_offset = sizeof(sd);

        if (security_information & OWNER_SECURITY_INFORMATION)
        {
            sd.Owner = current_offset;
            c.emu.write_memory(security_descriptor + current_offset, owner_sid);
            current_offset += sizeof(owner_sid);
        }

        if (security_information & GROUP_SECURITY_INFORMATION)
        {
            sd.Group = current_offset;
            c.emu.write_memory(security_descriptor + current_offset, group_sid);
            current_offset += sizeof(group_sid);
        }

        if (security_information & DACL_SECURITY_INFORMATION)
        {
            sd.Control |= SE_DACL_PRESENT;
            sd.Dacl = current_offset;
            c.emu.write_memory(security_descriptor + current_offset, dacl_data);
            current_offset += sizeof(dacl_data);
        }

        if (security_information & LABEL_SECURITY_INFORMATION)
        {
            sd.Control |= SE_SACL_PRESENT | SE_SACL_AUTO_INHERITED;
            sd.Sacl = current_offset;
            c.emu.write_memory(security_descriptor + current_offset, sacl_data);
            current_offset += sizeof(sacl_data);
        }

        assert(current_offset == total_size);

        c.emu.write_memory(security_descriptor, sd);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetSecurityObject()
    {
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/port.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"
#include "../port.hpp"

namespace syscalls
{
    NTSTATUS handle_NtConnectPort(const syscall_context& c, const emulator_object<handle> client_port_handle,
                                  const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> server_port_name,
                                  const emulator_object<SECURITY_QUALITY_OF_SERVICE> /*security_qos*/,
                                  const emulator_object<PORT_VIEW64> client_shared_memory,
                                  const emulator_object<REMOTE_PORT_VIEW64> /*server_shared_memory*/,
                                  const emulator_object<ULONG> /*maximum_message_length*/, const emulator_pointer connection_info,
                                  const emulator_object<ULONG> connection_info_length)
    {
        auto port_name = read_unicode_string(c.emu, server_port_name);
        c.win_emu.callbacks.on_generic_access("Connecting port", port_name);

        port_creation_data data{};
        client_shared_memory.access([&](PORT_VIEW64& view) {
            data.view_size = view.ViewSize;
            data.view_base = c.win_emu.memory.allocate_memory(static_cast<size_t>(data.view_size), memory_permission::read_write);
            view.ViewBase = data.view_base;
            view.ViewRemoteBase = view.ViewBase;
        });

        port_container container{std::u16string(port_name), c.win_emu, data};

        const auto handle = c.proc.ports.store(std::move(container));
        client_port_handle.write(handle);

        if (connection_info)
        {
            std::vector<uint8_t> zero_mem{};
            zero_mem.resize(connection_info_length.read(), 0);
            c.emu.write_memory(connection_info, zero_mem.data(), zero_mem.size());
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSecureConnectPort(const syscall_context& c, emulator_object<handle> client_port_handle,
                                        emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> server_port_name,
                                        emulator_object<SECURITY_QUALITY_OF_SERVICE> security_qos,
                                        emulator_object<PORT_VIEW64> client_shared_memory, emulator_pointer /*server_sid*/,
                                        emulator_object<REMOTE_PORT_VIEW64> server_shared_memory,
                                        emulator_object<ULONG> maximum_message_length, emulator_pointer connection_info,
                                        emulator_object<ULONG> connection_info_length)
    {
        return handle_NtConnectPort(c, client_port_handle, server_port_name, security_qos, client_shared_memory, server_shared_memory,
                                    maximum_message_length, connection_info, connection_info_length);
    }

    NTSTATUS handle_NtAlpcConnectPort(const syscall_context& c, const emulator_object<handle> port_handle,
                                      const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> server_port_name,
                                      const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> /*object_attributes*/,
                                      const emulator_pointer /*port_attributes*/, const ULONG /*flags*/,
                                      const emulator_pointer /*required_server_sid*/, const emulator_pointer /*connection_message*/,
                                      const emulator_object<EmulatorTraits<Emu64>::SIZE_T> /*buffer_length*/,
                                      const emulator_pointer /*out_message_attributes*/, const emulator_pointer /*in_message_attributes*/,
                                      const emulator_object<LARGE_INTEGER> /*timeout*/)
    {
        auto port_name = read_unicode_string(c.emu, server_port_name);
        c.win_emu.callbacks.on_generic_access("Connecting port", port_name);

        port_container container{std::u16string(port_name), c.win_emu, {}};

        const auto handle = c.proc.ports.store(std::move(container));
        port_handle.write(handle);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtAlpcConnectPortEx(const syscall_context& c, const emulator_object<handle> port_handle,
                                        const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> connection_port_object_attributes,
                                        const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> /*client_port_object_attributes*/,
                                        const emulator_pointer port_attributes, const ULONG flags,
                                        const emulator_pointer /*server_security_requirements*/, const emulator_pointer connection_message,
                                        const emulator_object<EmulatorTraits<Emu64>::SIZE_T> buffer_length,
                                        const emulator_pointer out_message_attributes, const emulator_pointer in_message_attributes,
                                        const emulator_object<LARGE_INTEGER> timeout)
    {
        if (!connection_port_object_attributes)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto attributes = connection_port_object_attributes.read();
        if (!attributes.ObjectName)
        {
            return STATUS_INVALID_PARAMETER;
        }

        emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> port_name{c.emu, attributes.ObjectName};
        return handle_NtAlpcConnectPort(c, port_handle, port_name, connection_port_object_attributes, port_attributes, flags, {},
                                        connection_message, buffer_length, out_message_attributes, in_message_attributes, timeout);
    }

    NTSTATUS handle_NtAlpcSendWaitReceivePort(const syscall_context& c, const handle port_handle, const ULONG /*flags*/,
                                              const emulator_object<PORT_MESSAGE64> send_message,
                                              const emulator_object<ALPC_MESSAGE_ATTRIBUTES>
                                              /*send_message_attributes*/,
                                              const emulator_object<PORT_MESSAGE64> receive_message,
                                              const emulator_object<EmulatorTraits<Emu64>::SIZE_T> /*buffer_length*/,
                                              const emulator_object<ALPC_MESSAGE_ATTRIBUTES>
                                              /*receive_message_attributes*/,
                                              const emulator_object<LARGE_INTEGER> /*timeout*/)
    {
        auto* port = c.proc.ports.get(port_handle);
        if (!port)
        {
            return STATUS_INVALID_HANDLE;
        }

        lpc_message_context context{c.emu};
        context.send_message = send_message;
        context.receive_message = receive_message;

        return port->handle_message(c.win_emu, context);
    }

    NTSTATUS handle_NtAlpcQueryInformation()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtAlpcSetInformation()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtAlpcCreateSecurityContext()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtAlpcDeleteSecurityContext()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtAlpcConnectPortEx()
    {
        return STATUS_NOT_SUPPORTED;
    }
}

```

`src/windows-emulator/syscalls/process.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

#include <utils/finally.hpp>

namespace syscalls
{
    NTSTATUS handle_NtQueryInformationProcess(const syscall_context& c, const handle process_handle, const uint32_t info_class,
                                              const uint64_t process_information, const uint32_t process_information_length,
                                              const emulator_object<uint32_t> return_length)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        const auto return_length_info = c.win_emu.memory.get_region_info(return_length.value());

        switch (info_class)
        {
        case ProcessExecuteFlags:
            return STATUS_NOT_SUPPORTED;
        case ProcessGroupInformation:
        case ProcessMitigationPolicy: {
            // ProcessMitigationPolicy requires special handling because the caller
            // specifies which policy to query via the Policy field in the input buffer.
            // We need to read this field first to determine what's being queried.

            // Ensure we have at least enough space to read the Policy field
            if (process_information_length < sizeof(PROCESS_MITIGATION_POLICY))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            // Read the policy type from the input buffer using safe emulator memory access
            const emulator_object<PROCESS_MITIGATION_POLICY> policy_obj{c.emu, process_information};
            const auto policy = policy_obj.read();

            // We only support querying ProcessDynamicCodePolicy
            if (policy != ProcessDynamicCodePolicy)
            {
                return STATUS_NOT_SUPPORTED;
            }

            return handle_query<PROCESS_MITIGATION_POLICY_RAW_DATA>(c.emu, process_information, process_information_length, return_length,
                                                                    [policy](PROCESS_MITIGATION_POLICY_RAW_DATA& policy_data) {
                                                                        policy_data.Policy = policy;
                                                                        policy_data.Value = 0;
                                                                    });
        }
        case ProcessEnclaveInformation:
            return STATUS_NOT_SUPPORTED;

        case ProcessTimes:
            return handle_query<KERNEL_USER_TIMES>(c.emu, process_information, process_information_length, return_length,
                                                   [](KERNEL_USER_TIMES& t) {
                                                       t = {}; //
                                                   });

        case ProcessCookie:
            return handle_query<uint32_t>(c.emu, process_information, process_information_length, return_length, [](uint32_t& cookie) {
                cookie = 0x01234567; //
            });

        case ProcessDebugObjectHandle:

            c.win_emu.callbacks.on_suspicious_activity("Anti-debug check with ProcessDebugObjectHandle");

            if ((process_information & 3) != 0)
            {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            if (return_length.value() == 0)
            {
                return STATUS_PORT_NOT_SET;
            }

            if (!return_length_info.is_reserved)
            {
                return STATUS_ACCESS_VIOLATION;
            }

            return handle_query<handle>(c.emu, process_information, process_information_length, return_length, [](handle& h) {
                h = NULL_HANDLE;
                return STATUS_PORT_NOT_SET;
            });

        case ProcessDebugFlags:
        case ProcessWx86Information:
        case ProcessDefaultHardErrorMode:
            return handle_query<ULONG>(c.emu, process_information, process_information_length, return_length, [&](ULONG& res) {
                res = (info_class == ProcessDebugFlags ? 1 : 0); //
            });

        case ProcessDebugPort:
            c.win_emu.callbacks.on_suspicious_activity("Anti-debug check with ProcessDebugPort");

            return handle_query<EmulatorTraits<Emu64>::PVOID>(c.emu, process_information, process_information_length, return_length,
                                                              [](EmulatorTraits<Emu64>::PVOID& ptr) {
                                                                  ptr = 0; //
                                                              });

        case ProcessDeviceMap:
            return handle_query<EmulatorTraits<Emu64>::PVOID>(c.emu, process_information, process_information_length, return_length,
                                                              [](EmulatorTraits<Emu64>::PVOID& ptr) {
                                                                  ptr = 0; //
                                                              });

        case ProcessEnableAlignmentFaultFixup:
            return handle_query<BOOLEAN>(c.emu, process_information, process_information_length, return_length, [](BOOLEAN& b) {
                b = FALSE; //
            });

        case ProcessPriorityClass:
            return handle_query<PROCESS_PRIORITY_CLASS>(c.emu, process_information, process_information_length, return_length,
                                                        [](PROCESS_PRIORITY_CLASS& c) {
                                                            c.Foreground = 1;
                                                            c.PriorityClass = 32; // Normal
                                                        });

        case ProcessBasicInformation: {
            const auto init_basic_info = [&](PROCESS_BASIC_INFORMATION64& basic_info) {
                basic_info.PebBaseAddress = c.proc.peb64.value();
                basic_info.UniqueProcessId = 1;
            };

            switch (process_information_length)
            {
            case sizeof(PROCESS_BASIC_INFORMATION64):
                return handle_query<PROCESS_BASIC_INFORMATION64>(c.emu, process_information, process_information_length, return_length,
                                                                 init_basic_info);
            case sizeof(PROCESS_EXTENDED_BASIC_INFORMATION):
                return handle_query<PROCESS_EXTENDED_BASIC_INFORMATION>(
                    c.emu, process_information, process_information_length, return_length,
                    [&](PROCESS_EXTENDED_BASIC_INFORMATION& ext_basic_info) {
                        ext_basic_info.Size = sizeof(PROCESS_EXTENDED_BASIC_INFORMATION);
                        init_basic_info(ext_basic_info.BasicInfo);
                    });
            default:
                return STATUS_INFO_LENGTH_MISMATCH;
            }
        }

        case ProcessImageInformation:
            return handle_query<SECTION_IMAGE_INFORMATION<EmulatorTraits<Emu64>>>(
                c.emu, process_information, process_information_length, return_length,
                [&](SECTION_IMAGE_INFORMATION<EmulatorTraits<Emu64>>& i) {
                    const auto& mod = *c.win_emu.mod_manager.executable;

                    const emulator_object<PEDosHeader_t> dos_header_obj{c.emu, mod.image_base};
                    const auto dos_header = dos_header_obj.read();

                    const emulator_object<PENTHeaders_t<uint64_t>> nt_headers_obj{c.emu, mod.image_base + dos_header.e_lfanew};
                    const auto nt_headers = nt_headers_obj.read();

                    const auto& file_header = nt_headers.FileHeader;
                    const auto& optional_header = nt_headers.OptionalHeader;

                    i.TransferAddress = 0;
                    i.MaximumStackSize = optional_header.SizeOfStackReserve;
                    i.CommittedStackSize = optional_header.SizeOfStackCommit;
                    i.SubSystemType = optional_header.Subsystem;
                    i.SubSystemMajorVersion = optional_header.MajorSubsystemVersion;
                    i.SubSystemMinorVersion = optional_header.MinorSubsystemVersion;
                    i.MajorOperatingSystemVersion = optional_header.MajorOperatingSystemVersion;
                    i.MinorOperatingSystemVersion = optional_header.MinorOperatingSystemVersion;
                    i.ImageCharacteristics = file_header.Characteristics;
                    i.DllCharacteristics = optional_header.DllCharacteristics;
                    i.Machine = file_header.Machine;
                    i.ImageContainsCode = TRUE;
                    i.ImageFlags = 0; // TODO
                    i.ImageFileSize = optional_header.SizeOfImage;
                    i.LoaderFlags = optional_header.LoaderFlags;
                    i.CheckSum = optional_header.CheckSum;
                });

        case ProcessImageFileNameWin32: {
            const auto peb = c.proc.peb64.read();
            emulator_object<RTL_USER_PROCESS_PARAMETERS64> proc_params{c.emu, peb.ProcessParameters};
            const auto params = proc_params.read();
            const auto length = params.ImagePathName.Length + sizeof(UNICODE_STRING<EmulatorTraits<Emu64>>) + 2;

            if (return_length)
            {
                return_length.write(static_cast<uint32_t>(length));
            }

            if (process_information_length < length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> info{c.emu, process_information};
            info.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& str) {
                const auto buffer_start = static_cast<uint64_t>(process_information) + sizeof(UNICODE_STRING<EmulatorTraits<Emu64>>);
                const auto string = read_unicode_string(c.emu, params.ImagePathName);
                c.emu.write_memory(buffer_start, string.c_str(), (string.size() + 1) * 2);
                str.Length = params.ImagePathName.Length;
                str.MaximumLength = str.Length;
                str.Buffer = buffer_start;
            });

            return STATUS_SUCCESS;
        }

        default:
            c.win_emu.log.error("Unsupported process info class: %X\n", info_class);
            c.emu.stop();

            return STATUS_NOT_SUPPORTED;
        }
    }

    NTSTATUS handle_NtSetInformationProcess(const syscall_context& c, const handle process_handle, const uint32_t info_class,
                                            const uint64_t process_information, const uint32_t process_information_length)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (info_class == ProcessSchedulerSharedData                     //
            || info_class == ProcessConsoleHostProcess                   //
            || info_class == ProcessFaultInformation                     //
            || info_class == ProcessDefaultHardErrorMode                 //
            || info_class == ProcessRaiseUMExceptionOnInvalidHandleClose //
            || info_class == ProcessDynamicFunctionTableInformation      //
            || info_class == ProcessPriorityBoost                        //
            || info_class == ProcessPriorityClassEx                      //
            || info_class == ProcessPriorityClass || info_class == ProcessAffinityMask)
        {
            return STATUS_SUCCESS;
        }

        if (info_class == ProcessExecuteFlags)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (info_class == ProcessTlsInformation)
        {
            if (process_information_length < sizeof(PROCESS_TLS_INFORMATION) ||
                (process_information_length - (sizeof(PROCESS_TLS_INFORMATION) - sizeof(THREAD_TLS_INFORMATION))) %
                    sizeof(THREAD_TLS_INFORMATION))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            constexpr auto thread_data_offset = offsetof(PROCESS_TLS_INFORMATION, ThreadData);
            const emulator_object<THREAD_TLS_INFORMATION> data{c.emu, process_information + thread_data_offset};

            PROCESS_TLS_INFORMATION tls_info{};
            c.emu.read_memory(process_information, &tls_info, thread_data_offset);

            for (uint32_t i = 0; i < tls_info.ThreadDataCount; ++i)
            {
                auto entry = data.read(i);

                const auto _ = utils::finally([&] { data.write(entry, i); });

                if (i >= c.proc.threads.size())
                {
                    entry.Flags = 0;
                    continue;
                }

                auto thread_iterator = c.proc.threads.begin();
                std::advance(thread_iterator, i);

                entry.Flags = 2;

                const auto is_wow64 = c.win_emu.process.is_wow64_process;
                const auto& thread = thread_iterator->second;

                thread.teb64->access([&](TEB64& teb) {
                    entry.ThreadId = teb.ClientId.UniqueThread;

                    uint64_t tls_vector = teb.ThreadLocalStoragePointer;
                    const auto ptr_size = is_wow64 ? sizeof(EmulatorTraits<Emu32>::PVOID) : sizeof(EmulatorTraits<Emu64>::PVOID);

                    if (is_wow64)
                    {
                        if (!thread.teb32.has_value())
                        {
                            return;
                        }

                        thread.teb32->access([&tls_vector](const TEB32& teb32) { tls_vector = teb32.ThreadLocalStoragePointer; });
                    }

                    if (!tls_vector)
                    {
                        return;
                    }

                    if (tls_info.OperationType == ProcessTlsReplaceIndex)
                    {
                        const auto tls_entry_ptr = tls_vector + (tls_info.TlsIndex * ptr_size);
                        uint64_t old_entry{};

                        if (is_wow64)
                        {
                            old_entry = c.emu.read_memory<EmulatorTraits<Emu32>::PVOID>(tls_entry_ptr);
                            c.emu.write_memory<EmulatorTraits<Emu32>::PVOID>(tls_entry_ptr, static_cast<uint32_t>(entry.NewTlsData));
                        }
                        else
                        {
                            old_entry = c.emu.read_memory<EmulatorTraits<Emu64>::PVOID>(tls_entry_ptr);
                            c.emu.write_memory<EmulatorTraits<Emu64>::PVOID>(tls_entry_ptr, entry.NewTlsData);
                        }

                        entry.OldTlsData = old_entry;
                    }
                    else if (tls_info.OperationType == ProcessTlsReplaceVector)
                    {
                        const auto new_tls_vector = entry.NewTlsData;

                        for (uint32_t index = 0; index < tls_info.PreviousCount; ++index)
                        {
                            if (is_wow64)
                            {
                                const auto old_entry = c.emu.read_memory<uint32_t>(tls_vector + (index * ptr_size));
                                c.emu.write_memory(new_tls_vector + (index * ptr_size), old_entry);
                            }
                            else
                            {
                                const auto old_entry = c.emu.read_memory<uint64_t>(tls_vector + (index * ptr_size));
                                c.emu.write_memory(new_tls_vector + (index * ptr_size), old_entry);
                            }
                        }

                        if (is_wow64)
                        {
                            thread.teb32->access([&new_tls_vector](TEB32& teb32) {
                                teb32.ThreadLocalStoragePointer = static_cast<uint32_t>(new_tls_vector);
                            });
                        }
                        else
                        {
                            teb.ThreadLocalStoragePointer = new_tls_vector;
                        }

                        entry.OldTlsData = tls_vector;
                    }
                });
            }

            return STATUS_SUCCESS;
        }

        if (info_class == ProcessInstrumentationCallback)
        {
            if (process_information_length != sizeof(PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION info;

            c.emu.read_memory(process_information, &info, sizeof(PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION));
            c.win_emu.callbacks.on_suspicious_activity("Setting ProcessInstrumentationCallback");

            c.proc.instrumentation_callback = info.Callback;

            return STATUS_SUCCESS;
        }

        c.win_emu.log.error("Unsupported info process class: %X\n", info_class);
        c.emu.stop();

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtOpenProcess()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtOpenProcessToken(const syscall_context&, const handle process_handle, const ACCESS_MASK /*desired_access*/,
                                       const emulator_object<handle> token_handle)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        token_handle.write(CURRENT_PROCESS_TOKEN);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtOpenProcessTokenEx(const syscall_context& c, const handle process_handle, const ACCESS_MASK desired_access,
                                         const ULONG /*handle_attributes*/, const emulator_object<handle> token_handle)
    {
        return handle_NtOpenProcessToken(c, process_handle, desired_access, token_handle);
    }

    NTSTATUS handle_NtTerminateProcess(const syscall_context& c, const handle process_handle, NTSTATUS exit_status)
    {
        if (process_handle == 0)
        {
            for (auto& thread : c.proc.threads | std::views::values)
            {
                if (&thread != c.proc.active_thread)
                {
                    thread.exit_status = exit_status;
                }
            }

            return STATUS_SUCCESS;
        }

        if (process_handle == CURRENT_PROCESS)
        {
            c.proc.exit_status = exit_status;
            c.emu.stop();
            return STATUS_SUCCESS;
        }

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtFlushInstructionCache(const syscall_context& c, const handle process_handle,
                                            const emulator_object<uint64_t> base_address, const uint64_t region_size)
    {
        (void)c;
        (void)process_handle;
        (void)base_address;
        (void)region_size;
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/registry.cpp`:

```cpp
#include "../std_include.hpp"
#include "../syscall_dispatcher.hpp"
#include "../cpu_context.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtOpenKey(const syscall_context& c, const emulator_object<handle> key_handle, const ACCESS_MASK /*desired_access*/,
                              const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        const auto attributes = object_attributes.read();
        auto key = read_unicode_string(c.emu, attributes.ObjectName);

        if (attributes.RootDirectory)
        {
            const auto* parent_handle = c.proc.registry_keys.get(attributes.RootDirectory);
            if (!parent_handle)
            {
                return STATUS_INVALID_HANDLE;
            }

            const std::filesystem::path full_path = parent_handle->hive.get() / parent_handle->path.get() / key;
            key = full_path.u16string();
        }

        c.win_emu.callbacks.on_generic_access("Registry key", key);

        auto entry = c.win_emu.registry.get_key({key});
        if (!entry.has_value())
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        const auto handle = c.proc.registry_keys.store(std::move(entry.value()));
        key_handle.write(handle);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtOpenKeyEx(const syscall_context& c, const emulator_object<handle> key_handle, const ACCESS_MASK desired_access,
                                const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG /*open_options*/)
    {
        return handle_NtOpenKey(c, key_handle, desired_access, object_attributes);
    }

    NTSTATUS handle_NtQueryKey(const syscall_context& c, const handle key_handle, const KEY_INFORMATION_CLASS key_information_class,
                               const uint64_t key_information, const ULONG length, const emulator_object<ULONG> result_length)
    {
        const auto* key = c.proc.registry_keys.get(key_handle);
        if (!key)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (key_information_class == KeyNameInformation)
        {
            auto key_name = (key->hive.get() / key->path.get()).u16string();
            while (key_name.ends_with(u'/') || key_name.ends_with(u'\\'))
            {
                key_name.pop_back();
            }

            std::ranges::transform(key_name, key_name.begin(), std::towupper);

            const auto required_size = sizeof(KEY_NAME_INFORMATION) + (key_name.size() * 2) - 1;
            result_length.write(static_cast<ULONG>(required_size));

            if (required_size > length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            KEY_NAME_INFORMATION info{};
            info.NameLength = static_cast<ULONG>(key_name.size() * 2);

            const emulator_object<KEY_NAME_INFORMATION> info_obj{c.emu, key_information};
            info_obj.write(info);

            c.emu.write_memory(key_information + offsetof(KEY_NAME_INFORMATION, Name), key_name.data(), info.NameLength);

            return STATUS_SUCCESS;
        }

        if (key_information_class == KeyFullInformation)
        {
            c.win_emu.log.warn("Unsupported registry class: %X\n", key_information_class);
            return STATUS_NOT_SUPPORTED;
        }

        if (key_information_class == KeyCachedInformation)
        {
            auto key_name = (key->hive.get() / key->path.get()).u16string();
            while (key_name.ends_with(u'/') || key_name.ends_with(u'\\'))
            {
                key_name.pop_back();
            }

            const auto hive_key = c.win_emu.registry.get_hive_key(*key);
            if (!hive_key.has_value())
            {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            constexpr auto required_size = sizeof(KEY_CACHED_INFORMATION);
            result_length.write(required_size);

            if (required_size > length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            KEY_CACHED_INFORMATION info{};
            info.SubKeys = static_cast<ULONG>(hive_key->key.get_sub_key_count(hive_key->file));
            info.Values = static_cast<ULONG>(hive_key->key.get_value_count(hive_key->file));
            info.NameLength = static_cast<ULONG>(key_name.size() * 2);
            info.MaxValueDataLen = 0x1000;
            info.MaxValueNameLen = 0x1000;
            info.MaxNameLen = 0x1000;

            c.emu.write_memory(key_information, info);
            return STATUS_SUCCESS;
        }

        if (key_information_class == KeyHandleTagsInformation)
        {
            constexpr auto required_size = sizeof(KEY_HANDLE_TAGS_INFORMATION);
            result_length.write(required_size);

            if (required_size > length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            KEY_HANDLE_TAGS_INFORMATION info{};
            info.HandleTags = 0; // ?

            const emulator_object<KEY_HANDLE_TAGS_INFORMATION> info_obj{c.emu, key_information};
            info_obj.write(info);

            return STATUS_SUCCESS;
        }

        c.win_emu.log.warn("Unsupported registry class: %X\n", key_information_class);
        c.emu.stop();
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryValueKey(const syscall_context& c, const handle key_handle,
                                    const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> value_name,
                                    const KEY_VALUE_INFORMATION_CLASS key_value_information_class, const uint64_t key_value_information,
                                    const ULONG length, const emulator_object<ULONG> result_length)
    {
        const auto* key = c.proc.registry_keys.get(key_handle);
        if (!key)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto query_name = read_unicode_string(c.emu, value_name);

        if (c.win_emu.callbacks.on_generic_access)
        {
            // TODO: Find a better way to log this
            c.win_emu.callbacks.on_generic_access("Querying value key", query_name + u" (" + key->to_string() + u")");
        }

        const auto value = c.win_emu.registry.get_value(*key, u16_to_u8(query_name));
        if (!value)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        const std::u16string original_name(value->name.begin(), value->name.end());

        if (key_value_information_class == KeyValueBasicInformation)
        {
            constexpr auto base_size = offsetof(KEY_VALUE_BASIC_INFORMATION, Name);
            const auto required_size = base_size + (original_name.size() * 2) - 1;
            result_length.write(static_cast<ULONG>(required_size));

            KEY_VALUE_BASIC_INFORMATION info{};
            info.TitleIndex = 0;
            info.Type = value->type;
            info.NameLength = static_cast<ULONG>(original_name.size() * 2);

            if (base_size <= length)
            {
                c.emu.write_memory(key_value_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_value_information + base_size, original_name.data(), info.NameLength);

            return STATUS_SUCCESS;
        }

        if (key_value_information_class == KeyValuePartialInformation)
        {
            constexpr auto base_size = offsetof(KEY_VALUE_PARTIAL_INFORMATION, Data);
            const auto required_size = base_size + value->data.size();
            result_length.write(static_cast<ULONG>(required_size));

            KEY_VALUE_PARTIAL_INFORMATION info{};
            info.TitleIndex = 0;
            info.Type = value->type;
            info.DataLength = static_cast<ULONG>(value->data.size());

            if (base_size <= length)
            {
                c.emu.write_memory(key_value_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_value_information + base_size, value->data.data(), value->data.size());

            return STATUS_SUCCESS;
        }

        if (key_value_information_class == KeyValueFullInformation)
        {
            constexpr auto base_size = offsetof(KEY_VALUE_FULL_INFORMATION, Name);
            const auto name_size = original_name.size() * 2;
            const auto value_size = value->data.size();
            const auto required_size = base_size + name_size + value_size + -1;
            result_length.write(static_cast<ULONG>(required_size));

            KEY_VALUE_FULL_INFORMATION info{};
            info.TitleIndex = 0;
            info.Type = value->type;
            info.DataLength = static_cast<ULONG>(value->data.size());
            info.NameLength = static_cast<ULONG>(original_name.size() * 2);

            if (base_size <= length)
            {
                c.emu.write_memory(key_value_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_value_information + base_size, original_name.data(), info.NameLength);

            c.emu.write_memory(key_value_information + base_size + info.NameLength, value->data.data(), value->data.size());

            return STATUS_SUCCESS;
        }

        c.win_emu.log.warn("Unsupported registry value class: %X\n", key_value_information_class);
        c.emu.stop();
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryMultipleValueKey(const syscall_context& c, const handle key_handle,
                                            const emulator_object<KEY_VALUE_ENTRY> value_entries, const ULONG entry_count,
                                            const uint64_t value_buffer, const emulator_object<ULONG> buffer_length,
                                            const emulator_object<ULONG> required_buffer_length)
    {
        if (entry_count > 0x10000)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        const auto* key = c.proc.registry_keys.get(key_handle);
        if (!key)
        {
            return STATUS_INVALID_HANDLE;
        }

        NTSTATUS status = STATUS_SUCCESS;
        auto remaining_length = buffer_length.read();
        ULONG required_length = 0;
        ULONG written_bytes = 0;

        for (ULONG i = 0; i < entry_count; i++)
        {
            auto entry = value_entries.read(i);
            if (!entry.ValueName)
            {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            const auto query_name = read_unicode_string(c.emu, entry.ValueName);

            if (c.win_emu.callbacks.on_generic_access)
            {
                // TODO: Find a better way to log this
                c.win_emu.callbacks.on_generic_access("Querying multiple value key ", query_name + u" (" + key->to_string() + u")");
            }

            const auto value = c.win_emu.registry.get_value(*key, u16_to_u8(query_name));
            if (!value)
            {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;
            }

            const auto data_length = static_cast<ULONG>(value->data.size());

            if (status == STATUS_SUCCESS)
            {
                if (remaining_length >= data_length)
                {
                    entry.DataOffset = written_bytes;
                    entry.DataLength = data_length;
                    entry.Type = value->type;

                    c.emu.write_memory(value_buffer + entry.DataOffset, value->data.data(), entry.DataLength);
                    value_entries.write(entry, i);

                    remaining_length -= data_length;
                    written_bytes += data_length;
                }
                else
                {
                    status = STATUS_BUFFER_OVERFLOW;
                }
            }

            required_length += data_length;
        }

        buffer_length.write(written_bytes);

        if (required_buffer_length.value())
        {
            required_buffer_length.write(required_length);
        }

        return status;
    }

    NTSTATUS handle_NtCreateKey(const syscall_context& c, const emulator_object<handle> key_handle, const ACCESS_MASK desired_access,
                                const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                const ULONG /*title_index*/, const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> /*class*/,
                                const ULONG /*create_options*/, const emulator_object<ULONG> /*disposition*/)
    {
        const auto result = handle_NtOpenKey(c, key_handle, desired_access, object_attributes);

        if (result == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            return STATUS_NOT_SUPPORTED;
        }

        return result;
    }

    NTSTATUS handle_NtNotifyChangeKey()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetInformationKey()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtEnumerateKey(const syscall_context& c, const handle key_handle, const ULONG index,
                                   const KEY_INFORMATION_CLASS key_information_class, const uint64_t key_information, const ULONG length,
                                   const emulator_object<ULONG> result_length)
    {
        const auto* key = c.proc.registry_keys.get(key_handle);
        if (!key)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto subkey_name = c.win_emu.registry.get_sub_key_name(*key, index);
        if (!subkey_name)
        {
            return STATUS_NO_MORE_ENTRIES;
        }

        const std::u16string subkey_name_u16(subkey_name->begin(), subkey_name->end());

        if (key_information_class == KeyBasicInformation)
        {
            constexpr auto base_size = offsetof(KEY_BASIC_INFORMATION, Name);
            const auto name_size = subkey_name_u16.size() * 2;
            const auto required_size = base_size + name_size;
            result_length.write(static_cast<ULONG>(required_size));

            KEY_BASIC_INFORMATION info{};
            info.LastWriteTime.QuadPart = 0;
            info.TitleIndex = 0;
            info.NameLength = static_cast<ULONG>(name_size);

            if (base_size <= length)
            {
                c.emu.write_memory(key_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_information + base_size, subkey_name_u16.data(), name_size);

            return STATUS_SUCCESS;
        }

        if (key_information_class == KeyNodeInformation)
        {
            constexpr auto base_size = offsetof(KEY_NODE_INFORMATION, Name);
            const auto name_size = subkey_name_u16.size() * 2;
            constexpr auto class_size = 0; // TODO: Class Name
            const auto required_size = base_size + name_size + class_size;
            result_length.write(static_cast<ULONG>(required_size));

            KEY_NODE_INFORMATION info{};
            info.LastWriteTime.QuadPart = 0;
            info.TitleIndex = 0;
            info.ClassOffset = static_cast<ULONG>(base_size + name_size);
            info.ClassLength = static_cast<ULONG>(class_size);
            info.NameLength = static_cast<ULONG>(name_size);

            if (base_size <= length)
            {
                c.emu.write_memory(key_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_information + base_size, subkey_name_u16.data(), name_size);
            // TODO: Write Class Name

            return STATUS_SUCCESS;
        }

        c.win_emu.log.warn("Unsupported registry enumeration class: %X\n", key_information_class);
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtEnumerateValueKey(const syscall_context& c, const handle key_handle, const ULONG index,
                                        const KEY_VALUE_INFORMATION_CLASS key_value_information_class, const uint64_t key_value_information,
                                        const ULONG length, const emulator_object<ULONG> result_length)
    {
        const auto* key = c.proc.registry_keys.get(key_handle);
        if (!key)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto value = c.win_emu.registry.get_value(*key, index);
        if (!value)
        {
            return STATUS_NO_MORE_ENTRIES;
        }

        const std::u16string value_name_u16(value->name.begin(), value->name.end());

        if (key_value_information_class == KeyValueBasicInformation)
        {
            constexpr auto base_size = offsetof(KEY_VALUE_BASIC_INFORMATION, Name);
            const auto name_size = value_name_u16.size() * 2;
            const auto required_size = base_size + name_size;
            result_length.write(static_cast<ULONG>(required_size));

            KEY_VALUE_BASIC_INFORMATION info{};
            info.TitleIndex = 0;
            info.Type = value->type;
            info.NameLength = static_cast<ULONG>(name_size);

            if (base_size <= length)
            {
                c.emu.write_memory(key_value_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_value_information + base_size, value_name_u16.data(), name_size);

            return STATUS_SUCCESS;
        }

        if (key_value_information_class == KeyValuePartialInformation)
        {
            constexpr auto base_size = offsetof(KEY_VALUE_PARTIAL_INFORMATION, Data);
            const auto data_size = value->data.size();
            const auto required_size = base_size + data_size;
            result_length.write(static_cast<ULONG>(required_size));

            KEY_VALUE_PARTIAL_INFORMATION info{};
            info.TitleIndex = 0;
            info.Type = value->type;
            info.DataLength = static_cast<ULONG>(data_size);

            if (base_size <= length)
            {
                c.emu.write_memory(key_value_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_value_information + base_size, value->data.data(), data_size);

            return STATUS_SUCCESS;
        }

        if (key_value_information_class == KeyValueFullInformation)
        {
            constexpr auto base_size = offsetof(KEY_VALUE_FULL_INFORMATION, Name);
            const auto name_size = value_name_u16.size() * 2;
            const auto data_size = value->data.size();
            const auto data_offset = static_cast<ULONG>(base_size + name_size);
            const auto required_size = data_offset + data_size;

            result_length.write(static_cast<ULONG>(required_size));

            KEY_VALUE_FULL_INFORMATION info{};
            info.TitleIndex = 0;
            info.Type = value->type;
            info.DataOffset = data_offset;
            info.DataLength = static_cast<ULONG>(data_size);
            info.NameLength = static_cast<ULONG>(name_size);

            if (base_size <= length)
            {
                c.emu.write_memory(key_value_information, &info, base_size);
            }

            if (required_size > length)
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            c.emu.write_memory(key_value_information + base_size, value_name_u16.data(), name_size);

            c.emu.write_memory(key_value_information + data_offset, value->data.data(), data_size);

            return STATUS_SUCCESS;
        }

        c.win_emu.log.warn("Unsupported registry value enumeration class: %X\n", key_value_information_class);
        return STATUS_NOT_SUPPORTED;
    }
}

```

`src/windows-emulator/syscalls/section.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"
#include "../memory_manager.hpp"

#include <utils/io.hpp>

namespace syscalls
{
    using namespace std::string_view_literals;

    namespace
    {
        // From syswow64 kernel32:
        // - _BaseDllInitialize reads ReadOnlyStaticServerData[2]
        // - _BaseDllInitializeIniFileMappings / BaseDllCaptureIniFileParameters read +0x170 and +0x9e8
        constexpr uint64_t k_base_static_server_data_table_index = 2;
        constexpr uint64_t k_base_static_server_data_ini_file_mapping_offset = 0x170;
        constexpr uint64_t k_base_static_server_data_bias_offset = 0x9e8;
        constexpr uint64_t k_base_static_server_data_legacy_time_zone_id_offset = 0x9c8;
        constexpr uint64_t k_base_static_server_data_win2019_time_zone_id_offset = 0xa70;
        constexpr uint32_t k_time_zone_id_invalid = 0xFFFFFFFF;

        struct ini_file_mapping64
        {
            uint64_t file_names;
            uint64_t default_file_name_mapping;
            uint64_t win_ini_file_mapping;
            uint32_t reserved;
            uint32_t padding;
        };

        static_assert(sizeof(ini_file_mapping64) == 0x20);

        NTSTATUS initialize_shared_section_base_static_server_data_mapping(const syscall_context& c, const uint64_t shared_section_address,
                                                                           const uint64_t shared_section_size, uint64_t& obj_address)
        {
            // BaseStaticServerData starts after shared pointer table entries
            const auto base_static_server_data_offset =
                align_up((k_base_static_server_data_table_index + 1) * sizeof(uint32_t), sizeof(uint64_t));

            // Emulator-owned ini mapping object at the end
            const auto ini_file_mapping_offset = align_up(shared_section_size - sizeof(ini_file_mapping64), alignof(ini_file_mapping64));

            const auto has_room = [&](const uint64_t offset, const uint64_t size) {
                return size <= shared_section_size && offset <= shared_section_size - size;
            };

            const bool table_index_has_room = has_room(sizeof(uint32_t) * k_base_static_server_data_table_index, sizeof(uint32_t));
            const bool ini_mapping_has_room =
                has_room(base_static_server_data_offset + k_base_static_server_data_ini_file_mapping_offset, sizeof(uint64_t));
            const bool bias_has_room = has_room(base_static_server_data_offset + k_base_static_server_data_bias_offset, sizeof(uint64_t));
            const bool legacy_tz_id_has_room =
                has_room(base_static_server_data_offset + k_base_static_server_data_legacy_time_zone_id_offset, sizeof(uint32_t));
            const bool win2019_tz_id_has_room =
                has_room(base_static_server_data_offset + k_base_static_server_data_win2019_time_zone_id_offset, sizeof(uint32_t));
            const bool ini_file_mapping_has_room = has_room(ini_file_mapping_offset, sizeof(ini_file_mapping64));

            if (!table_index_has_room || !ini_mapping_has_room || !bias_has_room || !legacy_tz_id_has_room || !win2019_tz_id_has_room ||
                !ini_file_mapping_has_room)
            {
                return STATUS_INVALID_PARAMETER;
            }

            c.emu.write_memory<uint32_t>(shared_section_address + (sizeof(uint32_t) * k_base_static_server_data_table_index),
                                         static_cast<uint32_t>(base_static_server_data_offset));

            // BaseStaticServerData (BASE_STATIC_SERVER_DATA)
            obj_address = shared_section_address + base_static_server_data_offset;

            const auto ini_file_mapping_address = shared_section_address + ini_file_mapping_offset;
            const auto ini_file_mapping_relative = ini_file_mapping_address - obj_address;

            c.emu.write_memory<uint64_t>(obj_address + k_base_static_server_data_ini_file_mapping_offset, ini_file_mapping_relative);
            c.emu.write_memory<uint64_t>(obj_address + k_base_static_server_data_bias_offset, 0);

            c.emu.write_memory<uint32_t>(obj_address + k_base_static_server_data_legacy_time_zone_id_offset, k_time_zone_id_invalid);
            c.emu.write_memory<uint32_t>(obj_address + k_base_static_server_data_win2019_time_zone_id_offset, k_time_zone_id_invalid);

            const ini_file_mapping64 zero_ini_file_mapping{};
            c.emu.write_memory(ini_file_mapping_address, &zero_ini_file_mapping, sizeof(zero_ini_file_mapping));

            return STATUS_SUCCESS;
        }

        void initialize_shared_section_base_static_server_data_paths(const syscall_context& c, const uint64_t obj_address,
                                                                     std::u16string_view windows_dir)
        {
            const auto windows_dir_size = windows_dir.size() * 2;
            const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> windir_obj{c.emu, obj_address};
            windir_obj.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& ucs) {
                const auto dir_address = kusd_mmio::address() + offsetof(KUSER_SHARED_DATA64, NtSystemRoot);

                ucs.Buffer = dir_address - obj_address;
                ucs.Length = static_cast<uint16_t>(windows_dir_size);
                ucs.MaximumLength = ucs.Length;
            });

            std::u16string system32_path{windows_dir};
            if (!system32_path.empty() && system32_path.back() != u'\\')
            {
                system32_path.push_back(u'\\');
            }
            system32_path += u"System32";

            const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> sysdir_obj{c.emu, windir_obj.value() + windir_obj.size()};
            sysdir_obj.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& ucs) {
                c.proc.base_allocator.make_unicode_string(ucs, system32_path);
                ucs.Buffer = ucs.Buffer - obj_address;
            });

            const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> base_dir_obj{c.emu, sysdir_obj.value() + sysdir_obj.size()};
            base_dir_obj.access([&](UNICODE_STRING<EmulatorTraits<Emu64>>& ucs) {
                c.proc.base_allocator.make_unicode_string(ucs, u"\\Sessions\\1\\BaseNamedObjects");
                ucs.Buffer = ucs.Buffer - obj_address;
            });
        }
    }

    NTSTATUS handle_NtCreateSection(const syscall_context& c, const emulator_object<handle> section_handle,
                                    const ACCESS_MASK /*desired_access*/,
                                    const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                    const emulator_object<ULARGE_INTEGER> maximum_size, const ULONG section_page_protection,
                                    const ULONG allocation_attributes, const handle file_handle)
    {
        section s{};
        s.section_page_protection = section_page_protection;
        s.allocation_attributes = allocation_attributes;

        const auto* file = c.proc.files.get(file_handle);
        if (file)
        {
            c.win_emu.callbacks.on_generic_access("Section for file", file->name);
            s.file_name = file->name;
        }

        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName)
            {
                auto name = read_unicode_string(c.emu, attributes.ObjectName);
                c.win_emu.callbacks.on_generic_access("Section with name", name);
                s.name = std::move(name);
            }
        }

        if (maximum_size)
        {
            maximum_size.access([&](ULARGE_INTEGER& large_int) {
                large_int.QuadPart = page_align_up(large_int.QuadPart);
                s.maximum_size = large_int.QuadPart;
            });
        }
        else if (!file)
        {
            return STATUS_INVALID_PARAMETER;
        }

        // If this is an image section, parse PE headers
        if ((allocation_attributes & SEC_IMAGE) && !s.file_name.empty())
        {
            std::vector<std::byte> file_data;
            if (utils::io::read_file(c.win_emu.file_sys.translate(s.file_name), &file_data))
            {
                s.cache_image_info_from_filedata(file_data);
            }
        }

        const auto h = c.proc.sections.store(std::move(s));
        section_handle.write(h);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtOpenSection(const syscall_context& c, const emulator_object<handle> section_handle,
                                  const ACCESS_MASK /*desired_access*/,
                                  const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        const auto attributes = object_attributes.read();

        auto filename = read_unicode_string(c.emu, attributes.ObjectName);
        auto filename_sv = std::u16string_view(filename);
        c.win_emu.callbacks.on_generic_access("Opening section", filename);

        if (utils::string::equals_ignore_case(filename_sv, u"\\Windows\\SharedSection"sv))
        {
            constexpr auto shared_section_size = 0x10000;

            const auto address = c.win_emu.memory.find_free_allocation_base(shared_section_size);
            c.win_emu.memory.allocate_memory(address, shared_section_size, memory_permission::read_write, false,
                                             memory_region_kind::section_view);
            c.proc.shared_section_address = address;
            c.proc.shared_section_size = shared_section_size;

            section_handle.write(SHARED_SECTION);
            return STATUS_SUCCESS;
        }

        if (utils::string::equals_ignore_case(filename_sv, u"DBWIN_BUFFER"sv))
        {
            constexpr auto dbwin_buffer_section_size = 0x1000;

            const auto address = c.win_emu.memory.find_free_allocation_base(dbwin_buffer_section_size);
            c.win_emu.memory.allocate_memory(address, dbwin_buffer_section_size, memory_permission::read_write, false,
                                             memory_region_kind::section_view);
            c.proc.dbwin_buffer = address;
            c.proc.dbwin_buffer_size = dbwin_buffer_section_size;

            section_handle.write(DBWIN_BUFFER);
            return STATUS_SUCCESS;
        }

        if (utils::string::equals_ignore_case(filename_sv, u"windows_shell_global_counters"sv) ||
            utils::string::equals_ignore_case(filename_sv, u"Global\\__ComCatalogCache__"sv) ||
            utils::string::equals_ignore_case(filename_sv, u"{00020000-0000-1005-8005-0000C06B5161}"sv) ||
            utils::string::equals_ignore_case(filename_sv, u"Global\\{00020000-0000-1005-8005-0000C06B5161}"sv))
        {
            return STATUS_NOT_SUPPORTED;
        }

        bool is_knowndll = (attributes.RootDirectory == KNOWN_DLLS32_DIRECTORY ||
                            utils::string::starts_with_ignore_case(filename_sv, u"\\KnownDlls32\\"sv)) ||
                           attributes.RootDirectory == KNOWN_DLLS_DIRECTORY ||
                           utils::string::starts_with_ignore_case(filename_sv, u"\\KnownDlls\\"sv);

        if (!is_knowndll && attributes.RootDirectory != BASE_NAMED_OBJECTS_DIRECTORY)
        {
            c.win_emu.log.error("Unsupported section\n");
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        if (is_knowndll)
        {
            bool is_knowndll32 = attributes.RootDirectory == KNOWN_DLLS32_DIRECTORY ||
                                 utils::string::starts_with_ignore_case(filename_sv, u"\\KnownDlls32\\"sv);

            std::u16string knowndll_name = filename;

            if (utils::string::starts_with_ignore_case(filename_sv, u"\\KnownDlls32\\"sv))
            {
                knowndll_name = filename.substr(13, filename.length() - 13);
            }

            else if (utils::string::starts_with_ignore_case(filename_sv, u"\\KnownDlls\\"sv))
            {
                knowndll_name = filename.substr(11, filename.length() - 11);
            }

            auto section = c.win_emu.process.get_knowndll_section_by_name(knowndll_name, is_knowndll32);
            if (!section.has_value())
            {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            section_handle.write(c.proc.sections.store(section.value()));
            return STATUS_SUCCESS;
        }

        for (auto& [handle, section] : c.proc.sections)
        {
            if (section.is_image() && utils::string::equals_ignore_case(section.name, filename))
            {
                section_handle.write(c.proc.sections.make_handle(handle));
                return STATUS_SUCCESS;
            }
        }

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    NTSTATUS handle_NtMapViewOfSection(const syscall_context& c, const handle section_handle, const handle process_handle,
                                       const emulator_object<uint64_t> base_address,
                                       const EMULATOR_CAST(EmulatorTraits<Emu64>::ULONG_PTR, ULONG_PTR) /*zero_bits*/,
                                       const EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T) /*commit_size*/,
                                       const emulator_object<LARGE_INTEGER> section_offset,
                                       const emulator_object<EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T)> view_size,
                                       const SECTION_INHERIT /*inherit_disposition*/, const ULONG /*allocation_type*/,
                                       const ULONG /*win32_protect*/)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (section_handle == SHARED_SECTION)
        {
            const auto shared_section_size = c.proc.shared_section_size;
            const auto address = c.proc.shared_section_address;

            const std::u16string_view windows_dir = c.proc.kusd.get().NtSystemRoot.arr;

            uint64_t obj_address{};
            if (const auto status = initialize_shared_section_base_static_server_data_mapping(c, address, shared_section_size, obj_address);
                !NT_SUCCESS(status))
            {
                return status;
            }

            initialize_shared_section_base_static_server_data_paths(c, obj_address, windows_dir);

            if (view_size)
            {
                view_size.write(shared_section_size);
            }

            base_address.write(address);

            return STATUS_SUCCESS;
        }

        if (section_handle == DBWIN_BUFFER)
        {
            const auto dbwin_buffer_section_size = c.proc.dbwin_buffer_size;
            const auto address = c.proc.dbwin_buffer;

            if (view_size)
            {
                view_size.write(dbwin_buffer_section_size);
            }

            base_address.write(address);

            return STATUS_SUCCESS;
        }

        auto* section_entry = c.proc.sections.get(section_handle);
        if (!section_entry)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (section_entry->is_image())
        {
            const auto* binary = c.win_emu.mod_manager.map_module(section_entry->file_name, c.win_emu.log, false, true);
            if (!binary)
            {
                return STATUS_FILE_INVALID;
            }

            std::u16string wide_name(binary->name.begin(), binary->name.end());
            section_entry->name = utils::string::to_lower_consume(wide_name);

            if (view_size.value())
            {
                view_size.write(binary->size_of_image);
            }

            base_address.write(binary->image_base);

            // Should return STATUS_IMAGE_MACHINE_TYPE_MISMATCH if a 64-bit process tried to map a 32-bit PE.
            if (!c.win_emu.process.is_wow64_process && binary->machine == IMAGE_FILE_MACHINE_I386)
            {
                return STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
            }

            if (c.win_emu.mod_manager.get_module_load_count_by_path(section_entry->file_name) > 1)
            {
                return STATUS_IMAGE_NOT_AT_BASE;
            }

            return STATUS_SUCCESS;
        }

        auto size = static_cast<size_t>(section_entry->maximum_size);
        std::vector<std::byte> file_data{};

        int64_t offset = 0;
        if (section_offset)
        {
            offset = section_offset.read().QuadPart;
            offset = std::max<int64_t>(offset, 0);
        }

        if (!section_entry->file_name.empty())
        {
            if (!utils::io::read_file(c.win_emu.file_sys.translate(section_entry->file_name), &file_data))
            {
                return STATUS_INVALID_PARAMETER;
            }

            size = static_cast<size_t>(file_data.size() - offset);
        }

        const auto aligned_size = static_cast<size_t>(page_align_up(size));
        const auto reserve_only = section_entry->allocation_attributes == SEC_RESERVE;
        const auto protection = map_nt_to_emulator_protection(section_entry->section_page_protection);
        const auto address = c.win_emu.memory.allocate_memory(aligned_size, protection, reserve_only, 0, memory_region_kind::section_view);

        if (!reserve_only && !file_data.empty())
        {
            c.emu.write_memory(address, file_data.data() + offset, size);
        }

        if (view_size)
        {
            view_size.write(aligned_size);
        }

        base_address.write(address);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtMapViewOfSectionEx(const syscall_context& c, const handle section_handle, const handle process_handle,
                                         const emulator_object<uint64_t> base_address, const emulator_object<LARGE_INTEGER> section_offset,
                                         const emulator_object<EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T)> view_size,
                                         const ULONG allocation_type, const ULONG page_protection,
                                         const uint64_t extended_parameters, // PMEM_EXTENDED_PARAMETER
                                         const ULONG extended_parameter_count)
    {
        // Process extended parameters if present
        struct ExtendedParamsInfo
        {
            uint64_t numa_node = 0;
            uint64_t lowest_address = 0;
            uint64_t highest_address = UINT64_MAX;
            uint64_t alignment = 0;
            uint32_t attribute_flags = 0;
            uint16_t image_machine = IMAGE_FILE_MACHINE_UNKNOWN;
            bool has_address_requirements = false;
            bool has_numa_node = false;
            bool has_attributes = false;
            bool has_image_machine = false;
        } ext_info;

        if (extended_parameters && extended_parameter_count > 0)
        {
            c.win_emu.log.info("NtMapViewOfSectionEx: Processing %u extended parameters\n", extended_parameter_count);

            // Read and process each extended parameter
            for (ULONG i = 0; i < extended_parameter_count; i++)
            {
                const auto param_addr = extended_parameters + (i * sizeof(MEM_EXTENDED_PARAMETER64));
                MEM_EXTENDED_PARAMETER64 param{};

                // Read the extended parameter structure
                if (!c.emu.try_read_memory(param_addr, &param, sizeof(param)))
                {
                    c.win_emu.log.error("NtMapViewOfSectionEx: Failed to read extended parameter %u\n", i);
                    return STATUS_INVALID_PARAMETER;
                }

                // Extract the type (lower 8 bits)
                const auto param_type = static_cast<MEM_EXTENDED_PARAMETER_TYPE>(param.Type & 0xFF);

                switch (param_type)
                {
                case MemExtendedParameterAddressRequirements: {
                    // Read the MEM_ADDRESS_REQUIREMENTS structure
                    MEM_ADDRESS_REQUIREMENTS64 addr_req{};
                    if (!c.emu.try_read_memory(param.Pointer, &addr_req, sizeof(addr_req)))
                    {
                        c.win_emu.log.error("NtMapViewOfSectionEx: Failed to read address requirements\n");
                        return STATUS_INVALID_PARAMETER;
                    }

                    ext_info.lowest_address = addr_req.LowestStartingAddress;
                    ext_info.highest_address = addr_req.HighestEndingAddress;
                    ext_info.alignment = addr_req.Alignment;
                    ext_info.has_address_requirements = true;

                    c.win_emu.log.info("NtMapViewOfSectionEx: Address requirements - Low: 0x%" PRIX64 ", High: 0x%" PRIX64
                                       ", Align: 0x%" PRIX64 "\n",
                                       ext_info.lowest_address, ext_info.highest_address, ext_info.alignment);
                }
                break;

                case MemExtendedParameterNumaNode:
                    ext_info.numa_node = param.ULong64;
                    ext_info.has_numa_node = true;
                    c.win_emu.log.info("NtMapViewOfSectionEx: NUMA node: %" PRIu64 "\n", ext_info.numa_node);
                    break;

                case MemExtendedParameterAttributeFlags:
                    ext_info.attribute_flags = static_cast<uint32_t>(param.ULong64);
                    ext_info.has_attributes = true;
                    c.win_emu.log.info("NtMapViewOfSectionEx: Attribute flags: 0x%X\n", ext_info.attribute_flags);

                    // Log specific attribute flags
                    if (ext_info.attribute_flags & MEM_EXTENDED_PARAMETER_GRAPHICS)
                    {
                        c.win_emu.log.info("  - Graphics memory requested\n");
                    }
                    if (ext_info.attribute_flags & MEM_EXTENDED_PARAMETER_NONPAGED)
                    {
                        c.win_emu.log.info("  - Non-paged memory requested\n");
                    }
                    if (ext_info.attribute_flags & MEM_EXTENDED_PARAMETER_EC_CODE)
                    {
                        c.win_emu.log.info("  - EC code memory requested\n");
                    }
                    break;

                case MemExtendedParameterImageMachine:
                    ext_info.image_machine = static_cast<uint16_t>(param.ULong);
                    ext_info.has_image_machine = true;
                    c.win_emu.log.info("NtMapViewOfSectionEx: Image machine: 0x%X\n", ext_info.image_machine);
                    break;

                case MemExtendedParameterPartitionHandle:
                    c.win_emu.log.info("NtMapViewOfSectionEx: Partition handle parameter (not supported)\n");
                    break;

                case MemExtendedParameterUserPhysicalHandle:
                    c.win_emu.log.info("NtMapViewOfSectionEx: User physical handle parameter (not supported)\n");
                    break;

                default:
                    c.win_emu.log.warn("NtMapViewOfSectionEx: Unknown extended parameter type: %u\n", param_type);
                    break;
                }
            }

            // Store extended parameters info in process context for other syscalls to use
            // This allows NtAllocateVirtualMemoryEx and other functions to access the same info
            c.proc.last_extended_params_numa_node = ext_info.numa_node;
            c.proc.last_extended_params_attributes = ext_info.attribute_flags;
        }

        // Call the existing NtMapViewOfSection implementation
        // For WOW64 processes with image machine parameter, validate architecture compatibility
        if (ext_info.has_image_machine && c.proc.is_wow64_process)
        {
            c.win_emu.log.info("NtMapViewOfSectionEx: WOW64 process mapping with machine type 0x%X\n", ext_info.image_machine);

            // Special handling for IMAGE_FILE_MACHINE_I386 (0x014c) on WOW64
            if (ext_info.image_machine == IMAGE_FILE_MACHINE_I386)
            {
                // This indicates the caller wants to map a 32-bit view
                // Store this for the module manager to use
                c.win_emu.log.info("NtMapViewOfSectionEx: Mapping 32-bit view for WOW64 process\n");
            }
            else if (ext_info.image_machine == IMAGE_FILE_MACHINE_AMD64)
            {
                // This indicates the caller wants to map a 64-bit view
                c.win_emu.log.info("NtMapViewOfSectionEx: Mapping 64-bit view for WOW64 process\n");
            }
        }

        // Store extended parameters for other syscalls to use
        if (ext_info.has_numa_node)
        {
            c.proc.last_extended_params_numa_node = ext_info.numa_node;
        }
        if (ext_info.has_attributes)
        {
            c.proc.last_extended_params_attributes = ext_info.attribute_flags;
        }
        if (ext_info.has_image_machine)
        {
            c.proc.last_extended_params_image_machine = ext_info.image_machine;
        }

        // Perform the actual mapping
        const auto status = handle_NtMapViewOfSection(c, section_handle, process_handle, base_address,
                                                      0,                // zero_bits (not in Ex)
                                                      0,                // commit_size (not in Ex)
                                                      section_offset,   // section_offset
                                                      view_size,        // view_size
                                                      ViewUnmap,        // inherit_disposition (default)
                                                      allocation_type,  // allocation_type
                                                      page_protection); // page_protection

        // If mapping succeeded and this is a WOW64 image section with specific machine type
        if (NT_SUCCESS(status) && ext_info.has_image_machine && c.proc.is_wow64_process)
        {
            // Check if this was an image section (DLL/EXE)
            auto* section_entry = c.proc.sections.get(section_handle);
            if (section_entry && section_entry->is_image())
            {
                c.win_emu.log.info("NtMapViewOfSectionEx: Successfully mapped image section for WOW64 with machine type 0x%X\n",
                                   ext_info.image_machine);
                // Note: In a full WOW64 implementation, we would check for Wow64Transition export here
            }
        }

        return status;
    }

    NTSTATUS handle_NtUnmapViewOfSection(const syscall_context& c, const handle process_handle, const uint64_t base_address)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (!base_address)
        {
            return STATUS_INVALID_PARAMETER;
        }

        if (c.proc.shared_section_address && base_address >= c.proc.shared_section_address &&
            base_address < c.proc.shared_section_address + c.proc.shared_section_size)
        {
            const auto address = c.proc.shared_section_address;
            c.proc.shared_section_address = 0;
            c.win_emu.memory.release_memory(address, static_cast<size_t>(c.proc.shared_section_size));
            return STATUS_SUCCESS;
        }

        if (c.proc.dbwin_buffer && is_within_start_and_length(base_address, c.proc.dbwin_buffer, c.proc.dbwin_buffer_size))
        {
            const auto address = c.proc.dbwin_buffer;
            c.proc.dbwin_buffer = 0;
            c.win_emu.memory.release_memory(address, static_cast<size_t>(c.proc.dbwin_buffer_size));
            return STATUS_SUCCESS;
        }

        const auto* mod = c.win_emu.mod_manager.find_by_address(base_address);
        if (mod != nullptr)
        {
            if (c.win_emu.mod_manager.unmap(mod->image_base))
            {
                return STATUS_SUCCESS;
            }

            return STATUS_INVALID_PARAMETER;
        }

        const auto region_info = c.win_emu.memory.get_region_info(base_address);
        if (region_info.is_reserved && memory_region_policy::is_section_kind(region_info.kind) &&
            c.win_emu.memory.release_memory(region_info.allocation_base, 0))
        {
            return STATUS_SUCCESS;
        }

        return STATUS_NOT_MAPPED_VIEW;
    }

    NTSTATUS handle_NtUnmapViewOfSectionEx(const syscall_context& c, const handle process_handle, const uint64_t base_address,
                                           const ULONG /*flags*/)
    {
        return handle_NtUnmapViewOfSection(c, process_handle, base_address);
    }

    NTSTATUS handle_NtAreMappedFilesTheSame()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQuerySection(const syscall_context& c, const handle section_handle,
                                   const SECTION_INFORMATION_CLASS section_information_class, const uint64_t section_information,
                                   const EmulatorTraits<Emu64>::SIZE_T section_information_length,
                                   const emulator_object<EmulatorTraits<Emu64>::SIZE_T> result_length)
    {
        // Check if section handle is valid
        auto* section_entry = c.proc.sections.get(section_handle);

        // Handle special sections
        if (section_handle == SHARED_SECTION || section_handle == DBWIN_BUFFER)
        {
            // These special sections don't support querying
            return STATUS_INVALID_HANDLE;
        }

        if (!section_entry)
        {
            return STATUS_INVALID_HANDLE;
        }

        switch (section_information_class)
        {
        case SECTION_INFORMATION_CLASS::SectionBasicInformation: {
            // Check buffer size
            if (section_information_length < sizeof(SECTION_BASIC_INFORMATION<EmulatorTraits<Emu64>>))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            SECTION_BASIC_INFORMATION<EmulatorTraits<Emu64>> info{};

            // BaseAddress - typically NULL unless SEC_BASED is used
            info.BaseAddress = 0;

            // Attributes - combine the SEC_ flags
            info.Attributes = section_entry->allocation_attributes;

            // If it's an image section, ensure SEC_IMAGE is set
            if (section_entry->is_image())
            {
                info.Attributes |= SEC_IMAGE;
            }

            // If it's file-backed, ensure SEC_FILE is set
            if (!section_entry->file_name.empty())
            {
                info.Attributes |= SEC_FILE;
            }

            // Size - maximum size of the section
            info.Size.QuadPart = static_cast<LONGLONG>(section_entry->maximum_size);

            // Write the structure to user buffer
            c.emu.write_memory(section_information, &info, sizeof(info));

            // Set return length if requested
            if (result_length)
            {
                result_length.write(sizeof(SECTION_BASIC_INFORMATION<EmulatorTraits<Emu64>>));
            }

            return STATUS_SUCCESS;
        }

        case SECTION_INFORMATION_CLASS::SectionImageInformation: {
            // Only image sections support this query
            if (!section_entry->is_image())
            {
                return STATUS_SECTION_NOT_IMAGE;
            }

            // Check buffer size
            if (section_information_length < sizeof(SECTION_IMAGE_INFORMATION<EmulatorTraits<Emu64>>))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            SECTION_IMAGE_INFORMATION<EmulatorTraits<Emu64>> info{};

            // First check if we have cached PE information
            if (section_entry->cached_image_info.has_value())
            {
                const auto& cached = section_entry->cached_image_info.value();

                // TransferAddress - entry point address (image base + RVA)
                info.TransferAddress = static_cast<std::uint64_t>(cached.image_base + cached.entry_point_rva);

                // Machine type
                info.Machine = static_cast<PEMachineType>(cached.machine);

                // Subsystem information
                info.SubSystemType = cached.subsystem;
                info.SubSystemMajorVersion = cached.subsystem_major_version;
                info.SubSystemMinorVersion = cached.subsystem_minor_version;

                // Stack sizes
                info.MaximumStackSize = cached.size_of_stack_reserve;
                info.CommittedStackSize = cached.size_of_stack_commit;

                // Image characteristics
                info.ImageCharacteristics = cached.image_characteristics;
                info.DllCharacteristics = cached.dll_characteristics;

                // Image contains code
                info.ImageContainsCode = cached.has_code ? TRUE : FALSE;

                // Image flags
                info.ImageMappedFlat = 1;
                info.ImageDynamicallyRelocated = (cached.dll_characteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) ? 1 : 0;

                // Other fields
                info.ZeroBits = 0;
                info.LoaderFlags = cached.loader_flags;
                info.CheckSum = cached.checksum;
                info.ImageFileSize = static_cast<ULONG>(section_entry->maximum_size);
            }
            else
            {
                // Try to get the mapped module to extract PE information
                // Convert u16string to string for find_by_name
                std::string narrow_name;
                if (!section_entry->name.empty())
                {
                    narrow_name = u16_to_u8(section_entry->name);
                }
                else if (!section_entry->file_name.empty())
                {
                    narrow_name = u16_to_u8(section_entry->file_name);
                }

                const mapped_module* module = nullptr;
                if (!narrow_name.empty())
                {
                    module = c.win_emu.mod_manager.find_by_name(narrow_name);
                }

                if (module)
                {
                    // TransferAddress - entry point address
                    info.TransferAddress = static_cast<std::uint64_t>(module->entry_point);

                    // Machine type and other fields would need to be extracted from PE headers
                    // For now, set reasonable defaults for x64
                    info.Machine = PEMachineType::AMD64;
                    info.SubSystemType = 3; // IMAGE_SUBSYSTEM_WINDOWS_CUI
                    info.SubSystemMajorVersion = 10;
                    info.SubSystemMinorVersion = 0;

                    // Stack sizes - typical defaults
                    info.MaximumStackSize = 0x100000;  // 1MB
                    info.CommittedStackSize = 0x10000; // 64KB

                    // Image characteristics
                    info.ImageCharacteristics = 0x0022; // IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LARGE_ADDRESS_AWARE
                    info.DllCharacteristics = 0x8160;   // Common DLL characteristics including ASLR and DEP

                    // Check if it's a DLL
                    if (section_entry->name.find(u".dll") != std::u16string::npos)
                    {
                        info.ImageCharacteristics |= IMAGE_FILE_DLL;
                    }

                    // Image contains code
                    info.ImageContainsCode = TRUE;

                    // Image flags
                    info.ImageMappedFlat = 1;
                    info.ImageDynamicallyRelocated = 1; // ASLR enabled

                    // File size
                    info.ImageFileSize = static_cast<ULONG>(module->size_of_image);

                    // Other fields
                    info.ZeroBits = 0;
                    info.LoaderFlags = 0;
                    info.CheckSum = 0;
                }
                else
                {
                    // If module is not mapped yet and no cached info, return minimal information
                    info.Machine = PEMachineType::AMD64;
                    info.SubSystemType = 3;
                    info.SubSystemMajorVersion = 10;
                    info.SubSystemMinorVersion = 0;
                    info.MaximumStackSize = 0x100000;
                    info.CommittedStackSize = 0x10000;
                    info.ImageCharacteristics = 0x0022;
                    info.DllCharacteristics = 0x8160;
                    info.ImageContainsCode = TRUE;
                    info.ImageMappedFlat = 1;
                    info.ImageDynamicallyRelocated = 1;
                    info.ImageFileSize = static_cast<ULONG>(section_entry->maximum_size);
                }
            }

            // Write the structure to user buffer
            c.emu.write_memory(section_information, &info, sizeof(info));

            // Set return length if requested
            if (result_length)
            {
                result_length.write(sizeof(SECTION_IMAGE_INFORMATION<EmulatorTraits<Emu64>>));
            }

            return STATUS_SUCCESS;
        }

        case SECTION_INFORMATION_CLASS::SectionRelocationInformation:
        case SECTION_INFORMATION_CLASS::SectionOriginalBaseInformation:
        case SECTION_INFORMATION_CLASS::SectionInternalImageInformation:
            // These information classes are not implemented
            return STATUS_NOT_SUPPORTED;

        default:
            return STATUS_NOT_SUPPORTED;
        }
    }
}

```

`src/windows-emulator/syscalls/semaphore.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtOpenSemaphore(const syscall_context& c, const emulator_object<handle> semaphore_handle,
                                    const ACCESS_MASK /*desired_access*/,
                                    const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
    {
        if (!object_attributes)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto attributes = object_attributes.read();
        if (!attributes.ObjectName)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto name = read_unicode_string(c.emu, emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>>{c.emu, attributes.ObjectName});
        if (name.empty())
        {
            return STATUS_INVALID_PARAMETER;
        }

        for (const auto& semaphore : c.proc.semaphores)
        {
            if (semaphore.second.name == name)
            {
                semaphore_handle.write(c.proc.semaphores.make_handle(semaphore.first));
                return STATUS_SUCCESS;
            }
        }

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    NTSTATUS handle_NtReleaseSemaphore(const syscall_context& c, const handle semaphore_handle, const ULONG release_count,
                                       const emulator_object<LONG> previous_count)
    {
        if (semaphore_handle.value.type != handle_types::semaphore)
        {
            c.win_emu.log.error("Bad handle type for NtReleaseSemaphore\n");
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        auto* mutant = c.proc.semaphores.get(semaphore_handle);
        if (!mutant)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto [old_count, succeeded] = mutant->release(release_count);

        if (previous_count)
        {
            previous_count.write(static_cast<LONG>(old_count));
        }

        return succeeded ? STATUS_SUCCESS : STATUS_SEMAPHORE_LIMIT_EXCEEDED;
    }

    NTSTATUS handle_NtCreateSemaphore(const syscall_context& c, const emulator_object<handle> semaphore_handle,
                                      const ACCESS_MASK /*desired_access*/,
                                      const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                      const ULONG initial_count, const ULONG maximum_count)
    {
        semaphore s{};
        s.current_count = initial_count;
        s.max_count = maximum_count;

        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName)
            {
                s.name = read_unicode_string(c.emu, attributes.ObjectName);
            }
        }

        if (!s.name.empty())
        {
            for (auto& entry : c.proc.semaphores)
            {
                if (entry.second.name == s.name)
                {
                    ++entry.second.ref_count;
                    semaphore_handle.write(c.proc.semaphores.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        const auto handle = c.proc.semaphores.store(std::move(s));
        semaphore_handle.write(handle);

        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/system.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    namespace
    {
        NTSTATUS handle_logical_processor_and_group_information(const syscall_context& c, const uint64_t input_buffer,
                                                                const uint32_t input_buffer_length, const uint64_t system_information,
                                                                const uint32_t system_information_length,
                                                                const emulator_object<uint32_t> return_length)
        {
            if (input_buffer_length != sizeof(LOGICAL_PROCESSOR_RELATIONSHIP))
            {
                return STATUS_INVALID_PARAMETER;
            }

            const auto request = c.emu.read_memory<LOGICAL_PROCESSOR_RELATIONSHIP>(input_buffer);

            if (request == RelationGroup)
            {
                constexpr auto root_size = offsetof(EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX64, Group);
                constexpr auto required_size = root_size + sizeof(EMU_GROUP_RELATIONSHIP64);

                if (return_length)
                {
                    return_length.write(required_size);
                }

                if (system_information_length < required_size)
                {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX64 proc_info{};
                proc_info.Size = required_size;
                proc_info.Relationship = RelationGroup;

                c.emu.write_memory(system_information, &proc_info, root_size);

                EMU_GROUP_RELATIONSHIP64 group{};
                group.ActiveGroupCount = 1;
                group.MaximumGroupCount = 1;

                auto& group_info = group.GroupInfo[0];
                group_info.ActiveProcessorCount = static_cast<uint8_t>(c.proc.kusd.get().ActiveProcessorCount);
                group_info.ActiveProcessorMask = (1 << group_info.ActiveProcessorCount) - 1;
                group_info.MaximumProcessorCount = group_info.ActiveProcessorCount;

                c.emu.write_memory(system_information + root_size, group);
                return STATUS_SUCCESS;
            }

            if (request == RelationNumaNode || request == RelationNumaNodeEx)
            {
                constexpr auto root_size = offsetof(EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX64, NumaNode);
                constexpr auto required_size = root_size + sizeof(EMU_NUMA_NODE_RELATIONSHIP64);

                if (return_length)
                {
                    return_length.write(required_size);
                }

                if (system_information_length < required_size)
                {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX64 proc_info{};
                proc_info.Size = required_size;
                proc_info.Relationship = RelationNumaNode;

                c.emu.write_memory(system_information, &proc_info, root_size);

                EMU_NUMA_NODE_RELATIONSHIP64 numa_node{};
                memset(&numa_node, 0, sizeof(numa_node));

                c.emu.write_memory(system_information + root_size, numa_node);
                return STATUS_SUCCESS;
            }

            c.win_emu.log.error("Unsupported processor relationship: %X\n", request);
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }
    }

    NTSTATUS handle_NtQuerySystemInformationEx(const syscall_context& c, const uint32_t info_class, const uint64_t input_buffer,
                                               const uint32_t input_buffer_length, const uint64_t system_information,
                                               const uint32_t system_information_length, const emulator_object<uint32_t> return_length)
    {
        switch (info_class)
        {
        case 250: // Build 27744
        case SystemFlushInformation:
        case SystemModuleInformation:
        case SystemProcessInformation:
        case SystemMemoryUsageInformation:
        case SystemCodeIntegrityPolicyInformation:
        case SystemHypervisorSharedPageInformation:
        case SystemFeatureConfigurationInformation:
        case SystemSupportedProcessorArchitectures2:
        case SystemFeatureConfigurationSectionInformation:
        case SystemFirmwareTableInformation:
            return STATUS_NOT_SUPPORTED;

        case SystemControlFlowTransition:
            c.win_emu.callbacks.on_suspicious_activity("Warbird control flow transition");
            return STATUS_NOT_SUPPORTED;

        case SystemTimeOfDayInformation:
            return handle_query<SYSTEM_TIMEOFDAY_INFORMATION64>(c.emu, system_information, system_information_length, return_length,
                                                                [&](SYSTEM_TIMEOFDAY_INFORMATION64& info) {
                                                                    memset(&info, 0, sizeof(info));
                                                                    info.BootTime.QuadPart = 0;
                                                                    info.TimeZoneId = 0x00000002;
                                                                    // TODO: Fill
                                                                });

        case SystemTimeZoneInformation:
        case SystemCurrentTimeZoneInformation:
            return handle_query<SYSTEM_TIMEZONE_INFORMATION>(
                c.emu, system_information, system_information_length, return_length, [&](SYSTEM_TIMEZONE_INFORMATION& tzi) {
                    memset(&tzi, 0, sizeof(tzi));

                    tzi.Bias = -60;
                    tzi.StandardBias = 0;
                    tzi.DaylightBias = -60;

                    constexpr std::u16string_view std_name{u"W. Europe Standard Time"};
                    memcpy(&tzi.StandardName.arr[0], std_name.data(), std_name.size() * sizeof(char16_t));

                    constexpr std::u16string_view dlt_name{u"W. Europe Daylight Time"};
                    memcpy(&tzi.DaylightName.arr[0], dlt_name.data(), dlt_name.size() * sizeof(char16_t));

                    // Standard Time: Last Sunday in October, 03:00
                    tzi.StandardDate.wMonth = 10;
                    tzi.StandardDate.wDayOfWeek = 0;
                    tzi.StandardDate.wDay = 5;
                    tzi.StandardDate.wHour = 3;
                    tzi.StandardDate.wMinute = 0;
                    tzi.StandardDate.wSecond = 0;
                    tzi.StandardDate.wMilliseconds = 0;

                    // Daylight Time: Last Sunday in March, 02:00
                    tzi.DaylightDate.wMonth = 3;
                    tzi.DaylightDate.wDayOfWeek = 0;
                    tzi.DaylightDate.wDay = 5;
                    tzi.DaylightDate.wHour = 2;
                    tzi.DaylightDate.wMinute = 0;
                    tzi.DaylightDate.wSecond = 0;
                    tzi.DaylightDate.wMilliseconds = 0;
                });

        case SystemDynamicTimeZoneInformation:
            return handle_query<SYSTEM_DYNAMIC_TIMEZONE_INFORMATION>(
                c.emu, system_information, system_information_length, return_length, [&](SYSTEM_DYNAMIC_TIMEZONE_INFORMATION& dtzi) {
                    memset(&dtzi, 0, sizeof(dtzi));

                    dtzi.Bias = -60;
                    dtzi.StandardBias = 0;
                    dtzi.DaylightBias = -60;

                    constexpr std::u16string_view std_name{u"W. Europe Standard Time"};
                    memcpy(&dtzi.StandardName.arr[0], std_name.data(), std_name.size() * sizeof(char16_t));

                    constexpr std::u16string_view dlt_name{u"W. Europe Daylight Time"};
                    memcpy(&dtzi.DaylightName.arr[0], dlt_name.data(), dlt_name.size() * sizeof(char16_t));

                    constexpr std::u16string_view key_name{u"W. Europe Standard Time"};
                    memcpy(&dtzi.TimeZoneKeyName.arr[0], key_name.data(), key_name.size() * sizeof(char16_t));

                    // Standard Time: Last Sunday in October, 03:00
                    dtzi.StandardDate.wMonth = 10;
                    dtzi.StandardDate.wDayOfWeek = 0;
                    dtzi.StandardDate.wDay = 5;
                    dtzi.StandardDate.wHour = 3;
                    dtzi.StandardDate.wMinute = 0;
                    dtzi.StandardDate.wSecond = 0;
                    dtzi.StandardDate.wMilliseconds = 0;

                    // Daylight Time: Last Sunday in March, 02:00
                    dtzi.DaylightDate.wMonth = 3;
                    dtzi.DaylightDate.wDayOfWeek = 0;
                    dtzi.DaylightDate.wDay = 5;
                    dtzi.DaylightDate.wHour = 2;
                    dtzi.DaylightDate.wMinute = 0;
                    dtzi.DaylightDate.wSecond = 0;
                    dtzi.DaylightDate.wMilliseconds = 0;

                    dtzi.DynamicDaylightTimeDisabled = FALSE;
                });

        case SystemRangeStartInformation:
            return handle_query<SYSTEM_RANGE_START_INFORMATION64>(c.emu, system_information, system_information_length, return_length,
                                                                  [&](SYSTEM_RANGE_START_INFORMATION64& info) {
                                                                      info.SystemRangeStart = 0xFFFF800000000000; //
                                                                  });

        case SystemProcessorInformation:
        case SystemEmulationProcessorInformation:
            return handle_query<SYSTEM_PROCESSOR_INFORMATION64>(
                c.emu, system_information, system_information_length, return_length, [&](SYSTEM_PROCESSOR_INFORMATION64& info) {
                    memset(&info, 0, sizeof(info));
                    info.MaximumProcessors = 2;
                    info.ProcessorArchitecture =
                        (info_class == SystemProcessorInformation ? PROCESSOR_ARCHITECTURE_AMD64 : PROCESSOR_ARCHITECTURE_INTEL);
                });

        case SystemNumaProcessorMap:
            return handle_query<SYSTEM_NUMA_INFORMATION64>(c.emu, system_information, system_information_length, return_length,
                                                           [&](SYSTEM_NUMA_INFORMATION64& info) {
                                                               memset(&info, 0, sizeof(info));
                                                               info.ActiveProcessorsGroupAffinity->Mask = 0xFFF;
                                                               info.AvailableMemory[0] = 0xFFF;
                                                               info.Pad[0] = 0xFFF;
                                                           });

        case SystemErrorPortTimeouts:
            return handle_query<SYSTEM_ERROR_PORT_TIMEOUTS>(c.emu, system_information, system_information_length, return_length,
                                                            [&](SYSTEM_ERROR_PORT_TIMEOUTS& info) {
                                                                info.StartTimeout = 0;
                                                                info.CommTimeout = 0;
                                                            });

        case SystemKernelDebuggerInformation:
            return handle_query<SYSTEM_KERNEL_DEBUGGER_INFORMATION>(c.emu, system_information, system_information_length, return_length,
                                                                    [&](SYSTEM_KERNEL_DEBUGGER_INFORMATION& info) {
                                                                        info.KernelDebuggerEnabled = FALSE;
                                                                        info.KernelDebuggerNotPresent = TRUE;
                                                                    });

        case SystemLogicalProcessorAndGroupInformation:
            return handle_logical_processor_and_group_information(c, input_buffer, input_buffer_length, system_information,
                                                                  system_information_length, return_length);

        case SystemLogicalProcessorInformation: {
            if (!input_buffer || input_buffer_length != sizeof(USHORT))
            {
                return STATUS_INVALID_PARAMETER;
            }

            using info_type = EMU_SYSTEM_LOGICAL_PROCESSOR_INFORMATION<EmulatorTraits<Emu64>>;

            const auto processor_group = c.emu.read_memory<USHORT>(input_buffer);

            return handle_query<info_type>(c.emu, system_information, system_information_length, return_length, [&](info_type& info) {
                info.Relationship = RelationProcessorCore;

                if (processor_group == 0)
                {
                    using mask_type = decltype(info.ProcessorMask);
                    const auto active_processor_count = c.proc.kusd.get().ActiveProcessorCount;
                    info.ProcessorMask = (static_cast<mask_type>(1) << active_processor_count) - 1;
                }
            });
        }

        case SystemBasicInformation:
        case SystemEmulationBasicInformation:
            return handle_query<SYSTEM_BASIC_INFORMATION64>(c.emu, system_information, system_information_length, return_length,
                                                            [&](SYSTEM_BASIC_INFORMATION64& basic_info) {
                                                                basic_info.Reserved = 0;
                                                                basic_info.TimerResolution = 0x0002625a;
                                                                basic_info.PageSize = 0x1000;
                                                                basic_info.LowestPhysicalPageNumber = 0x00000001;
                                                                basic_info.HighestPhysicalPageNumber = 0x00c9c7ff;
                                                                basic_info.AllocationGranularity = ALLOCATION_GRANULARITY;
                                                                basic_info.MinimumUserModeAddress = MIN_ALLOCATION_ADDRESS;
                                                                basic_info.MaximumUserModeAddress = MAX_ALLOCATION_ADDRESS;
                                                                basic_info.ActiveProcessorsAffinityMask = 0x0000000000000f;
                                                                basic_info.NumberOfProcessors = 4;
                                                            });

        default:
            c.win_emu.log.error("Unsupported system info class: %X\n", info_class);
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }
    }

    NTSTATUS handle_NtQuerySystemInformation(const syscall_context& c, const uint32_t info_class, const uint64_t system_information,
                                             const uint32_t system_information_length, const emulator_object<uint32_t> return_length)
    {
        return handle_NtQuerySystemInformationEx(c, info_class, 0, 0, system_information, system_information_length, return_length);
    }

    NTSTATUS handle_NtSetSystemInformation()
    {
        return STATUS_NOT_SUPPORTED;
    }
}

```

`src/windows-emulator/syscalls/thread.cpp`:

```cpp
#include "../std_include.hpp"
#include "../cpu_context.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

#include <utils/finally.hpp>

namespace
{
    struct wow64_callback_context
    {
        std::array<std::byte, 0x108> reserved0{};
        uint64_t output_pointer{};
        uint32_t output_length{};
        uint32_t status{};
        std::array<std::byte, 0x28> reserved1{};
    };
    static_assert(offsetof(wow64_callback_context, output_pointer) == 0x108);
    static_assert(offsetof(wow64_callback_context, output_length) == 0x110);
    static_assert(offsetof(wow64_callback_context, status) == 0x114);
    static_assert(sizeof(wow64_callback_context) == 0x140);

    void apply_pending_wow64_callback_postprocess(const syscall_context& c)
    {
        auto* thread = c.proc.active_thread;
        if (!thread || !thread->win32k_pending_wow64_callback.has_value())
        {
            return;
        }

        const auto postprocess = thread->win32k_pending_wow64_callback->postprocess;
        thread->win32k_pending_wow64_callback.reset();

        if (postprocess != wow64_callback_postprocess::bool_result_to_status)
        {
            return;
        }

        if (thread->win32k_callback_buffer == 0)
        {
            return;
        }

        wow64_callback_context callback_context{};
        if (!c.win_emu.memory.try_read_memory(thread->win32k_callback_buffer, &callback_context, sizeof(callback_context)))
        {
            return;
        }

        if (!NT_SUCCESS(static_cast<NTSTATUS>(callback_context.status)) || callback_context.output_pointer == 0 ||
            callback_context.output_length < sizeof(uint32_t))
        {
            return;
        }

        uint32_t callback_result{};
        if (!c.win_emu.memory.try_read_memory(callback_context.output_pointer, &callback_result, sizeof(callback_result)))
        {
            return;
        }

        callback_context.status = callback_result;
        c.win_emu.memory.try_write_memory(thread->win32k_callback_buffer + offsetof(wow64_callback_context, status),
                                          &callback_context.status, sizeof(callback_context.status));
    }
}

namespace syscalls
{
    NTSTATUS handle_NtSetInformationThread(const syscall_context& c, const handle thread_handle, const THREADINFOCLASS info_class,
                                           const uint64_t thread_information, const uint32_t thread_information_length)
    {
        auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (info_class == ThreadWow64Context)
        {
            // ThreadWow64Context is only valid for WOW64 processes
            if (!c.proc.is_wow64_process)
            {
                return STATUS_NOT_SUPPORTED;
            }

            if (thread_information_length != sizeof(WOW64_CONTEXT))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            // Check if thread has persistent WOW64 context
            if (!thread->wow64_cpu_reserved.has_value())
            {
                c.win_emu.log.print(color::red, "Error: WOW64 saved context not initialized for thread %d\n", thread->id);
                return STATUS_INTERNAL_ERROR;
            }

            const emulator_object<WOW64_CONTEXT> context_obj{c.emu, thread_information};
            const auto new_wow64_context = context_obj.read();

            // Update the persistent context for future queries
            thread->wow64_cpu_reserved->access([&](WOW64_CPURESERVED& ctx) {
                ctx.Flags |= WOW64_CPURESERVED_FLAG_RESET_STATE;
                ctx.Context = new_wow64_context;
                // c.win_emu.callbacks.on_suspicious_activity("WOW64 CONTEXT");
            });

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadSchedulerSharedDataSlot || info_class == ThreadBasePriority || info_class == ThreadAffinityMask ||
            info_class == ThreadPriorityBoost)
        {
            return STATUS_SUCCESS;
        }

        if (info_class == ThreadHideFromDebugger)
        {
            BOOLEAN hide = true;

            if (thread_information != 0 && thread_information % 4 != 0)
            {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            if (thread_information_length == 0 || thread_information_length == sizeof(hide))
            {
                if (thread_information_length == sizeof(hide))
                {
                    if (thread_information == 0 || !c.win_emu.memory.try_read_memory(thread_information, &hide, sizeof(hide)))
                    {
                        return STATUS_INTERNAL_ERROR;
                    }
                }

                c.win_emu.current_thread().debugger_hide = hide;
                c.win_emu.callbacks.on_suspicious_activity("Hiding thread from debugger");
                return STATUS_SUCCESS;
            }

            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (info_class == ThreadNameInformation)
        {
            if (thread_information_length != sizeof(THREAD_NAME_INFORMATION<EmulatorTraits<Emu64>>))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<THREAD_NAME_INFORMATION<EmulatorTraits<Emu64>>> info{c.emu, thread_information};
            const auto i = info.read();
            thread->name = read_unicode_string(c.emu, i.ThreadName);

            c.win_emu.callbacks.on_thread_set_name(*thread);

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadImpersonationToken)
        {
            if (thread_information_length != sizeof(handle))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<handle> info{c.emu, thread_information};
            info.write(DUMMY_IMPERSONATION_TOKEN);

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadZeroTlsCell)
        {
            if (thread_information_length != sizeof(ULONG))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto tls_cell = c.emu.read_memory<ULONG>(thread_information);

            for (const auto& t : c.proc.threads | std::views::values)
            {
                if (tls_cell < TLS_MINIMUM_AVAILABLE)
                {
                    if (c.proc.is_wow64_process)
                    {
                        if (t.teb32.has_value())
                        {
                            t.teb32->access([&](TEB32& teb32) { teb32.TlsSlots.arr[tls_cell] = 0; });
                        }
                    }
                    else
                    {
                        t.teb64->access([&](TEB64& teb64) { teb64.TlsSlots.arr[tls_cell] = 0; });
                    }
                }
                else if (tls_cell < TLS_MINIMUM_AVAILABLE + TLS_EXPANSION_SLOTS)
                {
                    if (c.proc.is_wow64_process)
                    {
                        if (t.teb32.has_value())
                        {
                            t.teb32->access([&](TEB32& teb32) {
                                if (teb32.TlsExpansionSlots)
                                {
                                    c.emu.write_memory<uint32_t>(teb32.TlsExpansionSlots + (4 * tls_cell) - TLS_MINIMUM_AVAILABLE, 0);
                                }
                            });
                        }
                    }
                    else
                    {
                        t.teb64->access([&](TEB64& teb64) {
                            if (teb64.TlsExpansionSlots)
                            {
                                c.emu.write_memory<uint64_t>(teb64.TlsExpansionSlots + (8 * tls_cell) - TLS_MINIMUM_AVAILABLE, 0);
                            }
                        });
                    }
                }
            }

            return STATUS_SUCCESS;
        }

        c.win_emu.log.error("Unsupported thread set info class: %X\n", info_class);
        c.emu.stop();
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQueryInformationThread(const syscall_context& c, const handle thread_handle, const uint32_t info_class,
                                             const uint64_t thread_information, const uint32_t thread_information_length,
                                             const emulator_object<uint32_t> return_length)
    {
        const auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        emulator_thread& cur_emulator_thread = c.win_emu.current_thread();

        if (info_class == ThreadWow64Context)
        {
            // ThreadWow64Context is only valid for WOW64 processes
            if (!c.proc.is_wow64_process)
            {
                return STATUS_NOT_SUPPORTED;
            }

            if (return_length)
            {
                return_length.write(sizeof(WOW64_CONTEXT));
            }

            if (thread_information_length < sizeof(WOW64_CONTEXT))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<WOW64_CONTEXT> context_obj{c.emu, thread_information};

            // Check if thread has persistent WOW64 context
            if (!thread->wow64_cpu_reserved.has_value())
            {
                c.win_emu.log.print(color::red, "Error: WOW64 saved context not initialized for thread %d\n", thread->id);
                return STATUS_INTERNAL_ERROR;
            }

            // Return the saved context (which was set by NtSetInformationThread)
            thread->wow64_cpu_reserved->access([&](const WOW64_CPURESERVED& ctx) {
                const auto wow64_context = ctx.Context;
                context_obj.write(wow64_context);
            });

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadTebInformation)
        {
            if (return_length)
            {
                return_length.write(sizeof(THREAD_TEB_INFORMATION));
            }

            if (thread_information_length < sizeof(THREAD_TEB_INFORMATION))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const auto teb_info = c.emu.read_memory<THREAD_TEB_INFORMATION>(thread_information);
            const auto data = c.emu.read_memory(thread->teb64->value() + teb_info.TebOffset, teb_info.BytesToRead);
            c.emu.write_memory(teb_info.TebInformation, data.data(), data.size());

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadBasicInformation)
        {
            if (return_length)
            {
                return_length.write(sizeof(THREAD_BASIC_INFORMATION64));
            }

            if (thread_information_length < sizeof(THREAD_BASIC_INFORMATION64))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<THREAD_BASIC_INFORMATION64> info{c.emu, thread_information};
            info.access([&](THREAD_BASIC_INFORMATION64& i) {
                i.TebBaseAddress = thread->teb64->value();
                i.ClientId = thread->teb64->read().ClientId;
            });

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadAmILastThread)
        {
            if (return_length)
            {
                return_length.write(sizeof(ULONG));
            }

            if (thread_information_length < sizeof(ULONG))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<ULONG> info{c.emu, thread_information};
            info.write(c.proc.threads.size() <= 1);

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadQuerySetWin32StartAddress)
        {
            if (return_length)
            {
                return_length.write(sizeof(EmulatorTraits<Emu64>::PVOID));
            }

            if (thread_information_length < sizeof(EmulatorTraits<Emu64>::PVOID))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<EmulatorTraits<Emu64>::PVOID> info{c.emu, thread_information};
            info.write(thread->start_address);

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadPerformanceCount)
        {
            if (return_length)
            {
                return_length.write(sizeof(LARGE_INTEGER));
            }

            if (thread_information_length < sizeof(LARGE_INTEGER))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<LARGE_INTEGER> info{c.emu, thread_information};
            info.write({});

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadHideFromDebugger)
        {
            if (thread_information != 0 && thread_information % 4 != 0)
            {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            if (thread_information_length != sizeof(BOOLEAN))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (return_length)
            {
                return_length.try_write(sizeof(BOOLEAN));
            }

            const emulator_object<BOOLEAN> info{c.emu, thread_information};
            info.try_write(cur_emulator_thread.debugger_hide);

            c.win_emu.callbacks.on_suspicious_activity("Checking if the thread is hidden from the debugger");

            return STATUS_SUCCESS;
        }

        if (info_class == ThreadTimes)
        {
            if (return_length)
            {
                return_length.write(sizeof(KERNEL_USER_TIMES));
            }

            if (thread_information_length != sizeof(KERNEL_USER_TIMES))
            {
                return STATUS_BUFFER_OVERFLOW;
            }

            const emulator_object<KERNEL_USER_TIMES> info{c.emu, thread_information};
            info.write(KERNEL_USER_TIMES{});

            return STATUS_SUCCESS;
        }

        c.win_emu.log.error("Unsupported thread query info class: %X\n", info_class);
        c.emu.stop();

        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtOpenThread(const syscall_context& c, const emulator_object<handle> thread_handle, ACCESS_MASK /*desired_access*/,
                                 emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> /*object_attributes*/,
                                 emulator_object<CLIENT_ID64> client_id)
    {
        if (!client_id)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto id = client_id.read();

        for (auto& [h_val, t] : c.proc.threads)
        {
            if (t.id == id.UniqueThread)
            {
                thread_handle.write(c.proc.threads.make_handle(h_val));
                return STATUS_SUCCESS;
            }
        }

        return STATUS_INVALID_CID;
    }

    NTSTATUS handle_NtOpenThreadToken(const syscall_context&, const handle thread_handle, const ACCESS_MASK /*desired_access*/,
                                      const BOOLEAN /*open_as_self*/, const emulator_object<handle> token_handle)
    {
        if (thread_handle != CURRENT_THREAD)
        {
            return STATUS_NOT_SUPPORTED;
        }

        token_handle.write(CURRENT_THREAD_TOKEN);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtOpenThreadTokenEx(const syscall_context& c, const handle thread_handle, const ACCESS_MASK desired_access,
                                        const BOOLEAN open_as_self, const ULONG /*handle_attributes*/,
                                        const emulator_object<handle> token_handle)
    {
        return handle_NtOpenThreadToken(c, thread_handle, desired_access, open_as_self, token_handle);
    }

    static void delete_thread_windows(const syscall_context& c, const uint32_t thread_id)
    {
        for (auto i = c.proc.windows.begin(); i != c.proc.windows.end();)
        {
            if (i->second.thread_id != thread_id)
            {
                ++i;
                continue;
            }

            i->second.ref_count = 1;
            i = c.proc.windows.erase(i).first;
        }
    }

    NTSTATUS handle_NtTerminateThread(const syscall_context& c, const handle thread_handle, const NTSTATUS exit_status)
    {
        auto* thread = !thread_handle.bits ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        thread->exit_status = exit_status;
        c.win_emu.callbacks.on_thread_terminated(thread_handle, *thread);

        delete_thread_windows(c, thread->id);

        if (thread == c.proc.active_thread)
        {
            c.win_emu.yield_thread();
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtDelayExecution(const syscall_context& c, const BOOLEAN alertable, const emulator_object<LARGE_INTEGER> delay_interval)
    {
        auto& t = c.win_emu.current_thread();
        if (delay_interval.value())
        {
            t.await_time = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), delay_interval.read());
        }
        c.win_emu.yield_thread(alertable);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtAlertThreadByThreadId(const syscall_context& c, const uint64_t thread_id)
    {
        for (auto& t : c.proc.threads | std::views::values)
        {
            if (t.id == thread_id)
            {
                t.alerted = true;
                return STATUS_SUCCESS;
            }
        }

        return STATUS_INVALID_HANDLE;
    }

    NTSTATUS handle_NtAlertThreadByThreadIdEx(const syscall_context& c, const uint64_t thread_id,
                                              const emulator_object<EMU_RTL_SRWLOCK<EmulatorTraits<Emu64>>> /*lock*/)
    {
        // TODO: Support lock
        /*if (lock.value())
        {
             c.win_emu.log.warn("NtAlertThreadByThreadIdEx with lock not supported yet!\n");
            //  c.emu.stop();
            //  return STATUS_NOT_SUPPORTED;
        }*/

        return handle_NtAlertThreadByThreadId(c, thread_id);
    }

    NTSTATUS handle_NtWaitForAlertByThreadId(const syscall_context& c, const uint64_t, const emulator_object<LARGE_INTEGER> timeout)
    {
        auto& t = c.win_emu.current_thread();
        t.waiting_for_alert = true;

        if (timeout.value() && !t.await_time.has_value())
        {
            t.await_time = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout.read());
        }

        c.win_emu.yield_thread();

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtYieldExecution(const syscall_context& c)
    {
        c.win_emu.yield_thread();
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSuspendThread(const syscall_context& c, const handle thread_handle,
                                    const emulator_object<ULONG> previous_suspend_count)
    {
        auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto old_count = thread->suspended;
        if (previous_suspend_count)
        {
            previous_suspend_count.write(old_count);
        }

        if (thread->suspended >= 0x7F) // MAXIMUM_SUSPEND_COUNT
        {
            return STATUS_SUSPEND_COUNT_EXCEEDED;
        }

        thread->suspended += 1;

        if (thread == c.proc.active_thread)
        {
            c.win_emu.yield_thread();
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtResumeThread(const syscall_context& c, const handle thread_handle,
                                   const emulator_object<ULONG> previous_suspend_count)
    {
        auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);
        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto old_count = thread->suspended;
        if (previous_suspend_count)
        {
            previous_suspend_count.write(old_count);
        }

        if (old_count > 0)
        {
            thread->suspended -= 1;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtContinueEx(const syscall_context& c, const emulator_object<CONTEXT64> thread_context,
                                 const uint64_t continue_argument)
    {
        c.write_status = false;

        KCONTINUE_ARGUMENT argument{};
        if (continue_argument <= 0xFF)
        {
            argument.ContinueFlags = KCONTINUE_FLAG_TEST_ALERT;
        }
        else
        {
            argument = c.emu.read_memory<KCONTINUE_ARGUMENT>(continue_argument);
        }

        apply_pending_wow64_callback_postprocess(c);
        const auto context = thread_context.read();
        cpu_context::restore(c.emu, context);

        if (argument.ContinueFlags & KCONTINUE_FLAG_TEST_ALERT)
        {
            c.win_emu.yield_thread(true);
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtContinue(const syscall_context& c, const emulator_object<CONTEXT64> thread_context, const BOOLEAN raise_alert)
    {
        return handle_NtContinueEx(c, thread_context, raise_alert ? 1 : 0);
    }

    NTSTATUS handle_NtGetNextThread(const syscall_context& c, const handle process_handle, const handle thread_handle,
                                    const ACCESS_MASK /*desired_access*/, const ULONG /*handle_attributes*/, const ULONG flags,
                                    const emulator_object<handle> new_thread_handle)
    {
        if (process_handle != CURRENT_PROCESS || thread_handle.value.type != handle_types::thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (flags != 0)
        {
            c.win_emu.log.error("NtGetNextThread flags %X not supported\n", static_cast<uint32_t>(flags));
            c.emu.stop();
            return STATUS_NOT_SUPPORTED;
        }

        bool return_next_thread = thread_handle == NULL_HANDLE;
        for (auto& t : c.proc.threads)
        {
            if (return_next_thread && !t.second.is_terminated())
            {
                ++t.second.ref_count;
                new_thread_handle.write(c.proc.threads.make_handle(t.first));
                return STATUS_SUCCESS;
            }

            if (t.first == thread_handle.value.id)
            {
                return_next_thread = true;
            }
        }

        new_thread_handle.write(NULL_HANDLE);
        return STATUS_NO_MORE_ENTRIES;
    }

    NTSTATUS handle_NtGetContextThread(const syscall_context& c, const handle thread_handle,
                                       const emulator_object<CONTEXT64> thread_context)
    {
        const auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        c.proc.active_thread->save(c.emu);
        const auto _ = utils::finally([&] {
            c.proc.active_thread->restore(c.emu); //
        });

        thread->restore(c.emu);

        thread_context.access([&](CONTEXT64& context) {
            if ((context.ContextFlags & CONTEXT_DEBUG_REGISTERS_64) == CONTEXT_DEBUG_REGISTERS_64)
            {
                c.win_emu.callbacks.on_suspicious_activity("Reading debug registers");
            }

            cpu_context::save(c.emu, context);
        });

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetContextThread(const syscall_context& c, const handle thread_handle,
                                       const emulator_object<CONTEXT64> thread_context)
    {
        const auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto needs_swich = thread != c.proc.active_thread;

        if (needs_swich)
        {
            c.proc.active_thread->save(c.emu);
            thread->restore(c.emu);
        }

        const auto _ = utils::finally([&] {
            if (needs_swich)
            {
                c.proc.active_thread->restore(c.emu); //
            }
        });

        const auto context = thread_context.read();
        cpu_context::restore(c.emu, context);

        if ((context.ContextFlags & CONTEXT_DEBUG_REGISTERS_64) == CONTEXT_DEBUG_REGISTERS_64)
        {
            c.win_emu.callbacks.on_suspicious_activity("Setting debug registers");
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCreateThreadEx(const syscall_context& c, const emulator_object<handle> thread_handle,
                                     const ACCESS_MASK /*desired_access*/,
                                     const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>>
                                     /*object_attributes*/,
                                     const handle process_handle, const uint64_t start_routine, const uint64_t argument,
                                     const ULONG create_flags, const EmulatorTraits<Emu64>::SIZE_T /*zero_bits*/,
                                     const EmulatorTraits<Emu64>::SIZE_T stack_size, const EmulatorTraits<Emu64>::SIZE_T maximum_stack_size,
                                     const emulator_object<PS_ATTRIBUTE_LIST<EmulatorTraits<Emu64>>> attribute_list)
    {
        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (stack_size > maximum_stack_size)
        {
            return STATUS_INVALID_PARAMETER;
        }

        uint64_t actual_stack_size = maximum_stack_size;
        if (maximum_stack_size == 0)
        {
            actual_stack_size = c.win_emu.mod_manager.executable->size_of_stack_reserve;
        }

        const auto h = c.proc.create_thread(c.win_emu.memory, start_routine, argument, actual_stack_size, create_flags);
        thread_handle.write(h);

        if (!attribute_list)
        {
            return STATUS_SUCCESS;
        }

        const auto* thread = c.proc.threads.get(h);

        const emulator_object<PS_ATTRIBUTE<EmulatorTraits<Emu64>>> attributes{
            c.emu, attribute_list.value() + offsetof(PS_ATTRIBUTE_LIST<EmulatorTraits<Emu64>>, Attributes)};

        const auto total_length = attribute_list.read().TotalLength;

        constexpr auto entry_size = sizeof(PS_ATTRIBUTE<EmulatorTraits<Emu64>>);
        constexpr auto header_size = sizeof(PS_ATTRIBUTE_LIST<EmulatorTraits<Emu64>>) - entry_size;
        const auto attribute_count = (total_length - header_size) / entry_size;

        for (size_t i = 0; i < attribute_count; ++i)
        {
            attributes.access(
                [&](const PS_ATTRIBUTE<EmulatorTraits<Emu64>>& attribute) {
                    const auto type = attribute.Attribute & ~PS_ATTRIBUTE_THREAD;

                    if (type == PsAttributeClientId)
                    {
                        const auto client_id = thread->teb64->read().ClientId;
                        write_attribute(c.emu, attribute, client_id);
                    }
                    else if (type == PsAttributeTebAddress)
                    {
                        write_attribute(c.emu, attribute, thread->teb64->value());
                    }
                    else
                    {
                        c.win_emu.log.error("Unsupported thread attribute type: %" PRIx64 "\n", type);
                    }
                },
                i);
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtGetCurrentProcessorNumberEx(const syscall_context&, const emulator_object<PROCESSOR_NUMBER> processor_number)
    {
        constexpr PROCESSOR_NUMBER number{};
        processor_number.write(number);
        return STATUS_SUCCESS;
    }

    ULONG handle_NtGetCurrentProcessorNumber()
    {
        return 0;
    }

    NTSTATUS handle_NtQueueApcThreadEx2(const syscall_context& c, const handle thread_handle, const handle /*reserve_handle*/,
                                        const uint32_t apc_flags, const uint64_t apc_routine, const uint64_t apc_argument1,
                                        const uint64_t apc_argument2, const uint64_t apc_argument3)
    {
        auto* thread = thread_handle == CURRENT_THREAD ? c.proc.active_thread : c.proc.threads.get(thread_handle);

        if (!thread)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (apc_flags)
        {
            c.win_emu.log.warn("Unsupported APC flags: %X\n", apc_flags);
            // c.emu.stop();
            // return STATUS_NOT_SUPPORTED;
        }

        thread->pending_apcs.push_back({
            .flags = apc_flags,
            .apc_routine = apc_routine,
            .apc_argument1 = apc_argument1,
            .apc_argument2 = apc_argument2,
            .apc_argument3 = apc_argument3,
        });

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueueApcThreadEx(const syscall_context& c, const handle thread_handle, const handle reserve_handle,
                                       const uint64_t apc_routine, const uint64_t apc_argument1, const uint64_t apc_argument2,
                                       const uint64_t apc_argument3)
    {
        uint32_t flags{0};
        auto real_reserve_handle = reserve_handle;
        if (reserve_handle.bits == QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC)
        {
            real_reserve_handle.bits = 0;
            flags = QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC;
            static_assert(QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC == 1);
        }

        return handle_NtQueueApcThreadEx2(c, thread_handle, real_reserve_handle, flags, apc_routine, apc_argument1, apc_argument2,
                                          apc_argument3);
    }

    NTSTATUS handle_NtQueueApcThread(const syscall_context& c, const handle thread_handle, const uint64_t apc_routine,
                                     const uint64_t apc_argument1, const uint64_t apc_argument2, const uint64_t apc_argument3)
    {
        return handle_NtQueueApcThreadEx(c, thread_handle, make_handle(0), apc_routine, apc_argument1, apc_argument2, apc_argument3);
    }

    NTSTATUS handle_NtCallbackReturn(const syscall_context& c, const emulator_pointer callback_result_ptr,
                                     const ULONG callback_result_length, const NTSTATUS /*callback_status*/)
    {
        auto& t = c.win_emu.current_thread();

        if (t.callback_stack.empty())
        {
            throw std::runtime_error("Unexpected callback return");
        }

        uint64_t callback_result = t.callback_return_rax.value_or(c.emu.reg<uint64_t>(x86_register::rax));
        t.callback_return_rax.reset();

        if (callback_result_ptr != 0 && callback_result_length != 0 && callback_result_length <= sizeof(callback_result))
        {
            std::array<std::byte, sizeof(callback_result)> result_bytes{};
            if (c.win_emu.memory.try_read_memory(callback_result_ptr, result_bytes.data(), callback_result_length))
            {
                callback_result = 0;
                memcpy(&callback_result, result_bytes.data(), callback_result_length);
            }
        }

        const auto frame = std::move(t.callback_stack.back());
        t.callback_stack.pop_back();

        frame.restore_registers(c.emu);

        auto dispatch_result = c.win_emu.dispatcher.dispatch_completion(c.win_emu, frame.handler_id, frame.state.get(), callback_result);

        if (dispatch_result != dispatch_result::new_callback)
        {
            // Move past syscall instruction
            const auto new_ip = c.emu.read_instruction_pointer();
            c.emu.reg(x86_register::rip, new_ip + 2);
        }

        c.write_status = false;
        return {};
    }
}

```

`src/windows-emulator/syscalls/timer.cpp`:

```cpp
#include "../std_include.hpp"
#include "../syscall_dispatcher.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    NTSTATUS handle_NtQueryTimerResolution(const syscall_context&, const emulator_object<ULONG> maximum_time,
                                           const emulator_object<ULONG> minimum_time, const emulator_object<ULONG> current_time)
    {
        maximum_time.write_if_valid(0x0002625a);
        minimum_time.write_if_valid(0x00001388);
        current_time.write_if_valid(0x00002710);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetTimerResolution(const syscall_context&, const ULONG /*desired_resolution*/, const BOOLEAN set_resolution,
                                         const emulator_object<ULONG> current_resolution)
    {
        if (current_resolution)
        {
            current_resolution.write(0x0002625a);
        }

        if (set_resolution)
        {
            return STATUS_TIMER_RESOLUTION_NOT_SET;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCreateTimer2(const syscall_context& c, const emulator_object<handle> timer_handle, uint64_t /*reserved*/,
                                   const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG /*attributes*/,
                                   ACCESS_MASK /*desired_access*/)
    {
        std::u16string name{};
        if (object_attributes)
        {
            const auto attributes = object_attributes.read();
            if (attributes.ObjectName)
            {
                name = read_unicode_string(c.emu, attributes.ObjectName);
                c.win_emu.callbacks.on_generic_access("Opening timer", name);
            }
        }

        if (!name.empty())
        {
            for (auto& entry : c.proc.timers)
            {
                if (entry.second.name == name)
                {
                    ++entry.second.ref_count;
                    timer_handle.write(c.proc.timers.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        timer t{};
        t.name = std::move(name);

        const auto h = c.proc.timers.store(std::move(t));
        timer_handle.write(h);

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtCreateTimer(const syscall_context& c, const emulator_object<handle> timer_handle, ACCESS_MASK desired_access,
                                  const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes, ULONG timer_type)
    {
        return handle_NtCreateTimer2(c, timer_handle, 0, object_attributes, timer_type, desired_access);
    }

    NTSTATUS handle_NtSetTimer()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetTimer2()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetTimerEx(const syscall_context& /*c*/, handle /*timer_handle*/, uint32_t /*timer_set_info_class*/,
                                 uint64_t /*timer_set_information*/, ULONG /*timer_set_information_length*/)
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtCancelTimer()
    {
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/token.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    TOKEN_TYPE get_token_type(const handle token_handle)
    {
        return token_handle == DUMMY_IMPERSONATION_TOKEN //
                   ? TokenImpersonation
                   : TokenPrimary;
    }

    NTSTATUS handle_NtDuplicateToken(const syscall_context&, const handle existing_token_handle, ACCESS_MASK /*desired_access*/,
                                     const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>>
                                     /*object_attributes*/,
                                     const BOOLEAN /*effective_only*/, const TOKEN_TYPE type,
                                     const emulator_object<handle> new_token_handle)
    {
        if (get_token_type(existing_token_handle) == type)
        {
            new_token_handle.write(existing_token_handle);
        }
        else if (type == TokenPrimary)
        {
            new_token_handle.write(CURRENT_PROCESS_TOKEN);
        }
        else
        {
            new_token_handle.write(DUMMY_IMPERSONATION_TOKEN);
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtQueryInformationToken(const syscall_context& c, const handle token_handle,
                                            const TOKEN_INFORMATION_CLASS token_information_class, const uint64_t token_information,
                                            const ULONG token_information_length, const emulator_object<ULONG> return_length)
    {
        if (token_handle != CURRENT_PROCESS_TOKEN && token_handle != CURRENT_THREAD_TOKEN &&
            token_handle != CURRENT_THREAD_EFFECTIVE_TOKEN && token_handle != DUMMY_IMPERSONATION_TOKEN)
        {
            return STATUS_NOT_SUPPORTED;
        }

        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        const uint8_t sid[] = {
            0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00, 0x84, 0x94,
            0xD4, 0x04, 0x4B, 0x68, 0x42, 0x34, 0x23, 0xBE, 0x69, 0x4E, 0xE9, 0x03, 0x00, 0x00,
        };

        if (token_information_class == TokenAppContainerSid)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (token_information_class == TokenUser)
        {
            constexpr auto required_size = sizeof(TOKEN_USER64) + sizeof(sid);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_USER64 user{};
            user.User.Attributes = 0;
            user.User.Sid = token_information + sizeof(TOKEN_USER64);

            emulator_object<TOKEN_USER64>{c.emu, token_information}.write(user);
            c.emu.write_memory(token_information + sizeof(TOKEN_USER64), sid, sizeof(sid));
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenGroups)
        {
            constexpr auto required_size = sizeof(TOKEN_GROUPS64) + sizeof(sid);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_GROUPS64 groups{};
            groups.GroupCount = 1;
            groups.Groups[0].Attributes = 0;
            groups.Groups[0].Sid = token_information + sizeof(TOKEN_GROUPS64);

            emulator_object<TOKEN_GROUPS64>{c.emu, token_information}.write(groups);
            c.emu.write_memory(token_information + sizeof(TOKEN_GROUPS64), sid, sizeof(sid));
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenOwner)
        {
            constexpr auto required_size = sizeof(sid) + sizeof(TOKEN_OWNER64);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_OWNER64 owner{};
            owner.Owner = token_information + sizeof(TOKEN_OWNER64);

            emulator_object<TOKEN_OWNER64>{c.emu, token_information}.write(owner);
            c.emu.write_memory(token_information + sizeof(TOKEN_OWNER64), sid, sizeof(sid));
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenPrimaryGroup)
        {
            constexpr auto required_size = sizeof(sid) + sizeof(TOKEN_PRIMARY_GROUP64);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_PRIMARY_GROUP64 primary_group{};
            primary_group.PrimaryGroup = token_information + sizeof(TOKEN_PRIMARY_GROUP64);

            emulator_object<TOKEN_PRIMARY_GROUP64>{c.emu, token_information}.write(primary_group);
            c.emu.write_memory(token_information + sizeof(TOKEN_PRIMARY_GROUP64), sid, sizeof(sid));
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenDefaultDacl)
        {
            constexpr auto acl_size = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + sizeof(sid) - sizeof(ULONG);
            constexpr auto required_size = sizeof(TOKEN_DEFAULT_DACL64) + acl_size;
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_DEFAULT_DACL64 default_dacl{};
            default_dacl.DefaultDacl = token_information + sizeof(TOKEN_DEFAULT_DACL64);

            emulator_object<TOKEN_DEFAULT_DACL64>{c.emu, token_information}.write(default_dacl);

            const auto acl_offset = token_information + sizeof(TOKEN_DEFAULT_DACL64);
            ACL acl{};
            acl.AclRevision = 2; // ACL_REVISION
            acl.Sbz1 = 0;
            acl.AclSize = static_cast<USHORT>(acl_size);
            acl.AceCount = 1;
            acl.Sbz2 = 0;

            c.emu.write_memory(acl_offset, acl);

            const auto ace_offset = acl_offset + sizeof(ACL);
            ACCESS_ALLOWED_ACE ace{};
            ace.Header.AceType = 0; // ACCESS_ALLOWED_ACE_TYPE
            ace.Header.AceFlags = 0;
            ace.Header.AceSize = static_cast<USHORT>(sizeof(ACCESS_ALLOWED_ACE) + sizeof(sid) - sizeof(ULONG));
            ace.Mask = GENERIC_ALL;

            c.emu.write_memory(ace_offset, ace);

            const auto sid_offset = ace_offset + sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            c.emu.write_memory(sid_offset, sid, sizeof(sid));

            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenType)
        {
            constexpr auto required_size = sizeof(TOKEN_TYPE);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_object<TOKEN_TYPE>{c.emu, token_information}.write(get_token_type(token_handle));
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenSessionId)
        {
            constexpr auto required_size = sizeof(ULONG);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_object<ULONG>{c.emu, token_information}.write(1);
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenPrivateNameSpace)
        {
            constexpr auto required_size = sizeof(ULONG);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_object<ULONG>{c.emu, token_information}.write(0);
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenUIAccess)
        {
            constexpr auto required_size = sizeof(ULONG);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_object<ULONG>{c.emu, token_information}.write(1);
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenElevation)
        {
            constexpr auto required_size = sizeof(TOKEN_ELEVATION);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            c.emu.write_memory(token_information, TOKEN_ELEVATION{
                                                      .TokenIsElevated = 0,
                                                  });
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenIsAppContainer)
        {
            constexpr auto required_size = sizeof(ULONG);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            emulator_object<ULONG>{c.emu, token_information}.write(0);
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenStatistics)
        {
            constexpr auto required_size = sizeof(TOKEN_STATISTICS);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_STATISTICS stats{};
            stats.TokenType = get_token_type(token_handle);
            stats.ImpersonationLevel = stats.TokenType == TokenImpersonation ? SecurityImpersonation : SecurityAnonymous;
            stats.GroupCount = 1;
            stats.PrivilegeCount = 0;

            c.emu.write_memory(token_information, stats);

            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenSecurityAttributes)
        {
            constexpr auto required_size = sizeof(TOKEN_SECURITY_ATTRIBUTES_INFORMATION);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            c.emu.write_memory(token_information, TOKEN_SECURITY_ATTRIBUTES_INFORMATION{
                                                      .Version = 0,
                                                      .Reserved = {},
                                                      .AttributeCount = 0,
                                                      .Attribute = {},
                                                  });

            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenIntegrityLevel)
        {
            // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
            const uint8_t medium_integrity_sid[] = {
                0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            };

            constexpr auto required_size = sizeof(medium_integrity_sid) + sizeof(TOKEN_MANDATORY_LABEL64);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            TOKEN_MANDATORY_LABEL64 label{};
            label.Label.Attributes = 0x60;
            label.Label.Sid = token_information + sizeof(TOKEN_MANDATORY_LABEL64);

            emulator_object<TOKEN_MANDATORY_LABEL64>{c.emu, token_information}.write(label);
            c.emu.write_memory(token_information + sizeof(TOKEN_MANDATORY_LABEL64), medium_integrity_sid, sizeof(medium_integrity_sid));
            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenProcessTrustLevel)
        {
            constexpr auto required_size = sizeof(TOKEN_PROCESS_TRUST_LEVEL64);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            c.emu.write_memory(token_information, TOKEN_PROCESS_TRUST_LEVEL64{
                                                      .TrustLevelSid = 0,
                                                  });

            return STATUS_SUCCESS;
        }

        if (token_information_class == TokenBnoIsolation)
        {
            constexpr auto required_size = sizeof(TOKEN_BNO_ISOLATION_INFORMATION64);
            return_length.write(required_size);

            if (required_size > token_information_length)
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            c.emu.write_memory(token_information, TOKEN_BNO_ISOLATION_INFORMATION64{
                                                      .IsolationPrefix = 0,
                                                      .IsolationEnabled = FALSE,
                                                  });

            return STATUS_SUCCESS;
        }

        c.win_emu.log.error("Unsupported token info class: %X\n", token_information_class);
        c.emu.stop();
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtQuerySecurityAttributesToken()
    {
        // puts("NtQuerySecurityAttributesToken not supported");
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtAdjustPrivilegesToken()
    {
        // puts("NtQuerySecurityAttributesToken not supported");
        return STATUS_NOT_SUPPORTED;
    }
}

```

`src/windows-emulator/syscalls/trace.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"

namespace syscalls
{
    namespace
    {
        constexpr uint32_t k_trace_control_wow64_bit = 0x80000000u;
        constexpr uint32_t k_trace_control_register_guids = 0x0Fu;
        constexpr uint32_t k_trace_control_add_notification_event = 0x1Bu;
        constexpr uint32_t k_trace_control_set_provider_traits = 0x1Eu;

        NTSTATUS handle_trace_control_add_notification_event(const syscall_context& c, const uint64_t input_buffer,
                                                             const ULONG input_buffer_length, const emulator_object<ULONG> return_length)
        {
            if (return_length)
            {
                return_length.write(0);
            }

            if (input_buffer == 0 || input_buffer_length != sizeof(uint32_t))
            {
                return STATUS_INVALID_PARAMETER;
            }

            const auto raw_event_handle = c.emu.read_memory<uint32_t>(input_buffer);

            handle event_handle{};
            event_handle.bits = raw_event_handle;

            if (!c.proc.events.get(event_handle))
            {
                return STATUS_INVALID_HANDLE;
            }

            if (c.proc.etw_notification_event)
            {
                return STATUS_UNSUCCESSFUL;
            }

            const auto held_handle = c.proc.events.duplicate(event_handle);
            if (!held_handle)
            {
                return STATUS_INVALID_HANDLE;
            }

            c.proc.etw_notification_event = *held_handle;
            return STATUS_SUCCESS;
        }

        NTSTATUS handle_trace_control_passthrough(const uint64_t output_buffer, const ULONG output_buffer_length,
                                                  const emulator_object<ULONG> return_length)
        {
            if (output_buffer_length != 0 && output_buffer == 0)
            {
                return STATUS_INVALID_PARAMETER;
            }

            if (return_length)
            {
                return_length.write(output_buffer_length);
            }

            return STATUS_SUCCESS;
        }
    }

    NTSTATUS handle_NtTraceControl(const syscall_context& c, const ULONG function_code, const uint64_t input_buffer,
                                   const ULONG input_buffer_length, const uint64_t output_buffer, const ULONG output_buffer_length,
                                   const emulator_object<ULONG> return_length)
    {
        const auto base_function_code = function_code & ~k_trace_control_wow64_bit;

        switch (base_function_code)
        {
        case k_trace_control_add_notification_event:
            return handle_trace_control_add_notification_event(c, input_buffer, input_buffer_length, return_length);
        case k_trace_control_register_guids:
        case k_trace_control_set_provider_traits:
            return handle_trace_control_passthrough(output_buffer, output_buffer_length, return_length);
        default:
            return STATUS_NOT_SUPPORTED;
        }
    }
}

```

`src/windows-emulator/syscalls/user.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../syscall_utils.hpp"
#include "../win32k_userconnect.hpp"
#include "common/segment_utils.hpp"
#include "windows-emulator/user_callback_dispatch.hpp"
#include <limits>
#include <utils/string.hpp>

namespace
{
    constexpr ULONG k_thread_state_win32_thread_info = 0xE;
    constexpr size_t k_win32_thread_info_slab_size = 0x2000;
    constexpr uint64_t k_win32_thread_info_bias = 0x800;
    // callback id used by wow64.dll!Wow64KiUserCallbackDispatcher
    constexpr uint32_t k_wow64_client_setup_callback_id = 0x54;
    // user32 callback id for ___ClientMonitorEnumProc@4
    constexpr uint32_t k_wow64_enum_display_monitors_callback_id = 0x57;
    constexpr size_t k_wow64_callback_context_buffer_size = 0x140;

    struct wow64_enum_display_monitors_callback_args
    {
        uint32_t monitor{};
        uint32_t dc{};
        RECT rect{};
        uint32_t param{};
        uint32_t callback{};
    };
    static_assert(offsetof(wow64_enum_display_monitors_callback_args, monitor) == 0x0);
    static_assert(offsetof(wow64_enum_display_monitors_callback_args, dc) == 0x4);
    static_assert(offsetof(wow64_enum_display_monitors_callback_args, rect) == 0x8);
    static_assert(offsetof(wow64_enum_display_monitors_callback_args, param) == 0x18);
    static_assert(offsetof(wow64_enum_display_monitors_callback_args, callback) == 0x1C);
    static_assert(sizeof(wow64_enum_display_monitors_callback_args) == 0x20);

    void set_guest_last_error(const syscall_context& c, uint32_t last_error)
    {
        c.proc.active_thread->teb64->access([&](TEB64& teb) {
            teb.LastErrorValue = static_cast<ULONG>(last_error); //
        });
    }

    void set_thread_window_context(const syscall_context& c, const uint64_t active_handle, const uint64_t active_window_ptr)
    {
        if (c.proc.active_thread && c.proc.active_thread->teb64)
        {
            c.proc.active_thread->teb64->access([&](TEB64& teb) {
                teb.Win32ClientInfo.arr[8] = active_handle;
                teb.Win32ClientInfo.arr[9] = active_window_ptr;
            });
        }

        if (c.proc.is_wow64_process && c.proc.active_thread && c.proc.active_thread->teb32)
        {
            uint32_t active_handle32{};
            uint32_t active_window_ptr32{};

            if (active_handle <= std::numeric_limits<uint32_t>::max())
            {
                active_handle32 = static_cast<uint32_t>(active_handle);
            }

            if (active_window_ptr <= std::numeric_limits<uint32_t>::max())
            {
                active_window_ptr32 = static_cast<uint32_t>(active_window_ptr);
            }

            c.proc.active_thread->teb32->access([&](TEB32& teb) {
                teb.Win32ClientInfo[8] = active_handle32;
                teb.Win32ClientInfo[9] = active_window_ptr32;
            });
        }
    }

    void set_thread_window_context(const syscall_context& c, const hwnd hwnd)
    {
        const auto* win = c.proc.windows.get(hwnd);

        uint64_t active_handle{};
        uint64_t active_window_ptr{};

        if (win)
        {
            active_handle = win->handle;
            active_window_ptr = win->guest.value();
        }

        set_thread_window_context(c, active_handle, active_window_ptr);
    }

    void set_user_handle_owner(const syscall_context& c, const handle h, const uint64_t owner)
    {
        if (owner == 0)
        {
            return;
        }

        const auto index = static_cast<uint32_t>(h.value.id);
        if (index == 0 || index >= user_handle_table::MAX_HANDLES)
        {
            return;
        }

        c.proc.user_handles.get_handle_table().access([&](USER_HANDLEENTRY& entry) { entry.pOwner = owner; }, index);
    }

    template <typename T>
    void dispatch_window_message(const syscall_context& c, callback_id id, T&& state, const window& win, uint32_t message,
                                 uint64_t w_param = 0, uint64_t l_param = 0)
    {
        set_thread_window_context(c, win.handle, win.guest.value());

        dispatch_user_callback(c, id, std::forward<T>(state), c.proc.dispatch_client_message, win.guest.value(),
                               static_cast<uint64_t>(message), w_param, l_param, win.wnd_proc);
    }

    template <typename T>
    void dispatch_next_message(const syscall_context& c, callback_id id, T&& state, const window& win, std::vector<qmsg>& message_queue)
    {
        const auto m = message_queue.back();
        message_queue.pop_back();

        dispatch_window_message(c, id, std::forward<T>(state), win, m.message, m.wParam, m.lParam);
    }

    uint64_t ensure_win32_thread_info(const syscall_context& c)
    {
        auto* thread = c.proc.active_thread;
        if (!thread || !thread->teb64)
        {
            return 0;
        }

        if (thread->win32k_thread_info != 0)
        {
            return thread->win32k_thread_info;
        }

        uint64_t thread_info{};
        thread->teb64->access([&](const TEB64& teb) { thread_info = teb.Win32ThreadInfo; });

        if (thread_info != 0)
        {
            thread->win32k_thread_info = thread_info;
            return thread_info;
        }

        const auto slab_base = c.proc.base_allocator.reserve(k_win32_thread_info_slab_size, 0x10);
        std::vector<std::byte> zero_slab(k_win32_thread_info_slab_size);
        c.emu.write_memory(slab_base, zero_slab.data(), zero_slab.size());
        thread->win32k_thread_info = slab_base + k_win32_thread_info_bias;
        return thread->win32k_thread_info;
    }

    void publish_win32_thread_info(const syscall_context& c, const uint64_t thread_info)
    {
        auto* thread = c.proc.active_thread;
        if (!thread || !thread->teb64 || thread_info == 0)
        {
            return;
        }

        const auto low = static_cast<ULONG>(thread_info & 0xFFFFFFFFull);
        const auto high = static_cast<ULONG>((thread_info >> 32) & 0xFFFFFFFFull);

        thread->teb64->access([&](TEB64& teb64) {
            teb64.Win32ThreadInfo = thread_info;
            teb64.User32Reserved.arr[13] = low;
            teb64.User32Reserved.arr[14] = high;
        });

        if (c.proc.is_wow64_process && thread->teb32)
        {
            thread->teb32->access([&](TEB32& teb32) {
                teb32.Win32ThreadInfo = low;
                teb32.User32Reserved[13] = low;
                teb32.User32Reserved[14] = high;
            });
        }
    }

    NTSTATUS ensure_user_shared_info_ptr(const syscall_context& c, uint64_t& user_shared_info_ptr)
    {
        user_shared_info_ptr = 0;

        if (!c.proc.peb32)
        {
            return STATUS_SUCCESS;
        }

        c.proc.peb32->access([&](const PEB32& peb) { user_shared_info_ptr = peb.UserSharedInfoPtr; });

        if (user_shared_info_ptr != 0)
        {
            return STATUS_SUCCESS;
        }

        user_shared_info_ptr = c.proc.base_allocator.reserve(sizeof(WIN32K_USERCONNECT32), alignof(WIN32K_USERCONNECT32));
        std::array<std::byte, sizeof(WIN32K_USERCONNECT32)> zeros{};
        c.emu.write_memory(user_shared_info_ptr, zeros.data(), zeros.size());

        uint32_t user_shared_info_ptr32{};
        const auto narrow_status = win32k_userconnect::narrow_wow64_address(user_shared_info_ptr, user_shared_info_ptr32);
        if (narrow_status != STATUS_SUCCESS)
        {
            return narrow_status;
        }

        c.proc.peb32->access([&](PEB32& peb) { peb.UserSharedInfoPtr = user_shared_info_ptr32; });
        return STATUS_SUCCESS;
    }

    uint64_t resolve_wow64_callback_dispatcher(const syscall_context& c)
    {
        if (c.proc.wow64_ki_user_callback_dispatcher != 0)
        {
            return c.proc.wow64_ki_user_callback_dispatcher;
        }

        for (const auto& [_, mod] : c.win_emu.mod_manager.modules())
        {
            if (!utils::string::equals_ignore_case(std::string_view{mod.name}, std::string_view{"wow64.dll"}))
            {
                continue;
            }

            const auto dispatcher = mod.find_export("Wow64KiUserCallbackDispatcher");
            if (dispatcher != 0)
            {
                c.proc.wow64_ki_user_callback_dispatcher = dispatcher;
                return dispatcher;
            }
        }

        return 0;
    }

    uint64_t ensure_wow64_callback_buffer(const syscall_context& c, emulator_thread& thread)
    {
        if (thread.win32k_callback_buffer != 0)
        {
            return thread.win32k_callback_buffer;
        }

        thread.win32k_callback_buffer = c.proc.base_allocator.reserve(k_wow64_callback_context_buffer_size, 0x10);
        std::array<std::byte, k_wow64_callback_context_buffer_size> zeros{};
        c.emu.write_memory(thread.win32k_callback_buffer, zeros.data(), zeros.size());
        return thread.win32k_callback_buffer;
    }

    bool schedule_wow64_callback(const syscall_context& c, emulator_thread& thread, const uint32_t callback_id, const uint64_t arg_buffer,
                                 const uint32_t arg_length, const std::optional<pending_wow64_callback>& pending_callback = std::nullopt)
    {
        if (!c.proc.is_wow64_process)
        {
            return false;
        }

        thread.win32k_pending_wow64_callback.reset();

        const auto dispatcher = resolve_wow64_callback_dispatcher(c);
        if (dispatcher == 0)
        {
            return false;
        }

        const auto cs_selector = c.emu.reg<uint16_t>(x86_register::cs);
        const auto bitness = segment_utils::get_segment_bitness(c.emu, cs_selector);
        if (!bitness || *bitness != segment_utils::segment_bitness::bit64)
        {
            return false;
        }

        const auto callback_buffer = ensure_wow64_callback_buffer(c, thread);
        std::array<std::byte, k_wow64_callback_context_buffer_size> zeros{};
        c.emu.write_memory(callback_buffer, zeros.data(), zeros.size());

        c.emu.reg(x86_register::rcx, callback_buffer);
        c.emu.reg(x86_register::rdx, static_cast<uint64_t>(callback_id));
        c.emu.reg(x86_register::r8, arg_buffer);
        c.emu.reg(x86_register::r9, static_cast<uint64_t>(arg_length));
        c.emu.reg(x86_register::rip, dispatcher);
        thread.win32k_pending_wow64_callback = pending_callback;
        return true;
    }

    bool schedule_wow64_client_callback(const syscall_context& c, emulator_thread& thread)
    {
        return schedule_wow64_callback(c, thread, k_wow64_client_setup_callback_id, 0, 0);
    }

}

namespace syscalls
{
    hdc handle_NtGdiGetDCforBitmap(const syscall_context& c, handle bitmap);

    NTSTATUS handle_NtUserDisplayConfigGetDeviceInfo()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserRegisterWindowMessage()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserGetThreadState(const syscall_context& c, const ULONG routine)
    {
        if (routine != k_thread_state_win32_thread_info)
        {
            return STATUS_SUCCESS;
        }

        const auto thread_info = ensure_win32_thread_info(c);
        if (thread_info == 0)
        {
            return STATUS_UNSUCCESSFUL;
        }

        publish_win32_thread_info(c, thread_info);

        if (c.proc.is_wow64_process && c.proc.active_thread && !c.proc.active_thread->win32k_thread_setup_done &&
            !c.proc.active_thread->win32k_thread_setup_pending)
        {
            if (!schedule_wow64_client_callback(c, *c.proc.active_thread))
            {
                return STATUS_UNSUCCESSFUL;
            }

            c.proc.active_thread->win32k_thread_setup_pending = true;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserProcessConnect(const syscall_context& c, const handle process_handle, const ULONG length,
                                         const emulator_pointer user_connect)
    {
        if (!c.proc.is_wow64_process)
        {
            return STATUS_NOT_SUPPORTED;
        }

        if (process_handle != CURRENT_PROCESS)
        {
            return STATUS_INVALID_HANDLE;
        }

        uint32_t connect_destination{};
        const auto destination_status = win32k_userconnect::resolve_wow64_destination(user_connect, length, connect_destination);
        if (destination_status != STATUS_SUCCESS)
        {
            return destination_status;
        }

        WIN32K_USERCONNECT32 connect_info{};
        const auto connect_status = win32k_userconnect::build_wow64_userconnect(c.proc, connect_info);
        if (connect_status != STATUS_SUCCESS)
        {
            return connect_status;
        }

        if (!win32k_userconnect::try_write_wow64_userconnect(c.emu, connect_destination, connect_info))
        {
            return STATUS_INVALID_PARAMETER;
        }

        uint64_t user_shared_info_ptr{};
        const auto shared_info_status = ensure_user_shared_info_ptr(c, user_shared_info_ptr);
        if (shared_info_status != STATUS_SUCCESS)
        {
            return shared_info_status;
        }

        if (user_shared_info_ptr != 0)
        {
            if (!win32k_userconnect::try_write_wow64_userconnect(c.emu, user_shared_info_ptr, connect_info))
            {
                return STATUS_INVALID_PARAMETER;
            }
        }

        if (c.proc.active_thread)
        {
            c.proc.active_thread->win32k_thread_setup_pending = false;
            c.proc.active_thread->win32k_thread_setup_done = true;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserInitializeClientPfnArrays(const syscall_context& c, const emulator_pointer apfn_client_a,
                                                    const emulator_pointer apfn_client_w, const emulator_pointer apfn_client_worker,
                                                    const emulator_pointer /*hmod_user*/)
    {
        if (c.proc.active_thread)
        {
            c.proc.active_thread->win32k_thread_setup_pending = false;
            c.proc.active_thread->win32k_thread_setup_done = true;
        }

        if (!win32k_userconnect::try_update_client_pfn_arrays_from_addresses(c.win_emu.memory, c.proc, apfn_client_a, apfn_client_w,
                                                                             apfn_client_worker))
        {
            return STATUS_UNSUCCESSFUL;
        }

        return STATUS_SUCCESS;
    }

    uint64_t handle_NtUserRemoteConnectState(const syscall_context&)
    {
        return 1;
    }

    hdesk handle_NtUserGetThreadDesktop(const syscall_context& c, const ULONG thread_id)
    {
        emulator_thread* target = nullptr;
        if (thread_id == 0 || (c.proc.active_thread && c.proc.active_thread->id == thread_id))
        {
            target = c.proc.active_thread;
        }
        else
        {
            for (auto& [_, thread] : c.proc.threads)
            {
                if (thread.id == thread_id)
                {
                    target = &thread;
                    break;
                }
            }
        }

        if (!target)
        {
            return 0;
        }

        if (target->win32k_desktop.bits == 0)
        {
            if (c.proc.default_desktop.bits == 0)
            {
                desktop desk{};
                desk.name = u"Default";
                c.proc.default_desktop = c.proc.desktops.store(std::move(desk));
            }

            target->win32k_desktop = c.proc.default_desktop;
        }

        return target->win32k_desktop.bits;
    }

    hdc handle_NtUserGetDCEx(const syscall_context& c, const hwnd /*window*/, const uint64_t /*clip_region*/, const ULONG /*flags*/)
    {
        return handle_NtGdiGetDCforBitmap(c, {});
    }

    hdc handle_NtUserGetDC(const syscall_context& c, const hwnd window)
    {
        return handle_NtUserGetDCEx(c, window, 0, 0);
    }

    hdc handle_NtUserGetWindowDC(const syscall_context& c, const hwnd /*window*/)
    {
        return handle_NtGdiGetDCforBitmap(c, {});
    }

    BOOL handle_NtUserReleaseDC()
    {
        return TRUE;
    }

    NTSTATUS handle_NtUserGetCursorPos()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserSetCursor()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserFindExistingCursorIcon()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserFindWindowEx(const syscall_context& c, const hwnd, const hwnd,
                                       const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                       const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> window_name)
    {
        if (c.win_emu.callbacks.on_generic_activity)
        {
            std::string class_name_str = "(null)";
            std::string window_name_str = "(null)";

            if (class_name)
            {
                class_name_str = u16_to_u8(read_unicode_string(c.emu, class_name));
            }

            if (window_name)
            {
                window_name_str = u16_to_u8(read_unicode_string(c.emu, window_name));
            }

            c.win_emu.callbacks.on_generic_activity("Window query for class '" + class_name_str + "' and name '" + window_name_str + "'");
        }

        return 0;
    }

    NTSTATUS handle_NtUserMoveWindow()
    {
        return 0;
    }

    NTSTATUS handle_NtUserGetProcessWindowStation()
    {
        return 0;
    }

    NTSTATUS handle_NtUserRegisterClassExWOW(const syscall_context& c, const emulator_object<EMU_WNDCLASSEX> wnd_class_ex,
                                             const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                             const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> /*class_version*/,
                                             const emulator_object<CLSMENUNAME<EmulatorTraits<Emu64>>> class_menu_name,
                                             const DWORD /*function_id*/, const DWORD /*flags*/, const emulator_pointer /*wow*/)
    {
        if (!wnd_class_ex)
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto class_name_str = read_unicode_string(c.emu, class_name);
        const auto index = c.proc.add_or_find_atom(class_name_str);

        constexpr auto cls_size = static_cast<size_t>(page_align_up(sizeof(USER_CLASS)));
        const auto cls_ptr = c.win_emu.memory.allocate_memory(cls_size, memory_permission::read);

        const auto wnd_class = wnd_class_ex.read();

        c.proc.classes.emplace(class_name_str, process_context::class_entry{cls_ptr, wnd_class, class_menu_name.read()});

        return index;
    }

    NTSTATUS handle_NtUserUnregisterClass(const syscall_context& c, const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                          const emulator_pointer /*instance*/,
                                          const emulator_object<CLSMENUNAME<EmulatorTraits<Emu64>>> class_menu_name)
    {
        const auto cls_name = read_unicode_string(c.emu, class_name);

        if (const auto it = c.proc.classes.find(cls_name); it != c.proc.classes.end())
        {
            if (class_menu_name)
            {
                class_menu_name.write(it->second.menu_name);
            }

            c.win_emu.memory.release_memory(it->second.guest_obj_addr, 0);
            c.proc.classes.erase(it);
        }

        return c.proc.delete_atom(cls_name);
    }

    BOOL handle_NtUserGetClassInfoEx(const syscall_context& c, const hinstance /*instance*/,
                                     const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> class_name,
                                     const emulator_object<EMU_WNDCLASSEX> wnd_class_ex, const emulator_pointer /*menu_name*/,
                                     const BOOL /*ansi*/)
    {
        std::u16string name_str = read_unicode_string(c.emu, class_name);

        auto it = c.proc.classes.find(name_str);
        if (it == c.proc.classes.end())
        {
            return FALSE;
        }

        if (wnd_class_ex)
        {
            wnd_class_ex.write(it->second.wnd_class);
        }

        return TRUE;
    }

    NTSTATUS handle_NtUserSetWindowsHookEx()
    {
        return STATUS_NOT_SUPPORTED;
    }

    NTSTATUS handle_NtUserUnhookWindowsHookEx()
    {
        return STATUS_NOT_SUPPORTED;
    }

    std::u16string read_large_string(const emulator_object<LARGE_STRING> str_obj)
    {
        if (!str_obj)
        {
            return {};
        }

        const auto str = str_obj.read();
        if (!str.bAnsi)
        {
            return read_string<char16_t>(*str_obj.get_memory_interface(), str.Buffer, str.Length / 2);
        }

        const auto ansi_string = read_string<char>(*str_obj.get_memory_interface(), str.Buffer, str.Length);
        return u8_to_u16(ansi_string);
    }

    hwnd handle_NtUserCreateWindowEx(const syscall_context& c, const DWORD ex_style, const emulator_object<LARGE_STRING> class_name,
                                     const emulator_object<LARGE_STRING> /*cls_version*/, const emulator_object<LARGE_STRING> window_name,
                                     const DWORD style, const int x, const int y, const int width, const int height, const hwnd /*parent*/,
                                     const hmenu /*menu*/, const hinstance /*instance*/, const pointer l_param, const DWORD /*flags*/,
                                     const pointer /*acbi_buffer*/)
    {
        const auto cls_name = read_large_string(class_name);
        const auto cls_it = c.proc.classes.find(cls_name);

        if (cls_it == c.proc.classes.end())
        {
            set_guest_last_error(c, 1407); // ERROR_CANNOT_FIND_WND_CLASS
            return 0;
        }

        const auto class_obj_addr = cls_it->second.guest_obj_addr;
        const auto* wnd_class = &cls_it->second.wnd_class;

        auto [handle, win] = c.proc.windows.create(c.win_emu.memory);
        win.ex_style = ex_style;
        win.style = style;
        win.x = x;
        win.y = y;
        win.width = width;
        win.height = height;
        win.thread_id = c.win_emu.current_thread().id;
        win.handle = handle.bits;
        win.class_name = cls_name;
        win.name = read_large_string(window_name);
        win.wnd_proc = wnd_class->lpfnWndProc;

        win.guest.access([&](USER_WINDOW& guest_win) {
            guest_win.hWnd = handle.bits;
            guest_win.ptrBase = win.guest.value();
            guest_win.dwExStyle = ex_style;
            guest_win.dwStyle = style;
            guest_win.lpfnWndProc = win.wnd_proc;
            guest_win.pcls = class_obj_addr;
            guest_win.cbWndExtra = wnd_class->cbWndExtra;

            if (wnd_class->cbWndExtra > 0)
            {
                const auto extra_size = static_cast<size_t>(page_align_up(wnd_class->cbWndExtra));
                guest_win.pExtraBytes = c.win_emu.memory.allocate_memory(extra_size, memory_permission::read);
            }
        });

        const auto thread_info = ensure_win32_thread_info(c);
        publish_win32_thread_info(c, thread_info);
        set_user_handle_owner(c, handle, thread_info);

        window_create_state state{};
        state.handle = handle.bits;

        EMU_CREATESTRUCT cs{};
        cs.lpCreateParams = l_param;
        state.create_struct_alloc = c.emu.push_stack(cs);

        RECT wr{};
        state.window_rect_alloc = c.emu.push_stack(wr);

        EMU_MINMAXINFO mmi{};
        state.min_max_info_alloc = c.emu.push_stack(mmi);

        state.message_queue = {
            {.message = WM_CREATE, .wParam = 0, .lParam = state.create_struct_alloc.address},
            {.message = WM_NCCALCSIZE, .wParam = 0, .lParam = state.window_rect_alloc.address},
            {.message = WM_NCCREATE, .wParam = 0, .lParam = state.create_struct_alloc.address},
            {.message = WM_GETMINMAXINFO, .wParam = 0, .lParam = state.min_max_info_alloc.address},
        };

        if ((style & WS_VISIBLE) != 0)
        {
            EMU_WINDOWPOS wp{};
            wp.hwnd = handle.bits;
            wp.hwndInsertAfter = 0;
            wp.x = x;
            wp.y = y;
            wp.cx = width;
            wp.cy = height;
            wp.flags = SWP_SHOWWINDOW;
            state.window_pos_alloc = c.emu.push_stack(wp);

            const auto move_lparam = static_cast<uint64_t>(((y & 0xFFFF) << 16) | (x & 0xFFFF));
            const auto size_lparam = static_cast<uint64_t>(((height & 0xFFFF) << 16) | (width & 0xFFFF));

            const std::initializer_list<qmsg> sw_messages = {
                {.message = WM_MOVE, .wParam = 0, .lParam = move_lparam},
                {.message = WM_SIZE, .wParam = 0, .lParam = size_lparam},
                {.message = WM_WINDOWPOSCHANGED, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_SETFOCUS, .wParam = 0, .lParam = 0},
                {.message = WM_ACTIVATE, .wParam = 1, .lParam = 0},
                {.message = WM_NCACTIVATE, .wParam = 1, .lParam = 0},
                {.message = WM_WINDOWPOSCHANGING, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_WINDOWPOSCHANGING, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_SHOWWINDOW, .wParam = 1, .lParam = 0},
            };
            state.message_queue.insert(state.message_queue.begin(), sw_messages);
        }

        dispatch_next_message(c, callback_id::NtUserCreateWindowEx, std::move(state), win, state.message_queue);
        return {};
    }

    hwnd completion_NtUserCreateWindowEx(const syscall_context& c, const DWORD /*ex_style*/,
                                         const emulator_object<LARGE_STRING> /*class_name*/,
                                         const emulator_object<LARGE_STRING> /*cls_version*/,
                                         const emulator_object<LARGE_STRING> /*window_name*/, const DWORD /*style*/, const int /*x*/,
                                         const int /*y*/, const int /*width*/, const int /*height*/, const hwnd /*parent*/,
                                         const hmenu /*menu*/, const hinstance /*instance*/, const pointer /*l_param*/,
                                         const DWORD /*flags*/, const pointer /*acbi_buffer*/)
    {
        auto& s = c.get_completion_state<window_create_state>();
        const auto* win = c.proc.windows.get(s.handle);

        if (!s.message_queue.empty())
        {
            dispatch_next_message(c, callback_id::NtUserCreateWindowEx, std::move(s), *win, s.message_queue);
            return {};
        }

        if (s.window_pos_alloc.address != 0)
        {
            c.emu.pop_stack(std::move(s.window_pos_alloc));
        }

        c.emu.pop_stack(std::move(s.min_max_info_alloc));
        c.emu.pop_stack(std::move(s.window_rect_alloc));
        c.emu.pop_stack(std::move(s.create_struct_alloc));

        return s.handle;
    }

    BOOL handle_NtUserDestroyWindow(const syscall_context& c, const hwnd window)
    {
        auto* win = c.proc.windows.get(window);
        if (!win)
        {
            return FALSE;
        }

        if (win->thread_id != c.proc.active_thread->id)
        {
            return FALSE;
        }

        window_destroy_state state{};

        if ((win->style & WS_VISIBLE) != 0)
        {
            EMU_WINDOWPOS wp{};
            wp.hwnd = window;
            wp.hwndInsertAfter = 0;
            wp.x = win->x;
            wp.y = win->y;
            wp.cx = win->width;
            wp.cy = win->height;
            wp.flags = SWP_HIDEWINDOW;
            state.window_pos_alloc = c.emu.push_stack(wp);

            state.message_queue = {
                {.message = WM_NCDESTROY, .wParam = 0, .lParam = 0},
                {.message = WM_DESTROY, .wParam = 0, .lParam = 0},
                {.message = WM_KILLFOCUS, .wParam = 0, .lParam = 0},
                {.message = WM_ACTIVATE, .wParam = 0, .lParam = 0},
                {.message = WM_NCACTIVATE, .wParam = FALSE, .lParam = 0},
                {.message = WM_WINDOWPOSCHANGED, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_WINDOWPOSCHANGING, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_UAHDESTROYWINDOW, .wParam = 0, .lParam = 0},
            };
        }
        else
        {
            state.message_queue = {
                {.message = WM_NCDESTROY, .wParam = 0, .lParam = 0},
                {.message = WM_DESTROY, .wParam = 0, .lParam = 0},
                {.message = WM_UAHDESTROYWINDOW, .wParam = 0, .lParam = 0},
            };
        }

        dispatch_next_message(c, callback_id::NtUserDestroyWindow, std::move(state), *win, state.message_queue);
        return {};
    }

    BOOL completion_NtUserDestroyWindow(const syscall_context& c, const hwnd window)
    {
        auto& s = c.get_completion_state<window_destroy_state>();
        auto* win = c.proc.windows.get(window);

        if (!s.message_queue.empty())
        {
            dispatch_next_message(c, callback_id::NtUserDestroyWindow, std::move(s), *win, s.message_queue);
            return {};
        }

        if (s.window_pos_alloc.address != 0)
        {
            c.emu.pop_stack(std::move(s.window_pos_alloc));
        }

        return c.proc.windows.erase(window);
    }

    BOOL handle_NtUserSetProp(const syscall_context& c, const hwnd window, const uint16_t atom, const uint64_t data)
    {
        auto* win = c.proc.windows.get(window);
        const auto* prop = c.proc.get_atom_name(atom);

        if (!win || !prop)
        {
            return FALSE;
        }

        win->props[*prop] = data;

        return TRUE;
    }

    BOOL handle_NtUserSetProp2(const syscall_context& c, const hwnd window,
                               const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> str, const uint64_t data)
    {
        auto* win = c.proc.windows.get(window);
        if (!win || !str)
        {
            return FALSE;
        }

        auto prop = read_unicode_string(c.emu, str);
        win->props[std::move(prop)] = data;

        return TRUE;
    }

    uint64_t handle_NtUserChangeWindowMessageFilterEx()
    {
        return 0;
    }

    BOOL handle_NtUserShowWindow(const syscall_context& c, const hwnd hwnd, const LONG cmd_show)
    {
        auto* win = c.proc.windows.get(hwnd);
        if (!win)
        {
            return FALSE;
        }

        if (win->thread_id != c.proc.active_thread->id)
        {
            // TODO: Wait?
            return FALSE;
        }

        const bool want_visible = (cmd_show != 0); // SW_HIDE
        const bool was_visible = (win->style & WS_VISIBLE) != 0;

        if (want_visible == was_visible)
        {
            return was_visible ? TRUE : FALSE;
        }

        window_show_state state{};
        state.was_visible = was_visible;

        EMU_WINDOWPOS wp{};
        wp.hwnd = hwnd;
        wp.hwndInsertAfter = 0;
        wp.x = win->x;
        wp.y = win->y;
        wp.cx = win->width;
        wp.cy = win->height;
        wp.flags = want_visible ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
        state.window_pos_alloc = c.emu.push_stack(wp);

        if (want_visible)
        {
            const auto move_lparam = static_cast<uint64_t>(((win->y & 0xFFFF) << 16) | (win->x & 0xFFFF));
            const auto size_lparam = static_cast<uint64_t>(((win->height & 0xFFFF) << 16) | (win->width & 0xFFFF));

            state.message_queue = {
                {.message = WM_MOVE, .wParam = 0, .lParam = move_lparam},
                {.message = WM_SIZE, .wParam = 0, .lParam = size_lparam},
                {.message = WM_WINDOWPOSCHANGED, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_SETFOCUS, .wParam = 0, .lParam = 0},
                {.message = WM_ACTIVATE, .wParam = 1, .lParam = 0},
                {.message = WM_NCACTIVATE, .wParam = TRUE, .lParam = 0},
                {.message = WM_WINDOWPOSCHANGING, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_WINDOWPOSCHANGING, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_SHOWWINDOW, .wParam = TRUE, .lParam = 0},
            };

            win->style |= WS_VISIBLE;
        }
        else
        {
            state.message_queue = {
                {.message = WM_KILLFOCUS, .wParam = 0, .lParam = 0},
                {.message = WM_ACTIVATE, .wParam = 0, .lParam = 0},
                {.message = WM_NCACTIVATE, .wParam = FALSE, .lParam = 0},
                {.message = WM_WINDOWPOSCHANGED, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_WINDOWPOSCHANGING, .wParam = 0, .lParam = state.window_pos_alloc.address},
                {.message = WM_SHOWWINDOW, .wParam = FALSE, .lParam = 0},
            };

            win->style &= ~WS_VISIBLE;
        }

        win->guest.access([&](USER_WINDOW& guest_win) { //
            guest_win.dwStyle = win->style;
        });

        dispatch_next_message(c, callback_id::NtUserShowWindow, std::move(state), *win, state.message_queue);
        return {};
    }

    BOOL completion_NtUserShowWindow(const syscall_context& c, const hwnd hwnd, const LONG /*cmd_show*/)
    {
        auto& s = c.get_completion_state<window_show_state>();
        const auto* win = c.proc.windows.get(hwnd);

        if (!s.message_queue.empty())
        {
            dispatch_next_message(c, callback_id::NtUserShowWindow, std::move(s), *win, s.message_queue);
            return {};
        }

        c.emu.pop_stack(std::move(s.window_pos_alloc));

        return s.was_visible ? TRUE : FALSE;
    }

    uint64_t handle_NtUserMessageCall(const syscall_context& c, const hwnd hwnd, const UINT msg, const uint64_t w_param,
                                      const uint64_t l_param, const uint64_t /*result_info*/, const DWORD /*type*/, const BOOL /*ansi*/)
    {
        const auto* win = c.proc.windows.get(hwnd);
        if (!win)
        {
            return 0;
        }

        if (win->thread_id != c.proc.active_thread->id)
        {
            return 0;
        }

        dispatch_window_message(c, callback_id::NtUserMessageCall, nullptr, *win, msg, w_param, l_param);
        return {};
    }

    uint64_t completion_NtUserMessageCall(const syscall_context& c, const hwnd /*hwnd*/, const UINT /*msg*/, const uint64_t /*w_param*/,
                                          const uint64_t /*l_param*/, const uint64_t /*result_info*/, const DWORD /*type*/,
                                          const BOOL /*ansi*/)
    {
        return c.get_callback_result<uint64_t>();
    }

    BOOL handle_NtUserGetMessage(const syscall_context& c, const emulator_object<msg> message, const hwnd hwnd, const UINT msg_filter_min,
                                 const UINT msg_filter_max)
    {
        auto& t = c.win_emu.current_thread();

        if (auto pending_msg = t.peek_pending_message(hwnd, msg_filter_min, msg_filter_max, true))
        {
            message.write(*pending_msg);
            set_thread_window_context(c, pending_msg->window);
            return pending_msg->message != WM_QUIT ? TRUE : FALSE;
        }

        t.await_msg = {message, hwnd, msg_filter_min, msg_filter_max};

        c.win_emu.yield_thread(false);
        return {};
    }

    BOOL handle_NtUserPeekMessage(const syscall_context& c, const emulator_object<msg> message, const hwnd hwnd, const UINT msg_filter_min,
                                  const UINT msg_filter_max, const UINT remove_message)
    {
        auto& t = c.win_emu.current_thread();

        const bool should_remove = (remove_message & PM_REMOVE) != 0;
        std::optional<msg> pending_msg = t.peek_pending_message(hwnd, msg_filter_min, msg_filter_max, should_remove);

        if (pending_msg)
        {
            message.write(*pending_msg);
            set_thread_window_context(c, pending_msg->window);
            return TRUE;
        }

        return FALSE;
    }

    BOOL handle_NtUserPostMessage(const syscall_context& c, const hwnd hwnd, const UINT msg, const uint64_t wParam, const uint64_t lParam)
    {
        const auto* win = c.proc.windows.get(hwnd);
        if (!win && hwnd != 0)
        {
            return FALSE;
        }

        uint32_t target_thread_id = hwnd != 0 ? win->thread_id : c.win_emu.current_thread().id;

        for (auto& thread : c.proc.threads | std::views::values)
        {
            if (thread.id == target_thread_id)
            {
                ::msg qmsg{};
                qmsg.window = hwnd;
                qmsg.message = msg;
                qmsg.wParam = wParam;
                qmsg.lParam = lParam;

                thread.post_message(qmsg);
                return TRUE;
            }
        }

        return FALSE;
    }

    BOOL handle_NtUserPostQuitMessage(const syscall_context& c, int exit_code)
    {
        msg qmsg{};
        qmsg.message = WM_QUIT;
        qmsg.wParam = exit_code;

        c.proc.active_thread->post_message(qmsg);
        return TRUE;
    }

    NTSTATUS handle_NtUserEnumDisplayDevices(const syscall_context& c,
                                             const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> str_device, const DWORD dev_num,
                                             const emulator_object<EMU_DISPLAY_DEVICEW> display_device, const DWORD /*flags*/)
    {
        if (!str_device)
        {
            if (dev_num > 0)
            {
                return STATUS_UNSUCCESSFUL;
            }

            display_device.access([&](EMU_DISPLAY_DEVICEW& dev) {
                dev.StateFlags = 0x5; // DISPLAY_DEVICE_PRIMARY_DEVICE | DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
                utils::string::copy(dev.DeviceName, u"\\\\.\\DISPLAY1");
                utils::string::copy(dev.DeviceString, u"Emulated Virtual Adapter");
                utils::string::copy(dev.DeviceID, u"PCI\\VEN_10DE&DEV_0000&SUBSYS_00000000&REV_A1");
                utils::string::copy(dev.DeviceKey, u"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Video\\{00000001-"
                                                   u"0002-0003-0004-000000000005}\\0000");
            });
        }
        else
        {
            const auto dev_name = read_unicode_string(c.emu, str_device);

            if (dev_name != u"\\\\.\\DISPLAY1")
            {
                return STATUS_UNSUCCESSFUL;
            }

            if (dev_num > 0)
            {
                return STATUS_UNSUCCESSFUL;
            }

            display_device.access([&](EMU_DISPLAY_DEVICEW& dev) {
                dev.StateFlags = 0x1; // DISPLAY_DEVICE_ACTIVE
                utils::string::copy(dev.DeviceName, u"\\\\.\\DISPLAY1\\Monitor0");
                utils::string::copy(dev.DeviceString, u"Generic PnP Monitor");
                utils::string::copy(dev.DeviceID, u"MONITOR\\EMU1234\\{4d36e96e-e325-11ce-bfc1-08002be10318}\\0000");
                utils::string::copy(dev.DeviceKey, u"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\DISPLAY\\EMU1234\\"
                                                   u"1&23a45b&0&UID67568640");
            });
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserEnumDisplaySettings(const syscall_context& c,
                                              const emulator_object<UNICODE_STRING<EmulatorTraits<Emu64>>> device_name,
                                              const DWORD mode_num, const emulator_object<EMU_DEVMODEW> dev_mode, const DWORD /*flags*/)
    {
        if (dev_mode && (mode_num == ENUM_CURRENT_SETTINGS || mode_num == 0))
        {
            const auto dev_name = read_unicode_string(c.emu, device_name);

            if (dev_name == u"\\\\.\\DISPLAY1")
            {
                dev_mode.access([](EMU_DEVMODEW& dm) {
                    dm.dmFields = 0x5C0000; // DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY
                    dm.dmPelsWidth = 1920;
                    dm.dmPelsHeight = 1080;
                    dm.dmBitsPerPel = 32;
                    dm.dmDisplayFrequency = 60;
                });

                return STATUS_SUCCESS;
            }
        }

        return STATUS_UNSUCCESSFUL;
    }

    BOOL handle_NtUserEnumDisplayMonitors(const syscall_context& c, const hdc hdc_in, const uint64_t clip_rect_ptr, const uint64_t callback,
                                          const uint64_t param)
    {
        if (!callback)
        {
            return FALSE;
        }

        const auto hmon = c.win_emu.process.default_monitor_handle.bits;
        const auto display_info = c.proc.user_handles.get_display_info().read();
        const emulator_object<USER_MONITOR> monitor_obj(c.emu, display_info.pPrimaryMonitor);
        if (!monitor_obj)
        {
            return FALSE;
        }

        const auto monitor = monitor_obj.read();
        auto effective_rc = monitor.rcMonitor;

        if (clip_rect_ptr)
        {
            RECT clip{};
            c.emu.read_memory(clip_rect_ptr, &clip, sizeof(clip));

            effective_rc.left = std::max(effective_rc.left, clip.left);
            effective_rc.top = std::max(effective_rc.top, clip.top);
            effective_rc.right = std::min(effective_rc.right, clip.right);
            effective_rc.bottom = std::min(effective_rc.bottom, clip.bottom);
            if (effective_rc.right <= effective_rc.left || effective_rc.bottom <= effective_rc.top)
            {
                return TRUE;
            }
        }

        if (c.proc.is_wow64_process)
        {
            if (!c.proc.active_thread)
            {
                return FALSE;
            }

            if (hmon > std::numeric_limits<uint32_t>::max() || hdc_in > std::numeric_limits<uint32_t>::max() ||
                callback > std::numeric_limits<uint32_t>::max() || param > std::numeric_limits<uint32_t>::max())
            {
                return FALSE;
            }

            wow64_enum_display_monitors_callback_args args{};
            args.monitor = static_cast<uint32_t>(hmon);
            args.dc = static_cast<uint32_t>(hdc_in);
            args.param = static_cast<uint32_t>(param);
            args.callback = static_cast<uint32_t>(callback);
            args.rect = effective_rc;

            const auto arg_buffer = c.proc.base_allocator.reserve(sizeof(args), alignof(uint32_t));
            emulator_object<wow64_enum_display_monitors_callback_args>{c.emu, arg_buffer}.write(args);

            pending_wow64_callback pending_callback{};
            pending_callback.callback_id = k_wow64_enum_display_monitors_callback_id;
            pending_callback.postprocess = wow64_callback_postprocess::bool_result_to_status;

            if (!schedule_wow64_callback(c, *c.proc.active_thread, k_wow64_enum_display_monitors_callback_id, arg_buffer,
                                         static_cast<uint32_t>(sizeof(args)), pending_callback))
            {
                return FALSE;
            }

            return TRUE;
        }

        const uint64_t rect_ptr = display_info.pPrimaryMonitor + offsetof(USER_MONITOR, rcMonitor);
        dispatch_user_callback(c, callback_id::NtUserEnumDisplayMonitors, callback, hmon, hdc_in, rect_ptr, param);
        return {};
    }

    BOOL completion_NtUserEnumDisplayMonitors(const syscall_context& c, const hdc /*hdc_in*/, const uint64_t /*clip_rect_ptr*/,
                                              const uint64_t /*callback*/, const uint64_t /*param*/)
    {
        return c.get_callback_result<BOOL>();
    }

    BOOL handle_NtUserGetHDevName(const syscall_context& c, handle hdev, emulator_pointer device_name)
    {
        if (hdev != c.proc.default_monitor_handle)
        {
            return FALSE;
        }

        const std::u16string name = u"\\\\.\\DISPLAY1";
        c.emu.write_memory(device_name, name.c_str(), (name.size() + 1) * sizeof(char16_t));

        return TRUE;
    }

    emulator_pointer handle_NtUserMapDesktopObject(const syscall_context& c, handle handle)
    {
        if (handle.value.type == handle_types::desktop && !handle.value.is_pseudo)
        {
            auto* desktop = c.proc.desktops.get(handle);
            if (!desktop)
            {
                return 0;
            }

            if (desktop->mapped_object == 0)
            {
                desktop->mapped_object = c.proc.base_allocator.reserve(sizeof(USER_DESKTOPINFO), alignof(USER_DESKTOPINFO));
                std::array<std::byte, sizeof(USER_DESKTOPINFO)> zeros{};
                c.emu.write_memory(desktop->mapped_object, zeros.data(), zeros.size());
            }

            return desktop->mapped_object;
        }

        const auto index = handle.value.id;

        if (index == 0 || index >= user_handle_table::MAX_HANDLES)
        {
            return 0;
        }

        const auto handle_entry = c.proc.user_handles.get_handle_table().read(static_cast<size_t>(index));
        return handle_entry.pHead;
    }

    NTSTATUS handle_NtUserTransformRect()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserSetWindowPos()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserSetForegroundWindow()
    {
        return STATUS_SUCCESS;
    }

    emulator_pointer handle_NtUserSetWindowLongPtr(const syscall_context& c, handle hWnd, int nIndex, emulator_pointer dwNewLong,
                                                   BOOL /*Ansi*/)
    {
        auto* win = c.proc.windows.get(hWnd);
        if (!win)
        {
            return 0;
        }

        emulator_pointer oldValue = 0;

        win->guest.access([&](USER_WINDOW& guest_win) {
            if (nIndex >= 0)
            {
                const auto offsetCorrection = guest_win.wndExtraOffset;
                const auto pBaseExtraBytes = guest_win.pExtraBytes;

                if (pBaseExtraBytes == 0)
                {
                    return;
                }

                const auto targetAddress = pBaseExtraBytes + (nIndex - offsetCorrection);

                c.win_emu.memory.read_memory(targetAddress, &oldValue, sizeof(oldValue));
                c.win_emu.memory.write_memory(targetAddress, &dwNewLong, sizeof(dwNewLong));
            }
            else
            {
                switch (nIndex)
                {
                case GWLP_USERDATA:
                    oldValue = guest_win.userData;
                    guest_win.userData = dwNewLong;
                    break;

                case GWLP_WNDPROC:
                    oldValue = guest_win.lpfnWndProc;
                    guest_win.lpfnWndProc = dwNewLong;
                    break;

                default:
                    break;
                }
            }
        });

        return oldValue;
    }

    uint32_t handle_NtUserSetWindowLong(const syscall_context& c, handle hWnd, int nIndex, uint32_t dwNewLong, BOOL Ansi)
    {
        const auto oldValue = handle_NtUserSetWindowLongPtr(c, hWnd, nIndex, static_cast<emulator_pointer>(dwNewLong), Ansi);
        return static_cast<uint32_t>(oldValue);
    }

    NTSTATUS handle_NtUserRedrawWindow()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserGetCPD()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserSetWindowFNID()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserEnableWindow()
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtUserGetSystemMenu()
    {
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/syscalls/worker_factory.cpp`:

```cpp
#include "../std_include.hpp"
#include "../emulator_utils.hpp"
#include "../io_completion_wait.hpp"
#include "../syscall_utils.hpp"

#include <limits>

namespace syscalls
{
    namespace
    {
        std::u16string read_object_name(const syscall_context& c,
                                        const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes)
        {
            if (!object_attributes)
            {
                return {};
            }

            const auto attributes = object_attributes.read();
            if (attributes.ObjectName == 0)
            {
                return {};
            }

            return read_unicode_string(c.emu, attributes.ObjectName);
        }

        void prune_worker_factory_threads(const syscall_context& c, worker_factory& factory)
        {
            std::erase_if(factory.worker_threads, [&](const handle thread_handle) {
                const auto* thread = c.proc.threads.get(thread_handle);
                return thread == nullptr || thread->is_terminated();
            });
        }

        uint32_t get_worker_factory_thread_limit(const worker_factory& factory)
        {
            uint32_t limit = std::numeric_limits<uint32_t>::max();

            if (factory.max_thread_count != 0)
            {
                limit = std::min(limit, factory.max_thread_count);
            }

            if (factory.thread_maximum != 0)
            {
                limit = std::min(limit, factory.thread_maximum);
            }

            if (factory.thread_soft_maximum != 0)
            {
                limit = std::min(limit, factory.thread_soft_maximum);
            }

            return limit;
        }

        void ensure_worker_factory_threads(const syscall_context& c, worker_factory& factory)
        {
            if (factory.shutdown || factory.paused != 0 || factory.start_routine == 0)
            {
                return;
            }

            prune_worker_factory_threads(c, factory);

            const auto limit = get_worker_factory_thread_limit(factory);
            if (limit == 0)
            {
                return;
            }

            auto desired = std::max(factory.thread_minimum, factory.binding_count);
            desired = std::min(desired, limit);

            while (factory.worker_threads.size() < desired)
            {
                const auto stack_size =
                    factory.stack_reserve != 0 ? factory.stack_reserve : c.win_emu.mod_manager.executable->size_of_stack_reserve;
                const auto create_flags = (factory.flags & WORKER_FACTORY_FLAG_LOADER_POOL) ? THREAD_CREATE_FLAGS_LOADER_WORKER : 0;
                const auto thread_handle =
                    c.proc.create_thread(c.win_emu.memory, factory.start_routine, factory.start_parameter, stack_size, create_flags);
                factory.worker_threads.push_back(thread_handle);
            }
        }
    }

    NTSTATUS handle_NtCreateWorkerFactory(const syscall_context& c, const emulator_object<handle> worker_factory_handle,
                                          const ACCESS_MASK /*desired_access*/,
                                          const emulator_object<OBJECT_ATTRIBUTES<EmulatorTraits<Emu64>>> object_attributes,
                                          const handle io_completion_handle, const handle worker_process_handle,
                                          const emulator_pointer start_routine, const emulator_pointer start_parameter,
                                          const ULONG max_thread_count,
                                          const EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T) stack_reserve,
                                          const EMULATOR_CAST(EmulatorTraits<Emu64>::SIZE_T, SIZE_T) stack_commit)
    {
        if (!c.proc.io_completions.get(io_completion_handle))
        {
            return STATUS_INVALID_HANDLE;
        }

        if (worker_process_handle != CURRENT_PROCESS)
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto name = read_object_name(c, object_attributes);
        if (!name.empty())
        {
            for (auto& entry : c.proc.worker_factories)
            {
                if (entry.second.name == name)
                {
                    ++entry.second.ref_count;
                    worker_factory_handle.write(c.proc.worker_factories.make_handle(entry.first));
                    return STATUS_OBJECT_NAME_EXISTS;
                }
            }
        }

        worker_factory factory{};
        factory.name = name;

        handle retained_io_completion_handle{};
        if (!io_completion_wait::retain_handle_reference(c.proc, io_completion_handle, retained_io_completion_handle))
        {
            return STATUS_INVALID_HANDLE;
        }

        factory.io_completion_handle = retained_io_completion_handle;
        factory.worker_process_handle = worker_process_handle;
        factory.start_routine = start_routine;
        factory.start_parameter = start_parameter;
        factory.max_thread_count = max_thread_count;
        factory.stack_reserve = stack_reserve;
        factory.stack_commit = stack_commit;
        factory.thread_maximum = max_thread_count;

        auto [stored_handle, stored_factory] = c.proc.worker_factories.store_and_get(std::move(factory));
        ensure_worker_factory_threads(c, *stored_factory);
        worker_factory_handle.write(stored_handle);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtWorkerFactoryWorkerReady(const syscall_context& c, const handle worker_factory_handle)
    {
        auto* factory = c.proc.worker_factories.get(worker_factory_handle);
        if (!factory)
        {
            return STATUS_INVALID_HANDLE;
        }

        ensure_worker_factory_threads(c, *factory);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtSetInformationWorkerFactory(const syscall_context& c, const handle worker_factory_handle,
                                                  const WORKERFACTORYINFOCLASS info_class,
                                                  const emulator_pointer worker_factory_information,
                                                  const ULONG worker_factory_information_length)
    {
        auto* factory = c.proc.worker_factories.get(worker_factory_handle);
        if (!factory)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (info_class >= MaxWorkerFactoryInfoClass)
        {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (worker_factory_information == 0 && worker_factory_information_length != 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        factory->last_info_class = static_cast<ULONG>(info_class);
        factory->last_info_length = worker_factory_information_length;
        factory->last_info_value = 0;

        const emulator_object<LARGE_INTEGER> value_i64{c.emu, worker_factory_information};
        const emulator_object<ULONG> value_u32{c.emu, worker_factory_information};
        const emulator_object<uint64_t> value_u64{c.emu, worker_factory_information};

        switch (info_class)
        {
        case WorkerFactoryTimeout:
        case WorkerFactoryRetryTimeout:
        case WorkerFactoryIdleTimeout: {
            if (worker_factory_information_length != sizeof(LARGE_INTEGER))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            const auto value = value_i64.read().QuadPart;
            factory->last_info_value = static_cast<uint64_t>(value);

            if (info_class == WorkerFactoryTimeout)
            {
                factory->timeout = value;
            }
            else if (info_class == WorkerFactoryRetryTimeout)
            {
                factory->retry_timeout = value;
            }
            else
            {
                factory->idle_timeout = value;
            }
            return STATUS_SUCCESS;
        }

        case WorkerFactoryBindingCount: {
            if (worker_factory_information_length != sizeof(ULONG))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            const auto raw_value = value_u32.read();
            const auto delta = static_cast<LONG>(raw_value);
            factory->last_info_value = raw_value;

            if (delta < 0)
            {
                const auto decrement = static_cast<uint32_t>(-delta);
                if (decrement >= factory->binding_count)
                {
                    factory->binding_count = 0;
                }
                else
                {
                    factory->binding_count -= decrement;
                }
            }
            else
            {
                const auto increment = static_cast<uint32_t>(delta);
                const auto next = static_cast<uint64_t>(factory->binding_count) + increment;
                factory->binding_count =
                    next > std::numeric_limits<uint32_t>::max() ? std::numeric_limits<uint32_t>::max() : static_cast<uint32_t>(next);
            }

            ensure_worker_factory_threads(c, *factory);
            return STATUS_SUCCESS;
        }

        case WorkerFactoryThreadMinimum:
        case WorkerFactoryThreadMaximum:
        case WorkerFactoryPaused:
        case WorkerFactoryThreadBasePriority:
        case WorkerFactoryTimeoutWaiters:
        case WorkerFactoryFlags:
        case WorkerFactoryThreadSoftMaximum: {
            if (worker_factory_information_length != sizeof(ULONG))
            {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            const auto value = value_u32.read();
            factory->last_info_value = value;

            switch (info_class)
            {
            case WorkerFactoryThreadMinimum:
                factory->thread_minimum = value;
                break;
            case WorkerFactoryThreadMaximum:
                factory->thread_maximum = value;
                break;
            case WorkerFactoryPaused:
                factory->paused = value;
                break;
            case WorkerFactoryThreadBasePriority:
                factory->thread_base_priority = value;
                break;
            case WorkerFactoryTimeoutWaiters:
                factory->timeout_waiters = value;
                break;
            case WorkerFactoryFlags:
                factory->flags = value;
                break;
            case WorkerFactoryThreadSoftMaximum:
                factory->thread_soft_maximum = value;
                break;
            default:
                break;
            }

            ensure_worker_factory_threads(c, *factory);
            return STATUS_SUCCESS;
        }

        default: {
            if (worker_factory_information_length == 0)
            {
                return STATUS_SUCCESS;
            }

            if (worker_factory_information_length == sizeof(ULONG))
            {
                factory->last_info_value = value_u32.read();
                return STATUS_SUCCESS;
            }

            if (worker_factory_information_length == sizeof(uint64_t))
            {
                factory->last_info_value = value_u64.read();
                return STATUS_SUCCESS;
            }

            return STATUS_NOT_SUPPORTED;
        }
        }
    }

    NTSTATUS handle_NtShutdownWorkerFactory(const syscall_context& c, const handle worker_factory_handle,
                                            const emulator_object<LONG> pending_worker_count)
    {
        auto* factory = c.proc.worker_factories.get(worker_factory_handle);
        if (!factory)
        {
            return STATUS_INVALID_HANDLE;
        }

        factory->shutdown = true;
        factory->worker_threads.clear();
        pending_worker_count.write_if_valid(0);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtReleaseWorkerFactoryWorker(const syscall_context& c, const handle worker_factory_handle)
    {
        auto* factory = c.proc.worker_factories.get(worker_factory_handle);
        if (!factory)
        {
            return STATUS_INVALID_HANDLE;
        }

        ensure_worker_factory_threads(c, *factory);
        return STATUS_SUCCESS;
    }

    NTSTATUS handle_NtWaitForWorkViaWorkerFactory(const syscall_context& c, const handle worker_factory_handle,
                                                  const emulator_object<FILE_IO_COMPLETION_INFORMATION<EmulatorTraits<Emu64>>> mini_packets,
                                                  const ULONG count, const emulator_object<ULONG> packets_returned,
                                                  const emulator_pointer /*deferred_work*/)
    {
        if (count == 0 || !mini_packets)
        {
            return STATUS_INVALID_PARAMETER;
        }

        auto* factory = c.proc.worker_factories.get(worker_factory_handle);
        if (!factory)
        {
            return STATUS_INVALID_HANDLE;
        }

        if (!c.proc.io_completions.get(factory->io_completion_handle))
        {
            return STATUS_INVALID_HANDLE;
        }

        const auto removed = io_completion_wait::dequeue_io_completion_entries(c.proc, factory->io_completion_handle, mini_packets, count);
        packets_returned.write_if_valid(removed);
        if (removed > 0)
        {
            return STATUS_SUCCESS;
        }

        auto& t = c.win_emu.current_thread();
        t.await_objects = {};
        t.await_any = false;
        t.await_time = {};
        t.await_msg = {};
        t.waiting_for_alert = false;
        t.await_io_completion = pending_io_completion_wait{};

        auto& wait = *t.await_io_completion;
        wait.type = io_completion_wait_type::remove_multiple;
        wait.io_completion_handle = factory->io_completion_handle;
        wait.completion_entries_ptr = mini_packets.value();
        wait.entries_removed_ptr = packets_returned.value();
        wait.max_entries = count;

        if (factory->timeout != 0)
        {
            LARGE_INTEGER timeout{};
            timeout.QuadPart = factory->timeout;
            wait.timeout = utils::convert_delay_interval_to_time_point(c.win_emu.clock(), timeout);

            constexpr auto infinite = std::chrono::steady_clock::time_point::min();
            if (wait.timeout.has_value() && wait.timeout.value() != infinite && wait.timeout.value() < c.win_emu.clock().steady_now())
            {
                packets_returned.write_if_valid(0);
                t.await_io_completion = {};
                return STATUS_TIMEOUT;
            }
        }

        c.win_emu.yield_thread(false);
        return STATUS_SUCCESS;
    }
}

```

`src/windows-emulator/user_callback_dispatch.hpp`:

```hpp
#pragma once

#include "syscall_utils.hpp"

// TODO: Here we are calling guest functions directly, but this is not how it works in the real Windows kernel.
//       In the real implementation, the kernel invokes ntdll!KiUserCallbackDispatcher and passes a callback
//       index that refers to an entry in PEB->KernelCallbackTable. The dispatcher then looks up the function
//       pointer in that table and invokes the corresponding user-mode callback.
//       See Also: https://web.archive.org/web/20080717175308/http://www.nynaeve.net/?p=204

template <typename... Args>
void prepare_call_stack(x86_64_emulator& emu, uint64_t return_address, Args... args)
{
    constexpr size_t arg_count = sizeof...(Args);
    const size_t stack_args_size = aligned_stack_space(arg_count);

    const uint64_t current_rsp = emu.read_stack_pointer();
    const uint64_t aligned_rsp = align_down(current_rsp, 16);

    // We subtract the args size (including the shadow space) AND the size of the return address
    const uint64_t new_rsp = aligned_rsp - stack_args_size - sizeof(emulator_pointer);
    emu.reg(x86_register::rsp, new_rsp);

    emu.write_memory(new_rsp, &return_address, sizeof(return_address));

    size_t index = 0;
    (set_function_argument(emu, index++, static_cast<uint64_t>(args)), ...);
}

template <typename StateT, typename... Args>
    requires(std::derived_from<std::remove_reference_t<StateT>, completion_state> ||
             std::same_as<std::remove_reference_t<StateT>, std::nullptr_t>)
void dispatch_user_callback(const syscall_context& c, callback_id completion_id, StateT&& state_obj, uint64_t func_address, Args... args)
{
    if (c.run_callback)
    {
        throw std::runtime_error("A callback has already been dispatched");
    }

    std::unique_ptr<completion_state> state;

    if constexpr (std::same_as<std::remove_reference_t<StateT>, std::nullptr_t>)
    {
        state = nullptr;
    }
    else
    {
        state = std::make_unique<std::remove_reference_t<StateT>>(std::forward<StateT>(state_obj));
    }

    callback_frame frame(completion_id, std::move(state));
    frame.save_registers(c.emu);
    c.proc.active_thread->callback_return_rax.reset();
    c.proc.active_thread->callback_stack.emplace_back(std::move(frame));

    prepare_call_stack(c.emu, c.proc.zw_callback_return, args...);

    c.emu.reg(x86_register::rip, func_address);
    c.run_callback = true;
}

template <typename... Args>
void dispatch_user_callback(const syscall_context& c, callback_id completion_id, uint64_t func_address, Args... args)
{
    dispatch_user_callback(c, completion_id, nullptr, func_address, args...);
}

```

`src/windows-emulator/user_handle_table.hpp`:

```hpp
#pragma once
#include "emulator_utils.hpp"
#include "handles.hpp"

class user_handle_table
{
  public:
    static constexpr uint32_t MAX_HANDLES = 0xFFFF;

    user_handle_table(memory_manager& memory)
        : memory_(&memory)
    {
    }

    void setup(const bool is_wow64_process)
    {
        this->is_wow64_process_ = is_wow64_process;

        used_indices_.resize(MAX_HANDLES, false);

        const auto server_info_size = static_cast<size_t>(page_align_up(sizeof(USER_SERVERINFO)));
        server_info_addr_ = this->allocate_memory(server_info_size, memory_permission::read);

        const auto display_info_size = static_cast<size_t>(page_align_up(sizeof(USER_DISPINFO)));
        display_info_addr_ = this->allocate_memory(display_info_size, memory_permission::read);

        const emulator_object<USER_SERVERINFO> srv_obj(*memory_, server_info_addr_);
        srv_obj.access([&](USER_SERVERINFO& srv) {
            srv.cHandleEntries = MAX_HANDLES - 1; //
        });

        const auto handle_table_size = static_cast<size_t>(page_align_up(sizeof(USER_HANDLEENTRY) * MAX_HANDLES));
        handle_table_addr_ = this->allocate_memory(handle_table_size, memory_permission::read);
    }

    emulator_object<USER_SERVERINFO> get_server_info() const
    {
        return {*memory_, server_info_addr_};
    }

    emulator_object<USER_HANDLEENTRY> get_handle_table() const
    {
        return {*memory_, handle_table_addr_};
    }

    emulator_object<USER_DISPINFO> get_display_info() const
    {
        return {*memory_, display_info_addr_};
    }

    template <typename T>
    std::pair<handle, emulator_object<T>> allocate_object(handle_types::type type)
    {
        const auto index = find_free_index();

        const auto alloc_size = static_cast<size_t>(page_align_up(sizeof(T)));
        const auto alloc_ptr = this->allocate_memory(alloc_size, memory_permission::read);
        const emulator_object<T> alloc_obj(*memory_, alloc_ptr);

        const emulator_object<USER_HANDLEENTRY> handle_table_obj(*memory_, handle_table_addr_);
        handle_table_obj.access(
            [&](USER_HANDLEENTRY& entry) {
                entry.pHead = alloc_ptr;
                entry.bType = get_native_type(type);
                entry.wUniq = static_cast<uint16_t>(type << 7);
            },
            index);

        used_indices_[index] = true;

        return {make_handle(index, type, false), alloc_obj};
    }

    void free_index(uint32_t index)
    {
        if (index >= used_indices_.size() || !used_indices_[index])
        {
            return;
        }

        used_indices_[index] = false;

        const emulator_object<USER_HANDLEENTRY> handle_table_obj(*memory_, handle_table_addr_);
        handle_table_obj.access(
            [&](USER_HANDLEENTRY& entry) {
                memory_->release_memory(entry.pHead, 0);
                entry = {};
            },
            index);
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(server_info_addr_);
        buffer.write(handle_table_addr_);
        buffer.write(display_info_addr_);
        buffer.write_vector(used_indices_);
        buffer.write(is_wow64_process_);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(server_info_addr_);
        buffer.read(handle_table_addr_);
        buffer.read(display_info_addr_);
        buffer.read_vector(used_indices_);
        buffer.read(is_wow64_process_);
    }

  private:
    uint32_t find_free_index() const
    {
        for (uint32_t i = 1; i < used_indices_.size(); ++i)
        {
            if (!used_indices_[i])
            {
                return i;
            }
        }
        throw std::runtime_error("No more user handles available");
    }

    static uint8_t get_native_type(handle_types::type type)
    {
        switch (type)
        {
        case handle_types::type::window:
            return TYPE_WINDOW;
        case handle_types::type::monitor:
            return TYPE_MONITOR;
        default:
            throw std::runtime_error("Unhandled handle type!");
        }
    }

    uint64_t allocate_memory(const size_t size, const nt_memory_permission permissions)
    {
        const auto allocation_base = this->is_wow64_process_ ? DEFAULT_ALLOCATION_ADDRESS_32BIT : DEFAULT_ALLOCATION_ADDRESS_64BIT;
        const auto base = memory_->find_free_allocation_base(size, allocation_base);
        return memory_->allocate_memory(size, permissions, false, base);
    }

    uint64_t server_info_addr_{};
    uint64_t handle_table_addr_{};
    uint64_t display_info_addr_{};
    std::vector<bool> used_indices_{};
    memory_manager* memory_{};
    bool is_wow64_process_{};
};

template <handle_types::type Type, typename T>
    requires(utils::Serializable<T> && std::is_base_of_v<ref_counted_object, T>)
class user_handle_store : public generic_handle_store
{
  public:
    using index_type = uint32_t;
    using value_map = std::map<index_type, T>;

    explicit user_handle_store(user_handle_table& table)
        : table_(&table)
    {
    }

    std::pair<handle, T&> create(memory_interface& memory)
    {
        if (this->block_mutation_)
        {
            throw std::runtime_error("Mutation of user object store is blocked!");
        }

        auto [h, guest_obj] = table_->allocate_object<typename T::guest_type>(Type);

        T new_obj(memory);
        new_obj.guest = std::move(guest_obj);

        const auto index = static_cast<uint32_t>(h.value.id);
        const auto it = this->store_.emplace(index, std::move(new_obj)).first;
        return {h, it->second};
    }

    bool block_mutation(bool blocked)
    {
        std::swap(this->block_mutation_, blocked);
        return blocked;
    }

    handle make_handle(const index_type index) const
    {
        handle h{};
        h.bits = 0;
        h.value.is_pseudo = false;
        h.value.type = Type;
        h.value.id = index;

        return h;
    }

    T* get_by_index(const uint32_t index)
    {
        const auto it = this->store_.find(index);
        if (it == this->store_.end())
        {
            return nullptr;
        }
        return &it->second;
    }

    T* get(const handle_value h)
    {
        if (h.type != Type || h.is_pseudo)
        {
            return nullptr;
        }

        return this->get_by_index(static_cast<uint32_t>(h.id));
    }

    T* get(const handle h)
    {
        return this->get(h.value);
    }

    T* get(const uint64_t h)
    {
        handle hh{};
        hh.bits = h;
        return this->get(hh);
    }

    size_t size() const
    {
        return this->store_.size();
    }

    std::optional<handle> duplicate(const handle h) override
    {
        auto* entry = this->get(h);
        if (!entry)
        {
            return std::nullopt;
        }

        ++entry->ref_count;
        return h;
    }

    std::pair<typename value_map::iterator, bool> erase(const typename value_map::iterator& entry)
    {
        if (this->block_mutation_)
        {
            throw std::runtime_error("Mutation of handle store is blocked!");
        }

        if (entry == this->store_.end())
        {
            return {entry, false};
        }

        if constexpr (handle_detail::has_deleter_function<T>())
        {
            if (!T::deleter(entry->second))
            {
                return {entry, true};
            }
        }

        auto new_iter = this->store_.erase(entry);
        return {new_iter, true};
    }

    bool erase(const handle_value h)
    {
        if (this->block_mutation_)
        {
            throw std::runtime_error("Mutation of user object store is blocked!");
        }

        if (h.type != Type || h.is_pseudo)
        {
            return false;
        }

        const auto index = static_cast<uint32_t>(h.id);
        const auto entry = this->store_.find(index);

        if (entry == this->store_.end())
        {
            return false;
        }

        if constexpr (handle_detail::has_deleter_function<T>())
        {
            if (!T::deleter(entry->second))
            {
                return false;
            }
        }

        table_->free_index(index);
        this->store_.erase(entry);

        return true;
    }

    bool erase(const handle h) override
    {
        return this->erase(h.value);
    }

    bool erase(const uint64_t h)
    {
        handle hh{};
        hh.bits = h;
        return this->erase(hh);
    }

    bool erase(const T& value)
    {
        const auto entry = this->find(value);
        if (entry == this->store_.end())
        {
            return false;
        }

        return this->erase(make_handle(entry->first));
    }

    typename value_map::iterator find(const T& value)
    {
        auto i = this->store_.begin();
        for (; i != this->store_.end(); ++i)
        {
            if (&i->second == &value)
            {
                break;
            }
        }
        return i;
    }

    typename value_map::const_iterator find(const T& value) const
    {
        auto i = this->store_.begin();
        for (; i != this->store_.end(); ++i)
        {
            if (&i->second == &value)
            {
                break;
            }
        }
        return i;
    }

    handle find_handle(const T& value) const
    {
        const auto entry = this->find(value);
        if (entry == this->end())
        {
            return {};
        }
        return this->make_handle(entry->first);
    }

    handle find_handle(const T* value) const
    {
        if (!value)
        {
            return {};
        }
        return this->find_handle(*value);
    }

    typename value_map::iterator begin()
    {
        return this->store_.begin();
    }
    typename value_map::const_iterator begin() const
    {
        return this->store_.begin();
    }
    typename value_map::iterator end()
    {
        return this->store_.end();
    }
    typename value_map::const_iterator end() const
    {
        return this->store_.end();
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->block_mutation_);
        buffer.write_map(this->store_);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->block_mutation_);
        buffer.read_map(this->store_);
    }

  private:
    user_handle_table* table_;
    bool block_mutation_{false};
    value_map store_{};
};

```

`src/windows-emulator/version/windows_version_manager.cpp`:

```cpp
#include "../std_include.hpp"
#include "windows_version_manager.hpp"
#include "../registry/registry_manager.hpp"
#include "../logger.hpp"
#include <platform/kernel_mapped.hpp>

void windows_version_manager::load_from_registry(registry_manager& registry, const logger& logger)
{
    constexpr auto version_key_path = R"(\Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion)";

    const auto version_key = registry.get_key({version_key_path});
    if (!version_key)
    {
        throw std::runtime_error("Failed to get CurrentVersion registry key");
    }

    for (size_t i = 0; const auto value = registry.get_value(*version_key, i); ++i)
    {
        if (value->name == "SystemRoot" && value->type == REG_SZ && !value->data.empty())
        {
            const auto* data_ptr = reinterpret_cast<const char16_t*>(value->data.data());
            const auto char_count = value->data.size() / sizeof(char16_t);
            std::u16string system_root(data_ptr, char_count > 0 && data_ptr[char_count - 1] == u'\0' ? char_count - 1 : char_count);
            info_.system_root = windows_path{system_root};
        }
        else if ((value->name == "CurrentBuildNumber" || value->name == "CurrentBuild") && value->type == REG_SZ)
        {
            const auto* s = reinterpret_cast<const char16_t*>(value->data.data());
            info_.windows_build_number = static_cast<uint32_t>(std::strtoul(u16_to_u8(s).c_str(), nullptr, 10));
        }
        else if (value->name == "UBR" && value->type == REG_DWORD && value->data.size() >= sizeof(uint32_t))
        {
            info_.windows_update_build_revision = *reinterpret_cast<const uint32_t*>(value->data.data());
        }
        else if (value->name == "CurrentMajorVersionNumber" && value->type == REG_DWORD && value->data.size() >= sizeof(uint32_t))
        {
            info_.major_version = *reinterpret_cast<const uint32_t*>(value->data.data());
        }
        else if (value->name == "CurrentMinorVersionNumber" && value->type == REG_DWORD && value->data.size() >= sizeof(uint32_t))
        {
            info_.minor_version = *reinterpret_cast<const uint32_t*>(value->data.data());
        }
    }

    if (info_.system_root.u16string().empty())
    {
        throw std::runtime_error("SystemRoot not found in registry");
    }

    if (info_.windows_build_number == 0)
    {
        logger.error("Failed to get CurrentBuildNumber from registry\n");
    }

    if (info_.windows_update_build_revision == 0)
    {
        logger.error("Failed to get UBR from registry\n");
    }
}

bool windows_version_manager::is_build_before(uint32_t build, std::optional<uint32_t> ubr) const
{
    if (info_.windows_build_number != build)
    {
        return info_.windows_build_number < build;
    }
    return ubr.has_value() && info_.windows_update_build_revision < *ubr;
}

bool windows_version_manager::is_build_before_or_equal(uint32_t build, std::optional<uint32_t> ubr) const
{
    if (info_.windows_build_number != build)
    {
        return info_.windows_build_number < build;
    }
    return !ubr.has_value() || info_.windows_update_build_revision <= *ubr;
}

bool windows_version_manager::is_build_after_or_equal(uint32_t build, std::optional<uint32_t> ubr) const
{
    if (info_.windows_build_number != build)
    {
        return info_.windows_build_number > build;
    }
    return !ubr.has_value() || info_.windows_update_build_revision >= *ubr;
}

bool windows_version_manager::is_build_after(uint32_t build, std::optional<uint32_t> ubr) const
{
    if (info_.windows_build_number != build)
    {
        return info_.windows_build_number > build;
    }
    return ubr.has_value() && info_.windows_update_build_revision > *ubr;
}

bool windows_version_manager::is_build_within(uint32_t start_build, uint32_t end_build, std::optional<uint32_t> start_ubr,
                                              std::optional<uint32_t> end_ubr) const
{
    return is_build_after_or_equal(start_build, start_ubr) && is_build_before(end_build, end_ubr);
}

void windows_version_manager::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write(info_.system_root);
    buffer.write(info_.major_version);
    buffer.write(info_.minor_version);
    buffer.write(info_.windows_build_number);
    buffer.write(info_.windows_update_build_revision);
}

void windows_version_manager::deserialize(utils::buffer_deserializer& buffer)
{
    buffer.read(info_.system_root);
    buffer.read(info_.major_version);
    buffer.read(info_.minor_version);
    buffer.read(info_.windows_build_number);
    buffer.read(info_.windows_update_build_revision);
}

```

`src/windows-emulator/version/windows_version_manager.hpp`:

```hpp
#pragma once

#include "../windows_path.hpp"
#include <serialization.hpp>
#include <optional>
#include <cstdint>

class logger;
class registry_manager;

struct windows_version_info
{
    windows_path system_root{};
    uint32_t major_version{0};
    uint32_t minor_version{0};
    uint32_t windows_build_number{0};
    uint32_t windows_update_build_revision{0};
};

class windows_version_manager
{
  public:
    void load_from_registry(registry_manager& registry, const logger& logger);

    bool is_build_before(uint32_t build, std::optional<uint32_t> ubr = std::nullopt) const;
    bool is_build_before_or_equal(uint32_t build, std::optional<uint32_t> ubr = std::nullopt) const;
    bool is_build_after_or_equal(uint32_t build, std::optional<uint32_t> ubr = std::nullopt) const;
    bool is_build_after(uint32_t build, std::optional<uint32_t> ubr = std::nullopt) const;
    bool is_build_within(uint32_t start_build, uint32_t end_build, std::optional<uint32_t> start_ubr = std::nullopt,
                         std::optional<uint32_t> end_ubr = std::nullopt) const;

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);

    const windows_path& get_system_root() const
    {
        return info_.system_root;
    }
    void set_system_root(const windows_path& value)
    {
        info_.system_root = value;
    }

    uint32_t get_major_version() const
    {
        return info_.major_version;
    }
    void set_major_version(uint32_t value)
    {
        info_.major_version = value;
    }

    uint32_t get_minor_version() const
    {
        return info_.minor_version;
    }
    void set_minor_version(uint32_t value)
    {
        info_.minor_version = value;
    }

    uint32_t get_windows_build_number() const
    {
        return info_.windows_build_number;
    }
    void set_windows_build_number(uint32_t value)
    {
        info_.windows_build_number = value;
    }

    uint32_t get_windows_update_build_revision() const
    {
        return info_.windows_update_build_revision;
    }
    void set_windows_update_build_revision(uint32_t value)
    {
        info_.windows_update_build_revision = value;
    }

  private:
    windows_version_info info_{};
};

```

`src/windows-emulator/win32k_userconnect.cpp`:

```cpp
#include "std_include.hpp"
#include "win32k_userconnect.hpp"

#include "process_context.hpp"
#include "windows_emulator.hpp"

namespace
{
    constexpr size_t k_dispatch_client_message_index = 21;
    constexpr size_t k_ntdll_probe_size = 128;
    constexpr size_t k_expected_pfn_pointer_count = 3;

    std::vector<uint64_t> scan_rip_relative_lea_references(const std::vector<uint8_t>& bytes, const uint64_t code_base,
                                                           const size_t max_results)
    {
        std::vector<uint64_t> results;
        results.reserve(max_results);

        for (size_t i = 0; i + 6 < bytes.size(); ++i)
        {
            if (bytes[i] != 0x48 || bytes[i + 1] != 0x8D || (bytes[i + 2] & 0xC7) != 0x05)
            {
                continue;
            }

            int32_t disp{};
            std::memcpy(&disp, &bytes[i + 3], sizeof(disp));
            results.push_back(code_base + i + 7 + disp);

            if (results.size() >= max_results)
            {
                break;
            }
        }

        return results;
    }

    void refresh_dispatch_client_message(process_context& process)
    {
        uint64_t dispatch_client_message = 0;

        process.user_handles.get_server_info().access([&](const USER_SERVERINFO& server_info) {
            dispatch_client_message = server_info.apfnClientA[k_dispatch_client_message_index];
            if (dispatch_client_message == 0)
            {
                dispatch_client_message = server_info.apfnClientW[k_dispatch_client_message_index];
            }
        });

        if (dispatch_client_message != 0)
        {
            process.dispatch_client_message = dispatch_client_message;
        }
    }
}

namespace win32k_userconnect
{
    NTSTATUS narrow_wow64_address(const uint64_t address, uint32_t& narrowed)
    {
        narrowed = 0;

        if (address > std::numeric_limits<uint32_t>::max())
        {
            return STATUS_INVALID_PARAMETER;
        }

        narrowed = static_cast<uint32_t>(address);
        return STATUS_SUCCESS;
    }

    NTSTATUS resolve_wow64_destination(const uint64_t user_connect_ptr, const uint64_t user_connect_length, uint32_t& destination)
    {
        destination = 0;

        if (user_connect_ptr == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        if (user_connect_length < sizeof(WIN32K_USERCONNECT32))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        uint64_t offset = 0;
        if (user_connect_length == sizeof(WIN32K_USERCONNECT32))
        {
            offset = 0;
        }
        else if (user_connect_length == (sizeof(WIN32K_USERCONNECT32) + k_wow64_userconnect_header_size))
        {
            offset = k_wow64_userconnect_header_size;
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }

        const auto destination64 = user_connect_ptr + offset;
        if (destination64 < user_connect_ptr)
        {
            return STATUS_INVALID_PARAMETER;
        }

        return narrow_wow64_address(destination64, destination);
    }

    NTSTATUS build_wow64_userconnect(const process_context& process, WIN32K_USERCONNECT32& connect)
    {
        connect = {};

        uint32_t psi{};
        uint32_t disp_info{};
        uint32_t ahe_list{};
        uint32_t monitor_info{};

        auto status = narrow_wow64_address(process.user_handles.get_server_info().value(), psi);
        if (status != STATUS_SUCCESS)
        {
            return status;
        }

        status = narrow_wow64_address(process.user_handles.get_display_info().value(), disp_info);
        if (status != STATUS_SUCCESS)
        {
            return status;
        }

        status = narrow_wow64_address(process.user_handles.get_handle_table().value(), ahe_list);
        if (status != STATUS_SUCCESS)
        {
            return status;
        }

        status = narrow_wow64_address(process.user_handles.get_display_info().value(), monitor_info);
        if (status != STATUS_SUCCESS)
        {
            return status;
        }

        connect.psi = psi;
        connect.ahe_list = ahe_list;
        connect.he_entry_size = sizeof(USER_HANDLEENTRY);
        connect.disp_info_low = disp_info;
        connect.monitor_info_low = monitor_info;
        connect.wndmsg_count = k_wow64_wndmsg_count;
        connect.ime_msg_count = k_wow64_ime_msg_count;

        return STATUS_SUCCESS;
    }

    bool try_write_wow64_userconnect(memory_interface& memory, const uint64_t destination, const WIN32K_USERCONNECT32& connect)
    {
        try
        {
            const emulator_object<WIN32K_USERCONNECT32> connect_obj{memory, destination};
            connect_obj.write(connect);
            return true;
        }
        catch (...)
        {
            return false;
        }
    }

    void populate_user_shared_info(USER_SHAREDINFO& shared, const process_context& process)
    {
        shared.psi = process.user_handles.get_server_info().value();
        shared.aheList = process.user_handles.get_handle_table().value();
        shared.HeEntrySize = sizeof(USER_HANDLEENTRY);
        shared.pDispInfo = process.user_handles.get_display_info().value();
    }

    bool try_write_user_shared_info(memory_interface& memory, const uint64_t destination, const process_context& process)
    {
        try
        {
            const emulator_object<USER_SHAREDINFO> shared_obj{memory, destination};
            auto shared = shared_obj.read();
            populate_user_shared_info(shared, process);
            shared_obj.write(shared);
            return true;
        }
        catch (...)
        {
            return false;
        }
    }

    bool try_write_api_port_userconnect_reply(memory_interface& memory, const uint64_t reply_base, const process_context& process)
    {
        const auto destination = reply_base + k_wow64_userconnect_reply_shared_info_offset;
        if (destination < reply_base)
        {
            return false;
        }

        return try_write_user_shared_info(memory, destination, process);
    }

    bool try_update_client_pfn_arrays_from_addresses(memory_interface& memory, process_context& process, const uint64_t apfn_client_a,
                                                     const uint64_t apfn_client_w, const uint64_t apfn_client_worker)
    {
        try
        {
            process.user_handles.get_server_info().access([&](USER_SERVERINFO& server_info) {
                if (apfn_client_a != 0)
                {
                    memory.read_memory(apfn_client_a, &server_info.apfnClientA, sizeof(server_info.apfnClientA));
                }

                if (apfn_client_w != 0)
                {
                    memory.read_memory(apfn_client_w, &server_info.apfnClientW, sizeof(server_info.apfnClientW));
                }

                if (apfn_client_worker != 0)
                {
                    memory.read_memory(apfn_client_worker, &server_info.apfnClientWorker, sizeof(server_info.apfnClientWorker));
                }
            });
        }
        catch (...)
        {
            return false;
        }

        refresh_dispatch_client_message(process);
        return true;
    }

    bool try_bootstrap_client_pfn_arrays_from_ntdll(windows_emulator& win_emu)
    {
        if (!win_emu.mod_manager.ntdll)
        {
            return false;
        }

        const auto retrieve_user_pfn = win_emu.mod_manager.ntdll->find_export("RtlRetrieveNtUserPfn");
        if (retrieve_user_pfn == 0)
        {
            return false;
        }

        std::vector<uint8_t> code_window(k_ntdll_probe_size);
        if (!win_emu.memory.try_read_memory(retrieve_user_pfn, code_window.data(), code_window.size()))
        {
            return false;
        }

        const auto pointers = scan_rip_relative_lea_references(code_window, retrieve_user_pfn, k_expected_pfn_pointer_count);
        if (pointers.size() != k_expected_pfn_pointer_count)
        {
            return false;
        }

        return try_update_client_pfn_arrays_from_addresses(win_emu.memory, win_emu.process, pointers[0], pointers[1], pointers[2]);
    }
}

```

`src/windows-emulator/win32k_userconnect.hpp`:

```hpp
#pragma once

#include "common/platform/process.hpp"
#include "common/platform/user.hpp"
#include "emulator_utils.hpp"

struct process_context;
class windows_emulator;

namespace win32k_userconnect
{
    constexpr uint32_t k_user_server_dll_index = 3;
    constexpr ULONG k_wow64_wndmsg_count = 0x2000;
    constexpr ULONG k_wow64_ime_msg_count = 0x2000;
    constexpr ULONG k_wow64_userconnect_header_size = 0x8;
    constexpr ULONG k_wow64_userconnect_reply_shared_info_offset = sizeof(uint64_t);

    NTSTATUS narrow_wow64_address(uint64_t address, uint32_t& narrowed);
    NTSTATUS resolve_wow64_destination(uint64_t user_connect_ptr, uint64_t user_connect_length, uint32_t& destination);
    NTSTATUS build_wow64_userconnect(const process_context& process, WIN32K_USERCONNECT32& connect);
    bool try_write_wow64_userconnect(memory_interface& memory, uint64_t destination, const WIN32K_USERCONNECT32& connect);
    void populate_user_shared_info(USER_SHAREDINFO& shared, const process_context& process);
    bool try_write_user_shared_info(memory_interface& memory, uint64_t destination, const process_context& process);
    bool try_write_api_port_userconnect_reply(memory_interface& memory, uint64_t reply_base, const process_context& process);
    bool try_update_client_pfn_arrays_from_addresses(memory_interface& memory, process_context& process, uint64_t apfn_client_a,
                                                     uint64_t apfn_client_w, uint64_t apfn_client_worker);
    bool try_bootstrap_client_pfn_arrays_from_ntdll(windows_emulator& win_emu);
}

```

`src/windows-emulator/windows_emulator.cpp`:

```cpp
#include "std_include.hpp"
#include "windows_emulator.hpp"

#include "cpu_context.hpp"

#include <utils/io.hpp>
#include <utils/finally.hpp>
#include <utils/lazy_object.hpp>

#include "exception_dispatch.hpp"
#include "apiset/apiset.hpp"

#include "network/static_socket_factory.hpp"
#include "memory_permission_ext.hpp"

constexpr auto MAX_INSTRUCTIONS_PER_TIME_SLICE = 0x20000;

namespace
{
    void adjust_working_directory(application_settings& app_settings)
    {
        if (!app_settings.working_directory.empty())
        {
            // Do nothing
        }
#ifdef OS_WINDOWS
        else if (app_settings.application.is_relative())
        {
            app_settings.working_directory = std::filesystem::current_path();
        }
#endif
        else
        {
            app_settings.working_directory = app_settings.application.parent();
        }
    }

    void adjust_application(application_settings& app_settings)
    {
        if (app_settings.application.is_relative())
        {
            app_settings.application = app_settings.working_directory / app_settings.application;
        }
    }

    void fixup_application_settings(application_settings& app_settings)
    {
        adjust_working_directory(app_settings);
        adjust_application(app_settings);
    }

    void perform_context_switch_work(windows_emulator& win_emu)
    {
        auto& threads = win_emu.process.threads;
        auto*& active = win_emu.process.active_thread;

        for (auto it = threads.begin(); it != threads.end();)
        {
            if (!it->second.is_terminated() || it->second.ref_count > 0)
            {
                ++it;
                continue;
            }

            if (active == &it->second)
            {
                active = nullptr;
            }

            const auto [new_it, deleted] = threads.erase(it);
            if (!deleted)
            {
                ++it;
            }
            else
            {
                it = new_it;
            }
        }

        auto& devices = win_emu.process.devices;

        // Crappy mechanism to prevent mutation while iterating.
        const auto was_blocked = devices.block_mutation(true);
        const auto _ = utils::finally([&] { devices.block_mutation(was_blocked); });

        for (auto& dev : devices | std::views::values)
        {
            dev.work(win_emu);
        }
    }

    emulator_thread* get_thread_by_id(process_context& process, const uint32_t id)
    {
        for (auto& t : process.threads | std::views::values)
        {
            if (t.id == id)
            {
                return &t;
            }
        }

        return nullptr;
    }

    void dispatch_next_apc(windows_emulator& win_emu, emulator_thread& thread)
    {
        assert(&win_emu.current_thread() == &thread);

        auto& emu = win_emu.emu();
        auto& apcs = thread.pending_apcs;
        if (apcs.empty())
        {
            return;
        }

        thread.setup_if_necessary(win_emu.emu(), win_emu.process);

        win_emu.callbacks.on_generic_activity("APC Dispatch");

        const auto next_apx = apcs.front();
        apcs.erase(apcs.begin());

        struct
        {
            CONTEXT64 context{};
            CONTEXT_EX context_ex{};
            KCONTINUE_ARGUMENT continue_argument{};
        } stack_layout;

        static_assert(offsetof(decltype(stack_layout), continue_argument) == 0x4F0);

        stack_layout.context.P1Home = next_apx.apc_argument1;
        stack_layout.context.P2Home = next_apx.apc_argument2;
        stack_layout.context.P3Home = next_apx.apc_argument3;
        stack_layout.context.P4Home = next_apx.apc_routine;

        stack_layout.continue_argument.ContinueFlags |= KCONTINUE_FLAG_TEST_ALERT;

        auto& ctx = stack_layout.context;
        ctx.ContextFlags = CONTEXT64_ALL;
        cpu_context::save(emu, ctx);

        const auto initial_sp = emu.reg(x86_register::rsp);
        const auto new_sp = align_down(initial_sp - sizeof(stack_layout), 0x100);

        emu.write_memory(new_sp, stack_layout);

        emu.reg(x86_register::rsp, new_sp);
        emu.reg(x86_register::rip, win_emu.process.ki_user_apc_dispatcher);
    }

    bool switch_to_thread(windows_emulator& win_emu, emulator_thread& thread, const bool force = false)
    {
        if (thread.is_terminated())
        {
            return false;
        }

        auto& emu = win_emu.emu();
        auto& context = win_emu.process;

        const auto is_ready = thread.is_thread_ready(context, win_emu.clock());
        const auto can_dispatch_apcs = thread.apc_alertable && !thread.pending_apcs.empty();

        if (!is_ready && !force && !can_dispatch_apcs)
        {
            return false;
        }

        auto* active_thread = context.active_thread;

        if (active_thread != &thread)
        {
            if (active_thread)
            {
                win_emu.callbacks.on_thread_switch(*active_thread, thread);
                active_thread->save(emu);
            }

            context.active_thread = &thread;

            thread.restore(emu);
        }

        thread.setup_if_necessary(emu, context);

        if (can_dispatch_apcs)
        {
            thread.mark_as_ready(STATUS_USER_APC);
            dispatch_next_apc(win_emu, thread);
        }

        thread.apc_alertable = false;
        return true;
    }

    bool switch_to_thread(windows_emulator& win_emu, const handle thread_handle)
    {
        auto* thread = win_emu.process.threads.get(thread_handle);
        if (!thread)
        {
            throw std::runtime_error("Bad thread handle");
        }

        return switch_to_thread(win_emu, *thread);
    }

    bool switch_to_next_thread(windows_emulator& win_emu)
    {
        perform_context_switch_work(win_emu);

        auto& context = win_emu.process;

        bool next_thread = false;

        for (auto& t : context.threads | std::views::values)
        {
            if (next_thread)
            {
                if (switch_to_thread(win_emu, t))
                {
                    return true;
                }

                continue;
            }

            if (&t == context.active_thread)
            {
                next_thread = true;
            }
        }

        for (auto& t : context.threads | std::views::values)
        {
            if (switch_to_thread(win_emu, t))
            {
                return true;
            }
        }

        return false;
    }

    struct instruction_tick_clock : utils::tick_clock
    {
        const uint64_t* instructions_{};

        instruction_tick_clock(const uint64_t& instructions, const system_time_point system_start = {},
                               const steady_time_point steady_start = {})
            : tick_clock(1000, system_start, steady_start),
              instructions_(&instructions)
        {
        }

        uint64_t ticks() override
        {
            return *this->instructions_;
        }
    };

    std::unique_ptr<utils::clock> get_clock(emulator_interfaces& interfaces, const uint64_t& instructions, const bool use_relative_time)
    {
        if (interfaces.clock)
        {
            return std::move(interfaces.clock);
        }

        if (use_relative_time)
        {
            return std::make_unique<instruction_tick_clock>(instructions);
        }

        return std::make_unique<utils::clock>();
    }
    std::unique_ptr<network::socket_factory> get_socket_factory(emulator_interfaces& interfaces)
    {
        if (interfaces.socket_factory)
        {
            return std::move(interfaces.socket_factory);
        }

#ifdef OS_EMSCRIPTEN
        return network::create_static_socket_factory();
#else
        return std::make_unique<network::socket_factory>();
#endif
    }
}

windows_emulator::windows_emulator(std::unique_ptr<x86_64_emulator> emu, application_settings app_settings,
                                   const emulator_settings& settings, emulator_callbacks callbacks, emulator_interfaces interfaces)
    : windows_emulator(std::move(emu), settings, std::move(callbacks), std::move(interfaces))
{
    fixup_application_settings(app_settings);
    this->application_settings_ = std::move(app_settings);
}

windows_emulator::windows_emulator(std::unique_ptr<x86_64_emulator> emu, const emulator_settings& settings, emulator_callbacks callbacks,
                                   emulator_interfaces interfaces)
    : emu_(std::move(emu)),
      clock_(get_clock(interfaces, this->executed_instructions_, settings.use_relative_time)),
      socket_factory_(get_socket_factory(interfaces)),
      emulation_root{settings.emulation_root.empty() ? settings.emulation_root : absolute(settings.emulation_root)},
      callbacks(std::move(callbacks)),
      file_sys(emulation_root.empty() ? emulation_root : emulation_root / "filesys"),
      memory(*this->emu_),
      registry(emulation_root.empty() ? settings.registry_directory : emulation_root / "registry"),
      mod_manager(memory, file_sys, this->callbacks),
      process(*this->emu_, memory, *this->clock_, this->callbacks),
      use_relative_time_(settings.use_relative_time)
{
#ifndef OS_WINDOWS
    if (this->emulation_root.empty())
    {
        throw std::runtime_error("Emulation root directory can not be empty!");
    }
#endif

    for (const auto& mapping : settings.path_mappings)
    {
        this->file_sys.map(mapping.first, mapping.second);
    }

    for (const auto& mapping : settings.port_mappings)
    {
        this->map_port(mapping.first, mapping.second);
    }

    this->setup_hooks();
}

windows_emulator::~windows_emulator() = default;

void windows_emulator::setup_process_if_necessary()
{
    if (!this->application_settings_)
    {
        return;
    }

    auto app_settings = std::move(*this->application_settings_);
    this->application_settings_ = {};

    this->setup_process(app_settings);
}

void windows_emulator::setup_process(const application_settings& app_settings)
{
    const auto& emu = this->emu();
    auto& context = this->process;

    this->version.load_from_registry(this->registry, this->log);

    this->mod_manager.map_main_modules(app_settings.application, this->version, context, this->log);

    const auto* executable = this->mod_manager.executable;
    const auto* ntdll = this->mod_manager.ntdll;
    const auto* win32u = this->mod_manager.win32u;

    const auto apiset_data = apiset::obtain(this->emulation_root);

    this->process.setup(this->emu(), this->memory, this->registry, this->file_sys, this->version, app_settings, *executable, *ntdll,
                        apiset_data, this->mod_manager.wow64_modules_.ntdll32);

    const auto ntdll_data = emu.read_memory(ntdll->image_base, static_cast<size_t>(ntdll->size_of_image));
    const auto win32u_data = emu.read_memory(win32u->image_base, static_cast<size_t>(win32u->size_of_image));

    this->dispatcher.setup(ntdll->exports, ntdll_data, win32u->exports, win32u_data);

    const auto main_thread_id = context.create_thread(this->memory, this->mod_manager.executable->entry_point, 0,
                                                      this->mod_manager.executable->size_of_stack_reserve, 0, true);

    switch_to_thread(*this, main_thread_id);
}

void windows_emulator::yield_thread(const bool alertable)
{
    this->switch_thread_ = true;
    this->current_thread().apc_alertable = alertable;
    this->emu().stop();
}

bool windows_emulator::perform_thread_switch()
{
    const auto needed_switch = std::exchange(this->switch_thread_, false);

    this->switch_thread_ = false;
    while (!switch_to_next_thread(*this))
    {
        if (this->use_relative_time_)
        {
            this->executed_instructions_ += MAX_INSTRUCTIONS_PER_TIME_SLICE;
        }
        else
        {
            std::this_thread::sleep_for(1ms);
        }

        if (this->should_stop)
        {
            this->switch_thread_ = needed_switch;
            return false;
        }
    }

    return true;
}

bool windows_emulator::activate_thread(const uint32_t id)
{
    auto* thread = get_thread_by_id(this->process, id);
    if (!thread)
    {
        return false;
    }

    return switch_to_thread(*this, *thread, true);
}

void windows_emulator::on_instruction_execution(const uint64_t address)
{
    auto& thread = this->current_thread();

    if (!thread.callback_stack.empty() && address == this->process.zw_callback_return)
    {
        thread.callback_return_rax = this->emu().reg<uint64_t>(x86_register::rax);
    }

    ++this->executed_instructions_;
    const auto thread_insts = ++thread.executed_instructions;
    if (thread_insts % MAX_INSTRUCTIONS_PER_TIME_SLICE == 0)
    {
        this->yield_thread();
    }

    thread.previous_ip = thread.current_ip;
    thread.current_ip = this->emu().read_instruction_pointer();

    this->callbacks.on_instruction(address);
}

void windows_emulator::setup_hooks()
{
    this->emu().hook_instruction(x86_hookable_instructions::syscall, [&] {
        this->dispatcher.dispatch(*this);
        return instruction_hook_continuation::skip_instruction;
    });

    this->emu().hook_instruction(x86_hookable_instructions::rdtscp, [&] {
        this->callbacks.on_rdtscp();

        const auto ticks = this->clock_->timestamp_counter();
        this->emu().reg(x86_register::rax, static_cast<uint32_t>(ticks));
        this->emu().reg(x86_register::rdx, static_cast<uint32_t>(ticks >> 32));

        // Return the IA32_TSC_AUX value in RCX (low 32 bits)
        auto tsc_aux = 0; // Need to replace this with proper CPUID later
        this->emu().reg(x86_register::rcx, tsc_aux);

        return instruction_hook_continuation::skip_instruction;
    });

    this->emu().hook_instruction(x86_hookable_instructions::rdtsc, [&] {
        this->callbacks.on_rdtsc();

        const auto ticks = this->clock_->timestamp_counter();
        this->emu().reg(x86_register::rax, static_cast<uint32_t>(ticks));
        this->emu().reg(x86_register::rdx, static_cast<uint32_t>(ticks >> 32));

        return instruction_hook_continuation::skip_instruction;
    });

    // TODO: Unicorn needs this - This should be handled in the backend
    this->emu().hook_instruction(x86_hookable_instructions::invalid, [&] {
        // TODO: Unify icicle & unicorn handling
        dispatch_illegal_instruction_violation(*this);
        return instruction_hook_continuation::skip_instruction; //
    });

    this->emu().hook_interrupt([&](const int interrupt) {
        this->callbacks.on_exception();
        const auto eflags = this->emu().reg<uint32_t>(x86_register::eflags);

        switch (interrupt)
        {
        case 0:
            dispatch_integer_division_by_zero(*this);
            return;
        case 1:
            if ((eflags & 0x100) != 0)
            {
                this->emu().reg(x86_register::eflags, eflags & ~0x100);
            }

            this->callbacks.on_suspicious_activity("Singlestep");
            dispatch_single_step(*this);
            return;
        case 3:
            this->callbacks.on_suspicious_activity("Breakpoint");
            dispatch_breakpoint(*this);
            return;
        case 6:
            this->callbacks.on_suspicious_activity("Illegal instruction");
            dispatch_illegal_instruction_violation(*this);
            return;
        case 45:
            this->callbacks.on_suspicious_activity("DbgPrint");
            dispatch_breakpoint(*this);
            return;
        default:
            if (this->callbacks.on_generic_activity)
            {
                this->callbacks.on_generic_activity("Interrupt " + std::to_string(interrupt));
            }

            break;
        }
    });

    this->emu().hook_memory_violation(
        [&](const uint64_t address, const size_t size, const memory_operation operation, const memory_violation_type type) {
            if (this->emu().reg<uint16_t>(x86_register::cs) == 0x33)
            {
                // loading gs selector only works in 64-bit mode
                const auto required_gs_base = this->current_thread().gs_segment->get_base();
                const auto actual_gs_base = this->emu().get_segment_base(x86_register::gs);
                if (actual_gs_base != required_gs_base)
                {
                    this->emu().set_segment_base(x86_register::gs, required_gs_base);
                    return memory_violation_continuation::restart;
                }
            }

            auto region = this->memory.get_region_info(address);
            if (region.permissions.is_guarded())
            {
                // Unset the GUARD_PAGE flag and dispatch a STATUS_GUARD_PAGE_VIOLATION
                this->memory.protect_memory(region.allocation_base, region.length, region.permissions & ~memory_permission_ext::guard);
                dispatch_guard_page_violation(*this, address, operation);
            }
            else
            {
                this->callbacks.on_memory_violate(address, size, operation, type);
                dispatch_access_violation(*this, address, operation);
            }

            return memory_violation_continuation::resume;
        });

    this->emu().hook_memory_execution([&](const uint64_t address) {
        this->on_instruction_execution(address); //
    });
}

void windows_emulator::start(size_t count)
{
    this->should_stop = false;
    this->setup_process_if_necessary();

    const auto use_count = count > 0;
    const auto start_instructions = this->executed_instructions_;
    const auto target_instructions = start_instructions + count;

    while (!this->should_stop)
    {
        if (this->switch_thread_ || !this->current_thread().is_thread_ready(this->process, this->clock()))
        {
            if (!this->perform_thread_switch())
            {
                break;
            }
        }

        this->emu().start(count);

        if (!this->switch_thread_ && !this->emu().has_violation())
        {
            break;
        }

        if (use_count)
        {
            const auto current_instructions = this->executed_instructions_;

            if (current_instructions >= target_instructions)
            {
                break;
            }

            count = static_cast<size_t>(target_instructions - current_instructions);
        }
    }
}

void windows_emulator::stop()
{
    this->should_stop = true;
    this->emu().stop();
}

void windows_emulator::register_factories(utils::buffer_deserializer& buffer)
{
    buffer.register_factory<memory_manager_wrapper>([this] {
        return memory_manager_wrapper{this->memory}; //
    });

    buffer.register_factory<module_manager_wrapper>([this] {
        return module_manager_wrapper{this->mod_manager}; //
    });

    buffer.register_factory<x64_emulator_wrapper>([this] {
        return x64_emulator_wrapper{this->emu()}; //
    });

    buffer.register_factory<windows_emulator_wrapper>([this] {
        return windows_emulator_wrapper{*this}; //
    });

    buffer.register_factory<clock_wrapper>([this] {
        return clock_wrapper{this->clock()}; //
    });

    buffer.register_factory<socket_factory_wrapper>([this] {
        return socket_factory_wrapper{this->socket_factory()}; //
    });

    buffer.register_factory<window>([this] {
        return window{this->emu()}; //
    });
}

void windows_emulator::serialize(utils::buffer_serializer& buffer) const
{
    buffer.write_optional(this->application_settings_);
    buffer.write(this->executed_instructions_);
    buffer.write(this->switch_thread_);
    buffer.write(this->use_relative_time_);

    this->version.serialize(buffer);

    this->emu().serialize_state(buffer, false);
    this->memory.serialize_memory_state(buffer, false);
    this->mod_manager.serialize(buffer);
    this->dispatcher.serialize(buffer);
    this->process.serialize(buffer);
}

void windows_emulator::deserialize(utils::buffer_deserializer& buffer)
{
    this->register_factories(buffer);

    buffer.read_optional(this->application_settings_);
    buffer.read(this->executed_instructions_);
    buffer.read(this->switch_thread_);

    const auto old_relative_time = this->use_relative_time_;
    buffer.read(this->use_relative_time_);

    if (old_relative_time != this->use_relative_time_)
    {
        throw std::runtime_error("Can not deserialize emulator with different time dimensions");
    }

    this->version.deserialize(buffer);

    this->memory.unmap_all_memory();

    this->emu().deserialize_state(buffer, false);
    this->memory.deserialize_memory_state(buffer, false);
    this->mod_manager.deserialize(buffer);
    this->dispatcher.deserialize(buffer);
    this->process.deserialize(buffer);
}

void windows_emulator::save_snapshot()
{
    utils::buffer_serializer buffer{};

    buffer.write_optional(this->application_settings_);
    buffer.write(this->executed_instructions_);
    buffer.write(this->switch_thread_);

    this->version.serialize(buffer);

    this->emu().serialize_state(buffer, true);
    this->memory.serialize_memory_state(buffer, true);
    this->mod_manager.serialize(buffer);
    this->process.serialize(buffer);

    this->process_snapshot_ = buffer.move_buffer();

    // TODO: Make process copyable
    // this->process_snapshot_ = this->process;
}

void windows_emulator::restore_snapshot()
{
    if (this->process_snapshot_.empty())
    {
        assert(false);
        return;
    }

    utils::buffer_deserializer buffer{this->process_snapshot_};

    this->register_factories(buffer);

    buffer.read_optional(this->application_settings_);
    buffer.read(this->executed_instructions_);
    buffer.read(this->switch_thread_);

    this->version.deserialize(buffer);

    this->emu().deserialize_state(buffer, true);
    this->memory.deserialize_memory_state(buffer, true);
    this->mod_manager.deserialize(buffer);
    this->process.deserialize(buffer);
    // this->process = *this->process_snapshot_;
}

```

`src/windows-emulator/windows_emulator.hpp`:

```hpp
#pragma once
#include "std_include.hpp"

#include <arch_emulator.hpp>

#include <utils/function.hpp>

#include "syscall_dispatcher.hpp"
#include "process_context.hpp"
#include "logger.hpp"
#include "file_system.hpp"
#include "memory_manager.hpp"
#include "module/module_manager.hpp"
#include "network/socket_factory.hpp"
#include "version/windows_version_manager.hpp"

struct io_device;

#define opt_func utils::optional_function

struct emulator_callbacks : module_manager::callbacks, process_context::callbacks
{
    using continuation = instruction_hook_continuation;

    opt_func<void()> on_exception{};

    opt_func<void(uint64_t address, uint64_t length, memory_permission)> on_memory_protect{};
    opt_func<void(uint64_t address, uint64_t length, memory_permission, bool commit)> on_memory_allocate{};
    opt_func<void(uint64_t address, uint64_t length, memory_operation, memory_violation_type type)> on_memory_violate{};

    opt_func<void()> on_rdtsc{};
    opt_func<void()> on_rdtscp{};
    opt_func<continuation(uint32_t syscall_id, std::string_view syscall_name)> on_syscall{};
    opt_func<void(std::string_view data)> on_stdout{};
    opt_func<void(std::string_view type, std::u16string_view name)> on_generic_access{};
    opt_func<void(std::string_view description)> on_generic_activity{};
    opt_func<void(std::string_view description)> on_suspicious_activity{};
    opt_func<void(std::string_view message)> on_debug_string{};
    opt_func<void(uint64_t address)> on_instruction{};
    opt_func<void(io_device& device, std::u16string_view device_name, ULONG code)> on_ioctrl{};
};

struct application_settings
{
    windows_path application{};
    windows_path working_directory{};
    std::vector<std::u16string> arguments{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->application);
        buffer.write(this->working_directory);
        buffer.write_vector(this->arguments);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->application);
        buffer.read(this->working_directory);
        buffer.read_vector(this->arguments);
    }
};

struct emulator_settings
{
    bool disable_logging{false};
    bool use_relative_time{false};

    std::filesystem::path emulation_root{};
    std::filesystem::path registry_directory{"./registry"};

    std::unordered_map<uint16_t, uint16_t> port_mappings{};
    std::unordered_map<windows_path, std::filesystem::path> path_mappings{};
};

struct emulator_interfaces
{
    std::unique_ptr<utils::clock> clock{};
    std::unique_ptr<network::socket_factory> socket_factory{};
};

class windows_emulator
{
    uint64_t executed_instructions_{0};
    std::optional<application_settings> application_settings_{};

    std::unique_ptr<x86_64_emulator> emu_{};
    std::unique_ptr<utils::clock> clock_{};
    std::unique_ptr<network::socket_factory> socket_factory_{};

  public:
    std::filesystem::path emulation_root{};
    emulator_callbacks callbacks{};
    logger log{};
    file_system file_sys;
    memory_manager memory;
    registry_manager registry{};
    windows_version_manager version{};
    module_manager mod_manager;
    process_context process;
    syscall_dispatcher dispatcher;

    windows_emulator(std::unique_ptr<x86_64_emulator> emu, const emulator_settings& settings = {}, emulator_callbacks callbacks = {},
                     emulator_interfaces interfaces = {});
    windows_emulator(std::unique_ptr<x86_64_emulator> emu, application_settings app_settings, const emulator_settings& settings = {},
                     emulator_callbacks callbacks = {}, emulator_interfaces interfaces = {});

    windows_emulator(windows_emulator&&) = delete;
    windows_emulator(const windows_emulator&) = delete;
    windows_emulator& operator=(windows_emulator&&) = delete;
    windows_emulator& operator=(const windows_emulator&) = delete;

    ~windows_emulator();

    x86_64_emulator& emu()
    {
        return *this->emu_;
    }

    const x86_64_emulator& emu() const
    {
        return *this->emu_;
    }

    utils::clock& clock()
    {
        return *this->clock_;
    }

    const utils::clock& clock() const
    {
        return *this->clock_;
    }

    network::socket_factory& socket_factory()
    {
        return *this->socket_factory_;
    }

    const network::socket_factory& socket_factory() const
    {
        return *this->socket_factory_;
    }

    emulator_thread& current_thread() const
    {
        if (!this->process.active_thread)
        {
            throw std::runtime_error("No active thread!");
        }

        return *this->process.active_thread;
    }

    uint64_t get_executed_instructions() const
    {
        return this->executed_instructions_;
    }

    void setup_process_if_necessary();

    void start(size_t count = 0);
    void stop();

    void serialize(utils::buffer_serializer& buffer) const;
    void deserialize(utils::buffer_deserializer& buffer);

    void save_snapshot();
    void restore_snapshot();

    uint16_t get_host_port(const uint16_t emulator_port) const
    {
        const auto entry = this->port_mappings_.find(emulator_port);
        if (entry == this->port_mappings_.end())
        {
            return emulator_port;
        }

        return entry->second;
    }

    uint16_t get_emulator_port(const uint16_t host_port) const
    {
        for (const auto& mapping : this->port_mappings_)
        {
            if (mapping.second == host_port)
            {
                return mapping.first;
            }
        }

        return host_port;
    }

    void map_port(const uint16_t emulator_port, const uint16_t host_port)
    {
        if (emulator_port != host_port)
        {
            this->port_mappings_[emulator_port] = host_port;
            return;
        }

        const auto entry = this->port_mappings_.find(emulator_port);
        if (entry != this->port_mappings_.end())
        {
            this->port_mappings_.erase(entry);
        }
    }

    void yield_thread(bool alertable = false);
    bool perform_thread_switch();
    bool activate_thread(uint32_t id);

  private:
    bool switch_thread_{false};
    bool use_relative_time_{false}; // TODO: Get rid of that
    std::atomic_bool should_stop{false};

    std::unordered_map<uint16_t, uint16_t> port_mappings_{};

    std::vector<std::byte> process_snapshot_{};
    // std::optional<process_context> process_snapshot_{};

    void setup_hooks();
    void setup_process(const application_settings& app_settings);
    void on_instruction_execution(uint64_t address);

    void register_factories(utils::buffer_deserializer& buffer);
};

```

`src/windows-emulator/windows_objects.hpp`:

```hpp
#pragma once

#include "handles.hpp"

#include <serialization_helper.hpp>
#include <utils/file_handle.hpp>
#include <platform/synchronisation.hpp>
#include <platform/win_pefile.hpp>

struct timer : ref_counted_object
{
    std::u16string name{};

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
    }
};

struct event : ref_counted_object
{
    bool signaled{};
    EVENT_TYPE type{};
    std::u16string name{};

    bool is_signaled()
    {
        const auto res = this->signaled;

        if (this->type == SynchronizationEvent)
        {
            this->signaled = false;
        }

        return res;
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->signaled);
        buffer.write(this->type);
        buffer.write(this->name);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->signaled);
        buffer.read(this->type);
        buffer.read(this->name);
    }
};

template <typename GuestType>
struct user_object : ref_counted_object
{
    using guest_type = GuestType;
    emulator_object<GuestType> guest;

    user_object(memory_interface& memory)
        : guest(memory)
    {
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->guest);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->guest);
    }
};

struct window : user_object<USER_WINDOW>
{
    uint32_t thread_id{};
    hwnd handle{};
    std::u16string name{};
    std::u16string class_name{};
    int32_t width{};
    int32_t height{};
    int32_t x{};
    int32_t y{};
    uint32_t ex_style{};
    uint32_t style{};
    std::map<std::u16string, uint64_t> props{};
    emulator_pointer wnd_proc{};

    window(memory_interface& memory)
        : user_object(memory)
    {
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        user_object::serialize_object(buffer);
        buffer.write(this->thread_id);
        buffer.write(this->handle);
        buffer.write(this->name);
        buffer.write(this->class_name);
        buffer.write(this->width);
        buffer.write(this->height);
        buffer.write(this->x);
        buffer.write(this->y);
        buffer.write(this->ex_style);
        buffer.write(this->style);
        buffer.write_map(this->props);
        buffer.write(this->wnd_proc);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        user_object::deserialize_object(buffer);
        buffer.read(this->thread_id);
        buffer.read(this->handle);
        buffer.read(this->name);
        buffer.read(this->class_name);
        buffer.read(this->width);
        buffer.read(this->height);
        buffer.read(this->x);
        buffer.read(this->y);
        buffer.read(this->ex_style);
        buffer.read(this->style);
        buffer.read_map(this->props);
        buffer.read(this->wnd_proc);
    }
};

struct desktop : ref_counted_object
{
    std::u16string name{};
    uint64_t mapped_object{};

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->mapped_object);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->mapped_object);
    }
};

struct mutant : ref_counted_object
{
    uint32_t locked_count{0};
    uint32_t owning_thread_id{};
    std::u16string name{};

    bool try_lock(const uint32_t thread_id)
    {
        if (this->locked_count == 0)
        {
            ++this->locked_count;
            this->owning_thread_id = thread_id;
            return true;
        }

        if (this->owning_thread_id != thread_id)
        {
            return false;
        }

        ++this->locked_count;
        return true;
    }

    std::pair<uint32_t, bool> release(const uint32_t thread_id)
    {
        const auto old_count = this->locked_count;

        if (this->locked_count <= 0 || this->owning_thread_id != thread_id)
        {
            return {old_count, false};
        }

        --this->locked_count;
        return {old_count, true};
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->locked_count);
        buffer.write(this->owning_thread_id);
        buffer.write(this->name);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->locked_count);
        buffer.read(this->owning_thread_id);
        buffer.read(this->name);
    }
};

struct file_entry
{
    std::filesystem::path file_path{};
    uint64_t file_size{};
    bool is_directory{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->file_path);
        buffer.write(this->file_size);
        buffer.write(this->is_directory);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->file_path);
        buffer.read(this->file_size);
        buffer.read(this->is_directory);
    }
};

struct file_enumeration_state
{
    size_t current_index{0};
    std::vector<file_entry> files{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->current_index);
        buffer.write_vector(this->files);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->current_index);
        buffer.read_vector(this->files);
    }
};

struct file : ref_counted_object
{
    utils::file_handle handle{};
    std::u16string name{};
    std::u16string open_mode{};
    std::filesystem::path host_path{};
    std::optional<file_enumeration_state> enumeration_state{};

    bool is_file() const
    {
        return this->handle;
    }

    bool is_directory() const
    {
        return !this->is_file();
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->open_mode);
        buffer.write(this->host_path.u16string());
        buffer.write_optional(this->enumeration_state);

        const auto has_handle = static_cast<bool>(this->handle);
        buffer.write(has_handle);

        if (has_handle)
        {
            buffer.write(this->handle);
        }
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->open_mode);
        this->host_path = buffer.read<std::u16string>();
        buffer.read_optional(this->enumeration_state);

        const auto has_handle = buffer.read<bool>();

        this->handle = {};

        if (has_handle)
        {
#if defined(OS_WINDOWS)
            FILE* native_file = _wfopen(this->host_path.c_str(), reinterpret_cast<const wchar_t*>(this->open_mode.c_str()));
#else
            FILE* native_file = fopen(u16_to_u8(this->host_path.u16string()).c_str(), u16_to_u8(this->open_mode).c_str());
#endif

            if (native_file)
            {
                this->handle = native_file;
                buffer.read(this->handle);
            }
            else
            {
                throw std::runtime_error("Failed to reobtain file handle");
            }
        }
    }
};

struct section : ref_counted_object
{
    std::u16string name{};
    std::u16string file_name{};
    uint64_t maximum_size{};
    uint32_t section_page_protection{};
    uint32_t allocation_attributes{};
    std::optional<winpe::pe_image_basic_info> cached_image_info{};

    bool is_image() const
    {
        return this->allocation_attributes & SEC_IMAGE;
    }

    void cache_image_info_from_filedata(const std::vector<std::byte>& file_data)
    {
        winpe::pe_image_basic_info info{};

        // Read the PE magic to determine if it's 32-bit or 64-bit
        bool parsed = false;
        if (file_data.size() >= sizeof(PEDosHeader_t))
        {
            const auto* dos_header = reinterpret_cast<const PEDosHeader_t*>(file_data.data());
            if (dos_header->e_magic == PEDosHeader_t::k_Magic &&
                file_data.size() >= dos_header->e_lfanew + sizeof(uint32_t) + sizeof(PEFileHeader_t) + sizeof(uint16_t))
            {
                const auto* magic_ptr =
                    reinterpret_cast<const uint16_t*>(file_data.data() + dos_header->e_lfanew + sizeof(uint32_t) + sizeof(PEFileHeader_t));
                const uint16_t magic = *magic_ptr;

                // Parse based on the actual PE type
                if (magic == PEOptionalHeader_t<std::uint32_t>::k_Magic)
                {
                    parsed = winpe::parse_pe_headers<uint32_t>(file_data, info);
                }
                else if (magic == PEOptionalHeader_t<std::uint64_t>::k_Magic)
                {
                    parsed = winpe::parse_pe_headers<uint64_t>(file_data, info);
                }
            }
        }

        if (parsed)
        {
            this->cached_image_info = info;
        }
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->file_name);
        buffer.write(this->maximum_size);
        buffer.write(this->section_page_protection);
        buffer.write(this->allocation_attributes);
        buffer.write_optional<winpe::pe_image_basic_info>(this->cached_image_info);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->file_name);
        buffer.read(this->maximum_size);
        buffer.read(this->section_page_protection);
        buffer.read(this->allocation_attributes);
        buffer.read_optional(this->cached_image_info);
    }
};

struct semaphore : ref_counted_object
{
    std::u16string name{};
    uint32_t current_count{};
    uint32_t max_count{};

    bool try_lock()
    {
        if (this->current_count > 0)
        {
            --this->current_count;
            return true;
        }

        return false;
    }

    std::pair<uint32_t, bool> release(const uint32_t release_count)
    {
        const auto old_count = this->current_count;

        if (this->current_count + release_count > this->max_count)
        {
            return {old_count, false};
        }

        this->current_count += release_count;

        return {old_count, true};
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->current_count);
        buffer.write(this->max_count);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->current_count);
        buffer.read(this->max_count);
    }
};

struct io_completion_message
{
    uint64_t key_context{};
    uint64_t apc_context{};
    IO_STATUS_BLOCK<EmulatorTraits<Emu64>> io_status_block{};
    handle wait_packet_handle{};

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write(this->key_context);
        buffer.write(this->apc_context);
        buffer.write(this->io_status_block);
        buffer.write(this->wait_packet_handle);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read(this->key_context);
        buffer.read(this->apc_context);
        buffer.read(this->io_status_block);
        buffer.read(this->wait_packet_handle);
    }
};

struct io_completion : ref_counted_object
{
    std::u16string name{};
    uint32_t number_of_concurrent_threads{};
    std::vector<io_completion_message> queue{};

    void enqueue(const io_completion_message& message)
    {
        this->queue.push_back(message);
    }

    bool dequeue(io_completion_message& out_message)
    {
        if (this->queue.empty())
        {
            return false;
        }

        out_message = this->queue.front();
        this->queue.erase(this->queue.begin());
        return true;
    }

    bool remove_by_wait_packet(const handle wait_packet_handle)
    {
        const auto entry = std::find_if(this->queue.begin(), this->queue.end(), [&](const io_completion_message& message) {
            return message.wait_packet_handle == wait_packet_handle;
        });

        if (entry == this->queue.end())
        {
            return false;
        }

        this->queue.erase(entry);
        return true;
    }

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->number_of_concurrent_threads);
        buffer.write_vector(this->queue);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->number_of_concurrent_threads);
        buffer.read_vector(this->queue);
    }
};

struct wait_completion_packet : ref_counted_object
{
    std::u16string name{};
    handle io_completion_handle{};
    handle target_object_handle{};
    uint64_t key_context{};
    uint64_t apc_context{};
    IO_STATUS_BLOCK<EmulatorTraits<Emu64>> io_status_block{};
    uint64_t io_status_information{};
    bool associated{};
    bool queued_completion{};

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->io_completion_handle);
        buffer.write(this->target_object_handle);
        buffer.write(this->key_context);
        buffer.write(this->apc_context);
        buffer.write(this->io_status_block);
        buffer.write(this->io_status_information);
        buffer.write(this->associated);
        buffer.write(this->queued_completion);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->io_completion_handle);
        buffer.read(this->target_object_handle);
        buffer.read(this->key_context);
        buffer.read(this->apc_context);
        buffer.read(this->io_status_block);
        buffer.read(this->io_status_information);
        buffer.read(this->associated);
        buffer.read(this->queued_completion);
    }
};

struct worker_factory : ref_counted_object
{
    std::u16string name{};
    handle io_completion_handle{};
    handle worker_process_handle{};
    uint64_t start_routine{};
    uint64_t start_parameter{};
    uint32_t max_thread_count{};
    uint64_t stack_reserve{};
    uint64_t stack_commit{};
    bool shutdown{};

    int64_t timeout{};
    int64_t retry_timeout{};
    int64_t idle_timeout{};
    uint32_t binding_count{};
    uint32_t thread_minimum{};
    uint32_t thread_maximum{};
    uint32_t paused{};
    uint32_t thread_base_priority{};
    uint32_t timeout_waiters{};
    uint32_t flags{};
    uint32_t thread_soft_maximum{};

    uint32_t last_info_class{};
    uint32_t last_info_length{};
    uint64_t last_info_value{};
    std::vector<handle> worker_threads{};

    void serialize_object(utils::buffer_serializer& buffer) const override
    {
        buffer.write(this->name);
        buffer.write(this->io_completion_handle);
        buffer.write(this->worker_process_handle);
        buffer.write(this->start_routine);
        buffer.write(this->start_parameter);
        buffer.write(this->max_thread_count);
        buffer.write(this->stack_reserve);
        buffer.write(this->stack_commit);
        buffer.write(this->shutdown);
        buffer.write(this->timeout);
        buffer.write(this->retry_timeout);
        buffer.write(this->idle_timeout);
        buffer.write(this->binding_count);
        buffer.write(this->thread_minimum);
        buffer.write(this->thread_maximum);
        buffer.write(this->paused);
        buffer.write(this->thread_base_priority);
        buffer.write(this->timeout_waiters);
        buffer.write(this->flags);
        buffer.write(this->thread_soft_maximum);
        buffer.write(this->last_info_class);
        buffer.write(this->last_info_length);
        buffer.write(this->last_info_value);
        buffer.write_vector(this->worker_threads);
    }

    void deserialize_object(utils::buffer_deserializer& buffer) override
    {
        buffer.read(this->name);
        buffer.read(this->io_completion_handle);
        buffer.read(this->worker_process_handle);
        buffer.read(this->start_routine);
        buffer.read(this->start_parameter);
        buffer.read(this->max_thread_count);
        buffer.read(this->stack_reserve);
        buffer.read(this->stack_commit);
        buffer.read(this->shutdown);
        buffer.read(this->timeout);
        buffer.read(this->retry_timeout);
        buffer.read(this->idle_timeout);
        buffer.read(this->binding_count);
        buffer.read(this->thread_minimum);
        buffer.read(this->thread_maximum);
        buffer.read(this->paused);
        buffer.read(this->thread_base_priority);
        buffer.read(this->timeout_waiters);
        buffer.read(this->flags);
        buffer.read(this->thread_soft_maximum);
        buffer.read(this->last_info_class);
        buffer.read(this->last_info_length);
        buffer.read(this->last_info_value);
        buffer.read_vector(this->worker_threads);
    }
};

```

`src/windows-emulator/windows_path.hpp`:

```hpp
#pragma once

#include <list>
#include <optional>
#include <filesystem>
#include <utils/string.hpp>

#include <serialization.hpp>

namespace windows_path_detail
{
    constexpr std::u16string_view unc_prefix = u"\\??\\";

    inline std::u16string_view strip_unc_prefix(const std::u16string_view path)
    {
        if (!path.starts_with(unc_prefix))
        {
            return path;
        }

        return path.substr(unc_prefix.size());
    }

    inline bool is_slash(const char16_t chr)
    {
        return chr == u'\\' || chr == u'/';
    }
}

class windows_path
{
  public:
    friend std::hash<windows_path>;

    windows_path() = default;

    windows_path(const std::filesystem::path& path)
    {
        const auto full_path = path.u16string();
        const auto canonical_path = windows_path_detail::strip_unc_prefix(full_path);

        std::u16string folder{};

        for (const auto chr : canonical_path)
        {
            if (chr == u':' && this->folders_.empty() && !this->drive_.has_value() && folder.size() == 1)
            {
                this->drive_ = static_cast<char>(folder[0]);
                folder.clear();
                continue;
            }

            if (windows_path_detail::is_slash(chr))
            {
                if (folder.empty())
                {
                    continue;
                }

                this->folders_.push_back(std::move(folder));
                folder = {};
                continue;
            }

            folder.push_back(chr);
        }

        if (!folder.empty())
        {
            this->folders_.push_back(folder);
        }

        this->canonicalize();
    }

    template <typename T>
        requires(!std::is_same_v<std::remove_cvref_t<T>, windows_path> && !std::is_same_v<std::remove_cvref_t<T>, std::filesystem::path> &&
                 !std::is_same_v<std::remove_cvref_t<T>, utils::buffer_deserializer>)
    windows_path(T&& path_like)
        : windows_path(std::filesystem::path(std::forward<T>(path_like)))
    {
    }

    windows_path(const std::optional<char> drive, std::list<std::u16string> folders)
        : drive_(drive),
          folders_(std::move(folders))
    {
        this->canonicalize();
    }

    bool is_absolute() const
    {
        return this->drive_.has_value();
    }

    bool is_relative() const
    {
        return !this->is_absolute();
    }

    std::u16string u16string() const
    {
        std::u16string path{};
        if (this->drive_)
        {
            path.push_back(static_cast<char16_t>(*this->drive_));
            path.push_back(u':');
        }

        for (const auto& folder : this->folders_)
        {
            if (!path.empty())
            {
                path.push_back(u'\\');
            }

            path.append(folder);
        }

        if (this->is_absolute() && this->folders_.empty())
        {
            path.push_back(u'\\');
        }

        return path;
    }

    std::string string() const
    {
        return u16_to_u8(this->u16string());
    }

    std::u16string to_unc_path() const
    {
        if (this->is_relative())
        {
            return this->u16string();
        }

        return std::u16string(windows_path_detail::unc_prefix) + this->u16string();
    }

    std::filesystem::path to_portable_path() const
    {
        std::u16string path{};
        if (this->drive_)
        {
            path.push_back(static_cast<char16_t>(*this->drive_));
        }

        for (const auto& folder : this->folders_)
        {
            if (!path.empty())
            {
                path.push_back(u'/');
            }

            path.append(folder);
        }

        return path;
    }

    std::u16string to_device_path() const
    {
        if (is_relative())
        {
            throw std::runtime_error("Device path can not be computed for relative paths!");
        }

        const auto drive_index = this->drive_.value_or('a') - 'a';
        const auto drive_number = std::to_string(drive_index + 1);
        const std::u16string number(drive_number.begin(), drive_number.end());

        std::u16string path = u"\\Device\\HarddiskVolume";
        path.append(number);
        path.push_back(u'\\');
        path.append(this->without_drive().u16string());

        return path;
    }

    std::optional<char> get_drive() const
    {
        return this->drive_;
    }

    windows_path without_drive() const
    {
        return windows_path{std::nullopt, this->folders_};
    }

    windows_path operator/(const windows_path& path) const
    {
        if (path.is_absolute())
        {
            return path;
        }

        auto folders = this->folders_;

        for (const auto& folder : path.folders_)
        {
            folders.push_back(folder);
        }

        return {this->drive_, std::move(folders)};
    }

    windows_path& operator/=(const windows_path& path)
    {
        *this = *this / path;
        return *this;
    }

    windows_path parent() const
    {
        auto folders = this->folders_;
        if (!folders.empty())
        {
            folders.pop_back();
        }

        return {this->drive_, std::move(folders)};
    }

    std::u16string leaf() const
    {
        if (this->folders_.empty())
        {
            return {};
        }

        return this->folders_.back();
    }

    void serialize(utils::buffer_serializer& buffer) const
    {
        buffer.write_optional(this->drive_);
        buffer.write_list(this->folders_);
    }

    void deserialize(utils::buffer_deserializer& buffer)
    {
        buffer.read_optional(this->drive_);
        buffer.read_list(this->folders_);
    }

    bool operator==(const windows_path& other) const
    {
        return this->drive_ == other.drive_ && this->folders_ == other.folders_;
    }

    bool operator!=(const windows_path& other) const
    {
        return !this->operator==(other);
    }

    bool empty() const
    {
        return this->is_relative() && this->folders_.empty();
    }

  private:
    std::optional<char> drive_{};
    std::list<std::u16string> folders_{};

    void canonicalize()
    {
        if (this->drive_.has_value())
        {
            this->drive_ = utils::string::char_to_lower(*this->drive_);
        }

        for (auto& folder : this->folders_)
        {
            for (auto& chr : folder)
            {
                chr = utils::string::char_to_lower(chr);
            }
        }
    }
};

template <>
struct std::hash<windows_path>
{
    std::size_t operator()(const windows_path& k) const noexcept
    {
        auto hash = std::hash<bool>()(k.drive_.has_value());

        if (k.drive_.has_value())
        {
            hash ^= std::hash<char>()(*k.drive_);
        }

        for (const auto& folder : k.folders_)
        {
            hash ^= std::hash<std::u16string>()(folder);
        }

        return hash;
    }
};

```

`src/windows-emulator/wow64_heaven_gate.hpp`:

```hpp
#pragma once

#include <array>
#include <cstddef>
#include <cstdint>

namespace wow64::heaven_gate
{
    inline constexpr uint64_t kCodeBase = 0xFF300000ULL;
    inline constexpr std::size_t kCodeSize = 0x1000ULL;

    inline constexpr uint64_t kStackBase = 0xFF400000ULL;
    inline constexpr std::size_t kStackSize = 0x10000ULL;
    inline constexpr uint64_t kStackTop = kStackBase + kStackSize;

    inline constexpr uint16_t kUserCodeSelector = 0x33;
    inline constexpr uint16_t kUserStackSelector = 0x2B;

    inline constexpr std::array<uint8_t, 19> kTrampolineBytes{0x6A, 0x33, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x83, 0x04, 0x24,
                                                              0x05, 0xCB, 0x52, 0x53, 0x9C, 0x51, 0x50, 0x48, 0xCF};
}

```

`src/windows-gdb-stub/CMakeLists.txt`:

```txt
file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS
  *.cpp
  *.hpp
  *.rc
)

list(SORT SRC_FILES)

add_library(windows-gdb-stub ${SRC_FILES})

momo_assign_source_group(${SRC_FILES})

target_link_libraries(windows-gdb-stub PUBLIC
  gdb-stub
  windows-emulator
)

target_include_directories(windows-gdb-stub INTERFACE "${CMAKE_CURRENT_LIST_DIR}")

momo_strip_target(windows-gdb-stub)

```

`src/windows-gdb-stub/win_x64_gdb_stub_handler.hpp`:

```hpp
#pragma once
#include "x64_gdb_stub_handler.hpp"

#include <atomic>
#include <windows_emulator.hpp>
#include <utils/function.hpp>
#include <utils/string.hpp>

class win_x64_gdb_stub_handler : public x64_gdb_stub_handler
{
  public:
    win_x64_gdb_stub_handler(windows_emulator& win_emu, utils::optional_function<bool()> should_stop = {})
        : x64_gdb_stub_handler(win_emu.emu()),
          win_emu_(&win_emu),
          should_stop_(std::move(should_stop))
    {
        auto hook = [this](mapped_module&) {
            library_stop_pending_ = true;
            win_emu_->stop();
        };

        mod_load_id = win_emu_->callbacks.on_module_load.add(hook);
        mod_unload_id = win_emu_->callbacks.on_module_unload.add(hook);
    }

    ~win_x64_gdb_stub_handler() override
    {
        win_emu_->callbacks.on_module_load.remove(mod_load_id);
        win_emu_->callbacks.on_module_unload.remove(mod_unload_id);
    }

    void on_interrupt() override
    {
        this->win_emu_->stop();
    }

    bool should_stop() override
    {
        return this->should_stop_();
    }

    gdb_stub::action run() override
    {
        try
        {
            this->win_emu_->start();
        }
        catch (const std::exception& e)
        {
            this->win_emu_->log.error("%s\n", e.what());
        }

        return gdb_stub::action::resume;
    }

    gdb_stub::action singlestep() override
    {
        try
        {
            this->win_emu_->start(1);
        }
        catch (const std::exception& e)
        {
            this->win_emu_->log.error("%s\n", e.what());
        }

        return gdb_stub::action::resume;
    }

    uint32_t get_current_thread_id() override
    {
        return this->win_emu_->current_thread().id;
    }

    std::vector<uint32_t> get_thread_ids() override
    {
        const auto& threads = this->win_emu_->process.threads;

        std::vector<uint32_t> ids{};
        ids.reserve(threads.size());

        for (const auto& t : threads | std::views::values)
        {
            if (!t.is_terminated())
            {
                ids.push_back(t.id);
            }
        }

        return ids;
    }

    bool switch_to_thread(const uint32_t thread_id) override
    {
        return this->win_emu_->activate_thread(thread_id);
    }

    std::optional<uint32_t> get_exit_code() override
    {
        const auto status = this->win_emu_->process.exit_status;
        if (!status)
        {
            return std::nullopt;
        }

        return static_cast<uint32_t>(*status);
    }

    std::vector<gdb_stub::library_info> get_libraries() override
    {
        std::vector<gdb_stub::library_info> libs{};
        const auto& mod_manager = this->win_emu_->mod_manager;
        libs.reserve(this->win_emu_->mod_manager.modules().size());
        for (const auto& [base_addr, mod] : mod_manager.modules())
        {
            if (!mod.module_path.empty())
            {
                libs.push_back({.name = mod.module_path.string(), .segment_address = base_addr + 0x1000});
            }
        }

        return libs;
    }

    std::string get_executable_path() override
    {
        const auto& mod_manager = this->win_emu_->mod_manager;
        return mod_manager.executable->module_path.string();
    }

    void reset_library_stop() override
    {
        library_stop_pending_ = false;
    }

    bool should_signal_library() override
    {
        return library_stop_pending_;
    }

  private:
    windows_emulator* win_emu_{};
    utils::optional_function<bool()> should_stop_{};

    // Track library stop events
    std::atomic<bool> library_stop_pending_{true};
    utils::callback_id_type mod_load_id{};
    utils::callback_id_type mod_unload_id{};
};

```

`src/windows-gdb-stub/x64_gdb_stub_handler.hpp`:

```hpp
#pragma once
#include <gdb_stub.hpp>
#include <scoped_hook.hpp>
#include <arch_emulator.hpp>

#include <utils/concurrency.hpp>

#include "x64_register_mapping.hpp"
#include "x64_target_descriptions.hpp"

struct breakpoint_key
{
    uint64_t addr{};
    size_t size{};
    gdb_stub::breakpoint_type type{};

    bool operator==(const breakpoint_key& other) const
    {
        return this->addr == other.addr && this->size == other.size && this->type == other.type;
    }
};

template <>
struct std::hash<breakpoint_key>
{
    std::size_t operator()(const breakpoint_key& k) const noexcept
    {
        return ((std::hash<uint64_t>()(k.addr) ^ (std::hash<size_t>()(k.size) << 1)) >> 1) ^
               (std::hash<size_t>()(static_cast<size_t>(k.type)) << 1);
    }
};

class x64_gdb_stub_handler : public gdb_stub::debugging_handler
{
  public:
    x64_gdb_stub_handler(x86_64_emulator& emu)
        : emu_(&emu)
    {
    }

    ~x64_gdb_stub_handler() override = default;

    gdb_stub::action run() override
    {
        try
        {
            this->emu_->start();
        }
        catch (const std::exception& e)
        {
            puts(e.what());
        }

        return gdb_stub::action::resume;
    }

    gdb_stub::action singlestep() override
    {
        try
        {
            this->emu_->start(1);
        }
        catch (const std::exception& e)
        {
            puts(e.what());
        }

        return gdb_stub::action::resume;
    }

    size_t get_register_count() override
    {
        return gdb_registers.size();
    }

    size_t get_max_register_size() override
    {
        return 512 / 8;
    }

    size_t read_register(const size_t reg, void* data, const size_t max_length) override
    {
        try
        {
            if (reg >= gdb_registers.size())
            {
                return 0;
            }

            const auto real_reg = gdb_registers[reg];

            auto size = this->emu_->read_register(real_reg.reg, data, max_length);

            if (real_reg.offset)
            {
                size -= *real_reg.offset;
                memcpy(data, static_cast<uint8_t*>(data) + *real_reg.offset, size);
            }

            const auto result_size = real_reg.expected_size.value_or(size);

            if (result_size > size)
            {
                memset(static_cast<uint8_t*>(data) + size, 0, result_size - size);
            }

            return result_size;
        }
        catch (...)
        {
            return 0;
        }
    }

    size_t write_register(const size_t reg, const void* data, const size_t size) override
    {
        try
        {
            if (reg >= gdb_registers.size())
            {
                return 0;
            }

            const auto real_reg = gdb_registers[reg];

            size_t written_size = 0;

            if (real_reg.offset)
            {
                std::vector<std::byte> full_data{};
                full_data.resize(this->get_max_register_size());

                written_size = this->emu_->read_register(real_reg.reg, full_data.data(), full_data.size());
                if (written_size < *real_reg.offset)
                {
                    return 0;
                }

                memcpy(full_data.data() + *real_reg.offset, data, written_size - *real_reg.offset);
                this->emu_->write_register(real_reg.reg, full_data.data(), written_size);
                written_size -= *real_reg.offset;
            }
            else
            {
                written_size = this->emu_->write_register(real_reg.reg, data, size);
            }

            return real_reg.expected_size.value_or(written_size);
        }
        catch (...)
        {
            return 0;
        }
    }

    bool read_memory(const uint64_t address, void* data, const size_t length) override
    {
        return this->emu_->try_read_memory(address, data, length);
    }

    bool write_memory(const uint64_t address, const void* data, const size_t length) override
    {
        try
        {
            this->emu_->write_memory(address, data, length);
            return true;
        }
        catch (...)
        {
            return false;
        }
    }

    bool set_breakpoint(const gdb_stub::breakpoint_type type, const uint64_t addr, const size_t size) override
    {
        try
        {
            return this->hooks_.access<bool>([&](hook_map& hooks) {
                auto hook_vector = this->create_hook(type, addr, size);

                hooks[{addr, size, type}] = scoped_hook(*this->emu_, std::move(hook_vector));

                return true;
            });
        }
        catch (...)
        {
            return false;
        }
    }

    bool delete_breakpoint(const gdb_stub::breakpoint_type type, const uint64_t addr, const size_t size) override
    {
        try
        {
            return this->hooks_.access<bool>([&](hook_map& hooks) {
                const auto entry = hooks.find({addr, size, type});
                if (entry == hooks.end())
                {
                    return false;
                }

                hooks.erase(entry);

                return true;
            });
        }
        catch (...)
        {
            return false;
        }
    }

    void on_interrupt() override
    {
        this->emu_->stop();
    }

    std::string get_target_description(const std::string_view file) override
    {
        const auto entry = x64_target_descriptions.find(file);
        if (entry == x64_target_descriptions.end())
        {
            return {};
        }

        return entry->second;
    }

    uint32_t get_current_thread_id() override
    {
        return 1;
    }

    std::vector<uint32_t> get_thread_ids() override
    {
        return {this->get_current_thread_id()};
    }

  private:
    x86_64_emulator* emu_{};

    using hook_map = std::unordered_map<breakpoint_key, scoped_hook>;
    utils::concurrency::container<hook_map> hooks_{};

    std::vector<emulator_hook*> create_execute_hook(const uint64_t addr, const size_t size)
    {
        std::vector<emulator_hook*> hooks{};
        hooks.reserve(size);

        for (size_t i = 0; i < size; ++i)
        {
            auto* hook = this->emu_->hook_memory_execution(addr + i, [this](const uint64_t) {
                this->on_interrupt(); //
            });

            hooks.push_back(hook);
        }

        return hooks;
    }

    std::vector<emulator_hook*> create_read_hook(const uint64_t addr, const size_t size)
    {
        auto* hook = this->emu_->hook_memory_read(addr, size, [this](const uint64_t, const void*, const size_t) {
            this->on_interrupt(); //
        });

        return {hook};
    }

    std::vector<emulator_hook*> create_write_hook(const uint64_t addr, const size_t size)
    {
        auto* hook = this->emu_->hook_memory_write(addr, size, [this](const uint64_t, const void*, const size_t) {
            this->on_interrupt(); //
        });

        return {hook};
    }

    std::vector<emulator_hook*> create_hook(const gdb_stub::breakpoint_type type, const uint64_t addr, const size_t size)
    {
        using enum gdb_stub::breakpoint_type;

        switch (type)
        {
        case software:
        case hardware_exec:
            return this->create_execute_hook(addr, size);
        case hardware_read:
            return this->create_read_hook(addr, size);
        case hardware_write:
            return this->create_write_hook(addr, size);
        case hardware_read_write: {
            auto hooks1 = this->create_hook(hardware_read, addr, size);
            auto hooks2 = this->create_hook(hardware_write, addr, size);
            hooks1.insert(hooks1.end(), hooks2.begin(), hooks2.end());
            return hooks1;
        }
        default:
            throw std::runtime_error("Bad bp type");
        }
    }
};

```

`src/windows-gdb-stub/x64_register_mapping.hpp`:

```hpp
#pragma once
#include <cstddef>
#include <optional>
#include <x86_register.hpp>

struct register_entry
{
    x86_register reg;
    std::optional<size_t> expected_size;
    std::optional<size_t> offset;

    register_entry(const x86_register reg = x86_register::invalid, const std::optional<size_t> expected_size = std::nullopt,
                   const std::optional<size_t> offset = std::nullopt)
        : reg(reg),
          expected_size(expected_size),
          offset(offset)
    {
    }
};

inline std::vector<register_entry> gdb_registers{
    x86_register::rax,
    x86_register::rbx,
    x86_register::rcx,
    x86_register::rdx,
    x86_register::rsi,
    x86_register::rdi,
    x86_register::rbp,
    x86_register::rsp,
    x86_register::r8,
    x86_register::r9,
    x86_register::r10,
    x86_register::r11,
    x86_register::r12,
    x86_register::r13,
    x86_register::r14,
    x86_register::r15,
    x86_register::rip,
    x86_register::eflags,

    {x86_register::cs, 4},
    {x86_register::ss, 4},
    {x86_register::ds, 4},
    {x86_register::es, 4},
    {x86_register::fs, 4},
    {x86_register::gs, 4},

    x86_register::st0,
    x86_register::st1,
    x86_register::st2,
    x86_register::st3,
    x86_register::st4,
    x86_register::st5,
    x86_register::st6,
    x86_register::st7,

    {x86_register::fpcw, 4},  // fctrl
    {x86_register::fpsw, 4},  // fstat
    {x86_register::fptag, 4}, // ftag
    {x86_register::fcs, 4},   // fiseg
    {x86_register::fip, 4},   // fioff
    {x86_register::fds, 4},   // foseg
    {x86_register::fdp, 4},   // fooff
    {x86_register::fop, 4},   // fop

    x86_register::xmm0,
    x86_register::xmm1,
    x86_register::xmm2,
    x86_register::xmm3,
    x86_register::xmm4,
    x86_register::xmm5,
    x86_register::xmm6,
    x86_register::xmm7,
    x86_register::xmm8,
    x86_register::xmm9,
    x86_register::xmm10,
    x86_register::xmm11,
    x86_register::xmm12,
    x86_register::xmm13,
    x86_register::xmm14,
    x86_register::xmm15,
    x86_register::mxcsr,
    x86_register::fs_base,
    x86_register::gs_base,
    {x86_register::ymm0, 16, 16},
    {x86_register::ymm1, 16, 16},
    {x86_register::ymm2, 16, 16},
    {x86_register::ymm3, 16, 16},
    {x86_register::ymm4, 16, 16},
    {x86_register::ymm5, 16, 16},
    {x86_register::ymm6, 16, 16},
    {x86_register::ymm7, 16, 16},
    {x86_register::ymm8, 16, 16},
    {x86_register::ymm9, 16, 16},
    {x86_register::ymm10, 16, 16},
    {x86_register::ymm11, 16, 16},
    {x86_register::ymm12, 16, 16},
    {x86_register::ymm13, 16, 16},
    {x86_register::ymm14, 16, 16},
    {x86_register::ymm15, 16, 16},
};

```

`src/windows-gdb-stub/x64_target_descriptions.hpp`:

```hpp
#pragma once

#include <map>
#include <string>

inline std::map<std::string, std::string, std::less<>> x64_target_descriptions{
    {
        "target.xml",
        R"__xml__(<?xml version="1.0"?>
<!-- Copyright (C) 2010-2018 Free Software Foundation, Inc.

     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->

<!-- AMD64 with AVX -->

<!DOCTYPE target SYSTEM "gdb-target.dtd">
<target>
  <architecture>i386:x86-64</architecture>
  <xi:include href="64bit-core.xml"/>
  <xi:include href="64bit-sse.xml"/>
  <xi:include href="64bit-segments.xml"/>
  <xi:include href="64bit-avx.xml"/>
</target>
)__xml__",
    },
    {
        "64bit-core.xml",
        R"__xml__(<?xml version="1.0"?>
<!-- Copyright (C) 2010-2018 Free Software Foundation, Inc.

     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->

<!DOCTYPE feature SYSTEM "gdb-target.dtd">
<feature name="org.gnu.gdb.i386.core">
  <flags id="i386_eflags" size="4">
    <field name="CF" start="0" end="0"/>
    <field name="" start="1" end="1"/>
    <field name="PF" start="2" end="2"/>
    <field name="AF" start="4" end="4"/>
    <field name="ZF" start="6" end="6"/>
    <field name="SF" start="7" end="7"/>
    <field name="TF" start="8" end="8"/>
    <field name="IF" start="9" end="9"/>
    <field name="DF" start="10" end="10"/>
    <field name="OF" start="11" end="11"/>
    <field name="NT" start="14" end="14"/>
    <field name="RF" start="16" end="16"/>
    <field name="VM" start="17" end="17"/>
    <field name="AC" start="18" end="18"/>
    <field name="VIF" start="19" end="19"/>
    <field name="VIP" start="20" end="20"/>
    <field name="ID" start="21" end="21"/>
  </flags>

  <reg name="rax" bitsize="64" type="int64"/>
  <reg name="rbx" bitsize="64" type="int64"/>
  <reg name="rcx" bitsize="64" type="int64"/>
  <reg name="rdx" bitsize="64" type="int64"/>
  <reg name="rsi" bitsize="64" type="int64"/>
  <reg name="rdi" bitsize="64" type="int64"/>
  <reg name="rbp" bitsize="64" type="data_ptr"/>
  <reg name="rsp" bitsize="64" type="data_ptr"/>
  <reg name="r8" bitsize="64" type="int64"/>
  <reg name="r9" bitsize="64" type="int64"/>
  <reg name="r10" bitsize="64" type="int64"/>
  <reg name="r11" bitsize="64" type="int64"/>
  <reg name="r12" bitsize="64" type="int64"/>
  <reg name="r13" bitsize="64" type="int64"/>
  <reg name="r14" bitsize="64" type="int64"/>
  <reg name="r15" bitsize="64" type="int64"/>

  <reg name="rip" bitsize="64" type="code_ptr"/>
  <reg name="eflags" bitsize="32" type="i386_eflags"/>
  <reg name="cs" bitsize="32" type="int32"/>
  <reg name="ss" bitsize="32" type="int32"/>
  <reg name="ds" bitsize="32" type="int32"/>
  <reg name="es" bitsize="32" type="int32"/>
  <reg name="fs" bitsize="32" type="int32"/>
  <reg name="gs" bitsize="32" type="int32"/>

  <reg name="st0" bitsize="80" type="i387_ext"/>
  <reg name="st1" bitsize="80" type="i387_ext"/>
  <reg name="st2" bitsize="80" type="i387_ext"/>
  <reg name="st3" bitsize="80" type="i387_ext"/>
  <reg name="st4" bitsize="80" type="i387_ext"/>
  <reg name="st5" bitsize="80" type="i387_ext"/>
  <reg name="st6" bitsize="80" type="i387_ext"/>
  <reg name="st7" bitsize="80" type="i387_ext"/>

  <reg name="fctrl" bitsize="32" type="int" group="float"/>
  <reg name="fstat" bitsize="32" type="int" group="float"/>
  <reg name="ftag" bitsize="32" type="int" group="float"/>
  <reg name="fiseg" bitsize="32" type="int" group="float"/>
  <reg name="fioff" bitsize="32" type="int" group="float"/>
  <reg name="foseg" bitsize="32" type="int" group="float"/>
  <reg name="fooff" bitsize="32" type="int" group="float"/>
  <reg name="fop" bitsize="32" type="int" group="float"/>
</feature>
)__xml__",
    },
    {
        "64bit-sse.xml",
        R"__xml__(<?xml version="1.0"?>
<!-- Copyright (C) 2010-2018 Free Software Foundation, Inc.

     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->

<!DOCTYPE feature SYSTEM "gdb-target.dtd">
<feature name="org.gnu.gdb.i386.sse">
  <vector id="v4f" type="ieee_single" count="4"/>
  <vector id="v2d" type="ieee_double" count="2"/>
  <vector id="v16i8" type="int8" count="16"/>
  <vector id="v8i16" type="int16" count="8"/>
  <vector id="v4i32" type="int32" count="4"/>
  <vector id="v2i64" type="int64" count="2"/>
  <union id="vec128">
    <field name="v4_float" type="v4f"/>
    <field name="v2_double" type="v2d"/>
    <field name="v16_int8" type="v16i8"/>
    <field name="v8_int16" type="v8i16"/>
    <field name="v4_int32" type="v4i32"/>
    <field name="v2_int64" type="v2i64"/>
    <field name="uint128" type="uint128"/>
  </union>
  <flags id="i386_mxcsr" size="4">
    <field name="IE" start="0" end="0"/>
    <field name="DE" start="1" end="1"/>
    <field name="ZE" start="2" end="2"/>
    <field name="OE" start="3" end="3"/>
    <field name="UE" start="4" end="4"/>
    <field name="PE" start="5" end="5"/>
    <field name="DAZ" start="6" end="6"/>
    <field name="IM" start="7" end="7"/>
    <field name="DM" start="8" end="8"/>
    <field name="ZM" start="9" end="9"/>
    <field name="OM" start="10" end="10"/>
    <field name="UM" start="11" end="11"/>
    <field name="PM" start="12" end="12"/>
    <field name="FZ" start="15" end="15"/>
  </flags>

  <reg name="xmm0" bitsize="128" type="vec128" regnum="40"/>
  <reg name="xmm1" bitsize="128" type="vec128"/>
  <reg name="xmm2" bitsize="128" type="vec128"/>
  <reg name="xmm3" bitsize="128" type="vec128"/>
  <reg name="xmm4" bitsize="128" type="vec128"/>
  <reg name="xmm5" bitsize="128" type="vec128"/>
  <reg name="xmm6" bitsize="128" type="vec128"/>
  <reg name="xmm7" bitsize="128" type="vec128"/>
  <reg name="xmm8" bitsize="128" type="vec128"/>
  <reg name="xmm9" bitsize="128" type="vec128"/>
  <reg name="xmm10" bitsize="128" type="vec128"/>
  <reg name="xmm11" bitsize="128" type="vec128"/>
  <reg name="xmm12" bitsize="128" type="vec128"/>
  <reg name="xmm13" bitsize="128" type="vec128"/>
  <reg name="xmm14" bitsize="128" type="vec128"/>
  <reg name="xmm15" bitsize="128" type="vec128"/>

  <reg name="mxcsr" bitsize="32" type="i386_mxcsr" group="vector"/>
</feature>
)__xml__",
    },
    {
        "64bit-segments.xml",
        R"__xml__(<?xml version="1.0"?>
<!-- Copyright (C) 2016-2018 Free Software Foundation, Inc.

     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->

<!DOCTYPE feature SYSTEM "gdb-target.dtd">
<feature name="org.gnu.gdb.i386.segments">
  <reg name="fs_base" bitsize="64" type="int"/>
  <reg name="gs_base" bitsize="64" type="int"/>
</feature>
)__xml__",
    },
    {
        "64bit-avx.xml",
        R"__xml__(<?xml version="1.0"?>
<!-- Copyright (C) 2010-2018 Free Software Foundation, Inc.

     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->

<!DOCTYPE feature SYSTEM "gdb-target.dtd">
<feature name="org.gnu.gdb.i386.avx">
  <reg name="ymm0h" bitsize="128" type="uint128"/>
  <reg name="ymm1h" bitsize="128" type="uint128"/>
  <reg name="ymm2h" bitsize="128" type="uint128"/>
  <reg name="ymm3h" bitsize="128" type="uint128"/>
  <reg name="ymm4h" bitsize="128" type="uint128"/>
  <reg name="ymm5h" bitsize="128" type="uint128"/>
  <reg name="ymm6h" bitsize="128" type="uint128"/>
  <reg name="ymm7h" bitsize="128" type="uint128"/>
  <reg name="ymm8h" bitsize="128" type="uint128"/>
  <reg name="ymm9h" bitsize="128" type="uint128"/>
  <reg name="ymm10h" bitsize="128" type="uint128"/>
  <reg name="ymm11h" bitsize="128" type="uint128"/>
  <reg name="ymm12h" bitsize="128" type="uint128"/>
  <reg name="ymm13h" bitsize="128" type="uint128"/>
  <reg name="ymm14h" bitsize="128" type="uint128"/>
  <reg name="ymm15h" bitsize="128" type="uint128"/>
</feature>
)__xml__",
    },
};

```