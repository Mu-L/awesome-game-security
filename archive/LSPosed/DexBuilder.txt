Project Path: arc_LSPosed_DexBuilder_vmvvj9c0

Source Tree:

```txt
arc_LSPosed_DexBuilder_vmvvj9c0
├── Android.mk
├── CMakeLists.txt
├── LICENSE
├── README.md
├── dex_builder.cc
├── dex_helper.cc
├── dex_helper_test.cc
├── dex_testcase_generator.cc
├── external
│   └── parallel_hashmap
├── include
│   ├── dex_builder.h
│   ├── dex_builder.ixx
│   ├── dex_helper.h
│   ├── dex_helper.ixx
│   └── slicer
│       ├── arrayview.h
│       ├── buffer.h
│       ├── chronometer.h
│       ├── common.h
│       ├── dex_bytecode.h
│       ├── dex_format.h
│       ├── dex_instruction_list.h
│       ├── dex_ir.h
│       ├── dex_leb128.h
│       ├── dex_utf8.h
│       ├── hash_table.h
│       ├── index_map.h
│       ├── memview.h
│       ├── reader.h
│       ├── scopeguard.h
│       ├── sha1.h
│       └── writer.h
└── slicer
    ├── common.cc
    ├── dex_bytecode.cc
    ├── dex_format.cc
    ├── dex_ir.cc
    ├── dex_utf8.cc
    ├── reader.cc
    ├── sha1.cpp
    └── writer.cc

```

`Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE            := dex_builder
LOCAL_CPPFLAGS          := -std=c++20
LOCAL_C_INCLUDES        := $(LOCAL_PATH)/include
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_SRC_FILES         := dex_builder.cc slicer/writer.cc slicer/reader.cc slicer/dex_ir.cc slicer/common.cc \
                           slicer/dex_format.cc slicer/dex_utf8.cc slicer/dex_bytecode.cc
LOCAL_EXPORT_LDLIBS     := -lz
LOCAL_LDLIBS            := -lz
LOCAL_CFLAGS            := -fvisibility=default -fvisibility-inlines-hidden -flto
LOCAL_LDFLAGS           := -flto
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE            := dex_builder_static
LOCAL_CPPFLAGS          := -std=c++20
LOCAL_C_INCLUDES        := $(LOCAL_PATH)/include
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_SRC_FILES         := dex_builder.cc slicer/writer.cc slicer/reader.cc slicer/dex_ir.cc slicer/common.cc \
                           slicer/dex_format.cc slicer/dex_utf8.cc slicer/dex_bytecode.cc
LOCAL_EXPORT_LDLIBS     := -lz
include $(BUILD_STATIC_LIBRARY)

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.28)
project(dex_builder)

find_program(CCACHE ccache)

if (CCACHE)
    set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE})
    set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE})
endif ()

set(CMAKE_CXX_STANDARD 23)

add_subdirectory(external/parallel_hashmap)

set(DB_SOURCES
        dex_builder.cc
        dex_helper.cc
        slicer/reader.cc
        slicer/writer.cc
        slicer/dex_ir.cc
        slicer/common.cc
        slicer/dex_format.cc
        slicer/dex_utf8.cc
        slicer/dex_bytecode.cc
        slicer/sha1.cpp
        )

set(DB_MODULES
    include/dex_builder.ixx
    include/dex_helper.ixx)

set(TEST_SOURCES
        dex_testcase_generator.cc
        )

set(CFLAGS
        -flto
        -fvisibility=default
        )

if (NOT DEFINED DEBUG_SYMBOLS_PATH)
    set(DEBUG_SYMBOLS_PATH ${CMAKE_BINARY_DIR}/symbols)
endif()

option(DEX_BUILDER_BUILD_SHARED "If ON, dex builder will also build shared library" ON)
if (DEX_BUILDER_BUILD_SHARED)
    message(STATUS "Building dex builder as shared library")
    add_library(${PROJECT_NAME} SHARED ${DB_SOURCES})
    set_target_properties(${PROJECT_NAME} PROPERTIES CXX_SCAN_FOR_MODULES ON)
    target_sources(${PROJECT_NAME} PUBLIC FILE_SET CXX_MODULES FILES ${DB_MODULES})
    target_include_directories(${PROJECT_NAME} PUBLIC include)
    target_link_libraries(${PROJECT_NAME} PUBLIC z log phmap)

    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E make_directory ${DEBUG_SYMBOLS_PATH}/${ANDROID_ABI}
            COMMAND ${CMAKE_OBJCOPY} --only-keep-debug $<TARGET_FILE:${PROJECT_NAME}>
            ${DEBUG_SYMBOLS_PATH}/${ANDROID_ABI}/${PROJECT_NAME}
            COMMAND ${CMAKE_STRIP} --strip-all $<TARGET_FILE:${PROJECT_NAME}>)

    target_compile_options(${PROJECT_NAME} PRIVATE ${CFLAGS})
    target_link_options(${PROJECT_NAME} PRIVATE -flto)
endif()

add_library(${PROJECT_NAME}_static STATIC ${DB_SOURCES})
set_target_properties(${PROJECT_NAME}_static PROPERTIES CXX_SCAN_FOR_MODULES ON)
target_sources(${PROJECT_NAME}_static PUBLIC FILE_SET CXX_MODULES FILES ${DB_MODULES})
target_include_directories(${PROJECT_NAME}_static PUBLIC include)
target_link_libraries(${PROJECT_NAME}_static PUBLIC z log phmap)

```

`LICENSE`:

```
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2022 LSPosed <https://lsposed.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`README.md`:

```md
# DexBuilder

c++ dex builder for replacement with [dexmaker](https://github.com/linkedin/dexmaker).

Most of them are copied from [AOSP](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/startop/view_compiler).

Modified parts are owed by LSPosed Developers. If you would like to use it in an open source project, please submodule it.

Only part of instructions used by LSPosed are implemented. If you want to add other instructions, PR is welcomed.

```

`dex_builder.cc`:

```cc
/* DexBuilder
 * Copyright (C) 2021 LSPosed
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Copyright (C) 2018 The Android Open Source Project
 * Modifications copyright (C) 2021 LSPosed Developers
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "dex_builder.h"
#include "slicer/dex_bytecode.h"
#include "slicer/dex_format.h"
#include "slicer/dex_ir.h"

#include <array>
#include <memory>

namespace startop {
namespace dex {

using std::string;

using ::dex::kAccPublic;
using ::dex::kAccAbstract;
using ::dex::kAccNative;

const TypeDescriptor TypeDescriptor::Int{"I"};
const TypeDescriptor TypeDescriptor::Void{"V"};
const TypeDescriptor TypeDescriptor::Boolean{"Z"};
const TypeDescriptor TypeDescriptor::Byte{"B"};
const TypeDescriptor TypeDescriptor::Char{"C"};
const TypeDescriptor TypeDescriptor::Double{"D", true};
const TypeDescriptor TypeDescriptor::Float{"F"};
const TypeDescriptor TypeDescriptor::Long{"J", true};
const TypeDescriptor TypeDescriptor::Short{"S"};

const TypeDescriptor TypeDescriptor::Object{"Ljava/lang/Object;"};
const TypeDescriptor TypeDescriptor::String{"Ljava/lang/String;"};
const TypeDescriptor TypeDescriptor::ObjectInt{"Ljava/lang/Integer;"};
const TypeDescriptor TypeDescriptor::ObjectBoolean{"Ljava/lang/Boolean;"};
const TypeDescriptor TypeDescriptor::ObjectByte{"Ljava/lang/Byte;"};
const TypeDescriptor TypeDescriptor::ObjectChar{"Ljava/lang/Character;"};
const TypeDescriptor TypeDescriptor::ObjectDouble{"Ljava/lang/Double;"};
const TypeDescriptor TypeDescriptor::ObjectFloat{"Ljava/lang/Float;"};
const TypeDescriptor TypeDescriptor::ObjectLong{"Ljava/lang/Long;"};
const TypeDescriptor TypeDescriptor::ObjectShort{"Ljava/lang/Short;"};

const phmap::flat_hash_map<TypeDescriptor, TypeDescriptor>
    TypeDescriptor::unbox_map{
        {ObjectInt, Int},   {ObjectBoolean, Boolean}, {ObjectByte, Byte},
        {ObjectChar, Char}, {ObjectDouble, Double},   {ObjectFloat, Float},
        {ObjectLong, Long}, {ObjectShort, Short},
    };

const phmap::flat_hash_map<TypeDescriptor, std::string> value_method_map{
    {TypeDescriptor::ObjectInt, "intValue"},
    {TypeDescriptor::ObjectBoolean, "booleanValue"},
    {TypeDescriptor::ObjectByte, "byteValue"},
    {TypeDescriptor::ObjectChar, "charValue"},
    {TypeDescriptor::ObjectDouble, "doubleValue"},
    {TypeDescriptor::ObjectFloat, "floatValue"},
    {TypeDescriptor::ObjectLong, "longValue"},
    {TypeDescriptor::ObjectShort, "shortValue"},
};
namespace {
// From https://source.android.com/devices/tech/dalvik/dex-format#dex-file-magic
constexpr uint8_t kDexFileMagic[]{0x64, 0x65, 0x78, 0x0a,
                                  0x30, 0x33, 0x35, 0x00};

// Strings lengths can be 32 bits long, but encoded as LEB128 this can take up
// to five bytes.
constexpr size_t kMaxEncodedStringLength{5};

std::string DotToDescriptor(const char *class_name) {
  std::string descriptor(class_name);
  std::replace(descriptor.begin(), descriptor.end(), '.', '/');
  if (descriptor.length() > 0 && descriptor[0] != '[') {
    descriptor = "L" + descriptor + ";";
  }
  return descriptor;
}

} // namespace

void *TrackingAllocator::Allocate(size_t size) {
  std::unique_ptr<uint8_t[]> buffer = std::make_unique<uint8_t[]>(size);
  void *raw_buffer = buffer.get();
  allocations_[raw_buffer] = std::move(buffer);
  return raw_buffer;
}

void TrackingAllocator::Free(void *ptr) {
  allocations_.erase(allocations_.find(ptr));
}

// Write out a DEX file that is basically:
//
// package dextest;
// public class DexTest {
//     public static int foo(String s) { return s.length(); }
// }

TypeDescriptor TypeDescriptor::FromClassname(const std::string &name) {
  return TypeDescriptor{DotToDescriptor(name.c_str())};
}

TypeDescriptor TypeDescriptor::ToBoxType() const {
  assert(is_primitive());
  switch (descriptor_[0]) {
  case 'I':
    return ObjectInt;
  case 'Z':
    return ObjectBoolean;
  case 'C':
    return ObjectChar;
  case 'J':
    return ObjectLong;
  case 'S':
    return ObjectShort;
  case 'F':
    return ObjectFloat;
  case 'D':
    return ObjectDouble;
  case 'B':
    return ObjectByte;
  default:
    assert(false);
    return Object;
  }
}

TypeDescriptor TypeDescriptor::ToUnBoxType() const {
  assert(is_object());
  auto unbox_type_iter = unbox_map.find(*this);
  assert(unbox_type_iter != unbox_map.end());
  return unbox_type_iter->second;
}
char TypeDescriptor::short_descriptor() const {
  if (descriptor_[0] == '[')
    return 'L';
  else
    return descriptor_[0];
}

TypeDescriptor TypeDescriptor::FromDescriptor(const char descriptor) {
  switch (descriptor) {
    case 'I':
      return Int;
    case 'Z':
      return Boolean;
    case 'C':
      return Char;
    case 'J':
      return Long;
    case 'S':
      return Short;
    case 'F':
      return Float;
    case 'D':
      return Double;
    case 'B':
      return Byte;
    case 'V':
      return Void;
    default:
      return Object;
  }
}

TypeDescriptor TypeDescriptor::FromDescriptor(const string &descriptor) {
  switch (descriptor[0]) {
  case 'I':
    return Int;
  case 'Z':
    return Boolean;
  case 'C':
    return Char;
  case 'J':
    return Long;
  case 'S':
    return Short;
  case 'F':
    return Float;
  case 'D':
    return Double;
  case 'B':
    return Byte;
  case 'V':
    return Void;
  default:
    return TypeDescriptor{descriptor, false};
  }
}

DexBuilder::DexBuilder() : dex_file_{std::make_shared<ir::DexFile>()} {
  dex_file_->magic = slicer::MemView{kDexFileMagic, sizeof(kDexFileMagic)};
}

slicer::MemView DexBuilder::CreateImage(bool checksum) {
  ::dex::Writer writer(dex_file_);
  size_t image_size{0};
  ::dex::u1 *image = writer.CreateImage(&allocator_, &image_size, checksum);
  return slicer::MemView{image, image_size};
}

ir::String *DexBuilder::GetOrAddString(const std::string &string) {
  auto it = strings_.find(string);
  if (it == strings_.end()) {
    // Need to encode the length and then write out the bytes, including 1 byte
    // for null terminator
    auto buffer = std::make_unique<uint8_t[]>(string.size() +
                                              kMaxEncodedStringLength + 1);
    size_t actual_len = 0u;
    const char* s = string.data();
    while (*s) actual_len += (*s++ & 0xc0) != 0x80;
    uint8_t *string_data_start =
        ::dex::WriteULeb128(buffer.get(), actual_len);

    size_t header_length = reinterpret_cast<uintptr_t>(string_data_start) -
                           reinterpret_cast<uintptr_t>(buffer.get());

    auto end = std::copy(string.begin(), string.end(), string_data_start);
    *end = '\0';

    auto* entry = Alloc<ir::String>();
    // +1 for null terminator
    entry->data =
        slicer::MemView{buffer.get(), header_length + string.size() + 1};
    it = strings_.emplace(entry->c_str(), entry).first;
    ::dex::u4 const new_index = dex_file_->strings_indexes.AllocateIndex();
    dex_file_->strings_map[new_index] = entry;
    entry->orig_index = new_index;
    string_data_.push_back(std::move(buffer));
  }
  return it->second;
}

ClassBuilder DexBuilder::MakeClass(const std::string &name) {
  auto *class_def = Alloc<ir::Class>();
  ir::Type *type_def = GetOrAddType(DotToDescriptor(name.c_str()));
  type_def->class_def = class_def;

  class_def->type = type_def;
  class_def->super_class = GetOrAddType(TypeDescriptor::Object);
  class_def->access_flags = kAccPublic;
  return ClassBuilder{this, name, class_def};
}

ir::Type *DexBuilder::GetOrAddType(const std::string &descriptor) {
  if (auto type = types_by_descriptor_.find(descriptor);
      type != types_by_descriptor_.end()) {
    return type->second;
  }

  ir::Type *type = Alloc<ir::Type>();
  type->descriptor = GetOrAddString(descriptor);
  types_by_descriptor_[type->descriptor->c_str()] = type;
  type->orig_index = dex_file_->types_indexes.AllocateIndex();
  dex_file_->types_map[type->orig_index] = type;
  return type;
}

ir::FieldDecl *DexBuilder::GetOrAddField(TypeDescriptor parent,
                                         const std::string &name,
                                         TypeDescriptor type) {
  const auto key = std::make_tuple(parent, name);
  if (auto field = field_decls_by_key_.find(key);
      field != field_decls_by_key_.end()) {
    return field->second;
  }

  ir::FieldDecl *field = Alloc<ir::FieldDecl>();
  field->parent = GetOrAddType(parent);
  field->name = GetOrAddString(name);
  field->type = GetOrAddType(type);
  field->orig_index = dex_file_->fields_indexes.AllocateIndex();
  dex_file_->fields_map[field->orig_index] = field;
  field_decls_by_key_[key] = field;
  return field;
}

ir::Proto *Prototype::Encode(DexBuilder *dex) const {
  auto *proto = dex->Alloc<ir::Proto>();
  proto->shorty = dex->GetOrAddString(Shorty());
  proto->return_type = dex->GetOrAddType(return_type_.descriptor());
  if (param_types_.size() > 0) {
    proto->param_types = dex->Alloc<ir::TypeList>();
    for (const auto &param_type : param_types_) {
      proto->param_types->types.push_back(
          dex->GetOrAddType(param_type.descriptor()));
    }
  } else {
    proto->param_types = nullptr;
  }
  return proto;
}

std::string Prototype::Shorty() const {
  std::string shorty;
  shorty += return_type_.short_descriptor();
  for (const auto &type_descriptor : param_types_) {
    shorty += type_descriptor.short_descriptor();
  }
  return shorty;
}

const TypeDescriptor &Prototype::ArgType(size_t index) const {
  assert(index < param_types_.size());
  return param_types_[index];
}

ClassBuilder::ClassBuilder(DexBuilder *parent, const std::string &name,
                           ir::Class *class_def)
    : parent_(parent), type_descriptor_{TypeDescriptor::FromClassname(name)},
      class_(class_def) {}

MethodBuilder ClassBuilder::CreateMethod(const std::string &name,
                                         const Prototype &prototype) {
  ir::MethodDecl *decl =
      parent_->GetOrDeclareMethod(type_descriptor_, name, prototype).decl;
  return {this, class_, decl};
}

FieldBuilder ClassBuilder::CreateField(const std::string &name,
                                       const TypeDescriptor &type) {
  ir::FieldDecl *decl = parent_->GetOrAddField(type_descriptor_, name, type);
  return {this, class_, decl};
}

ClassBuilder ClassBuilder::setSuperClass(const TypeDescriptor &type) {
    class_->super_class = parent_->GetOrAddType(type);
    return *this;
}

void ClassBuilder::set_source_file(const string &source) {
  class_->source_file = parent_->GetOrAddString(source);
}

FieldBuilder::FieldBuilder(ClassBuilder *parent, ir::Class *class_def,
                           ir::FieldDecl *decl)
    : parent_(parent), class_(class_def), decl_(decl) {}

ir::EncodedField *FieldBuilder::Encode() {
  auto *field = dex_file()->Alloc<ir::EncodedField>();
  field->decl = decl_;
  field->access_flags = access_flags_;
  class_->static_fields.push_back(field);
  return field;
}

MethodBuilder::MethodBuilder(ClassBuilder *parent, ir::Class *class_def,
                             ir::MethodDecl *decl)
    : parent_{parent}, class_{class_def}, decl_{decl} {}

ir::EncodedMethod *MethodBuilder::Encode() {
  auto *method = dex_file()->Alloc<ir::EncodedMethod>();
  method->decl = decl_;

  method->access_flags = access_flags_;

  if ((access_flags_ & (kAccAbstract | kAccNative)) == 0) {
    auto *code = dex_file()->Alloc<ir::Code>();
    assert(decl_->prototype != nullptr);

    size_t num_args = 0;
    if ((access_flags_ & ::dex::kAccStatic) == 0) {
      num_args += 1;
    }
    if (decl_->prototype->param_types != nullptr) {
      for (auto &type : decl_->prototype->param_types->types) {
        if (type->GetCategory() == ir::Type::Category::WideScalar) {
          num_args += 1;
        }
        num_args += 1;
      }
    }
    code->registers = NumRegisters() + num_args + kMaxScratchRegisters;
    code->ins_count = num_args;
    EncodeInstructions();
    code->instructions =
        slicer::ArrayView<const ::dex::u2>(buffer_.data(), buffer_.size());
    size_t const return_count =
        decl_->prototype->return_type ==
                dex_file()->GetOrAddType(TypeDescriptor::Void)
            ? 0
            : 1;
    code->outs_count = std::max(return_count, max_args_);
    if (class_->source_file) {
      static constexpr auto kDebugInfo =
          std::array{::dex::DBG_FIRST_SPECIAL, ::dex::DBG_END_SEQUENCE};
      auto *debug_info = dex_file()->Alloc<ir::DebugInfo>();
      debug_info->line_start = 0;
      debug_info->data = slicer::MemView{kDebugInfo.data(), kDebugInfo.size()};
      code->debug_info = debug_info;
    }
    method->code = code;
  }

  bool is_direct = (access_flags_ & (::dex::kAccStatic | ::dex::kAccPrivate | ::dex::kAccConstructor)) != 0;
  if (is_direct) {
    class_->direct_methods.push_back(method);
  } else {
    class_->virtual_methods.push_back(method);
  }

  return method;
}

LiveRegister MethodBuilder::AllocRegister() {
  // Find a free register
  for (size_t i = 0; i < register_liveness_.size(); ++i) {
    if (!register_liveness_[i]) {
      register_liveness_[i] = true;
      return LiveRegister{&register_liveness_, i};
    }
  }

  // If we get here, all the registers are in use, so we have to allocate a new
  // one.
  register_liveness_.push_back(true);
  return LiveRegister{&register_liveness_, register_liveness_.size() - 1};
}

Value MethodBuilder::MakeLabel() {
  labels_.push_back({});
  return Value::Label(labels_.size() - 1);
}

MethodBuilder &MethodBuilder::AddInstruction(Instruction instruction) {
  instructions_.push_back(instruction);
  return *this;
}
MethodBuilder &MethodBuilder::BuildBoxIfPrimitive(const Value &target,
                                                  const TypeDescriptor &type,
                                                  const Value &src) {
  if (type.is_primitive()) {
    auto box_type{type.ToBoxType()};
    MethodDeclData value_of{dex_file()->GetOrDeclareMethod(
        box_type, "valueOf", Prototype{box_type, type})};
    if (type.is_wide()) {
      auto wide_pair = src.WidePair();
      if (RegisterValue(src) >= 16 || RegisterValue(wide_pair) >= 16) {
        AddInstruction(Instruction::InvokeStaticObjectRange(value_of.id, target, src, 2));
      } else {
        AddInstruction(Instruction::InvokeStaticObject(value_of.id, target, src,
                                                       src.WidePair()));
      }
    } else {
        if(RegisterValue(src) >= 16) {
            AddInstruction(Instruction::InvokeStaticObjectRange(value_of.id, target, src, 1));
        } else {
            AddInstruction(Instruction::InvokeStaticObject(value_of.id, target, src));
        }
    }
  } else if (target != src) {
    AddInstruction(Instruction::OpWithArgs(Op::kMoveObject, target, src));
  }
  return *this;
}

MethodBuilder &MethodBuilder::BuildUnBoxIfPrimitive(const Value &target,
                                                    const TypeDescriptor &type,
                                                    const Value &src) {
  if (type.is_object()) {
    auto unbox_type{type.ToUnBoxType()};
    MethodDeclData value{dex_file()->GetOrDeclareMethod(
        type, value_method_map.at(type), Prototype{unbox_type})};
    if (unbox_type.is_wide())
      AddInstruction(Instruction::InvokeVirtualWide(value.id, target, src));
    else
      AddInstruction(Instruction::InvokeVirtual(value.id, target, src));
  } else if (target != src) {
    AddInstruction(Instruction::OpWithArgs(Op::kMove, target, src));
  }
  return *this;
}

void MethodBuilder::EncodeInstruction(const Instruction &instruction) {
  switch (instruction.opcode()) {
  case Instruction::Op::kReturn:
    return EncodeReturn(instruction, ::dex::Opcode::OP_RETURN);
  case Instruction::Op::kReturnObject:
    return EncodeReturn(instruction, ::dex::Opcode::OP_RETURN_OBJECT);
  case Instruction::Op::kReturnWide:
    return EncodeReturn(instruction, ::dex::Opcode::OP_RETURN_WIDE);
  case Instruction::Op::kMove:
  case Instruction::Op::kMoveObject:
  case Instruction::Op::kMoveWide:
    return EncodeMove(instruction);
  case Instruction::Op::kInvokeVirtual:
    return EncodeInvoke(instruction, ::dex::Opcode::OP_INVOKE_VIRTUAL);
  case Instruction::Op::kInvokeDirect:
    return EncodeInvoke(instruction, ::dex::Opcode::OP_INVOKE_DIRECT);
  case Instruction::Op::kInvokeStatic:
    return EncodeInvoke(instruction, ::dex::Opcode::OP_INVOKE_STATIC);
  case Instruction::Op::kInvokeInterface:
    return EncodeInvoke(instruction, ::dex::Opcode::OP_INVOKE_INTERFACE);
  case Instruction::Op::kInvokeVirtualRange:
    return EncodeInvokeRange(instruction, ::dex::Opcode::OP_INVOKE_VIRTUAL_RANGE);
  case Instruction::Op::kInvokeDirectRange:
    return EncodeInvokeRange(instruction, ::dex::Opcode::OP_INVOKE_DIRECT_RANGE);
  case Instruction::Op::kInvokeStaticRange:
    return EncodeInvokeRange(instruction, ::dex::Opcode::OP_INVOKE_STATIC_RANGE);
  case Instruction::Op::kInvokeInterfaceRange:
    return EncodeInvokeRange(instruction, ::dex::Opcode::OP_INVOKE_INTERFACE_RANGE);
  case Instruction::Op::kBindLabel:
    return BindLabel(instruction.args()[0]);
  case Instruction::Op::kBranchEqz:
    return EncodeBranch(::dex::Opcode::OP_IF_EQZ, instruction);
  case Instruction::Op::kBranchNEqz:
    return EncodeBranch(::dex::Opcode::OP_IF_NEZ, instruction);
  case Instruction::Op::kNew:
    return EncodeNew(instruction);
  case Instruction::Op::kNewArray:
    return EncodeNewArray(instruction);
  case Instruction::Op::kCheckCast:
    return EncodeCast(instruction);
  case Instruction::Op::kGetStaticField:
  case Instruction::Op::kGetStaticObjectField:
  case Instruction::Op::kSetStaticField:
  case Instruction::Op::kSetStaticObjectField:
  case Instruction::Op::kGetInstanceField:
  case Instruction::Op::kSetInstanceField:
    return EncodeFieldOp(instruction);
  case Instruction::Op::kAputObject:
    return EncodeAput(instruction);
  }
}

void MethodBuilder::EncodeReturn(const Instruction &instruction,
                                 ::dex::Opcode opcode) {
  assert(!instruction.dest().has_value());
  if (instruction.args().size() == 0) {
    Encode10x(::dex::Opcode::OP_RETURN_VOID);
  } else {
    assert(1 == instruction.args().size());
    size_t source = RegisterValue(instruction.args()[0]);
    Encode11x(opcode, source);
  }
}

void MethodBuilder::EncodeMove(const Instruction &instruction) {
  assert(Instruction::Op::kMove == instruction.opcode() ||
         Instruction::Op::kMoveObject == instruction.opcode() ||
         Instruction::Op::kMoveWide == instruction.opcode());
  assert(instruction.dest().has_value());
  assert(instruction.dest()->is_variable());
  assert(1 == instruction.args().size());

  const Value &source = instruction.args()[0];

  if (source.is_immediate() && Instruction::Op::kMove == instruction.opcode()) {
    if (RegisterValue(*instruction.dest()) < 16 && source.value() < 8) {
      Encode11n(::dex::Opcode::OP_CONST_4, RegisterValue(*instruction.dest()),
                source.value());
    } else if (source.value() <= 65535) {
      Encode21s(::dex::Opcode::OP_CONST_16, RegisterValue(*instruction.dest()),
                source.value());
    } else {
      Encode31i(::dex::Opcode::OP_CONST, RegisterValue(*instruction.dest()),
                source.value());
    }
  } else if (source.is_immediate() &&
             Instruction::Op::kMoveWide == instruction.opcode()) {
    if (source.value() <= 65535) {
      Encode21s(::dex::Opcode::OP_CONST_WIDE_16,
                RegisterValue(*instruction.dest()), source.value());
    } else if (source.value() <= 4294967295) {
      Encode31i(::dex::Opcode::OP_CONST_WIDE_32,
                RegisterValue(*instruction.dest()), source.value());
    } else {
      assert(false && "not supported yet");
      // Encode51i(::dex::Opcode::OP_CONST_WIDE,
      // RegisterValue(*instruction.dest()), source.value());
    }
  } else if (source.is_string()) {
    assert(RegisterValue(*instruction.dest()) < 256);
    assert(source.value() < 65536); // make sure we don't need a jumbo string
    Encode21c(::dex::Opcode::OP_CONST_STRING,
              RegisterValue(*instruction.dest()), source.value());
  } else if (source.is_variable()) {
    // For the moment, we only use this when we need to reshuffle registers for
    // an invoke instruction, meaning we are too big for the 4-bit version.
    // We'll err on the side of caution and always generate the 16-bit form of
    // the instruction.
    auto opcode = instruction.opcode() == Instruction::Op::kMove
                      ? ::dex::Opcode::OP_MOVE_16
                      : (instruction.opcode() == Instruction::Op::kMoveWide
                             ? ::dex::Opcode::OP_MOVE_WIDE_16
                             : ::dex::Opcode::OP_MOVE_OBJECT_16);
    Encode32x(opcode, RegisterValue(*instruction.dest()),
              RegisterValue(source));
  } else {
    assert(false);
  }
}

void MethodBuilder::EncodeInvoke(const Instruction &instruction,
                                 ::dex::Opcode opcode) {
  constexpr size_t kMaxArgs = 5;

  // Currently, we only support up to 5 arguments.
  assert(instruction.args().size() < kMaxArgs);

  uint8_t arguments[kMaxArgs]{0};
  bool has_long_args = false;
  for (size_t i = 0; i < instruction.args().size(); ++i) {
    assert(instruction.args()[i].is_variable());
    arguments[i] = RegisterValue(instruction.args()[i]);
    if (!IsShortRegister(arguments[i])) {
      has_long_args = true;
    }
  }

  if (has_long_args) {
    assert(false && "long args should use invoke range");
  } else {
    Encode35c(opcode, instruction.args().size(), instruction.index_argument(),
              arguments[0], arguments[1], arguments[2], arguments[3],
              arguments[4]);
  }

  // If there is a return value, add a move-result instruction
  if (instruction.dest().has_value()) {
    Encode11x(instruction.result_is_object()
                  ? ::dex::Opcode::OP_MOVE_RESULT_OBJECT
                  : (instruction.result_is_wide()
                         ? ::dex::Opcode::OP_MOVE_RESULT_WIDE
                         : ::dex::Opcode::OP_MOVE_RESULT),
              RegisterValue(*instruction.dest()));
  }
  max_args_ = std::max(max_args_, instruction.args().size());
}

void MethodBuilder::EncodeInvokeRange(const Instruction &instruction,
                                      ::dex::Opcode opcode) {
  const auto &args = instruction.args();
  assert(args.size() == 2);
  assert(args[1].is_immediate());
  Encode3rc(opcode, args[1].value(),
            instruction.index_argument(), RegisterValue(args[0]));
  // If there is a return value, add a move-result instruction
  if (instruction.dest().has_value()) {
    Encode11x(instruction.result_is_object()
                  ? ::dex::Opcode::OP_MOVE_RESULT_OBJECT
                  : (instruction.result_is_wide()
                         ? ::dex::Opcode::OP_MOVE_RESULT_WIDE
                         : ::dex::Opcode::OP_MOVE_RESULT),
              RegisterValue(*instruction.dest()));
  }
  max_args_ = std::max(max_args_, instruction.args().size());
}

// Encodes a conditional branch that tests a single argument.
void MethodBuilder::EncodeBranch(::dex::Opcode op,
                                 const Instruction &instruction) {
  const auto &args = instruction.args();
  const auto &test_value = args[0];
  const auto &branch_target = args[1];
  assert(2 == args.size());
  assert(test_value.is_variable());
  assert(branch_target.is_label());

  size_t instruction_offset = buffer_.size();
  size_t field_offset = buffer_.size() + 1;
  Encode21c(op, RegisterValue(test_value),
            LabelValue(branch_target, instruction_offset, field_offset));
}

void MethodBuilder::EncodeNew(const Instruction &instruction) {
  assert(Instruction::Op::kNew == instruction.opcode());
  assert(instruction.dest().has_value());
  assert(instruction.dest()->is_variable());
  assert(1 == instruction.args().size());

  const Value &type = instruction.args()[0];
  assert(RegisterValue(*instruction.dest()) < 256);
  assert(type.is_type());
  Encode21c(::dex::Opcode::OP_NEW_INSTANCE, RegisterValue(*instruction.dest()),
            type.value());
}

void MethodBuilder::EncodeCast(const Instruction &instruction) {
  assert(Instruction::Op::kCheckCast == instruction.opcode());
  assert(instruction.dest().has_value());
  assert(instruction.dest()->is_variable());
  assert(1 == instruction.args().size());

  const Value &type = instruction.args()[0];
  assert(RegisterValue(*instruction.dest()) < 256);
  assert(type.is_type());
  Encode21c(::dex::Opcode::OP_CHECK_CAST, RegisterValue(*instruction.dest()),
            type.value());
}

void MethodBuilder::EncodeNewArray(const Instruction &instruction) {
  assert(Instruction::Op::kNewArray == instruction.opcode());
  assert(instruction.dest().has_value());
  assert(instruction.dest()->is_variable());
  assert(2 == instruction.args().size());
  const auto &args = instruction.args();
  const Value &type = args[1];
  Encode22c(::dex::Opcode::OP_NEW_ARRAY, RegisterValue(*instruction.dest()),
            RegisterValue(args[0]), type.value());
}

void MethodBuilder::EncodeAput(const Instruction &instruction) {
  assert(Instruction::Op::kAputObject == instruction.opcode());
  assert(instruction.dest().has_value());
  assert(instruction.dest()->is_variable());
  assert(2 == instruction.args().size());
  const auto &args = instruction.args();
  switch (instruction.opcode()) {
  case Instruction::Op::kAputObject: {
    Encode23x(::dex::Opcode::OP_APUT_OBJECT, RegisterValue(*instruction.dest()),
              RegisterValue(args[0]), RegisterValue(args[1]));
    break;
  }
  default: {
    assert(false);
  }
  }
}

void MethodBuilder::EncodeFieldOp(const Instruction &instruction) {
  const auto &args = instruction.args();
  switch (instruction.opcode()) {
  case Instruction::Op::kGetStaticObjectField:
  case Instruction::Op::kGetStaticField: {
    assert(instruction.dest().has_value());
    assert(instruction.dest()->is_variable());
    assert(0 == instruction.args().size());

    Encode21c(instruction.opcode() == Instruction::Op::kGetStaticField
                  ? ::dex::Opcode::OP_SGET
                  : ::dex::Opcode::OP_SGET_OBJECT,
              RegisterValue(*instruction.dest()), instruction.index_argument());
    break;
  }
  case Instruction::Op::kSetStaticObjectField:
  case Instruction::Op::kSetStaticField: {
    assert(!instruction.dest().has_value());
    assert(1 == args.size());
    assert(args[0].is_variable());

    Encode21c(instruction.opcode() == Instruction::Op::kSetStaticField
                  ? ::dex::Opcode::OP_SPUT
                  : ::dex::Opcode::OP_SPUT_OBJECT,
              RegisterValue(args[0]), instruction.index_argument());
    break;
  }
  case Instruction::Op::kGetInstanceField: {
    assert(instruction.dest().has_value());
    assert(instruction.dest()->is_variable());
    assert(1 == instruction.args().size());

    Encode22c(::dex::Opcode::OP_IGET, RegisterValue(*instruction.dest()),
              RegisterValue(args[0]), instruction.index_argument());
    break;
  }
  case Instruction::Op::kSetInstanceField: {
    assert(!instruction.dest().has_value());
    assert(2 == args.size());
    assert(args[0].is_variable());
    assert(args[1].is_variable());

    Encode22c(::dex::Opcode::OP_IPUT, RegisterValue(args[1]),
              RegisterValue(args[0]), instruction.index_argument());
    break;
  }
  default: {
    assert(false);
  }
  }
}

size_t MethodBuilder::RegisterValue(const Value &value) const {
  if (value.is_register()) {
    return value.value();
  } else if (value.is_parameter()) {
    return value.value() + NumRegisters();
  }
  assert(false && "Must be either a parameter or a register");
  return 0;
}

void MethodBuilder::BindLabel(const Value &label_id) {
  assert(label_id.is_label());

  LabelData &label = labels_[label_id.value()];
  assert(!label.bound_address.has_value());

  label.bound_address = buffer_.size();

  // patch any forward references to this label.
  for (const auto &ref : label.references) {
    buffer_[ref.field_offset] = *label.bound_address - ref.instruction_offset;
  }
  // No point keeping these around anymore.
  label.references.clear();
}

::dex::u2 MethodBuilder::LabelValue(const Value &label_id,
                                    size_t instruction_offset,
                                    size_t field_offset) {
  assert(label_id.is_label());
  LabelData &label = labels_[label_id.value()];

  // Short-circuit if the label is already bound.
  if (label.bound_address.has_value()) {
    return *label.bound_address - instruction_offset;
  }

  // Otherwise, save a reference to where we need to back-patch later.
  label.references.push_front(LabelReference{instruction_offset, field_offset});
  return 0;
}

const MethodDeclData &DexBuilder::GetOrDeclareMethod(TypeDescriptor type,
                                                     const std::string &name,
                                                     Prototype prototype) {
  MethodDeclData &entry = method_id_map_[{type, name, prototype}];

  if (entry.decl == nullptr) {
    // This method has not already been declared, so declare it.
    ir::MethodDecl *decl = dex_file_->Alloc<ir::MethodDecl>();
    // The method id is the last added method.
    size_t id = dex_file_->methods.size() - 1;

    ir::String *dex_name{GetOrAddString(name)};
    decl->name = dex_name;
    decl->parent = GetOrAddType(type.descriptor());
    decl->prototype = GetOrEncodeProto(prototype);

    // update the index -> ir node map (see
    // tools/dexter/slicer/dex_ir_builder.cc)
    auto new_index = dex_file_->methods_indexes.AllocateIndex();
    auto &ir_node = dex_file_->methods_map[new_index];
    assert(ir_node == nullptr);
    ir_node = decl;
    decl->orig_index = decl->index = new_index;

    entry = {id, decl};
  }

  return entry;
}

std::optional<const Prototype>
DexBuilder::GetPrototypeByMethodId(size_t method_id) const {
  for (const auto &entry : method_id_map_) {
    if (entry.second.id == method_id) {
      return entry.first.prototype;
    }
  }
  return {};
}

ir::Proto *DexBuilder::GetOrEncodeProto(Prototype prototype) {
  ir::Proto *&ir_proto = proto_map_[prototype];
  if (ir_proto == nullptr) {
    ir_proto = prototype.Encode(this);
  }
  return ir_proto;
}

} // namespace dex
} // 

```

`dex_helper.cc`:

```cc
#include "dex_helper.h"

#include <algorithm>

#include "slicer/dex_format.h"
#include "slicer/dex_leb128.h"
#include "slicer/reader.h"
#include "slicer/dex_utf8.h"

namespace {
constexpr auto utf8_less = [](const std::string_view a, const std::string_view b) { return dex::Utf8Cmp(a.data(), b.data()) < 0; };
}  // namespace

DexHelper::DexHelper(const std::vector<std::tuple<const void *, size_t, const void *, size_t>> &dexs) {
    for (const auto &[image, size, data, data_size] : dexs) {
        readers_.emplace_back(static_cast<const dex::u1 *>(image), size, static_cast<const dex::u1 *>(data), data_size);
    }
    auto dex_count = readers_.size();

    // init
    rev_method_indices_.resize(dex_count);
    rev_class_indices_.resize(dex_count);
    rev_field_indices_.resize(dex_count);
    strings_.resize(dex_count);
    method_codes_.resize(dex_count);
    string_cache_.resize(dex_count);
    type_cache_.resize(dex_count);
    field_cache_.resize(dex_count);
    method_cache_.resize(dex_count);
    class_cache_.resize(dex_count);
    invoking_cache_.resize(dex_count);
    invoked_cache_.resize(dex_count);
    getting_cache_.resize(dex_count);
    setting_cache_.resize(dex_count);
    declaring_cache_.resize(dex_count);
    searched_methods_.resize(dex_count);

    for (auto dex_idx = 0zu; dex_idx < dex_count; ++dex_idx) {
        auto &dex = readers_[dex_idx];
        rev_method_indices_[dex_idx].resize(dex.MethodIds().size(), size_t(-1));
        rev_class_indices_[dex_idx].resize(dex.TypeIds().size(), size_t(-1));
        rev_field_indices_[dex_idx].resize(dex.FieldIds().size(), size_t(-1));

        strings_[dex_idx].reserve(dex.StringIds().size());
        method_codes_[dex_idx].resize(dex.MethodIds().size(), nullptr);

        type_cache_[dex_idx].resize(dex.StringIds().size(), dex::kNoIndex);
        field_cache_[dex_idx].resize(dex.TypeIds().size());
        method_cache_[dex_idx].resize(dex.TypeIds().size());
        class_cache_[dex_idx].resize(dex.TypeIds().size(), dex::kNoIndex);

        string_cache_[dex_idx].resize(dex.StringIds().size());
        invoking_cache_[dex_idx].resize(dex.MethodIds().size());
        invoked_cache_[dex_idx].resize(dex.MethodIds().size());
        getting_cache_[dex_idx].resize(dex.FieldIds().size());
        setting_cache_[dex_idx].resize(dex.FieldIds().size());
        declaring_cache_[dex_idx].resize(dex.TypeIds().size());

        searched_methods_[dex_idx].resize(dex.MethodIds().size());
    }

    for (auto dex_idx = 0zu; dex_idx < dex_count; ++dex_idx) {
        auto &dex = readers_[dex_idx];
        auto &strs = strings_[dex_idx];
        for (const auto &str : dex.StringIds()) {
            const auto *ptr = dex.dataPtr<dex::u1>(str.string_data_off);
            dex::ReadULeb128(&ptr);
            strs.emplace_back(reinterpret_cast<const char *>(ptr));
        }
    }

    for (auto dex_idx = 0zu; dex_idx < dex_count; ++dex_idx) {
        auto &dex = readers_[dex_idx];
        for (auto class_idx = 0zu; class_idx < dex.ClassDefs().size(); ++class_idx) {
            const auto &class_def = dex.ClassDefs()[class_idx];
            class_cache_[dex_idx][class_def.class_idx] = class_idx;
            if (class_def.class_data_off == 0) continue;
            const auto *class_data = dex.dataPtr<dex::u1>(class_def.class_data_off);
            dex::u4 static_fields_count = dex::ReadULeb128(&class_data);
            dex::u4 instance_fields_count = dex::ReadULeb128(&class_data);
            dex::u4 direct_methods_count = dex::ReadULeb128(&class_data);
            dex::u4 virtual_methods_count = dex::ReadULeb128(&class_data);

            auto &codes = method_codes_[dex_idx];
            codes.resize(dex.MethodIds().size(), nullptr);

            for (dex::u4 i = 0; i < static_fields_count; ++i) {
                dex::ReadULeb128(&class_data);
                dex::ReadULeb128(&class_data);
            }

            for (dex::u4 i = 0; i < instance_fields_count; ++i) {
                dex::ReadULeb128(&class_data);
                dex::ReadULeb128(&class_data);
            }

            for (dex::u4 i = 0, method_idx = 0; i < direct_methods_count; ++i) {
                method_idx += dex::ReadULeb128(&class_data);
                dex::ReadULeb128(&class_data);
                auto offset = dex::ReadULeb128(&class_data);
                if (offset != 0) {
                    codes[method_idx] = dex.dataPtr<const dex::CodeItem>(offset);
                }
            }

            for (dex::u4 i = 0, method_idx = 0; i < virtual_methods_count; ++i) {
                method_idx += dex::ReadULeb128(&class_data);
                dex::ReadULeb128(&class_data);
                auto offset = dex::ReadULeb128(&class_data);
                if (offset != 0) {
                    codes[method_idx] = dex.dataPtr<dex::CodeItem>(offset);
                }
            }
        }
    }
    for (auto dex_idx = 0zu; dex_idx < dex_count; ++dex_idx) {
        auto &dex = readers_[dex_idx];
        auto &type = type_cache_[dex_idx];
        auto &field = field_cache_[dex_idx];
        auto &declare = declaring_cache_[dex_idx];
        auto &method = method_cache_[dex_idx];
        for (auto type_idx = 0zu; type_idx < dex.TypeIds().size(); ++type_idx) {
            type[dex.TypeIds()[type_idx].descriptor_idx] = type_idx;
        }
        for (auto field_idx = 0zu; field_idx < dex.FieldIds().size(); ++field_idx) {
            auto f = dex.FieldIds()[field_idx];
            field[f.class_idx][f.name_idx] = field_idx;
            declare[f.type_idx].emplace_back(field_idx);
        }
        for (auto method_idx = 0zu; method_idx < dex.MethodIds().size(); ++method_idx) {
            auto m = dex.MethodIds()[method_idx];
            method[m.class_idx][m.name_idx].emplace_back(method_idx);
        }
    }
}

std::tuple<uint32_t, uint32_t> DexHelper::FindPrefixStringId(size_t dex_idx,
                                                             std::string_view to_find) const {
    const auto &strs = strings_[dex_idx];
    if (auto str_lower_bound = std::lower_bound(strs.cbegin(), strs.cend(), to_find, utf8_less),
        str_upper_bound =
            std::upper_bound(strs.cbegin(), strs.cend(), std::string(to_find) + '\xff', utf8_less);
        str_upper_bound != strs.cend() && str_lower_bound != strs.cend() &&
        str_lower_bound <= str_upper_bound) {
        return {str_lower_bound - strs.cbegin(), str_upper_bound - strs.cbegin()};
    }
    return {dex::kNoIndex, dex::kNoIndex};
}

uint32_t DexHelper::FindPrefixStringIdExact(size_t dex_idx, std::string_view to_find) const {
    const auto &strs = strings_[dex_idx];
    auto first = std::lower_bound(strs.cbegin(), strs.cend(), to_find, utf8_less);
    if (first != strs.cend() && *first == to_find) {
        return first - strs.cbegin();
    }
    return dex::kNoIndex;
}

void DexHelper::CreateFullCache() const {
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        const auto &codes = method_codes_[dex_idx];
        for (auto method_id = 0zu; method_id < codes.size(); ++method_id) {
            ScanMethod(dex_idx, method_id);
        }
    }
}

bool DexHelper::ScanMethod(size_t dex_idx, uint32_t method_id, size_t str_lower,
                           size_t str_upper) const {
    static constexpr dex::u1 kOpcodeMask = 0xff;
    static constexpr dex::u1 kOpcodeNoOp = 0x00;
    static constexpr dex::u1 kOpcodeConstString = 0x1a;
    static constexpr dex::u1 kOpcodeConstStringJumbo = 0x1b;
    static constexpr dex::u1 kOpcodeIGetStart = 0x52;
    static constexpr dex::u1 kOpcodeIGetEnd = 0x58;
    static constexpr dex::u1 kOpcodeSGetStart = 0x60;
    static constexpr dex::u1 kOpcodeSGetEnd = 0x66;
    static constexpr dex::u1 kOpcodeIPutStart = 0x59;
    static constexpr dex::u1 kOpcodeIPutEnd = 0x5f;
    static constexpr dex::u1 kOpcodeSPutStart = 0x67;
    static constexpr dex::u1 kOpcodeSPutEnd = 0x6d;
    static constexpr dex::u1 kOpcodeInvokeStart = 0x6e;
    static constexpr dex::u1 kOpcodeInvokeEnd = 0x72;
    static constexpr dex::u1 kOpcodeInvokeRangeStart = 0x74;
    static constexpr dex::u1 kOpcodeInvokeRangeEnd = 0x78;
    static constexpr dex::u2 kInstPackedSwitchPlayLoad = 0x0100;
    static constexpr dex::u2 kInstSparseSwitchPlayLoad = 0x0200;
    static constexpr dex::u2 kInstFillArrayDataPlayLoad = 0x0300;
    auto &dex = readers_[dex_idx];
    auto &str_cache = string_cache_[dex_idx];
    auto &inv_cache = invoking_cache_[dex_idx];
    auto &inved_cache = invoked_cache_[dex_idx];
    auto &get_cache = getting_cache_[dex_idx];
    auto &set_cache = setting_cache_[dex_idx];
    auto &scanned = searched_methods_[dex_idx];

    bool match_str = false;
    if (scanned[method_id]) {
        return match_str;
    }
    scanned[method_id] = true;
    const auto &code = method_codes_[dex_idx][method_id];
    if (!code) {
        return match_str;
    }
    const dex::u2 *inst;
    const dex::u2 *end;
    if (dex.IsCompact()) {
        auto insns_count_and_flags =  reinterpret_cast<const dex::CompactCode*>(code)->insns_count_and_flags;
        inst = reinterpret_cast<const dex::CompactCode*>(code)->insns;
        dex::u4 insns_count = (insns_count_and_flags >> dex::CompactCode::kInsnsSizeShift);
        if (insns_count_and_flags & dex::CompactCode::kFlagPreHeaderInsnsSize) {
            const auto *preheader = reinterpret_cast<const uint16_t*>(code);
            --preheader;
            insns_count += static_cast<uint32_t>(*preheader);
            --preheader;
            insns_count += static_cast<uint32_t>(*preheader) << 16;
        }
        end = inst + insns_count;
    } else {
        inst = reinterpret_cast<const dex::Code*>(code)->insns;
        end = inst + reinterpret_cast<const dex::Code*>(code)->insns_size;
    }
    while (inst < end) {
        dex::u1 opcode = *inst & kOpcodeMask;
        if (opcode == kOpcodeConstString) {
            auto str_idx = inst[1];
            if (str_lower <= str_idx && str_upper > str_idx) {
                match_str = true;
            }
            str_cache[str_idx].emplace_back(method_id);
        }
        if (opcode == kOpcodeConstStringJumbo) {
            auto str_idx = *reinterpret_cast<const dex::u4 *>(&inst[1]);
            if (str_lower <= str_idx && str_upper > str_idx) {
                match_str = true;
            }
            str_cache[str_idx].emplace_back(method_id);
        }
        if ((opcode >= kOpcodeIGetStart && opcode <= kOpcodeIGetEnd) ||
            (opcode >= kOpcodeSGetStart && opcode <= kOpcodeSGetEnd)) {
            auto field_idx = inst[1];
            get_cache[field_idx].emplace_back(method_id);
        }
        if ((opcode >= kOpcodeIPutStart && opcode <= kOpcodeIPutEnd) ||
            (opcode >= kOpcodeSPutStart && opcode <= kOpcodeSPutEnd)) {
            auto field_idx = inst[1];
            set_cache[field_idx].emplace_back(method_id);
        }
        if ((opcode >= kOpcodeInvokeStart && opcode <= kOpcodeInvokeEnd) ||
            (opcode >= kOpcodeInvokeRangeStart && opcode <= kOpcodeInvokeRangeEnd)) {
            auto callee = inst[1];
            inv_cache[method_id].emplace_back(callee);
            inved_cache[callee].emplace_back(method_id);
        }
        if (opcode == kOpcodeNoOp) {
            if (*inst == kInstPackedSwitchPlayLoad) {
                inst += inst[1] * 2 + 3;
            } else if (*inst == kInstSparseSwitchPlayLoad) {
                inst += inst[1] * 4 + 1;
            } else if (*inst == kInstFillArrayDataPlayLoad) {
                inst += (*reinterpret_cast<const dex::u4 *>(&inst[2]) * inst[1] + 1) / 2 + 3;
            }
        }
        inst += dex::opcode_len[opcode];
    }
    return match_str;
}

std::tuple<std::vector<std::vector<uint32_t>>, std::vector<std::vector<uint32_t>>>
DexHelper::ConvertParameters(const std::vector<size_t> &parameter_types,
                             const std::vector<size_t> &contains_parameter_types) const {
    std::vector<std::vector<uint32_t>> parameter_types_ids(readers_.size());
    std::vector<std::vector<uint32_t>> contains_parameter_types_ids(readers_.size());
    if (!parameter_types.empty()) {
        for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
            parameter_types_ids[dex_idx].reserve(parameter_types.size());
        }
        for (const auto &param : parameter_types) {
            if (param != size_t(-1) && param >= class_indices_.size()) {
                return {parameter_types_ids, contains_parameter_types_ids};
            }
            if (param == size_t(-1)) {
                for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
                    parameter_types_ids[dex_idx].emplace_back(-2);
                }
                break;
            }
            auto &ids = class_indices_[param];
            for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
                parameter_types_ids[dex_idx].emplace_back(ids[dex_idx]);
            }
        }
    }

    if (!contains_parameter_types.empty()) {
        for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
            contains_parameter_types_ids[dex_idx].reserve(contains_parameter_types.size());
        }
        for (const auto &param : contains_parameter_types) {
            if (param != size_t(-1) && param >= class_indices_.size()) {
                return {parameter_types_ids, contains_parameter_types_ids};
            }
            auto &ids = class_indices_[param];
            for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
                contains_parameter_types_ids[dex_idx].emplace_back(ids[dex_idx]);
            }
        }
    }
    return {parameter_types_ids, contains_parameter_types_ids};
}

std::vector<size_t> DexHelper::FindMethodUsingString(
    std::string_view str, bool match_prefix, size_t return_type, short parameter_count,
    std::string_view parameter_shorty, size_t declaring_class,
    const std::vector<size_t> &parameter_types, const std::vector<size_t> &contains_parameter_types,
    const std::vector<size_t> &dex_priority, bool find_first) const {
    std::vector<size_t> out;

    if (return_type != size_t(-1) && return_type >= class_indices_.size()) return out;
    if (declaring_class != size_t(-1) && declaring_class >= class_indices_.size()) return out;
    const auto [parameter_types_ids, contains_parameter_types_ids] =
        ConvertParameters(parameter_types, contains_parameter_types);

    for (auto dex_idx : GetPriority(dex_priority)) {
        uint32_t lower;
        uint32_t upper;
        if (match_prefix) {
            std::tie(lower, upper) = FindPrefixStringId(dex_idx, str);
            if (lower == dex::kNoIndex) continue;
        } else {
            lower = upper = FindPrefixStringIdExact(dex_idx, str);
            if (lower == dex::kNoIndex) continue;
            ++upper;
        }
        const auto &codes = method_codes_[dex_idx];
        const auto &strs = string_cache_[dex_idx];
        const auto return_type_id = return_type == size_t(-1) ? uint32_t(-2) : class_indices_[return_type][dex_idx];
        const auto declaring_class_id = declaring_class == size_t(-1) ? uint32_t(-2): class_indices_[declaring_class][dex_idx];

        if (find_first) {
            for (auto s = lower; s < upper; ++s) {
                for (const auto &m : strs[s]) {
                    if (IsMethodMatch(dex_idx, m,
                                      return_type_id,
                                      parameter_count, parameter_shorty,
                                      declaring_class_id,
                                      parameter_types_ids[dex_idx],
                                      contains_parameter_types_ids[dex_idx])) {
                        out.emplace_back(CreateMethodIndex(dex_idx, m));
                        return out;
                    }
                }
            }
        }

        for (auto method_id = 0zu; method_id < codes.size(); ++method_id) {
            auto &scanned = searched_methods_[dex_idx];
            if (scanned[method_id]) continue;
            if (IsMethodMatch(
                    dex_idx, method_id,
                    return_type_id,
                    parameter_count, parameter_shorty,
                    declaring_class_id,
                    parameter_types_ids[dex_idx], contains_parameter_types_ids[dex_idx])) {
                bool match = ScanMethod(dex_idx, method_id, lower, upper);
                if (match && find_first) break;
            }
        }

        for (auto s = lower; s < upper; ++s) {
            for (const auto &m : strs[s]) {
                if (IsMethodMatch(dex_idx, m,
                        return_type_id,
                                 parameter_count, parameter_shorty,
                                 declaring_class_id,
                                 parameter_types_ids[dex_idx],
                                 contains_parameter_types_ids[dex_idx])) {
                    out.emplace_back(CreateMethodIndex(dex_idx, m));
                    if (find_first) return out;
                }
            }
        }
    }
    return out;
}

std::vector<size_t> DexHelper::FindMethodInvoking(
    size_t method_idx, size_t return_type, short parameter_count, std::string_view parameter_shorty,
    size_t declaring_class, const std::vector<size_t> &parameter_types,
    const std::vector<size_t> &contains_parameter_types, const std::vector<size_t> &dex_priority,
    bool find_first) const {
    std::vector<size_t> out;

    if (method_idx >= method_indices_.size()) return out;
    if (return_type != size_t(-1) && return_type >= class_indices_.size()) return out;
    if (declaring_class != size_t(-1) && declaring_class >= class_indices_.size()) return out;
    const auto [parameter_types_ids, contains_parameter_types_ids] =
        ConvertParameters(parameter_types, contains_parameter_types);

    const auto method_ids = method_indices_[method_idx];

    for (auto dex_idx : GetPriority(dex_priority)) {
        auto caller_id = method_ids[dex_idx];
        if (caller_id == dex::kNoIndex) continue;
        const auto return_type_id = return_type == size_t(-1) ? uint32_t(-2) : class_indices_[return_type][dex_idx];
        const auto declaring_class_id = declaring_class == size_t(-1) ? uint32_t(-2): class_indices_[declaring_class][dex_idx];
        ScanMethod(dex_idx, caller_id);
        for (auto callee : invoking_cache_[dex_idx][caller_id]) {
            if (IsMethodMatch(
                    dex_idx, callee,
                    return_type_id,
                    parameter_count, parameter_shorty,
                    declaring_class_id,
                    parameter_types_ids[dex_idx], contains_parameter_types_ids[dex_idx])) {
                out.emplace_back(CreateMethodIndex(dex_idx, callee));
                if (find_first) return out;
            }
        }
    }
    return out;
}

std::vector<size_t> DexHelper::FindMethodInvoked(
    size_t method_idx, size_t return_type, short parameter_count, std::string_view parameter_shorty,
    size_t declaring_class, const std::vector<size_t> &parameter_types,
    const std::vector<size_t> &contains_parameter_types, const std::vector<size_t> &dex_priority,
    bool find_first) const {
    std::vector<size_t> out;

    if (method_idx >= method_indices_.size()) return out;
    if (return_type != size_t(-1) && return_type >= class_indices_.size()) return out;
    if (declaring_class != size_t(-1) && declaring_class >= class_indices_.size()) return out;
    const auto [parameter_types_ids, contains_parameter_types_ids] =
        ConvertParameters(parameter_types, contains_parameter_types);

    const auto method_ids = method_indices_[method_idx];

    for (auto dex_idx : GetPriority(dex_priority)) {
        auto callee_id = method_ids[dex_idx];
        if (callee_id == dex::kNoIndex) continue;
        const auto &codes = method_codes_[dex_idx];
        const auto &cache = invoked_cache_[dex_idx][callee_id];
        const auto return_type_id = return_type == size_t(-1) ? uint32_t(-2) : class_indices_[return_type][dex_idx];
        const auto declaring_class_id = declaring_class == size_t(-1) ? uint32_t(-2): class_indices_[declaring_class][dex_idx];
        if (find_first && !cache.empty()) {
            for(const auto &caller : cache) {
                if (IsMethodMatch(dex_idx, caller,
                                  return_type_id,
                                  parameter_count, parameter_shorty,
                                  declaring_class_id,
                                  parameter_types_ids[dex_idx],
                                  contains_parameter_types_ids[dex_idx])) {
                    out.emplace_back(CreateMethodIndex(dex_idx, caller));
                    return out;
                }
            }
        }
        for (auto method_id = 0zu; method_id < codes.size(); ++method_id) {
            auto &scanned = searched_methods_[dex_idx];
            if (scanned[method_id]) continue;
            if (IsMethodMatch(
                    dex_idx, method_id,
                    return_type_id,
                    parameter_count, parameter_shorty,
                    declaring_class_id,
                    parameter_types_ids[dex_idx], contains_parameter_types_ids[dex_idx])) {
                ScanMethod(dex_idx, method_id);
                if (find_first && !cache.empty()) break;
            }
        }
        for (const auto &caller : cache) {
            if (IsMethodMatch(dex_idx, caller,
                              return_type_id,
                              parameter_count, parameter_shorty,
                              declaring_class_id,
                              parameter_types_ids[dex_idx],
                              contains_parameter_types_ids[dex_idx])) {
                out.emplace_back(CreateMethodIndex(dex_idx, caller));
                if (find_first) return out;
            }
        }
    }
    return out;
}

std::vector<size_t> DexHelper::FindMethodGettingField(
    size_t field_idx, size_t return_type, short parameter_count, std::string_view parameter_shorty,
    size_t declaring_class, const std::vector<size_t> &parameter_types,
    const std::vector<size_t> &contains_parameter_types, const std::vector<size_t> &dex_priority,
    bool find_first) const {
    std::vector<size_t> out;

    if (field_idx >= field_indices_.size()) return out;
    if (return_type != size_t(-1) && return_type >= class_indices_.size()) return out;
    if (declaring_class != size_t(-1) && declaring_class >= class_indices_.size()) return out;
    const auto [parameter_types_ids, contains_parameter_types_ids] =
        ConvertParameters(parameter_types, contains_parameter_types);
    auto field_ids = field_indices_[field_idx];
    for (auto dex_idx : GetPriority(dex_priority)) {
        auto field_id = field_ids[dex_idx];
        if (field_id == dex::kNoIndex) continue;
        const auto &codes = method_codes_[dex_idx];
        const auto &cache = getting_cache_[dex_idx][field_id];
        const auto return_type_id = return_type == size_t(-1) ? uint32_t(-2) : class_indices_[return_type][dex_idx];
        const auto declaring_class_id = declaring_class == size_t(-1) ? uint32_t(-2): class_indices_[declaring_class][dex_idx];
        if (find_first && !cache.empty()) {
            for (const auto &getter : cache) {
                if (IsMethodMatch(dex_idx, getter,
                                  return_type_id,
                                  parameter_count, parameter_shorty,
                                  declaring_class_id,
                                  parameter_types_ids[dex_idx],
                                  contains_parameter_types_ids[dex_idx])) {
                    out.emplace_back(CreateMethodIndex(dex_idx, getter));
                    return out;
                }
            }
        }
        for (auto method_id = 0zu; method_id < codes.size(); ++method_id) {
            auto &scanned = searched_methods_[dex_idx];
            if (scanned[method_id]) continue;
            if (IsMethodMatch(
                    dex_idx, method_id,
                    return_type_id,
                    parameter_count, parameter_shorty,
                    declaring_class_id,
                    parameter_types_ids[dex_idx], contains_parameter_types_ids[dex_idx])) {
                ScanMethod(dex_idx, method_id);
                if (find_first && !cache.empty()) break;
            }
        }
        for (const auto &getter : cache) {
            if (IsMethodMatch(dex_idx, getter,
                              return_type_id,
                              parameter_count, parameter_shorty,
                              declaring_class_id,
                              parameter_types_ids[dex_idx],
                              contains_parameter_types_ids[dex_idx])) {
                out.emplace_back(CreateMethodIndex(dex_idx, getter));
                if (find_first) return out;
            }
        }
    }
    return out;
}

std::vector<size_t> DexHelper::FindMethodSettingField(
    size_t field_idx, size_t return_type, short parameter_count, std::string_view parameter_shorty,
    size_t declaring_class, const std::vector<size_t> &parameter_types,
    const std::vector<size_t> &contains_parameter_types, const std::vector<size_t> &dex_priority,
    bool find_first) const {
    std::vector<size_t> out;

    if (field_idx >= field_indices_.size()) return out;
    if (return_type != size_t(-1) && return_type >= class_indices_.size()) return out;
    if (declaring_class != size_t(-1) && declaring_class >= class_indices_.size()) return out;
    const auto [parameter_types_ids, contains_parameter_types_ids] =
        ConvertParameters(parameter_types, contains_parameter_types);
    auto field_ids = field_indices_[field_idx];
    for (auto dex_idx : GetPriority(dex_priority)) {
        auto field_id = field_ids[dex_idx];
        if (field_id == dex::kNoIndex) continue;
        const auto &codes = method_codes_[dex_idx];
        const auto &cache = setting_cache_[dex_idx][field_id];
        const auto return_type_id = return_type == size_t(-1) ? uint32_t(-2) : class_indices_[return_type][dex_idx];
        const auto declaring_class_id = declaring_class == size_t(-1) ? uint32_t(-2): class_indices_[declaring_class][dex_idx];
        if (find_first && !cache.empty()) {
            for (const auto &setter : cache) {
                if (IsMethodMatch(dex_idx, setter,
                                  return_type_id,
                                  parameter_count, parameter_shorty,
                                  declaring_class_id,
                                  parameter_types_ids[dex_idx],
                                  contains_parameter_types_ids[dex_idx])) {
                    out.emplace_back(CreateMethodIndex(dex_idx, setter));
                    return out;
                }
            }
        }
        for (auto method_id = 0zu; method_id < codes.size(); ++method_id) {
            auto &scanned = searched_methods_[dex_idx];
            if (scanned[method_id]) continue;
            if (IsMethodMatch(
                    dex_idx, method_id,
                    return_type == size_t(-1) ? uint32_t(-2)
                                              : class_indices_[return_type][dex_idx],
                    parameter_count, parameter_shorty,
                    declaring_class == size_t(-1) ? uint32_t(-2)
                                                  : class_indices_[declaring_class][dex_idx],
                    parameter_types_ids[dex_idx], contains_parameter_types_ids[dex_idx])) {
                ScanMethod(dex_idx, method_id);
                if (find_first && !cache.empty()) break;
            }
        }
        for (const auto &setter : cache) {
            if (IsMethodMatch(dex_idx, setter,
                              return_type_id,
                              parameter_count, parameter_shorty,
                              declaring_class_id,
                              parameter_types_ids[dex_idx],
                              contains_parameter_types_ids[dex_idx])) {
                out.emplace_back(CreateMethodIndex(dex_idx, setter));
                if (find_first) return out;
            }
        }
    }
    return out;
}
std::vector<size_t> DexHelper::FindField(size_t type, const std::vector<size_t> &dex_priority,
                                         bool find_first) const {
    std::vector<size_t> out;

    if (type >= class_indices_.size()) return out;
    auto &type_ids = class_indices_[type];
    for (auto dex_idx : GetPriority(dex_priority)) {
        const auto type_id = type_ids[dex_idx];
        if (type_id == dex::kNoIndex) continue;
        for (auto &field_id : declaring_cache_[dex_idx][type_id]) {
            out.emplace_back(CreateFieldIndex(dex_idx, field_id));
            if (find_first) return out;
        }
    }
    return out;
}

bool DexHelper::IsMethodMatch(size_t dex_id, uint32_t method_id, uint32_t return_type,
                              short parameter_count, std::string_view parameter_shorty,
                              uint32_t declaring_class,
                              const std::vector<uint32_t> &parameter_types,
                              const std::vector<uint32_t> &contains_parameter_types) const {
    const auto &dex = readers_[dex_id];
    const auto &method = dex.MethodIds()[method_id];
    const auto &strs = strings_[dex_id];
    if (declaring_class != uint32_t(-2) && method.class_idx != declaring_class) return false;
    const auto &proto = dex.ProtoIds()[method.proto_idx];
    const auto &shorty = strs[proto.shorty_idx];
    if (return_type != uint32_t(-2) && proto.return_type_idx != return_type) return false;
    if (!parameter_shorty.empty() && shorty != parameter_shorty) return false;
    if (parameter_count != -1 || !parameter_types.empty() || !contains_parameter_types.empty()) {
        auto param_off = dex.ProtoIds()[method.proto_idx].parameters_off;
        const auto *params = param_off ? dex.dataPtr<dex::TypeList>(param_off) : nullptr;
        const auto params_size = params ? params->size : 0zu;
        if (parameter_count != -1 && params_size != parameter_count) return false;
        if (!parameter_types.empty()) {
            if (parameter_types.size() != params_size) return false;
            for (auto i = 0zu; i < params_size; ++i) {
                if (parameter_types[i] != uint32_t(-2) && parameter_types[i] != params->list[i].type_idx) return false;
            }
        }
        if (!contains_parameter_types.empty()) {
            for (const auto &type : contains_parameter_types) {
                bool contains = false;
                for (auto i = 0zu; i < params_size; ++i) {
                    if (type == params->list[i].type_idx) {
                        contains = true;
                        break;
                    }
                }
                if (!contains) return false;
            }
        }
    }
    return true;
}
size_t DexHelper::CreateMethodIndex(std::string_view class_name, std::string_view method_name,
                                    const std::vector<std::string_view> &params_name) const {
    std::vector<uint32_t> method_ids;
    method_ids.resize(readers_.size(), dex::kNoIndex);
    bool created = false;
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        const auto &strs = strings_[dex_idx];
        auto method_name_iter = std::lower_bound(strs.cbegin(), strs.cend(), method_name, utf8_less);
        if (method_name_iter == strs.cend() || *method_name_iter != method_name) continue;
        auto method_name_id = method_name_iter - strs.cbegin();
        auto class_name_iter = std::lower_bound(strs.cbegin(), strs.cend(), class_name, utf8_less);
        if (class_name_iter == strs.cend() || *class_name_iter != class_name) continue;
        auto class_name_id = class_name_iter - strs.cbegin();
        auto class_id = type_cache_[dex_idx][class_name_id];
        if (class_id == dex::kNoIndex) continue;
        auto candidates = method_cache_[dex_idx][class_id].find(method_name_id);
        if (candidates == method_cache_[dex_idx][class_id].end()) continue;
        for (const auto &method_id : candidates->second) {
            const auto &dex = readers_[dex_idx];
            auto param_off = dex.ProtoIds()[dex.MethodIds()[method_id].proto_idx].parameters_off;
            const auto *params = param_off ? dex.dataPtr<dex::TypeList>(param_off) : nullptr;
            if (params && params->size != params_name.size()) continue;
            if (!params_name.empty() && !params) continue;
            bool are_params_same = true;
            for (auto i = 0zu; i < params_name.size(); ++i) {
                if (strs[dex.TypeIds()[params->list[i].type_idx].descriptor_idx] !=
                    params_name[i]) {
                    are_params_same = false;
                    break;
                }
            }
            if (!are_params_same) continue;
            if (auto idx = rev_method_indices_[dex_idx][method_id]; idx != size_t(-1)) return idx;
            created = true;
            method_ids[dex_idx] = method_id;
        }
    }
    if (!created) return -1;
    auto index = method_indices_.size();
    for (auto dex_id = 0zu; dex_id < readers_.size(); ++dex_id) {
        auto method_id = method_ids[dex_id];
        if (method_id != dex::kNoIndex) rev_method_indices_[dex_id][method_id] = index;
    }
    method_indices_.emplace_back(std::move(method_ids));
    return index;
}

size_t DexHelper::CreateClassIndex(std::string_view class_name) const {
    std::vector<uint32_t> class_ids;
    class_ids.resize(readers_.size(), dex::kNoIndex);
    bool created = false;
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        const auto &strs = strings_[dex_idx];
        auto class_name_iter = std::lower_bound(strs.cbegin(), strs.cend(), class_name, utf8_less);
        if (class_name_iter == strs.cend() || *class_name_iter != class_name) continue;
        auto class_name_id = class_name_iter - strs.cbegin();
        auto class_id = type_cache_[dex_idx][class_name_id];
        if (class_id == dex::kNoIndex) continue;
        if (auto idx = rev_class_indices_[dex_idx][class_id]; idx != size_t(-1)) return idx;
        created = true;
        class_ids[dex_idx] = class_id;
    }
    if (!created) return -1;
    auto index = class_indices_.size();
    for (auto dex_id = 0zu; dex_id < readers_.size(); ++dex_id) {
        auto class_id = class_ids[dex_id];
        if (class_id != dex::kNoIndex) rev_class_indices_[dex_id][class_id] = index;
    }
    class_indices_.emplace_back(std::move(class_ids));
    return index;
}

size_t DexHelper::CreateFieldIndex(std::string_view class_name, std::string_view field_name) const {
    std::vector<uint32_t> field_ids;
    field_ids.resize(readers_.size(), dex::kNoIndex);

    bool created = false;
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        const auto &strs = strings_[dex_idx];
        auto class_name_iter = std::lower_bound(strs.cbegin(), strs.cend(), class_name, utf8_less);
        if (class_name_iter == strs.cend() || *class_name_iter != class_name) continue;
        auto class_name_id = class_name_iter - strs.cbegin();
        auto field_name_iter = std::lower_bound(strs.cbegin(), strs.cend(), field_name, utf8_less);
        if (field_name_iter == strs.cend() || *field_name_iter != field_name) continue;
        auto field_name_id = field_name_iter - strs.cbegin();
        auto class_id = type_cache_[dex_idx][class_name_id];
        if (class_id == dex::kNoIndex) continue;
        auto iter = field_cache_[dex_idx][class_id].find(field_name_id);
        if (iter == field_cache_[dex_idx][class_id].end()) continue;
        auto field_id = iter->second;
        if (auto idx = rev_field_indices_[dex_idx][field_id]; idx != size_t(-1)) return idx;
        created = true;
        field_ids[dex_idx] = field_id;
    }
    if (!created) return -1;
    auto index = field_indices_.size();
    for (auto dex_id = 0zu; dex_id < readers_.size(); ++dex_id) {
        auto field_id = field_ids[dex_id];
        if (field_id != dex::kNoIndex) rev_field_indices_[dex_id][field_id] = index;
    }
    field_indices_.emplace_back(std::move(field_ids));
    return index;
}

size_t DexHelper::CreateMethodIndex(size_t dex_idx, uint32_t method_id) const {
    const auto &dex = readers_[dex_idx];
    const auto &strs = strings_[dex_idx];
    const auto &method = dex.MethodIds()[method_id];
    auto param_off = dex.ProtoIds()[dex.MethodIds()[method_id].proto_idx].parameters_off;
    const auto *params = param_off ? dex.dataPtr<dex::TypeList>(param_off) : nullptr;
    std::vector<std::string_view> param_names;
    if (params) {
        param_names.reserve(params->size);
        for (auto i = 0zu; i < params->size; ++i) {
            param_names.emplace_back(strs[dex.TypeIds()[params->list[i].type_idx].descriptor_idx]);
        }
    }
    return CreateMethodIndex(strs[dex.TypeIds()[method.class_idx].descriptor_idx],
                             strs[method.name_idx], param_names);
}

size_t DexHelper::CreateClassIndex(size_t dex_idx, uint32_t class_id) const {
    const auto &dex = readers_[dex_idx];
    const auto &strs = strings_[dex_idx];
    return CreateClassIndex(strs[dex.TypeIds()[class_id].descriptor_idx]);
}

size_t DexHelper::CreateFieldIndex(size_t dex_idx, uint32_t field_id) const {
    const auto &dex = readers_[dex_idx];
    const auto &strs = strings_[dex_idx];
    const auto &field = dex.FieldIds()[field_id];
    return CreateFieldIndex(strs[dex.TypeIds()[field.class_idx].descriptor_idx],
                            strs[field.name_idx]);
}

auto DexHelper::DecodeClass(size_t class_idx) const -> Class {
    if (class_idx >= class_indices_.size()) return {};
    auto &class_ids = class_indices_[class_idx];
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        auto class_id = class_ids[dex_idx];
        if (class_id == dex::kNoIndex) continue;
        return {
            .name = strings_[dex_idx][readers_[dex_idx].TypeIds()[class_id].descriptor_idx],
        };
    }
    return {};
}

auto DexHelper::DecodeField(size_t field_idx) const -> Field {
    if (field_idx >= field_indices_.size()) return {};
    auto &field_ids = field_indices_[field_idx];
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        auto field_id = field_ids[dex_idx];
        if (field_id == dex::kNoIndex) continue;
        const auto &dex = readers_[dex_idx];
        const auto &field = dex.FieldIds()[field_id];
        const auto &strs = strings_[dex_idx];
        return {
            .declaring_class =
                {
                    .name = strs[dex.TypeIds()[field.class_idx].descriptor_idx],
                },
            .type = {.name = strs[dex.TypeIds()[field.type_idx].descriptor_idx]},
            .name = strings_[dex_idx][field.name_idx],
        };
    }
    return {};
}

auto DexHelper::DecodeMethod(size_t method_idx) const -> Method {
    if (method_idx >= method_indices_.size()) return {};
    auto &method_ids = method_indices_[method_idx];
    for (auto dex_idx = 0zu; dex_idx < readers_.size(); ++dex_idx) {
        auto method_id = method_ids[dex_idx];
        if (method_id == dex::kNoIndex) continue;
        const auto &dex = readers_[dex_idx];
        const auto &method = dex.MethodIds()[method_id];
        const auto &strs = strings_[dex_idx];
        std::vector<Class> parameters;
        auto param_off = dex.ProtoIds()[dex.MethodIds()[method_id].proto_idx].parameters_off;
        const auto *params = param_off ? dex.dataPtr<dex::TypeList>(param_off) : nullptr;
        auto params_size = params ? params->size : 0zu;
        for (auto i = 0zu; i < params_size; ++i) {
            parameters.emplace_back(Class{
                .name = strs[dex.TypeIds()[params->list[i].type_idx].descriptor_idx],
            });
        }
        return {.declaring_class =
                    {
                        .name = strs[dex.TypeIds()[method.class_idx].descriptor_idx],
                    },
                .name = strs[method.name_idx],
                .parameters = std::move(parameters),
                .return_type = {
                    .name = strs[dex.TypeIds()[dex.ProtoIds()[method.proto_idx].return_type_idx]
                                     .descriptor_idx]}};
    }
    return {};
}

std::vector<size_t> DexHelper::GetPriority(const std::vector<size_t> &priority) const {
    std::vector<size_t> out;
    if (priority.empty()) {
        for (auto i = 0zu; i < readers_.size(); ++i) {
            out.emplace_back(i);
        }
    } else {
        for (const auto &i : priority) {
            if (i < readers_.size()) {
                out.emplace_back(i);
            }
        }
    }
    return out;
}

```

`dex_helper_test.cc`:

```cc
#include "dex_helper.h"
#include <cstdint>
#include <endian.h>
#include <fcntl.h>
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

std::ostream &operator<<(std::ostream &out, const DexHelper::Class &clazz) {
  return out << clazz.name;
}

std::ostream &operator<<(std::ostream &out, const DexHelper::Field &field) {
  return out << field.declaring_class.name << "->" << field.name << ":"
             << field.type.name;
}

std::ostream &operator<<(std::ostream &out, const DexHelper::Method &method) {
  out << method.declaring_class.name << "->" << method.name << "(";

  for (auto &param : method.parameters) {
    out << param.name;
  }

  return out << ")" << method.return_type.name;
}

int main(int argc, char *argv[]) {
  std::vector<std::tuple<const void *, size_t>> dexs;
  for (int i = 1; i <= 100; ++i) {
    std::string path = "dexs/classes" +
                       (i == 1 ? std::string("") : std::to_string(i)) + ".dex";
    int raw_dex = open(path.data(), O_RDONLY);
    if (raw_dex == -1) {
        break;
    }
    struct stat s {};
    fstat(raw_dex, &s);
    auto *out = reinterpret_cast<const dex::u1 *>(
        mmap(nullptr, s.st_size, PROT_READ, MAP_PRIVATE, raw_dex, 0));
    dexs.emplace_back(out, s.st_size);
  }

  std::string_view to_find = argv[2];
  DexHelper helper(dexs);

  auto class_idx = helper.CreateClassIndex("Ljava/lang/Object;");
  auto clazz = helper.DecodeClass(class_idx);
  std::cout << "got class: " << clazz << std::endl;

  auto field_indices = helper.FindField(class_idx, {}, true);
  if (!field_indices.empty()) {
    auto field_idx = field_indices[0];
    auto field = helper.DecodeField(field_idx);
    std::cout << "got field: " << field << std::endl;
    {
      auto method_indices = helper.FindMethodSettingField(field_idx, -1, -1, "",
                                                          -1, {}, {}, {}, true);
      if (!method_indices.empty()) {
        auto method_idx = method_indices[0];
        auto method = helper.DecodeMethod(method_idx);
        std::cout << "got method settings field " << field << " : " << method << std::endl;
      }
    }
    {
      auto method_indices = helper.FindMethodGettingField(field_idx, -1, -1, "",
                                                          -1, {}, {}, {}, true);
      if (!method_indices.empty()) {
        auto method_idx = method_indices[0];
        auto method = helper.DecodeMethod(method_idx);
        std::cout << "got method getting field " << field << " : " << method << std::endl;
      }
    }
  }
  auto method_indices = helper.FindMethodUsingString(
      "isNullableType", false, -1, 1, "VI", -1, {}, {}, {}, true);
  if (!method_indices.empty()) {
    auto method_idx = method_indices[0];
    auto method = helper.DecodeMethod(method_idx);
    std::cout << "got method with string: " << method << std::endl;
    {
      auto method_indices = helper.FindMethodInvoking(method_idx, -1, -1, "",
                                                      -1, {}, {}, {}, true);
      if (!method_indices.empty()) {
        auto method_idx = method_indices[0];
        auto callee = helper.DecodeMethod(method_idx);
        std::cout << "got method " << method << " invoking " << callee << std::endl;
      }
    }
    {
      auto method_indices =
          helper.FindMethodInvoked(method_idx, -1, -1, "", -1, {}, {}, {}, true);
      if (!method_indices.empty()) {
        auto method_idx = method_indices[0];
        auto caller = helper.DecodeMethod(method_idx);
        std::cout << "got method invoked by " << caller << " : " << method << std::endl;
      }
    }
  }
  //   helper.CreateFullCache();
}
```

`dex_testcase_generator.cc`:

```cc
/* DexBuilder
 * Copyright (C) 2021 LSPosed
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Copyright (C) 2018 The Android Open Source Project
 * Modifications copyright (C) 2021 LSPosed Developers
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "dex_builder.h"
#include "slicer/dex_format.h"
#include "slicer/reader.h"

#include <cstdint>
#include <fstream>
#include <iterator>
#include <string>
#include <iostream>
#include <vector>

// Adding tests here requires changes in several other places. See README.md in
// the view_compiler directory for more information.

using namespace startop::dex;
using namespace std;

void GenerateTrivialDexFile(const string &outdir) {
  DexBuilder dex_file;

  ClassBuilder cbuilder{
      dex_file.MakeClass("android.startop.test.testcases.Trivial")};
  cbuilder.set_source_file("dex_testcase_generator.cc#GenerateTrivialDexFile");

  slicer::MemView image{dex_file.CreateImage()};
  std::ofstream out_file(outdir + "/trivial.dex");
  out_file.write(image.ptr<const char>(), image.size());
}

// Generates test cases that test around 1 instruction.
void GenerateSimpleTestCases(const string &outdir) {
  DexBuilder dex_file;

  ClassBuilder cbuilder{
      dex_file.MakeClass("android.startop.test.testcases.SimpleTests")};
  cbuilder.set_source_file("dex_testcase_generator.cc#GenerateSimpleTestCases");

  auto static_field =
      cbuilder.CreateField("staticInteger", TypeDescriptor::Int);
  static_field.Encode();
  auto instance_field =
      cbuilder.CreateField("instanceField", TypeDescriptor::Int);
  instance_field.access_flags(dex::kAccPublic);
  instance_field.Encode();

  // int return5() { return 5; }
  auto return5{
      cbuilder.CreateMethod("return5", Prototype{TypeDescriptor::Int})};
  {
    LiveRegister r{return5.AllocRegister()};
    return5.BuildConst(r, 5);
    return5.BuildReturn(r);
  }
  return5.Encode();

  // int return5() { return 5; }
  auto returnInteger5{cbuilder.CreateMethod(
      "returnInteger5", Prototype{TypeDescriptor::ObjectInt})};
  [&](MethodBuilder &method) {
    LiveRegister five{method.AllocRegister()};
    method.BuildConst(five, 5);
    LiveRegister object{method.AllocRegister()};
    method.BuildNew(object, TypeDescriptor::ObjectInt,
                    Prototype{TypeDescriptor::Void, TypeDescriptor::Int}, five);
    method.BuildUnBoxIfPrimitive(five, TypeDescriptor::ObjectInt, object);
    method.BuildReturn(object, /*is_object=*/true);
  }(returnInteger5);
  returnInteger5.Encode();

  // // int returnParam(int x) { return x; }
  auto returnParam{cbuilder.CreateMethod(
      "returnParam", Prototype{TypeDescriptor::Int, TypeDescriptor::Int})};
  returnParam.BuildReturn(Value::Parameter(0));
  returnParam.Encode();

  // int returnStringLength(String x) { return x.length(); }
  MethodDeclData string_length{dex_file.GetOrDeclareMethod(
      TypeDescriptor::String, "length", Prototype{TypeDescriptor::Int})};

  auto returnStringLength{cbuilder.CreateMethod(
      "returnStringLength",
      Prototype{TypeDescriptor::Int, TypeDescriptor::String})};
  {
    LiveRegister result = returnStringLength.AllocRegister();
    returnStringLength.AddInstruction(Instruction::InvokeVirtual(
        string_length.id, result, Value::Parameter(0)));
    returnStringLength.BuildReturn(result);
  }
  returnStringLength.Encode();

  // int returnIfZero(int x) { if (x == 0) { return 5; } else { return 3; } }
  MethodBuilder returnIfZero{cbuilder.CreateMethod(
      "returnIfZero", Prototype{TypeDescriptor::Int, TypeDescriptor::Int})};
  {
    LiveRegister resultIfZero{returnIfZero.AllocRegister()};
    Value else_target{returnIfZero.MakeLabel()};
    returnIfZero.AddInstruction(
        Instruction::OpWithArgs(Instruction::Op::kBranchEqz, /*dest=*/{},
                                Value::Parameter(0), else_target));
    // else branch
    returnIfZero.BuildConst(resultIfZero, 3);
    returnIfZero.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturn, /*dest=*/{}, resultIfZero));
    // then branch
    returnIfZero.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kBindLabel, /*dest=*/{}, else_target));
    returnIfZero.BuildConst(resultIfZero, 5);
    returnIfZero.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturn, /*dest=*/{}, resultIfZero));
  }
  returnIfZero.Encode();

  // int returnIfNotZero(int x) { if (x != 0) { return 5; } else { return 3; } }
  MethodBuilder returnIfNotZero{cbuilder.CreateMethod(
      "returnIfNotZero", Prototype{TypeDescriptor::Int, TypeDescriptor::Int})};
  {
    LiveRegister resultIfNotZero{returnIfNotZero.AllocRegister()};
    Value else_target{returnIfNotZero.MakeLabel()};
    returnIfNotZero.AddInstruction(
        Instruction::OpWithArgs(Instruction::Op::kBranchNEqz, /*dest=*/{},
                                Value::Parameter(0), else_target));
    // else branch
    returnIfNotZero.BuildConst(resultIfNotZero, 3);
    returnIfNotZero.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturn, /*dest=*/{}, resultIfNotZero));
    // then branch
    returnIfNotZero.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kBindLabel, /*dest=*/{}, else_target));
    returnIfNotZero.BuildConst(resultIfNotZero, 5);
    returnIfNotZero.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturn, /*dest=*/{}, resultIfNotZero));
  }
  returnIfNotZero.Encode();

  // Make sure backwards branches work too.
  //
  // Pseudo code for test:
  // {
  //   zero = 0;
  //   result = 1;
  //   if (zero == 0) goto B;
  // A:
  //   return result;
  // B:
  //   result = 2;
  //   if (zero == 0) goto A;
  //   result = 3;
  //   return result;
  // }
  // If it runs correctly, this test should return 2.
  MethodBuilder backwardsBranch{
      cbuilder.CreateMethod("backwardsBranch", Prototype{TypeDescriptor::Int})};
  [](MethodBuilder &method) {
    LiveRegister zero = method.AllocRegister();
    LiveRegister result = method.AllocRegister();
    Value labelA = method.MakeLabel();
    Value labelB = method.MakeLabel();
    method.BuildConst(zero, 0);
    method.BuildConst(result, 1);
    method.AddInstruction(Instruction::OpWithArgs(Instruction::Op::kBranchEqz,
                                                  /*dest=*/{}, zero, labelB));

    method.AddInstruction(Instruction::OpWithArgs(Instruction::Op::kBindLabel,
                                                  /*dest=*/{}, labelA));
    method.BuildReturn(result);

    method.AddInstruction(Instruction::OpWithArgs(Instruction::Op::kBindLabel,
                                                  /*dest=*/{}, labelB));
    method.BuildConst(result, 2);
    method.AddInstruction(Instruction::OpWithArgs(Instruction::Op::kBranchEqz,
                                                  /*dest=*/{}, zero, labelA));

    method.BuildConst(result, 3);
    method.BuildReturn(result);
  }(backwardsBranch);
  backwardsBranch.Encode();

  // Test that we can make a null value. Basically:
  //
  // public static String returnNull() { return null; }
  MethodBuilder returnNull{
      cbuilder.CreateMethod("returnNull", Prototype{TypeDescriptor::String})};
  [](MethodBuilder &method) {
    LiveRegister zero = method.AllocRegister();
    method.BuildConst(zero, 0);
    method.BuildReturn(zero, /*is_object=*/true);
  }(returnNull);
  returnNull.Encode();

  // Test that we can make String literals. Basically:
  //
  // public static String makeString() { return "Hello, World!"; }
  MethodBuilder makeString{
      cbuilder.CreateMethod("makeString", Prototype{TypeDescriptor::String})};
  [](MethodBuilder &method) {
    LiveRegister string = method.AllocRegister();
    method.BuildConstString(string, "Hello, World!");
    method.BuildReturn(string, /*is_object=*/true);
  }(makeString);
  makeString.Encode();

  // Make sure strings are sorted correctly.
  //
  // int returnStringIfZeroAB(int x) { if (x == 0) { return "a"; } else { return
  // "b"; } }
  MethodBuilder returnStringIfZeroAB{cbuilder.CreateMethod(
      "returnStringIfZeroAB",
      Prototype{TypeDescriptor::String, TypeDescriptor::Int})};
  [&](MethodBuilder &method) {
    LiveRegister resultIfZero{method.AllocRegister()};
    Value else_target{method.MakeLabel()};
    method.AddInstruction(
        Instruction::OpWithArgs(Instruction::Op::kBranchEqz, /*dest=*/{},
                                Value::Parameter(0), else_target));
    // else branch
    method.BuildConstString(resultIfZero, "b");
    method.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturnObject, /*dest=*/{}, resultIfZero));
    // then branch
    method.AddInstruction(Instruction::OpWithArgs(Instruction::Op::kBindLabel,
                                                  /*dest=*/{}, else_target));
    method.BuildConstString(resultIfZero, "a");
    method.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturnObject, /*dest=*/{}, resultIfZero));
    method.Encode();
  }(returnStringIfZeroAB);
  // int returnStringIfZeroAB(int x) { if (x == 0) { return "b"; } else { return
  // "a"; } }
  MethodBuilder returnStringIfZeroBA{cbuilder.CreateMethod(
      "returnStringIfZeroBA",
      Prototype{TypeDescriptor::String, TypeDescriptor::Int})};
  [&](MethodBuilder &method) {
    LiveRegister resultIfZero{method.AllocRegister()};
    Value else_target{method.MakeLabel()};
    method.AddInstruction(
        Instruction::OpWithArgs(Instruction::Op::kBranchEqz, /*dest=*/{},
                                Value::Parameter(0), else_target));
    // else branch
    method.BuildConstString(resultIfZero, "a");
    method.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturnObject, /*dest=*/{}, resultIfZero));
    // then branch
    method.AddInstruction(Instruction::OpWithArgs(Instruction::Op::kBindLabel,
                                                  /*dest=*/{}, else_target));
    method.BuildConstString(resultIfZero, "b");
    method.AddInstruction(Instruction::OpWithArgs(
        Instruction::Op::kReturnObject, /*dest=*/{}, resultIfZero));
    method.Encode();
  }(returnStringIfZeroBA);

  // Make sure we can invoke static methods that return an object
  // String invokeStaticReturnObject(int n, int radix) { return
  // java.lang.Integer.toString(n, radix); }
  MethodBuilder invokeStaticReturnObject{cbuilder.CreateMethod(
      "invokeStaticReturnObject",
      Prototype{TypeDescriptor::String, TypeDescriptor::Int,
                TypeDescriptor::Int})};
  [&](MethodBuilder &method) {
    LiveRegister result{method.AllocRegister()};
    MethodDeclData to_string{dex_file.GetOrDeclareMethod(
        TypeDescriptor::FromClassname("java.lang.Integer"), "toString",
        Prototype{TypeDescriptor::String, TypeDescriptor::Int,
                  TypeDescriptor::Int})};
    method.AddInstruction(Instruction::InvokeStaticObject(
        to_string.id, result, Value::Parameter(0), Value::Parameter(1)));
    method.BuildReturn(result, /*is_object=*/true);
    method.Encode();
  }(invokeStaticReturnObject);

  // Make sure we can invoke virtual methods that return an object
  // String invokeVirtualReturnObject(String s, int n) { return s.substring(n);
  // }
  MethodBuilder invokeVirtualReturnObject{cbuilder.CreateMethod(
      "invokeVirtualReturnObject",
      Prototype{TypeDescriptor::String, TypeDescriptor::String,
                TypeDescriptor::Int})};
  [&](MethodBuilder &method) {
    LiveRegister result{method.AllocRegister()};
    MethodDeclData substring{dex_file.GetOrDeclareMethod(
        TypeDescriptor::String, "substring",
        Prototype{TypeDescriptor::String, TypeDescriptor::Int})};
    method.AddInstruction(Instruction::InvokeVirtualObject(
        substring.id, result, Value::Parameter(0), Value::Parameter(1)));
    method.BuildReturn(result, /*is_object=*/true);
    method.Encode();
  }(invokeVirtualReturnObject);

  // Make sure we can cast objects
  // String castObjectToString(Object o) { return (String)o; }
  MethodBuilder castObjectToString{cbuilder.CreateMethod(
      "castObjectToString",
      Prototype{TypeDescriptor::String, TypeDescriptor::Object})};
  [&](MethodBuilder &method) {
    const ir::Type *type_def =
        dex_file.GetOrAddType(TypeDescriptor::String.descriptor());
    method.AddInstruction(Instruction::Cast(Value::Parameter(0),
                                            Value::Type(type_def->orig_index)));
    method.BuildReturn(Value::Parameter(0), /*is_object=*/true);
    method.Encode();
  }(castObjectToString);

  // Read a static field
  // int readStaticField() { return TestClass.staticInteger; }
  MethodBuilder readStaticField{
      cbuilder.CreateMethod("readStaticField", Prototype{TypeDescriptor::Int})};
  [&](MethodBuilder &method) {
    const ir::FieldDecl *field = dex_file.GetOrAddField(
        cbuilder.descriptor(), "staticInteger", TypeDescriptor::Int);
    LiveRegister result{method.AllocRegister()};
    method.AddInstruction(
        Instruction::GetStaticField(field->orig_index, result));
    method.BuildReturn(result, /*is_object=*/false);
    method.Encode();
  }(readStaticField);

  // Set a static field
  // void setStaticField() { TestClass.staticInteger = 7; }
  MethodBuilder setStaticField{
      cbuilder.CreateMethod("setStaticField", Prototype{TypeDescriptor::Void})};
  [&](MethodBuilder &method) {
    const ir::FieldDecl *field = dex_file.GetOrAddField(
        cbuilder.descriptor(), "staticInteger", TypeDescriptor::Int);
    LiveRegister number{method.AllocRegister()};
    method.BuildConst(number, 7);
    method.AddInstruction(
        Instruction::SetStaticField(field->orig_index, number));
    method.BuildReturn();
    method.Encode();
  }(setStaticField);

  // Read an instance field
  // int readInstanceField(TestClass obj) { return obj.instanceField; }
  MethodBuilder readInstanceField{cbuilder.CreateMethod(
      "readInstanceField",
      Prototype{TypeDescriptor::Int, cbuilder.descriptor()})};
  [&](MethodBuilder &method) {
    const ir::FieldDecl *field = dex_file.GetOrAddField(
        cbuilder.descriptor(), "instanceField", TypeDescriptor::Int);
    LiveRegister result{method.AllocRegister()};
    method.AddInstruction(
        Instruction::GetField(field->orig_index, result, Value::Parameter(0)));
    method.BuildReturn(result, /*is_object=*/false);
    method.Encode();
  }(readInstanceField);

  // Set an instance field
  // void setInstanceField(TestClass obj) { obj.instanceField = 7; }
  MethodBuilder setInstanceField{cbuilder.CreateMethod(
      "setInstanceField",
      Prototype{TypeDescriptor::Void, cbuilder.descriptor()})};
  [&](MethodBuilder &method) {
    const ir::FieldDecl *field = dex_file.GetOrAddField(
        cbuilder.descriptor(), "instanceField", TypeDescriptor::Int);
    LiveRegister number{method.AllocRegister()};
    method.BuildConst(number, 7);
    method.AddInstruction(
        Instruction::SetField(field->orig_index, Value::Parameter(0), number));
    method.BuildReturn();
    method.Encode();
  }(setInstanceField);

  MethodBuilder newArray{
      cbuilder.CreateMethod("newArray", Prototype{TypeDescriptor::Void})};
  [&](MethodBuilder &method) {
    LiveRegister index{method.AllocRegister()};
    method.BuildConst(index, 5);
    LiveRegister array{method.AllocRegister()};
    method.BuildNewArray(array, TypeDescriptor::Object, index);
    LiveRegister object{method.AllocRegister()};
    for (int i = 0; i < 5; ++i) {
      method.BuildConst(index, i);
      method.BuildBoxIfPrimitive(object, TypeDescriptor::Int, index);
      method.BuildAput(Instruction::Op::kAputObject, array, object, index);
    }
    method.BuildReturn();
    method.Encode();
  }(newArray);

  slicer::MemView image{dex_file.CreateImage()};
  std::ofstream out_file(outdir + "/simple.dex");
  out_file.write(image.ptr<const char>(), image.size());
}

void GenerateHooker(const string &outdir) {
  DexBuilder dex_file;

  auto return_type = TypeDescriptor::Double;
  const auto parameter_types =
      std::vector{TypeDescriptor::Int,
                 TypeDescriptor::Long,
                  TypeDescriptor::FromClassname("io.github.lsposed.Test")};

  ClassBuilder cbuilder{dex_file.MakeClass("LSPHooker")};
  cbuilder.set_source_file("dex_testcase_generator.cc#GenerateHooker");

  auto hooker_type =
      TypeDescriptor::FromClassname("org.lsposed.lspd.hooker.LspHooker");

  auto *hooker_field = cbuilder.CreateField("hooker", hooker_type)
                           .access_flags(dex::kAccStatic)
                           .Encode();

  auto setupBuilder{cbuilder.CreateMethod(
      "setup", Prototype{TypeDescriptor::Void, hooker_type})};
  setupBuilder
      .AddInstruction(Instruction::SetStaticObjectField(
          hooker_field->decl->orig_index, Value::Parameter(0)))
      .BuildReturn()
      .Encode();

  auto hookBuilder{cbuilder.CreateMethod(
      "hook", Prototype{return_type, parameter_types})};
  // allocate tmp frist because of wide
  auto tmp{hookBuilder.AllocRegister()};
  hookBuilder.BuildConst(tmp, parameter_types.size());
  auto hook_params_array{hookBuilder.AllocRegister()};
  hookBuilder.BuildNewArray(hook_params_array, TypeDescriptor::Object, tmp);
  for (size_t i = 0u, j = 0u; i < parameter_types.size(); ++i, ++j) {
    hookBuilder.BuildBoxIfPrimitive(Value::Parameter(j), parameter_types[i],
                                    Value::Parameter(j));
    hookBuilder.BuildConst(tmp, i);
    hookBuilder.BuildAput(Instruction::Op::kAputObject, hook_params_array,
                          Value::Parameter(j), tmp);
    if (parameter_types[i].is_wide()) ++j;
  }
  auto handle_hook_method{dex_file.GetOrDeclareMethod(
      hooker_type, "handleHookedMethod",
      Prototype{TypeDescriptor::Object, TypeDescriptor::Object.ToArray()})};
  hookBuilder.AddInstruction(
      Instruction::GetStaticObjectField(hooker_field->decl->orig_index, tmp));
  hookBuilder.AddInstruction(Instruction::InvokeVirtualObject(
      handle_hook_method.id, tmp, tmp, hook_params_array));
  if (return_type == TypeDescriptor::Void) {
    hookBuilder.BuildReturn();
  } else if (return_type.is_primitive()) {
    auto box_type{return_type.ToBoxType()};
    const ir::Type *type_def = dex_file.GetOrAddType(box_type);
    hookBuilder.AddInstruction(
        Instruction::Cast(tmp, Value::Type(type_def->orig_index)));
    hookBuilder.BuildUnBoxIfPrimitive(tmp, box_type, tmp);
    hookBuilder.BuildReturn(tmp, false, return_type.is_wide());
  } else {
    const ir::Type *type_def = dex_file.GetOrAddType(return_type);
    hookBuilder.AddInstruction(
        Instruction::Cast(tmp, Value::Type(type_def->orig_index)));
    hookBuilder.BuildReturn(tmp, true);
  }
  auto *hook_method = hookBuilder.Encode();

  auto backup_builder{
      cbuilder.CreateMethod("backup", Prototype{return_type, parameter_types})};
  if (return_type == TypeDescriptor::Void) {
    backup_builder.BuildReturn();
  } else if(return_type.is_wide()){
    LiveRegister zero = backup_builder.AllocRegister();
    LiveRegister zero_wide = backup_builder.AllocRegister();
    backup_builder.BuildConstWide(zero, 0);
    backup_builder.BuildReturn(zero, /*is_object=*/true, true);
  } else {
    LiveRegister zero = backup_builder.AllocRegister();
    LiveRegister zero_wide = backup_builder.AllocRegister();
    backup_builder.BuildConst(zero, 0);
    backup_builder.BuildReturn(zero, /*is_object=*/true, false);
  }
  auto *back_method = backup_builder.Encode();

  slicer::MemView image{dex_file.CreateImage()};
  std::ofstream out_file(outdir + "/hooker.dex");
  out_file.write(image.ptr<const char>(), image.size());
}

int main(int argc, char **argv) {
  assert(argc == 2);

  string outdir = argv[1];
//   ifstream in(outdir + "/test.dex");

//   std::vector<uint8_t> buf{std::istreambuf_iterator<char>(in), std::istreambuf_iterator<char>()};

//   dex::Reader reader(buf.data(), buf.size());

//   reader.CreateFullIr();
//   auto ir = reader.GetIr();
//   auto idx = reader.FindClassIndex("Lio/github/xposed/test/T;");
//   std::cout << ir->classes[idx]->direct_methods[1]->decl->prototype->shorty->c_str() << std::endl;

//   GenerateTrivialDexFile(outdir);
//   GenerateSimpleTestCases(outdir);
  GenerateHooker(outdir);
}

```

`include/dex_builder.h`:

```h
/* DexBuilder
 * Copyright (C) 2021 LSPosed
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Copyright (C) 2018 The Android Open Source Project
 * Modifications copyright (C) 2021 LSPosed Developers
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef DEX_BUILDER_H_
#define DEX_BUILDER_H_

#include <array>
#include <forward_list>
#include <functional>
#include <map>
#include <optional>
#include <string>
#include <parallel_hashmap/phmap.h>
#include <vector>

#include "slicer/dex_bytecode.h"
#include "slicer/dex_format.h"
#include "slicer/dex_ir.h"
#include "slicer/writer.h"

namespace startop {
namespace dex {

//////////////////////////
// Forward declarations //
//////////////////////////
class DexBuilder;

// Our custom allocator for dex::Writer
//
// This keeps track of all allocations and ensures they are freed when
// TrackingAllocator is destroyed. Pointers to memory allocated by this
// allocator must not outlive the allocator.
class TrackingAllocator : public ::dex::Writer::Allocator {
public:
  virtual void *Allocate(size_t size);
  virtual void Free(void *ptr);

private:
  phmap::flat_hash_map<void *, std::unique_ptr<uint8_t[]>> allocations_;
};

// Represents a DEX type descriptor.
//
// TODO: add a way to create a descriptor for a reference of a class type.
class TypeDescriptor {
public:
  // Well known class
  static const TypeDescriptor Int;
  static const TypeDescriptor Void;
  static const TypeDescriptor Boolean;
  static const TypeDescriptor Byte;
  static const TypeDescriptor Char;
  static const TypeDescriptor Double;
  static const TypeDescriptor Float;
  static const TypeDescriptor Long;
  static const TypeDescriptor Short;

  static const TypeDescriptor Object;
  static const TypeDescriptor String;
  static const TypeDescriptor ObjectInt;
  static const TypeDescriptor ObjectBoolean;
  static const TypeDescriptor ObjectByte;
  static const TypeDescriptor ObjectChar;
  static const TypeDescriptor ObjectDouble;
  static const TypeDescriptor ObjectFloat;
  static const TypeDescriptor ObjectLong;
  static const TypeDescriptor ObjectShort;

  // Creates a type descriptor from a fully-qualified class name. For example,
  // it turns the class name java.lang.Object into the descriptor
  // Ljava/lang/Object.
  static TypeDescriptor FromClassname(const std::string &name);

  static TypeDescriptor FromDescriptor(const std::string &descriptor);

  static TypeDescriptor FromDescriptor(const char descriptor);

  TypeDescriptor ToArray() const { return TypeDescriptor{"[" + descriptor_}; }

  TypeDescriptor ToBoxType() const;

  TypeDescriptor ToUnBoxType() const;

  // Return the full descriptor, such as I or Ljava/lang/Object
  const std::string &descriptor() const { return descriptor_; }
  // Return the shorty descriptor, such as I or L
  char short_descriptor() const;

  bool is_object() const { return descriptor_[0] == 'L'; }

  bool is_array() const { return descriptor_[0] == '['; }

  bool is_primitive() const { return !is_object() && !is_array(); }

  bool is_wide() const { return wide_; }

  bool operator<(const TypeDescriptor &rhs) const {
    return descriptor_ < rhs.descriptor_;
  }

  bool operator==(const TypeDescriptor &rhs) const {
    return descriptor_ == rhs.descriptor_;
  }

  friend struct std::hash<TypeDescriptor>;

private:
  static const phmap::flat_hash_map<TypeDescriptor, TypeDescriptor> unbox_map;

  explicit TypeDescriptor(std::string descriptor, bool wide = false)
      : descriptor_{descriptor}, wide_(wide) {}

  const std::string descriptor_;
  const bool wide_;
};

// Defines a function signature. For example, Prototype{TypeDescriptor::VOID,
// TypeDescriptor::Int} represents the function type (Int) -> Void.
class Prototype {
public:
  template <typename... TypeDescriptors>
  explicit Prototype(const TypeDescriptor &return_type,
                     TypeDescriptors &&...param_types)
      : return_type_{return_type}, param_types_{std::forward<TypeDescriptors>(
                                       param_types)...} {}

  explicit Prototype(const TypeDescriptor &return_type,
                     const std::vector<TypeDescriptor> &param_types)
      : return_type_{return_type}, param_types_{param_types} {}

  // Encode this prototype into the dex file.
  ir::Proto *Encode(DexBuilder *dex) const;

  // Get the shorty descriptor, such as VII for (Int, Int) -> Void
  std::string Shorty() const;

  const TypeDescriptor &ArgType(size_t index) const;

  const TypeDescriptor &ReturnType() const { return return_type_; }

  bool operator<(const Prototype &rhs) const {
    return std::make_tuple(return_type_, param_types_) <
           std::make_tuple(rhs.return_type_, rhs.param_types_);
  }

private:
  const TypeDescriptor return_type_;
  const std::vector<TypeDescriptor> param_types_;
};

// Represents a DEX register or constant. We separate regular registers and
// parameters because we will not know the real parameter id until after all
// instructions have been generated.
class Value {
public:
  static constexpr Value Local(size_t id) {
    return Value{id, Kind::kLocalRegister};
  }
  static constexpr Value Parameter(size_t id) {
    return Value{id, Kind::kParameter};
  }
  static constexpr Value Immediate(size_t value) {
    return Value{value, Kind::kImmediate};
  }
  static constexpr Value String(size_t value) {
    return Value{value, Kind::kString};
  }
  static constexpr Value Label(size_t id) { return Value{id, Kind::kLabel}; }
  static constexpr Value Type(size_t id) { return Value{id, Kind::kType}; }

  bool is_register() const { return kind_ == Kind::kLocalRegister; }
  bool is_parameter() const { return kind_ == Kind::kParameter; }
  bool is_variable() const { return is_register() || is_parameter(); }
  bool is_immediate() const { return kind_ == Kind::kImmediate; }
  bool is_string() const { return kind_ == Kind::kString; }
  bool is_label() const { return kind_ == Kind::kLabel; }
  bool is_type() const { return kind_ == Kind::kType; }

  size_t value() const { return value_; }

  constexpr Value() : value_{0}, kind_{Kind::kInvalid} {}

  bool operator==(const Value &rhs) const {
    return value_ == rhs.value_ && kind_ == rhs.kind_;
  }
  bool operator!=(const Value &rhs) const { return !(*this == rhs); }

  Value WidePair() const {
    assert(kind_ == Kind::kLocalRegister || kind_ == Kind::kParameter);
    return Value{value_ + 1, kind_};
  }

private:
  enum class Kind {
    kInvalid,
    kLocalRegister,
    kParameter,
    kImmediate,
    kString,
    kLabel,
    kType
  };

  size_t value_;
  Kind kind_;

  constexpr Value(size_t value, Kind kind) : value_{value}, kind_{kind} {}
};

// Represents an allocated register returned by MethodBuilder::AllocRegister
class LiveRegister {
  friend class MethodBuilder;

public:
  LiveRegister(LiveRegister &&other)
      : liveness_{other.liveness_}, index_{other.index_} {
    other.index_ = {};
  };
  ~LiveRegister() {
    if (index_.has_value()) {
      (*liveness_)[*index_] = false;
    }
  };

  operator const Value() const { return Value::Local(*index_); }

private:
  LiveRegister(std::vector<bool> *liveness, size_t index)
      : liveness_{liveness}, index_{index} {}

  std::vector<bool> *const liveness_;
  std::optional<size_t> index_;
};

// A virtual instruction. We convert these to real instructions in
// MethodBuilder::Encode. Virtual instructions are needed to keep track of
// information that is not known until all of the code is generated. This
// information includes things like how many local registers are created and
// branch target locations.
class Instruction {
public:
  // The operation performed by this instruction. These are virtual instructions
  // that do not correspond exactly to DEX instructions.
  enum class Op {
    kBindLabel,
    kBranchEqz,
    kBranchNEqz,
    kCheckCast,
    kGetInstanceField,
    kGetStaticField,
    kGetStaticObjectField,
    kInvokeDirect,
    kInvokeInterface,
    kInvokeStatic,
    kInvokeVirtual,
    kInvokeDirectRange,
    kInvokeInterfaceRange,
    kInvokeStaticRange,
    kInvokeVirtualRange,
    kMove,
    kMoveObject,
    kMoveWide,
    kNew,
    kNewArray,
    kReturn,
    kReturnObject,
    kReturnWide,
    kSetInstanceField,
    kSetStaticField,
    kSetStaticObjectField,
    kAputObject,
  };

  ////////////////////////
  // Named Constructors //
  ////////////////////////

  // For instructions with no return value and no arguments.
  static inline Instruction OpNoArgs(Op opcode) {
    return Instruction{opcode, /*index_argument*/ 0, /*dest*/ {}};
  }
  // For most instructions, which take some number of arguments and have an
  // optional return value.
  template <typename... T>
  static inline Instruction
  OpWithArgs(Op opcode, std::optional<const Value> dest, const T &...args) {
    return Instruction{
        opcode, /*index_argument=*/0, /*result_is_object=*/false, false, dest,
        args...};
  }

  template <typename... T>
  static inline Instruction
  OpWithArgsWide(Op opcode, std::optional<const Value> dest, const T &...args) {
    return Instruction{
        opcode, /*index_argument=*/0, /*result_is_object=*/false, true, dest,
        args...};
  }

  // A cast instruction. Basically, `(type)val`
  static inline Instruction Cast(Value val, Value type) {
    assert(type.is_type());
    return OpWithArgs(Op::kCheckCast, val, type);
  }

  // For method calls.
  template <typename... T>
  static inline Instruction InvokeVirtual(size_t index_argument,
                                          std::optional<const Value> dest,
                                          Value this_arg, T... args) {
    return Instruction{
        Op::kInvokeVirtual,         index_argument,
        /*result_is_object=*/false, false,          dest, this_arg, args...};
  }
  template <typename... T>
  static inline Instruction InvokeVirtualWide(size_t index_argument,
                                              std::optional<const Value> dest,
                                              Value this_arg, T... args) {
    return Instruction{
        Op::kInvokeVirtual,         index_argument,
        /*result_is_object=*/false, true,           dest, this_arg, args...};
  }
  // Returns an object
  template <typename... T>
  static inline Instruction
  InvokeVirtualObject(size_t index_argument, std::optional<const Value> dest,
                      Value this_arg, const T &...args) {
    return Instruction{
        Op::kInvokeVirtual,        index_argument,
        /*result_is_object=*/true, false,          dest, this_arg, args...};
  }
  // For direct calls (basically, constructors).
  template <typename... T>
  static inline Instruction InvokeDirect(size_t index_argument,
                                         std::optional<const Value> dest,
                                         Value this_arg, const T &...args) {
    return Instruction{
        Op::kInvokeDirect,          index_argument,
        /*result_is_object=*/false, false,          dest, this_arg, args...};
  }
  // Returns an object
  template <typename... T>
  static inline Instruction
  InvokeDirectObject(size_t index_argument, std::optional<const Value> dest,
                     Value this_arg, const T &...args) {
    return Instruction{
        Op::kInvokeDirect,         index_argument,
        /*result_is_object=*/true, false,          dest, this_arg, args...};
  }
  // For static calls.
  template <typename... T>
  static inline Instruction InvokeStatic(size_t index_argument,
                                         std::optional<const Value> dest,
                                         const T &...args) {
    return Instruction{
        Op::kInvokeStatic,          index_argument,
        /*result_is_object=*/false, false,          dest, args...};
  }
  template <typename... T>
  static inline Instruction InvokeStaticWide(size_t index_argument,
                                             std::optional<const Value> dest,
                                             const T &...args) {
    return Instruction{
        Op::kInvokeStatic,          index_argument,
        /*result_is_object=*/false, true,           dest, args...};
  }
  static inline Instruction InvokeStaticRange(size_t index_argument,
                                              std::optional<const Value> dest,
                                              const Value &first,
                                              size_t length) {
    return Instruction{Op::kInvokeStaticRange,     index_argument,
                       /*result_is_object=*/false, false,          dest, first,
                       Value::Immediate(length)};
  }
  static inline Instruction
  InvokeStaticRangeWide(size_t index_argument, std::optional<const Value> dest,
                        const Value &first, size_t length) {
    return Instruction{Op::kInvokeStaticRange,     index_argument,
                       /*result_is_object=*/false, true,           dest, first,
                       Value::Immediate(length)};
  }
  // Returns an object
  template <typename... T>
  static inline Instruction InvokeStaticObject(size_t index_argument,
                                               std::optional<const Value> dest,
                                               const T &...args) {
    return Instruction{
        Op::kInvokeStatic,         index_argument,
        /*result_is_object=*/true, false,          dest, args...};
  }
  // Returns an object
  template <typename... T>
  static inline Instruction
  InvokeStaticObjectRange(size_t index_argument,
                          std::optional<const Value> dest, const Value &first, size_t length) {
    return Instruction{
        Op::kInvokeStaticRange,    index_argument,
        /*result_is_object=*/true, false,          dest, first, Value::Immediate(length)};
  }
  // For static calls.
  template <typename... T>
  static inline Instruction InvokeInterface(size_t index_argument,
                                            std::optional<const Value> dest,
                                            const T &...args) {
    return Instruction{Op::kInvokeInterface, index_argument,
                       /*result_is_object=*/false, dest, args...};
  }

  static inline Instruction GetStaticField(size_t field_id, const Value &dest) {
    return Instruction{Op::kGetStaticField, field_id, dest};
  }

  static inline Instruction GetStaticObjectField(size_t field_id,
                                                 const Value &dest) {
    return Instruction{Op::kGetStaticObjectField, field_id, dest};
  }

  static inline Instruction GetStaticField(size_t field_id, const Value &dest,
                                           bool result_is_wide) {
    return Instruction{Op::kGetStaticField, field_id, false, result_is_wide,
                       dest};
  }

  static inline Instruction SetStaticField(size_t field_id,
                                           const Value &value) {
    return Instruction{
        Op::kSetStaticField,        field_id,
        /*result_is_object=*/false, false,    /*dest=*/{}, value};
  }

  static inline Instruction SetStaticObjectField(size_t field_id,
                                                 const Value &value) {
    return Instruction{
        Op::kSetStaticObjectField,  field_id,
        /*result_is_object=*/false, false,    /*dest=*/{}, value};
  }

  static inline Instruction SetStaticField(size_t field_id, const Value &value,
                                           bool result_is_wide) {
    return Instruction{
        Op::kSetStaticField,        field_id,
        /*result_is_object=*/false, result_is_wide, /*dest=*/{}, value};
  }

  static inline Instruction GetField(size_t field_id, const Value &dest,
                                     const Value &object) {
    return Instruction{Op::kGetInstanceField,      field_id,
                       /*result_is_object=*/false, false,    dest, object};
  }

  static inline Instruction GetField(size_t field_id, const Value &dest,
                                     const Value &object, bool result_is_wide) {
    return Instruction{
        Op::kGetInstanceField,      field_id,
        /*result_is_object=*/false, result_is_wide, dest, object};
  }

  static inline Instruction SetField(size_t field_id, const Value &object,
                                     const Value &value) {
    return Instruction{Op::kSetInstanceField,
                       field_id,
                       /*result_is_object=*/false,
                       false,
                       /*dest=*/{},
                       object,
                       value};
  }

  static inline Instruction SetField(size_t field_id, const Value &object,
                                     const Value &value, bool result_is_wide) {
    return Instruction{
        Op::kSetInstanceField, field_id, /*result_is_object=*/false,
        result_is_wide,
        /*dest=*/{},           object,   value};
  }

  ///////////////
  // Accessors //
  ///////////////

  Op opcode() const { return opcode_; }
  size_t index_argument() const { return index_argument_; }
  bool result_is_object() const { return result_is_object_; }
  bool result_is_wide() const { return result_is_wide_; }
  const std::optional<const Value> &dest() const { return dest_; }
  const std::vector<Value> &args() const { return args_; }

private:
  inline Instruction(Op opcode, size_t index_argument,
                     std::optional<const Value> dest)
      : opcode_{opcode}, index_argument_{index_argument},
        result_is_object_{false}, result_is_wide_(false), dest_{dest}, args_{} {
  }

  template <typename... T>
  inline Instruction(Op opcode, size_t index_argument, bool result_is_object,
                     bool result_is_wide, std::optional<const Value> dest,
                     const T &...args)
      : opcode_{opcode}, index_argument_{index_argument},
        result_is_object_{result_is_object},
        result_is_wide_(result_is_wide), dest_{dest}, args_{args...} {}

  const Op opcode_;
  // The index of the method to invoke, for kInvokeVirtual and similar opcodes.
  const size_t index_argument_{0};
  const bool result_is_object_;
  const bool result_is_wide_;
  const std::optional<const Value> dest_;
  const std::vector<Value> args_;
};

// Needed for CHECK_EQ, DCHECK_EQ, etc.
std::ostream &operator<<(std::ostream &out, const Instruction::Op &opcode);

// Keeps track of information needed to manipulate or call a method.
struct MethodDeclData {
  size_t id;
  ir::MethodDecl *decl;
};

class MethodBuilder;
class FieldBuilder;
// A helper to build class definitions.
class ClassBuilder {
public:
  ClassBuilder(DexBuilder *parent, const std::string &name,
               ir::Class *class_def);

  void set_source_file(const std::string &source);

  // Create a method with the given name and prototype. The returned
  // MethodBuilder can be used to fill in the method body.
  MethodBuilder CreateMethod(const std::string &name,
                             const Prototype &prototype);

  FieldBuilder CreateField(const std::string &name, const TypeDescriptor &type);

  ClassBuilder setSuperClass(const TypeDescriptor &type);

  DexBuilder *parent() const { return parent_; }

  const TypeDescriptor &descriptor() const { return type_descriptor_; }

private:
  static const phmap::flat_hash_map<TypeDescriptor, std::string> value_method_map;

  DexBuilder *const parent_;
  const TypeDescriptor type_descriptor_;
  ir::Class *const class_;
};

class FieldBuilder {
public:
  FieldBuilder(ClassBuilder *parent, ir::Class *class_def, ir::FieldDecl *decl);
  ir::EncodedField *Encode();

  ClassBuilder *parent() const { return parent_; }
  DexBuilder *dex_file() const { return parent_->parent(); }

  ::dex::u4 access_flags() const { return access_flags_; }
  FieldBuilder &access_flags(const ::dex::u4 &access_flags) {
    access_flags_ = access_flags;
    return *this;
  }

private:
  ClassBuilder *parent_;
  ir::Class *class_;
  ir::FieldDecl *decl_;
  ::dex::u4 access_flags_ = ::dex::kAccPublic | ::dex::kAccStatic;
  ;
};

// Tools to help build methods and their bodies.
class MethodBuilder {
public:
  MethodBuilder(ClassBuilder *parent, ir::Class *class_def,
                ir::MethodDecl *decl);

  // Encode the method into DEX format.
  ir::EncodedMethod *Encode();

  // Create a new register to be used to storing values.
  LiveRegister AllocRegister();

  Value MakeLabel();

  /////////////////////////////////
  // Instruction builder methods //
  /////////////////////////////////

  MethodBuilder &AddInstruction(Instruction instruction);

  // return-void
  MethodBuilder &BuildReturn();
  MethodBuilder &BuildReturn(const Value &src, bool is_object = false,
                             bool is_wide = false);
  // const/4
  MethodBuilder &BuildConst(const Value &target, int value);
  MethodBuilder &BuildConstWide(const Value &target, int value);
  MethodBuilder &BuildConstString(const Value &target,
                                  const std::string &value);
  template <typename... T>
  MethodBuilder &BuildNew(const Value &target, const TypeDescriptor &type,
                          const Prototype &constructor, const T &...args);
  MethodBuilder &BuildNewArray(const Value &target,
                               const TypeDescriptor &base_type,
                               const Value &size);
  MethodBuilder &BuildAput(Instruction::Op opcode, const Value &target_array,
                           const Value &value, const Value &index);
  MethodBuilder &BuildBoxIfPrimitive(const Value &target,
                                     const TypeDescriptor &type,
                                     const Value &src);
  MethodBuilder &BuildUnBoxIfPrimitive(const Value &target,
                                       const TypeDescriptor &type,
                                       const Value &src);

  // TODO: add builders for more instructions

  DexBuilder *dex_file() const { return parent_->parent(); }
  ClassBuilder *parent() const { return parent_; }

  ::dex::u4 access_flags() const { return access_flags_; }
  MethodBuilder &access_flags(const ::dex::u4 &access_flags) {
    access_flags_ = access_flags;
    return *this;
  }

  // Converts a register or parameter to its DEX register number.
  size_t RegisterValue(const Value &value) const;

private:
  using Op = Instruction::Op;

  void EncodeInstructions();
  void EncodeInstruction(const Instruction &instruction);

  // Encodes a return instruction. For instructions with no return value, the
  // opcode field is ignored. Otherwise, this specifies which return instruction
  // will be used (return, return-object, etc.)
  void EncodeReturn(const Instruction &instruction, ::dex::Opcode opcode);

  void EncodeMove(const Instruction &instruction);
  void EncodeInvoke(const Instruction &instruction, ::dex::Opcode opcode);
  void EncodeInvokeRange(const Instruction &instruction, ::dex::Opcode opcode);
  void EncodeBranch(::dex::Opcode op, const Instruction &instruction);
  void EncodeNew(const Instruction &instruction);
  void EncodeCast(const Instruction &instruction);
  void EncodeFieldOp(const Instruction &instruction);
  void EncodeNewArray(const Instruction &instruction);
  void EncodeAput(const Instruction &instruction);

  // Low-level instruction format encoding. See
  // https://source.android.com/devices/tech/dalvik/instruction-formats for
  // documentation of formats.

  inline uint8_t ToBits(::dex::Opcode opcode) {
    static_assert(sizeof(uint8_t) == sizeof(::dex::Opcode));
    return static_cast<uint8_t>(opcode);
  }

  inline void Encode10x(::dex::Opcode opcode) {
    // 00|op
    static_assert(sizeof(uint8_t) == sizeof(::dex::Opcode));
    buffer_.push_back(ToBits(opcode));
  }

  inline void Encode11x(::dex::Opcode opcode, uint8_t a) {
    // aa|op
    buffer_.push_back((a << 8) | ToBits(opcode));
  }

  inline void Encode11n(::dex::Opcode opcode, uint8_t a, int8_t b) {
    // b|a|op

    // Make sure the fields are in bounds (4 bits for a, 4 bits for b).
    assert(a < 16);
    assert(-8 < b);
    assert(b < 8);

    buffer_.push_back(((b & 0xf) << 12) | (a << 8) | ToBits(opcode));
  }

  inline void Encode21c(::dex::Opcode opcode, uint8_t a, uint16_t b) {
    // aa|op|bbbb
    buffer_.push_back((a << 8) | ToBits(opcode));
    buffer_.push_back(b);
  }

  inline void Encode22c(::dex::Opcode opcode, uint8_t a, uint8_t b,
                        uint16_t c) {
    // b|a|op|bbbb
    assert(IsShortRegister(a));
    assert(IsShortRegister(b));
    buffer_.push_back((b << 12) | (a << 8) | ToBits(opcode));
    buffer_.push_back(c);
  }

  inline void Encode21s(::dex::Opcode opcode, uint8_t a, uint16_t b) {
    assert(b < 32768);
    Encode21c(opcode, a, b);
  }

  inline void Encode23x(::dex::Opcode opcode, uint8_t a, uint8_t b, uint8_t c) {
    // AA|op|CC|BB
    buffer_.push_back((a << 8) | ToBits(opcode));
    buffer_.push_back((c << 8) | b);
  }

  inline void Encode32x(::dex::Opcode opcode, uint16_t a, uint16_t b) {
    // ØØ|op|AAAA|BBBB
    buffer_.push_back(ToBits(opcode));
    buffer_.push_back(a);
    buffer_.push_back(b);
  }

  inline void Encode31i(::dex::Opcode opcode, uint8_t a, uint32_t b) {
    // AA|op|BBBBlo|BBBBhi
    buffer_.push_back((a << 8) | ToBits(opcode));
    // FIXME: it may be wrong
    buffer_.push_back((uint16_t)b);
    buffer_.push_back(b >> 16);
  }

  inline void Encode35c(::dex::Opcode opcode, size_t a, uint16_t b, uint8_t c,
                        uint8_t d, uint8_t e, uint8_t f, uint8_t g) {
    // a|g|op|bbbb|f|e|d|c

    assert(a < 5);
    assert(IsShortRegister(c));
    assert(IsShortRegister(d));
    assert(IsShortRegister(e));
    assert(IsShortRegister(f));
    assert(IsShortRegister(g));
    buffer_.push_back((a << 12) | (g << 8) | ToBits(opcode));
    buffer_.push_back(b);
    buffer_.push_back((f << 12) | (e << 8) | (d << 4) | c);
  }

  inline void Encode3rc(::dex::Opcode opcode, size_t a, uint16_t b,
                        uint16_t c) {
    assert(a < 255);
    buffer_.push_back((a << 8) | ToBits(opcode));
    buffer_.push_back(b);
    buffer_.push_back(c);
  }

  static constexpr bool IsShortRegister(size_t register_value) {
    return register_value < 16;
  }

  // Returns an array of num_regs scratch registers. These are guaranteed to be
  // contiguous, so they are suitable for the invoke-*/range instructions.
  template <int num_regs>
  std::array<Value, num_regs> GetScratchRegisters() const {
    // static_assert(num_regs <= kMaxScratchRegisters);
    std::array<Value, num_regs> regs;
    for (size_t i = 0; i < num_regs; ++i) {
      regs[i] = std::move(Value::Local(NumRegisters() + i));
    }
    return regs;
  }

  // Sets a label's address to the current position in the instruction buffer.
  // If there are any forward references to the label, this function will
  // back-patch them.
  void BindLabel(const Value &label);

  // Returns the offset of the label relative to the given instruction offset.
  // If the label is not bound, a reference will be saved and it will
  // automatically be patched when the label is bound.
  ::dex::u2 LabelValue(const Value &label, size_t instruction_offset,
                       size_t field_offset);

  ClassBuilder *parent_;
  ir::Class *class_;
  ir::MethodDecl *decl_;

  // A list of the instructions we will eventually encode.
  std::vector<Instruction> instructions_;

  // A buffer to hold instructions that have been encoded.
  std::vector<::dex::u2> buffer_;

  // We create some scratch registers for when we have to shuffle registers
  // around to make legal DEX code.
  // TODO: calculate it dynamically?
  static constexpr size_t kMaxScratchRegisters = 0;

  size_t NumRegisters() const { return register_liveness_.size(); }

  // Stores information needed to back-patch a label once it is bound. We need
  // to know the start of the instruction that refers to the label, and the
  // offset to where the actual label value should go.
  struct LabelReference {
    size_t instruction_offset;
    size_t field_offset;
  };

  struct LabelData {
    std::optional<size_t> bound_address;
    std::forward_list<LabelReference> references;
  };

  std::vector<LabelData> labels_;

  // During encoding, keep track of the largest number of arguments needed, so
  // we can use it for our outs count
  size_t max_args_{0};

  std::vector<bool> register_liveness_;

  ::dex::u4 access_flags_ = ::dex::kAccPublic | ::dex::kAccStatic;
  ;
};

// Builds Dex files from scratch.
class DexBuilder {
public:
  DexBuilder();

  // Create an in-memory image of the DEX file that can either be loaded
  // directly or written to a file.
  slicer::MemView CreateImage(bool checksum=false);

  template <typename T> T *Alloc() { return dex_file_->Alloc<T>(); }

  // Find the ir::String that matches the given string, creating it if it does
  // not exist.
  ir::String *GetOrAddString(const std::string &string);
  // Create a new class of the given name.
  ClassBuilder MakeClass(const std::string &name);

  // Add a type for the given descriptor, or return the existing one if it
  // already exists. See the TypeDescriptor class for help generating these.
  // GetOrAddType can be used to declare imported classes.
  ir::Type *GetOrAddType(const std::string &descriptor);
  inline ir::Type *GetOrAddType(TypeDescriptor descriptor) {
    return GetOrAddType(descriptor.descriptor());
  }

  ir::FieldDecl *GetOrAddField(TypeDescriptor parent, const std::string &name,
                               TypeDescriptor type);

  // Returns the method id for the method, creating it if it has not been
  // created yet.
  const MethodDeclData &GetOrDeclareMethod(TypeDescriptor type,
                                           const std::string &name,
                                           Prototype prototype);

  std::optional<const Prototype> GetPrototypeByMethodId(size_t method_id) const;

private:
  // Looks up the ir::Proto* corresponding to this given prototype, or creates
  // one if it does not exist.
  ir::Proto *GetOrEncodeProto(Prototype prototype);

  std::shared_ptr<ir::DexFile> dex_file_;

  // allocator_ is needed to be able to encode the image.
  TrackingAllocator allocator_;

  // We'll need to allocate buffers for all of the encoded strings we create.
  // This is where we store all of them.
  std::vector<std::unique_ptr<uint8_t[]>> string_data_;

  // Keep track of what types we've defined so we can look them up later.
  phmap::flat_hash_map<std::string_view, ir::Type *> types_by_descriptor_;

  struct MethodDescriptor {
    TypeDescriptor type;
    std::string name;
    Prototype prototype;

    inline bool operator<(const MethodDescriptor &rhs) const {
      return std::make_tuple(type, name, prototype) <
             std::make_tuple(rhs.type, rhs.name, rhs.prototype);
    }
  };

  // Maps method declarations to their method index. This is needed to encode
  // references to them. When we go to actually write the DEX file, slicer will
  // re-assign these after correctly sorting the methods list.
  std::map<MethodDescriptor, MethodDeclData> method_id_map_;

  // Keep track of what strings we've defined so we can look them up later.
  phmap::flat_hash_map<std::string_view, ir::String *> strings_;

  // Keep track of already-encoded protos.
  std::map<Prototype, ir::Proto *> proto_map_;

  // Keep track of fields that have been declared
  std::map<std::tuple<TypeDescriptor, std::string>, ir::FieldDecl *>
      field_decls_by_key_;
};

template <typename... T>
MethodBuilder &
MethodBuilder::BuildNew(const Value &target, const TypeDescriptor &type,
                        const Prototype &constructor, const T &...args) {
  MethodDeclData constructor_data{
      dex_file()->GetOrDeclareMethod(type, "<init>", constructor)};
  // allocate the object
  ir::Type *type_def = dex_file()->GetOrAddType(type.descriptor());
  AddInstruction(Instruction::OpWithArgs(Op::kNew, target,
                                         Value::Type(type_def->orig_index)));
  // call the constructor
  AddInstruction(Instruction::InvokeDirect(constructor_data.id, /*dest=*/{},
                                           target, args...));
  return *this;
};

inline MethodBuilder &MethodBuilder::BuildNewArray(const Value &target,
                                                   const TypeDescriptor &type,
                                                   const Value &size) {
  ir::Type *type_def = dex_file()->GetOrAddType(type.ToArray());
  AddInstruction(Instruction::OpWithArgs(Op::kNewArray, target, size,
                                         Value::Type(type_def->orig_index)));
  return *this;
};

inline MethodBuilder &MethodBuilder::BuildAput(Op opcode,
                                               const Value &target_array,
                                               const Value &value,
                                               const Value &index) {
  AddInstruction(Instruction::OpWithArgs(opcode, value, target_array, index));
  return *this;
}

inline MethodBuilder &MethodBuilder::BuildReturn() {
  AddInstruction(Instruction::OpNoArgs(Op::kReturn));
  return *this;
}

inline MethodBuilder &MethodBuilder::BuildReturn(const Value &src,
                                                 bool is_object, bool is_wide) {
  if (is_wide) {
    AddInstruction(
        Instruction::OpWithArgsWide(Op::kReturnWide, /*destination=*/{}, src));
  } else {
    AddInstruction(Instruction::OpWithArgs(
        is_object ? Op::kReturnObject : Op::kReturn, /*destination=*/{}, src));
  }
  return *this;
}

inline MethodBuilder &MethodBuilder::BuildConst(const Value &target,
                                                int value) {
  assert(value <= 65535);
  AddInstruction(
      Instruction::OpWithArgs(Op::kMove, target, Value::Immediate(value)));
  return *this;
}

inline MethodBuilder &MethodBuilder::BuildConstWide(const Value &target,
                                                    int value) {
  AddInstruction(
      Instruction::OpWithArgs(Op::kMoveWide, target, Value::Immediate(value)));
  return *this;
}

inline MethodBuilder &
MethodBuilder::BuildConstString(const Value &target, const std::string &value) {
  const ir::String *const dex_string = dex_file()->GetOrAddString(value);
  AddInstruction(Instruction::OpWithArgs(
      Op::kMove, target, Value::String(dex_string->orig_index)));
  return *this;
}

inline void MethodBuilder::EncodeInstructions() {
  buffer_.clear();
  for (const auto &instruction : instructions_) {
    EncodeInstruction(instruction);
  }
}
} // namespace dex
} // namespace startop

namespace std {
template <> struct hash<startop::dex::TypeDescriptor> {
  std::size_t operator()(const startop::dex::TypeDescriptor &s) const {
    return std::hash<std::string_view>{}(s.descriptor_);
  }
};
} // namespace std

#endif // DEX_BUILDER_H_

```

`include/dex_builder.ixx`:

```ixx
module;

#include "dex_builder.h"
#include "slicer/dex_format.h"
#include "slicer/reader.h"
#include "slicer/writer.h"

export module dex_builder;

export namespace startop::dex {
using startop::dex::ClassBuilder;
using startop::dex::DexBuilder;
using startop::dex::FieldBuilder;
using startop::dex::Instruction;
using startop::dex::LiveRegister;
using startop::dex::MethodBuilder;
using startop::dex::Prototype;
using startop::dex::TypeDescriptor;
using startop::dex::Value;
}  // namespace startop::dex

export namespace slicer {
using slicer::MemView;
}  // namespace slicer

export namespace ir {
using ir::Annotation;
using ir::AnnotationElement;
using ir::AnnotationsDirectory;
using ir::AnnotationSet;
using ir::AnnotationSetRefList;
using ir::Class;
using ir::Code;
using ir::DebugInfo;
using ir::DexFile;
using ir::EncodedArray;
using ir::EncodedField;
using ir::EncodedMethod;
using ir::EncodedValue;
using ir::FieldAnnotation;
using ir::FieldDecl;
using ir::IndexedNode;
using ir::MethodAnnotation;
using ir::MethodDecl;
using ir::Node;
using ir::ParamAnnotation;
using ir::Proto;
using ir::String;
using ir::Type;
using ir::TypeList;
}  // namespace ir

export namespace dex {
using dex::AnnotationItem;
using dex::AnnotationsDirectoryItem;
using dex::AnnotationSetItem;
using dex::AnnotationSetRefItem;
using dex::AnnotationSetRefList;
using dex::ClassDef;
using dex::Code;
using dex::CodeItem;
using dex::CompactCode;
using dex::FieldAnnotationsItem;
using dex::FieldId;
using dex::MapItem;
using dex::MapList;
using dex::MethodAnnotationsItem;
using dex::MethodId;
using dex::ParameterAnnotationsItem;
using dex::ProtoId;
using dex::Reader;
using dex::StringId;
using dex::TryBlock;
using dex::TypeId;
using dex::TypeItem;
using dex::TypeList;
using dex::Writer;

using dex::ReadSLeb128;
using dex::ReadULeb128;

using dex::DBG_ADVANCE_LINE;
using dex::DBG_ADVANCE_PC;
using dex::DBG_END_LOCAL;
using dex::DBG_END_SEQUENCE;
using dex::DBG_FIRST_SPECIAL;
using dex::DBG_LINE_BASE;
using dex::DBG_LINE_RANGE;
using dex::DBG_RESTART_LOCAL;
using dex::DBG_SET_EPILOGUE_BEGIN;
using dex::DBG_SET_FILE;
using dex::DBG_SET_PROLOGUE_END;
using dex::DBG_START_LOCAL;
using dex::DBG_START_LOCAL_EXTENDED;
using dex::kAccAbstract;
using dex::kAccAnnotation;
using dex::kAccBridge;
using dex::kAccConstructor;
using dex::kAccDeclaredSynchronized;
using dex::kAccEnum;
using dex::kAccFinal;
using dex::kAccInterface;
using dex::kAccNative;
using dex::kAccPrivate;
using dex::kAccProtected;
using dex::kAccPublic;
using dex::kAccStatic;
using dex::kAccStrict;
using dex::kAccSuper;
using dex::kAccSynchronized;
using dex::kAccSynthetic;
using dex::kAccTransient;
using dex::kAccVarargs;
using dex::kAccVolatile;
using dex::kAnnotationItem;
using dex::kAnnotationsDirectoryItem;
using dex::kAnnotationSetItem;
using dex::kAnnotationSetRefList;
using dex::kClassDataItem;
using dex::kClassDefItem;
using dex::kCodeItem;
using dex::kDebugInfoItem;
using dex::kEncodedAnnotation;
using dex::kEncodedArray;
using dex::kEncodedArrayItem;
using dex::kEncodedBoolean;
using dex::kEncodedByte;
using dex::kEncodedChar;
using dex::kEncodedDouble;
using dex::kEncodedEnum;
using dex::kEncodedField;
using dex::kEncodedFloat;
using dex::kEncodedInt;
using dex::kEncodedLong;
using dex::kEncodedMethod;
using dex::kEncodedMethodHandle;
using dex::kEncodedMethodType;
using dex::kEncodedNull;
using dex::kEncodedShort;
using dex::kEncodedString;
using dex::kEncodedType;
using dex::kEncodedValueArgShift;
using dex::kEncodedValueTypeMask;
using dex::kEndianConstant;
using dex::kFieldIdItem;
using dex::kHeaderItem;
using dex::kMapList;
using dex::kMethodIdItem;
using dex::kNoIndex;
using dex::kProtoIdItem;
using dex::kSHA1DigestLen;
using dex::kStringDataItem;
using dex::kStringIdItem;
using dex::kTypeIdItem;
using dex::kTypeList;
using dex::kVisibilityBuild;
using dex::kVisibilityEncoded;
using dex::kVisibilityRuntime;
using dex::kVisibilitySystem;
using dex::s1;
using dex::s2;
using dex::s4;
using dex::s8;
using dex::u1;
using dex::u2;
using dex::u4;
using dex::u8;

using dex::opcode_len;
}  // namespace dex

```

`include/dex_helper.h`:

```h
#pragma once

#include <string_view>
#include <parallel_hashmap/phmap.h>
#include <vector>

#include "slicer/reader.h"

class DexHelper {
public:
    DexHelper(const std::vector<std::tuple<const void *, size_t, const void *, size_t>> &dexs);

    void CreateFullCache() const;

    std::vector<size_t> FindMethodUsingString(std::string_view str, bool match_prefix,
                                              size_t return_type, short parameter_count,
                                              std::string_view parameter_shorty,
                                              size_t declaring_class,
                                              const std::vector<size_t> &parameter_types,
                                              const std::vector<size_t> &contains_parameter_types,
                                              const std::vector<size_t> &dex_priority,
                                              bool find_first) const;

    std::vector<size_t> FindMethodInvoking(size_t method_idx, size_t return_type,
                                           short parameter_count, std::string_view parameter_shorty,
                                           size_t declaring_class,
                                           const std::vector<size_t> &parameter_types,
                                           const std::vector<size_t> &contains_parameter_types,
                                           const std::vector<size_t> &dex_priority,
                                           bool find_first) const;

    std::vector<size_t> FindMethodInvoked(size_t method_idx, size_t return_type,
                                          short parameter_count, std::string_view parameter_shorty,
                                          size_t declaring_class,
                                          const std::vector<size_t> &parameter_types,
                                          const std::vector<size_t> &contains_parameter_types,
                                          const std::vector<size_t> &dex_priority,
                                          bool find_first) const;

    std::vector<size_t> FindMethodGettingField(size_t field_idx, size_t return_type,
                                               short parameter_count,
                                               std::string_view parameter_shorty,
                                               size_t declaring_class,
                                               const std::vector<size_t> &parameter_types,
                                               const std::vector<size_t> &contains_parameter_types,
                                               const std::vector<size_t> &dex_priority,
                                               bool find_first) const;

    std::vector<size_t> FindMethodSettingField(size_t field_idx, size_t return_type,
                                               short parameter_count,
                                               std::string_view parameter_shorty,
                                               size_t declaring_class,
                                               const std::vector<size_t> &parameter_types,
                                               const std::vector<size_t> &contains_parameter_types,
                                               const std::vector<size_t> &dex_priority,
                                               bool find_first) const;

    std::vector<size_t> FindField(size_t type, const std::vector<size_t> &dex_priority,
                                  bool find_first) const;

    struct Class {
        const std::string_view name;
    };
    struct Field {
        const Class declaring_class;
        const Class type;
        const std::string_view name;
    };
    struct Method {
        const Class declaring_class;
        const std::string_view name;
        const std::vector<Class> parameters;
        const Class return_type;
    };

    size_t CreateClassIndex(std::string_view class_name) const;
    size_t CreateMethodIndex(std::string_view class_name, std::string_view method_name,
                             const std::vector<std::string_view> &params_name) const;
    size_t CreateFieldIndex(std::string_view class_name, std::string_view field_name) const;

    Class DecodeClass(size_t class_idx) const;
    Field DecodeField(size_t field_idx) const;
    Method DecodeMethod(size_t method_idx) const;

private:
    std::tuple<std::vector<std::vector<uint32_t>>, std::vector<std::vector<uint32_t>>>
    ConvertParameters(const std::vector<size_t> &parameter_types,
                      const std::vector<size_t> &contains_parameter_types) const;

    std::vector<size_t> GetPriority(const std::vector<size_t> &priority) const;

    bool ScanMethod(size_t dex_idx, uint32_t method_id, size_t str_lower = size_t(-1),
                    size_t str_upper = size_t(-1)) const;

    std::tuple<uint32_t, uint32_t> FindPrefixStringId(size_t dex_idx,
                                                      std::string_view to_find) const;

    uint32_t FindPrefixStringIdExact(size_t dex_idx, std::string_view to_find) const;

    bool IsMethodMatch(size_t dex_id, uint32_t method_id, uint32_t return_type,
                       short parameter_count, std::string_view parameter_shorty,
                       uint32_t declaring_class, const std::vector<uint32_t> &parameter_types,
                       const std::vector<uint32_t> &contains_parameter_types) const;

    size_t CreateMethodIndex(size_t dex_idx, uint32_t method_id) const;
    size_t CreateClassIndex(size_t dex_idx, uint32_t class_id) const;
    size_t CreateFieldIndex(size_t dex_idx, uint32_t field_id) const;

    std::vector<dex::Reader> readers_;

    // for interface
    // indices[method_index][dex] -> id
    mutable std::vector<std::vector<uint32_t>> method_indices_;
    mutable std::vector<std::vector<uint32_t>> class_indices_;
    mutable std::vector<std::vector<uint32_t>> field_indices_;
    // rev[dex][method_id] -> method_index
    mutable std::vector<std::vector<size_t>> rev_method_indices_;  // for each dex
    mutable std::vector<std::vector<size_t>> rev_class_indices_;
    mutable std::vector<std::vector<size_t>> rev_field_indices_;

    // for preprocess
    // strings[dex][str_id] -> str
    std::vector<std::vector<std::string_view>> strings_;
    // method_codes[dex][method_id] -> code
    std::vector<std::vector<const dex::CodeItem *>> method_codes_;

    // for cache
    // type_cache[dex][str_id] -> type_id
    std::vector<std::vector<uint32_t>> type_cache_;
    // field_cache[dex][type_id][str_id] -> method_ids
    std::vector<std::vector<phmap::flat_hash_map<uint32_t, std::vector<uint32_t>>>> method_cache_;
    // field_cache[dex][type_id][str_id] -> field_id
    std::vector<std::vector<phmap::flat_hash_map<uint32_t, uint32_t>>> field_cache_;
    // class_cache[dex][type_id] -> class_id
    std::vector<std::vector<uint32_t>> class_cache_;

    // search result cache
    // string_cache[dex][str_id] -> method_ids
    mutable std::vector<std::vector<std::vector<uint32_t>>> string_cache_;
    // invoking_cache[dex][method_id] -> method_ids
    mutable std::vector<std::vector<std::vector<uint32_t>>> invoking_cache_;
    // invoked_cache[dex][method_id] -> method_ids
    mutable std::vector<std::vector<std::vector<uint32_t>>> invoked_cache_;
    // getting/setting_cache[dex][field_id] -> method_ids
    mutable std::vector<std::vector<std::vector<uint32_t>>> getting_cache_;
    mutable std::vector<std::vector<std::vector<uint32_t>>> setting_cache_;
    mutable std::vector<std::vector<std::vector<uint32_t>>> declaring_cache_;
    // for method search
    mutable std::vector<std::vector<bool>> searched_methods_;
};

```

`include/dex_helper.ixx`:

```ixx
module;

#include "dex_helper.h"

export module dex_helper;

export import dex_builder;
export using ::DexHelper;

```

`include/slicer/arrayview.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"

#include <stdlib.h>

namespace slicer {

// A shallow array view
template <class T>
class ArrayView {
 public:
  ArrayView() = default;

  ArrayView(const ArrayView&) = default;
  ArrayView& operator=(const ArrayView&) = default;

  ArrayView(T* ptr, size_t count) : begin_(ptr), end_(ptr + count) {}

  T* begin() const { return begin_; }
  T* end() const { return end_; }

  T* data() const { return begin_; }

  T& operator[](size_t i) const {
    SLICER_CHECK(i < size());
    return *(begin_ + i);
  }

  size_t size() const { return end_ - begin_; }
  bool empty() const { return begin_ == end_; }

 private:
  T* begin_ = nullptr;
  T* end_ = nullptr;
};

} // namespace slicer

```

`include/slicer/buffer.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"
#include "arrayview.h"
#include "memview.h"
#include "dex_leb128.h"

#include <assert.h>
#include <string>
#include <algorithm>
#include <vector>
#include <cstring>

namespace slicer {

// A simple growing memory buffer
//
// NOTE: pointers into this buffer are not stable
//   since it may be relocated as it expands.
//
class Buffer {
 public:
  Buffer() = default;

  ~Buffer() { Free(); }

  Buffer(const Buffer&) = delete;
  Buffer& operator=(const Buffer&) = delete;

  Buffer(Buffer&& b) {
    std::swap(buff_, b.buff_);
    std::swap(size_, b.size_);
    std::swap(capacity_, b.capacity_);
  }

  Buffer& operator=(Buffer&& b) {
    Free();
    std::swap(buff_, b.buff_);
    std::swap(size_, b.size_);
    std::swap(capacity_, b.capacity_);
    return *this;
  }

 public:
  // Align the total size and prevent further changes
  size_t Seal(size_t alignment) {
    SLICER_CHECK(!sealed_);
    Align(alignment);
    sealed_ = true;
    return size();
  }

  // Returns a pointer within the buffer
  //
  // NOTE: the returned pointer is "ephemeral" and
  //   is only valid until the next buffer push/alloc
  //
  template <class T>
  T* ptr(size_t offset) {
    SLICER_CHECK(offset + sizeof(T) <= size_);
    return reinterpret_cast<T*>(buff_ + offset);
  }

  // Align the buffer size to the specified alignment
  void Align(size_t alignment) {
    assert(alignment > 0);
    size_t rem = size_ % alignment;
    if (rem != 0) {
      Alloc(alignment - rem);
    }
  }

  size_t Alloc(size_t size) {
    size_t offset = size_;
    Expand(size);
    std::memset(buff_ + offset, 0, size);
    return offset;
  }

  size_t Push(const void* ptr, size_t size) {
    size_t offset = size_;
    Expand(size);
    std::memcpy(buff_ + offset, ptr, size);
    return offset;
  }

  size_t Push(const MemView& memView) {
    return Push(memView.ptr(), memView.size());
  }

  template <class T>
  size_t Push(const ArrayView<T>& a) {
    return Push(a.data(), a.size() * sizeof(T));
  }

  template <class T>
  size_t Push(const std::vector<T>& v) {
    return Push(v.data(), v.size() * sizeof(T));
  }

  size_t Push(const Buffer& buff) {
    SLICER_CHECK(&buff != this);
    return Push(buff.data(), buff.size());
  }

  // TODO: this is really dangerous since it would
  //   write any type - sometimes not what you expect.
  //
  template <class T>
  size_t Push(const T& value) {
    return Push(&value, sizeof(value));
  }

  size_t PushULeb128(dex::u4 value) {
    dex::u1 tmp[4];
    dex::u1* end = dex::WriteULeb128(tmp, value);
    assert(end > tmp && end - tmp <= 4);
    return Push(tmp, end - tmp);
  }

  size_t PushSLeb128(dex::s4 value) {
    dex::u1 tmp[4];
    dex::u1* end = dex::WriteSLeb128(tmp, value);
    assert(end > tmp && end - tmp <= 4);
    return Push(tmp, end - tmp);
  }

  size_t size() const { return size_; }

  bool empty() const { return size_ == 0; }

  void Free() {
    ::free(buff_);
    buff_ = nullptr;
    size_ = 0;
    capacity_ = 0;
  }

  const dex::u1* data() const {
    SLICER_CHECK(buff_ != nullptr);
    return buff_;
  }

 private:
  void Expand(size_t size) {
    SLICER_CHECK(!sealed_);
    if (size_ + size > capacity_) {
      capacity_ = std::max(size_t(capacity_ * 1.5), size_ + size);
      buff_ = static_cast<dex::u1*>(::realloc(buff_, capacity_));
      SLICER_CHECK(buff_ != nullptr);
    }
    size_ += size;
  }

 private:
  dex::u1* buff_ = nullptr;
  size_t size_ = 0;
  size_t capacity_ = 0;
  bool sealed_ = false;
};

} // namespace slicer


```

`include/slicer/chronometer.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <chrono>

namespace slicer {

// A very simple timing chronometer
class Chronometer {
  using Clock = std::chrono::high_resolution_clock;

 public:
  // elapsed time is in milliseconds
  explicit Chronometer(double& elapsed, bool cumulative = false) :
              elapsed_(elapsed), cumulative_(cumulative) {
    start_time_ = Clock::now();
  }

  ~Chronometer() {
    Clock::time_point end_time = Clock::now();
    std::chrono::duration<double, std::milli> ms = end_time - start_time_;
    if (cumulative_) {
      elapsed_ += ms.count();
    } else {
      elapsed_ = ms.count();
    }
  }

  Chronometer(const Chronometer&) = delete;
  Chronometer& operator=(const Chronometer&) = delete;

 private:
  double& elapsed_;
  Clock::time_point start_time_;
  bool cumulative_;
};

} // namespace slicer

```

`include/slicer/common.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

namespace slicer {

// Encapsulate the runtime check and error reporting policy.
// (currently a simple fail-fast but the the intention is to allow customization)
void _checkFailed(const char* expr, int line, const char* file) __attribute__((noreturn));
#ifdef NDEBUG
#define SLICER_CHECK(expr)
#else
#define SLICER_CHECK(expr) do { if(!(expr)) slicer::_checkFailed(#expr, __LINE__, __FILE__); } while(false)
#endif

// A modal check: if the strict mode is enabled, it behaves as a SLICER_CHECK,
// otherwise it will only log a warning and continue
//
// NOTE: we use SLICER_WEAK_CHECK for .dex format validations that are frequently
//   violated by existing apps. So we need to be able to annotate these common
//   problems and potentially ignoring them for parity with the Android runtime.
//
void _weakCheckFailed(const char* expr, int line, const char* file);
#ifdef NDEBUG
#define SLICER_WEAK_CHECK(expr)
#else
#define SLICER_WEAK_CHECK(expr) do { if(!(expr)) slicer::_weakCheckFailed(#expr, __LINE__, __FILE__); } while(false)
#endif

// Report a fatal condition with a printf-formatted message
void _fatal(const char* format, ...) __attribute__((noreturn));
#define SLICER_FATAL(format, ...) slicer::_fatal("\nSLICER_FATAL: " format "\n\n", ##__VA_ARGS__);

// Annotation customization point for extra validation / state.
#ifdef NDEBUG
#define SLICER_EXTRA(x)
#else
#define SLICER_EXTRA(x) x
#endif

#ifndef FALLTHROUGH_INTENDED
#ifdef __clang__
#define FALLTHROUGH_INTENDED [[clang::fallthrough]]
#else
#define FALLTHROUGH_INTENDED
#endif // __clang__
#endif // FALLTHROUGH_INTENDED

} // namespace slicer


```

`include/slicer/dex_bytecode.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "dex_format.h"

#include <stddef.h>

// .dex bytecode definitions and helpers:
// https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html

namespace dex {

// The number of Dalvik opcodes
constexpr size_t kNumPackedOpcodes = 0x100;

// Switch table and array data signatures are a code unit consisting
// of "NOP" (0x00) in the low-order byte and a non-zero identifying
// code in the high-order byte. (A true NOP is 0x0000.)
constexpr u2 kPackedSwitchSignature = 0x0100;
constexpr u2 kSparseSwitchSignature = 0x0200;
constexpr u2 kArrayDataSignature = 0x0300;

// Enumeration of all Dalvik opcodes
enum Opcode : u1 {
#define INSTRUCTION_ENUM(opcode, cname, ...) OP_##cname = (opcode),
#include "dex_instruction_list.h"
  DEX_INSTRUCTION_LIST(INSTRUCTION_ENUM)
#undef DEX_INSTRUCTION_LIST
#undef INSTRUCTION_ENUM
};

// Instruction formats associated with Dalvik opcodes
enum InstructionFormat : u1 {
  k10x,   // op
  k12x,   // op vA, vB
  k11n,   // op vA, #+B
  k11x,   // op vAA
  k10t,   // op +AA
  k20t,   // op +AAAA
  k20bc,  // [opt] op AA, thing@BBBB
  k22x,   // op vAA, vBBBB
  k21t,   // op vAA, +BBBB
  k21s,   // op vAA, #+BBBB
  k21h,   // op vAA, #+BBBB00000[00000000]
  k21c,   // op vAA, thing@BBBB
  k23x,   // op vAA, vBB, vCC
  k22b,   // op vAA, vBB, #+CC
  k22t,   // op vA, vB, +CCCC
  k22s,   // op vA, vB, #+CCCC
  k22c,   // op vA, vB, thing@CCCC
  k22cs,  // [opt] op vA, vB, field offset CCCC
  k30t,   // op +AAAAAAAA
  k32x,   // op vAAAA, vBBBB
  k31i,   // op vAA, #+BBBBBBBB
  k31t,   // op vAA, +BBBBBBBB
  k31c,   // op vAA, string@BBBBBBBB
  k35c,   // op {vC,vD,vE,vF,vG}, thing@BBBB
  k35ms,  // [opt] invoke-virtual+super
  k3rc,   // op {vCCCC .. v(CCCC+AA-1)}, thing@BBBB
  k3rms,  // [opt] invoke-virtual+super/range
  k35mi,  // [opt] inline invoke
  k3rmi,  // [opt] inline invoke/range
  k45cc,  // op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH
  k4rcc,  // op {VCCCC .. v(CCCC+AA-1)}, meth@BBBB, proto@HHHH
  k51l,   // op vAA, #+BBBBBBBBBBBBBBBB
};

using OpcodeFlags = u1;
enum : OpcodeFlags {
  kBranch = 0x01,         // conditional or unconditional branch
  kContinue = 0x02,       // flow can continue to next statement
  kSwitch = 0x04,         // switch statement
  kThrow = 0x08,          // could cause an exception to be thrown
  kReturn = 0x10,         // returns, no additional statements
  kInvoke = 0x20,         // a flavor of invoke
  kUnconditional = 0x40,  // unconditional branch
  kExperimental = 0x80,   // is an experimental opcode
};

using VerifyFlags = u4;
enum : VerifyFlags {
  kVerifyNothing = 0x0000000,
  kVerifyRegA = 0x0000001,
  kVerifyRegAWide = 0x0000002,
  kVerifyRegB = 0x0000004,
  kVerifyRegBField = 0x0000008,
  kVerifyRegBMethod = 0x0000010,
  kVerifyRegBNewInstance = 0x0000020,
  kVerifyRegBString = 0x0000040,
  kVerifyRegBType = 0x0000080,
  kVerifyRegBWide = 0x0000100,
  kVerifyRegC = 0x0000200,
  kVerifyRegCField = 0x0000400,
  kVerifyRegCNewArray = 0x0000800,
  kVerifyRegCType = 0x0001000,
  kVerifyRegCWide = 0x0002000,
  kVerifyArrayData = 0x0004000,
  kVerifyBranchTarget = 0x0008000,
  kVerifySwitchTargets = 0x0010000,
  kVerifyVarArg = 0x0020000,
  kVerifyVarArgNonZero = 0x0040000,
  kVerifyVarArgRange = 0x0080000,
  kVerifyVarArgRangeNonZero = 0x0100000,
  kVerifyRuntimeOnly = 0x0200000,
  kVerifyError = 0x0400000,
  kVerifyRegHPrototype = 0x0800000,
  kVerifyRegBCallSite = 0x1000000,
  kVerifyRegBMethodHandle = 0x2000000,
  kVerifyRegBPrototype = 0x4000000,
};

// Types of indexed reference that are associated with opcodes whose
// formats include such an indexed reference (e.g., 21c and 35c).
enum InstructionIndexType : u1 {
  kIndexUnknown = 0,
  kIndexNone,               // has no index
  kIndexVaries,             // "It depends." Used for throw-verification-error
  kIndexTypeRef,            // type reference index
  kIndexStringRef,          // string reference index
  kIndexMethodRef,          // method reference index
  kIndexFieldRef,           // field reference index
  kIndexInlineMethod,       // inline method index (for inline linked methods)
  kIndexVtableOffset,       // vtable offset (for static linked methods)
  kIndexFieldOffset,        // field offset (for static linked fields)
  kIndexMethodAndProtoRef,  // method index and proto index
  kIndexCallSiteRef,        // call site index
  kIndexMethodHandleRef,    // constant method handle reference index
  kIndexProtoRef,           // constant prototype reference index
};

// Holds the contents of a decoded instruction.
struct Instruction {
  u4 vA;          // the A field of the instruction
  u4 vB;          // the B field of the instruction
  u8 vB_wide;     // 64bit version of the B field (for k51l)
  u4 vC;          // the C field of the instruction
  u4 arg[5];      // vC/D/E/F/G in invoke or filled-new-array
  Opcode opcode;  // instruction opcode
};

// "packed-switch-payload" format
struct PackedSwitchPayload {
  u2 ident;
  u2 size;
  s4 first_key;
  s4 targets[];
};

// "sparse-switch-payload" format
struct SparseSwitchPayload {
  u2 ident;
  u2 size;
  s4 data[];
};

// "fill-array-data-payload" format
struct ArrayData {
  u2 ident;
  u2 element_width;
  u4 size;
  u1 data[];
};

// Collect the enums in a struct for better locality.
struct InstructionDescriptor {
  u4 verify_flags;  // Set of VerifyFlag.
  InstructionFormat format;
  InstructionIndexType index_type;
  u1 flags;  // Set of Flags.
};

// Extracts the opcode from a Dalvik code unit (bytecode)
Opcode OpcodeFromBytecode(u2 bytecode);

// Returns the name of an opcode
const char* GetOpcodeName(Opcode opcode);

// Returns the index type associated with the specified opcode
InstructionIndexType GetIndexTypeFromOpcode(Opcode opcode);

// Returns the format associated with the specified opcode
InstructionFormat GetFormatFromOpcode(Opcode opcode);

// Returns the flags for the specified opcode
OpcodeFlags GetFlagsFromOpcode(Opcode opcode);

// Returns the verify flags for the specified opcode
VerifyFlags GetVerifyFlagsFromOpcode(Opcode opcode);

// Returns the instruction width for the specified opcode format
size_t GetWidthFromFormat(InstructionFormat format);

// Return the width of the specified instruction, or 0 if not defined.  Also
// works for special OP_NOP entries, including switch statement data tables
// and array data.
size_t GetWidthFromBytecode(const u2* bytecode);

// Decode a .dex bytecode
Instruction DecodeInstruction(const u2* bytecode);

}  // namespace dex

```

`include/slicer/dex_format.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <stdint.h>
#include <string>

// Definitions for .dex file format structures and helpers.
//
// The names for the structures and fields follows the specification:
// https://source.android.com/devices/tech/dalvik/dex-format.html

namespace dex {

// These match the definitions in the VM specification
typedef uint8_t u1;
typedef uint16_t u2;
typedef uint32_t u4;
typedef uint64_t u8;
typedef int8_t s1;
typedef int16_t s2;
typedef int32_t s4;
typedef int64_t s8;

// General constants
constexpr inline u4 kEndianConstant = 0x12345678;
constexpr inline u4 kNoIndex = 0xffffffff;
constexpr inline u4 kSHA1DigestLen = 20;

// Annotation visibility
constexpr inline u1 kVisibilityBuild   = 0x00;
constexpr inline u1 kVisibilityRuntime = 0x01;
constexpr inline u1 kVisibilitySystem  = 0x02;

// Special visibility: encoded_annotation, not annotation_item
constexpr inline u1 kVisibilityEncoded = 0xff;

// encoded_value types
constexpr inline u1 kEncodedByte           = 0x00;
constexpr inline u1 kEncodedShort          = 0x02;
constexpr inline u1 kEncodedChar           = 0x03;
constexpr inline u1 kEncodedInt            = 0x04;
constexpr inline u1 kEncodedLong           = 0x06;
constexpr inline u1 kEncodedFloat          = 0x10;
constexpr inline u1 kEncodedDouble         = 0x11;
constexpr inline u1 kEncodedMethodHandle   = 0x15;
constexpr inline u1 kEncodedMethodType     = 0x16;
constexpr inline u1 kEncodedString         = 0x17;
constexpr inline u1 kEncodedType           = 0x18;
constexpr inline u1 kEncodedField          = 0x19;
constexpr inline u1 kEncodedMethod         = 0x1a;
constexpr inline u1 kEncodedEnum           = 0x1b;
constexpr inline u1 kEncodedArray          = 0x1c;
constexpr inline u1 kEncodedAnnotation     = 0x1d;
constexpr inline u1 kEncodedNull           = 0x1e;
constexpr inline u1 kEncodedBoolean        = 0x1f;

// encoded_value header
constexpr inline u1 kEncodedValueTypeMask  = 0x1f;
constexpr inline u1 kEncodedValueArgShift  = 5;

// access_flags
constexpr inline u4 kAccPublic                 = 0x0001;     // class, field, method, ic
constexpr inline u4 kAccPrivate                = 0x0002;     // field, method, ic
constexpr inline u4 kAccProtected              = 0x0004;     // field, method, ic
constexpr inline u4 kAccStatic                 = 0x0008;     // field, method, ic
constexpr inline u4 kAccFinal                  = 0x0010;     // class, field, method, ic
constexpr inline u4 kAccSynchronized           = 0x0020;     // method (only allowed on natives)
constexpr inline u4 kAccSuper                  = 0x0020;     // class (not used in dex)
constexpr inline u4 kAccVolatile               = 0x0040;     // field
constexpr inline u4 kAccBridge                 = 0x0040;     // method
constexpr inline u4 kAccTransient              = 0x0080;     // field
constexpr inline u4 kAccVarargs                = 0x0080;     // method
constexpr inline u4 kAccNative                 = 0x0100;     // method
constexpr inline u4 kAccInterface              = 0x0200;     // class, ic
constexpr inline u4 kAccAbstract               = 0x0400;     // class, method, ic
constexpr inline u4 kAccStrict                 = 0x0800;     // method
constexpr inline u4 kAccSynthetic              = 0x1000;     // class, field, method, ic
constexpr inline u4 kAccAnnotation             = 0x2000;     // class, ic
constexpr inline u4 kAccEnum                   = 0x4000;     // class, field, ic
constexpr inline u4 kAccConstructor            = 0x00010000; // method (dex only) <(cl)init>
constexpr inline u4 kAccDeclaredSynchronized   = 0x00020000; // method (dex only)

// map_item type codes
constexpr inline u2 kHeaderItem                = 0x0000;
constexpr inline u2 kStringIdItem              = 0x0001;
constexpr inline u2 kTypeIdItem                = 0x0002;
constexpr inline u2 kProtoIdItem               = 0x0003;
constexpr inline u2 kFieldIdItem               = 0x0004;
constexpr inline u2 kMethodIdItem              = 0x0005;
constexpr inline u2 kClassDefItem              = 0x0006;
constexpr inline u2 kMapList                   = 0x1000;
constexpr inline u2 kTypeList                  = 0x1001;
constexpr inline u2 kAnnotationSetRefList      = 0x1002;
constexpr inline u2 kAnnotationSetItem         = 0x1003;
constexpr inline u2 kClassDataItem             = 0x2000;
constexpr inline u2 kCodeItem                  = 0x2001;
constexpr inline u2 kStringDataItem            = 0x2002;
constexpr inline u2 kDebugInfoItem             = 0x2003;
constexpr inline u2 kAnnotationItem            = 0x2004;
constexpr inline u2 kEncodedArrayItem          = 0x2005;
constexpr inline u2 kAnnotationsDirectoryItem  = 0x2006;

// debug info opcodes
constexpr inline u1 DBG_END_SEQUENCE           = 0x00;
constexpr inline u1 DBG_ADVANCE_PC             = 0x01;
constexpr inline u1 DBG_ADVANCE_LINE           = 0x02;
constexpr inline u1 DBG_START_LOCAL            = 0x03;
constexpr inline u1 DBG_START_LOCAL_EXTENDED   = 0x04;
constexpr inline u1 DBG_END_LOCAL              = 0x05;
constexpr inline u1 DBG_RESTART_LOCAL          = 0x06;
constexpr inline u1 DBG_SET_PROLOGUE_END       = 0x07;
constexpr inline u1 DBG_SET_EPILOGUE_BEGIN     = 0x08;
constexpr inline u1 DBG_SET_FILE               = 0x09;
constexpr inline u1 DBG_FIRST_SPECIAL          = 0x0a;

// special debug info values
constexpr inline int DBG_LINE_BASE = -4;
constexpr inline int DBG_LINE_RANGE = 15;

// "header_item"
struct Header {
  u1 magic[8];
  u4 checksum;
  u1 signature[kSHA1DigestLen];
  u4 file_size;
  u4 header_size;
  u4 endian_tag;
  u4 link_size;
  u4 link_off;
  u4 map_off;
  u4 string_ids_size;
  u4 string_ids_off;
  u4 type_ids_size;
  u4 type_ids_off;
  u4 proto_ids_size;
  u4 proto_ids_off;
  u4 field_ids_size;
  u4 field_ids_off;
  u4 method_ids_size;
  u4 method_ids_off;
  u4 class_defs_size;
  u4 class_defs_off;
  u4 data_size;
  u4 data_off;
};

struct CompactHeader : public Header {
    u4 feature_flags;
    u4 debug_info_offsets_pos;
    u4 debug_info_offsets_table_offset;
    u4 debug_info_base;
    u4 owned_data_begin;
    u4 owned_data_end;
};

// "map_item"
struct MapItem {
  u2 type;
  u2 unused;
  u4 size;
  u4 offset;
};

// "map_list"
struct MapList {
  u4 size;
  MapItem list[];
};

// "string_id_item"
struct StringId {
  u4 string_data_off;
};

// "type_id_item"
struct TypeId {
  u4 descriptor_idx;
};

// "field_id_item"
struct FieldId {
  u2 class_idx;
  u2 type_idx;
  u4 name_idx;
};

// "method_id_item"
struct MethodId {
  u2 class_idx;
  u2 proto_idx;
  u4 name_idx;
};

// "proto_id_item"
struct ProtoId {
  u4 shorty_idx;
  u4 return_type_idx;
  u4 parameters_off;
};

// "class_def_item"
struct ClassDef {
  u4 class_idx;
  u4 access_flags;
  u4 superclass_idx;
  u4 interfaces_off;
  u4 source_file_idx;
  u4 annotations_off;
  u4 class_data_off;
  u4 static_values_off;
};

// "type_item"
struct TypeItem {
  u2 type_idx;
};

// "type_list"
struct TypeList {
  u4 size;
  TypeItem list[];
};

struct CodeItem{

};

// "code_item"
struct Code : CodeItem {
  u2 registers_size;
  u2 ins_size;
  u2 outs_size;
  u2 tries_size;
  u4 debug_info_off;
  u4 insns_size;
  u2 insns[];
  // followed by optional u2 padding
  // followed by try_item[tries_size]
  // followed by uleb128 handlersSize
  // followed by catch_handler_item[handlersSize]
};

struct CompactCode : CodeItem {

  static constexpr size_t kInsnsSizeShift = 5;
  static constexpr u2 kBitPreHeaderInsnsSize = 4;
  static constexpr u2 kFlagPreHeaderInsnsSize = 0x1 << kBitPreHeaderInsnsSize;
  u2 fields;
  u2 insns_count_and_flags;
  u2 insns[];
};

// "try_item"
struct TryBlock {
  u4 start_addr;
  u2 insn_count;
  u2 handler_off;
};

// "annotations_directory_item"
struct AnnotationsDirectoryItem {
  u4 class_annotations_off;
  u4 fields_size;
  u4 methods_size;
  u4 parameters_size;
  // followed by FieldAnnotationsItem[fields_size]
  // followed by MethodAnnotationsItem[methods_size]
  // followed by ParameterAnnotationsItem[parameters_size]
};

// "field_annotations_item"
struct FieldAnnotationsItem {
  u4 field_idx;
  u4 annotations_off;
};

// "method_annotations_item"
struct MethodAnnotationsItem {
  u4 method_idx;
  u4 annotations_off;
};

// "parameter_annotations_item"
struct ParameterAnnotationsItem {
  u4 method_idx;
  u4 annotations_off;
};

// "annotation_set_ref_item"
struct AnnotationSetRefItem {
  u4 annotations_off;
};

// "annotation_set_ref_list"
struct AnnotationSetRefList {
  u4 size;
  AnnotationSetRefItem list[];
};

// "annotation_set_item"
struct AnnotationSetItem {
  u4 size;
  u4 entries[];
};

// "annotation_item"
struct AnnotationItem {
  u1 visibility;
  u1 annotation[];
};

// Compute DEX checksum
u4 ComputeChecksum(const Header* header);

// Converts a type descriptor to a human-readable declaration
std::string DescriptorToDecl(const char* descriptor);

// Converts a type descriptor to the equivalent shorty type descriptor
char DescriptorToShorty(const char* descriptor);

}  // namespace dex

```

`include/slicer/dex_instruction_list.h`:

```h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ART_LIBDEXFILE_DEX_DEX_INSTRUCTION_LIST_H_
#define ART_LIBDEXFILE_DEX_DEX_INSTRUCTION_LIST_H_

/**
 * Cloned from //art/libdexfile/dex/dex_instruction_list.h.
 */

// V(opcode, instruction_code, name, format, index, flags, extended_flags, verifier_flags);
#define DEX_INSTRUCTION_LIST(V) \
  V(0x00, NOP, "nop", k10x, kIndexNone, kContinue, 0, kVerifyNothing) \
  V(0x01, MOVE, "move", k12x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x02, MOVE_FROM16, "move/from16", k22x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x03, MOVE_16, "move/16", k32x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x04, MOVE_WIDE, "move-wide", k12x, kIndexNone, kContinue, 0, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x05, MOVE_WIDE_FROM16, "move-wide/from16", k22x, kIndexNone, kContinue, 0, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x06, MOVE_WIDE_16, "move-wide/16", k32x, kIndexNone, kContinue, 0, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x07, MOVE_OBJECT, "move-object", k12x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x08, MOVE_OBJECT_FROM16, "move-object/from16", k22x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x09, MOVE_OBJECT_16, "move-object/16", k32x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x0A, MOVE_RESULT, "move-result", k11x, kIndexNone, kContinue, 0, kVerifyRegA) \
  V(0x0B, MOVE_RESULT_WIDE, "move-result-wide", k11x, kIndexNone, kContinue, 0, kVerifyRegAWide) \
  V(0x0C, MOVE_RESULT_OBJECT, "move-result-object", k11x, kIndexNone, kContinue, 0, kVerifyRegA) \
  V(0x0D, MOVE_EXCEPTION, "move-exception", k11x, kIndexNone, kContinue, 0, kVerifyRegA) \
  V(0x0E, RETURN_VOID, "return-void", k10x, kIndexNone, kReturn, 0, kVerifyNothing) \
  V(0x0F, RETURN, "return", k11x, kIndexNone, kReturn, 0, kVerifyRegA) \
  V(0x10, RETURN_WIDE, "return-wide", k11x, kIndexNone, kReturn, 0, kVerifyRegAWide) \
  V(0x11, RETURN_OBJECT, "return-object", k11x, kIndexNone, kReturn, 0, kVerifyRegA) \
  V(0x12, CONST_4, "const/4", k11n, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegA) \
  V(0x13, CONST_16, "const/16", k21s, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegA) \
  V(0x14, CONST, "const", k31i, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegA) \
  V(0x15, CONST_HIGH16, "const/high16", k21h, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegA) \
  V(0x16, CONST_WIDE_16, "const-wide/16", k21s, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegAWide) \
  V(0x17, CONST_WIDE_32, "const-wide/32", k31i, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegAWide) \
  V(0x18, CONST_WIDE, "const-wide", k51l, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegAWide) \
  V(0x19, CONST_WIDE_HIGH16, "const-wide/high16", k21h, kIndexNone, kContinue, kRegBFieldOrConstant, kVerifyRegAWide) \
  V(0x1A, CONST_STRING, "const-string", k21c, kIndexStringRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegBString) \
  V(0x1B, CONST_STRING_JUMBO, "const-string/jumbo", k31c, kIndexStringRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegBString) \
  V(0x1C, CONST_CLASS, "const-class", k21c, kIndexTypeRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegBType) \
  V(0x1D, MONITOR_ENTER, "monitor-enter", k11x, kIndexNone, kContinue | kThrow, kClobber, kVerifyRegA) \
  V(0x1E, MONITOR_EXIT, "monitor-exit", k11x, kIndexNone, kContinue | kThrow, kClobber, kVerifyRegA) \
  V(0x1F, CHECK_CAST, "check-cast", k21c, kIndexTypeRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegBType) \
  V(0x20, INSTANCE_OF, "instance-of", k22c, kIndexTypeRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegB | kVerifyRegCType) \
  V(0x21, ARRAY_LENGTH, "array-length", k12x, kIndexNone, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegB) \
  V(0x22, NEW_INSTANCE, "new-instance", k21c, kIndexTypeRef, kContinue | kThrow, kClobber, kVerifyRegA | kVerifyRegBNewInstance) \
  V(0x23, NEW_ARRAY, "new-array", k22c, kIndexTypeRef, kContinue | kThrow, kClobber, kVerifyRegA | kVerifyRegB | kVerifyRegCNewArray) \
  V(0x24, FILLED_NEW_ARRAY, "filled-new-array", k35c, kIndexTypeRef, kContinue | kThrow, kClobber, kVerifyRegBType | kVerifyVarArg) \
  V(0x25, FILLED_NEW_ARRAY_RANGE, "filled-new-array/range", k3rc, kIndexTypeRef, kContinue | kThrow, kClobber, kVerifyRegBType | kVerifyVarArgRange) \
  V(0x26, FILL_ARRAY_DATA, "fill-array-data", k31t, kIndexNone, kContinue | kThrow, kClobber, kVerifyRegA | kVerifyArrayData) \
  V(0x27, THROW, "throw", k11x, kIndexNone, kThrow, 0, kVerifyRegA) \
  V(0x28, GOTO, "goto", k10t, kIndexNone, kBranch | kUnconditional, 0, kVerifyBranchTarget) \
  V(0x29, GOTO_16, "goto/16", k20t, kIndexNone, kBranch | kUnconditional, 0, kVerifyBranchTarget) \
  V(0x2A, GOTO_32, "goto/32", k30t, kIndexNone, kBranch | kUnconditional, 0, kVerifyBranchTarget) \
  V(0x2B, PACKED_SWITCH, "packed-switch", k31t, kIndexNone, kContinue | kSwitch, 0, kVerifyRegA | kVerifySwitchTargets) \
  V(0x2C, SPARSE_SWITCH, "sparse-switch", k31t, kIndexNone, kContinue | kSwitch, 0, kVerifyRegA | kVerifySwitchTargets) \
  V(0x2D, CMPL_FLOAT, "cmpl-float", k23x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x2E, CMPG_FLOAT, "cmpg-float", k23x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x2F, CMPL_DOUBLE, "cmpl-double", k23x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x30, CMPG_DOUBLE, "cmpg-double", k23x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x31, CMP_LONG, "cmp-long", k23x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x32, IF_EQ, "if-eq", k22t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyRegB | kVerifyBranchTarget) \
  V(0x33, IF_NE, "if-ne", k22t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyRegB | kVerifyBranchTarget) \
  V(0x34, IF_LT, "if-lt", k22t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyRegB | kVerifyBranchTarget) \
  V(0x35, IF_GE, "if-ge", k22t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyRegB | kVerifyBranchTarget) \
  V(0x36, IF_GT, "if-gt", k22t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyRegB | kVerifyBranchTarget) \
  V(0x37, IF_LE, "if-le", k22t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyRegB | kVerifyBranchTarget) \
  V(0x38, IF_EQZ, "if-eqz", k21t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyBranchTarget) \
  V(0x39, IF_NEZ, "if-nez", k21t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyBranchTarget) \
  V(0x3A, IF_LTZ, "if-ltz", k21t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyBranchTarget) \
  V(0x3B, IF_GEZ, "if-gez", k21t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyBranchTarget) \
  V(0x3C, IF_GTZ, "if-gtz", k21t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyBranchTarget) \
  V(0x3D, IF_LEZ, "if-lez", k21t, kIndexNone, kContinue | kBranch, 0, kVerifyRegA | kVerifyBranchTarget) \
  V(0x3E, UNUSED_3E, "unused-3e", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x3F, UNUSED_3F, "unused-3f", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x40, UNUSED_40, "unused-40", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x41, UNUSED_41, "unused-41", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x42, UNUSED_42, "unused-42", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x43, UNUSED_43, "unused-43", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x44, AGET, "aget", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x45, AGET_WIDE, "aget-wide", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegAWide | kVerifyRegB | kVerifyRegC) \
  V(0x46, AGET_OBJECT, "aget-object", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x47, AGET_BOOLEAN, "aget-boolean", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x48, AGET_BYTE, "aget-byte", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x49, AGET_CHAR, "aget-char", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x4A, AGET_SHORT, "aget-short", k23x, kIndexNone, kContinue | kThrow, kLoad, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x4B, APUT, "aput", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x4C, APUT_WIDE, "aput-wide", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegAWide | kVerifyRegB | kVerifyRegC) \
  V(0x4D, APUT_OBJECT, "aput-object", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x4E, APUT_BOOLEAN, "aput-boolean", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x4F, APUT_BYTE, "aput-byte", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x50, APUT_CHAR, "aput-char", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x51, APUT_SHORT, "aput-short", k23x, kIndexNone, kContinue | kThrow, kStore, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x52, IGET, "iget", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x53, IGET_WIDE, "iget-wide", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegAWide | kVerifyRegB | kVerifyRegCField) \
  V(0x54, IGET_OBJECT, "iget-object", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x55, IGET_BOOLEAN, "iget-boolean", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x56, IGET_BYTE, "iget-byte", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x57, IGET_CHAR, "iget-char", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x58, IGET_SHORT, "iget-short", k22c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x59, IPUT, "iput", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x5A, IPUT_WIDE, "iput-wide", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegAWide | kVerifyRegB | kVerifyRegCField) \
  V(0x5B, IPUT_OBJECT, "iput-object", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x5C, IPUT_BOOLEAN, "iput-boolean", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x5D, IPUT_BYTE, "iput-byte", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x5E, IPUT_CHAR, "iput-char", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x5F, IPUT_SHORT, "iput-short", k22c, kIndexFieldRef, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRegCField) \
  V(0x60, SGET, "sget", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x61, SGET_WIDE, "sget-wide", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegAWide | kVerifyRegBField) \
  V(0x62, SGET_OBJECT, "sget-object", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x63, SGET_BOOLEAN, "sget-boolean", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x64, SGET_BYTE, "sget-byte", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x65, SGET_CHAR, "sget-char", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x66, SGET_SHORT, "sget-short", k21c, kIndexFieldRef, kContinue | kThrow, kLoad | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x67, SPUT, "sput", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x68, SPUT_WIDE, "sput-wide", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegAWide | kVerifyRegBField) \
  V(0x69, SPUT_OBJECT, "sput-object", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x6A, SPUT_BOOLEAN, "sput-boolean", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x6B, SPUT_BYTE, "sput-byte", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x6C, SPUT_CHAR, "sput-char", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x6D, SPUT_SHORT, "sput-short", k21c, kIndexFieldRef, kContinue | kThrow, kStore | kRegBFieldOrConstant, kVerifyRegA | kVerifyRegBField) \
  V(0x6E, INVOKE_VIRTUAL, "invoke-virtual", k35c, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgNonZero) \
  V(0x6F, INVOKE_SUPER, "invoke-super", k35c, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgNonZero) \
  V(0x70, INVOKE_DIRECT, "invoke-direct", k35c, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgNonZero) \
  V(0x71, INVOKE_STATIC, "invoke-static", k35c, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArg) \
  V(0x72, INVOKE_INTERFACE, "invoke-interface", k35c, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgNonZero) \
  V(0x73, RETURN_VOID_NO_BARRIER, "return-void-no-barrier", k10x, kIndexNone, kReturn, 0, kVerifyNothing) \
  V(0x74, INVOKE_VIRTUAL_RANGE, "invoke-virtual/range", k3rc, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgRangeNonZero) \
  V(0x75, INVOKE_SUPER_RANGE, "invoke-super/range", k3rc, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgRangeNonZero) \
  V(0x76, INVOKE_DIRECT_RANGE, "invoke-direct/range", k3rc, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgRangeNonZero) \
  V(0x77, INVOKE_STATIC_RANGE, "invoke-static/range", k3rc, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgRange) \
  V(0x78, INVOKE_INTERFACE_RANGE, "invoke-interface/range", k3rc, kIndexMethodRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgRangeNonZero) \
  V(0x79, UNUSED_79, "unused-79", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x7A, UNUSED_7A, "unused-7a", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0x7B, NEG_INT, "neg-int", k12x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x7C, NOT_INT, "not-int", k12x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x7D, NEG_LONG, "neg-long", k12x, kIndexNone, kContinue, 0, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x7E, NOT_LONG, "not-long", k12x, kIndexNone, kContinue, 0, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x7F, NEG_FLOAT, "neg-float", k12x, kIndexNone, kContinue, 0, kVerifyRegA | kVerifyRegB) \
  V(0x80, NEG_DOUBLE, "neg-double", k12x, kIndexNone, kContinue, 0, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x81, INT_TO_LONG, "int-to-long", k12x, kIndexNone, kContinue, kCast, kVerifyRegAWide | kVerifyRegB) \
  V(0x82, INT_TO_FLOAT, "int-to-float", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegB) \
  V(0x83, INT_TO_DOUBLE, "int-to-double", k12x, kIndexNone, kContinue, kCast, kVerifyRegAWide | kVerifyRegB) \
  V(0x84, LONG_TO_INT, "long-to-int", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegBWide) \
  V(0x85, LONG_TO_FLOAT, "long-to-float", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegBWide) \
  V(0x86, LONG_TO_DOUBLE, "long-to-double", k12x, kIndexNone, kContinue, kCast, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x87, FLOAT_TO_INT, "float-to-int", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegB) \
  V(0x88, FLOAT_TO_LONG, "float-to-long", k12x, kIndexNone, kContinue, kCast, kVerifyRegAWide | kVerifyRegB) \
  V(0x89, FLOAT_TO_DOUBLE, "float-to-double", k12x, kIndexNone, kContinue, kCast, kVerifyRegAWide | kVerifyRegB) \
  V(0x8A, DOUBLE_TO_INT, "double-to-int", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegBWide) \
  V(0x8B, DOUBLE_TO_LONG, "double-to-long", k12x, kIndexNone, kContinue, kCast, kVerifyRegAWide | kVerifyRegBWide) \
  V(0x8C, DOUBLE_TO_FLOAT, "double-to-float", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegBWide) \
  V(0x8D, INT_TO_BYTE, "int-to-byte", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegB) \
  V(0x8E, INT_TO_CHAR, "int-to-char", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegB) \
  V(0x8F, INT_TO_SHORT, "int-to-short", k12x, kIndexNone, kContinue, kCast, kVerifyRegA | kVerifyRegB) \
  V(0x90, ADD_INT, "add-int", k23x, kIndexNone, kContinue, kAdd, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x91, SUB_INT, "sub-int", k23x, kIndexNone, kContinue, kSubtract, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x92, MUL_INT, "mul-int", k23x, kIndexNone, kContinue, kMultiply, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x93, DIV_INT, "div-int", k23x, kIndexNone, kContinue | kThrow, kDivide, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x94, REM_INT, "rem-int", k23x, kIndexNone, kContinue | kThrow, kRemainder, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x95, AND_INT, "and-int", k23x, kIndexNone, kContinue, kAnd, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x96, OR_INT, "or-int", k23x, kIndexNone, kContinue, kOr, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x97, XOR_INT, "xor-int", k23x, kIndexNone, kContinue, kXor, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x98, SHL_INT, "shl-int", k23x, kIndexNone, kContinue, kShl, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x99, SHR_INT, "shr-int", k23x, kIndexNone, kContinue, kShr, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x9A, USHR_INT, "ushr-int", k23x, kIndexNone, kContinue, kUshr, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0x9B, ADD_LONG, "add-long", k23x, kIndexNone, kContinue, kAdd, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x9C, SUB_LONG, "sub-long", k23x, kIndexNone, kContinue, kSubtract, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x9D, MUL_LONG, "mul-long", k23x, kIndexNone, kContinue, kMultiply, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x9E, DIV_LONG, "div-long", k23x, kIndexNone, kContinue | kThrow, kDivide, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0x9F, REM_LONG, "rem-long", k23x, kIndexNone, kContinue | kThrow, kRemainder, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xA0, AND_LONG, "and-long", k23x, kIndexNone, kContinue, kAnd, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xA1, OR_LONG, "or-long", k23x, kIndexNone, kContinue, kOr, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xA2, XOR_LONG, "xor-long", k23x, kIndexNone, kContinue, kXor, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xA3, SHL_LONG, "shl-long", k23x, kIndexNone, kContinue, kShl, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegC) \
  V(0xA4, SHR_LONG, "shr-long", k23x, kIndexNone, kContinue, kShr, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegC) \
  V(0xA5, USHR_LONG, "ushr-long", k23x, kIndexNone, kContinue, kUshr, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegC) \
  V(0xA6, ADD_FLOAT, "add-float", k23x, kIndexNone, kContinue, kAdd, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0xA7, SUB_FLOAT, "sub-float", k23x, kIndexNone, kContinue, kSubtract, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0xA8, MUL_FLOAT, "mul-float", k23x, kIndexNone, kContinue, kMultiply, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0xA9, DIV_FLOAT, "div-float", k23x, kIndexNone, kContinue, kDivide, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0xAA, REM_FLOAT, "rem-float", k23x, kIndexNone, kContinue, kRemainder, kVerifyRegA | kVerifyRegB | kVerifyRegC) \
  V(0xAB, ADD_DOUBLE, "add-double", k23x, kIndexNone, kContinue, kAdd, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xAC, SUB_DOUBLE, "sub-double", k23x, kIndexNone, kContinue, kSubtract, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xAD, MUL_DOUBLE, "mul-double", k23x, kIndexNone, kContinue, kMultiply, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xAE, DIV_DOUBLE, "div-double", k23x, kIndexNone, kContinue, kDivide, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xAF, REM_DOUBLE, "rem-double", k23x, kIndexNone, kContinue, kRemainder, kVerifyRegAWide | kVerifyRegBWide | kVerifyRegCWide) \
  V(0xB0, ADD_INT_2ADDR, "add-int/2addr", k12x, kIndexNone, kContinue, kAdd, kVerifyRegA | kVerifyRegB) \
  V(0xB1, SUB_INT_2ADDR, "sub-int/2addr", k12x, kIndexNone, kContinue, kSubtract, kVerifyRegA | kVerifyRegB) \
  V(0xB2, MUL_INT_2ADDR, "mul-int/2addr", k12x, kIndexNone, kContinue, kMultiply, kVerifyRegA | kVerifyRegB) \
  V(0xB3, DIV_INT_2ADDR, "div-int/2addr", k12x, kIndexNone, kContinue | kThrow, kDivide, kVerifyRegA | kVerifyRegB) \
  V(0xB4, REM_INT_2ADDR, "rem-int/2addr", k12x, kIndexNone, kContinue | kThrow, kRemainder, kVerifyRegA | kVerifyRegB) \
  V(0xB5, AND_INT_2ADDR, "and-int/2addr", k12x, kIndexNone, kContinue, kAnd, kVerifyRegA | kVerifyRegB) \
  V(0xB6, OR_INT_2ADDR, "or-int/2addr", k12x, kIndexNone, kContinue, kOr, kVerifyRegA | kVerifyRegB) \
  V(0xB7, XOR_INT_2ADDR, "xor-int/2addr", k12x, kIndexNone, kContinue, kXor, kVerifyRegA | kVerifyRegB) \
  V(0xB8, SHL_INT_2ADDR, "shl-int/2addr", k12x, kIndexNone, kContinue, kShl, kVerifyRegA | kVerifyRegB) \
  V(0xB9, SHR_INT_2ADDR, "shr-int/2addr", k12x, kIndexNone, kContinue, kShr, kVerifyRegA | kVerifyRegB) \
  V(0xBA, USHR_INT_2ADDR, "ushr-int/2addr", k12x, kIndexNone, kContinue, kUshr, kVerifyRegA | kVerifyRegB) \
  V(0xBB, ADD_LONG_2ADDR, "add-long/2addr", k12x, kIndexNone, kContinue, kAdd, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xBC, SUB_LONG_2ADDR, "sub-long/2addr", k12x, kIndexNone, kContinue, kSubtract, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xBD, MUL_LONG_2ADDR, "mul-long/2addr", k12x, kIndexNone, kContinue, kMultiply, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xBE, DIV_LONG_2ADDR, "div-long/2addr", k12x, kIndexNone, kContinue | kThrow, kDivide, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xBF, REM_LONG_2ADDR, "rem-long/2addr", k12x, kIndexNone, kContinue | kThrow, kRemainder, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xC0, AND_LONG_2ADDR, "and-long/2addr", k12x, kIndexNone, kContinue, kAnd, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xC1, OR_LONG_2ADDR, "or-long/2addr", k12x, kIndexNone, kContinue, kOr, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xC2, XOR_LONG_2ADDR, "xor-long/2addr", k12x, kIndexNone, kContinue, kXor, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xC3, SHL_LONG_2ADDR, "shl-long/2addr", k12x, kIndexNone, kContinue, kShl, kVerifyRegAWide | kVerifyRegB) \
  V(0xC4, SHR_LONG_2ADDR, "shr-long/2addr", k12x, kIndexNone, kContinue, kShr, kVerifyRegAWide | kVerifyRegB) \
  V(0xC5, USHR_LONG_2ADDR, "ushr-long/2addr", k12x, kIndexNone, kContinue, kUshr, kVerifyRegAWide | kVerifyRegB) \
  V(0xC6, ADD_FLOAT_2ADDR, "add-float/2addr", k12x, kIndexNone, kContinue, kAdd, kVerifyRegA | kVerifyRegB) \
  V(0xC7, SUB_FLOAT_2ADDR, "sub-float/2addr", k12x, kIndexNone, kContinue, kSubtract, kVerifyRegA | kVerifyRegB) \
  V(0xC8, MUL_FLOAT_2ADDR, "mul-float/2addr", k12x, kIndexNone, kContinue, kMultiply, kVerifyRegA | kVerifyRegB) \
  V(0xC9, DIV_FLOAT_2ADDR, "div-float/2addr", k12x, kIndexNone, kContinue, kDivide, kVerifyRegA | kVerifyRegB) \
  V(0xCA, REM_FLOAT_2ADDR, "rem-float/2addr", k12x, kIndexNone, kContinue, kRemainder, kVerifyRegA | kVerifyRegB) \
  V(0xCB, ADD_DOUBLE_2ADDR, "add-double/2addr", k12x, kIndexNone, kContinue, kAdd, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xCC, SUB_DOUBLE_2ADDR, "sub-double/2addr", k12x, kIndexNone, kContinue, kSubtract, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xCD, MUL_DOUBLE_2ADDR, "mul-double/2addr", k12x, kIndexNone, kContinue, kMultiply, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xCE, DIV_DOUBLE_2ADDR, "div-double/2addr", k12x, kIndexNone, kContinue, kDivide, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xCF, REM_DOUBLE_2ADDR, "rem-double/2addr", k12x, kIndexNone, kContinue, kRemainder, kVerifyRegAWide | kVerifyRegBWide) \
  V(0xD0, ADD_INT_LIT16, "add-int/lit16", k22s, kIndexNone, kContinue, kAdd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD1, RSUB_INT, "rsub-int", k22s, kIndexNone, kContinue, kSubtract | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD2, MUL_INT_LIT16, "mul-int/lit16", k22s, kIndexNone, kContinue, kMultiply | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD3, DIV_INT_LIT16, "div-int/lit16", k22s, kIndexNone, kContinue | kThrow, kDivide | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD4, REM_INT_LIT16, "rem-int/lit16", k22s, kIndexNone, kContinue | kThrow, kRemainder | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD5, AND_INT_LIT16, "and-int/lit16", k22s, kIndexNone, kContinue, kAnd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD6, OR_INT_LIT16, "or-int/lit16", k22s, kIndexNone, kContinue, kOr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD7, XOR_INT_LIT16, "xor-int/lit16", k22s, kIndexNone, kContinue, kXor | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD8, ADD_INT_LIT8, "add-int/lit8", k22b, kIndexNone, kContinue, kAdd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xD9, RSUB_INT_LIT8, "rsub-int/lit8", k22b, kIndexNone, kContinue, kSubtract | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xDA, MUL_INT_LIT8, "mul-int/lit8", k22b, kIndexNone, kContinue, kMultiply | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xDB, DIV_INT_LIT8, "div-int/lit8", k22b, kIndexNone, kContinue | kThrow, kDivide | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xDC, REM_INT_LIT8, "rem-int/lit8", k22b, kIndexNone, kContinue | kThrow, kRemainder | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xDD, AND_INT_LIT8, "and-int/lit8", k22b, kIndexNone, kContinue, kAnd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xDE, OR_INT_LIT8, "or-int/lit8", k22b, kIndexNone, kContinue, kOr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xDF, XOR_INT_LIT8, "xor-int/lit8", k22b, kIndexNone, kContinue, kXor | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xE0, SHL_INT_LIT8, "shl-int/lit8", k22b, kIndexNone, kContinue, kShl | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xE1, SHR_INT_LIT8, "shr-int/lit8", k22b, kIndexNone, kContinue, kShr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xE2, USHR_INT_LIT8, "ushr-int/lit8", k22b, kIndexNone, kContinue, kUshr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \
  V(0xE3, IGET_QUICK, "iget-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xE4, IGET_WIDE_QUICK, "iget-wide-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegAWide | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xE5, IGET_OBJECT_QUICK, "iget-object-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xE6, IPUT_QUICK, "iput-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xE7, IPUT_WIDE_QUICK, "iput-wide-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegAWide | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xE8, IPUT_OBJECT_QUICK, "iput-object-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xE9, INVOKE_VIRTUAL_QUICK, "invoke-virtual-quick", k35c, kIndexVtableOffset, kContinue | kThrow | kInvoke, 0, kVerifyVarArgNonZero | kVerifyRuntimeOnly) \
  V(0xEA, INVOKE_VIRTUAL_RANGE_QUICK, "invoke-virtual/range-quick", k3rc, kIndexVtableOffset, kContinue | kThrow | kInvoke, 0, kVerifyVarArgRangeNonZero | kVerifyRuntimeOnly) \
  V(0xEB, IPUT_BOOLEAN_QUICK, "iput-boolean-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xEC, IPUT_BYTE_QUICK, "iput-byte-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xED, IPUT_CHAR_QUICK, "iput-char-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xEE, IPUT_SHORT_QUICK, "iput-short-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kStore | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xEF, IGET_BOOLEAN_QUICK, "iget-boolean-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xF0, IGET_BYTE_QUICK, "iget-byte-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xF1, IGET_CHAR_QUICK, "iget-char-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xF2, IGET_SHORT_QUICK, "iget-short-quick", k22c, kIndexFieldOffset, kContinue | kThrow, kLoad | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB | kVerifyRuntimeOnly) \
  V(0xF3, UNUSED_F3, "unused-f3", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xF4, UNUSED_F4, "unused-f4", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xF5, UNUSED_F5, "unused-f5", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xF6, UNUSED_F6, "unused-f6", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xF7, UNUSED_F7, "unused-f7", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xF8, UNUSED_F8, "unused-f8", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xF9, UNUSED_F9, "unused-f9", k10x, kIndexUnknown, 0, 0, kVerifyError) \
  V(0xFA, INVOKE_POLYMORPHIC, "invoke-polymorphic", k45cc, kIndexMethodAndProtoRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgNonZero | kVerifyRegHPrototype) \
  V(0xFB, INVOKE_POLYMORPHIC_RANGE, "invoke-polymorphic/range", k4rcc, kIndexMethodAndProtoRef, kContinue | kThrow | kInvoke, 0, kVerifyRegBMethod | kVerifyVarArgRangeNonZero | kVerifyRegHPrototype) \
  V(0xFC, INVOKE_CUSTOM, "invoke-custom", k35c, kIndexCallSiteRef, kContinue | kThrow, 0, kVerifyRegBCallSite | kVerifyVarArg) \
  V(0xFD, INVOKE_CUSTOM_RANGE, "invoke-custom/range", k3rc, kIndexCallSiteRef, kContinue | kThrow, 0, kVerifyRegBCallSite | kVerifyVarArgRange) \
  V(0xFE, CONST_METHOD_HANDLE, "const-method-handle", k21c, kIndexMethodHandleRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegBMethodHandle) \
  V(0xFF, CONST_METHOD_TYPE, "const-method-type", k21c, kIndexProtoRef, kContinue | kThrow, 0, kVerifyRegA | kVerifyRegBPrototype)

#define DEX_INSTRUCTION_FORMAT_LIST(V) \
  V(k10x) \
  V(k12x) \
  V(k11n) \
  V(k11x) \
  V(k10t) \
  V(k20t) \
  V(k22x) \
  V(k21t) \
  V(k21s) \
  V(k21h) \
  V(k21c) \
  V(k23x) \
  V(k22b) \
  V(k22t) \
  V(k22s) \
  V(k22c) \
  V(k32x) \
  V(k30t) \
  V(k31t) \
  V(k31i) \
  V(k31c) \
  V(k35c) \
  V(k3rc) \
  V(k45cc) \
  V(k4rcc) \
  V(k51l)

#endif  // ART_LIBDEXFILE_DEX_DEX_INSTRUCTION_LIST_H_
#undef ART_LIBDEXFILE_DEX_DEX_INSTRUCTION_LIST_H_  // the guard in this file is just for cpplint
```

`include/slicer/dex_ir.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"
#include "memview.h"
#include "arrayview.h"
#include "dex_format.h"
#include "dex_leb128.h"
#include "buffer.h"
#include "index_map.h"
#include "hash_table.h"

#include <stdlib.h>
#include <map>
#include <memory>
#include <vector>
#include <string>

// A simple, lightweight IR to abstract the key .dex structures
//
// 1. All the cross-IR references are modeled as plain pointers.
// 2. Newly allocated nodes are mem-zeroed first
//
// This IR can mirror any .dex file, although for JVMTI BCI
// it's expected to construct the IR for the single modified class only
// (and include only the nodes referenced from that class)

#define SLICER_IR_TYPE     \
  using Node::Node; \
  friend struct DexFile;

#define SLICER_IR_INDEXED_TYPE           \
  using IndexedNode::IndexedNode; \
  friend struct DexFile;

namespace ir {

// convenience notation
template <class T>
using own = std::unique_ptr<T>;

struct Node;
struct IndexedNode;
struct EncodedValue;
struct EncodedArray;
struct String;
struct Type;
struct TypeList;
struct Proto;
struct FieldDecl;
struct EncodedField;
struct DebugInfo;
struct Code;
struct MethodDecl;
struct EncodedMethod;
struct AnnotationElement;
struct Annotation;
struct AnnotationSet;
struct AnnotationSetRefList;
struct FieldAnnotation;
struct MethodAnnotation;
struct ParamAnnotation;
struct AnnotationsDirectory;
struct Class;
struct DexFile;

// The base class for all the .dex IR types:
//   This is not a polymorphic interface, but
//   a way to constrain the allocation and ownership
//   of .dex IR nodes.
struct Node {
  void* operator new(size_t size) {
    return ::calloc(1, size);
  }

  void* operator new[](size_t size) {
    return ::calloc(1, size);
  }

  void operator delete(void* ptr) {
    ::free(ptr);
  }

  void operator delete[](void* ptr) {
    ::free(ptr);
  }

 public:
  Node(const Node&) = delete;
  Node& operator=(const Node&) = delete;

 protected:
  Node() = default;
  ~Node() = default;
};

// a concession for the convenience of the .dex writer
//
// TODO: consider moving the indexing to the writer.
//
struct IndexedNode : public Node {
  SLICER_IR_TYPE;

  // this is the index in the generated image
  // (not the original index)
  dex::u4 index;

  // original indexe
  // (from the source .dex image or allocated post reader)
  dex::u4 orig_index;
};

struct EncodedValue : public Node {
  SLICER_IR_TYPE;

  dex::u1 type;
  union {
    int8_t byte_value;
    int16_t short_value;
    uint16_t char_value;
    int32_t int_value;
    int64_t long_value;
    float float_value;
    double double_value;
    String* string_value;
    Type* type_value;
    FieldDecl* field_value;
    MethodDecl* method_value;
    FieldDecl* enum_value;
    EncodedArray* array_value;
    Annotation* annotation_value;
    bool bool_value;
  } u;

  SLICER_EXTRA(slicer::MemView original);
};

struct EncodedArray : public Node {
  SLICER_IR_TYPE;

  std::vector<EncodedValue*> values;
};

struct String : public IndexedNode {
  SLICER_IR_INDEXED_TYPE;

  // opaque DEX "string_data_item"
  slicer::MemView data;

  const char* c_str() const {
    const dex::u1* strData = data.ptr<dex::u1>();
    dex::ReadULeb128(&strData);
    return reinterpret_cast<const char*>(strData);
  }
};

struct Type : public IndexedNode {
  SLICER_IR_INDEXED_TYPE;

  enum class Category { Void, Scalar, WideScalar, Reference };

  String* descriptor;
  Class* class_def;

  std::string Decl() const;
  Category GetCategory() const;
};

struct TypeList : public Node {
  SLICER_IR_TYPE;

  std::vector<Type*> types;
};

struct Proto : public IndexedNode {
  SLICER_IR_INDEXED_TYPE;

  String* shorty;
  Type* return_type;
  TypeList* param_types;

  std::string Signature() const;
};

struct FieldDecl : public IndexedNode {
  SLICER_IR_INDEXED_TYPE;

  String* name;
  Type* type;
  Type* parent;
};

struct EncodedField : public Node {
  SLICER_IR_TYPE;

  FieldDecl* decl;
  dex::u4 access_flags;
};

struct DebugInfo : public Node {
  SLICER_IR_TYPE;

  dex::u4 line_start;
  std::vector<String*> param_names;

  // original debug info opcodes stream
  // (must be "relocated" when creating a new .dex image)
  slicer::MemView data;
};

struct Code : public Node {
  SLICER_IR_TYPE;

  dex::u2 registers;
  dex::u2 ins_count;
  dex::u2 outs_count;
  slicer::ArrayView<const dex::u2> instructions;
  slicer::ArrayView<const dex::TryBlock> try_blocks;
  slicer::MemView catch_handlers;
  DebugInfo* debug_info;
};

struct MethodDecl : public IndexedNode {
  SLICER_IR_INDEXED_TYPE;

  String* name;
  Proto* prototype;
  Type* parent;
};

struct EncodedMethod : public Node {
  SLICER_IR_TYPE;

  MethodDecl* decl;
  Code* code;
  dex::u4 access_flags;
};

struct AnnotationElement : public Node {
  SLICER_IR_TYPE;

  String* name;
  EncodedValue* value;
};

struct Annotation : public Node {
  SLICER_IR_TYPE;

  Type* type;
  std::vector<AnnotationElement*> elements;
  dex::u1 visibility;
};

struct AnnotationSet : public Node {
  SLICER_IR_TYPE;

  std::vector<Annotation*> annotations;
};

struct AnnotationSetRefList : public Node {
  SLICER_IR_TYPE;

  std::vector<AnnotationSet*> annotations;
};

struct FieldAnnotation : public Node {
  SLICER_IR_TYPE;

  FieldDecl* field_decl;
  AnnotationSet* annotations;
};

struct MethodAnnotation : public Node {
  SLICER_IR_TYPE;

  MethodDecl* method_decl;
  AnnotationSet* annotations;
};

struct ParamAnnotation : public Node {
  SLICER_IR_TYPE;

  MethodDecl* method_decl;
  AnnotationSetRefList* annotations;
};

struct AnnotationsDirectory : public Node {
  SLICER_IR_TYPE;

  AnnotationSet* class_annotation;
  std::vector<FieldAnnotation*> field_annotations;
  std::vector<MethodAnnotation*> method_annotations;
  std::vector<ParamAnnotation*> param_annotations;
};

struct Class : public IndexedNode {
  SLICER_IR_INDEXED_TYPE;

  Type* type;
  dex::u4 access_flags;
  Type* super_class;
  TypeList* interfaces;
  String* source_file;
  AnnotationsDirectory* annotations;
  EncodedArray* static_init;

  std::vector<EncodedField*> static_fields;
  std::vector<EncodedField*> instance_fields;
  std::vector<EncodedMethod*> direct_methods;
  std::vector<EncodedMethod*> virtual_methods;
};

// ir::String hashing
struct StringsHasher {
  const char* GetKey(const String* string) const { return string->c_str(); }
  uint32_t Hash(const char* string_key) const;
  bool Compare(const char* string_key, const String* string) const;
};

// ir::Proto hashing
struct ProtosHasher {
  std::string GetKey(const Proto* proto) const { return proto->Signature(); }
  uint32_t Hash(const std::string& proto_key) const;
  bool Compare(const std::string& proto_key, const Proto* proto) const;
};

// ir::EncodedMethod hashing
struct MethodKey {
  String* class_descriptor = nullptr;
  String* method_name = nullptr;
  Proto* prototype = nullptr;
};

struct MethodsHasher {
  MethodKey GetKey(const EncodedMethod* method) const;
  uint32_t Hash(const MethodKey& method_key) const;
  bool Compare(const MethodKey& method_key, const EncodedMethod* method) const;
};

using StringsLookup = slicer::HashTable<const char*, String, StringsHasher>;
using PrototypesLookup = slicer::HashTable<const std::string&, Proto, ProtosHasher>;
using MethodsLookup = slicer::HashTable<const MethodKey&, EncodedMethod, MethodsHasher>;

// The main container/root for a .dex IR
struct DexFile {
  // indexed structures
  std::vector<own<String>> strings;
  std::vector<own<Type>> types;
  std::vector<own<Proto>> protos;
  std::vector<own<FieldDecl>> fields;
  std::vector<own<MethodDecl>> methods;
  std::vector<own<Class>> classes;

  // data segment structures
  std::vector<own<EncodedField>> encoded_fields;
  std::vector<own<EncodedMethod>> encoded_methods;
  std::vector<own<TypeList>> type_lists;
  std::vector<own<Code>> code;
  std::vector<own<DebugInfo>> debug_info;
  std::vector<own<EncodedValue>> encoded_values;
  std::vector<own<EncodedArray>> encoded_arrays;
  std::vector<own<Annotation>> annotations;
  std::vector<own<AnnotationElement>> annotation_elements;
  std::vector<own<AnnotationSet>> annotation_sets;
  std::vector<own<AnnotationSetRefList>> annotation_set_ref_lists;
  std::vector<own<AnnotationsDirectory>> annotations_directories;
  std::vector<own<FieldAnnotation>> field_annotations;
  std::vector<own<MethodAnnotation>> method_annotations;
  std::vector<own<ParamAnnotation>> param_annotations;

  // original index to IR node mappings
  //
  // CONSIDER: we only need to carry around
  //   the relocation for the referenced items
  //
  std::map<dex::u4, Type*> types_map;
  std::map<dex::u4, String*> strings_map;
  std::map<dex::u4, Proto*> protos_map;
  std::map<dex::u4, FieldDecl*> fields_map;
  std::map<dex::u4, MethodDecl*> methods_map;
  std::map<dex::u4, Class*> classes_map;

  // original .dex header "magic" signature
  slicer::MemView magic;

  // keep track of the used index values
  // (so we can easily allocate new ones)
  IndexMap strings_indexes;
  IndexMap types_indexes;
  IndexMap protos_indexes;
  IndexMap fields_indexes;
  IndexMap methods_indexes;
  IndexMap classes_indexes;

  // lookup hash tables
  StringsLookup strings_lookup;
  MethodsLookup methods_lookup;
  PrototypesLookup prototypes_lookup;

 public:
  DexFile() = default;

  // No copy/move semantics
  DexFile(const DexFile&) = delete;
  DexFile& operator=(const DexFile&) = delete;

  template <class T>
  T* Alloc() {
    T* p = new T();
    Track(p);
    return p;
  }

  void AttachBuffer(slicer::Buffer&& buffer) {
    buffers_.push_back(std::move(buffer));
  }

  void Normalize();

 private:
  void TopSortClassIndex(Class* irClass, dex::u4* nextIndex);
  void SortClassIndexes();

  template <class T>
  void PushOwn(std::vector<own<T>>& v, T* p) {
    v.push_back(own<T>(p));
  }

  void Track(String* p) { PushOwn(strings, p); }
  void Track(Type* p) { PushOwn(types, p); }
  void Track(Proto* p) { PushOwn(protos, p); }
  void Track(FieldDecl* p) { PushOwn(fields, p); }
  void Track(MethodDecl* p) { PushOwn(methods, p); }
  void Track(Class* p) { PushOwn(classes, p); }

  void Track(EncodedField* p) { PushOwn(encoded_fields, p); }
  void Track(EncodedMethod* p) { PushOwn(encoded_methods, p); }
  void Track(TypeList* p) { PushOwn(type_lists, p); }
  void Track(Code* p) { PushOwn(code, p); }
  void Track(DebugInfo* p) { PushOwn(debug_info, p); }
  void Track(EncodedValue* p) { PushOwn(encoded_values, p); }
  void Track(EncodedArray* p) { PushOwn(encoded_arrays, p); }
  void Track(Annotation* p) { PushOwn(annotations, p); }
  void Track(AnnotationElement* p) { PushOwn(annotation_elements, p); }
  void Track(AnnotationSet* p) { PushOwn(annotation_sets, p); }
  void Track(AnnotationSetRefList* p) { PushOwn(annotation_set_ref_lists, p); }
  void Track(AnnotationsDirectory* p) { PushOwn(annotations_directories, p); }
  void Track(FieldAnnotation* p) { PushOwn(field_annotations, p); }
  void Track(MethodAnnotation* p) { PushOwn(method_annotations, p); }
  void Track(ParamAnnotation* p) { PushOwn(param_annotations, p); }

private:
  // additional memory buffers owned by this .dex IR
  std::vector<slicer::Buffer> buffers_;
};

}  // namespace ir

#undef SLICER_IR_TYPE
#undef SLICER_IR_INDEXED_TYPE

```

`include/slicer/dex_leb128.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "dex_format.h"

// LEB128 encode/decode helpers:
// https://source.android.com/devices/tech/dalvik/dex-format.html

namespace dex {

// Reads an unsigned LEB128 value, updating the given pointer to
// point just past the end of the read value.
inline u4 ReadULeb128(const u1** pptr) {
  const u1* ptr = *pptr;
  u4 result = *(ptr++);

  if (result > 0x7f) {
    u4 cur = *(ptr++);
    result = (result & 0x7f) | ((cur & 0x7f) << 7);
    if (cur > 0x7f) {
      cur = *(ptr++);
      result |= (cur & 0x7f) << 14;
      if (cur > 0x7f) {
        cur = *(ptr++);
        result |= (cur & 0x7f) << 21;
        if (cur > 0x7f) {
          // We don't check to see if cur is out of
          // range here, meaning we tolerate garbage in the
          // high four-order bits.
          cur = *(ptr++);
          result |= cur << 28;
        }
      }
    }
  }

  *pptr = ptr;
  return result;
}

// Reads a signed LEB128 value, updating the given pointer to
// point just past the end of the read value.
inline s4 ReadSLeb128(const u1** pptr) {
  const u1* ptr = *pptr;
  s4 result = *(ptr++);

  if (result <= 0x7f) {
    result = (result << 25) >> 25;
  } else {
    s4 cur = *(ptr++);
    result = (result & 0x7f) | ((cur & 0x7f) << 7);
    if (cur <= 0x7f) {
      result = (result << 18) >> 18;
    } else {
      cur = *(ptr++);
      result |= (cur & 0x7f) << 14;
      if (cur <= 0x7f) {
        result = (result << 11) >> 11;
      } else {
        cur = *(ptr++);
        result |= (cur & 0x7f) << 21;
        if (cur <= 0x7f) {
          result = (result << 4) >> 4;
        } else {
          // Note: We don't check to see if cur is out of
          // range here, meaning we tolerate garbage in the
          // high four-order bits.
          cur = *(ptr++);
          result |= cur << 28;
        }
      }
    }
  }

  *pptr = ptr;
  return result;
}

// Writes a 32-bit value in unsigned ULEB128 format.
// Returns the updated pointer.
inline u1* WriteULeb128(u1* ptr, u4 data) {
  for (;;) {
    u1 out = data & 0x7f;
    if (out != data) {
      *ptr++ = out | 0x80;
      data >>= 7;
    } else {
      *ptr++ = out;
      break;
    }
  }
  return ptr;
}

// Writes a 32-bit value in signed ULEB128 format.
// Returns the updated pointer.
inline u1* WriteSLeb128(u1* ptr, s4 value) {
  u4 extra_bits = static_cast<u4>(value ^ (value >> 31)) >> 6;
  u1 out = value & 0x7f;
  while (extra_bits != 0u) {
    *ptr++ = out | 0x80;
    value >>= 7;
    out = value & 0x7f;
    extra_bits >>= 7;
  }
  *ptr++ = out;
  return ptr;
}

}  // namespace dex

```

`include/slicer/dex_utf8.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "dex_format.h"

// MUTF-8 (Modified UTF-8) Encoding helpers:
// https://source.android.com/devices/tech/dalvik/dex-format.html

namespace dex {

// Compare two '\0'-terminated modified UTF-8 strings, using Unicode
// code point values for comparison. This treats different encodings
// for the same code point as equivalent, except that only a real '\0'
// byte is considered the string terminator. The return value is as
// for strcmp().
int Utf8Cmp(const char* s1, const char* s2);

}  // namespace dex
```

`include/slicer/hash_table.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <vector>
#include <cstdint>
#include <memory>

namespace slicer {

// A specialized Key -> T* map (note that, unlike std:: containers, the values
// are always pointers here, and we don't explicitly store the lookup keys)
//
// Implemented as an incrementally resizable hash table: we split the logical hash table
// into two internal fixed size tables, the "full table" and a "insertion table".
// When the insertion table overflows, we allocate a larger hashtable to replace
// it and "insertion table" becomes the "full table" (the old "full table" is
// rehashed into the new hash table)
//
// Similar to open addressing hash tables, all the buckets are a single,
// contiguous array. But this table is growing and the collisions are still handled
// as chains (using indexes instead of pointers).
//
// The result is faster than std::unordered_map and uses ~25% of
// the memory used by std::unordered_map<const char*, String*>
//
// The Hash template argument is a type which must implement:
//   1. hash function   : uint32_t Hash(const Key& key)
//   2. key compare     : bool Compare(const Key& key, T* value)
//   3. key extraction  : Key GetKey(T* value)
//   4. copy semantics
//
template<class Key, class T, class Hash>
class HashTable {
 private:
  // the index type inside the bucket array
  using Index = uint32_t;

  static constexpr Index kInitialHashBuckets = (1 << 7) - 1;
  static constexpr Index kAvgChainLength = 2;
  static constexpr Index kInvalidIndex = static_cast<Index>(-1);
  static constexpr double kResizeFactor = 1.6;

  struct __attribute__((packed)) Bucket {
    T* value = nullptr;
    Index next = kInvalidIndex;
  };

  class Partition {
   public:
    Partition(Index size, const Hash& hasher);
    bool Insert(T* value);
    T* Lookup(const Key& key, uint32_t hash_value) const;
    Index HashBuckets() const { return hash_buckets_; }
    void InsertAll(const Partition& src);
    void PrintStats(const char* name, bool verbose);

   private:
    std::vector<Bucket> buckets_;
    const Index hash_buckets_;
    Hash hasher_;
  };

 public:
  explicit HashTable(const Hash& hasher = Hash()) : hasher_(hasher) {
    // we start with full_table_ == nullptr
    insertion_table_.reset(new Partition(kInitialHashBuckets, hasher_));
  }

  ~HashTable() = default;

  // No move or copy semantics
  HashTable(const HashTable&) = delete;
  HashTable& operator=(const HashTable&) = delete;

  // Insert a new, non-nullptr T* into the hash table
  // (we only store unique values so the new value must
  // not be in the table already)
  void Insert(T* value);

  // Lookup an existing value
  // (returns nullptr if the value is not found)
  T* Lookup(const Key& key) const;

  void PrintStats(const char* name, bool verbose);

 private:
  std::unique_ptr<Partition> full_table_;
  std::unique_ptr<Partition> insertion_table_;
  Hash hasher_;
};

template<class Key, class T, class Hash>
HashTable<Key, T, Hash>::Partition::Partition(Index size, const Hash& hasher)
    : hash_buckets_(size), hasher_(hasher) {
  // allocate space for the hash buckets + avg chain length
  buckets_.reserve(hash_buckets_ * kAvgChainLength);
  buckets_.resize(hash_buckets_);
}

// Similar to the "cellar" version of coalesced hashing,
// the buckets array is divided into a fixed set of entries
// addressable by the hash value [0 .. hash_buckets_) and
// extra buckets for the collision chains [hash_buckets_, buckets_.size())
// Unlike coalesced hashing, our "cellar" is growing so we don't actually
// have to coalesce any chains.
//
// Returns true if the insertion succeeded, false if the table overflows
// (we never insert more than the pre-reserved capacity)
//
template<class Key, class T, class Hash>
bool HashTable<Key, T, Hash>::Partition::Insert(T* value) {
  SLICER_CHECK(value != nullptr);
  // overflow?
  if (buckets_.size() + 1 > buckets_.capacity()) {
    return false;
  }
  auto key = hasher_.GetKey(value);
  Index bucket_index = hasher_.Hash(key) % hash_buckets_;
  if (buckets_[bucket_index].value == nullptr) {
    buckets_[bucket_index].value = value;
  } else {
    Bucket new_bucket = {};
    new_bucket.value = value;
    new_bucket.next = buckets_[bucket_index].next;
    buckets_[bucket_index].next = buckets_.size();
    buckets_.push_back(new_bucket);
  }
  return true;
}

template<class Key, class T, class Hash>
T* HashTable<Key, T, Hash>::Partition::Lookup(const Key& key, uint32_t hash_value) const {
  assert(hash_value == hasher_.Hash(key));
  Index bucket_index = hash_value % hash_buckets_;
  for (Index index = bucket_index; index != kInvalidIndex; index = buckets_[index].next) {
    auto value = buckets_[index].value;
    if (value == nullptr) {
      assert(index < hash_buckets_);
      break;
    } else if (hasher_.Compare(key, value)) {
      return value;
    }
  }
  return nullptr;
}

template<class Key, class T, class Hash>
void HashTable<Key, T, Hash>::Partition::InsertAll(const Partition& src) {
  for (const auto& bucket : src.buckets_) {
    if (bucket.value != nullptr) {
      SLICER_CHECK(Insert(bucket.value));
    }
  }
}

// Try to insert into the "insertion table". If that overflows,
// we allocate a new, larger hash table, move "full table" value to it
// and "insertion table" becomes the new "full table".
template<class Key, class T, class Hash>
void HashTable<Key, T, Hash>::Insert(T* value) {
  assert(Lookup(hasher_.GetKey(value)) == nullptr);
  if (!insertion_table_->Insert(value)) {
    std::unique_ptr<Partition> new_hash_table(
        new Partition(insertion_table_->HashBuckets() * kResizeFactor, hasher_));
    if (full_table_) {
      new_hash_table->InsertAll(*full_table_);
    }
    SLICER_CHECK(new_hash_table->Insert(value));
    full_table_ = std::move(insertion_table_);
    insertion_table_ = std::move(new_hash_table);
  }
}

// First look into the "full table" and if the value is
// not found there look into the "insertion table" next
template<class Key, class T, class Hash>
T* HashTable<Key, T, Hash>::Lookup(const Key& key) const {
  auto hash_value = hasher_.Hash(key);
  if (full_table_) {
    auto value = full_table_->Lookup(key, hash_value);
    if (value != nullptr) {
      return value;
    }
  }
  return insertion_table_->Lookup(key, hash_value);
}

template<class Key, class T, class Hash>
void HashTable<Key, T, Hash>::Partition::PrintStats(const char* name, bool verbose) {
  int max_chain_length = 0;
  int sum_chain_length = 0;
  int used_buckets = 0;
  for (Index i = 0; i < hash_buckets_; ++i) {
    if (verbose) printf("%4d : ", i);
    if (buckets_[i].value != nullptr) {
      ++used_buckets;
      int chain_length = 0;
      for (Index ci = i; buckets_[ci].next != kInvalidIndex; ci = buckets_[ci].next) {
        SLICER_CHECK(buckets_[ci].value != nullptr);
        ++chain_length;
        if (verbose) printf("*");
      }
      max_chain_length = std::max(max_chain_length, chain_length);
      sum_chain_length += chain_length;
    }
    if (verbose) printf("\n");
  }

  int avg_chain_length = used_buckets ? sum_chain_length / used_buckets : 0;

  printf("\nHash table partition (%s):\n", name);
  printf("  hash_buckets                   : %u\n", hash_buckets_);
  printf("  size/capacity                  : %zu / %zu\n", buckets_.size(), buckets_.capacity());
  printf("  used_buckets                   : %d\n", used_buckets);
  printf("  max_chain_length               : %d\n", max_chain_length);
  printf("  avg_chain_length               : %d\n", avg_chain_length);
}

template<class Key, class T, class Hash>
void HashTable<Key, T, Hash>::PrintStats(const char* name, bool verbose) {
  printf("\nHash table stats (%s)\n", name);
  if (full_table_) {
    full_table_->PrintStats("full_table", verbose);
  }
  insertion_table_->PrintStats("insertion_table", verbose);
}

}  // namespace slicer
```

`include/slicer/index_map.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"
#include "dex_format.h"

#include <vector>

namespace ir {

// A simple index tracking and allocator
class IndexMap {
 public:
  dex::u4 AllocateIndex() {
    const auto size = indexes_map_.size();
    while (alloc_pos_ < size && indexes_map_[alloc_pos_]) {
      ++alloc_pos_;
    }
    MarkUsedIndex(alloc_pos_);
    return alloc_pos_++;
  }

  void MarkUsedIndex(dex::u4 index) {
    if (index >= indexes_map_.size()) {
      indexes_map_.resize(index + 1);
    }
    SLICER_CHECK(!indexes_map_[index]);
    indexes_map_[index] = true;
  }

 private:
  std::vector<bool> indexes_map_;
  dex::u4 alloc_pos_ = 0;
};

}  // namespace ir
```

`include/slicer/memview.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"

#include <assert.h>
#include <stdlib.h>

namespace slicer {

// A shallow, non-owning reference to a "view" inside a memory buffer
class MemView {
 public:
  MemView() : ptr_(nullptr), size_(0) {}

  MemView(const void* ptr, size_t size) : ptr_(ptr), size_(size) {
    assert(size > 0);
  }

  ~MemView() = default;

  template <class T = void>
  const T* ptr() const {
    return static_cast<const T*>(ptr_);
  }

  size_t size() const { return size_; }

 private:
  const void* ptr_;
  size_t size_;
};

} // namespace slicer


```

`include/slicer/reader.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"
#include "dex_format.h"
#include "dex_ir.h"

#include <assert.h>
#include <stdlib.h>
#include <map>
#include <memory>

namespace dex {

inline constexpr uint8_t opcode_len[] = {
        1, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 2, 3, 5, 2, 2, 3, 2, 1, 1, 2,
        2, 1, 2, 2, 3, 3, 3, 1, 1, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1,
        1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2,
        2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, // removed in Android 12
        1, 1, 1, 1, 1, 1, 1, 4, 4, 3, 3, 2, 2};
static_assert(sizeof(opcode_len) == 256);

// Provides both a low level iteration over the .dex
// structures and incremental .dex IR creation.
//
// NOTES:
// - only little-endian .dex files and host machines are supported
// - aggresive structure validation & minimal semantic validation
//
class Reader {
 public:
  Reader(const dex::u1* image, size_t size, const dex::u1* data = nullptr, size_t data_size = 0);
  ~Reader() = default;

  Reader(Reader&&) = default;
  Reader& operator=(Reader&&) = default;

  // No copy semantics
  Reader(const Reader&) = delete;
  Reader& operator=(const Reader&) = delete;

 public:
  // Low level dex format interface
  const dex::Header* Header() const { return header_; }
  const bool IsCompact() const { return is_compact_; }
  const char* GetStringMUTF8(dex::u4 index) const;
  slicer::ArrayView<const dex::ClassDef> ClassDefs() const;
  slicer::ArrayView<const dex::StringId> StringIds() const;
  slicer::ArrayView<const dex::TypeId> TypeIds() const;
  slicer::ArrayView<const dex::FieldId> FieldIds() const;
  slicer::ArrayView<const dex::MethodId> MethodIds() const;
  slicer::ArrayView<const dex::ProtoId> ProtoIds() const;
  const dex::MapList* DexMapList() const;

  static bool IsCompact(const void* image) {
    const auto *header = reinterpret_cast<const struct Header*>(image);
    if (header->magic[0] == 'd' && header->magic[1] == 'e' && header->magic[2] == 'x' && header->magic[3] == '\n') {
      return false;
    } else if (header->magic[0] == 'c' && header->magic[1] == 'd' && header->magic[2] == 'e' && header->magic[3] == 'x') {
      return true;
    }
    return false;
  }

  // IR creation interface
  std::shared_ptr<ir::DexFile> GetIr() const { return dex_ir_; }
  void CreateFullIr();
  void CreateClassIr(dex::u4 index);
  dex::u4 FindClassIndex(const char* class_descriptor) const;

  // Convert a file pointer (absolute offset) to an in-memory pointer
  template <class T>
  const T* ptr(u4 offset) const {
    SLICER_CHECK(offset >= 0 && offset + sizeof(T) <= size_);
    return reinterpret_cast<const T*>(image_ + offset);
  }

  // Convert a data section file pointer (absolute offset) to an in-memory pointer
  // (offset should be inside the data section)
  template <class T>
  const T* dataPtr(size_t offset) const {
    SLICER_CHECK((is_compact_ || offset >= header_->data_off) && offset + sizeof(T) <= data_size_);
    return reinterpret_cast<const T*>(data_ + offset);
  }
 private:
  // Internal access to IR nodes for indexed .dex structures
  ir::Class* GetClass(dex::u4 index);
  ir::Type* GetType(dex::u4 index);
  ir::FieldDecl* GetFieldDecl(dex::u4 index);
  ir::MethodDecl* GetMethodDecl(dex::u4 index);
  ir::Proto* GetProto(dex::u4 index);
  ir::String* GetString(dex::u4 index);

  // Parsing annotations
  ir::AnnotationsDirectory* ExtractAnnotations(dex::u4 offset);
  ir::Annotation* ExtractAnnotationItem(dex::u4 offset);
  ir::AnnotationSet* ExtractAnnotationSet(dex::u4 offset);
  ir::AnnotationSetRefList* ExtractAnnotationSetRefList(dex::u4 offset);
  ir::FieldAnnotation* ParseFieldAnnotation(const dex::u1** pptr);
  ir::MethodAnnotation* ParseMethodAnnotation(const dex::u1** pptr);
  ir::ParamAnnotation* ParseParamAnnotation(const dex::u1** pptr);
  ir::EncodedField* ParseEncodedField(const dex::u1** pptr, dex::u4* baseIndex);
  ir::Annotation* ParseAnnotation(const dex::u1** pptr);

  // Parse encoded values and arrays
  ir::EncodedValue* ParseEncodedValue(const dex::u1** pptr);
  ir::EncodedArray* ParseEncodedArray(const dex::u1** pptr);
  ir::EncodedArray* ExtractEncodedArray(dex::u4 offset);

  // Parse root .dex structures
  ir::Class* ParseClass(dex::u4 index);
  ir::EncodedMethod* ParseEncodedMethod(const dex::u1** pptr, dex::u4* baseIndex);
  ir::Type* ParseType(dex::u4 index);
  ir::FieldDecl* ParseFieldDecl(dex::u4 index);
  ir::MethodDecl* ParseMethodDecl(dex::u4 index);
  ir::TypeList* ExtractTypeList(dex::u4 offset);
  ir::Proto* ParseProto(dex::u4 index);
  ir::String* ParseString(dex::u4 index);

  // Parse code and debug information
  ir::DebugInfo* ExtractDebugInfo(dex::u4 offset);
  ir::Code* ExtractCode(dex::u4 offset);
  void ParseInstructions(slicer::ArrayView<const dex::u2> code);

  // Map an indexed section to an ArrayView<T>
  template <class T>
  slicer::ArrayView<const T> section(int offset, int count) const {
    return slicer::ArrayView<const T>(ptr<T>(offset), count);
  }

  // Simple accessor for a MUTF8 string data
  const dex::u1* GetStringData(dex::u4 index) const {
    auto& stringId = StringIds()[index];
    return dataPtr<dex::u1>(stringId.string_data_off);
  }

  void ValidateHeader();

 private:
  // the in-memory .dex image
  const dex::u1* image_;
  [[maybe_unused]] size_t size_;
  const dex::u1* data_;
  [[maybe_unused]] size_t data_size_;

  // .dex image header
  const dex::Header* header_;

  // .dex IR associated with the reader
  std::shared_ptr<ir::DexFile> dex_ir_;

  bool is_compact_;

  // maps for de-duplicating items identified by file pointers
  std::map<dex::u4, ir::TypeList*> type_lists_;
  std::map<dex::u4, ir::Annotation*> annotations_;
  std::map<dex::u4, ir::AnnotationSet*> annotation_sets_;
  std::map<dex::u4, ir::AnnotationsDirectory*> annotations_directories_;
  std::map<dex::u4, ir::EncodedArray*> encoded_arrays_;
};

}  // namespace dex

```

`include/slicer/scopeguard.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

namespace slicer {

// A simple and lightweight scope guard and macro
// (inspired by Andrei Alexandrescu's C++11 Scope Guard)
//
// Here is how it's used:
//
//  FILE* file = std::fopen(...);
//  SLICER_SCOPE_EXIT {
//      std::fclose(file);
//  };
//
// "file" will be closed at the end of the enclosing scope,
//  regardless of how the scope is exited
//
class ScopeGuardHelper
{
    template<class T>
    class ScopeGuard
    {
    public:
        explicit ScopeGuard(T closure) :
            closure_(std::move(closure))
        {
        }

        ~ScopeGuard()
        {
            closure_();
        }

        // move constructor only
        ScopeGuard(ScopeGuard&&) = default;
        ScopeGuard(const ScopeGuard&) = delete;
        ScopeGuard& operator=(const ScopeGuard&) = delete;
        ScopeGuard& operator=(ScopeGuard&&) = delete;

    private:
        T closure_;
    };

public:
    template<class T>
    ScopeGuard<T> operator<<(T closure)
    {
        return ScopeGuard<T>(std::move(closure));
    }
};

#define SLICER_SG_MACRO_CONCAT2(a, b) a ## b
#define SLICER_SG_MACRO_CONCAT(a, b) SLICER_SG_MACRO_CONCAT2(a, b)
#define SLICER_SG_ANONYMOUS(prefix)  SLICER_SG_MACRO_CONCAT(prefix, __COUNTER__)

#define SLICER_SCOPE_EXIT \
    auto SLICER_SG_ANONYMOUS(_scope_guard_) = slicer::ScopeGuardHelper() << [&]()

} // namespace slicer

```

`include/slicer/sha1.h`:

```h
/* ================ sha1.h ================ */
/*
SHA-1 in C
By Steve Reid <steve@edmweb.com>
100% Public Domain
*/

#include <cstdint>
#define u_int32_t uint32_t

typedef struct {
    u_int32_t state[5];
    u_int32_t count[2];
    unsigned char buffer[64];
} SHA1_CTX;

void SHA1Transform(u_int32_t state[5], const unsigned char buffer[64]);
void SHA1Init(SHA1_CTX* context);
void SHA1Update(SHA1_CTX* context, const unsigned char* data, u_int32_t len);
void SHA1Final(unsigned char digest[20], SHA1_CTX* context);
```

`include/slicer/writer.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "common.h"
#include "buffer.h"
#include "arrayview.h"
#include "dex_format.h"
#include "dex_ir.h"

#include <map>
#include <memory>
#include <vector>

namespace dex {

// Specialized buffer for creating a .dex image section
// (tracking the section offset, section type, ...)
class Section : public slicer::Buffer {
 public:
  explicit Section(dex::u2 mapEntryType) : map_entry_type_(mapEntryType) {}
  ~Section() = default;

  Section(const Section&) = delete;
  Section& operator=(const Section&) = delete;

  void SetOffset(dex::u4 offset) {
    SLICER_CHECK(offset > 0 && offset % 4 == 0);
    offset_ = offset;
  }

  dex::u4 SectionOffset() const {
    SLICER_CHECK(offset_ > 0 && offset_ % 4 == 0);
    return ItemsCount() > 0 ? offset_ : 0;
  }

  dex::u4 AbsoluteOffset(dex::u4 itemOffset) const {
    SLICER_CHECK(offset_ > 0);
    SLICER_CHECK(itemOffset < size());
    return offset_ + itemOffset;
  }

  // TODO: return absolute offsets?
  dex::u4 AddItem(dex::u4 alignment = 1) {
    ++count_;
    Align(alignment);
    return size();
  }

  dex::u4 ItemsCount() const { return count_; }

  dex::u2 MapEntryType() const { return map_entry_type_; }

 private:
  dex::u4 offset_ = 0;
  dex::u4 count_ = 0;
  const dex::u2 map_entry_type_;
};

// A specialized container for an .dex index section
// (strings, types, fields, methods, ...)
template <class T>
class Index {
 public:
  explicit Index(dex::u2 mapEntryType) : map_entry_type_(mapEntryType) {}
  ~Index() = default;

  Index(const Index&) = delete;
  Index& operator=(const Index&) = delete;

  dex::u4 Init(dex::u4 offset, dex::u4 count) {
    values_.reset(new T[count]);
    offset_ = offset;
    count_ = count;
    return size();
  }

  void Free() {
    values_.reset();
    offset_ = 0;
    count_ = 0;
  }

  dex::u4 SectionOffset() const {
    SLICER_CHECK(offset_ > 0 && offset_ % 4 == 0);
    return ItemsCount() > 0 ? offset_ : 0;
  }

  T* begin() { return values_.get(); }
  T* end() { return begin() + count_; }

  bool empty() const { return count_ == 0; }

  dex::u4 ItemsCount() const { return count_; }
  const T* data() const { return values_.get(); }
  dex::u4 size() const { return count_ * sizeof(T); }

  T& operator[](dex::u4 i) {
    SLICER_CHECK(i < count_);
    return values_[i];
  }

  dex::u2 MapEntryType() const { return map_entry_type_; }

 private:
  dex::u4 offset_ = 0;
  dex::u4 count_ = 0;
  std::unique_ptr<T[]> values_;
  const dex::u2 map_entry_type_;
};

// Creates an in-memory .dex image from a .dex IR
class Writer {
  // The container for the individual sections in a .dex image
  // (factored out from Writer for a more granular lifetime control)
  struct DexImage {
    DexImage()
        : string_ids(dex::kStringIdItem),
          type_ids(dex::kTypeIdItem),
          proto_ids(dex::kProtoIdItem),
          field_ids(dex::kFieldIdItem),
          method_ids(dex::kMethodIdItem),
          class_defs(dex::kClassDefItem),
          string_data(dex::kStringDataItem),
          type_lists(dex::kTypeList),
          debug_info(dex::kDebugInfoItem),
          encoded_arrays(dex::kEncodedArrayItem),
          code(dex::kCodeItem),
          class_data(dex::kClassDataItem),
          ann_directories(dex::kAnnotationsDirectoryItem),
          ann_set_ref_lists(dex::kAnnotationSetRefList),
          ann_sets(dex::kAnnotationSetItem),
          ann_items(dex::kAnnotationItem),
          map_list(dex::kMapList) {}

    Index<dex::StringId> string_ids;
    Index<dex::TypeId> type_ids;
    Index<dex::ProtoId> proto_ids;
    Index<dex::FieldId> field_ids;
    Index<dex::MethodId> method_ids;
    Index<dex::ClassDef> class_defs;

    Section string_data;
    Section type_lists;
    Section debug_info;
    Section encoded_arrays;
    Section code;
    Section class_data;
    Section ann_directories;
    Section ann_set_ref_lists;
    Section ann_sets;
    Section ann_items;
    Section map_list;
  };

 public:
  // interface for allocating the final in-memory image
  struct Allocator {
    virtual void* Allocate(size_t size) = 0;
    virtual void Free(void* ptr) = 0;
    virtual ~Allocator() = default;
  };

 public:
  explicit Writer(std::shared_ptr<ir::DexFile> dex_ir) : dex_ir_(dex_ir) {}
  ~Writer() = default;

  Writer(const Writer&) = delete;
  Writer& operator=(const Writer&) = delete;

  // .dex image creation
  dex::u1* CreateImage(Allocator* allocator, size_t* new_image_size, bool checksum=false);

 private:
  // helpers for creating various .dex sections
  dex::u4 CreateStringDataSection(dex::u4 section_offset);
  dex::u4 CreateMapSection(dex::u4 section_offset);
  dex::u4 CreateAnnItemSection(dex::u4 section_offset);
  dex::u4 CreateAnnSetsSection(dex::u4 section_offset);
  dex::u4 CreateAnnSetRefListsSection(dex::u4 section_offset);
  dex::u4 CreateTypeListsSection(dex::u4 section_offset);
  dex::u4 CreateCodeItemSection(dex::u4 section_offset);
  dex::u4 CreateDebugInfoSection(dex::u4 section_offset);
  dex::u4 CreateClassDataSection(dex::u4 section_offset);
  dex::u4 CreateAnnDirectoriesSection(dex::u4 section_offset);
  dex::u4 CreateEncodedArrayItemSection(dex::u4 section_offset);

  // back-fill the indexes
  void FillTypes();
  void FillProtos();
  void FillFields();
  void FillMethods();
  void FillClassDefs();

  // helpers for writing .dex structures
  dex::u4 WriteTypeList(const std::vector<ir::Type*>& types);
  dex::u4 WriteAnnotationItem(const ir::Annotation* ir_annotation);
  dex::u4 WriteAnnotationSet(const ir::AnnotationSet* ir_annotation_set);
  dex::u4 WriteAnnotationSetRefList(const ir::AnnotationSetRefList* ir_annotation_set_ref_list);
  dex::u4 WriteClassAnnotations(const ir::Class* ir_class);
  dex::u4 WriteDebugInfo(const ir::DebugInfo* ir_debug_info);
  dex::u4 WriteCode(const ir::Code* ir_code);
  dex::u4 WriteClassData(const ir::Class* ir_class);
  dex::u4 WriteClassStaticValues(const ir::Class* ir_class);

  // Map indexes from the original .dex to the
  // corresponding index in the new image
  dex::u4 MapStringIndex(dex::u4 index) const;
  dex::u4 MapTypeIndex(dex::u4 index) const;
  dex::u4 MapFieldIndex(dex::u4 index) const;
  dex::u4 MapMethodIndex(dex::u4 index) const;
  dex::u4 MapProtoIndex(dex::u4 index) const;

  // writing parts of a class definition
  void WriteInstructions(slicer::ArrayView<const dex::u2> instructions);
  void WriteTryBlocks(const ir::Code* ir_code);
  void WriteEncodedField(const ir::EncodedField* irEncodedField, dex::u4* base_index);
  void WriteEncodedMethod(const ir::EncodedMethod* irEncodedMethod, dex::u4* base_index);

  dex::u4 FilePointer(const ir::Node* ir_node) const;

 private:
  std::shared_ptr<ir::DexFile> dex_ir_;
  std::unique_ptr<DexImage> dex_;

  // CONSIDER: we can have multiple maps per IR node type
  //  (that's what the reader does)
  std::map<const ir::Node*, dex::u4> node_offset_;
};

}  // namespace dex

```

`slicer/common.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/common.h"

#include <stdio.h>
#include <stdlib.h>
#include <cstdarg>
#include <set>
#include <utility>

namespace slicer {

// Helper for the default SLICER_CHECK() policy
void _checkFailed(const char* expr, int line, const char* file) {
  printf("\nSLICER_CHECK failed [%s] at %s:%d\n\n", expr, file, line);
  abort();
}

// keep track of the failures we already saw to avoid spamming with duplicates
thread_local std::set<std::pair<int, const char*>> weak_failures;

// Helper for the default SLICER_WEAK_CHECK() policy
//
// TODO: implement a modal switch (abort/continue)
//
void _weakCheckFailed(const char* expr, int line, const char* file) {
  auto failure_id = std::make_pair(line, file);
  if (weak_failures.find(failure_id) == weak_failures.end()) {
    printf("\nSLICER_WEAK_CHECK failed [%s] at %s:%d\n\n", expr, file, line);
    weak_failures.insert(failure_id);
  }
}

// Prints a formatted message and aborts
void _fatal(const char* format, ...) {
  va_list args;
  va_start(args, format);
  vprintf(format, args);
  va_end(args);
  abort();
}

} // namespace slicer

```

`slicer/dex_bytecode.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/dex_bytecode.h"
#include "slicer/common.h"

#include <assert.h>
#include <array>

namespace dex {

Opcode OpcodeFromBytecode(u2 bytecode) {
  Opcode opcode = Opcode(bytecode & 0xff);
  return opcode;
}

// Table that maps each opcode to the index type implied by that opcode
static constexpr std::array<InstructionDescriptor, kNumPackedOpcodes>
    gInstructionDescriptors = {{
#define INSTRUCTION_DESCR(o, c, p, format, index, flags, e, vflags) \
  {                                                                 \
      vflags,                                                       \
      format,                                                       \
      index,                                                        \
      flags,                                                        \
  },
#include "slicer/dex_instruction_list.h"
        DEX_INSTRUCTION_LIST(INSTRUCTION_DESCR)
#undef DEX_INSTRUCTION_LIST
#undef INSTRUCTION_DESCR
    }};

InstructionIndexType GetIndexTypeFromOpcode(Opcode opcode) {
  return gInstructionDescriptors[opcode].index_type;
}

InstructionFormat GetFormatFromOpcode(Opcode opcode) {
  return gInstructionDescriptors[opcode].format;
}

OpcodeFlags GetFlagsFromOpcode(Opcode opcode) {
  return gInstructionDescriptors[opcode].flags;
}

VerifyFlags GetVerifyFlagsFromOpcode(Opcode opcode) {
  return gInstructionDescriptors[opcode].verify_flags;
}

size_t GetWidthFromFormat(InstructionFormat format) {
  switch (format) {
    case k10x:
    case k12x:
    case k11n:
    case k11x:
    case k10t:
      return 1;
    case k20t:
    case k20bc:
    case k21c:
    case k22x:
    case k21s:
    case k21t:
    case k21h:
    case k23x:
    case k22b:
    case k22s:
    case k22t:
    case k22c:
    case k22cs:
      return 2;
    case k30t:
    case k31t:
    case k31c:
    case k32x:
    case k31i:
    case k35c:
    case k35ms:
    case k35mi:
    case k3rc:
    case k3rms:
    case k3rmi:
      return 3;
    case k45cc:
    case k4rcc:
      return 4;
    case k51l:
      return 5;
  }
}

size_t GetWidthFromBytecode(const u2* bytecode) {
  size_t width = 0;
  if (*bytecode == kPackedSwitchSignature) {
    width = 4 + bytecode[1] * 2;
  } else if (*bytecode == kSparseSwitchSignature) {
    width = 2 + bytecode[1] * 4;
  } else if (*bytecode == kArrayDataSignature) {
    u2 elemWidth = bytecode[1];
    u4 len = bytecode[2] | (((u4)bytecode[3]) << 16);
    // The plus 1 is to round up for odd size and width.
    width = 4 + (elemWidth * len + 1) / 2;
  } else {
    width = GetWidthFromFormat(
        GetFormatFromOpcode(OpcodeFromBytecode(bytecode[0])));
  }
  return width;
}

// Dalvik opcode names.
static constexpr std::array<const char*, kNumPackedOpcodes> gOpcodeNames = {
#define INSTRUCTION_NAME(o, c, pname, f, i, a, e, v) pname,
#include "slicer/dex_instruction_list.h"
    DEX_INSTRUCTION_LIST(INSTRUCTION_NAME)
#undef DEX_INSTRUCTION_LIST
#undef INSTRUCTION_NAME
};

const char* GetOpcodeName(Opcode opcode) { return gOpcodeNames[opcode]; }

// Helpers for DecodeInstruction()
static u4 InstA(u2 inst) { return (inst >> 8) & 0x0f; }
static u4 InstB(u2 inst) { return inst >> 12; }
static u4 InstAA(u2 inst) { return inst >> 8; }

// Helper for DecodeInstruction()
static u4 FetchU4(const u2* ptr) { return ptr[0] | (u4(ptr[1]) << 16); }

// Helper for DecodeInstruction()
static u8 FetchU8(const u2* ptr) {
  return FetchU4(ptr) | (u8(FetchU4(ptr + 2)) << 32);
}

// Decode a Dalvik bytecode and extract the individual fields
Instruction DecodeInstruction(const u2* bytecode) {
  u2 inst = bytecode[0];
  Opcode opcode = OpcodeFromBytecode(inst);
  InstructionFormat format = GetFormatFromOpcode(opcode);

  Instruction dec = {};
  dec.opcode = opcode;

  switch (format) {
    case k10x:  // op
      return dec;
    case k12x:  // op vA, vB
      dec.vA = InstA(inst);
      dec.vB = InstB(inst);
      return dec;
    case k11n:  // op vA, #+B
      dec.vA = InstA(inst);
      dec.vB = s4(InstB(inst) << 28) >> 28;  // sign extend 4-bit value
      return dec;
    case k11x:  // op vAA
      dec.vA = InstAA(inst);
      return dec;
    case k10t:                    // op +AA
      dec.vA = s1(InstAA(inst));  // sign-extend 8-bit value
      return dec;
    case k20t:                   // op +AAAA
      dec.vA = s2(bytecode[1]);  // sign-extend 16-bit value
      return dec;
    case k20bc:  // [opt] op AA, thing@BBBB
    case k21c:   // op vAA, thing@BBBB
    case k22x:   // op vAA, vBBBB
      dec.vA = InstAA(inst);
      dec.vB = bytecode[1];
      return dec;
    case k21s:  // op vAA, #+BBBB
    case k21t:  // op vAA, +BBBB
      dec.vA = InstAA(inst);
      dec.vB = s2(bytecode[1]);  // sign-extend 16-bit value
      return dec;
    case k21h:  // op vAA, #+BBBB0000[00000000]
      dec.vA = InstAA(inst);
      // The value should be treated as right-zero-extended, but we don't
      // actually do that here. Among other things, we don't know if it's
      // the top bits of a 32- or 64-bit value.
      dec.vB = bytecode[1];
      return dec;
    case k23x:  // op vAA, vBB, vCC
      dec.vA = InstAA(inst);
      dec.vB = bytecode[1] & 0xff;
      dec.vC = bytecode[1] >> 8;
      return dec;
    case k22b:  // op vAA, vBB, #+CC
      dec.vA = InstAA(inst);
      dec.vB = bytecode[1] & 0xff;
      dec.vC = s1(bytecode[1] >> 8);  // sign-extend 8-bit value
      return dec;
    case k22s:  // op vA, vB, #+CCCC
    case k22t:  // op vA, vB, +CCCC
      dec.vA = InstA(inst);
      dec.vB = InstB(inst);
      dec.vC = s2(bytecode[1]);  // sign-extend 16-bit value
      return dec;
    case k22c:   // op vA, vB, thing@CCCC
    case k22cs:  // [opt] op vA, vB, field offset CCCC
      dec.vA = InstA(inst);
      dec.vB = InstB(inst);
      dec.vC = bytecode[1];
      return dec;
    case k30t:  // op +AAAAAAAA
      dec.vA = FetchU4(bytecode + 1);
      return dec;
    case k31t:  // op vAA, +BBBBBBBB
    case k31c:  // op vAA, string@BBBBBBBB
      dec.vA = InstAA(inst);
      dec.vB = FetchU4(bytecode + 1);
      return dec;
    case k32x:  // op vAAAA, vBBBB
      dec.vA = bytecode[1];
      dec.vB = bytecode[2];
      return dec;
    case k31i:  // op vAA, #+BBBBBBBB
      dec.vA = InstAA(inst);
      dec.vB = FetchU4(bytecode + 1);
      return dec;
    case k35c:               // op {vC, vD, vE, vF, vG}, thing@BBBB
    case k35ms:              // [opt] invoke-virtual+super
    case k35mi: {            // [opt] inline invoke
      dec.vA = InstB(inst);  // This is labeled A in the spec.
      dec.vB = bytecode[1];

      u2 regList = bytecode[2];

      // Copy the argument registers into the arg[] array, and
      // also copy the first argument (if any) into vC. (The
      // Instruction structure doesn't have separate
      // fields for {vD, vE, vF, vG}, so there's no need to make
      // copies of those.) Note that cases 5..2 fall through.
      switch (dec.vA) {
        case 5:
          // A fifth arg is verboten for inline invokes
          SLICER_CHECK(format != k35mi);

          // Per note at the top of this format decoder, the
          // fifth argument comes from the A field in the
          // instruction, but it's labeled G in the spec.
          dec.arg[4] = InstA(inst);
          FALLTHROUGH_INTENDED;
        case 4:
          dec.arg[3] = (regList >> 12) & 0x0f;
          FALLTHROUGH_INTENDED;
        case 3:
          dec.arg[2] = (regList >> 8) & 0x0f;
          FALLTHROUGH_INTENDED;
        case 2:
          dec.arg[1] = (regList >> 4) & 0x0f;
          FALLTHROUGH_INTENDED;
        case 1:
          dec.vC = dec.arg[0] = regList & 0x0f;
          FALLTHROUGH_INTENDED;
        case 0:
          // Valid, but no need to do anything
          return dec;
      }
    }
      SLICER_CHECK(!"Invalid arg count in 35c/35ms/35mi");
    case k3rc:   // op {vCCCC .. v(CCCC+AA-1)}, meth@BBBB
    case k3rms:  // [opt] invoke-virtual+super/range
    case k3rmi:  // [opt] execute-inline/range
      dec.vA = InstAA(inst);
      dec.vB = bytecode[1];
      dec.vC = bytecode[2];
      return dec;
    case k45cc: {
      // AG op BBBB FEDC HHHH
      dec.vA = InstB(inst);  // This is labelled A in the spec.
      dec.vB = bytecode[1];  // vB meth@BBBB

      u2 regList = bytecode[2];
      dec.vC = regList & 0xf;
      dec.arg[0] = (regList >> 4) & 0xf;  // vD
      dec.arg[1] = (regList >> 8) & 0xf;  // vE
      dec.arg[2] = (regList >> 12);       // vF
      dec.arg[3] = InstA(inst);           // vG
      dec.arg[4] = bytecode[3];           // vH proto@HHHH
    }
      return dec;
    case k4rcc:
      // AA op BBBB CCCC HHHH
      dec.vA = InstAA(inst);
      dec.vB = bytecode[1];
      dec.vC = bytecode[2];
      dec.arg[4] = bytecode[3];  // vH proto@HHHH
      return dec;
    case k51l:  // op vAA, #+BBBBBBBBBBBBBBBB
      dec.vA = InstAA(inst);
      dec.vB_wide = FetchU8(bytecode + 1);
      return dec;
  }
  SLICER_FATAL("Can't decode unexpected format 0x%02x (op=0x%02x)", format,
               opcode);
}

}  // namespace dex

```

`slicer/dex_format.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/dex_format.h"
#include "slicer/common.h"

#include <zlib.h>

namespace dex {

// Compute the DEX file checksum for a memory-mapped DEX file
u4 ComputeChecksum(const Header* header) {
  const u1* start = reinterpret_cast<const u1*>(header);

  uLong adler = adler32(0L, Z_NULL, 0);
  const int non_sum = sizeof(header->magic) + sizeof(header->checksum);

  return static_cast<u4>(
      adler32(adler, start + non_sum, header->file_size - non_sum));
}

// Returns the human-readable name for a primitive type
static const char* PrimitiveTypeName(char type_char) {
  switch (type_char) {
    case 'B': return "byte";
    case 'C': return "char";
    case 'D': return "double";
    case 'F': return "float";
    case 'I': return "int";
    case 'J': return "long";
    case 'S': return "short";
    case 'V': return "void";
    case 'Z': return "boolean";
  }
  SLICER_CHECK(!"unexpected type");
  return nullptr;
}

// Converts a type descriptor to human-readable "dotted" form.  For
// example, "Ljava/lang/String;" becomes "java.lang.String", and
// "[I" becomes "int[]".
std::string DescriptorToDecl(const char* descriptor) {
  std::string ss;

  int array_dimensions = 0;
  while (*descriptor == '[') {
    ++array_dimensions;
    ++descriptor;
  }

  if (*descriptor == 'L') {
    for (++descriptor; *descriptor != ';'; ++descriptor) {
      SLICER_CHECK(*descriptor != '\0');
      ss += (*descriptor == '/' ? '.' : *descriptor);
    }
  } else {
    ss += PrimitiveTypeName(*descriptor);
  }

  SLICER_CHECK(descriptor[1] == '\0');

  // add the array brackets
  for (int i = 0; i < array_dimensions; ++i) {
    ss += "[]";
  }

  return ss;
}

// Converts a type descriptor to a single "shorty" char
// (ex. "LFoo;" and "[[I" become 'L', "I" stays 'I')
char DescriptorToShorty(const char* descriptor) {
  // skip array dimensions
  int array_dimensions = 0;
  while (*descriptor == '[') {
    ++array_dimensions;
    ++descriptor;
  }

  char short_descriptor = *descriptor;
  if (short_descriptor == 'L') {
    // skip the full class name
    for(; *descriptor && *descriptor != ';'; ++descriptor) {
    }
    SLICER_CHECK(*descriptor == ';');
  }

  SLICER_CHECK(descriptor[1] == '\0');
  SLICER_CHECK(short_descriptor == 'L' || PrimitiveTypeName(short_descriptor) != nullptr);

  return array_dimensions > 0 ? 'L' : short_descriptor;
}

}  // namespace dex

```

`slicer/dex_ir.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/dex_ir.h"
#include "slicer/chronometer.h"
#include "slicer/dex_utf8.h"
#include "slicer/dex_format.h"

#include <algorithm>
#include <cstdint>
#include <map>
#include <memory>
#include <vector>
#include <functional>
#include <cstdlib>

namespace ir {

// DBJ2a string hash
static uint32_t HashString(const char* cstr) {
  uint32_t hash = 5381;  // DBJ2 magic prime value
  while (*cstr) {
    hash = ((hash << 5) + hash) ^ *cstr++;
  }
  return hash;
}

uint32_t StringsHasher::Hash(const char* string_key) const {
  return HashString(string_key);
}

bool StringsHasher::Compare(const char* string_key, const String* string) const {
  return dex::Utf8Cmp(string_key, string->c_str()) == 0;
}

uint32_t ProtosHasher::Hash(const std::string& proto_key) const {
  return HashString(proto_key.c_str());
}

bool ProtosHasher::Compare(const std::string& proto_key, const Proto* proto) const {
  return proto_key == proto->Signature();
}

MethodKey MethodsHasher::GetKey(const EncodedMethod* method) const {
  MethodKey method_key;
  method_key.class_descriptor = method->decl->parent->descriptor;
  method_key.method_name = method->decl->name;
  method_key.prototype = method->decl->prototype;
  return method_key;
}

uint32_t MethodsHasher::Hash(const MethodKey& method_key) const {
  return static_cast<uint32_t>(std::hash<void*>{}(method_key.class_descriptor) ^
                               std::hash<void*>{}(method_key.method_name) ^
                               std::hash<void*>{}(method_key.prototype));
}

bool MethodsHasher::Compare(const MethodKey& method_key, const EncodedMethod* method) const {
  return method_key.class_descriptor == method->decl->parent->descriptor &&
         method_key.method_name == method->decl->name &&
         method_key.prototype == method->decl->prototype;
}

inline auto Comp(const dex::u4& i, const dex::u4& j) {
  if (i < j) return -1;
  if (j < i) return 1;
  return 0;
}

inline auto operator<=>(const AnnotationElement& a, const AnnotationElement& b) {
  return Comp(a.name->index, b.name->index);
}

inline auto operator<=>(const Annotation& a, const Annotation& b) {
  return Comp(a.type->index, b.type->index);
}

inline auto operator<=>(const FieldAnnotation& a, const FieldAnnotation& b) {
  return Comp(a.field_decl->index, b.field_decl->index);
}

inline auto operator<=>(const MethodAnnotation& a, const MethodAnnotation& b) {
  return Comp(a.method_decl->index, b.method_decl->index);
}

inline auto operator<=>(const ParamAnnotation& a, const ParamAnnotation& b) {
  return Comp(a.method_decl->index, b.method_decl->index);
}

inline auto operator<=>(const ir::Class& a, const ir::Class& b) {
  return Comp(a.index, b.index);
}

inline auto operator<=>(const ir::MethodDecl& a, const ir::MethodDecl& b) {
  return (a.parent->index != b.parent->index)
         ? Comp(a.parent->index, b.parent->index)
         : (a.name->index != b.name->index)
           ? Comp(a.name->index, b.name->index)
           : Comp(a.prototype->index, b.prototype->index);
}

inline auto operator<=>(const ir::String& a, const ir::String& b) {
  return dex::Utf8Cmp(a.c_str(), b.c_str());
}

inline auto operator<=>(const ir::Type& a, const ir::Type& b) {
  return Comp(a.descriptor->index, b.descriptor->index);
}

inline auto operator<=>(const ir::FieldDecl& a, const ir::FieldDecl& b) {
  return (a.parent->index != b.parent->index)
         ? Comp(a.parent->index, b.parent->index)
         : (a.name->index != b.name->index)
           ? Comp(a.name->index, b.name->index)
           : Comp(a.type->index, b.type->index);
}

inline auto operator<=>(const ir::EncodedField& a, const ir::EncodedField& b) {
  return Comp(a.decl->index, b.decl->index);
}

inline auto operator<=>(const ir::EncodedMethod& a, const ir::EncodedMethod& b) {
  return Comp(a.decl->index, b.decl->index);
}

inline auto operator<=>(const ir::Proto& a, const ir::Proto& b) {
  if (a.return_type->index != b.return_type->index) {
    return Comp(a.return_type->index, b.return_type->index);
  }
  std::vector<Type*> empty;
  const auto& aParamTypes = a.param_types ? a.param_types->types : empty;
  const auto& bParamTypes = b.param_types ? b.param_types->types : empty;
  auto less = [](const Type* t1, const Type* t2) { return t1->index < t2->index; };
  if (std::lexicographical_compare(
          aParamTypes.begin(), aParamTypes.end(), bParamTypes.begin(),
          bParamTypes.end(), less)) {
    return -1;
  }
  return 1;
}

// Human-readable type declaration
std::string Type::Decl() const {
  return dex::DescriptorToDecl(descriptor->c_str());
}

Type::Category Type::GetCategory() const {
  switch (*descriptor->c_str()) {
    case 'L':
    case '[':
      return Category::Reference;
    case 'V':
      return Category::Void;
    case 'D':
    case 'J':
      return Category::WideScalar;
    default:
      return Category::Scalar;
  }
}

// Create the corresponding JNI signature:
//  https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/types.html#type_signatures
std::string Proto::Signature() const {
  std::string ss;
  ss += "(";
  if (param_types != nullptr) {
    for (const auto& type : param_types->types) {
      ss += type->descriptor->c_str();
    }
  }
  ss += ")";
  ss += return_type->descriptor->c_str();
  return ss;
}


template<typename RandomIt>
inline void QuickSortPointer(RandomIt first, RandomIt last) {
  using ValueType = typename std::iterator_traits<RandomIt>::value_type;
  if (first == last) return;
  std::qsort(&*first, last - first, sizeof(ValueType),
             +[](const void* a, const void* b) -> int {
                 auto i = static_cast<const ValueType*>(a);
                 auto j = static_cast<const ValueType*>(b);
                 return **i <=> **j;
             }
  );
}

// Helper for IR normalization
// (it sorts items and update the numeric idexes to match)
template <class T>
static void IndexItems(std::vector<T>& items) {
  QuickSortPointer(items.begin(), items.end());
  for (size_t i = 0; i < items.size(); ++i) {
    items[i]->index = i;
  }
}

// Helper for IR normalization (DFS for topological sort)
//
// NOTE: this recursive version is clean and simple and we know
//  that the max depth is bounded (exactly 1 for JVMTI and a small
//  max for general case - the largest .dex file in AOSP has 5000 classes
//  total)
//
void DexFile::TopSortClassIndex(Class* irClass, dex::u4* nextIndex) {
  if (irClass->index == dex::u4(-1)) {
    if (irClass->super_class && irClass->super_class->class_def) {
      TopSortClassIndex(irClass->super_class->class_def, nextIndex);
    }

    if (irClass->interfaces) {
      for (Type* interfaceType : irClass->interfaces->types) {
        if (interfaceType->class_def) {
          TopSortClassIndex(interfaceType->class_def, nextIndex);
        }
      }
    }

    SLICER_CHECK(*nextIndex < classes.size());
    irClass->index = (*nextIndex)++;
  }
}

// Helper for IR normalization
// (topological sort the classes)
void DexFile::SortClassIndexes() {
  for (auto& irClass : classes) {
    irClass->index = dex::u4(-1);
  }

  dex::u4 nextIndex = 0;
  for (auto& irClass : classes) {
    TopSortClassIndex(irClass.get(), &nextIndex);
  }
}

// Helper for NormalizeClass()
static void SortEncodedFields(std::vector<EncodedField*>* fields) {
  QuickSortPointer(fields->begin(), fields->end());
}

// Helper for NormalizeClass()
static void SortEncodedMethods(std::vector<EncodedMethod*>* methods) {
  QuickSortPointer(methods->begin(), methods->end());
}

// Helper for IR normalization
// (sort the field & method arrays)
static void NormalizeClass(Class* irClass) {
  SortEncodedFields(&irClass->static_fields);
  SortEncodedFields(&irClass->instance_fields);
  SortEncodedMethods(&irClass->direct_methods);
  SortEncodedMethods(&irClass->virtual_methods);
}

// Prepare the IR for generating a .dex image
// (the .dex format requires a specific sort order for some of the arrays, etc...)
//
// TODO: not a great solution - move this logic to the writer!
//
// TODO: the comparison predicate can be better expressed by using std::tie()
//  Ex. FieldDecl has a method comp() returning tie(parent->index, name->index, type->index)
//
void DexFile::Normalize() {
  // sort build the .dex indexes
  IndexItems(strings);

  IndexItems(types);

  IndexItems(protos);

  IndexItems(fields);

  IndexItems(methods);

  // reverse topological sort
  //
  // the classes must be ordered such that a given class's superclass and
  // implemented interfaces appear in the list earlier than the referring
  // class
  //
  // CONSIDER: for the BCI-only scenario we can avoid this
  //
  SortClassIndexes();

  IndexItems(classes);

  // normalize class data
  for (const auto& irClass : classes) {
    NormalizeClass(irClass.get());
  }

  // normalize annotations
  for (const auto& irAnnotation : annotations) {
    // elements must be sorted in increasing order by string_id index
    auto& elements = irAnnotation->elements;
    QuickSortPointer(elements.begin(), elements.end());
  }

  // normalize "annotation_set_item"
  for (const auto& irAnnotationSet : annotation_sets) {
    // The elements must be sorted in increasing order, by type_idx
    auto& annotations = irAnnotationSet->annotations;
    QuickSortPointer(annotations.begin(), annotations.end());
  }

  // normalize "annotations_directory_item"
  for (const auto& irAnnotationDirectory : annotations_directories) {
    // field_annotations: The elements of the list must be
    // sorted in increasing order, by field_idx
    auto& field_annotations = irAnnotationDirectory->field_annotations;
    QuickSortPointer(field_annotations.begin(), field_annotations.end());

    // method_annotations: The elements of the list must be
    // sorted in increasing order, by method_idx
    auto& method_annotations = irAnnotationDirectory->method_annotations;
    QuickSortPointer(method_annotations.begin(), method_annotations.end());

    // parameter_annotations: The elements of the list must be
    // sorted in increasing order, by method_idx
    auto& param_annotations = irAnnotationDirectory->param_annotations;
    QuickSortPointer(param_annotations.begin(), param_annotations.end());
  }
}

} // namespace ir

```

`slicer/dex_utf8.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/dex_format.h"

namespace dex {

// Retrieve the next UTF-16 character from a UTF-8 string.
// Advances "*pUtf8Ptr" to the start of the next character.
//
// NOTE: If a string is corrupted by dropping a '\0' in the middle
// of a 3-byte sequence, you can end up overrunning the buffer with
// reads (and possibly with the writes if the length was computed and
// cached before the damage). For performance reasons, this function
// assumes that the string being parsed is known to be valid (e.g., by
// already being verified).
static u2 GetUtf16FromUtf8(const char** pUtf8Ptr) {
  u4 one = *(*pUtf8Ptr)++;
  if ((one & 0x80) != 0) {
    // two- or three-byte encoding
    u4 two = *(*pUtf8Ptr)++;
    if ((one & 0x20) != 0) {
      // three-byte encoding
      u4 three = *(*pUtf8Ptr)++;
      return ((one & 0x0f) << 12) | ((two & 0x3f) << 6) | (three & 0x3f);
    } else {
      // two-byte encoding
      return ((one & 0x1f) << 6) | (two & 0x3f);
    }
  } else {
    // one-byte encoding
    return one;
  }
}

int Utf8Cmp(const char* s1, const char* s2) {
  for (;;) {
    if (*s1 == '\0') {
      if (*s2 == '\0') {
        return 0;
      }
      return -1;
    } else if (*s2 == '\0') {
      return 1;
    }

    int utf1 = GetUtf16FromUtf8(&s1);
    int utf2 = GetUtf16FromUtf8(&s2);
    int diff = utf1 - utf2;

    if (diff != 0) {
      return diff;
    }
  }
}

}  // namespace dex

```

`slicer/reader.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/reader.h"
#include "slicer/dex_bytecode.h"
#include "slicer/chronometer.h"
#include "slicer/dex_leb128.h"

#include <assert.h>
#include <string.h>
#include <type_traits>
#include <cstdlib>

namespace dex {

Reader::Reader(const dex::u1* image, size_t size, const dex::u1* data, size_t data_size) : image_(image), size_(size), data_(data ? data : image), data_size_(data ? data_size : size) {
  // init the header reference
  header_ = reinterpret_cast<const dex::Header*>(image_);
  if (size_ == 0) {
      data_size_ = size_ = header_->file_size;
  }
  ValidateHeader();

  // start with an "empty" .dex IR
  dex_ir_ = std::make_shared<ir::DexFile>();
  dex_ir_->magic = slicer::MemView(header_, sizeof(dex::Header::magic));
}

slicer::ArrayView<const dex::ClassDef> Reader::ClassDefs() const {
  return section<dex::ClassDef>(header_->class_defs_off,
                                header_->class_defs_size);
}

slicer::ArrayView<const dex::StringId> Reader::StringIds() const {
  return section<dex::StringId>(header_->string_ids_off,
                                header_->string_ids_size);
}

slicer::ArrayView<const dex::TypeId> Reader::TypeIds() const {
  return section<dex::TypeId>(header_->type_ids_off,
                              header_->type_ids_size);
}

slicer::ArrayView<const dex::FieldId> Reader::FieldIds() const {
  return section<dex::FieldId>(header_->field_ids_off,
                               header_->field_ids_size);
}

slicer::ArrayView<const dex::MethodId> Reader::MethodIds() const {
  return section<dex::MethodId>(header_->method_ids_off,
                                header_->method_ids_size);
}

slicer::ArrayView<const dex::ProtoId> Reader::ProtoIds() const {
  return section<dex::ProtoId>(header_->proto_ids_off,
                               header_->proto_ids_size);
}

const dex::MapList* Reader::DexMapList() const {
  return dataPtr<dex::MapList>(header_->map_off);
}

const char* Reader::GetStringMUTF8(dex::u4 index) const {
  if (index == dex::kNoIndex) {
    return "<no_string>";
  }
  const dex::u1* strData = GetStringData(index);
  dex::ReadULeb128(&strData);
  return reinterpret_cast<const char*>(strData);
}

void Reader::CreateFullIr() {
  size_t classCount = ClassDefs().size();
  for (size_t i = 0; i < classCount; ++i) {
    CreateClassIr(i);
  }
}

void Reader::CreateClassIr(dex::u4 index) {
  [[maybe_unused]] auto ir_class = GetClass(index);
  SLICER_CHECK(ir_class != nullptr);
}

// Returns the index of the class with the specified
// descriptor, or kNoIndex if not found
dex::u4 Reader::FindClassIndex(const char* class_descriptor) const {
  auto classes = ClassDefs();
  auto types = TypeIds();
  for (dex::u4 i = 0; i < classes.size(); ++i) {
    auto typeId = types[classes[i].class_idx];
    const char* descriptor = GetStringMUTF8(typeId.descriptor_idx);
    if (strcmp(class_descriptor, descriptor) == 0) {
      return i;
    }
  }
  return dex::kNoIndex;
}

// map a .dex index to corresponding .dex IR node
//
// NOTES:
//  1. the mapping between an index and the indexed
//     .dex IR nodes is 1:1
//  2. we do a single index lookup for both existing
//     nodes as well as new nodes
//  3. placeholder is an invalid, but non-null pointer value
//     used to check that the mapping lookup/update is atomic
//  4. there should be no recursion with the same index
//     (we use the placeholder value to guard against this too)
//
ir::Class* Reader::GetClass(dex::u4 index) {
  SLICER_CHECK(index != dex::kNoIndex);
  auto& p = dex_ir_->classes_map[index];
  auto placeholder = reinterpret_cast<ir::Class*>(1);
  if (p == nullptr) {
    p = placeholder;
    auto newClass = ParseClass(index);
    SLICER_CHECK(p == placeholder);
    p = newClass;
    dex_ir_->classes_indexes.MarkUsedIndex(index);
  }
  SLICER_CHECK(p != placeholder);
  return p;
}

// map a .dex index to corresponding .dex IR node
// (see the Reader::GetClass() comments)
ir::Type* Reader::GetType(dex::u4 index) {
  SLICER_CHECK(index != dex::kNoIndex);
  auto& p = dex_ir_->types_map[index];
  auto placeholder = reinterpret_cast<ir::Type*>(1);
  if (p == nullptr) {
    p = placeholder;
    auto newType = ParseType(index);
    SLICER_CHECK(p == placeholder);
    p = newType;
    dex_ir_->types_indexes.MarkUsedIndex(index);
  }
  SLICER_CHECK(p != placeholder);
  return p;
}

// map a .dex index to corresponding .dex IR node
// (see the Reader::GetClass() comments)
ir::FieldDecl* Reader::GetFieldDecl(dex::u4 index) {
  SLICER_CHECK(index != dex::kNoIndex);
  auto& p = dex_ir_->fields_map[index];
  auto placeholder = reinterpret_cast<ir::FieldDecl*>(1);
  if (p == nullptr) {
    p = placeholder;
    auto newField = ParseFieldDecl(index);
    SLICER_CHECK(p == placeholder);
    p = newField;
    dex_ir_->fields_indexes.MarkUsedIndex(index);
  }
  SLICER_CHECK(p != placeholder);
  return p;
}

// map a .dex index to corresponding .dex IR node
// (see the Reader::GetClass() comments)
ir::MethodDecl* Reader::GetMethodDecl(dex::u4 index) {
  SLICER_CHECK(index != dex::kNoIndex);
  auto& p = dex_ir_->methods_map[index];
  auto placeholder = reinterpret_cast<ir::MethodDecl*>(1);
  if (p == nullptr) {
    p = placeholder;
    auto newMethod = ParseMethodDecl(index);
    SLICER_CHECK(p == placeholder);
    p = newMethod;
    dex_ir_->methods_indexes.MarkUsedIndex(index);
  }
  SLICER_CHECK(p != placeholder);
  return p;
}

// map a .dex index to corresponding .dex IR node
// (see the Reader::GetClass() comments)
ir::Proto* Reader::GetProto(dex::u4 index) {
  SLICER_CHECK(index != dex::kNoIndex);
  auto& p = dex_ir_->protos_map[index];
  auto placeholder = reinterpret_cast<ir::Proto*>(1);
  if (p == nullptr) {
    p = placeholder;
    auto newProto = ParseProto(index);
    SLICER_CHECK(p == placeholder);
    p = newProto;
    dex_ir_->protos_indexes.MarkUsedIndex(index);
  }
  SLICER_CHECK(p != placeholder);
  return p;
}

// map a .dex index to corresponding .dex IR node
// (see the Reader::GetClass() comments)
ir::String* Reader::GetString(dex::u4 index) {
  SLICER_CHECK(index != dex::kNoIndex);
  auto& p = dex_ir_->strings_map[index];
  auto placeholder = reinterpret_cast<ir::String*>(1);
  if (p == nullptr) {
    p = placeholder;
    auto newString = ParseString(index);
    SLICER_CHECK(p == placeholder);
    p = newString;
    dex_ir_->strings_indexes.MarkUsedIndex(index);
  }
  SLICER_CHECK(p != placeholder);
  return p;
}

ir::Class* Reader::ParseClass(dex::u4 index) {
  auto& dex_class_def = ClassDefs()[index];
  auto ir_class = dex_ir_->Alloc<ir::Class>();

  ir_class->type = GetType(dex_class_def.class_idx);
  assert(ir_class->type->class_def == nullptr);
  ir_class->type->class_def = ir_class;

  ir_class->access_flags = dex_class_def.access_flags;
  ir_class->interfaces = ExtractTypeList(dex_class_def.interfaces_off);

  if (dex_class_def.superclass_idx != dex::kNoIndex) {
    ir_class->super_class = GetType(dex_class_def.superclass_idx);
  }

  if (dex_class_def.source_file_idx != dex::kNoIndex) {
    ir_class->source_file = GetString(dex_class_def.source_file_idx);
  }

  if (dex_class_def.class_data_off != 0) {
    const dex::u1* class_data = dataPtr<dex::u1>(dex_class_def.class_data_off);

    dex::u4 static_fields_count = dex::ReadULeb128(&class_data);
    dex::u4 instance_fields_count = dex::ReadULeb128(&class_data);
    dex::u4 direct_methods_count = dex::ReadULeb128(&class_data);
    dex::u4 virtual_methods_count = dex::ReadULeb128(&class_data);

    dex::u4 base_index = dex::kNoIndex;
    for (dex::u4 i = 0; i < static_fields_count; ++i) {
      auto field = ParseEncodedField(&class_data, &base_index);
      ir_class->static_fields.push_back(field);
    }

    base_index = dex::kNoIndex;
    for (dex::u4 i = 0; i < instance_fields_count; ++i) {
      auto field = ParseEncodedField(&class_data, &base_index);
      ir_class->instance_fields.push_back(field);
    }

    base_index = dex::kNoIndex;
    for (dex::u4 i = 0; i < direct_methods_count; ++i) {
      auto method = ParseEncodedMethod(&class_data, &base_index);
      ir_class->direct_methods.push_back(method);
    }

    base_index = dex::kNoIndex;
    for (dex::u4 i = 0; i < virtual_methods_count; ++i) {
      auto method = ParseEncodedMethod(&class_data, &base_index);
      ir_class->virtual_methods.push_back(method);
    }
  }

  ir_class->static_init = ExtractEncodedArray(dex_class_def.static_values_off);
  ir_class->annotations = ExtractAnnotations(dex_class_def.annotations_off);
  ir_class->orig_index = index;

  return ir_class;
}

ir::AnnotationsDirectory* Reader::ExtractAnnotations(dex::u4 offset) {
  if (offset == 0) {
    return nullptr;
  }

  SLICER_CHECK(offset % 4 == 0);

  // first check if we already extracted the same "annotations_directory_item"
  auto& ir_annotations = annotations_directories_[offset];
  if (ir_annotations == nullptr) {
    ir_annotations = dex_ir_->Alloc<ir::AnnotationsDirectory>();

    auto dex_annotations = dataPtr<dex::AnnotationsDirectoryItem>(offset);

    ir_annotations->class_annotation =
        ExtractAnnotationSet(dex_annotations->class_annotations_off);

    const dex::u1* ptr = reinterpret_cast<const dex::u1*>(dex_annotations + 1);

    for (dex::u4 i = 0; i < dex_annotations->fields_size; ++i) {
      ir_annotations->field_annotations.push_back(ParseFieldAnnotation(&ptr));
    }

    for (dex::u4 i = 0; i < dex_annotations->methods_size; ++i) {
      ir_annotations->method_annotations.push_back(ParseMethodAnnotation(&ptr));
    }

    for (dex::u4 i = 0; i < dex_annotations->parameters_size; ++i) {
      ir_annotations->param_annotations.push_back(ParseParamAnnotation(&ptr));
    }
  }
  return ir_annotations;
}

ir::Annotation* Reader::ExtractAnnotationItem(dex::u4 offset) {
  SLICER_CHECK(offset != 0);

  // first check if we already extracted the same "annotation_item"
  auto& ir_annotation = annotations_[offset];
  if (ir_annotation == nullptr) {
    auto dexAnnotationItem = dataPtr<dex::AnnotationItem>(offset);
    const dex::u1* ptr = dexAnnotationItem->annotation;
    ir_annotation = ParseAnnotation(&ptr);
    ir_annotation->visibility = dexAnnotationItem->visibility;
  }
  return ir_annotation;
}

ir::AnnotationSet* Reader::ExtractAnnotationSet(dex::u4 offset) {
  if (offset == 0) {
    return nullptr;
  }

  SLICER_CHECK(offset % 4 == 0);

  // first check if we already extracted the same "annotation_set_item"
  auto& ir_annotation_set = annotation_sets_[offset];
  if (ir_annotation_set == nullptr) {
    ir_annotation_set = dex_ir_->Alloc<ir::AnnotationSet>();

    auto dex_annotation_set = dataPtr<dex::AnnotationSetItem>(offset);
    for (dex::u4 i = 0; i < dex_annotation_set->size; ++i) {
      auto ir_annotation = ExtractAnnotationItem(dex_annotation_set->entries[i]);
      assert(ir_annotation != nullptr);
      ir_annotation_set->annotations.push_back(ir_annotation);
    }
  }
  return ir_annotation_set;
}

ir::AnnotationSetRefList* Reader::ExtractAnnotationSetRefList(dex::u4 offset) {
  SLICER_CHECK(offset % 4 == 0);

  auto dex_annotation_set_ref_list = dataPtr<dex::AnnotationSetRefList>(offset);
  auto ir_annotation_set_ref_list = dex_ir_->Alloc<ir::AnnotationSetRefList>();

  for (dex::u4 i = 0; i < dex_annotation_set_ref_list->size; ++i) {
    dex::u4 entry_offset = dex_annotation_set_ref_list->list[i].annotations_off;
    if (entry_offset != 0) {
      auto ir_annotation_set = ExtractAnnotationSet(entry_offset);
      SLICER_CHECK(ir_annotation_set != nullptr);
      ir_annotation_set_ref_list->annotations.push_back(ir_annotation_set);
    }
  }

  return ir_annotation_set_ref_list;
}

ir::FieldAnnotation* Reader::ParseFieldAnnotation(const dex::u1** pptr) {
  auto dex_field_annotation = reinterpret_cast<const dex::FieldAnnotationsItem*>(*pptr);
  auto ir_field_annotation = dex_ir_->Alloc<ir::FieldAnnotation>();

  ir_field_annotation->field_decl = GetFieldDecl(dex_field_annotation->field_idx);

  ir_field_annotation->annotations =
      ExtractAnnotationSet(dex_field_annotation->annotations_off);
  SLICER_CHECK(ir_field_annotation->annotations != nullptr);

  *pptr += sizeof(dex::FieldAnnotationsItem);
  return ir_field_annotation;
}

ir::MethodAnnotation* Reader::ParseMethodAnnotation(const dex::u1** pptr) {
  auto dex_method_annotation =
      reinterpret_cast<const dex::MethodAnnotationsItem*>(*pptr);
  auto ir_method_annotation = dex_ir_->Alloc<ir::MethodAnnotation>();

  ir_method_annotation->method_decl = GetMethodDecl(dex_method_annotation->method_idx);

  ir_method_annotation->annotations =
      ExtractAnnotationSet(dex_method_annotation->annotations_off);
  SLICER_CHECK(ir_method_annotation->annotations != nullptr);

  *pptr += sizeof(dex::MethodAnnotationsItem);
  return ir_method_annotation;
}

ir::ParamAnnotation* Reader::ParseParamAnnotation(const dex::u1** pptr) {
  auto dex_param_annotation =
      reinterpret_cast<const dex::ParameterAnnotationsItem*>(*pptr);
  auto ir_param_annotation = dex_ir_->Alloc<ir::ParamAnnotation>();

  ir_param_annotation->method_decl = GetMethodDecl(dex_param_annotation->method_idx);

  ir_param_annotation->annotations =
      ExtractAnnotationSetRefList(dex_param_annotation->annotations_off);
  SLICER_CHECK(ir_param_annotation->annotations != nullptr);

  *pptr += sizeof(dex::ParameterAnnotationsItem);
  return ir_param_annotation;
}

ir::EncodedField* Reader::ParseEncodedField(const dex::u1** pptr, dex::u4* base_index) {
  auto ir_encoded_field = dex_ir_->Alloc<ir::EncodedField>();

  auto field_index = dex::ReadULeb128(pptr);
  SLICER_CHECK(field_index != dex::kNoIndex);
  if (*base_index != dex::kNoIndex) {
    SLICER_CHECK(field_index != 0);
    field_index += *base_index;
  }
  *base_index = field_index;

  ir_encoded_field->decl = GetFieldDecl(field_index);
  ir_encoded_field->access_flags = dex::ReadULeb128(pptr);

  return ir_encoded_field;
}

// Parse an encoded variable-length integer value
// (sign-extend signed types, zero-extend unsigned types)
template <class T>
static T ParseIntValue(const dex::u1** pptr, size_t size) {
  static_assert(std::is_integral<T>::value, "must be an integral type");

  SLICER_CHECK(size > 0);
  SLICER_CHECK(size <= sizeof(T));

  T value = 0;
  for (size_t i = 0; i < size; ++i) {
    value |= T(*(*pptr)++) << (i * 8);
  }

  // sign-extend?
  if (std::is_signed<T>::value) {
    size_t shift = (sizeof(T) - size) * 8;
    value = T(value << shift) >> shift;
  }

  return value;
}

// Parse an encoded variable-length floating point value
// (zero-extend to the right)
template <class T>
static T ParseFloatValue(const dex::u1** pptr, size_t size) {
  SLICER_CHECK(size > 0);
  SLICER_CHECK(size <= sizeof(T));

  T value = 0;
  int start_byte = sizeof(T) - size;
  for (dex::u1* p = reinterpret_cast<dex::u1*>(&value) + start_byte; size > 0;
       --size) {
    *p++ = *(*pptr)++;
  }
  return value;
}

ir::EncodedValue* Reader::ParseEncodedValue(const dex::u1** pptr) {
  auto ir_encoded_value = dex_ir_->Alloc<ir::EncodedValue>();

  SLICER_EXTRA(auto base_ptr = *pptr);

  dex::u1 header = *(*pptr)++;
  dex::u1 type = header & dex::kEncodedValueTypeMask;
  dex::u1 arg = header >> dex::kEncodedValueArgShift;

  ir_encoded_value->type = type;

  switch (type) {
    case dex::kEncodedByte:
      ir_encoded_value->u.byte_value = ParseIntValue<int8_t>(pptr, arg + 1);
      break;

    case dex::kEncodedShort:
      ir_encoded_value->u.short_value = ParseIntValue<int16_t>(pptr, arg + 1);
      break;

    case dex::kEncodedChar:
      ir_encoded_value->u.char_value = ParseIntValue<uint16_t>(pptr, arg + 1);
      break;

    case dex::kEncodedInt:
      ir_encoded_value->u.int_value = ParseIntValue<int32_t>(pptr, arg + 1);
      break;

    case dex::kEncodedLong:
      ir_encoded_value->u.long_value = ParseIntValue<int64_t>(pptr, arg + 1);
      break;

    case dex::kEncodedFloat:
      ir_encoded_value->u.float_value = ParseFloatValue<float>(pptr, arg + 1);
      break;

    case dex::kEncodedDouble:
      ir_encoded_value->u.double_value = ParseFloatValue<double>(pptr, arg + 1);
      break;

    case dex::kEncodedString: {
      dex::u4 index = ParseIntValue<dex::u4>(pptr, arg + 1);
      ir_encoded_value->u.string_value = GetString(index);
    } break;

    case dex::kEncodedType: {
      dex::u4 index = ParseIntValue<dex::u4>(pptr, arg + 1);
      ir_encoded_value->u.type_value = GetType(index);
    } break;

    case dex::kEncodedField: {
      dex::u4 index = ParseIntValue<dex::u4>(pptr, arg + 1);
      ir_encoded_value->u.field_value = GetFieldDecl(index);
    } break;

    case dex::kEncodedMethod: {
      dex::u4 index = ParseIntValue<dex::u4>(pptr, arg + 1);
      ir_encoded_value->u.method_value = GetMethodDecl(index);
    } break;

    case dex::kEncodedEnum: {
      dex::u4 index = ParseIntValue<dex::u4>(pptr, arg + 1);
      ir_encoded_value->u.enum_value = GetFieldDecl(index);
    } break;

    case dex::kEncodedArray:
      SLICER_CHECK(arg == 0);
      ir_encoded_value->u.array_value = ParseEncodedArray(pptr);
      break;

    case dex::kEncodedAnnotation:
      SLICER_CHECK(arg == 0);
      ir_encoded_value->u.annotation_value = ParseAnnotation(pptr);
      break;

    case dex::kEncodedNull:
      SLICER_CHECK(arg == 0);
      break;

    case dex::kEncodedBoolean:
      SLICER_CHECK(arg < 2);
      ir_encoded_value->u.bool_value = (arg == 1);
      break;

    default:
      SLICER_CHECK(!"unexpected value type");
  }

  SLICER_EXTRA(ir_encoded_value->original = slicer::MemView(base_ptr, *pptr - base_ptr));

  return ir_encoded_value;
}

ir::Annotation* Reader::ParseAnnotation(const dex::u1** pptr) {
  auto ir_annotation = dex_ir_->Alloc<ir::Annotation>();

  dex::u4 type_index = dex::ReadULeb128(pptr);
  dex::u4 elements_count = dex::ReadULeb128(pptr);

  ir_annotation->type = GetType(type_index);
  ir_annotation->visibility = dex::kVisibilityEncoded;

  for (dex::u4 i = 0; i < elements_count; ++i) {
    auto ir_element = dex_ir_->Alloc<ir::AnnotationElement>();

    ir_element->name = GetString(dex::ReadULeb128(pptr));
    ir_element->value = ParseEncodedValue(pptr);

    ir_annotation->elements.push_back(ir_element);
  }

  return ir_annotation;
}

ir::EncodedArray* Reader::ParseEncodedArray(const dex::u1** pptr) {
  auto ir_encoded_array = dex_ir_->Alloc<ir::EncodedArray>();

  dex::u4 count = dex::ReadULeb128(pptr);
  for (dex::u4 i = 0; i < count; ++i) {
    ir_encoded_array->values.push_back(ParseEncodedValue(pptr));
  }

  return ir_encoded_array;
}

ir::EncodedArray* Reader::ExtractEncodedArray(dex::u4 offset) {
  if (offset == 0) {
    return nullptr;
  }

  // first check if we already extracted the same "annotation_item"
  auto& ir_encoded_array = encoded_arrays_[offset];
  if (ir_encoded_array == nullptr) {
    auto ptr = dataPtr<dex::u1>(offset);
    ir_encoded_array = ParseEncodedArray(&ptr);
  }
  return ir_encoded_array;
}

ir::DebugInfo* Reader::ExtractDebugInfo(dex::u4 offset) {
  if (offset == 0) {
    return nullptr;
  }

  auto ir_debug_info = dex_ir_->Alloc<ir::DebugInfo>();
  const dex::u1* ptr = dataPtr<dex::u1>(offset);

  ir_debug_info->line_start = dex::ReadULeb128(&ptr);

  // TODO: implicit this param for non-static methods?
  dex::u4 param_count = dex::ReadULeb128(&ptr);
  for (dex::u4 i = 0; i < param_count; ++i) {
    dex::u4 name_index = dex::ReadULeb128(&ptr) - 1;
    auto ir_string =
        (name_index == dex::kNoIndex) ? nullptr : GetString(name_index);
    ir_debug_info->param_names.push_back(ir_string);
  }

  // parse the debug info opcodes and note the
  // references to strings and types (to make sure the IR
  // is the full closure of all referenced items)
  //
  // TODO: design a generic debug info iterator?
  //
  auto base_ptr = ptr;
  dex::u1 opcode = 0;
  while ((opcode = *ptr++) != dex::DBG_END_SEQUENCE) {
    switch (opcode) {
      case dex::DBG_ADVANCE_PC:
        // addr_diff
        dex::ReadULeb128(&ptr);
        break;

      case dex::DBG_ADVANCE_LINE:
        // line_diff
        dex::ReadSLeb128(&ptr);
        break;

      case dex::DBG_START_LOCAL: {
        // register_num
        dex::ReadULeb128(&ptr);

        dex::u4 name_index = dex::ReadULeb128(&ptr) - 1;
        if (name_index != dex::kNoIndex) {
          GetString(name_index);
        }

        dex::u4 type_index = dex::ReadULeb128(&ptr) - 1;
        if (type_index != dex::kNoIndex) {
          GetType(type_index);
        }
      } break;

      case dex::DBG_START_LOCAL_EXTENDED: {
        // register_num
        dex::ReadULeb128(&ptr);

        dex::u4 name_index = dex::ReadULeb128(&ptr) - 1;
        if (name_index != dex::kNoIndex) {
          GetString(name_index);
        }

        dex::u4 type_index = dex::ReadULeb128(&ptr) - 1;
        if (type_index != dex::kNoIndex) {
          GetType(type_index);
        }

        dex::u4 sig_index = dex::ReadULeb128(&ptr) - 1;
        if (sig_index != dex::kNoIndex) {
          GetString(sig_index);
        }
      } break;

      case dex::DBG_END_LOCAL:
      case dex::DBG_RESTART_LOCAL:
        // register_num
        dex::ReadULeb128(&ptr);
        break;

      case dex::DBG_SET_FILE: {
        dex::u4 name_index = dex::ReadULeb128(&ptr) - 1;
        if (name_index != dex::kNoIndex) {
          GetString(name_index);
        }
      } break;
    }
  }

  ir_debug_info->data = slicer::MemView(base_ptr, ptr - base_ptr);

  return ir_debug_info;
}

ir::Code* Reader::ExtractCode(dex::u4 offset) {
  if (offset == 0) {
    return nullptr;
  }

  SLICER_CHECK(offset % 4 == 0);

  auto dex_code = dataPtr<dex::Code>(offset);
  auto ir_code = dex_ir_->Alloc<ir::Code>();

  ir_code->registers = dex_code->registers_size;
  ir_code->ins_count = dex_code->ins_size;
  ir_code->outs_count = dex_code->outs_size;

  // instructions array
  ir_code->instructions =
      slicer::ArrayView<const dex::u2>(dex_code->insns, dex_code->insns_size);

  // parse the instructions to discover references to other
  // IR nodes (see debug info stream parsing too)
  ParseInstructions(ir_code->instructions);

  // try blocks & handlers
  //
  // TODO: a generic try/catch blocks iterator?
  //
  if (dex_code->tries_size != 0) {
    dex::u4 aligned_count = (dex_code->insns_size + 1) / 2 * 2;
    auto tries =
        reinterpret_cast<const dex::TryBlock*>(dex_code->insns + aligned_count);
    auto handlers_list =
        reinterpret_cast<const dex::u1*>(tries + dex_code->tries_size);

    ir_code->try_blocks =
        slicer::ArrayView<const dex::TryBlock>(tries, dex_code->tries_size);

    // parse the handlers list (and discover embedded references)
    auto ptr = handlers_list;

    dex::u4 handlers_count = dex::ReadULeb128(&ptr);
    SLICER_WEAK_CHECK(handlers_count <= dex_code->tries_size);

    for (dex::u4 handler_index = 0; handler_index < handlers_count; ++handler_index) {
      int catch_count = dex::ReadSLeb128(&ptr);

      for (int catch_index = 0; catch_index < std::abs(catch_count); ++catch_index) {
        dex::u4 type_index = dex::ReadULeb128(&ptr);
        GetType(type_index);

        // address
        dex::ReadULeb128(&ptr);
      }

      if (catch_count < 1) {
        // catch_all_addr
        dex::ReadULeb128(&ptr);
      }
    }

    ir_code->catch_handlers = slicer::MemView(handlers_list, ptr - handlers_list);
  }

  ir_code->debug_info = ExtractDebugInfo(dex_code->debug_info_off);

  return ir_code;
}

ir::EncodedMethod* Reader::ParseEncodedMethod(const dex::u1** pptr, dex::u4* base_index) {
  auto ir_encoded_method = dex_ir_->Alloc<ir::EncodedMethod>();

  auto method_index = dex::ReadULeb128(pptr);
  SLICER_CHECK(method_index != dex::kNoIndex);
  if (*base_index != dex::kNoIndex) {
    SLICER_CHECK(method_index != 0);
    method_index += *base_index;
  }
  *base_index = method_index;

  ir_encoded_method->decl = GetMethodDecl(method_index);
  ir_encoded_method->access_flags = dex::ReadULeb128(pptr);

  dex::u4 code_offset = dex::ReadULeb128(pptr);
  ir_encoded_method->code = ExtractCode(code_offset);

  // update the methods lookup table
  dex_ir_->methods_lookup.Insert(ir_encoded_method);

  return ir_encoded_method;
}

ir::Type* Reader::ParseType(dex::u4 index) {
  auto& dex_type = TypeIds()[index];
  auto ir_type = dex_ir_->Alloc<ir::Type>();

  ir_type->descriptor = GetString(dex_type.descriptor_idx);
  ir_type->orig_index = index;

  return ir_type;
}

ir::FieldDecl* Reader::ParseFieldDecl(dex::u4 index) {
  auto& dex_field = FieldIds()[index];
  auto ir_field = dex_ir_->Alloc<ir::FieldDecl>();

  ir_field->name = GetString(dex_field.name_idx);
  ir_field->type = GetType(dex_field.type_idx);
  ir_field->parent = GetType(dex_field.class_idx);
  ir_field->orig_index = index;

  return ir_field;
}

ir::MethodDecl* Reader::ParseMethodDecl(dex::u4 index) {
  auto& dex_method = MethodIds()[index];
  auto ir_method = dex_ir_->Alloc<ir::MethodDecl>();

  ir_method->name = GetString(dex_method.name_idx);
  ir_method->prototype = GetProto(dex_method.proto_idx);
  ir_method->parent = GetType(dex_method.class_idx);
  ir_method->orig_index = index;

  return ir_method;
}

ir::TypeList* Reader::ExtractTypeList(dex::u4 offset) {
  if (offset == 0) {
    return nullptr;
  }

  // first check to see if we already extracted the same "type_list"
  auto& ir_type_list = type_lists_[offset];
  if (ir_type_list == nullptr) {
    ir_type_list = dex_ir_->Alloc<ir::TypeList>();

    auto dex_type_list = dataPtr<dex::TypeList>(offset);
    SLICER_WEAK_CHECK(dex_type_list->size > 0);

    for (dex::u4 i = 0; i < dex_type_list->size; ++i) {
      ir_type_list->types.push_back(GetType(dex_type_list->list[i].type_idx));
    }
  }

  return ir_type_list;
}

ir::Proto* Reader::ParseProto(dex::u4 index) {
  auto& dex_proto = ProtoIds()[index];
  auto ir_proto = dex_ir_->Alloc<ir::Proto>();

  ir_proto->shorty = GetString(dex_proto.shorty_idx);
  ir_proto->return_type = GetType(dex_proto.return_type_idx);
  ir_proto->param_types = ExtractTypeList(dex_proto.parameters_off);
  ir_proto->orig_index = index;

  // update the prototypes lookup table
  dex_ir_->prototypes_lookup.Insert(ir_proto);

  return ir_proto;
}

ir::String* Reader::ParseString(dex::u4 index) {
  auto ir_string = dex_ir_->Alloc<ir::String>();

  auto data = GetStringData(index);
  auto cstr = data;
  dex::ReadULeb128(&cstr);
  size_t size = (cstr - data) + ::strlen(reinterpret_cast<const char*>(cstr)) + 1;

  ir_string->data = slicer::MemView(data, size);
  ir_string->orig_index = index;

  // update the strings lookup table
  dex_ir_->strings_lookup.Insert(ir_string);

  return ir_string;
}

void Reader::ParseInstructions(slicer::ArrayView<const dex::u2> code) {
  const dex::u2* ptr = code.begin();
  while (ptr < code.end()) {
    auto dex_instr = dex::DecodeInstruction(ptr);

    dex::u4 index = dex::kNoIndex;
    dex::u4 index2 = dex::kNoIndex;
    switch (dex::GetFormatFromOpcode(dex_instr.opcode)) {
      case dex::k20bc:
      case dex::k21c:
      case dex::k31c:
      case dex::k35c:
      case dex::k3rc:
        index = dex_instr.vB;
        break;

      case dex::k45cc:
      case dex::k4rcc:
        index = dex_instr.vB;
        index2 = dex_instr.arg[4];
        break;

      case dex::k22c:
        index = dex_instr.vC;
        break;

      default:
        break;
    }

    switch (GetIndexTypeFromOpcode(dex_instr.opcode)) {
      case dex::kIndexStringRef:
        GetString(index);
        break;

      case dex::kIndexTypeRef:
        GetType(index);
        break;

      case dex::kIndexFieldRef:
        GetFieldDecl(index);
        break;

      case dex::kIndexMethodRef:
        GetMethodDecl(index);
        break;

      case dex::kIndexMethodAndProtoRef:
        GetMethodDecl(index);
        GetProto(index2);
        break;

      default:
        break;
    }

    auto isize = dex::GetWidthFromBytecode(ptr);
    SLICER_CHECK(isize > 0);
    ptr += isize;
  }
  SLICER_CHECK(ptr == code.end());
}

// Basic .dex header structural checks
void Reader::ValidateHeader() {
  SLICER_CHECK(size_ > sizeof(dex::Header));

  // Known issue: For performance reasons the initial size_ passed to jvmti events might be an
  // estimate. b/72402467
  SLICER_CHECK(header_->file_size <= size_);
  static_assert(sizeof(dex::Header) == 112);
  static_assert(sizeof(dex::CompactHeader) == 136);
  if (IsCompact(header_)) {
    SLICER_CHECK(header_->header_size == sizeof(dex::CompactHeader));
    is_compact_ = true;
  } else {
    SLICER_CHECK(header_->header_size == sizeof(dex::Header));
    is_compact_ = false;
  }
  SLICER_CHECK(header_->endian_tag == dex::kEndianConstant);
  SLICER_CHECK(header_->data_size % 4 == 0);

  // Known issue: The fields might be slightly corrupted b/65452964
  // SLICER_CHECK(header_->data_off + header_->data_size <= size_);

  SLICER_CHECK(header_->string_ids_off % 4 == 0);
  SLICER_CHECK(header_->type_ids_size < 65536);
  SLICER_CHECK(header_->type_ids_off % 4 == 0);
  SLICER_CHECK(header_->proto_ids_size < 65536);
  SLICER_CHECK(header_->proto_ids_off % 4 == 0);
  SLICER_CHECK(header_->field_ids_off % 4 == 0);
  SLICER_CHECK(header_->method_ids_off % 4 == 0);
  SLICER_CHECK(header_->class_defs_off % 4 == 0);
  if (!is_compact_) {
    SLICER_CHECK(header_->map_off >= header_->data_off && header_->map_off < size_);
  }
  SLICER_CHECK(header_->link_size == 0);
  SLICER_CHECK(header_->link_off == 0);
  SLICER_CHECK(header_->data_off % 4 == 0);
  SLICER_CHECK(header_->map_off % 4 == 0);

  // we seem to have .dex files with extra bytes at the end ...
  // Known issue: For performance reasons the initial size_ passed to jvmti events might be an
  // estimate. b/72402467
  SLICER_WEAK_CHECK(header_->data_off + header_->data_size <= data_size_);

  // but we should still have the whole data section

  // Known issue: The fields might be slightly corrupted b/65452964
  // Known issue: For performance reasons the initial size_ passed to jvmti events might be an
  // estimate. b/72402467
  // SLICER_CHECK(header_->data_off + header_->data_size <= size_);

  // validate the map
  // (map section size = sizeof(MapList::size) + sizeof(MapList::list[size])
  auto map_list = DexMapList();
  SLICER_CHECK(map_list->size > 0);
  [[maybe_unused]] auto map_section_size =
      sizeof(dex::u4) + sizeof(dex::MapItem) * map_list->size;
  SLICER_CHECK(header_->map_off + map_section_size <= data_size_);
}

}  // namespace dex

```

`slicer/sha1.cpp`:

```cpp
/* from valgrind tests */

/* ================ sha1.c ================ */
/*
SHA-1 in C
By Steve Reid <steve@edmweb.com>
100% Public Domain
Test Vectors (from FIPS PUB 180-1)
"abc"
  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
A million repetitions of "a"
  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
*/

/* #define LITTLE_ENDIAN * This should be #define'd already, if true. */
/* #define SHA1HANDSOFF * Copies data before messing with it. */

#define SHA1HANDSOFF

#include <cstring>
#include <sys/types.h>	/* for u_int*_t */
#if defined(__sun)
#include "solarisfixes.h"
#endif
#include "slicer/sha1.h"

#ifndef BYTE_ORDER
#if (BSD >= 199103)
# include <machine/endian.h>
#else
#if defined(linux) || defined(__linux__)
# include <endian.h>
#else
#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax, pc) */
#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp)*/

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(__i386__) || \
    defined(MIPSEL) || defined(_MIPSEL) || defined(BIT_ZERO_ON_RIGHT) || \
    defined(__alpha__) || defined(__alpha)
#define BYTE_ORDER	LITTLE_ENDIAN
#endif

#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined(_MIPSEB) || defined(_IBMR2) || defined(DGUX) ||\
    defined(apollo) || defined(__convex__) || defined(_CRAY) || \
    defined(__hppa) || defined(__hp9000) || \
    defined(__hp9000s300) || defined(__hp9000s700) || \
    defined (BIT_ZERO_ON_LEFT) || defined(m68k) || defined(__sparc)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#endif /* linux */
#endif /* BSD */
#endif /* BYTE_ORDER */

#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
#if (__BYTE_ORDER == __LITTLE_ENDIAN)
#define BYTE_ORDER LITTLE_ENDIAN
#else
#define BYTE_ORDER BIG_ENDIAN
#endif
#endif

#if !defined(BYTE_ORDER) || \
    (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN && \
    BYTE_ORDER != PDP_ENDIAN)
/* you must determine what the correct bit order is for
	 * your compiler - the next line is an intentional error
	 * which will force your compiles to bomb until you fix
	 * the above macros.
	 */
#error "Undefined or invalid BYTE_ORDER"
#endif

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

/* blk0() and blk() perform the initial expand. */
/* I got the idea of expanding during the round function from SSLeay */
#if BYTE_ORDER == LITTLE_ENDIAN
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
    |(rol(block->l[i],8)&0x00FF00FF))
#elif BYTE_ORDER == BIG_ENDIAN
#define blk0(i) block->l[i]
#else
#error "Endianness not defined!"
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
    ^block->l[(i+2)&15]^block->l[i&15],1))

/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);


/* Hash a single 512-bit block. This is the core of the algorithm. */

void SHA1Transform(u_int32_t state[5], const unsigned char buffer[64])
{
    u_int32_t a, b, c, d, e;
    typedef union {
        unsigned char c[64];
        u_int32_t l[16];
    } CHAR64LONG16;
#ifdef SHA1HANDSOFF
    CHAR64LONG16 block[1];  /* use array to appear as a pointer */
    memcpy(block, buffer, 64);
#else
    /* The following had better never be used because it causes the
     * pointer-to-const buffer to be cast into a pointer to non-const.
     * And the result is written through.  I threw a "const" in, hoping
     * this will cause a diagnostic.
     */
CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
#endif
    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
    /* Add the working vars back into context.state[] */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
    /* Wipe variables */
    a = b = c = d = e = 0;
#ifdef SHA1HANDSOFF
    memset(block, '\0', sizeof(block));
#endif
}


/* SHA1Init - Initialize new context */

void SHA1Init(SHA1_CTX* context)
{
    /* SHA1 initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
    context->count[0] = context->count[1] = 0;
}


/* Run your data through this. */

void SHA1Update(SHA1_CTX* context, const unsigned char* data, u_int32_t len)
{
    u_int32_t i;
    u_int32_t j;

    j = context->count[0];
    if ((context->count[0] += len << 3) < j)
        context->count[1]++;
    context->count[1] += (len>>29);
    j = (j >> 3) & 63;
    if ((j + len) > 63) {
        memcpy(&context->buffer[j], data, (i = 64-j));
        SHA1Transform(context->state, context->buffer);
        for ( ; i + 63 < len; i += 64) {
            SHA1Transform(context->state, &data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&context->buffer[j], &data[i], len - i);
}


/* Add padding and return the message digest. */

void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
{
    unsigned i;
    unsigned char finalcount[8];
    unsigned char c;

#if 0	/* untested "improvement" by DHR */
    /* Convert context->count to a sequence of bytes
     * in finalcount.  Second element first, but
     * big-endian order within element.
     * But we do it all backwards.
     */
    unsigned char *fcp = &finalcount[8];

    for (i = 0; i < 2; i++)
    {
	u_int32_t t = context->count[i];
	int j;

	for (j = 0; j < 4; t >>= 8, j++)
	    *--fcp = (unsigned char) t
    }
#else
    for (i = 0; i < 8; i++) {
        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
                >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
    }
#endif
    c = 0200;
    SHA1Update(context, &c, 1);
    while ((context->count[0] & 504) != 448) {
        c = 0000;
        SHA1Update(context, &c, 1);
    }
    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
    for (i = 0; i < 20; i++) {
        digest[i] = (unsigned char)
                ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
    }
    /* Wipe variables */
    memset(context, '\0', sizeof(*context));
    memset(&finalcount, '\0', sizeof(finalcount));
}
/* ================ end of sha1.c ================ */

```

`slicer/writer.cc`:

```cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "slicer/writer.h"
#include "slicer/common.h"
#include "slicer/scopeguard.h"
#include "slicer/dex_bytecode.h"
#include "slicer/dex_format.h"
#include "slicer/dex_ir.h"
#include "slicer/dex_leb128.h"
#include "slicer/sha1.h"

#include <assert.h>
#include <type_traits>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <algorithm>

namespace dex {

// Returns the IR node index, or kNoIndex for null IR nodes
template <class T>
static dex::u4 OptIndex(const T* ir_node) {
  return ir_node != nullptr ? ir_node->index : dex::kNoIndex;
}

// Helper for creating the header of an encoded value
static void WriteEncodedValueHeader(dex::u1 type, int arg, Section& data) {
  assert((type & ~dex::kEncodedValueTypeMask) == 0);
  assert(arg >= 0 && arg < 8);
  dex::u1 header = dex::u1(type | (arg << dex::kEncodedValueArgShift));
  data.Push<dex::u1>(header);
}

// Writes an integer encoded value
template <class T>
static void WriteIntValue(dex::u1 type, T value, Section& data) {
  dex::u1 buff[sizeof(T)] = {};
  dex::u1* dst = buff;

  if (std::is_signed<T>::value) {
    const bool positive = (value >= 0);
    while (positive ? value >= 0x80 : value < -0x80) {
      *dst++ = value & 0xff;
      if constexpr(std::is_same_v<T, signed char>) break;
      value >>= 8;
    }
    *dst++ = value & 0xff;
  } else {
    do {
      *dst++ = value & 0xff;
      value >>= 8;
    } while (value != 0);
  }

  size_t size = dst - buff;
  assert(size > 0 && size <= sizeof(T));
  WriteEncodedValueHeader(type, size - 1, data);
  data.Push(buff, size);
}

// Writes a floating point encoded value
template <class T>
static void WriteFloatValue(dex::u1 type, T value, Section& data) {
  dex::u1 buff[sizeof(T)] = {};
  auto src = reinterpret_cast<const dex::u1*>(&value);
  size_t size = sizeof(T);

  // skip "rightmost" zero bytes
  while (size > 1 && *src == 0) {
    --size;
    ++src;
  }

  // copy the rest...
  for (size_t i = 0; i < size; ++i) {
    buff[i] = src[i];
  }

  assert(size > 0 && size <= sizeof(T));
  WriteEncodedValueHeader(type, size - 1, data);
  data.Push(buff, size);
}

static void WriteEncodedArray(const ir::EncodedArray* ir_array, Section& data);
static void WriteAnnotation(const ir::Annotation* ir_annotation, Section& data);

// "encoded_value"
static void WriteEncodedValue(const ir::EncodedValue* ir_value, Section& data) {
  SLICER_EXTRA(auto offset = data.size());

  dex::u1 type = ir_value->type;
  switch (type) {
    case dex::kEncodedByte:
      WriteIntValue(type, ir_value->u.byte_value, data);
      break;

    case dex::kEncodedShort:
      WriteIntValue(type, ir_value->u.short_value, data);
      break;

    case dex::kEncodedChar:
      WriteIntValue(type, ir_value->u.char_value, data);
      break;

    case dex::kEncodedInt:
      WriteIntValue(type, ir_value->u.int_value, data);
      break;

    case dex::kEncodedLong:
      WriteIntValue(type, ir_value->u.long_value, data);
      break;

    case dex::kEncodedFloat:
      WriteFloatValue(type, ir_value->u.float_value, data);
      break;

    case dex::kEncodedDouble:
      WriteFloatValue(type, ir_value->u.double_value, data);
      break;

    case dex::kEncodedString:
      WriteIntValue<dex::u4>(type, ir_value->u.string_value->index, data);
      break;

    case dex::kEncodedType:
      WriteIntValue<dex::u4>(type, ir_value->u.type_value->index, data);
      break;

    case dex::kEncodedField:
      WriteIntValue<dex::u4>(type, ir_value->u.field_value->index, data);
      break;

    case dex::kEncodedMethod:
      WriteIntValue<dex::u4>(type, ir_value->u.method_value->index, data);
      break;

    case dex::kEncodedEnum:
      WriteIntValue<dex::u4>(type, ir_value->u.enum_value->index, data);
      break;

    case dex::kEncodedArray:
      WriteEncodedValueHeader(type, 0, data);
      WriteEncodedArray(ir_value->u.array_value, data);
      break;

    case dex::kEncodedAnnotation:
      WriteEncodedValueHeader(type, 0, data);
      WriteAnnotation(ir_value->u.annotation_value, data);
      break;

    case dex::kEncodedNull:
      WriteEncodedValueHeader(type, 0, data);
      break;

    case dex::kEncodedBoolean: {
      int arg = ir_value->u.bool_value ? 1 : 0;
      WriteEncodedValueHeader(type, arg, data);
    } break;

    default:
      SLICER_CHECK(!"unexpected value type");
  }

  // optionally check the encoding against the original one
  // (if possible, some of the values contain relocated indexes)
  SLICER_EXTRA({
    switch (type) {
      case dex::kEncodedByte:
      case dex::kEncodedShort:
      case dex::kEncodedChar:
      case dex::kEncodedInt:
      case dex::kEncodedLong:
      case dex::kEncodedFloat:
      case dex::kEncodedDouble:
      case dex::kEncodedNull:
      case dex::kEncodedBoolean:
        auto ptr = data.ptr<const dex::u1>(offset);
        auto size = data.size() - offset;
        SLICER_CHECK(size == ir_value->original.size());
        SLICER_CHECK(memcmp(ptr, ir_value->original.ptr(), size) == 0);
        break;
    }
  });
}

// "encoded_annotation"
static void WriteAnnotation(const ir::Annotation* ir_annotation, Section& data) {
  data.PushULeb128(ir_annotation->type->index);
  data.PushULeb128(ir_annotation->elements.size());
  for (auto irAnnotationElement : ir_annotation->elements) {
    data.PushULeb128(irAnnotationElement->name->index);
    WriteEncodedValue(irAnnotationElement->value, data);
  }
}

// "encoded_array"
static void WriteEncodedArray(const ir::EncodedArray* ir_array, Section& data) {
  const auto& values = ir_array->values;
  data.PushULeb128(values.size());
  for (auto irEncodedValue : values) {
    WriteEncodedValue(irEncodedValue, data);
  }
}

// helper for concatenating .dex sections into the final image
template <class T>
static void CopySection(const T& section, dex::u1* image, dex::u4 image_size) {
  if (section.size() == 0) {
    SLICER_CHECK(section.ItemsCount() == 0);
    return;
  }

  SLICER_CHECK(section.ItemsCount() > 0);
  dex::u4 offset = section.SectionOffset();
  dex::u4 size = section.size();
  SLICER_CHECK(offset >= sizeof(dex::Header));
  SLICER_CHECK(offset + size <= image_size);

  ::memcpy(image + offset, section.data(), size);
}

static u4 ReadU4(const u2* ptr) { return ptr[0] | (u4(ptr[1]) << 16); }

static void WriteU4(u2* ptr, u4 val) {
  ptr[0] = val & 0xffff;
  ptr[1] = val >> 16;
}

// This is the main interface for the .dex writer
// (returns nullptr on failure)
dex::u1* Writer::CreateImage(Allocator* allocator, size_t* new_image_size, bool checksum) {
  // create a new DexImage
  dex_.reset(new DexImage);

  SLICER_SCOPE_EXIT {
      dex_.reset();
  };

  // TODO: revisit IR normalization
  // (ideally we shouldn't change the IR while generating an image)
  dex_ir_->Normalize();

  // track the current offset within the .dex image
  dex::u4 offset = 0;

  // allocate the image and index sections
  // (they will be back-filled)
  offset += sizeof(dex::Header);
  offset += dex_->string_ids.Init(offset, dex_ir_->strings.size());
  offset += dex_->type_ids.Init(offset, dex_ir_->types.size());
  offset += dex_->proto_ids.Init(offset, dex_ir_->protos.size());
  offset += dex_->field_ids.Init(offset, dex_ir_->fields.size());
  offset += dex_->method_ids.Init(offset, dex_ir_->methods.size());
  offset += dex_->class_defs.Init(offset, dex_ir_->classes.size());

  // the base offset for the "data" meta-section
  SLICER_CHECK(offset % 4 == 0);
  const dex::u4 data_offset = offset;

  // we must create the sections in a very specific
  // order due to file pointers across sections
  offset += CreateStringDataSection(offset);
  offset += CreateTypeListsSection(offset);
  offset += CreateDebugInfoSection(offset);
  offset += CreateEncodedArrayItemSection(offset);
  offset += CreateCodeItemSection(offset);
  offset += CreateClassDataSection(offset);
  offset += CreateAnnItemSection(offset);
  offset += CreateAnnSetsSection(offset);
  offset += CreateAnnSetRefListsSection(offset);
  offset += CreateAnnDirectoriesSection(offset);
  offset += CreateMapSection(offset);

  // back-fill the indexes
  FillTypes();
  FillFields();
  FillProtos();
  FillMethods();
  FillClassDefs();

  // allocate the final buffer for the .dex image
  SLICER_CHECK(offset % 4 == 0);
  const dex::u4 image_size = offset;
  dex::u1* image = static_cast<dex::u1*>(allocator->Allocate(image_size));
  if (image == nullptr) {
    // memory allocation failed, bailing out...
    return nullptr;
  }
  memset(image, 0, image_size);

  // finally, back-fill the header
  SLICER_CHECK(image_size > sizeof(dex::Header));

  dex::Header* header = reinterpret_cast<dex::Header*>(image + 0);

  // magic signature
  memcpy(header->magic, dex_ir_->magic.ptr(), dex_ir_->magic.size());

  header->file_size = image_size;
  header->header_size = sizeof(dex::Header);
  header->endian_tag = dex::kEndianConstant;

  header->link_size = 0;
  header->link_off = 0;

  header->map_off = dex_->map_list.SectionOffset();
  header->string_ids_size = dex_->string_ids.ItemsCount();
  header->string_ids_off = dex_->string_ids.SectionOffset();
  header->type_ids_size = dex_->type_ids.ItemsCount();
  header->type_ids_off = dex_->type_ids.SectionOffset();
  header->proto_ids_size = dex_->proto_ids.ItemsCount();
  header->proto_ids_off = dex_->proto_ids.SectionOffset();
  header->field_ids_size = dex_->field_ids.ItemsCount();
  header->field_ids_off = dex_->field_ids.SectionOffset();
  header->method_ids_size = dex_->method_ids.ItemsCount();
  header->method_ids_off = dex_->method_ids.SectionOffset();
  header->class_defs_size = dex_->class_defs.ItemsCount();
  header->class_defs_off = dex_->class_defs.SectionOffset();
  header->data_size = image_size - data_offset;
  header->data_off = data_offset;

  // copy the individual sections to the final image
  CopySection(dex_->string_ids, image, image_size);
  CopySection(dex_->type_ids, image, image_size);
  CopySection(dex_->proto_ids, image, image_size);
  CopySection(dex_->field_ids, image, image_size);
  CopySection(dex_->method_ids, image, image_size);
  CopySection(dex_->class_defs, image, image_size);
  CopySection(dex_->string_data, image, image_size);
  CopySection(dex_->type_lists, image, image_size);
  CopySection(dex_->debug_info, image, image_size);
  CopySection(dex_->encoded_arrays, image, image_size);
  CopySection(dex_->code, image, image_size);
  CopySection(dex_->class_data, image, image_size);
  CopySection(dex_->ann_directories, image, image_size);
  CopySection(dex_->ann_set_ref_lists, image, image_size);
  CopySection(dex_->ann_sets, image, image_size);
  CopySection(dex_->ann_items, image, image_size);
  CopySection(dex_->map_list, image, image_size);

  if (checksum) {
    // checksum
    SHA1_CTX ctx;
    SHA1Init(&ctx);
    const uint32_t no_sum =
            sizeof(header->magic) + sizeof(header->checksum) + sizeof(header->signature);
    SHA1Update(&ctx, reinterpret_cast<const unsigned char *>(header) + no_sum,
               header->file_size - no_sum);
    SHA1Final(header->signature, &ctx);
  }
  header->checksum = dex::ComputeChecksum(header);

  *new_image_size = image_size;
  return image;
}

// "string_id_item" + string data section
dex::u4 Writer::CreateStringDataSection(dex::u4 section_offset) {
  auto& section = dex_->string_data;
  section.SetOffset(section_offset);

  const auto& strings = dex_ir_->strings;
  for (size_t i = 0; i < strings.size(); ++i) {
    const auto& ir_string = strings[i];
    auto dexStringId = &dex_->string_ids[i];

    dex::u4 offset = section.AddItem();
    section.Push(ir_string->data);
    dexStringId->string_data_off = section.AbsoluteOffset(offset);
  }

  dex::u4 size = section.Seal(4);
  return size;
}

// Helper for creating the map section
template <class T>
static void AddMapItem(const T& section, std::vector<dex::MapItem>& items) {
  if (section.ItemsCount() > 0) {
    SLICER_CHECK(section.SectionOffset() >= sizeof(dex::Header));
    dex::MapItem map_item = {};
    map_item.type = section.MapEntryType();
    map_item.size = section.ItemsCount();
    map_item.offset = section.SectionOffset();
    items.push_back(map_item);
  }
}

// map_list section
dex::u4 Writer::CreateMapSection(dex::u4 section_offset) {
  auto& section = dex_->map_list;
  section.SetOffset(section_offset);
  section.AddItem(4);

  std::vector<dex::MapItem> map_items;

  dex::MapItem headerItem = {};
  headerItem.type = dex::kHeaderItem;
  headerItem.size = 1;
  headerItem.offset = 0;
  map_items.push_back(headerItem);

  AddMapItem(dex_->string_ids, map_items);
  AddMapItem(dex_->type_ids, map_items);
  AddMapItem(dex_->proto_ids, map_items);
  AddMapItem(dex_->field_ids, map_items);
  AddMapItem(dex_->method_ids, map_items);
  AddMapItem(dex_->class_defs, map_items);
  AddMapItem(dex_->string_data, map_items);
  AddMapItem(dex_->type_lists, map_items);
  AddMapItem(dex_->debug_info, map_items);
  AddMapItem(dex_->encoded_arrays, map_items);
  AddMapItem(dex_->code, map_items);
  AddMapItem(dex_->class_data, map_items);
  AddMapItem(dex_->ann_directories, map_items);
  AddMapItem(dex_->ann_set_ref_lists, map_items);
  AddMapItem(dex_->ann_sets, map_items);
  AddMapItem(dex_->ann_items, map_items);
  AddMapItem(dex_->map_list, map_items);

  std::qsort(&map_items[0], map_items.size(), sizeof(map_items[0]),
            +[](const void* a, const void* b) -> int {
              const auto* i = static_cast<const dex::MapItem*>(a);
              const auto* j = static_cast<const dex::MapItem*>(b);
              SLICER_CHECK(i->offset != j->offset);
              if (i->offset < j->offset) {
                return -1;
              }
              return 1;
            });

  section.Push<dex::u4>(map_items.size());
  section.Push(map_items);
  return section.Seal(4);
}

// annotation_item section
dex::u4 Writer::CreateAnnItemSection(dex::u4 section_offset) {
  dex_->ann_items.SetOffset(section_offset);

  for (const auto& ir_node : dex_ir_->annotations) {
    if (ir_node->visibility != dex::kVisibilityEncoded) {
      // TODO: factor out the node_offset_ updating
      dex::u4& offset = node_offset_[ir_node.get()];
      SLICER_CHECK(offset == 0);
      offset = WriteAnnotationItem(ir_node.get());
    }
  }

  return dex_->ann_items.Seal(4);
}

// annotation_set_item section
dex::u4 Writer::CreateAnnSetsSection(dex::u4 section_offset) {
  dex_->ann_sets.SetOffset(section_offset);

  for (const auto& ir_node : dex_ir_->annotation_sets) {
    dex::u4& offset = node_offset_[ir_node.get()];
    SLICER_CHECK(offset == 0);
    offset = WriteAnnotationSet(ir_node.get());
  }

  return dex_->ann_sets.Seal(4);
}

// annotation_set_ref_list section
dex::u4 Writer::CreateAnnSetRefListsSection(dex::u4 section_offset) {
  dex_->ann_set_ref_lists.SetOffset(section_offset);

  for (const auto& ir_node : dex_ir_->annotation_set_ref_lists) {
    dex::u4& offset = node_offset_[ir_node.get()];
    SLICER_CHECK(offset == 0);
    offset = WriteAnnotationSetRefList(ir_node.get());
  }

  return dex_->ann_set_ref_lists.Seal(4);
}

// type_list section
dex::u4 Writer::CreateTypeListsSection(dex::u4 section_offset) {
  dex_->type_lists.SetOffset(section_offset);

  for (const auto& ir_type_list : dex_ir_->type_lists) {
    dex::u4& offset = node_offset_[ir_type_list.get()];
    SLICER_CHECK(offset == 0);
    offset = WriteTypeList(ir_type_list->types);
  }

  return dex_->type_lists.Seal(4);
}

// code_item section
dex::u4 Writer::CreateCodeItemSection(dex::u4 section_offset) {
  dex_->code.SetOffset(section_offset);

  for (const auto& ir_node : dex_ir_->code) {
    dex::u4& offset = node_offset_[ir_node.get()];
    SLICER_CHECK(offset == 0);
    offset = WriteCode(ir_node.get());
  }

  dex::u4 size = dex_->code.Seal(4);
  return size;
}

// debug info section
dex::u4 Writer::CreateDebugInfoSection(dex::u4 section_offset) {
  dex_->debug_info.SetOffset(section_offset);

  for (const auto& ir_node : dex_ir_->debug_info) {
    dex::u4& offset = node_offset_[ir_node.get()];
    SLICER_CHECK(offset == 0);
    offset = WriteDebugInfo(ir_node.get());
  }

  dex::u4 size = dex_->debug_info.Seal(4);
  return size;
}

// class_data_item section
dex::u4 Writer::CreateClassDataSection(dex::u4 section_offset) {
  dex_->class_data.SetOffset(section_offset);

  const auto& classes = dex_ir_->classes;
  for (size_t i = 0; i < classes.size(); ++i) {
    auto ir_class = classes[i].get();
    auto dex_class_def = &dex_->class_defs[i];
    dex_class_def->class_data_off = WriteClassData(ir_class);
  }

  dex::u4 size = dex_->class_data.Seal(4);
  return size;
}

// annotations_directory section
dex::u4 Writer::CreateAnnDirectoriesSection(dex::u4 section_offset) {
  dex_->ann_directories.SetOffset(section_offset);

  const auto& classes = dex_ir_->classes;
  for (size_t i = 0; i < classes.size(); ++i) {
    auto ir_class = classes[i].get();
    auto dex_class_def = &dex_->class_defs[i];
    dex_class_def->annotations_off = WriteClassAnnotations(ir_class);
  }

  return dex_->ann_directories.Seal(4);
}

// encoded_array_item section
dex::u4 Writer::CreateEncodedArrayItemSection(dex::u4 section_offset) {
  dex_->encoded_arrays.SetOffset(section_offset);

  const auto& classes = dex_ir_->classes;
  for (size_t i = 0; i < classes.size(); ++i) {
    auto ir_class = classes[i].get();
    auto dex_class_def = &dex_->class_defs[i];
    dex_class_def->static_values_off = WriteClassStaticValues(ir_class);
  }

  return dex_->encoded_arrays.Seal(4);
}

// "type_id_item"
void Writer::FillTypes() {
  const auto& types = dex_ir_->types;
  for (size_t i = 0; i < types.size(); ++i) {
    const auto& ir_type = types[i];
    auto dexTypeId = &dex_->type_ids[i];
    // CONSIDER: an automatic index check would be nice
    dexTypeId->descriptor_idx = ir_type->descriptor->index;
  }
}

// "proto_id_item"
void Writer::FillProtos() {
  const auto& protos = dex_ir_->protos;
  for (size_t i = 0; i < protos.size(); ++i) {
    const auto& irProto = protos[i];
    auto dexProtoId = &dex_->proto_ids[i];
    dexProtoId->shorty_idx = irProto->shorty->index;
    dexProtoId->return_type_idx = irProto->return_type->index;
    dexProtoId->parameters_off = FilePointer(irProto->param_types);
  }
}

// "field_id_item"
void Writer::FillFields() {
  const auto& fields = dex_ir_->fields;
  for (size_t i = 0; i < fields.size(); ++i) {
    const auto& ir_field = fields[i];
    auto dexFieldId = &dex_->field_ids[i];
    dexFieldId->class_idx = ir_field->parent->index;
    dexFieldId->type_idx = ir_field->type->index;
    dexFieldId->name_idx = ir_field->name->index;
  }
}

// "method_id_item"
void Writer::FillMethods() {
  const auto& methods = dex_ir_->methods;
  for (size_t i = 0; i < methods.size(); ++i) {
    const auto& ir_method = methods[i];
    auto dexMethodId = &dex_->method_ids[i];
    dexMethodId->class_idx = ir_method->parent->index;
    dexMethodId->proto_idx = ir_method->prototype->index;
    dexMethodId->name_idx = ir_method->name->index;
  }
}

// "class_def_item"
void Writer::FillClassDefs() {
  const auto& classes = dex_ir_->classes;
  for (size_t i = 0; i < classes.size(); ++i) {
    auto ir_class = classes[i].get();
    auto dex_class_def = &dex_->class_defs[i];
    dex_class_def->class_idx = ir_class->type->index;
    dex_class_def->access_flags = ir_class->access_flags;
    dex_class_def->superclass_idx = OptIndex(ir_class->super_class);
    dex_class_def->source_file_idx = OptIndex(ir_class->source_file);
    dex_class_def->interfaces_off = FilePointer(ir_class->interfaces);

    // NOTE: we already set some offsets when we created the
    //  corresponding .dex section:
    //
    //  ->annotations_off
    //  ->class_data_off
    //  ->static_values_off
  }
}

// "type_list"
dex::u4 Writer::WriteTypeList(const std::vector<ir::Type*>& types) {
  if (types.empty()) {
    return 0;
  }

  auto& data = dex_->type_lists;
  dex::u4 offset = data.AddItem(4);
  data.Push<dex::u4>(types.size());
  for (auto ir_type : types) {
    data.Push<dex::u2>(ir_type->index);
  }
  return data.AbsoluteOffset(offset);
}

// "annotation_item"
dex::u4 Writer::WriteAnnotationItem(const ir::Annotation* ir_annotation) {
  SLICER_CHECK(ir_annotation->visibility != dex::kVisibilityEncoded);

  auto& data = dex_->ann_items;
  dex::u4 offset = data.AddItem();
  data.Push<dex::u1>(ir_annotation->visibility);
  WriteAnnotation(ir_annotation, data);
  return data.AbsoluteOffset(offset);
}

// "annotation_set_item"
dex::u4 Writer::WriteAnnotationSet(const ir::AnnotationSet* ir_annotation_set) {
  SLICER_CHECK(ir_annotation_set != nullptr);

  const auto& annotations = ir_annotation_set->annotations;

  auto& data = dex_->ann_sets;
  dex::u4 offset = data.AddItem(4);
  data.Push<dex::u4>(annotations.size());
  for (auto ir_annotation : annotations) {
    data.Push<dex::u4>(FilePointer(ir_annotation));
  }
  return data.AbsoluteOffset(offset);
}

// "annotation_set_ref_list"
dex::u4 Writer::WriteAnnotationSetRefList(
    const ir::AnnotationSetRefList* ir_annotation_set_ref_list) {
  SLICER_CHECK(ir_annotation_set_ref_list != nullptr);

  const auto& annotations = ir_annotation_set_ref_list->annotations;

  auto& data = dex_->ann_set_ref_lists;
  dex::u4 offset = data.AddItem(4);
  data.Push<dex::u4>(annotations.size());
  for (auto ir_annotation_set : annotations) {
    data.Push<dex::u4>(FilePointer(ir_annotation_set));
  }
  return data.AbsoluteOffset(offset);
}

// "annotations_directory_item"
dex::u4 Writer::WriteClassAnnotations(const ir::Class* ir_class) {
  if (ir_class->annotations == nullptr) {
    return 0;
  }

  auto ir_annotations = ir_class->annotations;

  dex::u4& offset = node_offset_[ir_annotations];
  if (offset == 0) {
    // in order to write a contiguous "annotations_directory_item" we do two
    // passes :
    // 1. write the field/method/params annotations content
    // 2. write the directory (including the field/method/params arrays)
    std::vector<dex::FieldAnnotationsItem> dex_field_annotations;
    std::vector<dex::MethodAnnotationsItem> dex_method_annotations;
    std::vector<dex::ParameterAnnotationsItem> dex_param_annotations;

    for (auto irItem : ir_annotations->field_annotations) {
      dex::FieldAnnotationsItem dex_item = {};
      dex_item.field_idx = irItem->field_decl->index;
      dex_item.annotations_off = FilePointer(irItem->annotations);
      dex_field_annotations.push_back(dex_item);
    }

    for (auto irItem : ir_annotations->method_annotations) {
      dex::MethodAnnotationsItem dex_item = {};
      dex_item.method_idx = irItem->method_decl->index;
      dex_item.annotations_off = FilePointer(irItem->annotations);
      dex_method_annotations.push_back(dex_item);
    }

    for (auto irItem : ir_annotations->param_annotations) {
      dex::ParameterAnnotationsItem dex_item = {};
      dex_item.method_idx = irItem->method_decl->index;
      dex_item.annotations_off = FilePointer(irItem->annotations);
      dex_param_annotations.push_back(dex_item);
    }

    dex::u4 class_annotations_offset =
        FilePointer(ir_annotations->class_annotation);

    // now that the annotations content is written,
    // we can write down the "annotations_directory_item"
    dex::AnnotationsDirectoryItem dex_annotations = {};
    dex_annotations.class_annotations_off = class_annotations_offset;
    dex_annotations.fields_size = ir_annotations->field_annotations.size();
    dex_annotations.methods_size = ir_annotations->method_annotations.size();
    dex_annotations.parameters_size = ir_annotations->param_annotations.size();

    auto& data = dex_->ann_directories;
    offset = data.AddItem(4);
    data.Push(dex_annotations);
    data.Push(dex_field_annotations);
    data.Push(dex_method_annotations);
    data.Push(dex_param_annotations);
    offset = data.AbsoluteOffset(offset);
  }
  return offset;
}

// "debug_info_item"
dex::u4 Writer::WriteDebugInfo(const ir::DebugInfo* ir_debug_info) {
  SLICER_CHECK(ir_debug_info != nullptr);

  auto& data = dex_->debug_info;
  dex::u4 offset = data.AddItem();

  // debug info "header"
  data.PushULeb128(ir_debug_info->line_start);
  data.PushULeb128(ir_debug_info->param_names.size());
  for (auto ir_string : ir_debug_info->param_names) {
    data.PushULeb128(OptIndex(ir_string) + 1);
  }

  // debug info "state machine bytecodes"
  const dex::u1* src = ir_debug_info->data.ptr<dex::u1>();
  dex::u1 opcode = 0;
  while ((opcode = *src++) != dex::DBG_END_SEQUENCE) {
    data.Push<dex::u1>(opcode);

    switch (opcode) {
      case dex::DBG_ADVANCE_PC:
        // addr_diff
        data.PushULeb128(dex::ReadULeb128(&src));
        break;

      case dex::DBG_ADVANCE_LINE:
        // line_diff
        data.PushSLeb128(dex::ReadSLeb128(&src));
        break;

      case dex::DBG_START_LOCAL: {
        // register_num
        data.PushULeb128(dex::ReadULeb128(&src));

        dex::u4 name_index = dex::ReadULeb128(&src) - 1;
        data.PushULeb128(MapStringIndex(name_index) + 1);

        dex::u4 type_index = dex::ReadULeb128(&src) - 1;
        data.PushULeb128(MapTypeIndex(type_index) + 1);
      } break;

      case dex::DBG_START_LOCAL_EXTENDED: {
        // register_num
        data.PushULeb128(dex::ReadULeb128(&src));

        dex::u4 name_index = dex::ReadULeb128(&src) - 1;
        data.PushULeb128(MapStringIndex(name_index) + 1);

        dex::u4 type_index = dex::ReadULeb128(&src) - 1;
        data.PushULeb128(MapTypeIndex(type_index) + 1);

        dex::u4 sig_index = dex::ReadULeb128(&src) - 1;
        data.PushULeb128(MapStringIndex(sig_index) + 1);
      } break;

      case dex::DBG_END_LOCAL:
      case dex::DBG_RESTART_LOCAL:
        // register_num
        data.PushULeb128(dex::ReadULeb128(&src));
        break;

      case dex::DBG_SET_FILE: {
        dex::u4 name_index = dex::ReadULeb128(&src) - 1;
        data.PushULeb128(MapStringIndex(name_index) + 1);
      } break;
    }
  }
  data.Push<dex::u1>(dex::DBG_END_SEQUENCE);

  return data.AbsoluteOffset(offset);
}

// instruction[] array
void Writer::WriteInstructions(slicer::ArrayView<const dex::u2> instructions) {
  SLICER_CHECK(!instructions.empty());

  auto offset = dex_->code.Push(instructions);
  dex::u2* ptr = dex_->code.ptr<dex::u2>(offset);
  dex::u2* const end = ptr + instructions.size();

  // relocate the instructions
  while (ptr < end) {
    auto opcode = dex::OpcodeFromBytecode(*ptr);
    dex::u2* idx = &ptr[1];
    dex::u2* idx2 = nullptr;

    size_t idx_size = 0;
    switch (dex::GetFormatFromOpcode(opcode)) {
      case dex::k20bc:
      case dex::k21c:
      case dex::k35c:
      case dex::k3rc:
      case dex::k22c:
        idx_size = 2;
        break;

      case dex::k31c:
        idx_size = 4;
        break;

      case dex::k45cc:
      case dex::k4rcc:
        idx_size = 2;
        idx2 = &ptr[3];
        break;

      default:
        break;
    }

    switch (dex::GetIndexTypeFromOpcode(opcode)) {
      case dex::kIndexStringRef:
        if (idx_size == 4) {
          dex::u4 new_index = MapStringIndex(ReadU4(idx));
          SLICER_CHECK(new_index != dex::kNoIndex);
          WriteU4(idx, new_index);
        } else {
          SLICER_CHECK(idx_size == 2);
          dex::u4 new_index = MapStringIndex(*idx);
          SLICER_CHECK(new_index != dex::kNoIndex);
          SLICER_CHECK(dex::u2(new_index) == new_index);
          *idx = dex::u2(new_index);
        }
        break;

      case dex::kIndexTypeRef: {
        SLICER_CHECK(idx_size == 2);
        dex::u4 new_index = MapTypeIndex(*idx);
        SLICER_CHECK(new_index != dex::kNoIndex);
        SLICER_CHECK(dex::u2(new_index) == new_index);
        *idx = dex::u2(new_index);
      } break;

      case dex::kIndexFieldRef: {
        SLICER_CHECK(idx_size == 2);
        dex::u4 new_index = MapFieldIndex(*idx);
        SLICER_CHECK(new_index != dex::kNoIndex);
        SLICER_CHECK(dex::u2(new_index) == new_index);
        *idx = dex::u2(new_index);
      } break;

      case dex::kIndexMethodRef: {
        SLICER_CHECK(idx_size == 2);
        dex::u4 new_index = MapMethodIndex(*idx);
        SLICER_CHECK(new_index != dex::kNoIndex);
        SLICER_CHECK(dex::u2(new_index) == new_index);
        *idx = dex::u2(new_index);
      } break;

      case dex::kIndexMethodAndProtoRef: {
        SLICER_CHECK(idx_size == 2);
        dex::u4 new_index = MapMethodIndex(*idx);
        SLICER_CHECK(new_index != dex::kNoIndex);
        SLICER_CHECK(dex::u2(new_index) == new_index);
        *idx = dex::u2(new_index);
        dex::u4 new_index2 = MapProtoIndex(*idx2);
        SLICER_CHECK(new_index2 != dex::kNoIndex);
        SLICER_CHECK(dex::u2(new_index2) == new_index2);
        *idx2 = dex::u2(new_index2);
      } break;

      default:
        break;
    }

    auto isize = dex::GetWidthFromBytecode(ptr);
    SLICER_CHECK(isize > 0);
    ptr += isize;
  }
  SLICER_CHECK(ptr == end);
}

// "try_item[] + encoded_catch_handler_list"
void Writer::WriteTryBlocks(const ir::Code* irCode) {
  SLICER_CHECK(!irCode->try_blocks.empty());

  // use a temporary buffer to build the "encoded_catch_handler_list"
  slicer::Buffer handlers_list;
  auto original_list = irCode->catch_handlers.ptr<dex::u1>();
  auto ptr = original_list;
  std::map<dex::u2, dex::u2> handlers_offset_map;

  dex::u4 handlers_count = dex::ReadULeb128(&ptr);
  handlers_list.PushULeb128(handlers_count);

  for (dex::u4 handler_index = 0; handler_index < handlers_count; ++handler_index) {
    // track the oldOffset/newOffset mapping
    handlers_offset_map[ptr - original_list] = handlers_list.size();

    // parse each "encoded_catch_handler"
    int catch_count = dex::ReadSLeb128(&ptr);
    handlers_list.PushSLeb128(catch_count);

    for (int catch_index = 0; catch_index < std::abs(catch_count); ++catch_index) {
      // type_idx
      dex::u4 type_index = dex::ReadULeb128(&ptr);
      handlers_list.PushULeb128(MapTypeIndex(type_index));

      // address
      handlers_list.PushULeb128(dex::ReadULeb128(&ptr));
    }

    if (catch_count < 1) {
      // catch_all_addr
      handlers_list.PushULeb128(dex::ReadULeb128(&ptr));
    }
  }

  handlers_list.Seal(1);

  // now write everything (try_item[] and encoded_catch_handler_list)
  auto& data = dex_->code;
  dex::u4 tries_offset = data.size();
  data.Push(irCode->try_blocks);
  data.Push(handlers_list);

  // finally relocate the offsets to handlers
  for (dex::TryBlock& dex_try : slicer::ArrayView<dex::TryBlock>(
           data.ptr<dex::TryBlock>(tries_offset), irCode->try_blocks.size())) {
    dex::u2 new_Handler_offset = handlers_offset_map[dex_try.handler_off];
    SLICER_CHECK(new_Handler_offset != 0);
    dex_try.handler_off = new_Handler_offset;
  }
}

// "code_item"
dex::u4 Writer::WriteCode(const ir::Code* irCode) {
  SLICER_CHECK(irCode != nullptr);

  dex::Code dex_code = {};
  dex_code.registers_size = irCode->registers;
  dex_code.ins_size = irCode->ins_count;
  dex_code.outs_size = irCode->outs_count;
  dex_code.tries_size = irCode->try_blocks.size();
  dex_code.debug_info_off = FilePointer(irCode->debug_info);
  dex_code.insns_size = irCode->instructions.size();

  auto& data = dex_->code;
  dex::u4 offset = data.AddItem(4);
  data.Push(&dex_code, offsetof(dex::Code, insns));
  WriteInstructions(irCode->instructions);
  if (!irCode->try_blocks.empty()) {
    data.Align(4);
    WriteTryBlocks(irCode);
  }
  return data.AbsoluteOffset(offset);
}

// "encoded_field"
void Writer::WriteEncodedField(const ir::EncodedField* ir_encoded_field,
                       dex::u4* base_index) {
  dex::u4 index_delta = ir_encoded_field->decl->index;
  SLICER_CHECK(index_delta != dex::kNoIndex);
  if (*base_index != dex::kNoIndex) {
    SLICER_CHECK(index_delta > *base_index);
    index_delta = index_delta - *base_index;
  }
  *base_index = ir_encoded_field->decl->index;

  auto& data = dex_->class_data;
  data.PushULeb128(index_delta);
  data.PushULeb128(ir_encoded_field->access_flags);
}

// "encoded_method"
void Writer::WriteEncodedMethod(const ir::EncodedMethod* ir_encoded_method,
                        dex::u4* base_index) {
  dex::u4 index_delta = ir_encoded_method->decl->index;
  SLICER_CHECK(index_delta != dex::kNoIndex);
  if (*base_index != dex::kNoIndex) {
    SLICER_CHECK(index_delta > *base_index);
    index_delta = index_delta - *base_index;
  }
  *base_index = ir_encoded_method->decl->index;

  dex::u4 code_offset = FilePointer(ir_encoded_method->code);

  auto& data = dex_->class_data;
  data.PushULeb128(index_delta);
  data.PushULeb128(ir_encoded_method->access_flags);
  data.PushULeb128(code_offset);
}

// "class_data_item"
dex::u4 Writer::WriteClassData(const ir::Class* ir_class) {
  if (ir_class->static_fields.empty() && ir_class->instance_fields.empty() &&
      ir_class->direct_methods.empty() && ir_class->virtual_methods.empty()) {
    return 0;
  }

  auto& data = dex_->class_data;
  dex::u4 offset = data.AddItem();

  data.PushULeb128(ir_class->static_fields.size());
  data.PushULeb128(ir_class->instance_fields.size());
  data.PushULeb128(ir_class->direct_methods.size());
  data.PushULeb128(ir_class->virtual_methods.size());

  dex::u4 base_index = dex::kNoIndex;
  for (auto ir_encoded_field : ir_class->static_fields) {
    WriteEncodedField(ir_encoded_field, &base_index);
  }

  base_index = dex::kNoIndex;
  for (auto ir_encoded_field : ir_class->instance_fields) {
    WriteEncodedField(ir_encoded_field, &base_index);
  }

  base_index = dex::kNoIndex;
  for (auto ir_encoded_method : ir_class->direct_methods) {
    WriteEncodedMethod(ir_encoded_method, &base_index);
  }

  base_index = dex::kNoIndex;
  for (auto ir_encoded_method : ir_class->virtual_methods) {
    WriteEncodedMethod(ir_encoded_method, &base_index);
  }

  return data.AbsoluteOffset(offset);
}

// "encoded_array_item"
dex::u4 Writer::WriteClassStaticValues(const ir::Class* ir_class) {
  if (ir_class->static_init == nullptr) {
    return 0;
  }

  dex::u4& offset = node_offset_[ir_class->static_init];
  if (offset == 0) {
    auto& data = dex_->encoded_arrays;
    offset = data.AddItem();
    WriteEncodedArray(ir_class->static_init, data);
    offset = data.AbsoluteOffset(offset);
  }
  return offset;
}

// Map an index from the original .dex to the new index
dex::u4 Writer::MapStringIndex(dex::u4 index) const {
  if (index != dex::kNoIndex) {
    index = dex_ir_->strings_map.at(index)->index;
    SLICER_CHECK(index != dex::kNoIndex);
  }
  return index;
}

// Map an index from the original .dex to the new index
dex::u4 Writer::MapTypeIndex(dex::u4 index) const {
  if (index != dex::kNoIndex) {
    index = dex_ir_->types_map.at(index)->index;
    SLICER_CHECK(index != dex::kNoIndex);
  }
  return index;
}

// Map an index from the original .dex to the new index
dex::u4 Writer::MapFieldIndex(dex::u4 index) const {
  if (index != dex::kNoIndex) {
    index = dex_ir_->fields_map.at(index)->index;
    SLICER_CHECK(index != dex::kNoIndex);
  }
  return index;
}

// Map an index from the original .dex to the new index
dex::u4 Writer::MapMethodIndex(dex::u4 index) const {
  if (index != dex::kNoIndex) {
    index = dex_ir_->methods_map.at(index)->index;
    SLICER_CHECK(index != dex::kNoIndex);
  }
  return index;
}

// Map an index from the original .dex to the new index
dex::u4 Writer::MapProtoIndex(dex::u4 index) const {
  if (index != dex::kNoIndex) {
    index = dex_ir_->protos_map.at(index)->index;
    SLICER_CHECK(index != dex::kNoIndex);
  }
  return index;
}

// .dex IR node to file pointer (absolute offset)
dex::u4 Writer::FilePointer(const ir::Node* ir_node) const {
  if (ir_node == nullptr) {
    return 0;
  }
  auto it = node_offset_.find(ir_node);
  SLICER_CHECK(it != node_offset_.end());
  dex::u4 offset = it->second;
  SLICER_CHECK(offset > 0);
  return offset;
}

}  // namespace dex

```