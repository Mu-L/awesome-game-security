Project Path: arc_cragson_osmium_t5pnzgqt

Source Tree:

```txt
arc_cragson_osmium_t5pnzgqt
├── Cheat
│   ├── Feature
│   │   └── feature.hpp
│   └── cheat.hpp
├── Includings
│   ├── custom_data_types.hpp
│   └── modules.hpp
├── LICENSE
├── Memory
│   ├── Hook
│   │   ├── hook.cpp
│   │   └── hook.hpp
│   ├── Image_x64
│   │   ├── image_x64.cpp
│   │   └── image_x64.hpp
│   ├── Image_x86
│   │   ├── image_x86.cpp
│   │   └── image_x86.hpp
│   ├── Process
│   │   ├── process.cpp
│   │   └── process.hpp
│   ├── RegisterDumper
│   │   └── registercontext.hpp
│   └── SharedMemoryInstance
│       └── sharedmemoryinstance.hpp
├── Overlay
│   ├── overlay.cpp
│   └── overlay.hpp
├── README.md
├── Testing
│   ├── test_cheat.cpp
│   ├── test_cheat.hpp
│   ├── test_overlay.cpp
│   └── test_overlay.hpp
└── res
    ├── osmium-logo.png
    ├── project-directx-linking.png
    ├── project-settings-language.png
    ├── project-settings.png
    ├── regdumper-dump-sh.png
    ├── regdumper-regdata.png
    └── sh-rw-test.png

```

`Cheat/Feature/feature.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <chrono>
#include <string>

class feature
{
public:

	///-------------------------------------------------------------------------------------------------
	/// <summary>Default constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	feature() :
		m_status( false ),
		m_virtualkey_code( int32_t() ),
		m_timepoint( std::chrono::high_resolution_clock::now() ),
		m_activation_delay( uint32_t() ),
		m_was_activated( false ),
		m_name( std::wstring() ),
		m_print_status( false ),
		m_should_draw( false )
	{}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="status"> 	True to enable the cheat, false to disable it.</param>
	/// <param name="vk_code">	The virtual key code.</param>
	/// <param name="delay">  	The activation delay.</param>
	///-------------------------------------------------------------------------------------------------

	feature( const bool status, const int32_t vk_code, const uint32_t delay ) :
		m_status( status ),
		m_virtualkey_code( vk_code ),
		m_timepoint( std::chrono::high_resolution_clock::now() ),
		m_activation_delay( delay ),
		m_was_activated( false) ,
		m_name( std::wstring() ),
		m_print_status( false ),
		m_should_draw( false )
	{}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="name">	The name of the feature.</param>
	///-------------------------------------------------------------------------------------------------

	explicit feature( const std::wstring & name ) : feature()
	{
		this->m_name = name;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Print the status of the feature to console.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	inline void print_status() const
	{
		wprintf( L"[%ws] is %ws!\n", this->m_name.c_str(), this->m_status ? L"enabled" : L"disabled" );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Query if the feature is active.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if active, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool is_active() const noexcept
	{
		return this->m_status;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Enables the feature and sets the new status, refreshes the timepoint and prints the status.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void enable() noexcept
	{
		// check here if this is the first activation
		if (!this->m_was_activated)
		{
			this->on_first_activation();

			this->m_was_activated = true;
		}

		// if the feature is not yet ready to be activated, just return.
		if (!this->is_activatable())
			return;

		this->m_status = true;

		this->on_enable();

		// reset the timepoint here after the activation
		this->refresh_timepoint();

		if( this->m_print_status )
			this->print_status();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Disables the feature and sets the new status, refreshes the timepoint and prints the status.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void disable() noexcept
	{
		// if the feature is not yet ready to be activated, just return.
		if (!this->is_activatable())
			return;

		this->m_status = false;

		this->on_disable();

		// reset the timepoint here after the activation
		this->refresh_timepoint();

		if (this->m_print_status)
			this->print_status();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Toggles the feature and sets the new status, refreshes the timepoint and prints the status.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void toggle() noexcept
	{

		// check here if this is the first activation
		if (!this->m_was_activated)
		{
			this->on_first_activation();

			this->m_was_activated = true;
		}

		// if the feature is not yet ready to be activated, just return.
		if (!this->is_activatable())
			return;

		this->m_status = !this->m_status;

		// check here if the feature was enabled or disabled and call the correct startup function for the different case.
		if (this->m_status)
			this->on_enable();
		else
			this->on_disable();

		// reset the timepoint here after the activation
		this->refresh_timepoint();

		if (this->m_print_status)
			this->print_status();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the status of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="new_status">	The new status of the feature.</param>
	///-------------------------------------------------------------------------------------------------

	void set_status(const bool new_status) noexcept
	{
		this->m_status = new_status;

		if (this->m_status)
			this->on_enable();
		else
			this->on_disable();

		if (this->m_print_status)
			this->print_status();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the virtual key code of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The virtual key code of the feature.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] int32_t get_virtual_key_code() const noexcept
	{
		return this->m_virtualkey_code;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets virtual key code of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="vk_code">	The virtual key code of the feature.</param>
	///-------------------------------------------------------------------------------------------------

	void set_virtual_key_code(const int32_t vk_code) noexcept
	{
		this->m_virtualkey_code = vk_code;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the current timepoint in milliseconds.
	/// 
	/// merci beaucoup, mon frère:
	/// 	https://stackoverflow.com/questions/16177295/get-time-since-epoch-in-milliseconds-preferably-using-c11-chrono.
	/// </summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The current timepoint in milliseconds.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline uint32_t get_current_timepoint_in_ms() const noexcept
	{
		// I am ignoring the possible data loss here, thank you.
		// Oh no, that shit will eventually result in really long debug sessions.

#pragma warning(disable:4244)
		return this->m_timepoint.time_since_epoch() / std::chrono::milliseconds(1);
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Refresh the current timepoint.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	inline void refresh_timepoint() noexcept
	{
		this->m_timepoint = std::chrono::high_resolution_clock::now();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the activation delay of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The activation delay.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline uint32_t get_activation_delay() const noexcept
	{
		return this->m_activation_delay;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the activation delay of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="new_delay">	The new activation delay of the feature in milliseconds.</param>
	///-------------------------------------------------------------------------------------------------

	inline void set_activation_delay(const uint32_t new_delay) noexcept
	{
		this->m_activation_delay = new_delay;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Query if the feature is activatable.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if activatable, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool is_activatable() const noexcept
	{
		return (std::chrono::high_resolution_clock::now().time_since_epoch() / std::chrono::milliseconds(1)) - this->m_timepoint.time_since_epoch() / std::chrono::milliseconds(1) >= this->m_activation_delay;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Determines if the feature was already activated.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if the feature was already activated, false if it was not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool was_already_activated() const noexcept
	{
		return this->m_was_activated;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the name of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The name of the feature.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::wstring get_name() const noexcept
	{
		return this->m_name;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the name of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="name">	The new name of the feature.</param>
	///-------------------------------------------------------------------------------------------------

	void set_name( const std::wstring & name )
	{
		this->m_name = name;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Query if the status change of the feature will be printed or not.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if status will be printed, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool is_status_printed() const noexcept
	{
		return this->m_print_status;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the print status of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="status">	If true the status will be printed on change, false it will not be printed.</param>
	///-------------------------------------------------------------------------------------------------

	inline void set_print_status( const bool status ) noexcept
	{
		this->m_print_status = status;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Enables the print status.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	inline void enable_print_status() noexcept
	{
		this->m_print_status = true;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Disables the print status.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	inline void disable_print_status() noexcept
	{
		this->m_print_status = false;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Toggle the print status.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	inline void toggle_print_status() noexcept
	{
		this->m_print_status = !this->m_print_status;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Determine if the feature should be drawn/ on_render function should be called in the overlay logic.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool should_be_drawn() const noexcept
	{
		return this->m_should_draw;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the feature drawing status to true, so the feature should draw.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void enable_drawing() noexcept
	{
		this->m_should_draw = true;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the feature drawing status to false, so the feature should not be draw.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void disable_drawing() noexcept
	{
		this->m_should_draw = false;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Toggle the drawing status of the feature.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void toggle_drawing() noexcept
	{
		this->m_should_draw = !this->m_should_draw;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>The virtual function which should be called frequently in the cheat logic.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void tick() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>The virtual function which will be called when the feature is enabled.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void on_enable() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>The virtual function which will be called when the feature is disabled.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void on_disable() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>The virtual function which will be called when the cheat is activated the first time.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void on_first_activation() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>The virtual function in which all drawing should happen because this should be called inside the overlay logic.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void on_render() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>	The virtual function which should be called when the shutdown function of the cheat was called. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void on_shutdown() = 0;

protected:
	bool m_status;

	int32_t m_virtualkey_code;

	std::chrono::high_resolution_clock::time_point m_timepoint;

	uint32_t m_activation_delay; // always in ms

	bool m_was_activated;

	std::wstring m_name;

	bool m_print_status;

	bool m_should_draw;
};

```

`Cheat/cheat.hpp`:

```hpp
#pragma once

#include <vector>
#include <memory>
#include "Feature/feature.hpp"

class cheat
{

public:

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets up the features by creating the instances and adding them to the internal features vector.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	virtual bool setup_features() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets up the offsets.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	virtual bool setup_offsets() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Runs the cheats logic, highly individual.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void run() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Shuts down the cheat and frees any resources it is using, highly individual.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void shutdown() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Print the offsets used by the cheat.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void print_offsets() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Print the features of the cheat.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void print_features() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the size of the internal features vector, tells how many features are in the cheat.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The features size.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline size_t get_features_size() const noexcept
	{
		return this->m_features.size();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets a pointer to the internal vector of features.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the vector of features as pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::vector< std::unique_ptr< feature > > * get_features_as_ptr() noexcept
	{
		return &this->m_features;
	}

protected:

	std::vector< std::unique_ptr < feature > > m_features;
};
```

`Includings/custom_data_types.hpp`:

```hpp
#pragma once

#include <vector>
#include <cstddef>

using byte_vector = std::vector< std::byte >;

#ifndef WILDCARD_BYTE
#define WILDCARD_BYTE 0xCC
#endif

```

`Includings/modules.hpp`:

```hpp
#pragma once

#include "../Memory/Process/process.hpp"

#include "../Testing/test_overlay.hpp"

#include "../Testing/test_cheat.hpp"

///-------------------------------------------------------------------------------------------------
// namespace: Modules
//
// summary:	This namespace contains Implementations of the cheat, overlay and process.
//			Personally I use this, so I don't have to implement for every cheat again. I just put the Testing folder on .gitignore :D
///-------------------------------------------------------------------------------------------------

namespace Modules
{
	inline std::unique_ptr< process > g_pProcess = std::make_unique< process >();

	inline std::unique_ptr< test_overlay > g_pOverlay = std::make_unique< test_overlay >();

	inline std::unique_ptr< test_cheat > g_pCheat = std::make_unique< test_cheat >();
}

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`Memory/Hook/hook.hpp`:

```hpp
#pragma once

#include <cstdint>

#include <vector>

class hook
{

public:

	///-------------------------------------------------------------------------------------------------
	/// <summary>Default constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	hook() :
		m_start_address( std::uintptr_t() ),
		m_allocated_page_address( std::uintptr_t() ),
		m_hook_size( size_t() ),
		m_shellcode( {} ),
		m_original_bytes( {} )
	{}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="start">		The start address where the hook will be placed.</param>
	/// <param name="page">			The address of the allocated memory page, needed for freeing it later.</param>
	/// <param name="size">			The number of bytes which were overwritten.</param>
	/// <param name="shellcode">	The shellcode as a vector of bytes.</param>
	/// <param name="original"> 	The original bytes, which were overwritten by the hook instructions, as a vector of bytes.</param>
	///-------------------------------------------------------------------------------------------------

	hook( 
		const std::uintptr_t start,
		const std::uintptr_t page,
		const size_t size, 
		const std::vector< uint8_t >& shellcode, 
		const std::vector< uint8_t >& original 
	) :
		m_start_address( start ),
		m_allocated_page_address( page ),
		m_hook_size( size ),
		m_shellcode( shellcode ),
		m_original_bytes( original )
	{}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the hook address, where the mid function hook was placed inside the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The hook address.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::uintptr_t get_hook_address() const noexcept
	{
		return this->m_start_address;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the address of the allocated page inside the target process, where the shellcode was placed.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The address of the allocated page.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::uintptr_t get_allocated_page_address() const noexcept
	{
		return this->m_allocated_page_address;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the size of the hook in bytes, also tells how many bytes were overwritten in the original function.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The size of the hook in bytes.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline size_t get_hook_size() const noexcept
	{
		return this->m_hook_size;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets a pointer to the shellcode, which is an vector of bytes.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The pointer to the shellcode.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline auto get_shellcode_ptr() noexcept
	{
		return &this->m_shellcode;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets a pointer to the original bytes, which is an vector of bytes.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The original bytes pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline auto get_original_bytes_ptr() noexcept
	{
		return &this->m_original_bytes;
	}

protected:

	std::uintptr_t m_start_address;
	std::uintptr_t m_allocated_page_address;

	size_t m_hook_size;

	std::vector< uint8_t > m_shellcode;
	std::vector< uint8_t > m_original_bytes;
};
```

`Memory/Image_x64/image_x64.cpp`:

```cpp
#include "image_x64.hpp"


std::uintptr_t image_x64::find_pattern(const std::wstring& pattern, const bool should_be_relative)
{
	// Old code, maybe I will rewrite it in the future

	std::vector< uint8_t > m_vecPattern;

	std::string         Temp = std::string();

	std::string         strPattern = std::string(pattern.begin(), pattern.end());
	strPattern.erase(std::remove_if(strPattern.begin(), strPattern.end(), isspace), strPattern.end());

	// Convert string pattern to byte pattern
	for (size_t i = 0; i < strPattern.length(); i++)
	{
		if (strPattern.at(i) == '?')
		{
			m_vecPattern.emplace_back(WILDCARD_BYTE);
			continue;
		}

		if (Temp.length() != 2)
			Temp += strPattern.at(i);

		if (Temp.length() == 2)
		{
			Temp.erase(std::remove_if(Temp.begin(), Temp.end(), isspace), Temp.end());
			auto converted_pattern_byte = strtol(Temp.c_str(), nullptr, 16) & 0xFFF;
			m_vecPattern.emplace_back(converted_pattern_byte);
			Temp.clear();
		}
	}
	const auto vector_size = m_vecPattern.size();

	// m_vecPattern contains now the converted byte pattern
	// Search now the memory area

	bool			 found = false;
	std::uintptr_t   found_addr = 0;

	for (std::uintptr_t current_addr = 0; current_addr < this->m_bytes.size(); current_addr++)
	{
		if (found)
			break;

		for (uint8_t i = 0; i < vector_size; i++)
		{
			const auto current_byte = this->m_bytes.at(current_addr + i);

			const auto pattern_byte = m_vecPattern.at(i);

			if (static_cast<uint8_t>(pattern_byte) == WILDCARD_BYTE)
			{
				if (i == vector_size - 1)
				{
					found = true;
					found_addr = current_addr;
					break;
				}
				continue;
			}

			if (static_cast<uint8_t>(current_byte) != pattern_byte)
				break;

			if (i == vector_size - 1)
			{
				found_addr = current_addr;
				found = true;
			}
		}
	}

	// if nothing was found, just return found_addr which will contain 0
	if (!found_addr)
		return found_addr;

	return should_be_relative ? found_addr : this->m_base + found_addr;
}

```

`Memory/Image_x64/image_x64.hpp`:

```hpp
#pragma once

#include <format>
#include <cstdint>
#include <string>
#include <Windows.h>
#include "../../Includings/custom_data_types.hpp"

class image_x64
{

public:

	///-------------------------------------------------------------------------------------------------
	/// <summary>Default constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	image_x64()
	{
		this->m_base = std::uintptr_t();

		this->m_size = size_t();

		this->m_bytes = byte_vector();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_base">	The image base.</param>
	/// <param name="image_size">	Size of the image.</param>
	///-------------------------------------------------------------------------------------------------

	image_x64(const std::uintptr_t image_base, const size_t image_size)
	{
		this->m_base = image_base;

		this->m_size = image_size;

		this->m_bytes = byte_vector();
		this->m_bytes.resize(image_size);
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets image base.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The image base.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::uintptr_t get_image_base() const noexcept
	{
		return this->m_base;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets image size.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The image size.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline size_t get_image_size() const noexcept
	{
		return this->m_size;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Queries if the byte vector is empty.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if the byte vector is empty, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool is_byte_vector_empty() const noexcept
	{
		return this->m_bytes.empty();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets a pointer to the byte vector, where all bytes from the dumped image are stored.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the byte vector pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline byte_vector* get_byte_vector_ptr() noexcept
	{
		return &this->m_bytes;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets pointer to first byte of the byte vector, where all bytes from the dumped image are stored.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the pointer to first byte of the byte vector.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::byte* get_ref_to_first_byte() noexcept
	{
		// make sure that the vector isn't empty, so no exception can occur
		if (this->m_bytes.empty())
			return nullptr;

		return &this->m_bytes.front();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Checks if the dumped image is an executable, by checking if the MZ signature is valid.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if executable, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool is_executable() const noexcept
	{
		if (this->m_bytes.size() < 2)
			return false;

		// how does this even work with using "constexpr"?
		// If you have a answer to my question, I would be very happy if you write me a quick mail - thanks! :)
		constexpr uint16_t MZ_SIGNATURE = 0x5A4D;

		return std::memcmp(reinterpret_cast<LPCVOID>(&this->m_bytes.at(0)), reinterpret_cast<LPCVOID>(&MZ_SIGNATURE), sizeof(std::byte) * 2) == 0;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets dos header pointer of the current image. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	The dos header pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline PIMAGE_DOS_HEADER get_dos_header_ptr() noexcept
	{
		if (this->m_bytes.size() < sizeof(IMAGE_DOS_HEADER))
			return nullptr;

		const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(this->m_bytes.data());

		if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
			return nullptr;

		return dos_header;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets NT headers pointer of the current image. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	The NT headers pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline PIMAGE_NT_HEADERS get_nt_headers_ptr() noexcept
	{
		const auto dos_header = this->get_dos_header_ptr();

		if (!dos_header)
			return nullptr;

		if (this->m_bytes.size() < sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS))
			return nullptr;

		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(this->m_bytes.data() + dos_header->e_lfanew);

		if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
			return nullptr;

		return nt_headers;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets import descriptor of the current image. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	The import descriptor pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline PIMAGE_IMPORT_DESCRIPTOR get_import_descriptor() noexcept
	{
		const auto nt_headers = this->get_nt_headers_ptr();

		if (!nt_headers)
			return nullptr;

		return reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(this->m_bytes.data() + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Parses the Import Address Table (IAT) of the current image and retrieves the imports. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	Returns an std::vector with the image name, function name and function ptr of all entries in the IAT. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline auto get_imports() noexcept
	{
		std::vector< std::tuple< std::string, std::string, std::uintptr_t > > ret = {};

		auto id = this->get_import_descriptor();

		if (!id)
			return ret;

		while (id->Name)
		{
			const auto module_name = std::string(reinterpret_cast<char*>(this->m_bytes.data() + id->Name));

			if (module_name.empty())
			{
				++id;

				continue;
			}

			auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(this->m_bytes.data() + id->FirstThunk);

			auto orig_thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(this->m_bytes.data() + id->OriginalFirstThunk);

			while (thunk->u1.AddressOfData)
			{
				std::string import_name = {};

				if (thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
				{
					// weird fix for handling incorrect values in orig_thunk like e.g.: 0x8000000000000008, 0x8000000000000005 etc.
					// need to do more research what this means and why this happens
					if (orig_thunk->u1.Ordinal && !(orig_thunk->u1.Ordinal & 0x8000000000000000))
						import_name = std::to_string(IMAGE_ORDINAL(orig_thunk->u1.Ordinal));
				}
				else
				{
					// weird fix for handling incorrect values in orig_thunk like e.g.: 0x8000000000000008, 0x8000000000000005 etc.
					if( orig_thunk->u1.AddressOfData && !(orig_thunk->u1.AddressOfData & 0x8000000000000000))
						import_name = std::string(reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(this->m_bytes.data() + orig_thunk->u1.AddressOfData)->Name);
				}

				if( !import_name.empty())
					ret.emplace_back(
						module_name, 
						import_name,
						thunk->u1.Function
					);

				++thunk;
				++orig_thunk;
			}
			++id;
		}

		return ret;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Searches for an byte pattern in the vector of bytes from the dumped image.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="pattern">			 	Specifies the pattern.</param>
	/// <param name="should_be_relative">	(Optional) True if the result address should be relative.</param>
	///
	/// <returns>The first found pattern match address.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::uintptr_t find_pattern(const std::wstring& pattern, const bool should_be_relative = true);

	///-------------------------------------------------------------------------------------------------
	/// <summary> This function is used for dereferencing the bytes from the byte_vector. </summary>
	///
	/// <typeparam name="T">	The type which will determine the return type and the size of the memcpy. </typeparam>
	/// <param name="address">	The address which will be deferenced, make sure this isn't relative but absolute (image base + offset). </param>
	/// <param name="size">   	(Optional) The size which will be used in the std::memcpy call. </param>
	///
	/// <returns> A Buffer of the determined type, holding the specific bytes at the given address of the image. </returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	[[nodiscard]] inline T deref_address(const std::uintptr_t address, const size_t size = sizeof(T))
	{
		// make sure address is in range of the image
		if (address < this->m_base || address > this->m_base + this->m_size)
			return T();

		T buffer = T();

		memcpy(&buffer, reinterpret_cast<LPCVOID>(&this->m_bytes.at(address - this->m_base)), size);

		return buffer;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>This functions prints a hexdump of the memory region to the console.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="start_addr">	   	The start address of the dump.</param>
	/// <param name="size">			   	The number of bytes, which should be dumped.</param>
	/// <param name="is_absolute_addr">	True if the address on the left should be absolute, false if not.</param>
	///-------------------------------------------------------------------------------------------------

	void print_memory_region( const std::uintptr_t start_addr, const size_t size, const bool is_absolute_addr )
	{
		if ( start_addr < 0 || start_addr > this->m_base + this->m_size )
			return;

		std::string left_side = {};
		std::string right_side = {};

		for ( uint32_t idx = 0; idx < size; idx += 16 )
		{
			// now loop through the buffer and prepare both sides
			for ( uint32_t j = 0; j < 16; j++ )
			{
				const auto current_byte = ( is_absolute_addr ) ? this->m_bytes.at( start_addr + idx + j - this->m_base ) : this->m_bytes.at( start_addr + idx + j );

				// prepare left side, which is the hex bytes
				if ( j != 15 )
					left_side += std::format( "{:02X} ", static_cast< uint8_t >( current_byte ) );
				else
					left_side += std::format( "{:02X}", static_cast< uint8_t >( current_byte ) );

				// prepare right side, which should be ascii chars etc
				const auto rs_value = static_cast< uint8_t >( current_byte );

				right_side += std::format( "{} ", ( rs_value >= 33 && rs_value < 127 ) ? static_cast< char >( rs_value ) : static_cast< char >( 46 ) );
			}

			// print now the current line and a newline
			printf( "%-25s | %s\n", left_side.c_str(), right_side.c_str() );

			// reset now both side strings
			left_side = "";
			right_side = "";
		}
	}

private:
	std::uintptr_t m_base;

	size_t m_size;

	byte_vector m_bytes;
};

```

`Memory/Image_x86/image_x86.cpp`:

```cpp
#include "image_x86.hpp"

std::uintptr_t image_x86::find_pattern(const std::wstring& pattern, const bool should_be_relative )
{
	// Old code, maybe I will rewrite it in the future

	std::vector< uint8_t > m_vecPattern;

	std::string         Temp = std::string();

	std::string         strPattern = std::string(pattern.begin(), pattern.end());
	strPattern.erase(std::remove_if(strPattern.begin(), strPattern.end(), isspace), strPattern.end());

	// Convert string pattern to byte pattern
	for (size_t i = 0; i < strPattern.length(); i++)
	{
		if (strPattern.at(i) == '?')
		{
			m_vecPattern.emplace_back(WILDCARD_BYTE);
			continue;
		}

		if (Temp.length() != 2)
			Temp += strPattern.at(i);

		if (Temp.length() == 2)
		{
			Temp.erase(std::remove_if(Temp.begin(), Temp.end(), isspace), Temp.end());
			auto converted_pattern_byte = strtol(Temp.c_str(), nullptr, 16) & 0xFFF;
			m_vecPattern.emplace_back(converted_pattern_byte);
			Temp.clear();
		}
	}
	const auto vector_size = m_vecPattern.size();

	// m_vecPattern contains now the converted byte pattern
	// Search now the memory area

	bool			 found = false;
	std::uintptr_t   found_addr = 0;

	for (std::uintptr_t current_addr = 0; current_addr < this->m_bytes.size(); current_addr++)
	{
		if (found)
			break;

		for (uint8_t i = 0; i < vector_size; i++)
		{
			const auto current_byte = this->m_bytes.at(current_addr + i);

			const auto pattern_byte = m_vecPattern.at(i);

			if (static_cast<uint8_t>(pattern_byte) == WILDCARD_BYTE)
			{
				if (i == vector_size - 1)
				{
					found = true;
					found_addr = current_addr;
					break;
				}
				continue;
			}

			if (static_cast<uint8_t>(current_byte) != pattern_byte)
				break;

			if (i == vector_size - 1)
			{
				found_addr = current_addr;
				found = true;
			}
		}
	}

	// if nothing was found, just return found_addr which will contain 0
	if (!found_addr)
		return found_addr;

	return should_be_relative ? found_addr : this->m_base + found_addr;
}

std::vector< std::uintptr_t > image_x86::find_all_pattern_occurences( const std::wstring& pattern, const bool should_be_relative )
{
	// Old code, maybe I will rewrite it in the future

	std::vector< uint8_t > m_vecPattern;

	std::string         Temp = std::string();

	std::string         strPattern = std::string(pattern.begin(), pattern.end());
	strPattern.erase( std::remove_if( strPattern.begin(), strPattern.end(), isspace), strPattern.end() );

	// Convert string pattern to byte pattern
	for ( size_t i = 0; i < strPattern.length(); i++ )
	{
		if ( strPattern.at( i ) == '?' )
		{
			m_vecPattern.emplace_back( WILDCARD_BYTE );
			continue;
		}

		if ( Temp.length() != 2 )
			Temp += strPattern.at( i );

		if ( Temp.length() == 2 )
		{
			Temp.erase( std::remove_if( Temp.begin(), Temp.end(), isspace ), Temp.end() );
			auto converted_pattern_byte = strtol( Temp.c_str(), nullptr, 16 ) & 0xFFF;
			m_vecPattern.emplace_back( converted_pattern_byte );
			Temp.clear();
		}
	}
	const auto vector_size = m_vecPattern.size();

	// m_vecPattern contains now the converted byte pattern
	// Search now the memory area

	bool			 found = false;
	std::vector< std::uintptr_t >   found_addresses = {};

	for ( std::uintptr_t current_addr = 0; current_addr < this->m_bytes.size(); current_addr++ )
	{

		for ( uint8_t i = 0; i < vector_size; i++ )
		{
			const auto current_byte = this->m_bytes.at( current_addr + i );

			const auto pattern_byte = m_vecPattern.at( i );

			if ( static_cast< uint8_t >( pattern_byte ) == WILDCARD_BYTE )
			{
				if ( i == vector_size - 1 )
				{
					found_addresses.push_back( should_be_relative ? current_addr : this->m_base + current_addr );
					
					current_addr += i;

					break;
				}
				continue;
			}

			if ( static_cast< uint8_t >( current_byte ) != pattern_byte )
				break;

			if ( i == vector_size - 1 )
			{
				found_addresses.push_back( should_be_relative ? current_addr : this->m_base + current_addr );

				break;
			}
		}
	}

	// if nothing was found, just return the empty vector
	if ( found_addresses.empty() )
		return found_addresses;

	return found_addresses;
}

```

`Memory/Image_x86/image_x86.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <Windows.h>
#include <format>

#include "../../Includings/custom_data_types.hpp"

class image_x86
{

public:

	///-------------------------------------------------------------------------------------------------
	/// <summary>Default constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	image_x86()
	{
		this->m_base = std::uintptr_t();

		this->m_size = size_t();

		this->m_bytes = byte_vector();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_base">	The image base.</param>
	/// <param name="image_size">	Size of the image.</param>
	///-------------------------------------------------------------------------------------------------

	image_x86(const std::uintptr_t image_base, const size_t image_size)
	{
		this->m_base = image_base;

		this->m_size = image_size;

		this->m_bytes = byte_vector();
		this->m_bytes.reserve(image_size);
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets image base.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The image base.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::uintptr_t get_image_base() const noexcept
	{
		return this->m_base;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets image size.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The image size.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline size_t get_image_size() const noexcept
	{
		return this->m_size;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Queries if the byte vector is empty.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if the byte vector is empty, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool is_byte_vector_empty() const noexcept
	{
		return this->m_bytes.empty();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets a pointer to the byte vector, where all bytes from the dumped image are stored.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the byte vector pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline byte_vector* get_byte_vector_ptr() noexcept
	{
		return &this->m_bytes;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets pointer to first byte of the byte vector, where all bytes from the dumped image are stored.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the pointer to first byte of the byte vector.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::byte* get_ref_to_first_byte() noexcept
	{
		// make sure that the vector isn't empty, so no exception can occur
		if (this->m_bytes.empty())
			return nullptr;

		return &this->m_bytes.front();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Checks if the dumped image is an executable, by checking if the MZ signature is valid.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if executable, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline bool is_executable() const noexcept
	{
		if (this->m_bytes.size() < 2)
			return false;

		// how does this even work with using "constexpr"?
		// If you have a answer to my question, I would be very happy if you write me a quick mail - thanks! :)
		constexpr uint16_t MZ_SIGNATURE = 0x5A4D;

		return std::memcmp(reinterpret_cast<LPCVOID>(&this->m_bytes.at(0)), reinterpret_cast<LPCVOID>(&MZ_SIGNATURE), sizeof(std::byte) * 2) == 0;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Searches for an byte pattern in the vector of bytes from the dumped image.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="pattern">			 	Specifies the pattern.</param>
	/// <param name="should_be_relative">	(Optional) True if the result address should be relative.</param>
	///
	/// <returns>The first found pattern match address.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::uintptr_t find_pattern(const std::wstring& pattern, const bool should_be_relative = true );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Searches for all byte pattern occurences inside the dumped image.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="pattern">			 	Specifies the pattern.</param>
	/// <param name="should_be_relative">	(Optional) True if the result addresses should be relative.</param>
	///
	/// <returns>An vector of addresses where the byte pattern could be matched inside the dumped image.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::vector< std::uintptr_t > find_all_pattern_occurences( const std::wstring& pattern, const bool should_be_relative = true );

	///-------------------------------------------------------------------------------------------------
	/// <summary> This function is used for dereferencing the bytes from the byte_vector. </summary>
	///
	/// <typeparam name="T">	The type which will determine the return type and the size of the memcpy. </typeparam>
	/// <param name="address">	The address which will be deferenced, make sure this isn't relative but absolute (image base + offset). </param>
	/// <param name="size">   	(Optional) The size which will be used in the std::memcpy call. </param>
	///
	/// <returns> A Buffer of the determined type, holding the specific bytes at the given address of the image. </returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	[[nodiscard]] inline T deref_address( const std::uintptr_t address, const size_t size = sizeof( T ) )
	{
		// make sure address is in range of the image
		if ( address < this->m_base || address > this->m_base + this->m_size )
			return T();

		T buffer = T();

		memcpy( &buffer, reinterpret_cast< LPCVOID >( &this->m_bytes.at( address - this->m_base ) ), size );

		return buffer;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Reads an nullterminated string from an address inside the image.</summary>
	///
	/// <remarks>cragson, 12/17/21.</remarks>
	///
	/// <param name="address">	  	The address of the string inside the image.</param>
	/// <param name="is_relative">	(Optional) If the address is absolute (base+offset) or is relative (offset). By default this parameter is false.</param>
	///
	/// <returns>The string read from the address.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline std::string read_string_from_address( const std::uintptr_t address, const bool is_relative = false )
	{
		if( address < this->m_base || address > this->m_base + this->m_size )
			return "OSMIUM_INVALID_ADDRESS";

		std::string ret = {};

		char c = {};

		auto stringptr = is_relative
		? this->deref_address< std::uintptr_t >( address )
		: this->deref_address< std::uintptr_t >( address - this->m_base );

		while( ( c = this->deref_address< char >( stringptr++ ) ) != '\0'  )
			ret += c;

		return ret;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>This functions prints a hexdump of the memory region to the console.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="start_addr">	   	The start address of the dump.</param>
	/// <param name="size">			   	The number of bytes, which should be dumped.</param>
	/// <param name="is_absolute_addr">	True if the address on the left should be absolute, false if not.</param>
	///-------------------------------------------------------------------------------------------------

	void print_memory_region( const std::uintptr_t start_addr, const size_t size, const bool is_absolute_addr ) const
	{
		if ( start_addr < 0 || start_addr > this->m_base + this->m_size )
			return;

		std::string left_side = {};
		std::string right_side = {};

		for ( uint32_t idx = 0; idx < size; idx += 16 )
		{
			// now loop through the buffer and prepare both sides
			for ( uint32_t j = 0; j < 16; j++ )
			{
				const auto current_byte = ( is_absolute_addr ) ? this->m_bytes.at( start_addr + idx + j - this->m_base ) : this->m_bytes.at( start_addr + idx + j );
				
				// prepare left side, which is the hex bytes
				if (j != 15)
					left_side += std::format("{:02X} ", static_cast<uint8_t>(current_byte));
				else
					left_side += std::format("{:02X}", static_cast<uint8_t>(current_byte));

				// prepare right side, which should be ascii chars etc
				const auto rs_value = static_cast< uint8_t >(current_byte);

				right_side += std::format("{} ", (rs_value >= 33 && rs_value < 127) ? static_cast<char>(rs_value) : static_cast<char>(46));
			}

			// print now the current line and a newline
			printf( "0x%0X | %-32s | %s\n", start_addr + idx, left_side.c_str(), right_side.c_str() );

			// reset now both side strings
			left_side = "";
			right_side = "";
		}
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets dos header pointer of the current image. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	The dos header pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline PIMAGE_DOS_HEADER get_dos_header_ptr() noexcept
	{
		if (this->m_bytes.size() < sizeof(IMAGE_DOS_HEADER))
			return nullptr;

		const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(this->m_bytes.data());

		if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
			return nullptr;

		return dos_header;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets NT headers pointer of the current image. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	The NT headers pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline PIMAGE_NT_HEADERS get_nt_headers_ptr() noexcept
	{
		const auto dos_header = this->get_dos_header_ptr();

		if (!dos_header)
			return nullptr;

		if (this->m_bytes.size() < sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS))
			return nullptr;

		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(this->m_bytes.data() + dos_header->e_lfanew);

		if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
			return nullptr;

		return nt_headers;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets import descriptor of the current image. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	The import descriptor pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline PIMAGE_IMPORT_DESCRIPTOR get_import_descriptor() noexcept
	{
		const auto nt_headers = this->get_nt_headers_ptr();

		if (!nt_headers)
			return nullptr;

		return reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(this->m_bytes.data() + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Parses the Import Address Table (IAT) of the current image and retrieves the imports. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <returns>	Returns an std::vector with the image name, function name and function ptr of all entries in the IAT. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline auto get_imports() noexcept
	{
		std::vector< std::tuple< std::string, std::string, std::uintptr_t > > ret = {};

		auto id = this->get_import_descriptor();

		if (!id)
			return ret;

		while (id->Name)
		{
			const auto module_name = std::string(reinterpret_cast<char*>(this->m_bytes.data() + id->Name));

			if (module_name.empty())
			{
				++id;

				continue;
			}

			auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(this->m_bytes.data() + id->FirstThunk);

			auto orig_thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(this->m_bytes.data() + id->OriginalFirstThunk);

			while (thunk->u1.AddressOfData)
			{
				const auto import_name = thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG
					? std::to_string(IMAGE_ORDINAL(orig_thunk->u1.Ordinal))
					: std::string(reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(this->m_bytes.data() + orig_thunk->u1.AddressOfData)->Name);

				ret.emplace_back(
					module_name,
					import_name,
					thunk->u1.Function
				);

				++thunk;
				++orig_thunk;
			}
			++id;
		}

		return ret;
	}


private:
	std::uintptr_t m_base;

	size_t m_size;

	byte_vector m_bytes;
};

```

`Memory/Process/process.cpp`:

```cpp
#include "process.hpp"
#include <TlHelp32.h>
#include <algorithm>

struct window_cb_args
{
	DWORD target_pid;
	HWND target_hwnd;
};

BOOL CALLBACK hwnd_cb( HWND hWnd, LPARAM lparam )
{
	DWORD pid = DWORD();

	GetWindowThreadProcessId( hWnd, &pid );

	const auto args = reinterpret_cast< window_cb_args* >( lparam );

	if( pid == args->target_pid )
	{
		args->target_hwnd = hWnd;

		return FALSE;
	}

	return TRUE;
};

bool process::refresh_image_map()
{
	MODULEENTRY32 me32 = { sizeof( MODULEENTRY32 ) };

	const auto snapshot_handle = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, this->m_pid );
	if( !snapshot_handle || snapshot_handle == INVALID_HANDLE_VALUE )
		return false;

	// after successfully retrieving my snapshot handle, I clear the map - to get rid of the old images + information
	this->m_images.clear();

	if( Module32First( snapshot_handle, &me32 ) )
	{
		do
		{
			// check first if the image name already exists, as a key, in the map
			// if so, just skip the certain image
			if( this->m_images.contains( me32.szModule ) )
				continue;

			const auto image_base = reinterpret_cast< std::uintptr_t >( me32.modBaseAddr );
			const auto image_size = static_cast< size_t >( me32.modBaseSize );

			// create a new object for the image name, which is the key for the map
#ifdef _WIN64
			this->m_images[me32.szModule] = std::make_unique< image_x64 >( image_base, image_size );
#else
			this->m_images[ me32.szModule ] = std::make_unique< image_x86 >( image_base, image_size );
#endif
			// now dump the image from memory and write it into the specific byte_vector
			// if the image could not be read, like RPM sets 299 as the error code
			// the image will be removed from the map
			// smart ptr should take care of collecting the garbage
			if( !this->read_image( this->m_images[ me32.szModule ]->get_byte_vector_ptr(), me32.szModule ) )
				this->m_images.erase( me32.szModule );
		}
		while( Module32Next( snapshot_handle, &me32 ) );
	}

	// make sure to close the handle 
	CloseHandle( snapshot_handle );

	return true;
}


bool process::setup_process( const std::wstring& process_identifier, const bool is_process_name )
{
	if( process_identifier.empty() )
		return false;

	auto window_handle = HWND();
	auto buffer = DWORD();
	auto proc_handle = INVALID_HANDLE_VALUE;

	// if the given process identifier is not a process name but a window title 
	// try to retrieve a window handle, the process id and a handle to the process with specific rights.
	if( !is_process_name )
	{
		window_handle = FindWindowW( nullptr, process_identifier.c_str() );
		if( !window_handle )
			return false;

		if( !GetWindowThreadProcessId( window_handle, &buffer ) )
			return false;

		proc_handle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, buffer );
		if( !proc_handle )
			return false;
	}
	// if the process identifier is a process name
	// use it for retrieving the process id first
	else
	{
		// Some quick note: Cz the project is lacking some proper documentation I want to describe the behaviour of the method here a bit better
		// I want to iterate above the different process entries and search for the first entry which matches my identifier
		// I take the PID from the first match and retrieve the window and process handle from it
		const auto snapshot_handle = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );
		if( !snapshot_handle )
			return false;

		auto pe32 = PROCESSENTRY32();
		pe32.dwSize = sizeof( PROCESSENTRY32 );

		if( Process32First( snapshot_handle, &pe32 ) )
		{
			do
			{
				if( const auto wprocess_name = std::wstring( pe32.szExeFile ); wprocess_name == process_identifier )
				{
					buffer = pe32.th32ProcessID;

					break;
				}
			}
			while( Process32Next( snapshot_handle, &pe32 ) );
		}
		else
			return false;

		// now I got the pid and I need to open a handle to the process
		proc_handle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, buffer );
		if( !proc_handle )
			return false;

		// prevent leaking the handle
		CloseHandle( snapshot_handle );

		// The last needed thing is the window handle
		window_cb_args args = { buffer, HWND() };

		EnumWindows( hwnd_cb, reinterpret_cast< LPARAM >( &args ) );

		if( !args.target_hwnd )
			return false;

		// Now I can go out of the else block and just let the values be set
		window_handle = args.target_hwnd;
	}

	// set now the correct data
	// Because refresh_image_map will call RPM which uses m_handle
	this->m_hwnd = window_handle;
	this->m_pid = buffer;
	this->m_handle = proc_handle;

	// Before I set the retrieved data, I want to safe information about every image in the process
	// So I iterate over every image loaded into the certain process and store them :)
	if( !this->refresh_image_map() )
	{
		// because I need the correct handle in this function, I need to take care of the case where the handle is correct but images cannot be dumped
		// so clear the retrieved data about the process here, if the function fails
		this->m_hwnd = nullptr;
		this->m_pid = 0;
		this->m_handle = INVALID_HANDLE_VALUE;

		return false;
	}

	return true;
}


bool process::setup_process( const DWORD process_id )
{
	// try to open a handle to the process 
	const auto handle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, process_id );

	if( !handle )
		return false;

	// now I got the valid handle, I try to receive a handle to the main window of the process
	window_cb_args args = { process_id, HWND() };

	EnumWindows( hwnd_cb, reinterpret_cast< LPARAM >( &args ) );

	if( !args.target_hwnd )
		return false;

	// set now the correct data
	this->m_hwnd = args.target_hwnd;

	this->m_pid = process_id;

	this->m_handle = handle;

	// Before I set the retrieved data, I want to safe information about every image in the process
	// So I iterate over every image loaded into the certain process and store them :)
	if( !this->refresh_image_map() )
	{
		// because I need the correct handle in this function, I need to take care of the case where the handle is correct but images cannot be dumped
		// so clear the retrieved data about the process here, if the function fails
		this->m_hwnd = nullptr;
		this->m_pid = 0;
		this->m_handle = INVALID_HANDLE_VALUE;

		return false;
	}

	return true;
}

bool process::patch_bytes( const byte_vector& bytes, const std::uintptr_t address, const size_t size )
{
	if( bytes.empty() || !address || !size || bytes.size() > size )
		return false;

	DWORD buffer = 0;

	if( !VirtualProtectEx(
		this->m_handle,
		reinterpret_cast< LPVOID >( address ),
		size,
		PAGE_EXECUTE_READWRITE,
		&buffer
	) )
		return false;

	for( size_t i = 0; i < size; i++ )
		this->write< byte >( address + i, 0x90 );

	for( size_t i = 0; i < bytes.size(); i++ )
		this->write< std::byte >( address + i, bytes.at( i ) );

	if( !VirtualProtectEx( this->m_handle, reinterpret_cast< LPVOID >( address ), size, buffer, &buffer ) )
		return false;

	return true;
}


bool process::patch_bytes( const std::byte bytes[ ], const std::uintptr_t address, const size_t size )
{
	if( !address || !size )
		return false;

	DWORD buffer = 0;

	if( !VirtualProtectEx(
		this->m_handle,
		reinterpret_cast< LPVOID >( address ),
		size,
		PAGE_EXECUTE_READWRITE,
		&buffer
	) )
		return false;

	for( size_t i = 0; i < size; i++ )
		this->write< std::byte >( address + i, bytes[ i ] );

	if( !VirtualProtectEx( this->m_handle, reinterpret_cast< LPVOID >( address ), size, buffer, &buffer ) )
		return false;

	return true;
}


bool process::nop_bytes( const std::uintptr_t address, const size_t size )
{
	if( !address || !size )
		return false;

	DWORD buffer = 0;

	if( !VirtualProtectEx(
		this->m_handle,
		reinterpret_cast< LPVOID >( address ),
		size,
		PAGE_EXECUTE_READWRITE,
		&buffer
	) )
		return false;

	for( size_t i = 0; i < size; i++ )
		this->write< byte >( address + i, 0x90 );

	if( !VirtualProtectEx( this->m_handle, reinterpret_cast< LPVOID >( address ), size, buffer, &buffer ) )
		return false;

	return true;
}

bool process::read_image( byte_vector* dest_vec, const std::wstring& image_name ) const
{
	if( !dest_vec || image_name.empty() || !this->does_image_exist_in_map( image_name ) )
		return false;

	// here should no exception occur, because I checked above if the image exists in the map
	const auto image = this->m_images.at( image_name ).get();

	// clear the vector and make sure the vector has the correct size
	dest_vec->clear();
	dest_vec->resize( image->get_image_size() );

	return ReadProcessMemory(
		this->m_handle,
		reinterpret_cast< LPCVOID >( image->get_image_base() ),
		dest_vec->data(),
		image->get_image_size(),
		nullptr
	) != 0;
}

bool process::create_hook_x86( const std::uintptr_t start_address, const size_t size,
                               const std::vector< uint8_t >& shellcode )
{
	if( start_address < 0 || size < 5 || shellcode.empty() )
		return false;

	// allocate a read-write-execute memory page in the target process
	const auto rwx_page = this->allocate_rwx_page_in_process( shellcode.size() > 4096 ? shellcode.size() : 4096 );

	if( !rwx_page )
		return false;

	// copy now the shellcode into the allocated memory page in the target process
	if( !WriteProcessMemory(
		this->m_handle,
		rwx_page,
		&shellcode.front(),
		shellcode.size(),
		nullptr
	) )
		return false;

	// calculate now the jump address back after the hook
	const DWORD jmp_back_addr = ( start_address + size ) - ( reinterpret_cast< std::uintptr_t >( rwx_page ) + shellcode.
		size() + 5 );

	// Place now the jmp instruction + address into the allocated page, which will jmp back to the hooked function (after the jmp to the hook)
	if( !this->write< uint8_t >( reinterpret_cast< std::uintptr_t >( rwx_page ) + shellcode.size(), 0xE9 ) )
		return false;

	if( !this->write< DWORD >( reinterpret_cast< std::uintptr_t >( rwx_page ) + shellcode.size() + 1, jmp_back_addr ) )
		return false;

	// the new memory page was allocated, the hook bytes were copied into it and the jmp back to the hooked function was done
	// now the original function needs to be hooked
	// buf before hooking I need to save the original bytes of the hooked function, which will be overwritten by the JMP instruction
	std::vector< uint8_t > original_bytes;

	// allocate space for the vector which will contain the original bytes
	original_bytes.resize( size );

	// read now the original bytes
	if( !ReadProcessMemory(
		this->m_handle,
		reinterpret_cast< LPCVOID >( start_address ),
		original_bytes.data(),
		size,
		nullptr
	) )
		return false;

	// change now the page protection of the hooked function
	DWORD buffer = 0;

	if( !VirtualProtectEx(
		this->m_handle,
		reinterpret_cast< LPVOID >( start_address ),
		size,
		PAGE_EXECUTE_READWRITE,
		&buffer
	) )
		return false;

	// before I write my hook I want to make sure all bytes, which will be overwritten are NOPed
	// because if the hook size is not equal with the size of the jmp + address I will have left over bytes which will do me dirty
	if( size > 5 )
	{
		for( auto idx = 0; idx < size; idx++ )
			this->write< uint8_t >( start_address + idx, 0x90 );
	}

	// write now the JMP instruction + the address to the hook function where the shellcode lies
	if( !this->write< uint8_t >( start_address, 0xE9 ) )
		return false;

	// calculate now the jump adress to the allocated memory from the hooked function
	const DWORD jmp_to_hook = ( reinterpret_cast< std::uintptr_t >( rwx_page ) ) - ( start_address + 5 );

	// write now the jump address after the jmp instruction in the hooked function
	if( !this->write< DWORD >( start_address + 1, jmp_to_hook ) )
		return false;

	// set now the old page protection, where the hooked function lies
	if( !VirtualProtectEx(
		this->m_handle,
		reinterpret_cast< LPVOID >( start_address ),
		size,
		buffer,
		&buffer
	) )
		return false;

	// now hopefully was all this done:
	// rwx memory page allocated
	// shellcode copied to memory page
	// jmp placed with address that points right after the jmp in the hooked function
	// target function was hooked with jmp which points to the rwx page

	// So after that procedure I am able to create a hook instance with the needed information
	auto _hook = std::make_unique< hook >(
		start_address,
		reinterpret_cast< std::uintptr_t >( rwx_page ),
		size,
		shellcode,
		original_bytes
	);

	// add now the hook to the process vector
	this->m_hooks.push_back( std::move( _hook ) );

	return true;
}

bool process::destroy_hook_x86( const std::uintptr_t start_address )
{
	if( start_address < 0 )
		return false;

	// iterate over all placed hooks and check if the address of the hooked function exists
	for( const auto& hk : this->m_hooks )
		if( hk->get_hook_address() == start_address )
		{
			// before I go on, I want to make sure that the hook size is equal to the size of the vector which contains the original bytes
			// this important because I will write them back with the size of the vector to make sure all bytes are copied
			if( hk->get_hook_size() != hk->get_original_bytes_ptr()->size() )
				return false;

			DWORD buffer = 0;

			// change the page protection to restore the original bytes
			if( !VirtualProtectEx(
				this->m_handle,
				reinterpret_cast< LPVOID >( start_address ),
				hk->get_hook_size(),
				PAGE_EXECUTE_READWRITE,
				&buffer
			) )
				return false;

			// write now the original bytes
			if( !WriteProcessMemory(
				this->m_handle,
				reinterpret_cast< LPVOID >( start_address ),
				hk->get_original_bytes_ptr()->data(),
				hk->get_original_bytes_ptr()->size(),
				nullptr
			) )
				return false;

			// restore the old page protection now
			if( !VirtualProtectEx(
				this->m_handle,
				reinterpret_cast< LPVOID >( start_address ),
				hk->get_hook_size(),
				buffer,
				&buffer
			) )
				return false;

			// now I need to free the allocated memory
			if( !VirtualFreeEx(
				this->m_handle,
				reinterpret_cast< LPVOID >( hk->get_allocated_page_address() ),
				NULL,
				MEM_RELEASE
			) )
				return false;

			// need to remove the hook element now from the vector
			this->m_hooks.erase( std::ranges::find( this->m_hooks.begin(), this->m_hooks.end(), hk ) );

			// now I restored the old bytes, free'd the allocated memory and removed the hook instance from the vector
			// the world should be fine again
			return true;
		}

	return false;
}

bool process::execute_shellcode_in_process( const std::vector< uint8_t >& shellcode ) const
{
	// no shellcode? no execution for you
	if( shellcode.empty() )
		return false;

	// allocate memory in process for the shellcode
	const auto page = this->allocate_rwx_page_in_process( shellcode.size() );

	if( !page )
		return false;

	// copy now the shellcode to the freshly allocated memory page
	if( !WriteProcessMemory(
		this->m_handle,
		page,
		shellcode.data(),
		shellcode.size(),
		nullptr
	) )
		return false;

	// create now a thread inside the process, which executes the shellcode
	const auto ret = CreateRemoteThread(
		this->m_handle,
		nullptr,
		NULL,
		reinterpret_cast< LPTHREAD_START_ROUTINE >( page ),
		nullptr,
		NULL,
		nullptr
	);

	if( !ret )
		return false;

	// Wait until thread finish it's execution
	WaitForSingleObject( ret, INFINITE );

	// close now the thread handle
	if( !CloseHandle( ret ) )
		return false;

	// free now the allocated memory page for the shellcode
	if( !VirtualFreeEx(
		this->m_handle,
		page,
		NULL,
		MEM_RELEASE
	) )
		return false;

	// Now everything should be fine again

	return true;
}

bool process::create_shared_memory_instance_x86( const std::string& object_name, const DWORD file_size_high,
                                                 const DWORD file_size_low )
{
	// i don't want empty object names here, hausrecht und so
	if( object_name.empty() )
		return false;

	// check if object name is already in instance vector
	for( const auto& inst : this->m_sh_instances )
		if( inst->get_object_name() == object_name )
			return false;

	const auto kernel32 = GetModuleHandleA( "Kernel32" );

	if( !kernel32 )
		return false;

	const auto fnCreateFileMappingA = GetProcAddress( kernel32, "CreateFileMappingA" );

	if( !fnCreateFileMappingA )
		return false;

	const auto fnMapViewOfFile = GetProcAddress( kernel32, "MapViewOfFile" );

	if( !fnMapViewOfFile )
		return false;

	// allocate now a memory page for the saved data and the string of the global object inside the process
	const auto save_data_ptr = this->allocate_page_in_process( PAGE_READWRITE, 8 + object_name.size() );

	if( !save_data_ptr )
		return false;

	const auto name_ptr = reinterpret_cast< std::uintptr_t >( save_data_ptr ) + 8;

	// write now the object name string into the process
	if( !WriteProcessMemory(
		this->m_handle,
		reinterpret_cast< LPVOID >( name_ptr ),
		object_name.data(),
		object_name.size(),
		nullptr
	) )
		return false;

	std::vector< uint8_t > install_sh =
	{
		0xBA, 0xEF, 0xBE, 0xAD, 0xDE,			// mov edx, DEADBEEF	; EDX = CreateFileMappingA Address
		0xBF, 0xEF, 0xBE, 0xAD, 0xDE,			// mov edi, DEADBEEF	; EDI = MapViewOfFile Address
		0xBB, 0xEF, 0xBE, 0xAD, 0xDE,			// mov ebx, DEADBEEF	; Address of global object name string
		0x53,									// push ebx
		0xBB, 0xEF, 0xBE, 0xAD, 0xDE,			// mov ebx, DEADBEEF	; max size LOW
		0x53,									// push ebx
		0xBB, 0xEF, 0xBE, 0xAD, 0xDE,			// mov ebx, DEADBEEF	; max size HIGH
		0x53,									// push ebx
		0x6A, 0x04,								// push 04				; PAGE_READWRITE
		0x6A, 0x00,								// push 00
		0x68, 0xFF, 0xFF, 0xFF, 0xFF,			// push FFFFFFFF
		0xFF, 0xD2,								// call edx				; CreateFileMappingA()
		0x83, 0xF8, 0x00,						// cmp eax,0
		0x74, 0x23,								// je 
		0x8B, 0xC8,								// mov ecx, eax			; ECX = handle to mapping object
		0xBB, 0xEF, 0xBE, 0xAD, 0xDE,			// mov ebx, DEADBEEF	; max size low
		0x53,									// push ebx
		0x6A, 0x00,								// push 00
		0x6A, 0x00,								// push 00
		0x68, 0x1F, 0x00, 0x0F, 0x00,			// push 000F001F		; FILE_MAP_ALL_ACCESS
		0x50,									// push eax
		0xFF, 0xD7,								// call edi				; MapViewOfFile()
		0x83, 0xF8, 0x00,						// cmp eax,0
		0x74, 0x0A,								// je 
		0xBB, 0xEF, 0xBE, 0xAD, 0xDE,			// mov ebx, DEADBEEF	; address where return values are backup'ed
		0x89, 0x0B,								// mov [ebx], ecx		; handle to mapping object
		0x89, 0x43, 0x04,						// mov [ebx+04], eax	; starting address of mapped view
		0xC3									// ret 
	};

	// set address of CreateFileMappingA
	*reinterpret_cast< std::uintptr_t* >( &install_sh[ 1 ] ) = reinterpret_cast< std::uintptr_t >(
		fnCreateFileMappingA );

	// set address of MapViewOfFile
	*reinterpret_cast< std::uintptr_t* >( &install_sh[ 6 ] ) = reinterpret_cast< std::uintptr_t >( fnMapViewOfFile );

	// set address of the global object name string
	*reinterpret_cast< std::uintptr_t* >( &install_sh[ 11 ] ) = name_ptr;

	// set maximum size low word of view offset
	*reinterpret_cast< DWORD* >( &install_sh[ 17 ] ) = file_size_low;

	// set maximum size high word of view offset
	*reinterpret_cast< DWORD* >( &install_sh[ 23 ] ) = file_size_high;

	// set maximum size low word of view offset
	*reinterpret_cast< DWORD* >( &install_sh[ 47 ] ) = file_size_low;

	// set now the allocated page ptr for the saved data
	*reinterpret_cast< std::uintptr_t* >( &install_sh[ 70 ] ) = reinterpret_cast< std::uintptr_t >( save_data_ptr );


	// execute now the installation shellcode
	if( !this->execute_shellcode_in_process( install_sh ) )
		return false;

	// read now the saved data from the allocated memory page
	const auto object_handle = this->read< HANDLE >( reinterpret_cast< std::uintptr_t >( save_data_ptr ) );

	if( !object_handle )
		return false;

	// read now the starting address of the mapped view fro the allocated memory page
	const auto view_address = this->read< std::uintptr_t >( reinterpret_cast< std::uintptr_t >( save_data_ptr ) + 4 );

	if( !view_address )
		return false;

	// now create the second part of the shared memory in this process

	// open the file mapping to the global object
	const auto file_handle = OpenFileMappingA( FILE_MAP_ALL_ACCESS, FALSE, object_name.c_str() );

	if( !file_handle )
		return false;

	// now map the view of the mapped file into our address space
	const auto view_ptr = MapViewOfFile(
		file_handle,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		file_size_high == 0 ? file_size_low : file_size_high & file_size_low
	);

	if( !view_ptr )
		return false;

	// create now the shared memory instance
	auto sh_mem = std::make_unique< shared_memory_instance >(
		object_name,
		file_handle,
		view_ptr,
		reinterpret_cast< void* >( view_address ),
		object_handle,
		!file_size_high ? file_size_low : file_size_high & file_size_low
	);

	// add it to the internal vector for shared memory instances
	this->m_sh_instances.push_back( std::move( sh_mem ) );

	// now free the allocated memory page for the saved data
	if( !VirtualFreeEx(
		this->m_handle,
		save_data_ptr,
		0,
		MEM_RELEASE
	) )
		return false;

	return true;
}

bool process::destroy_shared_memory_instance_x86( const std::string& object_name )
{
	if( object_name.empty() )
		return false;

	// check if object name exists in instance vector
	for( const auto& sh_inst : this->m_sh_instances )
	{
		if( sh_inst->get_object_name() == object_name )
		{
			// Get now the addresses of the needed winapi functions

			const auto kernel32 = GetModuleHandleA( "Kernel32" );

			if( !kernel32 )
				return false;

			const auto fnUnmapViewOfFile = GetProcAddress( kernel32, "UnmapViewOfFile" );

			if( !fnUnmapViewOfFile )
				return false;

			const auto fnCloseHandle = GetProcAddress( kernel32, "CloseHandle" );

			if( !fnCloseHandle )
				return false;

			// prepare now the shellcode

			std::vector< uint8_t > uninstall_sh =
			{
				0xBE, 0xEF, 0xBE, 0xAD, 0xDE,			// mov esi,DEADBEEF			; Address of UnmapViewOfFile
				0xBF, 0xEF, 0xBE, 0xAD, 0xDE,			// mov edi,DEADBEEF			; Address of CloseHandle
				0xB8, 0xEF, 0xDB, 0xEA, 0x0D,			// mov eax,0DEADBEF			; pBuf ptr
				0x50,									// push eax
				0xFF, 0xD6,								// call esi					; UnmapViewOfFile()
				0xB8, 0xEF, 0xBE, 0xAD, 0xDE,			// mov eax,DEADBEEF			; hMapFile handle
				0x50,									// push eax
				0xFF, 0xD7,								// call edi					; CloseHandle()
				0xC3									// ret 

			};

			// set address of UnmapViewOfFile
			*reinterpret_cast< std::uintptr_t* >( &uninstall_sh[ 1 ] ) = reinterpret_cast< std::uintptr_t >(
				fnUnmapViewOfFile );

			// set address of CloseHandle
			*reinterpret_cast< std::uintptr_t* >( &uninstall_sh[ 6 ] ) = reinterpret_cast< std::uintptr_t >(
				fnCloseHandle );

			// set now the pBuf pointer
			*reinterpret_cast< std::uintptr_t* >( &uninstall_sh[ 11 ] ) = reinterpret_cast< std::uintptr_t >( sh_inst->
				get_process_buffer_ptr() );

			// set now the hMapFile handle
			*reinterpret_cast< HANDLE* >( &uninstall_sh[ 19 ] ) = sh_inst->get_file_mapping_object_handle();

			// execute now the shellcode inside the process

			if( !this->execute_shellcode_in_process( uninstall_sh ) )
				return false;

			// now I need to unmap the view also from this process
			if( !UnmapViewOfFile( sh_inst->get_buffer_ptr< LPCVOID >() ) )
				return false;

			// also I need to close handle of the mapping file
			if( !CloseHandle( sh_inst->get_file_mapping_object_handle() ) )
				return false;

			// also I need to remove the shared memory instance ptr form the vector
			this->m_sh_instances.erase(
				std::ranges::find( this->m_sh_instances.begin(), this->m_sh_instances.end(), sh_inst )
			);

			// now everything should be fine 

			return true;
		}
	}
	return false;
}

bool process::create_register_dumper_x86( const std::uintptr_t dumped_address, const size_t hook_size )
{
	// if the address where the dumper will be placed is invalid
	if( dumped_address <= 0 )
		return false;

	// if a register context already exists with the given address
	if(
		std::ranges::any_of(
			this->m_register_dumper.begin(),
			this->m_register_dumper.end(),
			[&dumped_address]( const std::unique_ptr< registercontext >& re )
			{
				return re->get_dumped_address() == dumped_address;
			}
		)
	)
		return false;

	// create the custom object name for the register context
	const auto obj_name = std::vformat( "osmium-dumpctx-{:X}", std::make_format_args( dumped_address ) );

	// maybe a bit too paranoid but better safe than sorry
	if( obj_name.empty() )
		return false;

	// create the shared memory for the regdumper, with enough bytes to fit into the registers_data class
	if( !this->create_shared_memory_instance_x86( obj_name, NULL, sizeof( register_data ) ) )
		return false;

	// now after the shared memory instance was successfully created
	// let's place the hook which will dump all registers data into the shared memory

	std::vector< uint8_t > install_sh =
	{
		0xA3, 0xEF, 0xBE, 0xAD, 0xDE,			// 0000  mov [DEADBEEF],    eax
		0x89, 0x1D, 0xF3, 0xBE, 0xAD, 0xDE,		// 0005  mov [DEADBEEF+4],  ebx
		0x89, 0x0D, 0xF7, 0xBE, 0xAD, 0xDE,		// 000B  mov [DEADBEEF+8],  ecx
		0x89, 0x15, 0xFB, 0xBE, 0xAD, 0xDE,		// 0011  mov [DEADBEEF+C],  edx
		0x89, 0x25, 0xFF, 0xBE, 0xAD, 0xDE,		// 0017  mov [DEADBEEF+10], esp
		0x89, 0x2D, 0x03, 0xBF, 0xAD, 0xDE,		// 001D  mov [DEADBEEF+14], ebp
		0x89, 0x35, 0x07, 0xBF, 0xAD, 0xDE,		// 0023  mov [DEADBEEF+18], esi
		0x89, 0x3D, 0x0B, 0xBF, 0xAD, 0xDE		// 0029  mov [DEADBEEF+1C], edi
	};

	// get now the - hopefully - freshly created shared memory instance
	const auto sh_inst = this->get_shared_memory_instance_by_object_name( obj_name );

	// must be valid because nothing works without it
	if( sh_inst == nullptr )
		return false;

	// get now the address of the shared memory inside the target process
	const auto target_sh_ptr = reinterpret_cast< std::uintptr_t >( sh_inst->get_process_buffer_ptr() );

	// make sure the target process buffer pointer is valid
	if( !target_sh_ptr )
		return false;

	// prepare now the addresses where the registers will be written to

	// GPRs
	for( auto i = 0; i < 8; i++ )
	{
		if( i == 0 )
			*reinterpret_cast< std::uintptr_t* >( &install_sh[ 1 ] ) = target_sh_ptr;
		else
			*reinterpret_cast< std::uintptr_t* >( &install_sh[ 7 + 6 * ( i - 1 ) ] ) = target_sh_ptr + i * sizeof(
				uint32_t );
	}

	// Read now the original bytes from memory
	std::vector< uint8_t > original_bytes;
	original_bytes.resize( hook_size );

	if( !ReadProcessMemory(
		this->m_handle,
		reinterpret_cast< LPCVOID >( dumped_address ),
		original_bytes.data(),
		hook_size,
		nullptr
	) )
		return false;

	// append them now to the shellcode
	install_sh.insert( install_sh.end(), original_bytes.begin(), original_bytes.end() );

	// now place the hook at the address which should be dumped
	if( !this->create_hook_x86( dumped_address, hook_size, install_sh ) )
		return false;

	// At this point the following should be done
	// 1. Created a shared memory instance for the new register context
	// 2. Prepared the dumping shellcode with the proper pointer from the new shared memory instance
	// 3. Created and placed the hook at the given address, where the registers should be dumped

	// Create now the smart ptr with the proper instance
	auto ctx = std::make_unique< registercontext >( sh_inst, dumped_address, hook_size );

	// Enable the register_context, so the dumping will already happen
	ctx->enable_dumper();

	// Append now the fresh register context to the internal vector
	this->m_register_dumper.push_back( std::move( ctx ) );

	return true;
}

bool process::destroy_register_dumper_x86( const std::uintptr_t dumped_address )
{
	// If the address where the dumper will be placed is invalid
	if( dumped_address <= 0 )
		return false;

	// Try to find the registercontext for the given address
	const auto& existing_ctx = std::ranges::find_if(
		this->m_register_dumper.begin(),
		this->m_register_dumper.end(),
		[&dumped_address]( const std::unique_ptr< registercontext >& re )
		{
			return re->get_dumped_address() == dumped_address;
		}
	);

	// If no registercontext was found, return false
	if( existing_ctx == this->m_register_dumper.end() )
		return false;

	// If the registercontext is still active, stop it before destroying it
	// If it couldn't be stopped, return false
	if( existing_ctx->get()->is_dumper_active() )
		if( !this->stop_register_dumper_x86( dumped_address ) )
			return false;

	// Unhook the placed hook now
	if( !this->destroy_hook_x86( dumped_address ) )
		return false;

	// Craft now the object name from the existing shared memory instance
	const auto obj_name = std::vformat( "osmium-dumpctx-{:X}", std::make_format_args( dumped_address ) );

	// Maybe a bit too paranoid but better safe than sorry
	if( obj_name.empty() )
		return false;

	// Destroy now the existing shared memory instance
	if( !this->destroy_shared_memory_instance_x86( obj_name ) )
		return false;

	// Erase now the registercontext from the internal vector
	this->m_register_dumper.erase(
		std::ranges::find( this->m_register_dumper.begin(), this->m_register_dumper.end(), *existing_ctx )
	);

	// Now everything should be properly cleaned and fine again :-)

	return true;
}

bool process::start_register_dumper_x86( const std::uintptr_t dumped_address )
{
	// If no register context exists with the given dumped address, return false
	if( const auto not_exists = std::ranges::none_of(
		this->m_register_dumper,
		[&dumped_address]( const std::unique_ptr< registercontext >& re )
		{
			return re->get_dumped_address() == dumped_address;
		}
	) )
		return false;

	// Try finding a registercontext for the given address
	const auto& existing_ctx = std::ranges::find_if(
		this->m_register_dumper,
		[&dumped_address]( const std::unique_ptr< registercontext >& re )
		{
			return re->get_dumped_address() == dumped_address;
		}
	);

	// Check if the given address belongs to a existing registercontext
	// If the context doesn't exist, return false
	if( existing_ctx == this->m_register_dumper.end() )
		return false;

	// If a registercontext exists with the given address and is already active, return false
	// A already active context can not be started again
	if( existing_ctx->get()->is_dumper_active() )
		return false;

	// Craft now the object name from the existing shared memory instance
	const auto obj_name = std::vformat( "osmium-dumpctx-{:X}", std::make_format_args( dumped_address ) );

	// Now prepare the shellcode for the hook
	std::vector< uint8_t > start_sh =
	{
		0xA3, 0xEF, 0xBE, 0xAD, 0xDE,			// 0000  mov [DEADBEEF],    eax
		0x89, 0x1D, 0xF3, 0xBE, 0xAD, 0xDE,		// 0005  mov [DEADBEEF+4],  ebx
		0x89, 0x0D, 0xF7, 0xBE, 0xAD, 0xDE,		// 000B  mov [DEADBEEF+8],  ecx
		0x89, 0x15, 0xFB, 0xBE, 0xAD, 0xDE,		// 0011  mov [DEADBEEF+C],  edx
		0x89, 0x25, 0xFF, 0xBE, 0xAD, 0xDE,		// 0017  mov [DEADBEEF+10], esp
		0x89, 0x2D, 0x03, 0xBF, 0xAD, 0xDE,		// 001D  mov [DEADBEEF+14], ebp
		0x89, 0x35, 0x07, 0xBF, 0xAD, 0xDE,		// 0023  mov [DEADBEEF+18], esi
		0x89, 0x3D, 0x0B, 0xBF, 0xAD, 0xDE		// 0029  mov [DEADBEEF+1C], edi
	};

	// Get now the - hopefully - freshly created shared memory instance
	const auto sh_inst = this->get_shared_memory_instance_by_object_name( obj_name );

	// Must be valid because nothing works without it
	if( sh_inst == nullptr )
		return false;

	// Get now the address of the shared memory inside the target process
	const auto target_sh_ptr = reinterpret_cast< std::uintptr_t >( sh_inst->get_process_buffer_ptr() );

	// Make sure the target process buffer pointer is valid
	if( !target_sh_ptr )
		return false;

	// Prepare now the addresses where the registers will be written to

	// GPRs
	for( auto i = 0; i < 8; i++ )
	{
		if( i == 0 )
			*reinterpret_cast< std::uintptr_t* >( &start_sh[ 1 ] ) = target_sh_ptr;
		else
			*reinterpret_cast< std::uintptr_t* >( &start_sh[ 7 + 6 * ( i - 1 ) ] ) = target_sh_ptr + i * sizeof(
				uint32_t );
	}

	// Read now the original bytes from memory
	std::vector< uint8_t > original_bytes;
	original_bytes.resize( existing_ctx->get()->get_hook_size() );

	if( !ReadProcessMemory(
		this->m_handle,
		reinterpret_cast< LPCVOID >( dumped_address ),
		original_bytes.data(),
		existing_ctx->get()->get_hook_size(),
		nullptr
	) )
		return false;

	// append them now to the shellcode
	start_sh.insert( start_sh.end(), original_bytes.begin(), original_bytes.end() );

	// Now place the hook at the address which should be dumped
	if( !this->create_hook_x86( dumped_address, existing_ctx->get()->get_hook_size(), start_sh ) )
		return false;

	// Finally set the register context active
	existing_ctx->get()->enable_dumper();

	return true;
}

bool process::stop_register_dumper_x86( const std::uintptr_t dumped_address )
{
	// Try to find a registercontext instance for the given address
	const auto& existing_ctx = std::ranges::find_if(
		this->m_register_dumper.begin(),
		this->m_register_dumper.end(),
		[&dumped_address]( const std::unique_ptr< registercontext >& re )
		{
			return re->get_dumped_address() == dumped_address;
		}
	);

	// If no registercontext with given address exists, return false
	if( existing_ctx == this->m_register_dumper.end() )
		return false;

	// If a registercontext exists with the given address and is not active, return false
	if( !existing_ctx->get()->is_dumper_active() )
		return false;

	// Destroy now the placed hook
	if( !this->destroy_hook_x86( dumped_address ) )
		return false;

	// disable now the dumper
	existing_ctx->get()->disable_dumper();

	return true;
}

bool process::inject_dll_load_library(const std::string& dll_path)
{
	// Allocate memory which will hold the dll path
	const auto mem_dll = this->allocate_page_in_process(PAGE_READWRITE, dll_path.size() + 1);

	if (!mem_dll)
		return false;

	// Write the DLL path to the allocated memory
	if (!WriteProcessMemory(this->get_process_handle(), mem_dll, dll_path.c_str(), dll_path.size() + 1, NULL))
		return false;

	// Get a handle to the library where the needed function pointer is located at
	const auto module_handle = GetModuleHandleA("kernel32.dll");

	if (!module_handle)
		return false;

	// Get the address of LoadLibraryA in kernel32.dll
	const auto loadlib_a = (LPVOID)GetProcAddress(module_handle, "LoadLibraryA");
	if (!loadlib_a)
		return false;

	// Create a remote thread that calls LoadLibraryA with our DLL path as its argument
	const auto remote_thread = CreateRemoteThread(this->get_process_handle(), NULL, NULL, (LPTHREAD_START_ROUTINE)loadlib_a, mem_dll, NULL, NULL);
	if (!remote_thread)
		return false;

	// Wait for the remote thread to complete
	WaitForSingleObject(remote_thread, INFINITE);

	// Clean up
	VirtualFreeEx(this->get_process_handle(), mem_dll, NULL, MEM_RELEASE);

	return true;
}

std::uintptr_t process::get_peb_ptr()
{
	typedef NTSTATUS(NTAPI* pfnNtQueryInformationProcess)(
		IN  HANDLE ProcessHandle,
		IN  PROCESSINFOCLASS ProcessInformationClass,
		OUT PVOID ProcessInformation,
		IN  ULONG ProcessInformationLength,
		OUT PULONG ReturnLength    OPTIONAL
		);

	const auto ntdll = LoadLibraryA("ntdll.dll");
	if (ntdll == NULL)
		return {};

	const auto fn_NtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(ntdll, "NtQueryInformationProcess");

	PROCESS_BASIC_INFORMATION pbi = {};

	const auto ret = fn_NtQueryInformationProcess( this->m_handle, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr);

	if (!NT_SUCCESS(ret) || !pbi.PebBaseAddress)
		return {};

	return reinterpret_cast<std::uintptr_t>(pbi.PebBaseAddress);
}

PEB process::get_peb()
{
	const auto peb_ptr = this->get_peb_ptr();

	if (!peb_ptr)
		return {};

	return this->read< PEB >( peb_ptr );
}

std::uintptr_t process::get_peb_image_base_address() noexcept
{
	const auto peb = this->get_peb();

	return peb.Reserved3[1] != nullptr ? reinterpret_cast<std::uintptr_t>(peb.Reserved3[1]) : std::uintptr_t();

	return std::uintptr_t();
}

std::vector<std::tuple<std::string, std::uintptr_t, size_t>> process::get_modules_from_peb()
{
	std::vector<std::tuple<std::string, std::uintptr_t, size_t>> ret = {};

	const auto peb = this->get_peb();

	PEB_LDR_DATA ldr = {};

	if (!ReadProcessMemory(this->m_handle, peb.Ldr, &ldr, sizeof(ldr), nullptr))
		return ret;

	const auto ldr_head = ldr.InMemoryOrderModuleList.Flink;
	auto ldr_current = ldr_head;

	do
	{
		const auto ldr_data_current = this->read< LDR_DATA_TABLE_ENTRY >(
			reinterpret_cast<std::uintptr_t>(ldr_current) - sizeof(LIST_ENTRY)
		);

		const auto path_size = ldr_data_current.FullDllName.Length / sizeof(wchar_t);

		std::vector< wchar_t > full_dll_name = {};
		full_dll_name.resize(path_size);

		if (!ReadProcessMemory(
			this->m_handle, 
			ldr_data_current.FullDllName.Buffer, 
			full_dll_name.data(), 
			ldr_data_current.FullDllName.Length, 
			nullptr)
			)
			break;

		full_dll_name.emplace_back(L'\0');

		const auto image_name_w = std::wstring(full_dll_name.data());

		const auto image_name_a = std::string(image_name_w.begin(), image_name_w.end());

		const auto image_base = reinterpret_cast<std::uintptr_t>(ldr_data_current.DllBase);
		const auto image_size = reinterpret_cast<size_t>(ldr_data_current.Reserved3[1]);

		if (image_base && image_size)
		{
			ret.emplace_back(
				image_name_a,
				image_base,
				image_size
			);
		}

		const auto ldr_temp = this->read< LIST_ENTRY >(reinterpret_cast<std::uintptr_t>(ldr_current));

		ldr_current = ldr_temp.Flink;
		
	} while (ldr_current != ldr_head);

	return ret;
}

```

`Memory/Process/process.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>
#include <memory>
#include <unordered_map>
#include <ranges>
#include <winternl.h>

#ifdef _WIN64
#include "../Image_x64/image_x64.hpp"
#else
#include "../Image_x86/image_x86.hpp"
#endif

#include "../Hook/hook.hpp"
#include "../SharedMemoryInstance/sharedmemoryinstance.hpp"
#include "../RegisterDumper/registercontext.hpp"

class process
{
public:
	///-------------------------------------------------------------------------------------------------
	/// <summary>Default constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	process()
		: m_handle( INVALID_HANDLE_VALUE )
	  , m_hwnd( HWND() )
	  , m_pid( DWORD() ) {}

	///-------------------------------------------------------------------------------------------------
	/// <summary>The default destructor, it will also close the process handle, destroy every active hook and free their allocated memory.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	~process()
	{
		this->shutdown();

		if( this->m_handle )
			CloseHandle( this->m_handle );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	This function should be called, when it's expected that the destructor won't be called on exiting. Will free any used resources, so no memory leaks should appear after that. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	bool shutdown()
	{
		// make sure no memory will be leaked, by destroying all registered contexts 
		// first you should clear all registered contexts because their hooks and shared memory instances
		// will be also destroyed.
		// if you destroy the hooks or the sh instances first the destroy function of the register contexts will fail
		// resulting in unwanten behaviour  
		if( !this->m_register_dumper.empty() )
			for( const auto& reg_ctx : this->m_register_dumper )
				if( !this->destroy_register_dumper_x86( reg_ctx->get_dumped_address() ) )
					return false;

		// make sure no memory will be leaked, by unhooking existent hooks
		if( !this->m_hooks.empty() )
			for( const auto& hk : this->m_hooks )
				if( !this->destroy_hook_x86( hk->get_hook_address() ) )
					return false;

		// make sure no memory will be leaked, by destroying all named shared memory instances
		if( !this->m_sh_instances.empty() )
			for( const auto& sh_inst : this->m_sh_instances )
				if( !this->destroy_shared_memory_instance_x86( sh_inst->get_object_name() ) )
					return false;

		// clear the whole image map from the target process
		if ( !this->m_images.empty() )
			this->m_images.clear();

		return true;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets process handle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The process handle.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] HANDLE get_process_handle() const noexcept
	{
		return this->m_handle;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets window handle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The window handle.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] HWND get_window_handle() const noexcept
	{
		return this->m_hwnd;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets process id.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The process id of the target process.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] DWORD get_process_id() const noexcept
	{
		return this->m_pid;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Checks if the process is ready to use.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if process ready, false if not.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool is_process_ready() const noexcept
	{
		return this->m_handle != INVALID_HANDLE_VALUE && this->m_hwnd != nullptr && this->m_pid >= 0;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Reads memory from the target process.</summary>
	///
	/// <typeparam name="T">	Generic type parameter.</typeparam>
	/// <param name="address">	   	The address which you want to read.</param>
	/// <param name="size_of_read">	(Optional) Size which will be read from the address.</param>
	///
	/// <returns>A buffer with datatype T, read from the memory address.</returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	T read( const std::uintptr_t address, size_t size_of_read = sizeof( T ) )
	{
		T buffer;
		ReadProcessMemory( this->m_handle, reinterpret_cast< LPCVOID >( address ), &buffer, size_of_read, nullptr );
		return buffer;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Reads ASCII null terminated string from the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="address">	The address which will be read from.</param>
	///
	/// <returns>The ASCII null terminated string.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::string read_ascii_null_terminated_string( const std::uintptr_t address )
	{
		std::string ret = {};

		auto stringptr = address;

		char c = {};

		while( ( c = this->read< char >( stringptr++ ) ) != '\0' )
			if( c >= 32 && c < 127 )
				ret += c;
			else
				return "OSMIUM_NO_ASCII";

		return ret;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Writes memory to the target process.</summary>
	///
	/// <typeparam name="T">	Generic type parameter.</typeparam>
	/// <param name="address">	The address which should be written to.</param>
	/// <param name="value">  	The value which should be written to the memory address.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	bool write( std::uintptr_t address, T value )
	{
		return WriteProcessMemory(
			this->m_handle,
			reinterpret_cast< LPVOID >( address ),
			&value,
			sizeof( value ),
			nullptr
		) != 0;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Change the protection of a memory block.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="address">   	The address which protection will be changed.</param>
	/// <param name="size">		 	The number of bytes which get their protection changed.</param>
	/// <param name="protection">	The new protection which will be applied to the memory block.</param>
	///
	/// <returns>The old protection from the memory block, needed for restoring the old protection.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] DWORD change_protection_of_memory_block( const std::uintptr_t address, const size_t size,
	                                                       const DWORD protection ) const
	{
		DWORD buffer = 0;

		if( !VirtualProtectEx( this->m_handle, reinterpret_cast< LPVOID >( address ), size, protection, &buffer ) )
			return NULL;

		return buffer;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Writes to protected memory.</summary>
	///
	/// <typeparam name="T">	Generic type parameter.</typeparam>
	/// <param name="address">	The address which will be written to.</param>
	/// <param name="value">  	The value which will be written to the address.</param>
	/// <param name="size">   	(Optional) The number of bytes which their protection will get temporarily changed.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	bool write_to_protected_memory( std::uintptr_t address, T value, size_t size = sizeof( T ) )
	{
		if( !this->is_process_ready() )
			return false;

		DWORD buffer = 0;

		if( !VirtualProtectEx(
			this->m_handle,
			reinterpret_cast< LPVOID >( address ),
			size,
			PAGE_EXECUTE_READWRITE,
			&buffer
		) )
			return false;

		if( WriteProcessMemory(
			this->m_handle,
			reinterpret_cast< LPVOID >( address ),
			&value,
			sizeof( value ),
			nullptr
		) == 0 )
			return false;

		return VirtualProtectEx( this->m_handle, reinterpret_cast< LPVOID >( address ), size, buffer, &buffer ) != 0;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Allocate an rwx page in the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="page_size">	(Optional) Size of the page [in bytes].</param>
	///
	/// <returns>The pointer to the freshly allocated page or if it fails it will return a null pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] LPVOID allocate_rwx_page_in_process( const size_t page_size = 4096 ) const
	{
		const auto ret = VirtualAllocEx(
			this->m_handle,
			nullptr,
			page_size,
			MEM_COMMIT | MEM_RESERVE,
			PAGE_EXECUTE_READWRITE
		);

		return ret;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Allocate a memory page with specific protection in the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="page_protection">	The page protection which will be applied to the new allocated memory page.</param>
	/// <param name="page_size">	  	(Optional) Size of the page [in bytes].</param>
	///
	/// <returns>The pointer to the freshly allocated page or if it fails it will return a null pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] LPVOID allocate_page_in_process( const DWORD page_protection, const size_t page_size = 4096 ) const
	{
		const auto ret = VirtualAllocEx(
			this->m_handle,
			nullptr,
			page_size,
			MEM_COMMIT | MEM_RESERVE,
			page_protection
		);

		return ret;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Refreshes the internal image map by re-dumping all images in the target process and caching them locally.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool refresh_image_map();

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets up the process instance with an process identifier (window title, process name). </summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="process_identifier">	Identifier for the process, can be window title or process name.</param>
	/// <param name="is_process_name">   	(Optional) True if is process name, false if the process identifier is a window title.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool setup_process( const std::wstring& process_identifier, bool is_process_name = true );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets up the process instance with an process id of the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="process_id">	The process id of the target process.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool setup_process( DWORD process_id );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the image base of an dumped image by looking in the internal unordered_map.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_name">	Name of the image.</param>
	///
	/// <returns>The image base if the image was found or 0 if the image does not exist.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::uintptr_t get_image_base( const std::wstring& image_name ) const noexcept
	{
		try
		{
			return this->m_images.at( image_name ).get()->get_image_base();
		}
		catch( std::exception& exception )
		{
			UNREFERENCED_PARAMETER( exception );
			return std::uintptr_t();
		}
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the image size of an dumped image by looking in the internal unordered_map.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_name">	Name of the image.</param>
	///
	/// <returns>The image size if the image was found or 0 if the image does not exist.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] size_t get_image_size( const std::wstring& image_name ) const noexcept
	{
		try
		{
			return this->m_images.at( image_name ).get()->get_image_size();
		}
		catch( std::exception& exception )
		{
			UNREFERENCED_PARAMETER( exception );
			return size_t();
		}
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Checks if the image exists in the internal image map, tells if the image was dumped.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_name">	Name of the image.</param>
	///
	/// <returns>True if the image was dumped/ does exists and false if does not exists/ was not dumped.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool does_image_exist_in_map( const std::wstring& image_name ) const noexcept
	{
		try
		{
			const auto temp = this->m_images.at( image_name ).get();

			return true;
		}
		catch( std::exception& exception )
		{
			UNREFERENCED_PARAMETER( exception );

			return false;
		}
	}

#ifdef _WIN64

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets x64 image pointer by name.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_name">	Name of the image.</param>
	///
	/// <returns>Null if it fails, else the image pointer by name.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] image_x64* get_image_ptr_by_name( const std::wstring& image_name ) const noexcept
#else

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets x86 image pointer by name.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="image_name">	Name of the image.</param>
	///
	/// <returns>Null if it fails, else the image pointer by name.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] image_x86* get_image_ptr_by_name( const std::wstring& image_name ) const noexcept
#endif
	{
		if( !this->does_image_exist_in_map( image_name ) )
			return nullptr;

		return this->m_images.at( image_name ).get();
	}

#ifdef _WIN64

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the first x64 image pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the first image pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] image_x64* get_first_image_ptr() const noexcept
#else

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the first x86 image pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the first image pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] image_x86* get_first_image_ptr() const noexcept
#endif
	{
		if( this->m_images.empty() )
			return nullptr;

		return this->m_images.begin()->second.get();
	}

	[[nodiscard]] inline auto get_images_ptr() const noexcept
	{
		return &this->m_images;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the size of the internal image map, it tells how many images were dumped.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The map size.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] size_t get_map_size() const noexcept
	{
		return this->m_images.size();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the size of the internal image map in megabytes.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The map size in megabytes.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] double get_map_size_in_mbytes() const noexcept
	{
		if( this->m_images.empty() )
			return double();

		auto size = 0.0;

		constexpr auto divider = 1024.0 * 1024.0;

		for( const auto& image : this->m_images | std::views::values )
			size += image->get_image_size() / divider;

		return size;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Clears the image map.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void clear_image_map() noexcept
	{
		if( !this->m_images.empty() )
			this->m_images.clear();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Prints all dumped images in a nice summary with some info about them.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	void print_images() const
	{
		printf( "[#] Image-Name | Image-Base | Image-Size | Is-Executable\n" );

		for( auto& [ image_name, image_ptr ] : this->m_images )
			printf(
#ifdef _WIN64
				"[+] %-25ls | 0x%llX | 0x%llX | %d.\n",
#else
				"[+] %-32ls | 0x%08X | 0x%08X | %d.\n",
#endif
				image_name.c_str(),
				image_ptr->get_image_base(),
				image_ptr->get_image_size(),
				image_ptr->is_executable()
			);
		printf( "\n\n" );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Prints a specific count of dumped images in a nice summary with some info about them.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="num_of_images">	Number of images which should be printed.</param>
	///-------------------------------------------------------------------------------------------------

	void print_images( const size_t num_of_images ) const
	{
		if( this->m_images.empty() || num_of_images >= this->m_images.size() )
			return;

		printf( "[#] Image-Name | Image-Base | Image-Size | Is-Executable\n" );

		size_t counter = 0;

		for( auto& [ image_name, image_ptr ] : this->m_images )
		{
			if( counter == num_of_images )
				return;

			printf(
#ifdef _WIN64
				"[+] %-25ls | 0x%llX | 0x%llX | %d.\n",
#else
				"[+] %-32ls | 0x%08X | 0x%08X | %d.\n",
#endif
				image_name.c_str(),
				image_ptr->get_image_base(),
				image_ptr->get_image_size(),
				image_ptr->is_executable()
			);

			counter++;
		}
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Patch bytes in the target process with a given vector of bytes.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="bytes">  	The vector of bytes.</param>
	/// <param name="address">	The address which will be patched.</param>
	/// <param name="size">   	The number of bytes which will be overwritten.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	bool patch_bytes( const byte_vector& bytes, std::uintptr_t address, size_t size );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Patch bytes in the target process with a given array of bytes.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="bytes">  	The array of bytes.</param>
	/// <param name="address">	The address which will be patched.</param>
	/// <param name="size">   	The number of bytes which will be overwritten.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	bool patch_bytes( const std::byte bytes[ ], std::uintptr_t address, size_t size );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Overwrites bytes with NOP's inside the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="address">	The address where the bytes will be overwritten with NOP (0x90).</param>
	/// <param name="size">   	The number of bytes which will be overwritten.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	bool nop_bytes( std::uintptr_t address, size_t size );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Reads an image from the target process to an vector of bytes.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="dest_vec">  	[in,out] If non-null, destination vector.</param>
	/// <param name="image_name">	Name of the image.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool read_image( byte_vector* dest_vec, const std::wstring& image_name ) const;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Creates an mid function x86 hook inside of the target process by allocating a rwx page, copying the given shellcode to it and patching the given address with an JMP to the allocated page. Also adds a new hook instance into the local hook vector.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="start_address">	The start address where the mid function hook will be placed.</param>
	/// <param name="size">				The number of bytes the mid function hook should overwrite, needs to be atleast 5 bytes (JMP + ADDRESS).</param>
	/// <param name="shellcode">		The shellcode of your hook which should get executed.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool create_hook_x86( std::uintptr_t start_address, size_t size,
	                                    const std::vector< uint8_t >& shellcode );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Destroys the x86 hook inside the target process by restoring the old bytes and freeing the allocated memory page inside the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="start_address">	The start address of the mid function hook.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool destroy_hook_x86( std::uintptr_t start_address );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets size of current hooks inside the target process.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The number of current hooks inside of the target process.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] size_t get_size_of_hooks() const noexcept
	{
		return this->m_hooks.size();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets pointer to the related hook instance by the start address of the mid function hook.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="start_address_of_hook">	The start address of the mid function hook.</param>
	///
	/// <returns>Null if it fails, else the hook pointer by address.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] hook* get_hook_ptr_by_address( const std::uintptr_t start_address_of_hook ) const
	{
		for( const auto& hook : this->m_hooks )
			if( hook->get_hook_address() == start_address_of_hook )
				return hook.get();

		return nullptr;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the pointer to the vector where all hooks are stored.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The pointer to the vector where all hooks are stored.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] auto get_hooks_ptr() noexcept
	{
		return &this->m_hooks;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Executes the given shellcode via remote thread (allocated memory page has RWX rights) inside the target process and waits until the thread terminates. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <param name="shellcode">	The shellcode which will be executed. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool execute_shellcode_in_process( const std::vector< uint8_t >& shellcode ) const;

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Creates and installs a named shared memory instance with a given object name, file size HIGH and LOW. With the pointer from the shared memory instance you will be able to do IPC via Named Shared Memory. All new instances will be hold inside the instances vector. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <param name="object_name">   	Name of the object. </param>
	/// <param name="file_size_high">	The file size high. </param>
	/// <param name="file_size_low"> 	The file size low. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool create_shared_memory_instance_x86( const std::string& object_name, DWORD file_size_high,
	                                                      DWORD file_size_low );

	///-------------------------------------------------------------------------------------------------
	/// <summary>
	/// 	Destroys the shared memory instance described by object_name and removes the instance from the instances vector.
	/// </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <param name="object_name">	Name of the object. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool destroy_shared_memory_instance_x86( const std::string& object_name );

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets shared memory instance pointer by object name. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <param name="object_name">	Name of the object. </param>
	///
	/// <returns>	Null if it fails, else the shared memory instance pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] shared_memory_instance* get_shared_memory_instance_by_object_name(
		const std::string& object_name ) const
	{
		for( const auto& inst : this->m_sh_instances )
			if( inst->get_object_name() == object_name )
				return inst.get();
		return nullptr;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets the pointer to the vector whre all shared memory instances are stored. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	The pointer of the vector where all shared memory instances are stored. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] auto get_shared_memory_instances_ptr() noexcept
	{
		return &this->m_sh_instances;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Creates a new registercontext for the given address and stores it's new instance inside the internal vector for the registercontext's. Also all registercontext's are started by default. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The address where the register should be dumped from. </param>
	/// <param name="hook_size">	 	(Optional) Size of the hook in bytes. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool create_register_dumper_x86( std::uintptr_t dumped_address, size_t hook_size = 5 );

	///-------------------------------------------------------------------------------------------------
	/// <summary>
	/// 	Destroys a registercontext instance by unhooking it and destroying the shared memory instance, also erases it from the interal vector for the registercontext's.
	/// </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The dumped address of the registercontext which should be destroyed. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool destroy_register_dumper_x86( std::uintptr_t dumped_address );

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Sets the registercontext with the given address active and starting the dumping. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The dumped address of the registercontext which should be started. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool start_register_dumper_x86( std::uintptr_t dumped_address );

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Sets the registercontext with the given address inactive and stop the dumping. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The dumped address of the registercontext which should be stopped. </param>
	///
	/// <returns>	True if it succeeds, false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool stop_register_dumper_x86( std::uintptr_t dumped_address );

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Checks if a registercontext exists with a given address and which is active. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The dumped address of the registercontext. </param>
	///
	/// <returns>	True if a registercontext exists for the given address and is active, false if not. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] auto is_active_register_dumper_x86( const std::uintptr_t dumped_address ) const noexcept
	{
		return std::ranges::find_if(
			this->m_register_dumper.begin(),
			this->m_register_dumper.end(),
			[&dumped_address]( const std::unique_ptr< registercontext >& re )
			{
				return re->get_dumped_address() == dumped_address && re->is_dumper_active();
			}
		) != this->m_register_dumper.end();
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Retrieves the pointer to the registercontext class of a given dumped address which belongs to the registercontext. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The dumped address of the registercontext. </param>
	///
	/// <returns>	Nullpointer if it fails, else the registercontext pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] registercontext* get_register_dumper_x86_ptr( const std::uintptr_t dumped_address ) const noexcept
	{
		const auto ret = std::ranges::find_if(
			this->m_register_dumper.begin(),
			this->m_register_dumper.end(),
			[&dumped_address]( const std::unique_ptr< registercontext >& re )
			{
				return re->get_dumped_address() == dumped_address && re->is_dumper_active();
			}
		);

		return ret != this->m_register_dumper.end() ? ret->get() : nullptr;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Retrieves the pointer to the register_data class of a registercontext by searching for the given dumped address in the internal vector of registercontext's. </summary>
	///
	/// <remarks>	cragson, 23/12/2022. </remarks>
	///
	/// <param name="dumped_address">	The dumped address of the registercontext. </param>
	///
	/// <returns>	Nullpointer if it fails, else the register_data pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] register_data* get_data_from_registers_x86( const std::uintptr_t dumped_address ) const noexcept
	{
		const auto ret = std::ranges::find_if(
			this->m_register_dumper.begin(),
			this->m_register_dumper.end(),
			[&dumped_address]( const std::unique_ptr< registercontext >& re )
			{
				return re->get_dumped_address() == dumped_address && re->is_dumper_active();
			}
		);

		return ret != this->m_register_dumper.end() ? ret->get()->get_registers_data() : nullptr;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Injects a external dll into another process, utilizing the LoadLibrary technique. </summary>
	///
	/// <remarks>	cragson, 09/07/2024. </remarks>
	///
	/// <param name="dll_path">	The full path of the dll, which will be injected. </param>
	///
	/// <returns>	True if it injected successfully and false if it fails. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool inject_dll_load_library(const std::string& dll_path);

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Retreives a pointer to the PEB of the target process. </summary>
	///
	/// <remarks>	cragson, 19/07/2024. </remarks>
	///
	/// <returns>	The peb pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::uintptr_t get_peb_ptr();

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Dumps the PEB out of the memory from the target process. </summary>
	///
	/// <remarks>	cragson, 19/07/2024. </remarks>
	///
	/// <returns>	The peb structure. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] PEB get_peb();

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Reads the image base address member of the PEB struct from the target process. </summary>
	///
	/// <remarks>	cragson, 19/07/2024. </remarks>
	///
	/// <returns>	The peb image base address. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::uintptr_t get_peb_image_base_address() noexcept;

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Walks the InMemoryOrderModuleList of the PEB of the target process and stores all loaded module information in a vector. </summary>
	///
	/// <remarks>	cragson, 19/07/2024. </remarks>
	///
	/// <returns>	The std::vector of module information from InMemoryOrderModuleList inside the PEB. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::vector< std::tuple< std::string, std::uintptr_t, size_t > > get_modules_from_peb();

private:
	HANDLE m_handle;

	HWND m_hwnd;

	DWORD m_pid;

#ifdef _WIN64
	std::unordered_map< std::wstring, std::unique_ptr< image_x64 > > m_images;
#else
	std::unordered_map< std::wstring, std::unique_ptr< image_x86 > > m_images;
#endif

	std::vector< std::unique_ptr< hook > > m_hooks;

	std::vector< std::unique_ptr< shared_memory_instance > > m_sh_instances;

	std::vector< std::unique_ptr< registercontext > > m_register_dumper;
};

```

`Memory/RegisterDumper/registercontext.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "../SharedMemoryInstance/sharedmemoryinstance.hpp"

class register_data
{
public:

	// I don't want anyone to write into the struct as this would produce undefined behaviour
	// Because the dumper will write into the shared memory which a user could also might write to into the exact moment to it
	register_data& operator=(const register_data&) = delete;

	union EAX
	{
		uint32_t eax;
		uint16_t ax;
		uint8_t a[2];
	}EAX;

	union EBX
	{
		uint32_t ebx;
		uint16_t bx;
		uint8_t b[2];
	}EBX;

	union ECX
	{
		uint32_t ecx;
		uint16_t cx;
		uint8_t c[2];
	}ECX;

	union EDX
	{
		uint32_t edx;
		uint16_t dx;
		uint8_t d[2];
	}EDX;

	union ESP
	{
		uint32_t esp;
		uint16_t sp;
	}ESP;

	union EBP
	{
		uint32_t ebp;
		uint16_t bp;
	}EBP;

	union ESI
	{
		uint32_t esi;
		uint16_t si;
	}ESI;

	union EDI
	{
		uint32_t edi;
		uint16_t di;
	}EDI;

	//float st0, st1, st2, st3, st4, st5, st6, st7;

	//float xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15;
};

// TODO: add documentation
class registercontext
{
public:

	registercontext() = delete;

	explicit registercontext( shared_memory_instance* sh_ptr, const std::uintptr_t dumped_address, const size_t hook_size ) 
	{
		if (sh_ptr == nullptr)
			throw std::exception("Shared memory instance pointer is nullptr!");

		this->m_pShInstance = sh_ptr;

		this->m_bActive = false;

		this->m_iDumpedAddress = dumped_address;

		this->m_iHookSize = hook_size;
	}

	[[nodiscard]] inline auto get_shared_memory_instance_ptr() const noexcept
	{
		return this->m_pShInstance;
	}

	[[nodiscard]] inline auto get_registers_data() const noexcept
	{
		return static_cast< register_data* >( this->m_pShInstance->get_buffer_ptr() );
	}

	[[nodiscard]] inline auto is_dumper_active() const noexcept
	{
		return this->m_bActive;
	}

	[[nodiscard]] inline auto get_dumped_address() const noexcept
	{
		return this->m_iDumpedAddress;
	}

	[[nodiscard]] inline auto get_hook_size() const noexcept
	{
		return this->m_iHookSize;
	}

	inline void enable_dumper() noexcept
	{
		this->m_bActive = true;
	}

	inline void disable_dumper() noexcept
	{
		this->m_bActive = false;
	}

	inline void toggle_dumper() noexcept
	{
		this->m_bActive = !this->m_bActive;
	}

private:
	shared_memory_instance* m_pShInstance;

	bool m_bActive;

	std::uintptr_t m_iDumpedAddress;

	size_t m_iHookSize;
};
```

`Memory/SharedMemoryInstance/sharedmemoryinstance.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <string>

class shared_memory_instance
{
public:
	shared_memory_instance()
		: m_szObjectName( {} )
	  , m_hMapFile( nullptr )
	  , m_pBuffer( nullptr )
	  , m_pProcessBuffer( nullptr )
	  , m_hProcessMapFile( nullptr )
	  , m_iBufferSize( size_t() ) {}

	shared_memory_instance(
		const std::string& name,
		const HANDLE map,
		void* buffer,
		void* process_buffer,
		const HANDLE process_handle,
		const size_t buffer_size
	)
		: m_szObjectName( name )
	  , m_hMapFile( map )
	  , m_pBuffer( buffer )
	  , m_pProcessBuffer( process_buffer )
	  , m_hProcessMapFile( process_handle )
	  , m_iBufferSize( buffer_size ) {}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets a pointer to the shared memory of this process. </summary>
	/// 
	///  <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <typeparam name="T">	Generic type parameter. </typeparam>
	/// <param name="offset">	(Optional) The offset. </param>
	///
	/// <returns>	Null if it fails, else the buffer pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T = void >
	[[nodiscard]] T* get_buffer_ptr( const int32_t offset = 0 ) const noexcept
	{
		return !offset
		       ? static_cast< T* >( this->m_pBuffer )
		       : reinterpret_cast< T* >( reinterpret_cast< std::uintptr_t >( this->m_pBuffer ) + offset );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Reads the shared memory buffer at the given address. </summary>
	///
	/// <typeparam name="T">	Generic type parameter. </typeparam>
	/// <param name="address">	The address. </param>
	///
	/// <returns>	The value at the given address. </returns>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	[[nodiscard]] T read( const std::uintptr_t address ) const noexcept
	{
		if( address < reinterpret_cast< std::uintptr_t >( this->m_pBuffer ) || address > reinterpret_cast<
			std::uintptr_t >( this->m_pBuffer ) + this->m_iBufferSize )
			return {};

		return *reinterpret_cast< T* >( address );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Writes to the shared memory pointer. </summary>
	/// 
	/// <remarks>	cragson, 05/10/2022. </remarks>
	/// 
	/// <typeparam name="T">	Generic type parameter. </typeparam>
	/// <param name="value"> 	The value. </param>
	/// <param name="offset">	(Optional) The offset. </param>
	///-------------------------------------------------------------------------------------------------

	template< typename T >
	void write( const T& value, const int32_t offset = 0 )
	{
		*reinterpret_cast< T* >( this->get_buffer_ptr< T >( offset ) ) = value;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Writes a string to the shared memory pointer. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <param name="str">   	The string. </param>
	/// <param name="offset">	(Optional) The offset. </param>
	///-------------------------------------------------------------------------------------------------

	void write_string( const std::string& str, const int32_t offset = 0 ) const
	{
		memcpy( this->get_buffer_ptr( offset ), str.data(), str.size() );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Clears the shared memory buffer by zero'ing it. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///-------------------------------------------------------------------------------------------------

	void clear_memory() const
	{
		memset( this->m_pBuffer, 0, this->m_iBufferSize );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets object name. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	The object name. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] std::string get_object_name() const noexcept
	{
		return this->m_szObjectName;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets file mapping object handle. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	The file mapping object handle. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] HANDLE get_file_mapping_object_handle() const noexcept
	{
		return this->m_hMapFile;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets the pointer of the target process to the shared memory buffer. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	Null if it fails, else the process buffer pointer. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] void* get_process_buffer_ptr() const noexcept
	{
		return this->m_pProcessBuffer;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets the mapping object handle of the target process. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	The process mapping object handle. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] HANDLE get_process_mapping_object_handle() const noexcept
	{
		return this->m_hProcessMapFile;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>	Gets buffer size. </summary>
	///
	/// <remarks>	cragson, 05/10/2022. </remarks>
	///
	/// <returns>	The buffer size. </returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] size_t get_buffer_size() const noexcept
	{
		return this->m_iBufferSize;
	}

private:
	std::string m_szObjectName;

	HANDLE m_hMapFile;

	void* m_pBuffer;

	void* m_pProcessBuffer;

	HANDLE m_hProcessMapFile;

	size_t m_iBufferSize;
};

```

`Overlay/overlay.cpp`:

```cpp
#include "overlay.hpp"

#include <dwmapi.h>
#pragma comment(lib, "dwmapi.lib")

#include <numbers>

LRESULT CALLBACK WinProcedure( HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam )
{
	static overlay* this_ptr = {};
	wndproc_this_t* args = {};

	if( Message == WM_NCCREATE )
		args = reinterpret_cast< wndproc_this_t* >( lParam );

	switch( Message )
	{
		
		case WM_NCCREATE:
			this_ptr = args->m_this;
			break;

		case WM_PAINT:
			this_ptr->render();
			break;

		case WM_DESTROY:
			PostQuitMessage( 1 );
			break;

		case WM_SIZE:
			auto target_dim = RECT();
			GetWindowRect( this_ptr->get_target_window_handle(), &target_dim );

			this_ptr->set_overlay_width(  target_dim.right - target_dim.left );
			this_ptr->set_overlay_height( target_dim.bottom - target_dim.top );
			break;

		default:
			break;
	}
	return DefWindowProc( hWnd, Message, wParam, lParam );
}

DWORD WINAPI ThreadProc( LPVOID lpParam )
{
	const auto this_ptr = static_cast< overlay* >( lpParam );

	if (!this_ptr->create_window_class())
		return false;

	if (!this_ptr->create_window_overlay())
		return false;

	auto object_ptr = this_ptr->get_object_as_ptr();

	if ( FAILED( Direct3DCreate9Ex( D3D_SDK_VERSION, &object_ptr ) ) )
		return false;

	this_ptr->set_object_ptr( object_ptr );

	D3DPRESENT_PARAMETERS params;

	ZeroMemory(&params, sizeof(params));
	params.Windowed = true;
	params.BackBufferFormat = D3DFMT_A8R8G8B8;
	params.BackBufferHeight = this_ptr->get_overlay_height();
	params.BackBufferWidth = this_ptr->get_overlay_width();
	params.SwapEffect = D3DSWAPEFFECT_DISCARD;
	params.hDeviceWindow = this_ptr->get_overlay_window_handle();
	params.PresentationInterval = D3DPRESENT_INTERVAL_ONE;

	auto device_ptr = this_ptr->get_device_as_ptr();

	const auto create_ret = this_ptr->get_object_as_ptr()->CreateDeviceEx(
		D3DADAPTER_DEFAULT,
		D3DDEVTYPE_HAL,
		this_ptr->get_overlay_window_handle(),
		D3DCREATE_FPU_PRESERVE | D3DCREATE_MULTITHREADED | D3DCREATE_SOFTWARE_VERTEXPROCESSING,
		&params,
		nullptr,
		&device_ptr
	);

	if( FAILED( create_ret ) )
		return false;

	this_ptr->set_device_ptr( device_ptr );

	auto line_ptr = this_ptr->get_line_as_ptr();

	if ( FAILED( D3DXCreateLine( device_ptr, &line_ptr ) ) )
		return false;

	this_ptr->set_line_ptr( line_ptr );

	if (!this_ptr->register_font("Arial"))
		return false;

	if (!this_ptr->set_used_font("Arial"))
		return false;

	MSG current_msg = {};
	RtlZeroMemory( &current_msg, sizeof( MSG ) );

	while( true )
	{
		if (PeekMessage(&current_msg, this_ptr->get_overlay_window_handle(), 0, 0, PM_REMOVE))
		{
			DispatchMessage(&current_msg);
			TranslateMessage(&current_msg);
		}

		if (current_msg.message == WM_QUIT)
			break;

		this_ptr->move_target_window();

		this_ptr->render();
	}

	this_ptr->get_device_as_ptr()->Release();

	return 0;
}

bool overlay::register_font( const std::string& font_name, const int32_t height, const int32_t width, const int32_t weight )
{
	if ( !this->m_Device || font_name.empty() || height <= 0 || width < 0 || weight < 0 )
		return false;

	ID3DXFont* font_ptr = nullptr;

	const auto ret = D3DXCreateFontA( 
		this->m_Device, 
		height,
		width,
		weight,
		1,
		FALSE,
		DEFAULT_CHARSET,
		OUT_DEFAULT_PRECIS,
		DEFAULT_QUALITY,
		DEFAULT_PITCH | FF_DONTCARE,
		font_name.c_str(),
		&font_ptr
	);

	if( ret != S_OK )
		return false;


	this->m_Fonts[ font_name ] = font_ptr;

	return true;
}

bool overlay::create_window_class()
{
	this->m_WindowClass.cbClsExtra = 0;
	this->m_WindowClass.cbSize = sizeof( WNDCLASSEX );
	this->m_WindowClass.cbWndExtra = 0;
	this->m_WindowClass.hbrBackground = CreateSolidBrush( RGB( 0, 0, 0 ) );
	this->m_WindowClass.hCursor = LoadCursor( nullptr, IDC_ARROW );
	this->m_WindowClass.hIcon = LoadIcon( nullptr, IDI_APPLICATION );
	this->m_WindowClass.hIconSm = LoadIcon( nullptr, IDI_APPLICATION );
	this->m_WindowClass.hInstance = this->m_HandleInstance;
	this->m_WindowClass.lpfnWndProc = WinProcedure;
	this->m_WindowClass.lpszClassName = L"OVCRG";
	this->m_WindowClass.lpszMenuName = L"OVCRG";
	this->m_WindowClass.style = CS_HREDRAW | CS_VREDRAW;

	if( !RegisterClassEx( &this->m_WindowClass ) )
		return false;

	return true;
}

bool overlay::create_window_overlay()
{
	const std::string name = "OVCRG";

	const auto ret = CreateWindowExA( 
		WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TRANSPARENT, 
		name.data(), 
		name.data(), 
		WS_POPUP, 
		1, 
		1, 
		this->m_Width, 
		this->m_Height, 
		nullptr, 
		nullptr, 
		this->m_HandleInstance, 
		this // very important to pass here the this pointer because of the handling in the windowproc function
	);

	if( !ret )
		return false;

	const auto ret2 = SetLayeredWindowAttributes( 
		ret, 
		RGB(0, 0, 0), 
		255, 
		LWA_ALPHA
	);

	if( !ret2 )
		return false;

	ShowWindow( ret, SW_SHOW );

	const auto margin = MARGINS( 0, 0, this->m_Height, this->m_Width );

	const auto ret3 = DwmExtendFrameIntoClientArea( ret, &margin );

	if( ret3 != S_OK )
		return false;

	this->m_OverlayWindow = ret;

	return true;
}

bool overlay::move_target_window()
{
	auto target_dim = RECT();

	GetWindowRect( this->m_TargetWindow, &target_dim );
	this->m_Width = target_dim.right - target_dim.left;
	this->m_Height = target_dim.bottom - target_dim.top;

	auto target_style = DWORD();

	target_style = GetWindowLong( this->m_TargetWindow, GWL_STYLE );

	if( !target_style )
		return false;

	if( target_style & WS_BORDER )
	{
		target_dim.top += 23;
		this->m_Height -= 23;
	}

	return MoveWindow( 
		this->m_OverlayWindow, 
		target_dim.left, 
		target_dim.top, 
		this->m_Width, 
		this->m_Height, 
		true
	);
}

bool overlay::initialize( const std::string& target_window_title )
{
	BOOL status;
	const auto dwm_ret = DwmIsCompositionEnabled( &status );

	if ( !status || dwm_ret != S_OK )
		return false;

	if( target_window_title.empty() )
		return false;

	const auto ret = FindWindowA( nullptr, target_window_title.c_str() );

	if( !ret )
		return false;

	this->m_TargetWindow = ret;

	auto target_dim = RECT();

	GetWindowRect(this->m_TargetWindow, &target_dim);
	this->m_Width = target_dim.right - target_dim.left;
	this->m_Height = target_dim.bottom - target_dim.top;

	CreateThread( 
		nullptr, 
		NULL, 
		(LPTHREAD_START_ROUTINE)ThreadProc, 
		 this,
		NULL,
		nullptr
	);

	return true;
}

bool overlay::initialize(const HWND& window_handle)
{
	if( !window_handle )
		return false;

	BOOL status;
	const auto dwm_ret = DwmIsCompositionEnabled(&status);

	if ( !status || dwm_ret != S_OK )
		return false;

	this->m_TargetWindow = window_handle;

	auto target_dim = RECT();

	GetWindowRect(this->m_TargetWindow, &target_dim);
	this->m_Width = target_dim.right - target_dim.left;
	this->m_Height = target_dim.bottom - target_dim.top;

	CreateThread(
		nullptr,
		NULL,
		(LPTHREAD_START_ROUTINE)ThreadProc,
		this,
		NULL,
		nullptr
	);

	return true;
}

void overlay::draw_string( const std::string& msg, const int32_t x, const int32_t y, const int32_t red, const int32_t green, const int32_t blue, const int32_t alpha )
{
	if( msg.empty() || x < 0 || y < 0 || red < 0 || blue < 0 || green < 0 || alpha < 0 )
		return;

	const auto current_font = this->get_used_font_ptr();

	if( !current_font )
		return;

	RECT Position = {};

	Position.left = x;
	Position.top = y;

	current_font->DrawTextA( nullptr, msg.data(), msg.size(), &Position, DT_NOCLIP, D3DCOLOR_ARGB( alpha, red, green, blue ) );
}

void overlay::draw_rect( const int32_t x, const int32_t y, const int32_t width, const int32_t height, const int32_t red, const int32_t green, const int32_t blue, const int32_t width_rect )
{
	D3DXVECTOR2 Rect[ 5 ];

	Rect[ 0 ] = D3DXVECTOR2( x, y );
	Rect[ 1 ] = D3DXVECTOR2( x + width, y );
	Rect[ 2 ] = D3DXVECTOR2( x + width, y + height );
	Rect[ 3 ] = D3DXVECTOR2( x, y + height );
	Rect[ 4 ] = D3DXVECTOR2( x, y );

	this->m_Line->SetWidth( width_rect > 0 ? width_rect : 1 );

	this->m_Line->Draw( Rect, 5, D3DCOLOR_ARGB( 255, red, green, blue ) );

}

void overlay::draw_line( const int32_t x, const int32_t y, const int32_t x2, const int32_t y2, const int32_t red, const int32_t green, const int32_t blue, const int32_t width )
{
	D3DXVECTOR2 Line[ 2 ];

	Line[ 0 ] = D3DXVECTOR2( x, y );
	Line[ 1 ] = D3DXVECTOR2( x2, y2 );

	this->m_Line->SetWidth( width > 0 ? width : 1 );

	this->m_Line->Draw( Line, 2, D3DCOLOR_ARGB( 255, red, green, blue ) );
}

void overlay::draw_filled_rect(const int32_t x, const int32_t y, const int32_t width, const int32_t height, const int32_t red, const int32_t green, const int32_t blue)
{
	D3DXVECTOR2 Rect[ 2 ];
	Rect[ 0 ] = D3DXVECTOR2( x + width / 2, y );
	Rect[ 1 ] = D3DXVECTOR2( x + width / 2, y + height );
	this->m_Line->SetWidth( width );
	this->m_Line->Draw( Rect, 2, D3DCOLOR_ARGB( 255, red, green, blue ) );
}

void overlay::draw_circle(const int32_t x, const int32_t y, const int32_t radius, const int32_t red, const int32_t green, const int32_t blue)
{
}
```

`Overlay/overlay.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <unordered_map>
#include <memory>

#include <d3d9.h>
#include <d3dx9.h>
#include <string>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

class overlay
{

public:

	///-------------------------------------------------------------------------------------------------
	/// <summary>Default constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	overlay() :
	m_Object( nullptr ),
	m_Device( nullptr ),
	m_Width( 0 ),
	m_Height( 0 ),
	m_OverlayWindow( HWND() ),
	m_TargetWindow( HWND() ),
	m_WindowClass( { } ),
	m_HandleInstance( nullptr ),
	m_Line( nullptr )
	{ }

	///-------------------------------------------------------------------------------------------------
	/// <summary>Constructor.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="overlay_width"> 	Width of the overlay.</param>
	/// <param name="overlay_height">	Height of the overlay.</param>
	///-------------------------------------------------------------------------------------------------

	overlay( const int32_t overlay_width, const int32_t overlay_height ) :
	m_Object( nullptr ),
	m_Device( nullptr ),
	m_Width( overlay_width ),
	m_Height( overlay_height ),
	m_OverlayWindow( HWND() ),
	m_TargetWindow( HWND() ),
	m_WindowClass( { } ),
	m_HandleInstance( nullptr ),
	m_Line( nullptr )
	{ }

	///-------------------------------------------------------------------------------------------------
	/// <summary>Destructor, which releases the DirectX object and destroys the overlay window.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual ~overlay()
	{
		if( this->m_Object )
			this->m_Object->Release();

		if( this->m_OverlayWindow )
			DestroyWindow( this->m_OverlayWindow );
	}

	overlay( const overlay & ) = delete;
	overlay( const overlay && ) = delete;
	overlay& operator=( overlay && ) = delete;
	overlay& operator=( const overlay & ) = delete;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets overlay width.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The overlay width.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline int32_t get_overlay_width() const noexcept
	{
		return this->m_Width;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets overlay height.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The overlay height.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline int32_t get_overlay_height() const noexcept
	{
		return this->m_Height;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets overlay window handle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The overlay window handle.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline HWND get_overlay_window_handle() const noexcept
	{
		return this->m_OverlayWindow;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets target window handle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The target window handle.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline HWND get_target_window_handle() const noexcept
	{
		return this->m_TargetWindow;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets window class.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The window class.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline WNDCLASSEX get_window_class() const noexcept
	{
		return this->m_WindowClass;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets handle instance.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>The handle instance.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline HINSTANCE get_handle_instance() const noexcept
	{
		return this->m_HandleInstance;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the used DirectX object as pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the object as pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline IDirect3D9Ex* get_object_as_ptr() const noexcept
	{
		return this->m_Object;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the DirectX device as pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the device as pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline IDirect3DDevice9Ex* get_device_as_ptr() const noexcept
	{
		return this->m_Device;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the DirectX line as pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the line as pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline ID3DXLine* get_line_as_ptr() const noexcept
	{
		return this->m_Line;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the target window.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="handle">	Handle of the target window.</param>
	///-------------------------------------------------------------------------------------------------

	void set_target_window( HWND handle )
	{
		this->m_TargetWindow = handle;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the DirectX object pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="obj_ptr">	[in,out] If non-null, the object pointer.</param>
	///-------------------------------------------------------------------------------------------------

	void set_object_ptr( IDirect3D9Ex* obj_ptr )
	{
		this->m_Object = ( obj_ptr != nullptr ) ? obj_ptr : this->m_Object;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the DirectX device pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="device_ptr">	[in,out] If non-null, the device pointer.</param>
	///-------------------------------------------------------------------------------------------------

	void set_device_ptr( IDirect3DDevice9Ex* device_ptr )
	{
		this->m_Device = ( device_ptr != nullptr ) ? device_ptr : this->m_Device;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the DirectX line pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="line_ptr">	[in,out] If non-null, the line pointer.</param>
	///-------------------------------------------------------------------------------------------------

	void set_line_ptr( ID3DXLine* line_ptr )
	{
		this->m_Line = ( line_ptr != nullptr ) ? line_ptr : this->m_Line;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets overlay height.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="height">	The height.</param>
	///-------------------------------------------------------------------------------------------------

	void set_overlay_height( const int32_t height )
	{
		this->m_Height = ( height > 0 ) ? height : this->m_Height;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets overlay width.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="width">	The width.</param>
	///-------------------------------------------------------------------------------------------------

	void set_overlay_width( const int32_t width )
	{
		this->m_Width = ( width > 0 ) ? width : this->m_Width;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets a DirectX font as pointer, by it's name.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="font_name">	Name of the font.</param>
	///
	/// <returns>Null if it fails, else the font as pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] ID3DXFont* get_font_as_ptr( const std::string& font_name ) const noexcept
	{
		try
		{
			return this->m_Fonts.at( font_name );

		}
		catch( std::exception& e )
		{
			UNREFERENCED_PARAMETER( e );
			return nullptr;
		}
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Sets the current used DirectX font, be careful the font must be already registered!</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="font_name">	Name of the font, which should be used (must be already registered!!!).</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool set_used_font( const std::string & font_name )
	{
		if( !this->m_Fonts.contains( font_name ) )
			return false;

		this->m_UsedFont = font_name;

		return true;
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Gets the current used DirectX font pointer.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>Null if it fails, else the used font pointer.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] inline ID3DXFont* get_used_font_ptr() noexcept
	{
		if( this->m_Fonts.empty() )
			return nullptr;

		return this->m_Fonts.at( this->m_UsedFont );
	}

	///-------------------------------------------------------------------------------------------------
	/// <summary>Registers the DirectX font.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="font_name">	Name of the font.</param>
	/// <param name="height">   	(Optional) The height.</param>
	/// <param name="width">		(Optional) The width.</param>
	/// <param name="weight">   	(Optional) The weight.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool register_font( const std::string & font_name, const int32_t height = 20, const int32_t width = 0, const int32_t weight = FW_NORMAL );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Creates window class.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool create_window_class();

	///-------------------------------------------------------------------------------------------------
	/// <summary>Creates window overlay.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool create_window_overlay();

	///-------------------------------------------------------------------------------------------------
	/// <summary>Determines if we can move target window and replace it in the correct position.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	bool move_target_window();

	///-------------------------------------------------------------------------------------------------
	/// <summary>Initializes the overlay with an window title, this function also creates the window, overlay and thread.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="target_window_title">	Target window title.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool initialize( const std::string & target_window_title );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Initializes the overlay with an handle to the game window, this function also creates the window, overlay and thread.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="window_handle">	Handle of the window.</param>
	///
	/// <returns>True if it succeeds, false if it fails.</returns>
	///-------------------------------------------------------------------------------------------------

	[[nodiscard]] bool initialize( const HWND & window_handle );

	///-------------------------------------------------------------------------------------------------
	/// <summary>This virtual function you need to implement and should contain your render logic.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///-------------------------------------------------------------------------------------------------

	virtual void render() = 0;

	///-------------------------------------------------------------------------------------------------
	/// <summary>Draw string.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="msg">  	The string.</param>
	/// <param name="x">		The x coordinate.</param>
	/// <param name="y">		The y coordinate.</param>
	/// <param name="red">  	The red color (0-255).</param>
	/// <param name="green">	The green color (0-255).</param>
	/// <param name="blue"> 	The blue color (0-255).</param>
	/// <param name="alpha">	(Optional) The alpha (0-255).</param>
	///-------------------------------------------------------------------------------------------------

	void draw_string( const std::string & msg, const int32_t x, const int32_t y, const int32_t red, const int32_t green, const int32_t blue, const int32_t alpha = 255 );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Draw rectangle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="x">	 	The x coordinate.</param>
	/// <param name="y">	 	The y coordinate.</param>
	/// <param name="width"> 	The width.</param>
	/// <param name="height">	The height.</param>
	/// <param name="red">   	The red color (0-255).</param>
	/// <param name="green"> 	The green color (0-255).</param>
	/// <param name="blue">  	The blue color (0-255).</param>
	/// <param name="width_rect"> 	The width of the line.</param>
	///-------------------------------------------------------------------------------------------------

	void draw_rect( const int32_t x, const int32_t y, const int32_t width, const int32_t height, const int32_t red, const int32_t green, const int32_t blue, const int32_t width_rect = 1);

	///-------------------------------------------------------------------------------------------------
	/// <summary>Draw line.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="x">		The start x coordinate.</param>
	/// <param name="y">		The start y coordinate.</param>
	/// <param name="x2">   	The end x coordinate.</param>
	/// <param name="y2">   	The end y coordinate.</param>
	/// <param name="red">  	The red color (0-255).</param>
	/// <param name="green">	The green color (0-255).</param>
	/// <param name="blue"> 	The blue color (0-255).</param>
	/// <param name="width"> 	The width of the line.</param>
	///-------------------------------------------------------------------------------------------------

	void draw_line( const int32_t x, const int32_t y, const int32_t x2, const int32_t y2, const int32_t red, const int32_t green, const int32_t blue, const int32_t width = 1 );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Draw filled rectangle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="x">	 	The x coordinate.</param>
	/// <param name="y">	 	The y coordinate.</param>
	/// <param name="width"> 	The width.</param>
	/// <param name="height">	The height.</param>
	/// <param name="red">   	The red color (0-255).</param>
	/// <param name="green"> 	The green color (0-255).</param>
	/// <param name="blue">  	The blue color (0-255).</param>
	///-------------------------------------------------------------------------------------------------

	void draw_filled_rect( const int32_t x, const int32_t y, const int32_t width, const int32_t height, const int32_t red, const int32_t green, const int32_t blue );

	///-------------------------------------------------------------------------------------------------
	/// <summary>Draw circle.</summary>
	///
	/// <remarks>cragson, 03/30/22.</remarks>
	///
	/// <param name="x">	 	The x coordinate.</param>
	/// <param name="y">	 	The y coordinate.</param>
	/// <param name="radius">	The radius.</param>
	/// <param name="red">   	The red color (0-255).</param>
	/// <param name="green"> 	The green color (0-255).</param>
	/// <param name="blue">  	The blue color (0-255).</param>
	///-------------------------------------------------------------------------------------------------

	void draw_circle( const int32_t x, const int32_t y, const int32_t radius, const int32_t red, const int32_t green, const int32_t blue );

protected:

	IDirect3D9Ex* m_Object;
	IDirect3DDevice9Ex* m_Device;

	int32_t m_Width;
	int32_t m_Height;

	HWND m_OverlayWindow, m_TargetWindow;

	std::unordered_map< std::string, ID3DXFont* > m_Fonts;

	WNDCLASSEX m_WindowClass;

	HINSTANCE m_HandleInstance;

	std::string m_UsedFont;

	ID3DXLine* m_Line;
};

struct wndproc_this_t
{
	overlay* m_this;
};
```

`README.md`:

```md
![osmium-logo](res/osmium-logo.png)

# **osmium** - A Framework for Windows external cheats, written in modern C++.

- ##  **Used in many of my own open-source external cheat projects, actively maintained and always aimed for fitting my personal needs when developing an external cheat. (See below for my cheat projects)**
    - **[Borderlands GOTY Enhanced](https://github.com/cragson/bl-goty-external)**
    - **[Call of Duty Black Ops - Zombie mode](https://github.com/cragson/bo1-fun)**
    - **[Call of Duty Modern Warfare 3 - Survival mode](https://github.com/cragson/mw3-surviv0r)**
    - **[Crysis 2 - Remastered](https://github.com/cragson/crysis2-external)**
    - **[Dead Island - Definitive edition](https://github.com/cragson/dead-island-external)**
    - **[Dead Rising 2](https://github.com/cragson/dead-rising-2-external)**
    - **[DOOM Eternal](https://github.com/cragson/doom-eternal-cheat)**
    - **[Far Cry 4](https://github.com/cragson/far-cry-4-external)**
    - **[Magicite](https://github.com/cragson/magicite-external)**
    - **[Pokemon Mystery Dungeon Rescue Team Red (mGBA)](https://gthub.com/cragson/pkm-md-red)**
    - **[Risen](https://github.com/cragson/risen-external)**
    - **[Terraria](https://github.com/cragson/terraria-external)**


**The following content may change frequently due to the updates of the framework and might be not up2date at all times.**

# **Table of Contents**
1. **[A small foreword](#foreword)**
2. **[Installation & Setup](#installation--setup)**
3. **[Compilation](#compilation)**
4. **[Design of the framework](#design-of-the-framework)**
5. **[Examples of how to use osmium](#examples)**
    - [**Basic cheat module implementation**](#basic-cheat-module-implementation)
        -   [How to setup your features](#how-to-setup-your-features)
        -   [How to add new features to your cheat](#how-to-add-new-features-to-your-cheat)
        -   [How to setup your offsets](#how-to-setup-your-offsets)
        -   [How to run your cheat](#how-to-run-your-cheat)
    - [**Basic process implementation**](#basic-process-implementation)
        -   [How to initialize your process instance](#how-to-initialize-your-process-instance)
        -   [How to retrieve the image base of an image from the taget process](#how-to-retrieve-the-image-base-of-an-image-from-the-taget-process)
        -   [How to retrieve the image size of an image from the target process](#how-to-retrieve-the-image-size-of-an-image-from-the-target-process)
        -   [How to check if an image exists inside the dumped images](#how-to-check-if-an-image-exists-inside-the-dumped-images)
        -   [How to retrieve a pointer to an dumped image with the name of the image](#how-to-retrieve-a-pointer-to-an-dumped-image-with-the-name-of-the-image)
        -   [How to read memory](#how-to-read-memory)
        -   [How to write memory](#how-to-write-memory)
        -   [How to search for a signature (byte pattern)](#how-to-search-for-a-signature-byte-pattern)
        -   [How to dereference a address with image_x86 and image_x64](#how-to-dereference-a-address-with-image_x86-and-image_x64)
        -   [How to hexdump a memory region](#how-to-hexdump-a-memory-region)
        -   [How to read a ascii null terminated string](#how-to-read-a-ascii-null-terminated-string)
        -   [How to change the protection of a memory block](#how-to-change-the-protection-of-a-memory-block)
        -   [How to write to protected memory inside of the target process](#how-to-write-to-protected-memory-inside-of-the-target-process)
        -   [How to allocate a memory page inside of the target process with Read-Write-Execute rights](#how-to-allocate-a-memory-page-inside-of-the-target-process-with-read-write-execute-rights)
        -   [How to allocate a memory page inside of the target process with specific rights](#how-to-allocate-a-memory-page-inside-of-the-target-process-with-specific-rights)
        -   [How to create a x86 hook](#how-to-create-a-x86-hook)
        -   [How to destroy a x86 hook](#how-to-destroy-a-x86-hook)
        -   [How to inject a DLL with LoadLibrary](#how-to-inject-a-dll-with-loadlibrary)
		-	[How to get a pointer to the DOS header of an image](#how-to-get-a-pointer-to-the-dos-header-of-an-image)
        -   [How to get a pointer to the NT headers of an image](#how-to-get-a-pointer-to-the-nt-headers-of-an-image)
        -   [How to get a pointer to the import descriptor of an image](#how-to-get-a-pointer-to-the-import-descriptor-of-an-image)
        -   [How to parse/retrieve all imports of an image](#how-to-parseretrieve-all-imports-of-an-image)
        -   [How to get a pointer to the Process Environment Block (PEB) of the target process](#how-to-get-a-pointer-to-the-process-environment-block-peb-of-the-target-process)
        -   [How to retreive the PEB from the target process](#how-to-retreive-the-peb-from-the-target-process)
        -   [How to retreive the ImageBaseAddress of the PEB from the target process](#how-to-retreive-the-imagebaseaddress-of-the-peb-from-the-target-process)
        -   [How to retreive all modules inside InMemoryOrderModuleList of the PEB from the target process](#how-to-retreive-all-modules-inside-inmemoryordermodulelist-of-the-peb-from-the-target-process)
        -   [How to search for specific imports inside all modules from InMemoryOrderModuleList of the PEB from the target process](#how-to-search-for-specific-imports-inside-all-modules-from-inmemoryordermodulelist-of-the-peb-from-the-target-process)
        -   **[Inter-Process communication (IPC)](#inter-process-communication-ipc)**
            - [How to setup named shared memory x86](#how-to-setup-named-shared-memory-x86)
            - [How to read and write from/to the shared memory x86](#how-to-read-and-write-fromto-the-shared-memory-x86)
            - [How to clear the shared memory buffer x86](#how-to-clear-the-shared-memory-x86)
            - [How to remove named shared memory x86](#how-to-remove-named-shared-memory-x86)
        -   **[RegisterDumper x86](#registerdumper-x86)**
            - [How to create a register dumper x86](#how-to-create-a-register-dumper-x86)
            - [How to start a register dumper x86](#how-to-start-a-register-dumper-x86)
            - [How to stop a register dumper x86](#how-to-stop-a-register-dumper-x86)
            - [How to destroy a register dumper x86](#how-to-destroy-a-register-dumper-x86)
            - [How to check if a registercontext is active or not](#how-to-check-if-a-registercontext-is-active-or-not)
            - [How to retrieve a pointer to a registercontext with the dumped address](#how-to-retrieve-a-pointer-to-a-registercontext-with-the-dumped-address)
            - [How to access the registers data from the registercontext](#how-to-access-the-registers-data-from-the-registercontext)
    - [**Basic overlay implementation**](#basic-overlay-implementation)
        -   [How to setup your overlay](#how-to-setup-your-overlay)
        -   [How to draw a string](#how-to-draw-a-string)
        -   [How to draw a line](#how-to-draw-a-line)
        -   [How to draw a rect](#how-to-draw-a-rect)
        -   [How to draw a filled rect](#how-to-draw-a-filled-rect)
        -   [How to register a new font](#how-to-register-a-new-font)
        -   [How to change the current font](#how-to-change-the-current-font)
        -   [How to run your overlay](#how-to-run-your-overlay)

## **Foreword**
Since I began programming external cheats, I always wanted to have my own framework which I can use for any game and which should be easy and quick to setup. 
This was and is not an easy task for me but this project should not be a demonstration for best practices.
It is a collection of functionalities which I need to get my cheats done and these functionalities are not implemented in the best or stable way possible.
I got my own way of doing things and I am learning everyday new stuff, which I want to implement and test right away.
As I am still learning this project will be growing in it's own ways and will learn with me while evolving.
This description should give you, as an reader, a better feeling for the framework because you read the thoughts of the creator and his individual philosophy.

My goal for the framework is modularity and genericity at the right places.
The problem I have is that I don't know currently how I combine all different "modules" of the framework clever enough, so they will still be generic and easy to setup.
At some point you need specific definitions and restrictions implemented and these are all individual.
So the project might seem a bit more complicated to setup than it needed to be.
I hope I can take up on this problem in the future and solve it in a clever way.  

Until then I do my best to describe every tricky part as good as possible for me!
Thank you very much for reading this foreword, which I think this is important!

If you have any recommendations, encounter any problems or just want to give me some hints - make sure to contact me or open a pull request.

## **Installation & Setup**
For the framework to work out of the box you need some steps.
The first thing is the right folder structure, because the relative paths won't work properly if the folder structure is not right.
Because I am using Visual Studio as a IDE for C++, I will show the folder structure for this case.
Feel free to adapt the paths for yourself, if needed.

The default folder structure is the following (Example for Visual Studio):
```
project
│   project.vcxproj
│   project.vcxproj.filters    
│   project.vcxproj.user
|   main.cpp
|
└───osmium
    │   README.md
    │   .gitignore
    │
    |───Cheat
    |   │   cheat.hpp
    |   │   ...
    |
    └───Includings
        │   custom_data_types.hpp
        │   ...
    ...
...
```

After you did create your visual studio project, you need to clone this repository into it.
With the following command you can clone the repo correctly.

1. ```git clone https://github.com/cragson/osmium.git```

If you want to use the Overlay of the framework you need the DirectX-SDK, which you can download directly by clicking the link down below.
And the project will probably not compile without linking the includings and libs with it.
I'll explain these steps later on in detail.

2. [https://www.microsoft.com/en-us/download/confirmation.aspx?id=6812](https://www.microsoft.com/en-us/download/confirmation.aspx?id=6812)
## **Compilation**
To compile a project with this framework you need to prepare some things before.
1. **Make sure to link the DirectX includings and libs with Visual Studio**
    *   Go to **Project** -> **Properties** -> **VC++ Directories**
    *   You need to enter your DirectX Includes path under **External Include Directories**
    *   You need to enter your DirectX Libraries path under **Library Directories**
    *   Also make sure to do these changes for all configurations (Debug and Release) and the correct Platform!
    *   Another thing to watch out for is the correct library path from DirectX for your current platform!
    *   ![Project Settings](res/project-settings.png)
    *   ![DirectX Linking](res/project-directx-linking.png)
2. **Make sure to set the correct C++ Language Standard**
    * Go to **Project** -> **Properties** -> **General**
    * Try setting the **C++ Language Standard** to **/std:c++20**, if this won't work for some reason try setting it to **/std:c++latest**
    * ![C++ Language Standard](res/project-settings-language.png)

After these steps you should be able to successfully compile.
## **Design of the framework**
The framework contains the following modules:
- Cheat
    * Here you can find your interface for the cheat class, which you need for running the cheat logic, implementing features, dumping offsets and printing them.
    * There is also the feature interface which you can use for implementing your features, setting hotkeys, overwriting the render, tick and startup logic of the feature and give it a custom name.
    * This module is pretty essential as you need it to run any cheat feature related code.
    - `cheat::setup_features`
        * Here you are creating your features and adding them to the internal features vector.
        * Example: [How to setup your features](#how-to-setup-your-features)
    - `cheat::setup_offsets`
        * Here you are preparing your offsets, like searching for patterns etc.
        * Example: [How to setup your offsets](#how-to-setup-your-offsets)
    - `cheat::run`
        * The most important method of the class because you run your own cheat logic in here.
        * This means checking if the hotkeys of features are pressed, handling the logic of enabling/disabling and tick'ing them when active etc.
        * Example: [How to run your cheat](#how-to-run-your-cheat)
    - `cheat::shutdown`
        * If your features need some special logic when the cheat will be shutdown, you should implement it right here
- Includings
    * The most important thing here is the `modules.hpp` because you find a namespace with the testing implementations of `process`, `cheat` and `overlay` in it.
    * Also you will find some of my own data type definitions like the `byte_vector` or the `WILDCARD_BYTE` in it.
- Memory
    * This is **the CORE** module of the framework!
    * Because it is a wrapper for the WindowsAPI to interact with other processes and all needed operations for an external cheat.
    * **The process instance will dump ALL images inside of the target process and hold them in `private proces::m_images` for you**
    * You need to initialize a `process` class instance with a proper identifier and after that you are able to read and write memory, find byte patterns, create hooks with shellcode and a lot more.
        - Example: [How to initialize your process instance](#how-to-initialize-your-process-instance)
    * In most of the time you need this module because your cheat relies on modifying the memory of the target process.
    * The `process` class can be used for **both x86 and x64** architecture, it uses some macros which change the important lines in it dependent on which platform you use.
    * Also you find some other nice classes in it like `image_x86`, `image_x64` and `hook`:
        - `image_x86` is a wrapper for Windows x86 PE's
        - `image_x64` is a wrapper for Windows x64 PE's
        - `hook` is a class which is used for basic mid function hooking with custom shellcode on a allocated memory page inside the target process.
    * I can only suggest you to read into the code on yourself. I tried my best to cover a lot of the functionalities in understandable and easy examples. You find them here [Basic process implementation](#basic-process-implementation).
- Overlay
    * Before I say anything about that, I need to give proper credits to **Icew0lf83**! I came in contact with him and we shared our ideas and thoughts on a project, so I asked him if I am allowed to rewrite his DirectX9 Overlay and Renderer for my own purposes and he gave me the permissions to do it.
    * I did learn a lot while rewriting his code but I can't say this is the way to do a proper DirectX9 Overlay and/or Renderer. I still know too little of DirectX but I only wanted to serve my use cases for drawing. Maybe I will rewrite this whole module in the future, if I have time to dig a lot deeper into DirectX.
    * You will need to initialize this overlay with just the window title of the target process or a window handle to it, if you need any inspiration you might wanna have a look at [Basic overlay implementation](#basic-overlay-implementation).
    
- Testing
    * Here is my own implementation of the `cheat` and `overlay` logics.
    * If you don't wanna do it yourself you can just use this and be satisfied with the `modules.hpp` in `Includes` to be ready for your cheat to use.
## **Examples**
- ### **Basic cheat module implementation**
    - ### **How to setup your features**
        Every feature must inherit of the `feature` class and you need to overwrite every virtual function from the parent class.
        The header file of a new feature can look like this:
        ```cpp
            #pragma once
            #include "../osmium/Cheat/Feature/feature.hpp"

            class empty_feature : public feature
            {

            public:

                void on_disable() override;

                void on_enable() override;

                void on_first_activation() override;

                void tick() override;

                void on_render() override;

                void on_shutdown() override;
            };
        ```
        **The include path to the feature file may differ from your local folder structure!**
        
        You see you have five virtual functions which you need to override here.
        - `on_disable` will be executed when the feature gets disabled
        - `on_enable` will be executed when the feature gets enabled
        - `on_first_activation` will be executed when the feature gets the first time activated
        - `tick` is not called by default but should be called frequently when your feature is active, for an example look here: [How to run your cheat](#how-to-run-your-cheat).
        - `on_render` is not called by default but should be called in your overlay instance when the feature is active and wants to draw something, for an example look here: [How to run your overlay](#how-to-run-your-overlay).
        - `on_shutdown` should be called when the cheat is shutting down, like e.g. `cheat::shutdown`.
    
    - ### **How to add new features to your cheat**
        After you did finish your feature you want to add it to your `cheat` instance, right?
        I'll show you how to do this.

        You need to modify your `cheat::setup_features` function for this but to make sure to modify your own cheat class and not the interface one!

        If I want to add the `empty_feature` from [How to setup your features](#how-to-setup-your-features) to the cheat, I am able to configure the feature a bit more before adding.

        There are multiple functions in the `feature` interface, which you can use to configure the feature:
        - `set_status`
            * Here you can enable or disable the feature, if you pass a `true` to this function the feature will be enabled.
        - `set_virtual_key_code`
            * This is the way to configure which key you need to press to toggle your feature.
            * Here is a list of all virtual key codes: [https://docs.microsoft.com/de-de/windows/win32/inputdev/virtual-key-codes](https://docs.microsoft.com/de-de/windows/win32/inputdev/virtual-key-codes).
        - `set_activation_delay`
            * This is the delay in milliseconds, which you need to wait before toggling the feature again with the hotkey
        - `set_name`
            * here you can set the name of the feature, this will be needed for the `print_features` function of the cheat interface
        - `set_print_status`
            * If you enable this, everytime you enable or disable the feature a small info will be print into the console like: `[empty_feature] is enabled!` or `[empty_feature] is disabled!`
        - `enable_drawing`
            * If you want to render something make sure to call this function, because otherwise the on_render function will not be called.
            * **This also depends on your implementation of the overlay.**
        - `disable_drawing`
            * Here you can disable drawing for your feature

        Here is a small example for adding the `empty_feature` to the cheat
        ```cpp
        bool test_cheat::setup_features()
        {
            auto emptyfeature = std::make_unique< empty_feature >();
            emptyfeature->set_name( L"Fancy empty feature" );
            emptyfeature->set_virtual_key_code( VK_NUMPAD1 );
            emptyfeature->set_activation_delay( 1337 );
            emptyfeature->enable_print_status();
            this->m_features.push_back( std::move( emptyfeature ) );
            
            return true;
        }
        ```
    - ### **How to setup your offsets**
        Well here you should prepare your offsets by dumping them from the target process or using the dumped images to search for signatures.

        If you want to know a bit more about finding a signature, have a look here: [How to search for a signature (byte pattern)](#how-to-search-for-a-signature-byte-pattern)

        I am not going into detail here because this is something very individual here.
        Just as an example here is the `setup_offsets` function from my [Doom: Eternal cheat](https://github.com/cragson/doom-eternal-cheat/blob/89c5d57995cf0909a18ef73026df6c95af37d34f/cheat/SDK/doom_cheat.cpp#L36)

        **Please note that the `Globals` and `Offsets` namespaces here are not a part of the framework.
        ```cpp
        bool doom_cheat::setup_offsets()
        {
            if ( !Globals::g_pProcess->does_image_exist_in_map( L"DOOMEternalx64vk.exe" ) )
                return false;

            const auto game_image = Globals::g_pProcess->get_image_ptr_by_name( L"DOOMEternalx64vk.exe" );

            const auto ammo_patch = game_image->find_pattern( L"39 73 40 7D 07 03 FE" );
            if ( !ammo_patch )
                return false;

            Offsets::infinite_ammo_patch = ammo_patch + 3;

            
            const auto god_patch = game_image->find_pattern( L"84 C0 75 0C F3 0F 10 44 24 4C" );
            if( !god_patch )
                return false;

            Offsets::god_mode_patch = god_patch + 2;

            const auto upgrades_patch = game_image->find_pattern( L"41 8B E8 48 8B D9 44 01 84 B1" );
            if( !upgrades_patch )
                return false;

            Offsets::free_upgrades_patch = upgrades_patch + 7;

            return true;
        }
        ```
    - ### **How to run your cheat**
        In this chapter I want to talk about the logic of the `cheat::run` function.
        This is also something very individual, but I want to show you my own implementation of it and discuss some thoughts of mine while writing it.

        This code snippet is also from my [Doom: Eternal cheat](https://github.com/cragson/doom-eternal-cheat/blob/89c5d57995cf0909a18ef73026df6c95af37d34f/cheat/SDK/doom_cheat.cpp#L66), but I didn't change it in any other cheats.

        ```cpp
        void doom_cheat::run()
        {
            for ( const auto& feature : this->m_features )
            {
                // before tick'ing the feature, check first if the state will eventually change
                if ( utils::is_key_pressed( feature->get_virtual_key_code() ) )
                    feature->toggle();

                // let the feature tick() when active
                if ( feature->is_active() )
                    feature->tick();
            }
        }
        ```

        What does this function do? Let's split it into pieces.
        1.  Iterate over every feature inside of the `m_features` vector of the cheat
        2.  Check if the hotkey is pressed of the current feature and if this is the case, toggle the feature
        3.  If the feature is active/enabled, call the `tick` function of it.
    
        So with this basic procedure I am pretty satisfied already, for my purposes.
        I call the `doom_cheat::run` function in a infinite loop with a little sleep in it, so the features are quite often tick'ed when they are active.

        ```cpp
        while ( true )
        {
            Globals::g_pCheat->run();

            if ( utils::is_key_pressed( VK_END ) )
                break;

            Sleep( 3 );
        }
        ```

        You should see here now why I wrote in [How to setup your features](#how-to-setup-your-features) that it depends on how `features::tick` is called. You can implement any logic you want.
        But as I don't want to overcomplicate it for others, you can just stick to the logic here - if you want!
- ### **Basic process implementation**
    - ### **How to initialize your process instance**
        You have multiple ways of initializing your process instance but I try to break it down for you.
        First you need to think of an identifier of the target process, how can you identify it for sure?
        There are a few ways:
        - The process id 
        - The process name
        - The window name 

        You need to choose one of these identifiers and pass them to the `process::setup_process` function.

        If you want to initialize a process instance with the process id from some process, you can do it like this:
        ```cpp
        bool init_process()
        {
            const auto g_pProcess = std::make_unique< process >();

            if( !g_pProcess->setup_process( 1337 ) ) // 1337 is the process id from the target process
                return false;

            return true;
        }
        ```

         If you want to initialize a process instance with the process name from some process, you can do it like this:
        ```cpp
        bool init_process()
        {
            const auto g_pProcess = std::make_unique< process >();

            // Be careful setup_process wants a std::wstring, check your project settings (multibyte/unicode)
            if( !g_pProcess->setup_process( L"fancyprocess.exe" ) )
                return false;

            return true;
        }
        ```

         If you want to initialize a process instance with the window name from some process, you can do it like this:
        ```cpp
        bool init_process()
        {
            const auto g_pProcess = std::make_unique< process >();

            if( !g_pProcess->setup_process( L"I am a very fance window title", false ) ) // Make sure to pass the false as second argument, if you want to use a window name!
                return false;

            return true;
        }
        ```
    - ### **How to retrieve the image base of an image from the taget process**
        Here you need to be careful because the `process` class can only get a image base which was already dumped from the process!

        If the image was not dumped, the `process::get_image_base` function will return 0.

        ```cpp
        void work_with_image_base()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_base wants a std::wstring, check your project settings (multibyte/unicode)
            const auto image_base = g_pProcess->get_image_base( L"fancy_image.exe" );

            // PrInT iT tO dAh CoNsOlE
            printf( "[+] image base is: 0x%08X\n", image_base );
        }
        ```
    - ### **How to retrieve the image size of an image from the target process**
        Here you need to be careful because the `process` class can only get a image base which was already dumped from the process!

        If the image was not dumped, the `process::get_image_size` function will return 0.

        ```cpp
        void work_with_image_size()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_size wants a std::wstring, check your project settings (multibyte/unicode)
            const auto image_size = g_pProcess->get_image_size( L"fancy_image.exe" );

            // PrInT iT tO dAh CoNsOlE
            printf( "[+] image size is: 0x%08X\n", image_size );
        }
        ```
    - ### **How to check if an image exists inside the dumped images**

        You can do this easily with the `process::does_image_exist_in_map` function, which returns true when the image exists or false if not.

        ```cpp
        void check_if_fancy_image_exists()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful does_image_exist_in_map wants a std::wstring, check your project settings (multibyte/unicode)
            if( g_pProcess->does_image_exist_in_map( L"fancy_image.exe" ) )
                printf( "[!] Fancy image exists.\n" );
            else
                printf( "[!] Fuck me, something is wrong.\n" );
        }
        ```
    - ### **How to retrieve a pointer to an dumped image with the name of the image**
        You can do this easily with the `process::get_image_ptr_by_name` function, which also checks if the image exists or not.

        **BE FUCKING CAREFUL BECAUSE IF THE IMAGE DOES NOT EXIST, THIS FUNCTION WILL RETURN A NULLPTR**
        ```cpp
        void get_my_fancy_image()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_ptr_by_name wants a std::wstring, check your project settings (multibyte/unicode)
            const auto fancy_image = g_pProcess->get_image_ptr_by_name( L"fancy_image.exe" );

            // ALWAYS VALIDATE POINTER, my friend
            if( !fancy_image )
                return;

            const auto fancy_base = fancy_image->get_image_base();
            const auto fancy_size = fancy_image->get_image_size();
            const auto fancy_run = fancy_image->is_executable();
            // etc..
        }
    - ### **How to read memory**
        You can do this by using the `process::read` function. It is pretty much self explaining.
        You pass the memory address you want to read to the function, give the data type and receive the result.

        ```cpp
        void read_fancy_stuff()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            const auto fancy_byte = g_pProcess->read< uint8_t >( 0xDEADAFFE - 100 );

            const auto fancy_int = g_pProcess->read< int32_t >( 0xDEADAFFE );

            const auto fancy_float = g_pProcess->read< float >( 0xDEADAFFE + 100 );

            const auto fancy_double = g_pProcess->read< double >( 0xDEADAFFE + 200 );

            const auto fancy_uint = g_pProcess->read< std::uintptr_t >( 0xDEADAFFE + 300 );
        }
        ```
    - ### **How to write memory**
        You can do this by using the `process::write` function. It is pretty much self explaining.
        You pass the memory address you want to read to the function, give the data type, value to write and receive a bool if the call to `WriteProcessMemory` was successful or not.

        ```cpp
        void write_fancy_stuff()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            g_pProcess->write< uint8_t >( 0xDEADAFFE - 100, 0x69 );

            g_pProcess->write< int32_t >( 0xDEADAFFE, 1337 );

            if( !g_pProcess->write< float >( 0xDEADAFFE + 100, 13.37f ) )
                return;
            
            // etc..
        }
        ```
    - ### **How to search for a signature (byte pattern)**
        First I need to say there are really really many ways of how to search for a signature and even more ways of how to define a byte signature.
        
        I went the way I am most comfortable with by using the "IDA style" of byte signatures.
        This ways you can declare a sequence of bytes the following way:
        -   74 00 90 90 A2 C7
        -   74 ? ? ? ? C7

        The hex numbers are the value of the bytes and the `?` is a wildcard, which means the bytes there doesn't matter for matching the pattern because they can change at everytime (like a memory address for example).

        You can search for a signature by using the `image_x86::find_pattern` or `image_x64::find_pattern` function.
        Also I implemented the function `find_all_pattern_occurences`, which will return a vector of memory addresses where the pattern was matched successfully.
        So if you want to use that functions you need the pointer to the image, in where the signature should be matched.
        Also you can pass a optional bool as the second argument, to decide of the results should be relative to the image base or not.

        Here is a little code snippet, which should make the usage more clear:
        ```cpp
        void find_fancy_signatures()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_ptr_by_name wants a std::wstring, check your project settings (multibyte/unicode)
            const auto fancy_image = g_pProcess->get_image_ptr_by_name( L"fancy_image.exe" );

            // ALWAYS VALIDATE POINTER, my friend
            if( !fancy_image )
                return;

            // absolute address where the pattern matches (image base + offset)
            const auto result = fancy_image->find_pattern( "DE AD BE EF" );
            
            // relative address where the pattern matches (offset)
            const auto result2 = fancy_image->find_pattern( "DE AD BE EF", false );

            const auto result3 = fancy_image->find_pattern( "DE AD ? EF" );
            const auto result3 = fancy_image->find_pattern( "DE AD ? EF", false );
        }
        ```
    - ### **How to dereference a address with `image_x86` and `image_x64`**
        You can use the `image_x86::deref_address` or the `image_x64::deref_address` function to dereference a address from a dumped image.

        Here is a little code snippet, which should make the usage more clear:
        ```cpp
        void dereference_fancy_signatures()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_ptr_by_name wants a std::wstring, check your project settings (multibyte/unicode)
            const auto fancy_image = g_pProcess->get_image_ptr_by_name( L"fancy_image.exe" );

            // ALWAYS VALIDATE POINTER, my friend
            if( !fancy_image )
                return;

            // absolute address where the pattern matches (image base + offset)
            const auto result = fancy_image->find_pattern( "DE AD BE EF" );
            
            const auto deref = fancy_image->deref_address< std::uintptr_t >( result + 7 );
        }
        ```
    - ### **How to hexdump a memory region**
        I implemented this functionality just because I think this pretty damn cool. When I started reading about cheats and Reverse Engineering I saw pretty often the typical hex dump pictures as header in articles. ^^

        You can use the `print_memory_region` function inside `image_x86` or `image_x64` to dump a memory region.
        To the function you need to pass the start address, the size and a bool if you want to print absolut addresses.

        For example here is a small code snippet:
        ```cpp
        void print_fancy_region()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_ptr_by_name wants a std::wstring, check your project settings (multibyte/unicode)
            const auto fancy_image = g_pProcess->get_image_ptr_by_name( L"fancy_image.exe" );

            // ALWAYS VALIDATE POINTER, my friend
            if( !fancy_image )
                return;

            // Will print the first 256 bytes, starting at the address 0x13376077 as absolute addresses
            fancy_image->print_memory_region( 0x13376077, 256, true );
        }
        ```
    - ### **How to read a ascii null terminated string**
        Here you have multiple ways of reading a string:
        - Read it from a dumped image inside `process::m_images` 
        - Read it right from the memory of the target process

        If you want to read it from a dumped image you should use the `read_string_from_address` function from `image_x86` or `image_x64`. But be careful, if the address is not valid the function will return `OSMIUM_INVALID_ADDRESS` and make sure the string is **nullterminated**!
        Also the function takes one argument the address and one optional argument, which indicates if the given address should be handled as a absolute one or if it's relative.

        Here is a little code snippet for you:
        ```cpp
        void read_fancy_string_from_dumped_image()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // Be careful get_image_ptr_by_name wants a std::wstring, check your project settings (multibyte/unicode)
            const auto fancy_image = g_pProcess->get_image_ptr_by_name( L"fancy_image.exe" );

            // ALWAYS VALIDATE POINTER, my friend
            if( !fancy_image )
                return;

            // reads string from address 0x4000AFFE - the base of the fancy_image
            const auto absolute_fancy_string = fancy_image->read_string_from_address( 0x4000AFFE );

            const auto relative_fancy_string = fancy_image->read_string_from_address( 0xAFFE, true );
        }
        ```

        If you want to read the string right from the memory of the target process, you need to use the `read_ascii_null_terminated_string` from the `process` class.
        
        **Make sure the string is nullterminated in memory!**

        Also if the chars are not ascii, the function will return `OSMIUM_NO_ASCII`.

        Here is a little code snippet for you:
        ```cpp
        void read_string_from_memory()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            const auto fancy_string = g_pProcess->read_ascii_null_terminated_string( 0xAFFEDEAD );

            if( !fancy_string.empty() && fancy_string != "OSMIUM_NO_ASCII" )
                printf( "[!] String could be read from memory!\n" );
            else
                printf( "[!] Could not read the string from memory!\n" );
        }
        ```
    - ### **How to change the protection of a memory block**
        Here you should use the `change_protection_of_memory_block` function inside the `process` class.
        You pass the address, size and protection to this function and if it fails it returns 0 or if it succeeds it will return the old protection rights, so you can restore them later on. 

        Here is a small code snippet for you:
        ```cpp
        void change_memory_protection()
        {
             // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // In this example I want to patch a memory block inside of fancy_image.exe
            // so I need the base address of the image first
            const auto fancy_base = g_pProcess->get_image_base( L"fancy_image.exe" );

            if( !fancy_base )
                return;
            
            // make the memory block writable
            auto old_protection = g_pProcess->change_protection_of_memory_block( 
                fancy_base + 0x1000, 
                sizeof( uint32_t ), 
                PAGE_EXECUTE_READWRITE 
                ); 

            // modify some bytes yo
            g_pProcess->write< uint32_t >( fancy_base + 0x1000, 0x90909090 );

            // restore old protection of the memory block inside fancy_image.exe
            old_protection = g_pProcess->change_protection_of_memory_block( 
                fancy_base + 0x1000, 
                sizeof( uint32_t ), 
                old_protection 
            ); 
        }
        ```
    - ### **How to write to protected memory insside of the target process**
        For this use case I got the `write_to_protected_memory` function inside of the `process` class for you.
        You need to pass the address, value and optional the size to it and you will have fun.
        It will return a bool if it could write to the memory or not.

        Here is a small code snippet for you:
        ```cpp
        void overwrite_protected_bytes()
        {
             // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // In this example I want to patch a memory block inside of fancy_image.exe
            // so I need the base address of the image first
            const auto fancy_base = g_pProcess->get_image_base( L"fancy_image.exe" );

            if( !fancy_base )
                return;
            
            if( g_pProcess->write_to_protected_memory< float >( 0xAFFE1337, 60.77f ) )
                printf( "[!] Overwrote the damn hair length of the monkey.\n" );
            else
                printf( "[!] Could not write to the protected memory, what the monkey..\n" );
        }
        ```
    - ### **How to allocate a memory page inside of the target process with Read-Write-Execute rights**
        You should use the `allocate_rwx_page_in_process` function inside the `process` class for this.
        The function takes only one optional argument, the wanted size of the memory page which should be allocated.
        It will return a pointer to the allocated page if it succeeds, if it fails it will return a null pointer.
        **Be careful you need to take care of free'ing the allocated memory page to not leak any memory!**

        Here is a small code snippet for you:
        ```cpp
        void allocate_rwx_monkaeh()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            const auto monkaeh_page = g_pProcess->allocate_rwx_page_in_process();

            if( !monkaeh_page )
                return;

            printf( "[+] Allocated the damn monkaaaaaaehs at: 0x%p\n", monkaeh_page );

            const auto big_monkey = g_pProcess->allocate_rwx_page_in_process( 0x1000 * 20 );

            if( !big_monkey )
                return;

            printf( "[+] Allocated the big fuckin monkey at: 0x%p\n", big_monkey );
        }
        ```
        
    - ### **How to allocate a memory page inside of the target process with specific rights**
        For this purpose you can use the `allocate_page_in_process` function inside of the `process` class.
        Just pass the needed page protection and optional the wanted size of the memory page to the function and you should receive a pointer to the fresh allocated memory page inside of the target process.
        **Be careful you need to take care of free'ing the allocated memory page to not leak any memory!**

        Here a small code snippet for you:
        ```cpp
        void allocate_some_monkeys()
        {
            // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            const auto fresh_island = g_pProcess->allocate_page_in_process( PAGE_EXECUTE_READWRITE );

            if( !fresh_island )
                return;
            
            printf( "[+] Allocated the fresh island at: 0x%p\n", fresh_island );

            const auto fresh_small_island = g_pProcess->allocate_page_in_process( PAGE_EXECUTE, 0x2000 );

            if( !fresh_small_island )
                return;

            printf( "[+] Allocated a tropical island at: 0x%p\n", fresh_small_island );
        }
        ```
    - ### **How to create a x86 hook**
        This is little more complicated than the other things before but actually not that complex.
        I will try my best to break it down as easy and understandable for you as I can.

        The idea is that I want to hook functions inside the target process but as the framework is for external cheats, hooking is a bit more difficult than beeing internal.
        But this is classic mid function hook concept, because it is very practical and easy to accomplish externally.
        So my idea was:
        1. Write shellcode (your hook)
        2. Allocate a rwx memory page inside of the target process
        3. Copy the shellcode inside the memory page
        4. Calculate the jump address to the hooked function after the placed jump to the memory page and copy it after the shellcode on the memory page
        5. Place jump instruction and the calculated address after the shellcode on the memory page
        6. Overwrite the hooked function partially with the jump to the allocated memory page
        7. En - fucking - joy

        After the function got hooked a `hook` instance will be created with the given arguments and stored inside the `process::m_hooks` vector. Don't worry about unhooking, the destructor of the `process` class automatically unhooks all functions when destroying itself. ;)

        Basically you don't have to worry about this, just get familiar with it and it should be self explaining.

        Here is a small code snippet for you:
        ```cpp
        void hook_da_monkaeh()
        {
             // initialize here the process instance (yes yes it would be only local but idc for this example)
            if( !init_process() )
                return;

            // In this example I want to hook a specific function inside of fancy_image.exe
            // so I need the base address of the image first
            const auto fancy_base = g_pProcess->get_image_base( L"fancy_image.exe" );

            if( !fancy_base )
                return;

            // now I need my shellcode, which will be my hook
            std::vector< uint8_t > shellcode = {
                0x50,                               // push eax
                0xB8, 0x39, 0x05, 0x00, 0x00,       // mov eax, 1337
                0x03, 0x06,                         // add eax, dword ptr [esi]
                0x59                                // pop ecx

            };

            // At this address the function I want to hook is located
            const std::uintptr_t target_function = fancy_base + 0xAFFE;

            // I need to overwrite exactly 5 bytes on x86 because 1 byte jmp instruction + 4 bytes address and no other bytes needs to be overwritten/ nop'ed
            const size_t hook_size = 5;

            if( g_pProcess->create_hook_x86( target_function, hook_size, shellcode ) )
                printf( "[!] Successfully hooked the target function!\n" );
            else
                printf( "[!] Bloody hell something went wrong!\n" );
        }
        ```
    - ### **How to destroy a x86 hook**
        Well this is quite simple, just unhook it lol.

        The `destroy_hook_x86` function inside of the `process` class will automatically restore the original bytes, which were overwritten, and free the allocated memory page for the shellcode - so don't worry my friend.

        ```cpp
        void unhook_da_monkaeh()
        {
            // First hook the shit away
            hook_da_monkaeh();

            // Now unhook and solve the problems away

            const auto fancy_base = g_pProcess->get_image_base( L"fancy_image.exe" );

            if( !fancy_base )
                return;

            // I need the start address of the hook, which is the address I hooked
            // to unhook the shit
            const std::uintptr_t target_function = fancy_base + 0xAFFE;

            // U N H O O K
            if( g_pProcess->destroy_hook_x86( target_function ) )
                printf( "[!] Successfully unhooked :^)!\n" );
            else
                printf( "[!] MAYDAY MAYDAY error hello hi hallo holla bonjour!\n" );
        }
        ```
    - ### **How to inject a DLL with LoadLibrary**
        Just provide a valid path of the dll, which you want to inject into the target process, to the function `inject_dll_load_library`.

        ```cpp
        void demo_loadlib()
        {
            const auto proc = std::make_unique< process >();

            if (!proc->setup_process(L"dummy.exe"))
                return;

            std::println("[+] pid: {}\n", proc->get_process_id());

            if (!proc->inject_dll_load_library("C:\\Users\\craaaaaaaaaaaaagson\\Desktop\\test.dll"))
                return;

            std::println("[+] Succesfully injected dll into process");
        }
        ```
    - ### **How to get a pointer to the DOS header of an image**
        ```cpp
        void demo_dos_header()
        {
            const auto proc = std::make_unique< process >();

            if (!proc->setup_process(L"dummy.exe"))
                return;

            std::println("[+] pid: {}\n", proc->get_process_id());

            const auto img_ptr = proc->get_image_ptr_by_name(L"dummy.exe");

            if (!img_ptr)
                return;

            const auto dos_ptr = img_ptr->get_dos_header_ptr();

            if (!dos_ptr)
                return;

            std::println("[+] magic: {:04X}", dos_ptr->e_magic);
        }
        ```
    - ### **How to get a pointer to the NT headers of an image**
    ```cpp
    void demo_nt_headers()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"dummy.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto img_ptr = proc->get_image_ptr_by_name(L"dummy.exe");

        if (!img_ptr)
            return;

        const auto nt_ptr = img_ptr->get_nt_headers_ptr();

        if (!nt_ptr)
            return;

        std::println("[+] machine {:04X}", nt_ptr->FileHeader.Machine);
    }
    ```
    - ### **How to get a pointer to the import descriptor of an image**
    ```cpp
    void demo_import_descriptor()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"dummy.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto img_ptr = proc->get_image_ptr_by_name(L"dummy.exe");

        if (!img_ptr)
            return;

        const auto id = img_ptr->get_import_descriptor();

        if (!id)
            return;

        std::println("[+] import descriptor ptr: 0x{:08X}", reinterpret_cast< std::uintptr_t >( id ) );
    }
    ```
    - ### **How to parse/retrieve all imports of an image**
    For this case you can use the function `get_imports` of either `image_x64` or `image_x86`.
    It will return a `std::vector< std::tuple< std::string, std::string, std::uintptr_t > >`, which basically is a big list of all imports in the Import Address Table (IAT) of an image.
    The first string is the name of the image, from where the function is imported.
    The second string is the name of the function, which is imported.
    The last element of the tuple is pointer to the imported function, which can be used for IAT hooking etc.
    This function works for both `image_x64` and `image_x86`.

    Here is an example of how you can print out all entries from the IAT in a easy way:
    ```cpp
    void demo_image_iat()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"dummy.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto img_ptr = proc->get_image_ptr_by_name(L"dummy.exe");

        if (!img_ptr)
            return;

        const auto imports = img_ptr->get_imports();

        if (imports.empty())
            return;

        for (const auto& [img, fn_name, fn_ptr] : imports)
            std::println("[#] {}::{} -> 0x{:08X}", img, fn_name, fn_ptr);

        std::println("\n[+] Parsed {} imports", imports.size());
    }
    ```
    - ### **How to get a pointer to the Process Environment Block (PEB) of the target process**
    ```cpp
    void lab()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"dummy.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto peb_ptr = proc->get_peb_ptr();

        if (!peb_ptr)
            return;

        std::println("[+] peb: 0x{:X}", peb_ptr);
    }
    ```
    - ### **How to retreive the PEB from the target process**
    ```cpp
    void lab()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"dummy.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto peb = proc->get_peb();

        std::println("[+] PEB::Ldr -> 0x{:X}", reinterpret_cast< std::uintptr_t >( peb.Ldr ) );
    }
    ```
    - ### **How to retreive the ImageBaseAddress of the PEB from the target process**
    ```cpp
    void lab()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"firefox.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto peb_image_addr = proc->get_peb_image_base_address();

        std::println( "[+] PEB::ImageBaseAddress -> 0x{:X}", peb_image_addr );
    }
    ```
    - ### **How to retreive all modules inside InMemoryOrderModuleList of the PEB from the target process**
    ```cpp
    void lab()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"dummy.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto modules = proc->get_modules_from_peb();

        for (const auto& [module_name, module_base, module_size] : modules)
            std::println("{} -> 0x{:X} ({} bytes)", module_name, module_base, module_size);
    }
    ```
    - ### **How to search for specific imports inside all modules from InMemoryOrderModuleList of the PEB from the target process**
    ```cpp
    void lab()
    {
        const auto proc = std::make_unique< process >();

        if (!proc->setup_process(L"firefox.exe"))
            return;

        std::println("[+] pid: {}\n", proc->get_process_id());

        const auto modules = proc->get_modules_from_peb();

        for (const auto& [module_name, module_base, module_size] : modules)
        {
            std::println("{} -> 0x{:X} ({} bytes)", module_name, module_base, module_size);

            const auto temp = std::make_unique< image_x64 >(module_base, module_size);
            
            const auto module_name_w = std::wstring(module_name.begin(), module_name.end());

            if (!ReadProcessMemory(
                proc->get_process_handle(), 
                reinterpret_cast< LPCVOID >( module_base ), 
                temp->get_byte_vector_ptr()->data(), 
                module_size, nullptr
            ))
                continue;

            const auto imports = temp->get_imports();

            if (imports.empty())
                continue;

            std::ranges::for_each( imports, [&](const auto& tup)
                {
                    std::apply( [](const auto& image_name, const auto& fn_name, const auto& fn_ptr) 
                        {
                            // replace Nt here with the substring you want to filter for in the imports of the modules
                            if (fn_name.contains("Nt"))
                                std::println("{}::{} -> 0x{:X}", image_name, fn_name, fn_ptr);
                        }, tup);
                }
                );

            std::println("");
        }
    }
    ```
    - ### **Inter-Process Communication (IPC)**
        - ### **How to setup named shared memory x86**
            First you need a object name for the Named Shared Memory, if you want to use a "Global\\XXX" name: **Make sure to have the proper rights on both sides (cheat and game process)**, otherwise the function will **fail**!
            After that you need to know the size of the buffer, which will be split into HIGH- and LOW side. Both sides are DWORDs.
            First the function will check if the object name is empty or if already an instance with the same object name exists, if so the function returns **false**.
            After that these steps will be done:
            1. Get the image Base of Kernel32
            2. Get the addresses of CreateFileMappingA and MapViewOfFile
            3. Allocate a small buffer inside the target process for the return values of the called functions inside the target process and the object name string
            4. Write the object name string into the allocated memory
            5. Prepare now the shellcode with it's data (addresses and parameters)
            6. Execute now the shellcode inside the target process
            7. Read now the return values from the target process called functions (object handle and view address)
            8. Open the file mapping handle with OpenFileMappingA
            9. Map now the view of the mapped file into the address space of the callee process
            10. Create the shared memory instance
            11. Push it to the std::vector inside process
            12. Free the allocated memory page for the return values and the object name string

            So tl;dr here is some sample code for you, how to setup a shared memory instance:
            ```cpp
            printf( "[#] Creating a shared memory instance.." );
			if ( Globals::g_pProcess->create_shared_memory_instance_x86( "Local\\osmium_sh", 0, 0x100 ) )
			{
				printf( "success!\n" );

				const auto sh_inst = Globals::g_pProcess->get_shared_memory_instance_by_object_name( "Local\\osmium_sh" );

				const auto sh_ptr = sh_inst->get_buffer_ptr();

				printf( "[+] Wrote to %p (callee), remote buffer @ %p\n", sh_ptr, sh_inst->get_process_buffer_ptr() );
            }
            else
                printf( "failed!\n" );
            ```

            So what happens here is a Named Shared Memory with the object name **Local\\osmium_sh** and a total buffer size of **0x100** will be created. If it was successfully created, a pointer to the freshly created shared memory instance will be retrieved and also a pointer to the shared memory buffer from the callee process.
        - ### **How to read and write from/to the shared memory x86**
            I implemented some methods for reading or writing but you can do it easily on your own, if you want.
            Just retrieve the pointer to the buffer from the callee process via **get_buffer_ptr()** from **shared_memory_instance** and treat it like a normal pointer. I'll show both ways now in this sample code:
            ```cpp
            printf( "[#] Creating a shared memory instance.." );
			if ( Globals::g_pProcess->create_shared_memory_instance_x86( "Local\\osmium_sh", 0, 0x100 ) )
			{
				printf( "success!\n" );

				const auto sh_inst = Globals::g_pProcess->get_shared_memory_instance_by_object_name( "Local\\osmium_sh" );

				const auto sh_ptr = sh_inst->get_buffer_ptr();

				printf( "[+] Wrote to %p (callee), remote buffer @ %p\n", sh_ptr, sh_inst->get_process_buffer_ptr() );

                sh_inst->write_string( "iloveasm" );

				sh_inst->write< float >( 1337.123f, 0x20 );

				*reinterpret_cast< size_t* >( sh_ptr + 0x42 ) = 0x13376077;

				for( auto i = 0; i < 9; i++ )
					printf( "[+] Read from 0x%d (%08X): %c\n", i, sh_ptr + i, sh_inst->read< const char >( sh_ptr + i ) );

				printf( "[+] Read from 0x20: %.3f\n", sh_inst->read< float >( sh_ptr + 0x20 ) );

				printf( "[+] Read from 0x42: %04X\n", *reinterpret_cast< size_t* >( sh_ptr + 0x42 ) );
            }
            else
                printf( "failed!\n" );
            ```
            This snippet will produce the following output: ![sh-rw-test](res/sh-rw-test.png)
        - ### **How to clear the shared memory x86**
            If you want to zero the whole shared memory buffer, just use **clear_memory()** from **shared_memory_instance**.
            Or you can just call memset, because the function **clear_memory** just does it like this.
            ```cpp
            void clear_memory() const
            {
                memset( this->m_pBuffer, 0, this->m_iBufferSize );
            }
            ```
        - ### **How to remove named shared memory x86**
            If you want to remove the Named Shared Memory, just call **destroy_shared_memory_instance_x86** from **process**.
            This will unmap, free, remove and clean everything up for you. 
            -   Unmap view of mapped file
            -   Free's allocated memory pages
            -   Removes **shared_memory_instance** from instances vector inside **process**.
            ```cpp
            printf( "[#] Destroying now the shared memory instance.." );

            if ( Globals::g_pProcess->destroy_shared_memory_instance_x86( "Local\\osmium_sh" ) )
                printf( "success!\n" );
            else
                printf( "failed!\n" );
            ```
- ### **RegisterDumper x86**
    First of all I want to explain my motivation and real use case for this feature here.
    As this Framework is designed for external cheats some things from internal cheats aren't available easily, like e.g. function hooking and reading/writing the registers at the specific point inside the function.
    Since today I came across multiple occasions where I didn't find a static pointer for a list but a function where all elements from the list where processed.
    As I got no static pointer to that list, I could not simply sigscan, read and parse it like a normal external would do. 
    And I also could not just hook the function and grab the elements by reading out the used registers like in a internal cheat.
    Most of the time I found a workaround which allowed me to circumvent reading the used registers where the elements were stored in but there were also few times where no I couldn't find a workaround and I won't work out.

    **Well, what can I imagine now under the term "RegisterDumper x86"?**
    Obviously it's for x86 only, at the time. 
    Also this is feature which will allow you to access all GPRs from a point in memory.
    This works by utilizing a shared memory feature from this framework where all register content will be written to.
    Also a 5 byte hook is placed to the given address which redirects the code flow to a little shellcode which writes the registers content into the shared memory page, which e.g. looks like this:
    ![regdumper-dumper-sh](res/regdumper-dump-sh.png)

    After writing the registers content to the shared memory page the overwritten instructions will be executed and then a jump after the placed hook follows, so make sure to not overwrite instructions which depend on a correct callstack etc..

    There is an ```std::vector< std::unique_ptr< registercontext > >``` inside of the ```process``` class, which holds all created registercontext's. 
    
    **Now what is a registercontext?**
    This might be a bit confusing right now because I talked only about dumper and not context's but try to think about it like the dumper is the abstract design construct I had in mind, which is integrated into the ``` process``` class by different functions for creating, starting, stopping, destroying or the vector which holds all registercontext's. 
    A registercontext is one smaller part of the dumper, it's purpose is holding relevant data for the accessing/reading of the registers content. I can only suggest you to have a look at it's implementation inside ``` registercontext.hpp```.
    Also a registercontext holds a pointer to the shared memory instance which belongs to it, this is so because otherwise it could not map the class for the registers onto the pointer for the shared memory page where the registers content is.

    To make this more clear, here is the implementation of the ```registercontext::get_registers_data()``` function:
    ```cpp
    [[nodiscard]] inline auto get_registers_data() const noexcept
	{
		return static_cast< register_data* >( this->m_pShInstance->get_buffer_ptr() );
	}
    ```
    register_data is also defined in the same header file as registercontext, so you may have a look at it.
    Essentially it's just a class which holds unions and variables for the registers. 
    For the moment only the GPRs like e.g. EAX, ECX, ESP, ESI are supported but I plan to add support for the FPU registers also.

    Finally I want to say something about the registercontext's active status.
    I want you to understand that just because you call e.g. ```registercontext::enable_dumper()``` will not automatically start the dumping process of the register. 
    Please use ```process::start_register_dumper_x86``` or ```process::stop_register_dumper_x86``` functions to start or stop the dumping.
    The difference is that when you only set the active boolean from registercontext to true there is no hook applied or otherwise no hook removed and original bytes restored, it's mainly for internal purposes that the ```process``` class knows if an registercontext should be dumped or not.

    I'm sure this current state of my approach is a bit more complicated than it needed to be but just play with it yourself and get familiar with it.
    Also I want to improve the logic and simplicity in the future.

    - ### **How to create a register dumper x86**
    The following things will happen here:
    1. Create a shared memory instance with a custom object name for the specified adress where the register will be dumped.
    2. Preparing the shellcode which will dump the registers content and write it to the shared memory page.
    3. Create the hook which will redirect to the dump shellcode and jump back right after the placed hook.
    4. Create an instance of a registercontext with the given values and enable the dumping for it.
    5. Append the freshly created instance to the internal vector of the ```process``` class.
    
    ```cpp
    // (Assume g_pProcess is a instance of process)
	if( Globals::g_pProcess->create_register_dumper_x86( 0xDEADAFFE ) )
		printf( "[+] Registercontext was successfully created!\n" );
	else
		printf( "[!] Could not create the registercontext!\n" );
    ```

    - ### **How to start a register dumper x86**
    Here it will just hook the address again and enable the dumping, the shared memory still exists as the registercontext was not destroyed.

    ```cpp
    // (Assume g_pProcess is a instance of process)
    if( Globals::g_pProcess->start_register_dumper_x86( 0xDEADAFFE ) )
		printf( "[+] Dumping of the register is starting!\n" );
	else
		printf( "[!] Could not start the dumping of the registers!\n" );
    ```
    - ### **How to stop a register dumper x86**
    Here it will destroy the placed hook, restore it's original bytes and disable the dumping for the registercontext.

     ```cpp
    // (Assume g_pProcess is a instance of process)
    if( Globals::g_pProcess->stop_register_dumper_x86( 0xDEADAFFE ) )
		printf( "[+] Dumping of the register is stopped!\n" );
	else
		printf( "[!] Could not stop the dumping of the registers!\n" );
    ```

    - ### **How to destroy a register dumper x86**
    Here the following things will happen:
    1. If the registercontext, which the given address belongs to, is still active stop it.
    2. Destroy the placed hook and restore it's original bytes.
    3. Destroy the shared memory instance.
    4. Erase the registercontext element from the internal vector inside ```process``` class.
    
    ```cpp
    // (Assume g_pProcess is a instance of process)
	if( Globals::g_pProcess->destroy_register_dumper_x86( 0xDEADAFFE ) )
		printf( "[+] Registercontext was successfully destroyed!\n" );
	else
		printf( "[!] Could not destroy the registercontext!\n" );
    ```
    - ### **How to check if a registercontext is active or not**
     ```cpp
    // (Assume g_pProcess is a instance of process)
    if( Globals::g_pProcess->is_active_register_dumper_x86( 0xDEADAFFE ) )
		printf( "[+] Dumping of the registers is active!\n" );
	else
		printf( "[!] Dumping of the registers is not active!\n" );
    ```

    - ### **How to retrieve a pointer to a registercontext with the dumped address**
    Make sure to **always** validate the pointer you retrieve!

    ```cpp
    // (Assume g_pProcess is a instance of process)
    const auto ptr = Globals::g_pProcess->get_register_dumper_x86_ptr( 0xDEADAFFE );

    if( ptr != nullptr )
		printf( "[+] Registercontext pointer is valid!\n" );
	else
		printf( "[!] Registercontext is not valid!\n" );
    ```

    - ### **How to access the registers data from the registercontext**
     Make sure to **always** validate the pointer you retrieve!
    ```cpp
    // (Assume g_pProcess is a instance of process)

    const auto reg_data = Globals::g_pProcess->get_data_from_registers_x86( 0xDEADAFFE );

	const auto is_active = Globals::g_pProcess->is_active_register_dumper_x86( 0xDEADAFFE );

	if( reg_data != nullptr && is_active )
	{
		printf("[+] Dumped Registers from: 0x%08X\n", 0xDEADAFFE);

		printf("EAX -> 0x%08X\n", reg_data->EAX.eax);
		printf("\tAX -> 0x%04X\n", reg_data->EAX.ax);
		printf("\tAH, AL -> 0x%02X, 0x%02X\n", reg_data->EAX.a[0], reg_data->EAX.a[1]);

		printf("EBX -> 0x%08X\n", reg_data->EBX.ebx);
		printf("\tBX -> 0x%04X\n", reg_data->EBX.bx);
		printf("\tBH, BL -> 0x%02X, 0x%02X\n", reg_data->EBX.b[0], reg_data->EBX.b[1]);

		printf("ECX -> 0x%08X\n", reg_data->ECX.ecx);
		printf("\tCX -> 0x%04X\n", reg_data->ECX.cx);
		printf("\tCH, CL -> 0x%02X, 0x%02X\n", reg_data->ECX.c[0], reg_data->ECX.c[1]);

		printf("EDX -> 0x%08X\n", reg_data->EDX.edx);
		printf("\tDX -> 0x%04X\n", reg_data->EDX.dx);
		printf("\tDH, DL -> 0x%02X, 0x%02X\n", reg_data->EDX.d[0], reg_data->EDX.d[1]);

		printf("ESP -> 0x%08X\n", reg_data->ESP.esp);
		printf("\tSP -> 0x%04X\n", reg_data->ESP.sp);

		printf("EBP -> 0x%08X\n", reg_data->EBP.ebp);
		printf("\tBP -> 0x%04X\n", reg_data->EBP.bp);

		printf("ESI -> 0x%08X\n", reg_data->ESI.esi);
		printf("\tSI -> 0x%04X\n", reg_data->ESI.si);

		printf("EDI -> 0x%08X\n", reg_data->EDI.edi);
		printf("\tDI -> 0x%04X\n", reg_data->EDI.di);
    }
    ```
    Which would result in something like this:

    ![regdumper-regdata](res/regdumper-regdata.png)

- ### **Basic overlay implementation**
    - ### **How to setup your overlay**
        You can either initialize your overlay by using the window title of the target process or a window handle.
        Make sure to implement the `overlay` interface correctly, as I did in the `test_overlay` class because you need to define the render logic.
        
        But I got you, just have a look at [How to run your overlay](#how-to-run-your-overlay).
        
        The initialization function will directly create a window, the directx object, device and all of the other needed stuff for having some painty fun.
        The default class name of the window is `OVCRG` because OV = overlay and CRG = cragson, you know some pretty 300iq stuff right here (fml).

        Here you can have a look at it:
        ```cpp
        void init_ofalai()
        {
            const auto dx9_overlay = std::make_unique< test_overlay >();

            if( dx9_overlay->initialize( "Plants vs. Monkeys" ) )
                printf( "[!] Created the overlay!\n" );
            else
                printf( "[!] Could not create the overlay!\n" );

            const auto window_handle = FindWindowA( 0, "Plants vs. Monkeys" );

            if( !window_handle )
                return;

            if( dx9_overlay->initialize( window_handle ) )
                printf( "[!] Created the overlay!\n" );
            else
                printf( "[!] Could not create the overlay!\n" );
        }
        ```
    - ### **How to draw a string**
        You can use the `draw_string` function inside of your implementation of the `overlay` interface for it.
        You need to call this function inside the render loop of your `overlay` implementation.

        Here is a small example:
        ```cpp
        void draw_watermark()
        {   
            // yes yes yes I know it's local but just take it as a global overlay instance pointer 
            init_ofalai();

            dx9_overlay->draw_string( 
                "my fancy watermark right here",        // the string to be drawn
                100,                                    // x coordinate where the string should be drawn
                50,                                     // y coordinate where the string should be drawn
                0,                                      // red color (0-255)
                255,                                    // green color (0-255)
                150                                     // blue color (0-255)
            );

            dx9_overlay->draw_string( 
                "fancy watermark but now half transparent",     // the string to be drawn
                100,                                            // x coordinate where the string should be drawn
                50,                                             // y coordinate where the string should be drawn
                0,                                              // red color (0-255)
                255,                                            // green color (0-255)
                150,                                            // blue color (0-255)
                122                                             // alpha (0-255)
            );
        }
        ```
    - ### **How to draw a line**
        You can use the `draw_line` function inside of your implementation of the `overlay` interface for it.
        You need to call this function inside the render loop of your `overlay` implementation.

        Here is a small example:
        ```cpp
        void draw_a_line()
        {   
            // yes yes yes I know it's local but just take it as a global overlay instance pointer 
            init_ofalai();

             dx9_overlay->draw_line( 
                400,                    // start x coordinate
                200,                    // start y coordinate
                450,                    // end x coordinate
                250,                    // end y coordinate
                0,                      // red color (0-255)
                0,                      // green color (0-255)
                255,                    // blue color (0-255)
            );

            dx9_overlay->draw_line( 
                400,                    // start x coordinate
                200,                    // start y coordinate
                450,                    // end x coordinate
                250,                    // end y coordinate
                0,                      // red color (0-255)
                0,                      // green color (0-255)
                255,                    // blue color (0-255)
                2                       // width of the line (optional), default is 1
            );
        }
        ```
    - ### **How to draw a rect**
        You can use the `draw_rect` function inside of your implementation of the `overlay` interface for it.
        You need to call this function inside the render loop of your `overlay` implementation.

        Here is a small example:
        ```cpp
        void draw_a_rect()
        {   
            // yes yes yes I know it's local but just take it as a global overlay instance pointer 
            init_ofalai();

            dx9_overlay->draw_rect( 
                400,                    // start x coordinate
                200,                    // start y coordinate
                50,                     // width of the rect
                100,                    // height of the rect
                0,                      // red color (0-255)
                0,                      // green color (0-255)
                255                     // blue color (0-255)
            );

            dx9_overlay->draw_rect( 
                400,                    // start x coordinate
                200,                    // start y coordinate
                50,                     // width of the rect
                100,                    // height of the rect
                0,                      // red color (0-255)
                0,                      // green color (0-255)
                255,                    // blue color (0-255)
                2                       // width of the rect (optional), default is 1
            );
        }
        ```
    - ### **How to draw a filled rect**
        You can use the `draw_filled_rect` function inside of your implementation of the `overlay` interface for it.
        You need to call this function inside the render loop of your `overlay` implementation.

        Here is a small example:
        ```cpp
        void draw_a_filled_rect()
        {   
            // yes yes yes I know it's local but just take it as a global overlay instance pointer 
            init_ofalai();

            dx9_overlay->draw_filled_rect( 
                400,                    // start x coordinate
                200,                    // start y coordinate
                50,                     // width of the rect
                100,                    // height of the rect
                0,                      // red color (0-255)
                0,                      // green color (0-255)
                255                     // blue color (0-255)
            );
        }
        ```
    - ### **How to register a new font**
        If you want to register a new font, you should use the `register_font` function inside the `overlay` interface. It will return true or false, if the function succeeds/ fails.

        Here is a small example:
        ```cpp
        void register_a_new_font()
        {
            // yes yes yes I know it's local but just take it as a global overlay instance pointer 
            init_ofalai();

            const auto result = dx9_overlay->register_font(
                "Arial",                // font name
                50,                     // height
                50,                     // width
                10                      // weight
            );

            if( result )
                printf( "[!] Registered font!\n" );
            else
                printf( "[!] Could not register the font!\n" );
        }
        ```
    - ### **How to change the current font**
        If you want to switch the current used font, you need to use this function.
        Also after you registered a new font and want to use it, you need to use this function.

        You can switch the current font by using the `set_used_font` function inside the `overlay` interface.
        Important is to know that the font, you want to switch to, must be already registered before with `register_font`.

        If the function could set the new current font, it will return true otherwise it will return false.

        Here is a small example for you:
        ```cpp
        void change_da_current_font()
        {
            // yes yes yes I know it's local but just take it as a global overlay instance pointer 
            init_ofalai();

            if( dx9_overlay->set_used_font( "Arial" ) )
                printf( "[!] The current font is now Arial!\n" );
            else
                printf( "[!] Could not change the current font to Arial!\n" );
        }
        ```
    - ### **How to run your overlay**
        This is the same thing like above in [How to run your cheat](#how-to-run-your-cheat).
        It depends on your own logic and needs.

        I implemented for myself a very basic overlay logic, which works for me really good.
        What I thought of that I only want to render if the current foreground window is the target window and if this condition is true, I want to iterate over every feature, check if it should be drawn and if so I want to call the `on_render` function from it, if it's active.

        You can see this logic here:
        ```cpp
        void test_overlay::render()
        {
            this->m_Device->Clear( NULL, nullptr, D3DCLEAR_TARGET, D3DCOLOR_ARGB( 0, 0, 0, 0 ), 1.0f, NULL );
            this->m_Device->BeginScene();

            const auto fg_hwnd = GetForegroundWindow();

            if( fg_hwnd == this->m_TargetWindow )
            {
                const auto features = Modules::g_pCheat->get_features_as_ptr();

                for( auto it = features->begin(); it != features->end(); ++it )
                {
                    const auto current_feature = it->get();

                    if( !current_feature->should_be_drawn() )
                        continue;

                    if( current_feature->is_active() )
                        current_feature->on_render();
                }
            }

            this->m_Device->EndScene();
            this->m_Device->PresentEx( nullptr, nullptr, nullptr, nullptr, NULL );
            
        }
        ```

```

`Testing/test_cheat.cpp`:

```cpp
#include "test_cheat.hpp"

#include <Windows.h>

bool test_cheat::setup_features()
{
	return false;
}

bool test_cheat::setup_offsets()
{
	return false;
}

void test_cheat::run()
{
	for (const auto& feature : this->m_features)
	{
		// before tick'ing the feature, check first if the state will eventually change
		if ( GetAsyncKeyState( feature->get_virtual_key_code() ) & 0x8000 )
			feature->toggle();

		// let the feature tick() when active
		if (feature->is_active())
			feature->tick();
	}
}

void test_cheat::shutdown()
{
}

void test_cheat::print_features()
{
}

void test_cheat::print_offsets()
{
}

```

`Testing/test_cheat.hpp`:

```hpp
#pragma once

#include "../Cheat/cheat.hpp"

class test_cheat : public cheat
{
public:
	bool setup_features() override;

	bool setup_offsets() override;

	void run() override;

	void shutdown() override;

	void print_features() override;

	void print_offsets() override;
};
```

`Testing/test_overlay.cpp`:

```cpp
#include "test_overlay.hpp"

#include "../Includings/modules.hpp"

void test_overlay::render()
{
	this->m_Device->Clear( NULL, nullptr, D3DCLEAR_TARGET, D3DCOLOR_ARGB( 0, 0, 0, 0 ), 1.0f, NULL );
	this->m_Device->BeginScene();

	const auto fg_hwnd = GetForegroundWindow();

	if( fg_hwnd == this->m_TargetWindow )
	{
		const auto features = Modules::g_pCheat->get_features_as_ptr();

		for( auto it = features->begin(); it != features->end(); ++it )
		{
			const auto current_feature = it->get();

			if( !current_feature->should_be_drawn() )
				continue;

			if( current_feature->is_active() )
				current_feature->on_render();
		}
	}

	this->m_Device->EndScene();
	this->m_Device->PresentEx( nullptr, nullptr, nullptr, nullptr, NULL );
	
}

```

`Testing/test_overlay.hpp`:

```hpp
#pragma once

#include "../Overlay/overlay.hpp"

class test_overlay : public overlay
{

public:

	void render() override;
};
```